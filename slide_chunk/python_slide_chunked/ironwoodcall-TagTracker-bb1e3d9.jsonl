{"filename": "tt_util.py", "chunked_list": ["\"\"\"TagTracker by Julias Hocking.\n\nUtility functions & constants for TagTracker suite.\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.", "    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.", "    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"\n\nimport os\nimport sys\nimport datetime\nimport re\n\n# This is for type hints instead of (eg) int|str", "\n# This is for type hints instead of (eg) int|str\nfrom typing import Union, Tuple\n\nfrom tt_globals import *  # pylint:disable=unused-wildcard-import,wildcard-import\nfrom tt_time import VTime\nfrom tt_tag import TagID\n\n\ndef squawk(whatever: str = \"\") -> None:\n    \"\"\"Print whatever with file & linenumber in front of it.\n\n    This is intended for programming errors not prettiness.\n\n    Additional caller info:\n        caller_path = f.f_globals['__file__'] (though fails if squawk()\n            called from interpreter, as __file__ not in globals at that point)\n        caller_file = os.path.basename(caller_path)\n    \"\"\"\n    f = sys._getframe(1)  # pylint:disable=protected-access\n    caller_module = f.f_globals[\"__name__\"]\n    caller_function = f.f_code.co_name\n    caller_line_no = f.f_lineno\n    print(f\"{caller_module}:{caller_function}():{caller_line_no}: {whatever}\")", "\ndef squawk(whatever: str = \"\") -> None:\n    \"\"\"Print whatever with file & linenumber in front of it.\n\n    This is intended for programming errors not prettiness.\n\n    Additional caller info:\n        caller_path = f.f_globals['__file__'] (though fails if squawk()\n            called from interpreter, as __file__ not in globals at that point)\n        caller_file = os.path.basename(caller_path)\n    \"\"\"\n    f = sys._getframe(1)  # pylint:disable=protected-access\n    caller_module = f.f_globals[\"__name__\"]\n    caller_function = f.f_code.co_name\n    caller_line_no = f.f_lineno\n    print(f\"{caller_module}:{caller_function}():{caller_line_no}: {whatever}\")", "\n\ndef decomment(string: str) -> str:\n    \"\"\"Remove any part of the string that starts with '#'.\"\"\"\n    r = re.match(r\"^([^#]*) *#\", string)\n    if r:\n        return r.group(1)\n    return string\n\n\ndef get_date(long: bool = False) -> str:\n    \"\"\"Return current date as string YYYY-MM-DD or a longer str if long=True.\"\"\"\n    # FIXME: superseded by date_str()\n    return date_str(\"today\", long_date=long)", "\n\ndef get_date(long: bool = False) -> str:\n    \"\"\"Return current date as string YYYY-MM-DD or a longer str if long=True.\"\"\"\n    # FIXME: superseded by date_str()\n    return date_str(\"today\", long_date=long)\n    # if long:\n    #    return datetime.datetime.today().strftime(\"%A %B %d (%Y-%m-%d)\")\n    # return datetime.datetime.today().strftime(\"%Y-%m-%d\")\n", "    # return datetime.datetime.today().strftime(\"%Y-%m-%d\")\n\n\ndef date_str(\n    maybe_date: str,\n    dow_str_len: int = None,\n    long_date: bool = False,\n    strict: bool = False,\n) -> str:\n    \"\"\"Return maybe_date in the form of YYYY-MM-DD (or \"\").\n\n    Optional flags will return it in a variety of str or int\n    formats:\n        dow_str_len: if set, returns the date as day of week\n            of given length (up to day of week's full length)\n        long_date: if True, returns str as a long date\n        strict: if set, only accepts exact \"YYYY-MM-DD\";\n            otherwise accepts \"now\", \"today\" \"tomorrow\" and\n            \"yesterday\"; strips whitespace; and accepts\n            \"\" or \"/\" as separators\n\n    \"\"\"\n    # FIXME: replace get_date() with a call to this\n    if (\n        not maybe_date\n        or not isinstance(maybe_date, str)\n        or maybe_date.isspace()\n    ):\n        return \"\"\n    thisday = None\n    if not strict:\n        maybe_date = maybe_date.lower().strip()\n        if maybe_date in [\"now\", \"today\"]:\n            thisday = datetime.datetime.today()\n        elif maybe_date == \"yesterday\":\n            thisday = datetime.datetime.today() - datetime.timedelta(1)\n        elif maybe_date == \"tomorrow\":\n            thisday = datetime.datetime.today() + datetime.timedelta(1)\n        else:\n            # Allow YYYYMMDD or YYYY/MM/DD\n            r = re.fullmatch(r\"(\\d\\d\\d\\d)[-/]?(\\d\\d)[-/]?(\\d\\d)\", maybe_date)\n            if not r:\n                return \"\"\n            try:\n                thisday = datetime.datetime.strptime(\n                    f\"{r.group(1)}-{r.group(2)}-{r.group(3)}\", \"%Y-%m-%d\"\n                )\n            except ValueError:\n                return \"\"\n    if not thisday:\n        try:\n            thisday = datetime.datetime.strptime(maybe_date, \"%Y-%m-%d\")\n        except ValueError:\n            return \"\"\n    if not thisday:\n        return \"\"\n    # Now have thisday (a datetime object), convert to str\n    # Format as a day of the week?\n    if dow_str_len:\n        return thisday.strftime(\"%A\")[0:dow_str_len]\n    if long_date:\n        return thisday.strftime(\"%A %B %d (%Y-%m-%d)\")\n    return thisday.strftime(\"%Y-%m-%d\")", "\n\ndef dow_int(date_or_dayname: str) -> int:\n    \"\"\"Get ISO day of week from a date or weekday name.\"\"\"\n    date = date_str(date_or_dayname)\n    if date:\n        d = datetime.datetime.strptime(date, \"%Y-%m-%d\")\n        return int(d.strftime(\"%u\"))\n    # Try to match to a dow.\n    dow_ints = {\n        1: [\"m\", \"mo\", \"mon\", \"monday\"],\n        2: [\"tu\", \"tue\", \"tues\", \"tuesday\"],\n        3: [\"w\", \"we\", \"wed\", \"wednesday\"],\n        4: [\"th\", \"thu\", \"thurs\", \"thursday\"],\n        5: [\"f\", \"fr\", \"fri\", \"friday\"],\n        6: [\"sa\", \"sat\", \"saturday\"],\n        7: [\"su\", \"sun\", \"sunday\"],\n    }\n    for num, name_list in dow_ints.items():\n        if date_or_dayname.strip().lower() in name_list:\n            return num\n    return None", "\n\ndef dow_str(iso_dow: int, dow_str_len: int = 0) -> str:\n    \"\"\"Return int ISO day of week as a str of length dow_str_len.\n\n    If dow_len is not specified then returns whole dow name.\n    \"\"\"\n    iso_dow = str(iso_dow)\n    dow_str_len = dow_str_len if dow_str_len else 99\n    d = datetime.datetime.strptime(f\"2023-1-{iso_dow}\", \"%Y-%W-%u\")\n    return date_str(d.strftime(\"%Y-%m-%d\"), dow_str_len=dow_str_len)", "\n\ndef get_time() -> VTime:\n    \"\"\"Return current time as string: HH:MM.\"\"\"\n    # FIXME: get_time() deprecated, use VTime(\"now\") instead\n    return VTime(datetime.datetime.today().strftime(\"%H:%M\"))\n\n\ndef time_int(maybe_time: Union[str, int, float, None]) -> Union[int, None]:\n    \"\"\"Return maybe_time (str or int) to number of minutes since midnight or \"\".\n\n        Input can be int (minutes since midnight) or a string\n    that might be a time in HH:MM.\n\n    Return is either None (doesn't look like a valid time) or\n    will be an integer between 0 and 1440.\n\n    Warning: edge case: if given \"00:00\" or 0, this will return 0,\n    which can test as False in a boolean argument.  In cases where 0\n    might be a legitimate time, test for the type of the return or\n    test whether \"is None\".\n    \"\"\"\n    # FIXME: time_int() deprecated, use VTime() instead\n    if isinstance(maybe_time, float):\n        maybe_time = round(maybe_time)\n    if isinstance(maybe_time, str):\n        r = re.match(r\"^ *([012]*[0-9]):?([0-5][0-9]) *$\", maybe_time)\n        if not (r):\n            return None\n        h = int(r.group(1))\n        m = int(r.group(2))\n        # Test for an impossible time\n        if h > 24 or m > 59 or (h * 60 + m) > 1440:\n            return None\n        return h * 60 + m\n    if isinstance(maybe_time, int):\n        # Test for impossible time.\n        if not (0 <= maybe_time <= 1440):\n            return None\n        return maybe_time\n    if maybe_time is None:\n        return None\n    # Not an int, not a str, not None.\n    squawk(f\"PROGRAM ERROR: called time_int({maybe_time=})\")\n    return None", "def time_int(maybe_time: Union[str, int, float, None]) -> Union[int, None]:\n    \"\"\"Return maybe_time (str or int) to number of minutes since midnight or \"\".\n\n        Input can be int (minutes since midnight) or a string\n    that might be a time in HH:MM.\n\n    Return is either None (doesn't look like a valid time) or\n    will be an integer between 0 and 1440.\n\n    Warning: edge case: if given \"00:00\" or 0, this will return 0,\n    which can test as False in a boolean argument.  In cases where 0\n    might be a legitimate time, test for the type of the return or\n    test whether \"is None\".\n    \"\"\"\n    # FIXME: time_int() deprecated, use VTime() instead\n    if isinstance(maybe_time, float):\n        maybe_time = round(maybe_time)\n    if isinstance(maybe_time, str):\n        r = re.match(r\"^ *([012]*[0-9]):?([0-5][0-9]) *$\", maybe_time)\n        if not (r):\n            return None\n        h = int(r.group(1))\n        m = int(r.group(2))\n        # Test for an impossible time\n        if h > 24 or m > 59 or (h * 60 + m) > 1440:\n            return None\n        return h * 60 + m\n    if isinstance(maybe_time, int):\n        # Test for impossible time.\n        if not (0 <= maybe_time <= 1440):\n            return None\n        return maybe_time\n    if maybe_time is None:\n        return None\n    # Not an int, not a str, not None.\n    squawk(f\"PROGRAM ERROR: called time_int({maybe_time=})\")\n    return None", "\n\ndef time_str(\n    maybe_time: Union[int, str, float, None],\n    allow_now: bool = False,\n    default_now: bool = False,\n) -> VTime:\n    \"\"\"Return maybe_time as HH:MM (or \"\").\n\n    Input can be int/float (duration or minutes since midnight),\n    or a string that *might* be a time in [H]H[:]MM.\n\n    Special case: \"now\" will return current time if allowed\n    by flag \"allow_now\".\n\n    If default_now is True, then will return current time when input is blank.\n\n    Return is either \"\" (doesn't look like a valid time) or\n    will be HH:MM, always length 5 (i.e. 09:00 not 9:00)\n    \"\"\"\n    # FIXME: time_str() deprecated, use VTime() object\n    if not maybe_time and default_now:\n        return VTime(\"now\")\n    if isinstance(maybe_time, float):\n        maybe_time = round(maybe_time)\n    if isinstance(maybe_time, str):\n        if maybe_time.lower() == \"now\" and allow_now:\n            return VTime(\"now\")\n        r = re.match(r\"^ *([012]*[0-9]):?([0-5][0-9]) *$\", maybe_time)\n        if not (r):\n            return VTime(\"\")\n        h = int(r.group(1))\n        m = int(r.group(2))\n        # Test for an impossible time\n        if h > 24 or m > 59 or (h * 60 + m) > 1440:\n            return VTime(\"\")\n    elif maybe_time is None:\n        return VTime(\"\")\n    elif not isinstance(maybe_time, int):\n        squawk(f\"PROGRAM ERROR: called time_str({maybe_time=})\")\n        return VTime(\"\")\n    elif isinstance(maybe_time, int):\n        # Test for impossible time.\n        if not (0 <= maybe_time <= 1440):\n            return VTime(\"\")\n        h = maybe_time // 60\n        m = maybe_time % 60\n    # Return 5-digit time string\n    return VTime(f\"{h:02d}:{m:02d}\")", "\n\ndef pretty_time(atime: Union[int, str, float], trim: bool = False) -> str:\n    \"\"\"Replace lead 0 in HH:MM with blank (or remove, if 'trim' ).\"\"\"\n    # FIXME: pretty_time() deprecated; use VTime().tidy or VTime().short\n    atime = time_str(atime)\n    if not atime:\n        return \"\"\n    replace_with = \"\" if trim else \" \"\n    if atime[0] == \"0\":\n        atime = f\"{replace_with}{atime[1:]}\"\n    return atime", "\n\ndef parse_tag(\n    maybe_tag: str, must_be_in=None, uppercase: bool = False\n) -> list[str]:\n    \"\"\"Test maybe_tag as a tag, return it as tag and bits.\n\n    Tests maybe_tag by breaking it down into its constituent parts.\n    If looks like a valid tagname, returns a list of\n        [tag_id, colour, tag_letter, tag_number]\n    If tag is not valid, then the return list is empty []\n\n    If must_be_in is not an empty list (or None) then will check whether\n    this tag is in the list passed in, and if\n    not in the list, will return an empty list.\n\n    If uppercase, this will return the tag & its bits in uppercase;\n    otherwise in lowercase.\n\n    Canonical tag id is a concatenation of\n        tag_colour: 1+ lc letters representing the tag's colour,\n                as defined in COLOUR_LETTERS\n        tag_letter: 1 lc letter, the first character on the tag\n        tag_number: a sequence number, without lead zeroes.\n    \"\"\"\n    # FIXME: parse_tag() is  deprecated, use TagID()\n    maybe_tag = maybe_tag.lower()\n    # Regular expression for parsing tags\n    PARSE_TAG_RE = re.compile(r\"^ *([a-z]+)([a-z])0*([0-9]+) *$\")\n    r = PARSE_TAG_RE.match(maybe_tag)\n    if not bool(r):\n        return []\n\n    tag_colour = r.group(1)\n    tag_letter = r.group(2)\n    tag_colour = tag_colour.upper() if uppercase else tag_colour\n    tag_letter = tag_letter.upper() if uppercase else tag_letter\n    tag_number = r.group(3)\n    tag_id = f\"{tag_colour}{tag_letter}{tag_number}\"\n\n    if must_be_in and tag_id not in must_be_in:\n        return []\n\n    return [tag_id, tag_colour, tag_letter, tag_number]", "\n\ndef fix_tag(\n    maybe_tag: str, must_be_in: list = None, uppercase: bool = False\n) -> str:\n    \"\"\"Turn 'str' into a canonical tag name.\n\n    If must_be_in is exists & not an empty list then, will force\n    this to only allow tags that are in the list.\n\n    If uppercase then returns the tag in uppercase, default is lowercase.\n    \"\"\"\n    # FIXME fix_tag fn is now deprecated, useTagID()\n    bits = parse_tag(maybe_tag, must_be_in=must_be_in, uppercase=uppercase)\n    return bits[0] if bits else \"\"", "\n\ndef taglists_by_prefix(unsorted: tuple[TagID]) -> list[list[TagID]]:\n    \"\"\"Get tags sorted into lists by their prefix.\n\n    Return a list of lists of tags, sorted and de-duped. E.g.\n        taglists_by_prefix(['wa5','be1','be1', 'wa12','wd15','be1','be10','be9'])\n        --> [['be1','be9','be10],['wa5','wa12'],['wd15']]\n\n    Preconditions:\n        - tags are either all uppercase or all lowercase\n        - all tags are syntactically valid\n    \"\"\"\n\n    # Make a dictionary of all tags keyed by their prefixes\n    prefixed_tags = dict(\n        zip([tag.prefix for tag in unsorted], [[] for _ in range(0, 100)])\n    )\n    for tag in unsorted:\n        prefixed_tags[tag.prefix].append(tag)\n    outerlist = []\n    for prefix in sorted(prefixed_tags.keys()):\n        outerlist.append(sorted(prefixed_tags[prefix]))\n    return outerlist", "\n\ndef tagnums_by_prefix(tags: list[TagID]) -> dict[str, list[int]]:\n    \"\"\"Return a dict of tag prefixes with lists of associated tag numbers.\"\"\"\n    prefixes = {}\n    for tag in tags:\n        if tag.prefix not in prefixes:\n            prefixes[tag.prefix] = []\n        prefixes[tag.prefix].append(tag.number)\n    for numbers in prefixes.values():\n        numbers.sort()\n    return prefixes", "\n\ndef splitline(inp: str) -> list[str]:\n    \"\"\"Split input on commas & whitespace into list of non-blank strs.\"\"\"\n    # Start by splitting on commas\n    tokens = inp.split(\",\")\n    # Split on whitespace.  This makes a list of lists.\n    tokens = [item.split() for item in tokens]\n    # Flatten the list of lists into a single list.\n    tokens = [item for sublist in tokens for item in sublist]\n    # Reject any blank members of the list.\n    tokens = [x for x in tokens if x]\n    return tokens", "\n\ndef get_version() -> str:\n    \"\"\"Return system version number from changelog.txt.\n\n    If it looks like a git repo, will also try to include a ref from that.\n    \"\"\"\n    version_str = \"\"\n    changelog = \"changelog.txt\"\n    if os.path.exists(changelog):\n        # Read startup header from changelog.\n        with open(changelog, \"r\", encoding=\"utf-8\") as f:\n            for line in f:\n                r = re.match(r\"^ *([0-9]+\\.[0-9\\.]+\\.[0-9]+): *$\", line)\n                if r:\n                    version_str = r.group(1)\n                    break\n\n    # Git ref\n    git_head = os.path.join(\".git\", \"HEAD\")\n    if not os.path.exists(git_head):\n        return version_str\n    # .git/HEAD points to the file that contains the version\n    with open(git_head, \"r\", encoding=\"utf-8\") as f:\n        ref_path = \"\"\n        for line in f:\n            r = re.match(r\"^ref: *(refs.*)\", line)\n            if r:\n                ref_path = r.group(1)\n        if not ref_path:\n            return version_str\n    ref_full_path = os.path.join(\".git\", ref_path)\n    if not os.path.exists(ref_full_path):\n        return version_str\n    git_str = \"\"\n    with open(ref_full_path, \"r\", encoding=\"utf-8\") as f:\n        for line in f:\n            if line:\n                git_str = line.strip()[:7]\n                break\n    # get just the feature portion of the git ref_path\n    r = re.match(r\"^refs/heads/(.*)\", ref_path)\n    if r:\n        git_str = f\"{git_str} {r.group(1)}\"\n    # Full version string now\n    version_str = f\"{version_str} ({git_str})\"\n    return version_str", "\n\ndef plural(count: int) -> str:\n    \"\"\"Get an \"s\" if count indicates one is needed.\"\"\"\n    if isinstance(count, (int, float)) and count == 1:\n        return \"\"\n    else:\n        return \"s\"\n", ""]}
{"filename": "tt_publish.py", "chunked_list": ["\"\"\"TagTracker by Julias Hocking.\n\nReport & data publishing functions for tagtracker\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.", "    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.", "    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"\n\nimport os\nimport pathlib\n\nfrom tt_globals import *  # pylint:disable=unused-wildcard-import,wildcard-import\nfrom tt_time import VTime\nimport tt_util as ut", "from tt_time import VTime\nimport tt_util as ut\nfrom tt_trackerday import TrackerDay\nimport tt_datafile as df\nimport tt_printer as pr\nimport tt_reports as rep\n\nimport tt_conf as cfg\n\n\nclass Publisher:\n    \"\"\"Keep track of publishing activity.\"\"\"\n\n    def __init__(self,destination:str,frequency:int) -> None:\n        self.last_publish = \"00:00\"\n        self.able_to_publish = True\n        self.frequency = frequency\n        self.destination = destination\n        if not os.path.exists(destination):\n            self.able_to_publish = False\n            pr.iprint()\n            pr.iprint(\n                f\"Publication folder '{cfg.REPORTS_FOLDER}' not found, \"\n                \"will not try to Publish\",\n                style=cfg.ERROR_STYLE,\n            )\n\n    def publish(self,day:TrackerDay,as_of_when:str=\"\") -> None:\n        \"\"\"Publish.\"\"\"\n        if not self.able_to_publish:\n            return\n        if not self.publish_datafile(day,self.destination):\n            pr.iprint(\"ERROR PUBLISHING DATAFILE\",style=cfg.ERROR_STYLE)\n            pr.iprint(\"REPORT PUBLISHING TURNED OFF\",style=cfg.ERROR_STYLE)\n            self.able_to_publish = False\n            return\n\n        self.publish_reports(day,[as_of_when])\n        self.last_publish = VTime(\"now\")\n\n    def maybe_publish(self,day:TrackerDay,as_of_when:str=\"\") -> bool:\n        \"\"\"Maybe publish.  Return T if did a publish.\"\"\"\n        if not self.able_to_publish:\n            return\n        timenow = VTime(\"now\")\n        time_since_last = ut.time_int(timenow) - ut.time_int(self.last_publish)\n        if time_since_last >= self.frequency:\n            self.publish(day,as_of_when)\n\n    def publish_audit(self, day: TrackerDay, args: list[str]) -> None:\n        \"\"\"Publish the audit report.\"\"\"\n        if not self.able_to_publish:\n            return\n        fn = \"audit.txt\"\n        fullfn = os.path.join(cfg.REPORTS_FOLDER, fn)\n        if not pr.set_output(fullfn):\n            return\n        rep.audit_report(day, args)\n        pr.set_output()\n\n    def publish_datafile(self, day: TrackerDay, destination:str) -> bool:\n        \"\"\"Publish a copy of today's datafile.\n        Returns False if failed.\n        \"\"\"\n        if not self.able_to_publish:\n            return\n        filepath = df.datafile_name(destination,day.date)\n        if not filepath:\n            return False\n        result = df.write_datafile(filepath, day)\n        if not result:\n            return False\n        # Now save a copy to \"latest.dat\" in the same folder\n        latestpath = f\"{pathlib.Path(filepath).parent}/latest.dat\"\n        return df.write_datafile(latestpath, day)\n\n\n    def publish_city_report(self, day: TrackerDay, as_of_when: MaybeTime = \"now\") -> None:\n        \"\"\"Publish a report for daily insight to the City.\"\"\"\n        if not self.able_to_publish:\n            return\n        as_of_when:VTime = VTime(as_of_when)\n        fullfn = os.path.join(cfg.REPORTS_FOLDER, \"city.txt\")\n        if not pr.set_output(fullfn):\n            return\n        pr.iprint(f\"Overall valet report for {day.date}\")\n        pr.iprint(f\"Generated {ut.date_str('today')} {ut.get_time()}\")\n\n        rep.day_end_report(day, [as_of_when])\n        pr.iprint()\n        rep.busyness_report(day, [as_of_when])\n        pr.iprint()\n        rep.busy_graph(day, as_of_when=as_of_when)\n        pr.iprint()\n        rep.fullness_graph(day, as_of_when=as_of_when)\n        pr.iprint()\n        rep.full_chart(day, as_of_when=as_of_when)\n        pr.set_output()\n\n\n    def publish_reports(self, day: TrackerDay, args: list = None) -> None:\n        \"\"\"Publish reports to the PUBLISH directory.\"\"\"\n        if not self.able_to_publish:\n            return\n        as_of_when = (args + [None])[0]\n        if not as_of_when:\n            as_of_when = \"now\"\n        as_of_when:VTime = VTime(as_of_when)\n        self.publish_audit(day, [as_of_when])\n        self.publish_city_report(day, as_of_when=as_of_when)\n\n        fn = \"day_end.txt\"\n        day_end_fn = os.path.join(cfg.REPORTS_FOLDER, fn)\n        if not pr.set_output(day_end_fn):\n            return\n\n        pr.iprint(ut.date_str(day.date,long_date=True))\n        pr.iprint(f\"Report generated {ut.date_str('today')} {VTime('now')}\")\n        rep.day_end_report(day, [as_of_when])\n        pr.set_output()", "\n\nclass Publisher:\n    \"\"\"Keep track of publishing activity.\"\"\"\n\n    def __init__(self,destination:str,frequency:int) -> None:\n        self.last_publish = \"00:00\"\n        self.able_to_publish = True\n        self.frequency = frequency\n        self.destination = destination\n        if not os.path.exists(destination):\n            self.able_to_publish = False\n            pr.iprint()\n            pr.iprint(\n                f\"Publication folder '{cfg.REPORTS_FOLDER}' not found, \"\n                \"will not try to Publish\",\n                style=cfg.ERROR_STYLE,\n            )\n\n    def publish(self,day:TrackerDay,as_of_when:str=\"\") -> None:\n        \"\"\"Publish.\"\"\"\n        if not self.able_to_publish:\n            return\n        if not self.publish_datafile(day,self.destination):\n            pr.iprint(\"ERROR PUBLISHING DATAFILE\",style=cfg.ERROR_STYLE)\n            pr.iprint(\"REPORT PUBLISHING TURNED OFF\",style=cfg.ERROR_STYLE)\n            self.able_to_publish = False\n            return\n\n        self.publish_reports(day,[as_of_when])\n        self.last_publish = VTime(\"now\")\n\n    def maybe_publish(self,day:TrackerDay,as_of_when:str=\"\") -> bool:\n        \"\"\"Maybe publish.  Return T if did a publish.\"\"\"\n        if not self.able_to_publish:\n            return\n        timenow = VTime(\"now\")\n        time_since_last = ut.time_int(timenow) - ut.time_int(self.last_publish)\n        if time_since_last >= self.frequency:\n            self.publish(day,as_of_when)\n\n    def publish_audit(self, day: TrackerDay, args: list[str]) -> None:\n        \"\"\"Publish the audit report.\"\"\"\n        if not self.able_to_publish:\n            return\n        fn = \"audit.txt\"\n        fullfn = os.path.join(cfg.REPORTS_FOLDER, fn)\n        if not pr.set_output(fullfn):\n            return\n        rep.audit_report(day, args)\n        pr.set_output()\n\n    def publish_datafile(self, day: TrackerDay, destination:str) -> bool:\n        \"\"\"Publish a copy of today's datafile.\n        Returns False if failed.\n        \"\"\"\n        if not self.able_to_publish:\n            return\n        filepath = df.datafile_name(destination,day.date)\n        if not filepath:\n            return False\n        result = df.write_datafile(filepath, day)\n        if not result:\n            return False\n        # Now save a copy to \"latest.dat\" in the same folder\n        latestpath = f\"{pathlib.Path(filepath).parent}/latest.dat\"\n        return df.write_datafile(latestpath, day)\n\n\n    def publish_city_report(self, day: TrackerDay, as_of_when: MaybeTime = \"now\") -> None:\n        \"\"\"Publish a report for daily insight to the City.\"\"\"\n        if not self.able_to_publish:\n            return\n        as_of_when:VTime = VTime(as_of_when)\n        fullfn = os.path.join(cfg.REPORTS_FOLDER, \"city.txt\")\n        if not pr.set_output(fullfn):\n            return\n        pr.iprint(f\"Overall valet report for {day.date}\")\n        pr.iprint(f\"Generated {ut.date_str('today')} {ut.get_time()}\")\n\n        rep.day_end_report(day, [as_of_when])\n        pr.iprint()\n        rep.busyness_report(day, [as_of_when])\n        pr.iprint()\n        rep.busy_graph(day, as_of_when=as_of_when)\n        pr.iprint()\n        rep.fullness_graph(day, as_of_when=as_of_when)\n        pr.iprint()\n        rep.full_chart(day, as_of_when=as_of_when)\n        pr.set_output()\n\n\n    def publish_reports(self, day: TrackerDay, args: list = None) -> None:\n        \"\"\"Publish reports to the PUBLISH directory.\"\"\"\n        if not self.able_to_publish:\n            return\n        as_of_when = (args + [None])[0]\n        if not as_of_when:\n            as_of_when = \"now\"\n        as_of_when:VTime = VTime(as_of_when)\n        self.publish_audit(day, [as_of_when])\n        self.publish_city_report(day, as_of_when=as_of_when)\n\n        fn = \"day_end.txt\"\n        day_end_fn = os.path.join(cfg.REPORTS_FOLDER, fn)\n        if not pr.set_output(day_end_fn):\n            return\n\n        pr.iprint(ut.date_str(day.date,long_date=True))\n        pr.iprint(f\"Report generated {ut.date_str('today')} {VTime('now')}\")\n        rep.day_end_report(day, [as_of_when])\n        pr.set_output()", "\n"]}
{"filename": "cgi-reports.py", "chunked_list": ["#!/usr/bin/env python3\n\"\"\"CGI script for TagTracker reports against consolidated database.\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n", "    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"\n\nimport sqlite3\nimport sys\nimport os\nimport urllib.parse\nimport datetime\nimport pathlib", "import datetime\nimport pathlib\n\nfrom tt_globals import *\n\nimport tt_dbutil as db\nimport tt_conf as cfg\nimport tt_reports as rep\nimport tt_datafile as df\nfrom tt_tag import TagID", "import tt_datafile as df\nfrom tt_tag import TagID\nfrom tt_time import VTime\nimport tt_util as ut\nimport colourmap as cm\n\n\ndef untaint(tainted: str) -> str:\n    \"\"\"Remove any suspicious characters from a possibly tainted string.\"\"\"\n    return \"\".join(c for c in tainted if c.isprintable())", "\n\ndef selfref(\n    what: str = \"\",\n    qdate: str = \"\",\n    qtime: str = \"\",\n    qtag: str = \"\",\n    qdow: str = \"\",\n) -> str:\n    \"\"\"Return a self-reference with the given parameters.\"\"\"\n\n    me = untaint(os.environ.get(\"SCRIPT_NAME\", \"\"))\n    parms = []\n    if what:\n        parms.append(f\"what={what}\")\n    if qdate:\n        parms.append(f\"date={qdate}\")\n    if qtime:\n        parms.append(f\"time={qtime}\")\n    if qtag:\n        parms.append(f\"tag={qtag}\")\n    if qdow:\n        parms.append(f\"dow={qdow}\")\n    parms_str = f\"?{'&'.join(parms)}\" if parms else \"\"\n    return f\"{me}{untaint(parms_str)}\"", "\n\ndef style() -> str:\n    \"\"\"Return a CSS stylesheet as a string.\"\"\"\n    return \"\"\"\n        <style>\n            html {\n        font-family: sans-serif;\n        }\n\n        table {\n        border-collapse: collapse;\n        border: 2px solid rgb(200,200,200);\n        letter-spacing: 1px;\n        font-size: 0.8rem;\n        }\n\n        td, th {\n        border: 1px solid rgb(190,190,190);\n        padding: 4px 6px;\n        }\n\n        th {\n        background-color: rgb(235,235,235);\n        }\n\n        td {\n        text-align: right;\n        }\n\n        tr:nth-child(even) td {\n        background-color: rgb(250,250,250);\n        }\n\n        tr:nth-child(odd) td {\n        background-color: rgb(245,245,245);\n        }\n\n        caption {\n        padding: 10px;\n        }\n        </style>\n    \"\"\"", "\n\ndef form(\n    title: str = \"TagTracker\",\n    default_what: str = \"overview\",\n    default_date: str = \"\",\n    default_tag: str = \"\",\n    default_dow: str = \"Sunday\",\n):\n    if not default_date:\n        default_date = ut.date_str(\"today\")\n\n    what_choices = {\n        \"overview\": \"Overview\",\n        \"dow_overview\": \"Overview for one day of the week [specify Day of Week]\",\n        \"blocks\": \"Colour-coded daily activity overview\",\n        \"dow_blocks\": \"Colour-coded daily activity overview for one day of the week\",\n        \"abandoned\": \"Lost tags report\",\n        \"day_end\": \"Day-end report for a given date\",\n        \"audit\": \"Audit report for a given date\",\n        \"last_use\": \"History of use for a given tag\",\n        \"one_day_tags\": \"Tags in/out activity for a given date\",\n        \"datafile\": \"Recreated datafile for a given date\",\n        \"chart\": \"Activity charts for a given date [specify Date]\",\n    }\n    dow_choices = {  # These are ISO days of week not unix.\n        \"7\": \"Sunday\",\n        \"1\": \"Monday\",\n        \"2\": \"Tuesday\",\n        \"3\": \"Wednesday\",\n        \"4\": \"Thursday\",\n        \"5\": \"Friday\",\n        \"6\": \"Saturday\",\n    }\n\n    me_action = pathlib.Path(untaint(os.environ.get(\"SCRIPT_NAME\", \"\"))).name\n    if not me_action:\n        error_out(\"bad\")\n\n    print(f\"<html><head><title>{title}</title></head>\")\n    print(style())\n    print(\"<body>\")\n    print(\"<h2>TagTracker reports</h2>\")\n    print(\n        f\"\"\"\n    <form accept-charset=\"UTF-8\" action=\"{me_action}\" autocomplete=\"off\" method=\"GET\">\n\n\n    <label for=\"name\">Report to create:</label>\n    <select name=\"what\" id=\"what\">\n\"\"\"\n    )\n    for choice, descr in what_choices.items():\n        if choice == default_what:\n            print(\n                f'<option value=\"{choice}\" selected=\"selected\">{descr}</option>'\n            )\n        else:\n            print(f'<option value=\"{choice}\">{descr}</option>')\n    print(\n        f\"\"\"\n\n    </select>\n    <br /><br />\n    Date: <input name=\"date\" type=\"text\" value=\"{default_date}\" />\n    <br />\n    Tag: <input name=\"tag\" type=\"text\" value=\"{default_tag}\" />\n    <br />\n    Day of week:\n        <select name=\"dow\" id=\"dow\">\"\"\"\n    )\n    for choice, descr in dow_choices.items():\n        if choice == default_dow:\n            print(\n                f'<option value=\"{choice}\" selected=\"selected\">{descr}</option>'\n            )\n        else:\n            print(f'<option value=\"{choice}\">{descr}</option>')\n    print(\n        \"\"\"\n        </select>\n\n    <br /><br />\n    <button type=\"submit\" value=\"Submit\">Create report</button>\n\n    </form>\n    <hr>\n\"\"\"\n    )", "\n\ndef error_out(msg: str = \"\"):\n    if msg:\n        print(msg)\n    else:\n        print(\"Bad or unknown parameter\")\n    sys.exit(1)\n\n\ndef show_help():\n    print(\"<pre>\\n\")\n    print(\"There is no help here. Read the code.\")", "\n\ndef show_help():\n    print(\"<pre>\\n\")\n    print(\"There is no help here. Read the code.\")\n\n\ndef padval(val, length: int = 0) -> str:\n    valstr = str(val)\n    if length < len(valstr):\n        length = len(valstr)\n    pad = \" \" * (length - len(valstr))\n    if isinstance(val, str):\n        return f\"{valstr}{pad}\"\n    else:\n        return f\"{pad}{valstr}\"", "\n\ndef one_tag_history_report(\n    ttdb: sqlite3.Connection, maybe_tag: MaybeTag\n) -> None:\n    \"\"\"Report a tag's history.\"\"\"\n\n    tag = TagID(maybe_tag)\n    if not tag:\n        print(f\"Not a tag: '{untaint(tag.original)}'\")\n        sys.exit()\n    # Fetch all info about this tag.\n    (last_date, last_in, last_out) = (\"\", \"\", \"\")\n    curs = ttdb.cursor()\n    rows = curs.execute(\n        \"select date,time_in,time_out \"\n        \"from visit \"\n        f\"where tag = '{tag.lower()}' \"\n        \"order by date desc;\"\n    ).fetchall()\n\n    print(f\"<h1>History of tag {tag.upper()}</h1>\")\n    print(\n        f\"<h3>This tag has been used {len(rows)} time{ut.plural(len(rows))}</h3>\"\n    )\n    print()\n    if not rows:\n        print(f\"No record that {tag.upper()} ever used<br />\")\n    else:\n        print(\"<table>\")\n        print(\"<style>td {text-align: right;}</style>\")\n        print(\"<tr><th>Date</th><th>BikeIn</th><th>BikeOut</th></tr>\")\n        for row in rows:\n            out = VTime(row[2]).tidy if row[2] else \"     \"\n            linkdate = row[0]\n            link = selfref(what=\"one_day_tags\", qdate=linkdate)\n            print(\n                f\"<tr><td>\"\n                f\"<a href='{link}'>{row[0]}</a>\"\n                \"</td>\"\n                f\"<td>{VTime(row[1]).tidy}</td><td>{out}</td></tr>\"\n            )\n        print(\"</table>\")\n    print(\"</body></html>\")", "\n\ndef ytd_totals_table(ttdb: sqlite3.Connection, csv: bool = False):\n    \"\"\"Print a table of YTD totals.\n\n    YTD Total:\n\n    Regular parked  xx\n    Oversize parked xx\n    Total Parked    xx\n    Bike-hours      xx\n    Valet hours     xx\n    Bike-hrs/hr     xx\n    \"\"\"\n    sel = (\n        \"select \"\n        \"   sum(parked_regular) parked_regular, \"\n        \"   sum(parked_oversize) parked_oversize, \"\n        \"   sum(parked_total) parked_total, \"\n        \"   sum((julianday(time_closed)-julianday(time_open))*24) hours_open, \"\n        \"   sum(registrations) registrations \"\n        \"from day \"\n    )\n    drows = db.db_fetch(ttdb, sel)\n    # Find the total bike-hours\n    vrows = db.db_fetch(\n        ttdb,\n        \"select \"\n        \"   sum(julianday(duration)-julianday('00:00'))*24 bike_hours \"\n        \"from visit \",\n    )\n    day: db.DBRow = drows[0]\n    day.bike_hours = vrows[0].bike_hours\n    # Get total # of days of operation\n    day.num_days = db.db_fetch(ttdb, \"select count(date) num_days from day\")[\n        0\n    ].num_days\n\n    if csv:\n        print(\"measure,ytd_total\")\n        html_tr_start = \"\"\n        html_tr_mid = \",\"\n        html_tr_end = \"\\n\"\n    else:\n        print(\"<table><tr><th colspan=2>Year to date totals</th></tr>\")\n        html_tr_start = \"<tr><td style='text-align:left'>\"\n        html_tr_mid = \"</td><td style='text-align:right'>\"\n        html_tr_end = \"</td></tr>\\n\"\n    print(\n        f\"{html_tr_start}Total bikes parked{html_tr_mid}\"\n        f\"  {day.parked_total}{html_tr_end}\"\n        f\"{html_tr_start}Regular bikes parked{html_tr_mid}\"\n        f\"  {day.parked_regular}{html_tr_end}\"\n        f\"{html_tr_start}Oversize bikes parked{html_tr_mid}\"\n        f\"  {day.parked_oversize}{html_tr_end}\"\n        f\"{html_tr_start}529 Registrations{html_tr_mid}\"\n        f\"  {day.registrations}{html_tr_end}\"\n        f\"{html_tr_start}Total days open{html_tr_mid}\"\n        f\"  {day.num_days}{html_tr_end}\"\n        f\"{html_tr_start}Total hours open{html_tr_mid}\"\n        f\"  {day.hours_open:0.1f}{html_tr_end}\"\n        f\"{html_tr_start}Bike-hours total{html_tr_mid}\"\n        f\"  {day.bike_hours:0.0f}{html_tr_end}\"\n        f\"{html_tr_start}Average bikes / day{html_tr_mid}\"\n        f\"  {(day.parked_total/day.num_days):0.1f}{html_tr_end}\"\n        f\"{html_tr_start}Average stay length{html_tr_mid}\"\n        f\"  {VTime((day.bike_hours/day.parked_total)*60).short}{html_tr_end}\"\n        \"</table>\"\n    )", "\n\ndef overview_report(ttdb: sqlite3.Connection, iso_dow: str | int = \"\"):\n    \"\"\"Print new version of the all-days default report.\n\n    If dow is None then do for all days of the week, otherwise do\n    for ISO int dow (1=Monday-->7=Sunday)\n\n    \"\"\"\n    if iso_dow:\n        iso_dow = int(iso_dow)\n    if not iso_dow:\n        title_bit = \"\"\n        where = \"\"\n    else:\n        # sqlite uses unix dow, so need to adjust dow from 1->7 to 0->6.\n        title_bit = f\"{ut.dow_str(iso_dow)} \"\n        where = f\" where strftime('%w',date) = '{iso_dow % 7}' \"\n    sel = (\n        \"select \"\n        \"   date, time_open, time_closed, \"\n        \"   (julianday(time_closed)-julianday(time_open))*24 hours_open, \"\n        \"   parked_regular, parked_oversize, parked_total, \"\n        \"   leftover, \"\n        \"   max_total, \"\n        \"   registrations, \"\n        \"   precip_mm, temp, sunset \"\n        \"from day \"\n        f\"  {where} \"\n        \"   order by date desc\"\n    )\n    drows = db.db_fetch(ttdb, sel)\n\n    # Find the bike-hours for each day\n    vrows = db.db_fetch(\n        ttdb,\n        \"select \"\n        \"   sum(julianday(duration)-julianday('00:00'))*24 bike_hours, \"\n        \"   date \"\n        \"from visit \"\n        f\"  {where} \"\n        \"   group by date order by date desc;\",\n    )\n    for rownum, vday in enumerate(vrows):\n        if drows[rownum].date != vday.date:\n            print(f\"oops {rownum=}; {drows[rownum].date=} != {vday.date=}\")\n            drows[rownum].bike_hours = \"\"\n        else:\n            drows[rownum].bike_hours = vday.bike_hours\n\n    max_parked = 0\n    max_parked_date = \"\"\n    max_full = 0\n    max_full_date = \"\"\n    max_bike_hours = 0\n    max_bike_hours_date = \"\"\n    max_bike_hours_per_hour = 0\n    max_bike_hours_per_hour_date = \"\"\n\n    for r in drows:\n        r.bike_hours_per_hour = r.bike_hours / r.hours_open\n        if r.bike_hours_per_hour > max_bike_hours_per_hour:\n            max_bike_hours_per_hour = r.bike_hours_per_hour\n            max_bike_hours_per_hour_date = r.date\n        if r.parked_total > max_parked:\n            max_parked = r.parked_total\n            max_parked_date = r.date\n        if r.max_total > max_full:\n            max_full = r.max_total\n            max_full_date = r.date\n        if r.bike_hours > max_bike_hours:\n            max_bike_hours = r.bike_hours\n            max_bike_hours_date = r.date\n\n    max_precip = max(\n        [1] + [r.precip_mm for r in drows if r.precip_mm is not None]\n    )\n    max_temp = max([1] + [r.temp for r in drows if r.temp is not None])\n\n    # Set up colour maps for shading cell backgrounds\n    max_parked_colour = cm.ColourMap()\n    max_parked_colour.set_up_map(\n        \"white\",\n        \"lime green\",\n        x_bottom=0,\n        x_top=max_parked,\n        x_exponent=2,\n    )\n    max_full_colour = cm.ColourMap()\n    max_full_colour.set_up_map(\n        \"white\",\n        \"lime green\",\n        x_bottom=0,\n        x_top=max_full,\n        x_exponent=2,\n    )\n    max_left_colour = cm.ColourMap()\n    max_left_colour.set_up_map(\n        \"white\",\n        \"red\",\n        x_bottom=0,\n        x_top=10,\n        x_exponent=1,\n    )\n    max_bike_hours_colour = cm.ColourMap()\n    max_bike_hours_colour.set_up_map(\n        \"white\",\n        \"medium purple\",\n        x_bottom=0,\n        x_top=max_bike_hours,\n        x_exponent=2,\n    )\n    max_bike_hours_per_hour_colour = cm.ColourMap()\n    max_bike_hours_per_hour_colour.set_up_map(\n        \"white\",\n        \"medium purple\",\n        x_bottom=0,\n        x_top=max_bike_hours_per_hour,\n        x_exponent=2,\n    )\n    max_temp_colour = cm.ColourMap()\n    max_temp_colour.set_up_map(\n        (255, 255, 224),\n        \"gold\",\n        x_bottom=-0,\n        x_top=max_temp,\n        x_exponent=2,\n    )\n    max_precip_colour = cm.ColourMap()\n    max_precip_colour.set_up_map(\n        \"white\",\n        \"cyan\",\n        x_bottom=0,\n        x_top=max_precip,\n        x_exponent=0.5,\n    )\n\n    print(f\"<h1>{title_bit}Bike valet overview</h1>\")\n    print(\n        f\"<p><b>Most bikes parked:</b> \"\n        f\"  {max_parked} bikes on {ut.date_str(max_parked_date,long_date=True)}<br />\"\n        f\"<b>Valet was fullest:</b> \"\n        f\"  with {max_full} bikes on {ut.date_str(max_full_date,long_date=True)}<br />\"\n        f\"<b>Greatest utilization:</b> \"\n        f\"  {round(max_bike_hours)} bike-hours \"\n        f\"      on {ut.date_str(max_bike_hours_date,long_date=True)}<br />\"\n        f\"<b>Greatest utilization per hour:</b> \"\n        f\"  {round(max_bike_hours_per_hour,2)} bike-hours per valet hour \"\n        f\"      on {ut.date_str(max_bike_hours_per_hour_date,long_date=True)}</p>\"\n    )\n    print(\"<p>&nbsp;</p>\")\n\n    if not iso_dow:\n        ytd_totals_table(ttdb, csv=False)\n        print(\"<p>&nbsp;</p>\")\n\n    print(\"<table>\")\n    print(\"<style>td {text-align: right;}</style>\")\n    print(\n        \"<tr>\"\n        \"<th rowspan=2 colspan=2>Date<br />(newest to oldest)</th>\"\n        \"<th colspan=2>Valet Hours</th>\"\n        \"<th colspan=3>Bike Parked</th>\"\n        \"<th rowspan=2>Bikes<br />Left at<br />Valet</th>\"\n        \"<th rowspan=2>Most<br />Bikes<br />at Once</th>\"\n        \"<th rowspan=2>Bike-<br />hours</th>\"\n        \"<th rowspan=2>Bike-<br />hours<br />per hr</th>\"\n        \"<th rowspan=2>529<br />Regs</th>\"\n        \"<th colspan=3>Environment</th>\"\n        \"</tr>\"\n    )\n    print(\n        \"<tr>\"\n        # \"<th>Date</th>\"\n        \"<th>Open</th><th>Close</th>\"\n        \"<th>Reg</th><th>Ovr</th><th>Total</th>\"\n        # \"<th>Left</th>\"\n        # \"<th>Fullest</th>\"\n        \"<th>Max<br />Temp</th><th>Rain</th><th>Dusk</th>\"\n        \"</tr>\"\n    )\n\n    for row in drows:\n        date_link = selfref(what=\"day_end\", qdate=row.date)\n        reg_str = \"\" if row.registrations is None else f\"{row.registrations}\"\n        temp_str = \"\" if row.temp is None else f\"{row.temp:0.1f}\"\n        precip_str = \"\" if row.precip_mm is None else f\"{row.precip_mm:0.1f}\"\n        print(\n            f\"<tr>\"\n            f\"<td><a href='{date_link}'>{row.date}</a></td>\"\n            f\"<td style='text-align:left'>{ut.date_str(row.date,dow_str_len=3)}</td>\"\n            f\"<td>{row.time_open}</td><td>{row.time_closed}</td>\"\n            f\"<td>{row.parked_regular}</td><td>{row.parked_oversize}</td><td style='background-color: {max_parked_colour.get_rgb_str(row.parked_total)}'>{row.parked_total}</td>\"\n            f\"<td style='background-color: {max_left_colour.get_rgb_str(row.leftover)}'>{row.leftover}</td>\"\n            f\"<td style='background-color: {max_full_colour.get_rgb_str(row.max_total)}'>{row.max_total}</td>\"\n            f\"<td style='background-color: {max_bike_hours_colour.get_rgb_str(row.bike_hours)}'>{row.bike_hours:0.0f}</td>\"\n            f\"<td style='background-color: {max_bike_hours_per_hour_colour.get_rgb_str(row.bike_hours_per_hour)}'>{row.bike_hours_per_hour:0.2f}</td>\"\n            f\"<td>{reg_str}</td>\"\n            f\"<td style='background-color: {max_temp_colour.get_rgb_str(row.temp)}'>{temp_str}</td>\"\n            f\"<td style='background-color: {max_precip_colour.get_rgb_str(row.precip_mm)}'>{precip_str}</td>\"\n            f\"<td>{row.sunset}</td>\"\n            \"</tr>\"\n        )\n    print(\" </table>\")", "\n\ndef lost_tags(ttdb: sqlite3.Connection):\n    too_many = 10\n    curs = ttdb.cursor()\n    rows = curs.execute(\n        \"select tag,date,time_in from visit \"\n        f\"where date not in (select date from day where leftover > {too_many}) \"\n        'and (time_out is null or time_out = \"\")'\n        # \"and date < strftime('%Y-%m-%d') \"\n        \"order by date desc;\"\n    ).fetchall()\n\n    # print(\"<pre>\")\n    print(\"<h1>Tags of abandoned bikes</h1>\")\n    print(\"<ul>\")\n    print(\"<li>Listed newest to oldest</li>\")\n    print(\n        f\"<li>Excludes dates with more than {too_many} supposed leftovers</li>\"\n    )\n    print(\n        \"<li>Tags might have been returned to use after the dates listed</li>\"\n    )\n    print(\"</ul>\")\n\n    print(\"<table>\")\n    print(\"<style>td {text-align: left;}</style>\")\n    print(\"<tr><th>Tag</th><th>Last check-in</th></tr>\")\n    for row in rows:\n        tag = TagID(row[0])\n        in_date = row[1]\n        in_time = row[2]\n        tag_link = selfref(what=\"last_use\", qtag=tag)\n        date_link = selfref(what=\"one_day_tags\", qdate=in_date)\n\n        print(\n            f\"<tr><td>\"\n            f\"<a href='{tag_link}'>{tag.cased}</a>\"\n            \"</td>\"\n            f\"<td><a href='{date_link}'>{in_date}</a> {in_time}</td></tr>\"\n        )\n    print(\" </table>\")", "\n\ndef one_day_tags_report(ttdb: sqlite3.Connection, whatday: str = \"\"):\n    thisday = ut.date_str(whatday)\n    if not thisday:\n        bad_date(whatday)\n\n    rows = (\n        ttdb.cursor()\n        .execute(\n            \"select tag,time_in,time_out,duration from visit \"\n            f\"where date = '{thisday}' \"\n            \"order by time_in desc;\"\n        )\n        .fetchall()\n    )\n\n    visits = {}\n    for row in rows:\n        tag = TagID(row[0])\n        if not tag:\n            continue\n        v: db.VisitRow = db.VisitRow()\n        v.tag = tag\n        v.time_in = VTime(row[1])\n        v.time_out = VTime(row[2])\n        v.duration = VTime(row[3])\n        visits[tag] = v\n\n    print(\n        f\"<h1>Tags report for {thisday} ({ut.date_str(thisday,dow_str_len=10)})</h1>\"\n    )\n    print(\"<pre>\")\n    if not visits:\n        print(f\"No activity recorded for {thisday}\")\n        sys.exit()\n    print(f\"Tags for {thisday}\")\n    print(\"-------------------\")\n    print(\n        \"- Where no check-out time exists, duration is estimated\\n  assuming bike is at valet until the end of the day\"\n    )\n    print()\n    print(\"BIKE   --IN- -OUT-  DURTN\")\n    for tag in sorted(visits.keys()):\n        v: db.VisitRow = visits[tag]\n        print(\n            f\"{padval(tag,6)} {padval(v.time_in.tidy,5)} {padval(v.time_out.tidy,5)}  {v.duration.tidy}\"\n        )\n    print(\"</pre></body></html>\")", "\n\ndef datafile(ttdb: sqlite3.Connection, date: str = \"\"):\n    \"\"\"Print a reconstructed datafile for the given date.\"\"\"\n    thisday = ut.date_str(date)\n    if not thisday:\n        bad_date(date)\n    print(\n        f\"<h1>Reconstructed datafile for {ut.date_str(thisday,long_date=True)}</h1>\"\n    )\n    print(\"<pre>\")\n\n    day = db.db2day(ttdb, thisday)\n    print(f\"# TagTracker datafile for {thisday}\")\n    print(f\"# Reconstructed on {ut.date_str('today')} at {VTime('now')}\")\n    print(f\"{df.HEADER_VALET_DATE} {day.date}\")\n    print(f\"{df.HEADER_VALET_OPENS} {day.opening_time}\")\n    print(f\"{df.HEADER_VALET_CLOSES} {day.closing_time}\")\n    print(f\"{df.HEADER_BIKES_IN}\")\n    for tag, atime in day.bikes_in.items():\n        print(f\"  {tag.lower()},{atime}\")\n    print(f\"{df.HEADER_BIKES_OUT}\")\n    for tag, atime in day.bikes_out.items():\n        print(f\"  {tag.lower()},{atime}\")\n    print(f\"{df.HEADER_REGULAR}\")\n    print(f\"{df.HEADER_OVERSIZE}\")\n    print(f\"{df.HEADER_RETIRED}\")\n    print(f\"{df.HEADER_COLOURS}\")\n    for col, name in day.colour_letters.items():\n        print(f\"  {col},{name}\")", "\n\ndef bad_date(bad_date: str = \"\"):\n    \"\"\"Print message about bad date & exit.\"\"\"\n    error_out(\n        f\"Bad date '{untaint(bad_date)}'. \"\n        \"Use YYYY-MM-DD or 'today' or 'yesterday'.\"\n    )\n\n\ndef audit_report(ttdb: sqlite3.Connection, thisday: str, whattime: VTime):\n    \"\"\"Print audit report.\"\"\"\n    if not thisday:\n        bad_date(thisday)\n    print(f\"<h1>Audit report for {ut.date_str(thisday,long_date=True)}</h1>\")\n    print(\"<pre>\")\n    day = db.db2day(ttdb, thisday)\n    rep.audit_report(day, [VTime(whattime)])", "\n\ndef audit_report(ttdb: sqlite3.Connection, thisday: str, whattime: VTime):\n    \"\"\"Print audit report.\"\"\"\n    if not thisday:\n        bad_date(thisday)\n    print(f\"<h1>Audit report for {ut.date_str(thisday,long_date=True)}</h1>\")\n    print(\"<pre>\")\n    day = db.db2day(ttdb, thisday)\n    rep.audit_report(day, [VTime(whattime)])", "\n\ndef one_day_chart(ttdb: sqlite3.Connection, date: str):\n    \"\"\"One-day chart.\"\"\"\n    thisday = ut.date_str(date)\n    if not thisday:\n        bad_date(date)\n    query_time = \"now\" if thisday == ut.date_str(\"today\") else \"24:00\"\n    print(\n        f\"<h1>Activity charts for {ut.date_str(thisday,long_date=True)}</h1>\"\n    )\n    print(\"<pre>\")\n    rep.full_chart(db.db2day(ttdb, thisday), query_time)\n    rep.busy_graph(db.db2day(ttdb, thisday), query_time)\n    rep.fullness_graph(db.db2day(ttdb, thisday), query_time)", "\n\ndef one_day_summary(ttdb: sqlite3.Connection, thisday: str, qtime: VTime):\n    \"\"\"One-day busy report.\"\"\"\n    if not thisday:\n        bad_date(thisday)\n    day = db.db2day(ttdb, thisday)\n    print(f\"<h1>Day-end report for {ut.date_str(thisday,long_date=True)}</h1>\")\n    print(\"<pre>\")\n    rep.day_end_report(day, [qtime])\n    print()\n    rep.busyness_report(day, [qtime])\n    print(\"</pre>\")", "\n\ndef blocks_report(ttdb: sqlite3.Connection, iso_dow: str | int = \"\"):\n    \"\"\"Print block-by-block colours report for all days\n\n    If dow is None then do for all days of the week, otherwise do\n    for ISO int dow (1=Monday-->7=Sunday)\n\n    \"\"\"\n\n    class TableRow:\n        _allblocks = {}\n        for t in range(6 * 60, 24 * 60, 30):\n            _allblocks[VTime(t)] = (0, 0)  # Activity,Fullness\n\n        def __init__(self) -> None:\n            self.total_bikes = None\n            self.max_full = None\n            self.blocks = TableRow._allblocks.copy()\n\n    if iso_dow:\n        iso_dow = int(iso_dow)\n    if not iso_dow:\n        title_bit = \"\"\n        where = \"\"\n    else:\n        # sqlite uses unix dow, so need to adjust dow from 1->7 to 0->6.\n        title_bit = f\"{ut.dow_str(iso_dow)} \"\n        where = f\" where strftime('%w',date) = '{iso_dow % 7}' \"\n    sel = (\n        \"select \"\n        \"   date, parked_total total_bikes, max_total max_full \"\n        \"from day \"\n        f\"  {where} \"\n        \"   order by date desc\"\n    )\n    dayrows = db.db_fetch(ttdb, sel)\n\n    sel = (\n        \"select \"\n        \"    date,\"\n        \"    round(2*(julianday(time_in)-julianday('00:15'))*24,0)/2 block, \"\n        \"    count(time_in) bikes_in \"\n        \"from visit \"\n        f\"    {where} \"\n        \"group by date,block;\"\n    )\n    visitrows_in = db.db_fetch(ttdb, sel)\n    sel = (\n        \"select \"\n        \"    date,\"\n        \"    round(2*(julianday(time_out)-julianday('00:15'))*24,0)/2 block, \"\n        \"    count(time_out) bikes_out \"\n        \"from visit \"\n        f\"    {where} \"\n        \"group by date,block;\"\n    )\n    visitrows_out = db.db_fetch(ttdb, sel)\n\n    tabledata = {}\n    day_fullest = 0\n    day_busiest = 0\n    for row in dayrows:\n        date = row.date\n        daydata = TableRow()\n        daydata.total_bikes = row.total_bikes\n        if daydata.total_bikes > day_busiest:\n            day_busiest = daydata.total_bikes\n        daydata.max_full = row.max_full\n        if daydata.max_full > day_fullest:\n            day_fullest = daydata.max_full\n        tabledata[date] = daydata\n\n    # Consolidate activity info from the VISIT table\n    ins = {}\n    for row in visitrows_in:\n        thisdate = row.date\n        if not thisdate or not row.block or row.bikes_in is None:\n            continue\n        blocktime = VTime(row.block * 60)\n        if thisdate not in ins:\n            ins[thisdate] = {}\n        ins[thisdate][blocktime] = row.bikes_in\n    outs = {}\n    for row in visitrows_out:\n        thisdate = row.date\n        if not thisdate or not row.block or row.bikes_out is None:\n            continue\n        blocktime = VTime(row.block * 60)\n        if thisdate not in outs:\n            outs[thisdate] = {}\n        outs[thisdate][blocktime] = row.bikes_out\n\n    block_fullest = 0\n    block_busiest = 0\n    for date in sorted(ins.keys()):\n        full = 0\n        for block in sorted(tabledata[date].blocks.keys()):\n            num_in = ins[date][block] if block in ins[date] else 0\n            num_out = (\n                outs[date][block]\n                if date in outs and block in outs[date]\n                else 0\n            )\n            busy = num_in + num_out\n            full += num_in - num_out\n            if full > block_fullest:\n                block_fullest = full\n            if busy > block_busiest:\n                block_busiest = busy\n            tabledata[date].blocks[block] = (num_in, num_out, busy, full)\n\n    # Set up colour map\n    colours = cm.ColourMap()\n    colours.set_up_map(\n        \"white\",\n        (255, 80, 80),\n        (100, 100, 255),\n        0,\n        block_busiest,\n        0,\n        block_fullest,\n        0.75,\n        0.75,\n    )\n    day_busy_colours = cm.ColourMap()\n    day_busy_colours.set_up_map(\n        \"white\",\n        (255, 100, 100),\n        x_bottom=0,\n        x_top=day_busiest,\n        x_exponent=1.5,\n    )\n    day_full_colours = cm.ColourMap()\n    day_full_colours.set_up_map(\n        \"white\",\n        (100, 100, 255),\n        x_bottom=0,\n        x_top=day_fullest,\n        x_exponent=1.5,\n    )\n\n    print(f\"<h1>{title_bit}Daily activity detail</h1>\")\n    print(\"<table>\")\n    # print(\"<style>td {text-align: left}</style>\")\n    print(\n        f\"<tr><td style=text-align:left>REDS</td><td style=text-align:left>Activity (bikes coming and going)</td><td style='background-color:{colours.get_rgb_str(4,0)}'>LESS</td><td style='background-color:{colours.get_rgb_str(20,0)}'>MORE</td></tr>\"\n    )\n    print(\n        f\"<tr><td style=text-align:left>BLUES</td><td style=text-align:left>Number of bikes at the valet</td><td style='background-color:{colours.get_rgb_str(0,20)}'>LESS</td><td style='background-color:{colours.get_rgb_str(0,70)}'>MORE</td></tr>\"\n    )\n    print(\n        f\"<tr><td style=text-align:left>PURPLES</td><td style=text-align:left>Lots of both!</td><td style='background-color:{colours.get_rgb_str(4,20)}'>LESS</td><td style='background-color:{colours.get_rgb_str(20,70)}'>MORE</td></tr>\"\n    )\n    print(\"</table><p>&nbsp;</p>\")\n\n    def print_gap():\n        print(\n            \"<td style='border: 2px solid rgb(200,200,200);padding: 0px 0px;'></td>\"\n        )\n    print(\"<table>\")\n    print(\"<style>td {text-align: right;}</style>\")\n    print(\"<tr>\")\n    print(f\"<th colspan=3><a href='{selfref(what='blocks')}'>Date</a></th>\")\n    print(\"<th colspan=7>6:00 - 9:00</th>\")\n    print(\"<th colspan=7>9:00 - 12:00</th>\")\n    print(\"<th colspan=7>12:00 - 15:00</th>\")\n    print(\"<th colspan=7>15:00 - 18:00</th>\")\n    print(\"<th colspan=7>18:00 - 21:00</th>\")\n    print(\"<th colspan=7>21:00 - 24:00</th>\")\n    print(\"<th>Bikes<br>parked</th>\")\n    print(\"<th>Most<br/>bikes</th>\")\n    print(\"</tr>\")\n\n    for date in sorted(tabledata.keys(), reverse=True):\n        data: TableRow = tabledata[date]\n        summary_link = selfref(what=\"day_end\", qdate=date)\n        chartlink = selfref(what=\"chart\", qdate=date)\n\n        dayname = ut.date_str(date, dow_str_len=3)\n        daylink = selfref(what=\"dow_blocks\", qdow=ut.dow_int(dayname))\n\n        print(\n            f\"<tr><td style='text-align:center;'><a href='{summary_link}'>{date}</a></td>\"\n        )\n        print(\n            f\"<td style='text-align:center'><a href='{daylink}'>{dayname}</a></td>\"\n        )\n\n        for num, block in enumerate(sorted(data.blocks.keys())):\n            if num % 6 == 0:\n                print_gap()\n            (num_in, num_out, busy, full) = data.blocks[block]\n            cell_colour = colours.get_rgb_str(busy, full)\n            print(\n                f\"<td title='Bikes in: {num_in}\\nBikes out: {num_out}\\nBikes at end: {full}' style='background-color:{cell_colour} ;padding: 2px 8px;'><a href='{chartlink}' style='text-decoration:none;'>&nbsp;</a></td>\"\n            )\n        print_gap()\n\n        print(\n            f\"<td style='background-color:{day_busy_colours.get_rgb_str(data.total_bikes)}'><a href='{chartlink}'>{data.total_bikes}</a></td>\"\n        )\n        print(\n            f\"<td style='background-color:{day_full_colours.get_rgb_str(data.max_full)}'><a href='{chartlink}'>{data.max_full}</a></td>\"\n        )\n        print(\"</tr>\\n\")\n\n    print(\"</table>\")", "\n\n# =================================================================\nprint(\"Content-type: text/html\\n\\n\\n\")\n\nTagID.uc(cfg.TAGS_UPPERCASE)\n\nDBFILE = \"../data/cityhall_bikevalet.db\"\ndatabase = db.db_connect(DBFILE)\n", "database = db.db_connect(DBFILE)\n\n# Parse query parameters from the URL if present\nquery_string = untaint(os.environ.get(\"QUERY_STRING\", \"\"))\nif os.getenv(\"TAGTRACKER_DEV\"):\n    print(\n        \"<pre style='color:red'>\"\n        \"\\n\\nDEV DEV DEV DEV DEV DEV DEV DEV\\n\\n\"\n        f\"export QUERY_STRING='{query_string}'; \"\n        f\"export SERVER_PORT={os.environ.get('SERVER_PORT')}\\n\\n\"\n        \"</pre>\"\n    )", "\n\nquery_params = urllib.parse.parse_qs(query_string)\nwhat = query_params.get(\"what\", [\"\"])[0]\nwhat = what if what else \"overview\"\nmaybedate = query_params.get(\"date\", [\"\"])[0]\nmaybetime = query_params.get(\"time\", [\"\"])[0]\ntag = query_params.get(\"tag\", [\"\"])[0]\ndow_parameter = query_params.get(\"dow\", [\"\"])[0]\nif dow_parameter and dow_parameter not in [str(i) for i in range(1, 8)]:\n    error_out(f\"bad iso dow, need 1..7, not '{untaint(dow_parameter)}'\")", "dow_parameter = query_params.get(\"dow\", [\"\"])[0]\nif dow_parameter and dow_parameter not in [str(i) for i in range(1, 8)]:\n    error_out(f\"bad iso dow, need 1..7, not '{untaint(dow_parameter)}'\")\nif not dow_parameter:\n    # If no day of week, set it to today.\n    dow_parameter = str(\n        datetime.datetime.strptime(ut.date_str(\"today\"), \"%Y-%m-%d\").strftime(\n            \"%u\"\n        )\n    )", "\n\n# Date will be 'today' or 'yesterday' or ...\n# Time of day will be 24:00 unless it's today (or specified)\nqdate = ut.date_str(maybedate)\nif not maybetime:\n    if qdate == ut.date_str(\"today\"):\n        qtime = VTime(\"now\")\n    else:\n        qtime = VTime(\"24:00\")\nelse:\n    qtime = VTime(maybetime)", "if not qtime:\n    error_out(f\"Bad time: '{untaint(maybetime)}\")\nform(\n    default_what=what,\n    default_date=maybedate,\n    default_tag=tag,\n    default_dow=dow_parameter,\n)\nif not what:\n    sys.exit()\nif what == \"last_use\":\n    one_tag_history_report(database, tag)\nelif what == \"blocks\":\n    blocks_report(database)\nelif what == \"dow_blocks\":\n    blocks_report(database, dow_parameter)\nelif what == \"overview\":\n    overview_report(database)\nelif what == \"dow_overview\":\n    overview_report(database, dow_parameter)\nelif what == \"abandoned\":\n    lost_tags(database)\nelif what == \"one_day_tags\":\n    one_day_tags_report(database, qdate)\nelif what == \"datafile\":\n    datafile(database, qdate)\nelif what == \"audit\":\n    audit_report(database, qdate, qtime)\nelif what == \"day_end\":\n    one_day_summary(database, qdate, qtime)\nelif what == \"chart\" or what == \"busy-graph\":\n    one_day_chart(database, qdate)\nelse:\n    error_out(f\"Unknown request: {untaint(what)}\")\n    sys.exit(1)", "if not what:\n    sys.exit()\nif what == \"last_use\":\n    one_tag_history_report(database, tag)\nelif what == \"blocks\":\n    blocks_report(database)\nelif what == \"dow_blocks\":\n    blocks_report(database, dow_parameter)\nelif what == \"overview\":\n    overview_report(database)\nelif what == \"dow_overview\":\n    overview_report(database, dow_parameter)\nelif what == \"abandoned\":\n    lost_tags(database)\nelif what == \"one_day_tags\":\n    one_day_tags_report(database, qdate)\nelif what == \"datafile\":\n    datafile(database, qdate)\nelif what == \"audit\":\n    audit_report(database, qdate, qtime)\nelif what == \"day_end\":\n    one_day_summary(database, qdate, qtime)\nelif what == \"chart\" or what == \"busy-graph\":\n    one_day_chart(database, qdate)\nelse:\n    error_out(f\"Unknown request: {untaint(what)}\")\n    sys.exit(1)", "print(\"<pre>\")\nprint(db.db_latest(database))\nprint(f\"TagTracker version {ut.get_version()}\")\n"]}
{"filename": "tt_event.py", "chunked_list": ["\"\"\"TagTracker by Julias Hocking.\n\nEvent class for tagtracker.\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.", "    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.", "    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"\nfrom tt_globals import *  # pylint:disable=unused-wildcard-import,wildcard-import\nfrom tt_trackerday import TrackerDay\nfrom tt_time import VTime\n\n\nclass Event:\n    \"\"\"What happened at each discrete atime of day (that something happened).\"\"\"\n\n    def __init__(self, event_time: VTime) -> None:\n        \"\"\"Create empty Event, attributes initialized to type.\"\"\"\n        self.event_time = event_time\n        self.num_here_total = None  # will be int\n        self.num_here_regular = None\n        self.num_here_oversize = None\n        self.bikes_in = []  # List of canonical tag ids.\n        self.bikes_out = []\n        self.num_ins = 0  # This is just len(self.bikes_in).\n        self.num_outs = 0  # This is just len(self.bikes_out).\n        self.bikes_here = []  # List of all bikes here\n\n    @staticmethod\n    def calc_events(\n        day: TrackerDay, as_of_when: (int or VTime) = None\n    ) -> dict[VTime, 'Event']:\n        \"\"\"Create a dict of events keyed by HH:MM time.\n\n        If as_of_when is not given, then this will choose the latest\n        check-out time of the day as its time.\n\n        As a special case, this will also accept the word \"now\" to\n        mean the current time.\n        \"\"\"\n        if as_of_when is None:\n            # Set as_of_when to be the time of the latest checkout of the day.\n            if day.bikes_in:\n                as_of_when = day.latest_event()\n            else:\n                as_of_when = \"now\"\n        as_of_when = VTime(as_of_when)\n        # First pass, create all the Events and list their tags in & out.\n        events = {}\n        for tag, atime in day.bikes_in.items():\n            if atime > as_of_when:\n                continue\n            if atime not in events:\n                events[atime] = Event(atime)\n            events[atime].bikes_in.append(tag)\n        for tag, atime in day.bikes_out.items():\n            if atime > as_of_when:\n                continue\n            if atime not in events:\n                events[atime] = Event(atime)\n            events[atime].bikes_out.append(tag)\n        # Second pass, calculate other attributes of Events.\n        num_regular = 0  # Running balance of regular & oversize bikes.\n        num_oversize = 0\n        here_set = set()\n        for atime in sorted(events.keys()):\n            ev = events[atime]\n            ev.num_ins = len(ev.bikes_in)\n            ev.num_outs = len(ev.bikes_out)\n            # How many regular & oversize bikes have we added or lost?\n            delta_regular = len([x for x in ev.bikes_in if x in day.regular]) - len(\n                [x for x in ev.bikes_out if x in day.regular]\n            )\n            delta_oversize = len([x for x in ev.bikes_in if x in day.oversize]) - len(\n                [x for x in ev.bikes_out if x in day.oversize]\n            )\n            num_regular += delta_regular\n            num_oversize += delta_oversize\n            ev.num_here_regular = num_regular\n            ev.num_here_oversize = num_oversize\n            ev.num_here_total = num_regular + num_oversize\n            ev.num_ins = len(ev.bikes_in)\n            ev.num_outs = len(ev.bikes_out)\n            here_set = (here_set | set(ev.bikes_in)) - set(ev.bikes_out)\n            ev.bikes_here = list(here_set)\n        return events", "class Event:\n    \"\"\"What happened at each discrete atime of day (that something happened).\"\"\"\n\n    def __init__(self, event_time: VTime) -> None:\n        \"\"\"Create empty Event, attributes initialized to type.\"\"\"\n        self.event_time = event_time\n        self.num_here_total = None  # will be int\n        self.num_here_regular = None\n        self.num_here_oversize = None\n        self.bikes_in = []  # List of canonical tag ids.\n        self.bikes_out = []\n        self.num_ins = 0  # This is just len(self.bikes_in).\n        self.num_outs = 0  # This is just len(self.bikes_out).\n        self.bikes_here = []  # List of all bikes here\n\n    @staticmethod\n    def calc_events(\n        day: TrackerDay, as_of_when: (int or VTime) = None\n    ) -> dict[VTime, 'Event']:\n        \"\"\"Create a dict of events keyed by HH:MM time.\n\n        If as_of_when is not given, then this will choose the latest\n        check-out time of the day as its time.\n\n        As a special case, this will also accept the word \"now\" to\n        mean the current time.\n        \"\"\"\n        if as_of_when is None:\n            # Set as_of_when to be the time of the latest checkout of the day.\n            if day.bikes_in:\n                as_of_when = day.latest_event()\n            else:\n                as_of_when = \"now\"\n        as_of_when = VTime(as_of_when)\n        # First pass, create all the Events and list their tags in & out.\n        events = {}\n        for tag, atime in day.bikes_in.items():\n            if atime > as_of_when:\n                continue\n            if atime not in events:\n                events[atime] = Event(atime)\n            events[atime].bikes_in.append(tag)\n        for tag, atime in day.bikes_out.items():\n            if atime > as_of_when:\n                continue\n            if atime not in events:\n                events[atime] = Event(atime)\n            events[atime].bikes_out.append(tag)\n        # Second pass, calculate other attributes of Events.\n        num_regular = 0  # Running balance of regular & oversize bikes.\n        num_oversize = 0\n        here_set = set()\n        for atime in sorted(events.keys()):\n            ev = events[atime]\n            ev.num_ins = len(ev.bikes_in)\n            ev.num_outs = len(ev.bikes_out)\n            # How many regular & oversize bikes have we added or lost?\n            delta_regular = len([x for x in ev.bikes_in if x in day.regular]) - len(\n                [x for x in ev.bikes_out if x in day.regular]\n            )\n            delta_oversize = len([x for x in ev.bikes_in if x in day.oversize]) - len(\n                [x for x in ev.bikes_out if x in day.oversize]\n            )\n            num_regular += delta_regular\n            num_oversize += delta_oversize\n            ev.num_here_regular = num_regular\n            ev.num_here_oversize = num_oversize\n            ev.num_here_total = num_regular + num_oversize\n            ev.num_ins = len(ev.bikes_in)\n            ev.num_outs = len(ev.bikes_out)\n            here_set = (here_set | set(ev.bikes_in)) - set(ev.bikes_out)\n            ev.bikes_here = list(here_set)\n        return events", ""]}
{"filename": "tt_block.py", "chunked_list": ["\"\"\"TagTracker by Julias Hocking.\n\nBlock class to help with reporting in the TagTracker suite.\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.", "    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.", "    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"\n\nfrom typing import Union\nfrom tt_globals import *  # pylint:disable=unused-wildcard-import,wildcard-import\nfrom tt_trackerday import TrackerDay\nfrom tt_time import VTime\nfrom tt_event import Event\nimport tt_conf as cfg", "from tt_event import Event\nimport tt_conf as cfg\n\n\nclass Block:\n    \"\"\"Class to help with reporting.\n\n    Each instance is a timeblock of duration cfg.BLOCK_DURATION.\n    \"\"\"\n\n    def __init__(self, start_time: Union[VTime, int]) -> None:\n        \"\"\"Initialize. Assumes that start_time is valid.\"\"\"\n        self.start = VTime(start_time)  # in case it's a str not a VTime\n        self.ins_list = []  # Tags of bikes that came in.\n        self.num_ins = 0  # Number of bikes that came in.\n        self.num_ins_regular = 0\n        self.num_ins_oversize = 0\n        self.outs_list = []  # Tags of bikes returned out.\n        self.num_outs = 0  # Number of bikes that went out.\n        self.num_outs_regular = 0\n        self.num_outs_oversize = 0\n        self.here_list = []  # Tags of bikes in valet at end of block.\n        self.num_here = 0  # Number of bikes in valet at end of block.\n        self.num_here_regular = 0\n        self.num_here_oversize = 0\n        self.max_here_list = []  # Tags at time max bikes here during the block\n        self.max_here = 0  # Mxx number of bikes here any time in this block\n        self.max_here_regular = 0\n        self.max_here_oversize = 0", "\n\ndef block_start(atime: Union[int, str]) -> VTime:\n    \"\"\"Return the start time of the block that contains time 'atime'.\n\n    'atime' can be minutes since midnight or HHMM.\n    \"\"\"\n    # Get time in minutes\n    atime = VTime(atime)\n    if atime is None:\n        return \"\"\n    # which block of time does it fall in?\n    block_start_min = (atime.num // cfg.BLOCK_DURATION) * cfg.BLOCK_DURATION\n    return VTime(block_start_min)", "\n\ndef block_end(atime: Union[int, str]) -> VTime:\n    \"\"\"Return the last minute of the timeblock that contains time 'atime'.\n\n    'atime' can be minutes since midnight or HHMM.\n    \"\"\"\n    # Get block start\n    start = block_start(atime)\n    # Calculate block end\n    end = start.num + cfg.BLOCK_DURATION - 1\n    # Return as minutes or HHMM\n    return VTime(end)", "\n\ndef get_timeblock_list(day: TrackerDay, as_of_when: str) -> list[VTime]:\n    \"\"\"Build a list of timeblocks from beg of day until as_of_when.\n\n    Latest block of the day will be the latest timeblock that\n    had any transactions at or before as_of_when.\n    \"\"\"\n\n    as_of_when = as_of_when if as_of_when else \"now\"\n    as_of_when = VTime(as_of_when)\n    # Make list of transactions <= as_of_when\n    transx = [\n        x\n        for x in (list(day.bikes_in.values()) + list(day.bikes_out.values()))\n        if x <= as_of_when\n    ]\n    # Anything?\n    if not transx:\n        return []\n    # Find earliest and latest block of the day\n    min_block_min = block_start(min(transx)).num\n    max_block_min = block_start(max(transx)).num\n    # Create list of timeblocks for the the whole day.\n    timeblocks = []\n    for t in range(\n        min_block_min, max_block_min + cfg.BLOCK_DURATION, cfg.BLOCK_DURATION\n    ):\n        timeblocks.append(VTime(t))\n    return timeblocks", "\n\ndef calc_blocks(\n    day: TrackerDay, as_of_when: str = None\n) -> dict[VTime, object]:\n    \"\"\"Create a dictionary of Blocks {start:Block} for whole day.\"\"\"\n    if not as_of_when:\n        as_of_when = day.latest_event(\"24:00\")\n        if as_of_when < day.closing_time:\n            as_of_when = day.closing_time\n    as_of_when = VTime(as_of_when)\n    ##as_of_when = as_of_when if as_of_when else \"18:00\"\n    # Create dict with all the blocktimes as keys (None as values)\n    blocktimes = get_timeblock_list(day, as_of_when=as_of_when)\n    if not blocktimes:\n        return {}\n    blocks = {}\n    timeblock_list = get_timeblock_list(day, as_of_when=as_of_when)\n    for t in timeblock_list:\n        blocks[t] = Block(t)\n    # latest_time is the end of the latest block that interests us\n    latest_time = block_end(max(timeblock_list))\n    # Load check-ins & check-outs into the blocks to which they belong\n    # This has to happen carefully, in the order in which they occurred,\n    # thus processing as Events rather than reading check_ins & _outs\n    events = Event.calc_events(day, as_of_when=as_of_when)\n    for evtime in sorted(events.keys()):\n        ev: Event\n        ev = events[evtime]\n        bstart = block_start(ev.event_time)\n        blk: Block\n        blk = blocks[bstart]\n        if ev.event_time > latest_time:\n            continue\n        blk.ins_list += ev.bikes_in\n        blk.outs_list += ev.bikes_out\n        # Watch for highwater-mark *within* the block\n        if ev.num_here_total > blk.max_here:\n            blk.max_here = ev.num_here_total\n            blk.max_here_list = ev.bikes_here\n    # For each block, see what bikes are present at the end of the block\n    # Use a set to be able to find the set difference (ie list that's here)\n    here_set = set()\n    for blk in blocks.values():\n        blk.num_ins = len(blk.ins_list)\n        blk.num_outs = len(blk.outs_list)\n        here_set = (here_set | set(blk.ins_list)) - set(blk.outs_list)\n        blk.here_list = here_set\n        blk.num_here = len(here_set)\n    # Calculate the ins/outs and bikes here categorized by regular/oversize.\n    for blk in blocks.values():\n        for tag in blk.ins_list:\n            if tag in day.regular:\n                blk.num_ins_regular += 1\n            elif tag in day.oversize:\n                blk.num_ins_oversize += 1\n        for tag in blk.outs_list:\n            if tag in day.regular:\n                blk.num_outs_regular += 1\n            elif tag in day.oversize:\n                blk.num_outs_oversize += 1\n        for tag in blk.here_list:\n            if tag in day.regular:\n                blk.num_here_regular += 1\n            elif tag in day.oversize:\n                blk.num_here_oversize += 1\n        # Categorize the tag lists & counts at peak within the block\n        for tag in blk.max_here_list:\n            if tag in day.regular:\n                blk.max_here_regular += 1\n            elif tag in day.oversize:\n                blk.max_here_oversize += 1\n\n    return blocks", ""]}
{"filename": "tt_tag_inv.py", "chunked_list": ["\"\"\"All tags overview.\n\nSymbols for:\n- unknown (like, a missing member)  '  '\n- available                         '--'\n- bike in                           '<<'\n- bike out                          '>>'\n- retired                           ' \u25cf'\n\n\"\"\"", "\n\"\"\"\nfrom tt_globals import *\nimport tt_printer as pr\nfrom tt_time import VTime\nfrom tt_tag import TagID\nfrom tt_realtag import Stay\nfrom tt_trackerday import TrackerDay\nimport tt_conf as cfg\nimport tt_util as ut", "import tt_conf as cfg\nimport tt_util as ut\n\n\ndef tag_inventory_matrix(day: TrackerDay, as_of_when: str = \"now\") -> None:\n    \"\"\"Print a matrix of status of all known tags.\n\n    This reads these variables from config, each is a symbol/style tuple:\n        TAG_INV_UNKNOWN\n        TAG_INV_AVAILABLE\n        TAG_INV_BIKE_IN\n        TAG_INV_BIKE_OUT\n        TAG_INV_RETIRED\n\n    \"\"\"\n    tag_unknown = pr.text_style(cfg.TAG_INV_UNKNOWN[0],style=cfg.TAG_INV_UNKNOWN[1])\n    tag_available = pr.text_style(cfg.TAG_INV_AVAILABLE[0],style=cfg.TAG_INV_AVAILABLE[1])\n    tag_bike_in = pr.text_style(cfg.TAG_INV_BIKE_IN[0],style=cfg.TAG_INV_BIKE_IN[1])\n    tag_bike_out = pr.text_style(cfg.TAG_INV_BIKE_OUT[0],style=cfg.TAG_INV_BIKE_OUT[1])\n    tag_retired = pr.text_style(cfg.TAG_INV_RETIRED[0],style=cfg.TAG_INV_RETIRED[1])\n\n    as_of_when = VTime(as_of_when)\n    pr.iprint()\n    pr.iprint(f\"Tags status {as_of_when.as_at}\", style=cfg.TITLE_STYLE)\n    pr.iprint(\n        f\"Key: '{tag_available}'=Available; '{tag_bike_in}'=Bike In; \"\n        f\"'{tag_bike_out}'=Bike Out; '{tag_retired}'=Retired\",\n        style=cfg.NORMAL_STYLE,\n    )\n    pr.iprint()\n    max_tag_num = 0\n    prefixes = set()\n    for tag in day.regular | day.oversize:\n        if tag.number > max_tag_num:\n            max_tag_num = tag.number\n        prefixes.add(tag.prefix)\n    pr.iprint(f\"{' ':3s} \", style=cfg.HIGHLIGHT_STYLE,end=\"\")\n    for i in range(0, max_tag_num + 1):\n        pr.iprint(f\" {i:02d}\", style=cfg.HIGHLIGHT_STYLE,end=\"\")\n    pr.iprint()\n    for prefix in sorted(prefixes):\n        pr.iprint(f\"{prefix:3s} \", style=cfg.HIGHLIGHT_STYLE,end=\"\")\n        for i in range(0, max_tag_num + 1):\n            this_tag = Stay(f\"{prefix}{i}\", day, as_of_when)\n            if not this_tag or not this_tag.state:\n                s = tag_unknown\n            elif this_tag.state == USABLE:\n                s = tag_available\n            elif this_tag.state == BIKE_IN:\n                s = tag_bike_in\n            elif this_tag.state == BIKE_OUT:\n                s = tag_bike_out\n            elif this_tag.state == RETIRED:\n                s = tag_retired\n            else:\n                s = pr.text_style(\" ?\",style=cfg.ERROR_STYLE)\n            pr.iprint(f\" {s}\", end=\"\")\n        pr.iprint()", "\ndef colours_report(day: TrackerDay) -> None:\n    \"\"\"List colours in use.\"\"\"\n    type_names = {\n        UNKNOWN: \"None\",\n        REGULAR: \"Regular\",\n        OVERSIZE: \"Oversize\",\n        MIXED: \"Mixed\",\n    }\n\n    # Make a dict of the colour letters that's all lowercase\n    colours = {k.lower(): v for k, v in day.colour_letters.items()}\n    # Dict of bike types for tags: UNKNOWN, OVERSIZE, REGULAR or MIXED\n    tag_type = dict(\n        zip(list(day.colour_letters.keys()), [UNKNOWN for _ in range(0, 100)])\n    )\n    # Dictionary of how many tags are of each colour.\n    tag_count = dict(\n        zip(list(day.colour_letters.keys()), [0 for _ in range(0, 100)])\n    )\n    # Count and categorize the tags (all available for use)\n    for tag in day.all_tags():\n        code = tag.colour.lower()\n        if code not in colours:\n            ut.squawk(f\"bad colour for {tag}: '{code}' in colours_report()\")\n            continue\n        # Tag type\n        btype = REGULAR if tag in day.regular else OVERSIZE\n        if tag_type[code] == UNKNOWN:\n            tag_type[code] = btype\n        elif tag_type[code] != btype:\n            tag_type[code] = MIXED\n        # Tag count\n        tag_count[code] += 1\n\n    pr.iprint()\n    pr.iprint(\"Code Colour   Bike type  Count\", style=cfg.SUBTITLE_STYLE)\n    for code in sorted(colours):\n        name = colours[code].title()\n        code_str = code.upper() if TagID.uc() else code\n        pr.iprint(\n            f\" {code_str:>2}  {name:8} {type_names[tag_type[code]]:8}  \"\n            f\"{tag_count[code]:4d} tags\"\n        )", "\n\ndef retired_report(day: TrackerDay) -> None:\n    \"\"\"List retired tags.\"\"\"\n    pr.iprint()\n    pr.iprint(\"Retired tags\", style=cfg.SUBTITLE_STYLE)\n    if not day.retired:\n        pr.iprint(\"--no retired tags--\")\n        return\n    pr.iprint(\n        \" \".join(\n            [\n                x.cased\n                for sub in ut.taglists_by_prefix(day.retired)\n                for x in sub\n            ]\n        )\n    )", "\n\ndef tags_config_report(day: TrackerDay,args:list) -> None:\n    \"\"\"Report the current tags configuration.\"\"\"\n    as_of_when = (args + [\"now\"])[0]\n    as_of_when = VTime(as_of_when)\n    if not as_of_when:\n        pr.iprint(\n            f\"Unrecognized time {as_of_when.original}\", style=cfg.WARNING_STYLE\n        )\n        return\n    pr.iprint()\n    pr.iprint(\"Current tags configuration\", style=cfg.TITLE_STYLE)\n    colours_report(day)\n    retired_report(day)\n    tag_inventory_matrix(day, as_of_when)", "\n"]}
{"filename": "tt_dbutil.py", "chunked_list": ["\"\"\"Database utilities for reporting from TagTracker database.\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,", "\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"", "\n\"\"\"\n\nimport sqlite3\nimport sys\nimport os\nfrom typing import Tuple, Iterable\nfrom tt_trackerday import TrackerDay\nfrom tt_tag import TagID\nfrom tt_time import VTime", "from tt_tag import TagID\nfrom tt_time import VTime\n\n\nclass VisitRow:\n    def __init__(self):\n        self.tag = TagID()\n        self.time_in = VTime()\n        self.time_out = VTime()\n        self.duration = VTime()\n        self.checked_out = False", "\n\nclass DayRow:\n    def __init__(self):\n        self.date = \"\"\n        self.parked_regular = 0\n        self.parked_oversize = 0\n        self.parked_total = 0\n        self.leftover = 0\n        self.max_reg = 0\n        self.time_max_reg = 0\n        self.max_over = 0\n        self.time_max_over = VTime(\"\")\n        self.max_total = 0\n        self.time_max_total = VTime(\"\")\n        self.time_open = VTime(\"\")\n        self.time_closed = VTime(\"\")\n        self.weekday = None\n        self.precip_mm = None\n        self.temp = None\n        self.sunset = VTime(\"\")\n        self.event = \"\"\n        self.event_prox_km = None\n        self.registrations = None\n        self.notes = \"\"\n        self.batch = \"\"\n\n    def set_row(self, labels: list[str], vals: Iterable):\n        for i, name in enumerate(labels):\n            vars(self)[name] = vals[i]", "\n\nclass DBRow:\n    \"\"\"A generic class for holding database rows.\n\n    In use, pylint will not be aware of the names of the attributes\n    since they are created dynamically.\n    \"\"\"\n\n    def __init__(self, labels: list[str], vals: Iterable):\n        for i, name in enumerate(labels):\n            vars(self)[name] = vals[i]", "\n\ndef db_fetch(\n    ttdb: sqlite3.Connection,\n    select_statement: str,\n    col_names: list[str] = None,\n) -> list[DBRow]:\n    \"\"\"Fetch a select statement into a list of database rows.\n\n    The col_names dict converts the database column names into\n    other names. E.g. {'fred':'derf'} will convert any column\n    returned from the SELECT that is called 'fred' into a\n    DBRow attribute called 'derf'.  Not sure what happens when\n    the column name is something like 'count(tag)'\n\n    \"\"\"\n\n    def flatten(raw_column_name: str) -> str:\n        \"\"\"Convert str into a name usable as a class attribute.\"\"\"\n\n        usable: str = \"\".join(\n            [c for c in raw_column_name.lower() if c.isalnum() or c == \"_\"]\n        )\n        if usable and usable[0].isdigit():\n            usable = f\"_{usable}\"\n        return usable\n\n    curs = ttdb.cursor()\n    raw_rows = curs.execute(select_statement).fetchall()\n    # Make sure we have a list of the target names for the columns(attributes)\n    if not col_names:\n        col_names = [\n            flatten(description[0]) for description in curs.description\n        ]\n\n    rows = [DBRow(col_names, r) for r in raw_rows]\n    return rows", "\n\ndef db_latest(ttdb: sqlite3.Connection) -> str:\n    \"\"\"Return str describing latest db update date/time.\"\"\"\n\n    day_latest = db_fetch(ttdb, \"select max(batch) last from day;\")[0].last\n    visit_latest = db_fetch(ttdb, \"select max(batch) last from visit;\")[0].last\n    return f\"Last DB updates: DAY={day_latest} VISIT={visit_latest}\"\n\n\ndef db2day(ttdb: sqlite3.Connection, whatdate: str) -> TrackerDay:\n    \"\"\"Create one day's TrackerDay from the database.\"\"\"\n    # Do we have info about the day?  Need its open/close times\n    curs = ttdb.cursor()\n    rows = curs.execute(\n        \"select time_open,time_closed from day limit 1\"\n    ).fetchall()\n    if not rows:\n        return None\n    day = TrackerDay()\n    day.date = whatdate\n    day.opening_time = rows[0][0]\n    day.closing_time = rows[0][1]\n    # Fetch any tags checked in or out\n    curs = ttdb.cursor()\n    rows = curs.execute(\n        \"select tag,time_in,time_out,type from visit \"\n        f\"where date = '{whatdate}' \"\n        \"order by time_in desc;\"\n    ).fetchall()\n    oversize = set()\n    regular = set()\n    for row in rows:\n        tag = TagID(row[0])\n        time_in = VTime(row[1])\n        time_out = VTime(row[2])\n\n        still_in = not time_out\n        if not tag or not time_in:\n            continue\n        day.bikes_in[tag] = time_in\n        if time_out and not still_in:\n            day.bikes_out[tag] = time_out\n        # Tag type (regular/oversize)\n        tag_type = row[3] if row[3] else day.guess_tag_type(tag)\n        if tag_type == \"R\":\n            regular.add(tag)\n        elif tag_type == \"O\":\n            oversize.add(tag)\n    # Set the tag lists\n    day.regular = frozenset(regular)\n    day.oversize = frozenset(oversize)\n    # Fake up a colour dictionary\n    day.make_fake_colour_dict()\n    return day", "\n\ndef db2day(ttdb: sqlite3.Connection, whatdate: str) -> TrackerDay:\n    \"\"\"Create one day's TrackerDay from the database.\"\"\"\n    # Do we have info about the day?  Need its open/close times\n    curs = ttdb.cursor()\n    rows = curs.execute(\n        \"select time_open,time_closed from day limit 1\"\n    ).fetchall()\n    if not rows:\n        return None\n    day = TrackerDay()\n    day.date = whatdate\n    day.opening_time = rows[0][0]\n    day.closing_time = rows[0][1]\n    # Fetch any tags checked in or out\n    curs = ttdb.cursor()\n    rows = curs.execute(\n        \"select tag,time_in,time_out,type from visit \"\n        f\"where date = '{whatdate}' \"\n        \"order by time_in desc;\"\n    ).fetchall()\n    oversize = set()\n    regular = set()\n    for row in rows:\n        tag = TagID(row[0])\n        time_in = VTime(row[1])\n        time_out = VTime(row[2])\n\n        still_in = not time_out\n        if not tag or not time_in:\n            continue\n        day.bikes_in[tag] = time_in\n        if time_out and not still_in:\n            day.bikes_out[tag] = time_out\n        # Tag type (regular/oversize)\n        tag_type = row[3] if row[3] else day.guess_tag_type(tag)\n        if tag_type == \"R\":\n            regular.add(tag)\n        elif tag_type == \"O\":\n            oversize.add(tag)\n    # Set the tag lists\n    day.regular = frozenset(regular)\n    day.oversize = frozenset(oversize)\n    # Fake up a colour dictionary\n    day.make_fake_colour_dict()\n    return day", "\n\ndef db_connect(db_file, must_exist: bool = True) -> sqlite3.Connection:\n    \"\"\"Connect to (existing) SQLite database.\n\n    Flag must_exist indicates whether:\n        T: must exist; this fails if no DB [default]\n        F: database will be created if doesn't exist\n        This will create a new .db database file if none yet exists at the named\n    path.\"\"\"\n\n    if not os.path.exists(db_file):\n        print(f\"Database file {db_file} not found\", file=sys.stderr)\n        return None\n\n    try:\n        connection = sqlite3.connect(db_file)\n        ##print(sqlite3.version)\n    except sqlite3.Error as sqlite_err:\n        print(\n            \"sqlite ERROR in db_connect() -- \",\n            sqlite_err,\n            file=sys.stderr,\n        )\n        return None\n    return connection", "\n\ndef db_commit(db: sqlite3.Connection):\n    \"\"\"Just a database commit.  Only here for completeness.\"\"\"\n    db.commit()\n\n\ndef db_update(\n    db: sqlite3.Connection, update_sql: str, commit: bool = True\n) -> bool:\n    \"\"\"Execute a SQL UPDATE statement.  T/F indicates success.\n\n    (This could be any SQL statement, but the error checking and\n    return is based on assumption it's an UPDATE)\n    \"\"\"\n    try:\n        db.cursor().execute(update_sql)\n        if commit:\n            db.commit()\n    except (sqlite3.OperationalError, sqlite3.IntegrityError) as e:\n        print(f\"SQL error '{e}' for '{update_sql}'\", file=sys.stdout)\n        return False\n    return True", ""]}
{"filename": "tt_realtag.py", "chunked_list": ["\"\"\"This is the RealTag class\n\n\n    A TagID is the name of a tag; it might be a correct tag name or not.\n    It is a type of string, and its representation is canonical\n    tag representation (e.g. \"wa1\").  TagIDs with identical representation\n    are considered equal, even though the 'original' attribute\n    might not be the same.\n\n    A RealTag (AnyTag?) is a TagID about which something might be known", "\n    A RealTag (AnyTag?) is a TagID about which something might be known\n    from the tags config info. Its attributes identify whether its type\n    (OVERSIZE, REGULAR) and its config-based state (RETIRED, USABLE).\n\n\"\"\"\nfrom tt_globals import *\nfrom tt_tag import TagID\nfrom tt_time import VTime\nfrom tt_trackerday import TrackerDay", "from tt_time import VTime\nfrom tt_trackerday import TrackerDay\n\nclass RealTag:\n    \"\"\"A tag with attributes that reflect info in the Tags Config (only).\n\n    Arguments:\n        tag_string: a string that may or may not represent a valid TagID\n        config: a TrackerDay with (presumably) tags config info in it.\n            Only the tags config portion of the TrackerDay is used\n            (.retired, .oversize, .regular sets of TagIDs)\n\n    Attributes:\n        tagid: a TagID (or \"\" if given a string that does not look like a tagid)\n        type: None, OVERSIZE, REGULAR\n        state: None, USABLE, RETIRED\n\n    \"\"\"\n\n    def __init__(self, tag_string: MaybeTag = \"\", config: TrackerDay = None):\n        self.type = None\n        self.state = None\n        self.tag = TagID(tag_string)\n        if not self.tag or not config:\n            self.tag = \"\"\n            return\n        assert isinstance(\n            config, TrackerDay\n        ), f\"bad config in call to RealTag({tag_string})\"\n        if self.tag in config.regular:\n            self.type = REGULAR\n        elif self.tag in config.oversize:\n            self.type = OVERSIZE\n        if self.tag in config.retired:\n            self.state = RETIRED\n        elif self.tag in (config.oversize | config.regular):\n            self.state = USABLE", "\n\nclass Stay(RealTag):\n    \"\"\"A tag's use and condition at a particular time.\n\n    Arguments:\n        tag_string: a string that may or may not represent a valid TagID\n        config: a TrackerDay with (presumably) tags config info in it.\n            Only the tags config portion of the TrackerDay is used\n            (.retired, .oversize, .regular sets of TagIDs)\n\n    Attributes:\n        tagid: a TagID (or \"\" if given a string that does not look like a tagid)\n        type: None, OVERSIZE, REGULAR\n        state: None, USABLE, BIKE_IN, BIKE_OUT, RETIRED\n    \"\"\"\n\n    def __init__(\n        self,\n        tag_string: MaybeTag = \"\",\n        day: TrackerDay = None,\n        as_of_when: MaybeTime = \"now\",\n    ):\n        \"\"\"Create a Stay (ie a tag with activity)\"\"\"\n        super().__init__(tag_string, day)\n        as_of_when = VTime(as_of_when)\n        self.as_of_when = as_of_when\n        self.time_in = VTime(\"\")\n        self.time_out = VTime(\"\")\n        self.duration = 0\n        if not self.tag or not day:\n            return\n        if (\n            self.tag in day.bikes_out\n            and day.bikes_out[self.tag] <= self.as_of_when\n        ):\n            # Bike came and went before as_of_when\n            self.state = BIKE_OUT\n            self.time_out = day.bikes_out[self.tag]\n            self.time_in = day.bikes_in[self.tag]\n            self.duration = (\n                min(as_of_when.num, self.time_out.num) - self.time_in.num\n            )\n        elif (\n            self.tag in day.bikes_in\n            and day.bikes_in[self.tag] <= self.as_of_when\n        ):\n            # Bike came in before as_of_when\n            self.state = BIKE_IN\n            self.time_in = day.bikes_in[self.tag]\n            self.duration = as_of_when.num - self.time_in.num\n\n    @property\n    def still_here(self):\n        \"\"\"Get whether a tag bike is currently in the valet.\"\"\"\n        return self.state == BIKE_IN\n\n    @staticmethod\n    def dump_visits(visits: dict[\"Stay\"]) -> None:\n        \"\"\"Dump whole visits dictionary.\"\"\"\n        print(\"\\nvisits\\n\")\n        for v in visits.values():\n            print(v.dump())\n\n    @staticmethod\n    def calc_stays(\n        day: TrackerDay, as_of_when: MaybeTime = \"now\"\n    ) -> dict[TagID, \"Stay\"]:\n        \"\"\"Create a dict of stays keyed by tag as of as_of_when.\n\n        If as_of_when is not given, then this will use the current time.\n\n        If there are bikes that are not checked out, then this will\n        consider their check-out time to be:\n            earlier of:\n                current time\n                closing time if there is one, else time of latest event of the day.\n        \"\"\"\n        as_of_when = VTime(as_of_when)\n\n        # If a bike isn't checked out or its checkout is after the requested\n        # time, then use as_of_when as its checkout time?\n        stays = {}\n        for tag, time_in in day.bikes_in.items():\n            if time_in > as_of_when:\n                continue\n            this_stay = Stay(tag,day,as_of_when=as_of_when)\n            stays[tag] = this_stay\n        return stays", "\n"]}
{"filename": "csv2tracker.py", "chunked_list": ["\"\"\"Convert spreadsheet csv file to tagtracker format.\n\nThis is a standalone script to convert one csv file into one\ntagracker *.dat file.\n\nThis rejects any check-ins without check-outs... which makes it weird if\nconverting a partial-day's data.  Need to think about that.\n\"\"\"\n\nimport datetime", "\nimport datetime\nimport sys\nimport os\nimport re\nimport random\n##from typing import Union\nfrom tt_globals import *\nimport tt_util as ut\nfrom typing import Tuple", "import tt_util as ut\nfrom typing import Tuple\nfrom tt_tag import TagID\nfrom tt_time import VTime\n\n\nHEADER_VALET_DATE = \"Valet date:\"\nHEADER_VALET_OPENS = \"Valet opens:\"\nHEADER_VALET_CLOSES = \"Valet closes:\"\n", "HEADER_VALET_CLOSES = \"Valet closes:\"\n\n# If set, RANDOMIZE_TIMES will randomize times within their block.\n# To keep things crazy simple, this assumes blocks are 30 minutes.\n# This will also then make a second pass and arbitrarily make any\n# stays that are therefore 0-length or longer to a random length between\n# 10 - 30 minutes.\nRANDOMIZE_TIMES = False\nif RANDOMIZE_TIMES:\n    print( \"WARNING: this is bogifying times slightly for demo purposes\")", "if RANDOMIZE_TIMES:\n    print( \"WARNING: this is bogifying times slightly for demo purposes\")\n\nWARNING_MSG = \"Warning\"\nERROR_MSG = \"Error\"\nINFO_MSG = \"Info\"\n# Record check ins/outs as this many minutes into the time block\nBIKE_IN_OFFSET = 14\nBIKE_OUT_OFFSET = 16\n# Header lines to put in the datafile.", "BIKE_OUT_OFFSET = 16\n# Header lines to put in the datafile.\nBIKE_IN_HEADER = 'Bikes checked in / tags out:'\nBIKE_OUT_HEADER = 'Bikes checked out / tags in:'\n\nmessages = {}   # key=filename, value = list of messages\n\ndef message( filename:str, msg_text:str, severity:str=INFO_MSG ) -> None:\n    \"\"\"Print (& save) warning for given filename.\"\"\"\n    if filename not in messages:\n        messages[filename] = []\n    full_msg = f\"{severity}: {msg_text.strip()} in file '{filename}'\"\n    print(full_msg)\n    if severity in [WARNING_MSG,ERROR_MSG]:\n        messages[filename].append(full_msg)", "\ndef isadate(maybe:str ) -> str:\n    \"\"\"Return maybe as a YYYY-MM-DD date string if it looks like a date.\"\"\"\n    if re.match(r\"^ *[12][0-9][0-9][0-9]-[01][0-9]-[0-3][0-9] *$\", maybe):\n        return maybe.strip()\n    else:\n        return \"\"\n\n\n\ndef readafile( file:str ) -> Tuple[dict,dict]:\n    \"\"\"Read one file's tags, return as check_ins, check_outs list.\"\"\"\n    # Read one file.\n    inout = \"\"\n    check_ins = {}\n    check_outs = {}\n    lnum = 0\n    # File there?\n    if not os.path.exists(file):\n        message(file, \"not found\", ERROR_MSG)\n        return [\"\",dict(), dict()]\n    # Open & read the file.\n    with open(file,\"r\",encoding='utf-8') as f:\n        for line in f:\n            lnum += 1\n            line = line.strip()\n            chunks = line.split(\",\")\n            # Weirdness.  If it's today's tracking sheet, it seems to\n            # include an extra blank column at the start.  So....\n            # ... throw away a blank first column\n            if chunks and not chunks[0]:\n                chunks = chunks[1:]\n            if not chunks:\n                continue\n            # Is this a \"check-in\" or \"check-out\" header line?\n            if re.match(r\"^Tag given out\",chunks[0]):\n                inout = BIKE_IN\n                continue\n            elif re.match(r\"^Tag returned\",chunks[0]):\n                inout = BIKE_OUT\n                continue\n            # Ignore non-date junk at top of the file\n            if not inout:\n                continue\n            # This line is a line of tags in a block (presumably).\n            # Timeblocks might start in col 1 or col 2. (!!!!!)\n            if not chunks[0]:\n                chunks = chunks[1:]\n            if not chunks:\n                continue\n            if not (block_start := VTime(chunks[0])):\n                message( file, f\"ignoring line {lnum}: '{line}\", WARNING_MSG)\n                continue\n            # Looks like a legit line. Read the tags.\n            # (The two cells after start time are \"-\" and end time.  Ignore.)\n            for cell in chunks[3:]:\n                if not cell:\n                    continue    # Ignore empty cells\n                if not (tag := TagID(cell)):\n                    # Warn about poorly formed maybe-tags\n                    message(file,f\"Unrecognized tag '{cell}' in line {lnum}\",\n                            WARNING_MSG)\n                    continue\n                # A legit tag at a legit time.\n                if RANDOMIZE_TIMES:\n                    block_begin = ut.time_int(block_start)\n                    check_time = random.randint(block_begin,block_begin+29)\n                else:\n                    offset = BIKE_IN_OFFSET if inout == BIKE_IN else BIKE_OUT_OFFSET\n                    check_time = (ut.time_int(block_start)\n                            + offset)\n                if inout == BIKE_IN:\n                    check_ins[tag] = VTime(check_time)\n                elif inout == BIKE_OUT:\n                    check_outs[tag] = VTime(check_time)\n    return (dict(check_ins), dict(check_outs))", "\n\ndef readafile( file:str ) -> Tuple[dict,dict]:\n    \"\"\"Read one file's tags, return as check_ins, check_outs list.\"\"\"\n    # Read one file.\n    inout = \"\"\n    check_ins = {}\n    check_outs = {}\n    lnum = 0\n    # File there?\n    if not os.path.exists(file):\n        message(file, \"not found\", ERROR_MSG)\n        return [\"\",dict(), dict()]\n    # Open & read the file.\n    with open(file,\"r\",encoding='utf-8') as f:\n        for line in f:\n            lnum += 1\n            line = line.strip()\n            chunks = line.split(\",\")\n            # Weirdness.  If it's today's tracking sheet, it seems to\n            # include an extra blank column at the start.  So....\n            # ... throw away a blank first column\n            if chunks and not chunks[0]:\n                chunks = chunks[1:]\n            if not chunks:\n                continue\n            # Is this a \"check-in\" or \"check-out\" header line?\n            if re.match(r\"^Tag given out\",chunks[0]):\n                inout = BIKE_IN\n                continue\n            elif re.match(r\"^Tag returned\",chunks[0]):\n                inout = BIKE_OUT\n                continue\n            # Ignore non-date junk at top of the file\n            if not inout:\n                continue\n            # This line is a line of tags in a block (presumably).\n            # Timeblocks might start in col 1 or col 2. (!!!!!)\n            if not chunks[0]:\n                chunks = chunks[1:]\n            if not chunks:\n                continue\n            if not (block_start := VTime(chunks[0])):\n                message( file, f\"ignoring line {lnum}: '{line}\", WARNING_MSG)\n                continue\n            # Looks like a legit line. Read the tags.\n            # (The two cells after start time are \"-\" and end time.  Ignore.)\n            for cell in chunks[3:]:\n                if not cell:\n                    continue    # Ignore empty cells\n                if not (tag := TagID(cell)):\n                    # Warn about poorly formed maybe-tags\n                    message(file,f\"Unrecognized tag '{cell}' in line {lnum}\",\n                            WARNING_MSG)\n                    continue\n                # A legit tag at a legit time.\n                if RANDOMIZE_TIMES:\n                    block_begin = ut.time_int(block_start)\n                    check_time = random.randint(block_begin,block_begin+29)\n                else:\n                    offset = BIKE_IN_OFFSET if inout == BIKE_IN else BIKE_OUT_OFFSET\n                    check_time = (ut.time_int(block_start)\n                            + offset)\n                if inout == BIKE_IN:\n                    check_ins[tag] = VTime(check_time)\n                elif inout == BIKE_OUT:\n                    check_outs[tag] = VTime(check_time)\n    return (dict(check_ins), dict(check_outs))", "\ndef clean(file:str, check_ins:dict, check_outs:dict) -> None:\n    \"\"\"Remove bad tag records from the check_in/out dicts.\n\n    Uses 'file' only as an arg to the messages function.\n    \"\"\"\n    # Look for unmatched tags in check_ins\n    ##bad_tags = []\n    ##for tag in check_ins:\n    ##    if tag not in check_outs:\n    ##        message( file,f\"Unmatched bike check-in {tag} (retained) \", WARNING_MSG)\n    ##        #bad_tags.append(tag)\n    ##for tag in bad_tags:\n    ##    check_ins.pop(tag)\n    # Look for checkouts without checkins\n    bad_tags = []\n    for tag in check_outs:\n        if tag not in check_ins:\n            message( file,f\"Unmatched bike check-out {tag} (discarded) \",\n                    WARNING_MSG)\n            bad_tags.append(tag)\n    for tag in bad_tags:\n        check_outs.pop(tag)\n    # Look for checkins later than checkouts\n    bad_tags = []\n    for tag in check_outs:\n        if RANDOMIZE_TIMES:\n            if check_outs[tag] <= check_ins[tag]:\n                check_outs[tag] = ut.time_str(\n                    ut.time_int(check_ins[tag])\n                    + random.randint(10,30))\n        elif check_outs[tag] < check_ins[tag]:\n            message( file,f\"Check out before check in for {tag} (discarded) \",\n                    WARNING_MSG)\n            bad_tags.append(tag)\n    for tag in bad_tags:\n        check_outs.pop(tag)\n        check_ins.pop(tag)", "\ndef write_file(oldf:str, newf:str, filedate:str, the_hours:tuple,\n        check_ins:dict, check_outs:dict ) ->None:\n    \"\"\"Write the records to a tagtracker-complians file.\"\"\"\n    with open(newf , 'w',encoding='utf-8') as f: # write stored lines to file\n        f.write(f\"# {filedate}\\n\")\n        timestamp = datetime.datetime.today().strftime(\"%Y-%m-%d %H:%M\")\n        f.write(f\"# Converted from {oldf} on {timestamp}\\n\")\n        if  oldf  in messages and len(messages[oldf]):\n            f.write(\"# These issues detected during conversion:\\n\")\n            for msg in messages[ oldf ]:\n                f.write(f\"# {msg}\\n\")\n        f.write(f\"{HEADER_VALET_DATE} {filedate}\\n\")\n        f.write(f\"{HEADER_VALET_OPENS} {the_hours[0]}\\n\")\n        f.write(f\"{HEADER_VALET_CLOSES} {the_hours[1]}\\n\")\n        f.write(f\"{BIKE_IN_HEADER}\\n\")\n        for tag,time in check_ins.items():\n            f.write(f\"{tag},{time}\\n\")\n        f.write(f\"{BIKE_OUT_HEADER}\\n\")\n        for tag,time in check_outs.items():\n            f.write(f\"{tag},{time}\\n\")", "\ndef filename_to_date(filename:str) -> str:\n    \"\"\"Convert filename to a string of the day *before* the filename.\"\"\"\n    # Assumes filenames are YYYY-MM-DD.csv\n\n    bits = re.search(r\"(2023-[0-9][0-9]-[0-9][0-9])\",filename)\n    if not bits:\n        return \"\"\n    date_string = bits.group(1)\n    this_day = datetime.datetime.strptime(date_string, '%Y-%m-%d')\n    prev_day = this_day - datetime.timedelta(1)\n    return datetime.datetime.strftime(prev_day, '%Y-%m-%d')", "\ndef valet_hours(the_date:str) -> Tuple[VTime,VTime]:\n    \"\"\"Report what time the valet opened this the_date.\"\"\"\n    day = datetime.datetime.strptime(the_date,\"%Y-%m-%d\")\n    day_of_week = datetime.datetime.weekday(day) # 0..6\n    spring = {\n        0: (\"10:00\",\"17:00\"),   # sunday\n        1: (\"07:30\", \"18:00\"),\n        2: (\"07:30\", \"18:00\"),\n        3: (\"07:30\", \"18:00\"),\n        4: (\"07:30\", \"18:00\"),\n        5: (\"07:30\", \"20:00\"),\n        6: (\"10:00\", \"18:00\"),\n    }\n    summer = {  # summer hours start May 1\n        0: (\"10:00\",\"17:00\"),   # sunday\n        1: (\"07:30\", \"18:00\"),\n        2: (\"07:30\", \"18:00\"),\n        3: (\"07:30\", \"20:00\"),\n        4: (\"07:30\", \"20:00\"),\n        5: (\"07:30\", \"22:00\"),\n        6: (\"10:00\", \"12:00\"),\n    }\n    if the_date == \"2023-06-11\":    # Unknown special day\n        return (\"10:00\",\"18:30\")\n    elif the_date == \"2023-05-22\": # Victoria Day\n        return (\"09:00\",\"17:00\")\n    elif the_date >= \"2023-05-01\":\n        return summer[day_of_week]\n    elif the_date >= \"2023-03-17\":   # opening day\n        return spring[day_of_week]\n    else:\n        return (\"\",\"\")", "\nin_files = sys.argv[1:]\nfor oldfile in in_files:\n    # Data's date is the day before the day represented by the filename\n    # (I mean really.... !!!!????)\n    date = filename_to_date(oldfile)\n    if not date:\n        print(f\"Error: can not determine date from filename {oldfile}\")\n        continue\n    hours = valet_hours(date)\n    if not hours[0]:\n        print(f\"Error: have no hours known for {date}\")\n    print( f\"\\nReading file {oldfile}, data for {date}...\")\n    (bikes_in, bikes_out) = readafile(oldfile)\n    # Check for errors\n    print(\"   ...checking for errors...\")\n    clean(oldfile, bikes_in, bikes_out)\n    # Write the file\n    newfile = f\"cityhall_{date}.dat\"\n    print(f\"   ...writing tags to {newfile}\")\n    write_file(oldfile, newfile, date, hours, bikes_in, bikes_out)\n    print(\"   ...done\")", ""]}
{"filename": "tt_colours.py", "chunked_list": ["\"\"\"TagTracker by Julias Hocking.\n\nProvides colorama-based colour codes for TagTracker program.  Exposes:\n    Fore, Back, Style objects which either are loaded with colorama\n        values or blanks (if colorama was not available).\n    HAVE_COLOURS which is T/F if colorama colours were loaded.\n    STYLE dictionary\n    Style names (e.g. HIGHLIGHT_STYLE)\n\nCopyright (C) 2023 Julias Hocking", "\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of", "    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"\n\n\nclass _ForeClass:\n    \"\"\"An empty mockup of colorama's Fore class.\"\"\"\n\n    def __init__(self):\n        \"\"\"Set the colorama attributes.\"\"\"\n        self.BLACK = \"\"\n        self.BLUE = \"\"\n        self.CYAN = \"\"\n        self.GREEN = \"\"\n        self.LIGHTBLACK_EX = \"\"\n        self.LIGHTBLUE_EX = \"\"\n        self.LIGHTCYAN_EX = \"\"\n        self.LIGHTGREEN_EX = \"\"\n        self.LIGHTMAGENTA_EX = \"\"\n        self.LIGHTRED_EX = \"\"\n        self.LIGHTWHITE_EX = \"\"\n        self.LIGHTYELLOW_EX = \"\"\n        self.MAGENTA = \"\"\n        self.RED = \"\"\n        self.RESET = \"\"\n        self.WHITE = \"\"\n        self.YELLOW = \"\"", "\n\nclass _ForeClass:\n    \"\"\"An empty mockup of colorama's Fore class.\"\"\"\n\n    def __init__(self):\n        \"\"\"Set the colorama attributes.\"\"\"\n        self.BLACK = \"\"\n        self.BLUE = \"\"\n        self.CYAN = \"\"\n        self.GREEN = \"\"\n        self.LIGHTBLACK_EX = \"\"\n        self.LIGHTBLUE_EX = \"\"\n        self.LIGHTCYAN_EX = \"\"\n        self.LIGHTGREEN_EX = \"\"\n        self.LIGHTMAGENTA_EX = \"\"\n        self.LIGHTRED_EX = \"\"\n        self.LIGHTWHITE_EX = \"\"\n        self.LIGHTYELLOW_EX = \"\"\n        self.MAGENTA = \"\"\n        self.RED = \"\"\n        self.RESET = \"\"\n        self.WHITE = \"\"\n        self.YELLOW = \"\"", "\n\nclass _BackClass:\n    \"\"\"An empty mockup of colorama's Back class.\"\"\"\n\n    def __init__(self):\n        \"\"\"Set the colorama attributes.\"\"\"\n        self.BLACK = \"\"\n        self.BLUE = \"\"\n        self.CYAN = \"\"\n        self.GREEN = \"\"\n        self.LIGHTBLACK_EX = \"\"\n        self.LIGHTBLUE_EX = \"\"\n        self.LIGHTCYAN_EX = \"\"\n        self.LIGHTGREEN_EX = \"\"\n        self.LIGHTMAGENTA_EX = \"\"\n        self.LIGHTRED_EX = \"\"\n        self.LIGHTWHITE_EX = \"\"\n        self.LIGHTYELLOW_EX = \"\"\n        self.MAGENTA = \"\"\n        self.RED = \"\"\n        self.RESET = \"\"\n        self.WHITE = \"\"\n        self.YELLOW = \"\"", "\n\nclass _StyleClass:\n    \"\"\"An empty mockup of colorama's Style class.\"\"\"\n\n    def __init__(self):\n        \"\"\"Set the colorama attributes.\"\"\"\n        self.BRIGHT = \"\"\n        self.DIM = \"\"\n        self.NORMAL = \"\"\n        self.RESET_ALL = \"\"", "\n\n# If use colour, try to import colorama library\nHAVE_COLOURS = True\ntry:\n    import colorama\n\n    # from colorama import Style,Fore,Back\nexcept ImportError:\n    print(\"No colouring available (colorama module not installed)\")\n    HAVE_COLOURS = False", "\n# Set Fore, Back, Style objects - either from colorama or as blank\nif HAVE_COLOURS:\n    Fore = colorama.Fore\n    Back = colorama.Back\n    Style = colorama.Style\nelse:\n    Fore = _ForeClass()\n    Back = _BackClass()\n    Style = _StyleClass()", ""]}
{"filename": "tt_base_conf.py", "chunked_list": ["\"\"\"Config for TagTracker by Julias Hocking.\n\nConfiguration items for the data entry module.\n\nThis module sets configs then overrides with any same-named\nvalues that are set in tt_local_config\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify", "\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"\nfrom tt_colours import Style, Fore, Back\nfrom typing import Tuple\n\n# Screen appearance", "\n# Screen appearance\nSCREEN_WIDTH = 80  # characters\nUSE_COLOUR = True\nCURSOR = \">>> \"\nINCLUDE_TIME_IN_PROMPT = True\nTAGS_UPPERCASE = False\n\n# This file defines what tags are available, for current-day sessions.\nTAG_CONFIG_FILE = \"tags.cfg\"", "# This file defines what tags are available, for current-day sessions.\nTAG_CONFIG_FILE = \"tags.cfg\"\n# Files and folder locations\nDATA_FOLDER = \"../data\"  # Folder to keep datafiles in\nDATA_BASENAME = \"cityhall_\"  # Files will be {BASENAME}YY-MM-DD.dat\n# Persistent database is put in the REPORTS_FOLDER\nDB_FILENAME = \"cityhall_bikevalet.db\"  # Name of persistent database\n# Where and how often to publish reports\nREPORTS_FOLDER = r\"/mnt/chromeos/GoogleDrive/MyDrive/tracker_data/\"\nPUBLISH_FREQUENCY = 15  # minutes. \"0\" means do not publish", "REPORTS_FOLDER = r\"/mnt/chromeos/GoogleDrive/MyDrive/tracker_data/\"\nPUBLISH_FREQUENCY = 15  # minutes. \"0\" means do not publish\n# Echo captures full transcripts of a day's TT session\nECHO_FOLDER = r\"/mnt/chromeos/GoogleDrive/MyDrive/tracker_data/\"\nECHO = False\n\n# Ask confirmatino for checkouts when visits less than this duration.\nCHECK_OUT_CONFIRM_TIME = 30  # mins\n# Duration (minutes) for roll-up blocks (e.g. for datasheet report)\nBLOCK_DURATION = 30", "# Duration (minutes) for roll-up blocks (e.g. for datasheet report)\nBLOCK_DURATION = 30\n\n# Help message.  Colour styles will be applied as:\n#       First non-blank line will be in TITLE_STYLE, after which\n#       lines that are flush left will be in SUBTITLE_STYLE; and\n#       all other lines will be in NORMAL_STYLE\nHELP_MESSAGE = \"\"\"\nTagTracker Commands\n", "TagTracker Commands\n\nTo enter and change valet data\n  Check bike in or out         :   <tag name> (eg \u201cwa3\u201d)\n  Edit check in/out times      :   edit / e\n  Delete a check in/out        :   delete / del  / d\n  Set valet open/close hours   :   valet / v\n\nInformation and reports\n  Show info about one tag      :   query / q / ?", "Information and reports\n  Show info about one tag      :   query / q / ?\n  Show recent activity         :   recent / r\n  Show audit info              :   audit / a\n  Show day-end stats report    :   stat  / s\n  Show valet busy-ness report  :   busy / b\n  Show data as on paper form   :   form / f\n  Show tag configurations      :   tags / t\n  Show chart of all activity   :   chart / c\n", "  Show chart of all activity   :   chart / c\n\nOther\n  Show this list of commands   :   help  /  h\n  Set tag display to UPPERCASE :   uppercase / uc\n  Set tag display to lowercase :   lowercase / lc\n  Send reports to shared drive :   publish / pub\n  Exit                         :   exit / x\n\"\"\"\n", "\"\"\"\n\n# Styles related to colour\nSTYLE = {}\nPROMPT_STYLE = \"prompt_style\"\nSUBPROMPT_STYLE = \"subprompt_style\"\nANSWER_STYLE = \"answer_style\"\nTITLE_STYLE = \"title_style\"\nSUBTITLE_STYLE = \"subtitle_style\"\nNORMAL_STYLE = \"normal_style\"", "SUBTITLE_STYLE = \"subtitle_style\"\nNORMAL_STYLE = \"normal_style\"\nRESET_STYLE = \"reset_style\"\nHIGHLIGHT_STYLE = \"highlight_style\"\nWARNING_STYLE = \"warn_style\"\nERROR_STYLE = \"error_style\"\n\n# Colour combinations. Override these in local config as desired.\nSTYLE[PROMPT_STYLE] = f\"{Style.BRIGHT}{Fore.GREEN}{Back.BLACK}\"\nSTYLE[SUBPROMPT_STYLE] = f\"{Style.BRIGHT}{Fore.GREEN}{Back.BLACK}\"", "STYLE[PROMPT_STYLE] = f\"{Style.BRIGHT}{Fore.GREEN}{Back.BLACK}\"\nSTYLE[SUBPROMPT_STYLE] = f\"{Style.BRIGHT}{Fore.GREEN}{Back.BLACK}\"\nSTYLE[ANSWER_STYLE] = f\"{Style.BRIGHT}{Fore.YELLOW}{Back.BLUE}\"\nSTYLE[TITLE_STYLE] = f\"{Style.BRIGHT}{Fore.WHITE}{Back.BLUE}\"\nSTYLE[SUBTITLE_STYLE] = f\"{Style.BRIGHT}{Fore.CYAN}{Back.BLACK}\"\nSTYLE[RESET_STYLE] = f\"{Style.RESET_ALL}\"\nSTYLE[NORMAL_STYLE] = f\"{Style.RESET_ALL}\"\nSTYLE[HIGHLIGHT_STYLE] = f\"{Style.BRIGHT}{Fore.CYAN}{Back.BLACK}\"\nSTYLE[WARNING_STYLE] = f\"{Style.BRIGHT}{Fore.RED}{Back.BLACK}\"\nSTYLE[ERROR_STYLE] = f\"{Style.BRIGHT}{Fore.WHITE}{Back.RED}\"", "STYLE[WARNING_STYLE] = f\"{Style.BRIGHT}{Fore.RED}{Back.BLACK}\"\nSTYLE[ERROR_STYLE] = f\"{Style.BRIGHT}{Fore.WHITE}{Back.RED}\"\n\n# These are the symbols & styles used in the tag inventory matrix.\n# Each is a tuple of (symbol,style).\n# Each symbol should be 2 characters wide.  Warning if using fancy unicode\n# that those characters come in various widths, platform-dependent.\nTAG_INV_UNKNOWN = (\"  \",NORMAL_STYLE)\nTAG_INV_AVAILABLE = (\" -\",NORMAL_STYLE)\nTAG_INV_BIKE_IN = (\"In\",ANSWER_STYLE)", "TAG_INV_AVAILABLE = (\" -\",NORMAL_STYLE)\nTAG_INV_BIKE_IN = (\"In\",ANSWER_STYLE)\nTAG_INV_BIKE_OUT = (\"Ou\",PROMPT_STYLE)\nTAG_INV_RETIRED = (\"Re\",WARNING_STYLE)\n\n# Command keys and aliases.\nCMD_AUDIT = \"audit\"\nCMD_DELETE = \"delete\"\nCMD_EDIT = \"edit\"\nCMD_EXIT = \"exit\"", "CMD_EDIT = \"edit\"\nCMD_EXIT = \"exit\"\nCMD_BLOCK = \"block\"\nCMD_HELP = \"help\"\nCMD_LOOKBACK = \"lookback\"\nCMD_QUERY = \"query\"\nCMD_STATS = \"stats\"\nCMD_BUSY = \"busy\"\nCMD_VALET_HOURS = \"valet_hours\"\nCMD_CSV = \"csv\"", "CMD_VALET_HOURS = \"valet_hours\"\nCMD_CSV = \"csv\"\nCMD_UPPERCASE = \"uppercase\"\nCMD_LOWERCASE = \"lowercase\"\nCMD_LINT = \"lint\"\nCMD_DUMP = \"dump\"\nCMD_BUSY_CHART = \"busy_chart\"\nCMD_FULL_CHART = \"full_chart\"\nCMD_CHART = \"chart\"\nCMD_PUBLISH = \"publish\"", "CMD_CHART = \"chart\"\nCMD_PUBLISH = \"publish\"\nCMD_COLOURS = \"colours\"  # FIXME: remove in a while. Now \"tags\"\nCMD_RETIRED = \"retired\"  # FIXME: remove in a while.  Now \"tags\"\nCMD_TAGS = \"tags\"\n\n\nCOMMANDS = {}\nCOMMANDS[CMD_AUDIT] = [\"audit\", \"a\", \"aud\"]\nCOMMANDS[CMD_DELETE] = [\"del\", \"delete\", \"d\"]", "COMMANDS[CMD_AUDIT] = [\"audit\", \"a\", \"aud\"]\nCOMMANDS[CMD_DELETE] = [\"del\", \"delete\", \"d\"]\nCOMMANDS[CMD_EDIT] = [\"edit\", \"e\", \"ed\"]\nCOMMANDS[CMD_EXIT] = [\"quit\", \"exit\", \"stop\", \"x\", \"bye\"]\nCOMMANDS[CMD_BLOCK] = [\"log\", \"l\", \"form\", \"f\"]\nCOMMANDS[CMD_HELP] = [\"help\", \"h\"]\nCOMMANDS[CMD_LOOKBACK] = [\"recent\", \"r\"]\nCOMMANDS[CMD_QUERY] = [\"query\", \"q\", \"?\", \"/\"]\nCOMMANDS[CMD_STATS] = [\"s\", \"stat\", \"stats\", \"statistics\"]\nCOMMANDS[CMD_BUSY] = [\"b\", \"busy\", \"busyness\", \"business\"]", "COMMANDS[CMD_STATS] = [\"s\", \"stat\", \"stats\", \"statistics\"]\nCOMMANDS[CMD_BUSY] = [\"b\", \"busy\", \"busyness\", \"business\"]\nCOMMANDS[CMD_VALET_HOURS] = [\"v\", \"valet\"]\nCOMMANDS[CMD_CSV] = [\"csv\"]\nCOMMANDS[CMD_UPPERCASE] = [\"uc\", \"uppercase\", \"upper\"]\nCOMMANDS[CMD_LOWERCASE] = [\"lc\", \"lowercase\", \"lower\"]\nCOMMANDS[CMD_RETIRED] = [\"retired\", \"ret\"]\nCOMMANDS[CMD_LINT] = [\"consistency\", \"consistent\", \"cons\", \"con\"]\nCOMMANDS[CMD_DUMP] = [\"dump\"]\nCOMMANDS[CMD_BUSY_CHART] = [\"chart-busy\", \"graph-busy\", \"busy-chart\", \"busy-graph\"]", "COMMANDS[CMD_DUMP] = [\"dump\"]\nCOMMANDS[CMD_BUSY_CHART] = [\"chart-busy\", \"graph-busy\", \"busy-chart\", \"busy-graph\"]\nCOMMANDS[CMD_FULL_CHART] = [\"chart-full\", \"graph-full\", \"full-chart\", \"full-graph\"]\nCOMMANDS[CMD_CHART] = [\"chart\", \"c\"]\nCOMMANDS[CMD_PUBLISH] = [\"pub\", \"publish\"]\nCOMMANDS[CMD_COLOURS] = [\"col\", \"color\", \"colors\", \"colour\", \"colours\"]\nCOMMANDS[CMD_TAGS] = [\"tag\", \"tags\", \"t\"]\n# These are for commands that are not recognized so *maybe* are a tag\nCMD_UNKNOWN = \"unknown\" + chr(12345)  # special value to mean unrecognized command\nCMD_TAG_RETIRED = \"tag_retired\" + chr(12345)  # For a tag that's retired (not a command)", "CMD_UNKNOWN = \"unknown\" + chr(12345)  # special value to mean unrecognized command\nCMD_TAG_RETIRED = \"tag_retired\" + chr(12345)  # For a tag that's retired (not a command)\nCMD_TAG_UNUSABLE = \"tag_unusable\" + chr(12345)\n\n\ndef valet_hours(the_date:str) -> Tuple[str,str]:\n    \"\"\"Stub to provide valet open/closing hours.\n\n    This is called to get daily default valet hours.\n    Specific info can be provided in local config (tt_conf.py);\n    this simply returns empty strings.\n    \"\"\"\n    return (\"\",\"\")"]}
{"filename": "tt_reports.py", "chunked_list": ["\"\"\"TagTracker by Julias Hocking.\n\nReporting functions for  the TagTracker suite.\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.", "    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.", "    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"\n\nimport statistics\nfrom typing import Union\n\nfrom tt_globals import *  # pylint:disable=unused-wildcard-import,wildcard-import\nfrom tt_time import VTime\nfrom tt_tag import TagID", "from tt_time import VTime\nfrom tt_tag import TagID\nfrom tt_realtag import Stay\nfrom tt_trackerday import TrackerDay\nimport tt_util as ut\nfrom tt_event import Event\nimport tt_block\nimport tt_printer as pr\nimport tt_conf as cfg\n", "import tt_conf as cfg\n\n# try:\n#    import tt_local_config  # pylint:disable=unused-import\n# except ImportError:\n#    pass\n\n\n# Time ranges for categorizing stay-lengths, in hours.\n# First category will always be 0 - [0], last will always be > [-1]", "# Time ranges for categorizing stay-lengths, in hours.\n# First category will always be 0 - [0], last will always be > [-1]\nVISIT_CATEGORIES = [1.5, 5]\n\n# size of 'buckets' for calculating the mode stay time\nMODE_ROUND_TO_NEAREST = 30  # mins\n\n# List ow many ranked busiest times of day in report?\nBUSIEST_RANKS = 4\n", "BUSIEST_RANKS = 4\n\n\ndef recent(day: TrackerDay, args: list[str]) -> None:\n    \"\"\"Display a look back at recent activity.\n\n    Args are: start_time, end_time\n        If no args ==> now-30, now\n        If start_time but no end_time ==> start, now\n        If start_time and end_time ==> start, end\n    \"\"\"\n\n    def format_one(atime: VTime, tag: TagID, check_in: bool) -> str:\n        \"\"\"Format one line of output.\"\"\"\n        in_tag = f\"{tag}\" if check_in else \"\"\n        out_tag = \"\" if check_in else f\"{tag}\"\n        return f\"{atime.tidy}   {in_tag:<5s} {out_tag:<5s}\"\n\n    (start_time, end_time) = (args + [None, None])[:2]\n    if not start_time and not end_time:\n        end_time = VTime(\"now\")\n        start_time = VTime(end_time.num - 30)\n    elif start_time and not end_time:\n        start_time = VTime(start_time)\n        end_time = VTime(\"now\")\n    else:\n        start_time = VTime(start_time)\n        end_time = VTime(end_time)\n    # ANything we can work with?\n    if not start_time or not end_time or start_time > end_time:\n        pr.iprint(\n            \"Can not make sense of the given start/end times\",\n            style=cfg.WARNING_STYLE,\n        )\n        return\n    # Print header.\n    pr.iprint()\n    pr.iprint(\n        f\"Recent activity (from {start_time.short} to {end_time.short})\",\n        style=cfg.TITLE_STYLE,\n    )\n    pr.iprint()\n    pr.iprint(\"Time  BikeIn BikeOut\", style=cfg.SUBTITLE_STYLE)\n    # Collect & print any bike-in/bike-out events in the time period.\n    events = Event.calc_events(day, end_time)\n    current_block_end = None\n    for atime in sorted(events.keys()):\n        # Ignore events outside the desired time range.\n        if not (start_time <= atime <= end_time):\n            continue\n        # Possibly put a line between blocks of activity.\n        if not current_block_end:\n            current_block_end = tt_block.block_end(atime)\n        if atime > current_block_end:\n            pr.iprint(f\"{tt_block.block_start(atime).tidy}-------------\")\n            current_block_end = tt_block.block_end(atime)\n        # Print all the activity that happened at this time.\n        for tag in sorted(events[atime].bikes_in):\n            pr.iprint(format_one(atime, tag, True))\n        for tag in sorted(events[atime].bikes_out):\n            pr.iprint(format_one(atime, tag, False))", "\n\ndef later_events_warning(day: TrackerDay, when: VTime) -> None:\n    \"\"\"Warn about report that excludes later events.\n\n    If  no later events, does nothing.\n    \"\"\"\n    when = VTime(when)\n    if not when:\n        return\n    # Buid the message\n    later_events = day.num_later_events(when)\n    if not later_events:\n        return\n    msg = f\"Report excludes {later_events} events later than {when.short}\"\n    pr.iprint(msg, style=cfg.WARNING_STYLE)", "\n\ndef simplified_taglist(tags: Union[list[TagID], str]) -> str:\n    \"\"\"Make a simplified str of tag names from a list of tags.\n\n    E.g. \"wa0,2-7,9 wb1,9,10 be4\"\n    The tags list can be a string separated by whitespace or comma.\n    or it can be a list of tags.\n    \"\"\"\n\n    # FIXME: not adjusting this one to VTime/TagID yet, may not need to\n    def hyphenize(nums: list[int]) -> str:\n        \"\"\"Convert a list of ints into a hypenated list.\"\"\"\n        # Warning: dark magic.\n        # Build lists of sequences from the sorted list.\n        # starts is list of starting values of sequences.\n        # ends is matching list of ending values.\n        # singles is list of ints that are not part of sequences.\n        nums_set = set(nums)\n        starts = [\n            x for x in nums_set if x - 1 not in nums_set and x + 1 in nums_set\n        ]\n        startset = set(starts)\n        ends = [\n            x\n            for x in nums_set\n            if x - 1 in nums_set\n            and x + 1 not in nums_set\n            and x not in startset\n        ]\n        singles = [\n            x\n            for x in nums_set\n            if x - 1 not in nums_set and x + 1 not in nums_set\n        ]\n        # Build start & end into dictionary, rejecting any sequences\n        # shorter than an arbitrary shortest length\n        min_len = 3\n        seqs = {}  # key = int start; value = str representing the sequence\n        for start, end in zip(starts, ends):\n            if (end - start) >= (min_len - 1):\n                seqs[start] = f\"{start}-{end}\"\n            else:\n                # Too short, convert to singles\n                singles = singles + list(range(start, end + 1))\n        # Add the singles to the seqs dict\n        for num in singles:\n            seqs[num] = f\"{num}\"\n        # Return the whole thing as a comma-joined string\n        return \",\".join([seqs[n] for n in sorted(seqs.keys())])\n\n    if isinstance(tags, str):\n        # Break the tags down into a list.  First split comma.\n        tags = tags.split(\",\")\n        # Split on whitespace.  This makes a list of lists.\n        tags = [item.split() for item in tags]\n        # Flatten the list of lists into a single list.\n        tags = [item for sublist in tags for item in sublist]\n    # Make dict of [prefix]:list of tag_numbers_as_int\n    tag_prefixes = ut.tagnums_by_prefix(tags)\n    simplified_list = []\n    for prefix in sorted(tag_prefixes.keys()):\n        # A list of the tag numbers for this prefix\n        ##simplified_list.append(f\"{prefix}\" +\n        ##        (\",\".join([str(num) for num in sorted(tag_prefixes[prefix])])))\n        simplified_list.append(f\"{prefix}{hyphenize(tag_prefixes[prefix])}\")\n    # Return all of these joined together\n    simple_str = \" \".join(simplified_list)\n    ##simple_str = simple_str.upper() if UC_TAGS else simple_str.lower()\n    return simple_str", "\n\ndef inout_summary(day: TrackerDay, as_of_when: VTime = VTime(\"\")) -> None:\n    \"\"\"Print summary table of # of bikes in, out and still at valet.\"\"\"\n    # Count the totals\n    visits = Stay.calc_stays(day, as_of_when=as_of_when)\n    bikes_on_hand = [v.tag for v in visits.values() if v.still_here]\n    ##print(' '.join(bikes_on_hand))\n    num_bikes_on_hand = len(bikes_on_hand)\n    regular_in = 0\n    regular_out = 0\n    oversize_in = 0\n    oversize_out = 0\n    for v in visits.values():\n        if v.type == REGULAR:\n            regular_in += 1\n            if not v.still_here:\n                regular_out += 1\n        elif v.type == OVERSIZE:\n            oversize_in += 1\n            if not v.still_here:\n                oversize_out += 1\n\n    sum_in = regular_in + oversize_in\n    sum_out = regular_out + oversize_out\n    sum_on_hand = regular_in + oversize_in - regular_out - oversize_out\n\n    # Print summary of bikes in/out/here\n    pr.iprint()\n    pr.iprint(\n        \"Summary             Regular Oversize Total\", style=cfg.SUBTITLE_STYLE\n    )\n    pr.iprint(\n        f\"Bikes checked in:     {regular_in:4d}    {oversize_in:4d}\"\n        f\"    {sum_in:4d}\"\n    )\n    pr.iprint(\n        f\"Bikes returned out:   {regular_out:4d}    {oversize_out:4d}\"\n        f\"    {sum_out:4d}\"\n    )\n    pr.iprint(\n        f\"Bikes in valet:       {(regular_in-regular_out):4d}\"\n        f\"    {(oversize_in-oversize_out):4d}    {sum_on_hand:4d}\"\n    )\n    if sum_on_hand != num_bikes_on_hand:\n        ut.squawk(f\"inout_summary() {num_bikes_on_hand=} != {sum_on_hand=}\")", "\n\ndef audit_report(day: TrackerDay, args: list[str]) -> None:\n    \"\"\"Create & display audit report as at a particular time.\n\n    On entry: as_of_when_args is a list that can optionally\n    have a first element that's a time at which to make this for.\n\n    This is smart about any checkouts that are later than as_of_when.\n    If as_of_when is missing, then counts as of current time.\n\n    \"\"\"\n\n    # What time will this audit report reflect?\n    as_of_when = (args + [\"now\"])[0]\n    as_of_when = VTime(as_of_when)\n    if not as_of_when:\n        pr.iprint(\"Unrecognized time\", style=cfg.WARNING_STYLE)\n        return False\n\n    # Audit report header. Special case if request is for \"24:00\"\n    pr.iprint()\n    pr.iprint(\n        f\"Audit report for {day.date} {as_of_when.as_at}\",\n        style=cfg.TITLE_STYLE,\n    )\n    later_events_warning(day, as_of_when)\n\n    # Summary of bikes in a& bikes out\n    inout_summary(day, as_of_when)\n\n    # Get rid of any check-ins or -outs later than the requested time.\n    # (Yes I know there's a slicker way to do this but this is nice and clear.)\n    check_ins_to_now = {}\n    for tag, ctime in day.bikes_in.items():\n        if ctime <= as_of_when:\n            check_ins_to_now[tag] = ctime\n    check_outs_to_now = {}\n    for tag, ctime in day.bikes_out.items():\n        if ctime <= as_of_when:\n            check_outs_to_now[tag] = ctime\n    bikes_on_hand = {}\n    for tag, ctime in check_ins_to_now.items():\n        if tag not in check_outs_to_now:\n            bikes_on_hand[tag] = ctime\n\n    # Tags matrixes\n    # Tags broken down by prefix (for tags matrix)\n    prefixes_on_hand = ut.tagnums_by_prefix(bikes_on_hand.keys())\n    prefixes_returned_out = ut.tagnums_by_prefix(check_outs_to_now.keys())\n    returns_by_colour = {}\n    for prefix, numbers in prefixes_returned_out.items():\n        colour_code = prefix[:-1]  # prefix without the tag_letter\n        if colour_code not in returns_by_colour:\n            returns_by_colour[colour_code] = len(numbers)\n        else:\n            returns_by_colour[colour_code] += len(numbers)\n\n    NO_ITEM_STR = \"  \"  # what to show when there's no tag\n    RETIRED_TAG_STR = \" \u25cf\"\n    pr.iprint()\n    # Bikes returned out -- tags matrix.\n    pr.iprint(\n        f\"Bikes still in valet at {as_of_when.short}\"\n        f\" ({RETIRED_TAG_STR} --> retired tag)\",\n        style=cfg.SUBTITLE_STYLE,\n    )\n    for prefix in sorted(prefixes_on_hand.keys()):\n        numbers = prefixes_on_hand[prefix]\n        line = f\"{prefix:3>} \"\n        for i in range(0, max(numbers) + 1):  # FIXME: can numbers ever be []?\n            if i in numbers:\n                s = f\"{i:02d}\"\n            elif TagID(f\"{prefix}{i}\") in day.retired:\n                s = RETIRED_TAG_STR\n            else:\n                s = NO_ITEM_STR\n            line = f\"{line} {s}\"\n        pr.iprint(line)\n    if not prefixes_on_hand:\n        pr.iprint(\"-no bikes-\")\n    pr.iprint()\n\n    # Bikes returned out -- tags matrix.\n    bikes_out_title = \"Bikes returned out (\"\n    sum_out = 0\n    for colour_code in sorted(returns_by_colour.keys()):\n        num = returns_by_colour[colour_code]\n        sum_out += num\n        bikes_out_title = (\n            f\"{bikes_out_title}{num} \"\n            f\"{day.colour_letters[colour_code.lower()].title()}, \"\n        )\n    bikes_out_title = f\"{bikes_out_title}{sum_out} Total)\"\n    pr.iprint(bikes_out_title, style=cfg.SUBTITLE_STYLE)\n    for prefix in sorted(prefixes_returned_out.keys()):\n        numbers = prefixes_returned_out[prefix]\n        line = f\"{prefix:3>} \"\n        for i in range(0, max(numbers) + 1):\n            if i in numbers:\n                s = f\"{i:02d}\"\n            elif TagID(f\"{prefix}{i}\") in day.retired:\n                s = RETIRED_TAG_STR\n            else:\n                s = NO_ITEM_STR\n            line = f\"{line} {s}\"\n        pr.iprint(line)\n    if not prefixes_returned_out:\n        pr.iprint(\"-no bikes-\")\n\n    return", "\n\ndef csv_dump(day: TrackerDay, args) -> None:\n    \"\"\"Dump a few stats into csv for pasting into spreadsheets.\"\"\"\n    filename = (args + [None])[0]\n    if not filename:\n        ##pr.iprint(\"usage: csv <filename>\",style=cfg.WARNING_STYLE)\n        pr.iprint(\"Printing to screen.\", style=cfg.WARNING_STYLE)\n\n    def time_hrs(atime) -> str:\n        \"\"\"Return atime (str or int) as a string of decimal hours.\"\"\"\n        hrs = ut.time_int(atime) / 60\n        return f\"{hrs:0.3}\"\n\n    as_of_when = \"24:00\"\n\n    events = Event.calc_events(day, as_of_when)\n    # detailed fullness\n    pr.iprint()\n    print(\"Time, Regular, Oversize, Total\")\n    for atime in sorted(events.keys()):\n        ev = events[atime]\n        print(\n            f\"{time_hrs(atime)},{ev.num_here_regular},\"\n            f\"{ev.num_here_oversize},{ev.num_here_total}\"\n        )\n\n    # block, ins, outs, num_bikes_here\n    blocks_ins = dict(\n        zip(\n            tt_block.get_timeblock_list(day, as_of_when),\n            [0 for _ in range(0, 100)],\n        )\n    )\n    blocks_outs = blocks_ins.copy()\n    blocks_heres = blocks_ins.copy()\n    for atime, ev in events.items():\n        start = tt_block.block_start(atime)  # Which block?\n        blocks_ins[start] += ev.num_ins\n        blocks_outs[start] += ev.num_outs\n    prev_here = 0\n    for atime in sorted(blocks_heres.keys()):\n        blocks_heres[atime] = (\n            prev_here + blocks_ins[atime] - blocks_outs[atime]\n        )\n        prev_here = blocks_heres[atime]\n    pr.iprint()\n    print(\"Time period,Incoming,Outgoing,At Valet\")\n    for atime in sorted(blocks_ins.keys()):\n        print(\n            f\"{atime},{blocks_ins[atime]},{blocks_outs[atime]},{blocks_heres[atime]}\"\n        )\n    pr.iprint()\n\n    # stay_start(hrs),duration(hrs),stay_end(hrs)\n    visits = Stay.calc_stays(day, as_of_when)  # keyed by tag\n    # make list of stays keyed by start time\n    visits_by_start = {}\n    for v in visits.values():\n        start = v.time_in\n        if start not in visits_by_start:\n            visits_by_start[start] = []\n        visits_by_start[start].append(v)\n    pr.iprint()\n    print(\"Sequence, Start time, Length of stay\")\n    seq = 1\n    for atime in sorted(visits_by_start.keys()):\n        for v in visits_by_start[atime]:\n            print(f\"{seq},{time_hrs(v.time_in)},\" f\"{time_hrs(v.duration)}\")\n            seq += 1", "\n\ndef bike_check_ins_report(day: TrackerDay, as_of_when: VTime) -> None:\n    \"\"\"Print the check-ins count part of the summary statistics.\n\n    as_of_when is HH:MM time, assumed to be a correct time.\n    \"\"\"\n    # Find the subset of check-ins at or before our cutoff time.\n    these_check_ins = {}\n    for tag, atime in day.bikes_in.items():\n        if atime <= as_of_when:\n            these_check_ins[tag] = atime\n    # Summary stats\n    num_still_here = len(\n        set(these_check_ins.keys())\n        - set([x for x in day.bikes_out if day.bikes_out[x] <= as_of_when])\n    )\n    num_bikes_ttl = len(these_check_ins)\n    these_checkins_am = [\n        x for x in these_check_ins if these_check_ins[x] < \"12:00\"\n    ]\n    num_bikes_am = len(these_checkins_am)\n    num_bikes_regular = len([x for x in these_check_ins if x in day.regular])\n    num_bikes_oversize = len([x for x in these_check_ins if x in day.oversize])\n\n    pr.iprint()\n    pr.iprint(\"Bike check-ins\", style=cfg.SUBTITLE_STYLE)\n    pr.iprint(f\"Total bikes in:   {num_bikes_ttl:4d}\")\n    pr.iprint(f\"AM bikes in:      {num_bikes_am:4d}\")\n    pr.iprint(f\"PM bikes in:      {(num_bikes_ttl - num_bikes_am):4d}\")\n    pr.iprint(f\"Regular in:       {num_bikes_regular:4d}\")\n    pr.iprint(f\"Oversize in:      {num_bikes_oversize:4d}\")\n    pr.iprint(f\"Bikes still here: {num_still_here:4d}\")", "\n\ndef visit_lengths_by_category_report(visits: dict) -> None:\n    \"\"\"Report number of visits in different length categories.\"\"\"\n\n    def one_range(lower: float = None, upper: float = None) -> None:\n        \"\"\"Calculate and print visits in range lower:upper.\n\n        If lower is missing, uses anything below upper\n        If upper is missing, uses anything above lower\n        \"\"\"\n        noun = \"Stay\"\n        if not lower and not upper:\n            pr.iprint(\n                f\"PROGRAM ERROR: called one_range(lower='{lower}',\"\n                f\"upper='{upper}')\",\n                style=cfg.ERROR_STYLE,\n            )\n            return None\n        if not lower:\n            header = f\"{noun}s < {upper:3.1f}h:\"\n            lower = 0\n        elif not upper:\n            header = f\"{noun}s >= {lower:3.1f}h:\"\n            upper = 999\n        else:\n            header = f\"{noun}s {lower:3.1f}-{upper:3.1f}h:\"\n        # Count visits in this time range.\n        num = 0\n        for v in visits.values():\n            if v.duration >= lower * 60 and v.duration < upper * 60:\n                num += 1\n        pr.iprint(f\"{header:18s}{num:4d}\")\n\n    pr.iprint()\n    pr.iprint(\"Number of stays by duration\", style=cfg.SUBTITLE_STYLE)\n    prev_boundary = None\n    for boundary in VISIT_CATEGORIES:\n        one_range(lower=prev_boundary, upper=boundary)\n        prev_boundary = boundary\n    one_range(lower=prev_boundary, upper=None)", "\n\ndef visit_statistics_report(visits: dict) -> None:\n    \"\"\"Max, min, mean, median, mode of visits.\"\"\"\n    noun = \"stay\"\n\n    def one_line(key: str, value: str) -> None:\n        \"\"\"Print one line.\"\"\"\n        pr.iprint(f\"{key:17s}{value}\", style=cfg.NORMAL_STYLE)\n\n    def visits_mode(durations_list: list[int]) -> None:\n        \"\"\"Calculat and print the mode info.\"\"\"\n        # Find the mode value(s), with visit durations rounded\n        # to nearest ROUND_TO_NEAREST time.\n        rounded = [\n            round(x / MODE_ROUND_TO_NEAREST) * MODE_ROUND_TO_NEAREST\n            for x in durations_list\n        ]\n        modes_str = \",\".join([VTime(x).tidy for x in statistics.multimode(rounded)])\n        modes_str = (\n            f\"{modes_str}  (times \"\n            f\"rounded to {MODE_ROUND_TO_NEAREST} minutes)\"\n        )\n        one_line(\"Mode stay:\", modes_str)\n\n    def make_tags_str(tags: list[TagID]) -> str:\n        \"\"\"Make a 'list of tags' string that is sure not to be too long.\"\"\"\n        tagstr = \"tag: \" if len(tags) == 1 else \"tags: \"\n        tagstr = tagstr + \",\".join([t.cased for t in tags])\n        if len(tagstr) > 30:\n            tagstr = f\"{len(tags)} tags\"\n        return tagstr\n\n    # Make a dict of stay-lengths with list tags (for longest/shortest).\n    duration_tags = {}\n    for tag, v in visits.items():\n        dur = v.duration\n        if dur not in duration_tags:\n            duration_tags[dur] = []\n        duration_tags[dur].append(tag)\n    if not duration_tags:\n        return  # No durations\n    pr.iprint()\n    pr.iprint(\"Stay-length statistics\", style=cfg.SUBTITLE_STYLE)\n    longest = max(list(duration_tags.keys()))\n    long_tags = make_tags_str(duration_tags[longest])\n    shortest = min(list(duration_tags.keys()))\n    short_tags = make_tags_str(duration_tags[shortest])\n    one_line(f\"Longest {noun}:\", f\"{VTime(longest).tidy}  ({long_tags})\")\n    one_line(f\"Shortest {noun}:\", f\"{VTime(shortest).tidy}  ({short_tags})\")\n    # Make a list of stay-lengths (for mean, median, mode)\n    durations_list = [x.duration for x in visits.values()]\n    one_line(f\"Mean {noun}:\", VTime(statistics.mean(durations_list)).tidy)\n    one_line(\n        f\"Median {noun}:\",\n        VTime(statistics.median(list(duration_tags.keys()))).tidy,\n    )\n    visits_mode(durations_list)", "\n\ndef highwater_report(events: dict) -> None:\n    \"\"\"Make a highwater table as at as_of_when.\"\"\"\n\n    # High-water mark for bikes in valet at any one time\n    def one_line(\n        header: str, events: dict, atime: VTime, highlight_field: int\n    ) -> None:\n        \"\"\"Print one line for highwater_report.\"\"\"\n        values = [\n            events[atime].num_here_regular,\n            events[atime].num_here_oversize,\n            events[atime].num_here_total,\n        ]\n        line = f\"{header:15s}\"\n        for num, val in enumerate(values):\n            bit = f\"{val:3d}\"\n            if num == highlight_field:\n                bit = pr.text_style(bit, style=cfg.HIGHLIGHT_STYLE)\n            line = f\"{line}   {bit}\"\n        pr.iprint(f\"{line}    {atime}\")\n\n    # Table header\n    pr.iprint()\n    pr.iprint(\"Most bikes at valet at any one time\", style=cfg.SUBTITLE_STYLE)\n    if not events:\n        pr.iprint(\"-no bikes-\")\n        return\n    # Find maximum bikes on hand for the categories\n    max_regular_num = max([x.num_here_regular for x in events.values()])\n    max_oversize_num = max([x.num_here_oversize for x in events.values()])\n    max_total_num = max([x.num_here_total for x in events.values()])\n    max_regular_time = None\n    max_oversize_time = None\n    max_total_time = None\n    # Find the first time at which these took place\n    for atime in sorted(events.keys()):\n        if (\n            events[atime].num_here_regular >= max_regular_num\n            and not max_regular_time\n        ):\n            max_regular_time = atime\n        if (\n            events[atime].num_here_oversize >= max_oversize_num\n            and not max_oversize_time\n        ):\n            max_oversize_time = atime\n        if (\n            events[atime].num_here_total >= max_total_num\n            and not max_total_time\n        ):\n            max_total_time = atime\n    pr.iprint(\"                 Reglr OvrSz Total WhenAchieved\")\n    one_line(\"Most regular:\", events, max_regular_time, 0)\n    one_line(\"Most oversize:\", events, max_oversize_time, 1)\n    one_line(\"Most combined:\", events, max_total_time, 2)", "\n\ndef full_chart(day: TrackerDay, as_of_when: str = \"\") -> None:\n    \"\"\"Make chart of main stats by timeblock.\"\"\"\n    as_of_when = as_of_when if as_of_when else \"24:00\"\n    if not day.bikes_in:\n        pr.iprint()\n        pr.iprint(\"-no bikes-\", style=cfg.WARNING_STYLE)\n        return\n\n    blocks = tt_block.calc_blocks(day, as_of_when=as_of_when)\n    pr.iprint()\n    pr.iprint(f\"Activity chart {day.date}\", style=cfg.TITLE_STYLE)\n    pr.iprint()\n    pr.iprint(\n        \"          Activity    --Bikes at valet-    Max\",\n        style=cfg.SUBTITLE_STYLE,\n    )\n    pr.iprint(\n        \" Time     In   Out    Reglr Ovrsz Total   Bikes\",\n        style=cfg.SUBTITLE_STYLE,\n    )\n    for blk_start in sorted(blocks.keys()):\n        blk: tt_block.Block\n        blk = blocks[blk_start]\n        pr.iprint(\n            f\"{blk_start.tidy}    \"\n            f\"{blk.num_ins:3}   {blk.num_outs:3}    \"\n            f\"{blk.num_here_regular:4}  {blk.num_here_oversize:4}  {blk.num_here:4}    \"\n            f\"{blk.max_here:4}\"\n        )", "\n\ndef busy_graph(day: TrackerDay, as_of_when: str = \"\") -> None:\n    \"\"\"Make a quick & dirty graph of busyness.\"\"\"\n    in_marker = \"+\"  # O\u00d8 OX  <>  \u2193\u2191\n    out_marker = \"x\"\n\n    as_of_when = as_of_when if as_of_when else \"24:00\"\n    if not day.bikes_in:\n        pr.iprint()\n        pr.iprint(\"-no bikes-\", style=cfg.WARNING_STYLE)\n        return\n\n    blocks = tt_block.calc_blocks(day, as_of_when=as_of_when)\n    max_ins = max([b.num_ins for b in blocks.values()] + [0])\n    max_outs = max([b.num_outs for b in blocks.values()] + [0])\n    max_needed = max_ins + max_outs + 10\n    available_width = cfg.SCREEN_WIDTH\n    scale_factor = (max_needed // available_width) + 1\n    ##scale_factor = round((max_activity / available_width))\n    ##scale_factor = max(scale_factor, 1)\n\n    # Print graph\n    pr.iprint()\n    pr.iprint(f\"Chart of busyness for {day.date}\", style=cfg.TITLE_STYLE)\n    pr.iprint(\n        f\"Each marker represents {scale_factor} \"\n        f\"bike{ut.plural(scale_factor)} in ({in_marker}) or out ({out_marker})\",\n        style=cfg.SUBTITLE_STYLE,\n    )\n    ins_field_width = round(max_ins / scale_factor) + 1\n    for start in sorted(blocks.keys()):\n        blk: tt_block.Block\n        blk = blocks[start]\n        insize = round(blk.num_ins / scale_factor)\n        outsize = round(blk.num_outs / scale_factor)\n\n        pr.iprint(\n            f\"{' ' * (ins_field_width-insize)}{(in_marker * insize)}  \"\n            f\"{start}  {out_marker * outsize}\"\n        )", "\n\ndef fullness_graph(day: TrackerDay, as_of_when: str = \"\") -> None:\n    \"\"\"Make a quick & dirty graph of how full the valet is.\"\"\"\n    regular_marker = \"r\"\n    oversize_marker = \"O\"\n\n    as_of_when = as_of_when if as_of_when else \"24:00\"\n\n    blocks = tt_block.calc_blocks(day, as_of_when=as_of_when)\n    if not day.bikes_in:\n        pr.iprint()\n        pr.iprint(\"-no bikes-\", style=cfg.WARNING_STYLE)\n        return\n\n    max_full = max([b.num_here for b in blocks.values()] + [0])\n    available_width = cfg.SCREEN_WIDTH - 10\n    scale_factor = round((max_full / available_width))\n    scale_factor = max(scale_factor, 1)\n    # Print graph\n    pr.iprint()\n    pr.iprint(\n        f\"Max bikes at valet within a time block for {day.date}\",\n        style=cfg.TITLE_STYLE,\n    )\n    pr.iprint(\n        f\"Each marker represents {scale_factor} regular ({regular_marker}) \"\n        f\"or oversize ({oversize_marker}) bike{ut.plural(scale_factor)}\",\n        style=cfg.SUBTITLE_STYLE,\n    )\n    for start in sorted(blocks.keys()):\n        b: tt_block.Block\n        b = blocks[start]\n        regs = round(b.max_here_regular / scale_factor)\n        overs = round(b.max_here_oversize / scale_factor)\n        pr.iprint(f\"{start} {regular_marker * regs}{oversize_marker * overs}\")", "\n\ndef busy_report(\n    day: TrackerDay,\n    events: dict[VTime, Event],\n    as_of_when: VTime,\n) -> None:\n    \"\"\"Report the busiest time(s) of day.\"\"\"\n\n    def one_line(rank: int, num_events: int, times: list[VTime]) -> None:\n        \"\"\"Format and print one line of busyness report.\"\"\"\n        pr.iprint(f\"{rank:2d}     {num_events:3d}      \", end=\"\")\n        for time_num, start_time in enumerate(sorted(times), start=1):\n            end_time = VTime(start_time.num + cfg.BLOCK_DURATION)\n            pr.iprint(\n                f\"{start_time.short}-{end_time.short}\",\n                num_indents=0,\n                end=\"\",\n            )\n            if time_num < len(times):\n                pr.iprint(\", \", end=\"\",num_indents=0)\n        pr.iprint()\n\n    # Make an empty dict of busyness of timeblocks.\n    blocks = dict(\n        zip(\n            tt_block.get_timeblock_list(day, as_of_when),\n            [0 for _ in range(0, 100)],\n        )\n    )\n    # Count actions in each timeblock\n    for atime, ev in events.items():\n        start = tt_block.block_start(atime)  # Which block?\n        blocks[start] += ev.num_ins + ev.num_outs\n    # Make a dict of busynesses with list of timeblocks for each.\n    busy_times = {}\n    for atime, activity in blocks.items():\n        if activity not in busy_times:\n            busy_times[activity] = []\n        busy_times[activity].append(atime)\n    # Report the results.\n    pr.iprint()\n    pr.iprint(\"Busiest times of day\", style=cfg.SUBTITLE_STYLE)\n    pr.iprint(\"Rank  Ins&Outs  When\")\n    for rank, activity in enumerate(\n        sorted(busy_times.keys(), reverse=True), start=1\n    ):\n        if rank > BUSIEST_RANKS:\n            break\n        one_line(rank, activity, busy_times[activity])", "\n\ndef qstack_report(visits: dict[TagID : Stay]) -> None:\n    \"\"\"Report whether visits are more queue-like or more stack-like.\"\"\"\n    # Make a list of tuples: start_time, end_time for all visits.\n    visit_times = list(\n        zip(\n            [vis.time_in for vis in visits.values()],\n            [vis.time_out for vis in visits.values()],\n        )\n    )\n    ##ut.squawk( f\"{len(list(visit_times))=}\")\n    ##ut.squawk( f\"{list(visit_times)=}\")\n    queueish = 0\n    stackish = 0\n    neutralish = 0\n    visit_compares = 0\n    total_possible_compares = int(\n        (len(visit_times) * (len(visit_times) - 1)) / 2\n    )\n\n    for time_in, time_out in visit_times:\n        earlier_visits = [\n            (tin, tout)\n            for (tin, tout) in visit_times\n            if tin < time_in and tout > time_in\n        ]\n        visit_compares += len(earlier_visits)\n        for earlier_out in [v[1] for v in earlier_visits]:\n            if earlier_out < time_out:\n                queueish += 1\n            elif earlier_out > time_out:\n                stackish += 1\n            else:\n                neutralish += 1\n\n    pr.iprint()\n    pr.iprint(\n        \"Were today's stays more queue-like or stack-like?\",\n        style=cfg.SUBTITLE_STYLE,\n    )\n    if not queueish and not stackish:\n        pr.iprint(\"Unable to determine.\")\n        return\n    neutralish = total_possible_compares - queueish - stackish\n    queue_proportion = queueish / (queueish + stackish + neutralish)\n    stack_proportion = stackish / (queueish + stackish + neutralish)\n    pr.iprint(\n        f\"The {total_possible_compares} compares of today's {len(visits)} \"\n        \"stays are:\"\n    )\n    pr.iprint(\n        f\"{(queue_proportion):0.3f} queue-like (overlapping stays)\",\n        num_indents=2,\n    )\n    pr.iprint(\n        f\"{(stack_proportion):0.3f} stack-like (nested stays)\",\n        num_indents=2,\n    )\n    pr.iprint(\n        f\"{((1 - stack_proportion - queue_proportion)):0.3f} neither \"\n        \"(disjunct stays, or share a check-in or -out time)\",\n        num_indents=2,\n    )", "\n\ndef day_end_report(day: TrackerDay, args: list) -> None:\n    \"\"\"Report summary statistics about visits, up to the given time.\n\n    If not time given, calculates as of latest checkin/out of the day.\n    \"\"\"\n    rightnow = VTime(\"now\")\n    as_of_when = (args + [None])[0]\n    if not as_of_when:\n        as_of_when = rightnow\n    else:\n        as_of_when = VTime(as_of_when)\n        if not (as_of_when):\n            pr.iprint(\n                f\"Unrecognized time passed to visits summary ({args[0]})\",\n                style=cfg.WARNING_STYLE,\n            )\n            return\n    pr.iprint()\n    pr.iprint(\n        f\"Summary statistics {as_of_when.as_at}\",\n        style=cfg.TITLE_STYLE,\n    )\n    later_events_warning(day, as_of_when)\n    if not day.latest_event(as_of_when):\n        pr.iprint(\n            f\"No bikes checked in by {as_of_when}\", style=cfg.SUBTITLE_STYLE\n        )\n        return\n    # Bikes in, in various categories.\n    bike_check_ins_report(day, as_of_when)\n    # Stats that use visits (stays)\n    visits = Stay.calc_stays(day, as_of_when)\n    visit_lengths_by_category_report(visits)\n    visit_statistics_report(visits)", "\n\ndef busyness_report(day: TrackerDay, args: list) -> None:\n    \"\"\"Report more summary statistics about visits, up to the given time.\n\n    If not time given, calculates as of latest checkin/out of the day.\n    \"\"\"\n    # rightnow = ut.get_time()\n    as_of_when = VTime((args + [\"now\"])[0])\n    if not (as_of_when):\n        pr.iprint(\"Unrecognized time\", style=cfg.WARNING_STYLE)\n        return\n    pr.iprint()\n    pr.iprint(\n        f\"Busyness report {as_of_when.as_at}\",\n        style=cfg.TITLE_STYLE,\n    )\n    later_events_warning(day, as_of_when)\n    if not day.latest_event(as_of_when):\n        pr.iprint(\n            f\"No bikes checked in by {as_of_when}\", style=cfg.SUBTITLE_STYLE\n        )\n        return\n    # Dict of time (events)\n    events = Event.calc_events(day, as_of_when)\n    highwater_report(events)\n    # Busiest times of day\n    busy_report(day, events, as_of_when)\n\n    # Queue-like vs stack-like\n    visits = Stay.calc_stays(day, as_of_when)\n    qstack_report(visits)", "\n\ndef dataform_report(day: TrackerDay, args: list[str]) -> None:\n    \"\"\"Print days activity in timeblocks.\n\n    This is to match the (paper/google) data tracking sheets.\n    Single args are both optional, end_time.\n    If end_time is missing, runs to current time.\n    If start_time is missing, starts one hour before end_time.\n    \"\"\"\n    end_time = VTime((args + [\"now\"])[0])\n    if not end_time:\n        pr.iprint(\n            f\"Unrecognized time {end_time.original}\", style=cfg.WARNING_STYLE\n        )\n        return\n    # Special case: allow \"24:00\"\n    if end_time != \"24:00\":\n        end_time = tt_block.block_end(end_time)\n        if not (end_time):\n            pr.iprint()\n            pr.iprint(f\"Unrecognized time {args[0]}\", style=cfg.WARNING_STYLE)\n            return\n\n    pr.iprint()\n    pr.iprint(\n        f\"Tracking form data from start of day until {end_time.short}\",\n        style=cfg.TITLE_STYLE,\n    )\n    later_events_warning(day, end_time)\n    all_blocks = tt_block.calc_blocks(day, end_time)\n    if not all_blocks:\n        earliest = day.earliest_event()\n        pr.iprint(\n            f\"No bikes checked in before {end_time} \"\n            f\"(earliest in at {earliest})\",\n            style=cfg.HIGHLIGHT_STYLE,\n        )\n        return\n    for which in [BIKE_IN, BIKE_OUT]:\n        if which == BIKE_IN:\n            titlebit = \"checked IN\"\n            prefix = \"<<<<\"\n            suffix = \"\"\n        else:\n            titlebit = \"returned OUT\"\n            prefix = \">>>>\"\n            suffix = \"\"\n        title = f\"Bikes {titlebit}\"\n        pr.iprint()\n        pr.iprint(title, style=cfg.SUBTITLE_STYLE)\n        pr.iprint(\"-\" * len(title), style=cfg.SUBTITLE_STYLE)\n        for start, block in all_blocks.items():\n            inouts = block.ins_list if which == BIKE_IN else block.outs_list\n            end = tt_block.block_end(start)\n            tagslist = simplified_taglist(inouts)\n            if TagID.uc():\n                tagslist = tagslist.upper()\n            else:\n                tagslist = tagslist.lower()\n            pr.iprint(f\"{start}-{end} {prefix} {tagslist} {suffix}\")", ""]}
{"filename": "tt_tag.py", "chunked_list": ["\"\"\"This is the TagID class.\n\n\n    A TagID is the name of a tag; it might be a correct tag name or not.\n    It is a type of string, and its representation is canonical\n    tag representation (e.g. \"wa1\").  TagIDs with identical representation\n    are considered equal, even though the 'original' attribute\n    might not be the same.\n\"\"\"\n", "\"\"\"\n\nimport re\nfrom tt_globals import *\n\n\nclass TagID(str):\n    \"\"\"The label for a tag.\n\n    Attributes & methods:\n        original:   The string that was passed in to maybe be a TagID\n        valid:      bool: is this a valid TagID?\n        full:       The full version of the tagid E.g. for wa1, is wa001\n        prefix:     The tag prefix. E.g. for wa1, is \"wa\"\n        colour:     The tag colour. E.g. for wa1, is \"w\"\n        letter:     The tag letter. E.g. for wa1, is \"a\"\n        number:     The tag number (as int). E.g. for wa1, is 1\n        cased:      The tag as a string, uc or lc depending on uc() state\n        canon:      Canonical tagid (always lowercase)\n        uc():       Sets uppercase representation on or off.\n                    Returns current state. Can be called empty\n\n        If the string passed in does not form a valid tag, all the str\n        attributes will be \"\", the number attribute will be None, and\n        valid will be False.\n\n        Comparisons are made as if comparing full versions of the\n        calculated TagID with case folded the same way, so:\n            >>> TagID(\"wa1\") == \"   wA01\"\n            True\n            >>> TagID(\"wa10\") > TagID(\"wa3\")\n            True\n        and even:\n            >>> TagID(\"wa10\") > \"wa3\"\n            True\n            >>> \"wa3\" < TagID(\"wa10\")\n            True\n\n        uc() sets whether to represent the tag in uppercase.  String\n        representations will always respect the uc() state, but there\n        are some oddball cases.\n        E.g.:\n            >>> a.uc(True)\n            True\n            >>> a\n            'WA1'\n            >>> print(a)\n            WA1\n            >>> ' ' + a\n            ' wa1'\n            >>> type(' ' + a)\n            <class 'str'>\n            >>> str(' ' + a)\n            ' wa1'\n            >>> ' ' + str(a)\n            ' WA1'\n            >>> print(' ' + a)\n            wa1\n            >>> print(' ', a)\n            WA1\n        The moral seems to be: if in doubt, use str() or f-strings:\n            >>> x = [TagID(s) for s in [\"wa1\",\"bf3\",\"ob12\"]]\n            >>> x\n            ['WA1', 'BF3', 'OB12']\n            >>> \" \".join(x)\n            'wa1 bf3 ob12'\n            >>> \" \".join([str(tag) for tag in x])\n            'WA1 BF3 OB12'\n            >>>\n    \"\"\"\n\n    # This ugly dodge is to deal with the linter\n    _always_False = False\n\n    # _uc indicates whether to print in uppercase (otherwise lc).\n    # Canonical representation is *always* lowercase.\n    _uc = False\n\n    @classmethod\n    def uc(cls, new_state: bool = None) -> bool:\n        \"\"\"Set uppercase state if given; return current state.\"\"\"\n        if new_state is not None:\n            cls._uc = bool(new_state)\n        return cls._uc\n\n    def __new__(cls, string: str = \"\"):\n        \"\"\"Create a TagID string with its 'self' as canonical tag id.\"\"\"\n        if not isinstance(string, str):\n            selfstring = \"\"\n        else:\n            r = re.match(r\"^ *([a-z][a-z]?)([a-z])0*([0-9]+) *$\", string.lower())\n            if r:\n                selfstring = f\"{r.group(1)}{r.group(2)}{r.group(3)}\".lower()\n            else:\n                selfstring = \"\"\n        instance = super().__new__(cls, selfstring)\n        instance.canon = selfstring\n        instance.original = str(string)\n        if bool(selfstring):\n            instance.valid = True\n            instance._colour = r.group(1)\n            instance._letter = r.group(2)\n            instance.number = int(r.group(3))\n            instance._prefix = f\"{r.group(1)}{r.group(2)}\"\n        else:\n            instance.valid = False\n            instance._colour = \"\"\n            instance._letter = \"\"\n            instance.number = None\n            instance._prefix = \"\"\n        return instance\n\n    def __init__(self, string: str = \"\"):  # pylint:disable=unused-argument\n        \"\"\"Initialize attributes not done in __new__().\"\"\"\n        # str.__init__(\"\")\n        # The following idiocy is to keep pylint happy\n        if self._always_False:  # pylint:disable=using-constant-test\n            self.original = \"\"\n            self.canon = \"\"\n            self.valid = False\n            self._colour = \"\"\n            self._letter = \"\"\n            self.number = 0\n            self._prefix = \"\"\n        self.uppercase = self.upper()\n        if self:\n            self._full = f\"{self._prefix}{self.number:03d}\"\n        else:\n            self._full = \"\"\n\n    def __eq__(self, otherstring: str) -> bool:\n        \"\"\"Define equality to mean represent same tag name.\"\"\"\n        return bool(str(self) == str(TagID(otherstring)))\n\n    def __le__(self, otherstring: str) -> bool:\n        return bool(self._full <= (TagID(otherstring)._full))\n\n    def __lt__(self, otherstring: str) -> bool:\n        return bool(self._full < TagID(otherstring)._full)\n\n    def __ge__(self, otherstring: str) -> bool:\n        return bool(self._full >= (TagID(otherstring)._full))\n\n    def __gt__(self, otherstring: str) -> bool:\n        return bool(self._full > (TagID(otherstring)._full))\n\n    def __ne__(self, otherstring: str) -> bool:\n        return bool(str(self) != str(TagID(otherstring)))\n\n    def __bool__(self):\n        \"\"\"Define True/False as whether 'valid' flag is set.\"\"\"\n        return self.valid\n\n    @property\n    def prefix(self) -> str:\n        \"\"\"Return the tag's prefix. E.g. in WA01, the prefix is \"WA\".\"\"\"\n        if TagID._uc:\n            return self._prefix.upper()\n        return self._prefix\n\n    @property\n    def letter(self) -> str:\n        \"\"\"Return the tag's letter. E.g. in WA01, the letter is \"A\".\"\"\"\n        if TagID._uc:\n            return self._letter.upper()\n        return self._letter\n\n    @property\n    def colour(self) -> str:\n        \"\"\"Return the tag's colour. E.g. in WA01, the colour is \"W\".\"\"\"\n        if TagID._uc:\n            return self._colour.upper()\n        return self._colour\n\n    @property\n    def full(self) -> str:\n        \"\"\"Return the full tag id - e.g. \"WA001\".\"\"\"\n        if TagID._uc:\n            return self._full.upper()\n        return self._full\n\n    @property\n    def cased(self) -> str:\n        \"\"\"Return TagID as uppercase/lowercase depending on flag.\"\"\"\n        if TagID._uc:\n            return self.upper()\n        return self.lower()\n\n    def __hash__(self):\n        \"\"\"Make hash int for the object.\n\n        Not a simple object so not hashable (ie not usable as a dict key)\n        so must provide own hash method that can be used as a dict key.\n        For these, just hash the tag's string value (always lowercase!!!)\n        \"\"\"\n        return hash(self.lower())\n\n    def __str__(self) -> str:\n        \"\"\"Show as a string, respecting uppercase flag.\"\"\"\n        if self._uc:\n            return self.upper()\n        else:\n            return self.lower()\n\n    def __repr__(self) -> str:\n        return f\"'{self.__str__()}'\"", "\n\n"]}
{"filename": "tt_time.py", "chunked_list": ["\"\"\"VTime (Valet Time) str object represents tie as HH:MM.\n\nTypically used for time since midnight but can also\nrepresent duration (<=24 hours)\n\nAttributes:\n    {self}  canonical time string \"HH:MM\" since midnight\n    tidy    pretty version of itself (e.g. \" 6:30\" instead of \"06:30\")\n    short   shortened pretty version (e.g. \"6:30\" instead of \"06:30\")\n    num     integer minutes since midnight", "    short   shortened pretty version (e.g. \"6:30\" instead of \"06:30\")\n    num     integer minutes since midnight\n    original    string representation of whatever was passed in\n\nInvocation:\n    string as HMM, HHMM, HH:MM, H:MM; or\n    int/float as minutes since midnight (or of duration); or\n    the keyword \"now\", which sets it to the current locale time\n\nInvalid input results in a blank VTime object.", "\nInvalid input results in a blank VTime object.\n\"\"\"\nimport re\nimport datetime\n\n\nclass VTime(str):\n    _always_false = False\n    @staticmethod\n    def _time_int(maybe_time: str) -> int:\n        \"\"\"Convert known-good string representation of time to int (or None).\"\"\"\n        r = re.match(r\"^ *([012]*[0-9]):?([0-5][0-9]) *$\", maybe_time)\n        if not (r):\n            return None\n        h = int(r.group(1))\n        m = int(r.group(2))\n        as_int = h * 60 + m\n        # Test for an impossible time\n        if 0 <= h <= 24 and 0 <= m <= 59:\n            return as_int\n        return None\n\n    @staticmethod\n    def _find_time(maybe_time) -> str:\n        \"\"\"Get tuple (str,int) representation of maybe_time.\"\"\"\n        if isinstance(maybe_time, float):\n            maybe_time = round(maybe_time)\n        if isinstance(maybe_time, int):\n            if 0 <= maybe_time <= 60 * 24:\n                h = maybe_time // 60\n                m = maybe_time % 60\n                return (f\"{h:02d}:{m:02d}\", maybe_time)\n            else:\n                return (\"\", None)\n        if not isinstance(maybe_time, str):\n            return (\"\", None)\n        if maybe_time.strip().lower() == \"now\":\n            timenow = datetime.datetime.today().strftime(\"%H:%M\")\n            return (timenow, VTime._time_int(timenow))\n        # Candidate might be some kind of HHMM\n        as_int = VTime._time_int(maybe_time)\n        if as_int is None:\n            return (\"\", None)\n        return VTime._find_time(as_int)\n\n    def __new__(cls, maybe_time=\"\"):\n        \"\"\"Create a Valet Time string with its 'self' as canonical time.\"\"\"\n        (self_string, self_int) = cls._find_time(maybe_time)\n        instance = super().__new__(cls, self_string)\n        instance.num = self_int\n        instance.original = str(maybe_time)\n        return instance\n\n    def __init__(self, maybe_time=\"\"):  # pylint:disable=unused-argument\n        # str.__init__()\n        # On entry, {self} is \"\" or a valid HH:MM time\n        if self._always_false:\n            self.original = \"\"\n            self.num = 0\n        if self and (self[0] == \"0\"):\n            self.tidy = f\" {self[1:]}\"\n            self.short = self[1:]\n        else:\n            self.tidy = self\n            self.short = self\n\n    # Comparisons are between str representations of itself and other\n    def __eq__(self, other) -> bool:\n        \"\"\"Define equality to mean represent same tag name.\"\"\"\n        return bool(str(self) == str(VTime(other)))\n\n    def __lt__(self, other) -> bool:\n        return bool(str(self) < str(VTime(other)))\n\n    def __gt__(self, other) -> bool:\n        return bool(str(self) > str(VTime(other)))\n\n    def __le__(self, other) -> bool:\n        return bool(str(self) <= str(VTime(other)))\n\n    def __ge__(self, other) -> bool:\n        return bool(str(self) >= str(VTime(other)))\n\n    def __ne__(self, other) -> bool:\n        return bool(str(self) != str(VTime(other)))\n\n    def __hash__(self):\n        \"\"\"Make hash int for the object.\n\n        Not a simple object so not hashable (ie not usable as a dict key)\n        so must provide own hash method that can be used as a dict key.\n        For these, just hash the tag's string value. Case folding\n        not necessary since it will never contain alpha characters.\n        \"\"\"\n        return hash(str(self))\n\n    @property\n    def as_at(self) -> str:\n        \"\"\"pretty string to say 'as at {time}'; or equivalent.\"\"\"\n        if str(self) == \"24:00\":\n            return \"projected to end of day\"\n        else:\n            return f\"as at {self.short}\""]}
{"filename": "tt_conf_template.py", "chunked_list": ["\"\"\"Config for TagTracker by Julias Hocking.\n\nConfiguration template for TagTracker.py\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.", "    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.", "    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"\nfrom tt_base_conf import *  # pylint:disable=unused-wildcard-import,wildcard-import\n\n\n# Screen appearance\n##SCREEN_WIDTH = 80 # characters\n##USE_COLOUR = True\n##CURSOR = \">>> \"", "##USE_COLOUR = True\n##CURSOR = \">>> \"\n##INCLUDE_TIME_IN_PROMPT = True\n##TAGS_UPPERCASE = False\n\n# This file defines what tags are available, for current-day sessions.\n##TAG_CONFIG_FILE = \"tags.cfg\"\n# Files and folder locations\n##DATA_FOLDER = \"../data\" # Folder to keep datafiles in\n##DATA_BASENAME = \"cityhall_\" # Files will be {BASENAME}YY-MM-DD.dat", "##DATA_FOLDER = \"../data\" # Folder to keep datafiles in\n##DATA_BASENAME = \"cityhall_\" # Files will be {BASENAME}YY-MM-DD.dat\n# Where and how often to publish reports\n##REPORTS_FOLDER = r\"/mnt/chromeos/GoogleDrive/MyDrive/tracker_data/\"\n# Persistent database is put in the REPORTS_FOLDER\n##DB_FILENAME = \"cityhall_bikevalet.db\" # Name of persistent database\n##PUBLISH_FREQUENCY = 15 # minutes. \"0\" means do not publish\n# Echo captures full transcripts of a day's TT session\n##ECHO_FOLDER = r\"/mnt/chromeos/GoogleDrive/MyDrive/tracker_data/\"\n##ECHO = False", "##ECHO_FOLDER = r\"/mnt/chromeos/GoogleDrive/MyDrive/tracker_data/\"\n##ECHO = False\n\n# Ask confirmatino for checkouts when visits less than this duration.\n##CHECK_OUT_CONFIRM_TIME = 30 # mins\n# Duration (minutes) for roll-up blocks (e.g. for datasheet report)\n##BLOCK_DURATION = 30\n\n# Help message.  Colour styles will be applied as:\n#       First non-blank line will be in TITLE_STYLE, after which", "# Help message.  Colour styles will be applied as:\n#       First non-blank line will be in TITLE_STYLE, after which\n#       lines that are flush left will be in SUBTITLE_STYLE; and\n#       all other lines will be in NORMAL_STYLE\n##HELP_MESSAGE = \"\"\"\n##TagTracker Commands\n##\n##To enter and change valet data\n##  Check bike in or out         :   <tag name> (eg \u201cwa3\u201d)\n##  Edit check in/out times      :   edit / e", "##  Check bike in or out         :   <tag name> (eg \u201cwa3\u201d)\n##  Edit check in/out times      :   edit / e\n##  Delete a check in/out        :   delete / del  / d\n##  Set valet open/close hours   :   valet / v\n##\n##Information and reports\n##  Show info about one tag      :   query / q / ?\n##  Show recent activity         :   recent / r\n##  Show audit info              :   audit / a\n##  Show day-end stats report    :   stat  / s", "##  Show audit info              :   audit / a\n##  Show day-end stats report    :   stat  / s\n##  Show valet busy-ness report  :   busy / b\n##  Show data as on paper form   :   form / f\n##  Show tag configurations      :   tags / t\n##  Show chart of all activity   :   chart / c\n##\n##Other\n##  Show this list of commands   :   help  /  h\n##  Set tag display to UPPERCASE :   uppercase / uc", "##  Show this list of commands   :   help  /  h\n##  Set tag display to UPPERCASE :   uppercase / uc\n##  Set tag display to lowercase :   lowercase / lc\n##  Send reports to shared drive :   publish / pub\n##  Exit                         :   exit / x\n##\"\"\"\n\n# Colour combinations. Override these desired.\n##STYLE[PROMPT_STYLE] = f\"{Style.BRIGHT}{Fore.GREEN}{Back.BLACK}\"\n##STYLE[SUBPROMPT_STYLE] = f\"{Style.BRIGHT}{Fore.GREEN}{Back.BLACK}\"", "##STYLE[PROMPT_STYLE] = f\"{Style.BRIGHT}{Fore.GREEN}{Back.BLACK}\"\n##STYLE[SUBPROMPT_STYLE] = f\"{Style.BRIGHT}{Fore.GREEN}{Back.BLACK}\"\n##STYLE[ANSWER_STYLE] = f\"{Style.BRIGHT}{Fore.YELLOW}{Back.BLUE}\"\n##STYLE[TITLE_STYLE] = f\"{Style.BRIGHT}{Fore.WHITE}{Back.BLUE}\"\n##STYLE[SUBTITLE_STYLE] = f\"{Style.BRIGHT}{Fore.CYAN}{Back.BLACK}\"\n##STYLE[RESET_STYLE] = f\"{Style.RESET_ALL}\"\n##STYLE[NORMAL_STYLE] = f\"{Style.RESET_ALL}\"\n##STYLE[HIGHLIGHT_STYLE] = f\"{Style.BRIGHT}{Fore.CYAN}{Back.BLACK}\"\n##STYLE[WARNING_STYLE] = f\"{Style.BRIGHT}{Fore.RED}{Back.BLACK}\"\n##STYLE[ERROR_STYLE] = f\"{Style.BRIGHT}{Fore.WHITE}{Back.RED}\"", "##STYLE[WARNING_STYLE] = f\"{Style.BRIGHT}{Fore.RED}{Back.BLACK}\"\n##STYLE[ERROR_STYLE] = f\"{Style.BRIGHT}{Fore.WHITE}{Back.RED}\"\n\n# These are the symbols & styles used in the tag inventory matrix.\n# Each is a tuple of (symbol,style).\n# Each symbol should be 2 characters wide.  Warning if using fancy unicode\n# that those characters come in various widths, platform-dependent.\n##TAG_INV_UNKNOWN = (\"  \",NORMAL_STYLE)\n##TAG_INV_AVAILABLE = (\" -\",NORMAL_STYLE)\n##TAG_INV_BIKE_IN = (\"In\",ANSWER_STYLE)", "##TAG_INV_AVAILABLE = (\" -\",NORMAL_STYLE)\n##TAG_INV_BIKE_IN = (\"In\",ANSWER_STYLE)\n##TAG_INV_BIKE_OUT = (\"Ou\",PROMPT_STYLE)\n##TAG_INV_RETIRED = (\"Re\",WARNING_STYLE)\n\n# Surely you don't want to change these.  Which strings activate which commands.\n##COMMANDS[CMD_AUDIT] = ['audit','a','aud']\n##COMMANDS[CMD_DELETE] = ['del','delete','d']\n##COMMANDS[CMD_EDIT] = ['edit','e','ed']\n##COMMANDS[CMD_EXIT] = ['quit','exit','stop','x','bye']", "##COMMANDS[CMD_EDIT] = ['edit','e','ed']\n##COMMANDS[CMD_EXIT] = ['quit','exit','stop','x','bye']\n##COMMANDS[CMD_BLOCK] = ['log', 'l', 'form', 'f']\n##COMMANDS[CMD_HELP] = ['help','h']\n##COMMANDS[CMD_LOOKBACK] = ['recent', 'r']\n##COMMANDS[CMD_QUERY] = ['query','q','?','/']\n##COMMANDS[CMD_STATS] = ['s','stat','stats','statistics']\n##COMMANDS[CMD_BUSY] = [\"b\", \"busy\",\"busyness\",\"business\"]\n##COMMANDS[CMD_VALET_HOURS] = [\"v\",\"valet\"]\n##COMMANDS[CMD_CSV] = [\"csv\"]", "##COMMANDS[CMD_VALET_HOURS] = [\"v\",\"valet\"]\n##COMMANDS[CMD_CSV] = [\"csv\"]\n##COMMANDS[CMD_UPPERCASE] = [\"uc\",\"uppercase\", \"upper\"]\n##COMMANDS[CMD_LOWERCASE] = [\"lc\",\"lowercase\", \"lower\"]\n##COMMANDS[CMD_RETIRED] = [\"retired\",\"ret\"]\n##COMMANDS[CMD_LINT] = [\"consistency\",\"consistent\",\"cons\",\"con\"]\n##COMMANDS[CMD_DUMP] = [\"dump\"]\n##COMMANDS[CMD_BUSY_CHART] = [\"chart-busy\",\"graph-busy\",\"busy-chart\",\"busy-graph\"]\n##COMMANDS[CMD_FULL_CHART] = [\"chart-full\",\"graph-full\",\"full-chart\",\"full-graph\"]\n##COMMANDS[CMD_CHART] = [\"chart\",\"c\"]", "##COMMANDS[CMD_FULL_CHART] = [\"chart-full\",\"graph-full\",\"full-chart\",\"full-graph\"]\n##COMMANDS[CMD_CHART] = [\"chart\",\"c\"]\n##COMMANDS[CMD_PUBLISH] = [\"pub\",\"publish\"]\n##COMMANDS[CMD_COLOURS] = [\"col\",\"color\",\"colors\",\"colour\",\"colours\"]\n##COMMANDS[CMD_TAGS] = [\"tag\", \"tags\", \"t\"]\n"]}
{"filename": "colourmap.py", "chunked_list": ["\"\"\"Map (x,y) data values onto (RGB) colour space.\"\"\"\n\nimport math\nimport statistics\nimport random\n\nColourDef = tuple|str\n\n\n_COLOURS = {", "\n_COLOURS = {\n\t\"maroon\":(128,0,0),\n\t\"darkred\":(139,0,0),\n\t\"brown\":(165,42,42),\n\t\"firebrick\":(178,34,34),\n\t\"crimson\":(220,20,60),\n\t\"red\":(255,0,0),\n\t\"tomato\":(255,99,71),\n\t\"coral\":(255,127,80),", "\t\"tomato\":(255,99,71),\n\t\"coral\":(255,127,80),\n\t\"indianred\":(205,92,92),\n\t\"lightcoral\":(240,128,128),\n\t\"darksalmon\":(233,150,122),\n\t\"salmon\":(250,128,114),\n\t\"lightsalmon\":(255,160,122),\n\t\"orangered\":(255,69,0),\n\t\"darkorange\":(255,140,0),\n\t\"orange\":(255,165,0),", "\t\"darkorange\":(255,140,0),\n\t\"orange\":(255,165,0),\n\t\"gold\":(255,215,0),\n\t\"darkgoldenrod\":(184,134,11),\n\t\"goldenrod\":(218,165,32),\n\t\"palegoldenrod\":(238,232,170),\n\t\"darkkhaki\":(189,183,107),\n\t\"khaki\":(240,230,140),\n\t\"olive\":(128,128,0),\n\t\"yellow\":(255,255,0),", "\t\"olive\":(128,128,0),\n\t\"yellow\":(255,255,0),\n\t\"yellowgreen\":(154,205,50),\n\t\"darkolivegreen\":(85,107,47),\n\t\"olivedrab\":(107,142,35),\n\t\"lawngreen\":(124,252,0),\n\t\"chartreuse\":(127,255,0),\n\t\"greenyellow\":(173,255,47),\n\t\"darkgreen\":(0,100,0),\n\t\"green\":(0,128,0),", "\t\"darkgreen\":(0,100,0),\n\t\"green\":(0,128,0),\n\t\"forestgreen\":(34,139,34),\n\t\"lime\":(0,255,0),\n\t\"limegreen\":(50,205,50),\n\t\"lightgreen\":(144,238,144),\n\t\"palegreen\":(152,251,152),\n\t\"darkseagreen\":(143,188,143),\n\t\"mediumspringgreen\":(0,250,154),\n\t\"springgreen\":(0,255,127),", "\t\"mediumspringgreen\":(0,250,154),\n\t\"springgreen\":(0,255,127),\n\t\"seagreen\":(46,139,87),\n\t\"mediumaquamarine\":(102,205,170),\n\t\"mediumseagreen\":(60,179,113),\n\t\"lightseagreen\":(32,178,170),\n\t\"darkslategray\":(47,79,79),\n\t\"teal\":(0,128,128),\n\t\"darkcyan\":(0,139,139),\n\t\"aqua\":(0,255,255),", "\t\"darkcyan\":(0,139,139),\n\t\"aqua\":(0,255,255),\n\t\"cyan\":(0,255,255),\n\t\"lightcyan\":(224,255,255),\n\t\"darkturquoise\":(0,206,209),\n\t\"turquoise\":(64,224,208),\n\t\"mediumturquoise\":(72,209,204),\n\t\"paleturquoise\":(175,238,238),\n\t\"aquamarine\":(127,255,212),\n\t\"powderblue\":(176,224,230),", "\t\"aquamarine\":(127,255,212),\n\t\"powderblue\":(176,224,230),\n\t\"cadetblue\":(95,158,160),\n\t\"steelblue\":(70,130,180),\n\t\"cornflowerblue\":(100,149,237),\n\t\"deepskyblue\":(0,191,255),\n\t\"dodgerblue\":(30,144,255),\n\t\"lightblue\":(173,216,230),\n\t\"skyblue\":(135,206,235),\n\t\"lightskyblue\":(135,206,250),", "\t\"skyblue\":(135,206,235),\n\t\"lightskyblue\":(135,206,250),\n\t\"midnightblue\":(25,25,112),\n\t\"navy\":(0,0,128),\n\t\"darkblue\":(0,0,139),\n\t\"mediumblue\":(0,0,205),\n\t\"blue\":(0,0,255),\n\t\"royalblue\":(65,105,225),\n\t\"blueviolet\":(138,43,226),\n\t\"indigo\":(75,0,130),", "\t\"blueviolet\":(138,43,226),\n\t\"indigo\":(75,0,130),\n\t\"darkslateblue\":(72,61,139),\n\t\"slateblue\":(106,90,205),\n\t\"mediumslateblue\":(123,104,238),\n\t\"mediumpurple\":(147,112,219),\n\t\"darkmagenta\":(139,0,139),\n\t\"darkviolet\":(148,0,211),\n\t\"darkorchid\":(153,50,204),\n\t\"mediumorchid\":(186,85,211),", "\t\"darkorchid\":(153,50,204),\n\t\"mediumorchid\":(186,85,211),\n\t\"purple\":(128,0,128),\n\t\"thistle\":(216,191,216),\n\t\"plum\":(221,160,221),\n\t\"violet\":(238,130,238),\n\t\"magenta\":(255,0,255),\n\t\"fuchsia\":(255,0,255),\n\t\"orchid\":(218,112,214),\n\t\"mediumvioletred\":(199,21,133),", "\t\"orchid\":(218,112,214),\n\t\"mediumvioletred\":(199,21,133),\n\t\"palevioletred\":(219,112,147),\n\t\"deeppink\":(255,20,147),\n\t\"hotpink\":(255,105,180),\n\t\"lightpink\":(255,182,193),\n\t\"pink\":(255,192,203),\n\t\"antiquewhite\":(250,235,215),\n\t\"beige\":(245,245,220),\n\t\"bisque\":(255,228,196),", "\t\"beige\":(245,245,220),\n\t\"bisque\":(255,228,196),\n\t\"blanchedalmond\":(255,235,205),\n\t\"wheat\":(245,222,179),\n\t\"cornsilk\":(255,248,220),\n\t\"lemonchiffon\":(255,250,205),\n\t\"lightgoldenrodyellow\":(250,250,210),\n\t\"lightyellow\":(255,255,224),\n\t\"saddlebrown\":(139,69,19),\n\t\"sienna\":(160,82,45),", "\t\"saddlebrown\":(139,69,19),\n\t\"sienna\":(160,82,45),\n\t\"chocolate\":(210,105,30),\n\t\"peru\":(205,133,63),\n\t\"sandybrown\":(244,164,96),\n\t\"burlywood\":(222,184,135),\n\t\"tan\":(210,180,140),\n\t\"rosybrown\":(188,143,143),\n\t\"moccasin\":(255,228,181),\n\t\"navajowhite\":(255,222,173),", "\t\"moccasin\":(255,228,181),\n\t\"navajowhite\":(255,222,173),\n\t\"peachpuff\":(255,218,185),\n\t\"mistyrose\":(255,228,225),\n\t\"lavenderblush\":(255,240,245),\n\t\"linen\":(250,240,230),\n\t\"oldlace\":(253,245,230),\n\t\"papayawhip\":(255,239,213),\n\t\"seashell\":(255,245,238),\n\t\"mintcream\":(245,255,250),", "\t\"seashell\":(255,245,238),\n\t\"mintcream\":(245,255,250),\n\t\"slategray\":(112,128,144),\n\t\"lightslategray\":(119,136,153),\n\t\"lightsteelblue\":(176,196,222),\n\t\"lavender\":(230,230,250),\n\t\"floralwhite\":(255,250,240),\n\t\"aliceblue\":(240,248,255),\n\t\"ghostwhite\":(248,248,255),\n\t\"honeydew\":(240,255,240),", "\t\"ghostwhite\":(248,248,255),\n\t\"honeydew\":(240,255,240),\n\t\"ivory\":(255,255,240),\n\t\"azure\":(240,255,255),\n\t\"snow\":(255,250,250),\n\t\"black\":(0,0,0),\n\t\"dimgray\":(105,105,105),\n\t\"dimgrey\":(105,105,105),\n\t\"gray\":(128,128,128),\n\t\"grey\":(128,128,128),", "\t\"gray\":(128,128,128),\n\t\"grey\":(128,128,128),\n\t\"darkgray\":(169,169,169),\n\t\"darkgrey\":(169,169,169),\n\t\"silver\":(192,192,192),\n\t\"lightgray\":(211,211,211),\n\t\"lightgrey\":(211,211,211),\n\t\"gainsboro\":(220,220,220),\n\t\"whitesmoke\":(245,245,245),\n\t\"white\":(255,255,255),", "\t\"whitesmoke\":(245,245,245),\n\t\"white\":(255,255,255),\n}\n\ndef _make_rgb(colour_in:ColourDef) -> tuple:\n    \"\"\"Converts a name to an RGB tuple.  If already tuple returns that.\"\"\"\n    if isinstance(colour_in,tuple):\n        return colour_in\n    if isinstance(colour_in,str):\n        colour_in = colour_in.strip().lower().replace(\" \", \"\")\n        if colour_in in _COLOURS:\n            return _COLOURS[colour_in]\n        raise ValueError\n    raise TypeError", "\n\n_REDKEY = \"r\"\n_GREENKEY = \"g\"\n_BLUEKEY = \"b\"\n_RGB_LIST = [_REDKEY, _GREENKEY, _BLUEKEY]\n\nAXIS_X = \"AXIS_X\"\nAXIS_Y = \"AXIS_Y\"\n", "AXIS_Y = \"AXIS_Y\"\n\n# Ways to combine colours\nMIX_ADD = \"MIX_ADD\"\nMIX_SUBTRACT = \"MIX_SUBTRACT\"\nMIX_AVERAGE = \"MIX_AVERAGE\"\nMIX_MIN = \"MIX_MIN\"\nMIX_MAX = \"MIX_MAX\"\n\n\nclass ColourBand:\n    \"\"\"A single dimension for a colour.  E.g. R, G, B.\n\n    Maps an input value to an output colour.\n    Output colour values will always be held to be within the range of\n     the colour range.\n    Colour range is used to identify the value extremes for\n    the colour values; there is no assumption that top > bottom.\n    Input range is used to set the relationship between in & out\n    but input values do not need to lie within that range.\n    Exponent skews the factor to create greater differentiation\n    at one end or another.\n    \"\"\"\n\n    def __init__(\n        self,\n        colour_bottom: int = 255,\n        colour_top: int = 0,\n        exponent: float = 1,\n        data_bottom: int = 0,\n        data_top: int = 100,\n    ) -> None:\n        self.colour_bottom = colour_bottom\n        self.colour_top = colour_top\n        self.exponent = exponent\n        self.data_bottom = data_bottom\n        self.data_top = data_top\n\n    def get_colour_value(self, data_value: int | float) -> int:\n        \"\"\"Return a colour value for a value input.\"\"\"\n        data_range_exponented = math.pow(\n            self.data_top, self.exponent\n        ) - math.pow(self.data_bottom, self.exponent)\n        colour_range = self.colour_top - self.colour_bottom\n        scale_factor = colour_range / data_range_exponented\n        ##print(f\"{data_value=};{data_range_exponented=};{colour_range=};{scale_factor=}\")\n        colour_val = round(\n            self.colour_bottom\n            + math.pow(data_value, self.exponent) * scale_factor\n        )\n        # Assure that return colour value is within range\n        if self.colour_bottom < self.colour_top:\n            colour_val = max(\n                min(colour_val, self.colour_top), self.colour_bottom\n            )\n        else:\n            colour_val = min(\n                max(colour_val, self.colour_top), self.colour_bottom\n            )\n        return colour_val\n\n    def dump(self) -> str:\n        \"\"\"Return contents of object as a string.\"\"\"\n        return (\n            f\"{self.colour_bottom=};{self.colour_top=};\"\n            f\"{self.exponent=};{self.data_bottom=};{self.data_top=}\"\n        )", "\n\nclass ColourBand:\n    \"\"\"A single dimension for a colour.  E.g. R, G, B.\n\n    Maps an input value to an output colour.\n    Output colour values will always be held to be within the range of\n     the colour range.\n    Colour range is used to identify the value extremes for\n    the colour values; there is no assumption that top > bottom.\n    Input range is used to set the relationship between in & out\n    but input values do not need to lie within that range.\n    Exponent skews the factor to create greater differentiation\n    at one end or another.\n    \"\"\"\n\n    def __init__(\n        self,\n        colour_bottom: int = 255,\n        colour_top: int = 0,\n        exponent: float = 1,\n        data_bottom: int = 0,\n        data_top: int = 100,\n    ) -> None:\n        self.colour_bottom = colour_bottom\n        self.colour_top = colour_top\n        self.exponent = exponent\n        self.data_bottom = data_bottom\n        self.data_top = data_top\n\n    def get_colour_value(self, data_value: int | float) -> int:\n        \"\"\"Return a colour value for a value input.\"\"\"\n        data_range_exponented = math.pow(\n            self.data_top, self.exponent\n        ) - math.pow(self.data_bottom, self.exponent)\n        colour_range = self.colour_top - self.colour_bottom\n        scale_factor = colour_range / data_range_exponented\n        ##print(f\"{data_value=};{data_range_exponented=};{colour_range=};{scale_factor=}\")\n        colour_val = round(\n            self.colour_bottom\n            + math.pow(data_value, self.exponent) * scale_factor\n        )\n        # Assure that return colour value is within range\n        if self.colour_bottom < self.colour_top:\n            colour_val = max(\n                min(colour_val, self.colour_top), self.colour_bottom\n            )\n        else:\n            colour_val = min(\n                max(colour_val, self.colour_top), self.colour_bottom\n            )\n        return colour_val\n\n    def dump(self) -> str:\n        \"\"\"Return contents of object as a string.\"\"\"\n        return (\n            f\"{self.colour_bottom=};{self.colour_top=};\"\n            f\"{self.exponent=};{self.data_bottom=};{self.data_top=}\"\n        )", "\n\nclass ColourMap:\n    \"\"\"Map X or X,Y data into a RGB colour space.\n\n    Create object, initialize with set_up_map(), then\n    get colour values from the map with get_rgb_tuple() or get_rgb_str()\n\n    Attributes:\n        _colour_data_axes[AXIS][COLOUR_BAND] = ColourBand\n        Where\n            AXIS is AXIS_X or AXIS_Y\n            COLOUR_BAND is _REDKEY, _GREENKEY, _BLUEKEY.\n        In use, bool(self._colour_data_axes[AXIS_Y]) tells us whether\n        this is a 1D map (False) or a 2D map (True).\n\n    Public methods:\n        __init__ - sets up _colour_data_axes dict\n        set_up_map() - creates the mapping between the data axes (X,Y) and\n            the colour bands\n        get_rgb_tuple() - get (R,G,B) ints as a tuple for given (x) or (x,y)\n        get_rgb_str() - same but returns as rgb string e.g. \"rbg(13,157,99)\"\n    \"\"\"\n\n    def __init__(\n        self,\n    ) -> None:\n        \"\"\"Inititalize the empty colour map.\"\"\"\n        self._colour_data_axes = {}\n        self._colour_data_axes[AXIS_X] = {}\n        self._colour_data_axes[AXIS_Y] = {}\n        # List of axes - either [AXIS_X] or [AXIS_X,AXIS_Y]\n        self.axes = []\n\n    def _assign_colours_for_one_data_axis(\n        self,\n        data_axis: str = AXIS_X,\n        zero_rgb: ColourDef = \"white\",\n        top_rgb: ColourDef = (128, 128, 128),\n    ) -> None:\n        \"\"\"Initialize one data axis into _colour_data_axes dict.\"\"\"\n        zero_rgb = _make_rgb(zero_rgb)\n        top_rgb = _make_rgb(top_rgb)\n        rgb_tuples = list(zip(_RGB_LIST, zero_rgb, top_rgb))\n        for colour, colour_bottom, colour_top in rgb_tuples:\n            band = ColourBand()\n            band.colour_bottom = colour_bottom\n            band.colour_top = colour_top\n            self._colour_data_axes[data_axis][colour] = band\n\n    def set_up_map(\n        self,\n        zero_colour: ColourDef,\n        x_max_colour: ColourDef,\n        y_max_colour: ColourDef = None,\n        x_bottom: float = 0,\n        x_top: float = 100,\n        y_bottom: float = 0,\n        y_top: float = 100,\n        x_exponent: float = 1,\n        y_exponent: float = 1,\n        mix_type: str = MIX_ADD,\n    ):\n        \"\"\"This sets up a colour map for 1-axis (X) or 2-axis (X,Y) data.\"\"\"\n        # Load colour dimensions for X 7 Y into self._colour_data_axes.\n        self._assign_colours_for_one_data_axis(\n            data_axis=AXIS_X,\n            zero_rgb=zero_colour,\n            top_rgb=x_max_colour,\n        )\n        self.axes.append(AXIS_X)\n        if y_max_colour:\n            self._assign_colours_for_one_data_axis(\n                data_axis=AXIS_Y,\n                zero_rgb=zero_colour,\n                top_rgb=y_max_colour,\n            )\n            self.axes.append(AXIS_Y)\n        # Add the data range info.\n        for axis in self.axes:\n            for band in self._colour_data_axes[axis].values():\n                band: ColourBand\n                if axis == AXIS_X:\n                    band.data_bottom = x_bottom\n                    band.data_top = x_top\n                    band.exponent = x_exponent\n                else:\n                    band.data_bottom = y_bottom\n                    band.data_top = y_top\n                    band.exponent = y_exponent\n        # How will the colours get mixed?\n        self.mix_type = mix_type\n\n    def _combine_colours(self, colours: list[int]) -> int:\n        \"\"\"Mix a list of colours within a single colour band.\"\"\"\n        if len(colours) == 1:\n            return colours[0]\n\n        if self.mix_type == MIX_AVERAGE:\n            # Average\n            result = statistics.mean(colours)\n        elif self.mix_type == MIX_MIN:\n            # Min\n            result = min(colours)\n        elif self.mix_type == MIX_MAX:\n            # Min\n            result = max(colours)\n        elif self.mix_type == MIX_SUBTRACT:\n            # Fancy subtractive\n            for i, c in enumerate(colours):\n                if i == 0:\n                    result = c\n                else:\n                    # do a fancy subtract of these 2 colours\n                    result = 255 - abs((255 - result) - (255 - c))\n                    result = max(min(255, result), 0)\n        elif self.mix_type == MIX_ADD:\n            # Fancy additive\n            for i, c in enumerate(colours):\n                if i == 0:\n                    result = c\n                else:\n                    # do a fancy addition of these 2 colours\n                    result = 255 - abs((255 - result) + (255 - c))\n                    result = max(min(255, result), 0)\n        else:\n            # Unknown mix_type\n            raise ValueError\n        result = max(min(255, result), 0)\n        return result\n\n    def get_rgb_tuple(self, x, y=None) -> tuple:\n        \"\"\"Return RGB tuple.\"\"\"\n        rgb_vals_list = dict(zip(_RGB_LIST, ([], [], [])))\n        x = x if x is not None else 0\n        for axis in self.axes:\n            input_val = x if axis == AXIS_X else y\n            for colour in _RGB_LIST:\n                this_band: ColourBand = self._colour_data_axes[axis][colour]\n                color_val = this_band.get_colour_value(input_val)\n                rgb_vals_list[colour].append(color_val)\n        rgb_vals = []\n        for colour in _RGB_LIST:\n            # Blend colours within this band.\n            val = self._combine_colours(rgb_vals_list[colour])\n            val = min(max(val, 0), 255)\n            rgb_vals.append(val)\n        return rgb_vals\n\n    def get_rgb_str(self, x, y=None) -> str:\n        \"\"\"Return html RGB string.\"\"\"\n        rgb_str = \",\".join([f\"{s}\" for s in self.get_rgb_tuple(x, y)])\n        return f\"rgb({rgb_str})\"\n\n    def dump(self) -> str:\n        \"\"\"Return the object into a string.\"\"\"\n        dstr = \"_colour_data_axes:\\n\"\n        for axis in sorted(self._colour_data_axes.keys()):\n            dstr = f\"{dstr}  axis: {axis}\\n\"\n            for colour in sorted(\n                self._colour_data_axes[axis].keys(), reverse=True\n            ):\n                dstr = f\"{dstr}    colour: {colour}:\\n\"\n                band: ColourBand\n                band = self._colour_data_axes[axis][colour]\n                if isinstance(band, ColourBand):\n                    dstr = f\"{dstr}      {band.dump()}\\n\"\n                else:\n                    dstr = f\"{dstr}      Object is type {type(band)}\\n\"\n        return dstr", "\n\nif __name__ == \"__main__\":\n\n    def style() -> str:\n        \"\"\"Return a CSS stylesheet as a string.\"\"\"\n        return \"\"\"\n            <style>\n                html {\n            font-family: sans-serif;\n            }\n\n            table {\n            border-collapse: collapse;\n            border: 2px solid rgb(200,200,200);\n            letter-spacing: 1px;\n            font-size: 0.8rem;\n            }\n\n            td, th {\n            border: 1px solid rgb(190,190,190);\n            padding: 5px 15px;\n            }\n\n            th {\n            background-color: rgb(235,235,235);\n            }\n\n            td {\n            text-align: right;\n            }\n\n            tr:nth-child(even) td {\n            background-color: rgb(250,250,250);\n            }\n\n            tr:nth-child(odd) td {\n            background-color: rgb(245,245,245);\n            }\n\n            caption {\n            padding: 10px;\n            }\n            </style>\n        \"\"\"\n\n    if False:\n        print(\"Content-type: text/plain\\n\\n\")\n        print(\"Test for single-data-axis map:\")\n        colorer = ColourMap()\n        colorer.set_up_map((255, 255, 255), (100, 255, 255), x_exponent=2)\n        print(f\"{colorer.dump()}\")\n        for x in [0, 10, 50, 90, 100]:\n            print(f\"{x} -> {colorer.get_rgb_str(x)}\")\n        print(\"\\nTest 2-axis map:\")\n        colorer = ColourMap()\n        colorer.set_up_map(\n            (255, 255, 255),\n            (100, 255, 255),\n            (255, 0, 128),\n            x_exponent=3,\n            y_exponent=1 / 3,\n        )\n        for x in [0, 5, 10, 20, 50, 100, 200]:\n            for y in [0, 10, 50, 90, 100]:\n                print(f\"({x},{y}) -> {colorer.get_rgb_str(x,y)}\")\n\n        print(\"\\nTest for contention error:\")\n        colorer = ColourMap()\n        colorer.set_up_map(\n            (255, 0, 0),\n            (00, 255, 255),\n            (0, 0, 255),\n        )\n\n    #    zero_colour=(200,200,200),\n    #    x_max_colour=(255,20,20),\n    #    y_max_colour=(0,0,255),\n    #    x_exponent=.3, #1.25, #.3\n    #    y_exponent=.75, #1.25, # .75\n\n    colorer = ColourMap()\n    colorer.set_up_map(\n        zero_colour=(240, 240, 240),\n        x_max_colour=(255, 40, 40),\n        y_max_colour=(128, 128, 255),\n        x_exponent=0.75,\n        y_exponent=0.75,\n        x_bottom=0,\n        x_top=30,\n        y_bottom=0,\n        y_top=120,\n    )\n\n    print(\"Content-type: text/html\\n\\n\\n\")\n    print(\"<html>\")\n    print(style())\n    print(\"<body>\")\n\n    # Generate a pretend block list\n    blocks = []\n    for x in range(12, 48):\n        blocks.append(x / 2)\n\n    def num2time(num) -> str:\n        \"\"\"Make H:M for # of hrs.\"\"\"\n        h = int(num + 0.000001)\n        m = round((num - h) * 60)\n        s = f\"{h}:{m:02d}\"\n        return s\n\n    def print_gap():\n        print(\n            \"<td style='border: 3px solid rgb(255,255,255);padding: 0px 0px;'></td>\"\n        )\n\n    print(\"<table>\")\n\n    print(\"<tr><th>Date</th>\")\n    print(\"<th colspan=6>6:00-8:30</th>\")\n    print_gap()\n    print(\"<th colspan=6>9:00-11:30</th>\")\n    print_gap()\n    print(\"<th colspan=6>12:00-14:30</th>\")\n    print_gap()\n    print(\"<th colspan=6>15:00-17:30</th>\")\n    print_gap()\n    print(\"<th colspan=6>18:00-20:30</th>\")\n    print_gap()\n    print(\"<th colspan=6>21:00-23:30</th>\")\n    print(\"</tr>\")\n\n    for y in range(21):\n        print(\"<tr>\")\n        print(\n            f\"<td>2023-{random.randint(1,12):02}-{random.randint(1,30):02}</td>\"\n        )\n        for x, block in enumerate(blocks):\n            if x % 6 == 0 and x > 0:\n                print_gap()\n\n            block_factor = block / max(blocks)\n            busy = random.randint(0, 30) * block_factor\n            full = random.randint(0, 120) * block_factor\n            content = num2time(block)\n            content = \",\".join([f\"{c}\" for c in colorer.get_rgb_tuple(x, y)])\n            content = \"&nbsp\"\n            # content = f\"{x},{y}\"\n            print(\n                f\"<td style='background-color: {colorer.get_rgb_str(busy,full)}'>{content}</td>\"\n            )\n        print(\"</tr>\")\n    print(\"</table>\")\n\n    print(f\"<pre>\\n{colorer.dump()}\\n</pre>\")\n    print(\"</body></html>\")", ""]}
{"filename": "tt_trackerday.py", "chunked_list": ["\"\"\"TagTracker by Julias Hocking.\n\nTrackerDay class for tagtracker.\nTrackerDay holds all the state information about a single day at the bike valet.\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or", "    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License", "\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"\n\nfrom typing import Union\nfrom tt_globals import *  # pylint:disable=unused-wildcard-import,wildcard-import\nfrom tt_tag import TagID\nfrom tt_time import VTime\nimport tt_util as ut", "from tt_time import VTime\nimport tt_util as ut\n\n\nclass TrackerDay:\n    \"\"\"One day's worth of tracker info and its context.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize blank.\"\"\"\n        self.date = \"\"\n        self.opening_time = \"\"\n        self.closing_time = \"\"\n        self.bikes_in = {}\n        self.bikes_out = {}\n        self.regular = frozenset()\n        self.oversize = frozenset()\n        self.retired = frozenset()\n        self.colour_letters = {}\n\n    def all_tags(self) -> frozenset[TagID]:\n        \"\"\"Return list of all usable tags.\"\"\"\n        return frozenset((self.regular | self.oversize) - self.retired)\n\n    def DISABLED__make_lowercase(self) -> None:\n        \"\"\"Set TrackerDay object to all lowercase.\"\"\"\n        self.regular = frozenset([t.lower() for t in self.regular])\n        self.oversize = frozenset([t.lower() for t in self.oversize])\n        self.retired = frozenset([t.lower() for t in self.retired])\n        self.bikes_in = {k.lower(): v for k, v in self.bikes_in.items()}\n        self.bikes_out = {k.lower(): v for k, v in self.bikes_out.items()}\n\n    def DISABLED__make_uppercase(self) -> None:\n        \"\"\"Set TrackerDay object to all uppercase.\"\"\"\n        self.regular = frozenset([t.upper() for t in self.regular])\n        self.oversize = frozenset([t.upper() for t in self.oversize])\n        self.retired = frozenset([t.upper() for t in self.retired])\n        self.bikes_in = {k.upper(): v for k, v in self.bikes_in.items()}\n        self.bikes_out = {k.upper(): v for k, v in self.bikes_out.items()}\n\n    def DISABLED__fold_case(self, uppercase: bool) -> None:\n        \"\"\"Folds to either uppercase or lowercase.\"\"\"\n        if uppercase:\n            self.DISABLED__make_uppercase()\n        else:\n            self.DISABLED__make_lowercase()\n\n    @staticmethod\n    def guess_tag_type(tag: TagID) -> str:\n        \"\"\"Guess the type of tag (R=regular or O=oversize).\"\"\"\n        colour = TagID(tag).colour.lower()\n        if colour in [\"o\", \"p\", \"w\", \"g\"]:\n            return \"R\"\n        if colour in [\"b\"]:\n            return \"O\"\n        return \"\"\n\n    def make_fake_tag_lists(self) -> None:\n        \"\"\"Fake up regular/oversized tag ists based on City Hall use in 2023.\"\"\"\n        regulars = set()\n        oversizes = set()\n        for tag in set(self.bikes_in.keys()) | set(self.bikes_out.keys()):\n            tag_type = self.guess_tag_type(tag)\n            if tag_type == \"R\":\n                regulars.add(tag)\n            elif tag_type == \"O\":\n                oversizes.add(tag)\n        self.regular = frozenset(regulars)\n        self.oversize = frozenset(oversizes)\n\n    def make_fake_colour_dict(self) -> None:\n        \"\"\"Fake up a colour dictionary in day from existing tags.\"\"\"\n        letters = set()\n        for tag in self.bikes_in:\n            letters.add(tag.colour.lower())\n        colour_dict = {}\n        for c in letters:\n            colour_dict[c] = f\"colour {c}\"\n        self.colour_letters = colour_dict\n\n    def lint_check(self, strict_datetimes: bool = False) -> list[str]:\n        \"\"\"Generate a list of logic error messages for TrackerDay object.\n\n        If no errors found returns []\n        If errors, returns list of error message strings.\n\n        Check for:\n        - bikes checked out but not in\n        - checked out before in\n        - multiple check-ins, multiple check-outs\n        - unrecognized tag in check-ins & check-outs\n        - poorly formed Tag\n        - poorly formed Time\n        - use of a tag that is retired (to do later)\n        If strict_datetimes then checks:\n        - valet date, opening and closing are well-formed\n        - valet opening time < closing time\n        \"\"\"\n\n        def bad_tags(taglist: list[TagID], listname: str) -> list[str]:\n            \"\"\"Get list of err msgs about poorly formed tags in taglist.\"\"\"\n            msgs = []\n            for tag in taglist:\n                tag: TagID\n                if not isinstance(tag, TagID) or not tag.valid:\n                    msgs.append(f\"Bad tag '{tag}' in {listname}\")\n            return msgs\n\n        def bad_times(timesdict: dict[str, VTime], listname: str) -> list[str]:\n            \"\"\"Get list of errors about mal-formed time values in timesdict.\"\"\"\n            msgs = []\n            for key, atime in timesdict.items():\n                if not isinstance(atime, VTime) or not atime:\n                    msgs.append(\n                        f\"Bad time '{atime}' in \"\n                        f\"{listname} with key '{key}'\"\n                    )\n            return msgs\n\n        errors = []\n        # Look for missing or bad times and dates\n        if strict_datetimes:\n            if not self.date or ut.date_str(self.date) != self.date:\n                errors.append(f\"Bad or missing valet date {self.date}\")\n            if not self.opening_time or not isinstance(\n                self.opening_time, VTime\n            ):\n                errors.append(\n                    f\"Bad or missing opening time {self.opening_time}\"\n                )\n            if not self.closing_time or not isinstance(\n                self.closing_time, VTime\n            ):\n                errors.append(\n                    f\"Bad or missing closing time {self.closing_time}\"\n                )\n            if (\n                self.opening_time\n                and self.closing_time\n                and self.opening_time >= self.closing_time\n            ):\n                errors.append(\n                    f\"Opening time '{self.opening_time}' is not \"\n                    f\"earlier then closing time '{self.closing_time}'\"\n                )\n        # Look for poorly formed times and tags\n        errors += bad_tags(self.regular, \"regular-tags\")\n        errors += bad_tags(self.oversize, \"oversize-tags\")\n        errors += bad_tags(self.bikes_in.keys(), \"bikes-checked-in\")\n        errors += bad_tags(self.bikes_out.keys(), \"bikes-checked-out\")\n        errors += bad_times(self.bikes_in, \"bikes-checked-in\")\n        errors += bad_times(self.bikes_out, \"bikes-checked-out\")\n        # Look for duplicates in regular and oversize tags lists\n        if len(self.regular | self.oversize) != len(self.regular) + len(\n            self.oversize\n        ):\n            errors.append(\n                \"Size mismatch between regular+oversize tags and their union\"\n            )\n        # Look for bike checked out but not in, or check-in later than check-out\n        for tag, atime in self.bikes_out.items():\n            if tag not in self.bikes_in:\n                errors.append(f\"Bike {tag} checked in but not out\")\n            elif atime < self.bikes_in[tag]:\n                errors.append(f\"Bike {tag} check-out earlier than check-in\")\n        # Bikes that are not in the list of allowed bikes\n        _allowed_tags = self.regular | self.oversize\n        _used_tags = self.bikes_in.keys() | self.bikes_out.keys()\n        for tag in _used_tags:\n            if tag not in _allowed_tags:\n                errors.append(\n                    f\"Tag {tag} not in use (not regular nor oversized)\"\n                )\n            if tag in self.retired:\n                errors.append(f\"Tag {tag} is marked as retired\")\n        return errors\n\n    def earliest_event(self) -> VTime:\n        \"\"\"Return the earliest event of the day as HH:MM (or \"\" if none).\"\"\"\n        all_events = self.bikes_in.keys() | self.bikes_out.keys()\n        if not all_events:\n            return \"\"\n        return min(all_events)\n\n    def latest_event(\n        self, as_of_when: Union[VTime, int, None] = None\n    ) -> VTime:\n        \"\"\"Return the latest event of the day at or before as_of_when.\n\n        If no events in the time period, return \"\".\n        If as_of_when is blank or None, then this will use the whole day.\n        \"\"\"\n        if not as_of_when:\n            as_of_when = VTime(\"24:00\")\n        else:\n            as_of_when = VTime(as_of_when)\n            if not (as_of_when):\n                return \"\"\n        events = [\n            x\n            for x in (\n                set(self.bikes_in.values()) | set(self.bikes_out.values())\n            )\n            if x <= as_of_when\n        ]\n        # Anything?\n        if not events:\n            return \"\"\n        # Find latest event of the day\n        latest = max(events)\n        return latest\n\n    def num_later_events(\n        self, after_when: Union[VTime, int, None] = None\n    ) -> int:\n        \"\"\"Get count of events that are later than after_when.\"\"\"\n        if not after_when:\n            after_when = VTime(\"now\")\n        else:\n            after_when = VTime(after_when)\n            if not (after_when):\n                return \"\"\n\n        events = [\n            x\n            for x in (\n                set(self.bikes_in.values()) | set(self.bikes_out.values())\n            )\n            if x > after_when\n        ]\n        return len(events)", ""]}
{"filename": "fullness_alert.py", "chunked_list": ["#!/usr/bin/env python3\n\"\"\"TagTracker utility to (maybe) send email.\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n", "    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"\n\n\nimport argparse\nimport os\nimport sys\nimport tt_dbutil as db\nimport tt_util as ut", "import tt_dbutil as db\nimport tt_util as ut\n\n\ndef parse_args() -> argparse.Namespace:\n    \"\"\"Collect command args into an argparse.Namespace.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Prints a message if DATE's max bikes were over THRESHOLD\",\n        epilog=\"This is intended to pipe into a mailer as an alert on \"\n        \"whether the valet was reaching critical capacity.  If bikes \"\n        \"are below THRESHOLD then normally no message is printed; \"\n        \"this is to fit into the 'discard empty messages' option \"\n        \"of mailing programs (e.g. -E for s-nail).  To make always \"\n        \"print a message, use the --force option.\",\n    )\n    parser.add_argument(\n        \"database_file\",\n        metavar=\"DATABASE_FILE\",\n        help=\"TagTracker database file\",\n    )\n    DEFAULT_DATE = \"yesterday\"\n    parser.add_argument(\n        \"--date\",\n        default=DEFAULT_DATE,\n        help=f\"date to test for fullness (default='{DEFAULT_DATE}')\",\n    )\n    DEFAULT_THRESHOLD = \"135\"\n    parser.add_argument(\n        \"--threshold\",\n        default=DEFAULT_THRESHOLD,\n        help=\"Print message if at least this many bikes \"\n        f\"(default={DEFAULT_THRESHOLD})\",\n    )\n    parser.add_argument(\n        \"--force\",\n        action=\"store_true\",\n        default=False,\n        help=\"Print a message even if max bikes is below threshold\",\n    )\n\n    the_args = parser.parse_args()\n    the_args.date = ut.date_str(the_args.date)\n    if not the_args.date:\n        print(\"Bad date\", file=sys.stderr)\n        sys.exit(1)\n    # What threshold to alert on?\n    if the_args.threshold and not the_args.threshold.isdigit():\n        print(\"Threshold must be integer\", file=sys.stderr)\n        sys.exit(1)\n    the_args.threshold = int(the_args.threshold)\n\n    return the_args", "\n\n# args needed: email address(es), option threshhold, database_file\nargs = parse_args()\n\n# How many bikes are there on the given date?\nif not os.path.exists(args.database_file):\n    print(f\"Database file {args.database_file} not found\", file=sys.stderr)\n    sys.exit(1)\ndatabase = db.db_connect(args.database_file, must_exist=True)", "database = db.db_connect(args.database_file, must_exist=True)\ndbrows = db.db_fetch(\n    database, f\"select max_total from day where date = '{args.date}'\"\n)\nif not dbrows:\n    print(f\"No data for {args.date}\", file=sys.stderr)\n    exit(1)\nmax_total = dbrows[0].max_total\nif max_total >= args.threshold:\n    print(\n        f\"Date {args.date} had {max_total} bikes; >= threshold of {args.threshold}\"\n    )\nelif args.force:\n    print(\n        f\"Date {args.date} had {max_total} bikes; less than threshold of {args.threshold}\"\n    )", "if max_total >= args.threshold:\n    print(\n        f\"Date {args.date} had {max_total} bikes; >= threshold of {args.threshold}\"\n    )\nelif args.force:\n    print(\n        f\"Date {args.date} had {max_total} bikes; less than threshold of {args.threshold}\"\n    )\n", ""]}
{"filename": "tt_datafile.py", "chunked_list": ["\"\"\"TagTracker by Julias Hocking.\n\nFunctions to save and retrieve data (TrackerDay objects) in datafiles.\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.", "    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.", "    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n    Datafiles (datafiles) contain a full day's tracker data.\n    It is made of both\n        key:value lines (for valet date, opening and closing time)\n        header/list sections (for tag lists and events):\n        Anything following comments (#) is ignored, as are blank lines and\n            lead/trailing whitespace\n", "            lead/trailing whitespace\n\n\"\"\"\nimport os\n\nfrom tt_globals import *  # pylint:disable=unused-wildcard-import,wildcard-import\nfrom tt_tag import TagID\nfrom tt_time import VTime\nimport tt_util as ut\nfrom tt_trackerday import TrackerDay", "import tt_util as ut\nfrom tt_trackerday import TrackerDay\nimport tt_conf as cfg\n\n# Header strings to use in datafile and tags- config file\n# These are used when writing & also for string-matching when reading.\nHEADER_BIKES_IN = \"Bikes checked in / tags out:\"\nHEADER_BIKES_OUT = \"Bikes checked out / tags in:\"\nHEADER_VALET_DATE = \"Valet date:\"\nHEADER_VALET_OPENS = \"Valet opens:\"", "HEADER_VALET_DATE = \"Valet date:\"\nHEADER_VALET_OPENS = \"Valet opens:\"\nHEADER_VALET_CLOSES = \"Valet closes:\"\nHEADER_OVERSIZE = \"Oversize-bike tags:\"\nHEADER_REGULAR = \"Regular-bike tags:\"\nHEADER_RETIRED = \"Retired tags:\"\nHEADER_COLOURS = \"Colour codes:\"\n\n\n\ndef datafile_name(folder: str, whatdate:str=\"today\") -> str:\n    \"\"\"Return the name of the data file (datafile) to read/write.\"\"\"\n    # Use default filename\n    date = ut.date_str(whatdate)\n    if not date:\n        return \"\"\n    return f\"{folder}/{cfg.DATA_BASENAME}{date}.dat\"", "\n\ndef datafile_name(folder: str, whatdate:str=\"today\") -> str:\n    \"\"\"Return the name of the data file (datafile) to read/write.\"\"\"\n    # Use default filename\n    date = ut.date_str(whatdate)\n    if not date:\n        return \"\"\n    return f\"{folder}/{cfg.DATA_BASENAME}{date}.dat\"\n", "\n\ndef rotate_datafile(filename: str) -> None:\n    \"\"\"Rename the current datafile to <itself>.bak.\"\"\"\n    backuppath = f\"{filename}.bak\"\n    if os.path.exists(backuppath):\n        os.unlink(backuppath)\n    if os.path.exists(filename):\n        os.rename(filename, backuppath)\n    return None", "\n\ndef read_datafile(\n    filename: str, err_msgs: list[str], usable_tags: list[TagID] = None\n) -> TrackerDay:\n    \"\"\"Fetch tag data from file into a TrackerDay object.\n\n    Read data from a pre-existing data file, returns the info in a\n    TrackerDay object.  If no file, TrackerDay will be mostly blank.\n\n    err_msgs is the (presumably empty) list, to which any error messages\n    will be appended.  If no messages are added, then it means this\n    ran without error.\n\n    usable_tags is a list of tags that can be used; if a tag is not in the\n    list then it's an error.  If usable_tags is empty or None then no\n    checking takes place.\n\n    \"\"\"\n\n    def data_read_error(\n        text: str,\n        message_list: list[str],\n        errs: int = 0,\n        fname: str = \"\",\n        fline: int = None,\n    ) -> int:\n        \"\"\"Print a datafile read error, increments error counter.\n\n        This returns the incremented error counter.  Ugh.\n        Also, if this is the first error (errors_before is None or 0)\n        then this makes an initial print() on the assumptino that the\n        immediately preceding print() statement had end=\"\".\n        \"\"\"\n        text = f\" {text}\"\n        if fline:\n            text = f\"{fline}:{text}\"\n        if fname:\n            text = f\"{fname}:{text}\"\n        message_list.append(text)\n        return errs + 1\n\n    data = TrackerDay()\n    errors = 0  # How many errors found reading datafile?\n    section = None\n    with open(filename, \"r\", encoding=\"utf-8\") as f:\n\n        for line_num, line in enumerate(f, start=1):\n            # ignore blank or # comment lines\n            line = re.sub(r\"\\s*#.*\", \"\", line)\n            line = line.strip()\n            if not line:\n                continue\n            # Look for section headers to figure out what section we will process\n            if re.match(rf\"^ *{HEADER_BIKES_IN}\", line):\n                section = BIKE_IN\n                continue\n            elif re.match(rf\"^ *{HEADER_BIKES_OUT}\", line):\n                section = BIKE_OUT\n                continue\n            # Look for headers for oversize & regular bikes, ignore them.\n            elif re.match(rf\"^ *{HEADER_REGULAR}\", line):\n                section = REGULAR\n                continue\n            elif re.match(rf\"^ *{HEADER_OVERSIZE}\", line):\n                section = OVERSIZE\n                continue\n            elif re.match(rf\"^ *{HEADER_RETIRED}\", line):\n                section = RETIRED\n                continue\n            elif re.match(rf\"^ *{HEADER_COLOURS}\", line):\n                section = COLOURS\n                continue\n            elif re.match(rf\"^ *{HEADER_VALET_DATE}\", line):\n                # Read the datafile's date\n                section = IGNORE\n                r = re.match(rf\"{HEADER_VALET_DATE} *(.+)\", line)\n                maybedate = ut.date_str(r.group(1))\n                if not maybedate:\n                    errors = data_read_error(\n                        \"Unable to read valet date\",\n                        err_msgs,\n                        errs=errors,\n                        fname=filename,\n                        fline=line_num,\n                    )\n                    continue\n                data.date = maybedate\n                continue\n            elif re.match(rf\"({HEADER_VALET_OPENS}|{HEADER_VALET_CLOSES})\", line):\n                # This is an open or a close time (probably)\n                section = IGNORE\n                r = re.match(\n                    rf\"({HEADER_VALET_OPENS}|{HEADER_VALET_CLOSES}) *(.+)\", line\n                )\n                maybetime = VTime(r.group(2))\n                if not maybetime:\n                    errors = data_read_error(\n                        f\"Unable to understand valet open/close time '{maybetime.original}'\",\n                        err_msgs,\n                        errs=errors,\n                        fname=filename,\n                        fline=line_num,\n                    )\n                    continue\n                if r.group(1) == HEADER_VALET_OPENS:\n                    data.opening_time = maybetime\n                else:\n                    data.closing_time = maybetime\n                continue\n            # Can do nothing unless we know what section we're in\n            if section is None:\n                errors = data_read_error(\n                    \"Unexpected unintelligibility in line\",\n                    err_msgs,\n                    errs=errors,\n                    fname=filename,\n                    fline=line_num,\n                )\n                continue\n\n            if section == IGNORE:\n                # Things to ignore\n                continue\n\n            if section == COLOURS:\n                # Read the colour dictionary\n                bits = ut.splitline(line)\n                if len(bits) < 2:\n                    errors = data_read_error(\n                        f\"Bad colour code '{line}\",\n                        err_msgs,\n                        errs=errors,\n                        fname=filename,\n                        fline=line_num,\n                    )\n                    continue\n                if bits[0] in data.colour_letters:\n                    errors = data_read_error(\n                        f\"Duplicate colour code '{bits[0]}\",\n                        err_msgs,\n                        errs=errors,\n                        fname=filename,\n                        fline=line_num,\n                    )\n                    continue\n                data.colour_letters[bits[0]] = \" \".join(bits[1:])\n                continue\n\n            if section in [REGULAR, OVERSIZE, RETIRED]:\n                # Break each line into 0 or more tags\n                bits = ut.splitline(line)\n                taglist = [TagID(x) for x in bits]\n                taglist = [x for x in taglist if x]  # remove blanks\n                # Any errors?\n                if len(taglist) != len(bits):\n                    errors = data_read_error(\n                        f\"Bad tag(s) in '{line}\",\n                        err_msgs,\n                        errs=errors,\n                        fname=filename,\n                        fline=line_num,\n                    )\n                    continue\n                # Looks like we have some tags\n                if section == REGULAR:\n                    data.regular |= set(taglist)\n                elif section == OVERSIZE:\n                    data.oversize |= set(taglist)\n                elif section == RETIRED:\n                    data.retired |= set(taglist)\n                else:\n                    ut.squawk(f\"Bad section value in read_datafile(), '{section}\")\n                    return\n                continue\n\n            if section not in [BIKE_IN, BIKE_OUT]:\n                ut.squawk(f\"Bad section value in read_datafile(), '{section}\")\n                return\n\n            # This is a tags in or tags out section\n            # Break into putative tag and text, looking for errors\n            cells = line.split(\",\")\n            if len(cells) != 2:\n                errors = data_read_error(\n                    \"Bad line in file\",\n                    err_msgs,\n                    errs=errors,\n                    fname=filename,\n                    fline=line_num,\n                )\n                continue\n            this_tag = TagID(cells[0])\n            if not (this_tag):\n                errors = data_read_error(\n                    \"String does not appear to be a tag\",\n                    err_msgs,\n                    errs=errors,\n                    fname=filename,\n                    fline=line_num,\n                )\n                continue\n            if usable_tags and this_tag not in usable_tags:\n                errors = data_read_error(\n                    f\"Tag '{this_tag}' not in use\",\n                    err_msgs,\n                    errs=errors,\n                    fname=filename,\n                    fline=line_num,\n                )\n                continue\n            this_time = VTime(cells[1])\n            if not (this_time):\n                errors = data_read_error(\n                    \"Poorly formed time value\",\n                    err_msgs,\n                    errs=errors,\n                    fname=filename,\n                    fline=line_num,\n                )\n                continue\n            # Maybe add to data.bikes_in or data.bikes_out structures.\n            if section == BIKE_IN:\n                # Maybe add to check_in structure\n                if this_tag in data.bikes_in:\n                    errors = data_read_error(\n                        f\"Duplicate {this_tag} check-in\",\n                        err_msgs,\n                        errs=errors,\n                        fname=filename,\n                        fline=line_num,\n                    )\n                    continue\n                if this_tag in data.bikes_out and data.bikes_out[this_tag] < this_time:\n                    errors = data_read_error(\n                        f\"Tag {this_tag} check out before check-in\",\n                        err_msgs,\n                        errs=errors,\n                        fname=filename,\n                        fline=line_num,\n                    )\n                    continue\n                data.bikes_in[this_tag] = this_time\n            elif section == BIKE_OUT:\n                if this_tag in data.bikes_out:\n                    errors = data_read_error(\n                        f\"Duplicate {this_tag} check-out\",\n                        err_msgs,\n                        errs=errors,\n                        fname=filename,\n                        fline=line_num,\n                    )\n                    continue\n                if this_tag not in data.bikes_in:\n                    errors = data_read_error(\n                        f\"Tag {this_tag} checked out but not in\",\n                        err_msgs,\n                        errs=errors,\n                        fname=filename,\n                        fline=line_num,\n                    )\n                    continue\n                if this_tag in data.bikes_in and data.bikes_in[this_tag] > this_time:\n                    errors = data_read_error(\n                        f\"Tag {this_tag} check out before check-in\",\n                        err_msgs,\n                        errs=errors,\n                        fname=filename,\n                        fline=line_num,\n                    )\n                    continue\n                data.bikes_out[this_tag] = this_time\n            else:\n                ut.squawk(\"PROGRAM ERROR: should not reach this code spot\")\n                errors += 1\n                continue\n\n    if errors:\n        err_msgs.append(f\"Found {errors} errors in datafile {filename}\")\n    # If no colour dictionary, fake one up\n    if not data.colour_letters:\n        data.make_fake_colour_dict()\n    # Return today's working data.\n    return data", "\n\ndef write_datafile(\n    filename: str, data: TrackerDay, header_lines: list = None\n) -> bool:\n    \"\"\"Write current data to today's data file.\n\n    Return True if succeeded, False if failed.\n    \"\"\"\n    lines = []\n    if header_lines:\n        lines = header_lines\n    else:\n        lines.append(\n            \"# TagTracker datafile (data file) created on \"\n            f\"{ut.date_str('today')} {VTime('now')}\"\n        )\n        lines.append(f\"# TagTracker version {ut.get_version()}\")\n    # Valet data, opening & closing hours\n    if data.date:\n        lines.append(f\"{HEADER_VALET_DATE} {data.date}\")\n    if data.opening_time:\n        lines.append(f\"{HEADER_VALET_OPENS} {data.opening_time}\")\n    if data.closing_time:\n        lines.append(f\"{HEADER_VALET_CLOSES} {data.closing_time}\")\n\n    lines.append(HEADER_BIKES_IN)\n    for tag, atime in data.bikes_in.items():  # for each bike checked in\n        lines.append(f\"{tag.canon},{atime}\")  # add a line \"tag,time\"\n    lines.append(HEADER_BIKES_OUT)\n    for tag, atime in data.bikes_out.items():  # for each  checked\n        lines.append(f\"{tag.canon},{atime}\")  # add a line \"tag,time\"\n    # Also write tag info of which bikes are oversize, which are regular.\n    # This to make complete bundles for historic information\n    lines.append(\"# Following sections are context for the check-ins/outs\")\n    lines.append(HEADER_REGULAR)\n    for group in ut.taglists_by_prefix(data.regular):\n        lines.append(\" \".join(group).lower())\n    lines.append(HEADER_OVERSIZE)\n    for group in ut.taglists_by_prefix(data.oversize):\n        lines.append(\" \".join(group).lower())\n    lines.append(HEADER_RETIRED)\n    lines.append(\" \".join(data.retired).lower())\n    lines.append(HEADER_COLOURS)\n    for letter, name in data.colour_letters.items():\n        lines.append(f\"{letter.lower()},{name}\")\n    lines.append(\"# Normal end of file\")\n    # Write the data to the file.\n    try:\n        with open(filename, \"w\", encoding=\"utf-8\") as f:  # write stored lines to file\n            for line in lines:\n                f.write(line)\n                f.write(\"\\n\")\n    except OSError:\n        ut.squawk(f\"PROBLEM: Unable to create datafile '{filename}'\")\n        return False\n    return True", "\n\ndef new_tag_config_file(filename: str):\n    \"\"\"Create new, empty tags config file.\"\"\"\n    template = [\n        \"# Tags configuration file for TagTracker \\n\",\n        \"\\n\",\n        \"# Regular bike tags are tags that are used for bikes that are stored on racks.\\n\",\n        \"# List tags in any order, with one or more tags per line,\\n\",\n        \"# separated by spaces or commas.\\n\",\n        \"# E.g. bf1 bf2 bf3 bf4\\n\",\n        \"Regular-bike tags:\\n\\n\",\n        \"# Oversize bike tags are tags that are used for oversize bikes.\\n\",\n        \"# List tags in any order, with one or more tags per line,\\n\",\n        \"# separated by spaces or commas.\\n\",\n        \"# E.g. bf1 bf2 bf3 bf4\\n\",\n        \"Oversize-bike tags:\\n\\n\",\n        \"# Retired tags are tags that are no longer available for use.\\n\",\n        \"Retired tags:\\n\\n\",\n        \"# Colour codes are used to format reports.\\n\",\n        \"# Each line is one- or two-letter colour code then the name of the colour\\n\",\n        \"# E.g. r red \\n\",\n        \"Colour codes:\\n\\n\",\n    ]\n    if not os.path.exists(filename):  # make new tags config file only if needed\n        try:\n            with open(filename, \"w\", encoding=\"utf-8\") as f:\n                f.writelines(template)\n        except OSError:\n            ut.squawk(f\"ERROR: Unable to write file {filename}\")\n            ut.squawk(\"exiting\")\n            exit(1)", ""]}
{"filename": "tt_globals.py", "chunked_list": ["\"\"\"TagTracker by Julias Hocking.\n\nGlobal constants for use through most or all the TagTracker modules.\nThese are meant to be wildcard-imported.\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or", "    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License", "\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"\nimport re\n\n# Type aliases only to improve readability and IDE linting\nMaybeTag = str\nMaybeTime = str\nMaybeDate = str", "MaybeTime = str\nMaybeDate = str\n\n# Constants to use as dictionary keys.\n# E.g. rather than something[this_time][\"tag\"] = \"whatever\",\n# could instead be something[this_time][TAG_KEY] = \"whatever\"\n# The values of these constants aren't important as long as they're unique.\n# By using these rather than string values, the lint checker in the\n# editor can pick up missing or misspelled items, as can Python itself.\n# These all have a non-ASCII chr (\u2192) at the beginning to make it unlikely", "# editor can pick up missing or misspelled items, as can Python itself.\n# These all have a non-ASCII chr (\u2192) at the beginning to make it unlikely\n# that their values would ever get typed or otherwise be non-unique\n\nTAG = chr(0x2192) + \"tag\"\nBIKE_IN = chr(0x2192) + \"bike_in\"\nBIKE_OUT = chr(0x2192) + \"bike_out\"\nINOUT = chr(0x2192) + \"inout\"\nREGULAR = chr(0x2192) + \"regular\"\nOVERSIZE = chr(0x2192) + \"oversize\"", "REGULAR = chr(0x2192) + \"regular\"\nOVERSIZE = chr(0x2192) + \"oversize\"\nMIXED = chr(0x2192) + \"mixed\"\nRETIRED = chr(0x2192) + \"retired\"\nUSABLE = chr(0x2192) + \"usable\"\nTOTAL = chr(0x2192) + \"total\"\nCOUNT = chr(0x2192) + \"count\"\nTIME = chr(0x2192) + \"time\"\nIGNORE = chr(0x2192) + \"ignore\"\nCOLOURS = chr(0x2192) + \"colours\"", "IGNORE = chr(0x2192) + \"ignore\"\nCOLOURS = chr(0x2192) + \"colours\"\nBADVALUE = chr(0x2192) + \"badvalue\"\nUPPERCASE = chr(0x2192) + \"uppercase\"\nLOWERCASE = chr(0x2192) + \"lowercase\"\nUNKNOWN = chr(0x2192) + \"unknown\"\nON = chr(0x2192) + \"on\"\nOFF = chr(0x2192) + \"off\"\n\n# Here's how I really want to do it, but then pylint won't know they're defined", "\n# Here's how I really want to do it, but then pylint won't know they're defined\n# for keyword in [\n#    \"TAG\", \"TIME\",\n#    \"BIKE_IN\",\"BIKE_OUT\",\"INOUT\",\n#    \"REGULAR\",\"OVERSIZE\",\"RETIRED\",\n#    \"TOTAL\",\"COUNT\",\n#    \"IGNORE\",\n#    \"COLOURS\",\n#    \"BADVALUE\",", "#    \"COLOURS\",\n#    \"BADVALUE\",\n#    \"UPPERCASE\",\"LOWERCASE\",\n#   \"UNKNOWN\",\n#    \"ON\",\"OFF\"\n# ]:\n#   globals()[keyword] = chr(0x2192) + keyword.lower()\n\n# Date re checks for date that might be in another string\n_DATE_RE = r\"(2[0-9][0-9][0-9])[/-]([01]?[0-9])[/-]([0123]?[0-9])\"", "# Date re checks for date that might be in another string\n_DATE_RE = r\"(2[0-9][0-9][0-9])[/-]([01]?[0-9])[/-]([0123]?[0-9])\"\n# Match a date within another string\nDATE_PART_RE = re.compile(r\"(\\b|[^a-zA-Z0-9])\" + _DATE_RE + r\"\\b\")\n# Match a date as the whole string\nDATE_FULL_RE = re.compile(r\"^ *\" + _DATE_RE + \" *$\")\n"]}
{"filename": "dbupdate.py", "chunked_list": ["#!/usr/bin/env python3\n\"\"\"Update existing records in TagTraker database.\n\nReads info from day-end-form (csv) or from other\nsources (e.g. weather info from NRCan? tbd)\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published", "    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n", "    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"\n\n\nimport argparse\nimport csv\nimport datetime", "import csv\nimport datetime\nimport sys\nimport sqlite3\n\nimport tt_dbutil as db\nimport tt_util as ut\nfrom tt_time import VTime\n\n\nclass NewVals:\n    \"\"\"This tiny class is just for holding data from new source.\n\n    NRCan will use some fields, day-end-form may use some fields.\n    \"\"\"\n\n    def __init__(\n        self,\n        registrations: int = None,\n        abandoned: int = None,\n        precip: float = None,\n        max_temp: float = None,\n        min_temp: float = None,\n        mean_temp:float = None,\n        rainfall: float = None,\n        sunset:str = None,\n    ) -> None:\n        self.registrations = registrations\n        self.abandoned = abandoned\n        self.precip = precip\n        self.max_temp = max_temp\n        self.min_temp = min_temp\n        self.mean_temp = mean_temp\n        self.rainfall = rainfall\n        self.sunset = sunset\n\n    def dump(self):\n        return (f\"{self.registrations=}; {self.abandoned=}; {self.precip=}; \"\n            f\"{self.max_temp=}; {self.min_temp=}; {self.mean_temp=}\")", "\n\nclass NewVals:\n    \"\"\"This tiny class is just for holding data from new source.\n\n    NRCan will use some fields, day-end-form may use some fields.\n    \"\"\"\n\n    def __init__(\n        self,\n        registrations: int = None,\n        abandoned: int = None,\n        precip: float = None,\n        max_temp: float = None,\n        min_temp: float = None,\n        mean_temp:float = None,\n        rainfall: float = None,\n        sunset:str = None,\n    ) -> None:\n        self.registrations = registrations\n        self.abandoned = abandoned\n        self.precip = precip\n        self.max_temp = max_temp\n        self.min_temp = min_temp\n        self.mean_temp = mean_temp\n        self.rainfall = rainfall\n        self.sunset = sunset\n\n    def dump(self):\n        return (f\"{self.registrations=}; {self.abandoned=}; {self.precip=}; \"\n            f\"{self.max_temp=}; {self.min_temp=}; {self.mean_temp=}\")", "\ndef oneval(\n    thisrow: list,\n    field: int,\n    want_num: bool = False,\n    want_int: bool = False,\n) -> str | int | float | None:\n    \"\"\"Get item field from thisrow.\"\"\"\n    myval = (thisrow + [\"\"] * 20)[field]\n    if want_int:\n        if myval.isdigit():\n            return int(myval)\n        else:\n            return None\n    if want_num:\n        try:\n            return float(myval)\n        except ValueError:\n            return None\n    return myval", "\ndef read_day_end_vals(\n    day_end_csv: str,\n) -> dict[str, NewVals]:\n    \"\"\"Get data from day end form google sheet csv file.\n\n    Sample lines:\n        \"Timestamp\",\"Email Address\",\"What Day?\",\"Staff Name (who is filling this out)\",\"Day\",\"Opening Time\",\"Closing Time\",\"Bike Parking Time Average (Mean)\",\"Regular Bikes Parked\",\"Oversized Bikes Parked\",\"Total Bikes Parked (Manual Count)\",\"What cool, interesting, or weird things did you park today?\",\"Project 529 Registrations Today\",\"Weather description\",\"Precipitation (https://www.victoriaweather.ca/datatime.php?field=raintotal&interval=1440&year=2022&month=7&day=20)\",\"Temperature (#)\",\"Day End Checklist: make sure to complete all tasks\",\"How many abandoned bikes were there left? (#)\",\"Notes, feedback, suggestions, comments?\",\"Bike Parking Time (Median)\",\"Bike Parking Time (Mode)\",\"AM Bikes (#)\",\"PM Bikes (#)\",\"Stays under 1.5 Hours (#)\",\"Stays between 1.5 and 5 hours (#)\",\"Stays over 5 hours (#)\",\"Maximum Time Parked\",\"Minimum Time Parked\",\"Total Tags Tracked (AM+PM bikes)\",\"Precipitation (https://www.victoriaweather.ca/datatime.php?field=raintotal&interval=1440&year=2022&month=7&day=20)\"\n        \"3/27/2023 17:52:42\",\"\",\"3/27/2023\",\"todd\",\"Monday\",\"7:30:00 AM\",\"6:00:00 PM\",\"5:00:00\",\"51\",\"41\",\"92\",\"\",\"4\",\"clear light wind\",\"0\",\"11\",\"Sandwich boards collected, Inventory completed, Abandoned bikes photographed and locked (if any), Abandoned bikes photos sent to coordinator (if any)\",\"0\",\"\",\"4:00:00\",\"3:00:00\",\"56\",\"30\",\"0\",\"67\",\"23\",\"10:30:00\",\"0:30:00\",\"86\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"\n    Items of potential interest (0-based counting)\n        0: m/d/yyyy hh:mm:ss timestamp\n        2: m/dd/yyyy datestamp indicating date for the data <-- prone to error\n        12: 529 registrations\n        13: weather description\n        14: precip (from https://www.victoriaweather.ca/datatime.php?field=raintotal&interval=1440&year=2022&month=7&day=20)\n        15: temp (manually entered)\n        17: abandoned bikes\n\n    \"\"\"\n\n    def mdy2ymd(maybedate: str) -> str:\n        \"\"\"Convert \"m/d/y h:m:s\" string to ISO YYYY-MM-DD string (or \"\").\"\"\"\n        datepart = (maybedate.split() + [\"\"])[0]\n        try:\n            newdate = datetime.datetime.strptime(datepart, \"%m/%d/%Y\")\n        except ValueError:\n            return \"\"\n        return newdate.strftime(\"%Y-%m-%d\")\n\n    results = {}\n    with open(day_end_csv, \"r\", newline=\"\", encoding=\"utf-8\") as csvfile:\n        dereader = csv.reader(csvfile)\n        for row in dereader:\n            thisdate = mdy2ymd(row[0])\n            if not thisdate:\n                continue\n            results[thisdate] = NewVals(\n                registrations=oneval(row, 12, want_int=True),\n                abandoned=oneval(row, 17, want_int=True),\n                #precip=oneval(row, 14, want_num=True),\n                #temp=oneval(row, 15, want_num=True),\n            )\n    return results", "\n\ndef get_day_end_changes(\n    ttdb:sqlite3.Connection,\n    day_end_file: str,\n    force: bool,\n    onedate: str,\n) -> list[str]:\n    \"\"\"Get SQL statements of changes from day end form source.\"\"\"\n\n    where = f\" where date = '{onedate}' \" if onedate else \"\"\n    db_data = db.db_fetch(\n        ttdb,\n        \"select \"\n        \"   date, registrations, leftover, precip_mm, temp \"\n        \"from day \"\n        f\"{where}\"\n        \"order by date\",\n    )\n    if not db_data:\n        return []\n\n    new = read_day_end_vals(day_end_file)\n    sqls = []\n    for existing in db_data:\n        if onedate and onedate != existing.date:\n            continue\n\n        if (\n            (force or existing.registrations is None)\n            and existing.date in new\n            and new[existing.date].registrations is not None\n        ):\n            sqls.append(\n                f\"update day set registrations = {new[existing.date].registrations} where date = '{existing.date}';\"\n            )\n        if (\n            (force or existing.leftover is None)\n            and existing.date in new\n            and new[existing.date].abandoned is not None\n        ):\n            sqls.append(\n                f\"update day set leftover = {new[existing.date].abandoned} where date = '{existing.date}';\"\n            )\n    return sqls", "\n\ndef read_wx_data(source_csv: str) -> dict[str, NewVals]:\n    \"\"\"Get weather data from NRCan data file for given range of dates.\n\n    https://api.weather.gc.ca/collections/climate-daily/items?datetime=2023-01-01%2000:00:00/2023-07-09%2000:00:00&STN_ID=51337&sortby=PROVINCE_CODE,STN_ID,LOCAL_DATE&f=csv&limit=150000&startindex=0\n    7,8,9: y,m,d\n    10 - mean temp\n    12 - min temp\n    14 - max temp\n    16 - total precip\n    18 - total rainfall\n    30 - heating degree days\n\n    ANother(?) possible URL:\n    YYJ: https://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=csv&stationID=51337&Year=2023&Month=7&Day=1&time=&timeframe=2&submit=Download+Data\n    UVic: https://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=csv&stationID=6812&Year=2023&Month=7&Day=1&time=&timeframe=2&submit=Download+Data\n    5,6,7: y,m,d\n    9: max temp\n    11: min temp\n    13: mean temp\n    23: precip\n\n    \"\"\"\n\n\n    results = {}\n    with open(source_csv, \"r\", newline=\"\", encoding=\"utf-8\") as csvfile:\n        for row in csv.reader(csvfile):\n            maybedate = f\"{row[5]}-{('0'+row[6])[-2:]}-{('0'+row[7])[-2:]}\"\n            thisdate = ut.date_str(maybedate)\n            if not thisdate:\n                continue\n            results[thisdate] = NewVals(\n                precip=oneval(row, 23, want_num=True),\n                #temp=oneval(row, 14, want_num=True),    # max\n                min_temp=oneval(row,11,want_num=True),\n                max_temp=oneval(row,9,want_num=True),\n                mean_temp=oneval(row,13,want_num=True),\n            )\n    return results", "\n\ndef get_wx_changes(\n    ttdb:sqlite3.Connection,\n    source_csv: str,\n    force: str,\n    onedate: str,\n) -> list[str]:\n    \"\"\"Get SQL statements of changes from NRCan source.\"\"\"\n\n    where = f\" where date = '{onedate}' \" if onedate else \"\"\n    db_data = db.db_fetch(\n        ttdb,\n        \"select \"\n        \"   date, registrations, leftover, precip_mm, temp \"\n        \"from day \"\n        f\"{where}\"\n        \"order by date\",\n    )\n    if not db_data:\n        return []\n\n    new = read_wx_data(source_csv)\n\n    sqls = []\n    for existing in db_data:\n        if onedate and onedate != existing.date:\n            continue\n\n        if (\n            (force or existing.precip_mm is None)\n            and existing.date in new\n            and new[existing.date].precip is not None\n        ):\n            sqls.append(\n                f\"update day set precip_mm = {new[existing.date].precip} where date = '{existing.date}';\"\n            )\n        if (\n            (force or not existing.temp)\n            and existing.date in new\n            and new[existing.date].max_temp is not None\n        ):\n            sqls.append(\n                f\"update day set temp = {new[existing.date].max_temp} where date = '{existing.date}';\"\n            )\n    return sqls", "#-------------------\ndef read_sun_data(source_csv: str) -> dict[str, NewVals]:\n    \"\"\"Get sunset data from NRCan data file for given range of dates.\n\n    Using whole-year text file produced from solar calculator at\n    https://nrc.canada.ca/en/research-development/products-services/software-applications/sun-calculator/\n\n    Fields of interest:\n        0: Data as \"Mmm D YYYY\"\n        5: sunset\n        6: civilian twilight\n        7: nautical twilight\n\n    \"\"\"\n\n    MONTHS={'Jan':'01','Feb':'02','Mar':'03','Apr':'04','May':'05','Jun':'06',\n            'Jul':'07','Aug':'08','Sep':'09','Oct':'10','Nov':'11','Dec':'12'}\n\n    results = {}\n    with open(source_csv, \"r\", newline=\"\", encoding=\"utf-8\") as csvfile:\n        for row in csv.reader(csvfile):\n            if not row or not row[0]:\n                if args.verbose:\n                    print(f\"discarding sun csv row {row}\")\n                continue\n            # Break first element into date elements\n            datebits = row[0].split()\n            if len(datebits) != 3:\n                if args.verbose:\n                    print(f\"discarding bad date in sun csv row {row}\")\n                continue\n            maybedate = f\"{datebits[2]}-{MONTHS[datebits[0]]}-{('0'+datebits[1])[-2:]}\"\n            thisdate = ut.date_str(maybedate)\n            if not thisdate:\n                continue\n            if args.verbose:\n                print(f\"have date: {thisdate}\")\n            results[thisdate] = NewVals(\n                sunset=VTime(oneval(row, 6)),\n            )\n        if args.verbose:\n            [print(f\"{d}: {s.sunset}\") for d,s in results.items()]\n    return results", "\n\ndef get_sun_changes(\n    ttdb:sqlite3.Connection,\n    source_csv: str,\n    force: str,\n    onedate: str,\n) -> list[str]:\n    \"\"\"Get SQL statements of changes from NRCan source.\"\"\"\n\n    where = f\" where date = '{onedate}' \" if onedate else \"\"\n    db_data = db.db_fetch(\n        ttdb,\n        \"select \"\n        \"   date, sunset \"\n        \"from day \"\n        f\"{where}\"\n        \"order by date\",\n    )\n    if not db_data:\n        return []\n    if args.verbose:\n        for row in db_data:\n            print(f\"{row.date=};{row.sunset=}\")\n    new = read_sun_data(source_csv)\n\n    sqls = []\n    for existing in db_data:\n        if onedate and onedate != existing.date:\n            continue\n\n        if (\n            (force or existing.sunset is None)\n            and existing.date in new\n            and new[existing.date].sunset is not None\n        ):\n            sqls.append(\n                f\"update day set sunset = '{new[existing.date].sunset}' where date = '{existing.date}';\"\n            )\n    return sqls", "\n\n#-------------------\n\nclass ProgArgs:\n    \"\"\"Program arguments.\n\n    Attributes:\n        database_file: filename of the database\n        target_rows: EMPTY, ALL or ONEDATE\n        onedate: a valid date string or \"\" (only if ONEDATE)\n        weather_csv: filename of WEATHER csv file (if any, else \"\")\n        day_end_csv: filename of DAY END csv file (if any, else \"\")\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Get all the program arguments.\"\"\"\n        progargs = self._parse_args()\n        self.verbose = progargs.verbose\n        self.database_file = progargs.database_file\n        self.day_end = progargs.day_end\n        self.force = progargs.force\n        self.onedate = \"\"\n        if progargs.date:\n            #self.target_rows = ONEDATE\n            self.onedate = ut.date_str(progargs.date)\n            if not self.onedate:\n                print(\n                    \"DATE must be YYYY-MM-DD, 'today' or 'yesterday'\",\n                    file=sys.stderr,\n                )\n                sys.exit(1)\n        #elif args.all:\n        #    self.target_rows = ALL\n        #elif args.empty:\n        #    self.target_rows = EMPTY\n        self.weather_csv = progargs.weather if progargs.weather else \"\"\n        self.sun_csv = progargs.sun if progargs.sun else \"\"\n        self.day_end_csv = progargs.day_end if progargs.day_end else \"\"\n        #if not self.target_rows:\n        #    print(\n        #        \"Unknown args supporting which rows to update\",\n        #        file=sys.stderr,\n        #    )\n        #    sys.exit(1)\n        if not self.weather_csv and not self.day_end_csv and not self.sun_csv:\n            print(\n                \"Must specify at least one of --weather --sun --day-end\",\n                file=sys.stderr,\n            )\n            sys.exit(1)\n\n    def dump(self):\n        \"\"\"Print the contents of the object.\"\"\"\n        print(f\"{self.weather_csv=}; {self.day_end_csv=}\")\n        print(f\"{self.force=}; {self.onedate=}\")\n        print(f\"{self.database_file=}\")\n\n    @staticmethod\n    def _parse_args() -> argparse.Namespace:\n        \"\"\"Collect command args into an argparse.Namespace.\"\"\"\n        parser = argparse.ArgumentParser(\n            description=\"Update TagTracker database DAY table from non-TagTracker sources\",\n            epilog=\"\",\n        )\n        parser.add_argument(\n            \"database_file\",\n            metavar=\"DATABASE_FILE\",\n            help=\"TagTracker database file to update\",\n        )\n        parser.add_argument(\n            \"--force\",\n            action=\"store_true\",\n            default=False,\n            help=\"Update all attributes (usually only updates empty attributes)\",\n        )\n        parser.add_argument(\n            \"--date\",\n            help=\"Limit update to DAY row for date DATE\",\n        )\n        parser.add_argument(\n            \"--weather\",\n            metavar=\"FILE\",\n            help=\"Read temp/precip from csv file of Environment Canada historic climate data\",\n        )\n        parser.add_argument(\n            \"--sun\",\n            metavar=\"FILE\",\n            help=\"Read sunset times from csv file of NR Canada sunrise/sunset times\",\n        )\n        parser.add_argument(\n            \"--day-end\",\n            metavar=\"FILE\",\n            help=\"Read registrations/leftovers from csv file of day-end-form gsheet data\",\n        )\n        parser.add_argument( \"--verbose\",action=\"store_true\",default=False)\n        return parser.parse_args()", "\nargs = ProgArgs()\nif args.verbose:\n    args.dump()\n\n# Get existing database info\n# FIXME: make test for existnece of file part of create_connection\ndatabase = db.db_connect(args.database_file,must_exist=True)\n\nweather_changes = []\nif args.weather_csv:\n    if args.verbose:\n        print(\"\\nWEATHER\\n\")\n    weather_changes: list[str] = get_wx_changes(\n        database,\n        args.weather_csv,\n        args.force,\n        args.onedate,\n    )\n    for sql in weather_changes:\n        if args.verbose:\n            print(sql)\n        db.db_update(database,sql,commit=False)\n    db.db_commit(database)", "\nweather_changes = []\nif args.weather_csv:\n    if args.verbose:\n        print(\"\\nWEATHER\\n\")\n    weather_changes: list[str] = get_wx_changes(\n        database,\n        args.weather_csv,\n        args.force,\n        args.onedate,\n    )\n    for sql in weather_changes:\n        if args.verbose:\n            print(sql)\n        db.db_update(database,sql,commit=False)\n    db.db_commit(database)", "\nsun_changes = []\nif args.sun_csv:\n    if args.verbose:\n        print(\"\\SUN\\n\")\n    sun_changes: list[str] = get_sun_changes(\n        database,\n        args.sun_csv,\n        args.force,\n        args.onedate,\n    )\n    for sql in sun_changes:\n        if args.verbose:\n            print(sql)\n        db.db_update(database,sql,commit=False)\n    db.db_commit(database)", "\nday_end_changes = []\nif args.day_end_csv:\n    if args.verbose:\n        print(\"\\nDAY END\\n\")\n    day_end_changes: list[str] = get_day_end_changes(\n        database,\n        args.day_end_csv,\n        args.force,\n        args.onedate,\n    )\n    for sql in day_end_changes:\n        if args.verbose:\n            print(sql)\n        db.db_update(database,sql,commit=False)\n    db.db_commit(database)", "\nprint(f\"Updated database '{args.database_file}':\")\nif args.weather_csv:\n    print(f\"   {len(weather_changes):3d} weather updates from '{args.weather_csv}'\")\nif args.sun_csv:\n    print(f\"   {len(sun_changes):3d} sun updates from '{args.sun_csv}'\")\nif args.day_end_csv:\n    print(f\"   {len(day_end_changes):3d} day_end updates from '{args.day_end_csv}'\")\n\n", "\n"]}
{"filename": "tt_printer.py", "chunked_list": ["\"\"\"TagTracker by Julias Hocking.\n\nStyling and printing functions for  the TagTracker suite.\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.", "    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.", "    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"\n\nimport os\nimport io\n\n# The readline module magically solves arrow keys creating ANSI esc codes\n# on the Chromebook.  But it isn't on all platforms.\ntry:\n    import readline  # pylint:disable=unused-import\nexcept ImportError:\n    pass", "# on the Chromebook.  But it isn't on all platforms.\ntry:\n    import readline  # pylint:disable=unused-import\nexcept ImportError:\n    pass\n\nfrom tt_globals import *  # pylint:disable=unused-wildcard-import,wildcard-import\nimport tt_util as ut\nimport tt_conf as cfg\n", "import tt_conf as cfg\n\n##from tt_colours import *\n# pylint:disable=unused-import\n# from tt_colours import (HAVE_COLOURS, STYLE,\n#            PROMPT_STYLE, SUBPROMPT_STYLE, ANSWER_STYLE, TITLE_STYLE,\n#            SUBTITLE_STYLE, RESET_STYLE, NORMAL_STYLE, HIGHLIGHT_STYLE,\n#            WARNING_STYLE, ERROR_STYLE,Fore,Back,Style)\n# pylint:enable=unused-import\n# try:", "# pylint:enable=unused-import\n# try:\n#    import tt_local_config  # pylint:disable=unused-import\n# except ImportError:\n#    pass\n\n# Amount to indent normal output. iprint() indents in units of _INDENT\n_INDENT = \"  \"\n\n# If use colour, try to import colorama library", "\n# If use colour, try to import colorama library\n# USE_COLOUR = True\n# if USE_COLOUR and not HAVE_COLOURS:\n#    USE_COLOUR = False\n#    print(\"WARNING: No colours available, text will be in black & white.\")\n\n\n# echo will save all input & (screen) output to an echo datafile\n# To start echoing, call set_echo(True)", "# echo will save all input & (screen) output to an echo datafile\n# To start echoing, call set_echo(True)\n# To stop it, call set_echo(False)\n\n_echo_state = False\n_echo_filename = os.path.join(cfg.ECHO_FOLDER, f\"echo-{ut.date_str('today')}.txt\")\n_echo_file = None  # This is the file object\n\n\ndef get_echo() -> bool:\n    \"\"\"Return current echo state ON or OFF.\"\"\"\n    return _echo_state", "\ndef get_echo() -> bool:\n    \"\"\"Return current echo state ON or OFF.\"\"\"\n    return _echo_state\n\n\ndef set_echo(state: bool) -> None:\n    \"\"\"Set the echo state to ON or OFF.\"\"\"\n    global _echo_state, _echo_file\n    if state == _echo_state:\n        return\n    _echo_state = state\n    # If turning echo off, close the file\n    if not state and isinstance(_echo_file, io.TextIOWrapper):\n        _echo_file.close()\n    # If turning echo on, try to open the file\n    if state:\n        try:\n            _echo_file = open(_echo_filename, \"at\", encoding=\"utf-8\")\n        except OSError:\n            ut.squawk(f\"OSError opening echo file '{_echo_filename}'\")\n            ut.squawk(\"Setting echo off.\")\n            _echo_state = False", "\n\ndef echo(text: str = \"\") -> None:\n    \"\"\"Send text to the echo log.\"\"\"\n    if not _echo_state:\n        return\n    if not _echo_file:\n        ut.squawk(\"call to echo when echo file not open\")\n        set_echo(False)\n        return\n    _echo_file.write(f\"{text}\")", "\n\ndef echo_flush() -> None:\n    \"\"\"If an echo file is active, flush buffer contents to it.\"\"\"\n    if _echo_state and _echo_file:\n        # To make more robust, close & reopen echo file intead of flush\n        set_echo(False)\n        set_echo(True)\n        ##_echo_file.flush()\n", "        ##_echo_file.flush()\n\n\ndef tt_inp(prompt: str = \"\", style: str = \"\") -> str:\n    \"\"\"Get input, possibly echo to file.\"\"\"\n    inp = input(text_style(prompt, style))\n    if _echo_state:\n        echo(f\"{prompt}  {inp}\\n\")\n    return inp\n", "\n\n# Output destination\n_destination: str = \"\"  # blank == screen\n_destination_file = None\n\n\ndef set_output(filename: str = \"\") -> bool:\n    \"\"\"Set print destination to filename or (default) screen.\n\n    Only close the file if it has changed to a different filename\n    (ie not just to screen).\n\n    Returns True/False if able to change to the new filename.\n    (Always True if returning output to screen.)\n    \"\"\"\n    global _destination, _destination_file\n    if filename == _destination:\n        return True\n    if _destination:\n        _destination_file.close()\n    if filename:\n        try:\n            _destination_file = open(filename, mode=\"wt\", encoding=\"utf-8\")\n        except OSError:\n            iprint(f\"OSError opening destination file '{filename}'\",\n                   style=cfg.ERROR_STYLE)\n            iprint(\"Ignoring print redirect request.\",style=cfg.ERROR_STYLE)\n            _destination = \"\"\n            return False\n    _destination = filename\n    return True", "\n\ndef get_output() -> str:\n    \"\"\"Get the current output destination (filename), or \"\" if screen.\"\"\"\n    return _destination\n\n\ndef text_style(text: str, style=None) -> str:\n    \"\"\"Return text with style 'style' applied.\"\"\"\n    # If redirecting to file, do not apply style\n    if _destination:\n        return text\n    # If no colour avilable, do not apply style\n    if not cfg.USE_COLOUR:\n        return text\n    if not style:\n        style = cfg.NORMAL_STYLE\n    if style not in cfg.STYLE:\n        ut.squawk(f\"Call to text_style() with unknown style '{style}'\")\n        return \"!!!???\"\n    return f\"{cfg.STYLE[style]}{text}{cfg.STYLE[cfg.RESET_STYLE]}\"", "\n\ndef iprint(text: str = \"\", num_indents: int = 1, style=None, end=\"\\n\") -> None:\n    \"\"\"Print the text, indented num_indents times.\n\n    Recognizes the 'end=' keyword for the print() statement.\n\n    Everything gets indented\n    Only screen output gets styled; indents do *not* get styled to screen\n    \"\"\"\n    indent = _INDENT * num_indents\n\n    # Going to screen?\n    if _destination:\n        # Going to file - print with indents but no styling\n        _destination_file.write(f\"{indent}{text}{end}\")\n    else:\n        # Going to screen.  Style and indent.\n        if cfg.USE_COLOUR and style:\n            styled_text = text_style(text, style=style)\n            print(f\"{indent}{styled_text}\", end=end)\n        else:\n            print(f\"{indent}{text}\", end=end)\n\n    # Also echo?\n    if _echo_state and not _destination:\n        echo(f\"{indent}{text}{end}\")", ""]}
{"filename": "tracker2db.py", "chunked_list": ["#!/usr/bin/env python3\n\"\"\"TagTracker by Julias Hocking.\n\nDatabase updater for TagTracker suite.\n\nThis is a script to update a persistent SQLite database in a configurable\ndirectory with data from all available (by default) or specific TagTracker\ndata files.\nIt pulls some functions and constants from tagtracker_config.py\nand tracker_util.py.", "It pulls some functions and constants from tagtracker_config.py\nand tracker_util.py.\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n", "    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"\n\n\nimport argparse\nimport calendar\nimport glob\nimport os\nimport re\nimport sqlite3", "import re\nimport sqlite3\nimport sys\nfrom typing import Union  # for type hints instead of (eg) int|str\n\nimport tt_datafile\nimport tt_dbutil\nimport tt_globals\nimport tt_util as ut\n", "import tt_util as ut\n\nfrom tt_event import Event\nfrom tt_time import VTime\n\n\n# Names for tables and columns.s\n# Table of individual bike visits\nTABLE_VISITS = \"visit\"\nCOL_ID = \"id\"  # text date.tag PK", "TABLE_VISITS = \"visit\"\nCOL_ID = \"id\"  # text date.tag PK\nCOL_DATE = \"date\"\nCOL_TAG = \"tag\"\nCOL_BIKETYPE = \"type\"\nCOL_TIME_IN = \"time_in\"\nCOL_TIME_OUT = \"time_out\"\nCOL_DURATION = \"duration\"\nCOL_NOTES = \"notes\"\nCOL_BATCH = \"batch\"", "COL_NOTES = \"notes\"\nCOL_BATCH = \"batch\"\n\n# Table of day summaries\nTABLE_DAYS = \"day\"\n# COL_DATE name reused - text date PK\nCOL_REGULAR = \"parked_regular\"  # int count\nCOL_OVERSIZE = \"parked_oversize\"  # int count\nCOL_TOTAL = \"parked_total\"  # int sum of 2 above\nCOL_TOTAL_LEFTOVER = \"leftover\"  # int count", "COL_TOTAL = \"parked_total\"  # int sum of 2 above\nCOL_TOTAL_LEFTOVER = \"leftover\"  # int count\nCOL_MAX_REGULAR = \"max_reg\"  # int count of max regular bikes\nCOL_MAX_REGULAR_TIME = \"time_max_reg\"  # HHMM time\nCOL_MAX_OVERSIZE = \"max_over\"  # int count of max oversize bikes\nCOL_MAX_OVERSIZE_TIME = \"time_max_over\"  # HHMM time\nCOL_MAX_TOTAL = \"max_total\"  # int sum of 2 above\nCOL_MAX_TOTAL_TIME = \"time_max_total\"  # HHMM\nCOL_TIME_OPEN = \"time_open\"  # HHMM opening time\nCOL_TIME_CLOSE = \"time_closed\"  # HHMM closing time", "COL_TIME_OPEN = \"time_open\"  # HHMM opening time\nCOL_TIME_CLOSE = \"time_closed\"  # HHMM closing time\nCOL_DAY_OF_WEEK = \"weekday\"  # ISO 8601-compliant 1-7 M-S\nCOL_PRECIP_MM = \"precip_mm\"  # mm (bulk pop from EnvCan dat)\nCOL_TEMP = \"temp\"\nCOL_SUNSET = \"sunset\"  # HHMM time at sunset - same\nCOL_EVENT = \"event\"  # brief name of nearby event\nCOL_EVENT_PROX = \"event_prox_km\"  # est. num of km to event\nCOL_REGISTRATIONS = \"registrations\"  # num of 529 registrations recorded\n# COL_NOTES name reused", "COL_REGISTRATIONS = \"registrations\"  # num of 529 registrations recorded\n# COL_NOTES name reused\n# COL_BATCH name reused\n\n# Bike-type codes. Must match check constraint in code table TYPES.CODE\nREGULAR = \"R\"\nOVERSIZE = \"O\"\n\n\ndef calc_duration(hhmm_in: str, hhmm_out: str) -> str:\n    \"\"\"Calculate a str duration from a str time in and out.\"\"\"\n    t_in = VTime(hhmm_in).num\n    t_out = VTime(hhmm_out).num\n    t_stay = t_out - t_in\n    hhmm_stay = VTime(t_stay)\n\n    return hhmm_stay", "\ndef calc_duration(hhmm_in: str, hhmm_out: str) -> str:\n    \"\"\"Calculate a str duration from a str time in and out.\"\"\"\n    t_in = VTime(hhmm_in).num\n    t_out = VTime(hhmm_out).num\n    t_stay = t_out - t_in\n    hhmm_stay = VTime(t_stay)\n\n    return hhmm_stay\n", "\n\ndef data_to_db(filename: str) -> None:\n    \"\"\"Record one datafile to the database.\n\n    Read the datafile in question into a TrackerDay object with\n    df.read_datafile()\n\n    For the day, UPDATE or INSERT a row of day summary data into TABLE_DAYS\n\n    Then calculate some things which might be based on it\n    for each bike, and record a row of visit data into TABLE_VISITS\n    \"\"\"\n\n    def what_bike_type(tag: str) -> Union[str, None]:\n        \"\"\"Return the type 'Normal' or 'Oversize' of a tag.\n        Based on each day's datafile\"\"\"\n        if tag in regular_tags:\n            return REGULAR\n        elif tag in oversize_tags:\n            return OVERSIZE\n        else:\n            print(\n                f\"Error: couldn't parse bike type for {tag} in {filename}. \"\n                \"Exiting with error.\",\n                file=sys.stderr,\n            )\n            sys.exit(1)\n\n    if not os.path.isfile(filename):\n        print(f\"Error: couldn't find file: {filename}\", file=sys.stderr)\n        return\n\n    if args.verbose:\n        print(f\"\\nWorking on {filename}\")\n\n    data = tt_datafile.read_datafile(f\"{filename}\", err_msgs=[])\n    date = data.date\n    if not date:  # get from filename for old data formats (hopefully never)\n        print(\n            f\"Error: unable to read valet date from file {filename}. \"\n            \"Skipping this file\",\n            file=sys.stderr,\n        )\n        globals()[\"SKIP_COUNT\"] += 1\n        return\n\n    if not data.bikes_in:  # if no visits to record, stop now\n        print(f\"No visits in {filename}\")\n        globals()[\"EMPTY_COUNT\"] += 1\n        return\n\n    if data.regular and data.oversize:\n        regular_tags = data.regular\n        oversize_tags = data.oversize\n        if args.verbose:\n            print(\"Tags: datafile tag lists loaded\")\n    else:  # if no context\n        print(\n            f\"Error: unable to read tags context from file {filename}. \"\n            \"Skipping this file.\",\n            file=sys.stderr,\n        )\n        globals()[\"SKIP_COUNT\"] += 1\n        return\n\n    # TABLE_DAYS handling\n    # Simple counts\n    regular_parked = 0\n    oversize_parked = 0\n    for tag in data.bikes_in.keys():\n        bike_type = what_bike_type(tag)\n        if bike_type == REGULAR:\n            regular_parked += 1\n        elif bike_type == OVERSIZE:\n            oversize_parked += 1\n    total_parked = regular_parked + oversize_parked\n    total_leftover = len(data.bikes_in) - len(data.bikes_out)\n    if total_leftover < 0:\n        print(\n            f\"Error: calculated negative value ({total_leftover})\"\n            f\" of leftover bikes for {date}. Skipping {filename}.\",\n            file=sys.stderr,\n        )\n        globals()[\"SKIP_COUNT\"] += 1\n        return\n\n    # Highwater values\n    events = Event.calc_events(data)\n    max_regular_num = max([x.num_here_regular for x in events.values()])\n    max_oversize_num = max([x.num_here_oversize for x in events.values()])\n    max_total_num = max([x.num_here_total for x in events.values()])\n    max_regular_time = None\n    max_oversize_time = None\n    max_total_time = None\n    # Find the first time at which these took place\n    for atime in sorted(events.keys()):\n        if (\n            events[atime].num_here_regular >= max_regular_num\n            and not max_regular_time\n        ):\n            max_regular_time = atime\n        if (\n            events[atime].num_here_oversize >= max_oversize_num\n            and not max_oversize_time\n        ):\n            max_oversize_time = atime\n        if (\n            events[atime].num_here_total >= max_total_num\n            and not max_total_time\n        ):\n            max_total_time = atime\n\n    # Open and close times\n    if data.opening_time and data.closing_time:\n        time_open = data.opening_time\n        time_close = data.closing_time\n    else:  # guess with bike check-ins\n        time_open = data.earliest_event()\n        time_close = data.latest_event()\n\n    # Find int day of week\n    date_bits = re.match(tt_globals.DATE_FULL_RE, date)\n    year = int(date_bits.group(1))\n    month = int(date_bits.group(2))\n    day = int(date_bits.group(3))\n    weekday = 1 + calendar.weekday(year, month, day)  # ISO 8601 says 1-7 M-S\n\n    if not sql_do(  # First try to make a new row...\n        f\"\"\"INSERT INTO {TABLE_DAYS} (\n                {COL_DATE},\n                {COL_REGULAR},\n                {COL_OVERSIZE},\n                {COL_TOTAL},\n                {COL_TOTAL_LEFTOVER},\n                {COL_MAX_REGULAR},\n                {COL_MAX_REGULAR_TIME},\n                {COL_MAX_OVERSIZE},\n                {COL_MAX_OVERSIZE_TIME},\n                {COL_MAX_TOTAL},\n                {COL_MAX_TOTAL_TIME},\n                {COL_TIME_OPEN},\n                {COL_TIME_CLOSE},\n                {COL_DAY_OF_WEEK},\n                {COL_BATCH}\n                ) VALUES (\n                '{date}',\n                {regular_parked},\n                {oversize_parked},\n                {total_parked},\n                {total_leftover},\n                {max_regular_num},\n                '{max_regular_time}',\n                {max_oversize_num},\n                '{max_oversize_time}',\n                {max_total_num},\n                '{max_total_time}',\n                '{time_open}',\n                '{time_close}',\n                {weekday},\n                '{batch}'\n                );\"\"\",\n        quiet=True,\n    ):\n        if not sql_do(  # Then try to update...\n            f\"\"\"UPDATE {TABLE_DAYS} SET\n                    {COL_REGULAR} = {regular_parked},\n                    {COL_OVERSIZE} = {oversize_parked},\n                    {COL_TOTAL} = {total_parked},\n                    {COL_TOTAL_LEFTOVER} = {total_leftover},\n                    {COL_MAX_REGULAR} = {max_regular_num},\n                    {COL_MAX_REGULAR_TIME} = '{max_regular_time}',\n                    {COL_MAX_OVERSIZE} = {max_oversize_num},\n                    {COL_MAX_OVERSIZE_TIME} = '{max_oversize_time}',\n                    {COL_MAX_TOTAL} = {max_total_num},\n                    {COL_MAX_TOTAL_TIME} = '{max_total_time}',\n                    {COL_TIME_OPEN} = '{time_open}',\n                    {COL_TIME_CLOSE} = '{time_close}',\n                    {COL_DAY_OF_WEEK} = {weekday},\n                    {COL_BATCH} = '{batch}'\n                    WHERE {COL_DATE} = '{date}'\n                    ;\"\"\"\n        ):\n            print(\n                \"Error: failed to INSERT or UPDATE \"\n                f\"day summary for {filename}.\",\n                file=sys.stderr,\n            )\n            sys.exit(1)\n\n    # TABLE_VISITS handling\n    closing = select_closing_time(date)  # fetch checkout time for whole day\n    if not closing:\n        print(\n            f\"Error - datafile {filename} missing closing time. \"\n            \"Skipping datafile.\",\n            file=sys.stderr,\n        )\n        globals()[\"SKIP_COUNT\"] += 1\n        return\n\n    visit_commit_count = total_parked\n    visit_fail_count = 0\n    sql_do(f\"DELETE FROM {TABLE_VISITS} WHERE date = '{date}';\")\n\n    for tag, time_in in data.bikes_in.items():\n        time_in = VTime(time_in)\n        if time_in > closing:  # both should be VTime\n            print(\n                f\"Error: visit {tag} in {filename} has check-in ({time_in})\"\n                f\" after closing time ({closing}). Visit not recorded.\",\n                file=sys.stderr,\n            )\n            continue\n\n        if tag in data.bikes_out.keys():\n            time_out = VTime(data.bikes_out[tag])\n            dur_end = time_out\n        else:  # no check-out recorded\n            dur_end = closing\n            if args.verbose:\n                print(\n                    f\"(normal leftover): {tag} stay time found using \"\n                    f\"closing time {closing} from table '{TABLE_DAYS}'\"\n                )\n            time_out = \"\"  # empty str for no time\n        time_stay = calc_duration(time_in, dur_end)\n        biketype = what_bike_type(tag)\n        if not sql_do(\n            f\"\"\"INSERT INTO {TABLE_VISITS} (\n                    {COL_ID},\n                    {COL_DATE},\n                    {COL_TAG},\n                    {COL_BIKETYPE},\n                    {COL_TIME_IN},\n                    {COL_TIME_OUT},\n                    {COL_DURATION},\n                    {COL_BATCH}\n                    ) VALUES (\n                    '{date}.{tag}',\n                    '{date}',\n                    '{tag}',\n                    '{biketype}',\n                    '{time_in}',\n                    '{time_out}',\n                    '{time_stay}',\n                    '{batch}');\"\"\"\n        ):\n            print(\n                f\"Error: failed to INSERT a stay for {tag}\",\n                file=sys.stderr,\n            )\n            visit_commit_count -= 1\n            visit_fail_count += 1\n    globals()[\"SUCCESS_COUNT\"] += 1\n\n    try:\n        conn.commit()  # commit one datafile transaction\n        if not args.quiet:\n            print(\n                f\" --> Committed records for {visit_commit_count} \"\n                f\"visits on {date} ({visit_fail_count} failed)\"\n            )\n    except sqlite3.Error as sqlite_err:\n        print(\n            f\"Error (SQLite) committing for {filename}:\",\n            sqlite_err,\n            \"Exiting with error.\",\n            file=sys.stderr,\n        )\n        globals()[\"COMMIT_FAIL_COUNT\"] += 1\n        sys.exit(1)", "\n\ndef select_closing_time(date: str) -> Union[VTime, bool]:\n    \"\"\"Return the closing time of a given date in TABLE_DAYS.\n\n    - SELECT closing time from rows with matching dates (should be just 1)\n    - If this yields no rows, return False.\n    - If this yields 1 row, return the closing time as a str HHMM.\n    - If this yields >1 row, raise error that the day has multiple records\n    (shouldn't happen b/c of UNIQUE constraint on the date row, but in case)\n    \"\"\"\n    curs = conn.cursor()\n    rows = curs.execute(\n        f\"SELECT {COL_TIME_CLOSE} FROM {TABLE_DAYS} \"\n        f\"WHERE {COL_DATE} == '{date}'\"\n    ).fetchall()\n    num_rows = len(rows)\n    if num_rows == 0:\n        return False  # will now use last event instead\n    elif num_rows == 1:\n        return VTime(rows[0][0])  # needs double subscript apparently\n    else:\n        print(\n            f\"Error (database): finding closing time on date {date} in table \"\n            f\"'{TABLE_DAYS}' returned multiple rows from query\"\n        )\n        sys.exit(1)", "\n\ndef sql_do(sql_statement: str, quiet: bool = False) -> bool:\n    \"\"\"Execute a SQL statement, or print the slite3 error.\"\"\"\n    try:\n        curs = conn.cursor()\n        curs.execute(sql_statement)\n        return True\n    except sqlite3.Error as sqlite_err:\n        if not quiet:\n            print(\n                \"Error (SQLite) using sql_do():\", sqlite_err, file=sys.stderr\n            )\n        return False", "\n\ndef setup_parser() -> None:\n    \"\"\"Add arguments to the ArgumentParser.\"\"\"\n    parser.add_argument(\n        \"-q\",\n        \"--quiet\",\n        action=\"store_const\",\n        const=True,\n        help=\"suppresses all non-error output\",\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"store_const\",\n        const=True,\n        help=\"provides most detailed output\",\n    )\n    parser.add_argument(\n        \"dataglob\",\n        type=str,\n        nargs=\"+\",\n        help=\"glob(s) to select target datafiles\",\n    )\n    parser.add_argument(\n        \"dbfile\", type=str, help=\"path of destination SQLite3 database file\"\n    )", "\n\ndef find_datafiles(arguments: argparse.Namespace) -> list:\n    \"\"\"Use provided args to assemble a list of datafiles.\n\n    Needs at least 1 of:\n    - specific file to target\n    - glob to search with in specified directory\n\n    If provided both, returns the set union of all datafiles found.\n    \"\"\"\n    targeted_datafiles = []\n    for this_glob in arguments.dataglob:\n        globbed_files = glob.glob(this_glob)  # glob glob glob\n        if len(globbed_files) < 1:  # if still empty after globbing\n            print(\n                f\"Error: no files found matching glob '{this_glob}'\",\n                file=sys.stderr,\n            )\n            sys.exit(1)\n        targeted_datafiles = sorted(\n            list(set().union(targeted_datafiles, globbed_files))\n        )\n    return targeted_datafiles", "\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    setup_parser()\n    args = parser.parse_args()\n\n    DB_FILEPATH = args.dbfile\n    datafiles = find_datafiles(args)\n\n    if args.verbose:\n        print(f\"Connecting to database at {DB_FILEPATH}...\")\n    conn = tt_dbutil.db_connect(DB_FILEPATH)\n    if not conn:\n        sys.exit(1)  # Error messages already taken care of in fn\n\n    if sql_do(\"PRAGMA foreign_keys=ON;\"):\n        if args.verbose:\n            print(\"Successfully enabled SQLite foreign keys\")\n    else:\n        print(\n            \"Error: couldn't enable SQLite use of foreign keys\",\n            file=sys.stderr,\n        )\n        sys.exit(1)\n\n    date_today = ut.date_str(\"today\")\n    batch = f\"{date_today}T{VTime('now')}\"\n    if not args.quiet:\n        print(f\"Batch: {batch}\")\n\n    SUCCESS_COUNT = 0\n    COMMIT_FAIL_COUNT = 0\n    SKIP_COUNT = 0\n    EMPTY_COUNT = 0\n\n    for datafilename in datafiles:\n        data_to_db(datafilename)\n\n    conn.close()\n\n    if not args.quiet:\n        print(\n            f\"\\n\\nProcessed data from {SUCCESS_COUNT} datafiles \"\n            f\"({SKIP_COUNT} skipped, {EMPTY_COUNT} empty). \"\n            f\"{COMMIT_FAIL_COUNT} failed commits.\"\n        )", ""]}
{"filename": "tagtracker.py", "chunked_list": ["#!/usr/bin/env python3\n\n\"\"\"TagTracker by Julias Hocking.\n\nThis is the data entry module for the TagTracker suite.\nIts configuration file is tagtracker_config.py.\n\nCopyright (C) 2023 Julias Hocking\n\n    This program is free software: you can redistribute it and/or modify", "\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"\n\nimport os\nimport sys\nimport time", "import sys\nimport time\nimport pathlib\n\n# The readline module magically solves arrow keys creating ANSI esc codes\n# on the Chromebook.  But it isn't on all platforms.\ntry:\n    import readline  # pylint:disable=unused-import\nexcept ImportError:\n    pass", "\nfrom tt_globals import *  # pylint:disable=unused-wildcard-import,wildcard-import\nfrom tt_tag import TagID\nfrom tt_realtag import Stay\nfrom tt_time import VTime\nimport tt_util as ut\nimport tt_trackerday as td\nimport tt_conf as cfg\nimport tt_printer as pr\nimport tt_datafile as df", "import tt_printer as pr\nimport tt_datafile as df\nimport tt_reports as rep\nimport tt_publish as pub\nimport tt_tag_inv as inv\n\n# Local connfiguration\n# try:\n#    import tt_local_config  # pylint:disable=unused-import\n# except ImportError:", "#    import tt_local_config  # pylint:disable=unused-import\n# except ImportError:\n#    pass\n\n# Initialize valet open/close globals\n# (These are all represented in TrackerDay attributes or methods)\nVALET_OPENS = \"\"\nVALET_CLOSES = \"\"\nVALET_DATE = \"\"\nNORMAL_TAGS = []", "VALET_DATE = \"\"\nNORMAL_TAGS = []\nOVERSIZE_TAGS = []\nRETIRED_TAGS = []\nALL_TAGS = []\nCOLOUR_LETTERS = {}\ncheck_ins = {}\ncheck_outs = {}\n\n\ndef valet_logo():\n    \"\"\"Print a cute bike valet logo using unicode.\"\"\"\n    UL = chr(0x256D)\n    VR = chr(0x2502)\n    HR = chr(0x2500)\n    UR = chr(0x256E)\n    LL = chr(0x2570)\n    LR = chr(0x256F)\n    BL = \" \"\n    LOCK00 = chr(0x1F512)\n    BIKE00 = chr(0x1F6B2)\n    SCOOTR = chr(0x1F6F4)\n\n    ln1 = f\"{BL}{UL}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{UR}\"\n    ln2 = f\"{BL}{VR}{BL}{BIKE00}{BIKE00}{SCOOTR}{BIKE00}{BL}{VR}\"\n    ln3 = f\"{LOCK00}{BL}{BIKE00}{BIKE00}{BIKE00}{SCOOTR}{BL}{VR}\"\n    ln4 = f\"{BL}{LL}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{LR}\"\n\n    WHATSTYLE = cfg.ANSWER_STYLE\n\n    pr.iprint()\n    pr.iprint(f\"            {ln1}             \", style=WHATSTYLE)\n    pr.iprint(f\"   FREE     {ln2}     BIKE    \", style=WHATSTYLE)\n    pr.iprint(f\"   SAFE     {ln3}     VALET   \", style=WHATSTYLE)\n    pr.iprint(f\"            {ln4}             \", style=WHATSTYLE)\n    pr.iprint()", "\n\ndef valet_logo():\n    \"\"\"Print a cute bike valet logo using unicode.\"\"\"\n    UL = chr(0x256D)\n    VR = chr(0x2502)\n    HR = chr(0x2500)\n    UR = chr(0x256E)\n    LL = chr(0x2570)\n    LR = chr(0x256F)\n    BL = \" \"\n    LOCK00 = chr(0x1F512)\n    BIKE00 = chr(0x1F6B2)\n    SCOOTR = chr(0x1F6F4)\n\n    ln1 = f\"{BL}{UL}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{UR}\"\n    ln2 = f\"{BL}{VR}{BL}{BIKE00}{BIKE00}{SCOOTR}{BIKE00}{BL}{VR}\"\n    ln3 = f\"{LOCK00}{BL}{BIKE00}{BIKE00}{BIKE00}{SCOOTR}{BL}{VR}\"\n    ln4 = f\"{BL}{LL}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{HR}{LR}\"\n\n    WHATSTYLE = cfg.ANSWER_STYLE\n\n    pr.iprint()\n    pr.iprint(f\"            {ln1}             \", style=WHATSTYLE)\n    pr.iprint(f\"   FREE     {ln2}     BIKE    \", style=WHATSTYLE)\n    pr.iprint(f\"   SAFE     {ln3}     VALET   \", style=WHATSTYLE)\n    pr.iprint(f\"            {ln4}             \", style=WHATSTYLE)\n    pr.iprint()", "\n\ndef fix_2400_events() -> list[TagID]:\n    \"\"\"Change any 24:00 events to 23:59, warn, return Tags changed.\"\"\"\n    changed = []\n    for tag, atime in check_ins.items():\n        if atime == \"24:00\":\n            check_ins[tag] = VTime(\"23:59\")\n            changed.append(tag)\n    for tag, atime in check_outs.items():\n        if atime == \"24:00\":\n            check_outs[tag] = VTime(\"23:59\")\n            changed.append(tag)\n    changed = list(set(changed))  # Remove duplicates.\n    if changed:\n        pr.iprint(\n            f\"(Time for {rep.simplified_taglist(changed)} adjusted to 23:59)\",\n            style=cfg.WARNING_STYLE,\n        )\n    return changed", "\n\ndef deduce_valet_date(current_guess: str, filename: str) -> str:\n    \"\"\"Guess what date the current data is for.\n\n    Logic:\n        If current_guess is set (presumably read from the contents\n        of the datafile) then it is used.\n        Else if there appears to be a date embedded in the name of\n        the datafile, it is used.\n        Else today's date is used.\n    \"\"\"\n    if current_guess:\n        return current_guess\n    r = DATE_PART_RE.search(filename)\n    if r:\n        return (\n            f\"{int(r.group(2)):04d}-{int(r.group(3)):02d}-\"\n            f\"{int(r.group(4)):02d}\"\n        )\n    return ut.date_str(\"today\")", "\n\ndef pack_day_data() -> td.TrackerDay:\n    \"\"\"Create a TrackerDay object loaded with today's data.\"\"\"\n    # Pack info into TrackerDay object\n    day = td.TrackerDay()\n    day.date = VALET_DATE\n    day.opening_time = VALET_OPENS\n    day.closing_time = VALET_CLOSES\n    day.bikes_in = check_ins\n    day.bikes_out = check_outs\n    day.regular = NORMAL_TAGS\n    day.oversize = OVERSIZE_TAGS\n    day.retired = RETIRED_TAGS\n    day.colour_letters = COLOUR_LETTERS\n    return day", "\n\ndef unpack_day_data(today_data: td.TrackerDay) -> None:\n    \"\"\"Set globals from a TrackerDay data object.\"\"\"\n    # pylint: disable=global-statement\n    global VALET_DATE, VALET_OPENS, VALET_CLOSES\n    global check_ins, check_outs\n    global NORMAL_TAGS, OVERSIZE_TAGS, RETIRED_TAGS\n    global ALL_TAGS\n    global COLOUR_LETTERS\n    # pylint: enable=global-statement\n    VALET_DATE = today_data.date\n    VALET_OPENS = today_data.opening_time\n    VALET_CLOSES = today_data.closing_time\n    check_ins = today_data.bikes_in\n    check_outs = today_data.bikes_out\n    NORMAL_TAGS = today_data.regular\n    OVERSIZE_TAGS = today_data.oversize\n    RETIRED_TAGS = today_data.retired\n    ALL_TAGS = (NORMAL_TAGS | OVERSIZE_TAGS) - RETIRED_TAGS\n    COLOUR_LETTERS = today_data.colour_letters", "\n\ndef initialize_today() -> bool:\n    \"\"\"Read today's info from datafile & maybe tags-config file.\"\"\"\n    # Does the file even exist? (If not we will just create it later)\n    new_datafile = False\n    pathlib.Path(cfg.DATA_FOLDER).mkdir(\n        exist_ok=True\n    )  # make data folder if missing\n    if not os.path.exists(DATA_FILEPATH):\n        new_datafile = True\n        pr.iprint(\n            \"Creating new datafile\" f\" {DATA_FILEPATH}.\",\n            style=cfg.SUBTITLE_STYLE,\n        )\n        today = td.TrackerDay()\n    else:\n        # Fetch data from file; errors go into error_msgs\n        pr.iprint(\n            f\"Reading data from {DATA_FILEPATH}...\",\n            end=\"\",\n            style=cfg.SUBTITLE_STYLE,\n        )\n        error_msgs = []\n        today = df.read_datafile(DATA_FILEPATH, error_msgs)\n        if error_msgs:\n            pr.iprint()\n            for text in error_msgs:\n                pr.iprint(text, style=cfg.ERROR_STYLE)\n            return False\n    # Figure out the date for this bunch of data\n    if not today.date:\n        today.date = deduce_valet_date(today.date, DATA_FILEPATH)\n    # Find the tag reference lists (regular, oversize, etc).\n    # If there's no tag reference lists, or it's today's date,\n    # then fetch the tag reference lists from tags config\n    if not (today.regular or today.oversize) or today.date == ut.date_str(\"today\"):\n        tagconfig = get_taglists_from_config()\n        today.regular = tagconfig.regular\n        today.oversize = tagconfig.oversize\n        today.retired = tagconfig.retired\n        today.colour_letters = tagconfig.colour_letters\n    # Set UC if needed (NB: datafiles are always LC)\n    TagID.uc(cfg.TAGS_UPPERCASE)\n    # On success, set today's working data\n    unpack_day_data(today)\n    # Now do a consistency check.\n    errs = pack_day_data().lint_check(strict_datetimes=False)\n    if errs:\n        pr.iprint()\n        for msg in errs:\n            pr.iprint(msg, style=cfg.ERROR_STYLE)\n        error_exit()\n    # Done\n    if not new_datafile:\n        pr.iprint(\"done.\", num_indents=0, style=cfg.SUBTITLE_STYLE)\n    if VALET_DATE != ut.date_str('today'):\n        pr.iprint(\n            f\"Warning: Valet information is from {ut.date_str(VALET_DATE,long_date=True)}\",\n            style=cfg.WARNING_STYLE,\n        )\n    return True", "\n\ndef delete_entry(\n    maybe_target: str = \"\",\n    maybe_what: str = \"\",\n    maybe_confirm: str = \"\",\n    *extra,\n) -> None:\n    \"\"\"Perform tag entry deletion dialogue.\n\n    Delete syntax is:\n        delete <tag> <in|out|both> <confirm>\n    \"\"\"\n\n    def arg_prompt(maybe: str, prompt: str, optional: bool = False) -> str:\n        \"\"\"Prompt for one command argument (token).\"\"\"\n        if optional or maybe:\n            maybe = \"\" if maybe is None else f\"{maybe}\".strip().lower()\n            return maybe\n        pr.iprint(\n            f\"{prompt} {cfg.CURSOR}\",\n            style=cfg.SUBPROMPT_STYLE,\n            end=\"\",\n        )\n        return pr.tt_inp().strip().lower()\n\n    def nogood(\n        msg: str = \"\", syntax: bool = True, severe: bool = True\n    ) -> None:\n        \"\"\"Print the nogood msg + syntax msg.\"\"\"\n        style = cfg.WARNING_STYLE if severe else cfg.HIGHLIGHT_STYLE\n        if msg:\n            pr.iprint(msg, style=style)\n        if syntax:\n            pr.iprint(\n                \"Syntax: delete <tag> <in|out|both> <y|n|!>\",\n                style=style,\n            )\n\n    def cancel():\n        \"\"\"Give a 'delete cancelled' message.\"\"\"\n        nogood(\"Delete cancelled\", syntax=False, severe=False)\n\n    if extra:\n        nogood(\"\", syntax=True, severe=True)\n        return\n\n    ##(maybe_target, maybe_what, maybe_confirm) = (args + [\"\", \"\", \"\"])[:3]\n    # What tag are we to delete parts of?\n    maybe_target = arg_prompt(maybe_target, \"Delete entries for what tag?\")\n    if not maybe_target:\n        cancel()\n        return\n    target = TagID(maybe_target)\n    if not target:\n        nogood(f\"'{maybe_target}' is not a tag\", syntax=False)\n        return\n    if target not in ALL_TAGS:\n        nogood(f\"'{maybe_target}' is not a tag in use\", syntax=False)\n        return\n    if target not in check_ins:\n        nogood(\n            f\"Tag {target} not checked in or out, nothing to do.\", syntax=False\n        )\n        return\n    # Special case: \"!\" after what without a space\n    if maybe_what and maybe_what[-1] == \"!\" and not maybe_confirm:\n        maybe_what = maybe_what[:-1]\n        maybe_confirm = \"!\"\n    # Find out what kind of checkin/out we are to delete\n    what = arg_prompt(\n        maybe_what, \"Delete check-IN, check-OUT or BOTH (i/o/b)?\"\n    )\n    if not what:\n        cancel()\n        return\n    if what not in [\"i\", \"in\", \"o\", \"out\", \"b\", \"both\"]:\n        nogood(\"Must indicate in, out or both\")\n        return\n    if what in [\"i\", \"in\"] and target in check_outs:\n        nogood(\n            f\"Bike {target} checked out.  Can't delete check-in \"\n            \"for a returned bike without check-out too\",\n            syntax=False,\n        )\n        return\n    # Get a confirmation\n    confirm = arg_prompt(maybe_confirm, \"Are you sure (y/N)?\")\n    if confirm not in [\"n\", \"no\", \"!\", \"y\", \"yes\"]:\n        nogood(\n            f\"Confirmation must be 'y' or 'n', not '{confirm}'\",\n            severe=True,\n            syntax=True,\n        )\n        return\n    if confirm not in [\"y\", \"yes\", \"!\"]:\n        cancel()\n        return\n    # Perform the delete\n    if what in [\"b\", \"both\", \"o\", \"out\"] and target in check_outs:\n        check_outs.pop(target)\n    if what in [\"b\", \"both\", \"i\", \"in\"] and target in check_ins:\n        check_ins.pop(target)\n    pr.iprint(\"Deleted.\", style=cfg.ANSWER_STYLE)", "\n\ndef query_one_tag(\n    maybe_tag: str, day: td.TrackerDay, multi_line: bool = False\n) -> None:\n    \"\"\"Print a summary of one tag's status.\n\n    If multi_line is true, then this *may* print the status on multiple lines;\n    otherwise will always put it on a single line.\n    \"\"\"\n    tagid = TagID(maybe_tag)\n    if not tagid:\n        pr.iprint(\n            f\"Input '{tagid.original}' is not a tag name\",\n            style=cfg.WARNING_STYLE,\n        )\n        return\n    tag = Stay(tagid, day, as_of_when=\"24:00\")\n    if not tag.state:\n        pr.iprint(\n            f\"Tag {tag.tag} is not available\",\n            style=cfg.WARNING_STYLE,\n        )\n        return\n    if tag.state == RETIRED:\n        pr.iprint(f\"Tag {tag.tag} is retired\", style=cfg.WARNING_STYLE)\n        return\n    if tag.state == BIKE_OUT:\n        if multi_line:\n            pr.iprint(\n                f\"{tag.time_in.tidy}  \" f\"{tag.tag} checked in\",\n                style=cfg.ANSWER_STYLE,\n            )\n            pr.iprint(\n                f\"{tag.time_out.tidy}  \" f\"{tag.tag} checked out\",\n                style=cfg.ANSWER_STYLE,\n            )\n        else:\n            pr.iprint(\n                f\"Tag {tag.tag} bike in at {tag.time_in.short}; \"\n                f\"out at {tag.time_out.short}\",\n                style=cfg.ANSWER_STYLE,\n            )\n        return\n    if tag.state == BIKE_IN:\n        # Bike has come in sometime today but gone out\n        dur = VTime(\"now\").num - tag.time_in.num\n        if multi_line:\n            pr.iprint(\n                f\"{tag.time_in.tidy}  \" f\"{tag.tag} checked in\",\n                style=cfg.ANSWER_STYLE,\n            )\n            pr.iprint(\n                f\"       {tag.tag} not checked out\", style=cfg.ANSWER_STYLE\n            )\n        else:\n            if dur >= 60:\n                dur_str = f\"(in valet for {VTime(dur).short})\"\n            elif dur >= 0:\n                dur_str = f\"(in valet for {dur} minutes)\"\n            else:\n                # a future time\n                dur_str = f\"({VTime(abs(dur)).short} in the future)\"\n\n            pr.iprint(\n                f\"Tag {tag.tag} bike in at {tag.time_in.short} {dur_str}\",\n                style=cfg.ANSWER_STYLE,\n            )\n\n        return\n    if tag.state == USABLE:\n        pr.iprint(\n            f\"Tag {tag.tag} not used yet today\",\n            style=cfg.ANSWER_STYLE,\n        )\n        return\n    pr.iprint(f\"Tag {tag.tag} has unknown state\", style=cfg.ERROR_STYLE)", "\n\ndef query_tag(targets: list[str], multi_line: bool = None) -> None:\n    \"\"\"Query one or more tags\"\"\"\n    if len(targets) == 0:\n        # Have to prompt\n        pr.iprint(\n            f\"Query which tags? (tag name) {cfg.CURSOR}\",\n            style=cfg.SUBPROMPT_STYLE,\n            end=\"\",\n        )\n        targets = ut.splitline(pr.tt_inp())\n        if not targets:\n            pr.iprint(\"Query cancelled\", style=cfg.HIGHLIGHT_STYLE)\n            return\n    day = pack_day_data()\n    pr.iprint()\n    if multi_line is None:\n        multi_line = len(targets) == 1\n\n    for maybe_tag in targets:\n        query_one_tag(maybe_tag, day, multi_line=multi_line)", "\n\ndef prompt_for_time(inp=False, prompt: str = None) -> VTime:\n    \"\"\"Prompt for a time input if needed.\n\n    Helper for edit_entry() & others; if no time passed in, get a valid\n    24h time input from the user and return an HH:MM string.\n    \"\"\"\n    if not inp:\n        if not prompt:\n            prompt = \"Correct time for this event? (HHMM or 'now')\"\n        pr.iprint(f\"{prompt} {cfg.CURSOR}\", style=cfg.SUBPROMPT_STYLE, end=\"\")\n        inp = pr.tt_inp()\n    return VTime(inp)", "\n\ndef set_valet_hours(args: list[str]) -> None:\n    \"\"\"Set the valet opening & closing hours.\"\"\"\n    global VALET_OPENS, VALET_CLOSES  # pylint: disable=global-statement\n    (open_arg, close_arg) = (args + [\"\", \"\"])[:2]\n    pr.iprint()\n    if VALET_DATE:\n        pr.iprint(\n            f\"Bike Valet information for {ut.date_str(VALET_DATE,long_date=True)}\",\n            style=cfg.HIGHLIGHT_STYLE,\n        )\n    # Valet opening time\n    if VALET_OPENS:\n        pr.iprint(f\"Opening time is: {VALET_OPENS}\", style=cfg.HIGHLIGHT_STYLE)\n    if VALET_CLOSES:\n        pr.iprint(\n            f\"Closing time is: {VALET_CLOSES}\", style=cfg.HIGHLIGHT_STYLE\n        )\n\n    maybe_open = prompt_for_time(\n        open_arg,\n        prompt=\"New valet opening time (24 hour clock HHMM or <Enter> to cancel)\",\n    )\n    if not maybe_open:\n        pr.iprint(\n            \"Input is not a time.  Opening time unchanged.\",\n            style=cfg.WARNING_STYLE,\n        )\n        return\n    VALET_OPENS = maybe_open\n    pr.iprint(f\"Opening time now set to {VALET_OPENS}\", style=cfg.ANSWER_STYLE)\n    # Valet closing time\n    maybe_close = prompt_for_time(\n        close_arg,\n        prompt=\"New valet closing time (24 hour clock HHMM or <Enter> to cancel)\",\n    )\n    if not maybe_close:\n        pr.iprint(\n            \"Input is not a time.  Closing time unchanged.\",\n            style=cfg.WARNING_STYLE,\n        )\n        return\n    if maybe_close <= VALET_OPENS:\n        pr.iprint(\n            \"Closing time must be later than opening time. Time unchanged.\",\n            style=cfg.ERROR_STYLE,\n        )\n        return\n    VALET_CLOSES = maybe_close\n    pr.iprint(\n        f\"Closing time now set to {VALET_CLOSES}\", style=cfg.ANSWER_STYLE\n    )", "\n\ndef multi_edit(args: list[str]):\n    \"\"\"Perform Dialog to correct a tag's check in/out time.\n\n    Command syntax: edit [tag-list] [in|out] [time]\n    Where:\n        tag-list is a comma or whitespace-separated list of tags\n        inout is 'in', 'i', 'out', 'o'\n        time is a valid time (including 'now')\n    \"\"\"\n\n    def prompt_for_stuff(prompt: str):\n        pr.iprint(f\"{prompt} {cfg.CURSOR}\", style=cfg.SUBPROMPT_STYLE, end=\"\")\n        return pr.tt_inp().lower()\n\n    def error(msg: str, severe: bool = True) -> None:\n        if severe:\n            pr.iprint(msg, style=cfg.WARNING_STYLE)\n        else:\n            pr.iprint(msg, style=cfg.HIGHLIGHT_STYLE)\n\n    def cancel():\n        error(\"Edit cancelled\", severe=False)\n\n    class TokenSet:\n        \"\"\"Local class to hold parsed portions of command.\"\"\"\n\n        def __init__(self, token_str: str) -> None:\n            \"\"\"Break token_str into token portions.\"\"\"\n            # In future this might do hyphenated tag lists\n            #       - num_tokens is total of tokens in that list\n            #       - add elements to taglist as long as look like tags\n            #       - next element if present is INOUT\n            #       - next element if present is TIME\n            #       - remaining elements are REMAINDER\n            parts = ut.splitline(token_str)\n            self.num_tokens = len(parts)\n            self.tags = []  # valid Tags (though possibly not available)\n            self.inout_str = \"\"  # what the user said\n            self.inout_value = BADVALUE  # or BIKE_IN, BIKE_OUT\n            self.atime_str = \"\"  # What the user said\n            self.atime_value = BADVALUE  # A valid time, or BADVALUE\n            self.remainder = []  # whatever is left (hopefully nothing)\n            if self.num_tokens == 0:\n                return\n            # Break into tags list and other list\n            done_tags = False\n            for part in parts:\n                tag = TagID(part)\n                if done_tags or not tag:\n                    self.remainder.append(part)\n                else:\n                    self.tags.append(tag)\n            # Anything left over?\n            if not self.remainder:\n                return\n            # Is next part IN/OUT?\n            self.inout_str = self.remainder[0]\n            self.remainder = self.remainder[1:]\n            if self.inout_str.lower() in [\"i\", \"in\"]:\n                self.inout_value = BIKE_IN\n            elif self.inout_str.lower() in [\"o\", \"out\"]:\n                self.inout_value = BIKE_OUT\n            else:\n                return\n            # Anything left over?\n            if not self.remainder:\n                return\n            # Next part a time value?\n            self.atime_str = self.remainder[0]\n            self.remainder = self.remainder[1:]\n            atime = VTime(self.atime_str)\n            if not atime:\n                return\n            self.atime_value = atime\n            # All done here\n            return\n\n    def edit_processor(\n        maybe_tag: TagID, inout: str, target_time: VTime\n    ) -> bool:\n        \"\"\"Execute one edit command with all its args known.\n\n        On entry:\n            tag: is a valid tag id (though possibly not usable)\n            inout: is BIKE_IN or BIKE_OUT\n            target_time: is a valid Time\n        On exit, either:\n            tag has been changed, msg delivered, returns True; or\n            no change, error msg delivered, returns False\n        \"\"\"\n\n        def success(tag: TagID, inout_str: str, newtime: VTime) -> None:\n            \"\"\"Print change message. inout_str is 'in' or 'out.\"\"\"\n            inoutflag = BIKE_IN if inout_str == \"in\" else BIKE_OUT\n            print_tag_inout(tag, inoutflag, newtime)\n\n        # Error conditions to test for\n        # Unusable tag (not known, retired)\n        # For checking in:\n        #   Existing Out is earler than target time\n        # For checking out:\n        #   Not yet checked in\n        #   Existing In later than target_time\n\n        tag = TagID(maybe_tag)\n        if not tag.valid:\n            error(f\"String '{tag.original}' is not a valid tag ID\")\n            return False\n        if tag in RETIRED_TAGS:\n            error(f\"Tag '{tag}' is marked as retired\")\n            return False\n        if tag not in ALL_TAGS:\n            error(f\"Tag '{tag}' not available for use\")\n            return False\n        if (\n            inout == BIKE_IN\n            and tag in check_outs\n            and check_outs[tag] < target_time\n        ):\n            error(f\"Tag '{tag}' has check-out time earlier than {target_time}\")\n            return False\n        if inout == BIKE_OUT:\n            if tag not in check_ins:\n                error(f\"Tag '{tag}' not checked in\")\n                return False\n            if check_ins[tag] > target_time:\n                error(\n                    f\"Tag '{tag}' has checked in later than {target_time.short}\"\n                )\n                return False\n        # Have checked for errors, can now commit the change\n        if inout == BIKE_IN:\n            check_ins[tag] = target_time\n            success(tag, \"in\", target_time)\n        elif inout == BIKE_OUT:\n            check_outs[tag] = target_time\n            success(tag, \"out\", target_time)\n        else:\n            ut.squawk(f\"Bad inout in call to edit_processor: '{inout}'\")\n            return False\n        return True\n\n    syntax = \"Syntax: edit [tag(s)] [in|out] [time|'now']\"\n    # Turn all the args into a string, discarding the 'edit' at the front\n\n    argstring = \" \".join(args)\n    cmd = TokenSet(argstring)\n    if cmd.num_tokens > 0 and not cmd.tags:\n        error(f\"Bad input. {syntax}\")\n        return\n    if not cmd.tags:\n        response = prompt_for_stuff(\"Set time for which bike tag(s)?\")\n        if not response:\n            cancel()\n            return\n        argstring += \" \" + response\n        cmd = TokenSet(argstring)\n        if not cmd.tags:\n            error(\"Bad tag values\", severe=True)\n            return\n    # At this point we know we have tags\n    while not cmd.inout_str:\n        response = prompt_for_stuff(\"Set bike check-IN or OUT (i/o)?\")\n        if not response:\n            cancel()\n            return\n        argstring += \" \" + response\n        cmd = TokenSet(argstring)\n    if cmd.inout_value not in [BIKE_IN, BIKE_OUT]:\n        error(f\"Must specify IN or OUT, not '{cmd.inout_str}'. \" f\"{syntax}\")\n        return\n    # Now we know we have tags and an INOUT\n    while not cmd.atime_str:\n        response = prompt_for_stuff(\"Set to what time?\")\n        if not response:\n            cancel()\n            return\n        argstring += \" \" + response\n        cmd = TokenSet(argstring)\n    if cmd.atime_value == BADVALUE:\n        error(\n            f\"Bad time '{cmd.atime_str}', \" f\"must be HHMM or 'now'. {syntax}\"\n        )\n        return\n    # That should be the whole command, with nothing left over.\n    if cmd.remainder:\n        error(\"Bad input at end \" f\"'{' '.join(cmd.remainder)}'. {syntax}\")\n        return\n    # Now we have a list of maybe-ish Tags, a usable INOUT and a usable Time\n    for tag in cmd.tags:\n        edit_processor(tag, cmd.inout_value, cmd.atime_value)", "\n\ndef print_tag_inout(tag: TagID, inout: str, when: VTime = VTime(\"\")) -> None:\n    \"\"\"Pretty-print a tag-in or tag-out message.\"\"\"\n    if inout == BIKE_IN:\n        basemsg = f\"Bike {tag} checked in\"\n        basemsg = f\"{basemsg} at {when.short}\" if when else basemsg\n        finalmsg = f\"{basemsg:40} <---in---  \"\n    elif inout == BIKE_OUT:\n        basemsg = f\"Bike {tag} checked out\"\n        basemsg = f\"{basemsg} at {when.short}\" if when else basemsg\n        finalmsg = f\"{basemsg:55} ---out--->  \"\n    else:\n        ut.squawk(f\"bad call to called print_tag_inout({tag}, {inout})\")\n        return\n    # Print\n    pr.iprint(finalmsg, style=cfg.ANSWER_STYLE)", "\n\ndef tag_check(tag: TagID) -> None:\n    \"\"\"Check a tag in or out.\n\n    This processes a prompt that's just a tag ID.\n    \"\"\"\n    if tag in RETIRED_TAGS:  # if retired print specific retirement message\n        pr.iprint(f\"{tag} is retired\", style=cfg.WARNING_STYLE)\n    else:  # must not be retired so handle as normal\n        if tag in check_ins:\n            if tag in check_outs:  # if tag has checked in & out\n                query_tag([tag], multi_line=False)\n                pr.iprint(\n                    f\"Overwrite {check_outs[tag]} check-out with \"\n                    f\"current time ({VTime('now').short})? \"\n                    f\"(y/N) {cfg.CURSOR}\",\n                    style=cfg.SUBPROMPT_STYLE,\n                    end=\"\",\n                )\n                sure = pr.tt_inp().lower() in [\"y\", \"yes\"]\n                if sure:\n                    multi_edit([tag, \"o\", VTime(\"now\")])\n                else:\n                    pr.iprint(\"Cancelled\", style=cfg.WARNING_STYLE)\n            else:  # checked in only\n                # How long ago checked in? Maybe ask operator to confirm.\n                rightnow = VTime(\"now\")\n                time_diff_mins = rightnow.num - VTime(check_ins[tag]).num\n                if time_diff_mins < 0:\n                    query_tag([tag], multi_line=False)\n                    pr.iprint(\n                        \"Check-in is in the future; check out cancelled\",\n                        style=cfg.WARNING_STYLE,\n                    )\n                    return\n                if time_diff_mins < cfg.CHECK_OUT_CONFIRM_TIME:\n                    query_tag([tag], multi_line=False)\n                    pr.iprint(\n                        \"Do you want to check it out? \" f\"(y/N) {cfg.CURSOR}\",\n                        style=cfg.SUBPROMPT_STYLE,\n                        end=\"\",\n                    )\n                    sure = pr.tt_inp().lower() in [\"yes\", \"y\"]\n                else:  # don't check for long stays\n                    sure = True\n                if sure:\n                    multi_edit([tag, \"o\", rightnow])\n                else:\n                    pr.iprint(\n                        \"Cancelled bike check out\", style=cfg.WARNING_STYLE\n                    )\n        else:  # if string is in neither dict\n            check_ins[tag] = VTime(\"now\")\n            print_tag_inout(tag, BIKE_IN)", "\n\ndef parse_command(user_input: str) -> list[str]:\n    \"\"\"Parse user's input into list of [tag] or [command, command args].\n\n    Return:\n        [cfg.CMD_TAG_RETIRED,args] if a tag but is retired\n        [cfg.CMD_TAG_UNUSABLE,args] if a tag but otherwise not usable\n        [cfg.CMD_UNKNOWN,args] if not a tag & not a command\n    \"\"\"\n    user_input = user_input.lower().strip(\"\\\\][ \\t\")\n    if not (user_input):\n        return []\n    # Special case - if user input starts with '/' or '?' add a space.\n    if user_input[0] in [\"/\", \"?\"]:\n        user_input = user_input[0] + \" \" + user_input[1:]\n    # Split to list, test to see if tag.\n    input_tokens = user_input.split()\n    # See if it matches tag syntax\n    maybetag = TagID(input_tokens[0])\n    if maybetag:\n        # This appears to be a tag\n        if maybetag in RETIRED_TAGS:\n            return [cfg.CMD_TAG_RETIRED] + input_tokens[1:]\n        # Is this tag usable?\n        if maybetag not in ALL_TAGS:\n            return [cfg.CMD_TAG_UNUSABLE] + input_tokens[1:]\n        # This appears to be a usable tag.\n        return [maybetag]\n\n    # See if it is a recognized command.\n    # cfg.command_aliases is dict of lists of aliases keyed by\n    # canonical command name (e.g. {\"edit\":[\"ed\",\"e\",\"edi\"], etc})\n    command = None\n    for c, aliases in cfg.COMMANDS.items():\n        if input_tokens[0] in aliases:\n            command = c\n            break\n    # Is this an unrecognized command?\n    if not command:\n        return [cfg.CMD_UNKNOWN] + input_tokens[1:]\n    # We have a recognized command, return it with its args.\n    return [command] + input_tokens[1:]", "\n\ndef show_help():\n    \"\"\"Show help_message with colour style highlighting.\n\n    Prints first non-blank line as title;\n    lines that are flush-left as subtitles;\n    other lines in normal style.\n    \"\"\"\n    title_done = False\n    for line in cfg.HELP_MESSAGE.split(\"\\n\"):\n        if not line:\n            pr.iprint()\n        elif not title_done:\n            title_done = True\n            pr.iprint(line, style=cfg.TITLE_STYLE)\n        elif line[0] != \" \":\n            pr.iprint(line, style=cfg.SUBTITLE_STYLE)\n        else:\n            pr.iprint(line, style=cfg.NORMAL_STYLE)", "\n\ndef dump_data():\n    \"\"\"For debugging. Dump current contents of core data structures.\"\"\"\n    pr.iprint()\n    pr.iprint(\"    cfg   \", num_indents=0, style=cfg.ERROR_STYLE)\n    for var in vars(cfg):\n        if var[0] == \"_\":\n            continue\n        value = vars(cfg)[var]\n        if isinstance(value, (str, dict, list, set, float, int)):\n            pr.iprint(\n                f\"{var} {type(value)}:  \", style=cfg.ANSWER_STYLE, end=\"\"\n            )\n            pr.iprint(value)\n    pr.iprint()\n    pr.iprint(\"    main module   \", num_indents=0, style=cfg.ERROR_STYLE)\n    for var in globals():\n        if var[0] == \"_\":\n            continue\n        value = globals()[var]\n        if isinstance(value, (str, dict, list, frozenset, set, float, int)):\n            pr.iprint(\n                f\"{var} {type(value)}:  \", style=cfg.ANSWER_STYLE, end=\"\"\n            )\n            pr.iprint(value)\n    if check_ins:\n        pr.iprint()\n        pr.iprint(f\"{type(list(check_ins.keys())[0])=}\")\n        pr.iprint(f\"{type(list(check_outs.keys())[0])=}\")\n        pr.iprint(f\"{type(list(NORMAL_TAGS)[0])=}\")", "\n\ndef main():\n    \"\"\"Run main program loop and dispatcher.\"\"\"\n    done = False\n    todays_date = ut.date_str('today')\n    publishment = pub.Publisher(cfg.REPORTS_FOLDER, cfg.PUBLISH_FREQUENCY)\n    while not done:\n        pr.iprint()\n        if cfg.INCLUDE_TIME_IN_PROMPT:\n            pr.iprint(f\"{VTime('now').short}\", end=\"\")\n        pr.iprint(\n            f\"Bike tag or command {cfg.CURSOR}\", style=cfg.PROMPT_STYLE, end=\"\"\n        )\n        user_str = pr.tt_inp()\n        # Break command into tokens, parse as command\n        tokens = parse_command(user_str)\n        # If midnight has passed then need to restart\n        if midnight_passed(todays_date):\n            if not tokens or tokens[0] != cfg.CMD_EXIT:\n                midnight_message()\n            done = True\n            continue\n        # If null input, just ignore\n        if not tokens:\n            continue  # No input, ignore\n        (cmd, *args) = tokens\n        # Dispatcher\n        data_dirty = False\n        if cmd == cfg.CMD_EDIT:\n            multi_edit(args)\n            data_dirty = True\n        elif cmd == cfg.CMD_AUDIT:\n            rep.audit_report(pack_day_data(), args)\n            publishment.publish_audit(pack_day_data(), args)\n        elif cmd == cfg.CMD_DELETE:\n            delete_entry(*args)\n            data_dirty = True\n        elif cmd == cfg.CMD_EXIT:\n            done = True\n        elif cmd == cfg.CMD_BLOCK:\n            rep.dataform_report(pack_day_data(), args)\n        elif cmd == cfg.CMD_HELP:\n            show_help()\n        elif cmd == cfg.CMD_LOOKBACK:\n            rep.recent(pack_day_data(), args)\n        elif cmd == cfg.CMD_RETIRED or cmd == cfg.CMD_COLOURS:\n            pr.iprint(\n                \"This command has been replaced by the 'tags' command.\",\n                style=cfg.WARNING_STYLE,\n            )\n        elif cmd == cfg.CMD_TAGS:\n            inv.tags_config_report(pack_day_data(), args)\n        elif cmd == cfg.CMD_QUERY:\n            query_tag(args)\n        elif cmd == cfg.CMD_STATS:\n            rep.day_end_report(pack_day_data(), args)\n            # Force publication when do day-end reports\n            publishment.publish(pack_day_data())\n            ##last_published = maybe_publish(last_published, force=True)\n        elif cmd == cfg.CMD_BUSY:\n            rep.busyness_report(pack_day_data(), args)\n        elif cmd == cfg.CMD_CHART:\n            rep.full_chart(pack_day_data())\n        elif cmd == cfg.CMD_BUSY_CHART:\n            rep.busy_graph(pack_day_data())\n        elif cmd == cfg.CMD_FULL_CHART:\n            rep.fullness_graph(pack_day_data())\n        elif cmd == cfg.CMD_CSV:\n            rep.csv_dump(pack_day_data(), args)\n        elif cmd == cfg.CMD_DUMP:\n            dump_data()\n        elif cmd == cfg.CMD_LINT:\n            lint_report(strict_datetimes=True)\n        elif cmd == cfg.CMD_PUBLISH:\n            publishment.publish_reports(pack_day_data(), args)\n        elif cmd == cfg.CMD_VALET_HOURS:\n            set_valet_hours(args)\n            data_dirty = True\n        elif cmd == cfg.CMD_UPPERCASE or cmd == cfg.CMD_LOWERCASE:\n            set_tag_case(cmd == cfg.CMD_UPPERCASE)\n        # Check for bad input\n        elif not TagID(cmd):\n            # This is not a tag\n            if cmd == cfg.CMD_UNKNOWN or len(args) > 0:\n                msg = \"Unrecognized command, enter 'h' for help\"\n            elif cmd == cfg.CMD_TAG_RETIRED:\n                msg = f\"Tag '{TagID(user_str)}' is retired\"\n            elif cmd == cfg.CMD_TAG_UNUSABLE:\n                msg = f\"Valet not configured to use tag '{TagID(user_str)}'\"\n            else:\n                # Should never get to this point\n                msg = \"Surprised by unrecognized command\"\n            pr.iprint()\n            pr.iprint(msg, style=cfg.WARNING_STYLE)\n\n        else:\n            # This is a tag\n            tag_check(cmd)\n            data_dirty = True\n        # If anything has becomne \"24:00\" change it to \"23:59\"\n        if data_dirty:\n            fix_2400_events()\n        # Save if anything has changed\n        if data_dirty:\n            data_dirty = False\n            save()\n            publishment.maybe_publish(pack_day_data())\n            ##last_published = maybe_publish(last_published)\n        # Flush any echo buffer\n        pr.echo_flush()\n    # Exiting; one last save and publishing\n    save()\n    publishment.publish(pack_day_data())", "\n\ndef custom_datafile() -> str:\n    \"\"\"Return custom datafilename from command line arg or \"\".\"\"\"\n    if len(sys.argv) <= 1:\n        return \"\"\n    # Custom datafile name or location\n    file = sys.argv[1]\n    # File there?\n    if not os.path.exists(file):\n        pr.iprint(f\"Error: File {file} not found\", style=cfg.ERROR_STYLE)\n        error_exit()\n    # This is the custom datafile & it exists\n    return file", "\n\ndef save():\n    \"\"\"Save today's data in the datafile.\"\"\"\n    # Save .bak\n    df.rotate_datafile(DATA_FILEPATH)\n    # Pack data into a TrackerDay object to store\n    day = pack_day_data()\n    # Store the data\n    if not df.write_datafile(DATA_FILEPATH, day):\n        ut.squawk(\"CRITICAL ERROR. Can not continue\")\n        error_exit()", "\n\ndef error_exit() -> None:\n    \"\"\"If an error has occurred, give a message and shut down.\n\n    Any specific info about the error should already have been printed.\n    \"\"\"\n    pr.iprint()\n    pr.iprint(\"Closing in 30 seconds\", style=cfg.ERROR_STYLE)\n    time.sleep(30)\n    exit()", "\n\ndef set_tag_case(want_uppercase: bool) -> None:\n    \"\"\"Set tags to be uppercase or lowercase depending on 'command'.\"\"\"\n    ##global UC_TAGS  # pylint: disable=global-statement\n    case_str = \"upper case\" if want_uppercase else \"lower case\"\n    if TagID.uc() == want_uppercase:\n        pr.iprint(f\"Tags already {case_str}.\", style=cfg.WARNING_STYLE)\n        return\n    TagID.uc(want_uppercase)\n    pr.iprint(f\" Tags will now show in {case_str}. \", style=cfg.ANSWER_STYLE)", "\n\ndef lint_report(strict_datetimes: bool = True) -> None:\n    \"\"\"Check tag lists and event lists for consistency.\"\"\"\n    errs = pack_day_data().lint_check(strict_datetimes)\n    if errs:\n        for msg in errs:\n            pr.iprint(msg, style=cfg.WARNING_STYLE)\n    else:\n        pr.iprint(\"No inconsistencies found\", style=cfg.HIGHLIGHT_STYLE)\n    # And while we're at it, fix up any times that are set to \"24:00\"\n    fix_2400_events()", "\ndef midnight_message():\n    \"\"\"Print a \"you have to restart\" message.\"\"\"\n    # Time has rolled over past midnight so need a new datafile.\n    print(\"\\n\\n\\n\")\n    pr.iprint(\n        \"Program has been running since yesterday.\", style=cfg.WARNING_STYLE\n    )\n    pr.iprint(\n        \"Please restart program to reset for today's data.\",\n        style=cfg.WARNING_STYLE,\n    )\n    pr.iprint()\n    print(\"\\n\\n\\n\")\n    print(\"Automatically exiting in 15 seconds\")\n    time.sleep(15)", "\ndef midnight_passed(today_is: str) -> bool:\n    \"\"\"Check if it's still the same day.\"\"\"\n    if today_is == ut.date_str('today'):\n        return False\n    return True\n\n\ndef get_taglists_from_config() -> td.TrackerDay:\n    \"\"\"Read tag lists (oversize, etc) from tag config file.\"\"\"\n    # Lists of normal, oversize, retired tags\n    # Return a TrackerDay object, though its bikes_in/out are meaningless.\n    errs = []\n    day = df.read_datafile(cfg.TAG_CONFIG_FILE, errs)\n    if errs:\n        print(f\"Errors in file, {errs=}\")\n        error_exit()\n    return day", "def get_taglists_from_config() -> td.TrackerDay:\n    \"\"\"Read tag lists (oversize, etc) from tag config file.\"\"\"\n    # Lists of normal, oversize, retired tags\n    # Return a TrackerDay object, though its bikes_in/out are meaningless.\n    errs = []\n    day = df.read_datafile(cfg.TAG_CONFIG_FILE, errs)\n    if errs:\n        print(f\"Errors in file, {errs=}\")\n        error_exit()\n    return day", "\n\n# ---------------------------------------------\n# STARTUP\n\n# Tags uppercase or lowercase?\n# Data file\nDATA_FILEPATH = custom_datafile()\nCUSTOM_DAT = bool(DATA_FILEPATH)\nif not CUSTOM_DAT:\n    DATA_FILEPATH = df.datafile_name(cfg.DATA_FOLDER)", "CUSTOM_DAT = bool(DATA_FILEPATH)\nif not CUSTOM_DAT:\n    DATA_FILEPATH = df.datafile_name(cfg.DATA_FOLDER)\n\n\nif __name__ == \"__main__\":\n    # Possibly turn on echo\n    if cfg.ECHO:\n        pr.set_echo(True)\n\n    pr.iprint()\n    pr.iprint(\n        \"TagTracker by Julias Hocking\",\n        num_indents=0,\n        style=cfg.ANSWER_STYLE,\n    )\n    pr.iprint(f\"Version {ut.get_version()}\")\n    pr.iprint()\n    # If no tags file, create one and tell them to edit it.\n    if not os.path.exists(cfg.TAG_CONFIG_FILE):\n        df.new_tag_config_file(cfg.TAG_CONFIG_FILE)\n        pr.iprint(\"No tags configuration file found.\", style=cfg.WARNING_STYLE)\n        pr.iprint(\n            f\"Creating new configuration file {cfg.TAG_CONFIG_FILE}\",\n            style=cfg.WARNING_STYLE,\n        )\n        pr.iprint(\n            \"Edit this file then re-rerun TagTracker.\", style=cfg.WARNING_STYLE\n        )\n        print(\"\\n\" * 3, \"Exiting automatically in 15 seconds.\")\n        time.sleep(15)\n        exit()\n\n    # Configure check in- and out-lists and operating hours from file\n    if not initialize_today():  # only run main() if tags read successfully\n        error_exit()\n\n    lint_report(strict_datetimes=False)\n\n    # Get/set valet date & time\n    if not VALET_OPENS or not VALET_CLOSES:\n        (opens,closes) = cfg.valet_hours(VALET_DATE)\n        VALET_OPENS = VALET_OPENS if VALET_OPENS else opens\n        VALET_CLOSES = VALET_CLOSES if VALET_CLOSES else closes\n\n    pr.iprint()\n    pr.iprint(\n        \"Please check today's opening/closing times.\",\n        style=cfg.ERROR_STYLE,\n    )\n    set_valet_hours([\"\",\"\"])\n    if VALET_OPENS or VALET_CLOSES:\n        save()\n\n    valet_logo()\n    main()\n\n    pr.set_echo(False)", "# ==========================================\n"]}
{"filename": "helpers/valet_hours_check.py", "chunked_list": ["#!/usr/bin/env python3\n\"\"\"Scan valet hours to see if they seem correct.\"\"\"\n\nimport sys\nsys.path.append(\"../\")\nimport tt_dbutil as db\nfrom tt_conf import valet_hours\nfrom tt_util import date_str\n\ndbfile = \"/fs/sysbits/tagtracker/dev/data/cityhall_bikevalet.db\"", "\ndbfile = \"/fs/sysbits/tagtracker/dev/data/cityhall_bikevalet.db\"\n\ndatabase = db.db_connect(dbfile)\nvhours = db.db_fetch(\n    database, \"select date,time_open,time_closed from day order by date\"\n)\nprint(\"Mismatches between actual and exected valet hours.\")\nprint(f\"Database: {dbfile}\")\nprint()", "print(f\"Database: {dbfile}\")\nprint()\nprint(\"Date            Actual(DB)   Expected\")\nfor onedate in vhours:\n    (expected_open, expected_close) = valet_hours(onedate.date)\n    actual_open = onedate.time_open\n    actual_close = onedate.time_closed\n    nomatch = \"\"\n    if actual_open != expected_open:\n        nomatch = \"OPEN\"\n    if actual_close != expected_close:\n        nomatch = \"BOTH\" if nomatch else \"CLOSE\"\n    if nomatch:\n        print(\n            f\"{onedate.date} {date_str(onedate.date,dow_str_len=3)}  \"\n            f\"{actual_open}-{actual_close}  \"\n            f\"{expected_open}-{expected_close}  \"\n            f\"{nomatch}\"\n        )", ""]}
{"filename": "helpers/fix-hours.py", "chunked_list": ["#!/usr/bin/env python3\n\"\"\"One-time script to add valet hours to historic datafiles.\n\nDelete as soon as historic conversions are complete & loaded into DB\n\"\"\"\nimport sys\nsys.path.append(\"../\")\nimport datetime\nimport os\nimport re", "import os\nimport re\nfrom typing import Tuple\nfrom tt_conf import valet_hours\n\n\nHEADER_VALET_DATE = \"Valet date:\"\nHEADER_VALET_OPENS = \"Valet opens:\"\nHEADER_VALET_CLOSES = \"Valet closes:\"\n", "HEADER_VALET_CLOSES = \"Valet closes:\"\n\ndatfolder = r\"/fs/sysbits/tagtracker/data_conversion/remotedata.fix_hours\"\n\n# Add valet date/hours header lines to a datafile.\n\nwhoami = os.path.basename(__file__)\n\nthedate = \"2023-03-16\"  # day beforethe first day of interest\nenddate = \"2023-07-01\"", "thedate = \"2023-03-16\"  # day beforethe first day of interest\nenddate = \"2023-07-01\"\nwhile thedate <= enddate:\n    datedate = datetime.datetime.strptime(\n        thedate, \"%Y-%m-%d\"\n    ) + datetime.timedelta(1)\n    thedate = datedate.strftime(\"%Y-%m-%d\")\n\n    (vopen, vclose) = valet_hours(thedate)\n", "    (vopen, vclose) = valet_hours(thedate)\n\n    fname = f\"cityhall_{thedate}\"\n    path = os.path.join(datfolder, f\"cityhall_{thedate}.dat\")\n    print()\n    if not os.path.exists(path):\n        print(f\"File {path} not found\")\n        continue\n    with open(path, \"r\") as f:\n        print(f\"Reading {path}\")\n        lines = f.readlines()", "    with open(path, \"r\") as f:\n        print(f\"Reading {path}\")\n        lines = f.readlines()\n    ##needs_dates = True\n    for num,line in enumerate(lines):\n        if re.match(\n            rf\"({HEADER_VALET_DATE}|{HEADER_VALET_OPENS}|{HEADER_VALET_CLOSES})\",\n            line,\n        ):\n            lines[num] = f\"## commented out by {whoami}: {line}\"", "            ##print(f\"Skipping {path}\")\n            ##needs_dates = False\n\n    ##if not needs_dates:\n    ##    continue\n    with open(path, \"w\") as f:\n        print(f\"Rewriting {path}\")\n        f.write(f\"# added by {whoami}\\n\")\n        f.write(f\"{HEADER_VALET_DATE} {thedate}\\n\")\n        f.write(f\"{HEADER_VALET_OPENS} {vopen}\\n\")\n        f.write(f\"{HEADER_VALET_CLOSES} {vclose}\\n\")\n        f.write(f\"# end of addition by {whoami}\\n\\n\")\n        f.writelines(lines)", ""]}
{"filename": "helpers/__init__.py", "chunked_list": [""]}
{"filename": "helpers/colorama_colours.py", "chunked_list": ["#!/usr/bin/python\n# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\n\n# print grid of all colors and brightnesses\n# uses stdout.write to write chars with no newline nor spaces between them\n# This should run more-or-less identically on Windows and Unix.\nfrom __future__ import print_function\nimport sys\n\n# Add parent dir to sys path, so the following 'import colorama' always finds", "\n# Add parent dir to sys path, so the following 'import colorama' always finds\n# the local source in preference to any installed version of colorama.\n#import fixpath\nfrom colorama import Fore, Back, Style\n\n\n# Fore, Back and Style are convenience classes for the constant ANSI strings that set\n#     the foreground, background and style. The don't have any magic of their own.\nFORES = [ Fore.BLACK, Fore.RED, Fore.GREEN, Fore.YELLOW, Fore.BLUE, Fore.MAGENTA, Fore.CYAN, Fore.WHITE ]", "#     the foreground, background and style. The don't have any magic of their own.\nFORES = [ Fore.BLACK, Fore.RED, Fore.GREEN, Fore.YELLOW, Fore.BLUE, Fore.MAGENTA, Fore.CYAN, Fore.WHITE ]\nBACKS = [ Back.BLACK, Back.RED, Back.GREEN, Back.YELLOW, Back.BLUE, Back.MAGENTA, Back.CYAN, Back.WHITE ]\nSTYLES = [ Style.DIM, Style.NORMAL, Style.BRIGHT ]\n\nNAMES = {\n    Fore.BLACK: 'black', Fore.RED: 'red', Fore.GREEN: 'green', Fore.YELLOW: 'yellow', Fore.BLUE: 'blue', Fore.MAGENTA: 'magenta', Fore.CYAN: 'cyan', Fore.WHITE: 'white'\n    , Fore.RESET: 'reset',\n    Back.BLACK: 'black', Back.RED: 'red', Back.GREEN: 'green', Back.YELLOW: 'yellow', Back.BLUE: 'blue', Back.MAGENTA: 'magenta', Back.CYAN: 'cyan', Back.WHITE: 'white',\n    Back.RESET: 'reset'", "    Back.BLACK: 'black', Back.RED: 'red', Back.GREEN: 'green', Back.YELLOW: 'yellow', Back.BLUE: 'blue', Back.MAGENTA: 'magenta', Back.CYAN: 'cyan', Back.WHITE: 'white',\n    Back.RESET: 'reset'\n}\n\n# show the color names\nsys.stdout.write('        ')\nfor foreground in FORES:\n    sys.stdout.write('%s%-7s' % (foreground, NAMES[foreground]))\nprint()\n", "print()\n\n# make a row for each background color\nfor background in BACKS:\n    sys.stdout.write('%s%-7s%s %s' % (background, NAMES[background], Back.RESET, background))\n    # make a column for each foreground color\n    for foreground in FORES:\n        sys.stdout.write(foreground)\n        # show dim, normal bright\n        for brightness in STYLES:\n            sys.stdout.write('%sX ' % brightness)\n        sys.stdout.write(Style.RESET_ALL + ' ' + background)\n    print(Style.RESET_ALL)", "\nprint()\n"]}
