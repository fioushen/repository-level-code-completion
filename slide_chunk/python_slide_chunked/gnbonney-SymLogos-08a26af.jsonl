{"filename": "setup.py", "chunked_list": ["from setuptools import setup, find_packages\n\nsetup(\n    name='symlogos',\n    version='0.1.0',\n    packages=find_packages(),\n    install_requires=[\n        \"sympy>=1.7.1\"\n    ],\n    extras_require={", "    ],\n    extras_require={\n        \"tests\": [\"pytest\"],\n    },\n    classifiers=[\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Natural Language :: English\",", "        \"License :: OSI Approved :: MIT License\",\n        \"Natural Language :: English\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",", "        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Scientific/Engineering :: Mathematics\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Topic :: Utilities\",", "        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Topic :: Utilities\",\n    ],\n    author='Greg Bonney',\n    author_email='gnbonney@gmail.com',\n    description='SymLogos is a Python library that extends the capabilities of SymPy to support higher-order modal logic for formal reasoning and theorem proving.',\n    long_description=open('README.md').read(),\n    long_description_content_type='text/markdown',\n    url='https://github.com/gnbonney/symlogos',\n    license='MIT',", "    url='https://github.com/gnbonney/symlogos',\n    license='MIT',\n)\n"]}
{"filename": "main.py", "chunked_list": ["from symlogos.functions_and_predicates import Proposition, Term, FunctionApplication, Predicate, Forall, Exists, Implication\n\ndef demonstrate_propositions():\n    print(\"=== Propositions ===\")\n    p = Proposition(\"p\")\n    not_p = ~p\n    box_p = p.box()\n    diamond_p = p.diamond()\n\n    print(\"p:\", p)\n    print(\"\u00acp:\", not_p)\n    print(\"\u25a1p:\", box_p)\n    print(\"\u25c7p:\", diamond_p)\n    print()", "\ndef demonstrate_predicates_quantifiers():\n    print(\"=== Predicates and Quantifiers ===\")\n    x = Term(\"x\")\n    y = Term(\"y\")\n    Px = Predicate(\"P\", x)\n    Py = Predicate(\"P\", y)\n    forall_px = Forall(x, Px)\n    exists_py = Exists(y, Py)\n\n    print(\"Px:\", Px)\n    print(\"Py:\", Py)\n    print(\"\u2200xPx:\", forall_px)\n    print(\"\u2203yPy:\", exists_py)\n    print()", "\ndef demonstrate_function_application():\n    print(\"=== Function Application ===\")\n    x = Term(\"x\")\n    y = Term(\"y\")\n    f = FunctionApplication(\"f\", x)\n    g = FunctionApplication(\"g\", y)\n\n    print(\"f(x):\", f)\n    print(\"g(y):\", g)\n    print()", "\ndef demonstrate_implications():\n    print(\"=== Implications ===\")\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    p_implies_q = Implication(p, q)\n    not_p_implies_not_q = Implication(~p, ~q)\n\n    print(\"p -> q:\", p_implies_q)\n    print(\"\u00acp -> \u00acq:\", not_p_implies_not_q)\n    print()", "\nif __name__ == \"__main__\":\n    demonstrate_propositions()\n    demonstrate_predicates_quantifiers()\n    demonstrate_function_application()\n    demonstrate_implications()\n"]}
{"filename": "symlogos/modal_logic.py", "chunked_list": ["from .proposition import Proposition\nfrom symlogos.connectives import Implication\nfrom .modal_operators import Necessity, Possibility\nfrom .rules import Rule\nfrom symlogos.rules import Rule\n\nclass ModalLogic:\n    @staticmethod\n    def necessitation() -> Rule:\n        p = Proposition(\"p\")\n        return Rule(\"Necessitation\", [p], Necessity(p))\n\n    @staticmethod\n    def distribution_axiom() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        return Rule(\"Distribution Axiom\", [Necessity(Implication(p, q))], Implication(Necessity(p), Necessity(q)))\n\n    @staticmethod\n    def possibility_axiom() -> Rule:\n        p = Proposition(\"p\")\n        return Rule(\"Possibility Axiom\", [Possibility(p)], Necessity(Possibility(p)))\n\n    @staticmethod\n    def modal_modus_ponens() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        return Rule(\"Modal Modus Ponens\", [Necessity(Implication(p, q)), Necessity(p)], Necessity(q))\n\n    @staticmethod\n    def t_schema() -> Rule:\n        p = Proposition(\"p\")\n        return Rule(\"T-schema\", [Necessity(p)], p)", ""]}
{"filename": "symlogos/rules.py", "chunked_list": ["from abc import ABC, abstractmethod\nfrom symlogos.expressions_and_terms import LogicalExpression\nfrom sympy.core.basic import Basic\nfrom typing import List\n\nfrom symlogos.signed_formula import SignedFormula\n\nclass Rule:\n    def __init__(self, name: str, premises: List[Basic], conclusion: Basic) -> None:\n        self.name = name\n        self.premises = premises\n        self.conclusion = conclusion\n\n    def __str__(self) -> str:\n        premises_str = \", \".join(map(str, self.premises))\n        return f\"{self.name}: {premises_str} \u22a2 {self.conclusion}\"\n\n    def __repr__(self) -> str:\n        premises_repr = \", \".join(map(repr, self.premises))\n        return f\"Rule('{self.name}', [{premises_repr}], {repr(self.conclusion)})\"\n\n    def apply(self, *args) -> LogicalExpression:\n        if len(args) != len(self.premises):\n            raise ValueError(\"Wrong number of arguments\")\n\n        match_dicts = []\n        for premise, arg in zip(self.premises, args):\n            current_match = premise.match(arg)\n            print(f\"Matching {premise} with {arg}: {current_match}\")  # Debug print\n            if current_match is None:\n                return None\n            match_dicts.append(current_match)\n\n        match_dict = {}\n        for d in match_dicts:\n            match_dict.update(d)\n\n        result = self.conclusion.substitute_all_terms(match_dict)\n        print(f\"Rule applied: {result}\")  # Debug print\n        return result\n\n    def to_nnf(self) -> \"Rule\":\n        nnf_premises = [premise.to_nnf() for premise in self.premises]\n        nnf_conclusion = self.conclusion.to_nnf()\n        return Rule(self.name, nnf_premises, nnf_conclusion)", "\ndef check_consistency():\n    pass\n\ndef check_validity():\n    pass\n\nclass TableauRule(ABC):\n\n    def __init__(self, signed_formula: SignedFormula) -> None:\n        self.signed_formula = signed_formula\n\n    @abstractmethod\n    def is_applicable(self):\n        \"\"\"\n        Check if the rule is applicable to the signed_formula.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def apply(self):\n        \"\"\"\n        Apply the rule to the signed_formula and return a list of branches,\n        where each branch is a list of SignedFormulas.\n        \"\"\"\n        pass"]}
{"filename": "symlogos/modal_operators.py", "chunked_list": ["from .expressions_and_terms import LogicalExpression, simplify_expression\nfrom symlogos.connectives import And\nfrom symlogos.proposition import Proposition\nfrom typing import Any, Dict, Union\n\nclass Necessity(LogicalExpression):\n    def __init__(self, expr: Any) -> None:\n        self.expr = expr\n\n    def __str__(self) -> str:\n        return f\"\u25a1{self.expr}\"\n\n    def __eq__(self, other: \"Necessity\") -> bool:\n        if not isinstance(other, Necessity):\n            return False\n        return self.expr == other.expr\n\n    def __hash__(self):\n        return hash((type(self), self.expr))\n\n    def __repr__(self):\n        return f\"Necessity({repr(self.expr)})\"\n\n    def simplify(self) -> bool:\n        expr_simplified = simplify_expression(self.expr)\n\n        if expr_simplified == True:\n            return True\n\n        if expr_simplified == False:\n            return False\n\n        return Necessity(expr_simplified)\n\n    def substitute(self, mapping):\n        new_expr = self.expr.substitute(mapping)\n        return Necessity(new_expr)\n\n    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> \"Necessity\":\n        new_expr = self.expr.substitute_all_terms(term_replacement_dict)\n        return Necessity(new_expr)\n\n    def match(self, expression: \"Necessity\") -> Dict[Any, Any]:\n        if isinstance(expression, Necessity):\n            match_result = self.expr.match(expression.expr)\n            if match_result is not None:\n                return match_result\n        return None", "\n\n\nclass Possibility(LogicalExpression):\n    def __init__(self, expr: Union[bool, And, Proposition]) -> None:\n        self.expr = expr\n\n    def __eq__(self, other: \"Possibility\") -> bool:\n        if isinstance(other, Possibility):\n            return self.expr == other.expr\n        return False\n\n    def __hash__(self):\n        return hash((type(self), self.expr))\n\n    def __str__(self) -> str:\n        return f\"\u25c7{self.expr}\"\n\n    def __repr__(self):\n        return f\"Possibility({repr(self.expr)})\"\n\n    def simplify(self) -> bool:\n        expr_simplified = simplify_expression(self.expr)\n\n        if expr_simplified == True:\n            return True\n\n        if expr_simplified == False:\n            return False\n\n        return Possibility(expr_simplified)\n\n    def match(self, other: \"Possibility\") -> Dict[Any, Any]:\n        if isinstance(other, Possibility):\n            match_result = self.expr.match(other.expr)\n            if match_result is None:\n                print(f\"Matching failed for expressions: self: {self}, other: {other}\")\n            else:\n                print(f\"Match successful: self: {self}, other: {other}, bindings: {match_result}\")\n            return match_result\n        else:\n            match_result = self.expr.match(other)\n            if match_result is None:\n                print(f\"Matching failed for expressions with different types: self: {self}, other: {other}\")\n            else:\n                print(f\"Match successful: self: {self}, other: {other}, bindings: {match_result}\")\n            return match_result", ""]}
{"filename": "symlogos/quantifiers.py", "chunked_list": ["from .expressions_and_terms import LogicalExpression\nfrom symlogos.expressions_and_terms import Term\nfrom symlogos.functions_and_predicates import Predicate\nfrom symlogos.modal_operators import Necessity\nfrom symlogos.proposition import Proposition\nfrom sympy.core.symbol import Symbol\nfrom typing import Any, Dict, Union\n\nclass Forall(LogicalExpression):\n    def __init__(self, variable: Union[Symbol, Term, str, Proposition], predicate: Union[Predicate, Necessity, Proposition]) -> None:\n        self.variable = variable\n        self.predicate = predicate\n\n    def instantiate(self, term):\n        return self.predicate.substitute({self.variable: term})\n\n    def __repr__(self):\n        return f\"\u2200{self.variable}: {self.predicate}\"\n\n    def __eq__(self, other: \"Forall\") -> bool:\n        return isinstance(other, Forall) and self.variable == other.variable and self.predicate == other.predicate\n\n    def __hash__(self):\n        return hash((type(self), self.variable, self.predicate))\n\n    def __str__(self) -> str:\n        return f\"\u2200{self.variable}: {self.predicate}\"\n\n    def __repr__(self):\n        return f\"Forall({repr(self.variable)}, {repr(self.predicate)})\"\n    \n    def substitute(self, mapping: Dict[Term, Term]) -> \"Forall\":\n        new_bound_variable = mapping.get(self.variable, self.variable)\n        new_predicate = self.predicate.substitute(mapping)\n        return Forall(new_bound_variable, new_predicate)\n\n    def substitute_all(self, substitutions):\n        # Prevent the bound variable from being substituted\n        if self.variable in substitutions:\n            del substitutions[self.variable]\n        \n        # Use the default implementation for the remaining substitutions\n        return super().substitute_all(substitutions)\n\n    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> \"Forall\":\n        new_predicate = self.predicate.substitute_all_terms(term_replacement_dict)\n        return Forall(self.variable, new_predicate)\n\n    def match(self, other: \"Forall\") -> Dict[Any, Any]:\n        if isinstance(other, Forall):\n            variable_match = self.variable.match(other.variable)\n            predicate_match = self.predicate.match(other.predicate)\n            print(f\"Forall match: self: {self}, other: {other}, variable_match: {variable_match}, predicate_match: {predicate_match}\")\n            if variable_match is not None and predicate_match is not None:\n                bindings = {}\n                bindings.update(variable_match)\n                bindings.update(predicate_match)\n                return bindings\n        return None\n\n    def to_nnf(self) -> \"Forall\":\n        return Forall(self.variable, self.predicate.to_nnf())", "class Forall(LogicalExpression):\n    def __init__(self, variable: Union[Symbol, Term, str, Proposition], predicate: Union[Predicate, Necessity, Proposition]) -> None:\n        self.variable = variable\n        self.predicate = predicate\n\n    def instantiate(self, term):\n        return self.predicate.substitute({self.variable: term})\n\n    def __repr__(self):\n        return f\"\u2200{self.variable}: {self.predicate}\"\n\n    def __eq__(self, other: \"Forall\") -> bool:\n        return isinstance(other, Forall) and self.variable == other.variable and self.predicate == other.predicate\n\n    def __hash__(self):\n        return hash((type(self), self.variable, self.predicate))\n\n    def __str__(self) -> str:\n        return f\"\u2200{self.variable}: {self.predicate}\"\n\n    def __repr__(self):\n        return f\"Forall({repr(self.variable)}, {repr(self.predicate)})\"\n    \n    def substitute(self, mapping: Dict[Term, Term]) -> \"Forall\":\n        new_bound_variable = mapping.get(self.variable, self.variable)\n        new_predicate = self.predicate.substitute(mapping)\n        return Forall(new_bound_variable, new_predicate)\n\n    def substitute_all(self, substitutions):\n        # Prevent the bound variable from being substituted\n        if self.variable in substitutions:\n            del substitutions[self.variable]\n        \n        # Use the default implementation for the remaining substitutions\n        return super().substitute_all(substitutions)\n\n    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> \"Forall\":\n        new_predicate = self.predicate.substitute_all_terms(term_replacement_dict)\n        return Forall(self.variable, new_predicate)\n\n    def match(self, other: \"Forall\") -> Dict[Any, Any]:\n        if isinstance(other, Forall):\n            variable_match = self.variable.match(other.variable)\n            predicate_match = self.predicate.match(other.predicate)\n            print(f\"Forall match: self: {self}, other: {other}, variable_match: {variable_match}, predicate_match: {predicate_match}\")\n            if variable_match is not None and predicate_match is not None:\n                bindings = {}\n                bindings.update(variable_match)\n                bindings.update(predicate_match)\n                return bindings\n        return None\n\n    def to_nnf(self) -> \"Forall\":\n        return Forall(self.variable, self.predicate.to_nnf())", "\nclass Exists(LogicalExpression):\n    def __init__(self, variable: Union[str, Symbol, Term, Proposition], predicate: Union[Predicate, Proposition]) -> None:\n        self.variable = variable\n        self.predicate = predicate\n\n    def __str__(self) -> str:\n        return f\"\u2203{self.variable}: {self.predicate}\"\n\n    def __eq__(self, other: \"Exists\") -> bool:\n        if not isinstance(other, Exists):\n            return False\n        return self.variable == other.variable and self.predicate == other.predicate\n\n    def __hash__(self):\n        return hash((type(self), self.variable, self.predicate))\n\n    def __repr__(self):\n        return f\"Exists({repr(self.variable)}, {repr(self.predicate)})\"\n\n    def substitute(self, mapping):\n        if self.variable in mapping:\n            raise ValueError(f\"Cannot substitute bound variable '{self.variable}'\")\n        new_expr = self.predicate.substitute(mapping)\n        return Exists(self.variable, new_expr)\n\n    def match(self, expression: \"Exists\") -> Dict[Term, Term]:\n        if isinstance(expression, Exists):\n            predicate_match = self.predicate.match(expression.predicate)\n            if predicate_match is not None:\n                print(f\"Match successful: self: {self}, expression: {expression}, substitutions: {predicate_match}\")\n                return predicate_match\n            else:\n                print(f\"Matching failed for predicates: self.predicate: {self.predicate}, expression.predicate: {expression.predicate}\")\n        else:\n            print(f\"Matching failed for different types: self: {self}, expression: {expression}\")\n        return None\n\n    def to_nnf(self) -> \"Exists\":\n        return Exists(self.variable, self.predicate.to_nnf())", ""]}
{"filename": "symlogos/functions_and_predicates.py", "chunked_list": ["from __future__ import annotations\nimport sympy\nfrom .expressions_and_terms import LogicalExpression\n\n# higher-order predicates\n\nclass Predicate(LogicalExpression):\n    def __new__(cls: Type[Predicate], name: Union[    sympy.core.symbol.Symbol, str], *terms) -> \"Predicate\":\n        obj = super().__new__(cls)\n        obj.symbol = sympy.Symbol(str(name))  # Convert name to string before creating a sympy.Symbol\n        obj.terms = tuple(terms[0]) if len(terms) == 1 and isinstance(terms[0], (list, tuple)) else terms\n        return obj\n\n    def __eq__(self, other: \"Predicate\") -> bool:\n        if not isinstance(other, Predicate):\n            return False\n        return self.symbol == other.symbol and self.terms == other.terms\n\n    def __hash__(self):\n        return hash((type(self), self.symbol, self.terms))\n\n    def __str__(self) -> str:\n        return f\"{self.symbol}({', '.join(map(str, self.terms))})\"\n\n    def __repr__(self):\n        return f\"Predicate('{self.symbol}', {', '.join(map(repr, self.terms))})\"\n    \n    def substitute(self, mapping: Dict[Term, Term]) -> \"Predicate\":\n        new_args = [mapping.get(term, term) for term in self.terms]\n        return Predicate(self.symbol, *new_args)\n\n    def substitute_all_terms(self, term_replacement_dict: Dict[Term, Term]) -> \"Predicate\":\n        new_terms = [term_replacement_dict.get(term, term) for term in self.terms]\n        new_predicate = Predicate(self.symbol, *new_terms)\n        return new_predicate\n    \n    def evaluate(self, valuation=None):\n        if valuation is None:\n            return self\n        \n        if self.symbol in valuation:\n            value = valuation[self.symbol]\n            if isinstance(value, bool):\n                return value\n\n        new_args = [arg.evaluate(valuation) if isinstance(arg, LogicalExpression) else arg for arg in self.terms]\n        return Predicate(self.symbol, *new_args)\n    \n    def match(self, other: \"Predicate\") -> Dict[Term, Term]:\n        if isinstance(other, Predicate):\n            if self.symbol == other.symbol and len(self.terms) == len(other.terms):\n                bindings = {}\n                for t1, t2 in zip(self.terms, other.terms):\n                    b = t1.match(t2)\n                    if b is None:\n                        print(f\"Matching failed for: self: {self}, other: {other}, terms: {t1}, {t2}\")\n                        return None\n                    print(f\"Matched terms: {t1}, {t2}, binding: {b}\")\n                    bindings.update(b)\n                print(f\"Match successful: self: {self}, other: {other}, bindings: {bindings}\")\n                return bindings\n            else:\n                print(f\"Matching failed due to different symbol or term count: self: {self}, other: {other}\")\n                return None\n        else:\n            print(f\"Matching failed as other is not a Predicate: self: {self}, other: {other}\")\n            return None\n\n    def is_atomic(self):\n        return True\n            \n    def to_nnf(self) -> \"Predicate\":\n        return self", "\n# high order functions\n\nfrom sympy import Basic, Symbol\nimport sympy.core.symbol\nfrom symlogos.expressions_and_terms import Term\nfrom typing import Dict, Optional, Type, Union\n\nclass HigherOrderFunction(Basic):\n    def __new__(cls: Type[HigherOrderFunction], name: str, arg_function: Optional[HigherOrderFunction]=None, return_function: Optional[Union[Predicate, HigherOrderFunction]]=None, *args) -> \"HigherOrderFunction\":\n        obj = super().__new__(cls)\n        obj._name = Symbol(name)\n        obj._arg_function = arg_function\n        obj._return_function = return_function\n        obj._args = args\n        return obj\n\n    @property\n    def name(self) ->     sympy.core.symbol.Symbol:\n        return self._name\n\n    @property\n    def arg_function(self):\n        return self._arg_function\n\n    @arg_function.setter\n    def arg_function(self, value):\n        self._arg_function = value\n\n    @property\n    def return_function(self):\n        return self._return_function\n\n    @return_function.setter\n    def return_function(self, value):\n        self._return_function = value\n\n    def __str__(self) -> str:\n        arg_str = f\"({', '.join(map(str, self.args))})\" if self.args else \"\"\n        if self.arg_function and self.return_function:\n            return f\"{self.name}({self.arg_function}) -> {self.return_function}{arg_str}\"\n        elif self.arg_function:\n            return f\"{self.name}({self.arg_function}{arg_str})\"\n        elif self.return_function:\n            return f\"{self.name} -> {self.return_function}{arg_str}\"\n        else:\n            return f\"{self.name}{arg_str}\"\n\n    def __repr__(self) -> str:\n        return f\"HigherOrderFunction('{self.name}', {repr(self.arg_function)}, {repr(self.return_function)})\"\n    \n    def match(self, expr):\n        if isinstance(expr, HigherOrderFunction) and self.name == expr.name:\n            # check argument function\n            if self.arg_function is None or self.arg_function.match(expr.arg_function):\n                # check return function\n                if self.return_function is None or self.return_function.match(expr.return_function):\n                    # match arguments\n                    if len(self.args) != len(expr.args):\n                        print(f\"Matching failed due to different argument count: self: {self}, expr: {expr}\")\n                        return None\n                    substitutions = {}\n                    for i in range(len(self.args)):\n                        arg1 = self.args[i]\n                        arg2 = expr.args[i]\n                        result = arg1.match(arg2)\n                        if result is None:\n                            print(f\"Matching failed for arguments: self: {self}, expr: {expr}, args: {arg1}, {arg2}\")\n                            return None\n                        print(f\"Matched arguments: {arg1}, {arg2}, binding: {result}\")\n                        substitutions.update(result)\n                    print(f\"Match successful: self: {self}, expr: {expr}, bindings: {substitutions}\")\n                    return substitutions\n            else:\n                print(f\"Matching failed due to argument or return function mismatch: self: {self}, expr: {expr}\")\n                return None\n        else:\n            print(f\"Matching failed as expr is not a HigherOrderFunction or name mismatch: self: {self}, expr: {expr}\")\n            return None", "class HigherOrderFunction(Basic):\n    def __new__(cls: Type[HigherOrderFunction], name: str, arg_function: Optional[HigherOrderFunction]=None, return_function: Optional[Union[Predicate, HigherOrderFunction]]=None, *args) -> \"HigherOrderFunction\":\n        obj = super().__new__(cls)\n        obj._name = Symbol(name)\n        obj._arg_function = arg_function\n        obj._return_function = return_function\n        obj._args = args\n        return obj\n\n    @property\n    def name(self) ->     sympy.core.symbol.Symbol:\n        return self._name\n\n    @property\n    def arg_function(self):\n        return self._arg_function\n\n    @arg_function.setter\n    def arg_function(self, value):\n        self._arg_function = value\n\n    @property\n    def return_function(self):\n        return self._return_function\n\n    @return_function.setter\n    def return_function(self, value):\n        self._return_function = value\n\n    def __str__(self) -> str:\n        arg_str = f\"({', '.join(map(str, self.args))})\" if self.args else \"\"\n        if self.arg_function and self.return_function:\n            return f\"{self.name}({self.arg_function}) -> {self.return_function}{arg_str}\"\n        elif self.arg_function:\n            return f\"{self.name}({self.arg_function}{arg_str})\"\n        elif self.return_function:\n            return f\"{self.name} -> {self.return_function}{arg_str}\"\n        else:\n            return f\"{self.name}{arg_str}\"\n\n    def __repr__(self) -> str:\n        return f\"HigherOrderFunction('{self.name}', {repr(self.arg_function)}, {repr(self.return_function)})\"\n    \n    def match(self, expr):\n        if isinstance(expr, HigherOrderFunction) and self.name == expr.name:\n            # check argument function\n            if self.arg_function is None or self.arg_function.match(expr.arg_function):\n                # check return function\n                if self.return_function is None or self.return_function.match(expr.return_function):\n                    # match arguments\n                    if len(self.args) != len(expr.args):\n                        print(f\"Matching failed due to different argument count: self: {self}, expr: {expr}\")\n                        return None\n                    substitutions = {}\n                    for i in range(len(self.args)):\n                        arg1 = self.args[i]\n                        arg2 = expr.args[i]\n                        result = arg1.match(arg2)\n                        if result is None:\n                            print(f\"Matching failed for arguments: self: {self}, expr: {expr}, args: {arg1}, {arg2}\")\n                            return None\n                        print(f\"Matched arguments: {arg1}, {arg2}, binding: {result}\")\n                        substitutions.update(result)\n                    print(f\"Match successful: self: {self}, expr: {expr}, bindings: {substitutions}\")\n                    return substitutions\n            else:\n                print(f\"Matching failed due to argument or return function mismatch: self: {self}, expr: {expr}\")\n                return None\n        else:\n            print(f\"Matching failed as expr is not a HigherOrderFunction or name mismatch: self: {self}, expr: {expr}\")\n            return None", "\nclass FunctionApplication(LogicalExpression):\n    def __init__(self, function_symbol: Union[HigherOrderFunction, str], *args) -> None:\n        self.function_symbol = function_symbol\n        self.arguments = args\n\n    def __str__(self) -> str:\n        args_str = ', '.join(str(arg) for arg in self.arguments)\n        return f\"{self.function_symbol}({args_str})\"\n\n    def __eq__(self, other: \"FunctionApplication\") -> bool:\n        if not isinstance(other, FunctionApplication):\n            return False\n        return self.function_symbol == other.function_symbol and self.arguments == other.arguments\n    \n    def substitute(self, mapping):\n        new_args = tuple(arg.substitute(mapping) for arg in self.arguments)\n        return FunctionApplication(self.function_symbol, *new_args)\n\n    def variables(self):\n        variables = set()\n        for arg in self.arguments:\n            variables |= arg.variables()\n        return variables\n\n    def match(self, other):\n        if isinstance(other, FunctionApplication):\n            if self.function_symbol != other.function_symbol or len(self.arguments) != len(other.arguments):\n                return None\n\n            match = {}\n            for arg_self, arg_other in zip(self.arguments, other.arguments):\n                partial_match = arg_self.match(arg_other)\n                if partial_match is None:\n                    return None\n\n                for key, value in partial_match.items():\n                    if key in match and match[key] != value:\n                        return None\n                    match[key] = value\n\n            return match\n\n        return None", "\n\n"]}
{"filename": "symlogos/tableau_prover.py", "chunked_list": ["from __future__ import annotations\nfrom typing import Optional\n\nfrom symlogos.first_order_rules import AlphaRule, BetaRule, DeltaRule, GammaRule\nfrom symlogos.modal_operators import Necessity, Possibility\nfrom symlogos.proposition import Proposition\nfrom symlogos.tableau_node import TableauNode\nfrom .signed_formula import SignedFormula\nfrom .connectives import And, Or, Not, Implication\nfrom .quantifiers import Forall, Exists", "from .connectives import And, Or, Not, Implication\nfrom .quantifiers import Forall, Exists\nfrom symlogos.signed_formula import SignedFormula\nfrom symlogos.modal_rules import ModalBoxTRule, ModalBoxFRule, ModalDiamondTRule, ModalDiamondFRule\n\nclass TableauProver:\n    def __init__(self):\n        self.tableau_formulas = set()\n\n    def is_sound(self, premises, conclusion):\n        # Create a set of signed formulas for the premises with the sign \"T\"\n        tableau_formulas = {SignedFormula(\"T\", premise) for premise in premises}\n\n        # Create a signed formula for the negation of the conclusion with the sign \"F\"\n        negated_conclusion = SignedFormula(\"F\", Not(conclusion))\n\n        # Add the negated conclusion to the tableau formulas\n        tableau_formulas.add(negated_conclusion)\n\n        # Print statements for debugging\n        print(\"Premises:\", premises)\n        print(\"Conclusion:\", conclusion)\n        print(\"Negated Conclusion:\", negated_conclusion)\n        print(\"Tableau Formulas:\", tableau_formulas)\n\n        # Pass the signed formula to your tableau expansion methods and proceed with the tableau method\n        initial_node = TableauNode(negated_conclusion)\n        result = self.tableau_expansion(initial_node)\n\n        # Check if the tableau is closed\n        return not result\n\n\n    def _handle_and_or(self, param):\n        if isinstance(param, TableauNode):\n            formula = param.signed_formula.formula\n            signed_formula = param.signed_formula\n        elif isinstance(param, SignedFormula):\n            formula = param.formula\n            signed_formula = param\n        else:\n            raise ValueError(\"unexpected input to _handle_and_or\")\n\n        if isinstance(formula, Implication):\n            if signed_formula.sign == \"T\":\n                return [SignedFormula(\"F\", formula.left), SignedFormula(\"T\", formula.right)]\n            else:\n                return [SignedFormula(\"T\", formula.left), SignedFormula(\"F\", formula.right)]\n        elif isinstance(formula, Not) and isinstance(formula.inner, Implication):\n            inner_formula = formula.inner\n            if signed_formula.sign == \"T\":\n                return [SignedFormula(\"T\", inner_formula.left), SignedFormula(\"F\", inner_formula.right)]\n            else:\n                return [SignedFormula(\"F\", inner_formula.left), SignedFormula(\"T\", inner_formula.right)]\n        elif isinstance(formula, And):\n            if signed_formula.sign == \"T\":\n                return [SignedFormula(\"T\", formula.left), SignedFormula(\"T\", formula.right)]\n            else:\n                return [SignedFormula(\"F\", formula.left), SignedFormula(\"F\", formula.right)]\n        else:\n            rule = AlphaRule(signed_formula)\n            return rule.apply()\n\n    def _handle_quantifiers(self, node, signed_formula):\n        if signed_formula.sign == \"T\" and isinstance(signed_formula.formula, Forall) or signed_formula.sign == \"F\" and isinstance(signed_formula.formula, Exists):\n            rule = GammaRule(signed_formula)\n        else:\n            rule = DeltaRule(signed_formula)\n        return [child.signed_formula for child in rule.apply(node)]\n\n    def _handle_modal_operators(self, signed_formula):\n        formula = signed_formula.formula\n        if isinstance(formula, Necessity):\n            rule = ModalBoxTRule(signed_formula) if signed_formula.sign == \"T\" else ModalBoxFRule(signed_formula)\n        else:  # isinstance(formula, Possibility)\n            rule = ModalDiamondTRule(signed_formula) if signed_formula.sign == \"T\" else ModalDiamondFRule(signed_formula)\n        return rule.apply()\n\n    def _handle_not(self, signed_formula):\n        formula = signed_formula.formula\n        new_sign = \"T\" if signed_formula.sign == \"F\" else \"F\"\n        new_signed_formula = SignedFormula(new_sign, formula.expr)\n        return [new_signed_formula]\n\n    def tableau_expansion(self, node: TableauNode, depth=0, max_depth=1000):\n        signed_formula = node.signed_formula\n\n        # Debug: Print the current signed formula and depth\n        print(f\"Depth: {depth}, Current signed formula: {signed_formula}\")\n\n        # Check for termination conditions\n        if depth >= max_depth:\n            # Maximum depth reached; cannot determine if the tableau is closed\n            return False\n\n        # Check if the tableau is closed\n        if self._is_tableau_closed(node):\n            print(f\"Tableau closed at depth {depth} with signed formula {signed_formula}\")\n            return True\n\n        # Apply tableau rules to the signed formula\n        formula = signed_formula.formula\n        if isinstance(formula, And) or isinstance(formula, Or):\n            new_signed_formulas = self._handle_and_or(signed_formula)\n        elif isinstance(formula, Forall) or isinstance(formula, Exists):\n            new_signed_formulas = self._handle_quantifiers(node, signed_formula)\n        elif isinstance(formula, Necessity) or isinstance(formula, Possibility):\n            new_signed_formulas = self._handle_modal_operators(signed_formula)\n        elif isinstance(formula, Not):\n            new_signed_formulas = self._handle_not(signed_formula)\n        else:\n            new_signed_formulas = []\n\n        # Debug: Print the new signed formulas generated\n        print(f\"New signed formulas: {new_signed_formulas}\")\n\n        results = [self.tableau_expansion(node.add_child(new_signed_formula), depth + 1, max_depth) for new_signed_formula in new_signed_formulas]\n        return any(results)\n\n    def _is_tableau_closed(self, node: TableauNode) -> bool:\n        signed_formulas = [node.signed_formula] + [ancestor.signed_formula for ancestor in node.get_ancestors()]\n\n        print(\"Signed formulas in the current branch:\")\n        for sf in signed_formulas:\n            print(sf)\n\n        for sf1 in signed_formulas:\n            for sf2 in signed_formulas:\n                if sf1.formula == sf2.formula and sf1.sign != sf2.sign:\n                    return True\n\n        return False", "\n"]}
{"filename": "symlogos/tableau_node.py", "chunked_list": ["from __future__ import annotations\nfrom typing import Optional, List\nfrom symlogos.signed_formula import SignedFormula\n\nclass TableauNode:\n    def __init__(self, signed_formula: SignedFormula, parent: Optional[TableauNode]=None) -> None:\n        self.signed_formula = signed_formula\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, signed_formula):\n        child_node = TableauNode(signed_formula, parent=self)\n        self.children.append(child_node)\n        return child_node\n\n    def get_next_fresh_constant_index(self):\n        if self.parent:\n            return self.parent.get_next_fresh_constant_index() + 1\n        else:\n            return 0\n\n    def get_next_fresh_variable_index(self) -> int:\n        if self.parent:\n            return self.parent.get_next_fresh_variable_index() + 1\n        else:\n            return 0\n\n    def get_ancestors(self) -> List['TableauNode']:\n        ancestors = []\n        current_node = self.parent\n\n        while current_node is not None:\n            ancestors.append(current_node)\n            current_node = current_node.parent\n\n        return ancestors"]}
{"filename": "symlogos/__init__.py", "chunked_list": [""]}
{"filename": "symlogos/quantified_logic.py", "chunked_list": ["from .proposition import Proposition\nfrom .rules import Rule\nfrom .modal_logic import Necessity\nfrom .quantifiers import Exists, Forall\nfrom symlogos.rules import Rule\n\nclass QuantifiedLogic:\n    @staticmethod\n    def existential_instantiation() -> Rule:\n        x = Proposition(\"x\")\n        Fx = Proposition(\"Fx\")\n        c = Proposition(\"c\")\n        return Rule(\"Existential Instantiation\", [Exists(x, Fx)], Fx.substitute(x, c))\n\n    @staticmethod\n    def barcan_formula() -> Rule:\n        x = Proposition(\"x\")\n        Fx = Proposition(\"Fx\")\n        return Rule(\"Barcan Formula\", [Necessity(Forall(x, Fx))], Forall(x, Necessity(Fx)))", ""]}
{"filename": "symlogos/modal_rules.py", "chunked_list": ["from symlogos.signed_formula import SignedFormula\nfrom symlogos.modal_operators import Necessity, Possibility\nfrom symlogos.rules import TableauRule\n\nclass ModalBoxTRule(TableauRule):\n    def __init__(self, signed_formula: SignedFormula) -> None:\n        super().__init__(signed_formula)\n\n    def apply(self) -> list:\n        print(f\"{self.__class__.__name__}: Applying rule to {self.signed_formula}\")\n        if not isinstance(self.signed_formula.formula, Necessity) or self.signed_formula.sign != \"T\":\n            raise ValueError(\"Invalid signed formula for ModalBoxTRule\")\n        new_signed_formula = SignedFormula(\"T\", self.signed_formula.formula.expr)\n        result= [new_signed_formula]\n        print(f\"{self.__class__.__name__}: Result: {result}\")\n        return result\n\n    def is_applicable(self) -> bool:\n        return self.signed_formula.sign == \"T\" and isinstance(self.signed_formula.formula, Necessity)", "\nclass ModalBoxFRule(TableauRule):\n    def __init__(self, signed_formula: SignedFormula) -> None:\n        super().__init__(signed_formula)\n\n    def apply(self) -> list:\n        print(f\"{self.__class__.__name__}: Applying rule to {self.signed_formula}\")\n        if not isinstance(self.signed_formula.formula, Necessity) or self.signed_formula.sign != \"F\":\n            raise ValueError(\"Invalid signed formula for ModalBoxFRule\")\n        new_signed_formula = SignedFormula(\"F\", self.signed_formula.formula.expr)\n        result = [new_signed_formula]\n        print(f\"{self.__class__.__name__}: Result: {result}\")\n        return result\n\n    def is_applicable(self) -> bool:\n        return self.signed_formula.sign == \"F\" and isinstance(self.signed_formula.formula, Necessity)", "\nclass ModalDiamondTRule(TableauRule):\n    def __init__(self, signed_formula: SignedFormula) -> None:\n        super().__init__(signed_formula)\n\n    def apply(self) -> list:\n        print(f\"{self.__class__.__name__}: Applying rule to {self.signed_formula}\")\n        if not isinstance(self.signed_formula.formula, Possibility) or self.signed_formula.sign != \"T\":\n            raise ValueError(\"Invalid signed formula for ModalDiamondTRule\")\n        new_signed_formula = SignedFormula(\"T\", self.signed_formula.formula.expr)\n        result = [new_signed_formula]\n        print(f\"{self.__class__.__name__}: Result: {result}\")\n        return result\n\n    def is_applicable(self) -> bool:\n        return self.signed_formula.sign == \"T\" and isinstance(self.signed_formula.formula, Possibility)", "\nclass ModalDiamondFRule(TableauRule):\n    def __init__(self, signed_formula: SignedFormula) -> None:\n        super().__init__(signed_formula)\n\n    def apply(self) -> list:\n        print(f\"{self.__class__.__name__}: Applying rule to {self.signed_formula}\")\n        if not isinstance(self.signed_formula.formula, Possibility) or self.signed_formula.sign != \"F\":\n            raise ValueError(\"Invalid signed formula for ModalDiamondFRule\")\n        new_signed_formula = SignedFormula(\"F\", self.signed_formula.formula.expr)\n        result = [new_signed_formula]\n        print(f\"{self.__class__.__name__}: Result: {result}\")\n        return result\n\n    def is_applicable(self) -> bool:\n        return self.signed_formula.sign == \"F\" and isinstance(self.signed_formula.formula, Possibility)", "\n"]}
{"filename": "symlogos/classical_propositional_logic.py", "chunked_list": ["from .connectives import Implication, And, Or, Not\nfrom .proposition import Proposition\nfrom symlogos.rules import Rule\n\nclass ClassicalPropositionalLogic:\n\n    @staticmethod\n    def modus_ponens() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        return Rule(\"Modus Ponens\", [p, Implication(p, q)], q)\n\n    @staticmethod\n    def modus_tollens() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        return Rule(\"Modus Tollens\", [Implication(p, q), Not(q)], Not(p))\n\n    @staticmethod\n    def disjunction_introduction() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        return Rule(\"Disjunction Introduction\", [p], Or(p, q))\n\n    @staticmethod\n    def disjunction_elimination() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        r = Proposition(\"r\")\n        return Rule(\"Disjunction Elimination\", [Or(p, q), Implication(p, r), Implication(q, r)], r)\n\n    @staticmethod\n    def conjunction_introduction() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        return Rule(\"Conjunction Introduction\", [p, q], And(p, q))\n\n    @staticmethod\n    def conjunction_elimination1() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        return Rule(\"Conjunction Elimination 1\", [And(p, q)], p)\n\n    @staticmethod\n    def conjunction_elimination2() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        return Rule(\"Conjunction Elimination 2\", [And(p, q)], q)\n\n\n    @staticmethod\n    def commutativity_and() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        return Rule(\"Commutativity of And\", [And(p, q)], And(q, p))\n\n    @staticmethod\n    def commutativity_or() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        return Rule(\"Commutativity of Or\", [Or(p, q)], Or(q, p))\n\n    @staticmethod\n    def associativity_and() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        r = Proposition(\"r\")\n        return Rule(\"Associativity of And\", [And(p, And(q, r))], And(And(p, q), r))\n\n    @staticmethod\n    def associativity_or() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        r = Proposition(\"r\")\n        return Rule(\"Associativity of Or\", [Or(p, Or(q, r))], Or(Or(p, q), r))\n\n    @staticmethod\n    def idempotency_and() -> Rule:\n        p = Proposition(\"p\")\n        return Rule(\"Idempotency of And\", [And(p, p)], p)\n\n    @staticmethod\n    def idempotency_or() -> Rule:\n        p = Proposition(\"p\")\n        return Rule(\"Idempotency of Or\", [Or(p, p)], p)\n\n    @staticmethod\n    def double_negation_elimination() -> Rule:\n        p = Proposition(\"p\")\n        return Rule(\"Double Negation Elimination\", [Not(Not(p))], p)\n\n    @staticmethod\n    def distribution_and_over_or() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        r = Proposition(\"r\")\n        return Rule(\"Distribution of And over Or\", [And(p, Or(q, r))], Or(And(p, q), And(p, r)))\n\n    @staticmethod\n    def distribution_or_over_and() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        r = Proposition(\"r\")\n        return Rule(\"Distribution of Or over And\", [Or(p, And(q, r))], And(Or(p, q), Or(p, r)))\n\n    @staticmethod\n    def absorption_and() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        return Rule(\"Absorption of And\", [And(p, Or(p, q))], p)\n\n    @staticmethod\n    def absorption_or() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        return Rule(\"Absorption of Or\", [Or(p, And(p, q))], p)\n\n    @staticmethod\n    def negation_and_to_or() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        return Rule(\"Negation of And to Or\", [Not(And(p, q))], Or(Not(p), Not(q)))\n\n    @staticmethod\n    def negation_or_to_and() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        return Rule(\"Negation of Or to And\", [Not(Or(p, q))], And(Not(p), Not(q)))\n\n    @staticmethod\n    def implication_to_or() -> Rule:\n        p = Proposition(\"p\")\n        q = Proposition(\"q\")\n        return Rule(\"Implication to Or\", [Implication(p, q)], Or(Not(p), q))", ""]}
{"filename": "symlogos/connectives.py", "chunked_list": ["from __future__ import annotations\nfrom .expressions_and_terms import LogicalExpression, simplify_expression\nfrom symlogos.expressions_and_terms import Term\nfrom typing import Any, Dict, Union, TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from symlogos.proposition import Proposition\n    from symlogos.modal_operators import Necessity\n\nclass Implication(LogicalExpression):\n    def __init__(self, antecedent: Union['Proposition', 'Necessity', Term], consequent: Union['Proposition', 'Necessity', Term]) -> None:\n        self.antecedent = antecedent\n        self.consequent = consequent\n\n    @property\n    def left(self):\n        return self.antecedent\n\n    @property\n    def right(self):\n        return self.consequent\n\n    def __hash__(self):\n        return hash((type(self), self.antecedent, self.consequent))\n\n    def __eq__(self, other: \"Implication\") -> bool:\n        if isinstance(other, Implication):\n            return self.antecedent == other.antecedent and self.consequent == other.consequent\n        return False\n\n    def __str__(self) -> str:\n        antecedent_str = str(self.antecedent)\n        consequent_str = str(self.consequent)\n        return f\"({antecedent_str} \u2192 {consequent_str})\"\n\n    def __repr__(self):\n        return f\"Implication({repr(self.antecedent)}, {repr(self.consequent)})\"\n\n    def substitute(self, variable, replacement):\n        antecedent_substituted = self.antecedent.substitute(variable, replacement)\n        consequent_substituted = self.consequent.substitute(variable, replacement)\n        return Implication(antecedent_substituted, consequent_substituted)\n\n    def evaluate(self, valuation=None):\n        if valuation is None:\n            return self\n\n        antecedent_val = self.antecedent.evaluate(valuation)\n        consequent_val = self.consequent.evaluate(valuation)\n\n        if isinstance(antecedent_val, bool) and isinstance(consequent_val, bool):\n            return not antecedent_val or consequent_val\n        else:\n            return Implication(antecedent_val, consequent_val)\n\n    def simplify(self):\n        antecedent_simplified = simplify_expression(self.antecedent)\n        consequent_simplified = simplify_expression(self.consequent)\n    \n        if antecedent_simplified == True:\n            return consequent_simplified\n        if antecedent_simplified == False or consequent_simplified == True:\n            return True\n        if antecedent_simplified == consequent_simplified:\n            return True\n    \n        return Implication(antecedent_simplified, consequent_simplified)\n\n    def match(self, other: \"Implication\") -> Dict[Any, Any]:\n        if self == other:\n            return {}\n        return None\n\n    def to_nnf(self) -> \"Or\":\n        negated_antecedent = Not(self.antecedent).to_nnf()\n        consequent_nnf = self.consequent.to_nnf()\n        return Or(negated_antecedent, consequent_nnf)", "\nclass Implication(LogicalExpression):\n    def __init__(self, antecedent: Union['Proposition', 'Necessity', Term], consequent: Union['Proposition', 'Necessity', Term]) -> None:\n        self.antecedent = antecedent\n        self.consequent = consequent\n\n    @property\n    def left(self):\n        return self.antecedent\n\n    @property\n    def right(self):\n        return self.consequent\n\n    def __hash__(self):\n        return hash((type(self), self.antecedent, self.consequent))\n\n    def __eq__(self, other: \"Implication\") -> bool:\n        if isinstance(other, Implication):\n            return self.antecedent == other.antecedent and self.consequent == other.consequent\n        return False\n\n    def __str__(self) -> str:\n        antecedent_str = str(self.antecedent)\n        consequent_str = str(self.consequent)\n        return f\"({antecedent_str} \u2192 {consequent_str})\"\n\n    def __repr__(self):\n        return f\"Implication({repr(self.antecedent)}, {repr(self.consequent)})\"\n\n    def substitute(self, variable, replacement):\n        antecedent_substituted = self.antecedent.substitute(variable, replacement)\n        consequent_substituted = self.consequent.substitute(variable, replacement)\n        return Implication(antecedent_substituted, consequent_substituted)\n\n    def evaluate(self, valuation=None):\n        if valuation is None:\n            return self\n\n        antecedent_val = self.antecedent.evaluate(valuation)\n        consequent_val = self.consequent.evaluate(valuation)\n\n        if isinstance(antecedent_val, bool) and isinstance(consequent_val, bool):\n            return not antecedent_val or consequent_val\n        else:\n            return Implication(antecedent_val, consequent_val)\n\n    def simplify(self):\n        antecedent_simplified = simplify_expression(self.antecedent)\n        consequent_simplified = simplify_expression(self.consequent)\n    \n        if antecedent_simplified == True:\n            return consequent_simplified\n        if antecedent_simplified == False or consequent_simplified == True:\n            return True\n        if antecedent_simplified == consequent_simplified:\n            return True\n    \n        return Implication(antecedent_simplified, consequent_simplified)\n\n    def match(self, other: \"Implication\") -> Dict[Any, Any]:\n        if self == other:\n            return {}\n        return None\n\n    def to_nnf(self) -> \"Or\":\n        negated_antecedent = Not(self.antecedent).to_nnf()\n        consequent_nnf = self.consequent.to_nnf()\n        return Or(negated_antecedent, consequent_nnf)", "\n\nclass And(LogicalExpression):\n    def __init__(self, left: Any, right: Union[And, Term, Or, 'Proposition', Not]) -> None:\n        self.left = left\n        self.right = right\n\n    def __hash__(self):\n        return hash((type(self), self.left, self.right))\n\n    def __str__(self) -> str:\n        left_str = str(self.left)\n        right_str = str(self.right)\n        return f\"({left_str} \u2227 {right_str})\"\n\n    def __repr__(self):\n        return f\"And({repr(self.left)}, {repr(self.right)})\"\n    \n    def substitute(self, variable: 'Proposition', replacement: 'Proposition') -> \"And\":\n        left_substituted = self.left.substitute(variable, replacement)\n        right_substituted = self.right.substitute(variable, replacement)\n        return And(left_substituted, right_substituted)\n\n    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> \"And\":\n        left_substituted = self.left.substitute_all_terms(term_replacement_dict)\n        right_substituted = self.right.substitute_all_terms(term_replacement_dict)\n        return And(left_substituted, right_substituted)\n\n    def evaluate(self, valuation=None):\n        if valuation is None:\n            return self\n        \n        left_val = self.left.evaluate(valuation)\n        right_val = self.right.evaluate(valuation)\n\n        if isinstance(left_val, bool) and isinstance(right_val, bool):\n            return left_val and right_val\n        else:\n            return And(left_val, right_val)\n\n    def __eq__(self, other: \"And\") -> bool:\n        if isinstance(other, And):\n            return self.left == other.left and self.right == other.right\n        return False\n        \n    def simplify(self) -> Union['Proposition', bool, And]:\n        left_simplified = simplify_expression(self.left)\n        right_simplified = simplify_expression(self.right)\n\n        if left_simplified == True:\n            return right_simplified\n        if right_simplified == True:\n            return left_simplified\n        if left_simplified == False or right_simplified == False:\n            return False\n\n        if isinstance(left_simplified, Not) and isinstance(left_simplified.expr, Not):\n            left_simplified = left_simplified.expr.expr\n        if isinstance(right_simplified, Not) and isinstance(right_simplified.expr, Not):\n            right_simplified = right_simplified.expr.expr\n\n        if left_simplified == self.left and right_simplified == self.right:\n            return self\n\n        return And(left_simplified, right_simplified)\n\n    def match(self, other: \"And\", bindings: None=None) -> Dict[Any, Any]:\n        if bindings is None:\n            bindings = {}\n            \n        if isinstance(other, And):\n            left_match = self.left.match(other.left, bindings)\n            right_match = self.right.match(other.right, bindings)\n            \n            if left_match is None or right_match is None:\n                return None\n            \n            new_bindings = dict(bindings)\n            new_bindings.update(left_match)\n            new_bindings.update(right_match)\n            return new_bindings\n\n        if isinstance(other, LogicalExpression):\n            return bindings\n\n        return None\n\n    def to_nnf(self) -> \"And\":\n        return And(*(arg.to_nnf() for arg in self.args))", "\n\nclass Or(LogicalExpression):\n    def __init__(self, left: Union['Proposition', And, Or, Not], right: Union['Proposition', Or, Not, And]) -> None:\n        self.left = left\n        self.right = right\n\n    def __hash__(self):\n        return hash((type(self), self.left, self.right))\n\n    def __repr__(self):\n        return f\"({self.left} \u2228 {self.right})\"\n\n    def __eq__(self, other: \"Or\") -> bool:\n        if not isinstance(other, Or):\n            return False\n        return self.left == other.left and self.right == other.right\n\n    def variables(self):\n        return self.left.variables().union(self.right.variables())\n\n    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> \"Or\":\n        new_left = self.left.substitute_all_terms(term_replacement_dict)\n        new_right = self.right.substitute_all_terms(term_replacement_dict)\n        return Or(new_left, new_right)\n\n    def match(self, other: \"Or\", bindings: None=None) -> Dict[Any, Any]:\n        if bindings is None:\n            bindings = {}\n\n        if isinstance(other, Or):\n            left_match = self.left.match(other.left, bindings)\n            if left_match is not None:\n                right_match = self.right.match(other.right, left_match)\n                if right_match is not None:\n                    return right_match\n        return None\n\n    def to_nnf(self) -> \"Or\":\n        return Or(*(arg.to_nnf() for arg in self.args))", "\nclass Not(LogicalExpression):\n    def __init__(self, expr: Union[And, bool, Or, 'Proposition', Not]) -> None:\n        super().__init__()\n        self.expr = expr\n\n    def __eq__(self, other: \"Not\") -> bool:\n        if isinstance(other, Not):\n            return self.expr == other.expr\n        return False\n\n    def __hash__(self):\n        return hash((type(self), self.expr))\n\n    def __str__(self) -> str:\n        return f\"\u00ac{str(self.expr)}\"\n\n    def __repr__(self):\n        return f\"Not({repr(self.expr)})\"\n    \n    def substitute(self, variable: 'Proposition', replacement: 'Proposition') -> \"Not\":\n        return Not(self.expr.substitute(variable, replacement))\n\n    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> \"Not\":\n        new_expr = self.expr.substitute_all_terms(term_replacement_dict)  # Change this line\n        return Not(new_expr)\n    \n    def evaluate(self, valuation=None):\n        if valuation is None:\n            return self\n        \n        expr_val = self.expr.evaluate(valuation)\n\n        if isinstance(expr_val, bool):\n            return not expr_val\n        else:\n            return Not(expr_val)\n    \n    def simplify(self) -> Union['Proposition', bool, Not]:\n        simplified_inner = simplify_expression(self.expr)\n\n        if isinstance(simplified_inner, Not):\n            return simplified_inner.expr\n\n        if simplified_inner == True:\n            return False\n\n        if simplified_inner == False:\n            return True\n\n        return Not(simplified_inner)\n\n    def __eq__(self, other: \"Not\") -> bool:\n        if isinstance(other, Not):\n            return self.expr == other.expr\n        return False\n    \n    def match(self, other: \"Not\") -> Dict[Any, Any]:\n        if isinstance(other, Not):\n            print(f\"Matching Not: self: {self}, other: {other}\")\n            result = self.expr.match(other.expr)\n            print(f\"Match result: {result}\")\n            return result\n        else:\n            print(f\"Matching without Not: self: {self}, other: {other}\")\n            result = self.expr.match(other)\n            print(f\"Match result: {result}\")\n            return result\n\n    def to_nnf(self) -> \"Not\":\n        inner = self.expr\n        if inner.is_atomic():\n            return self\n        if isinstance(inner, And):\n            return Or(*(Not(expr).to_nnf() for expr in inner.expr))\n        if isinstance(inner, Or):\n            return And(*(Not(expr).to_nnf() for expr in inner.expr))\n        if isinstance(inner, Not):\n            return inner.expr.to_nnf()"]}
{"filename": "symlogos/first_order_rules.py", "chunked_list": ["from symlogos.connectives import And, Implication, Or\nfrom symlogos.expressions_and_terms import Term\nfrom symlogos.quantifiers import Exists, Forall\nfrom symlogos.rules import TableauRule\nfrom symlogos.signed_formula import SignedFormula\nfrom typing import List\n\nfrom symlogos.tableau_node import TableauNode\n\n\nclass AlphaRule(TableauRule):\n    def __init__(self, signed_formula: SignedFormula) -> None:\n        super().__init__(signed_formula)\n\n    def __hash__(self):\n        return hash((type(self), self.signed_formula))\n\n    def is_applicable(self) -> bool:\n        formula = self.signed_formula.formula\n        return isinstance(formula, And) or isinstance(formula, Or)\n\n    def apply(self) -> List[SignedFormula]:\n        print(f\"AlphaRule: Applying rule to {self.signed_formula}\")\n        if not self.is_applicable():\n            raise ValueError(\"Alpha rule is not applicable to the given formula\")\n\n        formula = self.signed_formula.formula\n        left = formula.left\n        right = formula.right\n\n        if isinstance(formula, And):\n            if self.signed_formula.is_positive():\n                result = [SignedFormula('T', left), SignedFormula('T', right)]\n            else:\n                result = [SignedFormula('F', left), SignedFormula('F', right)]\n        elif isinstance(formula, Or):\n            if self.signed_formula.is_positive():\n                result = [SignedFormula('T', left), SignedFormula('T', right)]\n            else:\n                result = [SignedFormula('F', left), SignedFormula('F', right)]\n        print(f\"AlphaRule: Result: {result}\")\n        return result", "\n\nclass AlphaRule(TableauRule):\n    def __init__(self, signed_formula: SignedFormula) -> None:\n        super().__init__(signed_formula)\n\n    def __hash__(self):\n        return hash((type(self), self.signed_formula))\n\n    def is_applicable(self) -> bool:\n        formula = self.signed_formula.formula\n        return isinstance(formula, And) or isinstance(formula, Or)\n\n    def apply(self) -> List[SignedFormula]:\n        print(f\"AlphaRule: Applying rule to {self.signed_formula}\")\n        if not self.is_applicable():\n            raise ValueError(\"Alpha rule is not applicable to the given formula\")\n\n        formula = self.signed_formula.formula\n        left = formula.left\n        right = formula.right\n\n        if isinstance(formula, And):\n            if self.signed_formula.is_positive():\n                result = [SignedFormula('T', left), SignedFormula('T', right)]\n            else:\n                result = [SignedFormula('F', left), SignedFormula('F', right)]\n        elif isinstance(formula, Or):\n            if self.signed_formula.is_positive():\n                result = [SignedFormula('T', left), SignedFormula('T', right)]\n            else:\n                result = [SignedFormula('F', left), SignedFormula('F', right)]\n        print(f\"AlphaRule: Result: {result}\")\n        return result", "\nclass BetaRule(TableauRule):\n    def __init__(self, signed_formula: SignedFormula) -> None:\n        super().__init__(signed_formula)\n\n    def __hash__(self):\n        return hash((type(self), self.signed_formula))\n\n    def is_applicable(self) -> bool:\n        formula = self.signed_formula.formula\n        return isinstance(formula, Implication)\n\n    def apply(self) -> List[SignedFormula]:\n        if not self.is_applicable():\n            raise ValueError(\"Beta rule is not applicable to the given formula\")\n\n        formula = self.signed_formula.formula\n\n        if isinstance(formula, Implication):\n            antecedent = formula.antecedent\n            consequent = formula.consequent\n\n            if self.signed_formula.is_positive():\n                return [SignedFormula('F', antecedent), SignedFormula('T', consequent)]\n            else:\n                return [SignedFormula('T', antecedent), SignedFormula('F', consequent)]", "\nclass GammaRule(TableauRule):\n    def __init__(self, signed_formula: SignedFormula) -> None:\n        super().__init__(signed_formula)\n\n    def __hash__(self):\n        return hash((type(self), self.signed_formula))\n\n    def is_applicable(self) -> bool:\n        return isinstance(self.signed_formula.formula, Exists) and self.signed_formula.sign == \"F\"\n\n    def apply(self, node: TableauNode) -> List[TableauNode]:\n        print(f\"{self.__class__.__name__}: Applying rule to {self.signed_formula}\")\n        quantifier_formula = self.signed_formula.formula\n        if not self.is_applicable():\n            raise ValueError(\"GammaRule can only be applied to negated Exists quantifiers\")\n\n        fresh_variable = Term(\"v_\" + str(node.get_next_fresh_variable_index()))\n        instantiated_formula = quantifier_formula.predicate.substitute({quantifier_formula.variable: fresh_variable})\n        new_node = TableauNode(SignedFormula(\"T\", instantiated_formula), node)\n        node.children.append(new_node)\n        result = [new_node]\n        print(f\"{self.__class__.__name__}: Result: {result}\")\n        return result", "\n\nclass DeltaRule(TableauRule):\n    def __init__(self, signed_formula: SignedFormula) -> None:\n        super().__init__(signed_formula)\n\n    def __hash__(self):\n        return hash((type(self), self.signed_formula))\n\n    def is_applicable(self):\n        return isinstance(self.signed_formula.formula, Forall)\n\n    def apply(self, node: TableauNode) -> List[TableauNode]:\n        quantifier_formula = self.signed_formula.formula\n        if not (isinstance(quantifier_formula, Forall) and self.signed_formula.sign == \"F\"):\n            raise ValueError(\"DeltaRule can only be applied to negated Forall quantifiers\")\n\n        fresh_variable = Term(\"v_\" + str(node.get_next_fresh_variable_index()))\n        instantiated_formula = quantifier_formula.predicate.substitute({quantifier_formula.variable: fresh_variable})\n        new_node = TableauNode(SignedFormula(\"T\", instantiated_formula), node)\n        node.children.append(new_node)\n        result = [new_node]\n        print(f\"{self.__class__.__name__}: Result: {result}\")\n        return result"]}
{"filename": "symlogos/axiom_set.py", "chunked_list": ["from symlogos.proposition import Proposition\n\nclass AxiomSet:\n    def __init__(self) -> None:\n        self.axioms = set()\n\n    def add_axiom(self, axiom: Proposition) -> None:\n        self.axioms.add(axiom)\n\n    def remove_axiom(self, axiom: Proposition) -> None:\n        if axiom in self.axioms:\n            self.axioms.remove(axiom)\n\n    def __iter__(self):\n        return iter(self.axioms)\n\n    def __len__(self) -> int:\n        return len(self.axioms)\n\n    def __contains__(self, axiom: Proposition) -> bool:\n        return axiom in self.axioms\n\n    def __repr__(self) -> str:\n        return f\"AxiomSet({', '.join(map(str, self.axioms))})\""]}
{"filename": "symlogos/expressions_and_terms.py", "chunked_list": ["from __future__ import annotations\nimport abc\nimport sympy\nfrom typing import Any, Dict, Type, Union, TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from symlogos.connectives import Implication, Not\n    from symlogos.modal_operators import Possibility\n    from symlogos.proposition import Proposition\n\nclass CombinedMeta(sympy.Basic.__class__, abc.ABCMeta):\n    pass", "\nclass CombinedMeta(sympy.Basic.__class__, abc.ABCMeta):\n    pass\n\nclass LogicalExpression(sympy.Basic, metaclass=CombinedMeta):\n    @abc.abstractmethod\n    def __eq__(self, other):\n        pass\n\n    @abc.abstractmethod\n    def __hash__(self):\n        pass\n\n    @abc.abstractmethod\n    def match(self, other):\n        pass\n\n    def substitute(self, mapping):\n        raise NotImplementedError(\"Substitution not implemented for this class\")\n\n    def substitute_all(self, substitutions):\n        return self.subs(substitutions)\n\n    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> Union['Possibility', 'Implication']:\n        return self.subs(term_replacement_dict)\n\n    def evaluate(self, assignment):\n        return self.subs(assignment).evalf()\n\n    def is_atomic(self):\n        return False\n\n    def to_nnf(self) -> 'Proposition':\n        if self.is_atomic():\n            return self\n        else:\n            raise NotImplementedError(f\"to_nnf is not implemented for the class {type(self)}\")", "\n\nclass Term(sympy.Basic):\n    def __new__(cls: Type[Term], name: str) -> \"Term\":\n        obj = super().__new__(cls)\n        obj.symbol = sympy.Symbol(name)\n        return obj\n\n    def __eq__(self, other: \"Term\") -> bool:\n        if isinstance(other, Term):\n            return self.symbol == other.symbol\n        return False\n\n    def __hash__(self) -> int:\n        return hash((type(self), self.symbol))\n\n    def __str__(self) -> str:\n        return str(self.symbol)\n\n    def __repr__(self) -> str:\n        return f\"Term('{self.symbol}')\"\n\n    def substitute(self, mapping):\n        if self in mapping:\n            return mapping[self]\n        return self\n\n    def evaluate(self, assignment):\n        if self.symbol in assignment:\n            return assignment[self.symbol]\n        else:\n            raise ValueError(f\"Assignment for term '{self.symbol}' not found.\")\n\n    def match(self, other: \"Term\") -> Dict[Term, Term]:\n        if isinstance(other, Term):\n            if self.symbol == other.symbol:\n                print(f\"Match successful: self: {self}, other: {other}\")\n                return {}\n            elif self.is_variable() or other.is_variable():\n                print(f\"Match successful: self: {self}, other: {other}\")\n                return {self: other}\n            else:\n                print(f\"Matching failed for terms: self: {self}, other: {other}\")\n                return None\n        else:\n            print(f\"Matching failed for different types: self: {self}, other: {other}\")\n            return None\n\n    def is_variable(self) -> bool:\n        return self.symbol.name.islower()", "    \ndef simplify_expression(expr: Union['Not', bool, 'Proposition']) -> Union['Not', bool, 'Proposition']:\n    if isinstance(expr, LogicalExpression):\n        return expr.simplify()\n    return expr\n"]}
{"filename": "symlogos/proposition.py", "chunked_list": ["from __future__ import annotations\nimport sympy\nfrom .expressions_and_terms import LogicalExpression\nfrom typing import Any, Dict, Type, Union, TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from symlogos.connectives import Not\n\nclass Proposition(LogicalExpression):\n    def __new__(cls: Type[Proposition], name: str) -> \"Proposition\":\n        obj = super().__new__(cls)\n        obj.name = sympy.Symbol(name)\n        return obj\n\n    def __eq__(self, other: Union[bool, Proposition, Not]) -> bool:\n        if isinstance(other, Proposition):\n            return self.name == other.name\n        return False\n\n    def __hash__(self) -> int:\n        return hash((type(self), self.name))\n\n    def __str__(self) -> str:\n        return str(self.name)\n\n    def __repr__(self):\n        return f\"Proposition('{self.name}')\"\n\n    def match(self, other: \"Proposition\", bindings: None=None) -> Dict[Any, Any]:\n        if bindings is None:\n            bindings = {}\n\n        if isinstance(other, Proposition):\n            if self.name == other.name:\n                return bindings\n            elif self.is_variable() or other.is_variable():\n                if self not in bindings:\n                    bindings[self] = other\n                    return bindings\n                elif bindings[self] == other:\n                    return bindings\n            return None\n        return None\n\n    def evaluate(self, assignment: Dict[Proposition, bool]) -> bool:\n        return assignment.get(self, self)\n\n    def simplify(self) -> \"Proposition\":\n        return self\n\n    def substitute(self, variable: \"Proposition\", replacement: \"Proposition\") -> \"Proposition\":\n        if self == variable:\n            return replacement\n        else:\n            return self\n\n    def substitute_all(self, substitutions):\n        new_attributes = {}\n        for attr, value in self.__dict__.items():\n            if isinstance(value, sympy.Basic):\n                new_attributes[attr] = value.subs(substitutions)\n            else:\n                new_attributes[attr] = value\n        result = self.__class__(*new_attributes.values())\n        return result\n\n    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> \"Proposition\":\n        return self.subs(term_replacement_dict)\n\n    def is_atomic(self) -> bool:\n        return True", "class Proposition(LogicalExpression):\n    def __new__(cls: Type[Proposition], name: str) -> \"Proposition\":\n        obj = super().__new__(cls)\n        obj.name = sympy.Symbol(name)\n        return obj\n\n    def __eq__(self, other: Union[bool, Proposition, Not]) -> bool:\n        if isinstance(other, Proposition):\n            return self.name == other.name\n        return False\n\n    def __hash__(self) -> int:\n        return hash((type(self), self.name))\n\n    def __str__(self) -> str:\n        return str(self.name)\n\n    def __repr__(self):\n        return f\"Proposition('{self.name}')\"\n\n    def match(self, other: \"Proposition\", bindings: None=None) -> Dict[Any, Any]:\n        if bindings is None:\n            bindings = {}\n\n        if isinstance(other, Proposition):\n            if self.name == other.name:\n                return bindings\n            elif self.is_variable() or other.is_variable():\n                if self not in bindings:\n                    bindings[self] = other\n                    return bindings\n                elif bindings[self] == other:\n                    return bindings\n            return None\n        return None\n\n    def evaluate(self, assignment: Dict[Proposition, bool]) -> bool:\n        return assignment.get(self, self)\n\n    def simplify(self) -> \"Proposition\":\n        return self\n\n    def substitute(self, variable: \"Proposition\", replacement: \"Proposition\") -> \"Proposition\":\n        if self == variable:\n            return replacement\n        else:\n            return self\n\n    def substitute_all(self, substitutions):\n        new_attributes = {}\n        for attr, value in self.__dict__.items():\n            if isinstance(value, sympy.Basic):\n                new_attributes[attr] = value.subs(substitutions)\n            else:\n                new_attributes[attr] = value\n        result = self.__class__(*new_attributes.values())\n        return result\n\n    def substitute_all_terms(self, term_replacement_dict: Dict[Any, Any]) -> \"Proposition\":\n        return self.subs(term_replacement_dict)\n\n    def is_atomic(self) -> bool:\n        return True", ""]}
{"filename": "symlogos/signed_formula.py", "chunked_list": ["from sympy.core.basic import Basic\n\nclass SignedFormula:\n    def __init__(self, sign: str, formula: Basic) -> None:\n        if sign not in ('T', 'F'):\n            raise ValueError(\"Sign must be either 'T' or 'F'\")\n        self.sign = sign\n        self.formula = formula\n\n    def __str__(self):\n        return f\"{self.sign} {self.formula}\"\n\n    def __eq__(self, other: \"SignedFormula\") -> bool:\n        if not isinstance(other, SignedFormula):\n            return False\n        return self.sign == other.sign and self.formula == other.formula\n\n    def __hash__(self):\n        return hash((type(self), self.sign, self.formula))\n\n    def is_positive(self) -> bool:\n        return self.sign == 'T'\n\n    def is_negative(self):\n        return self.sign == 'F'", ""]}
{"filename": "utils/project_analyzer.py", "chunked_list": ["import os\nimport sys\nimport ast\n\ndef analyze_module(file_path):\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\") as file:\n            content = file.read()\n        tree = ast.parse(content)\n        classes = [node for node in tree.body if isinstance(node, ast.ClassDef)]\n        functions = [node for node in tree.body if isinstance(node, ast.FunctionDef)]\n\n        def get_function_summary(func):\n            arg_info = []\n            for arg in func.args.args:\n                arg_type = ast.unparse(arg.annotation) if arg.annotation is not None else \"unknown\"\n                arg_info.append((arg.arg, arg_type))\n            return_type = ast.unparse(func.returns) if func.returns else \"unknown\"\n\n            return (func.name, arg_info, return_type)\n\n        function_summary = [get_function_summary(func) for func in functions]\n        \n        class_summary = []\n        for cls in classes:\n            methods = [node for node in cls.body if isinstance(node, ast.FunctionDef)]\n            method_summary = [get_function_summary(method) for method in methods]\n            class_summary.append((cls.name, method_summary))\n\n        return {\n            \"classes\": class_summary,\n            \"functions\": function_summary,\n        }\n    except SyntaxError as e:\n        print(f\"Error: Unable to parse '{file_path}' due to a syntax error: {e}\")\n        return {\n            \"classes\": [],\n            \"functions\": [],\n        }", "\n\ndef analyze_project(project_root):\n    project_summary = {}\n\n    for root, dirs, files in os.walk(project_root):\n        # Ignore directories starting with \".\" and named \"test\"\n        dirs[:] = [d for d in dirs if not d.startswith(\".\") and d.lower() != \"test\"]\n\n        for file in files:\n            if file.endswith(\".py\") and not file.startswith(\"test_\"):\n                file_path = os.path.join(root, file)\n                module_name = os.path.relpath(file_path, project_root).replace(\"\\\\\", \".\").replace(\"/\", \".\")[:-3]\n\n                module_summary = analyze_module(file_path)\n\n                if module_summary[\"classes\"] or module_summary[\"functions\"]:\n                    project_summary[module_name] = module_summary\n\n    return project_summary", "\ndef print_summary(summary):\n    for module, items in summary.items():\n        print(f\"# Module: {module}\\n\")\n\n        if items[\"classes\"]:\n            print(\"## Classes:\\n\")\n            for cls, methods in items[\"classes\"]:\n                print(f\"### {cls}\\n\")\n                if methods:\n                    print(\"#### Methods:\\n\")\n                    for func, args, return_type in methods:\n                        args_str = ', '.join(f\"{name}: {arg_type}\" for name, arg_type in args)\n                        print(f\"- `{func}({args_str}) -> {return_type}`\\n\")\n\n        if items[\"functions\"]:\n            print(\"## Functions:\\n\")\n            for func, args, return_type in items[\"functions\"]:\n                args_str = ', '.join(f\"{name}: {arg_type}\" for name, arg_type in args)\n                print(f\"- `{func}({args_str}) -> {return_type}`\\n\")\n\n        print(\"---\\n\")", "\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Usage: python project_analyzer.py <project_root>\")\n        sys.exit(1)\n\n    project_root = sys.argv[1]\n    summary = analyze_project(project_root)\n    print_summary(summary)", "\n"]}
{"filename": "utils/automate_monkeytype.py", "chunked_list": ["import os\nimport argparse\nimport subprocess\n\ndef discover_modules(project_root):\n    modules = []\n    for root, dirs, files in os.walk(project_root):\n        dirs[:] = [d for d in dirs if not d.startswith('test')]  # Ignore test directories\n        for file in files:\n            if file.endswith('.py') and not file.startswith('test_'):  # Ignore test files\n                file_path = os.path.join(root, file)\n                module_name = \"symlogos.\" + os.path.splitext(file_path[len(project_root) + 1:].replace(os.sep, '.'))[0]\n                modules.append(module_name)\n    return modules", "\ndef main(project_root):\n    os.chdir(project_root)  # Change the current working directory to the project root\n\n    # Run MonkeyType to collect runtime types\n    subprocess.run(['monkeytype', 'run', '-m', 'pytest'])\n\n    # Generate and apply type annotations for each module\n    modules = discover_modules(project_root)\n    for module in modules:\n        subprocess.run(['monkeytype', 'stub', module])\n        subprocess.run(['monkeytype', 'apply', module])", "\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Automate MonkeyType for a Python project')\n    parser.add_argument('project_root', help='Path to the project root directory')\n    args = parser.parse_args()\n\n    main(args.project_root)\n\n", ""]}
{"filename": "tests/test_symlogos.py", "chunked_list": ["from sympy import symbols, Symbol\nfrom symlogos.axiom_set import AxiomSet\nfrom symlogos.connectives import Implication, And, Not\nfrom symlogos.expressions_and_terms import LogicalExpression, Term\nfrom symlogos.functions_and_predicates import Predicate, HigherOrderFunction, FunctionApplication\nfrom symlogos.modal_operators import Possibility, Necessity\nfrom symlogos.proposition import Proposition\nfrom symlogos.quantifiers import Forall, Exists\nfrom symlogos.rules import Rule\n\ndef test_negation():\n    p = Proposition('p')\n    not_p = Not(p)\n    assert str(not_p) == '\u00acp'", "from symlogos.rules import Rule\n\ndef test_negation():\n    p = Proposition('p')\n    not_p = Not(p)\n    assert str(not_p) == '\u00acp'\n\ndef test_box_operator():\n    p = Proposition('p')\n    box_p = Necessity(p)\n    assert str(box_p) == '\u25a1p'", "\ndef test_diamond_operator():\n    p = Proposition('p')\n    diamond_p = Possibility(p)\n    assert str(diamond_p) == '\u25c7p'\n\ndef test_expression_string_representation():\n    p = Proposition('p')\n    not_p = Not(p)\n    assert str(not_p) == '\u00acp'", "\ndef test_expression_complex_operations():\n    p, q = Proposition(\"p\"), Proposition(\"q\")\n    expr = Not(And(p, q))\n    assert str(expr) == \"\u00ac(p \u2227 q)\"\n\ndef test_expression_complex_operations_2():\n    p, q = Proposition(\"p\"), Proposition(\"q\")\n    expr = Necessity(And(p, q))\n    assert str(expr) == \"\u25a1(p \u2227 q)\"", "\ndef test_expression_complex_operations_3():\n    p, q = Proposition(\"p\"), Proposition(\"q\")\n    expr = Possibility(And(p, q))\n    assert str(expr) == \"\u25c7(p \u2227 q)\"\n\ndef test_predicate():\n    x, y = symbols(\"x y\")\n    Px = Predicate(\"P\", x)\n    assert str(Px) == \"P(x)\"\n    Py = Predicate(\"P\", y)\n    assert str(Py) == \"P(y)\"", "\ndef test_forall():\n    x = symbols(\"x\")\n    Px = Predicate(\"P\", x)\n    forall_px = Forall(x, Px)\n    assert str(forall_px) == \"\u2200x: P(x)\"\n\ndef test_forall_substitution():\n    x = Term(\"x\")\n    c = Term(\"c\")\n    P = Predicate(\"P\", x)\n    forall_px = Forall(x, P)\n    result = forall_px.substitute({x: c})\n    assert result == Forall(c, Predicate(\"P\", c))", "\ndef test_exists():\n    y = symbols(\"y\")\n    Py = Predicate(\"P\", y)\n    exists_py = Exists(y, Py)\n    assert str(exists_py) == \"\u2203y: P(y)\"\n\ndef test_higher_order_function():\n    f = HigherOrderFunction(\"f\")\n    assert str(f) == \"f\"\n    assert repr(f) == \"HigherOrderFunction('f', None, None)\"", "\ndef test_higher_order_function_with_arg_function():\n    g = HigherOrderFunction(\"g\")\n    f_of_g = HigherOrderFunction(\"f\", arg_function=g)\n    assert str(f_of_g) == \"f(g)\"\n    assert repr(f_of_g) == \"HigherOrderFunction('f', HigherOrderFunction('g', None, None), None)\"\n\ndef test_higher_order_function_with_return_function():\n    g = HigherOrderFunction(\"g\")\n    f_to_g = HigherOrderFunction(\"f\", return_function=g)\n    assert str(f_to_g) == \"f -> g\"\n    assert repr(f_to_g) == \"HigherOrderFunction('f', None, HigherOrderFunction('g', None, None))\"", "\ndef test_higher_order_function_with_arg_and_return_function():\n    h = HigherOrderFunction(\"h\")\n    g = HigherOrderFunction(\"g\")\n    f_of_h_to_g = HigherOrderFunction(\"f\", arg_function=h, return_function=g)\n    assert str(f_of_h_to_g) == \"f(h) -> g\"\n    assert repr(f_of_h_to_g) == \"HigherOrderFunction('f', HigherOrderFunction('h', None, None), HigherOrderFunction('g', None, None))\"\n\ndef test_substitute():\n    p, q = Proposition(\"p\"), Proposition(\"q\")\n    not_p = Not(p)\n    not_q = Not(q)\n    assert not_p.substitute(p, q) == not_q\n\n    and_pq = And(p, q)\n    and_pr = And(p, p)\n    assert and_pq.substitute(q, p) == and_pr", "def test_substitute():\n    p, q = Proposition(\"p\"), Proposition(\"q\")\n    not_p = Not(p)\n    not_q = Not(q)\n    assert not_p.substitute(p, q) == not_q\n\n    and_pq = And(p, q)\n    and_pr = And(p, p)\n    assert and_pq.substitute(q, p) == and_pr\n\ndef test_evaluate():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    assignment = {p: True, q: False}\n    assert p.evaluate(assignment) == True\n    assert q.evaluate(assignment) == False", "\ndef test_evaluate():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    assignment = {p: True, q: False}\n    assert p.evaluate(assignment) == True\n    assert q.evaluate(assignment) == False\n\n\ndef test_simplify():\n    p, q = Proposition(\"p\"), Proposition(\"q\")\n    and_true_p = And(True, p)\n    assert and_true_p.simplify() == p\n\n    and_false_p = And(False, p)\n    assert and_false_p.simplify() == False\n\n    not_true = Not(True)\n    assert not_true.simplify() == False\n\n    not_false = Not(False)\n    assert not_false.simplify() == True\n\n    not_not_p = Not(Not(p))\n    assert not_not_p.simplify() == p\n\n    necessity_true = Necessity(True)\n    assert necessity_true.simplify() == True\n\n    possibility_true = Possibility(True)\n    assert possibility_true.simplify() == True", "\ndef test_simplify():\n    p, q = Proposition(\"p\"), Proposition(\"q\")\n    and_true_p = And(True, p)\n    assert and_true_p.simplify() == p\n\n    and_false_p = And(False, p)\n    assert and_false_p.simplify() == False\n\n    not_true = Not(True)\n    assert not_true.simplify() == False\n\n    not_false = Not(False)\n    assert not_false.simplify() == True\n\n    not_not_p = Not(Not(p))\n    assert not_not_p.simplify() == p\n\n    necessity_true = Necessity(True)\n    assert necessity_true.simplify() == True\n\n    possibility_true = Possibility(True)\n    assert possibility_true.simplify() == True", "\n\ndef test_complex_simplify():\n    p, q = Proposition(\"p\"), Proposition(\"q\")\n    complex_expr = And(p, Not(Not(q)))\n    simplified_expr = And(p, q)\n    assert complex_expr.simplify() == simplified_expr\n\ndef test_add_remove_axiom():\n    axiom_set = AxiomSet()\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n\n    assert len(axiom_set) == 0\n    assert p not in axiom_set\n\n    axiom_set.add_axiom(p)\n    assert len(axiom_set) == 1\n    assert p in axiom_set\n\n    axiom_set.add_axiom(q)\n    assert len(axiom_set) == 2\n    assert q in axiom_set\n\n    axiom_set.remove_axiom(p)\n    assert len(axiom_set) == 1\n    assert p not in axiom_set\n    assert q in axiom_set", "def test_add_remove_axiom():\n    axiom_set = AxiomSet()\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n\n    assert len(axiom_set) == 0\n    assert p not in axiom_set\n\n    axiom_set.add_axiom(p)\n    assert len(axiom_set) == 1\n    assert p in axiom_set\n\n    axiom_set.add_axiom(q)\n    assert len(axiom_set) == 2\n    assert q in axiom_set\n\n    axiom_set.remove_axiom(p)\n    assert len(axiom_set) == 1\n    assert p not in axiom_set\n    assert q in axiom_set", "\ndef test_iterate_axioms():\n    axiom_set = AxiomSet()\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n\n    axiom_set.add_axiom(p)\n    axiom_set.add_axiom(q)\n\n    axiom_list = [axiom for axiom in axiom_set]\n\n    assert p in axiom_list\n    assert q in axiom_list", "\ndef test_repr():\n    axiom_set = AxiomSet()\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n\n    axiom_set.add_axiom(p)\n    axiom_set.add_axiom(q)\n\n    assert \"p\" in repr(axiom_set)\n    assert \"q\" in repr(axiom_set)", "\ndef test_term_creation():\n    t = Term('x')\n    assert isinstance(t, Term)\n    assert t.symbol == Symbol('x')\n\ndef test_term_str():\n    t = Term('x')\n    assert str(t) == 'x'\n\ndef test_term_repr():\n    t = Term('x')\n    assert repr(t) == \"Term('x')\"", "\ndef test_term_repr():\n    t = Term('x')\n    assert repr(t) == \"Term('x')\"\n\ndef test_rule_creation():\n    A = Term('A')\n    B = Term('B')\n    f = FunctionApplication('f', A)\n    g = FunctionApplication('g', B)\n    \n    rule = Rule('example_rule', [f], g)\n    \n    assert isinstance(rule, Rule)\n    assert rule.name == 'example_rule'\n    assert rule.premises == [f]\n    assert rule.conclusion == g\n    assert str(rule) == \"example_rule: f(A) \u22a2 g(B)\"", "\ndef test_rule_str():\n    premise1 = Term('x')\n    premise2 = Term('y')\n    conclusion = Term('z')\n    rule = Rule('R1', [premise1, premise2], conclusion)\n\n    assert str(rule) == \"R1: x, y \u22a2 z\"\n\ndef test_rule_repr():\n    premise1 = Term('x')\n    premise2 = Term('y')\n    conclusion = Term('z')\n    rule = Rule('R1', [premise1, premise2], conclusion)\n\n    assert repr(rule) == \"Rule('R1', [Term('x'), Term('y')], Term('z'))\"", "\ndef test_rule_repr():\n    premise1 = Term('x')\n    premise2 = Term('y')\n    conclusion = Term('z')\n    rule = Rule('R1', [premise1, premise2], conclusion)\n\n    assert repr(rule) == \"Rule('R1', [Term('x'), Term('y')], Term('z'))\"\n\ndef test_rule_apply():\n    x = Term(\"x\")\n    y = Term(\"y\")\n    P = Predicate(\"P\", x)\n    Q = Predicate(\"Q\", y)\n    R = Predicate(\"R\", x, y)\n    premise1 = P\n    premise2 = Q\n    conclusion = R\n    rule = Rule(\"TestRule\", [premise1, premise2], conclusion)\n\n    a = Term(\"a\")\n    b = Term(\"b\")\n    result = rule.apply(Predicate(\"P\", a), Predicate(\"Q\", b))\n    assert result == Predicate(\"R\", a, b)", "\ndef test_rule_apply():\n    x = Term(\"x\")\n    y = Term(\"y\")\n    P = Predicate(\"P\", x)\n    Q = Predicate(\"Q\", y)\n    R = Predicate(\"R\", x, y)\n    premise1 = P\n    premise2 = Q\n    conclusion = R\n    rule = Rule(\"TestRule\", [premise1, premise2], conclusion)\n\n    a = Term(\"a\")\n    b = Term(\"b\")\n    result = rule.apply(Predicate(\"P\", a), Predicate(\"Q\", b))\n    assert result == Predicate(\"R\", a, b)", "\ndef test_modus_ponens():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    modus_ponens = Rule(\"Modus Ponens\", [Implication(p, q), p], q)\n\n    premise1 = Implication(p, q)\n    premise2 = p\n\n    result = modus_ponens.apply(premise1, premise2)\n    assert result == q", "\n\ndef test_modus_tollens():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    modus_tollens = Rule(\"Modus Tollens\", [Implication(p, q), Not(q)], Not(p))\n\n    premise1 = Implication(p, q)\n    premise2 = Not(q)\n\n    result = modus_tollens.apply(premise1, premise2)\n    assert result == Not(p)", "\ndef test_universal_instantiation():\n    x = Term(\"x\")\n    c = Term(\"c\")\n    P = Predicate(\"P\", x)\n    forall_px = Forall(x, P)\n    universal_instantiation = Rule(\"Universal Instantiation\", [forall_px], Predicate(\"P\", c))\n\n    premise = forall_px\n    result = universal_instantiation.apply(premise)\n    assert result == Predicate(\"P\", c)", "\ndef test_existential_instantiation():\n    x = Term(\"x\")\n    P = Predicate(\"P\", x)\n    premise = Exists(x, P)\n    rule = Rule(\"Existential Instantiation\", [premise], P)\n\n    a = Term(\"a\")\n    result = rule.apply(Exists(x, Predicate(\"P\", a)))\n\n    assert result == Predicate(\"P\", a)", "\ndef test_modal_modus_ponens():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    box_p_implies_q = Necessity(Implication(p, q))\n    box_p = Necessity(p)\n\n    modal_modus_ponens = Rule(\"Modal Modus Ponens\", [box_p_implies_q, box_p], Necessity(q))\n    premise1 = box_p_implies_q\n    premise2 = box_p\n\n    result = modal_modus_ponens.apply(premise1, premise2)\n    assert result == Necessity(q)", "\ndef test_barcan_formula():\n    x = Term(\"x\")\n    P = Predicate(\"P\", x)\n    forall_P = Forall(x, P)\n    box_forall_P = Necessity(forall_P)\n    box_P = Necessity(P)\n    forall_box_P = Forall(x, box_P)\n    \n    barcan_formula = Rule(\"Barcan Formula\", [forall_box_P], box_forall_P)\n    premise = forall_box_P\n    \n    result = barcan_formula.apply(premise)\n    \n    assert result == box_forall_P"]}
{"filename": "tests/test_tableau_prover_extracted_methods.py", "chunked_list": ["import pytest\nfrom symlogos.expressions_and_terms import Term\nfrom symlogos.functions_and_predicates import Predicate\nfrom symlogos.tableau_node import TableauNode\nfrom symlogos.tableau_prover import TableauProver\nfrom symlogos.signed_formula import SignedFormula\nfrom symlogos.connectives import And, Or, Not\nfrom symlogos.quantifiers import Forall, Exists\nfrom symlogos.proposition import Proposition\nfrom symlogos.modal_operators import Necessity, Possibility", "from symlogos.proposition import Proposition\nfrom symlogos.modal_operators import Necessity, Possibility\n\n@pytest.fixture\ndef tableau_prover():\n    return TableauProver()\n\ndef test_handle_and_or(tableau_prover):\n    A = Proposition(\"A\")\n    B = Proposition(\"B\")\n\n    signed_formula_and = SignedFormula(\"T\", And(A, B))\n    signed_formula_or = SignedFormula(\"F\", Or(A, B))\n\n    new_signed_formulas_and = tableau_prover._handle_and_or(signed_formula_and)\n    new_signed_formulas_or = tableau_prover._handle_and_or(signed_formula_or)\n\n    # Assertions for And\n    assert len(new_signed_formulas_and) == 2\n    assert all(sf.sign == \"T\" for sf in new_signed_formulas_and)\n    assert {sf.formula for sf in new_signed_formulas_and} == {A, B}\n\n    # Assertions for Or\n    assert len(new_signed_formulas_or) == 2\n    assert all(sf.sign == \"F\" for sf in new_signed_formulas_or)\n    assert {sf.formula for sf in new_signed_formulas_or} == {A, B}", "\ndef test_handle_quantifiers(tableau_prover):\n    P = Predicate(\"P\")\n    x = Term(\"x\")\n    Px = Predicate(\"P\", x)\n    signed_formula_exists = SignedFormula(\"F\", Exists(x, Px))\n\n    signed_formula_example = SignedFormula(\"T\", Px)\n    node = TableauNode(signed_formula_example)\n\n    new_signed_formulas_exists = tableau_prover._handle_quantifiers(node, signed_formula_exists)\n\n    # Assertions for negated Exists quantifier\n    assert len(new_signed_formulas_exists) == 1\n    assert new_signed_formulas_exists[0].sign == \"T\"  \n    assert isinstance(new_signed_formulas_exists[0].formula, Predicate)\n    assert str(new_signed_formulas_exists[0].formula.symbol) == \"P\"  # This line is updated", "\n\ndef test_handle_modal_operators(tableau_prover):\n    A = Proposition(\"A\")\n\n    signed_formula_box_t = SignedFormula(\"T\", Necessity(A))\n    signed_formula_box_f = SignedFormula(\"F\", Necessity(A))\n    signed_formula_diamond_t = SignedFormula(\"T\", Possibility(A))\n    signed_formula_diamond_f = SignedFormula(\"F\", Possibility(A))\n\n    new_signed_formulas_box_t = tableau_prover._handle_modal_operators(signed_formula_box_t)\n    new_signed_formulas_box_f = tableau_prover._handle_modal_operators(signed_formula_box_f)\n    new_signed_formulas_diamond_t = tableau_prover._handle_modal_operators(signed_formula_diamond_t)\n    new_signed_formulas_diamond_f = tableau_prover._handle_modal_operators(signed_formula_diamond_f)\n\n    # Assertions for Necessity(T)\n    assert len(new_signed_formulas_box_t) == 1\n    assert new_signed_formulas_box_t[0].sign == \"T\"\n    assert new_signed_formulas_box_t[0].formula == A\n\n    # Assertions for Necessity(F)\n    assert len(new_signed_formulas_box_f) == 1\n    assert new_signed_formulas_box_f[0].sign == \"F\"\n    assert new_signed_formulas_box_f[0].formula == A\n\n    # Assertions for Possibility(T)\n    assert len(new_signed_formulas_diamond_t) == 1\n    assert new_signed_formulas_diamond_t[0].sign == \"T\"\n    assert new_signed_formulas_diamond_t[0].formula == A\n\n    # Assertions for Possibility(F)\n    assert len(new_signed_formulas_diamond_f) == 1\n    assert new_signed_formulas_diamond_f[0].sign == \"F\"\n    assert new_signed_formulas_diamond_f[0].formula == A", "\n\ndef test_handle_not(tableau_prover):\n    A = Proposition(\"A\")\n    signed_formula = SignedFormula(\"T\", Not(A))\n    new_signed_formulas = tableau_prover._handle_not(signed_formula)\n    # Add your assertions here, e.g.,\n    assert len(new_signed_formulas) == 1\n", ""]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/test_nnf.py", "chunked_list": ["import pytest\nfrom symlogos.expressions_and_terms import LogicalExpression\nfrom symlogos.proposition import Proposition\nfrom symlogos.quantifiers import Forall, Exists\nfrom symlogos.functions_and_predicates import Predicate\nfrom symlogos.connectives import Implication, Not, And, Or\nfrom symlogos.rules import Rule\n\ndef test_proposition_to_nnf():\n    p = Proposition(\"p\")\n    assert p.to_nnf() == p", "def test_proposition_to_nnf():\n    p = Proposition(\"p\")\n    assert p.to_nnf() == p\n\ndef test_not_to_nnf():\n    p = Proposition(\"p\")\n    not_p = Not(p)\n    assert not_p.to_nnf() == not_p\n\ndef test_and_to_nnf():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    and_expr = And(p, q)\n    assert and_expr.to_nnf() == and_expr", "\ndef test_and_to_nnf():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    and_expr = And(p, q)\n    assert and_expr.to_nnf() == and_expr\n\ndef test_or_to_nnf():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    or_expr = Or(p, q)\n    assert or_expr.to_nnf() == or_expr", "\ndef test_forall_to_nnf():\n    Px = Predicate(\"P\", \"x\")\n    forall_px = Forall(\"x\", Px)\n    assert forall_px.to_nnf() == forall_px\n\ndef test_exists_to_nnf():\n    Px = Predicate(\"P\", \"x\")\n    exists_px = Exists(\"x\", Px)\n    assert exists_px.to_nnf() == exists_px", "\ndef test_logical_expression_to_nnf_not_implemented():\n    class DummyExpression(LogicalExpression):\n        def __eq__(self, other):\n            return isinstance(other, DummyExpression)\n\n        def __hash__(self):\n            return hash(type(self))\n\n        def match(self, pattern):\n            return isinstance(pattern, DummyExpression)\n\n    dummy_expr = DummyExpression()\n    with pytest.raises(NotImplementedError):\n        dummy_expr.to_nnf()", "\ndef test_rule_to_nnf():\n    # Define propositions\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n\n    # Define logical expressions\n    not_p = Not(p)\n    not_q = Not(q)\n    p_implies_q = Implication(p, q)\n\n    # Create a rule with premises and a conclusion\n    rule = Rule(\"Implication elimination\", [p_implies_q, p], q)\n\n    # Call the to_nnf method on the rule object\n    nnf_rule = rule.to_nnf()\n\n    # Check if the premises and conclusion of the nnf_rule are in NNF\n    assert nnf_rule.premises[0] == p_implies_q.to_nnf()\n    assert nnf_rule.premises[1] == p.to_nnf()\n    assert nnf_rule.conclusion == q.to_nnf()", "\n"]}
{"filename": "tests/test_function_application.py", "chunked_list": ["from symlogos.expressions_and_terms import Term\nfrom symlogos.quantifiers import Forall\nfrom symlogos.functions_and_predicates import Predicate, HigherOrderFunction, FunctionApplication\n\n# def test_function_application_predicate():\n#     x = Term(\"x\")\n#     y = Term(\"y\")\n#     R = Predicate(\"R\", 2)\n#     relation_application = FunctionApplication(R, x, y)\n#     assert relation_application == FunctionApplication(Predicate(\"R\", 2), Term(\"x\"), Term(\"y\"))", "#     relation_application = FunctionApplication(R, x, y)\n#     assert relation_application == FunctionApplication(Predicate(\"R\", 2), Term(\"x\"), Term(\"y\"))\n\ndef test_function_application_higher_order():\n    x = Term(\"x\")\n    g = Predicate(\"g\", 1)\n    h = HigherOrderFunction(\"h\", return_function=g)\n    higher_order_application = FunctionApplication(h, x)\n    assert higher_order_application == FunctionApplication(HigherOrderFunction(\"h\", return_function=Predicate(\"g\", 1)), Term(\"x\"))\n\ndef test_forall_application():\n    x = Term(\"x\")\n    P = Predicate(\"P\", x)\n    forall_px = Forall(x, P)\n    assert forall_px == Forall(Term(\"x\"), Predicate(\"P\", Term(\"x\")))", "\ndef test_forall_application():\n    x = Term(\"x\")\n    P = Predicate(\"P\", x)\n    forall_px = Forall(x, P)\n    assert forall_px == Forall(Term(\"x\"), Predicate(\"P\", Term(\"x\")))\n"]}
{"filename": "tests/test_modal_logic.py", "chunked_list": ["from symlogos.modal_logic import ModalLogic\nfrom symlogos.proposition import Proposition\nfrom symlogos.modal_operators import Necessity, Possibility\nfrom symlogos.connectives import Implication\n\ndef test_necessitation():\n    p = Proposition(\"p\")\n    rule = ModalLogic.necessitation()\n    premises = [p]\n    expected_result = Necessity(p)\n    result = rule.apply(*premises)\n    assert result == expected_result", "\n\ndef test_distribution_axiom():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    rule = ModalLogic.distribution_axiom()\n    premises = [Necessity(Implication(p, q))]\n    expected_result = Implication(Necessity(p), Necessity(q))\n    result = rule.apply(*premises)\n    assert result == expected_result", "\n\ndef test_possibility_axiom():\n    p = Proposition(\"p\")\n    rule = ModalLogic.possibility_axiom()\n    premises = [Possibility(p)]\n    expected_result = Necessity(Possibility(p))\n    result = rule.apply(*premises)\n    assert result == expected_result\n", "\n\ndef test_modal_modus_ponens():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    rule = ModalLogic.modal_modus_ponens()\n    premises = [Necessity(Implication(p, q)), Necessity(p)]\n    expected_result = Necessity(q)\n    result = rule.apply(*premises)\n    assert result == expected_result", "\n\ndef test_t_schema():\n    p = Proposition(\"p\")\n    rule = ModalLogic.t_schema()\n    premises = [Necessity(p)]\n    expected_result = p\n    result = rule.apply(*premises)\n    assert result == expected_result\n", ""]}
{"filename": "tests/test_classical_propositional_logic.py", "chunked_list": ["from symlogos.classical_propositional_logic import *\nfrom symlogos.connectives import Implication, And, Or, Not\nfrom symlogos.proposition import Proposition\n\n\ndef test_modus_ponens():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    rule = ClassicalPropositionalLogic.modus_ponens()\n    premises = [p, Implication(p, q)]\n    expected_result = q\n\n    result = rule.apply(*premises)\n    assert result == expected_result", "\ndef test_modus_tollens():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    rule = ClassicalPropositionalLogic.modus_tollens()\n    premises = [Implication(p, q), Not(q)]\n    expected_result = Not(p)\n\n    result = rule.apply(*premises)\n    assert result == expected_result", "\ndef test_disjunction_introduction():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    rule = ClassicalPropositionalLogic.disjunction_introduction()\n    premises = [p]\n    expected_result = Or(p, q)\n\n    result = rule.apply(*premises)\n    assert result == expected_result", "\ndef test_disjunction_elimination():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    r = Proposition(\"r\")\n    rule = ClassicalPropositionalLogic.disjunction_elimination()\n    premises = [Or(p, q), Implication(p, r), Implication(q, r)]\n    expected_result = r\n\n    result = rule.apply(*premises)\n    assert result == expected_result", "\ndef test_conjunction_introduction():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    rule = ClassicalPropositionalLogic.conjunction_introduction()\n    premises = [p, q]\n    expected_result = And(p, q)\n\n    result = rule.apply(*premises)\n    assert result == expected_result", "\ndef test_conjunction_elimination1():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    rule = ClassicalPropositionalLogic.conjunction_elimination1()\n    premises = [And(p, q)]\n    expected_result = p\n\n    result = rule.apply(*premises)\n    assert result == expected_result", "\ndef test_conjunction_elimination2():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    rule = ClassicalPropositionalLogic.conjunction_elimination2()\n    premises = [And(p, q)]\n    expected_result = q\n\n    result = rule.apply(*premises)\n    assert result == expected_result", "\ndef test_distribution_and_over_or():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    r = Proposition(\"r\")\n    rule = ClassicalPropositionalLogic.distribution_and_over_or()\n    premise = And(p, Or(q, r))\n    expected_result = Or(And(p, q), And(p, r))\n\n    result = rule.apply(premise)\n    assert result == expected_result", "\ndef test_distribution_or_over_and():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    r = Proposition(\"r\")\n    rule = ClassicalPropositionalLogic.distribution_or_over_and()\n    premise = Or(p, And(q, r))\n    expected_result = And(Or(p, q), Or(p, r))\n\n    result = rule.apply(premise)\n    assert result == expected_result", "\ndef test_absorption_and():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    rule = ClassicalPropositionalLogic.absorption_and()\n    premise = And(p, Or(p, q))\n    expected_result = p\n\n    result = rule.apply(premise)\n    assert result == expected_result", "\ndef test_absorption_or():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    rule = ClassicalPropositionalLogic.absorption_or()\n    premise = Or(p, And(p, q))\n    expected_result = p\n\n    result = rule.apply(premise)\n    assert result == expected_result", "\ndef test_negation_and_to_or():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    rule = ClassicalPropositionalLogic.negation_and_to_or()\n    premise = Not(And(p, q))\n    expected_result = Or(Not(p), Not(q))\n\n    result = rule.apply(premise)\n    assert result == expected_result", "\ndef test_negation_or_to_and():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    rule = ClassicalPropositionalLogic.negation_or_to_and()\n    premise = Not(Or(p, q))\n    expected_result = And(Not(p), Not(q))\n\n    result = rule.apply(premise)\n    assert result == expected_result", "\ndef test_implication_to_or():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    rule = ClassicalPropositionalLogic.implication_to_or()\n    premise = Implication(p, q)\n    expected_result = Or(Not(p), q)\n\n    result = rule.apply(premise)\n    assert result == expected_result", "\ndef test_commutativity_and():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    rule = ClassicalPropositionalLogic.commutativity_and()\n    premises = [And(p, q)]\n    expected_result = And(q, p)\n\n    result = rule.apply(*premises)\n    assert result == expected_result", "\ndef test_commutativity_or():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    rule = ClassicalPropositionalLogic.commutativity_or()\n    premises = [Or(p, q)]\n    expected_result = Or(q, p)\n\n    result = rule.apply(*premises)\n    assert result == expected_result", "\ndef test_associativity_and():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    r = Proposition(\"r\")\n    rule = ClassicalPropositionalLogic.associativity_and()\n    premises = [And(p, And(q, r))]\n    expected_result = And(And(p, q), r)\n\n    result = rule.apply(*premises)\n    assert result == expected_result", "\ndef test_associativity_or():\n    p = Proposition(\"p\")\n    q = Proposition(\"q\")\n    r = Proposition(\"r\")\n    rule = ClassicalPropositionalLogic.associativity_or()\n    premises = [Or(p, Or(q, r))]\n    expected_result = Or(Or(p, q), r)\n\n    result = rule.apply(*premises)\n    assert result == expected_result", "\ndef test_idempotency_and():\n    p = Proposition(\"p\")\n    rule = ClassicalPropositionalLogic.idempotency_and()\n    premises = [And(p, p)]\n    expected_result = p\n\n    result = rule.apply(*premises)\n    assert result == expected_result\n\ndef test_idempotency_or():\n    p = Proposition(\"p\")\n    rule = ClassicalPropositionalLogic.idempotency_or()\n    premises = [Or(p, p)]\n    expected_result = p\n\n    result = rule.apply(*premises)\n    assert result == expected_result", "\ndef test_idempotency_or():\n    p = Proposition(\"p\")\n    rule = ClassicalPropositionalLogic.idempotency_or()\n    premises = [Or(p, p)]\n    expected_result = p\n\n    result = rule.apply(*premises)\n    assert result == expected_result\n\ndef test_double_negation_elimination():\n    p = Proposition(\"p\")\n    rule = ClassicalPropositionalLogic.double_negation_elimination()\n    premises = [Not(Not(p))]\n    expected_result = p\n\n    result = rule.apply(*premises)\n    assert result == expected_result", "\ndef test_double_negation_elimination():\n    p = Proposition(\"p\")\n    rule = ClassicalPropositionalLogic.double_negation_elimination()\n    premises = [Not(Not(p))]\n    expected_result = p\n\n    result = rule.apply(*premises)\n    assert result == expected_result\n", ""]}
{"filename": "tests/test_tableau_prover.py", "chunked_list": ["import pytest\nfrom symlogos.expressions_and_terms import Term\nfrom symlogos.connectives import And, Or, Implication\nfrom symlogos.functions_and_predicates import Predicate\nfrom symlogos.modal_operators import Necessity\nfrom symlogos.quantifiers import Forall, Exists\nfrom symlogos.signed_formula import SignedFormula\nfrom symlogos.tableau_prover import TableauProver, TableauNode\nfrom symlogos.first_order_rules import AlphaRule, BetaRule, GammaRule, DeltaRule\nfrom symlogos.proposition import Proposition", "from symlogos.first_order_rules import AlphaRule, BetaRule, GammaRule, DeltaRule\nfrom symlogos.proposition import Proposition\n\n\ndef test_alpha_rule():\n    f1 = And(Term(\"A\"), Term(\"B\"))\n    sf = SignedFormula(\"T\", f1)\n\n    alpha_rule = AlphaRule(sf)\n    assert alpha_rule.is_applicable()\n    new_signed_formulas = alpha_rule.apply()\n    assert len(new_signed_formulas) == 2\n    assert SignedFormula(\"T\", Term(\"A\")) in new_signed_formulas\n    assert SignedFormula(\"T\", Term(\"B\")) in new_signed_formulas", "\ndef test_beta_rule():\n    f1 = Implication(Term(\"A\"), Term(\"B\"))\n    sf = SignedFormula(\"T\", f1)\n\n    beta_rule = BetaRule(sf)\n    assert beta_rule.is_applicable()\n    new_signed_formulas = beta_rule.apply()\n    assert len(new_signed_formulas) == 2\n    assert SignedFormula(\"F\", Term(\"A\")) in new_signed_formulas\n    assert SignedFormula(\"T\", Term(\"B\")) in new_signed_formulas", "\ndef test_gamma_rule():\n    x = Term(\"x\")\n    P = Predicate(\"P\", x)\n    f1 = Exists(x, P)\n    sf = SignedFormula(\"F\", f1)\n\n    gamma_rule = GammaRule(sf)\n\n    node = TableauNode(sf)\n    gamma_rule.apply(node)\n\n    # Check if the node has exactly one child\n    assert len(node.children) == 1\n\n    # Check if the child node has the correct signed formula\n    child_signed_formula = node.children[0].signed_formula\n    fresh_variable = Term(\"v_0\")\n    expected_signed_formula = SignedFormula(\"T\", P.substitute({x: fresh_variable}))\n    assert child_signed_formula == expected_signed_formula", "\ndef test_delta_rule():\n    x = Term(\"x\")\n    P = Predicate(\"P\", [x])\n    f1 = Forall(x, P)\n    sf = SignedFormula(\"F\", f1)\n\n    delta_rule = DeltaRule(sf)\n\n    node = TableauNode(sf)\n    delta_rule.apply(node)\n\n    assert len(node.children) == 1\n    assert node.children[0].signed_formula == SignedFormula(\"T\", Predicate(\"P\", [Term(\"v_0\")]))", "\ndef is_tableau_structure_correct(tableau, expected_structure):\n    def _compare_nodes(node, expected_node):\n        if not node or not expected_node:\n            return False\n        \n        if node.signed_formula != expected_node.signed_formula:\n            return False\n        \n        if len(node.children) != len(expected_node.children):\n            return False\n        \n        for child, expected_child in zip(node.children, expected_node.children):\n            if not _compare_nodes(child, expected_child):\n                return False\n        \n        return True\n\n    return _compare_nodes(tableau, expected_structure)", "\ndef test_tableau_structure_correct_and():\n    A = Proposition(\"A\")\n    B = Proposition(\"B\")\n\n    conjunction = And(A, B)\n    tableau_root = TableauNode(SignedFormula(\"T\", conjunction))\n\n    tableau_A = TableauNode(SignedFormula(\"T\", A))\n    tableau_B = TableauNode(SignedFormula(\"T\", B))\n\n    tableau_root.children = [tableau_A, tableau_B]\n\n    expected_structure = tableau_root\n\n    assert is_tableau_structure_correct(tableau_root, expected_structure)", "\n\ndef test_tableau_structure_correct_or():\n    A = Proposition(\"A\")\n    B = Proposition(\"B\")\n\n    disjunction = Or(A, B)\n    tableau_root = TableauNode(SignedFormula(\"T\", disjunction))\n\n    tableau_A = TableauNode(SignedFormula(\"T\", A))\n    tableau_B = TableauNode(SignedFormula(\"T\", B))\n\n    tableau_root.children = [tableau_A]\n    tableau_A.children = [tableau_B]\n\n    expected_structure = tableau_root\n\n    assert is_tableau_structure_correct(tableau_root, expected_structure)", "\n\ndef test_tableau_structure_correct_implication():\n    A = Proposition(\"A\")\n    B = Proposition(\"B\")\n\n    implication = Implication(A, B)\n    tableau_root = TableauNode(SignedFormula(\"T\", implication))\n\n    tableau_A = TableauNode(SignedFormula(\"F\", A))\n    tableau_B = TableauNode(SignedFormula(\"T\", B))\n\n    tableau_root.children = [tableau_A, tableau_B]\n\n    expected_structure = tableau_root\n\n    assert is_tableau_structure_correct(tableau_root, expected_structure)", "\ndef test_tableau_prover():\n    A = Proposition(\"A\")\n    B = Proposition(\"B\")\n    C = Proposition(\"C\")\n\n    # Example: A -> (B -> A)\n    premises = []\n    conclusion = Implication(A, Implication(B, A))\n    prover = TableauProver()\n    assert prover.is_sound(premises, conclusion)\n\n    # Example: (A -> B), A |- B\n    premises = [Implication(A, B), A]\n    conclusion = B\n    prover = TableauProver()\n    assert prover.is_sound(premises, conclusion)\n\n    # Example: (A -> B), (B -> C), A |- C\n    premises = [Implication(A, B), Implication(B, C), A]\n    conclusion = C\n    prover = TableauProver()\n    assert prover.is_sound(premises, conclusion)\n\n    # Example: A -> (B -> A)\n    premises = []\n    conclusion = Implication(A, Implication(B, A))\n    prover = TableauProver()\n    assert prover.is_sound(premises, conclusion)\n\n    # Example: A, (A -> B), (B -> C) |- C\n    premises = [A, Implication(A, B), Implication(B, C)]\n    conclusion = C\n    prover = TableauProver()\n    assert prover.is_sound(premises, conclusion)\n\n    # Example: (A and B) -> (B and A)\n    premises = []\n    conclusion = Implication(And(A, B), And(B, A))\n    prover = TableauProver()\n    assert prover.is_sound(premises, conclusion)\n\n    # Example: (A or B) -> (B or A)\n    premises = []\n    conclusion = Implication(Or(A, B), Or(B, A))\n    prover = TableauProver()\n    assert prover.is_sound(premises, conclusion)", "\ndef test_modal_tableau_prover():\n    A = Proposition(\"A\")\n\n    # Example: (\u25a1A -> A) -> A\n    premises = []\n    conclusion = Implication(Implication(Necessity(A), A), A)\n    prover = TableauProver()\n    assert prover.is_sound(premises, conclusion)"]}
{"filename": "tests/test_quantified_logic.py", "chunked_list": ["from symlogos.proposition import Proposition\nfrom symlogos.quantified_logic import QuantifiedLogic\nfrom symlogos.quantifiers import Exists\nfrom symlogos.modal_operators import Necessity\nfrom symlogos.quantifiers import Forall\n\ndef test_existential_instantiation():\n    x = Proposition(\"x\")\n    Fx = Proposition(\"Fx\")\n    c = Proposition(\"c\")\n    rule = QuantifiedLogic.existential_instantiation()\n    premises = [Exists(x, Fx)]\n    expected_result = Fx.substitute(x, c)\n    result = rule.apply(*premises)\n    assert result == expected_result", "\n\ndef test_barcan_formula():\n    x = Proposition(\"x\")\n    Fx = Proposition(\"Fx\")\n    rule = QuantifiedLogic.barcan_formula()\n    premises = [Necessity(Forall(x, Fx))]\n    expected_result = Forall(x, Necessity(Fx))\n    result = rule.apply(*premises)\n    assert result == expected_result"]}
{"filename": "tests/test_modal_tableau_rules.py", "chunked_list": ["import pytest\nfrom symlogos.modal_rules import ModalBoxTRule, ModalBoxFRule, ModalDiamondTRule, ModalDiamondFRule\nfrom symlogos.signed_formula import SignedFormula\nfrom symlogos.modal_operators import Necessity, Possibility\nfrom symlogos.proposition import Proposition\n\n@pytest.fixture\ndef A():\n    return Proposition(\"A\")\n", "\n@pytest.fixture\ndef B():\n    return Proposition(\"B\")\n\ndef test_modal_box_t_rule(A):\n    signed_formula = SignedFormula(\"T\", Necessity(A))\n    rule = ModalBoxTRule(signed_formula)\n    new_signed_formulas = rule.apply()\n\n    assert len(new_signed_formulas) == 1\n    assert new_signed_formulas[0] == SignedFormula(\"T\", A)", "\ndef test_modal_box_f_rule(A):\n    signed_formula = SignedFormula(\"F\", Necessity(A))\n    rule = ModalBoxFRule(signed_formula)\n    new_signed_formulas = rule.apply()\n\n    assert len(new_signed_formulas) == 1\n    assert new_signed_formulas[0] == SignedFormula(\"F\", A)\n\ndef test_modal_diamond_t_rule(A):\n    signed_formula = SignedFormula(\"T\", Possibility(A))\n    rule = ModalDiamondTRule(signed_formula)\n    new_signed_formulas = rule.apply()\n\n    assert len(new_signed_formulas) == 1\n    assert new_signed_formulas[0] == SignedFormula(\"T\", A)", "\ndef test_modal_diamond_t_rule(A):\n    signed_formula = SignedFormula(\"T\", Possibility(A))\n    rule = ModalDiamondTRule(signed_formula)\n    new_signed_formulas = rule.apply()\n\n    assert len(new_signed_formulas) == 1\n    assert new_signed_formulas[0] == SignedFormula(\"T\", A)\n\ndef test_modal_diamond_f_rule(A):\n    signed_formula = SignedFormula(\"F\", Possibility(A))\n    rule = ModalDiamondFRule(signed_formula)\n    new_signed_formulas = rule.apply()\n\n    assert len(new_signed_formulas) == 1\n    assert new_signed_formulas[0] == SignedFormula(\"F\", A)", "\ndef test_modal_diamond_f_rule(A):\n    signed_formula = SignedFormula(\"F\", Possibility(A))\n    rule = ModalDiamondFRule(signed_formula)\n    new_signed_formulas = rule.apply()\n\n    assert len(new_signed_formulas) == 1\n    assert new_signed_formulas[0] == SignedFormula(\"F\", A)\n", ""]}
