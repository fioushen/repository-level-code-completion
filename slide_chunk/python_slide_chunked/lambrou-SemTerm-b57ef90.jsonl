{"filename": "setup.py", "chunked_list": ["from setuptools import setup, find_packages\n\nsetup(\n    name=\"semterm\",\n    version=\"0.5.0\",\n    description=\"The Semantic Terminal\",\n    long_description=\"The Semantic Terminal\",\n    author=\"Lambrou\",\n    author_email=\"alexanderlambrou0602@gmail.com\",\n    packages=find_packages(),", "    author_email=\"alexanderlambrou0602@gmail.com\",\n    packages=find_packages(),\n    include_package_data=True,\n    entry_points={\n        \"console_scripts\": [\n            \"semterm = semterm.main:main\",\n        ],\n    },\n    install_requires=[\n        \"langchain\",", "    install_requires=[\n        \"langchain\",\n        \"tiktoken\",\n        \"pexpect\",\n        \"pydantic\",\n        \"openai\",\n    ],\n)\n", ""]}
{"filename": "semterm/main.py", "chunked_list": ["from semterm.config.Config import Config\nfrom semterm.agent.MrklAgent import MrklAgent\nfrom semterm.UI.UserInterface import UserInterface\n\n\ndef main():\n    config = Config()\n    agent = MrklAgent(config)\n    UserInterface(agent).start()\n", "\n\nif __name__ == \"__main__\":\n    main()  # pragma: no cover\n"]}
{"filename": "semterm/__init__.py", "chunked_list": [""]}
{"filename": "semterm/terminal/TerminalOutputParser.py", "chunked_list": ["import json\nfrom abc import ABC\nfrom typing import Union\nfrom langchain.agents.conversational_chat.output_parser import ConvoOutputParser\nfrom langchain.schema import AgentAction, AgentFinish\nfrom semterm.agent.TerminalAgentPrompt import FORMAT_INSTRUCTIONS\nfrom semterm.langchain_extensions.schema import AgentMistake\n\n\nclass TerminalOutputParser(ConvoOutputParser, ABC):\n    def get_format_instructions(self) -> str:\n        return FORMAT_INSTRUCTIONS\n\n    def parse(self, text: str) -> Union[AgentAction, AgentFinish]:\n        text = text.strip().replace(\"\\xa0\", \" \")\n        start_positions = [i for i, c in enumerate(text) if c == \"{\"]\n        end_positions = [i for i, c in enumerate(text) if c == \"}\"]\n\n        for start in start_positions:\n            for end in end_positions:\n                if start < end:  # ensure the end position is after the start\n                    try:\n                        cleaned_output = text[start : end + 1]\n                        response = json.loads(cleaned_output)\n                        action, action_input = (\n                            response[\"action\"],\n                            response[\"action_input\"],\n                        )\n                        if action == \"Final Answer\":\n                            return AgentFinish({\"output\": action_input}, text)\n                        else:\n                            return AgentAction(action, action_input, text)\n                    except json.JSONDecodeError:\n                        return AgentMistake(text, text)\n\n        # If we reach this point, no valid JSON was found in the text\n        return AgentFinish({\"output\": text}, text)", "\nclass TerminalOutputParser(ConvoOutputParser, ABC):\n    def get_format_instructions(self) -> str:\n        return FORMAT_INSTRUCTIONS\n\n    def parse(self, text: str) -> Union[AgentAction, AgentFinish]:\n        text = text.strip().replace(\"\\xa0\", \" \")\n        start_positions = [i for i, c in enumerate(text) if c == \"{\"]\n        end_positions = [i for i, c in enumerate(text) if c == \"}\"]\n\n        for start in start_positions:\n            for end in end_positions:\n                if start < end:  # ensure the end position is after the start\n                    try:\n                        cleaned_output = text[start : end + 1]\n                        response = json.loads(cleaned_output)\n                        action, action_input = (\n                            response[\"action\"],\n                            response[\"action_input\"],\n                        )\n                        if action == \"Final Answer\":\n                            return AgentFinish({\"output\": action_input}, text)\n                        else:\n                            return AgentAction(action, action_input, text)\n                    except json.JSONDecodeError:\n                        return AgentMistake(text, text)\n\n        # If we reach this point, no valid JSON was found in the text\n        return AgentFinish({\"output\": text}, text)", ""]}
{"filename": "semterm/terminal/SemanticTerminalProcess.py", "chunked_list": ["import getpass\nimport re\nimport signal\nfrom typing import Any\n\nimport pexpect as pexpect\nimport tiktoken\nfrom langchain.utilities import BashProcess\nfrom langchain.text_splitter import TokenTextSplitter\n", "from langchain.text_splitter import TokenTextSplitter\n\n\nclass SemanticTerminalProcess(BashProcess):\n    model_name: str = \"gpt-3.5-turbo\"\n    chunk_size: int = 500\n\n    def __init__(self, pid, print_terminal_output=True, timeout=20):\n        self.print_terminal_output = print_terminal_output\n        self.timeout = timeout\n        self.pid = pid\n        self.prompt = pid\n        self.process = self._initialize_persistent_process()\n        self.last_command_output = \"\"\n        self.incorrect_password_attempts = 0\n\n    def _initialize_persistent_process(self) -> pexpect.spawn:\n        process = pexpect.spawn(\n            \"bash\",\n            encoding=\"utf-8\",\n        )\n        process.expect(r\"\\$\")\n        process.sendline(\"PS1=\" + self.prompt)\n        process.expect_exact(self.prompt, timeout=10)\n        return process\n\n    @staticmethod\n    def _tiktoken_encoder(text: str, **kwargs: Any) -> int:\n        encoder = tiktoken.encoding_for_model(SemanticTerminalProcess.model_name)\n        return len(encoder.encode(text, **kwargs))\n\n    @staticmethod\n    def _get_last_n_tokens(text: str, n: int = chunk_size, overlap: int = 200) -> str:\n        \"\"\"Return last n tokens from the output.\"\"\"\n        text_splitter = TokenTextSplitter(\n            model_name=SemanticTerminalProcess.model_name,\n            chunk_size=n,\n            chunk_overlap=overlap,\n        )\n        split_text = text_splitter.split_text(text)\n        last = split_text[-1]\n        if SemanticTerminalProcess._tiktoken_encoder(last) < n:\n            return last\n        else:\n            return \"Truncated Output: ...\" + \"\".join(split_text[-2:])\n\n    def process_output(self, output: str, command: str) -> str:\n        \"\"\"Process the output.\"\"\"\n        return output\n\n    def _run_persistent(self, command: str) -> str:\n        \"\"\"Run commands and return final output.\"\"\"\n        self.command = command\n        if self.process is None:\n            raise ValueError(\"Process not initialized\")\n        print(\"semterm > \" + command)\n        try:\n            self.process.sendline(command)\n            self.process.expect([command, self.prompt], timeout=self.timeout)\n            self.last_command_output = self._handle_stdout(command)\n        except Exception as e:  # noqa - LLM is extremely error prone at the moment.\n            self.last_command_output = (\n                \"The last command resulted in an error. Error: \",\n                str(e),\n            )\n        if self.print_terminal_output:\n            print(self.last_command_output)\n        return SemanticTerminalProcess._get_last_n_tokens(self.last_command_output)\n\n    def _handle_stdout(self, command):\n        response = self._handle_terminal_expects(command)\n        return self._handle_terminal_response(command, response)\n\n    def _handle_terminal_response(self, command, response):\n        if response == \"password_request\":\n            return self._handle_password_request(command)\n        if response == \"incorrect_password\":\n            if self.incorrect_password_attempts > 2:\n                return \"Too many bad pass attempts.\"\n            self.incorrect_password_attempts += 1\n            return self._handle_password_request(command, self.incorrect_password_attempts)\n        elif response == \"prompt\":\n            return self.process.before\n        elif response == \"EOF\":\n            return f\"Process exited with error status: \" \\\n                   f\"{self.process.exitstatus}\"\n\n        elif response == \"TIMEOUT\":\n            return f\"Timeout reached. Most recent output: \" \\\n                   f\"{self.process.buffer}\"\n\n    def _handle_password_request(self, command, try_count=0):\n        try:\n            try_text = f\"{try_count} / 3 Attempts\\n\" if try_count > 0 else f\"\\n\"\n            signal.signal(signal.SIGINT, self.keyboard_interrupt_handler)\n            try:\n                self.process.expect_exact(':', timeout=1)\n            except pexpect.exceptions.TIMEOUT:  # pragma: no cover\n                pass\n            self.process.sendline(\n                getpass.getpass(\n                    try_text +\n                    f\"semterm is requesting your password to run the following command: {command}\\n\"\n                    f\"If you trust semterm, please enter your password below:\\n\"\n                    f\"(CTRL+C to Dismiss) Password for {getpass.getuser()}: \",\n                )\n            )\n            return self._handle_stdout(command)\n        except KeyboardInterrupt:\n            self.process.sendintr()\n            print(\"KeyboardInterrupt: Password not sent.\")\n            return \"User aborted password request.\"\n        finally:\n            signal.signal(signal.SIGINT, signal.default_int_handler)\n\n    def _handle_terminal_expects(self, command: str) -> str:\n        password_regex = re.compile(\n            r\"(password for|Enter password|Password:|'s password:)\", re.IGNORECASE\n        )\n        incorrect_password_regex = re.compile(\n            r\"(?i)(?!.*attempts)(incorrect password|password incorrect|wrong password|try \"\n            r\"again|wrong|incorrect)\"\n        )\n        expect_dict = {\n            \"prompt\": self.prompt,\n            \"password_request\": password_regex,\n            \"incorrect_password\": incorrect_password_regex,\n            \"EOF\": pexpect.EOF,\n            \"TIMEOUT\": pexpect.TIMEOUT,\n        }\n        list_index = self.process.expect(\n            list(expect_dict.values()), timeout=self.timeout\n        )\n\n        return list(expect_dict.keys())[list_index]\n\n    def get_most_recent_output(self):\n        return self.process.buffer\n\n    @staticmethod\n    def keyboard_interrupt_handler(sig, frame):\n        print(\"\\nPassword request cancelled.\")\n        raise KeyboardInterrupt", ""]}
{"filename": "semterm/terminal/SemanticTerminalManager.py", "chunked_list": ["from uuid import uuid4\n\nfrom semterm.terminal.SemanticTerminalProcess import SemanticTerminalProcess\n\n\nclass SemanticTerminalManager:\n    def __init__(self):\n        self.processes = {}\n\n    def create_process(self, print_terminal_output=True, timeout=20):\n        process = SemanticTerminalProcess(str(uuid4()), print_terminal_output, timeout)\n        self.processes[process.pid] = process\n        return process\n\n    def get_process(self, pid):\n        return self.processes.get(pid)\n\n    def get_most_recent_output(self, pid):\n        process = self.get_process(pid)\n        if process is not None:\n            return process.get_most_recent_output()", ""]}
{"filename": "semterm/terminal/__init__.py", "chunked_list": [""]}
{"filename": "semterm/terminal/TerminalTool.py", "chunked_list": ["from typing import Dict, Any, Union, Tuple, Sequence\nfrom uuid import uuid4\nfrom inspect import signature\n\nfrom langchain.tools.base import BaseTool\nfrom pydantic.decorator import validate_arguments\n\nfrom semterm.terminal.SemanticTerminalManager import SemanticTerminalManager\n\n\nclass TerminalTool(BaseTool):\n    name: str = \"Terminal\"\n    description: str = (\n        \"Executes commands in a terminal. Input should be valid commands, and the output will be any \"\n        \"output from running that command. If you are asked to do perform a task, it is likely the setup for the task \"\n        \"has not been done yet. \"\n        \"If you are unsure, use the Human tool to verify with the human that they want you to run all setup commands \"\n        \"as well. \"\n    )\n    manager: SemanticTerminalManager = SemanticTerminalManager()\n\n    @property\n    def func(self):\n        return self.manager.create_process().run\n\n    @property\n    def args(self) -> dict:\n        if self.args_schema is not None:\n            return self.args_schema.schema()[\"properties\"]\n        else:\n            inferred_model = validate_arguments(self.func).model\n            schema = inferred_model.schema()[\"properties\"]\n            valid_keys = signature(self.func).parameters\n            return {k: schema[k] for k in valid_keys if k not in (\"run_manager\", \"callbacks\")}\n\n    def _run(self, *args: Any, **kwargs: Any) -> str:\n        \"\"\"Use the tool.\"\"\"\n        return self.func(*args, **kwargs)\n\n    async def _arun(self, *args: Any, **kwargs: Any) -> str:  # pragma: no cover\n        \"\"\"Use the tool asynchronously.\"\"\"\n        if self.coroutine:\n            return await self.coroutine(*args, **kwargs)\n        raise NotImplementedError(\"Tool does not support async\")\n\n    def _to_args_and_kwargs(\n        self, tool_input: Union[str, Dict, list[str]]\n    ) -> Tuple[Tuple, Dict]:\n        \"\"\"Convert tool input to pydantic model.\"\"\"\n        args, kwargs = self._to_args_and_kwargs_b_compat(tool_input)\n        # For backwards compatibility. The tool must be run with a single input\n        all_args = list(args) + list(kwargs.values())\n        if len(all_args) != 1:\n            raise ValueError(\n                f\"Too many arguments to single-input tool {self.name}.\"\n                f\" Args: {all_args}\"\n            )\n        return tuple(all_args), {}\n\n    @staticmethod\n    def _to_args_and_kwargs_b_compat(\n        run_input: Union[str, Dict, list[str]]\n    ) -> Tuple[Sequence, dict]:\n        # For backwards compatability, if run_input is a string,\n        # pass as a positional argument.\n        if isinstance(run_input, str):\n            return (run_input,), {}\n        if isinstance(run_input, list):\n            return [], {\"command\": \";\".join(run_input)}\n        else:\n            return [], run_input", "\n\nclass TerminalTool(BaseTool):\n    name: str = \"Terminal\"\n    description: str = (\n        \"Executes commands in a terminal. Input should be valid commands, and the output will be any \"\n        \"output from running that command. If you are asked to do perform a task, it is likely the setup for the task \"\n        \"has not been done yet. \"\n        \"If you are unsure, use the Human tool to verify with the human that they want you to run all setup commands \"\n        \"as well. \"\n    )\n    manager: SemanticTerminalManager = SemanticTerminalManager()\n\n    @property\n    def func(self):\n        return self.manager.create_process().run\n\n    @property\n    def args(self) -> dict:\n        if self.args_schema is not None:\n            return self.args_schema.schema()[\"properties\"]\n        else:\n            inferred_model = validate_arguments(self.func).model\n            schema = inferred_model.schema()[\"properties\"]\n            valid_keys = signature(self.func).parameters\n            return {k: schema[k] for k in valid_keys if k not in (\"run_manager\", \"callbacks\")}\n\n    def _run(self, *args: Any, **kwargs: Any) -> str:\n        \"\"\"Use the tool.\"\"\"\n        return self.func(*args, **kwargs)\n\n    async def _arun(self, *args: Any, **kwargs: Any) -> str:  # pragma: no cover\n        \"\"\"Use the tool asynchronously.\"\"\"\n        if self.coroutine:\n            return await self.coroutine(*args, **kwargs)\n        raise NotImplementedError(\"Tool does not support async\")\n\n    def _to_args_and_kwargs(\n        self, tool_input: Union[str, Dict, list[str]]\n    ) -> Tuple[Tuple, Dict]:\n        \"\"\"Convert tool input to pydantic model.\"\"\"\n        args, kwargs = self._to_args_and_kwargs_b_compat(tool_input)\n        # For backwards compatibility. The tool must be run with a single input\n        all_args = list(args) + list(kwargs.values())\n        if len(all_args) != 1:\n            raise ValueError(\n                f\"Too many arguments to single-input tool {self.name}.\"\n                f\" Args: {all_args}\"\n            )\n        return tuple(all_args), {}\n\n    @staticmethod\n    def _to_args_and_kwargs_b_compat(\n        run_input: Union[str, Dict, list[str]]\n    ) -> Tuple[Sequence, dict]:\n        # For backwards compatability, if run_input is a string,\n        # pass as a positional argument.\n        if isinstance(run_input, str):\n            return (run_input,), {}\n        if isinstance(run_input, list):\n            return [], {\"command\": \";\".join(run_input)}\n        else:\n            return [], run_input", ""]}
{"filename": "semterm/UI/__init__.py", "chunked_list": [""]}
{"filename": "semterm/UI/UserInterface.py", "chunked_list": ["from semterm.agent.MrklAgent import MrklAgent\n\n\nclass UserInterface:\n    def __init__(self, agent: MrklAgent):\n        self.agent = agent\n\n    def start(self):\n        while True:\n            user_input = input(\"You > \")\n            if user_input.lower() == \"exit\":\n                break\n\n            response = self.agent.run(user_input)\n            print(\"\\rsemterm > \", response)", ""]}
{"filename": "semterm/config/Config.py", "chunked_list": ["import configparser\nimport os\n\n\nclass Config:\n    def __init__(self):\n        self.config = configparser.ConfigParser()\n        self.config.read(Config.get_config_file_path())\n\n    def get(self):\n        return self.config\n\n    @staticmethod\n    def get_config_file_path():\n        src_dir = os.path.dirname(os.path.abspath(__file__))\n        config_file = os.path.join(src_dir, \"config.ini\")\n        return config_file", ""]}
{"filename": "semterm/config/__init__.py", "chunked_list": [""]}
{"filename": "semterm/output_discriminator/OutputDiscriminator.py", "chunked_list": [""]}
{"filename": "semterm/output_discriminator/OutputDiscriminatorPrompt.py", "chunked_list": [""]}
{"filename": "semterm/agent/TerminalAgentPrompt.py", "chunked_list": ["# flake8: noqa\nPREFIX = \"\"\"You are a Semantic Terminal. Users will ask for you to perform tasks, expecting you to use the Terminal \ntool. Use it often and go above and beyond in completing the users request. Remember that you don't have to run all your commands in one go. You can run a command, look at the \noutput, and then run a new command based on that output. You can also use the Terminal tool to run multiple commands.\nIf you need to install a program to use it, use the Human tool to get permission from the user and then install it.\n\nYour current directory is {current_directory}\n\"\"\"\n\nFORMAT_INSTRUCTIONS = \"\"\"Begin Response Format instructions. ---", "\nFORMAT_INSTRUCTIONS = \"\"\"Begin Response Format instructions. ---\nRespond to the user in one of two formats:\n\n**Option 1:**\nUse this if you want to use a tool.\nJSON formatted in the following schema:\n\nThought: Here is where you will plan out your next steps\n```json", "Thought: Here is where you will plan out your next steps\n```json\n{{{{\n    \"action\": string \\\\ The action to take. Must be one of {tool_names}\n    \"action_input\": string or list of strings \\\\ The input to the action\n}}}}\n```\n\n**Option #2:**\nUse this if you want to respond directly to the human. JSON formatted in the following schema:", "**Option #2:**\nUse this if you want to respond directly to the human. JSON formatted in the following schema:\nThought: Here is where you will plan out your next steps\n```json\n{{{{\n    \"action\": \"Final Answer\",\n    \"action_input\": string \\\\ Use this to give a final answer or ask a question.\n}}}}\n```\n\"\"\"", "```\n\"\"\"\n\nSUFFIX = \"\"\"You can use tools to complete tasks the user asks you to do. The tools you can use are:\n\n{{tools}}\n\n{format_instructions}\n\nUSER'S INPUT ---------", "\nUSER'S INPUT ---------\n\n{{{{input}}}}\n\nPlan out what you will do to complete the task and then respond with an action.\n\"\"\"\n\nTEMPLATE_TOOL_RESPONSE = \"\"\"Observation: \n", "TEMPLATE_TOOL_RESPONSE = \"\"\"Observation: \n\n{observation}\n\nUsing the information above, plan out what you will do next to complete the task and then complete it.\n\"\"\"\n"]}
{"filename": "semterm/agent/TerminalAgent.py", "chunked_list": ["import os\nfrom abc import ABC\nfrom typing import Sequence, Optional, List, Tuple, Any\nfrom langchain import BasePromptTemplate\nfrom langchain.agents import (\n    ConversationalChatAgent,\n    AgentOutputParser,\n)\nfrom langchain.tools import BaseTool\nfrom pydantic import Field", "from langchain.tools import BaseTool\nfrom pydantic import Field\n\nfrom .TerminalAgentPrompt import (\n    PREFIX,\n    SUFFIX,\n    TEMPLATE_TOOL_RESPONSE,\n)\nfrom langchain.schema import (\n    AgentAction,", "from langchain.schema import (\n    AgentAction,\n    BaseOutputParser,\n    BaseMessage,\n    AIMessage,\n    SystemMessage,\n)\nfrom semterm.terminal.TerminalOutputParser import TerminalOutputParser\n\n\nclass TerminalAgent(ConversationalChatAgent, ABC):\n    output_parser: AgentOutputParser = Field(default_factory=TerminalOutputParser)\n\n    @classmethod\n    def create_prompt(\n        cls,\n        tools: Sequence[BaseTool],\n        system_message: str = PREFIX.format(current_directory=os.getcwd()),\n        human_message: str = SUFFIX,\n        input_variables: Optional[List[str]] = None,\n        output_parser: Optional[BaseOutputParser] = None,\n    ) -> BasePromptTemplate:\n        return super().create_prompt(\n            tools=tools,\n            system_message=system_message,\n            human_message=human_message,\n            input_variables=input_variables,\n            output_parser=output_parser or cls._get_default_output_parser(),\n        )\n\n    def _construct_scratchpad(\n        self, intermediate_steps: List[Tuple[AgentAction, str]]\n    ) -> List[BaseMessage]:\n        thoughts: List[BaseMessage] = []\n        for action, observation in intermediate_steps:\n            if action.tool == \"Human\":\n                thoughts.append(AIMessage(content=action.tool_input))\n                continue\n            if isinstance(action.tool_input, list):\n                observation = observation.replace(\";\".join(action.tool_input), \"\")\n            else:\n                observation = observation.replace(action.tool_input, \"\")\n            thoughts.append(AIMessage(content=action.log))\n            system_message = SystemMessage(\n                content=TEMPLATE_TOOL_RESPONSE.format(observation=observation)\n            )\n            thoughts.append(system_message)\n        return thoughts", "\n\nclass TerminalAgent(ConversationalChatAgent, ABC):\n    output_parser: AgentOutputParser = Field(default_factory=TerminalOutputParser)\n\n    @classmethod\n    def create_prompt(\n        cls,\n        tools: Sequence[BaseTool],\n        system_message: str = PREFIX.format(current_directory=os.getcwd()),\n        human_message: str = SUFFIX,\n        input_variables: Optional[List[str]] = None,\n        output_parser: Optional[BaseOutputParser] = None,\n    ) -> BasePromptTemplate:\n        return super().create_prompt(\n            tools=tools,\n            system_message=system_message,\n            human_message=human_message,\n            input_variables=input_variables,\n            output_parser=output_parser or cls._get_default_output_parser(),\n        )\n\n    def _construct_scratchpad(\n        self, intermediate_steps: List[Tuple[AgentAction, str]]\n    ) -> List[BaseMessage]:\n        thoughts: List[BaseMessage] = []\n        for action, observation in intermediate_steps:\n            if action.tool == \"Human\":\n                thoughts.append(AIMessage(content=action.tool_input))\n                continue\n            if isinstance(action.tool_input, list):\n                observation = observation.replace(\";\".join(action.tool_input), \"\")\n            else:\n                observation = observation.replace(action.tool_input, \"\")\n            thoughts.append(AIMessage(content=action.log))\n            system_message = SystemMessage(\n                content=TEMPLATE_TOOL_RESPONSE.format(observation=observation)\n            )\n            thoughts.append(system_message)\n        return thoughts", ""]}
{"filename": "semterm/agent/__init__.py", "chunked_list": [""]}
{"filename": "semterm/agent/TerminalAgentExecutor.py", "chunked_list": ["from abc import ABC\nfrom typing import Dict, List, Tuple, Union, Optional\n\nfrom langchain.agents import AgentExecutor\nfrom langchain.agents.tools import InvalidTool\nfrom langchain.callbacks.manager import CallbackManagerForChainRun\nfrom langchain.schema import AgentAction, AgentFinish\nfrom langchain.tools import BaseTool\n\nfrom semterm.langchain_extensions.schema import AgentMistake", "\nfrom semterm.langchain_extensions.schema import AgentMistake\n\n\nclass TerminalAgentExecutor(AgentExecutor, ABC):\n    def _take_next_step(\n        self,\n        name_to_tool_map: Dict[str, BaseTool],\n        color_mapping: Dict[str, str],\n        inputs: Dict[str, str],\n        intermediate_steps: List[Tuple[AgentAction, str]],\n        run_manager: Optional[CallbackManagerForChainRun] = None,\n    ) -> Union[\n        AgentFinish, List[Tuple[AgentAction, str]], List[Tuple[AgentMistake, str]]\n    ]:\n        \"\"\"Take a single step in the thought-action-observation loop.\n\n        Override this to take control of how the agent makes and acts on choices.\n        \"\"\"\n        # Call the LLM to see what to do.\n        output = self.agent.plan(intermediate_steps, **inputs)\n        result = []\n        actions: List[AgentAction]\n        # If the tool chosen is the finishing tool, then we end and return.\n        if isinstance(output, AgentFinish):\n            return output\n        if isinstance(output, (AgentAction, AgentMistake)):\n            actions = [output]\n        for agent_action in actions:\n            if run_manager:\n                run_manager.on_agent_action(  # pragma: no cover\n                    agent_action,\n                    verbose=self.verbose,\n                    color=\"green\",\n                )\n            # Otherwise we lookup the tool\n            if agent_action.tool in name_to_tool_map:\n                tool = name_to_tool_map[agent_action.tool]\n                return_direct = tool.return_direct\n                color = color_mapping[agent_action.tool]\n                tool_run_kwargs = self.agent.tool_run_logging_kwargs()\n                if return_direct:\n                    tool_run_kwargs[\"llm_prefix\"] = \"\"\n                # We then call the tool on the tool input to get an observation\n                observation = tool.run(\n                    agent_action.tool_input,\n                    verbose=self.verbose,\n                    color=color,\n                    **tool_run_kwargs,\n                )\n            else:\n                tool_run_kwargs = self.agent.tool_run_logging_kwargs()\n                observation = InvalidTool().run(\n                    agent_action.tool,\n                    verbose=self.verbose,\n                    color=None,\n                    **tool_run_kwargs,\n                )\n            result.append((agent_action, observation))\n        return result", ""]}
{"filename": "semterm/agent/MrklAgent.py", "chunked_list": ["import os\n\nfrom langchain.agents import load_tools\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.memory import ConversationEntityMemory\n\nfrom semterm.agent.TerminalAgentPrompt import PREFIX\nfrom semterm.config.Config import Config\nfrom semterm.agent.TerminalAgent import TerminalAgent\nfrom semterm.agent.TerminalAgentExecutor import TerminalAgentExecutor", "from semterm.agent.TerminalAgent import TerminalAgent\nfrom semterm.agent.TerminalAgentExecutor import TerminalAgentExecutor\nfrom semterm.terminal.TerminalOutputParser import TerminalOutputParser\nfrom semterm.terminal.TerminalTool import TerminalTool\nfrom semterm.terminal.SemanticTerminalManager import SemanticTerminalManager\nfrom semterm.langchain_extensions.tools import MistakeTool, TerminalHumanTool\n\n\nclass MrklAgent:\n    def __init__(self, config: Config):\n        config = config.get()\n        self.verbose = config.getboolean(\"DEFAULT\", \"verbose\")\n        self.max_iterations = config.getint(\"DEFAULT\", \"max_iterations\")\n        self.timeout = config.getint(\"DEFAULT\", \"timeout\")\n        self.print_terminal_output = config.getboolean(\n            \"DEFAULT\", \"print_terminal_output\"\n        )\n\n        self.llm = ChatOpenAI(temperature=0)\n        self.tools = self.load_tools()\n        self.memory = self.initialize_memory()\n\n        self.terminal_agent = self.initialize_agent()\n        self.terminal_agent_executor = self.initialize_executor()\n\n    def load_tools(self):\n        tools = [\n            TerminalTool(manager=SemanticTerminalManager()),\n            TerminalHumanTool(),\n            MistakeTool(),\n        ]\n\n        return tools\n\n    def initialize_memory(self):\n        return ConversationEntityMemory(\n            llm=self.llm,\n            return_messages=True,\n            chat_history_key=\"chat_history\",\n        )\n\n    def initialize_agent(self):\n        return TerminalAgent.from_llm_and_tools(\n            self.llm,\n            self.tools,\n            memory=self.memory,\n            system_message=PREFIX.format(current_directory=os.getcwd()),\n            output_parser=TerminalOutputParser(),\n            verbose=self.verbose,\n        )\n\n    def initialize_executor(self):\n        return TerminalAgentExecutor.from_agent_and_tools(\n            self.terminal_agent,\n            self.tools,\n            memory=self.memory,\n            max_iterations=self.max_iterations,\n            verbose=self.verbose,\n        )\n\n    def run(self, user_input):\n        return self.terminal_agent_executor.run(input=user_input)", "class MrklAgent:\n    def __init__(self, config: Config):\n        config = config.get()\n        self.verbose = config.getboolean(\"DEFAULT\", \"verbose\")\n        self.max_iterations = config.getint(\"DEFAULT\", \"max_iterations\")\n        self.timeout = config.getint(\"DEFAULT\", \"timeout\")\n        self.print_terminal_output = config.getboolean(\n            \"DEFAULT\", \"print_terminal_output\"\n        )\n\n        self.llm = ChatOpenAI(temperature=0)\n        self.tools = self.load_tools()\n        self.memory = self.initialize_memory()\n\n        self.terminal_agent = self.initialize_agent()\n        self.terminal_agent_executor = self.initialize_executor()\n\n    def load_tools(self):\n        tools = [\n            TerminalTool(manager=SemanticTerminalManager()),\n            TerminalHumanTool(),\n            MistakeTool(),\n        ]\n\n        return tools\n\n    def initialize_memory(self):\n        return ConversationEntityMemory(\n            llm=self.llm,\n            return_messages=True,\n            chat_history_key=\"chat_history\",\n        )\n\n    def initialize_agent(self):\n        return TerminalAgent.from_llm_and_tools(\n            self.llm,\n            self.tools,\n            memory=self.memory,\n            system_message=PREFIX.format(current_directory=os.getcwd()),\n            output_parser=TerminalOutputParser(),\n            verbose=self.verbose,\n        )\n\n    def initialize_executor(self):\n        return TerminalAgentExecutor.from_agent_and_tools(\n            self.terminal_agent,\n            self.tools,\n            memory=self.memory,\n            max_iterations=self.max_iterations,\n            verbose=self.verbose,\n        )\n\n    def run(self, user_input):\n        return self.terminal_agent_executor.run(input=user_input)", ""]}
{"filename": "semterm/langchain_extensions/schema.py", "chunked_list": ["from typing import NamedTuple\n\n\nclass AgentMistake(NamedTuple):\n    \"\"\"Class to use when an agent made a mistake and needs to be informed.\"\"\"\n\n    tool_input: str\n    log: str\n    tool: str = \"mistake_tool\"\n", ""]}
{"filename": "semterm/langchain_extensions/__init__.py", "chunked_list": [""]}
{"filename": "semterm/langchain_extensions/tools.py", "chunked_list": ["from abc import ABC\nfrom typing import Optional\n\nfrom langchain.callbacks.manager import (\n    CallbackManagerForToolRun,\n)\nfrom langchain.tools import BaseTool, HumanInputRun\n\n\nclass MistakeTool(BaseTool):\n    \"\"\"Tool that is run when invalid tool name is encountered by agent.\"\"\"\n\n    name = \"mistake_tool\"\n    description = \"DO NOT USE.\"  # For the agent to know not to use it.\n\n    def _run(self, agent_input: str) -> str:\n        \"\"\"Use the tool.\"\"\"\n        return (\n            f\"'''{agent_input}''' is not valid JSON. You must respond with valid JSON.\"\n        )\n\n    async def _arun(self, agent_input: str) -> str:\n        \"\"\"Use the tool asynchronously.\"\"\"\n        return (\n            f\"'''{agent_input}''' is not valid JSON. You must respond with valid JSON.\"\n        )", "\nclass MistakeTool(BaseTool):\n    \"\"\"Tool that is run when invalid tool name is encountered by agent.\"\"\"\n\n    name = \"mistake_tool\"\n    description = \"DO NOT USE.\"  # For the agent to know not to use it.\n\n    def _run(self, agent_input: str) -> str:\n        \"\"\"Use the tool.\"\"\"\n        return (\n            f\"'''{agent_input}''' is not valid JSON. You must respond with valid JSON.\"\n        )\n\n    async def _arun(self, agent_input: str) -> str:\n        \"\"\"Use the tool asynchronously.\"\"\"\n        return (\n            f\"'''{agent_input}''' is not valid JSON. You must respond with valid JSON.\"\n        )", "\n\nclass TerminalHumanTool(HumanInputRun, ABC):\n    description = (\n        \"You can ask a human for guidance when you think you \"\n        \"got stuck or you are not sure what to do next. \"\n        \"The input should be a question for the human.\"\n        \"NEVER ask the user for their password.\"\n        \"Example: \"\n        \"```json\"\n        '{{\"action\": \"Human\", \"action_input\": \"What is the meaning of life?\"}}'\n        \"```\"\n    )\n\n    def _run(\n        self,\n        query: str,\n        run_manager: Optional[CallbackManagerForToolRun] = None,\n    ) -> str:\n        \"\"\"Use the Human input tool.\"\"\"\n        if \"password\" in query.lower():\n            return (\n                f\"You should never use this tool to ask the user their password. \"\n                f\"If you are not trying to get the user's password, just replace the \"\n                f\"word 'password' with 'passphrase' or something else.\"\n            )\n\n        self.prompt_func(\"semterm > \" + query)\n        return input(\"You > \")", ""]}
{"filename": "tests/test_main.py", "chunked_list": ["from unittest.mock import MagicMock, patch\nimport semterm.main as semterm_main\n\nfrom semterm.UI.UserInterface import UserInterface\nfrom semterm.agent.MrklAgent import MrklAgent\nfrom semterm.config.Config import Config\n\n\ndef test_main():\n    with patch(\"semterm.main.Config\", MagicMock(spec=Config)) as config_mock, patch(\n        \"semterm.main.MrklAgent\", MagicMock(spec=MrklAgent)\n    ) as agent_mock, patch(\n        \"semterm.main.UserInterface\", MagicMock(spec=UserInterface)\n    ) as ui_mock:\n        semterm_main.main()\n\n    # Check that the classes are instantiated and the start method is called on the UserInterface instance\n    config_mock.assert_called_once()\n    agent_mock.assert_called_once_with(config=config_mock.return_value)\n    ui_mock.assert_called_once_with(agent=agent_mock.return_value)\n    ui_mock.return_value.start.assert_called_once()", "def test_main():\n    with patch(\"semterm.main.Config\", MagicMock(spec=Config)) as config_mock, patch(\n        \"semterm.main.MrklAgent\", MagicMock(spec=MrklAgent)\n    ) as agent_mock, patch(\n        \"semterm.main.UserInterface\", MagicMock(spec=UserInterface)\n    ) as ui_mock:\n        semterm_main.main()\n\n    # Check that the classes are instantiated and the start method is called on the UserInterface instance\n    config_mock.assert_called_once()\n    agent_mock.assert_called_once_with(config=config_mock.return_value)\n    ui_mock.assert_called_once_with(agent=agent_mock.return_value)\n    ui_mock.return_value.start.assert_called_once()", ""]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/conftest.py", "chunked_list": ["import os\nfrom unittest.mock import MagicMock\n\nimport pytest\nfrom langchain.base_language import BaseLanguageModel\nfrom langchain.schema import BaseMemory, LLMResult, Generation\nfrom langchain.tools import BaseTool\n\nfrom semterm.agent.TerminalAgent import TerminalAgent\nfrom semterm.agent.TerminalAgentPrompt import PREFIX", "from semterm.agent.TerminalAgent import TerminalAgent\nfrom semterm.agent.TerminalAgentPrompt import PREFIX\nfrom semterm.terminal.TerminalOutputParser import TerminalOutputParser\n\n\n@pytest.fixture\ndef mock_tools():\n    tools = [MagicMock(spec=BaseTool) for _ in range(3)]\n\n    # Set custom name and description for each tool\n    for idx, tool in enumerate(tools):\n        tool.name = f\"Tool{idx + 1}\"\n        tool.description = f\"Tool{idx + 1} description\"\n\n    return tools", "\n\n@pytest.fixture\ndef terminal_agent(mock_tools, monkeypatch):\n    memory_mock = MagicMock(spec=BaseMemory)\n    system_message = PREFIX.format(current_directory=os.getcwd())\n    output_parser_mock = MagicMock(spec=TerminalOutputParser)\n    verbose_mock = False\n\n    def mock_generate_prompt(*args, **kwargs):\n        return LLMResult(generations=[[Generation(text=\"Hello\")]])\n\n    llm_mock = MagicMock(spec=BaseLanguageModel)\n    llm_mock.generate_prompt = mock_generate_prompt\n\n    # Instantiate the TerminalAgent using the from_llm_and_tools method\n    terminal_agent_instance = TerminalAgent.from_llm_and_tools(\n        llm=llm_mock,\n        tools=mock_tools,\n        memory=memory_mock,\n        system_message=system_message,\n        output_parser=output_parser_mock,\n        verbose=verbose_mock,\n    )\n\n    return terminal_agent_instance", ""]}
{"filename": "tests/tools/test_tools.py", "chunked_list": ["from unittest.mock import patch\nimport pytest\nfrom semterm.langchain_extensions.tools import MistakeTool, TerminalHumanTool\n\n\nclass TestMistakeTool:\n    @pytest.fixture\n    def mistake_tool(self):\n        return MistakeTool()\n\n    def test_run(self, mistake_tool):\n        agent_input = \"invalid_input\"\n        expected_output = (\n            f\"'''{agent_input}''' is not valid JSON. You must respond with valid JSON.\"\n        )\n        output = mistake_tool.run(agent_input)\n        assert output == expected_output\n\n    @pytest.mark.asyncio\n    async def test_arun(self, mistake_tool):\n        agent_input = \"invalid_input\"\n        expected_output = (\n            f\"'''{agent_input}''' is not valid JSON. You must respond with valid JSON.\"\n        )\n        output = await mistake_tool.arun(agent_input)\n        assert output == expected_output", "\n\nclass TestTerminalHumanTool:\n    @pytest.fixture\n    def human_tool(self):\n        return TerminalHumanTool()\n\n    def test_run(self, human_tool):\n        agent_input = \"What is the meaning of life?\"\n        expected_output = \"You > \"\n        with patch(\"builtins.input\", return_value=expected_output):\n            output = human_tool.run(agent_input)\n        assert output == expected_output\n\n    def test_run_with_password_request(self, human_tool):\n        agent_input = \"What is your password?\"\n        expected_output = (\n            f\"You should never use this tool to ask the user their password. \"\n            f\"If you are not trying to get the user's password, just replace the \"\n            f\"word 'password' with 'passphrase' or something else.\"\n        )\n        output = human_tool.run(agent_input)\n        assert output == expected_output", ""]}
{"filename": "tests/tools/__init__.py", "chunked_list": [""]}
{"filename": "tests/terminal/test_TerminalOutputParser.py", "chunked_list": ["import pytest\nfrom typing import Union\nfrom langchain.schema import AgentAction, AgentFinish\nfrom semterm.agent.TerminalAgentPrompt import FORMAT_INSTRUCTIONS\nfrom semterm.langchain_extensions.schema import AgentMistake\nfrom semterm.terminal.TerminalOutputParser import (\n    TerminalOutputParser,\n)\n\n\nclass TestTerminalOutputParser:\n    @pytest.fixture\n    def parser(self):\n        return TerminalOutputParser()\n\n    def test_get_format_instructions(self, parser):\n        assert parser.get_format_instructions() == FORMAT_INSTRUCTIONS\n\n    @pytest.mark.parametrize(\n        \"text, expected\",\n        [\n            (\n                '{\"action\": \"Final Answer\", \"action_input\": \"42\"}',\n                AgentFinish(\n                    {\"output\": \"42\"}, '{\"action\": \"Final Answer\", \"action_input\": \"42\"}'\n                ),\n            ),\n            (\n                'Something before {\"action\": \"Test Action\", \"action_input\": \"test input\"} and after',\n                AgentAction(\n                    \"Test Action\",\n                    \"test input\",\n                    'Something before {\"action\": \"Test Action\", \"action_input\": \"test input\"} and after',\n                ),\n            ),\n            (\n                \"This is a text without valid JSON\",\n                AgentFinish(\n                    {\"output\": \"This is a text without valid JSON\"},\n                    \"This is a text without valid JSON\",\n                ),\n            ),\n            (\n                \"{'action': 'Invalid JSON', 'action_input': thisiswrong}\",\n                AgentMistake(\n                    \"{'action': 'Invalid JSON', 'action_input': thisiswrong}\",\n                    \"{'action': 'Invalid JSON', 'action_input': thisiswrong}\",\n                ),\n            ),\n        ],\n    )\n    def test_parse(self, parser, text: str, expected: Union[AgentAction, AgentFinish]):\n        result = parser.parse(text)\n        assert result == expected", "\n\nclass TestTerminalOutputParser:\n    @pytest.fixture\n    def parser(self):\n        return TerminalOutputParser()\n\n    def test_get_format_instructions(self, parser):\n        assert parser.get_format_instructions() == FORMAT_INSTRUCTIONS\n\n    @pytest.mark.parametrize(\n        \"text, expected\",\n        [\n            (\n                '{\"action\": \"Final Answer\", \"action_input\": \"42\"}',\n                AgentFinish(\n                    {\"output\": \"42\"}, '{\"action\": \"Final Answer\", \"action_input\": \"42\"}'\n                ),\n            ),\n            (\n                'Something before {\"action\": \"Test Action\", \"action_input\": \"test input\"} and after',\n                AgentAction(\n                    \"Test Action\",\n                    \"test input\",\n                    'Something before {\"action\": \"Test Action\", \"action_input\": \"test input\"} and after',\n                ),\n            ),\n            (\n                \"This is a text without valid JSON\",\n                AgentFinish(\n                    {\"output\": \"This is a text without valid JSON\"},\n                    \"This is a text without valid JSON\",\n                ),\n            ),\n            (\n                \"{'action': 'Invalid JSON', 'action_input': thisiswrong}\",\n                AgentMistake(\n                    \"{'action': 'Invalid JSON', 'action_input': thisiswrong}\",\n                    \"{'action': 'Invalid JSON', 'action_input': thisiswrong}\",\n                ),\n            ),\n        ],\n    )\n    def test_parse(self, parser, text: str, expected: Union[AgentAction, AgentFinish]):\n        result = parser.parse(text)\n        assert result == expected", ""]}
{"filename": "tests/terminal/test_SemanticTerminalManager.py", "chunked_list": ["import pytest\nfrom unittest.mock import MagicMock\nfrom semterm.terminal.SemanticTerminalManager import SemanticTerminalManager\nfrom semterm.terminal.SemanticTerminalProcess import SemanticTerminalProcess\n\n\nclass TestSemanticTerminalManager:\n    @pytest.fixture\n    def semantic_terminal_manager(self):\n        return SemanticTerminalManager()\n\n    @pytest.fixture\n    def mock_semantic_terminal_process(self, monkeypatch):\n        mock_instance = MagicMock()\n        mock_instance.pid = \"mock_pid\"\n\n        monkeypatch.setattr(\n            SemanticTerminalProcess, \"__new__\", MagicMock(return_value=mock_instance)\n        )\n        return mock_instance\n\n    def test_create_process(self, semantic_terminal_manager):\n        process = semantic_terminal_manager.create_process()\n        assert process.pid in semantic_terminal_manager.processes\n\n    def test_get_process(self, semantic_terminal_manager):\n        process = semantic_terminal_manager.create_process()\n        fetched_process = semantic_terminal_manager.get_process(process.pid)\n\n        assert process == fetched_process\n\n    def test_get_most_recent_output(self, semantic_terminal_manager, monkeypatch):\n        monkeypatch.setattr(\n            SemanticTerminalProcess,\n            \"get_most_recent_output\",\n            MagicMock(return_value=\"test_output\"),\n        )\n        process = semantic_terminal_manager.create_process()\n        output = semantic_terminal_manager.get_most_recent_output(process.pid)\n\n        assert output == \"test_output\"\n\n    def test_get_most_recent_output_invalid_pid(self, semantic_terminal_manager):\n        output = semantic_terminal_manager.get_most_recent_output(\"invalid_pid\")\n\n        assert output is None", ""]}
{"filename": "tests/terminal/__init__.py", "chunked_list": [""]}
{"filename": "tests/terminal/test_TerminalTool.py", "chunked_list": ["from contextlib import contextmanager\n\nimport pytest\nfrom unittest.mock import MagicMock, patch, Mock, create_autospec\n\nfrom pydantic import BaseModel\nfrom pydantic.decorator import validate_arguments\n\nfrom semterm.terminal import TerminalTool, SemanticTerminalManager\nfrom semterm.terminal.SemanticTerminalProcess import SemanticTerminalProcess", "from semterm.terminal import TerminalTool, SemanticTerminalManager\nfrom semterm.terminal.SemanticTerminalProcess import SemanticTerminalProcess\n\n\nclass MockSemanticTerminalManager(SemanticTerminalManager.SemanticTerminalManager):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def create_process(self, *args, **kwargs):\n        return MockSemanticTerminalProcess()", "\n\nclass MockSemanticTerminalProcess(SemanticTerminalProcess):\n    def __init__(self, *args, **kwargs):\n        pass\n\n    def _initialize_persistent_process(self):\n        return None\n\n    def run(self, *args, **kwargs):\n        return \"Mocked response\"\n\n    def _run(self, *args, **kwargs):\n        return \"Mocked response\"", "\n\nclass TestTerminalTool:\n    @pytest.fixture(autouse=True)\n    def setup_terminal_tool(self):\n        self.terminal_tool = TerminalTool.TerminalTool(\n            manager=MockSemanticTerminalManager()\n        )\n\n    def test_func(self):\n        func = self.terminal_tool.func\n        assert func() == \"Mocked response\"\n\n    def test_run(self):\n        result = self.terminal_tool._run(\"example_command\")\n        assert result == \"Mocked response\"\n\n    def test_args_with_args_schema(self):\n        class ArgsSchema(BaseModel):\n            arg1: int\n            arg2: str\n\n        self.terminal_tool.args_schema = ArgsSchema\n\n        expected_args = {\n            \"arg1\": {\"title\": \"Arg1\", \"type\": \"integer\"},\n            \"arg2\": {\"title\": \"Arg2\", \"type\": \"string\"},\n        }\n\n        assert self.terminal_tool.args == expected_args\n\n    def test_args_without_args_schema(self):\n        def dummy_function(arg1: int, arg2: str):\n            return \"Dummy response\"\n\n        type(self.terminal_tool).func = property(lambda _: dummy_function)\n\n        expected_args = {\n            \"arg1\": {\"title\": \"Arg1\", \"type\": \"integer\"},\n            \"arg2\": {\"title\": \"Arg2\", \"type\": \"string\"},\n        }\n\n        assert self.terminal_tool.args == expected_args\n\n    def test_to_args_and_kwargs(self):\n        args, kwargs = self.terminal_tool._to_args_and_kwargs(\"example_command\")\n        assert args == (\"example_command\",)\n        assert kwargs == {}\n\n        args, kwargs = self.terminal_tool._to_args_and_kwargs({\"key\": \"value\"})\n        assert args == (\"value\",)\n        assert kwargs == {}\n\n        args, kwargs = self.terminal_tool._to_args_and_kwargs([\"command1\", \"command2\"])\n        assert args == (\"command1;command2\",)\n        assert kwargs == {}\n\n        with pytest.raises(ValueError, match=r\"Too many arguments\"):\n            self.terminal_tool._to_args_and_kwargs(\n                {\"command1\": \"value\", \"command2\": \"value\"}\n            )\n\n    def test_to_args_and_kwargs_b_compat(self):\n        args, kwargs = self.terminal_tool._to_args_and_kwargs_b_compat(\n            \"example_command\"\n        )\n        assert args == (\"example_command\",)\n        assert kwargs == {}\n\n        args, kwargs = self.terminal_tool._to_args_and_kwargs_b_compat({\"key\": \"value\"})\n        assert args == []\n        assert kwargs == {\"key\": \"value\"}\n\n        args, kwargs = self.terminal_tool._to_args_and_kwargs_b_compat(\n            [\"command1\", \"command2\"]\n        )\n        assert args == []\n        assert kwargs == {\"command\": \"command1;command2\"}", ""]}
{"filename": "tests/terminal/test_SemanticTerminalProcess.py", "chunked_list": ["import types\nimport pexpect\nimport pytest\nfrom unittest.mock import MagicMock, patch, call\nfrom semterm.terminal.SemanticTerminalProcess import (\n    SemanticTerminalProcess,\n    TokenTextSplitter,\n)\n\n\nclass TestSemanticTerminalProcess:\n    @pytest.fixture\n    def semantic_terminal_process(self, monkeypatch):\n        original_method = SemanticTerminalProcess._initialize_persistent_process\n        monkeypatch.setattr(\n            SemanticTerminalProcess,\n            \"_initialize_persistent_process\",\n            MagicMock(return_value=MagicMock()),\n        )\n        instance = SemanticTerminalProcess(pid=\"test_pid\")\n        instance.original_initialize_persistent_process = types.MethodType(\n            original_method, instance\n        )\n        return instance\n\n    def test_initialize_persistent_process(\n            self, semantic_terminal_process, monkeypatch\n    ):\n        semantic_terminal_process._initialize_persistent_process = (\n            semantic_terminal_process.original_initialize_persistent_process\n        )\n        spawn_mock = MagicMock()\n        monkeypatch.setattr(pexpect, \"spawn\", spawn_mock)\n\n        semantic_terminal_process._initialize_persistent_process()\n\n        spawn_mock.assert_called_with(\"bash\", encoding=\"utf-8\")\n        spawn_mock.return_value.expect.assert_called_with(r\"\\$\")\n        spawn_mock.return_value.sendline.assert_called_with(\n            \"PS1=\" + semantic_terminal_process.prompt\n        )\n        spawn_mock.return_value.expect_exact.assert_called_with(\n            semantic_terminal_process.prompt, timeout=10\n        )\n\n    def test_tiktoken_encoder(self, semantic_terminal_process):\n        with patch(\"tiktoken.Encoding.encode\") as encode_mock:\n            encode_mock.return_value = \"test_encoded_value\" * 10\n            result = SemanticTerminalProcess._tiktoken_encoder(\"test_text\")\n\n            assert result == 10 * len(\"test_encoded_value\")\n\n    def test_get_last_n_tokens(self, semantic_terminal_process, monkeypatch):\n        text_splitter_mock = MagicMock()\n        monkeypatch.setattr(TokenTextSplitter, \"split_text\", text_splitter_mock)\n        text_splitter_mock.return_value = [\"sample1\", \"sample2\", \"sample3\"]\n\n        encoding_mock = MagicMock()\n        monkeypatch.setattr(SemanticTerminalProcess, \"_tiktoken_encoder\", encoding_mock)\n        encoding_mock.return_value = 100\n\n        result = SemanticTerminalProcess._get_last_n_tokens(\"some_text\", 250)\n\n        assert result == \"sample3\"\n\n    def test_get_last_n_tokens_last_two(self, semantic_terminal_process, monkeypatch):\n        text_splitter_mock = MagicMock()\n        monkeypatch.setattr(TokenTextSplitter, \"split_text\", text_splitter_mock)\n        text_splitter_mock.return_value = [\"sample1\", \"sample2\", \"sample3\"]\n\n        encoding_mock = MagicMock()\n        monkeypatch.setattr(SemanticTerminalProcess, \"_tiktoken_encoder\", encoding_mock)\n        encoding_mock.return_value = 100\n\n        result = SemanticTerminalProcess._get_last_n_tokens(\"some_text\", 2, 1)\n\n        assert result == \"Truncated Output: ...sample2sample3\"\n\n    def test_process_output(self, semantic_terminal_process):\n        output = \"output\"\n        command = \"command\"\n\n        result = semantic_terminal_process.process_output(output, command)\n\n        assert result == output\n\n    def test_run_persistent_basic_command(self, semantic_terminal_process, monkeypatch):\n        semantic_terminal_process.process = MagicMock()\n        semantic_terminal_process.process.after = \"test_prompt\"\n        semantic_terminal_process.process.expect.return_value = 0\n\n        monkeypatch.setattr(SemanticTerminalProcess, \"_get_last_n_tokens\", MagicMock())\n\n        semantic_terminal_process._run_persistent(\"ls\")\n\n        semantic_terminal_process.process.sendline.assert_has_calls(\n            [call(\"ls\")], any_order=False\n        )\n        assert semantic_terminal_process.prompt in semantic_terminal_process.process.expect.call_args[0][0]\n\n    def test_run_persistent_elevated_command(self, semantic_terminal_process, monkeypatch):\n        fake_password = \"password123\"\n        semantic_terminal_process.process = MagicMock()\n        semantic_terminal_process.process.after = \"test_prompt\"\n        semantic_terminal_process.process.expect.return_value = 1\n\n        monkeypatch.setattr(SemanticTerminalProcess, \"_get_last_n_tokens\", MagicMock())\n        monkeypatch.setattr(\"getpass.getpass\", MagicMock(return_value=fake_password))\n\n        semantic_terminal_process._run_persistent(\"sudo ls\")\n        semantic_terminal_process.process.sendline.assert_has_calls(\n            [call(\"sudo ls\"), call(fake_password)], any_order=False\n        )\n        assert semantic_terminal_process.prompt in semantic_terminal_process.process.expect.call_args[0][0]\n\n    def test_run_persistent_not_init(self, semantic_terminal_process, monkeypatch):\n        semantic_terminal_process.process = None\n        with pytest.raises(ValueError, match=r\"not initialized\"):\n            semantic_terminal_process._run_persistent(\"ls\")\n\n    def test_run_persistent_exception(self, semantic_terminal_process, monkeypatch):\n        semantic_terminal_process.process = MagicMock()\n        semantic_terminal_process.process.sendline = MagicMock()\n        monkeypatch.setattr(SemanticTerminalProcess, \"_get_last_n_tokens\", MagicMock())\n        semantic_terminal_process.process.expect.side_effect = Exception(\n            \"Test Exception\"\n        )\n\n        result = semantic_terminal_process._run_persistent(\"test_command\")\n\n        assert result.startswith(\n            \"The last command resulted in an error. Error: Test Exception\"\n        )\n\n    def test_run_persistent_pexpect_eof(self, semantic_terminal_process, monkeypatch):\n        monkeypatch.setattr(SemanticTerminalProcess, \"_get_last_n_tokens\", MagicMock())\n        semantic_terminal_process.process = MagicMock()\n        semantic_terminal_process.process.sendline = MagicMock()\n        semantic_terminal_process.process.expect.return_value = None\n        semantic_terminal_process.process.after = pexpect.EOF\n        semantic_terminal_process.process.exitstatus = 1\n\n        result = semantic_terminal_process._run_persistent(\"test_command\")\n\n        assert result.startswith(\"Process exited with error status: 1\")\n\n    def test_handle_terminal_response_EOF(self, semantic_terminal_process):\n        command = \"command\"\n        response = \"EOF\"\n        semantic_terminal_process.process = MagicMock()\n        semantic_terminal_process.process.exitstatus = 1\n        result = semantic_terminal_process._handle_terminal_response(command, response)\n        assert result == \"Process exited with error status: 1\"\n\n    def test_handle_terminal_response_TIMEOUT(self, semantic_terminal_process):\n        command = \"command\"\n        response = \"TIMEOUT\"\n        semantic_terminal_process.process = MagicMock()\n        semantic_terminal_process.process.buffer = \"test buffer\"\n        result = semantic_terminal_process._handle_terminal_response(command, response)\n        assert result == \"Timeout reached. Most recent output: test buffer\"\n\n    @patch.object(SemanticTerminalProcess, '_handle_stdout', return_value='test')\n    @patch('getpass.getpass', return_value='password')\n    def test_handle_password_request_keyboard_interrupt(self, mock_getpass, mock_handle_stdout, semantic_terminal_process):\n        command = \"command\"\n        semantic_terminal_process.process.sendline.side_effect = self.raise_keyboard_interrupt\n        result = semantic_terminal_process._handle_password_request(command)\n        semantic_terminal_process.process.sendintr.assert_called_once()\n        assert result == \"User aborted password request.\"\n\n    def raise_keyboard_interrupt(*args, **kwargs):\n        raise KeyboardInterrupt\n\n    def test_keyboard_interrupt_handler(self):\n        with pytest.raises(KeyboardInterrupt):\n            SemanticTerminalProcess.keyboard_interrupt_handler(1, 2)\n\n    def test_handle_terminal_response_password_request(self, semantic_terminal_process):\n        command = \"command\"\n        response = \"password_request\"\n        semantic_terminal_process._handle_password_request = MagicMock(return_value=\"test\")\n        result = semantic_terminal_process._handle_terminal_response(command, response)\n        assert result == \"test\"\n\n    def test_handle_terminal_response_incorrect_password_exceeded_attempts(self, semantic_terminal_process):\n        command = \"command\"\n        response = \"incorrect_password\"\n        semantic_terminal_process.incorrect_password_attempts = 3\n        result = semantic_terminal_process._handle_terminal_response(command, response)\n        assert result == \"Too many bad pass attempts.\"\n\n    def test_handle_terminal_response_incorrect_password_within_attempts(self, semantic_terminal_process):\n        command = \"command\"\n        response = \"incorrect_password\"\n        semantic_terminal_process.incorrect_password_attempts = 2\n        semantic_terminal_process._handle_password_request = MagicMock(return_value=\"test\")\n        result = semantic_terminal_process._handle_terminal_response(command, response)\n        assert result == \"test\"\n        assert semantic_terminal_process.incorrect_password_attempts == 3\n\n    def test_get_most_recent_output(self, semantic_terminal_process):\n        semantic_terminal_process.process = MagicMock()\n        semantic_terminal_process.process.buffer = \"test_output\"\n\n        result = semantic_terminal_process.get_most_recent_output()\n\n        assert result == \"test_output\"", "\n\nclass TestSemanticTerminalProcess:\n    @pytest.fixture\n    def semantic_terminal_process(self, monkeypatch):\n        original_method = SemanticTerminalProcess._initialize_persistent_process\n        monkeypatch.setattr(\n            SemanticTerminalProcess,\n            \"_initialize_persistent_process\",\n            MagicMock(return_value=MagicMock()),\n        )\n        instance = SemanticTerminalProcess(pid=\"test_pid\")\n        instance.original_initialize_persistent_process = types.MethodType(\n            original_method, instance\n        )\n        return instance\n\n    def test_initialize_persistent_process(\n            self, semantic_terminal_process, monkeypatch\n    ):\n        semantic_terminal_process._initialize_persistent_process = (\n            semantic_terminal_process.original_initialize_persistent_process\n        )\n        spawn_mock = MagicMock()\n        monkeypatch.setattr(pexpect, \"spawn\", spawn_mock)\n\n        semantic_terminal_process._initialize_persistent_process()\n\n        spawn_mock.assert_called_with(\"bash\", encoding=\"utf-8\")\n        spawn_mock.return_value.expect.assert_called_with(r\"\\$\")\n        spawn_mock.return_value.sendline.assert_called_with(\n            \"PS1=\" + semantic_terminal_process.prompt\n        )\n        spawn_mock.return_value.expect_exact.assert_called_with(\n            semantic_terminal_process.prompt, timeout=10\n        )\n\n    def test_tiktoken_encoder(self, semantic_terminal_process):\n        with patch(\"tiktoken.Encoding.encode\") as encode_mock:\n            encode_mock.return_value = \"test_encoded_value\" * 10\n            result = SemanticTerminalProcess._tiktoken_encoder(\"test_text\")\n\n            assert result == 10 * len(\"test_encoded_value\")\n\n    def test_get_last_n_tokens(self, semantic_terminal_process, monkeypatch):\n        text_splitter_mock = MagicMock()\n        monkeypatch.setattr(TokenTextSplitter, \"split_text\", text_splitter_mock)\n        text_splitter_mock.return_value = [\"sample1\", \"sample2\", \"sample3\"]\n\n        encoding_mock = MagicMock()\n        monkeypatch.setattr(SemanticTerminalProcess, \"_tiktoken_encoder\", encoding_mock)\n        encoding_mock.return_value = 100\n\n        result = SemanticTerminalProcess._get_last_n_tokens(\"some_text\", 250)\n\n        assert result == \"sample3\"\n\n    def test_get_last_n_tokens_last_two(self, semantic_terminal_process, monkeypatch):\n        text_splitter_mock = MagicMock()\n        monkeypatch.setattr(TokenTextSplitter, \"split_text\", text_splitter_mock)\n        text_splitter_mock.return_value = [\"sample1\", \"sample2\", \"sample3\"]\n\n        encoding_mock = MagicMock()\n        monkeypatch.setattr(SemanticTerminalProcess, \"_tiktoken_encoder\", encoding_mock)\n        encoding_mock.return_value = 100\n\n        result = SemanticTerminalProcess._get_last_n_tokens(\"some_text\", 2, 1)\n\n        assert result == \"Truncated Output: ...sample2sample3\"\n\n    def test_process_output(self, semantic_terminal_process):\n        output = \"output\"\n        command = \"command\"\n\n        result = semantic_terminal_process.process_output(output, command)\n\n        assert result == output\n\n    def test_run_persistent_basic_command(self, semantic_terminal_process, monkeypatch):\n        semantic_terminal_process.process = MagicMock()\n        semantic_terminal_process.process.after = \"test_prompt\"\n        semantic_terminal_process.process.expect.return_value = 0\n\n        monkeypatch.setattr(SemanticTerminalProcess, \"_get_last_n_tokens\", MagicMock())\n\n        semantic_terminal_process._run_persistent(\"ls\")\n\n        semantic_terminal_process.process.sendline.assert_has_calls(\n            [call(\"ls\")], any_order=False\n        )\n        assert semantic_terminal_process.prompt in semantic_terminal_process.process.expect.call_args[0][0]\n\n    def test_run_persistent_elevated_command(self, semantic_terminal_process, monkeypatch):\n        fake_password = \"password123\"\n        semantic_terminal_process.process = MagicMock()\n        semantic_terminal_process.process.after = \"test_prompt\"\n        semantic_terminal_process.process.expect.return_value = 1\n\n        monkeypatch.setattr(SemanticTerminalProcess, \"_get_last_n_tokens\", MagicMock())\n        monkeypatch.setattr(\"getpass.getpass\", MagicMock(return_value=fake_password))\n\n        semantic_terminal_process._run_persistent(\"sudo ls\")\n        semantic_terminal_process.process.sendline.assert_has_calls(\n            [call(\"sudo ls\"), call(fake_password)], any_order=False\n        )\n        assert semantic_terminal_process.prompt in semantic_terminal_process.process.expect.call_args[0][0]\n\n    def test_run_persistent_not_init(self, semantic_terminal_process, monkeypatch):\n        semantic_terminal_process.process = None\n        with pytest.raises(ValueError, match=r\"not initialized\"):\n            semantic_terminal_process._run_persistent(\"ls\")\n\n    def test_run_persistent_exception(self, semantic_terminal_process, monkeypatch):\n        semantic_terminal_process.process = MagicMock()\n        semantic_terminal_process.process.sendline = MagicMock()\n        monkeypatch.setattr(SemanticTerminalProcess, \"_get_last_n_tokens\", MagicMock())\n        semantic_terminal_process.process.expect.side_effect = Exception(\n            \"Test Exception\"\n        )\n\n        result = semantic_terminal_process._run_persistent(\"test_command\")\n\n        assert result.startswith(\n            \"The last command resulted in an error. Error: Test Exception\"\n        )\n\n    def test_run_persistent_pexpect_eof(self, semantic_terminal_process, monkeypatch):\n        monkeypatch.setattr(SemanticTerminalProcess, \"_get_last_n_tokens\", MagicMock())\n        semantic_terminal_process.process = MagicMock()\n        semantic_terminal_process.process.sendline = MagicMock()\n        semantic_terminal_process.process.expect.return_value = None\n        semantic_terminal_process.process.after = pexpect.EOF\n        semantic_terminal_process.process.exitstatus = 1\n\n        result = semantic_terminal_process._run_persistent(\"test_command\")\n\n        assert result.startswith(\"Process exited with error status: 1\")\n\n    def test_handle_terminal_response_EOF(self, semantic_terminal_process):\n        command = \"command\"\n        response = \"EOF\"\n        semantic_terminal_process.process = MagicMock()\n        semantic_terminal_process.process.exitstatus = 1\n        result = semantic_terminal_process._handle_terminal_response(command, response)\n        assert result == \"Process exited with error status: 1\"\n\n    def test_handle_terminal_response_TIMEOUT(self, semantic_terminal_process):\n        command = \"command\"\n        response = \"TIMEOUT\"\n        semantic_terminal_process.process = MagicMock()\n        semantic_terminal_process.process.buffer = \"test buffer\"\n        result = semantic_terminal_process._handle_terminal_response(command, response)\n        assert result == \"Timeout reached. Most recent output: test buffer\"\n\n    @patch.object(SemanticTerminalProcess, '_handle_stdout', return_value='test')\n    @patch('getpass.getpass', return_value='password')\n    def test_handle_password_request_keyboard_interrupt(self, mock_getpass, mock_handle_stdout, semantic_terminal_process):\n        command = \"command\"\n        semantic_terminal_process.process.sendline.side_effect = self.raise_keyboard_interrupt\n        result = semantic_terminal_process._handle_password_request(command)\n        semantic_terminal_process.process.sendintr.assert_called_once()\n        assert result == \"User aborted password request.\"\n\n    def raise_keyboard_interrupt(*args, **kwargs):\n        raise KeyboardInterrupt\n\n    def test_keyboard_interrupt_handler(self):\n        with pytest.raises(KeyboardInterrupt):\n            SemanticTerminalProcess.keyboard_interrupt_handler(1, 2)\n\n    def test_handle_terminal_response_password_request(self, semantic_terminal_process):\n        command = \"command\"\n        response = \"password_request\"\n        semantic_terminal_process._handle_password_request = MagicMock(return_value=\"test\")\n        result = semantic_terminal_process._handle_terminal_response(command, response)\n        assert result == \"test\"\n\n    def test_handle_terminal_response_incorrect_password_exceeded_attempts(self, semantic_terminal_process):\n        command = \"command\"\n        response = \"incorrect_password\"\n        semantic_terminal_process.incorrect_password_attempts = 3\n        result = semantic_terminal_process._handle_terminal_response(command, response)\n        assert result == \"Too many bad pass attempts.\"\n\n    def test_handle_terminal_response_incorrect_password_within_attempts(self, semantic_terminal_process):\n        command = \"command\"\n        response = \"incorrect_password\"\n        semantic_terminal_process.incorrect_password_attempts = 2\n        semantic_terminal_process._handle_password_request = MagicMock(return_value=\"test\")\n        result = semantic_terminal_process._handle_terminal_response(command, response)\n        assert result == \"test\"\n        assert semantic_terminal_process.incorrect_password_attempts == 3\n\n    def test_get_most_recent_output(self, semantic_terminal_process):\n        semantic_terminal_process.process = MagicMock()\n        semantic_terminal_process.process.buffer = \"test_output\"\n\n        result = semantic_terminal_process.get_most_recent_output()\n\n        assert result == \"test_output\"", ""]}
{"filename": "tests/UI/test_UserInterface.py", "chunked_list": ["from unittest.mock import patch\nfrom semterm.UI.UserInterface import UserInterface\n\n\nclass TestUserInterface:\n    @patch(\"semterm.agent.MrklAgent.MrklAgent\")\n    @patch(\"builtins.print\")\n    @patch(\"builtins.input\", side_effect=[\"Hello\", \"exit\"])\n    def test_start(self, mock_input, mock_print, mock_mrkl_agent):\n        mock_mrkl_agent.return_value.run.side_effect = lambda x: f\"Mock response: {x}\"\n\n        user_interface = UserInterface(mock_mrkl_agent())\n        user_interface.start()\n\n        mock_input.assert_any_call(\"You > \")\n        mock_print.assert_any_call(\"\\rsemterm > \", \"Mock response: Hello\")\n        assert mock_input.call_count == 2\n        assert mock_print.call_count == 1", ""]}
{"filename": "tests/UI/__init__.py", "chunked_list": [""]}
{"filename": "tests/config/test_Config.py", "chunked_list": ["import os\nimport configparser\nfrom semterm.config.Config import Config\nfrom unittest.mock import patch\nimport pytest\n\n\nclass TestConfig:\n    @pytest.fixture(scope=\"class\", autouse=True)\n    def temp_dir(self, tmpdir_factory):\n        tmpdir = tmpdir_factory.mktemp(\"config\")\n        tmp_config_file = tmpdir.join(\"config.ini\")\n        tmp_config_file.write(\"[example]\\nkey=value\\n\")\n        return tmp_config_file\n\n    def test_config_initialization(self, temp_dir):\n        # Patch the get_config_file_path to return the path of the temporary config file\n        with patch(\n            \"semterm.config.Config.Config.get_config_file_path\",\n            return_value=temp_dir.strpath,\n        ):\n            config = Config()\n\n        # Check if the config object is an instance of configparser.ConfigParser\n        assert isinstance(config.config, configparser.ConfigParser)\n\n        # Test if the config file is read correctly\n        assert config.config.get(\"example\", \"key\") == \"value\"\n\n    def test_get_config_file_path(self, temp_dir):\n        # Patch the get_config_file_path to return the path of the temporary config file\n        with patch(\n            \"semterm.config.Config.Config.get_config_file_path\",\n            return_value=temp_dir.strpath,\n        ):\n            config = Config()\n            actual_path = config.get_config_file_path()\n\n        # Check if the mocked get_config_file_path method returns the path of the temporary config file\n        assert actual_path == temp_dir.strpath\n\n    def test_get(self):\n        config = Config()\n        assert isinstance(config.get(), configparser.ConfigParser)", ""]}
{"filename": "tests/agent/test_TerminalAgentExecutor.py", "chunked_list": ["from abc import ABC\n\nimport pytest\nfrom unittest.mock import MagicMock, patch\n\nfrom langchain.schema import (\n    AgentAction,\n    AgentFinish,\n    BaseMemory,\n    SystemMessage,", "    BaseMemory,\n    SystemMessage,\n)\nfrom langchain.tools import BaseTool\nfrom pydantic.typing import NoneType\n\nfrom semterm.agent.TerminalAgent import TerminalAgent\nfrom semterm.agent.TerminalAgentExecutor import TerminalAgentExecutor\nfrom semterm.langchain_extensions.schema import AgentMistake\n", "from semterm.langchain_extensions.schema import AgentMistake\n\n\nclass MockTool(BaseTool, ABC):\n    name = \"mock_tool\"\n    description = \"Mock tool for testing purposes.\"\n\n    def _run(self, *args, **kwargs):\n        pass\n\n    def _arun(self):\n        pass", "\n\nclass TestTerminalAgentExecutor:\n    @pytest.fixture\n    def executor(self, mock_tools, terminal_agent):\n        memory = MagicMock(spec=BaseMemory)\n        return TerminalAgentExecutor.from_agent_and_tools(\n            terminal_agent,\n            [MockTool(name=\"Tool1\"), MockTool(name=\"Tool2\"), MockTool(name=\"Tool3\")],\n            max_iterations=10,\n            verbose=True,\n            memory=memory,\n        )\n\n    @patch.object(\n        TerminalAgent,\n        \"plan\",\n        return_value=AgentFinish(\n            return_values={\"output\": \"42\"},\n            log='{\"action\": \"Final Answer\", \"action_input\": \"42\"}',\n        ),\n    )\n    def test_take_next_step_returns_finish(self, plan_mock, executor):\n        # Test that _take_next_step returns AgentFinish when the output is an instance of AgentFinish\n        output = AgentFinish(\n            {\"output\": \"42\"}, '{\"action\": \"Final Answer\", \"action_input\": \"42\"}'\n        )\n        result = executor._take_next_step({}, {}, {}, [])\n        assert result == output\n\n    @patch.object(\n        TerminalAgent,\n        \"plan\",\n        return_value=AgentAction(tool=\"tool1\", tool_input=\"input1\", log=\"input1\"),\n    )\n    @patch.object(MockTool, \"run\", return_value=\"observation1\")\n    def test_take_next_step_returns_actions(self, run_mock, plan_mock, executor):\n        # Test that _take_next_step returns a list of AgentAction and observation tuples\n        name_to_tool_map = {\"tool1\": MockTool()}\n        color_mapping = {\"tool1\": \"red\"}\n        inputs = {\"input1\": \"value1\"}\n        intermediate_steps = []\n        result = executor._take_next_step(\n            name_to_tool_map, color_mapping, inputs, intermediate_steps\n        )\n        assert len(result) == 1\n        assert isinstance(result[0][0], AgentAction)\n        assert result[0][0].tool == \"tool1\"\n        assert result[0][0].tool_input == \"input1\"\n        assert isinstance(result[0][1], str)\n        assert result[0][1] == \"observation1\"\n\n    @patch.object(\n        TerminalAgent,\n        \"plan\",\n        return_value=AgentMistake(\n            log=\"Invalid input\", tool_input=\"input1\", tool=\"tool1\"\n        ),\n    )\n    def test_take_next_step_returns_mistakes(self, plan_mock, executor):\n        # Test that _take_next_step returns a list of AgentMistake and observation tuples\n        name_to_tool_map = {\"tool1\": MockTool()}\n        color_mapping = {\"tool1\": \"red\"}\n        inputs = {\"chat_history\": [SystemMessage(content=\"Hello\")], \"input\": \"value1\"}\n        intermediate_steps = []\n\n        result = executor._take_next_step(\n            name_to_tool_map,\n            color_mapping,\n            inputs,\n            intermediate_steps,\n        )\n        assert len(result) == 1\n        assert isinstance(result[0][0], AgentMistake)\n        assert result[0][0].log == \"Invalid input\"\n        assert result[0][0].tool_input == \"input1\"\n        assert result[0][0].tool == \"tool1\"\n        assert isinstance(result[0][1], NoneType)\n\n    @patch.object(\n        TerminalAgent,\n        \"plan\",\n        return_value=AgentAction(\n            log=\"Unknown tool\", tool_input=\"input1\", tool=\"unknown_tool\"\n        ),\n    )\n    def test_take_next_step_returns_invalid_tool(self, plan_mock, executor):\n        # Test that _take_next_step returns a list of AgentMistake and observation tuples\n        name_to_tool_map = {\"tool1\": MockTool()}\n        color_mapping = {\"tool1\": \"red\"}\n        inputs = {\n            \"chat_history\": [SystemMessage(content=\"Hello\")],\n            \"input\": \"value1\",\n        }\n        intermediate_steps = []\n\n        result = executor._take_next_step(\n            name_to_tool_map,\n            color_mapping,\n            inputs,\n            intermediate_steps,\n        )\n        assert len(result) == 1\n        assert isinstance(result[0][0], AgentAction)\n        assert result[0][0].log == \"Unknown tool\"\n        assert result[0][0].tool_input == \"input1\"\n        assert result[0][0].tool == \"unknown_tool\"\n        assert result[0][1] == \"unknown_tool is not a valid tool, try another one.\"\n\n    @patch.object(\n        TerminalAgent,\n        \"plan\",\n        return_value=AgentAction(log=\"input1\", tool_input=\"input1\", tool=\"tool1\"),\n    )\n    def test_take_next_step_returns_directly(self, plan_mock, executor):\n        name_to_tool_map = {\"tool1\": MockTool(return_direct=True)}\n        color_mapping = {\"tool1\": \"green\"}\n        inputs = {\n            \"chat_history\": [SystemMessage(content=\"Hello\")],\n            \"input\": \"value1\",\n        }\n        intermediate_steps = []\n\n        result = executor._take_next_step(\n            name_to_tool_map,\n            color_mapping,\n            inputs,\n            intermediate_steps,\n        )\n        assert len(result) == 1\n        assert isinstance(result[0][0], AgentAction)\n        assert result[0][0].log == \"input1\"\n        assert result[0][0].tool_input == \"input1\"\n        assert result[0][0].tool == \"tool1\"\n        assert result[0][1] == None", ""]}
{"filename": "tests/agent/test_MrklAgent.py", "chunked_list": ["from functools import partial\n\nimport pytest\nfrom unittest.mock import MagicMock, patch\n\nfrom langchain.agents import Agent, AgentExecutor\nfrom langchain.base_language import BaseLanguageModel\nfrom langchain.schema import BaseMemory\nfrom langchain.tools import BaseTool\n", "from langchain.tools import BaseTool\n\nfrom semterm.agent.TerminalAgent import TerminalAgent\nfrom semterm.agent.TerminalAgentExecutor import TerminalAgentExecutor\nfrom semterm.config.Config import Config\nfrom semterm.agent.MrklAgent import MrklAgent\nfrom semterm.langchain_extensions.tools import MistakeTool\nfrom semterm.terminal.TerminalOutputParser import TerminalOutputParser\nfrom semterm.terminal.TerminalTool import TerminalTool\n", "from semterm.terminal.TerminalTool import TerminalTool\n\n\nclass TestMrklAgent:\n    @pytest.fixture\n    def mrkl_agent(self, monkeypatch):\n        config_mock = MagicMock(spec=Config)\n        config_parser_mock = MagicMock()\n        config_parser_mock.getboolean.return_value = False\n        config_parser_mock.getint.return_value = 10\n        config_mock.get.return_value = config_parser_mock\n\n        # Store the original methods as attributes of the instance\n        original_load_tools = MrklAgent.load_tools\n        original_initialize_memory = MrklAgent.initialize_memory\n        original_initialize_agent = MrklAgent.initialize_agent\n        original_initialize_executor = MrklAgent.initialize_executor\n\n        monkeypatch.setattr(MrklAgent, \"load_tools\", MagicMock())\n        monkeypatch.setattr(MrklAgent, \"initialize_memory\", MagicMock())\n        monkeypatch.setattr(MrklAgent, \"initialize_agent\", MagicMock())\n        monkeypatch.setattr(MrklAgent, \"initialize_executor\", MagicMock())\n\n        chat_openai_mock = MagicMock()\n        monkeypatch.setattr(\"semterm.agent.MrklAgent.ChatOpenAI\", chat_openai_mock)\n\n        agent = MrklAgent(config=config_mock)\n\n        agent.original_load_tools = partial(original_load_tools, agent)\n        agent.original_initialize_memory = partial(original_initialize_memory, agent)\n        agent.original_initialize_agent = partial(original_initialize_agent, agent)\n        agent.original_initialize_executor = partial(\n            original_initialize_executor, agent\n        )\n\n        return agent\n\n    def test_load_tools(self, mrkl_agent, monkeypatch):\n        load_tools_mock = MagicMock(return_value=[MagicMock(spec=BaseTool)])\n        terminal_tool_mock = MagicMock(spec=TerminalTool)\n        mistake_tool_mock = MagicMock(spec=MistakeTool)\n        monkeypatch.setattr(\"langchain.agents.load_tools\", load_tools_mock)\n        monkeypatch.setattr(\n            \"semterm.terminal.TerminalTool.TerminalTool\", terminal_tool_mock\n        )\n        monkeypatch.setattr(\n            \"semterm.langchain_extensions.tools.MistakeTool\", mistake_tool_mock\n        )\n\n        tools = mrkl_agent.original_load_tools()\n\n        assert isinstance(tools, list)\n        assert all(isinstance(tool, BaseTool) for tool in tools)\n        assert any(isinstance(tool, TerminalTool) for tool in tools)\n\n    def test_initialize_memory(self, mrkl_agent, monkeypatch):\n        base_language_model_mock = MagicMock(spec=BaseLanguageModel)\n        monkeypatch.setattr(\n            \"langchain.base_language.BaseLanguageModel\",\n            MagicMock(return_value=base_language_model_mock),\n        )\n\n        # Set the MagicMock instance as the 'llm' attribute of mrkl_agent\n        mrkl_agent.llm = base_language_model_mock\n\n        memory = mrkl_agent.original_initialize_memory()\n\n        assert isinstance(memory, BaseMemory)\n\n    def test_initialize_agent(self, mrkl_agent, monkeypatch):\n        # Mock the objects used by the method\n        base_language_model_mock = MagicMock(spec=BaseLanguageModel)\n        terminal_agent_mock = MagicMock(spec=TerminalAgent)\n        terminal_output_parser_mock = MagicMock(spec=TerminalOutputParser)\n\n        # Set the MagicMock instances as the attributes of mrkl_agent\n        mrkl_agent.llm = base_language_model_mock\n        mrkl_agent.tools = [MagicMock(spec=BaseTool)]\n        mrkl_agent.memory = MagicMock(spec=BaseMemory)\n        mrkl_agent.verbose = False\n\n        # Mock the constructors and methods\n        monkeypatch.setattr(\n            \"langchain.base_language.BaseLanguageModel\",\n            MagicMock(return_value=base_language_model_mock),\n        )\n        monkeypatch.setattr(\n            \"semterm.agent.TerminalAgent.TerminalAgent.from_llm_and_tools\",\n            MagicMock(return_value=terminal_agent_mock),\n        )\n        monkeypatch.setattr(\n            \"semterm.terminal.TerminalOutputParser\", terminal_output_parser_mock\n        )\n\n        agent = mrkl_agent.original_initialize_agent()\n\n        # Assert that the agent is an instance of a subclass of the Agent class\n        assert issubclass(agent.__class__, Agent)\n\n    def test_initialize_executor(self, mrkl_agent, monkeypatch):\n        # Mock the objects used by the method\n        terminal_agent_executor_mock = MagicMock(spec=TerminalAgentExecutor)\n\n        # Set the MagicMock instances as the attributes of mrkl_agent\n        mrkl_agent.terminal_agent = MagicMock(spec=TerminalAgent)\n        mrkl_agent.tools = [MagicMock(spec=BaseTool)]\n        mrkl_agent.memory = MagicMock(spec=BaseMemory)\n        mrkl_agent.max_iterations = 10\n        mrkl_agent.verbose = False\n\n        # Mock the constructors and methods\n        monkeypatch.setattr(\n            \"semterm.agent.TerminalAgentExecutor.TerminalAgentExecutor.from_agent_and_tools\",\n            MagicMock(return_value=terminal_agent_executor_mock),\n        )\n\n        executor = mrkl_agent.original_initialize_executor()\n\n        # Assert that the executor is an instance of a subclass of the BaseExecutor class\n        assert issubclass(executor.__class__, AgentExecutor)\n\n    def test_run(self, mrkl_agent):\n        user_input = \"test_input\"\n\n        mrkl_agent.terminal_agent_executor.run = MagicMock()\n        mrkl_agent.run(user_input)\n        mrkl_agent.terminal_agent_executor.run.assert_called_with(input=user_input)", ""]}
{"filename": "tests/agent/test_TerminalAgent.py", "chunked_list": ["import os\n\nimport pytest\nfrom unittest.mock import MagicMock\n\nfrom langchain.base_language import BaseLanguageModel\nfrom langchain.prompts import SystemMessagePromptTemplate\nfrom langchain.tools import BaseTool\nfrom langchain.schema import (\n    AgentAction,", "from langchain.schema import (\n    AgentAction,\n    BaseMessage,\n    AIMessage,\n    SystemMessage,\n    BaseMemory,\n)\nfrom semterm.agent.TerminalAgent import TerminalAgent\nfrom semterm.agent.TerminalAgentPrompt import PREFIX, SUFFIX\nfrom semterm.terminal.TerminalOutputParser import TerminalOutputParser", "from semterm.agent.TerminalAgentPrompt import PREFIX, SUFFIX\nfrom semterm.terminal.TerminalOutputParser import TerminalOutputParser\n\n\nclass TestTerminalAgent:\n    def test_create_prompt(self, terminal_agent, mock_tools):\n        system_message = PREFIX.format(current_directory=os.getcwd())\n        human_message = SUFFIX\n        input_variables = [\"input\", \"chat_history\", \"agent_scratchpad\"]\n\n        prompt = TerminalAgent.create_prompt(\n            tools=mock_tools,\n            system_message=system_message,\n            human_message=human_message,\n            input_variables=input_variables,\n        )\n        # Extract properties from the returned ChatPromptTemplate\n        system_message_from_prompt = prompt.messages[0].format_messages()[0].content\n        human_message_from_prompt = (\n            prompt.messages[2].format_messages(input=\"test input\")[0].content\n        )\n\n        # Assert that the properties have the expected values\n        assert system_message_from_prompt == system_message\n        assert all(tool.name in human_message_from_prompt for tool in mock_tools)\n        assert all(tool.description in human_message_from_prompt for tool in mock_tools)\n        assert prompt.input_variables == input_variables\n\n    def test_construct_scratchpad(self, terminal_agent):\n        intermediate_steps = [\n            (AgentAction(tool=\"Human\", tool_input=\"cd ..\", log=\"cd ..\"), \"\"),\n            (\n                AgentAction(\n                    tool=\"TerminalTool\", tool_input=\"ls\", log=\"ls command executed\"\n                ),\n                \"file1 file2\",\n            ),\n            (\n                AgentAction(\n                    tool=\"TerminalTool\",\n                    tool_input=[\"cd ..\", \"ls\"],\n                    log=\"['cd ..', 'ls']\",\n                ),\n                \"file1 file2\",\n            ),\n        ]\n\n        scratchpad = terminal_agent._construct_scratchpad(intermediate_steps)\n\n        assert isinstance(scratchpad, list)\n        assert all(isinstance(msg, BaseMessage) for msg in scratchpad)\n        assert len(scratchpad) == 5\n        assert isinstance(scratchpad[0], AIMessage)\n        assert scratchpad[0].content == \"cd ..\"\n        assert isinstance(scratchpad[1], AIMessage)\n        assert scratchpad[1].content == \"ls command executed\"\n        assert isinstance(scratchpad[2], SystemMessage)\n        assert scratchpad[2].content.startswith(\"Observation:\")\n        assert isinstance(scratchpad[3], AIMessage)\n        assert scratchpad[3].content == \"['cd ..', 'ls']\"", ""]}
{"filename": "tests/agent/__init__.py", "chunked_list": [""]}
{"filename": "tests/agent/test_TerminalAgentPrompt.py", "chunked_list": ["import semterm.agent.TerminalAgentPrompt as TerminalAgentPrompt\n\n\ndef test_terminal_agent_prompt_constants():\n    assert hasattr(\n        TerminalAgentPrompt, \"TEMPLATE_TOOL_RESPONSE\"\n    ), \"TEMPLATE_TOOL_RESPONSE constant not found.\"\n    assert hasattr(TerminalAgentPrompt, \"SUFFIX\"), \"SUFFIX constant not found.\"\n    assert hasattr(\n        TerminalAgentPrompt, \"FORMAT_INSTRUCTIONS\"\n    ), \"FORMAT_INSTRUCTIONS constant not found.\"\n    assert hasattr(TerminalAgentPrompt, \"PREFIX\"), \"PREFIX constant not found.\"", ""]}
