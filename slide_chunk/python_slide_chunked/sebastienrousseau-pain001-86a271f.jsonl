{"filename": "setup.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n#\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"The setup.py file for Python Pain001.\"\"\"\n", "\"\"\"The setup.py file for Python Pain001.\"\"\"\n\nfrom setuptools import setup\n\nwith open(\"README.md\") as f:\n    LONG_DESCRIPTION = f.read()\n\nSHORT_DESCRIPTION = \"\"\"\nPain001, A Python Library for Automating ISO 20022-Compliant Payment Files\nUsing CSV Or SQlite Data Files.", "Pain001, A Python Library for Automating ISO 20022-Compliant Payment Files\nUsing CSV Or SQlite Data Files.\n\"\"\".strip()\n\nDEPENDENCIES = [\n    \"click==8.1.3\",\n    \"defusedxml==0.7.1\",\n    \"rich==13.4.2\",\n    \"xmlschema==2.3.1\",\n]", "    \"xmlschema==2.3.1\",\n]\n\nTEST_DEPENDENCIES = [\n    \"pytest>=7.3.2\",\n]\n\nNAME = \"pain001\"\nURL = \"https://github.com/sebastienrousseau/pain001\"\nVERSION = \"0.0.22\"", "URL = \"https://github.com/sebastienrousseau/pain001\"\nVERSION = \"0.0.22\"\n\nsetup(\n    name=NAME,\n    version=VERSION,\n    description=SHORT_DESCRIPTION,\n    long_description=LONG_DESCRIPTION,\n    long_description_content_type=\"text/markdown\",\n    url=URL,", "    long_description_content_type=\"text/markdown\",\n    url=URL,\n    author=\"Sebastien Rousseau\",\n    author_email=\"sebastian.rousseau@gmail.com\",\n    license=\"Apache Software License\",\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Financial and Insurance Industry\",\n        \"License :: OSI Approved :: Apache Software License\",", "        \"Intended Audience :: Financial and Insurance Industry\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Operating System :: MacOS\",\n        \"Operating System :: OS Independent\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python\",", "        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n    ],\n    keywords=\"\"\"\n    pain001,iso20022,payment-processing,automate-payments,sepa,financial,banking-payments,csv,sqlite\n    \"\"\",\n    packages=[\"pain001\"],\n    install_requires=DEPENDENCIES,\n    tests_require=TEST_DEPENDENCIES,", "    install_requires=DEPENDENCIES,\n    tests_require=TEST_DEPENDENCIES,\n)\n"]}
{"filename": "pain001/__main__.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# pylint: disable=invalid-name\n\"\"\"\nEnables use of Python Pain001 as a \"main\" function (i.e.", "\"\"\"\nEnables use of Python Pain001 as a \"main\" function (i.e.\n\"python3 -m pain001\n<xml_message_type> <xml_template_file_path> <xsd_schema_file_path>\n<data_file_path>\").\n\nThis allows using Pain001 with third-party libraries without modifying\ntheir code.\n\"\"\"\n", "\"\"\"\n\n\nimport os\nimport sys\nimport click\n\nfrom pain001.constants.constants import valid_xml_types\nfrom pain001.context.context import Context\nfrom pain001.core.core import process_files", "from pain001.context.context import Context\nfrom pain001.core.core import process_files\n\n# from pain001.xml.validate_via_xsd import validate_via_xsd\n\nfrom rich.console import Console\nfrom rich.table import Table\nfrom rich import box\n\nconsole = Console()", "\nconsole = Console()\n\ndescription = \"\"\"\nA powerful Python library that enables you to create\nISO 20022-compliant payment files directly from CSV or SQLite Data files.\\n\nhttps://pain001.com\n\"\"\"\ntitle = \"Pain001\"\n", "title = \"Pain001\"\n\ntable = Table(\n    box=box.ROUNDED,\n    safe_box=True,\n    show_header=False,\n    title=title,\n)\n\ntable.add_column(justify=\"center\", no_wrap=False, vertical=\"middle\")", "\ntable.add_column(justify=\"center\", no_wrap=False, vertical=\"middle\")\ntable.add_row(description)\ntable.width = 80\nconsole.print(table)\n\n\n@click.command(\n    help=(\n        \"To use Pain001, you must specify the following options:\\n\\n\"", "    help=(\n        \"To use Pain001, you must specify the following options:\\n\\n\"\n    ),\n    context_settings=dict(help_option_names=[\"-h\", \"--help\"]),\n)\n@click.option(\n    \"-t\",\n    \"--xml_message_type\",\n    default=None,\n    help=\"Type of XML message (required)\",", "    default=None,\n    help=\"Type of XML message (required)\",\n)\n@click.option(\n    \"-m\",\n    \"--xml_template_file_path\",\n    default=None,\n    type=click.Path(),\n    help=\"Path to XML template file (required)\",\n)", "    help=\"Path to XML template file (required)\",\n)\n@click.option(\n    \"-s\",\n    \"--xsd_schema_file_path\",\n    default=None,\n    type=click.Path(),\n    help=\"Path to XSD template file (required)\",\n)\n@click.option(", ")\n@click.option(\n    \"-d\",\n    \"--data_file_path\",\n    default=None,\n    type=click.Path(),\n    help=\"Path to data file (CSV or SQLite) (required)\",\n)\ndef main(\n    xml_message_type,\n    xml_template_file_path,\n    xsd_schema_file_path,\n    data_file_path,\n):\n    \"\"\"Initialize the context and log a message.\"\"\"\n    logger = Context.get_instance().get_logger()\n\n    # print(\"Inside main function\")\n\n    def check_variable(variable, name):\n        if variable is None:\n            print(f\"Error: {name} is required.\")\n            sys.exit(1)\n\n    # Check that xml_message_type is provided\n    check_variable(xml_message_type, \"xml_message_type\")\n\n    # Check that xsd_schema_file_path is provided\n    check_variable(xsd_schema_file_path, \"xsd_schema_file_path\")\n\n    # Check that data_file_path is provided\n    check_variable(data_file_path, \"data_file_path\")\n\n    # Check that xml_template_file_path is not invalid\n    if not os.path.isfile(xml_template_file_path):\n        print(\n            f\"The XML template file '{xml_template_file_path}' does not exist.\"\n        )\n        sys.exit(1)\n\n    # Check that xsd_schema_file_path is not invalid\n    if not os.path.isfile(xsd_schema_file_path):\n        print(\n            f\"The XSD template file '{xsd_schema_file_path}' does not exist.\"\n        )\n        sys.exit(1)\n\n    # Check that data_file_path is not invalid\n    if not os.path.isfile(data_file_path):\n        print(f\"The data file '{data_file_path}' does not exist.\")\n        sys.exit(1)\n\n    # Check that other necessary arguments are provided\n    if (\n        xml_template_file_path is None\n        or xsd_schema_file_path is None\n        or data_file_path is None\n    ):\n        print(click.get_current_context().get_help())\n        sys.exit(1)\n    \"\"\"\n    Entrypoint for pain001 when invoked as a module with\n    python3 -m pain001 <xml_message_type> <xml_template_file_path>\n    <xsd_schema_file_path> <data_file_path>.\n    \"\"\"\n    logger = Context.get_instance().get_logger()\n\n    logger.info(\"Parsing command line arguments.\")\n\n    # Check that the XML message type is valid\n    if xml_message_type not in valid_xml_types:\n        logger.info(f\"Invalid XML message type: {xml_message_type}.\")\n        print(f\"Invalid XML message type: {xml_message_type}.\")\n        sys.exit(1)\n\n    if not os.path.isfile(xml_template_file_path):\n        logger.info(\n            f\"The XML template file '{xml_template_file_path}' does not exist.\"\n        )\n        print(\n            f\"The XML template file '{xml_template_file_path}' does not exist.\"\n        )\n        sys.exit(1)\n\n    if not os.path.isfile(xsd_schema_file_path):\n        logger.info(\n            f\"The XSD template file '{xsd_schema_file_path}' does not exist.\"\n        )\n        print(\n            f\"The XSD template file '{xsd_schema_file_path}' does not exist.\"\n        )\n        sys.exit(1)\n\n    if not os.path.isfile(data_file_path):\n        logger.info(f\"The data file '{data_file_path}' does not exist.\")\n        print(f\"The data file '{data_file_path}' does not exist.\")\n        sys.exit(1)\n\n    process_files(\n        xml_message_type,\n        xml_template_file_path,\n        xsd_schema_file_path,\n        data_file_path,\n    )", "def main(\n    xml_message_type,\n    xml_template_file_path,\n    xsd_schema_file_path,\n    data_file_path,\n):\n    \"\"\"Initialize the context and log a message.\"\"\"\n    logger = Context.get_instance().get_logger()\n\n    # print(\"Inside main function\")\n\n    def check_variable(variable, name):\n        if variable is None:\n            print(f\"Error: {name} is required.\")\n            sys.exit(1)\n\n    # Check that xml_message_type is provided\n    check_variable(xml_message_type, \"xml_message_type\")\n\n    # Check that xsd_schema_file_path is provided\n    check_variable(xsd_schema_file_path, \"xsd_schema_file_path\")\n\n    # Check that data_file_path is provided\n    check_variable(data_file_path, \"data_file_path\")\n\n    # Check that xml_template_file_path is not invalid\n    if not os.path.isfile(xml_template_file_path):\n        print(\n            f\"The XML template file '{xml_template_file_path}' does not exist.\"\n        )\n        sys.exit(1)\n\n    # Check that xsd_schema_file_path is not invalid\n    if not os.path.isfile(xsd_schema_file_path):\n        print(\n            f\"The XSD template file '{xsd_schema_file_path}' does not exist.\"\n        )\n        sys.exit(1)\n\n    # Check that data_file_path is not invalid\n    if not os.path.isfile(data_file_path):\n        print(f\"The data file '{data_file_path}' does not exist.\")\n        sys.exit(1)\n\n    # Check that other necessary arguments are provided\n    if (\n        xml_template_file_path is None\n        or xsd_schema_file_path is None\n        or data_file_path is None\n    ):\n        print(click.get_current_context().get_help())\n        sys.exit(1)\n    \"\"\"\n    Entrypoint for pain001 when invoked as a module with\n    python3 -m pain001 <xml_message_type> <xml_template_file_path>\n    <xsd_schema_file_path> <data_file_path>.\n    \"\"\"\n    logger = Context.get_instance().get_logger()\n\n    logger.info(\"Parsing command line arguments.\")\n\n    # Check that the XML message type is valid\n    if xml_message_type not in valid_xml_types:\n        logger.info(f\"Invalid XML message type: {xml_message_type}.\")\n        print(f\"Invalid XML message type: {xml_message_type}.\")\n        sys.exit(1)\n\n    if not os.path.isfile(xml_template_file_path):\n        logger.info(\n            f\"The XML template file '{xml_template_file_path}' does not exist.\"\n        )\n        print(\n            f\"The XML template file '{xml_template_file_path}' does not exist.\"\n        )\n        sys.exit(1)\n\n    if not os.path.isfile(xsd_schema_file_path):\n        logger.info(\n            f\"The XSD template file '{xsd_schema_file_path}' does not exist.\"\n        )\n        print(\n            f\"The XSD template file '{xsd_schema_file_path}' does not exist.\"\n        )\n        sys.exit(1)\n\n    if not os.path.isfile(data_file_path):\n        logger.info(f\"The data file '{data_file_path}' does not exist.\")\n        print(f\"The data file '{data_file_path}' does not exist.\")\n        sys.exit(1)\n\n    process_files(\n        xml_message_type,\n        xml_template_file_path,\n        xsd_schema_file_path,\n        data_file_path,\n    )", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "pain001/__init__.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"The Python pain001 module.\"\"\"\n__all__ = [\"pain001\"]\n__version__ = \"0.0.22\"", "__all__ = [\"pain001\"]\n__version__ = \"0.0.22\"\n"]}
{"filename": "pain001/context/context.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\n\n\nclass Context:\n    \"\"\"A class that can be used to manage logging.\n\n    Methods:\n        __init__(self): Initializes the class and creates a logger.\n        get_instance(): Returns the singleton instance of the class.\n        get_logger(self): Returns the logger.\n        init_logger(self): Initializes the logger.\n        set_log_level(self, log_level): Sets the log level of the logger.\n        set_name(self, name): Sets the name of the logger.\n    \"\"\"\n\n    instance = None\n    name = \"\"\n    log_level = logging.INFO\n    logger = None\n\n    @staticmethod\n    def get_instance():\n        \"\"\"Returns the singleton instance of the class.\n\n        Returns:\n            A Context instance.\n        \"\"\"\n        if Context.instance is None:\n            Context()\n        return Context.instance\n\n    def __init__(self):\n        \"\"\"Initializes the class and creates a logger.\n\n        Raises:\n            Exception: If the class is already initialized.\n        \"\"\"\n        if Context.instance is not None:\n            raise Exception(\"This class is a singleton!\")\n        else:\n            Context.instance = self\n            self.logger = logging.getLogger(self.name)\n            self.logger.setLevel(self.log_level)\n            self.logger.info(\"Context initialized\")\n\n    def set_name(self, name):\n        \"\"\"Sets the name of the logger.\n\n        Args:\n            name: The name of the logger.\n        \"\"\"\n        self.name = name\n\n    def set_log_level(self, log_level):\n        \"\"\"Sets the log level of the logger.\n\n        Args:\n            log_level: The log level of the logger.\n\n        Raises:\n            Exception: If the log level is invalid.\n        \"\"\"\n        valid_log_levels = {\n            \"DEBUG\": logging.DEBUG,\n            \"INFO\": logging.INFO,\n            \"WARNING\": logging.WARNING,\n            \"ERROR\": logging.ERROR,\n            \"CRITICAL\": logging.CRITICAL,\n        }\n\n        if isinstance(\n            log_level, int\n        ):  # Check if log_level is an integer\n            if log_level in valid_log_levels.values():\n                self.log_level = log_level\n            else:\n                raise Exception(\"Invalid log level\")\n        else:\n            log_level = (\n                log_level.strip().upper()\n            )  # Strip and convert to uppercase\n            if log_level in valid_log_levels:\n                self.log_level = valid_log_levels[log_level]\n            else:\n                raise Exception(\"Invalid log level\")\n\n        if self.logger:\n            self.logger.setLevel(self.log_level)\n\n    def init_logger(self):\n        \"\"\"Initializes the logger.\n\n        Raises:\n            Exception: If the logger has already been initialized.\n        \"\"\"\n        if self.logger is not None:\n            raise Exception(\"Logger has already been initialized\")\n\n        self.logger = logging.getLogger(self.name)\n        console_handler = logging.StreamHandler()\n        self.logger.setLevel(self.log_level)\n        log_format = logging.Formatter(\n            \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        )\n        console_handler.setFormatter(log_format)\n        if not self.logger.handlers:\n            self.logger.addHandler(console_handler)\n        self.logger.info(\"Logging initialized\")\n\n    def get_logger(self):\n        \"\"\"Returns the logger.\n\n        Returns:\n            A Logger instance.\n        \"\"\"\n        if self.logger is None:\n            self.init_logger()\n        return self.logger", "\n\nclass Context:\n    \"\"\"A class that can be used to manage logging.\n\n    Methods:\n        __init__(self): Initializes the class and creates a logger.\n        get_instance(): Returns the singleton instance of the class.\n        get_logger(self): Returns the logger.\n        init_logger(self): Initializes the logger.\n        set_log_level(self, log_level): Sets the log level of the logger.\n        set_name(self, name): Sets the name of the logger.\n    \"\"\"\n\n    instance = None\n    name = \"\"\n    log_level = logging.INFO\n    logger = None\n\n    @staticmethod\n    def get_instance():\n        \"\"\"Returns the singleton instance of the class.\n\n        Returns:\n            A Context instance.\n        \"\"\"\n        if Context.instance is None:\n            Context()\n        return Context.instance\n\n    def __init__(self):\n        \"\"\"Initializes the class and creates a logger.\n\n        Raises:\n            Exception: If the class is already initialized.\n        \"\"\"\n        if Context.instance is not None:\n            raise Exception(\"This class is a singleton!\")\n        else:\n            Context.instance = self\n            self.logger = logging.getLogger(self.name)\n            self.logger.setLevel(self.log_level)\n            self.logger.info(\"Context initialized\")\n\n    def set_name(self, name):\n        \"\"\"Sets the name of the logger.\n\n        Args:\n            name: The name of the logger.\n        \"\"\"\n        self.name = name\n\n    def set_log_level(self, log_level):\n        \"\"\"Sets the log level of the logger.\n\n        Args:\n            log_level: The log level of the logger.\n\n        Raises:\n            Exception: If the log level is invalid.\n        \"\"\"\n        valid_log_levels = {\n            \"DEBUG\": logging.DEBUG,\n            \"INFO\": logging.INFO,\n            \"WARNING\": logging.WARNING,\n            \"ERROR\": logging.ERROR,\n            \"CRITICAL\": logging.CRITICAL,\n        }\n\n        if isinstance(\n            log_level, int\n        ):  # Check if log_level is an integer\n            if log_level in valid_log_levels.values():\n                self.log_level = log_level\n            else:\n                raise Exception(\"Invalid log level\")\n        else:\n            log_level = (\n                log_level.strip().upper()\n            )  # Strip and convert to uppercase\n            if log_level in valid_log_levels:\n                self.log_level = valid_log_levels[log_level]\n            else:\n                raise Exception(\"Invalid log level\")\n\n        if self.logger:\n            self.logger.setLevel(self.log_level)\n\n    def init_logger(self):\n        \"\"\"Initializes the logger.\n\n        Raises:\n            Exception: If the logger has already been initialized.\n        \"\"\"\n        if self.logger is not None:\n            raise Exception(\"Logger has already been initialized\")\n\n        self.logger = logging.getLogger(self.name)\n        console_handler = logging.StreamHandler()\n        self.logger.setLevel(self.log_level)\n        log_format = logging.Formatter(\n            \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        )\n        console_handler.setFormatter(log_format)\n        if not self.logger.handlers:\n            self.logger.addHandler(console_handler)\n        self.logger.info(\"Logging initialized\")\n\n    def get_logger(self):\n        \"\"\"Returns the logger.\n\n        Returns:\n            A Logger instance.\n        \"\"\"\n        if self.logger is None:\n            self.init_logger()\n        return self.logger", ""]}
{"filename": "pain001/context/__init__.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"]}
{"filename": "pain001/db/load_db_data.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport sqlite3\nimport os\n", "import os\n\n# Load the SQLite database into a list of dictionaries with the column names as\n# keys\n\n\ndef load_db_data(data_file_path, table_name):\n    if not os.path.exists(data_file_path):\n        raise FileNotFoundError(\n            f\"SQLite file '{data_file_path}' does not exist.\"\n        )\n\n    conn = sqlite3.connect(data_file_path)\n    cursor = conn.cursor()\n\n    # Fetch column names from the table\n    cursor.execute(f\"PRAGMA table_info({table_name})\")\n    columns = [column[1] for column in cursor.fetchall()]\n\n    # Fetch data from the table\n    cursor.execute(f\"SELECT * FROM {table_name}\")\n    rows = cursor.fetchall()\n\n    # Create a list of dictionaries with column names as keys\n    data = []\n    for row in rows:\n        row_dict = {}\n        for i, value in enumerate(row):\n            row_dict[columns[i]] = value\n        data.append(row_dict)\n\n    conn.close()\n\n    return data", ""]}
{"filename": "pain001/db/validate_db_data.py", "chunked_list": ["def validate_db_data(data):\n    \"\"\"Validate the SQLite data before processing it.\n\n    Args:\n        data (list): A list of dictionaries containing the SQLite data.\n\n    Returns:\n        bool: True if the data is valid, False otherwise.\n    \"\"\"\n    required_columns = {\n        \"id\": int,\n        \"date\": str,\n        \"nb_of_txs\": int,\n        \"initiator_name\": str,\n        \"payment_information_id\": str,\n        \"payment_method\": str,\n        \"batch_booking\": bool,\n        \"control_sum\": int,\n        \"service_level_code\": str,\n        \"requested_execution_date\": str,\n        \"debtor_name\": str,\n        \"debtor_account_IBAN\": str,\n        \"debtor_agent_BIC\": str,\n        \"forwarding_agent_BIC\": str,\n        \"charge_bearer\": str,\n        \"payment_id\": str,\n        \"payment_amount\": float,\n        \"currency\": str,\n        \"creditor_agent_BIC\": str,\n        \"creditor_name\": str,\n        \"creditor_account_IBAN\": str,\n        \"remittance_information\": str,\n    }\n\n    for row in data:\n        for column, data_type in required_columns.items():\n            value = row.get(column)\n            if value is None or str(value).strip() == \"\":\n                print(\n                    f\"Error: Missing value for column '{column}' \"\n                    f\"in row: {row}\"\n                )\n                return False\n\n            try:\n                if data_type == int:\n                    int(value)\n                elif data_type == float:\n                    float(value)\n                elif data_type == bool:\n                    if str(value).lower() not in [\"true\", \"false\"]:\n                        raise ValueError\n                else:\n                    str(value)\n            except ValueError:\n                print(\n                    f\"Error: Invalid data type for column '{column}', \"\n                    f\"expected {data_type.__name__} in row: {row}\"\n                )\n                return False\n\n    return True", ""]}
{"filename": "pain001/constants/__init__.py", "chunked_list": [""]}
{"filename": "pain001/constants/constants.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Defines the valid XML types for the ISO 20022 Payment Initiation\n# message types that are supported by the pain001 library.\nvalid_xml_types = [", "# message types that are supported by the pain001 library.\nvalid_xml_types = [\n    \"pain.001.001.03\",  # Customer Credit Transfer Initiation\n    \"pain.001.001.04\",  # Customer Direct Debit Initiation\n    \"pain.001.001.05\",  # Request for Payment Status\n    \"pain.001.001.06\",  # Notification of Payment Status\n    \"pain.001.001.07\",  # Request for Reversal\n    \"pain.001.001.08\",  # Notification of Reversal\n    \"pain.001.001.09\",  # Request for Amendment\n    \"pain.001.001.10\"   # Notification of Amendment", "    \"pain.001.001.09\",  # Request for Amendment\n    \"pain.001.001.10\"   # Notification of Amendment\n    \"pain.001.001.11\"   # Request for Cancellation\n]\n"]}
{"filename": "pain001/core/__init__.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"]}
{"filename": "pain001/core/core.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n#\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Import the standard libraries\nimport sys", "# Import the standard libraries\nimport sys\nimport os\n\n# Import the pain001 library functions\nfrom pain001.constants.constants import valid_xml_types\nfrom pain001.context.context import Context\nfrom pain001.csv.load_csv_data import load_csv_data\nfrom pain001.csv.validate_csv_data import validate_csv_data\nfrom pain001.db.load_db_data import load_db_data", "from pain001.csv.validate_csv_data import validate_csv_data\nfrom pain001.db.load_db_data import load_db_data\nfrom pain001.db.validate_db_data import validate_db_data\nfrom pain001.xml.register_namespaces import register_namespaces\nfrom pain001.xml.xml_generator import xml_generator\n\n\ndef process_files(\n    xml_message_type,\n    xml_template_file_path,\n    xsd_schema_file_path,\n    data_file_path,\n):\n    \"\"\"\n    This function generates an ISO 20022 payment message from a CSV or SQLite\n    file containing the payment data.\n\n    Args:\n        xml_message_type (str): The type of XML message to generate. Valid\n        options are 'pain.001.001.03' and 'pain.001.001.09'.\n        xml_template_file_path (str): The path of the XML template file.\n        xsd_schema_file_path (str): The path of the XSD schema file.\n        data_file_path (str): The path of the CSV or SQLite file containing the\n        payment data.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the XML message type is not supported.\n        FileNotFoundError: If the XML template file does not exist.\n        FileNotFoundError: If the XSD schema file does not exist.\n        FileNotFoundError: If the Data file does not exist.\n    \"\"\"\n\n    # Initialize the context and log a message.\n    logger = Context.get_instance().get_logger()\n\n    # Loop through the payment initiation message types and check if the XML\n    # message type is supported.\n    if xml_message_type not in valid_xml_types:\n        error_message = (\n            f\"Error: Invalid XML message type: '{xml_message_type}'.\"\n        )\n        logger.error(error_message)\n        raise ValueError(error_message)\n\n    # Check if the XML template file exists\n    if not os.path.exists(xml_template_file_path):\n        error_message = (\n            f\"Error: XML template '{xml_template_file_path}' \"\n            f\"does not exist.\"\n        )\n        logger.error(error_message)\n        raise FileNotFoundError(error_message)\n\n    # Check if the XSD schema file exists\n    if not os.path.exists(xsd_schema_file_path):\n        error_message = (\n            f\"Error: XSD schema file '{xsd_schema_file_path}' \"\n            f\"does not exist.\"\n        )\n        logger.error(error_message)\n        raise FileNotFoundError(error_message)\n\n    # Sanitize the path to the data file.\n    data_file_path = os.path.normpath(data_file_path)\n\n    # Check if the data file exists\n    if not os.path.exists(data_file_path):\n        error_message = (\n            f\"Error: Data file '{data_file_path}' does not exist.\"\n        )\n        logger.error(error_message)\n        raise FileNotFoundError(error_message)\n\n    # Define mapping dictionary between XML element tags and CSV column names\n    mapping = {\n        \"MsgId\": \"id\",\n        \"CreDtTm\": \"date\",\n        \"NbOfTxs\": \"nb_of_txs\",\n        \"Nm\": \"initiator_name\",\n        \"PmtInfId\": \"payment_information_id\",\n        \"PmtMtd\": \"payment_method\",\n    }\n\n    # Determine the type of data file (CSV or SQLite)\n    is_csv = data_file_path.endswith(\".csv\")\n    is_sqlite = data_file_path.endswith(\".db\")\n\n    # Load data into a list of dictionaries based on the file type\n    if is_csv:\n        data = load_csv_data(data_file_path)\n        if not validate_csv_data(data):\n            error_message = \"Error: Invalid CSV data.\"\n            logger.error(error_message)\n            raise ValueError(error_message)\n    elif is_sqlite:\n        data = load_db_data(data_file_path, table_name=\"pain001\")\n        if not validate_db_data(data):\n            error_message = \"Error: Invalid SQLite data.\"\n            logger.error(error_message)\n            raise ValueError(error_message)\n    else:\n        error_message = \"Error: Unsupported data file type.\"\n        logger.error(error_message)\n        raise ValueError(error_message)\n\n    # Register the namespace prefixes and URIs for the XML message type\n    register_namespaces(xml_message_type)\n\n    # Generate the updated XML file path\n    xml_generator(\n        data,\n        mapping,\n        xml_message_type,\n        xml_template_file_path,\n        xsd_schema_file_path,\n    )\n\n    # Confirm the XML file has been created\n    if os.path.exists(xml_template_file_path):\n        logger.info(\n            f\"Successfully generated XML file '{xml_template_file_path}'\"\n        )\n    else:\n        logger.error(\n            f\"Failed to generate XML file at '{xml_template_file_path}'\"\n        )", "\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 5:\n        print(\n            \"Usage: python3 -m pain001 \"\n            + \" \".join(\n                [\n                    \"<xml_message_type>\",\n                    \"<xml_template_file_path>\",\n                    \"<xsd_schema_file_path>\",\n                    \"<data_file_path>\",\n                ]\n            )\n        )\n\n        sys.exit(1)\n    process_files(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4])", ""]}
{"filename": "pain001/xml/generate_xml.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Import the XML libraries\nimport xml.etree.ElementTree as ET\n", "import xml.etree.ElementTree as ET\n\n# Import the datetime library\nfrom datetime import datetime\n\n# Import the functions from the other modules\nfrom .create_xml_element import create_xml_element\n\n\ndef create_common_elements(parent, row, mapping):\n    \"\"\"Create common elements \"PmtInfId\" and \"PmtMtd\" in the XML tree using\n    data from the CSV or SQLite Data Files.\n\n    Parameters\n    ----------\n    parent : xml.etree.ElementTree.Element\n        Parent element in the XML tree.\n    row : list\n        List of strings, each string is a row of the Data file.\n    mapping : dict\n        Dictionary with the mapping between XML tags and Data columns.\n    \"\"\"\n\n    for xml_tag, csv_column in mapping.items():\n        if xml_tag in [\"PmtInfId\", \"PmtMtd\"]:\n            create_xml_element(parent, xml_tag, row[csv_column])", "\ndef create_common_elements(parent, row, mapping):\n    \"\"\"Create common elements \"PmtInfId\" and \"PmtMtd\" in the XML tree using\n    data from the CSV or SQLite Data Files.\n\n    Parameters\n    ----------\n    parent : xml.etree.ElementTree.Element\n        Parent element in the XML tree.\n    row : list\n        List of strings, each string is a row of the Data file.\n    mapping : dict\n        Dictionary with the mapping between XML tags and Data columns.\n    \"\"\"\n\n    for xml_tag, csv_column in mapping.items():\n        if xml_tag in [\"PmtInfId\", \"PmtMtd\"]:\n            create_xml_element(parent, xml_tag, row[csv_column])", "\n\ndef create_xml_v3(root, data, mapping):\n    \"\"\"Create the XML tree for the pain.001.001.03 schema.\n\n    Args:\n        root (ElementTree.Element): The root element of the XML tree.\n        data (list): A list of dictionaries containing the data to be added\n        to the XML document.\n        mapping (dict): A dictionary mapping the Data column names to the XML\n        element names.\n\n    Returns:\n        The root element of the XML tree.\n    \"\"\"\n\n    # Create CstmrCdtTrfInitn element\n    cstmr_cdt_trf_initn_element = ET.Element(\"CstmrCdtTrfInitn\")\n    root.append(cstmr_cdt_trf_initn_element)\n\n    # Create GrpHdr element and append it to CstmrCdtTrfInitn\n    GrpHdr_element = ET.Element(\"GrpHdr\")\n    cstmr_cdt_trf_initn_element.append(GrpHdr_element)\n\n    # Add the MsgId, CreDtTm, and NbOfTxs elements to the GrpHdr element\n    for xml_tag, csv_column in mapping.items():\n        if xml_tag in [\"MsgId\"]:\n            create_xml_element(\n                GrpHdr_element, xml_tag, data[0][csv_column]\n            )\n\n    # Calculate CreDtTm\n    time_and_date_str = str(datetime.now())\n    CreDtTm_value = time_and_date_str[0:10] + \"T\" + time_and_date_str[11:19]\n    # Add CreDtTm Element in the XML tree\n    create_xml_element(GrpHdr_element, \"CreDtTm\", CreDtTm_value)\n\n    # Calculate NbOfTxs\n    NbOfTxs = 0\n    for row in data:\n        NbOfTxs = NbOfTxs + 1\n    # Add NbOfTxs to the XML tree\n    create_xml_element(GrpHdr_element, \"NbOfTxs\", str(NbOfTxs))\n\n    # Calculate CtrlSum Element from the CSV file\n    totalSum = 0\n    for row in data:\n        totalSum += float(row[\"payment_amount\"])\n    # Add CtrlSum Element in the XML tree\n    create_xml_element(GrpHdr_element, \"CtrlSum\", str(round(totalSum, 2)))\n\n    # Create new \"InitgPty\" element in the XML tree using data from the\n    # CSV file\n    InitgPty_element = ET.Element(\"InitgPty\")\n    create_xml_element(\n        InitgPty_element, \"Nm\", data[0][\"initiator_name\"]\n    )\n    GrpHdr_element.append(InitgPty_element)\n\n    for row in data:\n        # Create new \"PmtInf\" element in the XML tree using data from\n        # the CSV file\n        PmtInf_element = ET.Element(\"PmtInf\")\n\n        create_common_elements(PmtInf_element, row, mapping)\n\n        # Create new \"BtchBookg\" element in the XML tree using data\n        # from the Data file\n        create_xml_element(\n            PmtInf_element, \"BtchBookg\", row[\"batch_booking\"].lower()\n        )\n\n        # Create new \"NbOfTxs\" element in the XML tree using data from\n        # the Data file\n        # create_xml_element(PmtInf_element, \"NbOfTxs\", row[\"nb_of_txs\"])\n\n        # Create new \"CtrlSum\" element in the XML tree using data from\n        # the Data file\n        # create_xml_element(\n        # PmtInf_element, \"CtrlSum\", f\"{row['control_sum']}\")\n\n        # Create new \"PmtTpInf\" element in the XML tree using data from\n        # the Data file\n        PmtTpInf_element = ET.Element(\"PmtTpInf\")\n        child_element = ET.Element(\"SvcLvl\")\n        child_element2 = ET.Element(\"Cd\")\n        child_element2.text = row[\"service_level_code\"]\n        child_element.append(child_element2)\n        PmtTpInf_element.append(child_element)\n        PmtInf_element.append(PmtTpInf_element)\n\n        # Create new \"ReqdExctnDt\" element in the XML tree using data\n        # from the Data file\n        create_xml_element(\n            PmtInf_element,\n            \"ReqdExctnDt\",\n            row[\"requested_execution_date\"],\n        )\n\n        # Create new \"Dbtr\" element in the XML tree using data from\n        # the Data file\n        Dbtr_element = ET.Element(\"Dbtr\")\n        child_element = ET.Element(\"Nm\")\n        child_element.text = row[\"debtor_name\"]\n        Dbtr_element.append(child_element)\n        PmtInf_element.append(Dbtr_element)\n\n        # Create new \"DbtrAcct\" element in the XML tree using data\n        # from the Data file\n        DbtrAcct_element = ET.Element(\"DbtrAcct\")\n        child_element = ET.Element(\"Id\")\n        child_element2 = ET.Element(\"IBAN\")\n        # replace with the appropriate value\n        child_element2.text = row[\"debtor_account_IBAN\"]\n        child_element.append(child_element2)\n        # Create CCy Element\n        CCy_element = ET.Element(\"Ccy\")\n        CCy_element.text = row[\"currency\"]\n        # Add Both Elements to Parents\n        DbtrAcct_element.append(child_element)\n        DbtrAcct_element.append(CCy_element)\n        PmtInf_element.append(DbtrAcct_element)\n\n        # Create new \"DbtrAgt\" element in the XML tree using data\n        # from the Data file\n        DbtrAgt_element = ET.Element(\"DbtrAgt\")\n        child_element = ET.Element(\"FinInstnId\")\n        child_element2 = ET.Element(\"BIC\")\n        # replace with the appropriate value\n        child_element2.text = row[\"debtor_agent_BIC\"]\n        child_element.append(child_element2)\n        DbtrAgt_element.append(child_element)\n        PmtInf_element.append(DbtrAgt_element)\n\n        # Create new \"CdtTrfTxInf\" element in the XML tree using data\n        # from the Data file\n        CdtTrfTxInf_element = ET.Element(\"CdtTrfTxInf\")\n\n        # Create new \"PmtId\" element in the XML tree using data\n        # from the Data file\n        PmtId_element = ET.Element(\"PmtId\")\n        InstrId_element = ET.Element(\"InstrId\")\n        child_element = ET.Element(\"EndToEndId\")\n        InstrId_element.text = row[\"payment_id\"]\n        child_element.text = row[\"payment_id\"]\n        PmtId_element.append(InstrId_element)\n        PmtId_element.append(child_element)\n        CdtTrfTxInf_element.append(PmtId_element)\n\n        # Create new \"Amt\" element in the XML tree using data\n        # from the Data file\n        Amt_element = ET.Element(\"Amt\")\n        child_element = ET.Element(\"InstdAmt\")\n        child_element.text = row[\"payment_amount\"]\n        child_element.set(\"Ccy\", row[\"currency\"])\n        Amt_element.append(child_element)\n        CdtTrfTxInf_element.append(Amt_element)\n\n        # Create new \"ChrgBr\" element in the XML tree using data\n        # from the Data file\n        ChrgBr_element = ET.Element(\"ChrgBr\")\n        # replace with the appropriate value\n        ChrgBr_element.text = row[\"charge_bearer\"]\n        PmtInf_element.append(ChrgBr_element)\n\n        # Create new \"CdtrAgt\" element in the XML tree using data\n        # from the Data file\n        CdtrAgt_element = ET.Element(\"CdtrAgt\")\n        child_element = ET.Element(\"FinInstnId\")\n        child_element2 = ET.Element(\"BIC\")\n        child_element2.text = row[\"creditor_agent_BIC\"]\n        child_element.append(child_element2)\n        CdtrAgt_element.append(child_element)\n        CdtTrfTxInf_element.append(CdtrAgt_element)\n\n        # Create new \"Cdtr\" element in the XML tree using data\n        # from the Data file\n        Cdtr_element = ET.Element(\"Cdtr\")\n        child_element = ET.Element(\"Nm\")\n        child_element.text = row[\"creditor_name\"]\n        Cdtr_element.append(child_element)\n        CdtTrfTxInf_element.append(Cdtr_element)\n\n        # Create new \"CdtrAcct\" element in the XML tree using data\n        # from the CSV file\n        CdtrAcct_element = ET.Element(\"CdtrAcct\")\n        Id_element = ET.Element(\"Id\")\n        IBAN_element = ET.Element(\"IBAN\")\n        IBAN_element.text = row[\"creditor_account_IBAN\"]\n        Id_element.append(IBAN_element)\n        CdtrAcct_element.append(Id_element)\n        CdtTrfTxInf_element.append(CdtrAcct_element)\n\n        # Create new \"RmtInf\" element in the XML tree using data\n        # from the Data file\n        RmtInf_element = ET.Element(\"RmtInf\")\n        child_element = ET.Element(\"Ustrd\")\n        child_element.text = row[\"remittance_information\"]\n        RmtInf_element.append(child_element)\n        CdtTrfTxInf_element.append(RmtInf_element)\n\n        # Append the new CdtTrfTxInf element to the PmtInf element\n        PmtInf_element.append(CdtTrfTxInf_element)\n\n        # Append the new PmtInf element to the CstmrCdtTrfInitn element\n        cstmr_cdt_trf_initn_element.append(PmtInf_element)", "\n\ndef create_xml_v4(root, data, mapping):\n    \"\"\"Creates an XML document for the pain.001.001.04 format.\n\n    Args:\n        root: The root element of the XML document.\n        data: A list of dictionaries containing the payment data.\n        mapping: A dictionary that maps XML element names to Data column names.\n\n    Returns:\n        The root element of the XML document.\n    \"\"\"\n\n    # Create new \"CstmrCdtTrfInitn\" element in the XML tree\n    cstmr_cdt_trf_initn_element = ET.Element(\"CstmrCdtTrfInitn\")\n    root.append(cstmr_cdt_trf_initn_element)\n\n    # Create new \"GrpHdr\" element in the XML tree\n    GrpHdr_element = ET.Element(\"GrpHdr\")\n    cstmr_cdt_trf_initn_element.append(GrpHdr_element)\n\n    # Loop through the first row of the Data file and create new\n    # \"MsgId\", \"CreDtTm\" and \"NbOfTxs\" elements in the XML tree\n    for xml_tag, csv_column in mapping.items():\n        if xml_tag in [\"MsgId\", \"CreDtTm\", \"NbOfTxs\"]:\n            create_xml_element(\n                GrpHdr_element, xml_tag, data[0][csv_column]\n            )\n    # Create new \"InitgPty\" element in the XML tree using data\n    InitgPty_element = ET.Element(\"InitgPty\")\n    create_xml_element(\n        InitgPty_element, \"Nm\", data[0][\"initiator_name\"]\n    )\n    GrpHdr_element.append(InitgPty_element)\n\n    # Loop through the Data file and create new \"PmtInf\" elements\n    for row in data:\n        PmtInf_element = ET.Element(\"PmtInf\")\n        cstmr_cdt_trf_initn_element.append(PmtInf_element)\n\n        create_common_elements(PmtInf_element, row, mapping)\n\n        create_xml_element(\n            PmtInf_element, \"BtchBookg\", row[\"batch_booking\"].lower()\n        )\n\n        create_xml_element(PmtInf_element, \"NbOfTxs\", row[\"nb_of_txs\"])\n\n        create_xml_element(\n            PmtInf_element, \"CtrlSum\", f\"{row['control_sum']}\"\n        )\n\n        PmtTpInf_element = ET.Element(\"PmtTpInf\")\n        SvcLvl_element = ET.Element(\"SvcLvl\")\n        Cd_element = ET.Element(\"Cd\")\n        Cd_element.text = row[\"service_level_code\"]\n        SvcLvl_element.append(Cd_element)\n        PmtTpInf_element.append(SvcLvl_element)\n        PmtInf_element.append(PmtTpInf_element)\n\n        create_xml_element(\n            PmtInf_element,\n            \"ReqdExctnDt\",\n            row[\"requested_execution_date\"],\n        )\n\n        Dbtr_element = ET.Element(\"Dbtr\")\n        Nm_element = ET.Element(\"Nm\")\n        Nm_element.text = row[\"debtor_name\"]\n        Dbtr_element.append(Nm_element)\n        PmtInf_element.append(Dbtr_element)\n\n        DbtrAcct_element = ET.Element(\"DbtrAcct\")\n        Id_element = ET.Element(\"Id\")\n        IBAN_element = ET.Element(\"IBAN\")\n        IBAN_element.text = row[\"debtor_account_IBAN\"]\n        Id_element.append(IBAN_element)\n        DbtrAcct_element.append(Id_element)\n        PmtInf_element.append(DbtrAcct_element)\n\n        DbtrAgt_element = ET.Element(\"DbtrAgt\")\n        FinInstnId_element = ET.Element(\"FinInstnId\")\n        BIC_element = ET.Element(\"BICFI\")\n        BIC_element.text = row[\"debtor_agent_BIC\"]\n        FinInstnId_element.append(BIC_element)\n        DbtrAgt_element.append(FinInstnId_element)\n        PmtInf_element.append(DbtrAgt_element)\n\n        CdtTrfTxInf_element = ET.Element(\"CdtTrfTxInf\")\n\n        PmtId_element = ET.Element(\"PmtId\")\n        EndToEndId_element = ET.Element(\"EndToEndId\")\n        EndToEndId_element.text = row[\"payment_id\"]\n        PmtId_element.append(EndToEndId_element)\n        CdtTrfTxInf_element.append(PmtId_element)\n\n        Amt_element = ET.Element(\"Amt\")\n        InstdAmt_element = ET.Element(\"InstdAmt\")\n        InstdAmt_element.text = row[\"payment_amount\"]\n        InstdAmt_element.set(\"Ccy\", row[\"currency\"])\n        Amt_element.append(InstdAmt_element)\n        CdtTrfTxInf_element.append(Amt_element)\n\n        CdtrAgt_element = ET.Element(\"CdtrAgt\")\n        FinInstnId_element = ET.Element(\"FinInstnId\")\n        BIC_element = ET.Element(\"BICFI\")\n        BIC_element.text = row[\"creditor_agent_BIC\"]\n        FinInstnId_element.append(BIC_element)\n        CdtrAgt_element.append(FinInstnId_element)\n        CdtTrfTxInf_element.append(CdtrAgt_element)\n\n        Cdtr_element = ET.Element(\"Cdtr\")\n        Nm_element = ET.Element(\"Nm\")\n        Nm_element.text = row[\"creditor_name\"]\n        Cdtr_element.append(Nm_element)\n        CdtTrfTxInf_element.append(Cdtr_element)\n\n        CdtrAcct_element = ET.Element(\"CdtrAcct\")\n        Id_element = ET.Element(\"Id\")\n        IBAN_element = ET.Element(\"IBAN\")\n        IBAN_element.text = row[\"creditor_account_IBAN\"]\n        Id_element.append(IBAN_element)\n        CdtrAcct_element.append(Id_element)\n        CdtTrfTxInf_element.append(CdtrAcct_element)\n\n        RmtInf_element = ET.Element(\"RmtInf\")\n        Ustrd_element = ET.Element(\"Ustrd\")\n        Ustrd_element.text = row[\"remittance_information\"]\n        RmtInf_element.append(Ustrd_element)\n        CdtTrfTxInf_element.append(RmtInf_element)\n\n        PmtInf_element.append(CdtTrfTxInf_element)", "\n\ndef create_xml_v9(root, data, mapping):\n    \"\"\"Creates an XML document for the pain.001.001.09 schema.\n\n    Args:\n        root (ElementTree.Element): The root element of the XML tree.\n        data (list): A list of dictionaries containing the data to be added\n        to the XML document.\n        mapping (dict): A dictionary mapping the Data column names to the XML\n        element names.\n\n    Returns:\n        The root element of the XML tree.\n    \"\"\"\n\n    # Create CstmrCdtTrfInitn element\n    cstmr_cdt_trf_initn_element = ET.Element(\"CstmrCdtTrfInitn\")\n    root.append(cstmr_cdt_trf_initn_element)\n\n    # Create GrpHdr element and append it to CstmrCdtTrfInitn\n    GrpHdr_element = ET.Element(\"GrpHdr\")\n    cstmr_cdt_trf_initn_element.append(GrpHdr_element)\n\n    # Add the MsgId, CreDtTm, and NbOfTxs elements to the GrpHdr element\n    for xml_tag, csv_column in mapping.items():\n        if xml_tag in [\"MsgId\", \"CreDtTm\", \"NbOfTxs\"]:\n            create_xml_element(\n                GrpHdr_element, xml_tag, data[0][csv_column]\n            )\n\n    # Create new \"InitgPty\" element in the XML tree using data from the\n    # Data file\n    InitgPty_element = ET.Element(\"InitgPty\")\n    create_xml_element(\n        InitgPty_element, \"Nm\", data[0][\"initiator_name\"]\n    )\n    GrpHdr_element.append(InitgPty_element)\n\n    for row in data:\n        # Create new \"PmtInf\" element in the XML tree using data from\n        # the Data file\n        PmtInf_element = ET.Element(\"PmtInf\")\n        cstmr_cdt_trf_initn_element.append(PmtInf_element)\n\n        create_common_elements(PmtInf_element, row, mapping)\n\n        Dbtr_element = ET.Element(\"ReqdExctnDt\")\n        child_element = ET.Element(\"Dt\")\n        child_element.text = row[\"requested_execution_date\"]\n        Dbtr_element.append(child_element)\n        PmtInf_element.append(Dbtr_element)\n\n        # Create new \"Dbtr\" element in the XML tree using data from\n        # the Data file\n        Dbtr_element = ET.Element(\"Dbtr\")\n        child_element = ET.Element(\"Nm\")\n        child_element.text = row[\"debtor_name\"]\n        Dbtr_element.append(child_element)\n        PmtInf_element.append(Dbtr_element)\n\n        # Create new \"DbtrAcct\" element in the XML tree using data\n        # from the Data file\n        DbtrAcct_element = ET.Element(\"DbtrAcct\")\n        child_element = ET.Element(\"Id\")\n        child_element2 = ET.Element(\"IBAN\")\n        # replace with the appropriate value\n        child_element2.text = row[\"debtor_account_IBAN\"]\n        child_element.append(child_element2)\n        DbtrAcct_element.append(child_element)\n        PmtInf_element.append(DbtrAcct_element)\n\n        # Create new \"DbtrAgt\" element in the XML tree using data\n        # from the Data file\n        DbtrAgt_element = ET.Element(\"DbtrAgt\")\n        child_element = ET.Element(\"FinInstnId\")\n        child_element2 = ET.Element(\"BICFI\")\n        # replace with the appropriate value\n        child_element2.text = row[\"debtor_agent_BIC\"]\n        child_element2.set(\n            \"xmlns\", \"urn:iso:std:iso:20022:tech:xsd:pain.001.001.09\"\n        )\n        child_element.append(child_element2)\n        DbtrAgt_element.append(child_element)\n        PmtInf_element.append(DbtrAgt_element)\n\n        # Create new \"ChrgBr\" element in the XML tree using data\n        # from the Data file\n        child_element = ET.Element(\"ChrgBr\")\n        # replace with the appropriate value\n        child_element.text = row[\"charge_bearer\"]\n        PmtInf_element.append(child_element)\n\n        # Create new \"CdtTrfTxInf\" element in the XML tree using data\n        # from the Data file\n        CdtTrfTxInf_element = ET.Element(\"CdtTrfTxInf\")\n\n        # Create new \"PmtId\" element in the XML tree using data\n        # from the Data file\n        PmtId_element = ET.Element(\"PmtId\")\n        child_element = ET.Element(\"EndToEndId\")\n        child_element.text = row[\"payment_id\"]\n        PmtId_element.append(child_element)\n        CdtTrfTxInf_element.append(PmtId_element)\n\n        # Create new \"Amt\" element in the XML tree using data\n        # from the Data file\n        Amt_element = ET.Element(\"Amt\")\n        child_element = ET.Element(\"InstdAmt\")\n        child_element.text = row[\"payment_amount\"]\n        child_element.set(\"Ccy\", row[\"currency\"])\n        Amt_element.append(child_element)\n        CdtTrfTxInf_element.append(Amt_element)\n\n        # Create new \"CdtrAgt\" element in the XML tree using data\n        # from the Data file\n        CdtrAgt_element = ET.Element(\"CdtrAgt\")\n        child_element = ET.Element(\"FinInstnId\")\n        child_element2 = ET.Element(\"BICFI\")\n        # replace with the appropriate value\n        child_element2.text = row[\"creditor_agent_BIC\"]\n        child_element2.set(\n            \"xmlns\", \"urn:iso:std:iso:20022:tech:xsd:pain.001.001.09\"\n        )\n        child_element.append(child_element2)\n        CdtrAgt_element.append(child_element)\n        CdtTrfTxInf_element.append(CdtrAgt_element)\n\n        # Create new \"Cdtr\" element in the XML tree using data\n        # from the Data file\n        Cdtr_element = ET.Element(\"Cdtr\")\n        child_element = ET.Element(\"Nm\")\n        child_element.text = row[\"creditor_name\"]\n        Cdtr_element.append(child_element)\n        CdtTrfTxInf_element.append(Cdtr_element)\n\n        # Create new \"CdtrAcct\" element in the XML tree using data\n        # from the CSV file\n        CdtrAcct_element = ET.Element(\"CdtrAcct\")\n        child_element = ET.Element(\"Id\")\n        child_element2 = ET.Element(\"IBAN\")\n        child_element2.text = row[\"creditor_agent_BIC\"]\n        child_element.append(child_element2)\n        CdtrAcct_element.append(child_element)\n        CdtTrfTxInf_element.append(CdtrAcct_element)\n\n        # Create new \"RmtInf\" element in the XML tree using data\n        # from the Data file\n        RmtInf_element = ET.Element(\"RmtInf\")\n        child_element = ET.Element(\"Ustrd\")\n        child_element.text = row[\"remittance_information\"]\n        RmtInf_element.append(child_element)\n        CdtTrfTxInf_element.append(RmtInf_element)\n\n        # Append the new CdtTrfTxInf element to the PmtInf element\n        PmtInf_element.append(CdtTrfTxInf_element)\n\n        # Append the new PmtInf element to the CstmrCdtTrfInitn element\n        cstmr_cdt_trf_initn_element.append(PmtInf_element)\n\n        # Create new \"SplmtryData\" elements in the XML tree using data\n        # from the Data file\"\n        # Create the main elements\n        SplmtryData_element = ET.Element(\"SplmtryData\")\n        Envlp_element = ET.SubElement(SplmtryData_element, \"Envlp\")\n        child_element = ET.SubElement(Envlp_element, \"WC\")\n        CdtTrfTxInf_element.append(SplmtryData_element)", ""]}
{"filename": "pain001/xml/validate_via_xsd.py", "chunked_list": ["import xmlschema\n\n# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#", "# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport defusedxml.ElementTree as ET", "\nimport defusedxml.ElementTree as ET\n\n\ndef validate_via_xsd(xml_file_path, xsd_file_path):\n    \"\"\"\n    Validates an XML file against an XSD schema.\n\n    Args:\n        xml_file_path (str): Path to the XML file to validate.\n        xsd_file_path (str): Path to the XSD schema file.\n\n    Returns:\n        bool: True if the XML file is valid, False otherwise.\n    \"\"\"\n\n    # Load XML file into an ElementTree object.\n    try:\n        xml_tree = ET.parse(xml_file_path)\n    except Exception as e:\n        print(f\"Error: {e}\")\n        return False\n\n    # Load XSD schema into an XMLSchema object.\n    xsd = xmlschema.XMLSchema(xsd_file_path)\n\n    # Validate XML file against XSD schema.\n    try:\n        is_valid = xsd.is_valid(xml_tree)\n    except Exception as e:\n        print(f\"Error: {e}\")\n        return False\n\n    # Return True if XML file is valid, False otherwise.\n    return is_valid", ""]}
{"filename": "pain001/xml/create_root_element.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport xml.etree.ElementTree as ET\n\n# Create the root element and set its attributes (XML tags and CSV", "\n# Create the root element and set its attributes (XML tags and CSV\n# columns mapping)\n\n\ndef create_root_element(payment_initiation_message_type):\n    # Create the namespace for the payment initiation message type.\n    namespace = (\n        \"urn:iso:std:iso:20022:tech:xsd:\"\n        + payment_initiation_message_type\n    )\n\n    # Create the root element.\n    root = ET.Element(\"Document\")\n    root.set(\"xmlns\", namespace)\n    root.set(\"xmlns:xsi\", \"http://www.w3.org/2001/XMLSchema-instance\")\n\n    # Set the schema location.\n    schema_location = (\n        namespace + \" \" + payment_initiation_message_type + \".xsd\"\n    )\n    root.set(\"xsi:schemaLocation\", schema_location)\n\n    for elem in root.iter():\n        elem.tag = elem.tag.split(\"}\", 1)[-1]\n\n    return root", ""]}
{"filename": "pain001/xml/xml_generator.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# XML generator function that creates the XML file from the CSV data\n# and the mapping dictionary between XML tags and CSV columns names and\n# writes it to a file in the same directory as the CSV file", "# and the mapping dictionary between XML tags and CSV columns names and\n# writes it to a file in the same directory as the CSV file\n\n\nimport sys\nfrom pain001.xml.create_root_element import create_root_element\nfrom pain001.xml.generate_updated_xml_file_path import (\n    generate_updated_xml_file_path,\n)\nfrom pain001.xml.generate_xml import (", ")\nfrom pain001.xml.generate_xml import (\n    create_xml_v3,\n    create_xml_v4,\n    create_xml_v9,\n)\n\nfrom pain001.xml.validate_via_xsd import validate_via_xsd\nfrom pain001.xml.write_xml_to_file import write_xml_to_file\n", "from pain001.xml.write_xml_to_file import write_xml_to_file\n\n\ndef xml_generator(\n    data,\n    mapping,\n    payment_initiation_message_type,\n    xml_file_path,\n    xsd_file_path,\n):\n    # Create the root element and set its attributes\n    root = create_root_element(payment_initiation_message_type)\n\n    # Define a mapping between the XML types and the XML generators\n    xml_generators = {\n        \"pain.001.001.03\": create_xml_v3,\n        \"pain.001.001.04\": create_xml_v4,\n        \"pain.001.001.09\": create_xml_v9,\n    }\n\n    # Check if the provided payment_initiation_message_type exists in\n    # the mapping\n    if payment_initiation_message_type in xml_generators:\n        # Get the corresponding XML generation function for the XML type\n        xml_generator = xml_generators[payment_initiation_message_type]\n\n        # Check if data is not empty\n        if not data:\n            print(\"Error: No data to process.\")\n            sys.exit(1)\n\n        # Generate the XML file for the XML type and set its attributes\n        xml_generator(\n            root, data, mapping\n        )  # Pass root, data, and mapping as arguments to the xml_generator\n\n        # Generate updated XML file path\n        updated_xml_file_path = generate_updated_xml_file_path(\n            xml_file_path, payment_initiation_message_type\n        )\n\n        # Write the updated XML tree to a file\n        write_xml_to_file(updated_xml_file_path, root)\n\n        print(\n            f\"A new XML file has been created at {updated_xml_file_path}\"\n        )\n\n        print(updated_xml_file_path)\n\n        # Validate the updated XML file against the XSD schema\n        is_valid = validate_via_xsd(\n            updated_xml_file_path, xsd_file_path\n        )\n        if not is_valid:\n            print(\"Error: Invalid XML data.\")\n            sys.exit(1)\n        else:\n            print(f\"The XML has been validated against {xsd_file_path}\")\n    else:\n        # Handle the case when the payment_initiation_message_type is\n        # not valid\n        print(\n            \"Error: Invalid XML message type:\",\n            payment_initiation_message_type,\n        )\n        sys.exit(1)", ""]}
{"filename": "pain001/xml/write_xml_to_file.py", "chunked_list": ["import xml.etree.ElementTree as ET\n\n# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#", "# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom defusedxml.minidom import parseString", "\nfrom defusedxml.minidom import parseString\n\n# Write XML to file with pretty formatting (indentation)\n\n\ndef write_xml_to_file(xml_file_path, root):\n    with open(xml_file_path, \"w\") as f:\n        xml_string = ET.tostring(root, encoding=\"utf-8\")\n        xml_declaration = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n        xml_string = xml_declaration + xml_string.decode(\"utf-8\")\n\n        dom = parseString(xml_string)\n        f.write(dom.toprettyxml())", ""]}
{"filename": "pain001/xml/register_namespaces.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport xml.etree.ElementTree as ET\n\n# Register the namespace prefixes with the ElementTree module so that", "\n# Register the namespace prefixes with the ElementTree module so that\n# they are automatically added to the XML tags when the XML elements\n# are created (XML tags and CSV columns mapping)\n\n\ndef register_namespaces(payment_initiation_message_type):\n    \"\"\"This function registers the namespaces for the payment initiation\n    message type.\n\n    Args:\n        payment_initiation_message_type (str):\n        The payment initiation message type.\n\n    Returns:\n        None.\n    \"\"\"\n\n    # Create the namespace for the payment initiation message type.\n    namespace = (\n        \"urn:iso:std:iso:20022:tech:xsd:\"\n        + payment_initiation_message_type\n    )\n\n    # Register the namespaces.\n    ET.register_namespace(\"\", namespace)\n    ET.register_namespace(\n        \"xsi\", \"http://www.w3.org/2001/XMLSchema-instance\"\n    )", ""]}
{"filename": "pain001/xml/create_xml_element.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport xml.etree.ElementTree as ET\n\n# Create an XML element with the specified tag, text, and attributes,", "\n# Create an XML element with the specified tag, text, and attributes,\n# and append it to the given parent element (XML tags and CSV columns\n# mapping)\n\n\ndef create_xml_element(parent, tag, text=None, attributes=None):\n    \"\"\"\n    Create an XML element with the specified tag, text, and\n    attributes, and append it to the given parent element.\n\n    Args:\n        parent (Element): The parent element to append the new element\n        to.\n        tag (str): The tag name of the new element.\n        text (str, optional): The text content of the new element.\n        attributes (dict, optional): A dictionary of attribute names\n        and values for the new element.\n\n    Returns:\n        Element: The created XML element.\n    \"\"\"\n    element = ET.Element(tag)\n    if text is not None:\n        element.text = text\n    if attributes is not None:\n        for key, value in attributes.items():\n            element.set(key, value)\n    parent.append(element)\n    return element", ""]}
{"filename": "pain001/xml/generate_updated_xml_file_path.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\n\n# Generate the path to the updated XML file based on the path to the", "\n# Generate the path to the updated XML file based on the path to the\n# original XML file\n\n\ndef generate_updated_xml_file_path(\n    xml_file_path, payment_initiation_message_type\n):\n    # print(os.path.splitext(xml_file_path)[0])\n    base_directory = os.path.dirname(xml_file_path)\n    base_name = os.path.basename(xml_file_path)\n    file_name, _ = os.path.splitext(base_name)\n\n    new_file_name = payment_initiation_message_type + \".xml\"\n    new_file_path = os.path.join(base_directory, new_file_name)\n\n    return new_file_path", ""]}
{"filename": "pain001/csv/validate_csv_data.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Validate the CSV data before processing it. The CSV data must contain\n# the following columns:\n#", "# the following columns:\n#\n# - id (int) - unique identifier\n# - date (str) - date of the payment\n# - nb_of_txs (int) - number of transactions\n# - initiator_name (str) - name of the initiator\n# - payment_information_id (str) - payment information identifier\n# - payment_method (str) - payment method\n# - batch_booking (bool) - batch booking\n# - control_sum (int) - control sum", "# - batch_booking (bool) - batch booking\n# - control_sum (int) - control sum\n# - service_level_code (str) - service level code\n# - requested_execution_date (str) - requested execution date\n# - debtor_name (str) - debtor name\n# - debtor_account_IBAN (str) - debtor account IBAN\n# - debtor_agent_BIC (str) - debtor agent BIC\n# - forwarding_agent_BIC (str) - forwarding agent BIC\n# - charge_bearer (str) - charge bearer\n# - payment_id (str) - payment identifier", "# - charge_bearer (str) - charge bearer\n# - payment_id (str) - payment identifier\n# - payment_amount (str) - payment amount\n# - currency (str) - currency\n# - creditor_agent_BIC (str) - creditor agent BIC\n# - creditor_name (str) - creditor name\n# - creditor_account_IBAN (str) - creditor account IBAN\n# - remittance_information (str) - remittance information\n\n\ndef validate_csv_data(data):\n    \"\"\"Validate the CSV data before processing it.\n\n    Args:\n        data (list): A list of dictionaries containing the CSV data.\n\n    Returns:\n        bool: True if the data is valid, False otherwise.\n    \"\"\"\n    required_columns = {\n        \"id\": int,\n        \"date\": str,\n        \"nb_of_txs\": int,\n        \"initiator_name\": str,\n        \"payment_information_id\": str,\n        \"payment_method\": str,\n        \"batch_booking\": bool,\n        \"control_sum\": int,\n        \"service_level_code\": str,\n        \"requested_execution_date\": str,\n        \"debtor_name\": str,\n        \"debtor_account_IBAN\": str,\n        \"debtor_agent_BIC\": str,\n        \"forwarding_agent_BIC\": str,\n        \"charge_bearer\": str,\n        \"payment_id\": str,\n        \"payment_amount\": float,\n        \"currency\": str,\n        \"creditor_agent_BIC\": str,\n        \"creditor_name\": str,\n        \"creditor_account_IBAN\": str,\n        \"remittance_information\": str,\n    }\n\n    for row in data:\n        for column, data_type in required_columns.items():\n            value = row.get(column)\n            if value is None or value.strip() == \"\":\n                print(\n                    f\"Error: Missing value for column '{column}' \"\n                    f\"in row: {row}\"\n                )\n                return False\n\n            try:\n                if data_type == int:\n                    int(value)\n                elif data_type == float:\n                    float(value)\n                elif data_type == bool:\n                    if value.lower() not in [\"true\", \"false\"]:\n                        raise ValueError\n                else:\n                    str(value)\n            except ValueError:\n                print(\n                    f\"Error: Invalid data type for column '{column}', \"\n                    f\"expected {data_type.__name__} in row: {row}\"\n                )\n                return False\n\n    return True", "\n\ndef validate_csv_data(data):\n    \"\"\"Validate the CSV data before processing it.\n\n    Args:\n        data (list): A list of dictionaries containing the CSV data.\n\n    Returns:\n        bool: True if the data is valid, False otherwise.\n    \"\"\"\n    required_columns = {\n        \"id\": int,\n        \"date\": str,\n        \"nb_of_txs\": int,\n        \"initiator_name\": str,\n        \"payment_information_id\": str,\n        \"payment_method\": str,\n        \"batch_booking\": bool,\n        \"control_sum\": int,\n        \"service_level_code\": str,\n        \"requested_execution_date\": str,\n        \"debtor_name\": str,\n        \"debtor_account_IBAN\": str,\n        \"debtor_agent_BIC\": str,\n        \"forwarding_agent_BIC\": str,\n        \"charge_bearer\": str,\n        \"payment_id\": str,\n        \"payment_amount\": float,\n        \"currency\": str,\n        \"creditor_agent_BIC\": str,\n        \"creditor_name\": str,\n        \"creditor_account_IBAN\": str,\n        \"remittance_information\": str,\n    }\n\n    for row in data:\n        for column, data_type in required_columns.items():\n            value = row.get(column)\n            if value is None or value.strip() == \"\":\n                print(\n                    f\"Error: Missing value for column '{column}' \"\n                    f\"in row: {row}\"\n                )\n                return False\n\n            try:\n                if data_type == int:\n                    int(value)\n                elif data_type == float:\n                    float(value)\n                elif data_type == bool:\n                    if value.lower() not in [\"true\", \"false\"]:\n                        raise ValueError\n                else:\n                    str(value)\n            except ValueError:\n                print(\n                    f\"Error: Invalid data type for column '{column}', \"\n                    f\"expected {data_type.__name__} in row: {row}\"\n                )\n                return False\n\n    return True", ""]}
{"filename": "pain001/csv/load_csv_data.py", "chunked_list": ["# Copyright (C) 2023 Sebastien Rousseau.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport csv\nimport os\n", "import os\n\n# Load the CSV file into a list of dictionaries with the column names as\n# keys\n\n\ndef load_csv_data(csv_file_path):\n    if not os.path.exists(csv_file_path):\n        raise FileNotFoundError(\n            f\"CSV file '{csv_file_path}' does not exist.\"\n        )\n\n    data = []\n    with open(csv_file_path, \"r\") as csv_file:\n        reader = csv.DictReader(csv_file)\n        for row in reader:\n            data.append(row)\n    return data", ""]}
{"filename": "tests/test_main.py", "chunked_list": ["from click.testing import CliRunner\nfrom pain001.__main__ import main\n\n\nclass TestMain:\n    def setup_method(self):\n        self.runner = CliRunner()\n        self.xml_message_type = \"pain.001.001.03\"\n        self.xml_file = \"tests/data/template.xml\"\n        self.xsd_file = \"tests/data/template.xsd\"\n        self.csv_file = \"tests/data/template.csv\"\n\n    def test_main_with_valid_files(self):\n        result = self.runner.invoke(\n            main,\n            [\n                \"--xml_message_type\",\n                self.xml_message_type,\n                \"--xml_template_file_path\",\n                self.xml_file,\n                \"--xsd_schema_file_path\",\n                self.xsd_file,\n                \"--data_file_path\",\n                self.csv_file,\n            ],\n        )\n        assert (\n            \"The XML has been validated against tests/data/template.xsd\\n\"\n            in result.output\n        )\n        assert result.exit_code == 0\n\n    def test_main_with_missing_xml_message_type(self):\n        result = self.runner.invoke(\n            main,\n            [\n                \"--xml_template_file_path\",\n                self.xml_file,\n                \"--xsd_schema_file_path\",\n                self.xsd_file,\n                \"--data_file_path\",\n                self.csv_file,\n            ],\n        )\n        assert result.exit_code == 1\n        assert \"Error: xml_message_type is required.\" in result.output\n\n    def test_main_with_missing_xsd_template_file(self):\n        result = self.runner.invoke(\n            main,\n            [\n                \"--xml_message_type\",\n                self.xml_message_type,\n                \"--xml_template_file_path\",\n                self.xml_file,\n                \"--data_file_path\",\n                self.csv_file,\n            ],\n        )\n        assert result.exit_code == 1\n        assert (\n            \"Error: xsd_schema_file_path is required.\" in result.output\n        )\n\n    def test_main_with_missing_data_file(self):\n        result = self.runner.invoke(\n            main,\n            [\n                \"--xml_message_type\",\n                self.xml_message_type,\n                \"--xml_template_file_path\",\n                self.xml_file,\n                \"--xsd_schema_file_path\",\n                self.xsd_file,\n            ],\n        )\n        assert result.exit_code == 1\n        assert \"Error: data_file_path is required.\" in result.output\n\n    def test_main_with_invalid_xml_message_type(self):\n        result = self.runner.invoke(\n            main,\n            [\n                \"--xml_message_type\",\n                \"invalid\",\n                \"--xml_template_file_path\",\n                self.xml_file,\n                \"--xsd_schema_file_path\",\n                self.xsd_file,\n                \"--data_file_path\",\n                self.csv_file,\n            ],\n        )\n        assert result.exit_code == 1\n        assert \"Invalid XML message type: invalid.\" in result.output\n\n    def test_main_with_invalid_xml_template_file(self):\n        result = self.runner.invoke(\n            main,\n            [\n                \"--xml_message_type\",\n                self.xml_message_type,\n                \"--xml_template_file_path\",\n                \"invalid\",\n                \"--xsd_schema_file_path\",\n                self.xsd_file,\n                \"--data_file_path\",\n                self.csv_file,\n            ],\n        )\n        assert result.exit_code == 1\n        assert (\n            \"The XML template file 'invalid' does not exist.\"\n            in result.output\n        )\n\n    def test_main_with_invalid_xsd_template_file(self):\n        result = self.runner.invoke(\n            main,\n            [\n                \"--xml_message_type\",\n                self.xml_message_type,\n                \"--xml_template_file_path\",\n                self.xml_file,\n                \"--xsd_schema_file_path\",\n                \"invalid\",\n                \"--data_file_path\",\n                self.csv_file,\n            ],\n        )\n        assert result.exit_code == 1\n        assert (\n            \"The XSD template file 'invalid' does not exist.\"\n            in result.output\n        )\n\n    def test_main_with_invalid_data_file(self):\n        result = self.runner.invoke(\n            main,\n            [\n                \"--xml_message_type\",\n                self.xml_message_type,\n                \"--xml_template_file_path\",\n                self.xml_file,\n                \"--xsd_schema_file_path\",\n                self.xsd_file,\n                \"--data_file_path\",\n                \"invalid\",\n            ],\n        )\n        assert result.exit_code == 1\n        assert (\n            \"The data file 'invalid' does not exist.\" in result.output\n        )\n\n    def test_invalid_xml_template_file_path(self):\n        \"\"\"\n        Test that the `print(click.get_current_context().get_help())` line is\n        executed when the `xml_template_file_path` argument is set to an\n        invalid value.\n        \"\"\"\n\n        result = self.runner.invoke(\n            main,\n            [\n                \"--xml_message_type\",\n                \"pain.001.001.03\",\n                \"--xml_template_file_path\",\n                \"invalid\",\n                \"--xsd_schema_file_path\",\n                self.xsd_file,\n                \"--data_file_path\",\n                self.csv_file,\n            ],\n        )\n\n        assert result.exit_code == 1\n        assert (\n            \"The XML template file 'invalid' does not exist.\"\n            in result.output\n        )\n        assert (\n            \"The XML template file 'invalid' does not exist.\"\n            in result.output\n        )\n\n    def test_non_existent_xml_template_file_path(self):\n        \"\"\"\n        Test that the `logger.info()` and `print()` lines are executed\n        when the `xml_template_file_path` argument is set to a non-existent\n        file path.\n        \"\"\"\n\n        result = self.runner.invoke(\n            main,\n            [\n                \"--xml_message_type\",\n                \"pain.001.001.03\",\n                \"--xml_template_file_path\",\n                \"non_existent_file.xml\",\n                \"--xsd_schema_file_path\",\n                self.xsd_file,\n                \"--data_file_path\",\n                self.csv_file,\n            ],\n        )\n\n        assert result.exit_code == 1\n        assert (\n            \"The XML template file 'non_existent_file.xml' does not exist.\"\n            in result.output\n        )", ""]}
{"filename": "tests/test_generate_updated_xml_file_path.py", "chunked_list": ["from pain001.xml.generate_updated_xml_file_path import (\n    generate_updated_xml_file_path,\n)\n\n# Test if the updated XML file path is generated correctly\n\n\ndef test_generate_updated_xml_file_path():\n    # Test with a file path that has an extension\n    xml_file_path = \"tests/data/template.xml\"\n    payment_initiation_message_type = \"pain.001.001.03\"\n    expected_output = \"tests/data/pain.001.001.03.xml\"\n    assert generate_updated_xml_file_path(\n        xml_file_path,\n        payment_initiation_message_type\n    ) == expected_output", ""]}
{"filename": "tests/test_validate_via_xsd.py", "chunked_list": ["import unittest\nimport os\nfrom pain001.xml.validate_via_xsd import validate_via_xsd\n\n# Test if the XML file is validated correctly against the XSD schema\n\n\nclass TestValidateViaXsd(unittest.TestCase):\n    def setUp(self):\n        \"\"\"\n        Test case setup method.\n        \"\"\"\n        self.valid_xml_file = \"valid_test.xml\"\n        self.invalid_xml_file = \"invalid_test.xml\"\n        self.xsd_file = \"test_schema.xsd\"\n\n        # Create valid XML test file\n        with open(self.valid_xml_file, \"w\") as f:\n            f.write(\n                \"\"\"<root>\n                            <element>Valid data</element>\n                        </root>\"\"\"\n            )\n\n        # Create invalid XML test file\n        with open(self.invalid_xml_file, \"w\") as f:\n            f.write(\n                \"\"\"\n            <root>\n                <invalidElement>Invalid data</invalidElement>\n            </root>\n            \"\"\"\n            )\n\n        # Create test XSD schema file\n        with open(self.xsd_file, \"w\") as f:\n            f.write(\n                \"\"\"\n            <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n                <xs:element name=\"root\">\n                    <xs:complexType>\n                        <xs:sequence>\n                            <xs:element name=\"element\">\n                                <xs:simpleType>\n                                    <xs:restriction base=\"xs:string\"/>\n                                </xs:simpleType>\n                            </xs:element>\n                        </xs:sequence>\n                    </xs:complexType>\n                </xs:element>\n            </xs:schema>\n            \"\"\"\n            )\n\n    def tearDown(self):\n        \"\"\"\n        Test case tear down method.\n        \"\"\"\n        os.remove(self.valid_xml_file)\n        os.remove(self.invalid_xml_file)\n        os.remove(self.xsd_file)\n\n    def test_valid_xml(self):\n        \"\"\"\n        Test case for validating a valid XML file against an XSD schema.\n        \"\"\"\n        assert validate_via_xsd(self.valid_xml_file, self.xsd_file)\n\n    def test_invalid_xml(self):\n        \"\"\"\n        Test case for validating an invalid XML file against an XSD schema.\n        \"\"\"\n        assert not validate_via_xsd(\n            self.invalid_xml_file, self.xsd_file\n        )\n        assert not validate_via_xsd(\n            self.invalid_xml_file, self.xsd_file\n        )", ""]}
{"filename": "tests/test_create_root_element.py", "chunked_list": ["from pain001.xml.create_root_element import create_root_element\nimport xml.etree.ElementTree as ET\n\n# Test if the root element is created correctly\n\n\ndef test_create_root_element():\n\n    # Define the XML message type\n    payment_initiation_message_type = \"pain.001.001.03\"\n\n    # Create the root element\n    root = create_root_element(payment_initiation_message_type)\n\n    # Check if root element has correct tag\n    assert root.tag == 'Document'\n\n    # Check if xmlns attribute is set correctly\n    xmlns_attr = 'urn:iso:std:iso:20022:tech:xsd:pain.001.001.03'\n    assert root.attrib['xmlns'] == xmlns_attr\n\n    # Check if xmlns:xsi attribute is set correctly\n    xsi_attr = 'http://www.w3.org/2001/XMLSchema-instance'\n    assert root.attrib['xmlns:xsi'] == xsi_attr\n\n    # Check if xsi:schemaLocation attribute is set correctly\n    schema_location = (\n        'urn:iso:std:iso:20022:tech:xsd:pain.001.001.03 '\n        'pain.001.001.03.xsd'\n    )\n    assert root.attrib['xsi:schemaLocation'] == schema_location", "\n\ndef test_create_root_element_returns_element_object():\n\n    # Define the XML message type\n    payment_initiation_message_type = \"pain.001.001.03\"\n\n    # Create the root element\n    root = create_root_element(payment_initiation_message_type)\n\n    # Check if root element is an instance of Element\n    assert isinstance(root, ET.Element)", "\n\ndef test_create_root_element_does_not_raise_exception():\n    try:\n        # Define the XML message type\n        payment_initiation_message_type = \"pain.001.001.03\"\n\n        # Create the root element\n        create_root_element(payment_initiation_message_type)\n    except Exception:\n        error_msg = 'create_root_element unexpected exception'\n        assert False, error_msg", "\n\ndef test_create_root_element_handles_empty_input_gracefully():\n    # Test that the function does not raise an exception when\n    # called with no input\n    try:\n        # Define the XML message type\n        payment_initiation_message_type = \"pain.001.001.03\"\n\n        # Create the root element\n        create_root_element(payment_initiation_message_type)\n    except Exception:\n        error_msg = 'create_root_element unexpected exception'\n        assert False, error_msg", "\n\ndef test_create_root_element_sets_all_expected_attributes_correctly():\n    # Define the XML message type\n    payment_initiation_message_type = \"pain.001.001.03\"\n\n    # Create the root element\n    root = create_root_element(payment_initiation_message_type)\n\n    # Check if required attributes are set correctly\n    assert root.tag == 'Document'\n\n    # Check if xmlns attribute is set correctly\n    expected_xmlns = 'urn:iso:std:iso:20022:tech:xsd:pain.001.001.03'\n    assert root.attrib['xmlns'] == expected_xmlns\n\n    # Check if xmlns:xsi attribute is set correctly\n    expected_xsi = 'http://www.w3.org/2001/XMLSchema-instance'\n    assert root.attrib['xmlns:xsi'] == expected_xsi\n\n    # Check if xsi:schemaLocation attribute is set correctly\n    assert root.attrib['xsi:schemaLocation'] == (\n        'urn:iso:std:iso:20022:tech:xsd:pain.001.001.03 '\n        'pain.001.001.03.xsd'\n    )\n\n    # Check if optional attributes are set correctly\n    root_with_optional_attrs = create_root_element(\n        payment_initiation_message_type\n    )\n    assert 'xmlns:xs' not in root_with_optional_attrs.attrib.keys()\n\n    root = create_root_element(payment_initiation_message_type)\n\n    # Check that optional attributes are not set by default\n    assert 'xmlns:xs' not in root.attrib.keys()\n    assert 'xmlns:foo' not in root.attrib.keys()\n\n    # Set optional attributes and check that they are set correctly\n    root.set('xmlns:xs', 'http://www.w3.org/2001/XMLSchema')\n    root.set('xmlns:foo', 'http://example.com/foo')\n    assert root.attrib['xmlns:xs'] == 'http://www.w3.org/2001/XMLSchema'\n    assert root.attrib['xmlns:foo'] == 'http://example.com/foo'", ""]}
{"filename": "tests/test_validate_csv_data.py", "chunked_list": ["import unittest\nfrom pain001.csv.validate_csv_data import validate_csv_data\n\n# Test if the CSV data is validated correctly\n\n\nclass TestValidateCsvData(unittest.TestCase):\n\n    def test_valid_data(self):\n        # Test valid data\n        data = [\n            {\n                'id': '1',\n                'date': '2022-01-01',\n                'nb_of_txs': '1',\n                'initiator_name': 'John Doe',\n                'payment_information_id': '12345',\n                'payment_method': 'TRF',\n                'batch_booking': 'false',\n                'control_sum': '100',\n                'service_level_code': 'SEPA',\n                'requested_execution_date': '2022-01-01',\n                'debtor_name': 'John Doe',\n                'debtor_account_IBAN': 'DE89370400440532013000',\n                'debtor_agent_BIC': 'DEUTDEDBFRA',\n                'forwarding_agent_BIC': 'FORWARD',\n                'charge_bearer': 'SHA',\n                'payment_id': '12345',\n                'payment_amount': '100.00',\n                'currency': 'EUR',\n                'creditor_agent_BIC': 'DABADEHHXXX',\n                'creditor_name': 'Jane Doe',\n                'creditor_account_IBAN': 'DE89370400440532013001',\n                'remittance_information': 'Invoice 1234'\n            },\n            {\n                'id': '2',\n                'date': '2022-01-02',\n                'nb_of_txs': '1',\n                'initiator_name': 'Jane Doe',\n                'payment_information_id': '67890',\n                'payment_method': 'TRF',\n                'batch_booking': 'false',\n                'control_sum': '200',\n                'service_level_code': 'SEPA',\n                'requested_execution_date': '2022-01-02',\n                'debtor_name': 'Jane Doe',\n                'debtor_account_IBAN': 'DE89370400440532013001',\n                'debtor_agent_BIC': 'DEUTDEDBFRA',\n                'forwarding_agent_BIC': 'FORWARD2',\n                'charge_bearer': 'SHA',\n                'payment_id': '67890',\n                'payment_amount': '200.00',\n                'currency': 'EUR',\n                'creditor_agent_BIC': 'DABADEHHXXX',\n                'creditor_name': 'John Doe',\n                'creditor_account_IBAN': 'DE89370400440532013000',\n                'remittance_information': 'Invoice 5678'\n            }\n        ]\n\n        assert validate_csv_data(data) is True\n\n    def test_missing_required_columns(self):\n        # Test missing required columns\n        data = [\n            {\n                'id': '1',\n                'date': '2022-01-01',\n                'nb_of_txs': '1',\n                'payment_information_id': '12345',\n                'payment_method': 'TRF',\n                'batch_booking': 'false',\n                'control_sum': '100',\n                'service_level_code': 'SEPA',\n                'requested_execution_date': '2022-01-01',\n                'debtor_name': 'John Doe',\n                'debtor_account_IBAN': 'DE89370400440532013000',\n                'debtor_agent_BIC': 'DEUTDEDBFRA',\n                'forwarding_agent_BIC': 'FORWARD',\n                'charge_bearer': 'SHA',\n                'payment_id': '12345',\n                'payment_amount': '100.00',\n                'currency': 'EUR',\n                'creditor_agent_BIC': 'DABADEHHXXX',\n                'creditor_name': 'Jane Doe',\n                'creditor_account_IBAN': 'DE89370400440532013001',\n                'remittance_information': 'Invoice 1234'\n            },\n            {\n                'id': '2',\n                'date': '2022-01-02',\n                'nb_of_txs': '1',\n                'initiator_name': 'Jane Doe',\n                'payment_information_id': '67890',\n                'payment_method': 'TRF',\n                'batch_booking': 'false',\n                'control_sum': '200',\n                'service_level_code': 'SEPA',\n                'requested_execution_date': '2022-01-02',\n                'debtor_name': 'Jane Doe',\n                'debtor_account_IBAN': 'DE89370400440532013001',\n                'debtor_agent_BIC': 'DEUTDEDBFRA',\n                'forwarding_agent_BIC': 'FORWARD',\n                'charge_bearer': 'SHA',\n                'payment_id': '67890',\n                'payment_amount': '200.00',\n                'currency': 'EUR',\n                'creditor_agent_BIC': 'DABADEHHXXX',\n                'creditor_name': 'John Doe',\n                'creditor_account_IBAN': 'DE89370400440532013000',\n                'remittance_information': 'Invoice 5678'\n            }\n        ]\n\n        assert not validate_csv_data(data)", ""]}
{"filename": "tests/test_context.py", "chunked_list": ["import logging\nimport unittest\n\nfrom pain001.context.context import Context\n\n\nclass TestContext(unittest.TestCase):\n    \"\"\"Unit tests for the Context class.\"\"\"\n\n    def setUp(self):\n        \"\"\"Set up the test fixture.\"\"\"\n        Context.instance = None\n\n    def tearDown(self):\n        \"\"\"Tear down the test fixture.\"\"\"\n        if Context.instance:\n            Context.instance.logger = None\n        Context.instance = None\n\n    def test_singleton(self):\n        \"\"\"Test that Context is a singleton.\"\"\"\n        context1 = Context()\n        context2 = Context.get_instance()\n        self.assertEqual(context1, context2)\n        with self.assertRaises(Exception):\n            Context()\n\n    def test_set_name(self):\n        \"\"\"Test that set_name() sets the name of the logger.\"\"\"\n        context = Context.get_instance()\n        context.set_name(\"my_context\")\n        self.assertEqual(context.name, \"my_context\")\n\n    def test_set_log_level(self):\n        \"\"\"Test that set_log_level() sets the log level of the logger\"\"\"\n        context = Context.get_instance()\n\n        \"\"\"Test all valid log levels\"\"\"\n        valid_log_levels = {\n            \"DEBUG\": logging.DEBUG,\n            \"INFO\": logging.INFO,\n            \"WARNING\": logging.WARNING,\n            \"ERROR\": logging.ERROR,\n            \"CRITICAL\": logging.CRITICAL,\n        }\n\n        for level_str, level_int in valid_log_levels.items():\n            context.set_log_level(level_str)\n            self.assertEqual(context.log_level, level_int)\n            context.set_log_level(level_int)\n            self.assertEqual(context.log_level, level_int)\n\n        \"\"\"\n        Test that set_log_level() raises an exception if the log level is\n        invalid.\n        \"\"\"\n        with self.assertRaises(Exception):\n            context.set_log_level(\"INVALID\")\n        with self.assertRaises(Exception):\n            context.set_log_level(12345)  # some invalid int\n\n    def test_init_logger(self):\n        \"\"\"Test that init_logger() initializes the logger.\"\"\"\n        context = Context.get_instance()\n\n        \"\"\"Ensure the logger is not initialized\"\"\"\n        context.logger = None\n        context.init_logger()\n        self.assertIsNotNone(context.logger)\n\n        \"\"\"Test that init_logger() raises an exception if called again.\"\"\"\n        with self.assertRaises(Exception):\n            context.init_logger()\n\n    def test_get_logger(self):\n        \"\"\"Test that get_logger() returns the logger.\"\"\"\n        context = Context.get_instance()\n        logger = context.get_logger()\n        self.assertIsNotNone(logger)\n        self.assertEqual(logger, context.logger)\n\n        \"\"\"Test that get_logger() can initialize the logger.\"\"\"\n        context.logger = None\n        logger = context.get_logger()\n        self.assertIsNotNone(logger)\n        self.assertEqual(logger, context.logger)\n\n    def test_log_level_propagation(self):\n        \"\"\"Test that the log level is correctly propagated to the logger.\"\"\"\n        context = Context.get_instance()\n        context.set_log_level(logging.DEBUG)\n        self.assertEqual(context.logger.level, logging.DEBUG)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/test_create_xml_element.py", "chunked_list": ["import unittest\nimport xml.etree.ElementTree as ET\nfrom pain001.xml.create_xml_element import create_xml_element\n\n# Test if the XML element is created correctly\n\n\nclass TestCreateXmlElement(unittest.TestCase):\n    def test_create_element_with_tag_only(self):\n        \"\"\"\n        Test if the XML element is created correctly with a tag only.\n        \"\"\"\n        root = ET.Element(\"root\")\n        elem = create_xml_element(root, \"test\")\n        self.assertEqual(elem.tag, \"test\")\n        self.assertIsNone(elem.text)\n        self.assertEqual(root.find(\"test\"), elem)\n\n    def test_create_element_with_tag_and_text(self):\n        \"\"\"\n        Test if the XML element is created correctly with a tag and text.\n        \"\"\"\n        root = ET.Element(\"root\")\n        elem = create_xml_element(root, \"test\", text=\"Hello, world!\")\n        self.assertEqual(elem.tag, \"test\")\n        self.assertEqual(elem.text, \"Hello, world!\")\n        self.assertEqual(root.find(\"test\"), elem)\n\n    def test_create_element_with_tag_and_attributes(self):\n        \"\"\"\n        Test if the XML element is created correctly with a tag and attributes.\n        \"\"\"\n        root = ET.Element(\"root\")\n        attributes = {\"attr1\": \"value1\", \"attr2\": \"value2\"}\n        elem = create_xml_element(root, \"test\", attributes=attributes)\n        self.assertEqual(elem.tag, \"test\")\n        self.assertIsNone(elem.text)\n        self.assertEqual(elem.attrib, attributes)\n        self.assertEqual(root.find(\"test\"), elem)\n\n    def test_create_element_with_tag_text_and_attributes(self):\n        \"\"\"\n        Test if the XML element is created correctly with a tag, text and\n        attributes.\n        \"\"\"\n        root = ET.Element(\"root\")\n        attributes = {\"attr1\": \"value1\", \"attr2\": \"value2\"}\n        elem = create_xml_element(\n            root, \"test\", text=\"Hello, world!\", attributes=attributes\n        )\n        self.assertEqual(elem.tag, \"test\")\n        self.assertEqual(elem.text, \"Hello, world!\")\n        self.assertEqual(elem.attrib, attributes)\n        self.assertEqual(root.find(\"test\"), elem)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/test_core.py", "chunked_list": ["import pytest\nimport sys\n\nfrom contextlib import contextmanager\nfrom io import StringIO\n\nfrom pain001.core.core import process_files\n\n\n@contextmanager\ndef catch_stdout():\n    try:\n        old_out, sys.stdout = sys.stdout, StringIO()\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out", "\n@contextmanager\ndef catch_stdout():\n    try:\n        old_out, sys.stdout = sys.stdout, StringIO()\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\n\nclass TestProcessFiles:\n    def test_invalid_csv_data(self):\n        \"\"\"\n        Test case for processing files with invalid CSV data.\n        \"\"\"\n        with catch_stdout():\n            with pytest.raises(SystemExit) as exc_info:\n                process_files(\n                    \"pain.001.001.03\",\n                    \"tests/data/template.xml\",\n                    \"tests/data/template.xsd\",\n                    \"tests/data/invalid.csv\",\n                )\n\n        assert exc_info.value.code == 1\n\n    def test_invalid_xml_message_type(self):\n        \"\"\"\n        Test case for processing files with an invalid XML message type.\n        \"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            process_files(\n                \"invalid\",\n                \"tests/data/template.xml\",\n                \"tests/data/template.xsd\",\n                \"tests/data/template.csv\",\n            )\n\n        error_message = str(exc_info.value)\n        expected_error_message = (\n            \"Error: Invalid XML message type: 'invalid'.\"\n        )\n        assert error_message == expected_error_message\n\n    def test_nonexistent_data_file_path(self):\n        \"\"\"\n        Test case for processing files with a non-existent data file path.\n        \"\"\"\n        with pytest.raises(FileNotFoundError) as exc_info:\n            process_files(\n                \"pain.001.001.03\",\n                \"tests/data/template.xml\",\n                \"tests/data/template.xsd\",\n                \"tests/data/nonexistent.csv\",\n            )\n        assert (\n            str(exc_info.value)\n            == \"Error: Data file 'tests/data/nonexistent.csv' does not exist.\"\n        )\n\n    def test_nonexistent_xml_file_path(self):\n        \"\"\"\n        Test case for processing files with a non-existent XML file path.\n        \"\"\"\n        with pytest.raises(FileNotFoundError):\n            process_files(\n                \"pain.001.001.03\",\n                \"tests/data/nonexistent.xml\",\n                \"tests/data/template.xsd\",\n                \"tests/data/template.csv\",\n            )\n        # assert exc_info.value.code == 1\n\n    def test_nonexistent_xsd_file_path(self):\n        \"\"\"\n        Test case for processing files with a non-existent XSD file path.\n        \"\"\"\n        with pytest.raises(FileNotFoundError):\n            process_files(\n                \"pain.001.001.03\",\n                \"tests/data/template.xml\",\n                \"tests/data/nonexistent.xsd\",\n                \"tests/data/template.csv\",\n            )\n        # assert exc_info.value.code == 1\n\n    def test_successful_execution(self):\n        \"\"\"\n        Test case for successful execution of file processing.\n        \"\"\"\n        process_files(\n            \"pain.001.001.03\",\n            \"tests/data/template.xml\",\n            \"tests/data/template.xsd\",\n            \"tests/data/template.csv\",\n        )\n\n    def test_unsupported_data_file_type(self):\n        \"\"\"\n        Test case for processing files with an unsupported data file type.\n        \"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            process_files(\n                \"pain.001.001.03\",\n                \"tests/data/template.xml\",\n                \"tests/data/template.xsd\",\n                \"tests/data/invalid.rtf\",\n            )\n        assert (\n            str(exc_info.value) == \"Error: Unsupported data file type.\"\n        )\n\n    def test_uses_sqlite_database(self):\n        \"\"\"\n        Test case for processing files using an SQLite database.\n        \"\"\"\n        xml_message_type = \"pain.001.001.03\"\n        xml_file_path = \"tests/data/template.xml\"\n        xsd_file_path = \"tests/data/template.xsd\"\n        data_file_path = \"tests/data/template.db\"\n\n        process_files(\n            xml_message_type,\n            xml_file_path,\n            xsd_file_path,\n            data_file_path,\n        )\n\n    def test_valid_xml_message_type(self):\n        \"\"\"\n        Test case for processing files with a valid XML message type.\n        \"\"\"\n        process_files(\n            \"pain.001.001.03\",\n            \"tests/data/template.xml\",\n            \"tests/data/template.xsd\",\n            \"tests/data/template.csv\",\n        )", "\n\nclass TestProcessFiles:\n    def test_invalid_csv_data(self):\n        \"\"\"\n        Test case for processing files with invalid CSV data.\n        \"\"\"\n        with catch_stdout():\n            with pytest.raises(SystemExit) as exc_info:\n                process_files(\n                    \"pain.001.001.03\",\n                    \"tests/data/template.xml\",\n                    \"tests/data/template.xsd\",\n                    \"tests/data/invalid.csv\",\n                )\n\n        assert exc_info.value.code == 1\n\n    def test_invalid_xml_message_type(self):\n        \"\"\"\n        Test case for processing files with an invalid XML message type.\n        \"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            process_files(\n                \"invalid\",\n                \"tests/data/template.xml\",\n                \"tests/data/template.xsd\",\n                \"tests/data/template.csv\",\n            )\n\n        error_message = str(exc_info.value)\n        expected_error_message = (\n            \"Error: Invalid XML message type: 'invalid'.\"\n        )\n        assert error_message == expected_error_message\n\n    def test_nonexistent_data_file_path(self):\n        \"\"\"\n        Test case for processing files with a non-existent data file path.\n        \"\"\"\n        with pytest.raises(FileNotFoundError) as exc_info:\n            process_files(\n                \"pain.001.001.03\",\n                \"tests/data/template.xml\",\n                \"tests/data/template.xsd\",\n                \"tests/data/nonexistent.csv\",\n            )\n        assert (\n            str(exc_info.value)\n            == \"Error: Data file 'tests/data/nonexistent.csv' does not exist.\"\n        )\n\n    def test_nonexistent_xml_file_path(self):\n        \"\"\"\n        Test case for processing files with a non-existent XML file path.\n        \"\"\"\n        with pytest.raises(FileNotFoundError):\n            process_files(\n                \"pain.001.001.03\",\n                \"tests/data/nonexistent.xml\",\n                \"tests/data/template.xsd\",\n                \"tests/data/template.csv\",\n            )\n        # assert exc_info.value.code == 1\n\n    def test_nonexistent_xsd_file_path(self):\n        \"\"\"\n        Test case for processing files with a non-existent XSD file path.\n        \"\"\"\n        with pytest.raises(FileNotFoundError):\n            process_files(\n                \"pain.001.001.03\",\n                \"tests/data/template.xml\",\n                \"tests/data/nonexistent.xsd\",\n                \"tests/data/template.csv\",\n            )\n        # assert exc_info.value.code == 1\n\n    def test_successful_execution(self):\n        \"\"\"\n        Test case for successful execution of file processing.\n        \"\"\"\n        process_files(\n            \"pain.001.001.03\",\n            \"tests/data/template.xml\",\n            \"tests/data/template.xsd\",\n            \"tests/data/template.csv\",\n        )\n\n    def test_unsupported_data_file_type(self):\n        \"\"\"\n        Test case for processing files with an unsupported data file type.\n        \"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            process_files(\n                \"pain.001.001.03\",\n                \"tests/data/template.xml\",\n                \"tests/data/template.xsd\",\n                \"tests/data/invalid.rtf\",\n            )\n        assert (\n            str(exc_info.value) == \"Error: Unsupported data file type.\"\n        )\n\n    def test_uses_sqlite_database(self):\n        \"\"\"\n        Test case for processing files using an SQLite database.\n        \"\"\"\n        xml_message_type = \"pain.001.001.03\"\n        xml_file_path = \"tests/data/template.xml\"\n        xsd_file_path = \"tests/data/template.xsd\"\n        data_file_path = \"tests/data/template.db\"\n\n        process_files(\n            xml_message_type,\n            xml_file_path,\n            xsd_file_path,\n            data_file_path,\n        )\n\n    def test_valid_xml_message_type(self):\n        \"\"\"\n        Test case for processing files with a valid XML message type.\n        \"\"\"\n        process_files(\n            \"pain.001.001.03\",\n            \"tests/data/template.xml\",\n            \"tests/data/template.xsd\",\n            \"tests/data/template.csv\",\n        )", ""]}
{"filename": "tests/test_generate_xml.py", "chunked_list": ["import unittest\n\nimport xml.etree.ElementTree as ET\n\nfrom pain001.xml.generate_xml import (\n    create_common_elements,\n    create_xml_v3,\n    create_xml_v9,\n)\n", ")\n\n\nclass TestXMLCreation(unittest.TestCase):\n    def setUp(self):\n        \"\"\"\n        Test setup\n        \"\"\"\n        self.root = ET.Element(\"Root\")\n        self.row = {\n            \"initiator_name\": \"Initiator\",\n            \"batch_booking\": \"true\",\n            \"nb_of_txs\": \"2\",\n            \"control_sum\": \"3000\",\n            \"service_level_code\": \"Code\",\n            \"requested_execution_date\": \"2023-05-21\",\n            \"debtor_name\": \"Debtor\",\n            \"debtor_account_IBAN\": \"DE123456789\",\n            \"debtor_agent_BIC\": \"DEUTDEFF\",\n            \"charge_bearer\": \"Bearer\",\n            \"payment_id\": \"PID123\",\n            \"payment_amount\": \"1500\",\n            \"payment_method\": \"pain.001.001.09\",\n            \"currency\": \"EUR\",\n            \"creditor_agent_BIC\": \"NOLADE21KIE\",\n            \"creditor_name\": \"Creditor\",\n            \"creditor_account_IBAN\": \"DE26500700100096773701\",\n            \"remittance_information\": \"Invoice 123\",\n        }\n        self.mapping = {\n            \"MsgId\": \"payment_id\",\n            \"CreDtTm\": \"requested_execution_date\",\n            \"NbOfTxs\": \"nb_of_txs\",\n            \"PmtInfId\": \"payment_id\",\n            \"PmtMtd\": \"payment_method\",\n        }\n\n    def test_create_common_elements(self):\n        \"\"\"\n        Test create_common_elements\n        \"\"\"\n        create_common_elements(self.root, self.row, self.mapping)\n        self.assertEqual(len(self.root), 2)\n        self.assertEqual(self.root[0].tag, \"PmtInfId\")\n        self.assertEqual(self.root[0].text, \"PID123\")\n        self.assertEqual(self.root[1].tag, \"PmtMtd\")\n        self.assertEqual(self.root[1].text, \"pain.001.001.09\")\n\n    def test_create_xml_v3(self):\n        \"\"\"\n        Test create_xml_v3\n        \"\"\"\n        create_xml_v3(self.root, [self.row], self.mapping)\n        cstmr_cdt_trf_initn_element = self.root[0]\n        self.assertEqual(\n            cstmr_cdt_trf_initn_element.tag, \"CstmrCdtTrfInitn\"\n        )\n        # You can continue to assert more conditions based on your expectations\n\n    def test_create_xml_v9(self):\n        \"\"\"\n        Test create_xml_v9\n        \"\"\"\n\n        create_xml_v9(self.root, [self.row], self.mapping)\n        cstmr_cdt_trf_initn_element = self.root[0]\n        self.assertEqual(\n            cstmr_cdt_trf_initn_element.tag, \"CstmrCdtTrfInitn\"\n        )", "        # You can continue to assert more conditions based on your expectations\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/test_xml_generator.py", "chunked_list": ["import unittest\n\nfrom pain001.xml.xml_generator import xml_generator\n\n\nclass TestXmlGenerator(unittest.TestCase):\n    def test_xml_generator_with_invalid_input(self):\n        \"\"\"\n        Test if the XML generator exits with a non-zero exit code when\n        invalid input is provided.\n        \"\"\"\n\n        # Arrange\n        data = {\n            \"amount\": \"100.00\",\n            \"currency\": \"USD\",\n            \"beneficiary_bic\": \"ABCDE123\",\n            \"beneficiary_iban\": \"DE8937060198000001234567\",\n            \"creditor_bic\": \"DEFGH456\",\n            \"creditor_iban\": \"DE893706019800000234567\",\n        }\n        mapping = {\n            \"amount\": \"Amount\",\n            \"currency\": \"Currency\",\n            \"beneficiary_bic\": \"BeneficiaryBIC\",\n            \"beneficiary_iban\": \"BeneficiaryIBAN\",\n            \"creditor_bic\": \"CreditorBIC\",\n            \"creditor_iban\": \"CreditorIBAN\",\n        }\n        payment_initiation_message_type = \"invalid_message_type\"\n        xml_file_path = \"test.xml\"\n        xsd_file_path = \"schema.xsd\"\n\n        # Act\n        with self.assertRaises(SystemExit):\n            xml_generator(\n                data,\n                mapping,\n                payment_initiation_message_type,\n                xml_file_path,\n                xsd_file_path,\n            )", "\n        # Assert\n        # self.assertEqual(sys.exitcode, 1)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/test_load_csv_data.py", "chunked_list": ["import csv\nfrom pain001.csv.load_csv_data import load_csv_data\n\n# Test if the CSV data is loaded correctly\n\n\ndef test_load_csv_data():\n    # Test with an existing CSV file\n    csv_file_path = \"tests/data/existing_file.csv\"\n    expected_output = [\n        {\"col1\": \"val1\", \"col2\": \"val2\", \"col3\": \"val3\"},\n        {\"col1\": \"val4\", \"col2\": \"val5\", \"col3\": \"val6\"},\n        {\"col1\": \"val7\", \"col2\": \"val8\", \"col3\": \"val9\"},\n    ]\n    with open(csv_file_path, \"w\", newline=\"\") as csv_file:\n        writer = csv.DictWriter(\n            csv_file, fieldnames=[\"col1\", \"col2\", \"col3\"]\n        )\n        writer.writeheader()\n        writer.writerows(expected_output)\n    assert load_csv_data(csv_file_path) == expected_output\n\n    # Test with a non-existing CSV file\n    csv_file_path = \"path/to/non_existing_file.csv\"\n    try:\n        load_csv_data(csv_file_path)\n    except FileNotFoundError as e:\n        assert str(e) == f\"CSV file '{csv_file_path}' does not exist.\"\n    else:\n        assert False, \"Expected FileNotFoundError not raised.\"", ""]}
