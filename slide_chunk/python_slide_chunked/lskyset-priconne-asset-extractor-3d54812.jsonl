{"filename": "example.py", "chunked_list": ["from src import Dataminer\n\n\ndef examples():\n    # initializes the dataminer\n    dm = Dataminer()\n\n    # Extracting a whole manifest\n    dm.datamine(\n        manifest_filter=\"wac\",\n        assetbundle_filter=\"\",\n        file_filter=\"\",\n    )\n\n    # Extracting images\n    dm.datamine(\n        manifest_filter=\"bg\",\n        assetbundle_filter=r\"still_unit_1001[0-9]{2}\",\n        file_filter=r\"still_unit_1001[0-9]{2}\\.png\",\n    )\n\n    # Sound and Movie manifests only contain regular files so the assetbundle filter isn't needed.\n    dm.datamine(\n        manifest_filter=\"sound\",\n        assetbundle_filter=\"\",\n        file_filter=r\"bgm_M36\\.\",\n    )\n    dm.datamine(\n        manifest_filter=\"sound\",\n        assetbundle_filter=\"\",\n        file_filter=\"bgm_M152\",\n    )\n    dm.datamine(\n        manifest_filter=\"movie\",\n        assetbundle_filter=\"\",\n        file_filter=r\"character_1001[0-9]{2}\",\n    )\n\n    def sd_skel_example():\n        # 000000 files contains animations shared by all units\n        dm.datamine(\n            manifest_filter=\"spine\",\n            assetbundle_filter=\"000000\",\n            file_filter=\"cysp\",\n        )\n\n        # the common cysp contain animations shared by units from the same same class (eg. sword units)\n        dm.datamine(\n            manifest_filter=\"spine\",\n            assetbundle_filter=\"common\",\n            file_filter=\"cysp\",\n        )\n\n        # filters for the specific unit animations, include all uncap versions\n        dm.datamine(\n            manifest_filter=\"spine\",\n            assetbundle_filter=r\"1001[0-9]{2}\",\n            file_filter=r\"1001[0-9]{2}\",\n        )\n\n        # assemble .cysp files into a .skel file for a given unit_id\n        dm.get_skel(100111)\n\n    sd_skel_example()", "\n\nif __name__ == \"__main__\":\n    # keep all scripting in this scope to avoid bugs with multiprocessing\n    examples()\n"]}
{"filename": "priconne_asset_extractor.py", "chunked_list": ["from src import Dataminer\n\n\ndef main():\n    dm = Dataminer()\n\n    # Running as is will download all the manifests.\n    # They are just text files with file names so you can open them and adjust your filters.\n    # Files ending with .unity3d are assetbundles (containing more files) which you filter with assetbundle_filter\n    # Leaving filters empty will download / extract everything so make sure you have enough disk space when dealing with sound and movie files.\n    dm.datamine(\n        manifest_filter=\"\",  # (empty) manifest_name\n        assetbundle_filter=\"assetbundle_name\",\n        file_filter=\"file_name\",\n    )", "\n\nif __name__ == \"__main__\":\n    # keep all scripting in this scope to avoid bugs with multiprocessing\n    main()\n"]}
{"filename": "src/story_deserializer.py", "chunked_list": ["import base64\nfrom enum import Enum\nfrom struct import unpack\n\n\nclass CommandId(Enum):\n    NONE = -1\n    TITLE = 0\n    OUTLINE = 1\n    VISIBLE = 2", "    OUTLINE = 1\n    VISIBLE = 2\n    FACE = 3\n    FOCUS = 4\n    BACKGROUND = 5\n    PRINT = 6\n    TAG = 7\n    GOTO = 8\n    BGM = 9\n    TOUCH = 10", "    BGM = 9\n    TOUCH = 10\n    CHOICE = 11\n    VO = 12\n    WAIT = 13\n    IN_L = 14\n    IN_R = 15\n    OUT_L = 16\n    OUT_R = 17\n    FADEIN = 18", "    OUT_R = 17\n    FADEIN = 18\n    FADEOUT = 19\n    IN_FLOAT = 20\n    OUT_FLOAT = 21\n    JUMP = 22\n    SHAKE = 23\n    POP = 24\n    NOD = 25\n    SE = 26", "    NOD = 25\n    SE = 26\n    BLACK_OUT = 27\n    BLACK_IN = 28\n    WHITE_OUT = 29\n    WHITE_IN = 30\n    TRANSITION = 31\n    SITUATION = 32\n    COLOR_FADEIN = 33\n    FLASH = 34", "    COLOR_FADEIN = 33\n    FLASH = 34\n    SHAKE_TEXT = 35\n    TEXT_SIZE = 36\n    SHAKE_SCREEN = 37\n    DOUBLE = 38\n    SCALE = 39\n    TITLE_TELOP = 40\n    WINDOW_VISIBLE = 41\n    LOG = 42", "    WINDOW_VISIBLE = 41\n    LOG = 42\n    NOVOICE = 43\n    CHANGE = 44\n    FADEOUT_ALL = 45\n    MOVIE = 46\n    MOVIE_STAY = 47\n    BATTLE = 48\n    STILL = 49\n    BUSTUP = 50", "    STILL = 49\n    BUSTUP = 50\n    ENV = 51\n    TUTORIAL_REWARD = 52\n    NAME_EDIT = 53\n    EFFECT = 54\n    EFFECT_DELETE = 55\n    EYE_OPEN = 56\n    MOUTH_OPEN = 57\n    AUTO_END = 58", "    MOUTH_OPEN = 57\n    AUTO_END = 58\n    EMOTION = 59\n    EMOTION_END = 60\n    ENV_STOP = 61\n    BGM_PAUSE = 62\n    BGM_RESUME = 63\n    BGM_VOLUME_CHANGE = 64\n    ENV_RESUME = 65\n    ENV_VOLUME = 66", "    ENV_RESUME = 65\n    ENV_VOLUME = 66\n    SE_PAUSE = 67\n    CHARA_FULL = 68\n    SWAY = 69\n    BACKGROUND_COLOR = 70\n    PAN = 71\n    STILL_UNIT = 72\n    SLIDE_CHARA = 73\n    SHAKE_SCREEN_ONCE = 74", "    SLIDE_CHARA = 73\n    SHAKE_SCREEN_ONCE = 74\n    TRANSITION_RESUME = 75\n    SHAKE_LOOP = 76\n    SHAKE_DELETE = 77\n    UNFACE = 78\n    WAIT_TOKEN = 79\n    EFFECT_ENV = 80\n    BRIGHT_CHANGE = 81\n    CHARA_SHADOW = 82", "    BRIGHT_CHANGE = 81\n    CHARA_SHADOW = 82\n    UI_VISIBLE = 83\n    FADEIN_ALL = 84\n    CHANGE_WINDOW = 85\n    BG_PAN = 86\n    STILL_MOVE = 87\n    STILL_NORMALIZE = 88\n    VOICE_EFFECT = 89\n    TRIAL_END = 90", "    VOICE_EFFECT = 89\n    TRIAL_END = 90\n    SE_EFFECT = 91\n    CHARACTER_UP_DOWN = 92\n    BG_CAMERA_ZOOM = 93\n    BACKGROUND_SPLIT = 94\n    CAMERA_ZOOM = 95\n    SPLIT_SLIDE = 96\n    BGM_TRANSITION = 97\n    SHAKE_ANIME = 98", "    BGM_TRANSITION = 97\n    SHAKE_ANIME = 98\n    INSERT_STORY = 99\n    PLACE = 100\n    IGNORE_BGM = 101\n    MULTI_LIPSYNC = 102\n    JINGLE = 103\n    TOUCH_TO_START = 104\n    EVENT_ADV_MOVE_HORIZONTAL = 105\n    BG_PAN_X = 106", "    EVENT_ADV_MOVE_HORIZONTAL = 105\n    BG_PAN_X = 106\n    BACKGROUND_BLUR = 107\n    SEASONAL_REWARD = 108\n    MINI_GAME = 109\n    MAX = 110\n    UNKNOWN = 112  # todo: find the actual name\n\n\ndef deserialize_command(data) -> tuple[CommandId, list[str]]:", "\ndef deserialize_command(data) -> tuple[CommandId, list[str]]:\n    index = data[0]\n    args = []\n    if len(data) > 1:\n        args = data[1:]\n    array = []\n    for arg in args:\n        array2 = []\n        for byte in arg:", "        array2 = []\n        for byte in arg:\n            if byte > 127:\n                array2.append(255 - byte)\n            else:\n                array2.append(byte)\n        str_ = base64.b64decode(bytearray(array2))\n        array.append(str_.decode())\n    return (CommandId(index), array)\n", "    return (CommandId(index), array)\n\n\ndef deserialize_story_raw(bytes_: bytes) -> list[tuple[CommandId, list[str]]]:\n    commands = []\n    fs = 0\n    raw_commands = []\n    i = 2\n    while i < len(bytes_):\n        args: list[bytes | int] = []", "    while i < len(bytes_):\n        args: list[bytes | int] = []\n        index = int(unpack(\">H\", bytes_[fs : fs + 2])[0])\n        fs += 2\n        args.append(index)\n        num = i\n        while True:\n            length = int(unpack(\">l\", bytes_[fs : fs + 4])[0])\n            fs += 4\n            if length == 0:", "            fs += 4\n            if length == 0:\n                break\n            array = bytes_[fs : fs + length]\n            fs += length\n            args.append(array)\n            num += 4 + length\n        i = num + 4\n        raw_commands.append(args)\n        i += 2", "        raw_commands.append(args)\n        i += 2\n    for raw_command in raw_commands:\n        if len(raw_command) > 1:\n            commands.append(deserialize_command(raw_command))\n    return commands\n\n\ndef deserialize_story(bytes_: bytes) -> dict:\n    commands = deserialize_story_raw(bytes_)", "def deserialize_story(bytes_: bytes) -> dict:\n    commands = deserialize_story_raw(bytes_)\n    story: dict[int, dict] = {}\n    num = 0\n    story[num] = {}\n    block: dict[str, str | tuple | dict] = story[num]\n    for command_id, args in commands:\n        match command_id:\n            case CommandId.PRINT:\n                cmd = block.setdefault(command_id.name.lower(), {})", "            case CommandId.PRINT:\n                cmd = block.setdefault(command_id.name.lower(), {})\n                cmd.setdefault(\"name\", args[0])\n                cmd[\"text\"] = (cmd.get(\"text\") or \"\") + clean_text(args[1])\n            case CommandId.CHOICE:\n                block.setdefault(command_id.name.lower(), [])\n                block[command_id.name.lower()].append(\n                    {\n                        \"text\": args[0],\n                        \"tag\": args[1],", "                        \"text\": args[0],\n                        \"tag\": args[1],\n                    }\n                )\n            case CommandId.BUSTUP:\n                num += 1\n                block = story.setdefault(num, {})\n            case CommandId.TAG:\n                story.setdefault(num + 1, {})\n                story[num + 1][command_id.name.lower()] = args[0]", "                story.setdefault(num + 1, {})\n                story[num + 1][command_id.name.lower()] = args[0]\n            case CommandId.TITLE | CommandId.SITUATION | CommandId.OUTLINE | CommandId.VO | CommandId.GOTO:\n                if len(args) == 1:\n                    args = args[0]\n                block[command_id.name.lower()] = args\n    return story\n\n\ndef clean_text(text: str) -> str:", "\ndef clean_text(text: str) -> str:\n    replace_pairs = (\n        (\"\\\\n\", \"\\n\"),\n        (\"{0}\", \"{player_name}\"),\n        ('\\\\\"', '\"'),\n    )\n    for pair in replace_pairs:\n        text = text.replace(*pair)\n    return text", "        text = text.replace(*pair)\n    return text\n"]}
{"filename": "src/config.py", "chunked_list": ["from dataclasses import dataclass\nfrom enum import Enum\nfrom pathlib import Path\n\nimport UnityPy\n\n\nclass ManifestType(Enum):\n    ASSET = \"dl/Resources/%s/Jpn/AssetBundles/Windows/manifest/%s\"\n    MOVIE = \"dl/Resources/%s/Jpn/Movie/PC/High/manifest/%s\"\n    SOUND = \"dl/Resources/%s/Jpn/Sound/manifest/%s\"", "\n\nclass AssetType(Enum):\n    ASSET = \"dl/pool/AssetBundles\"\n    MOVIE = \"dl/pool/Movie\"\n    SOUND = \"dl/pool/Sound\"\n\n\nclass BundleType(Enum):\n    TEXTURE_2D = \"Texture2D\"\n    Sprite = \"Sprite\"\n    TEXT_ASSET = \"TextAsset\"", "class BundleType(Enum):\n    TEXTURE_2D = \"Texture2D\"\n    Sprite = \"Sprite\"\n    TEXT_ASSET = \"TextAsset\"\n\n\nclass BundleSource(Enum):\n    WEB = 0\n    LOCAL = 1  # not implemented\n", "\n\nclass PricoHost(Enum):\n    JP = \"prd-priconne-redive.akamaized.net\"\n    EN = \"assets-priconne-redive-us.akamaized.net\"  # not implemented\n\n\n@dataclass(frozen=True)\nclass Config:\n    image_format: str = \".png\"\n    bundle_source: BundleSource = BundleSource.WEB\n    host = PricoHost.JP\n    usmtoolkit_path = Path(\"usmtoolkit/UsmToolkit.exe\")\n    vgmstream_path = usmtoolkit_path.parent / \"vgmstream\" / \"test.exe\"", "class Config:\n    image_format: str = \".png\"\n    bundle_source: BundleSource = BundleSource.WEB\n    host = PricoHost.JP\n    usmtoolkit_path = Path(\"usmtoolkit/UsmToolkit.exe\")\n    vgmstream_path = usmtoolkit_path.parent / \"vgmstream\" / \"test.exe\"\n\n\nUnityPy.config.FALLBACK_UNITY_VERSION = \"2021.3.20f1\"\n", "UnityPy.config.FALLBACK_UNITY_VERSION = \"2021.3.20f1\"\n"]}
{"filename": "src/asset_bundle.py", "chunked_list": ["from pathlib import Path\n\nimport UnityPy  # type: ignore[import]\n\nfrom src.abc.abstract_manifest_file import AbstractManifestFile\n\nfrom .config import AssetType, BundleType, Config\nfrom .files import BundleFile, FileContainer\n\n\nclass AssetBundle(AbstractManifestFile, FileContainer[BundleFile]):\n    def __init__(\n        self,\n        path: Path | str,\n        hash_: str,\n        size: int,\n    ) -> None:\n        super().__init__(path, hash_, AssetType.ASSET, size)\n\n    @property\n    def name(self) -> str:\n        if name := self._name.split(\"_\", 1)[1]:\n            return name\n        return self._name\n\n    @property\n    def path(self) -> Path:\n        if len(self._name.split(\"_\", 1)) == 2:\n            sub_folder, name = self._name.split(\"_\", 1)\n            return self._path.parent / sub_folder / \"assetbundle\" / name\n        return self._path\n\n    @property\n    def url(self):\n        endpoint = f\"{AssetType.ASSET.value}/{self._hash[:2]}/{self._hash}\"\n        return f\"https://{Config.host.value}/{endpoint}\"\n\n    @property\n    def files(self) -> list[BundleFile]:\n        if self._files is None:\n            self._files = self._read()\n        return self._files\n\n    def _read(self) -> list[BundleFile]:\n        self.download()\n        files = []\n        env = UnityPy.load(self.path.as_posix())\n        supported_bundle_types = [t.value for t in BundleType]\n        for obj in env.objects:\n            if obj.type.name in supported_bundle_types:\n                files.append(BundleFile(self, obj))\n        return files", "\n\nclass AssetBundle(AbstractManifestFile, FileContainer[BundleFile]):\n    def __init__(\n        self,\n        path: Path | str,\n        hash_: str,\n        size: int,\n    ) -> None:\n        super().__init__(path, hash_, AssetType.ASSET, size)\n\n    @property\n    def name(self) -> str:\n        if name := self._name.split(\"_\", 1)[1]:\n            return name\n        return self._name\n\n    @property\n    def path(self) -> Path:\n        if len(self._name.split(\"_\", 1)) == 2:\n            sub_folder, name = self._name.split(\"_\", 1)\n            return self._path.parent / sub_folder / \"assetbundle\" / name\n        return self._path\n\n    @property\n    def url(self):\n        endpoint = f\"{AssetType.ASSET.value}/{self._hash[:2]}/{self._hash}\"\n        return f\"https://{Config.host.value}/{endpoint}\"\n\n    @property\n    def files(self) -> list[BundleFile]:\n        if self._files is None:\n            self._files = self._read()\n        return self._files\n\n    def _read(self) -> list[BundleFile]:\n        self.download()\n        files = []\n        env = UnityPy.load(self.path.as_posix())\n        supported_bundle_types = [t.value for t in BundleType]\n        for obj in env.objects:\n            if obj.type.name in supported_bundle_types:\n                files.append(BundleFile(self, obj))\n        return files", ""]}
{"filename": "src/version_finder.py", "chunked_list": ["import json\nfrom pathlib import Path\n\nfrom requests_futures.sessions import FuturesSession\n\nfrom src.config import ManifestType, PricoHost\n\n\ndef find_version(host: PricoHost, default_version: int) -> int:\n    max_test_amount = 30\n    test_multiplier = 10\n    version = default_version\n\n    s = FuturesSession()\n    while True:\n        urls = [\n            f'http://{host.value}/{ManifestType.ASSET.value % (version + (i + 1) * test_multiplier, \"manifest_assetmanifest\")}'\n            for i in range(max_test_amount)\n        ]\n        responses = [s.get(url) for url in urls]\n        results = [r.result().status_code == 200 for r in responses]\n        if not any(results):\n            return version\n        version += (max_test_amount - results[::-1].index(True)) * test_multiplier", "def find_version(host: PricoHost, default_version: int) -> int:\n    max_test_amount = 30\n    test_multiplier = 10\n    version = default_version\n\n    s = FuturesSession()\n    while True:\n        urls = [\n            f'http://{host.value}/{ManifestType.ASSET.value % (version + (i + 1) * test_multiplier, \"manifest_assetmanifest\")}'\n            for i in range(max_test_amount)\n        ]\n        responses = [s.get(url) for url in urls]\n        results = [r.result().status_code == 200 for r in responses]\n        if not any(results):\n            return version\n        version += (max_test_amount - results[::-1].index(True)) * test_multiplier", "\n\ndef find_version_fallback(host: PricoHost) -> int:\n    s = FuturesSession()\n    if host == PricoHost.JP:\n        r = s.get(\"https://redive.estertion.win/last_version_jp.json\").result()\n        latest = json.loads(r.content)\n    else:\n        raise \"could not find version\"\n    return int(latest[\"TruthVersion\"])", "\n\ndef get_latest_version(host: PricoHost) -> int:\n    print(\"Finding latest version\")\n    default_version = 10047400\n    versions = {}\n    path = Path(\"versions.json\")\n    if path.exists():\n        versions = json.loads(path.read_text())\n        default_version = versions.get(host.value, default_version)\n    try:\n        version = find_version(host, default_version)\n    except Exception as e:\n        print(e, \"\\nusing fallback version finder\")\n        version = find_version_fallback(host)\n\n    versions[host.value] = version\n    path.write_text(json.dumps(versions))\n    print(f\"{version=}\")\n    return version", ""]}
{"filename": "src/__init__.py", "chunked_list": ["from .dataminer import Dataminer\n\n__all__ = [\"Dataminer\"]\n"]}
{"filename": "src/protocols.py", "chunked_list": ["from pathlib import Path\nfrom typing import Protocol\n\n\nclass File(Protocol):\n    @property\n    def path(self) -> Path:\n        ...\n\n    @property\n    def name(self) -> str:\n        ...", "\n\nclass Readable(Protocol):\n    def _read(self) -> list:\n        ...\n\n\nclass Downloadable(File, Protocol):\n    def download(self) -> None:\n        ...", "\n\nclass Extractable(Protocol):\n    def extract(self) -> None:\n        ...\n"]}
{"filename": "src/dataminer.py", "chunked_list": ["import re\nfrom itertools import chain\nfrom multiprocessing import Pool\nfrom pathlib import Path\nfrom urllib.request import urlretrieve\n\nfrom src.config import Config\n\nfrom . import version_finder\nfrom .asset_bundle import AssetBundle", "from . import version_finder\nfrom .asset_bundle import AssetBundle\nfrom .cysp2skel import Cysp2Skel\nfrom .files import BundleFile\nfrom .manifests import AssetManifest, Manifest, MovieManifest, SoundManifest\nfrom .mdb import MDB\nfrom .protocols import Extractable\n\n\nclass Dataminer:\n    _mdb: MDB | None = None\n    _cysp2skel: Cysp2Skel | None = None\n\n    __slots__ = (\n        \"_asset_manifest\",\n        \"_sound_manifest\",\n        \"_movie_manifest\",\n    )\n\n    def __init__(self, *, version: int | None = None) -> None:\n        if version is None:\n            version = version_finder.get_latest_version(Config.host)\n        self._asset_manifest: AssetManifest = AssetManifest(version)\n        self._sound_manifest: SoundManifest = SoundManifest(version)\n        self._movie_manifest: MovieManifest = MovieManifest(version)\n\n    @staticmethod\n    def _pool_manifest_files(data: tuple[Manifest, str]) -> list[AssetBundle]:\n        manifest, match = data\n        ret = manifest.get_files(match)\n        return ret\n\n    @staticmethod\n    def _pool_bundle_files(data: tuple[AssetBundle, str]) -> list[BundleFile]:\n        assetbundle, match = data\n        return assetbundle.get_files(match)\n\n    @staticmethod\n    def _extract_file(file: Extractable):\n        file.extract()\n\n    @staticmethod\n    def download_mdb(mdb_name=\"master.db\") -> str:\n        return urlretrieve(\n            \"https://github.com/lskyset/nozomi-cb-data/raw/main/master.db\",\n            mdb_name,\n        )[0]\n\n    @property\n    def mdb(self) -> MDB:\n        if Dataminer._mdb is None:\n            Dataminer._mdb = MDB(Dataminer.download_mdb())\n        return Dataminer._mdb\n\n    @property\n    def cysp2skel(self) -> Cysp2Skel:\n        if Dataminer._cysp2skel is None:\n            Dataminer._cysp2skel = Cysp2Skel(\"a/spine/unitanimation\", self.mdb)\n        return Dataminer._cysp2skel\n\n    def get_manifests(\n        self, match: str = \"\"\n    ) -> list[Manifest | SoundManifest | MovieManifest]:\n        manifests: list[SoundManifest | MovieManifest] = []\n        tmp: list[SoundManifest | MovieManifest] = [\n            self._sound_manifest,\n            self._movie_manifest,\n        ]\n        for manifest in tmp:\n            if re.search(match, manifest.name):\n                manifests.append(manifest)\n        return self._asset_manifest.get_files(match) + manifests\n\n    def datamine(\n        self,\n        *,\n        manifest_filter: str,\n        assetbundle_filter: str,\n        file_filter: str,\n    ):\n        manifests: list[Manifest | SoundManifest | MovieManifest]\n        manifests = self.get_manifests(manifest_filter)\n\n        with Pool() as p:\n            assetbundles: chain[AssetBundle] = chain(\n                *p.imap(\n                    self._pool_manifest_files,\n                    [\n                        (manifest, assetbundle_filter)\n                        for manifest in manifests\n                        if type(manifest) == Manifest\n                    ],\n                )\n            )\n\n            files: chain[Extractable] = chain(\n                *p.imap(\n                    self._pool_bundle_files,\n                    [(assetbndl, file_filter) for assetbndl in assetbundles],\n                ),\n                chain(\n                    *[\n                        manifest.get_files(file_filter)\n                        for manifest in manifests\n                        if type(manifest) == SoundManifest\n                        or type(manifest) == MovieManifest\n                    ]\n                ),\n            )\n\n            list(p.imap(self._extract_file, files))\n\n    def get_skel(self, unit_id: int):\n        if (buffer := self.cysp2skel.get_skeleton_buffer(unit_id)) is None:\n            return print(f\"Could not find {unit_id=}\")\n        path = Path(f\"a/spine/sdnormal/spine_{unit_id}/{unit_id}.skel\")\n        path.parent.mkdir(parents=True, exist_ok=True)\n        with path.open(\"wb\") as f:\n            f.write(buffer.read())\n        print(f\"EX {path.absolute()}\")", "\nclass Dataminer:\n    _mdb: MDB | None = None\n    _cysp2skel: Cysp2Skel | None = None\n\n    __slots__ = (\n        \"_asset_manifest\",\n        \"_sound_manifest\",\n        \"_movie_manifest\",\n    )\n\n    def __init__(self, *, version: int | None = None) -> None:\n        if version is None:\n            version = version_finder.get_latest_version(Config.host)\n        self._asset_manifest: AssetManifest = AssetManifest(version)\n        self._sound_manifest: SoundManifest = SoundManifest(version)\n        self._movie_manifest: MovieManifest = MovieManifest(version)\n\n    @staticmethod\n    def _pool_manifest_files(data: tuple[Manifest, str]) -> list[AssetBundle]:\n        manifest, match = data\n        ret = manifest.get_files(match)\n        return ret\n\n    @staticmethod\n    def _pool_bundle_files(data: tuple[AssetBundle, str]) -> list[BundleFile]:\n        assetbundle, match = data\n        return assetbundle.get_files(match)\n\n    @staticmethod\n    def _extract_file(file: Extractable):\n        file.extract()\n\n    @staticmethod\n    def download_mdb(mdb_name=\"master.db\") -> str:\n        return urlretrieve(\n            \"https://github.com/lskyset/nozomi-cb-data/raw/main/master.db\",\n            mdb_name,\n        )[0]\n\n    @property\n    def mdb(self) -> MDB:\n        if Dataminer._mdb is None:\n            Dataminer._mdb = MDB(Dataminer.download_mdb())\n        return Dataminer._mdb\n\n    @property\n    def cysp2skel(self) -> Cysp2Skel:\n        if Dataminer._cysp2skel is None:\n            Dataminer._cysp2skel = Cysp2Skel(\"a/spine/unitanimation\", self.mdb)\n        return Dataminer._cysp2skel\n\n    def get_manifests(\n        self, match: str = \"\"\n    ) -> list[Manifest | SoundManifest | MovieManifest]:\n        manifests: list[SoundManifest | MovieManifest] = []\n        tmp: list[SoundManifest | MovieManifest] = [\n            self._sound_manifest,\n            self._movie_manifest,\n        ]\n        for manifest in tmp:\n            if re.search(match, manifest.name):\n                manifests.append(manifest)\n        return self._asset_manifest.get_files(match) + manifests\n\n    def datamine(\n        self,\n        *,\n        manifest_filter: str,\n        assetbundle_filter: str,\n        file_filter: str,\n    ):\n        manifests: list[Manifest | SoundManifest | MovieManifest]\n        manifests = self.get_manifests(manifest_filter)\n\n        with Pool() as p:\n            assetbundles: chain[AssetBundle] = chain(\n                *p.imap(\n                    self._pool_manifest_files,\n                    [\n                        (manifest, assetbundle_filter)\n                        for manifest in manifests\n                        if type(manifest) == Manifest\n                    ],\n                )\n            )\n\n            files: chain[Extractable] = chain(\n                *p.imap(\n                    self._pool_bundle_files,\n                    [(assetbndl, file_filter) for assetbndl in assetbundles],\n                ),\n                chain(\n                    *[\n                        manifest.get_files(file_filter)\n                        for manifest in manifests\n                        if type(manifest) == SoundManifest\n                        or type(manifest) == MovieManifest\n                    ]\n                ),\n            )\n\n            list(p.imap(self._extract_file, files))\n\n    def get_skel(self, unit_id: int):\n        if (buffer := self.cysp2skel.get_skeleton_buffer(unit_id)) is None:\n            return print(f\"Could not find {unit_id=}\")\n        path = Path(f\"a/spine/sdnormal/spine_{unit_id}/{unit_id}.skel\")\n        path.parent.mkdir(parents=True, exist_ok=True)\n        with path.open(\"wb\") as f:\n            f.write(buffer.read())\n        print(f\"EX {path.absolute()}\")", ""]}
{"filename": "src/cysp2skel.py", "chunked_list": ["import struct\nfrom io import BufferedReader, BytesIO, RawIOBase\nfrom pathlib import Path\nfrom typing import cast\n\nfrom .mdb import MDB\n\n\nclass Cysp2Skel:\n    _default_base: BufferedReader | None = None\n    _default_base_animation_count: int = 0\n    _default_animation_count_index: int = 0\n\n    _unit_class_data: dict[str, str] | None = None\n\n    __slots__ = (\n        \"_cysp_dir\",\n        \"mdb\",\n        \"_current_base\",\n        \"_current_base_animation_count\",\n        \"_current_animation_count_index\",\n    )\n\n    def __init__(self, cysp_dir: str | Path, mdb: MDB) -> None:\n        self._cysp_dir = Path(cysp_dir)\n        self.mdb = mdb\n        self._current_base: BufferedReader | None = None\n        self._current_base_animation_count: int = 0\n        self._current_animation_count_index: int = 0\n\n    def _get_base(self, str_id: str) -> RawIOBase:\n        files: list[str] = [\n            f\"{str_id}_{name}.cysp\"\n            for name in [\n                \"CHARA_BASE\",\n                \"DEAR\",\n                \"NO_WEAPON\",\n                \"POSING\",\n                \"RACE\",\n                \"RUN_JUMP\",\n                \"SMILE\",\n            ]\n        ]\n\n        paths: list[Path] = [self._cysp_dir / file for file in files]\n\n        self._current_base_animation_count = 0\n        base = BytesIO()\n        for file in paths:\n            try:\n                with file.open(\"rb\") as f:\n                    f.seek(12)\n                    count = _read_varint(f)\n                    f.seek((count + 1) * 32)\n                    base.write(f.read())\n                    if \"CHARA_BASE.cysp\" in file.name:\n                        self._current_animation_count_index = base.tell()\n                        base.write(b\"\\0\")\n                    else:\n                        self._current_base_animation_count += count\n            except FileNotFoundError as e:\n                print(f\"Ignoring {e}\")\n        base.seek(self._current_animation_count_index)\n        base.write(bytes([self._current_base_animation_count]))\n        base.seek(0)\n        return base\n\n    def get_default_base(self) -> BufferedReader:\n        if Cysp2Skel._default_base is not None:\n            Cysp2Skel._default_base.seek(0)\n            self._current_base_animation_count = Cysp2Skel._default_base_animation_count\n            self._current_animation_count_index = (\n                Cysp2Skel._default_animation_count_index\n            )\n            return Cysp2Skel._default_base\n\n        Cysp2Skel._default_base = BufferedReader(self._get_base(\"000000\"))\n        Cysp2Skel._default_base_animation_count = self._current_base_animation_count\n        Cysp2Skel._default_animation_count_index = self._current_animation_count_index\n\n        return Cysp2Skel._default_base\n\n    def get_unit_data(self) -> dict[str | dict[str | str]]:\n        unit_data = self.mdb.c.execute(\n            \"select unit_id,prefab_id,prefab_id_battle,motion_type from unit_data\"\n        ).fetchall()\n\n        unit_enemy_data = self.mdb.c.execute(\n            \"select unit_id,prefab_id,motion_type from unit_enemy_data\"\n        ).fetchall()\n\n        unit_data_dict = {\n            str(unit_id): {\n                \"motion_type\": str(motion_type),\n                \"prefab_id\": str(prefab_id),\n                \"prefab_id_battle\": str(prefab_id_battle),\n            }\n            for unit_id, prefab_id, prefab_id_battle, motion_type in unit_data\n        }\n        enemy_data_dict = {\n            str(unit_id): {\n                \"motion_type\": str(motion_type),\n                \"prefab_id\": str(prefab_id),\n            }\n            for unit_id, prefab_id, motion_type in unit_enemy_data\n        }\n\n        return {**unit_data_dict, **enemy_data_dict}\n\n    @property\n    def unit_data(self) -> dict:\n        if Cysp2Skel._unit_class_data is None:\n            Cysp2Skel._unit_class_data = self.get_unit_data()\n        return Cysp2Skel._unit_class_data\n\n    def get_skeleton_buffer(self, unit_id: int) -> BufferedReader | None:\n        base_unit_id = str(unit_id // 100) + \"01\"\n\n        if (unit := self.unit_data.get(base_unit_id)) is None:\n            for unit in self.unit_data.values():\n                if unit.get(\"prefab_id\") == base_unit_id:\n                    break\n                if unit.get(\"prefab_id_battle\") == base_unit_id:\n                    break\n\n        motion_type: str = unit.get(\"motion_type\")\n\n        if motion_type is None:\n            return None\n        if motion_type == \"0\":\n            motion_type = base_unit_id\n            self._current_base = self._get_base(base_unit_id)\n        else:\n            self._current_base = self.get_default_base()\n\n        chara_class: str = motion_type.rjust(2, \"0\")\n        files: list[str] = []\n        files.append(f\"{chara_class}_COMMON_BATTLE.cysp\")\n        # files.append(f\"{chara_class}_LOADING.cysp\")\n        files.append(f\"{unit.get('prefab_id')}_BATTLE.cysp\")\n        paths: list[Path] = [self._cysp_dir / file for file in files]\n\n        skel = BytesIO()\n        skel.write(self._current_base.read())\n        class_animation_count = 0\n        for file in paths:\n            with file.open(\"rb\") as f:\n                f.seek(12)\n                count = _read_varint(f)\n                f.seek((count + 1) * 32)\n                skel.write(f.read())\n                class_animation_count += count\n        skel.seek(self._current_animation_count_index)\n        anim_count = self._current_base_animation_count + class_animation_count\n        skel.write(bytes([anim_count]))\n        skel.seek(0)\n        return BufferedReader(cast(RawIOBase, skel))", "class Cysp2Skel:\n    _default_base: BufferedReader | None = None\n    _default_base_animation_count: int = 0\n    _default_animation_count_index: int = 0\n\n    _unit_class_data: dict[str, str] | None = None\n\n    __slots__ = (\n        \"_cysp_dir\",\n        \"mdb\",\n        \"_current_base\",\n        \"_current_base_animation_count\",\n        \"_current_animation_count_index\",\n    )\n\n    def __init__(self, cysp_dir: str | Path, mdb: MDB) -> None:\n        self._cysp_dir = Path(cysp_dir)\n        self.mdb = mdb\n        self._current_base: BufferedReader | None = None\n        self._current_base_animation_count: int = 0\n        self._current_animation_count_index: int = 0\n\n    def _get_base(self, str_id: str) -> RawIOBase:\n        files: list[str] = [\n            f\"{str_id}_{name}.cysp\"\n            for name in [\n                \"CHARA_BASE\",\n                \"DEAR\",\n                \"NO_WEAPON\",\n                \"POSING\",\n                \"RACE\",\n                \"RUN_JUMP\",\n                \"SMILE\",\n            ]\n        ]\n\n        paths: list[Path] = [self._cysp_dir / file for file in files]\n\n        self._current_base_animation_count = 0\n        base = BytesIO()\n        for file in paths:\n            try:\n                with file.open(\"rb\") as f:\n                    f.seek(12)\n                    count = _read_varint(f)\n                    f.seek((count + 1) * 32)\n                    base.write(f.read())\n                    if \"CHARA_BASE.cysp\" in file.name:\n                        self._current_animation_count_index = base.tell()\n                        base.write(b\"\\0\")\n                    else:\n                        self._current_base_animation_count += count\n            except FileNotFoundError as e:\n                print(f\"Ignoring {e}\")\n        base.seek(self._current_animation_count_index)\n        base.write(bytes([self._current_base_animation_count]))\n        base.seek(0)\n        return base\n\n    def get_default_base(self) -> BufferedReader:\n        if Cysp2Skel._default_base is not None:\n            Cysp2Skel._default_base.seek(0)\n            self._current_base_animation_count = Cysp2Skel._default_base_animation_count\n            self._current_animation_count_index = (\n                Cysp2Skel._default_animation_count_index\n            )\n            return Cysp2Skel._default_base\n\n        Cysp2Skel._default_base = BufferedReader(self._get_base(\"000000\"))\n        Cysp2Skel._default_base_animation_count = self._current_base_animation_count\n        Cysp2Skel._default_animation_count_index = self._current_animation_count_index\n\n        return Cysp2Skel._default_base\n\n    def get_unit_data(self) -> dict[str | dict[str | str]]:\n        unit_data = self.mdb.c.execute(\n            \"select unit_id,prefab_id,prefab_id_battle,motion_type from unit_data\"\n        ).fetchall()\n\n        unit_enemy_data = self.mdb.c.execute(\n            \"select unit_id,prefab_id,motion_type from unit_enemy_data\"\n        ).fetchall()\n\n        unit_data_dict = {\n            str(unit_id): {\n                \"motion_type\": str(motion_type),\n                \"prefab_id\": str(prefab_id),\n                \"prefab_id_battle\": str(prefab_id_battle),\n            }\n            for unit_id, prefab_id, prefab_id_battle, motion_type in unit_data\n        }\n        enemy_data_dict = {\n            str(unit_id): {\n                \"motion_type\": str(motion_type),\n                \"prefab_id\": str(prefab_id),\n            }\n            for unit_id, prefab_id, motion_type in unit_enemy_data\n        }\n\n        return {**unit_data_dict, **enemy_data_dict}\n\n    @property\n    def unit_data(self) -> dict:\n        if Cysp2Skel._unit_class_data is None:\n            Cysp2Skel._unit_class_data = self.get_unit_data()\n        return Cysp2Skel._unit_class_data\n\n    def get_skeleton_buffer(self, unit_id: int) -> BufferedReader | None:\n        base_unit_id = str(unit_id // 100) + \"01\"\n\n        if (unit := self.unit_data.get(base_unit_id)) is None:\n            for unit in self.unit_data.values():\n                if unit.get(\"prefab_id\") == base_unit_id:\n                    break\n                if unit.get(\"prefab_id_battle\") == base_unit_id:\n                    break\n\n        motion_type: str = unit.get(\"motion_type\")\n\n        if motion_type is None:\n            return None\n        if motion_type == \"0\":\n            motion_type = base_unit_id\n            self._current_base = self._get_base(base_unit_id)\n        else:\n            self._current_base = self.get_default_base()\n\n        chara_class: str = motion_type.rjust(2, \"0\")\n        files: list[str] = []\n        files.append(f\"{chara_class}_COMMON_BATTLE.cysp\")\n        # files.append(f\"{chara_class}_LOADING.cysp\")\n        files.append(f\"{unit.get('prefab_id')}_BATTLE.cysp\")\n        paths: list[Path] = [self._cysp_dir / file for file in files]\n\n        skel = BytesIO()\n        skel.write(self._current_base.read())\n        class_animation_count = 0\n        for file in paths:\n            with file.open(\"rb\") as f:\n                f.seek(12)\n                count = _read_varint(f)\n                f.seek((count + 1) * 32)\n                skel.write(f.read())\n                class_animation_count += count\n        skel.seek(self._current_animation_count_index)\n        anim_count = self._current_base_animation_count + class_animation_count\n        skel.write(bytes([anim_count]))\n        skel.seek(0)\n        return BufferedReader(cast(RawIOBase, skel))", "\n\ndef int32(x: int) -> int:\n    if x > 0xFFFFFFFF:\n        raise OverflowError\n    if x > 0x7FFFFFFF:\n        x = 0x100000000 - x\n        if x < 2147483648:\n            return -x\n        else:\n            return -2147483648\n    return x", "\n\ndef _read_byte(input: BufferedReader) -> int:\n    return struct.unpack(\">B\", input.read(1))[0]\n\n\ndef _read_varint(input: BufferedReader, optimizePositive: bool = True) -> int:\n    b = _read_byte(input)\n    value = b & 0x7F\n    if b & 0x80:\n        b = _read_byte(input)\n        value |= (b & 0x7F) << 7\n        if b & 0x80:\n            b = _read_byte(input)\n            value |= (b & 0x7F) << 14\n            if b & 0x80:\n                b = _read_byte(input)\n                value |= (b & 0x7F) << 21\n                if b & 0x80:\n                    value |= (_read_byte(input) & 0x7F) << 28\n    if not optimizePositive:\n        value = (value >> 1) ^ -(value & 1)\n    return int32(value)", ""]}
{"filename": "src/mdb.py", "chunked_list": ["import sqlite3\nfrom pathlib import Path\n\n\nclass MDB:\n    __slots__ = (\"_mdb\", \"_c\")\n\n    def __init__(self, path: str | Path) -> None:\n        self._mdb: sqlite3.Connection = sqlite3.connect(path)\n        self._c: sqlite3.Cursor = self._mdb.cursor()\n\n    @property\n    def c(self) -> sqlite3.Cursor:\n        return self._c\n\n    def __del__(self):\n        self._mdb.close()", ""]}
{"filename": "src/manifests/asset_manifest.py", "chunked_list": ["from ..config import ManifestType\nfrom .manifest import AbstractManifest, Manifest\n\n\nclass AssetManifest(AbstractManifest[Manifest]):\n    def __init__(self, version: int):\n        AbstractManifest.__init__(\n            self, \"manifest_assetmanifest\", version, ManifestType.ASSET\n        )\n\n    def _read(self) -> list[Manifest]:\n        self.download()\n        with self.path.open() as f:\n            rows = f.readlines()\n        files = []\n        for row in rows:\n            path, hash_, _, size, *_ = row.split(\",\")\n            manifest = Manifest(\n                path, hash_, self.version, ManifestType.ASSET, int(size)\n            )\n            files.append(manifest)\n        return files", ""]}
{"filename": "src/manifests/manifest.py", "chunked_list": ["from pathlib import Path\n\nfrom ..abc.abstract_manifest_file import AbstractManifestFile\nfrom ..asset_bundle import AssetBundle\nfrom ..config import ManifestType\nfrom .abstract_manifest import AbstractManifest\n\n\nclass Manifest(\n    AbstractManifestFile,\n    AbstractManifest[AssetBundle],\n):\n    def __init__(\n        self,\n        path: Path | str,\n        hash_: str,\n        version: int,\n        type_: ManifestType,\n        size: int = 0,\n    ) -> None:\n        AbstractManifest.__init__(self, path, version, type_, size)\n        AbstractManifestFile.__init__(self, path, hash_, type_, size, version)\n\n    def _read(self) -> list[AssetBundle]:\n        self.download()\n        with self.path.open() as f:\n            rows = f.readlines()\n        files = []\n        for row in rows:\n            path, hash_, _, size, *_ = row.split(\",\")\n            files.append(AssetBundle(path, hash_, int(size)))\n        return files", "class Manifest(\n    AbstractManifestFile,\n    AbstractManifest[AssetBundle],\n):\n    def __init__(\n        self,\n        path: Path | str,\n        hash_: str,\n        version: int,\n        type_: ManifestType,\n        size: int = 0,\n    ) -> None:\n        AbstractManifest.__init__(self, path, version, type_, size)\n        AbstractManifestFile.__init__(self, path, hash_, type_, size, version)\n\n    def _read(self) -> list[AssetBundle]:\n        self.download()\n        with self.path.open() as f:\n            rows = f.readlines()\n        files = []\n        for row in rows:\n            path, hash_, _, size, *_ = row.split(\",\")\n            files.append(AssetBundle(path, hash_, int(size)))\n        return files", ""]}
{"filename": "src/manifests/__init__.py", "chunked_list": ["from .asset_manifest import AssetManifest\nfrom .manifest import Manifest\nfrom .movie_manifest import MovieManifest\nfrom .sound_manifest import SoundManifest\n\n__all__ = [\n    \"AssetManifest\",\n    \"Manifest\",\n    \"MovieManifest\",\n    \"SoundManifest\",", "    \"MovieManifest\",\n    \"SoundManifest\",\n]\n"]}
{"filename": "src/manifests/abstract_manifest.py", "chunked_list": ["from abc import ABCMeta, abstractmethod\nfrom pathlib import Path\nfrom typing import Generic, TypeVar\nfrom urllib.request import urlretrieve\n\nfrom ..abc import AbstractFile\nfrom ..config import Config, ManifestType\nfrom ..files import FileContainer\nfrom ..protocols import Downloadable, File, Readable\n", "from ..protocols import Downloadable, File, Readable\n\nT = TypeVar(\"T\", bound=File)\n\n\nclass AbstractManifest(\n    AbstractFile,\n    FileContainer[T],\n    Downloadable,\n    Readable,\n    Generic[T],\n    metaclass=ABCMeta,\n):\n    __slots__ = (\"_version\",)\n\n    def __init__(\n        self,\n        path: Path | str,\n        version: int,\n        type_: ManifestType,\n        size: int = 0,\n    ) -> None:\n        AbstractFile.__init__(self, path, type_, size)\n        self._version: int = version\n        self._files: list[T] | None = None\n\n    @property\n    def name(self) -> str:\n        return self._name\n\n    @property\n    def path(self) -> Path:\n        return self._path\n\n    @property\n    def url(self) -> str:\n        endpoint = self._type.value % (str(self._version), self._name)\n        return f\"https://{Config.host.value}/{endpoint}\"\n\n    @property\n    def version(self) -> int:\n        return self._version\n\n    @property\n    def files(self) -> list[T]:\n        if self._files is None:\n            self._files = self._read()\n        return self._files\n\n    @abstractmethod\n    def _read(self) -> list[T]:\n        ...\n\n    def download(self) -> None:\n        if self.path.exists():\n            if self.path.stat().st_size == self.size:\n                return\n        self.path.parent.mkdir(parents=True, exist_ok=True)\n        urlretrieve(self.url, self.path)\n        print(f\"DL {self.url} -> {self.path.absolute()}\")", ""]}
{"filename": "src/manifests/sound_manifest.py", "chunked_list": ["from pathlib import Path\n\nfrom ..config import ManifestType\nfrom ..files.sound_file import SoundFile\nfrom .abstract_manifest import AbstractManifest\n\n\nclass SoundManifest(AbstractManifest[SoundFile]):\n    def __init__(self, version: int):\n        super().__init__(\"soundmanifest\", version, ManifestType.SOUND)\n\n    def _read(self) -> list[SoundFile]:\n        self.download()\n        with self.path.open() as f:\n            rows = f.readlines()\n        files: list[SoundFile] = []\n        for row in rows:\n            path, hash_, _, size, *_ = row.split(\",\")\n            new_path: Path = Path(path)\n            files.append(\n                SoundFile(\n                    new_path.parent / \"awb\" / new_path.name,\n                    hash_,\n                    int(size),\n                ),\n            )\n        return files", ""]}
{"filename": "src/manifests/movie_manifest.py", "chunked_list": ["from pathlib import Path\n\nfrom ..config import ManifestType\nfrom ..files import MovieFile\nfrom .abstract_manifest import AbstractManifest\n\n\nclass MovieManifest(AbstractManifest[MovieFile]):\n    def __init__(self, version: int):\n        super().__init__(\"movie2manifest\", version, ManifestType.MOVIE)\n\n    def _read(self) -> list[MovieFile]:\n        self.download()\n        with self.path.open() as f:\n            rows = f.readlines()\n        files: list[MovieFile] = []\n        for row in rows:\n            path, hash_, _, size, *_ = row.split(\",\")\n            new_path = Path(path)\n            files.append(\n                MovieFile(\n                    new_path.parent / \"usm\" / new_path.name,\n                    hash_,\n                    int(size),\n                ),\n            )\n        return files", ""]}
{"filename": "src/abc/abstract_file.py", "chunked_list": ["from abc import ABCMeta\nfrom pathlib import Path\nfrom typing import Generic, TypeVar\n\nfrom ..protocols import File\n\nT = TypeVar(\"T\")\n\n\nclass AbstractFile(File, Generic[T], metaclass=ABCMeta):\n\n    __slots__ = (\"_path\", \"_name\", \"_size\", \"_type\")\n\n    def __init__(\n        self,\n        path: Path | str,\n        type_: T,\n        size: int = 0,\n    ) -> None:\n        self._path: Path = Path(path)\n        self._name: str = self._path.name\n        self._type: T = type_\n        self._size: int = size\n\n    @property\n    def path(self) -> Path:\n        return self._path\n\n    @property\n    def name(self) -> str:\n        return self._name\n\n    @property\n    def size(self) -> int:\n        return self._size", "\nclass AbstractFile(File, Generic[T], metaclass=ABCMeta):\n\n    __slots__ = (\"_path\", \"_name\", \"_size\", \"_type\")\n\n    def __init__(\n        self,\n        path: Path | str,\n        type_: T,\n        size: int = 0,\n    ) -> None:\n        self._path: Path = Path(path)\n        self._name: str = self._path.name\n        self._type: T = type_\n        self._size: int = size\n\n    @property\n    def path(self) -> Path:\n        return self._path\n\n    @property\n    def name(self) -> str:\n        return self._name\n\n    @property\n    def size(self) -> int:\n        return self._size", ""]}
{"filename": "src/abc/__init__.py", "chunked_list": ["from .abstract_file import AbstractFile\nfrom .abstract_manifest_file import AbstractManifestFile\n\n__all__ = [\"AbstractFile\", \"AbstractManifestFile\"]\n"]}
{"filename": "src/abc/abstract_manifest_file.py", "chunked_list": ["from abc import ABCMeta\nfrom pathlib import Path\nfrom typing import Generic, TypeVar\nfrom urllib.request import urlretrieve\n\nfrom ..config import Config, ManifestType\nfrom ..protocols import Downloadable\nfrom .abstract_file import AbstractFile\n\nT = TypeVar(\"T\")", "\nT = TypeVar(\"T\")\n\n\nclass AbstractManifestFile(\n    AbstractFile,\n    Downloadable,\n    Generic[T],\n    metaclass=ABCMeta,\n):\n    def __init__(\n        self,\n        path: Path | str,\n        hash_: str,\n        type_: T,\n        size: int = 0,\n        version: int = 0,\n    ) -> None:\n        AbstractFile.__init__(self, path, type_, size)\n        self._hash = hash_\n        self._version = version\n\n    @property\n    def url(self) -> str:\n        if type(self._type) == ManifestType:\n            endpoint = f\"{self._type.value % (self._version,self.name)}\"\n        else:\n            endpoint = f\"{self._type.value}/{self._hash[:2]}/{self._hash}\"\n\n        return f\"https://{Config.host.value}/{endpoint}\"\n\n    def download(self) -> None:\n        if self.path.exists():\n            if self.path.stat().st_size == self.size:\n                return\n        self.path.parent.mkdir(parents=True, exist_ok=True)\n        urlretrieve(self.url, self.path)\n        print(f\"DL {self.url} -> {self.path.absolute()}\")", ""]}
{"filename": "src/files/file_container.py", "chunked_list": ["import re\nfrom abc import abstractmethod\nfrom typing import Generic, TypeVar\n\nfrom ..protocols import File\n\nT = TypeVar(\"T\", bound=File)\n\n\nclass FileContainer(Generic[T]):\n\n    _files: list[T] | None = None\n\n    @abstractmethod\n    def _read(self) -> list[T]:\n        ...\n\n    @property\n    def files(self) -> list[T]:\n        if self._files is None:\n            self._files = self._read()\n        return self._files\n\n    def get_file(self, match: str) -> T | None:\n        for file in self.files:\n            if re.search(match, file.name):\n                return file\n        return None\n\n    def get_files(self, match: str) -> list[T]:\n        files: list[T] = []\n        for file in self.files:\n            if re.search(match, file.name):\n                files.append(file)\n        return files", "\nclass FileContainer(Generic[T]):\n\n    _files: list[T] | None = None\n\n    @abstractmethod\n    def _read(self) -> list[T]:\n        ...\n\n    @property\n    def files(self) -> list[T]:\n        if self._files is None:\n            self._files = self._read()\n        return self._files\n\n    def get_file(self, match: str) -> T | None:\n        for file in self.files:\n            if re.search(match, file.name):\n                return file\n        return None\n\n    def get_files(self, match: str) -> list[T]:\n        files: list[T] = []\n        for file in self.files:\n            if re.search(match, file.name):\n                files.append(file)\n        return files", ""]}
{"filename": "src/files/sound_file.py", "chunked_list": ["import os\nfrom pathlib import Path\n\nfrom ..abc import AbstractManifestFile\nfrom ..config import AssetType, Config\nfrom ..protocols import Extractable\n\n\nclass SoundFile(AbstractManifestFile, Extractable):\n    def __init__(self, path: Path | str, hash_: str, size: int = 0) -> None:\n        super().__init__(path, hash_, AssetType.SOUND, size)\n\n    def extract(self) -> None:\n        self.download()\n        if \".acb\" in self.name:\n            return\n        extract_path = self.path.parent.parent / (self.path.stem + \".wav\")\n        extract_path_2 = self.path.parent.parent / (self.path.stem + \"_1.wav\")\n        if extract_path.exists() or extract_path_2.exists():\n            return\n        print(\n            f\"{Config.vgmstream_path.absolute()}\"\n            f\" -S 0 {self.path.absolute()}\"\n            f\" -o {extract_path.parent.absolute()}/?n_?s.wav\"\n        )\n        stream = os.popen(\n            f\"{Config.vgmstream_path.absolute()}\"\n            f\" -S 0 {self.path.absolute()}\"\n            f\" -o {extract_path.parent.absolute()}/?n_?s.wav\"\n        )\n        stream.read()\n        files = [*extract_path.parent.glob(f\"{self.path.stem};*\")] + [\n            *extract_path.parent.glob(f\"{self.path.stem}_*\")\n        ]\n        for file in files:\n            rename = file.stem.split(\";\")[0]\n            file = file.replace(file.with_stem(rename).absolute())\n            print(f\"EX {self.name} -> {file.absolute()}\")", "class SoundFile(AbstractManifestFile, Extractable):\n    def __init__(self, path: Path | str, hash_: str, size: int = 0) -> None:\n        super().__init__(path, hash_, AssetType.SOUND, size)\n\n    def extract(self) -> None:\n        self.download()\n        if \".acb\" in self.name:\n            return\n        extract_path = self.path.parent.parent / (self.path.stem + \".wav\")\n        extract_path_2 = self.path.parent.parent / (self.path.stem + \"_1.wav\")\n        if extract_path.exists() or extract_path_2.exists():\n            return\n        print(\n            f\"{Config.vgmstream_path.absolute()}\"\n            f\" -S 0 {self.path.absolute()}\"\n            f\" -o {extract_path.parent.absolute()}/?n_?s.wav\"\n        )\n        stream = os.popen(\n            f\"{Config.vgmstream_path.absolute()}\"\n            f\" -S 0 {self.path.absolute()}\"\n            f\" -o {extract_path.parent.absolute()}/?n_?s.wav\"\n        )\n        stream.read()\n        files = [*extract_path.parent.glob(f\"{self.path.stem};*\")] + [\n            *extract_path.parent.glob(f\"{self.path.stem}_*\")\n        ]\n        for file in files:\n            rename = file.stem.split(\";\")[0]\n            file = file.replace(file.with_stem(rename).absolute())\n            print(f\"EX {self.name} -> {file.absolute()}\")", ""]}
{"filename": "src/files/__init__.py", "chunked_list": ["from .bundle_file import BundleFile\nfrom .file_container import FileContainer\nfrom .movie_file import MovieFile\nfrom .sound_file import SoundFile\n\n__all__ = [\n    \"BundleFile\",\n    \"FileContainer\",\n    \"MovieFile\",\n    \"SoundFile\",", "    \"MovieFile\",\n    \"SoundFile\",\n]\n"]}
{"filename": "src/files/movie_file.py", "chunked_list": ["import os\nfrom pathlib import Path\n\nfrom ..abc import AbstractManifestFile\nfrom ..config import AssetType, Config\nfrom ..protocols import Extractable\n\n\nclass MovieFile(AbstractManifestFile, Extractable):\n    def __init__(self, path: Path | str, hash_: str, size: int = 0) -> None:\n        super().__init__(path, hash_, AssetType.MOVIE, size)\n\n    def extract(self) -> None:\n        self.download()\n        extract_path = self.path.parent.parent / (self.path.stem + \".mp4\")\n        if extract_path.exists():\n            return\n\n        os.system(\n            f\"cd {Config.usmtoolkit_path.parent.absolute()}\"\n            f\" && {Config.usmtoolkit_path.name} convert\"\n            f\" -c {self.path.absolute()}\"\n            f\" -o {extract_path.parent.absolute()}\"\n        )\n        print(f\"EX {self.name} -> {extract_path.absolute()}\")", "class MovieFile(AbstractManifestFile, Extractable):\n    def __init__(self, path: Path | str, hash_: str, size: int = 0) -> None:\n        super().__init__(path, hash_, AssetType.MOVIE, size)\n\n    def extract(self) -> None:\n        self.download()\n        extract_path = self.path.parent.parent / (self.path.stem + \".mp4\")\n        if extract_path.exists():\n            return\n\n        os.system(\n            f\"cd {Config.usmtoolkit_path.parent.absolute()}\"\n            f\" && {Config.usmtoolkit_path.name} convert\"\n            f\" -c {self.path.absolute()}\"\n            f\" -o {extract_path.parent.absolute()}\"\n        )\n        print(f\"EX {self.name} -> {extract_path.absolute()}\")", ""]}
{"filename": "src/files/bundle_file.py", "chunked_list": ["from __future__ import annotations\n\nimport json\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, cast\n\nimport UnityPy  # type: ignore[import]\n\nfrom src.story_deserializer import deserialize_story\n", "from src.story_deserializer import deserialize_story\n\nfrom ..config import BundleType, Config\nfrom ..protocols import Extractable\n\nif TYPE_CHECKING:\n    from ..asset_bundle import AssetBundle\n\n\nclass BundleFile(Extractable):\n    __slots__ = (\n        \"_parent_path\",\n        \"_object\",\n        \"_type\",\n        \"_data\",\n        \"image\",\n        \"script\",\n        \"container\",\n        \"_asset_name\",\n    )\n\n    def __init__(\n        self, pcr_file: AssetBundle, obj: UnityPy.environment.ObjectReader\n    ) -> None:\n        self._parent_path: Path = pcr_file.path.parent.parent\n        self._object: UnityPy.environment.ObjectReader | None = obj\n        self._type: BundleType = BundleType(obj.type.name)\n        self._data: Any = None\n        self.image: Any = None\n        self.script: Any = None\n        self.container: str | None = None\n        self._asset_name: str | None = None\n\n        # for Protocol\n        self._name = self.name\n        self._path = self.path\n        self._size = self.size\n\n    @property\n    def parent_path(self) -> Path:\n        return self._parent_path\n\n    @property\n    def type(self) -> BundleType:\n        return self._type\n\n    @property\n    def data(self) -> Any:\n        if self._data is None and self._object:\n            self._data = self._object.read()\n            self._object = None\n        return self._data\n\n    @property\n    def extention(self) -> str:\n        if self.is_image:\n            return Config().image_format\n        if self.is_text:\n            if \"storydata\" in self._asset_name:\n                return \".json\"\n            return \".txt\"\n        return \"\"\n\n    @property\n    def name(self) -> str:\n        if self._asset_name is None and self.data:\n            self._asset_name = self.data.name\n        if self._asset_name:\n            return self._asset_name + self.extention\n        else:\n            raise Exception(\"Name cannot be None.\")\n\n    @property\n    def size(self) -> int:\n        return 0\n\n    @property\n    def path(self) -> Path:\n        if self.data:\n            self.container = cast(str | None, self.data.container)\n        if self.container:\n            str_path = self.container.replace(\n                \"assets/_elementsresources/resources\", \"a\"\n            )\n            return Path(str_path).parent / self.name\n        else:\n            return self._parent_path / self.name\n\n    @property\n    def is_image(self) -> bool:\n        return self.type in [BundleType.TEXTURE_2D, BundleType.Sprite]\n\n    @property\n    def is_text(self) -> bool:\n        return self.type == BundleType.TEXT_ASSET\n\n    def extract(self) -> None:\n        if self.path.exists():\n            return\n        self.path.parent.mkdir(parents=True, exist_ok=True)\n\n        self.process_data()\n        if self.image:\n            self._extract_image()\n        elif self.script:\n            self._extract_text()\n        print(f\"EX {self.name} -> {self.path.absolute()}\")\n\n    def _extract_image(self):\n        self.image.save(self.path, lossless=True)\n\n    def _extract_text(self):\n        if \"storydata\" in self.name:\n            with self.path.open(\"w\", encoding=\"utf-8\") as f:\n                json.dump(\n                    deserialize_story(self.script),\n                    f,\n                    indent=4,\n                    ensure_ascii=False,\n                )\n        else:\n            self.path.write_bytes(self.script)\n\n    def process_data(self) -> None:\n        if self._data is None:\n            return\n        if self.is_image:\n            self.image = self.data.image\n        elif self.is_text:\n            self.script = bytes(self.data.script)\n        self._asset_name = self.data.name\n        self.container = self.data.container\n        self._data = None\n\n    def __getstate__(self) -> tuple[None, dict]:\n        self.process_data()\n        slot_dict: dict[str, Any] = {}\n        for attribute in self.__slots__:\n            slot_dict[attribute] = getattr(self, attribute)\n        return (None, slot_dict)", "\nclass BundleFile(Extractable):\n    __slots__ = (\n        \"_parent_path\",\n        \"_object\",\n        \"_type\",\n        \"_data\",\n        \"image\",\n        \"script\",\n        \"container\",\n        \"_asset_name\",\n    )\n\n    def __init__(\n        self, pcr_file: AssetBundle, obj: UnityPy.environment.ObjectReader\n    ) -> None:\n        self._parent_path: Path = pcr_file.path.parent.parent\n        self._object: UnityPy.environment.ObjectReader | None = obj\n        self._type: BundleType = BundleType(obj.type.name)\n        self._data: Any = None\n        self.image: Any = None\n        self.script: Any = None\n        self.container: str | None = None\n        self._asset_name: str | None = None\n\n        # for Protocol\n        self._name = self.name\n        self._path = self.path\n        self._size = self.size\n\n    @property\n    def parent_path(self) -> Path:\n        return self._parent_path\n\n    @property\n    def type(self) -> BundleType:\n        return self._type\n\n    @property\n    def data(self) -> Any:\n        if self._data is None and self._object:\n            self._data = self._object.read()\n            self._object = None\n        return self._data\n\n    @property\n    def extention(self) -> str:\n        if self.is_image:\n            return Config().image_format\n        if self.is_text:\n            if \"storydata\" in self._asset_name:\n                return \".json\"\n            return \".txt\"\n        return \"\"\n\n    @property\n    def name(self) -> str:\n        if self._asset_name is None and self.data:\n            self._asset_name = self.data.name\n        if self._asset_name:\n            return self._asset_name + self.extention\n        else:\n            raise Exception(\"Name cannot be None.\")\n\n    @property\n    def size(self) -> int:\n        return 0\n\n    @property\n    def path(self) -> Path:\n        if self.data:\n            self.container = cast(str | None, self.data.container)\n        if self.container:\n            str_path = self.container.replace(\n                \"assets/_elementsresources/resources\", \"a\"\n            )\n            return Path(str_path).parent / self.name\n        else:\n            return self._parent_path / self.name\n\n    @property\n    def is_image(self) -> bool:\n        return self.type in [BundleType.TEXTURE_2D, BundleType.Sprite]\n\n    @property\n    def is_text(self) -> bool:\n        return self.type == BundleType.TEXT_ASSET\n\n    def extract(self) -> None:\n        if self.path.exists():\n            return\n        self.path.parent.mkdir(parents=True, exist_ok=True)\n\n        self.process_data()\n        if self.image:\n            self._extract_image()\n        elif self.script:\n            self._extract_text()\n        print(f\"EX {self.name} -> {self.path.absolute()}\")\n\n    def _extract_image(self):\n        self.image.save(self.path, lossless=True)\n\n    def _extract_text(self):\n        if \"storydata\" in self.name:\n            with self.path.open(\"w\", encoding=\"utf-8\") as f:\n                json.dump(\n                    deserialize_story(self.script),\n                    f,\n                    indent=4,\n                    ensure_ascii=False,\n                )\n        else:\n            self.path.write_bytes(self.script)\n\n    def process_data(self) -> None:\n        if self._data is None:\n            return\n        if self.is_image:\n            self.image = self.data.image\n        elif self.is_text:\n            self.script = bytes(self.data.script)\n        self._asset_name = self.data.name\n        self.container = self.data.container\n        self._data = None\n\n    def __getstate__(self) -> tuple[None, dict]:\n        self.process_data()\n        slot_dict: dict[str, Any] = {}\n        for attribute in self.__slots__:\n            slot_dict[attribute] = getattr(self, attribute)\n        return (None, slot_dict)", ""]}
