{"filename": "setup.py", "chunked_list": ["from setuptools import setup\n\nsetup(\n    name='xapi-python',\n    author='Pawe\u0142 Knio\u0142a',\n    author_email='pawel.kn@gmail.com',\n    description='The xStation5 API Python library',\n    long_description=open('README.md', encoding='utf-8').read(),\n    license='MIT',\n    keywords='python python3 bitcoin trading websocket trading-api forex xapi forex-trading exchange-api forex-data xstation xstation5 xtb xopenhub forex-api xopenhub-api xtb-api xstation-api x-trade-brokers bfbcapital',", "    license='MIT',\n    keywords='python python3 bitcoin trading websocket trading-api forex xapi forex-trading exchange-api forex-data xstation xstation5 xtb xopenhub forex-api xopenhub-api xtb-api xstation-api x-trade-brokers bfbcapital',\n    url='https://github.com/pawelkn/xapi-python',\n    classifiers=[\n        \"Operating System :: OS Independent\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",", "        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\"\n    ],\n    python_requires='>=3.7',\n    version=\"0.1.6\",\n    packages=['xapi'],\n)", ")"]}
{"filename": "tests/test_xapi.py", "chunked_list": ["import unittest\nfrom unittest.mock import AsyncMock, patch\n\nfrom xapi import connect, XAPI, Socket, Stream, LoginFailed\n\nclass TestXAPI(unittest.IsolatedAsyncioTestCase):\n\n    async def test_xapi(self):\n        async with XAPI() as x:\n            self.assertIsInstance(x.socket, Socket)\n            self.assertIsInstance(x.stream, Stream)\n\n    @patch('xapi.xapi.Stream', return_value=AsyncMock())\n    @patch('xapi.xapi.Socket', return_value=AsyncMock())\n    async def test_connect_successful_login(self, SocketMock, _):\n        SocketMock().login.return_value = {\"status\": True, \"streamSessionId\": \"abc123\"}\n\n        async with await connect(\"myaccount\", \"mypassword\", \"ws.xtb.com\", \"real\", False) as x:\n            self.assertIsInstance(x, XAPI)\n\n            self.assertEqual(x.stream.safe, False)\n            self.assertEqual(x.socket.safe, False)\n            self.assertEqual(x.stream.streamSessionId, \"abc123\")\n\n            x.socket.connect.assert_called_once_with(\"wss://ws.xtb.com/real\")\n            x.stream.connect.assert_called_once_with(\"wss://ws.xtb.com/realStream\")\n            x.socket.login.assert_called_once_with(\"myaccount\", \"mypassword\")\n\n    @patch('xapi.xapi.Stream', return_value=AsyncMock())\n    @patch('xapi.xapi.Socket', return_value=AsyncMock())\n    async def test_connect_failed_login(self, SocketMock, _):\n        SocketMock().login.return_value = AsyncMock(return_value = {\"status\": False, \"errorCode\": 1001})\n\n        with self.assertRaises(LoginFailed):\n            await connect(\"myaccount\", \"mypassword\", \"ws.xtb.com\", \"real\", False)", ""]}
{"filename": "tests/test_stream.py", "chunked_list": ["import unittest\nfrom unittest.mock import AsyncMock\n\nfrom xapi import Stream, TradeCmd, TradeType, PeriodCode\n\n\nclass TestStream(unittest.IsolatedAsyncioTestCase):\n\n    def setUp(self):\n        self.stream = Stream()\n        self.stream._request = AsyncMock()\n        self.stream.streamSessionId = \"abc123\"\n\n    async def test_getBalance(self):\n        await self.stream.getBalance()\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"getBalance\",\n            \"streamSessionId\": \"abc123\"\n        })\n\n    async def test_stopBalance(self):\n        await self.stream.stopBalance()\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"stopBalance\"\n        })\n\n    async def test_getCandles(self):\n        await self.stream.getCandles(\"symbol\")\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"getCandles\",\n            \"streamSessionId\": \"abc123\",\n            \"symbol\": \"symbol\"\n        })\n\n    async def test_stopCandles(self):\n        await self.stream.stopCandles(\"symbol\")\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"stopCandles\",\n            \"symbol\": \"symbol\"\n        })\n\n    async def test_getKeepAlive(self):\n        await self.stream.getKeepAlive()\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"getKeepAlive\",\n            \"streamSessionId\": \"abc123\"\n        })\n\n    async def test_stopKeepAlive(self):\n        await self.stream.stopKeepAlive()\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"stopKeepAlive\"\n        })\n\n    async def test_getNews(self):\n        await self.stream.getNews()\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"getNews\",\n            \"streamSessionId\": \"abc123\"\n        })\n\n    async def test_stopNews(self):\n        await self.stream.stopNews()\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"stopNews\"\n        }\n        )\n\n    async def test_getProfits(self):\n        await self.stream.getProfits()\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"getProfits\",\n            \"streamSessionId\": \"abc123\"\n        })\n\n    async def test_stopProfits(self):\n        await self.stream.stopProfits()\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"stopProfits\"\n        })\n\n    async def test_getTickPrices(self):\n        await self.stream.getTickPrices(\"symbol\", 123, 456)\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"getTickPrices\",\n            \"streamSessionId\": \"abc123\",\n            \"symbol\": \"symbol\",\n            \"minArrivalTime\": 123,\n            \"maxLevel\": 456\n        })\n\n    async def test_stopTickPrices(self):\n        await self.stream.stopTickPrices(\"symbol\")\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"stopTickPrices\",\n            \"symbol\": \"symbol\"\n        })\n\n    async def test_getTrades(self):\n        await self.stream.getTrades()\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"getTrades\",\n            \"streamSessionId\": \"abc123\"\n        })\n\n    async def test_stopTrades(self):\n        await self.stream.stopTrades()\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"stopTrades\"\n        })\n\n    async def test_getTradeStatus(self):\n        await self.stream.getTradeStatus()\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"getTradeStatus\",\n            \"streamSessionId\": \"abc123\"\n        })\n\n    async def test_stopTradeStatus(self):\n        await self.stream.stopTradeStatus()\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"stopTradeStatus\"\n        })\n\n    async def test_ping(self):\n        await self.stream.ping()\n        self.stream._request.assert_awaited_once_with({\n            \"command\": \"ping\",\n            \"streamSessionId\": \"abc123\"\n        })"]}
{"filename": "tests/test_connection.py", "chunked_list": ["import unittest\nfrom unittest.mock import AsyncMock, patch\n\nimport websockets.client\nimport websockets.exceptions\nimport websockets.datastructures\nimport socket\nimport json\nimport asyncio\nimport time", "import asyncio\nimport time\n\nfrom xapi import Connection, ConnectionClosed\n\nclass TestConnection(unittest.IsolatedAsyncioTestCase):\n\n    async def test_connect_websocket_exception(self):\n        c = Connection()\n        with patch(\"websockets.client.connect\", new_callable=AsyncMock) as mocked_connect:\n            mocked_connect.side_effect = websockets.exceptions.InvalidStatusCode(status_code=404, headers=websockets.datastructures.Headers())\n            with self.assertRaises(ConnectionClosed) as cm:\n                await c.connect(\"ws://127.0.0.1:9000\")\n            self.assertEqual(str(cm.exception), \"WebSocket exception: server rejected WebSocket connection: HTTP 404\")\n\n    async def test_connect_socket_gaierror(self):\n        c = Connection()\n        with patch(\"websockets.client.connect\", new_callable=AsyncMock) as mocked_connect:\n            mocked_connect.side_effect = socket.gaierror()\n            with self.assertRaises(ConnectionClosed) as cm:\n                await c.connect(\"ws://127.0.0.1:9000\")\n            self.assertEqual(str(cm.exception), \"Hostname cannot be resolved\")\n\n    async def test_connect_timeout_error(self):\n        c = Connection()\n        with patch(\"websockets.client.connect\", new_callable=AsyncMock) as mocked_connect:\n            mocked_connect.side_effect = asyncio.exceptions.TimeoutError()\n            with self.assertRaises(ConnectionClosed) as cm:\n                await c.connect(\"ws://127.0.0.1:9000\")\n            self.assertEqual(str(cm.exception), \"Connection timed out\")\n\n    async def test_connect_refused_error(self):\n        c = Connection()\n        with patch(\"websockets.client.connect\", new_callable=AsyncMock) as mocked_connect:\n            mocked_connect.side_effect = ConnectionRefusedError()\n            with self.assertRaises(ConnectionClosed) as cm:\n                await c.connect(\"ws://127.0.0.1:9000\")\n            self.assertEqual(str(cm.exception), \"Connection refused\")\n\n    async def test_disconnect(self):\n        c = Connection()\n        c._conn = AsyncMock(spec=websockets.client.WebSocketClientProtocol)\n        await c.disconnect()\n        self.assertIsNone(c._conn)\n\n    async def test_disconnect_connection_closed(self):\n        c = Connection()\n        c._conn = AsyncMock(spec=websockets.client.WebSocketClientProtocol)\n        c._conn.close.side_effect = websockets.exceptions.ConnectionClosed(None, None)\n        await c.disconnect()\n        self.assertIsNone(c._conn)\n\n    async def test_listen_with_connection(self):\n        c = Connection()\n        c._conn = AsyncMock()\n        c._conn.__aiter__.return_value = iter(['{\"message\": \"Hello, world!\"}'])\n        messages = []\n        async for message in c.listen():\n            messages.append(message)\n        self.assertEqual(messages, [{\"message\": \"Hello, world!\"}])\n\n    async def test_listen_without_connection(self):\n        c = Connection()\n        with self.assertRaises(ConnectionClosed) as cm:\n            async for _ in c.listen(): pass\n        self.assertEqual(str(cm.exception), \"Not connected\")\n\n    async def test_listen_connection_closed(self):\n        c = Connection()\n        c._conn = AsyncMock()\n        c._conn.__aiter__.side_effect = websockets.exceptions.ConnectionClosed(None, None)\n        with self.assertRaises(ConnectionClosed) as cm:\n            async for _ in c.listen(): pass\n        self.assertEqual(str(cm.exception), \"WebSocket exception: no close frame received or sent\")\n\n    async def test_request_with_connection(self):\n        conn = Connection()\n        conn._conn = AsyncMock()\n        command = {\"command\": \"test\"}\n        await conn._request(command)\n        conn._conn.send.assert_called_once_with(json.dumps(command))\n\n    async def test_request_without_connection(self):\n        conn = Connection()\n        command = {\"command\": \"test\"}\n        with self.assertRaises(ConnectionClosed) as cm:\n            await conn._request(command)\n        self.assertEqual(str(cm.exception), \"Not connected\")\n\n    async def test_request_with_delay(self):\n        conn = Connection()\n        conn._conn = AsyncMock()\n        command = {\"command\": \"test\"}\n\n        # first run without delay\n        await conn._request(command)\n\n        # second run postponed by at least 200ms\n        start_time = time.time()\n        await conn._request(command)\n        end_time = time.time()\n        elapsed_time = end_time - start_time\n        self.assertGreaterEqual(elapsed_time, 0.2)\n\n    async def test_request_connection_closed(self):\n        conn = Connection()\n        conn._conn = AsyncMock()\n        conn._conn.send.side_effect = websockets.exceptions.ConnectionClosed(None, None)\n        command = {\"command\": \"test\"}\n        with self.assertRaises(ConnectionClosed) as cm:\n            await conn._request(command)\n        self.assertEqual(str(cm.exception), \"WebSocket exception: no close frame received or sent\")\n\n    async def test_transaction_with_connection(self):\n        conn = Connection()\n        conn._conn = AsyncMock()\n        command = {\"command\": \"test\"}\n        response = {\"response\": \"test\"}\n        conn._conn.recv.return_value = json.dumps(response)\n        result = await conn._transaction(command)\n        conn._conn.send.assert_called_once_with(json.dumps(command))\n        conn._conn.recv.assert_called_once()\n        self.assertEqual(result, response)\n\n    async def test_transaction_without_connection(self):\n        conn = Connection()\n        command = {\"command\": \"test\"}\n        with self.assertRaises(ConnectionClosed) as cm:\n            await conn._transaction(command)\n        self.assertEqual(str(cm.exception), \"Not connected\")\n\n    async def test_transaction_with_delay(self):\n        conn = Connection()\n        conn._conn = AsyncMock()\n        command = {\"command\": \"test\"}\n        response = {\"response\": \"test\"}\n        conn._conn.recv.return_value = json.dumps(response)\n\n        # first run without delay\n        await conn._transaction(command)\n\n        # second run postponed by at least 200ms\n        start_time = time.time()\n        await conn._transaction(command)\n        end_time = time.time()\n        elapsed_time = end_time - start_time\n        self.assertGreaterEqual(elapsed_time, 0.2)\n\n    async def test_transaction_send_connection_closed(self):\n        conn = Connection()\n        conn._conn = AsyncMock()\n        conn._conn.send.side_effect = websockets.exceptions.ConnectionClosed(None, None)\n        command = {\"command\": \"test\"}\n        with self.assertRaises(ConnectionClosed) as cm:\n            await conn._transaction(command)\n        self.assertEqual(str(cm.exception), \"WebSocket exception: no close frame received or sent\")\n\n    async def test_transaction_recv_connection_closed(self):\n        conn = Connection()\n        conn._conn = AsyncMock()\n        conn._conn.recv.side_effect = websockets.exceptions.ConnectionClosed(None, None)\n        command = {\"command\": \"test\"}\n        with self.assertRaises(ConnectionClosed) as cm:\n            await conn._transaction(command)\n        self.assertEqual(str(cm.exception), \"WebSocket exception: no close frame received or sent\")", ""]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/test_socket.py", "chunked_list": ["import unittest\nfrom unittest.mock import AsyncMock\n\nfrom xapi import Socket, TradeCmd, TradeType, PeriodCode\n\nclass TestSocket(unittest.IsolatedAsyncioTestCase):\n\n    def setUp(self):\n        self.socket = Socket()\n        self.socket._transaction = AsyncMock()\n\n    async def test_login(self):\n        await self.socket.login(\"my_account_id\", \"my_password\")\n        self.socket._transaction.assert_called_once_with({\n            \"command\": \"login\",\n            \"arguments\": {\n                \"userId\": \"my_account_id\",\n                \"password\": \"my_password\"\n            }\n        })\n\n    async def test_logout(self):\n        await self.socket.logout()\n        self.socket._transaction.assert_awaited_once_with({\"command\": \"logout\"})\n\n    async def test_getAllSymbols(self):\n        await self.socket.getAllSymbols()\n        self.socket._transaction.assert_awaited_once_with({\"command\": \"getAllSymbols\"})\n\n    async def test_getCalendar(self):\n        await self.socket.getCalendar()\n        self.socket._transaction.assert_awaited_once_with({\"command\": \"getCalendar\"})\n\n    async def test_getChartLastRequest(self):\n        await self.socket.getChartLastRequest(\"symbol\", 123, PeriodCode.PERIOD_H4)\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getChartLastRequest\",\n            \"arguments\": {\n                \"info\": {\n                    \"period\": PeriodCode.PERIOD_H4.value,\n                    \"start\": 123,\n                    \"symbol\": \"symbol\"\n                }\n            }\n        })\n\n    async def test_getChartRangeRequest(self):\n        await self.socket.getChartRangeRequest(\"symbol\", 123, 456, PeriodCode.PERIOD_M1, 10)\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getChartRangeRequest\",\n            \"arguments\": {\n                \"info\": {\n                    \"end\": 456,\n                    \"period\": PeriodCode.PERIOD_M1.value,\n                    \"start\": 123,\n                    \"symbol\": \"symbol\",\n                    \"ticks\": 10\n                }\n            }\n        })\n\n    async def test_getCommissionDef(self):\n        await self.socket.getCommissionDef(\"symbol\", 123)\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getCommissionDef\",\n            \"arguments\": {\n                \"symbol\": \"symbol\",\n                \"volume\": 123\n            }\n        })\n\n    async def test_getCurrentUserData(self):\n        await self.socket.getCurrentUserData()\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getCurrentUserData\"\n        })\n\n    async def test_getIbsHistory(self):\n        await self.socket.getIbsHistory(123, 456)\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getIbsHistory\",\n            \"arguments\": {\n                \"end\": 456,\n                \"start\": 123\n            }\n        })\n\n    async def test_getMarginLevel(self):\n        await self.socket.getMarginLevel()\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getMarginLevel\"\n        })\n\n    async def test_getMarginTrade(self):\n        await self.socket.getMarginTrade(\"symbol\", 123)\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getMarginTrade\",\n            \"arguments\": {\n                \"symbol\": \"symbol\",\n                \"volume\": 123\n            }\n        })\n\n    async def test_getNews(self):\n        await self.socket.getNews(123, 456)\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getNews\",\n            \"arguments\": {\n                \"end\": 456,\n                \"start\": 123\n            }\n        })\n\n    async def test_getProfitCalculation(self):\n        await self.socket.getProfitCalculation(\"symbol\", 1, 1.23, 4.56, 10)\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getProfitCalculation\",\n            \"arguments\": {\n                \"closePrice\": 4.56,\n                \"cmd\": 1,\n                \"openPrice\": 1.23,\n                \"symbol\": \"symbol\",\n                \"volume\": 10\n            }\n        })\n\n    async def test_getServerTime(self):\n        await self.socket.getServerTime()\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getServerTime\"\n        })\n\n    async def test_getStepRules(self):\n        await self.socket.getStepRules()\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getStepRules\"\n        })\n\n    async def test_getSymbol(self):\n        await self.socket.getSymbol(\"symbol\")\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getSymbol\",\n            \"arguments\": {\n                \"symbol\": \"symbol\"\n            }\n        })\n\n    async def test_getTickPrices(self):\n        await self.socket.getTickPrices([\"symbol_a\", \"symbol_b\"], 123)\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getTickPrices\",\n            \"arguments\": {\n                \"level\": 0,\n                \"symbols\": [\"symbol_a\", \"symbol_b\"],\n                \"timestamp\": 123\n            }\n        })\n\n    async def test_getTradeRecords(self):\n        await self.socket.getTradeRecords([123, 456])\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getTradeRecords\",\n            \"arguments\": {\n                \"orders\": [123, 456]\n            }\n        })\n\n    async def test_getTrades(self):\n        await self.socket.getTrades()\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getTrades\",\n            \"arguments\": {\n                \"openedOnly\": True\n            }\n        })\n\n    async def test_getTradesHistory(self):\n        await self.socket.getTradesHistory(123)\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getTradesHistory\",\n            \"arguments\": {\n                \"end\": 0,\n                \"start\": 123\n            }\n        })\n\n    async def test_getTradingHours(self):\n        await self.socket.getTradingHours([\"symbol_a\", \"symbol_b\"])\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getTradingHours\",\n            \"arguments\": {\n                \"symbols\": [\"symbol_a\", \"symbol_b\"]\n            }\n        })\n\n    async def test_getVersion(self):\n        await self.socket.getVersion()\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"getVersion\"\n        })\n\n    async def test_ping(self):\n        await self.socket.ping()\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"ping\"\n        })\n\n    async def test_tradeTransaction(self):\n        self.socket.safe = True\n        await self.socket.tradeTransaction(\"symbol\", TradeCmd.BUY, TradeType.OPEN, 1.23, 4.56)\n        self.socket._transaction.assert_not_awaited()\n\n        self.socket.safe = False\n        await self.socket.tradeTransaction(\"symbol\", TradeCmd.BUY, TradeType.OPEN, 1.23, 4.56)\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"tradeTransaction\",\n            \"arguments\": {\n                \"tradeTransInfo\": {\n                    \"cmd\": TradeCmd.BUY.value,\n                    \"customComment\": str(),\n                    \"expiration\": 0,\n                    \"offset\": 0,\n                    \"order\": 0,\n                    \"price\": 1.23,\n                    \"sl\": 0,\n                    \"symbol\": \"symbol\",\n                    \"tp\": 0,\n                    \"type\": TradeType.OPEN.value,\n                    \"volume\": 4.56\n                }\n            }\n        })\n\n    async def test_tradeTransactionStatus(self):\n        await self.socket.tradeTransactionStatus(123)\n        self.socket._transaction.assert_awaited_once_with({\n            \"command\": \"tradeTransactionStatus\",\n            \"arguments\": {\n                \"order\": 123\n            }\n        })", ""]}
{"filename": "xapi/enums.py", "chunked_list": ["from enum import IntEnum\n\nclass TradeCmd(IntEnum):\n    BUY = 0             # buy\n    SELL = 1            # sell\n    BUY_LIMIT = 2       # buy limit\n    SELL_LIMIT = 3      # sell limit\n    BUY_STOP = 4        # buy stop\n    SELL_STOP = 5       # sell stop\n    BALANCE = 6         # Read only. Used in getTradesHistory for manager's deposit/withdrawal operations (profit>0 for deposit, profit<0 for withdrawal).\n    CREDIT = 7          # Read only", "\nclass TradeType(IntEnum):\n    OPEN = 0            # order open, used for opening orders\n    PENDING = 1         # order pending, only used in the streaming getTrades command\n    CLOSE = 2           # order close\n    MODIFY = 3          # order modify, only used in the tradeTransaction command\n    DELETE = 4          # order delete, only used in the tradeTransaction command\n\nclass TradeStatus(IntEnum):\n    ERROR = 0           # error\n    PENDING = 1         # pending\n    ACCEPTED = 3        # The transaction has been executed successfully\n    REJECTED = 4        # The transaction has been rejected", "class TradeStatus(IntEnum):\n    ERROR = 0           # error\n    PENDING = 1         # pending\n    ACCEPTED = 3        # The transaction has been executed successfully\n    REJECTED = 4        # The transaction has been rejected\n\nclass PeriodCode(IntEnum):\n    PERIOD_M1 = 1       # 1 minute\n    PERIOD_M5 = 5       # 5 minutes\n    PERIOD_M15 = 15     # 15 minutes\n    PERIOD_M30 = 30     # 30 minutes\n    PERIOD_H1 = 60      # 60 minutes (1 hour)\n    PERIOD_H4 = 240     # 240 minutes (4 hours)\n    PERIOD_D1 = 1440    # 1440 minutes (1 day)\n    PERIOD_W1 = 10080   # 10080 minutes (1 week)\n    PERIOD_MN1 = 43200  # 43200 minutes (30 days)"]}
{"filename": "xapi/__init__.py", "chunked_list": ["\"\"\"\n.. moduleauthor:: Pawe\u0142 Knio\u0142a <pawel.kn@gmail.com>\n\"\"\"\n\nname = \"xapi\"\n__version__ = \"0.1.6\"\n\nfrom .xapi import XAPI, connect\nfrom .enums import TradeCmd, TradeType, TradeStatus, PeriodCode\nfrom .connection import Connection", "from .enums import TradeCmd, TradeType, TradeStatus, PeriodCode\nfrom .connection import Connection\nfrom .socket import Socket\nfrom .stream import Stream\nfrom .exceptions import ConnectionClosed, LoginFailed"]}
{"filename": "xapi/stream.py", "chunked_list": ["from .connection import Connection\n\n\nclass Stream(Connection):\n\n    def __init__(self):\n        super().__init__()\n        self.streamSessionId = str()\n\n    async def getBalance(self):\n        return await self._request({\n            \"command\": \"getBalance\",\n            \"streamSessionId\": self.streamSessionId\n        })\n\n    async def stopBalance(self):\n        return await self._request({\n            \"command\": \"stopBalance\"\n        })\n\n    async def getCandles(self, symbol: str):\n        return await self._request({\n            \"command\": \"getCandles\",\n            \"streamSessionId\": self.streamSessionId,\n            \"symbol\": symbol\n        })\n\n    async def stopCandles(self, symbol: str):\n        return await self._request({\n            \"command\": \"stopCandles\",\n            \"symbol\": symbol\n        })\n\n    async def getKeepAlive(self):\n        return await self._request({\n            \"command\": \"getKeepAlive\",\n            \"streamSessionId\": self.streamSessionId\n        })\n\n    async def stopKeepAlive(self):\n        return await self._request({\n            \"command\": \"stopKeepAlive\"\n        })\n\n    async def getNews(self):\n        return await self._request({\n            \"command\": \"getNews\",\n            \"streamSessionId\": self.streamSessionId\n        })\n\n    async def stopNews(self):\n        return await self._request({\n            \"command\": \"stopNews\"\n        }\n        )\n\n    async def getProfits(self):\n        return await self._request({\n            \"command\": \"getProfits\",\n            \"streamSessionId\": self.streamSessionId\n        })\n\n    async def stopProfits(self):\n        return await self._request({\n            \"command\": \"stopProfits\"\n        })\n\n    async def getTickPrices(self, symbol: str, minArrivalTime: int = 0, maxLevel: int = 2):\n        return await self._request({\n            \"command\": \"getTickPrices\",\n            \"streamSessionId\": self.streamSessionId,\n            \"symbol\": symbol,\n            \"minArrivalTime\": minArrivalTime,\n            \"maxLevel\": maxLevel\n        })\n\n    async def stopTickPrices(self, symbol: str):\n        return await self._request({\n            \"command\": \"stopTickPrices\",\n            \"symbol\": symbol\n        })\n\n    async def getTrades(self):\n        return await self._request({\n            \"command\": \"getTrades\",\n            \"streamSessionId\": self.streamSessionId\n        })\n\n    async def stopTrades(self):\n        return await self._request({\n            \"command\": \"stopTrades\"\n        })\n\n    async def getTradeStatus(self):\n        return await self._request({\n            \"command\": \"getTradeStatus\",\n            \"streamSessionId\": self.streamSessionId\n        })\n\n    async def stopTradeStatus(self):\n        return await self._request({\n            \"command\": \"stopTradeStatus\"\n        })\n\n    async def ping(self):\n        return await self._request({\n            \"command\": \"ping\",\n            \"streamSessionId\": self.streamSessionId\n        })", ""]}
{"filename": "xapi/xapi.py", "chunked_list": ["from .socket import Socket\nfrom .stream import Stream\nfrom .exceptions import LoginFailed\n\nclass XAPI:\n    def __init__(self):\n        self.socket = Socket()\n        self.stream = Stream()\n\n    async def __aenter__(self):\n        return self\n\n    async def __aexit__(self, *args):\n        await self.disconnect()\n\n    async def disconnect(self):\n        \"\"\"\n        This is an asynchronous function that closes connection to the xStation5 trading platform.\n        \"\"\"\n\n        await self.socket.disconnect()\n        await self.stream.disconnect()", "\nasync def connect(\n        accountId: str,\n        password: str,\n        host: str = \"ws.xtb.com\",\n        type: str = \"real\",\n        safe: bool = False\n    ):\n    \"\"\"\n    This is an asynchronous function that establishes a connection to the xStation5 trading platform.", "    \"\"\"\n    This is an asynchronous function that establishes a connection to the xStation5 trading platform.\n\n    Parameters\n    ----------\n    `accountId` : `str`\n        User's xStation5 account ID\n    `password` : `str`\n        User's xStation5 account password\n    `host` : `str`, `optional`", "        User's xStation5 account password\n    `host` : `str`, `optional`\n        The xStation5 trading platform host name or IP address (default is `ws.xtb.com`)\n    `type` : `str`, `optional`\n        A type of the xStation5 account, which can be either `real` or `demo` (default is `real`)\n    `safe` : `boolean`, `optional`\n        A parameter indicating whether the connection should disallow trade execution (default is `False`)\n\n    Returns\n    -------", "    Returns\n    -------\n    `XAPI`\n        An object of XAPI that can be utilized to communicate with the xStation 5 trading platform.\n\n    Raises\n    ------\n    `LoginFailed`\n        Raised when a log in failed.\n    `ConnectionClosed`", "        Raised when a log in failed.\n    `ConnectionClosed`\n        Raised when a connection has never been opened or closed unexpectedly.\n    \"\"\"\n\n    x = XAPI()\n\n    x.stream.safe = safe\n    x.socket.safe = safe\n\n    if not host.startswith(\"wss://\") and not host.startswith(\"ws://\"):\n        host = f\"wss://{host}\"", "    x.socket.safe = safe\n\n    if not host.startswith(\"wss://\") and not host.startswith(\"ws://\"):\n        host = f\"wss://{host}\"\n\n    socket_url = f\"{host}/{type}\"\n    stream_url = f\"{host}/{type}Stream\"\n\n    await x.socket.connect(socket_url)\n    await x.stream.connect(stream_url)", "    await x.socket.connect(socket_url)\n    await x.stream.connect(stream_url)\n\n    result = await x.socket.login(accountId, password)\n    if result['status'] != True:\n        raise LoginFailed(result)\n\n    x.stream.streamSessionId = result['streamSessionId']\n    return x", "    return x"]}
{"filename": "xapi/socket.py", "chunked_list": ["from .connection import Connection\nfrom .enums import TradeCmd, TradeType, PeriodCode\n\nfrom typing import List\n\nclass Socket(Connection):\n\n    async def login(self, accountId: str, password: str):\n        return await self._transaction({\n            \"command\": \"login\",\n            \"arguments\": {\n                \"userId\": accountId,\n                \"password\": password\n            }\n        })\n\n    async def logout(self):\n        return await self._transaction({\n            \"command\": \"logout\"\n        })\n\n    async def getAllSymbols(self):\n        return await self._transaction({\n            \"command\": \"getAllSymbols\"\n        })\n\n    async def getCalendar(self):\n        return await self._transaction({\n            \"command\": \"getCalendar\"\n        })\n\n    async def getChartLastRequest(self, symbol: str, start: int, period: PeriodCode):\n        return await self._transaction({\n            \"command\": \"getChartLastRequest\",\n            \"arguments\": {\n                \"info\": {\n                    \"period\": period.value,\n                    \"start\": start,\n                    \"symbol\": symbol\n                }\n            }\n        })\n\n    async def getChartRangeRequest(self, symbol: str, start: int, end: int, period: PeriodCode, ticks: int):\n        return await self._transaction({\n            \"command\": \"getChartRangeRequest\",\n            \"arguments\": {\n                \"info\": {\n                    \"end\": end,\n                    \"period\": period.value,\n                    \"start\": start,\n                    \"symbol\": symbol,\n                    \"ticks\": ticks\n                }\n            }\n        })\n\n    async def getCommissionDef(self, symbol: str, volume: float):\n        return await self._transaction({\n            \"command\": \"getCommissionDef\",\n            \"arguments\": {\n                \"symbol\": symbol,\n                \"volume\": volume\n            }\n        })\n\n    async def getCurrentUserData(self):\n        return await self._transaction({\n            \"command\": \"getCurrentUserData\"\n        })\n\n    async def getIbsHistory(self, start: int, end: int):\n        return await self._transaction({\n            \"command\": \"getIbsHistory\",\n            \"arguments\": {\n                \"end\": end,\n                \"start\": start\n            }\n        })\n\n    async def getMarginLevel(self):\n        return await self._transaction({\n            \"command\": \"getMarginLevel\"\n        })\n\n    async def getMarginTrade(self, symbol: str, volume: float):\n        return await self._transaction({\n            \"command\": \"getMarginTrade\",\n            \"arguments\": {\n                \"symbol\": symbol,\n                \"volume\": volume\n            }\n        })\n\n    async def getNews(self, start: int, end: int):\n        return await self._transaction({\n            \"command\": \"getNews\",\n            \"arguments\": {\n                \"end\": end,\n                \"start\": start\n            }\n        })\n\n    async def getProfitCalculation(self, symbol: str, cmd: int, openPrice: float, closePrice: float, volume: float):\n        return await self._transaction({\n            \"command\": \"getProfitCalculation\",\n            \"arguments\": {\n                \"closePrice\": closePrice,\n                \"cmd\": cmd,\n                \"openPrice\": openPrice,\n                \"symbol\": symbol,\n                \"volume\": volume\n            }\n        })\n\n    async def getServerTime(self):\n        return await self._transaction({\n            \"command\": \"getServerTime\"\n        })\n\n    async def getStepRules(self):\n        return await self._transaction({\n            \"command\": \"getStepRules\"\n        })\n\n    async def getSymbol(self, symbol: str):\n        return await self._transaction({\n            \"command\": \"getSymbol\",\n            \"arguments\": {\n                \"symbol\": symbol\n            }\n        })\n\n    async def getTickPrices(self, symbols: List[str], timestamp: int, level: int = 0 ):\n        return await self._transaction({\n            \"command\": \"getTickPrices\",\n            \"arguments\": {\n                \"level\": level,\n                \"symbols\": symbols,\n                \"timestamp\": timestamp\n            }\n        })\n\n    async def getTradeRecords(self, orders: List[int]):\n        return await self._transaction({\n            \"command\": \"getTradeRecords\",\n            \"arguments\": {\n                \"orders\": orders\n            }\n        })\n\n    async def getTrades(self, openedOnly: bool = True):\n        return await self._transaction({\n            \"command\": \"getTrades\",\n            \"arguments\": {\n                \"openedOnly\": openedOnly\n            }\n        })\n\n    async def getTradesHistory(self, start: int, end: int = 0):\n        return await self._transaction({\n            \"command\": \"getTradesHistory\",\n            \"arguments\": {\n                \"end\": end,\n                \"start\": start\n            }\n        })\n\n    async def getTradingHours(self, symbols: List[str]):\n        return await self._transaction({\n            \"command\": \"getTradingHours\",\n            \"arguments\": {\n                \"symbols\": symbols\n            }\n        })\n\n    async def getVersion(self):\n        return await self._transaction({\n            \"command\": \"getVersion\"\n        })\n\n    async def ping(self):\n        return await self._transaction({\n            \"command\": \"ping\"\n        })\n\n    async def tradeTransaction(self, symbol: str, cmd: TradeCmd, type: TradeType, price: float, volume: float,\n                               sl: float = 0, tp: float = 0, order: int = 0, expiration: int = 0,\n                               offset: int = 0, customComment: str = str()):\n        if self.safe == True:\n            return {\n                \"status\": False,\n                'errorCode': 'N/A',\n                'errorDescr': 'Trading is disabled when safe=True'\n            }\n\n        return await self._transaction({\n            \"command\": \"tradeTransaction\",\n            \"arguments\": {\n                \"tradeTransInfo\": {\n                    \"cmd\": cmd.value,\n                    \"customComment\": customComment,\n                    \"expiration\": expiration,\n                    \"offset\": offset,\n                    \"order\": order,\n                    \"price\": price,\n                    \"sl\": sl,\n                    \"symbol\": symbol,\n                    \"tp\":   tp,\n                    \"type\": type.value,\n                    \"volume\": volume\n                }\n            }\n        })\n\n    async def tradeTransactionStatus(self, order: int):\n        return await self._transaction({\n            \"command\": \"tradeTransactionStatus\",\n            \"arguments\": {\n                \"order\": order\n            }\n        })", ""]}
{"filename": "xapi/exceptions.py", "chunked_list": ["class LoginFailed(Exception):\n    \"\"\"\n    Raised when a log in failed.\n    \"\"\"\n\nclass ConnectionClosed(Exception):\n    \"\"\"\n    Raised when a connection has never been opened or closed unexpectedly.\n    \"\"\""]}
{"filename": "xapi/connection.py", "chunked_list": ["from .exceptions import ConnectionClosed\n\nimport websockets.client\nimport websockets.exceptions\nimport socket\nimport asyncio\nimport json\nimport time\n\nclass Connection():\n    def __init__(self):\n        self.safe = False\n        self._conn = None\n        self._lock = asyncio.Lock()\n        self._last_request_time = None\n\n    async def connect(self, url):\n        try:\n            self._conn = await websockets.client.connect(url, close_timeout=0, max_size=None)\n\n        except websockets.exceptions.WebSocketException as e:\n            raise ConnectionClosed(f\"WebSocket exception: {e}\")\n\n        except socket.gaierror:\n            raise ConnectionClosed(\"Hostname cannot be resolved\")\n\n        except asyncio.exceptions.TimeoutError:\n            raise ConnectionClosed(\"Connection timed out\")\n\n        except ConnectionRefusedError:\n            raise ConnectionClosed(\"Connection refused\")\n\n    async def disconnect(self):\n        try:\n            if self._conn:\n                await self._conn.close()\n\n        except websockets.exceptions.ConnectionClosed:\n            pass\n\n        self._conn = None\n\n    async def listen(self):\n        try:\n            if self._conn:\n                async for message in self._conn:\n                    yield json.loads(message)\n            else:\n                raise ConnectionClosed(\"Not connected\")\n\n        except websockets.exceptions.WebSocketException as e:\n            self._conn = None\n            raise ConnectionClosed(f\"WebSocket exception: {e}\")\n\n    async def _request(self, command):\n        if self._last_request_time is not None:\n            elapsed_time = time.time() - self._last_request_time\n            if elapsed_time < 0.2:\n                await asyncio.sleep(0.2 - elapsed_time)\n\n        try:\n            if self._conn:\n                await self._conn.send(json.dumps(command))\n                self._last_request_time = time.time()\n            else:\n                raise ConnectionClosed(\"Not connected\")\n\n        except websockets.exceptions.WebSocketException as e:\n            self._conn = None\n            raise ConnectionClosed(f\"WebSocket exception: {e}\")\n\n    async def _transaction(self, command):\n        async with self._lock:\n            try:\n                if self._conn:\n                    await self._request(command)\n                    response = await self._conn.recv()\n                    return json.loads(response)\n                else:\n                    raise ConnectionClosed(\"Not connected\")\n\n            except websockets.exceptions.WebSocketException as e:\n                self._conn = None\n                raise ConnectionClosed(f\"WebSocket exception: {e}\")", "\nclass Connection():\n    def __init__(self):\n        self.safe = False\n        self._conn = None\n        self._lock = asyncio.Lock()\n        self._last_request_time = None\n\n    async def connect(self, url):\n        try:\n            self._conn = await websockets.client.connect(url, close_timeout=0, max_size=None)\n\n        except websockets.exceptions.WebSocketException as e:\n            raise ConnectionClosed(f\"WebSocket exception: {e}\")\n\n        except socket.gaierror:\n            raise ConnectionClosed(\"Hostname cannot be resolved\")\n\n        except asyncio.exceptions.TimeoutError:\n            raise ConnectionClosed(\"Connection timed out\")\n\n        except ConnectionRefusedError:\n            raise ConnectionClosed(\"Connection refused\")\n\n    async def disconnect(self):\n        try:\n            if self._conn:\n                await self._conn.close()\n\n        except websockets.exceptions.ConnectionClosed:\n            pass\n\n        self._conn = None\n\n    async def listen(self):\n        try:\n            if self._conn:\n                async for message in self._conn:\n                    yield json.loads(message)\n            else:\n                raise ConnectionClosed(\"Not connected\")\n\n        except websockets.exceptions.WebSocketException as e:\n            self._conn = None\n            raise ConnectionClosed(f\"WebSocket exception: {e}\")\n\n    async def _request(self, command):\n        if self._last_request_time is not None:\n            elapsed_time = time.time() - self._last_request_time\n            if elapsed_time < 0.2:\n                await asyncio.sleep(0.2 - elapsed_time)\n\n        try:\n            if self._conn:\n                await self._conn.send(json.dumps(command))\n                self._last_request_time = time.time()\n            else:\n                raise ConnectionClosed(\"Not connected\")\n\n        except websockets.exceptions.WebSocketException as e:\n            self._conn = None\n            raise ConnectionClosed(f\"WebSocket exception: {e}\")\n\n    async def _transaction(self, command):\n        async with self._lock:\n            try:\n                if self._conn:\n                    await self._request(command)\n                    response = await self._conn.recv()\n                    return json.loads(response)\n                else:\n                    raise ConnectionClosed(\"Not connected\")\n\n            except websockets.exceptions.WebSocketException as e:\n                self._conn = None\n                raise ConnectionClosed(f\"WebSocket exception: {e}\")"]}
{"filename": "examples/get-symbol.py", "chunked_list": ["import logging\nimport asyncio\nimport json\nimport xapi\n\nlogging.basicConfig(level=logging.INFO)\n\nwith open(\"credentials.json\", \"r\") as f:\n    CREDENTIALS = json.load(f)\n", "\nasync def main():\n    try:\n        async with await xapi.connect(**CREDENTIALS) as x:\n            response = await x.socket.getSymbol(\"BITCOIN\")\n            if response['status'] == True:\n                print(response['returnData'])\n            else:\n                print(\"Failed to get symbol\", response)\n\n    except xapi.LoginFailed as e:\n        print(f\"Log in failed: {e}\")\n\n    except xapi.ConnectionClosed as e:\n        print(f\"Connection closed: {e}\")", "\nif __name__ == \"__main__\":\n    asyncio.run(main())"]}
{"filename": "examples/get-balance.py", "chunked_list": ["import logging\nimport asyncio\nimport json\nimport xapi\n\nlogging.basicConfig(level=logging.INFO)\n\nwith open(\"credentials.json\", \"r\") as f:\n    CREDENTIALS = json.load(f)\n", "\nasync def main():\n    while True:\n        try:\n            async with await xapi.connect(**CREDENTIALS) as x:\n                await x.stream.getBalance()\n\n                async for message in x.stream.listen():\n                    print(message['data'])\n\n        except xapi.LoginFailed as e:\n            print(f\"Log in failed: {e}\")\n            return\n\n        except xapi.ConnectionClosed as e:\n            print(f\"Connection closed: {e}, reconnecting ...\")\n            await asyncio.sleep(1)\n            continue", "\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n\n    except KeyboardInterrupt:\n        pass"]}
{"filename": "examples/get-trades-history.py", "chunked_list": ["import logging\nimport asyncio\nimport json\nimport xapi\n\nlogging.basicConfig(level=logging.INFO)\n\nwith open(\"credentials.json\", \"r\") as f:\n    CREDENTIALS = json.load(f)\n", "\n# start from the first day of a current year\nfrom datetime import datetime as dt\nSTART = round(dt.today().replace(month=1, day=1).timestamp() * 1000)\n\nasync def main():\n    try:\n        async with await xapi.connect(**CREDENTIALS) as x:\n            response = await x.socket.getTradesHistory(START)\n            if response['status'] == True:\n                print(response['returnData'])\n            else:\n                print(\"Failed to get trades history\", response)\n\n    except xapi.LoginFailed as e:\n        print(f\"Log in failed: {e}\")\n\n    except xapi.ConnectionClosed as e:\n        print(f\"Connection closed: {e}\")", "\nif __name__ == \"__main__\":\n    asyncio.run(main())"]}
{"filename": "examples/get-margin-level.py", "chunked_list": ["import logging\nimport asyncio\nimport json\nimport xapi\n\nlogging.basicConfig(level=logging.INFO)\n\nwith open(\"credentials.json\", \"r\") as f:\n    CREDENTIALS = json.load(f)\n", "\nasync def main():\n    try:\n        async with await xapi.connect(**CREDENTIALS) as x:\n            response = await x.socket.getMarginLevel()\n            if response['status'] == True:\n                print(response['returnData'])\n            else:\n                print(\"Failed to get margin level\", response)\n\n    except xapi.LoginFailed as e:\n        print(f\"Log in failed: {e}\")\n\n    except xapi.ConnectionClosed as e:\n        print(f\"Connection closed: {e}\")", "\nif __name__ == \"__main__\":\n    asyncio.run(main())"]}
{"filename": "examples/get-all-symbols.py", "chunked_list": ["import logging\nimport asyncio\nimport json\nimport xapi\n\nlogging.basicConfig(level=logging.INFO)\n\nwith open(\"credentials.json\", \"r\") as f:\n    CREDENTIALS = json.load(f)\n", "\nasync def main():\n    try:\n        async with await xapi.connect(**CREDENTIALS) as x:\n            response = await x.socket.getAllSymbols()\n            if response['status'] == True:\n                print(response['returnData'])\n            else:\n                print(\"Failed to get all symbols\", response)\n\n    except xapi.LoginFailed as e:\n        print(f\"Log in failed: {e}\")\n\n    except xapi.ConnectionClosed as e:\n        print(f\"Connection closed: {e}\")", "\nif __name__ == \"__main__\":\n    asyncio.run(main())"]}
{"filename": "examples/get-tick-prices.py", "chunked_list": ["import logging\nimport asyncio\nimport json\nimport xapi\n\nlogging.basicConfig(level=logging.INFO)\n\nwith open(\"credentials.json\", \"r\") as f:\n    CREDENTIALS = json.load(f)\n", "\nasync def main():\n    while True:\n        try:\n            async with await xapi.connect(**CREDENTIALS) as x:\n                await x.stream.getTickPrices(\"BITCOIN\")\n                await x.stream.getTickPrices(\"ETHEREUM\")\n\n                async for message in x.stream.listen():\n                    print(message['data'])\n\n        except xapi.LoginFailed as e:\n            print(f\"Log in failed: {e}\")\n            return\n\n        except xapi.ConnectionClosed as e:\n            print(f\"Connection closed: {e}, reconnecting ...\")\n            await asyncio.sleep(1)\n            continue", "\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n\n    except KeyboardInterrupt:\n        pass"]}
{"filename": "examples/trade-transaction.py", "chunked_list": ["import logging\nimport asyncio\nimport json\nimport xapi\nfrom xapi import TradeCmd, TradeType, TradeStatus\n\nlogging.basicConfig(level=logging.INFO)\n\nwith open(\"credentials.json\", \"r\") as f:\n    CREDENTIALS = json.load(f)", "with open(\"credentials.json\", \"r\") as f:\n    CREDENTIALS = json.load(f)\n\nasync def main():\n    try:\n        async with await xapi.connect(**CREDENTIALS) as x:\n            response = await x.socket.tradeTransaction(\n                symbol=\"BITCOIN\",\n                cmd=TradeCmd.BUY_LIMIT,\n                type=TradeType.OPEN,\n                price=10.00,\n                volume=1\n            )\n\n            if response['status'] != True:\n                print(\"Failed to trade a transaction\", response)\n                return\n\n            order = response['returnData']['order']\n\n            response = await x.socket.tradeTransactionStatus(order)\n            if response['status'] != True:\n                print(\"Failed to trade a transaction\", response)\n                return\n\n            requestStatus = response['returnData']['requestStatus']\n            if requestStatus == TradeStatus.ERROR.value:\n                print(f\"The transaction finished with error: {response['returnData']['message']}\")\n            elif requestStatus == TradeStatus.PENDING.value:\n                print(f\"The transaction is pending\")\n            elif requestStatus == TradeStatus.ACCEPTED.value:\n                print(f\"The transaction has been executed successfully\")\n            elif requestStatus == TradeStatus.REJECTED.value:\n                print(f\"The transaction has been rejected: {response['returnData']['message']}\")\n\n    except xapi.LoginFailed as e:\n        print(f\"Log in failed: {e}\")\n\n    except xapi.ConnectionClosed as e:\n        print(f\"Connection closed: {e}\")", "\nif __name__ == \"__main__\":\n    asyncio.run(main())"]}
