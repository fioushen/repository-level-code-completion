{"filename": "tasks.py", "chunked_list": ["\"\"\"Invoke tasks.\"\"\"\nimport os\n\nfrom distutils.util import strtobool\nfrom invoke import Collection, task as invoke_task\n\n\nNETBOX_VERSION = \"v3.4.4\"\n\nnamespace = Collection(\"netbox\")", "\nnamespace = Collection(\"netbox\")\nnamespace.configure(\n    {\n        \"netbox\": {\n            \"project_name\": \"netbox-nornir\",\n            \"python_ver\": \"3.9\",\n            \"local\": bool(strtobool(os.environ.get(\"INVOKE_NETBOX_LOCAL\", \"false\"))),\n            \"compose_dir\": os.path.join(os.path.dirname(__file__), \"docker/\"),\n            \"local_compose_files\": [", "            \"compose_dir\": os.path.join(os.path.dirname(__file__), \"docker/\"),\n            \"local_compose_files\": [\n                \"docker-compose.local.yml\",\n            ],\n            \"dev_compose_files\": [\n                \"docker-compose.yml\",\n                \"docker-compose.dev.yml\",\n            ],\n            \"prod_compose_files\": [\n                \"docker-compose.yml\",", "            \"prod_compose_files\": [\n                \"docker-compose.yml\",\n                \"docker-compose.prod.yml\",\n            ],\n        }\n    }\n)\n\n\ndef is_truthy(arg):\n    \"\"\"Convert \"truthy\" strings into Booleans.\n\n    Examples:\n        >>> is_truthy('yes')\n        True\n    Args:\n        arg (str): Truthy string (True values are y, yes, t, true, on and 1; false values are n, no,\n        f, false, off and 0. Raises ValueError if val is anything else.\n    \"\"\"\n    if isinstance(arg, bool):\n        return arg\n    return bool(strtobool(arg))", "\ndef is_truthy(arg):\n    \"\"\"Convert \"truthy\" strings into Booleans.\n\n    Examples:\n        >>> is_truthy('yes')\n        True\n    Args:\n        arg (str): Truthy string (True values are y, yes, t, true, on and 1; false values are n, no,\n        f, false, off and 0. Raises ValueError if val is anything else.\n    \"\"\"\n    if isinstance(arg, bool):\n        return arg\n    return bool(strtobool(arg))", "\n\ndef task(function=None, *args, **kwargs):\n    \"\"\"Task decorator to override the default Invoke task decorator.\"\"\"\n\n    def task_wrapper(function=None):\n        \"\"\"Wrapper around invoke.task to add the task to the namespace as well.\"\"\"\n        if args or kwargs:\n            task_func = invoke_task(*args, **kwargs)(function)\n        else:\n            task_func = invoke_task(function)\n        namespace.add_task(task_func)\n        return task_func\n\n    if function:\n        # The decorator was called with no arguments\n        return task_wrapper(function)\n    # The decorator was called with arguments\n    return task_wrapper", "\n\ndef docker_compose(context, command, target=\"dev\", **kwargs):\n    \"\"\"Helper function for running a specific docker compose command with all appropriate parameters and environment.\n\n    Args:\n        context (obj): Used to run specific commands\n        command (str): Command string to append to the \"docker compose ...\" command, such as \"build\", \"up\", etc.\n        **kwargs: Passed through to the context.run() call.\n    \"\"\"\n    compose_command = f'docker compose --project-name {context.netbox.project_name} --project-directory \"{context.netbox.compose_dir}\"'\n\n    for compose_file in getattr(context.netbox, f\"{target}_compose_files\"):\n        compose_file_path = os.path.join(context.netbox.compose_dir, compose_file)\n        compose_command += f' -f \"{compose_file_path}\"'\n\n    compose_command += f\" {command}\"\n\n    # If `service` was passed as a kwarg, add it to the end.\n    service = kwargs.pop(\"service\", None)\n    if service is not None:\n        compose_command += f\" {service}\"\n\n    print(f'Running docker compose command \"{command}\"')\n\n    return context.run(\n        compose_command,\n        env={\"PYTHON_VER\": context.netbox.python_ver},\n        **kwargs,\n    )", "\n\ndef run_cmd(context, command, **kwargs):\n    \"\"\"Run a command locally or inside container.\"\"\"\n    if is_truthy(context.netbox.local):\n        context.run(command, pty=True, **kwargs)\n    else:\n        # Check if netbox is running; no need to start another netbox container to run a command\n        docker_compose_status = \"ps --services --filter status=running\"\n        results = docker_compose(context, docker_compose_status, hide=\"out\")\n        if \"netbox\" in results.stdout:\n            compose_command = f\"exec netbox {command}\"\n        else:\n            compose_command = f\"run --entrypoint '{command}' netbox\"\n        docker_compose(context, compose_command, pty=True)", "\n\n@task(help={\"container\": \"Name of the container to shell into\"})\ndef cli(context, container=\"netbox\"):\n    \"\"\"Launch a bash shell inside the running netbox container.\"\"\"\n    docker_compose(context, f\"exec {container} bash\", pty=True)\n\n\n@task(\n    help={", "@task(\n    help={\n        \"user\": \"Name of the superuser to create. (Default: admin)\",\n    }\n)\ndef createsuperuser(context, user=\"admin\"):\n    \"\"\"Create a new netbox superuser account (default: \"admin\"), will prompt for password.\"\"\"\n    command = \"python manage.py createsuperuser --username admin\"\n    run_cmd(context, command)\n", "\n\n@task(\n    help={\n        \"force_rm\": \"Always remove intermediate containers.\",\n        \"cache\": \"Whether to use Docker's cache when building the image. (Default: enabled)\",\n    }\n)\ndef build(\n    context,\n    force_rm=False,\n    cache=True,\n    target=\"dev\",\n    image_name=\"netbox\",\n    tag=\"latest\",\n):\n    \"\"\"Build netbox docker image.\"\"\"\n    command = f\"build --build-arg PYTHON_VER={context.netbox.python_ver}\"\n\n    if not cache:\n        command += \" --no-cache\"\n    if force_rm:\n        command += \" --force-rm\"\n\n    print(f\"Building netbox with Python {context.netbox.python_ver}...\")\n    docker_compose(context, command, target=target)", "def build(\n    context,\n    force_rm=False,\n    cache=True,\n    target=\"dev\",\n    image_name=\"netbox\",\n    tag=\"latest\",\n):\n    \"\"\"Build netbox docker image.\"\"\"\n    command = f\"build --build-arg PYTHON_VER={context.netbox.python_ver}\"\n\n    if not cache:\n        command += \" --no-cache\"\n    if force_rm:\n        command += \" --force-rm\"\n\n    print(f\"Building netbox with Python {context.netbox.python_ver}...\")\n    docker_compose(context, command, target=target)", "\n\n@task(\n    help={\n        \"cache\": \"Whether to use Docker's cache when building the image. (Default: enabled)\",\n        \"cache_dir\": \"Directory to use for caching buildx output. (Default: /home/travis/.cache/docker)\",\n        \"platforms\": \"Comma-separated list of strings for which to build. (Default: linux/amd64)\",\n        \"target\": \"Build target from the Dockerfile. (Default: dev)\",\n    }\n)\ndef buildx(\n    context,\n    cache=False,\n    cache_dir=\"\",\n    platforms=\"linux/amd64\",\n    target=\"dev\",\n    image_name=\"netbox\",\n):\n    \"\"\"Build netbox docker image using the experimental buildx docker functionality (multi-arch capablility).\"\"\"\n    print(f\"Building netbox with Python {context.netbox.python_ver} for {platforms}...\")\n    command = f\"docker buildx build --tag {image_name} --platform {platforms} --load -f ./docker/Dockerfile --build-arg PYTHON_VER={context.netbox.python_ver} .\"\n    if not cache:\n        command += \" --no-cache\"\n    else:\n        command += f\" --cache-to type=local,dest={cache_dir}/{context.netbox.python_ver} --cache-from type=local,src={cache_dir}/{context.netbox.python_ver}\"\n\n    context.run(command, env={\"PYTHON_VER\": context.netbox.python_ver})", "    }\n)\ndef buildx(\n    context,\n    cache=False,\n    cache_dir=\"\",\n    platforms=\"linux/amd64\",\n    target=\"dev\",\n    image_name=\"netbox\",\n):\n    \"\"\"Build netbox docker image using the experimental buildx docker functionality (multi-arch capablility).\"\"\"\n    print(f\"Building netbox with Python {context.netbox.python_ver} for {platforms}...\")\n    command = f\"docker buildx build --tag {image_name} --platform {platforms} --load -f ./docker/Dockerfile --build-arg PYTHON_VER={context.netbox.python_ver} .\"\n    if not cache:\n        command += \" --no-cache\"\n    else:\n        command += f\" --cache-to type=local,dest={cache_dir}/{context.netbox.python_ver} --cache-from type=local,src={cache_dir}/{context.netbox.python_ver}\"\n\n    context.run(command, env={\"PYTHON_VER\": context.netbox.python_ver})", "\n\n@task(\n    help={\n        \"cache\": \"Whether to use Docker's cache when building the image. (Default: enabled)\",\n        \"cache_dir\": \"Directory to use for caching buildx output. (Default: /home/travis/.cache/docker)\",\n        \"platforms\": \"Comma-separated list of strings for which to build. (Default: linux/amd64)\",\n        \"target\": \"Build target from the Dockerfile. (Default: dev)\",\n    }\n)\ndef docker_build(\n    context,\n    cache=False,\n    cache_dir=\"\",\n    platforms=\"linux/amd64\",\n    target=\"dev\",\n    image_name=\"netbox\",\n):\n    \"\"\"Build netbox docker image using the experimental buildx docker functionality (multi-arch capablility).\"\"\"\n    print(f\"Building netbox with Python {context.netbox.python_ver} for {platforms}...\")\n    command = f\"docker build --tag {image_name} --platform {platforms} --target {target} -f ./docker/Dockerfile --build-arg PYTHON_VER={context.netbox.python_ver} .\"\n    if not cache:\n        command += \" --no-cache\"\n    else:\n        command += f\" --cache-to type=local,dest={cache_dir}/{context.netbox.python_ver} --cache-from type=local,src={cache_dir}/{context.netbox.python_ver}\"\n\n    context.run(command, env={\"PYTHON_VER\": context.netbox.python_ver})", "    }\n)\ndef docker_build(\n    context,\n    cache=False,\n    cache_dir=\"\",\n    platforms=\"linux/amd64\",\n    target=\"dev\",\n    image_name=\"netbox\",\n):\n    \"\"\"Build netbox docker image using the experimental buildx docker functionality (multi-arch capablility).\"\"\"\n    print(f\"Building netbox with Python {context.netbox.python_ver} for {platforms}...\")\n    command = f\"docker build --tag {image_name} --platform {platforms} --target {target} -f ./docker/Dockerfile --build-arg PYTHON_VER={context.netbox.python_ver} .\"\n    if not cache:\n        command += \" --no-cache\"\n    else:\n        command += f\" --cache-to type=local,dest={cache_dir}/{context.netbox.python_ver} --cache-from type=local,src={cache_dir}/{context.netbox.python_ver}\"\n\n    context.run(command, env={\"PYTHON_VER\": context.netbox.python_ver})", "\n\n@task(help={\"service\": \"If specified, only affect this service.\"})\ndef debug(context, service=None, target=\"dev\"):\n    \"\"\"Start netbox and its dependencies in debug mode.\"\"\"\n    print(\"Starting netbox in debug mode...\")\n    docker_compose(context, \"up\", service=service, target=target)\n\n\n@task(help={\"service\": \"If specified, only affect this service.\"})\ndef start(context, service=None, target=\"dev\"):\n    \"\"\"Start netbox and its dependencies in detached mode.\"\"\"\n    print(\"Starting netbox in detached mode...\")\n    docker_compose(context, \"up --detach\", service=service, target=target)", "\n@task(help={\"service\": \"If specified, only affect this service.\"})\ndef start(context, service=None, target=\"dev\"):\n    \"\"\"Start netbox and its dependencies in detached mode.\"\"\"\n    print(\"Starting netbox in detached mode...\")\n    docker_compose(context, \"up --detach\", service=service, target=target)\n\n\n@task(help={\"service\": \"If specified, only affect this service.\"})\ndef restart(context, service=None, target=\"dev\"):\n    \"\"\"Gracefully restart containers.\"\"\"\n    print(\"Restarting netbox...\")\n    docker_compose(context, \"restart\", service=service, target=target)", "@task(help={\"service\": \"If specified, only affect this service.\"})\ndef restart(context, service=None, target=\"dev\"):\n    \"\"\"Gracefully restart containers.\"\"\"\n    print(\"Restarting netbox...\")\n    docker_compose(context, \"restart\", service=service, target=target)\n\n\n@task(help={\"service\": \"If specified, only affect this service.\"})\ndef stop(context, service=None, target=\"dev\"):\n    \"\"\"Stop netbox and its dependencies.\"\"\"\n    print(\"Stopping netbox...\")\n    if not service:\n        docker_compose(context, \"down\", target=target)\n    else:\n        docker_compose(context, \"stop\", service=service, target=target)", "def stop(context, service=None, target=\"dev\"):\n    \"\"\"Stop netbox and its dependencies.\"\"\"\n    print(\"Stopping netbox...\")\n    if not service:\n        docker_compose(context, \"down\", target=target)\n    else:\n        docker_compose(context, \"stop\", service=service, target=target)\n\n\n@task\ndef destroy(context, target=\"dev\"):\n    \"\"\"Destroy all containers and volumes.\"\"\"\n    print(\"Destroying netbox...\")\n    docker_compose(context, \"down --volumes\", target=target)", "\n@task\ndef destroy(context, target=\"dev\"):\n    \"\"\"Destroy all containers and volumes.\"\"\"\n    print(\"Destroying netbox...\")\n    docker_compose(context, \"down --volumes\", target=target)\n\n\n@task\ndef build_local_env(context):\n    \"\"\"Build local environment for development.\"\"\"\n    print(\"Building local environment...\")\n\n    context.run(\"rm -rf netbox\")\n    context.run(\"mkdir netbox\")\n    context.run(\n        f\"curl -L https://codeload.github.com/netbox-community/netbox/tar.gz/refs/tags/{NETBOX_VERSION} | tar -xz --strip=1 -C ./netbox\"\n    )\n    context.run(\"pip install -r ./netbox/requirements.txt\")\n    context.run(\"poetry install\")\n    if not os.path.isfile(\"./docker/configuration/configuration.py\"):\n        context.run(\n            \"cp $(pwd)/docker/configuration/configuration.example.py $(pwd)/docker/configuration/configuration.py\"\n        )\n    if not os.path.islink(\"./netbox/netbox/netbox/configuration.py\"):\n        context.run(\"rm -f $(pwd)/netbox/netbox/netbox/configuration.py\")\n        context.run(\"ln -s $(pwd)/docker/configuration/configuration.py $(pwd)/netbox/netbox/netbox/\")\n    print(\"To run with containerized db use `invoke debug --target=local` before starting Django process.\")", "@task\ndef build_local_env(context):\n    \"\"\"Build local environment for development.\"\"\"\n    print(\"Building local environment...\")\n\n    context.run(\"rm -rf netbox\")\n    context.run(\"mkdir netbox\")\n    context.run(\n        f\"curl -L https://codeload.github.com/netbox-community/netbox/tar.gz/refs/tags/{NETBOX_VERSION} | tar -xz --strip=1 -C ./netbox\"\n    )\n    context.run(\"pip install -r ./netbox/requirements.txt\")\n    context.run(\"poetry install\")\n    if not os.path.isfile(\"./docker/configuration/configuration.py\"):\n        context.run(\n            \"cp $(pwd)/docker/configuration/configuration.example.py $(pwd)/docker/configuration/configuration.py\"\n        )\n    if not os.path.islink(\"./netbox/netbox/netbox/configuration.py\"):\n        context.run(\"rm -f $(pwd)/netbox/netbox/netbox/configuration.py\")\n        context.run(\"ln -s $(pwd)/docker/configuration/configuration.py $(pwd)/netbox/netbox/netbox/\")\n    print(\"To run with containerized db use `invoke debug --target=local` before starting Django process.\")", "\n\n@task\ndef manage(context, command, target=\"dev\"):\n    \"\"\"Run a Django management command.\"\"\"\n    print(f\"Running Django management command: {command}\")\n    docker_compose(context, f\"run --rm netbox python3 ./manage.py {command}\", target=target)\n\n\n@task(help={\"name\": \"Use this name for migration file(s). If unspecified, a name will be generated.\"})\ndef makemigrations(context, name=\"\"):\n    \"\"\"Perform makemigrations operation in Django.\"\"\"\n    command = \"python manage.py makemigrations\"\n\n    if name:\n        command += f\" --name {name}\"\n\n    run_cmd(context, command)", "\n@task(help={\"name\": \"Use this name for migration file(s). If unspecified, a name will be generated.\"})\ndef makemigrations(context, name=\"\"):\n    \"\"\"Perform makemigrations operation in Django.\"\"\"\n    command = \"python manage.py makemigrations\"\n\n    if name:\n        command += f\" --name {name}\"\n\n    run_cmd(context, command)", "\n\n@task\ndef migrate(context):\n    \"\"\"Perform migrate operation in Django.\"\"\"\n    command = \"python manage.py migrate\"\n\n    run_cmd(context, command)\n\n", "\n\n@task()\ndef pytest(context):\n    \"\"\"Launch pytest for the specified name and Python version.\n\n    Args:\n        context (obj): Used to run specific commands\n    \"\"\"\n    # pty is set to true to properly run the docker commands due to the invocation process of docker\n    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n    # Install python module\n    exec_cmd = \"pytest -vv\"\n    run_cmd(context, exec_cmd)", "\n\n@task()\ndef black(context):\n    \"\"\"Launch black to check that Python files adherence to black standards.\n\n    Args:\n        context (obj): Used to run specific commands\n    \"\"\"\n    # pty is set to true to properly run the docker commands due to the invocation process of docker\n    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n    exec_cmd = \"black --exclude ./workspace --check --diff .\"\n    run_cmd(context, exec_cmd)", "\n\n@task()\ndef blacken(context):\n    \"\"\"Launch black to apply black standards to the code.\n\n    Args:\n        context (obj): Used to run specific commands\n    \"\"\"\n    # pty is set to true to properly run the docker commands due to the invocation process of docker\n    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n    exec_cmd = \"black .\"\n    run_cmd(context, exec_cmd)", "\n\n@task()\ndef flake8(context):\n    \"\"\"Launch flake8 for the specified name and Python version.\n\n    Args:\n        context (obj): Used to run specific commands\n    \"\"\"\n    # pty is set to true to properly run the docker commands due to the invocation process of docker\n    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n    exec_cmd = \"flake8 --exclude=./workspace,./netbox .\"\n    run_cmd(context, exec_cmd)", "\n\n@task()\ndef pylint(context):\n    \"\"\"Launch pylint for the specified name and Python version.\n\n    Args:\n        context (obj): Used to run specific commands\n    \"\"\"\n    # pty is set to true to properly run the docker commands due to the invocation process of docker\n    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n    exec_cmd = 'find . -type f -name \"*.py\" | xargs pylint'\n    run_cmd(context, exec_cmd)", "\n\n@task()\ndef yamllint(context):\n    \"\"\"Launch yamllint to validate formatting.\n\n    Args:\n        context (obj): Used to run specific commands\n    \"\"\"\n    # pty is set to true to properly run the docker commands due to the invocation process of docker\n    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n    exec_cmd = 'yamllint -d \"{ignore: ./workspace}\" .'\n    run_cmd(context, exec_cmd)", "\n\n@task()\ndef pydocstyle(context):\n    \"\"\"Launch pydocstyle to validate docstring.\n\n    Args:\n        context (obj): Used to run specific commands\n    \"\"\"\n    # pty is set to true to properly run the docker commands due to the invocation process of docker\n    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n    exec_cmd = \"pydocstyle .\"\n    run_cmd(context, exec_cmd)", "\n\n@task()\ndef bandit(context):\n    \"\"\"Launch bandit to validate basic static code security analysis.\n\n    Args:\n        context (obj): Used to run specific commands\n    \"\"\"\n    # pty is set to true to properly run the docker commands due to the invocation process of docker\n    # https://docs.pyinvoke.org/en/latest/api/runners.html - Search for pty for more information\n    exec_cmd = \"bandit --recursive ./\"\n    run_cmd(context, exec_cmd)", "\n\n@task()\ndef tests(context):\n    \"\"\"Launch all tests for the specified name and Python version.\n\n    Args:\n        context (obj): Used to run specific commands\n    \"\"\"\n    print(\"Running black...\")\n    black(context)\n    print(\"Running flake8...\")\n    flake8(context)\n    # print(\"Running pylint...\")\n    # pylint(context)\n    print(\"Running yamllint...\")\n    yamllint(context)\n    # print(\"Running pydocstyle...\")\n    # pydocstyle(context)\n    # print(\"Running bandit...\")\n    # bandit(context)\n    # print(\"Running pytest...\")\n    # pytest(context)\n\n    print(\"All tests have passed!\")", ""]}
{"filename": "netbox_nornir/__init__.py", "chunked_list": ["\"\"\"Base NetBox plugin for interactions with AWX or Ansible Tower.\"\"\"\n\nfrom extras.plugins import PluginConfig\n\n\n__version__ = \"0.1.0\"\n\n\nclass NetboxNornirConfig(PluginConfig):\n    \"\"\"Plugin configuration for netbox_nornir.\"\"\"\n\n    name = \"netbox_nornir\"\n    verbose_name = \"Netbox Nornir\"\n    version = __version__\n    author = \"OpticoreIT\"\n    author_email = \"info@opticoreit.com\"\n    description = \"\"\n    base_url = \"nornir\"", "class NetboxNornirConfig(PluginConfig):\n    \"\"\"Plugin configuration for netbox_nornir.\"\"\"\n\n    name = \"netbox_nornir\"\n    verbose_name = \"Netbox Nornir\"\n    version = __version__\n    author = \"OpticoreIT\"\n    author_email = \"info@opticoreit.com\"\n    description = \"\"\n    base_url = \"nornir\"", "\n\nconfig = NetboxNornirConfig  # pylint: disable=invalid-name\n"]}
{"filename": "netbox_nornir/utils.py", "chunked_list": ["\"\"\"Utilities for plugin.\"\"\"\nimport logging\nfrom typing import Any\n\nfrom netbox_nornir.plugins.tasks.dispatcher import _DEFAULT_DRIVERS_MAPPING\nfrom netbox_nornir.constraints import PLUGIN_CFG\n\n\ndef get_dispatcher():\n    \"\"\"Helper method to load the dispatcher from netbox nornir or config if defined.\"\"\"\n    if PLUGIN_CFG.get(\"dispatcher_mapping\"):\n        return {**_DEFAULT_DRIVERS_MAPPING, **PLUGIN_CFG[\"dispatcher_mapping\"]}\n    return _DEFAULT_DRIVERS_MAPPING", "def get_dispatcher():\n    \"\"\"Helper method to load the dispatcher from netbox nornir or config if defined.\"\"\"\n    if PLUGIN_CFG.get(\"dispatcher_mapping\"):\n        return {**_DEFAULT_DRIVERS_MAPPING, **PLUGIN_CFG[\"dispatcher_mapping\"]}\n    return _DEFAULT_DRIVERS_MAPPING\n\n\nclass NornirLogger:\n    \"\"\"Similar to a mixin, to utilize Python logging and Jobs Result obj.\"\"\"\n\n    def __init__(self, name: str, netbox_job=None, debug: bool = False):\n        \"\"\"Initialize the object.\"\"\"\n        self.logger = logging.getLogger(name)\n        self.debug = debug\n        self.netbox_job = netbox_job\n\n    def log_debug(self, message: str, grouping: str = \"main\"):\n        \"\"\"Debug, does not take obj, and only logs to jobs result when in global debug mode.\"\"\"\n        if self.netbox_job and self.debug:\n            self.netbox_job.log_debug(message, grouping=grouping)\n        self.logger.debug(message)\n\n    def log_info(self, obj: Any, message: str, grouping: str = \"main\"):\n        \"\"\"Log to Python logger and jogs results for info messages.\"\"\"\n        if self.netbox_job:\n            self.netbox_job.log_info(message, grouping=grouping)\n        self.logger.info(\"%s | %s\", str(obj), message)\n\n    def log_success(self, obj: Any, message: str, grouping: str = \"main\"):\n        \"\"\"Log to Python logger and jogs results for success messages.\"\"\"\n        if self.netbox_job:\n            self.netbox_job.log_success(message, grouping=grouping)\n        self.logger.info(\"%s | %s\", str(obj), message)\n\n    def log_warning(self, obj: Any, message: str, grouping: str = \"main\"):\n        \"\"\"Log to Python logger and jogs results for warning messages.\"\"\"\n        if self.netbox_job:\n            self.netbox_job.log_warning(message, grouping=grouping)\n        self.logger.warning(\"%s | %s\", str(obj), message)\n\n    def log_failure(self, obj: Any, message: str, grouping: str = \"main\"):\n        \"\"\"Log to Python logger and jogs results for failure messages.\"\"\"\n        if self.netbox_job:\n            self.netbox_job.log_failure(message, grouping=grouping)\n        self.logger.error(\"%s | %s\", str(obj), message)", ""]}
{"filename": "netbox_nornir/constraints.py", "chunked_list": ["\"\"\"Constants for plugin.\"\"\"\nfrom django.conf import settings\n\n\n_NORNIR_SETTINGS = {\n    \"inventory\": \"netbox_nornir.plugins.inventory.netbox_orm.NetboxORMInventory\",\n    \"credentials\": \"netbox_nornir.plugins.credentials.env_vars.CredentialsEnvVars\",\n    \"runner\": {\"options\": {\"num_workers\": 20}},\n}\n", "}\n\nPLUGIN_CFG = settings.PLUGINS_CONFIG.get(\"netbox_nornir\", {})\nNORNIR_SETTINGS = PLUGIN_CFG.get(\"nornir_settings\", _NORNIR_SETTINGS)\nCONNECTION_SECRETS_PATHS = {\n    \"netmiko\": \"netmiko.extras.secret\",\n    \"napalm\": \"napalm.extras.optional_args.secret\",\n    \"scrapli\": \"scrapli.extras.auth_secondary\",\n}\n", "}\n\nCONNECTION_ENABLE_PASSWORD_PATHS = {\n    \"netmiko\": \"netmiko.extras.enable_password\",\n    \"napalm\": \"napalm.extras.optional_args.enable_password\",\n    \"scrapli\": \"scrapli.extras.enable_password\",\n}\n"]}
{"filename": "netbox_nornir/exceptions.py", "chunked_list": ["\"\"\"Exceptions for NetBox Nornir plugin.\"\"\"\n\n\nclass NornirNetboxException(Exception):\n    \"\"\"Base exception for NetBox Nornir plugin.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/inventory/netbox_orm.py", "chunked_list": ["\"\"\"NetBox ORM inventory plugin.\"\"\"\nfrom typing import Any, Dict\n\nfrom django.db.models import QuerySet\nfrom django.utils.module_loading import import_string\nfrom nornir.core.inventory import (\n    ConnectionOptions,\n    Defaults,\n    Group,\n    Groups,", "    Group,\n    Groups,\n    Host,\n    Hosts,\n    Inventory,\n    ParentGroups,\n)\n\nfrom dcim.models import Device\n", "from dcim.models import Device\n\nfrom netbox_nornir.constraints import CONNECTION_ENABLE_PASSWORD_PATHS, CONNECTION_SECRETS_PATHS, PLUGIN_CFG\nfrom netbox_nornir.exceptions import NornirNetboxException\n\n\ndef _set_dict_key_path(dictionary, key_path, value):\n    \"\"\"Set a value in a nested dictionary using a key path.\n\n    Args:\n        dictionary (dict): The dictionary to set the value in.\n        key_path (str): The key path to set the value in.\n    \"\"\"\n    *keys, last_key = key_path.split(\".\")\n    pointer = dictionary\n    for key in keys:\n        pointer = pointer.setdefault(key, {})\n    pointer[last_key] = value", "\n\ndef build_out_secret_paths(connection_options, device_secret):\n    \"\"\"Build out secret paths.\n\n    Args:\n        connection_options (dict): Connection options\n        device_secret (str): Device secret\n    \"\"\"\n    for nornir_provider, nornir_options in connection_options.items():\n        # Offers extensibility to nornir plugins not listed in constants.py under CONNECTION_SECRETS_PATHS.\n        if nornir_options.get(\"connection_secret_path\"):\n            secret_path = nornir_options.pop(\"connection_secret_path\")\n        elif CONNECTION_SECRETS_PATHS.get(nornir_provider):\n            secret_path = CONNECTION_SECRETS_PATHS[nornir_provider]\n        else:\n            continue\n        _set_dict_key_path(connection_options, secret_path, device_secret)", "\n\ndef build_out_enable_password_paths(connection_options, device_secret):\n    \"\"\"Build out enable password paths.\n\n    Args:\n        connection_options (dict): Connection options\n        device_secret (str): Device secret\n    \"\"\"\n    for nornir_provider, nornir_options in connection_options.items():\n        # Offers extensibility to nornir plugins not listed in constants.py under CONNECTION_SECRETS_PATHS.\n        if nornir_options.get(\"connection_enable_password_path\"):\n            secret_path = nornir_options.pop(\"connection_enable_password_path\")\n        elif CONNECTION_ENABLE_PASSWORD_PATHS.get(nornir_provider):\n            secret_path = CONNECTION_ENABLE_PASSWORD_PATHS[nornir_provider]\n        else:\n            continue\n        _set_dict_key_path(connection_options, secret_path, device_secret)", "\n\ndef set_host(data: Dict[str, Any], name: str, groups, host, defaults) -> Host:\n    \"\"\"Set host.\n\n    Args:\n        data (dict): Data\n        name (str): Name\n        groups (dict): Groups\n        host (dict): Host\n        defaults (dict): Defaults\n    Returns:\n        Host: Host\n    \"\"\"\n    connection_option = {}\n    for key, value in data.get(\"connection_options\", {}).items():\n        connection_option[key] = ConnectionOptions(\n            hostname=value.get(\"hostname\"),\n            username=value.get(\"username\"),\n            password=value.get(\"password\"),\n            port=value.get(\"port\"),\n            platform=value.get(\"platform\"),\n            extras=value.get(\"extras\"),\n        )\n    return Host(\n        name=name,\n        hostname=host[\"hostname\"],\n        username=host[\"username\"],\n        password=host[\"password\"],\n        platform=host[\"platform\"],\n        data=data,\n        groups=groups,\n        defaults=defaults,\n        connection_options=connection_option,\n    )", "\n\nclass NetboxORMInventory:\n    \"\"\"Construct nornir inventory from NetBox using ORM.\"\"\"\n\n    def __init__(\n        self,\n        queryset: QuerySet = None,\n        filters: Dict = None,\n        credentials_class: str = \"netbox_nornir.plugins.credentials.env_vars.CredentialsEnvVars\",\n        credentials_params: Dict = None,\n    ) -> None:\n        \"\"\"Initialize inventory.\"\"\"\n        self.queryset = queryset\n        self.filters = filters\n\n        if isinstance(credentials_class, str):\n            self.cred_class = import_string(credentials_class)\n        else:\n            raise NornirNetboxException(\n                f\"A valid credentials class path (as defined by Django's import_string function) is required, but got {credentials_class} which is not importable.\"\n            )\n        self.credentials_params = credentials_params\n\n    def load(self) -> Inventory:\n        \"\"\"Load inventory.\"\"\"\n\n        if isinstance(self.queryset, QuerySet) and not self.queryset:\n            self.queryset = Device.objects.all()\n\n        if self.filters:\n            self.queryset = self.queryset.filter(**self.filters)\n\n        hosts = Hosts()\n        groups = Groups()\n        defaults = Defaults()\n\n        if self.credentials_params:\n            cred = self.cred_class(params=self.credentials_params)\n        else:\n            cred = self.cred_class()\n\n        for device in self.queryset:\n            host = self.create_host(device, cred, {})\n            hosts[device.name] = set_host(\n                data=host[\"data\"],\n                name=host[\"name\"],\n                groups=host[\"groups\"],\n                host=host,\n                defaults=defaults,\n            )\n\n            for group in hosts[device.name].groups:\n                if group not in groups.keys():\n                    groups[group] = Group(name=group, defaults=defaults)\n\n        for _host in hosts.values():\n            _host.groups = ParentGroups([groups[_group] for _group in _host.groups])\n        for _group in groups.values():\n            _group.groups = ParentGroups([groups[_group] for _group in _group.groups])\n\n        return Inventory(hosts=hosts, groups=groups, defaults=defaults)\n\n    def create_host(self, device, cred, params: Dict):\n        \"\"\"Create host.\"\"\"\n        host = {\"data\": {}}\n        if \"use_fqdn\" in params and params.get(\"use_fqdn\"):\n            host[\"hostname\"] = f\"{device.name}.{params.get('fqdn')}\"\n        else:\n            if device.primary_ip:\n                host[\"hostname\"] = str(device.primary_ip.address.ip)\n            else:\n                host[\"hostname\"] = device.name\n        host[\"name\"] = device.name\n\n        if not device.platform:\n            raise NornirNetboxException(f\"Platform missing from device {device.name}, preemptively failed.\")\n\n        host[\"platform\"] = device.platform.napalm_driver\n        host[\"data\"][\"id\"] = device.id\n        host[\"data\"][\"type\"] = device.device_type.slug\n        host[\"data\"][\"site\"] = device.site.slug\n        host[\"data\"][\"role\"] = device.device_role.slug\n        host[\"data\"][\"obj\"] = device\n\n        username, password, secret, key = cred.get_device_creds(device=device)\n\n        host[\"username\"] = username\n        host[\"password\"] = password\n        host[\"data\"][\"secret\"] = secret\n        host[\"data\"][\"enable_password\"] = secret\n        host[\"data\"][\"key\"] = key\n\n        global_options = PLUGIN_CFG.get(\"connection_options\", {\"netmiko\": {}, \"napalm\": {}, \"scrapli\": {}})\n\n        conn_options = global_options\n\n        build_out_secret_paths(conn_options, secret)\n        build_out_enable_password_paths(conn_options, secret)\n\n        host[\"data\"][\"connection_options\"] = conn_options\n        host[\"groups\"] = self.get_host_groups(device=device)\n\n        if device.platform.napalm_driver:\n            if not host[\"data\"][\"connection_options\"].get(\"napalm\"):\n                host[\"data\"][\"connection_options\"][\"napalm\"] = {}\n            host[\"data\"][\"connection_options\"][\"napalm\"][\"platform\"] = device.platform.napalm_driver\n        return host\n\n    @staticmethod\n    def get_host_groups(device):\n        \"\"\"Get the names of the groups a given device should be part of.\n        Args:\n            device (dcim.models.Device): Device obj\n        Returns:\n            (list): List of group names the device should be part of\n        \"\"\"\n        groups = [\n            \"global\",\n            f\"site__{device.site.slug}\",\n            f\"role__{device.device_role.slug}\",\n            f\"type__{device.device_type.slug}\",\n            f\"manufacturer__{device.device_type.manufacturer.slug}\",\n        ]\n\n        if device.platform:\n            groups.append(f\"platform__{device.platform.napalm_driver}\")\n\n        if device.tenant:\n            groups.append(f\"tenant__{device.tenant.slug}\")\n\n        return groups", ""]}
{"filename": "netbox_nornir/plugins/credentials/base.py", "chunked_list": ["\"\"\"Base credentials plugin for Netbox Nornir.\"\"\"\n\n\nclass BaseCredentials:\n    \"\"\"Base credentials plugin for Netbox Nornir.\"\"\"\n\n    username = None\n    password = None\n    secret = None\n\n    def get_device_creds(self, device):  # pylint: disable=unused-argument\n        \"\"\"Return the credentials for a given device.\n        Args:\n            device (dcim.models.Device): Netbox device object\n        Return:\n            username (string):\n            password (string):\n            secret (string):\n        \"\"\"\n        return (self.username, self.password, self.secret)", ""]}
{"filename": "netbox_nornir/plugins/credentials/aws_ssm.py", "chunked_list": ["\"\"\"Nornir plugin to retrieve credentials from AWS SSM Parameter Store.\"\"\"\n\nimport boto3\nfrom botocore.client import Config\nfrom dcim.models import Device\n\nfrom .base import BaseCredentials\n\n\nclass CredentialsAwsSsm(BaseCredentials):\n    \"\"\"Nornir plugin to retrieve credentials from AWS SSM Parameter Store.\"\"\"\n\n    def __init__(self, params={}):  # pylint: disable=dangerous-default-value\n        \"\"\"Init.\"\"\"\n        config = Config(connect_timeout=15, retries={\"max_attempts\": 0})\n        self.client = boto3.client(\"ssm\", config=config)\n        self.params = params\n        self.username = None\n        self.password = None\n        self.secret = None\n        self.key = None\n\n    def build_parameter_names(self, device_name, manufacturer, platform):\n        \"\"\"Build a list of parameter names to try.\"\"\"\n        prefix = \"/netbox\"\n        # Ordered list of parameter names to try\n        return [\n            \"/\".join([prefix, device_name, \"username\"]),\n            \"/\".join([prefix, device_name, \"password\"]),\n            \"/\".join([prefix, device_name, \"secret\"]),\n            \"/\".join([prefix, device_name, \"key\"]),\n            \"/\".join(\n                [\n                    prefix,\n                    f\"{manufacturer.lower()}_{platform.lower()}\",\n                    \"username\",\n                ]\n            ),\n            \"/\".join(\n                [\n                    prefix,\n                    f\"{manufacturer.lower()}_{platform.lower()}\",\n                    \"password\",\n                ]\n            ),\n            \"/\".join(\n                [\n                    prefix,\n                    f\"{manufacturer.lower()}_{platform.lower()}\",\n                    \"secret\",\n                ]\n            ),\n            \"/\".join(\n                [\n                    prefix,\n                    f\"{manufacturer.lower()}_{platform.lower()}\",\n                    \"key\",\n                ]\n            ),\n        ]\n\n    @staticmethod\n    def lookup_nested_dict(param_list, key, value):\n        \"\"\"Lookup a value in a list of nested dicts.\"\"\"\n        for param in param_list:\n            if value in param[key]:\n                return param\n        return {}\n\n    def get_default_creds(self):\n        \"\"\"Get default credentials from environment variables.\n        Returns:\n            (tuple): Tuple of username, password, secret, key\n        \"\"\"\n        prefix = \"/netbox\"\n        parameter_names = [\n            \"/\".join([prefix, \"device_default\", \"username\"]),\n            \"/\".join([prefix, \"device_default\", \"password\"]),\n            \"/\".join([prefix, \"device_default\", \"secret\"]),\n            \"/\".join([prefix, \"device_default\", \"key\"]),\n        ]\n        return self.client.get_parameters(Names=parameter_names, WithDecryption=True)[\"Parameters\"]\n\n    def get_device_creds(self, device, **kwargs):\n        \"\"\"Get device credentials.\n\n        Args:\n            device (Device): NetBox device\n            **kwargs: Additional arguments\n        Returns:\n            (tuple): Tuple of username, password, secret, key\n        \"\"\"\n        if isinstance(device, Device):\n            device_name = device.name\n            manufacturer = device.device_type.manufacturer.slug\n            platform = device.platform.slug\n        else:\n            device_name = device[\"name\"]\n            manufacturer = kwargs.get(\"manufacturer\")\n            platform = kwargs.get(\"platform\")\n        parameter_names = self.build_parameter_names(device_name, manufacturer, platform)\n        credentials = self.client.get_parameters(Names=parameter_names, WithDecryption=True)[\"Parameters\"]\n        if not credentials:\n            credentials = self.get_default_creds()\n        return (\n            self.lookup_nested_dict(credentials, \"Name\", \"username\").get(\"Value\"),\n            self.lookup_nested_dict(credentials, \"Name\", \"password\").get(\"Value\"),\n            self.lookup_nested_dict(credentials, \"Name\", \"secret\").get(\"Value\"),\n            self.lookup_nested_dict(credentials, \"Name\", \"key\").get(\"Value\"),\n        )", "\nclass CredentialsAwsSsm(BaseCredentials):\n    \"\"\"Nornir plugin to retrieve credentials from AWS SSM Parameter Store.\"\"\"\n\n    def __init__(self, params={}):  # pylint: disable=dangerous-default-value\n        \"\"\"Init.\"\"\"\n        config = Config(connect_timeout=15, retries={\"max_attempts\": 0})\n        self.client = boto3.client(\"ssm\", config=config)\n        self.params = params\n        self.username = None\n        self.password = None\n        self.secret = None\n        self.key = None\n\n    def build_parameter_names(self, device_name, manufacturer, platform):\n        \"\"\"Build a list of parameter names to try.\"\"\"\n        prefix = \"/netbox\"\n        # Ordered list of parameter names to try\n        return [\n            \"/\".join([prefix, device_name, \"username\"]),\n            \"/\".join([prefix, device_name, \"password\"]),\n            \"/\".join([prefix, device_name, \"secret\"]),\n            \"/\".join([prefix, device_name, \"key\"]),\n            \"/\".join(\n                [\n                    prefix,\n                    f\"{manufacturer.lower()}_{platform.lower()}\",\n                    \"username\",\n                ]\n            ),\n            \"/\".join(\n                [\n                    prefix,\n                    f\"{manufacturer.lower()}_{platform.lower()}\",\n                    \"password\",\n                ]\n            ),\n            \"/\".join(\n                [\n                    prefix,\n                    f\"{manufacturer.lower()}_{platform.lower()}\",\n                    \"secret\",\n                ]\n            ),\n            \"/\".join(\n                [\n                    prefix,\n                    f\"{manufacturer.lower()}_{platform.lower()}\",\n                    \"key\",\n                ]\n            ),\n        ]\n\n    @staticmethod\n    def lookup_nested_dict(param_list, key, value):\n        \"\"\"Lookup a value in a list of nested dicts.\"\"\"\n        for param in param_list:\n            if value in param[key]:\n                return param\n        return {}\n\n    def get_default_creds(self):\n        \"\"\"Get default credentials from environment variables.\n        Returns:\n            (tuple): Tuple of username, password, secret, key\n        \"\"\"\n        prefix = \"/netbox\"\n        parameter_names = [\n            \"/\".join([prefix, \"device_default\", \"username\"]),\n            \"/\".join([prefix, \"device_default\", \"password\"]),\n            \"/\".join([prefix, \"device_default\", \"secret\"]),\n            \"/\".join([prefix, \"device_default\", \"key\"]),\n        ]\n        return self.client.get_parameters(Names=parameter_names, WithDecryption=True)[\"Parameters\"]\n\n    def get_device_creds(self, device, **kwargs):\n        \"\"\"Get device credentials.\n\n        Args:\n            device (Device): NetBox device\n            **kwargs: Additional arguments\n        Returns:\n            (tuple): Tuple of username, password, secret, key\n        \"\"\"\n        if isinstance(device, Device):\n            device_name = device.name\n            manufacturer = device.device_type.manufacturer.slug\n            platform = device.platform.slug\n        else:\n            device_name = device[\"name\"]\n            manufacturer = kwargs.get(\"manufacturer\")\n            platform = kwargs.get(\"platform\")\n        parameter_names = self.build_parameter_names(device_name, manufacturer, platform)\n        credentials = self.client.get_parameters(Names=parameter_names, WithDecryption=True)[\"Parameters\"]\n        if not credentials:\n            credentials = self.get_default_creds()\n        return (\n            self.lookup_nested_dict(credentials, \"Name\", \"username\").get(\"Value\"),\n            self.lookup_nested_dict(credentials, \"Name\", \"password\").get(\"Value\"),\n            self.lookup_nested_dict(credentials, \"Name\", \"secret\").get(\"Value\"),\n            self.lookup_nested_dict(credentials, \"Name\", \"key\").get(\"Value\"),\n        )", ""]}
{"filename": "netbox_nornir/plugins/credentials/__init__.py", "chunked_list": [""]}
{"filename": "netbox_nornir/plugins/credentials/env_vars.py", "chunked_list": ["\"\"\"Credentials Class designed to work with environment variables.\"\"\"\nimport os\nfrom .base import BaseCredentials\n\nUSERNAME_ENV_VAR_NAME = \"NAPALM_USERNAME\"  # nosec\nPASSWORD_ENV_VAR_NAME = \"NAPALM_PASSWORD\"  # nosec\nSECRET_ENV_VAR_NAME = \"DEVICE_SECRET\"  # nosec\n\n\nclass CredentialsEnvVars(BaseCredentials):\n    \"\"\"Credentials Class designed to work with Netbox ORM.\n    This class is the default class that will return the same login and password\n    for all devices based on the values of the environment variables\n    \"\"\"\n\n    def __init__(self, params={}):  # pylint: disable=dangerous-default-value\n        \"\"\"Initialize Credentials Class designed to work with environment variables.\n\n        Args:\n            params ([dict], optional): Credentials Parameters\n        \"\"\"\n        if not isinstance(params, dict):\n            raise TypeError(\"params must be a dictionary\")\n\n        self.username = os.getenv(params.get(\"username\", USERNAME_ENV_VAR_NAME))\n        self.password = os.getenv(params.get(\"password\", PASSWORD_ENV_VAR_NAME))\n        self.secret = os.getenv(params.get(\"secret\", SECRET_ENV_VAR_NAME))\n\n        if not self.secret:\n            self.secret = self.password", "\nclass CredentialsEnvVars(BaseCredentials):\n    \"\"\"Credentials Class designed to work with Netbox ORM.\n    This class is the default class that will return the same login and password\n    for all devices based on the values of the environment variables\n    \"\"\"\n\n    def __init__(self, params={}):  # pylint: disable=dangerous-default-value\n        \"\"\"Initialize Credentials Class designed to work with environment variables.\n\n        Args:\n            params ([dict], optional): Credentials Parameters\n        \"\"\"\n        if not isinstance(params, dict):\n            raise TypeError(\"params must be a dictionary\")\n\n        self.username = os.getenv(params.get(\"username\", USERNAME_ENV_VAR_NAME))\n        self.password = os.getenv(params.get(\"password\", PASSWORD_ENV_VAR_NAME))\n        self.secret = os.getenv(params.get(\"secret\", SECRET_ENV_VAR_NAME))\n\n        if not self.secret:\n            self.secret = self.password", ""]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/cisco_asa.py", "chunked_list": ["\"\"\"network_importer driver for cisco_asa.\"\"\"\n\nfrom .default import NetmikoNetboxNornirDriver as DefaultNetboxNornirDriver\n\n\nclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n    \"\"\"Driver for Cisco ASA.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/cisco_ios_xr.py", "chunked_list": ["\"\"\"network_importer driver for cisco IOS-XR.\"\"\"\n\nfrom .default import NetboxNornirDriver as DefaultNetboxNornirDriver\n\n\nclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n    \"\"\"Driver for Cisco IOS-XR.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/netscaler.py", "chunked_list": ["\"\"\"default network_importer driver for Netscaler.\"\"\"\n\nfrom .default import NetmikoNetboxNornirDriver as DefaultNetboxNornirDriver\n\n\nclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n    \"\"\"Collection of Nornir Tasks specific to Cisco AireOS devices.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/cisco_aireos.py", "chunked_list": ["\"\"\"default network_importer driver for Cisco AireOS.\"\"\"\n\nfrom .default import NetmikoNetboxNornirDriver as DefaultNetboxNornirDriver\n\n\nclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n    \"\"\"Collection of Nornir Tasks specific to Cisco AireOS devices.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/cisco_wlc.py", "chunked_list": ["\"\"\"default network_importer driver for Cisco AireOS.\"\"\"\n\nfrom .default import NetmikoNetboxNornirDriver as DefaultNetboxNornirDriver\n\n\nclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n    \"\"\"Collection of Nornir Tasks specific to Cisco AireOS devices.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/cisco_nxos.py", "chunked_list": ["\"\"\"network_importer driver for cisco NXOS.\"\"\"\n\nfrom .default import NetboxNornirDriver as DefaultNetboxNornirDriver\n\n\nclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n    \"\"\"Driver for Cisco NXOS.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/juniper_junos.py", "chunked_list": ["\"\"\"default network_importer driver for Juniper.\"\"\"\n\nfrom .default import NetboxNornirDriver as DefaultNetboxNornirDriver\n\n\nclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n    \"\"\"Collection of Nornir Tasks specific to Juniper Junos devices.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/__init__.py", "chunked_list": ["\"\"\"Used to intialize the dispatcher.\"\"\"\n# pylint: disable=raise-missing-from\n\nimport importlib\nimport logging\n\nfrom nornir.core.exceptions import NornirSubTaskError\nfrom nornir.core.task import Result, Task\nfrom netbox_nornir.exceptions import NornirNetboxException\n", "from netbox_nornir.exceptions import NornirNetboxException\n\nLOGGER = logging.getLogger(__name__)\n\n_DEFAULT_DRIVERS_MAPPING = {\n    \"default\": \"netbox_nornir.plugins.tasks.dispatcher.default.NetboxNornirDriver\",\n    \"default_netmiko\": \"netbox_nornir.plugins.tasks.dispatcher.default.NetmikoNetboxNornirDriver\",\n    \"arista_eos\": \"netbox_nornir.plugins.tasks.dispatcher.arista_eos.NetboxNornirDriver\",\n    \"cisco_aireos\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_aireos.NetboxNornirDriver\",\n    \"cisco_asa\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_asa.NetboxNornirDriver\",", "    \"cisco_aireos\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_aireos.NetboxNornirDriver\",\n    \"cisco_asa\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_asa.NetboxNornirDriver\",\n    \"cisco_ios\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_ios.NetboxNornirDriver\",\n    \"cisco_ios_restconf\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_ios_restconf.NetboxNornirDriver\",\n    \"cisco_nxos\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_nxos.NetboxNornirDriver\",\n    \"cisco_wlc\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_wlc.NetboxNornirDriver\",\n    \"cisco_xr\": \"netbox_nornir.plugins.tasks.dispatcher.cisco_ios_xr.NetboxNornirDriver\",\n    \"fortinet_fortios\": \"netbox_nornir.plugins.tasks.dispatcher.fortinet_fortios.NetboxNornirDriver\",\n    \"juniper_junos\": \"netbox_nornir.plugins.tasks.dispatcher.juniper_junos.NetboxNornirDriver\",\n    \"netscaler\": \"netbox_nornir.plugins.tasks.dispatcher.netscaler.NetboxNornirDriver\",", "    \"juniper_junos\": \"netbox_nornir.plugins.tasks.dispatcher.juniper_junos.NetboxNornirDriver\",\n    \"netscaler\": \"netbox_nornir.plugins.tasks.dispatcher.netscaler.NetboxNornirDriver\",\n    \"paloalto_panos\": \"netbox_nornir.plugins.tasks.dispatcher.paloalto_panos.NetboxNornirDriver\",\n}\n\n\ndef dispatcher(task: Task, method: str, logger, obj, *args, **kwargs) -> Result:\n    \"\"\"Helper Task to retrieve a given Nornir task for a given platform.\n\n    Args:\n        task (Nornir Task):  Nornir Task object.\n        method (str):  The string value of the method to dynamically find.\n\n    Returns:\n        Result: Nornir Task result.\n    \"\"\"\n    if kwargs.get(\"default_drivers_mapping\"):\n        default_drivers_mapping = kwargs[\"default_drivers_mapping\"]\n        del kwargs[\"default_drivers_mapping\"]\n    else:\n        default_drivers_mapping = _DEFAULT_DRIVERS_MAPPING\n\n    logger.log_debug(\n        f\"Executing dispatcher for {task.host.name} ({task.host.platform})\",\n        grouping=task.host.name,\n    )\n\n    # Get the platform specific driver, if not available, get the default driver\n    driver = default_drivers_mapping.get(task.host.platform, default_drivers_mapping.get(\"default\"))\n    logger.log_debug(f\"Found driver {driver}\", grouping=task.host.name)\n\n    if not driver:\n        logger.log_failure(\n            obj,\n            f\"Unable to find the driver for {method} for platform: {task.host.platform}, preemptively failed.\",\n            grouping=task.host.name,\n        )\n        raise NornirNetboxException(\n            f\"Unable to find the driver for {method} for platform: {task.host.platform}, preemptively failed.\"\n        )\n\n    module_name, class_name = driver.rsplit(\".\", 1)\n    driver_class = getattr(importlib.import_module(module_name), class_name)\n\n    if not driver_class:\n        logger.log_failure(\n            obj,\n            f\"Unable to locate the class {driver}, preemptively failed.\",\n            grouping=task.host.name,\n        )\n        raise NornirNetboxException(f\"Unable to locate the class {driver}, preemptively failed.\")\n\n    try:\n        driver_task = getattr(driver_class, method)\n    except AttributeError:\n        logger.log_failure(\n            obj,\n            f\"Unable to locate the method {method} for {driver}, preemptively failed.\",\n            grouping=task.host.name,\n        )\n        raise NornirNetboxException(f\"Unable to locate the method {method} for {driver}, preemptively failed.\")\n\n    result = None\n    error = None\n    try:\n        result = task.run(task=driver_task, logger=logger, obj=obj, *args, **kwargs)\n    except NornirSubTaskError as exc:\n        traceback_lines = exc.result[0].result.splitlines()\n        logger.log_failure(obj, f\"Subtask failed: {traceback_lines[-1]}\", grouping=task.host.name)\n        error = traceback_lines[-1]\n        for line in traceback_lines:\n            logger.log_debug(line, grouping=task.host.name)\n        raise NornirNetboxException(f\"Subtask failed: {traceback_lines[-1]}\")\n    return Result(\n        host=task.host,\n        result=result,\n        error=error,\n    )", ""]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/default.py", "chunked_list": ["\"\"\"Default collection of Nornir Tasks based on Napalm.\"\"\"\nfrom netmiko import NetmikoAuthenticationException, NetmikoTimeoutException\nfrom nornir.core.exceptions import NornirSubTaskError\nfrom nornir.core.task import Result, Task\nfrom nornir_netmiko.tasks import netmiko_send_command\nfrom nornir_napalm.plugins.tasks import napalm_get\n\nfrom netbox_nornir.exceptions import NornirNetboxException\n\n", "\n\nRUN_COMMAND_MAPPING = {\n    \"default\": \"show run\",\n    \"arista_eos\": \"show run\",\n    \"cisco_aireos\": \"show run-config commands\",\n    \"cisco_nxos\": \"show run\",\n    \"cisco_ios\": \"show run\",\n    \"cisco_wlc\": \"show running-config\",\n    \"cisco_xr\": \"show run\",", "    \"cisco_wlc\": \"show running-config\",\n    \"cisco_xr\": \"show run\",\n    \"juniper_junos\": \"show configuration | display set\",\n    \"netscaler\": \"show run\",\n}\n\n\nclass NetboxNornirDriver:\n    \"\"\"Default collection of Nornir Tasks based on Napalm.\"\"\"\n\n    @staticmethod\n    def get_config(task: Task, logger, obj) -> Result:\n        \"\"\"Get the latest configuration from the device.\n        Args:\n            task (Task): Nornir Task.\n            logger (NornirLogger): Custom NornirLogger object to reflect job results (via Netbox Jobs) and Python logger.\n            obj (Device): A Netbox Device Django ORM object instance.\n        Returns:\n            Result: Nornir Result object with a dict as a result containing the running configuration\n                { \"config: <running configuration> }\n        \"\"\"\n        logger.log_debug(\n            f\"Executing get_config for {task.host.name} on {task.host.platform}\",\n            grouping=task.host.name,\n        )\n\n        # TODO: Find standard napalm exceptions and account for them\n        try:\n            result = task.run(task=napalm_get, getters=[\"config\"], retrieve=\"running\")\n        except NornirSubTaskError as exc:\n            traceback_lines = exc.result[0].result.splitlines()\n            logger.log_failure(\n                obj,\n                f\"`get_config` method failed with an unexpected issue: `{traceback_lines[-1]}`\",\n                grouping=task.host.name,\n            )\n            for traceback_line in traceback_lines:\n                logger.log_debug(\n                    traceback_line,\n                    grouping=task.host.name,\n                )\n            raise NornirNetboxException(\n                f\"`get_config` method failed with an unexpected issue: `{traceback_lines[-1]}`\"\n            ) from exc\n\n        if result[0].failed:\n            logger.log_failure(\n                obj,\n                f\"`get_config` nornir task failed with an unexpected issue: `{str(result.exception)}`\",\n                grouping=task.host.name,\n            )\n            return result\n\n        running_config = result[0].result.get(\"config\", {}).get(\"running\", None)\n        return Result(host=task.host, result={\"config\": running_config})\n\n    @staticmethod\n    def get_facts(task: Task, logger, obj) -> Result:\n        \"\"\"Get the latest facts from the device.\n        Args:\n            task (Task): Nornir Task.\n            logger (NornirLogger): Custom NornirLogger object to reflect job results (via Netbox Jobs) and Python logger.\n            obj (Device): A Netbox Device Django ORM object instance.\n        Returns:\n            Result: Nornir Result object with a dict as a result containing the facts\n                { \"facts: <facts> }\n        \"\"\"\n        logger.log_debug(\n            f\"Executing get_facts for {task.host.name} on {task.host.platform}\",\n            grouping=task.host.name,\n        )\n        try:\n            results = task.run(task=napalm_get, getters=[\"facts\"])\n        except NornirSubTaskError as exc:\n            traceback_lines = exc.result[0].result.splitlines()\n            logger.log_failure(\n                obj,\n                f\"`get_facts` method failed with an unexpected issue: `{traceback_lines[-1]}`\",\n                grouping=task.host.name,\n            )\n            for traceback_line in traceback_lines:\n                logger.log_debug(\n                    traceback_line,\n                    grouping=task.host.name,\n                )\n            raise NornirNetboxException(\n                f\"`get_facts` method failed with an unexpected issue: `{traceback_lines[-1]}`\"\n            ) from exc\n        facts = results[0].result.get(\"facts\", None)\n        return Result(host=task.host, result={\"facts\": facts})\n\n    @staticmethod\n    def get_interfaces(task: Task, logger, obj) -> Result:\n        \"\"\"Get the latest interface IP addresses from the device.\n        Args:\n            task (Task): Nornir Task.\n            logger (NornirLogger): Custom NornirLogger object to reflect job results (via Netbox Jobs) and Python logger.\n            obj (Device): A Netbox Device Django ORM object instance.\n        Returns:\n            Result: Nornir Result object with a dict as a result containing the interface IP addresses\n                { \"interface_ip_addresses: <interface_ip_addresses> }\n        \"\"\"\n        logger.log_debug(\n            f\"Executing get_interface_ip_addresses for {task.host.name} on {task.host.platform}\",\n            grouping=task.host.name,\n        )\n        try:\n            results = task.run(task=napalm_get, getters=[\"interfaces\", \"interfaces_ip\"])\n        except NornirSubTaskError as exc:\n            traceback_lines = exc.result[0].result.splitlines()\n            logger.log_failure(\n                obj,\n                f\"`get_interface_ip_addresses` method failed with an unexpected issue: `{traceback_lines[-1]}`\",\n                grouping=task.host.name,\n            )\n            for traceback_line in traceback_lines:\n                logger.log_debug(\n                    traceback_line,\n                    grouping=task.host.name,\n                )\n            raise NornirNetboxException(\n                f\"`get_interface_ip_addresses` method failed with an unexpected issue: `{traceback_lines[-1]}`\"\n            ) from exc\n\n        naplam_interfaces = results[0].result\n        combined_interfaces = {}\n        for interface_name, interface_details in naplam_interfaces[\"interfaces\"].items():\n            combined_interfaces[interface_name] = {\n                **interface_details,\n                **naplam_interfaces[\"interfaces_ip\"].get(interface_name, {}),\n            }\n        return Result(host=task.host, result={\"interfaces\": combined_interfaces})", "\n\nclass NetmikoNetboxNornirDriver(NetboxNornirDriver):\n    \"\"\"Default collection of Nornir Tasks based on Netmiko.\"\"\"\n\n    @staticmethod\n    def get_config(task: Task, logger, obj) -> Result:\n        \"\"\"Get the latest configuration from the device using Netmiko.\n\n        Args:\n            task (Task): Nornir Task.\n            logger (NornirLogger): Custom NornirLogger object to reflect job results (via Netbox Jobs) and Python logger.\n            obj (Device): A Netbox Device Django ORM object instance.\n            remove_lines (list): A list of regex lines to remove configurations.\n            substitute_lines (list): A list of dictionaries with to remove and replace lines.\n\n        Returns:\n            Result: Nornir Result object with a dict as a result containing the running configuration\n                { \"config: <running configuration> }\n        \"\"\"\n        logger.log_debug(\n            f\"Executing get_config for {task.host.name} on {task.host.platform}\",\n            grouping=task.host.name,\n        )\n        command = RUN_COMMAND_MAPPING.get(task.host.platform, RUN_COMMAND_MAPPING[\"default\"])\n\n        try:\n            result = task.run(task=netmiko_send_command, command_string=command)\n        except NornirSubTaskError as exc:\n            if isinstance(exc.result.exception, NetmikoAuthenticationException):\n                logger.log_failure(\n                    obj,\n                    f\"Failed with an authentication issue: `{exc.result.exception}`\",\n                    grouping=task.host.name,\n                )\n                raise NornirNetboxException(f\"Failed with an authentication issue: `{exc.result.exception}`\") from exc\n\n            if isinstance(exc.result.exception, NetmikoTimeoutException):\n                logger.log_failure(\n                    obj,\n                    f\"Failed with a timeout issue. `{exc.result.exception}`\",\n                    grouping=task.host.name,\n                )\n                raise NornirNetboxException(f\"Failed with a timeout issue. `{exc.result.exception}`\") from exc\n\n            logger.log_failure(\n                obj,\n                f\"Failed with an unknown issue. `{exc.result.exception}`\",\n                grouping=task.host.name,\n            )\n            raise NornirNetboxException(f\"Failed with an unknown issue. `{exc.result.exception}`\") from exc\n\n        if result[0].failed:\n            return result\n\n        running_config = result[0].result\n\n        # Primarily seen in Cisco devices.\n        if \"ERROR: % Invalid input detected at\" in running_config:\n            logger.log_failure(\n                obj,\n                \"Discovered `ERROR: % Invalid input detected at` in the output\",\n                grouping=task.host.name,\n            )\n            raise NornirNetboxException(\"Discovered `ERROR: % Invalid input detected at` in the output\")\n\n        return Result(host=task.host, result={\"config\": running_config})\n\n    @staticmethod\n    def get_facts(task: Task, logger, obj) -> Result:\n        return NotImplementedError(\"get_facts is not implemented for NetmikoNetboxNornirDriver\")\n\n    @staticmethod\n    def get_interfaces(task: Task, logger, obj) -> Result:\n        return NotImplementedError(\"get_interfaces is not implemented for NetmikoNetboxNornirDriver\")", ""]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/cisco_ios_restconf.py", "chunked_list": ["\"\"\"Cisco IOS RESTCONF driver.\"\"\"\nimport requests\nfrom nornir.core.task import Result, Task\n\nfrom .default import NetmikoNetboxNornirDriver as DefaultNetboxNornirDriver\n\n\nclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n    \"\"\"Fortigate for configuration backup.\"\"\"\n\n    @staticmethod\n    def get_config(task: Task, logger, obj) -> Result:\n        \"\"\"Get the latest configuration from the device.\n        Args:\n            task (Task): Nornir Task.\n            logger (NornirLogger): Custom NornirLogger object to reflect job results (via Netbox Jobs) and Python logger.\n            obj (Device): A Netbox Device Django ORM object instance.\n        Returns:\n            Result: Nornir Result object with a dict as a result containing the running configuration\n                { \"config: <running configuration> }\n        \"\"\"\n\n        session = requests.Session()\n        session.trust_env = False\n        logger.log_debug(\n            f\"Executing get_config for {task.host.name} on {task.host.platform}\",\n            grouping=task.host.name,\n        )\n        auth = (task.host.username, task.host.password)\n        headers = {\"Accept\": \"application/yang-data+json\"}\n        params = {\"content\": \"config\", \"depth\": \"65535\"}\n\n        response = session.get(\n            f\"https://{task.host.hostname}/restconf/data/Cisco-IOS-XE-native:native\",\n            auth=auth,\n            headers=headers,\n            params=params,\n            verify=False,\n            timeout=10,\n        )\n        response.raise_for_status()\n        return Result(host=task.host, result={\"config\": response.text})", ""]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/fortinet_fortios.py", "chunked_list": ["\"\"\"Fortinet FortiOS Netbox Nornir Driver.\"\"\"\nimport requests\nfrom nornir.core.task import Result, Task\n\nfrom .default import NetmikoNetboxNornirDriver as DefaultNetboxNornirDriver\n\n\nclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n    \"\"\"Fortigate for configuration backup.\"\"\"\n\n    @staticmethod\n    def get_config(task: Task, logger, obj) -> Result:\n        \"\"\"Get the latest configuration from the device.\n        Args:\n            task (Task): Nornir Task.\n            logger (NornirLogger): Custom NornirLogger object to reflect job results (via Netbox Jobs) and Python logger.\n            obj (Device): A Netbox Device Django ORM object instance.\n        Returns:\n            Result: Nornir Result object with a dict as a result containing the running configuration\n                { \"config: <running configuration> }\n        \"\"\"\n\n        session = requests.Session()\n        session.trust_env = False\n        logger.log_debug(\n            f\"Executing get_config for {task.host.name} on {task.host.platform}\",\n            grouping=task.host.name,\n        )\n        response = session.get(\n            f\"https://{task.host.hostname}/api/v2/monitor/system/config/backup?scope=global&access_token={task.host.data['key']}\",\n            verify=False,\n            timeout=10,\n        )\n        response.raise_for_status()\n        return Result(host=task.host, result={\"config\": response.text})", ""]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/arista_eos.py", "chunked_list": ["\"\"\"network_importer driver for arista_eos.\"\"\"\n\nfrom .default import NetboxNornirDriver as DefaultNetboxNornirDriver\n\n\nclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n    \"\"\"Collection of Nornir Tasks specific to Arista EOS devices.\"\"\"\n"]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/paloalto_panos.py", "chunked_list": ["\"\"\"Palo Alto PANOS driver.\"\"\"\nimport xml.dom.minidom  # nosec\n\nimport requests\nfrom nornir.core.task import Result, Task\n\nfrom .default import NetmikoNetboxNornirDriver as DefaultNetboxNornirDriver\n\n\nclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n    \"\"\"Palo Alto PANOS driver for configuration backup.\"\"\"\n\n    @staticmethod\n    def get_config(task: Task, logger, obj) -> Result:\n        \"\"\"Get the latest configuration from the device.\n        Args:\n            task (Task): Nornir Task.\n            logger (NornirLogger): Custom NornirLogger object to reflect job results (via Netbox Jobs) and Python logger.\n            obj (Device): A Netbox Device Django ORM object instance.\n        Returns:\n            Result: Nornir Result object with a dict as a result containing the running configuration\n                { \"config: <running configuration> }\n        \"\"\"\n\n        session = requests.Session()\n        session.trust_env = False\n        logger.log_debug(\n            f\"Executing get_config for {task.host.name} on {task.host.platform}\",\n            grouping=task.host.name,\n        )\n        response = session.get(\n            f\"https://{task.host.hostname}/api/?type=export&category=configuration&key={task.host.data['key']}\",\n            verify=False,\n            timeout=10,\n        )\n        response.raise_for_status()\n        xml_response = xml.dom.minidom.parseString(response.text)  # nosec\n        xml_pretty = xml_response.toprettyxml()\n        return Result(host=task.host, result={\"config\": xml_pretty})", "\nclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n    \"\"\"Palo Alto PANOS driver for configuration backup.\"\"\"\n\n    @staticmethod\n    def get_config(task: Task, logger, obj) -> Result:\n        \"\"\"Get the latest configuration from the device.\n        Args:\n            task (Task): Nornir Task.\n            logger (NornirLogger): Custom NornirLogger object to reflect job results (via Netbox Jobs) and Python logger.\n            obj (Device): A Netbox Device Django ORM object instance.\n        Returns:\n            Result: Nornir Result object with a dict as a result containing the running configuration\n                { \"config: <running configuration> }\n        \"\"\"\n\n        session = requests.Session()\n        session.trust_env = False\n        logger.log_debug(\n            f\"Executing get_config for {task.host.name} on {task.host.platform}\",\n            grouping=task.host.name,\n        )\n        response = session.get(\n            f\"https://{task.host.hostname}/api/?type=export&category=configuration&key={task.host.data['key']}\",\n            verify=False,\n            timeout=10,\n        )\n        response.raise_for_status()\n        xml_response = xml.dom.minidom.parseString(response.text)  # nosec\n        xml_pretty = xml_response.toprettyxml()\n        return Result(host=task.host, result={\"config\": xml_pretty})", ""]}
{"filename": "netbox_nornir/plugins/tasks/dispatcher/cisco_ios.py", "chunked_list": ["\"\"\"network_importer driver for cisco IOS.\"\"\"\n\nfrom .default import NetboxNornirDriver as DefaultNetboxNornirDriver\n\n\nclass NetboxNornirDriver(DefaultNetboxNornirDriver):\n    \"\"\"Driver for Cisco IOS.\"\"\"\n"]}
{"filename": "docker/configuration/configuration.example.py", "chunked_list": ["import re\nfrom os import environ\nfrom os.path import abspath, dirname, join\n\n# For reference see https://netbox.readthedocs.io/en/stable/configuration/\n# Based on https://github.com/netbox-community/netbox/blob/master/netbox/netbox/configuration.example.py\n\n\n# Read secret from file\ndef _read_secret(secret_name, default=None):\n    try:\n        f = open(\"/run/secrets/\" + secret_name, \"r\", encoding=\"utf-8\")\n    except EnvironmentError:\n        return default\n    else:\n        with f:\n            return f.readline().strip()", "# Read secret from file\ndef _read_secret(secret_name, default=None):\n    try:\n        f = open(\"/run/secrets/\" + secret_name, \"r\", encoding=\"utf-8\")\n    except EnvironmentError:\n        return default\n    else:\n        with f:\n            return f.readline().strip()\n", "\n\n_BASE_DIR = dirname(dirname(abspath(__file__)))\n\n#########################\n#                       #\n#   Required settings   #\n#                       #\n#########################\n", "#########################\n\n# This is a list of valid fully-qualified domain names (FQDNs) for the NetBox server. NetBox will not permit write\n# access to the server via any other hostnames. The first FQDN in the list will be treated as the preferred name.\n#\n# Example: ALLOWED_HOSTS = ['netbox.example.com', 'netbox.internal.local']\nALLOWED_HOSTS = environ.get(\"ALLOWED_HOSTS\", \"*\").split(\" \")\n\n# PostgreSQL database configuration. See the Django documentation for a complete list of available parameters:\n#   https://docs.djangoproject.com/en/stable/ref/settings/#databases", "# PostgreSQL database configuration. See the Django documentation for a complete list of available parameters:\n#   https://docs.djangoproject.com/en/stable/ref/settings/#databases\nDATABASE = {\n    \"NAME\": environ.get(\"DB_NAME\", \"netbox\"),  # Database name\n    \"USER\": environ.get(\"DB_USER\", \"\"),  # PostgreSQL username\n    \"PASSWORD\": _read_secret(\"db_password\", environ.get(\"DB_PASSWORD\", \"\")),\n    # PostgreSQL password\n    \"HOST\": environ.get(\"DB_HOST\", \"localhost\"),  # Database server\n    \"PORT\": environ.get(\"DB_PORT\", \"\"),  # Database port (leave blank for default)\n    \"OPTIONS\": {\"sslmode\": environ.get(\"DB_SSLMODE\", \"prefer\")},", "    \"PORT\": environ.get(\"DB_PORT\", \"\"),  # Database port (leave blank for default)\n    \"OPTIONS\": {\"sslmode\": environ.get(\"DB_SSLMODE\", \"prefer\")},\n    # Database connection SSLMODE\n    \"CONN_MAX_AGE\": int(environ.get(\"DB_CONN_MAX_AGE\", \"300\")),\n    # Max database connection age\n    \"DISABLE_SERVER_SIDE_CURSORS\": environ.get(\"DB_DISABLE_SERVER_SIDE_CURSORS\", \"False\").lower() == \"true\",\n    # Disable the use of server-side cursors transaction pooling\n}\n\n# Redis database settings. Redis is used for caching and for queuing background tasks such as webhook events. A separate", "\n# Redis database settings. Redis is used for caching and for queuing background tasks such as webhook events. A separate\n# configuration exists for each. Full connection details are required in both sections, and it is strongly recommended\n# to use two separate database IDs.\nREDIS = {\n    \"tasks\": {\n        \"HOST\": environ.get(\"REDIS_HOST\", \"localhost\"),\n        \"PORT\": int(environ.get(\"REDIS_PORT\", 6379)),\n        \"PASSWORD\": _read_secret(\"redis_password\", environ.get(\"REDIS_PASSWORD\", \"\")),\n        \"DATABASE\": int(environ.get(\"REDIS_DATABASE\", 0)),", "        \"PASSWORD\": _read_secret(\"redis_password\", environ.get(\"REDIS_PASSWORD\", \"\")),\n        \"DATABASE\": int(environ.get(\"REDIS_DATABASE\", 0)),\n        \"SSL\": environ.get(\"REDIS_SSL\", \"False\").lower() == \"true\",\n        \"INSECURE_SKIP_TLS_VERIFY\": environ.get(\"REDIS_INSECURE_SKIP_TLS_VERIFY\", \"False\").lower() == \"true\",\n    },\n    \"caching\": {\n        \"HOST\": environ.get(\"REDIS_CACHE_HOST\", environ.get(\"REDIS_HOST\", \"localhost\")),\n        \"PORT\": int(environ.get(\"REDIS_CACHE_PORT\", environ.get(\"REDIS_PORT\", 6379))),\n        \"PASSWORD\": _read_secret(\n            \"redis_cache_password\",", "        \"PASSWORD\": _read_secret(\n            \"redis_cache_password\",\n            environ.get(\"REDIS_CACHE_PASSWORD\", environ.get(\"REDIS_PASSWORD\", \"\")),\n        ),\n        \"DATABASE\": int(environ.get(\"REDIS_CACHE_DATABASE\", 1)),\n        \"SSL\": environ.get(\"REDIS_CACHE_SSL\", environ.get(\"REDIS_SSL\", \"False\")).lower() == \"true\",\n        \"INSECURE_SKIP_TLS_VERIFY\": environ.get(\n            \"REDIS_CACHE_INSECURE_SKIP_TLS_VERIFY\",\n            environ.get(\"REDIS_INSECURE_SKIP_TLS_VERIFY\", \"False\"),\n        ).lower()", "            environ.get(\"REDIS_INSECURE_SKIP_TLS_VERIFY\", \"False\"),\n        ).lower()\n        == \"true\",\n    },\n}\n\n# This key is used for secure generation of random numbers and strings. It must never be exposed outside of this file.\n# For optimal security, SECRET_KEY should be at least 50 characters in length and contain a mix of letters, numbers, and\n# symbols. NetBox will not run without this defined. For more information, see\n# https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-SECRET_KEY", "# symbols. NetBox will not run without this defined. For more information, see\n# https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-SECRET_KEY\nSECRET_KEY = _read_secret(\"secret_key\", environ.get(\"SECRET_KEY\", \"\"))\n\n\n#########################\n#                       #\n#   Optional settings   #\n#                       #\n#########################", "#                       #\n#########################\n\n# Specify one or more name and email address tuples representing NetBox administrators. These people will be notified of\n# application errors (assuming correct email settings are provided).\nADMINS = [\n    # ['John Doe', 'jdoe@example.com'],\n]\n\n# URL schemes that are allowed within links in NetBox", "\n# URL schemes that are allowed within links in NetBox\nALLOWED_URL_SCHEMES = (\n    \"file\",\n    \"ftp\",\n    \"ftps\",\n    \"http\",\n    \"https\",\n    \"irc\",\n    \"mailto\",", "    \"irc\",\n    \"mailto\",\n    \"sftp\",\n    \"ssh\",\n    \"tel\",\n    \"telnet\",\n    \"tftp\",\n    \"vnc\",\n    \"xmpp\",\n)", "    \"xmpp\",\n)\n\n# Optionally display a persistent banner at the top and/or bottom of every page. HTML is allowed. To display the same\n# content in both banners, define BANNER_TOP and set BANNER_BOTTOM = BANNER_TOP.\nBANNER_TOP = environ.get(\"BANNER_TOP\", \"\")\nBANNER_BOTTOM = environ.get(\"BANNER_BOTTOM\", \"\")\n\n# Text to include on the login page above the login form. HTML is allowed.\nBANNER_LOGIN = environ.get(\"BANNER_LOGIN\", \"\")", "# Text to include on the login page above the login form. HTML is allowed.\nBANNER_LOGIN = environ.get(\"BANNER_LOGIN\", \"\")\n\n# Base URL path if accessing NetBox within a directory. For example, if installed at http://example.com/netbox/, set:\n# BASE_PATH = 'netbox/'\nBASE_PATH = environ.get(\"BASE_PATH\", \"\")\n\n# Maximum number of days to retain logged changes. Set to 0 to retain changes indefinitely. (Default: 90)\nCHANGELOG_RETENTION = int(environ.get(\"CHANGELOG_RETENTION\", 90))\n", "CHANGELOG_RETENTION = int(environ.get(\"CHANGELOG_RETENTION\", 90))\n\n# API Cross-Origin Resource Sharing (CORS) settings. If CORS_ORIGIN_ALLOW_ALL is set to True, all origins will be\n# allowed. Otherwise, define a list of allowed origins using either CORS_ORIGIN_WHITELIST or\n# CORS_ORIGIN_REGEX_WHITELIST. For more information, see https://github.com/ottoyiu/django-cors-headers\nCORS_ORIGIN_ALLOW_ALL = environ.get(\"CORS_ORIGIN_ALLOW_ALL\", \"False\").lower() == \"true\"\nCORS_ORIGIN_WHITELIST = list(filter(None, environ.get(\"CORS_ORIGIN_WHITELIST\", \"https://localhost\").split(\" \")))\nCORS_ORIGIN_REGEX_WHITELIST = [\n    re.compile(r) for r in list(filter(None, environ.get(\"CORS_ORIGIN_REGEX_WHITELIST\", \"\").split(\" \")))\n]", "    re.compile(r) for r in list(filter(None, environ.get(\"CORS_ORIGIN_REGEX_WHITELIST\", \"\").split(\" \")))\n]\n\n# Cross-Site-Request-Forgery-Attack settings. If Netbox is sitting behind a reverse proxy, you might need to set the CSRF_TRUSTED_ORIGINS flag.\n# Django 4.0 requires to specify the URL Scheme in this setting. An example environment variable could be specified like:\n# CSRF_TRUSTED_ORIGINS=https://demo.netbox.dev http://demo.netbox.dev\nCSRF_TRUSTED_ORIGINS = list(filter(None, environ.get(\"CSRF_TRUSTED_ORIGINS\", \"\").split(\" \")))\n\n# Set to True to enable server debugging. WARNING: Debugging introduces a substantial performance penalty and may reveal\n# sensitive information about your installation. Only enable debugging while performing testing. Never enable debugging", "# Set to True to enable server debugging. WARNING: Debugging introduces a substantial performance penalty and may reveal\n# sensitive information about your installation. Only enable debugging while performing testing. Never enable debugging\n# on a production system.\nDEBUG = environ.get(\"DEBUG\", \"False\").lower() == \"true\"\nDEVELOPER = True\n\n# Email settings\nEMAIL = {\n    \"SERVER\": environ.get(\"EMAIL_SERVER\", \"localhost\"),\n    \"PORT\": int(environ.get(\"EMAIL_PORT\", 25)),", "    \"SERVER\": environ.get(\"EMAIL_SERVER\", \"localhost\"),\n    \"PORT\": int(environ.get(\"EMAIL_PORT\", 25)),\n    \"USERNAME\": environ.get(\"EMAIL_USERNAME\", \"\"),\n    \"PASSWORD\": _read_secret(\"email_password\", environ.get(\"EMAIL_PASSWORD\", \"\")),\n    \"USE_SSL\": environ.get(\"EMAIL_USE_SSL\", \"False\").lower() == \"true\",\n    \"USE_TLS\": environ.get(\"EMAIL_USE_TLS\", \"False\").lower() == \"true\",\n    \"SSL_CERTFILE\": environ.get(\"EMAIL_SSL_CERTFILE\", \"\"),\n    \"SSL_KEYFILE\": environ.get(\"EMAIL_SSL_KEYFILE\", \"\"),\n    \"TIMEOUT\": int(environ.get(\"EMAIL_TIMEOUT\", 10)),  # seconds\n    \"FROM_EMAIL\": environ.get(\"EMAIL_FROM\", \"\"),", "    \"TIMEOUT\": int(environ.get(\"EMAIL_TIMEOUT\", 10)),  # seconds\n    \"FROM_EMAIL\": environ.get(\"EMAIL_FROM\", \"\"),\n}\n\n# Enforcement of unique IP space can be toggled on a per-VRF basis. To enforce unique IP space within the global table\n# (all prefixes and IP addresses not assigned to a VRF), set ENFORCE_GLOBAL_UNIQUE to True.\nENFORCE_GLOBAL_UNIQUE = environ.get(\"ENFORCE_GLOBAL_UNIQUE\", \"False\").lower() == \"true\"\n\n# Exempt certain models from the enforcement of view permissions. Models listed here will be viewable by all users and\n# by anonymous users. List models in the form `<app>.<model>`. Add '*' to this list to exempt all models.", "# Exempt certain models from the enforcement of view permissions. Models listed here will be viewable by all users and\n# by anonymous users. List models in the form `<app>.<model>`. Add '*' to this list to exempt all models.\nEXEMPT_VIEW_PERMISSIONS = list(filter(None, environ.get(\"EXEMPT_VIEW_PERMISSIONS\", \"\").split(\" \")))\n\n# Enable GraphQL API.\nGRAPHQL_ENABLED = environ.get(\"GRAPHQL_ENABLED\", \"True\").lower() == \"true\"\n\n# Enable custom logging. Please see the Django documentation for detailed guidance on configuring custom logs:\n#   https://docs.djangoproject.com/en/stable/topics/logging/\nLOGGING = {}", "#   https://docs.djangoproject.com/en/stable/topics/logging/\nLOGGING = {}\n\n# Setting this to True will permit only authenticated users to access any part of NetBox. By default, anonymous users\n# are permitted to access most data in NetBox (excluding secrets) but not make any changes.\nLOGIN_REQUIRED = environ.get(\"LOGIN_REQUIRED\", \"False\").lower() == \"true\"\n\n# The length of time (in seconds) for which a user will remain logged into the web UI before being prompted to\n# re-authenticate. (Default: 1209600 [14 days])\nLOGIN_TIMEOUT = int(environ.get(\"LOGIN_TIMEOUT\", 1209600))", "# re-authenticate. (Default: 1209600 [14 days])\nLOGIN_TIMEOUT = int(environ.get(\"LOGIN_TIMEOUT\", 1209600))\n\n# Setting this to True will display a \"maintenance mode\" banner at the top of every page.\nMAINTENANCE_MODE = environ.get(\"MAINTENANCE_MODE\", \"False\").lower() == \"true\"\n\n# Maps provider\nMAPS_URL = environ.get(\"MAPS_URL\", None)\n\n# An API consumer can request an arbitrary number of objects =by appending the \"limit\" parameter to the URL (e.g.", "\n# An API consumer can request an arbitrary number of objects =by appending the \"limit\" parameter to the URL (e.g.\n# \"?limit=1000\"). This setting defines the maximum limit. Setting it to 0 or None will allow an API consumer to request\n# all objects by specifying \"?limit=0\".\nMAX_PAGE_SIZE = int(environ.get(\"MAX_PAGE_SIZE\", 1000))\n\n# The file path where uploaded media such as image attachments are stored. A trailing slash is not needed. Note that\n# the default value of this setting is derived from the installed location.\nMEDIA_ROOT = environ.get(\"MEDIA_ROOT\", join(_BASE_DIR, \"media\"))\n", "MEDIA_ROOT = environ.get(\"MEDIA_ROOT\", join(_BASE_DIR, \"media\"))\n\n# Expose Prometheus monitoring metrics at the HTTP endpoint '/metrics'\nMETRICS_ENABLED = environ.get(\"METRICS_ENABLED\", \"False\").lower() == \"true\"\n\n# Credentials that NetBox will uses to authenticate to devices when connecting via NAPALM.\nNAPALM_USERNAME = environ.get(\"NAPALM_USERNAME\", \"\")\nNAPALM_PASSWORD = _read_secret(\"napalm_password\", environ.get(\"NAPALM_PASSWORD\", \"\"))\n\n# NAPALM timeout (in seconds). (Default: 30)", "\n# NAPALM timeout (in seconds). (Default: 30)\nNAPALM_TIMEOUT = int(environ.get(\"NAPALM_TIMEOUT\", 30))\n\n# NAPALM optional arguments (see http://napalm.readthedocs.io/en/latest/support/#optional-arguments). Arguments must\n# be provided as a dictionary.\nNAPALM_ARGS = {}\n\n# Determine how many objects to display per page within a list. (Default: 50)\nPAGINATE_COUNT = int(environ.get(\"PAGINATE_COUNT\", 50))", "# Determine how many objects to display per page within a list. (Default: 50)\nPAGINATE_COUNT = int(environ.get(\"PAGINATE_COUNT\", 50))\n\n# Enable installed plugins. Add the name of each plugin to the list.\n# configuration.py\nPLUGINS = [\n    \"netbox_nornir\",\n]\n\n# Plugins configuration settings. These settings are used by various plugins that the user may have installed.", "\n# Plugins configuration settings. These settings are used by various plugins that the user may have installed.\n# Each key in the dictionary is the name of an installed plugin and its value is a dictionary of settings.\nPLUGINS_CONFIG = {\n    \"netbox_config_backup\": {\n        \"smtp_server\": \"\",\n        \"smtp_port\": 587,\n        \"smtp_username\": \"\",\n        \"smtp_password\": \"\",\n    },", "        \"smtp_password\": \"\",\n    },\n}\n\n# When determining the primary IP address for a device, IPv6 is preferred over IPv4 by default. Set this to True to\n# prefer IPv4 instead.\nPREFER_IPV4 = environ.get(\"PREFER_IPV4\", \"False\").lower() == \"true\"\n\n# Rack elevation size defaults, in pixels. For best results, the ratio of width to height should be roughly 10:1.\nRACK_ELEVATION_DEFAULT_UNIT_HEIGHT = int(environ.get(\"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\", 22))", "# Rack elevation size defaults, in pixels. For best results, the ratio of width to height should be roughly 10:1.\nRACK_ELEVATION_DEFAULT_UNIT_HEIGHT = int(environ.get(\"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\", 22))\nRACK_ELEVATION_DEFAULT_UNIT_WIDTH = int(environ.get(\"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\", 220))\n\n# Remote authentication support\nREMOTE_AUTH_ENABLED = environ.get(\"REMOTE_AUTH_ENABLED\", \"False\").lower() == \"true\"\nREMOTE_AUTH_BACKEND = environ.get(\"REMOTE_AUTH_BACKEND\", \"netbox.authentication.RemoteUserBackend\")\nREMOTE_AUTH_HEADER = environ.get(\"REMOTE_AUTH_HEADER\", \"HTTP_REMOTE_USER\")\nREMOTE_AUTH_AUTO_CREATE_USER = environ.get(\"REMOTE_AUTH_AUTO_CREATE_USER\", \"True\").lower() == \"true\"\nREMOTE_AUTH_DEFAULT_GROUPS = list(filter(None, environ.get(\"REMOTE_AUTH_DEFAULT_GROUPS\", \"\").split(\" \")))", "REMOTE_AUTH_AUTO_CREATE_USER = environ.get(\"REMOTE_AUTH_AUTO_CREATE_USER\", \"True\").lower() == \"true\"\nREMOTE_AUTH_DEFAULT_GROUPS = list(filter(None, environ.get(\"REMOTE_AUTH_DEFAULT_GROUPS\", \"\").split(\" \")))\n\n# This repository is used to check whether there is a new release of NetBox available. Set to None to disable the\n# version check or use the URL below to check for release in the official NetBox repository.\n# https://api.github.com/repos/netbox-community/netbox/releases\nRELEASE_CHECK_URL = environ.get(\"RELEASE_CHECK_URL\", None)\n\n# The file path where custom reports will be stored. A trailing slash is not needed. Note that the default value of\n# this setting is derived from the installed location.", "# The file path where custom reports will be stored. A trailing slash is not needed. Note that the default value of\n# this setting is derived from the installed location.\nREPORTS_ROOT = environ.get(\"REPORTS_ROOT\", \"/etc/netbox/reports\")\n\n# Maximum execution time for background tasks, in seconds.\nRQ_DEFAULT_TIMEOUT = int(environ.get(\"RQ_DEFAULT_TIMEOUT\", 300))\n\n# The file path where custom scripts will be stored. A trailing slash is not needed. Note that the default value of\n# this setting is derived from the installed location.\nSCRIPTS_ROOT = environ.get(\"SCRIPTS_ROOT\", \"/etc/netbox/scripts\")", "# this setting is derived from the installed location.\nSCRIPTS_ROOT = environ.get(\"SCRIPTS_ROOT\", \"/etc/netbox/scripts\")\n\n# By default, NetBox will store session data in the database. Alternatively, a file path can be specified here to use\n# local file storage instead. (This can be useful for enabling authentication on a standby instance with read-only\n# database access.) Note that the user as which NetBox runs must have read and write permissions to this path.\nSESSION_FILE_PATH = environ.get(\"SESSIONS_ROOT\", None)\n\n# Time zone (default: UTC)\nTIME_ZONE = environ.get(\"TIME_ZONE\", \"UTC\")", "# Time zone (default: UTC)\nTIME_ZONE = environ.get(\"TIME_ZONE\", \"UTC\")\n\n# Date/time formatting. See the following link for supported formats:\n# https://docs.djangoproject.com/en/stable/ref/templates/builtins/#date\nDATE_FORMAT = environ.get(\"DATE_FORMAT\", \"N j, Y\")\nSHORT_DATE_FORMAT = environ.get(\"SHORT_DATE_FORMAT\", \"Y-m-d\")\nTIME_FORMAT = environ.get(\"TIME_FORMAT\", \"g:i a\")\nSHORT_TIME_FORMAT = environ.get(\"SHORT_TIME_FORMAT\", \"H:i:s\")\nDATETIME_FORMAT = environ.get(\"DATETIME_FORMAT\", \"N j, Y g:i a\")", "SHORT_TIME_FORMAT = environ.get(\"SHORT_TIME_FORMAT\", \"H:i:s\")\nDATETIME_FORMAT = environ.get(\"DATETIME_FORMAT\", \"N j, Y g:i a\")\nSHORT_DATETIME_FORMAT = environ.get(\"SHORT_DATETIME_FORMAT\", \"Y-m-d H:i\")\n"]}
