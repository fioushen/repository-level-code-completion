{"filename": "oneringcore.py", "chunked_list": ["from typing import Optional\n\nfrom jaa import JaaCore\n\nfrom termcolor import colored, cprint\nimport os\nimport json\n\nversion = \"7.3.0\"\n\nclass OneRingCore(JaaCore):\n    def __init__(self):\n        JaaCore.__init__(self)\n\n        self.translators:dict = {\n        }\n\n        self.default_translator:str = \"\"\n        self.default_from_lang:str = \"\"\n        self.default_to_lang:str = \"\"\n\n        self.default_translate_router:dict[str,str] = {}\n\n        self.api_keys_allowed:list = []\n\n        self.is_debug_input_output:bool = False\n        self.is_multithread:bool = True\n\n        self.init_on_start:str = \"\"\n\n        self.user_lang:str = \"\"\n\n        self.cache_is_use = False\n        self.cache_save_every = 5\n        self.cache_per_model = True\n\n        self.cache_dict:dict[str,dict[str,str]] = {}\n\n        self.inited_translator_engines = []\n\n        self.dict_lang_to_2let = {'Afrikaans': 'af', 'Albanian': 'sq', 'Amharic': 'am', 'Arabic': 'ar', 'Armenian': 'hy', 'Azerbaijani': 'az', 'Basque': 'eu', 'Belarusian': 'be', 'Bengali': 'bn', 'Bosnian': 'bs', 'Bulgarian': 'bg', 'Catalan': 'ca', 'Cebuano': 'ceb', 'Chinese (Simplified)': 'zh-CN', 'Chinese (Traditional)': 'zh-TW', 'Corsican': 'co', 'Croatian': 'hr', 'Czech': 'cs', 'Danish': 'da', 'Dutch': 'nl', 'English': 'en', 'Esperanto': 'eo', 'Estonian': 'et', 'Finnish': 'fi', 'French': 'fr', 'Frisian': 'fy', 'Galician': 'gl', 'Georgian': 'ka', 'German': 'de', 'Greek': 'el', 'Gujarati': 'gu', 'Haitian Creole': 'ht', 'Hausa': 'ha', 'Hawaiian': 'haw', 'Hebrew': 'iw', 'Hindi': 'hi', 'Hmong': 'hmn', 'Hungarian': 'hu', 'Icelandic': 'is', 'Igbo': 'ig', 'Indonesian': 'id', 'Irish': 'ga', 'Italian': 'it', 'Japanese': 'ja', 'Javanese': 'jw', 'Kannada': 'kn', 'Kazakh': 'kk', 'Khmer': 'km', 'Korean': 'ko', 'Kurdish': 'ku', 'Kyrgyz': 'ky', 'Lao': 'lo', 'Latin': 'la', 'Latvian': 'lv', 'Lithuanian': 'lt', 'Luxembourgish': 'lb', 'Macedonian': 'mk', 'Malagasy': 'mg', 'Malay': 'ms', 'Malayalam': 'ml', 'Maltese': 'mt', 'Maori': 'mi', 'Marathi': 'mr', 'Mongolian': 'mn', 'Myanmar (Burmese)': 'my', 'Nepali': 'ne', 'Norwegian': 'no', 'Nyanja (Chichewa)': 'ny', 'Pashto': 'ps', 'Persian': 'fa', 'Polish': 'pl', 'Portuguese (Portugal, Brazil)': 'pt', 'Punjabi': 'pa', 'Romanian': 'ro', 'Russian': 'ru', 'Samoan': 'sm', 'Scots Gaelic': 'gd', 'Serbian': 'sr', 'Sesotho': 'st', 'Shona': 'sn', 'Sindhi': 'sd', 'Sinhala (Sinhalese)': 'si', 'Slovak': 'sk', 'Slovenian': 'sl', 'Somali': 'so', 'Spanish': 'es', 'Sundanese': 'su', 'Swahili': 'sw', 'Swedish': 'sv', 'Tagalog (Filipino)': 'tl', 'Tajik': 'tg', 'Tamil': 'ta', 'Telugu': 'te', 'Thai': 'th', 'Turkish': 'tr', 'Ukrainian': 'uk', 'Urdu': 'ur', 'Uzbek': 'uz', 'Vietnamese': 'vi', 'Welsh': 'cy', 'Xhosa': 'xh', 'Yiddish': 'yi', 'Yoruba': 'yo', 'Zulu': 'zu'}\n        self.dict_2let_to_lang = {}\n        for i in self.dict_lang_to_2let.keys():\n            self.dict_2let_to_lang[self.dict_lang_to_2let[i]] = i\n\n    # ----------- process plugins functions ------\n    def process_plugin_manifest(self, modname, manifest):\n        # is req online?\n        # adding tts engines from plugin manifest\n        if \"translate\" in manifest:  # process commands\n            for cmd in manifest[\"translate\"].keys():\n                self.translators[cmd] = manifest[\"translate\"][cmd]\n\n        return manifest\n\n    def init_with_plugins(self):\n        self.init_plugins([\"core\"])\n        #self.init_plugins()\n        self.display_init_info()\n\n        self.init_translator_engine(self.default_translator)\n\n        ar_init_on_start = self.init_on_start.split(\",\")\n        for translator in ar_init_on_start:\n            if translator != \"\":\n                self.init_translator_engine(translator)\n\n    # ------------ formatting stuff -------------------\n    def display_init_info(self):\n        cprint(\"OneRingCore v{0}:\".format(version), \"blue\", end=' ')\n        self.format_print_key_list(\"translate engines\", self.translators.keys())\n        print(\"Default translator:\",self.default_translator)\n\n    def format_print_key_list(self, key:str, value:list):\n        print(colored(key+\": \", \"blue\")+\", \".join(value))\n\n    def print_error(self,err_txt,e:Exception = None):\n        cprint(err_txt,\"red\")\n        # if e != None:\n        #     cprint(e,\"red\")\n        import traceback\n        traceback.print_exc()\n\n    def print_red(self,txt):\n        cprint(txt,\"red\")\n\n    def print_blue(self, txt):\n        cprint(txt, \"blue\")\n\n    # ---------------- init translation stuff ----------------\n    def init_translator_engine(self, translator_engine:str):\n\n        if translator_engine in self.inited_translator_engines:\n            # already inited\n            return\n\n        try:\n            self.print_blue(\"TRY: init translation plugin '{0}'...\".format(translator_engine))\n            self.translators[translator_engine][0](self)\n            self.inited_translator_engines.append(translator_engine)\n            self.print_blue(\"SUCCESS: '{0}' inited!\".format(translator_engine))\n\n        except Exception as e:\n            self.print_error(\"Error init translation plugin {0}...\".format(translator_engine), e)\n\n    def translate(self, text:str, from_lang:str = \"\", to_lang:str = \"\", translator_plugin:str = \"\", add_params:str = \"\"):\n        if self.is_debug_input_output:\n            print(\"Input: {0}\".format(text))\n\n        # 1. Calculating translator plugin\n        if translator_plugin == \"\":\n            router_trans = self.default_translate_router.get(f\"{from_lang}->{to_lang}\")\n            router_ast1 = self.default_translate_router.get(f\"*->{to_lang}\")\n            router_ast2 = self.default_translate_router.get(f\"{from_lang}->*\")\n            if router_trans is not None:\n                if self.is_debug_input_output:\n                    print(\"Calculated ROUTER -> translator: {0}\".format(router_trans))\n                translator_plugin = router_trans\n            elif router_ast1 is not None:\n                if self.is_debug_input_output:\n                    print(\"Calculated ROUTER *-> translator: {0}\".format(router_ast1))\n                translator_plugin = router_ast1\n            elif router_ast2 is not None:\n                if self.is_debug_input_output:\n                    print(\"Calculated ROUTER ->* translator: {0}\".format(router_ast2))\n                translator_plugin = router_ast2\n            else:\n                if self.is_debug_input_output:\n                    print(\"Calculated default_translator translator: {0}\".format(self.default_translator))\n                translator_plugin = self.default_translator\n\n        # 2. Special case - if \":\" in translator_plugin, then try to setup model for this plugin\n        # usually works OK only with online translators\n        if \":\" in translator_plugin:\n            translator_plugin,new_model = translator_plugin.split(\":\",1)\n            self.plugin_options(\"plugin_\"+translator_plugin)[\"model\"] = new_model\n\n        # 3. Calc from_lang and to_lang if they are blank\n        if from_lang == \"\":\n            from_lang = self.default_from_lang\n\n        if to_lang == \"\":\n            to_lang = self.default_to_lang\n\n        if from_lang == \"user\":\n            from_lang = self.user_lang\n            if self.user_lang == \"\":\n                return {\"error\": \"user_lang is blank. Please, setup it in options/core.json file\"}\n\n        if to_lang == \"user\":\n            to_lang = self.user_lang\n            if self.user_lang == \"\":\n                return {\"error\": \"user_lang is blank. Please, setup it in options/core.json file\"}\n\n        # 4. Calculating cache_id. Get result from cache if it exists\n        cache_id = self.cache_calc_id(from_lang,to_lang,translator_plugin)\n        if self.cache_is_use:\n            cache_res = self.cache_get(text,cache_id)\n            if cache_res is not None:\n                if self.is_debug_input_output:\n                    print(\"Output from CACHE: {0}\".format(cache_res))\n                return {\"result\": cache_res, \"cache\": True}\n\n        # init after cache\n        if translator_plugin != \"\":\n            self.init_translator_engine(translator_plugin)\n\n            if translator_plugin not in self.inited_translator_engines:\n                return {\"error\": \"Translator plugin not inited\"}\n\n\n        # Actual call translation plugin\n        res = self.translators[translator_plugin][1](self, text, from_lang, to_lang, add_params)\n\n        if self.is_debug_input_output:\n            print(\"Output: {0}\".format(res))\n\n        if self.cache_is_use:\n            self.cache_set(text,cache_id,res)\n\n        return {\"result\": res, \"cache\": False}\n\n    # -------------- caching functions ----------------\n    def cache_calc_id(self, from_lang:str, to_lang:str, translator_plugin:str) -> str:\n        res = translator_plugin+\"__\"+from_lang+\"__\"+to_lang\n        #print(self.cache_per_model)\n        if self.cache_per_model:\n            # params = self.plugin_manifest(translator_plugin)\n            # if params is not None:\n            options = self.plugin_options(\"plugin_\"+translator_plugin)\n            #print(translator_plugin,options)\n            if options is not None:\n                model = options.get(\"model\")\n                if model is not None:\n                    model_normalized = str(model)\\\n                        .replace(\"/\",\"_\")\\\n                        .replace(\"\\\\\",\"_\")\\\n                        .replace(\":\",\"_\")\\\n                        .replace(\">\",\"_\")\\\n                        .replace(\"<\", \"_\")\n                    res += \"__\"+model_normalized\n        return res\n\n    def cache_calc_filepath(self, cache_id:str) -> str:\n        return os.path.dirname(__file__)+os.path.sep+\"cache\"+os.path.sep+cache_id+\".json\"\n\n    def cache_load_if_not_exists(self, cache_id:str):\n        if self.cache_dict.get(cache_id) is None:\n            if os.path.exists(self.cache_calc_filepath(cache_id)):\n                with open(self.cache_calc_filepath(cache_id), 'r', encoding=\"utf-8\") as f:\n                    # Load the JSON data from the file into a Python dictionary\n                    data = json.load(f)\n\n                    self.cache_dict[cache_id] = data\n            else:\n                self.cache_dict[cache_id] = {}\n    def cache_get(self, text:str, cache_id:str) -> Optional[str]:\n        self.cache_load_if_not_exists(cache_id)\n\n        return self.cache_dict.get(cache_id).get(text)\n\n    def cache_set(self, text:str, cache_id:str, text_translated:str):\n        self.cache_load_if_not_exists(cache_id)\n\n        self.cache_dict[cache_id][text] = text_translated\n\n        #print(cache_id,self.cache_dict[cache_id])\n\n        if len(self.cache_dict[cache_id]) % self.cache_save_every == 0:\n            self.cache_save(cache_id)\n            #print(\"saved!\")\n\n    def cache_save(self, cache_id:str):\n        with open(self.cache_calc_filepath(cache_id), 'w', encoding=\"utf-8\") as f:\n            json.dump(self.cache_dict[cache_id], f, indent=2, ensure_ascii=False)", "version = \"7.3.0\"\n\nclass OneRingCore(JaaCore):\n    def __init__(self):\n        JaaCore.__init__(self)\n\n        self.translators:dict = {\n        }\n\n        self.default_translator:str = \"\"\n        self.default_from_lang:str = \"\"\n        self.default_to_lang:str = \"\"\n\n        self.default_translate_router:dict[str,str] = {}\n\n        self.api_keys_allowed:list = []\n\n        self.is_debug_input_output:bool = False\n        self.is_multithread:bool = True\n\n        self.init_on_start:str = \"\"\n\n        self.user_lang:str = \"\"\n\n        self.cache_is_use = False\n        self.cache_save_every = 5\n        self.cache_per_model = True\n\n        self.cache_dict:dict[str,dict[str,str]] = {}\n\n        self.inited_translator_engines = []\n\n        self.dict_lang_to_2let = {'Afrikaans': 'af', 'Albanian': 'sq', 'Amharic': 'am', 'Arabic': 'ar', 'Armenian': 'hy', 'Azerbaijani': 'az', 'Basque': 'eu', 'Belarusian': 'be', 'Bengali': 'bn', 'Bosnian': 'bs', 'Bulgarian': 'bg', 'Catalan': 'ca', 'Cebuano': 'ceb', 'Chinese (Simplified)': 'zh-CN', 'Chinese (Traditional)': 'zh-TW', 'Corsican': 'co', 'Croatian': 'hr', 'Czech': 'cs', 'Danish': 'da', 'Dutch': 'nl', 'English': 'en', 'Esperanto': 'eo', 'Estonian': 'et', 'Finnish': 'fi', 'French': 'fr', 'Frisian': 'fy', 'Galician': 'gl', 'Georgian': 'ka', 'German': 'de', 'Greek': 'el', 'Gujarati': 'gu', 'Haitian Creole': 'ht', 'Hausa': 'ha', 'Hawaiian': 'haw', 'Hebrew': 'iw', 'Hindi': 'hi', 'Hmong': 'hmn', 'Hungarian': 'hu', 'Icelandic': 'is', 'Igbo': 'ig', 'Indonesian': 'id', 'Irish': 'ga', 'Italian': 'it', 'Japanese': 'ja', 'Javanese': 'jw', 'Kannada': 'kn', 'Kazakh': 'kk', 'Khmer': 'km', 'Korean': 'ko', 'Kurdish': 'ku', 'Kyrgyz': 'ky', 'Lao': 'lo', 'Latin': 'la', 'Latvian': 'lv', 'Lithuanian': 'lt', 'Luxembourgish': 'lb', 'Macedonian': 'mk', 'Malagasy': 'mg', 'Malay': 'ms', 'Malayalam': 'ml', 'Maltese': 'mt', 'Maori': 'mi', 'Marathi': 'mr', 'Mongolian': 'mn', 'Myanmar (Burmese)': 'my', 'Nepali': 'ne', 'Norwegian': 'no', 'Nyanja (Chichewa)': 'ny', 'Pashto': 'ps', 'Persian': 'fa', 'Polish': 'pl', 'Portuguese (Portugal, Brazil)': 'pt', 'Punjabi': 'pa', 'Romanian': 'ro', 'Russian': 'ru', 'Samoan': 'sm', 'Scots Gaelic': 'gd', 'Serbian': 'sr', 'Sesotho': 'st', 'Shona': 'sn', 'Sindhi': 'sd', 'Sinhala (Sinhalese)': 'si', 'Slovak': 'sk', 'Slovenian': 'sl', 'Somali': 'so', 'Spanish': 'es', 'Sundanese': 'su', 'Swahili': 'sw', 'Swedish': 'sv', 'Tagalog (Filipino)': 'tl', 'Tajik': 'tg', 'Tamil': 'ta', 'Telugu': 'te', 'Thai': 'th', 'Turkish': 'tr', 'Ukrainian': 'uk', 'Urdu': 'ur', 'Uzbek': 'uz', 'Vietnamese': 'vi', 'Welsh': 'cy', 'Xhosa': 'xh', 'Yiddish': 'yi', 'Yoruba': 'yo', 'Zulu': 'zu'}\n        self.dict_2let_to_lang = {}\n        for i in self.dict_lang_to_2let.keys():\n            self.dict_2let_to_lang[self.dict_lang_to_2let[i]] = i\n\n    # ----------- process plugins functions ------\n    def process_plugin_manifest(self, modname, manifest):\n        # is req online?\n        # adding tts engines from plugin manifest\n        if \"translate\" in manifest:  # process commands\n            for cmd in manifest[\"translate\"].keys():\n                self.translators[cmd] = manifest[\"translate\"][cmd]\n\n        return manifest\n\n    def init_with_plugins(self):\n        self.init_plugins([\"core\"])\n        #self.init_plugins()\n        self.display_init_info()\n\n        self.init_translator_engine(self.default_translator)\n\n        ar_init_on_start = self.init_on_start.split(\",\")\n        for translator in ar_init_on_start:\n            if translator != \"\":\n                self.init_translator_engine(translator)\n\n    # ------------ formatting stuff -------------------\n    def display_init_info(self):\n        cprint(\"OneRingCore v{0}:\".format(version), \"blue\", end=' ')\n        self.format_print_key_list(\"translate engines\", self.translators.keys())\n        print(\"Default translator:\",self.default_translator)\n\n    def format_print_key_list(self, key:str, value:list):\n        print(colored(key+\": \", \"blue\")+\", \".join(value))\n\n    def print_error(self,err_txt,e:Exception = None):\n        cprint(err_txt,\"red\")\n        # if e != None:\n        #     cprint(e,\"red\")\n        import traceback\n        traceback.print_exc()\n\n    def print_red(self,txt):\n        cprint(txt,\"red\")\n\n    def print_blue(self, txt):\n        cprint(txt, \"blue\")\n\n    # ---------------- init translation stuff ----------------\n    def init_translator_engine(self, translator_engine:str):\n\n        if translator_engine in self.inited_translator_engines:\n            # already inited\n            return\n\n        try:\n            self.print_blue(\"TRY: init translation plugin '{0}'...\".format(translator_engine))\n            self.translators[translator_engine][0](self)\n            self.inited_translator_engines.append(translator_engine)\n            self.print_blue(\"SUCCESS: '{0}' inited!\".format(translator_engine))\n\n        except Exception as e:\n            self.print_error(\"Error init translation plugin {0}...\".format(translator_engine), e)\n\n    def translate(self, text:str, from_lang:str = \"\", to_lang:str = \"\", translator_plugin:str = \"\", add_params:str = \"\"):\n        if self.is_debug_input_output:\n            print(\"Input: {0}\".format(text))\n\n        # 1. Calculating translator plugin\n        if translator_plugin == \"\":\n            router_trans = self.default_translate_router.get(f\"{from_lang}->{to_lang}\")\n            router_ast1 = self.default_translate_router.get(f\"*->{to_lang}\")\n            router_ast2 = self.default_translate_router.get(f\"{from_lang}->*\")\n            if router_trans is not None:\n                if self.is_debug_input_output:\n                    print(\"Calculated ROUTER -> translator: {0}\".format(router_trans))\n                translator_plugin = router_trans\n            elif router_ast1 is not None:\n                if self.is_debug_input_output:\n                    print(\"Calculated ROUTER *-> translator: {0}\".format(router_ast1))\n                translator_plugin = router_ast1\n            elif router_ast2 is not None:\n                if self.is_debug_input_output:\n                    print(\"Calculated ROUTER ->* translator: {0}\".format(router_ast2))\n                translator_plugin = router_ast2\n            else:\n                if self.is_debug_input_output:\n                    print(\"Calculated default_translator translator: {0}\".format(self.default_translator))\n                translator_plugin = self.default_translator\n\n        # 2. Special case - if \":\" in translator_plugin, then try to setup model for this plugin\n        # usually works OK only with online translators\n        if \":\" in translator_plugin:\n            translator_plugin,new_model = translator_plugin.split(\":\",1)\n            self.plugin_options(\"plugin_\"+translator_plugin)[\"model\"] = new_model\n\n        # 3. Calc from_lang and to_lang if they are blank\n        if from_lang == \"\":\n            from_lang = self.default_from_lang\n\n        if to_lang == \"\":\n            to_lang = self.default_to_lang\n\n        if from_lang == \"user\":\n            from_lang = self.user_lang\n            if self.user_lang == \"\":\n                return {\"error\": \"user_lang is blank. Please, setup it in options/core.json file\"}\n\n        if to_lang == \"user\":\n            to_lang = self.user_lang\n            if self.user_lang == \"\":\n                return {\"error\": \"user_lang is blank. Please, setup it in options/core.json file\"}\n\n        # 4. Calculating cache_id. Get result from cache if it exists\n        cache_id = self.cache_calc_id(from_lang,to_lang,translator_plugin)\n        if self.cache_is_use:\n            cache_res = self.cache_get(text,cache_id)\n            if cache_res is not None:\n                if self.is_debug_input_output:\n                    print(\"Output from CACHE: {0}\".format(cache_res))\n                return {\"result\": cache_res, \"cache\": True}\n\n        # init after cache\n        if translator_plugin != \"\":\n            self.init_translator_engine(translator_plugin)\n\n            if translator_plugin not in self.inited_translator_engines:\n                return {\"error\": \"Translator plugin not inited\"}\n\n\n        # Actual call translation plugin\n        res = self.translators[translator_plugin][1](self, text, from_lang, to_lang, add_params)\n\n        if self.is_debug_input_output:\n            print(\"Output: {0}\".format(res))\n\n        if self.cache_is_use:\n            self.cache_set(text,cache_id,res)\n\n        return {\"result\": res, \"cache\": False}\n\n    # -------------- caching functions ----------------\n    def cache_calc_id(self, from_lang:str, to_lang:str, translator_plugin:str) -> str:\n        res = translator_plugin+\"__\"+from_lang+\"__\"+to_lang\n        #print(self.cache_per_model)\n        if self.cache_per_model:\n            # params = self.plugin_manifest(translator_plugin)\n            # if params is not None:\n            options = self.plugin_options(\"plugin_\"+translator_plugin)\n            #print(translator_plugin,options)\n            if options is not None:\n                model = options.get(\"model\")\n                if model is not None:\n                    model_normalized = str(model)\\\n                        .replace(\"/\",\"_\")\\\n                        .replace(\"\\\\\",\"_\")\\\n                        .replace(\":\",\"_\")\\\n                        .replace(\">\",\"_\")\\\n                        .replace(\"<\", \"_\")\n                    res += \"__\"+model_normalized\n        return res\n\n    def cache_calc_filepath(self, cache_id:str) -> str:\n        return os.path.dirname(__file__)+os.path.sep+\"cache\"+os.path.sep+cache_id+\".json\"\n\n    def cache_load_if_not_exists(self, cache_id:str):\n        if self.cache_dict.get(cache_id) is None:\n            if os.path.exists(self.cache_calc_filepath(cache_id)):\n                with open(self.cache_calc_filepath(cache_id), 'r', encoding=\"utf-8\") as f:\n                    # Load the JSON data from the file into a Python dictionary\n                    data = json.load(f)\n\n                    self.cache_dict[cache_id] = data\n            else:\n                self.cache_dict[cache_id] = {}\n    def cache_get(self, text:str, cache_id:str) -> Optional[str]:\n        self.cache_load_if_not_exists(cache_id)\n\n        return self.cache_dict.get(cache_id).get(text)\n\n    def cache_set(self, text:str, cache_id:str, text_translated:str):\n        self.cache_load_if_not_exists(cache_id)\n\n        self.cache_dict[cache_id][text] = text_translated\n\n        #print(cache_id,self.cache_dict[cache_id])\n\n        if len(self.cache_dict[cache_id]) % self.cache_save_every == 0:\n            self.cache_save(cache_id)\n            #print(\"saved!\")\n\n    def cache_save(self, cache_id:str):\n        with open(self.cache_calc_filepath(cache_id), 'w', encoding=\"utf-8\") as f:\n            json.dump(self.cache_dict[cache_id], f, indent=2, ensure_ascii=False)", "\n"]}
{"filename": "run_cmdline.py", "chunked_list": ["from oneringcore import OneRingCore\n\ncore = OneRingCore()\ncore.init_with_plugins()\n\nres = core.translate(\"Hello! How are you?\", \"en\", \"ru\", \"openrouter_chat\")\n\nprint(res.get(\"result\"))"]}
{"filename": "run_webapi.py", "chunked_list": ["\n# ----------\n\nfrom fastapi import FastAPI, HTTPException\nfrom starlette.responses import Response, HTMLResponse\nimport uvicorn\nimport multiprocessing\n\nfrom starlette.staticfiles import StaticFiles\n", "from starlette.staticfiles import StaticFiles\n\nfrom oneringcore import OneRingCore, version\n\nimport asyncio\n\napp = FastAPI()\n\nwebapi_version = \"2.1\"\n", "webapi_version = \"2.1\"\n\ncore:OneRingCore = None\n\napp.mount(\"/webapi_client\", StaticFiles(directory=\"webapi_client\", html = True), name=\"webapi_client\")\n\n@app.get(\"/\", response_class=HTMLResponse)\nasync def read_items():\n    html_content = f\"\"\"\n    <html>", "    html_content = f\"\"\"\n    <html>\n        <head>\n            <meta charset=\"utf-8\" />\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n            <title>OneRingTranslator</title>\n            <link rel=\"stylesheet\" href=\"/webapi_client/chota.min.css\">\n        </head>\n        <body>\n            <div id=\"top\" class=\"container\" role=\"document\">", "        <body>\n            <div id=\"top\" class=\"container\" role=\"document\">\n                <h1>OneRingTranslator {version}</h1>\n                \n                <a href=\"/webapi_client\" class=\"button\">Web interface (simple)</a><br /><br />\n                \n                <a href=\"/docs\" class=\"button\">API and docs</a><br /><br />\n                \n                <a href=\"https://github.com/janvarev/OneRingTranslator\" class=\"button\" target=\"_blank\">Github</a><br /><br />\n            </div>", "                <a href=\"https://github.com/janvarev/OneRingTranslator\" class=\"button\" target=\"_blank\">Github</a><br /><br />\n            </div>\n        </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(content=html_content, status_code=200)\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    global core", "async def startup_event():\n    global core\n    core = OneRingCore()\n    core.init_with_plugins()\n    pass\n\n@app.get(\n    \"/translate\",\n\n    # Set what the media type will be in the autogenerated OpenAPI specification.", "\n    # Set what the media type will be in the autogenerated OpenAPI specification.\n    # fastapi.tiangolo.com/advanced/additional-responses/#additional-media-types-for-the-main-response\n    # responses = {\n    #     200: {\n    #         \"content\": {\"text\": {}}\n    #     }\n    # },\n\n    # Prevent FastAPI from adding \"application/json\" as an additional", "\n    # Prevent FastAPI from adding \"application/json\" as an additional\n    # response media type in the autogenerated OpenAPI specification.\n    # https://github.com/tiangolo/fastapi/issues/3258\n    # response_class=Response\n)\nasync def translate(text:str, from_lang:str = \"\", to_lang:str = \"\", translator_plugin:str = \"\", add_params:str = \"\", api_key:str = \"\"):\n    \"\"\"\n       Return translation\n", "       Return translation\n\n       :param str text: text to translate\n\n       :param str from_lang: from language (2 symbols, like \"en\"). May be \"user\" (will be replaced to \"user_lang\" from options)\n\n       :param str to_lang: to language (2 symbols, like \"en\"). May be \"user\" (will be replaced to \"user_lang\" from options)\n\n       :param str translator_plugin: to use. If blank, default will be used. If not inited plugin will call, core try to init plugin\n", "       :param str translator_plugin: to use. If blank, default will be used. If not inited plugin will call, core try to init plugin\n\n       :param str add_params: additional params for translation (depends on plugin)\n\n       :param str api_key: api key for access (if service setup in security mode with api keys)\n\n       :return: dict (result: text)\n       \"\"\"\n\n", "\n\n    #return Response(content=data, media_type=\"text/wav\")\n    if len(core.api_keys_allowed) > 0: # there are some api keys\n        if api_key == \"\":\n            return {\"error\": \"API key required\"}\n        if not (api_key in core.api_keys_allowed):\n            return {\"error\": \"No valid API key provided\"}\n\n", "\n\n\n\n    if core.is_multithread:\n        #print(\"Multithread\")\n        #res = await asyncio.to_thread(core.translators[translator_plugin][1], core, text, from_lang, to_lang, add_params)\n\n        # init before other threads will run\n        if translator_plugin != \"\":\n            core.init_translator_engine(translator_plugin)\n\n            if translator_plugin not in core.inited_translator_engines:\n                return {\"error\": \"Translator plugin not inited\"}\n\n        res = await asyncio.to_thread(core.translate, text, from_lang, to_lang, translator_plugin,\n                                      add_params)\n    else:\n        res = core.translate(text,from_lang,to_lang,translator_plugin,add_params)", "\n\n\n    # import time\n    # time.sleep(1)\n\n    return res #{\"result\": res}\n\n@app.get(\n    \"/translator_plugin_info\",", "@app.get(\n    \"/translator_plugin_info\",\n)\nasync def translator_plugin_info(api_key:str = \"\"):\n    \"\"\"\n       Return list of available translator plugins\n\n       :param int api_key: api key for access (if service setup in security mode with api keys)\n\n       :return: dict with info", "\n       :return: dict with info\n       \"\"\"\n    if len(core.api_keys_allowed) > 0: # there are some api keys\n        if api_key == \"\":\n            return {\"error\": \"API key required\"}\n        if not (api_key in core.api_keys_allowed):\n            return {\"error\": \"No valid API key provided\"}\n\n    full_list = list(core.translators.keys())", "\n    full_list = list(core.translators.keys())\n    inited_list = core.inited_translator_engines\n    return {\"result\": {\n        \"default\": core.default_translator,\n        \"all_translator\": full_list,\n        \"inited_translator\": inited_list,\n        \"user_lang\": core.user_lang\n    }}\n", "    }}\n\n@app.get(\n    \"/whois\",\n)\nasync def whois():\n    \"\"\"\n       Return whois service info\n\n       :return: dict with info", "\n       :return: dict with info\n       \"\"\"\n    from oneringcore import version\n    return {\"result\": {\n        \"service\": \"OneRingTranslator\",\n        \"version\": version,\n    }}\n\nif __name__ == \"__main__\":\n    #multiprocessing.freeze_support()\n    print(\"Running OneRingTranslator v{0}, web server v{1}...\".format(version, webapi_version))\n    uvicorn.run(\"run_webapi:app\", host=\"127.0.0.1\", port=4990, log_level=\"info\")", "\nif __name__ == \"__main__\":\n    #multiprocessing.freeze_support()\n    print(\"Running OneRingTranslator v{0}, web server v{1}...\".format(version, webapi_version))\n    uvicorn.run(\"run_webapi:app\", host=\"127.0.0.1\", port=4990, log_level=\"info\")"]}
{"filename": "run_estimate_bleu.py", "chunked_list": ["import time\nimport random\n\nfrom nltk.translate.bleu_score import sentence_bleu\n\n# ----------\nfrom oneringcore import OneRingCore\n\n# ----------------- key settings params ----------------\nBLEU_PAIRS = \"fra->eng,eng->fra,rus->eng,eng->rus\" # pairs of language in terms of FLORES dataset https://huggingface.co/datasets/gsarti/flores_101/viewer", "# ----------------- key settings params ----------------\nBLEU_PAIRS = \"fra->eng,eng->fra,rus->eng,eng->rus\" # pairs of language in terms of FLORES dataset https://huggingface.co/datasets/gsarti/flores_101/viewer\nBLEU_PAIRS_2LETTERS = \"fr->en,en->fr,ru->en,en->ru\" # pairs of language codes that will be passed to plugin (from_lang, to_lang params)\n\n# BLEU_PAIRS = \"jpn->rus\" # pairs of language in terms of FLORES dataset https://huggingface.co/datasets/gsarti/flores_101/viewer\n# BLEU_PAIRS_2LETTERS = \"ja->ru\" # pairs of language codes that will be passed to plugin (from_lang, to_lang params)\n\n#BLEU_PLUGINS = \"no_translate2,google_translate,fb_nllb_ctranslate2,openrouter_chat,multi_sources,use_mid_lang\" # plugins to estimate, old version\nBLEU_PLUGINS_AR = [\"google_translate\", \"deepl\", \"multi_sources:google_translate,deepl\"]\n    # plugins to estimate, array", "BLEU_PLUGINS_AR = [\"google_translate\", \"deepl\", \"multi_sources:google_translate,deepl\"]\n    # plugins to estimate, array\n    # now you can run them in format \"plugin:model\", that works only if plugin support \"on-the-fly\" model change (usually YES for synthetic and online plugins, and NO for offline)\n\n#BLEU_PLUGINS_AR = [\"multi_sources:google_translate,deepl,use_mid_lang:deepl->deepl,use_mid_lang:google_translate->deepl,use_mid_lang:google_translate->google_translate,use_mid_lang:deepl->google_translate\"]\n#BLEU_PLUGINS_AR = [\"use_mid_lang:deepl->yandex_dev\"]\n\nBLEU_NUM_PHRASES = 100 # num of phrases to estimate. Between 1 and 100 for now.\nBLEU_START_PHRASE = 150 # offset from FLORES dataset to get NUM phrases\n", "BLEU_START_PHRASE = 150 # offset from FLORES dataset to get NUM phrases\n\nBLEU_METRIC = \"comet\" # bleu | comet\n\ncore:OneRingCore = None\n\ndef load_dataset(lang, split, start, num):\n    import requests\n    req_url = f\"https://datasets-server.huggingface.co/rows?dataset=gsarti%2Fflores_101&config={lang}&split={split}&offset={start}&limit={num}\"\n    #print(req_url)\n    #return \"\"\n    r = requests.get(req_url)\n    if r.status_code != 200:\n        print(f\"Error {r.status_code} during get dataset {req_url}\")\n        quit()\n    j = r.json()\n    #return j[\"rows\"]\n\n    # we have problems with NUM param when getting results from server, so try to fix it\n    rows = j[\"rows\"]\n    if len(rows) > num:\n        rows = rows[:num]\n\n    return rows", "\n\n\n\ndef translate(text:str, from_lang:str = \"\", to_lang:str = \"\", translator_plugin:str = \"\", add_params:str = \"\"):\n\n    res = core.translate(text,from_lang,to_lang,translator_plugin,add_params)\n\n    if res.get(\"error\") is not None:\n        raise ValueError(\"Error in translate: \"+res.get(\"error\"))\n\n    return res.get(\"result\"), res.get(\"cache\")", "\nif __name__ == \"__main__\":\n    from tqdm import trange\n    import tqdm\n    #multiprocessing.freeze_support()\n    core = OneRingCore()\n    core.init_with_plugins()\n\n    pairs_ar = BLEU_PAIRS.split(\",\")\n    pairs_ar2 = BLEU_PAIRS_2LETTERS.split(\",\")\n    #bleu_plugins_ar = BLEU_PLUGINS.split(\",\")\n    bleu_plugins_ar = BLEU_PLUGINS_AR\n\n    # adding model in info on final table\n    bleu_plugins_ar_model = []\n    for plugin_str in bleu_plugins_ar:\n        res = plugin_str\n\n        if \":\" in plugin_str: # \":\" set, so it will be actual model in translation\n            plugin_str, new_model = plugin_str.split(\":\", 1)\n            res = f\"{plugin_str} {new_model}\"\n\n        else: # try to calc model name usual way\n            options = core.plugin_options(\"plugin_\" + plugin_str)\n            if options is not None:\n                model = options.get(\"model\")\n                if model is not None:\n                    res += \" \" + model\n\n        bleu_plugins_ar_model.append(res)\n\n    table_bleu = [([bleu_plugins_ar_model[i]] + ([\"-\"] * len(pairs_ar))) for i in range(len(bleu_plugins_ar))]\n\n\n\n    if BLEU_METRIC == \"comet\":\n        from comet import download_model, load_from_checkpoint\n        print(\"Activating COMET model...\")\n        model_path = download_model(\"Unbabel/wmt22-comet-da\")\n        model = load_from_checkpoint(model_path)\n        print(\"COMET model activated!\")\n\n    for j in range(len(pairs_ar)):\n        pair = pairs_ar[j]\n        pair2 = pairs_ar2[j]\n\n        from_lang, to_lang = pair.split(\"->\")\n        from_lang_let2, to_lang_let2 = pair2.split(\"->\") # we usually needs 2letter lang codes to transfer to plugins\n\n\n        from_lines = load_dataset(from_lang, \"devtest\", BLEU_START_PHRASE, BLEU_NUM_PHRASES)\n        to_lines = load_dataset(to_lang, \"devtest\", BLEU_START_PHRASE, BLEU_NUM_PHRASES)\n\n        for k in range(len(bleu_plugins_ar)):\n            plugin = bleu_plugins_ar[k]\n\n            #print(f\"--------------\\n{plugin} plugin\\n--------------\\n\")\n\n            bleu_sum = 0.0\n            bleu_cnt = 0\n            print(f\"---- Estimating {plugin} for pair {pair}....\")\n            tqdm_bar = trange(len(from_lines))\n\n            data_comet = []\n\n            for i in tqdm_bar: # tqdm range\n                text_need_translate = from_lines[i][\"row\"][\"sentence\"]\n                text_reference = to_lines[i][\"row\"][\"sentence\"]\n                text_candidate, is_from_cache = translate(text_need_translate,from_lang_let2,to_lang_let2, plugin)\n\n                if BLEU_METRIC == \"bleu\":\n                    score = sentence_bleu([text_reference.strip().split()],text_candidate.strip().split(),weights=(0.5, 0.5))\n\n                    bleu_sum += score\n                    bleu_cnt += 1\n\n                    tqdm_bar.set_description(\n                        f\"'{plugin}' on '{pair}' pair average {BLEU_METRIC.upper()} score: {'{:8.2f}'.format(bleu_sum * 100 / bleu_cnt)}\")\n                elif BLEU_METRIC == \"comet\":\n                    data_comet.append(\n                        {\n                            \"src\": text_need_translate,\n                            \"mt\": text_candidate,\n                            \"ref\": text_reference\n                        }\n                    )\n                    #score_pred = model.predict(data, batch_size=8, gpus=0)\n                    #print(score_pred)\n                    tqdm_bar.set_description(\n                        f\"'{plugin}' on '{pair}' pair, {BLEU_METRIC.upper()} score, getting translations...: \")\n                #print(f\"Original: {text_need_translate}\\nTranslation: {text_candidate}\\nReference: {text_reference}\\nScore: {score}\\n\\n\")\n\n\n                # on some web plugin and not from cache result we need delay\n                # (cache results must pass without delay)\n                if plugin == \"openai_chat\" and not is_from_cache:\n                    import time\n                    import random\n                    time.sleep(20 + random.random()*3)\n\n                # if not is_from_cache:\n                #     time.sleep(1 + random.random() * 2)\n\n            if BLEU_METRIC == \"bleu\":\n                bleu_score = bleu_sum / len(from_lines)\n\n            elif BLEU_METRIC == \"comet\":\n                print(\"Calculating COMET model...\")\n                score_pred = model.predict(data_comet, batch_size=8, gpus=0)\n                #print(score_pred)\n\n                bleu_score = score_pred.get(\"system_score\")\n\n            print(f\"****** Average {BLEU_METRIC.upper()} score for '{plugin}' on '{pair.upper()}' pair ({len(to_lines)} samples): {bleu_score}\")\n\n            table_bleu[k][j+1] = \"{:8.2f}\".format(bleu_score*100)\n\n    from tabulate import tabulate\n    res_print_table = tabulate(table_bleu,headers=[\" \"*70]+pairs_ar,tablefmt=\"github\")\n\n    print(\"*\" * 70)\n    print(f\"{BLEU_METRIC.upper()} scores\")\n    print(\"*\" * 70)\n    print(res_print_table)", "\n"]}
{"filename": "jaa.py", "chunked_list": ["\"\"\"\nJaa.py Plugin Framework\nAuthor: Janvarev Vladislav\n\nJaa.py - minimalistic one-file plugin framework with no dependencies.\nMain functions:\n- run all plugins files from \"plugins\" folder, base on filename\n- save each plugin options in \"options\" folder in JSON text files for further editing\n\n- Plugins", "\n- Plugins\nmust located in plugins/ folder\nmust have \"start(core)\" function, that returns manifest dict\nmanifest must contain keys \"name\" and \"version\"\ncan contain \"default_options\"\n- if contain - options will be saved in \"options\" folder and reload instead next time\n- if contain - \"start_with_options(core,manifest)\" function will run with manifest with \"options\" key\nmanifest will be processed in \"process_plugin_manifest\" function if you override it\n", "manifest will be processed in \"process_plugin_manifest\" function if you override it\n\n- Options (for plugins)\nare saved under \"options\" folder in JSON format\ncreated at first run plugin with \"default_options\"\nupdated when plugin change \"version\"\n\n- Example usage:\nclass VoiceAssCore(JaaCore): # class must override JaaCore\n    def __init__(self):", "class VoiceAssCore(JaaCore): # class must override JaaCore\n    def __init__(self):\n        JaaCore.__init__(self,__file__)\n  ...\n\nmain = VoiceAssCore()\nmain.init_plugins([\"core\"]) # 1 param - first plugins to be initialized\n                            # Good if you need some \"core\" options/plugin to be loaded before others\n                            # not necessary starts with \"plugin_\" prefix\n", "                            # not necessary starts with \"plugin_\" prefix\n\nalso can be run like\n\nmain.init_plugins()\n\n- Requirements\nPython 3.5+ (due to dict mix in final_options calc), can be relaxed\n\"\"\"\n", "\"\"\"\n\nimport os\nimport traceback\nimport json\n\n# here we trying to use termcolor to highlight plugin info and errors during load\ntry:\n    from termcolor import cprint\nexcept Exception as e:\n    # not found? making a stub!\n    def cprint(p,color=None):\n        if color == None:\n            print(p)\n        else:\n            print(str(color).upper(),p)", "\nversion = \"1.7.1\"\n\nclass JaaCore:\n    def __init__(self,root_file = __file__):\n        self.jaaPluginPrefix = \"plugin_\"\n        self.jaaVersion = version\n        self.jaaRootFolder = os.path.dirname(root_file)\n        self.jaaOptionsPath = self.jaaRootFolder+os.path.sep+\"options\"\n        self.jaaShowTracebackOnPluginErrors = False\n        cprint(\"JAA.PY v{0} class created!\".format(version),\"blue\")\n\n    # ------------- plugins -----------------\n    def init_plugins(self, list_first_plugins = []):\n        self.plugin_manifests = {}\n\n        # 1. run first plugins first!\n        for modname in list_first_plugins:\n            self.init_plugin(modname)\n\n        # 2. run all plugins from plugins folder\n        from os import listdir\n        from os.path import isfile, join\n        pluginpath = self.jaaRootFolder+\"/plugins\"\n        files = [f for f in listdir(pluginpath) if isfile(join(pluginpath, f))]\n\n        for fil in files:\n            # print fil[:-3]\n            if fil.startswith(self.jaaPluginPrefix) and fil.endswith(\".py\"):\n                modfile = fil[:-3]\n                self.init_plugin(modfile)\n\n\n\n    def init_plugin(self,modname):\n        # import\n        try:\n            mod = self.import_plugin(\"plugins.\"+modname)\n        except Exception as e:\n            self.print_error(\"JAA PLUGIN ERROR: {0} error on load: {1}\".format(modname, str(e)))\n            return False\n\n        # run start function\n        try:\n            res = mod.start(self)\n        except Exception as e:\n            self.print_error(\"JAA PLUGIN ERROR: {0} error on start: {1}\".format(modname, str(e)))\n            return False\n\n        # if plugin has an options\n        if \"default_options\" in res:\n            try:\n                # saved options try to read\n                saved_options = {}\n                try:\n                    with open(self.jaaOptionsPath+'/'+modname+'.json', 'r', encoding=\"utf-8\") as f:\n                        s = f.read()\n                    saved_options = json.loads(s)\n                    #print(\"Saved options\", saved_options)\n                except Exception as e:\n                    pass\n\n                res[\"default_options\"][\"v\"] = res[\"version\"]\n\n\n                # only string needs Python 3.5\n                final_options = {**res[\"default_options\"], **saved_options}\n\n                # if no option found or version is differ from mod version\n                if len(saved_options) == 0 or saved_options[\"v\"] != res[\"version\"]:\n                    final_options[\"v\"] = res[\"version\"]\n                    self.save_plugin_options(modname,final_options)\n\n                res[\"options\"] = final_options\n\n                try:\n                    res2 = mod.start_with_options(self,res)\n                    if res2 != None:\n                        res = res2\n                except Exception as e:\n                    self.print_error(\"JAA PLUGIN ERROR: {0} error on start_with_options processing: {1}\".format(modname, str(e)))\n                    return False\n\n            except Exception as e:\n                self.print_error(\"JAA PLUGIN ERROR: {0} error on options processing: {1}\".format(modname, str(e)))\n                return False\n\n\n        # processing plugin manifest\n        try:\n            # set up name and version\n            plugin_name = res[\"name\"]\n            plugin_version = res[\"version\"]\n\n\n            self.process_plugin_manifest(modname,res)\n\n        except Exception as e:\n            print(\"JAA PLUGIN ERROR: {0} error on process startup options: {1}\".format(modname, str(e)))\n            return False\n\n        self.plugin_manifests[modname] = res\n\n        self.on_succ_plugin_start(modname,plugin_name,plugin_version)\n        return True\n\n    def on_succ_plugin_start(self, modname, plugin_name, plugin_version):\n        cprint(\"JAA PLUGIN: {1} {2} ({0}) started!\".format(modname, plugin_name, plugin_version))\n\n    def print_error(self,p):\n        cprint(p,\"red\")\n        if self.jaaShowTracebackOnPluginErrors:\n            traceback.print_exc()\n\n    def import_plugin(self, module_name):\n        import sys\n\n        __import__(module_name)\n\n        if module_name in sys.modules:\n            return sys.modules[module_name]\n        return None\n\n    def save_plugin_options(self,modname,options):\n        # check folder exists\n        if not os.path.exists(self.jaaOptionsPath):\n            os.makedirs(self.jaaOptionsPath)\n\n        str_options = json.dumps(options, sort_keys=True, indent=4, ensure_ascii=False)\n        with open(self.jaaOptionsPath+'/'+modname+'.json', 'w', encoding=\"utf-8\") as f:\n            f.write(str_options)\n            f.close()\n\n    # process manifest must be overrided in inherit class\n    def process_plugin_manifest(self,modname,manifest):\n        print(\"JAA PLUGIN: {0} manifest dummy procession (override 'process_plugin_manifest' function)\".format(modname))\n        return\n\n    def plugin_manifest(self,pluginname):\n        if pluginname in self.plugin_manifests:\n            return self.plugin_manifests[pluginname]\n        return {}\n\n    def plugin_options(self,pluginname):\n        manifest = self.plugin_manifest(pluginname)\n        if \"options\" in manifest:\n            return manifest[\"options\"]\n        return None", "\ndef load_options(options_file=None,py_file=None,default_options={}):\n    # 1. calculating options filename\n    if options_file == None:\n        if py_file == None:\n            raise Exception('JAA: Options or PY file is not defined, cant calc options filename')\n        else:\n            options_file = py_file[:-3]+'.json'\n\n    # 2. try to read saved options\n    saved_options = {}\n    try:\n        with open(options_file, 'r', encoding=\"utf-8\") as f:\n            s = f.read()\n        saved_options = json.loads(s)\n        #print(\"Saved options\", saved_options)\n    except Exception as e:\n        pass\n\n    # 3. calculating final options\n\n    # only string needs Python 3.5\n    final_options = {**default_options, **saved_options}\n\n    # 4. calculating hash from def options to check - is file rewrite needed?\n    import hashlib\n    hash = hashlib.md5((json.dumps(default_options, sort_keys=True)).encode('utf-8')).hexdigest()\n\n    # 5. if no option file found or hash was from other default options\n    if len(saved_options) == 0 or not (\"hash\" in saved_options.keys()) or saved_options[\"hash\"] != hash:\n        final_options[\"hash\"] = hash\n        #self.save_plugin_options(modname,final_options)\n\n        # saving in file\n        str_options = json.dumps(final_options, sort_keys=True, indent=4, ensure_ascii=False)\n        with open(options_file, 'w', encoding=\"utf-8\") as f:\n            f.write(str_options)\n            f.close()\n\n    return final_options", "\n\"\"\"\nThe MIT License (MIT)\nCopyright (c) 2021 Janvarev Vladislav\n\nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the \u201cSoftware\u201d), to deal \nin the Software without restriction, including without limitation the rights to use, \ncopy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, \nand to permit persons to whom the Software is furnished to do so, subject to the following conditions:", "copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, \nand to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or \nsubstantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, \nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR \nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE \nFOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ", "PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE \nFOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, \nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\"\"\""]}
{"filename": "plugins/plugin_no_translate.py", "chunked_list": ["# No Translate dummy plugin\n# author: Vladislav Janvarev\n\nfrom oneringcore import OneRingCore\nimport os\n\nmodname = os.path.basename(__file__)[:-3] # calculating modname\n\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"No Translate dummy plugin\", # name\n        \"version\": \"1.0\", # version\n\n        \"translate\": {\n            \"no_translate\": (init,translate) # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"No Translate dummy plugin\", # name\n        \"version\": \"1.0\", # version\n\n        \"translate\": {\n            \"no_translate\": (init,translate) # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "\ndef init(core:OneRingCore):\n    pass\n\ndef translate(core:OneRingCore, text:str, from_lang:str = \"\", to_lang:str = \"\", add_params:str = \"\"):\n    return text\n"]}
{"filename": "plugins/plugin_use_mid_lang.py", "chunked_list": ["# Use mid (mediator) language\n# Translate in two phases: from lang->mediator lang, mediator lang->to lang\n# author: Vladislav Janvarev\n\nfrom oneringcore import OneRingCore\nimport os\nimport time\n\nmodname = os.path.basename(__file__)[:-3] # calculating modname\n", "modname = os.path.basename(__file__)[:-3] # calculating modname\n\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"Use mediator language\", # name\n        \"version\": \"1.1\", # version\n\n        \"default_options\": {\n            \"model\": \"google_translate->deepl\",  # 1 phase plugin, 2 phase plugin\n            #  1 phase from lang->mediator lang,\n            #  2 phase mediator lang->to lang\n            \"mid_lang\": \"en\",\n        },\n\n        \"translate\": {\n            \"use_mid_lang\": (init,translate) # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "\ndef start_with_options(core:OneRingCore, manifest:dict):\n    pass\n\ndef init(core:OneRingCore):\n    pass\n\ndef translate(core:OneRingCore, text:str, from_lang:str = \"\", to_lang:str = \"\", add_params:str = \"\"):\n    plugins: str = core.plugin_options(modname).get(\"model\").split(\"->\")\n    mid_lang: str = core.plugin_options(modname).get(\"mid_lang\")\n    res1 = core.translate(text,from_lang,mid_lang,plugins[0]).get(\"result\")\n    #print(from_lang,mid_lang,res1)\n    #time.sleep(0.02)\n    res2 = core.translate(res1,mid_lang,to_lang,plugins[1]).get(\"result\")\n    #print(mid_lang,to_lang,res2)\n\n    return res2", ""]}
{"filename": "plugins/plugin_google_translate.py", "chunked_list": ["# Google Translate plugin\n# author: Vladislav Janvarev\n\nfrom oneringcore import OneRingCore\nimport os\n\nmodname = os.path.basename(__file__)[:-3] # calculating modname\n\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"Google Translate\", # name\n        \"version\": \"1.0\", # version\n\n        \"translate\": {\n            \"google_translate\": (init,translate) # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"Google Translate\", # name\n        \"version\": \"1.0\", # version\n\n        \"translate\": {\n            \"google_translate\": (init,translate) # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "\ndef init(core:OneRingCore):\n    pass\n\ndef translate(core:OneRingCore, text:str, from_lang:str = \"\", to_lang:str = \"\", add_params:str = \"\"):\n    # \u043f\u0440\u043e\u0441\u0442\u043e \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u0442\u0435\u043a\u0441\u0442 \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u044c\n    from deep_translator import GoogleTranslator\n    res = GoogleTranslator(source=from_lang, target=to_lang).translate(text)\n    return res\n", ""]}
{"filename": "plugins/plugin_deepl.py", "chunked_list": ["# Deepl Translate plugin\n# author: Vladislav Janvarev\n\nfrom oneringcore import OneRingCore\nimport os\n\nmodname = os.path.basename(__file__)[:-3] # calculating modname\n\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"Deepl Translator\", # name\n        \"version\": \"1.1\", # version\n\n        \"default_options\": {\n            \"api_key\": \"\",  #\n            \"is_free_api\": True, # use Free version or not\n        },\n\n        \"translate\": {\n\n            \"deepl\": (init, translate),  # 1 function - init, 2 - translate\n            # deprecated\n            \"deepl_translate\": (init, translate)  # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"Deepl Translator\", # name\n        \"version\": \"1.1\", # version\n\n        \"default_options\": {\n            \"api_key\": \"\",  #\n            \"is_free_api\": True, # use Free version or not\n        },\n\n        \"translate\": {\n\n            \"deepl\": (init, translate),  # 1 function - init, 2 - translate\n            # deprecated\n            \"deepl_translate\": (init, translate)  # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "\ndef start_with_options(core:OneRingCore, manifest:dict):\n    pass\ndef init(core:OneRingCore):\n    pass\n\ndef translate(core:OneRingCore, text:str, from_lang:str = \"\", to_lang:str = \"\", add_params:str = \"\"):\n    from deep_translator import DeeplTranslator\n    #custom_url = core.plugin_options(modname).get(\"custom_url\")\n    is_free:bool = core.plugin_options(modname).get(\"is_free_api\")\n    api_key:str = core.plugin_options(modname).get(\"api_key\")\n    #print(custom_url)\n    #res = LibreTranslator(source=from_lang, target=to_lang, custom_url=custom_url).translate(text)\n    res = DeeplTranslator(api_key, use_free_api=is_free, source=from_lang, target=to_lang).translate(text)\n\n\n    return res", ""]}
{"filename": "plugins/plugin_no_translate2.py", "chunked_list": ["# No Translate dummy plugin - return blank\n# author: Vladislav Janvarev\n\nfrom oneringcore import OneRingCore\nimport os\n\nmodname = os.path.basename(__file__)[:-3] # calculating modname\n\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"No Translate2 dummy plugin\", # name\n        \"version\": \"1.0\", # version\n\n        \"translate\": {\n            \"no_translate2\": (init,translate) # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"No Translate2 dummy plugin\", # name\n        \"version\": \"1.0\", # version\n\n        \"translate\": {\n            \"no_translate2\": (init,translate) # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "\ndef init(core:OneRingCore):\n    pass\n\ndef translate(core:OneRingCore, text:str, from_lang:str = \"\", to_lang:str = \"\", add_params:str = \"\"):\n    return \"\"\n"]}
{"filename": "plugins/plugin_lingvanex.py", "chunked_list": ["# lingvanex Translate plugin\n# author: Vladislav Janvarev\n\nfrom oneringcore import OneRingCore\nimport os\n\nmodname = os.path.basename(__file__)[:-3] # calculating modname\n\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"lingvanex Translator\", # name\n        \"version\": \"1.1\", # version\n\n        \"default_options\": {\n            \"api_key\": \"\",  #\n        },\n\n        \"translate\": {\n            \"lingvanex\": (init, translate)  # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"lingvanex Translator\", # name\n        \"version\": \"1.1\", # version\n\n        \"default_options\": {\n            \"api_key\": \"\",  #\n        },\n\n        \"translate\": {\n            \"lingvanex\": (init, translate)  # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "\ndef start_with_options(core:OneRingCore, manifest:dict):\n    pass\ndef init(core:OneRingCore):\n    pass\n\ndef translate(core:OneRingCore, text:str, from_lang:str = \"\", to_lang:str = \"\", add_params:str = \"\"):\n\n    api_key:str = core.plugin_options(modname).get(\"api_key\")\n\n    import requests\n\n    url = \"https://api-b2b.backenster.com/b1/api/v3/translate\"\n\n    payload = {\n        \"platform\": \"api\",\n        \"from\": from_lang,\n        \"to\": to_lang,\n        \"data\": text\n    }\n    headers = {\n        \"accept\": \"application/json\",\n        \"content-type\": \"application/json\",\n        \"Authorization\": api_key\n    }\n\n    response = requests.post(url, json=payload, headers=headers)\n\n    #print(respons*e.text)\n    response_json = response.json()\n\n    if response_json.get(\"err\") is not None:\n        raise ValueError(\"ERR in ligvanex server call: \"+response_json.get(\"err\"))\n    #print(response_json)\n\n\n    return response_json[\"result\"]", ""]}
{"filename": "plugins/plugin_opus_mt.py", "chunked_list": ["# opus mt\n# author: Vladislav Janvarev\n\n# from https://huggingface.co/Helsinki-NLP/opus-mt-tc-big-hu-en\n\nfrom oneringcore import OneRingCore\nimport os\n\nmodname = os.path.basename(__file__)[:-3] # calculating modname\n", "modname = os.path.basename(__file__)[:-3] # calculating modname\n\nmodel = None\ntokenizer = None\n\ncuda_opt = -1\nto_device = \"cpu\"\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"Opus MT Translate\", # name\n        \"version\": \"1.0\", # version\n\n        \"translate\": {\n            \"opus_mt\": (init,translate) # 1 function - init, 2 - translate\n        },\n\n        \"default_options\": {\n            \"model\": \"Helsinki-NLP/opus-mt-en-ru\",  # key model\n            \"cuda\": -1, # -1 if you want run on CPU, 0 - if on CUDA\n            \"text_prefix\": \"\" # for models like https://huggingface.co/Helsinki-NLP/opus-mt-tc-big-he-itc\n            # be like >>hbs<< etc.\n        },\n    }\n    return manifest", "def start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"Opus MT Translate\", # name\n        \"version\": \"1.0\", # version\n\n        \"translate\": {\n            \"opus_mt\": (init,translate) # 1 function - init, 2 - translate\n        },\n\n        \"default_options\": {\n            \"model\": \"Helsinki-NLP/opus-mt-en-ru\",  # key model\n            \"cuda\": -1, # -1 if you want run on CPU, 0 - if on CUDA\n            \"text_prefix\": \"\" # for models like https://huggingface.co/Helsinki-NLP/opus-mt-tc-big-he-itc\n            # be like >>hbs<< etc.\n        },\n    }\n    return manifest", "\ndef start_with_options(core:OneRingCore, manifest:dict):\n    global cuda_opt\n    global to_device\n    cuda_opt = manifest[\"options\"].get(\"cuda\")\n    if cuda_opt == -1:\n        to_device = \"cpu\"\n    else:\n        to_device = \"cuda:{0}\".format(cuda_opt)\n    pass", "\ndef init(core:OneRingCore):\n    from transformers import MarianMTModel, MarianTokenizer\n\n    global model, tokenizer\n\n    #print(to_device)\n    model_name = core.plugin_options(modname).get(\"model\")\n    tokenizer = MarianTokenizer.from_pretrained(model_name)\n    model = MarianMTModel.from_pretrained(model_name).to(to_device)", "\n\ndef translate(core:OneRingCore, text:str, from_lang:str = \"\", to_lang:str = \"\", add_params:str = \"\"):\n    src_text = [core.plugin_options(modname).get(\"text_prefix\")+text]\n    translated = model.generate(**tokenizer(src_text, return_tensors=\"pt\", padding=True).to(to_device))\n    res = tokenizer.decode(translated[0], skip_special_tokens=True)\n    return res"]}
{"filename": "plugins/core.py", "chunked_list": ["# Core plugin\n# author: Vladislav Janvarev\n\nfrom oneringcore import OneRingCore\n\n# start function\ndef start(core:OneRingCore):\n    manifest = {\n        \"name\": \"Core plugin\",\n        \"version\": \"1.5\",\n\n        # this is DEFAULT options\n        # ACTUAL options is in options/<plugin_name>.json after first run\n        \"default_options\": {\n            \"default_translate_plugin\": \"google_translate\", # default translation engine. Will be auto inited on start\n            \"init_on_start\": \"\",  # additional list of engines, that must be init on start, separated by \",\"\n            \"default_from_lang\": \"es\", # default from language\n            \"default_to_lang\": \"en\", # default to language\n            \"api_keys_allowed\": [], # set of API keys. If empty - no API key required.\n            \"debug_input_output\": False, # allow debug print input and output in console\n            \"allow_multithread\": True, # allow multithread run of translation engine\n            \"user_lang\": \"\", # standart user language. Replaces \"user\" in to_lang or from_lang API params\n            \"cache_is_use\": True, # use cache?\n            \"cache_save_every\": 5,  # every X elements save cache to disk\n            \"cache_per_model\": True, # differentiate cache per model\n            \"default_translate_router\": { # routing for default translation engine on different language pairs\n                \"fr->es\": \"no_translate\", # this is just an example, adjust in to your needs\n                \"fr->fn\": \"no_translate2\", # asterisk supported like *->fr\n            }\n        },\n\n    }\n    return manifest", "\ndef start_with_options(core:OneRingCore, manifest:dict):\n    #print(manifest[\"options\"])\n    options = manifest[\"options\"]\n\n    core.default_translator = options[\"default_translate_plugin\"]\n    core.default_from_lang = options[\"default_from_lang\"]\n    core.default_to_lang = options[\"default_to_lang\"]\n    core.default_translate_router = options[\"default_translate_router\"]\n\n    core.api_keys_allowed = options[\"api_keys_allowed\"]\n\n    core.is_multithread = options[\"allow_multithread\"]\n    core.is_debug_input_output = options[\"debug_input_output\"]\n\n    core.user_lang = options[\"user_lang\"]\n\n    core.cache_is_use = options[\"cache_is_use\"]\n    core.cache_save_every = options[\"cache_save_every\"]\n    core.cache_per_model = options[\"cache_per_model\"]\n\n    core.init_on_start = options[\"init_on_start\"]\n\n    return manifest", ""]}
{"filename": "plugins/plugin_openai_chat.py", "chunked_list": ["# Translation throw ChatGPT\n# author: Vladislav Janvarev\n\nimport os\nimport openai\n\nfrom oneringcore import OneRingCore\n\nimport json\nimport os", "import json\nimport os\nimport openai\n\n# ---------- from https://github.com/stancsz/chatgpt ----------\nclass ChatApp:\n    def __init__(self, model=\"gpt-3.5-turbo\", load_file='', system=''):\n        # Setting the API key to use the OpenAI API\n        self.model = model\n        self.messages = []\n        if system != '':\n            self.messages.append({\"role\": \"system\", \"content\" : system})\n        if load_file != '':\n            self.load(load_file)\n\n    def chat(self, message):\n        if message == \"exit\":\n            self.save()\n            os._exit(1)\n        elif message == \"save\":\n            self.save()\n            return \"(saved)\"\n        self.messages.append({\"role\": \"user\", \"content\": message})\n        print(self.messages)\n        response = openai.ChatCompletion.create(\n            model=self.model,\n            messages=self.messages,\n            temperature=0.7,\n            n=1,\n            max_tokens=int(len(message)*1.5),\n            #headers=\n        )\n        self.messages.append({\"role\": \"assistant\", \"content\": response[\"choices\"][0][\"message\"].content})\n        return response[\"choices\"][0][\"message\"]\n    def save(self):\n        try:\n            import time\n            import re\n            import json\n            ts = time.time()\n            json_object = json.dumps(self.messages, indent=4)\n            filename_prefix=self.messages[0]['content'][0:30]\n            filename_prefix = re.sub('[^0-9a-zA-Z]+', '-', f\"{filename_prefix}_{ts}\")\n            with open(f\"models/chat_model_{filename_prefix}.json\", \"w\") as outfile:\n                outfile.write(json_object)\n        except:\n            os._exit(1)\n\n    def load(self, load_file):\n        with open(load_file) as f:\n            data = json.load(f)\n            self.messages = data", "\nmodname = os.path.basename(__file__)[:-3] # calculating modname\n\n# \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043d\u0430 \u0441\u0442\u0430\u0440\u0442\u0435\ndef start(core:OneRingCore):\n    manifest = {\n        \"name\": \"Translation through ChatGPT\",\n        \"version\": \"3.1\",\n        \"description\": \"After define apiKey allow to translate through ChatGPT.\",\n\n        \"options_label\": {\n            \"apiKey\": \"API-key OpenAI\", #\n            \"apiBaseUrl\": \"URL for OpenAI (allow OpenAI emulation servers)\",  #\n            \"system\": \"System input string.\"\n        },\n\n        \"default_options\": {\n            \"apiKey\": \"\", #\n            \"apiBaseUrl\": \"\",  #\n            \"system\": \"You are a professional translator.\",\n            \"prompt\": \"Instruction: Translate this text from {0} to {1}:\\n\\n{2}\",\n            \"model\": \"gpt-3.5-turbo\",\n        },\n\n        \"translate\": {\n            \"openai_chat\": (init, translate)  # 1 function - init, 2 - translate\n        }\n\n    }\n    return manifest", "\ndef start_with_options(core:OneRingCore, manifest:dict):\n    pass\n\ndef init(core:OneRingCore):\n    options = core.plugin_options(modname)\n\n    if options[\"apiKey\"] == \"\" and options[\"apiBaseUrl\"] == \"\":\n        raise ValueError(\"Needed API KEY for access\")\n\n    openai.api_key = options[\"apiKey\"]\n    if options[\"apiBaseUrl\"] != \"\":\n        openai.api_base = options[\"apiBaseUrl\"]", "\n\ndef translate(core:OneRingCore, text:str, from_lang:str = \"\", to_lang:str = \"\", add_params:str = \"\"):\n\n    options = core.plugin_options(modname)\n\n    from_full_lang = core.dict_2let_to_lang.get(from_lang)\n    to_full_lang = core.dict_2let_to_lang.get(to_lang)\n\n    #prompt = f\"Instruction: Translate this text from {from_full_lang} to {to_full_lang}:\\n\\n{text}\"\n    prompt = str(options[\"prompt\"]).format(from_full_lang,to_full_lang,text)\n    system_text = str(options[\"system\"]).format(from_full_lang,to_full_lang,text)\n\n    core.chatapp = ChatApp(model=str(options[\"model\"]),system=system_text) # create new chat\n\n    response = core.chatapp.chat(prompt)  # generate_response(phrase)\n    #print(response)\n    return response[\"content\"]", "\n"]}
{"filename": "plugins/plugin_koboldapi_translate.py", "chunked_list": ["# Translate plugin throw KoboldAPI interface\n# KoboldAPI is a REST interface for lots of LLM servers (like koboldcpp, text-generation-webui)\n# author: Vladislav Janvarev\n\nfrom oneringcore import OneRingCore\nimport os\n\nmodname = os.path.basename(__file__)[:-3] # calculating modname\n\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"KoboldAPI Translator\", # name\n        \"version\": \"2.0\", # version\n\n        \"default_options\": {\n            \"custom_url\": \"http://localhost:5000/\",  #\n            \"prompt\": \"Below is an instruction that describes a task. Write a response that appropriately completes the request.\\n### Instruction:\\nTranslate this text from {0} to {1}:\\n\\n{2}\\n\\n\\n### Response:\"\n        },\n\n        \"translate\": {\n            \"koboldapi_translate\": (init,translate) # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"KoboldAPI Translator\", # name\n        \"version\": \"2.0\", # version\n\n        \"default_options\": {\n            \"custom_url\": \"http://localhost:5000/\",  #\n            \"prompt\": \"Below is an instruction that describes a task. Write a response that appropriately completes the request.\\n### Instruction:\\nTranslate this text from {0} to {1}:\\n\\n{2}\\n\\n\\n### Response:\"\n        },\n\n        \"translate\": {\n            \"koboldapi_translate\": (init,translate) # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "\ndef start_with_options(core:OneRingCore, manifest:dict):\n    pass\ndef init(core:OneRingCore):\n    pass\n\ndef translate(core:OneRingCore, text:str, from_lang:str = \"\", to_lang:str = \"\", add_params:str = \"\"):\n    options = core.plugin_options(modname)\n\n    import json\n    custom_stopping_strings = [\"\\n\\n\",\"\\n### \"]\n    params = {\n        'max_new_tokens': int(len(text)*1.5),\n        'max_length': int(len(text)*1.5),\n        'do_sample': True,\n        'temperature': 0.7,\n        'top_p': 0.2,\n        'typical_p': 1,\n        'repetition_penalty': 1.18,\n        'encoder_repetition_penalty': 1.0,\n        'top_k': 40,\n        'min_length': 0,\n        'no_repeat_ngram_size': 0,\n        'num_beams': 1,\n        'penalty_alpha': 0,\n        'length_penalty': 1,\n        'early_stopping': True,\n        'seed': -1,\n        'add_bos_token': True,\n        'custom_stopping_strings': custom_stopping_strings,\n        'stop_sequence': custom_stopping_strings,\n        'truncation_length': 2048,\n        'ban_eos_token': False,\n    }\n\n    from_full_lang = core.dict_2let_to_lang.get(from_lang)\n    to_full_lang = core.dict_2let_to_lang.get(to_lang)\n\n\n    from time import time\n    start = time()\n    # # Input prompt for Alpaca\n    # tpl = \"Below is an instruction that describes a task. Write a response that appropriately completes the request.\\n\"\n    # tpl += f\"### Instruction:\\nTranslate this text from {from_full_lang} to {to_full_lang}:\\n\\n\"\n    # #tpl += \"### Input:\\n{0}\\n\\n\\n\\n\"\n    # tpl += \"{0}\\n\\n\\n\"\n    # tpl += \"### Response:\"\n\n    prompt = str(options[\"prompt\"]).format(from_full_lang,to_full_lang,text)\n    print(prompt)\n\n    params[\"prompt\"] = prompt\n    #print(params)\n\n    import requests\n    url = f\"{core.plugin_options(modname).get('custom_url')}api/v1/generate\"\n    #print(url)\n    response = requests.post(url, json=params)\n\n    if response.status_code != 200:\n        return \"ERROR in call KoboldAPI url: status code {0}\".format(response.status_code)\n\n    #print(response)\n\n    reply:str = response.json()[\"results\"][0]['text']\n    reply = reply.strip()\n\n    end = time()\n    #print(\"Duration: {0}\".format(end - start))\n\n    for stop_string in custom_stopping_strings:\n        if stop_string in reply:\n            res = reply.split(stop_string)\n            reply = res[0]\n\n    #print(reply)\n\n    return reply"]}
{"filename": "plugins/plugin_libre_translate.py", "chunked_list": ["# Libre Translate plugin\n# author: Vladislav Janvarev\n\nfrom oneringcore import OneRingCore\nimport os\n\nmodname = os.path.basename(__file__)[:-3] # calculating modname\n\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"Libre Translator\", # name\n        \"version\": \"1.0\", # version\n\n        \"default_options\": {\n            \"custom_url\": \"https://translate.argosopentech.com/\",  # mirror for LibreTranslator service\n        },\n\n        \"translate\": {\n            \"libre_translate\": (init,translate) # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"Libre Translator\", # name\n        \"version\": \"1.0\", # version\n\n        \"default_options\": {\n            \"custom_url\": \"https://translate.argosopentech.com/\",  # mirror for LibreTranslator service\n        },\n\n        \"translate\": {\n            \"libre_translate\": (init,translate) # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "\ndef start_with_options(core:OneRingCore, manifest:dict):\n    pass\ndef init(core:OneRingCore):\n    pass\n\ndef translate(core:OneRingCore, text:str, from_lang:str = \"\", to_lang:str = \"\", add_params:str = \"\"):\n    from deep_translator import LibreTranslator\n    custom_url = core.plugin_options(modname).get(\"custom_url\")\n    #print(custom_url)\n    res = LibreTranslator(source=from_lang, target=to_lang, custom_url=custom_url).translate(text)\n    return res", ""]}
{"filename": "plugins/plugin_fb_nllb_ctranslate2.py", "chunked_list": ["# nllb plugin with https://opennmt.net/CTranslate2/index.html support\n# author: Vladislav Janvarev\n\n# from https://github.com/facebookresearch/fairseq/tree/nllb\n\nfrom oneringcore import OneRingCore\nimport os\n\nmodname = os.path.basename(__file__)[:-3] # calculating modname\n", "modname = os.path.basename(__file__)[:-3] # calculating modname\n\nmodel = None\ntokenizers:dict = {}\n\n# -------- lang list\n\nlanglist_str = \"\"\"\nace_Arab    | Acehnese (Arabic script)\nace_Latn    | Acehnese (Latin script)", "ace_Arab    | Acehnese (Arabic script)\nace_Latn    | Acehnese (Latin script)\nacm_Arab    | Mesopotamian Arabic\nacq_Arab    | Ta\u2019izzi-Adeni Arabic\naeb_Arab    | Tunisian Arabic\nafr_Latn    | Afrikaans\najp_Arab    | South Levantine Arabic\naka_Latn    | Akan\nals_Latn    | Tosk Albanian\namh_Ethi    | Amharic", "als_Latn    | Tosk Albanian\namh_Ethi    | Amharic\napc_Arab    | North Levantine Arabic\narb_Arab    | Modern Standard Arabic\narb_Latn    | Modern Standard Arabic (Romanized)\nars_Arab    | Najdi Arabic\nary_Arab    | Moroccan Arabic\narz_Arab    | Egyptian Arabic\nasm_Beng    | Assamese\nast_Latn    | Asturian", "asm_Beng    | Assamese\nast_Latn    | Asturian\nawa_Deva    | Awadhi\nayr_Latn    | Central Aymara\nazb_Arab    | South Azerbaijani\nazj_Latn    | North Azerbaijani\nbak_Cyrl    | Bashkir\nbam_Latn    | Bambara\nban_Latn    | Balinese\nbel_Cyrl    | Belarusian", "ban_Latn    | Balinese\nbel_Cyrl    | Belarusian\nbem_Latn    | Bemba\nben_Beng    | Bengali\nbho_Deva    | Bhojpuri\nbjn_Arab    | Banjar (Arabic script)\nbjn_Latn    | Banjar (Latin script)\nbod_Tibt    | Standard Tibetan\nbos_Latn    | Bosnian\nbug_Latn    | Buginese", "bos_Latn    | Bosnian\nbug_Latn    | Buginese\nbul_Cyrl    | Bulgarian\ncat_Latn    | Catalan\nceb_Latn    | Cebuano\nces_Latn    | Czech\ncjk_Latn    | Chokwe\nckb_Arab    | Central Kurdish\ncrh_Latn    | Crimean Tatar\ncym_Latn    | Welsh", "crh_Latn    | Crimean Tatar\ncym_Latn    | Welsh\ndan_Latn    | Danish\ndeu_Latn    | German\ndik_Latn    | Southwestern Dinka\ndyu_Latn    | Dyula\ndzo_Tibt    | Dzongkha\nell_Grek    | Greek\neng_Latn    | English\nepo_Latn    | Esperanto", "eng_Latn    | English\nepo_Latn    | Esperanto\nest_Latn    | Estonian\neus_Latn    | Basque\newe_Latn    | Ewe\nfao_Latn    | Faroese\nfij_Latn    | Fijian\nfin_Latn    | Finnish\nfon_Latn    | Fon\nfra_Latn    | French", "fon_Latn    | Fon\nfra_Latn    | French\nfur_Latn    | Friulian\nfuv_Latn    | Nigerian Fulfulde\ngaz_Latn    | West Central Oromo\ngla_Latn    | Scottish Gaelic\ngle_Latn    | Irish\nglg_Latn    | Galician\ngrn_Latn    | Guarani\nguj_Gujr    | Gujarati", "grn_Latn    | Guarani\nguj_Gujr    | Gujarati\nhat_Latn    | Haitian Creole\nhau_Latn    | Hausa\nheb_Hebr    | Hebrew\nhin_Deva    | Hindi\nhne_Deva    | Chhattisgarhi\nhrv_Latn    | Croatian\nhun_Latn    | Hungarian\nhye_Armn    | Armenian", "hun_Latn    | Hungarian\nhye_Armn    | Armenian\nibo_Latn    | Igbo\nilo_Latn    | Ilocano\nind_Latn    | Indonesian\nisl_Latn    | Icelandic\nita_Latn    | Italian\njav_Latn    | Javanese\njpn_Jpan    | Japanese\nkab_Latn    | Kabyle", "jpn_Jpan    | Japanese\nkab_Latn    | Kabyle\nkac_Latn    | Jingpho\nkam_Latn    | Kamba\nkan_Knda    | Kannada\nkas_Arab    | Kashmiri (Arabic script)\nkas_Deva    | Kashmiri (Devanagari script)\nkat_Geor    | Georgian\nkaz_Cyrl    | Kazakh\nkbp_Latn    | Kabiy\u00e8", "kaz_Cyrl    | Kazakh\nkbp_Latn    | Kabiy\u00e8\nkea_Latn    | Kabuverdianu\nkhk_Cyrl    | Halh Mongolian\nkhm_Khmr    | Khmer\nkik_Latn    | Kikuyu\nkin_Latn    | Kinyarwanda\nkir_Cyrl    | Kyrgyz\nkmb_Latn    | Kimbundu\nkmr_Latn    | Northern Kurdish", "kmb_Latn    | Kimbundu\nkmr_Latn    | Northern Kurdish\nknc_Arab    | Central Kanuri (Arabic script)\nknc_Latn    | Central Kanuri (Latin script)\nkon_Latn    | Kikongo\nkor_Hang    | Korean\nlao_Laoo    | Lao\nlij_Latn    | Ligurian\nlim_Latn    | Limburgish\nlin_Latn    | Lingala", "lim_Latn    | Limburgish\nlin_Latn    | Lingala\nlit_Latn    | Lithuanian\nlmo_Latn    | Lombard\nltg_Latn    | Latgalian\nltz_Latn    | Luxembourgish\nlua_Latn    | Luba-Kasai\nlug_Latn    | Ganda\nluo_Latn    | Luo\nlus_Latn    | Mizo", "luo_Latn    | Luo\nlus_Latn    | Mizo\nlvs_Latn    | Standard Latvian\nmag_Deva    | Magahi\nmai_Deva    | Maithili\nmal_Mlym    | Malayalam\nmar_Deva    | Marathi\nmin_Arab    | Minangkabau (Arabic script)\nmin_Latn    | Minangkabau (Latin script)\nmkd_Cyrl    | Macedonian", "min_Latn    | Minangkabau (Latin script)\nmkd_Cyrl    | Macedonian\nmlt_Latn    | Maltese\nmni_Beng    | Meitei (Bengali script)\nmos_Latn    | Mossi\nmri_Latn    | Maori\nmya_Mymr    | Burmese\nnld_Latn    | Dutch\nnno_Latn    | Norwegian Nynorsk\nnob_Latn    | Norwegian Bokm\u00e5l", "nno_Latn    | Norwegian Nynorsk\nnob_Latn    | Norwegian Bokm\u00e5l\nnpi_Deva    | Nepali\nnso_Latn    | Northern Sotho\nnus_Latn    | Nuer\nnya_Latn    | Nyanja\noci_Latn    | Occitan\nory_Orya    | Odia\npag_Latn    | Pangasinan\npan_Guru    | Eastern Panjabi", "pag_Latn    | Pangasinan\npan_Guru    | Eastern Panjabi\npap_Latn    | Papiamento\npbt_Arab    | Southern Pashto\npes_Arab    | Western Persian\nplt_Latn    | Plateau Malagasy\npol_Latn    | Polish\npor_Latn    | Portuguese\nprs_Arab    | Dari\nquy_Latn    | Ayacucho Quechua", "prs_Arab    | Dari\nquy_Latn    | Ayacucho Quechua\nron_Latn    | Romanian\nrun_Latn    | Rundi\nrus_Cyrl    | Russian\nsag_Latn    | Sango\nsan_Deva    | Sanskrit\nsat_Olck    | Santali\nscn_Latn    | Sicilian\nshn_Mymr    | Shan", "scn_Latn    | Sicilian\nshn_Mymr    | Shan\nsin_Sinh    | Sinhala\nslk_Latn    | Slovak\nslv_Latn    | Slovenian\nsmo_Latn    | Samoan\nsna_Latn    | Shona\nsnd_Arab    | Sindhi\nsom_Latn    | Somali\nsot_Latn    | Southern Sotho", "som_Latn    | Somali\nsot_Latn    | Southern Sotho\nspa_Latn    | Spanish\nsrd_Latn    | Sardinian\nsrp_Cyrl    | Serbian\nssw_Latn    | Swati\nsun_Latn    | Sundanese\nswe_Latn    | Swedish\nswh_Latn    | Swahili\nszl_Latn    | Silesian", "swh_Latn    | Swahili\nszl_Latn    | Silesian\ntam_Taml    | Tamil\ntaq_Latn    | Tamasheq (Latin script)\ntaq_Tfng    | Tamasheq (Tifinagh script)\ntat_Cyrl    | Tatar\ntel_Telu    | Telugu\ntgk_Cyrl    | Tajik\ntgl_Latn    | Tagalog\ntha_Thai    | Thai", "tgl_Latn    | Tagalog\ntha_Thai    | Thai\ntir_Ethi    | Tigrinya\ntpi_Latn    | Tok Pisin\ntsn_Latn    | Tswana\ntso_Latn    | Tsonga\ntuk_Latn    | Turkmen\ntum_Latn    | Tumbuka\ntur_Latn    | Turkish\ntwi_Latn    | Twi", "tur_Latn    | Turkish\ntwi_Latn    | Twi\ntzm_Tfng    | Central Atlas Tamazight\nuig_Arab    | Uyghur\nukr_Cyrl    | Ukrainian\numb_Latn    | Umbundu\nurd_Arab    | Urdu\nuzn_Latn    | Northern Uzbek\nvec_Latn    | Venetian\nvie_Latn    | Vietnamese", "vec_Latn    | Venetian\nvie_Latn    | Vietnamese\nwar_Latn    | Waray\nwol_Latn    | Wolof\nxho_Latn    | Xhosa\nydd_Hebr    | Eastern Yiddish\nyor_Latn    | Yoruba\nyue_Hant    | Yue Chinese\nzho_Hans    | Chinese (Simplified)\nzho_Hant    | Chinese (Traditional)", "zho_Hans    | Chinese (Simplified)\nzho_Hant    | Chinese (Traditional)\nzsm_Latn    | Standard Malay\nzul_Latn    | Zulu\n\"\"\"\n\nl = langlist_str.split(\"\\n\")\nlanglist = []\nfor k in l:\n    if k != \"\":\n        langlist.append(k[0:8])", "for k in l:\n    if k != \"\":\n        langlist.append(k[0:8])\n\n#print(langlist)\n\n\ncuda_opt = -1\nto_device = \"cpu\"\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"NLLB Translate with CTranslate2\", # name\n        \"version\": \"2.0\", # version\n\n        \"translate\": {\n            \"fb_nllb_ctranslate2\": (init,translate) # 1 function - init, 2 - translate\n        },\n\n        \"default_options\": {\n            \"model\": \"facebook/nllb-200-distilled-600M\",  # key model\n            \"cuda\": -1, # -1 if you want run on CPU, 0 - if on CUDA\n        },\n    }\n    return manifest", "to_device = \"cpu\"\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"NLLB Translate with CTranslate2\", # name\n        \"version\": \"2.0\", # version\n\n        \"translate\": {\n            \"fb_nllb_ctranslate2\": (init,translate) # 1 function - init, 2 - translate\n        },\n\n        \"default_options\": {\n            \"model\": \"facebook/nllb-200-distilled-600M\",  # key model\n            \"cuda\": -1, # -1 if you want run on CPU, 0 - if on CUDA\n        },\n    }\n    return manifest", "\ndef start_with_options(core:OneRingCore, manifest:dict):\n    global cuda_opt\n    global to_device\n    cuda_opt = manifest[\"options\"].get(\"cuda\")\n    if cuda_opt == -1:\n        to_device = \"cpu\"\n    else:\n        #to_device = \"cuda:{0}\".format(cuda_opt)\n        to_device = \"cuda\".format(cuda_opt)\n    pass", "\ndef init(core:OneRingCore):\n    from transformers import AutoModelForSeq2SeqLM, AutoTokenizer\n    import ctranslate2\n    global model\n\n    #print(to_device)\n    #model = AutoModelForSeq2SeqLM.from_pretrained(core.plugin_options(modname).get(\"model\")).to(to_device)\n    model = ctranslate2.Translator(core.plugin_options(modname).get(\"model\"), device=to_device)\n\n    pass", "\ndef convert_lang(input_lang:str) -> str:\n    if len(input_lang) == 2 or len(input_lang) == 3:\n        if input_lang == \"en\" or input_lang == \"eng\":\n            return \"eng_Latn\"\n        if input_lang == \"ru\":\n            return \"rus_Cyrl\"\n\n        for lang in langlist:\n            if lang.startswith(input_lang):\n                return lang\n\n    else:\n        return input_lang", "\ndef translate(core:OneRingCore, text:str, from_lang:str = \"\", to_lang:str = \"\", add_params:str = \"\"):\n    from transformers import AutoModelForSeq2SeqLM, AutoTokenizer\n\n    from_lang_tr = convert_lang(from_lang)\n    to_lang_tr = convert_lang(to_lang)\n    if tokenizers.get(from_lang_tr) is None:\n        tokenizers[from_lang_tr] = AutoTokenizer.from_pretrained(core.plugin_options(modname).get(\"model\"), src_lang=from_lang_tr)\n    # if tokenizers.get(to_lang_tr) is None:\n    #     tokenizers[to_lang_tr] = AutoTokenizer.from_pretrained(core.plugin_options(modname).get(\"model\"), src_lang=to_lang_tr)\n\n    tokenizer_from = tokenizers.get(from_lang_tr)\n    #source = tokenizer_from(text, return_tensors=\"pt\").to(to_device)\n    source = tokenizer_from.convert_ids_to_tokens(tokenizer_from.encode(text))\n\n    #source = tokenizer.convert_ids_to_tokens(tokenizer.encode(\"Hello world!\"))\n    target_prefix = [to_lang_tr]\n    results = model.translate_batch([source], target_prefix=[target_prefix])\n    translated_tokens = results[0].hypotheses[0][1:]\n\n    #res = tokenizer_from.batch_decode(translated_tokens, skip_special_tokens=True)[0]\n    res = tokenizer_from.decode(tokenizer_from.convert_tokens_to_ids(translated_tokens))\n\n\n\n    return res", "\n"]}
{"filename": "plugins/plugin_fb_mbart50.py", "chunked_list": ["# mbart plugin\n# author: Vladislav Janvarev\n\n# from https://huggingface.co/facebook/mbart-large-50-one-to-many-mmt\n\nfrom oneringcore import OneRingCore\nimport os\n\nmodname = os.path.basename(__file__)[:-3] # calculating modname\n", "modname = os.path.basename(__file__)[:-3] # calculating modname\n\nmodel = None\ntokenizers:dict = {}\n\n# -------- lang list\n\n#langlist_str = \"ar_AR,cs_CZ,de_DE,en_XX,es_XX,et_EE,fi_FI,fr_XX,gu_IN,hi_IN,it_IT,ja_XX,kk_KZ,ko_KR,lt_LT,lv_LV,my_MM,ne_NP,nl_XX,ro_RO,ru_RU,si_LK,tr_TR,vi_VN,zh_CN\"\n\n#langlist = langlist_str.split(\",\")", "\n#langlist = langlist_str.split(\",\")\nlanglist_str = \"Arabic (ar_AR), Czech (cs_CZ), German (de_DE), English (en_XX), Spanish (es_XX), Estonian (et_EE), Finnish (fi_FI), French (fr_XX), Gujarati (gu_IN), Hindi (hi_IN), Italian (it_IT), Japanese (ja_XX), Kazakh (kk_KZ), Korean (ko_KR), Lithuanian (lt_LT), Latvian (lv_LV), Burmese (my_MM), Nepali (ne_NP), Dutch (nl_XX), Romanian (ro_RO), Russian (ru_RU), Sinhala (si_LK), Turkish (tr_TR), Vietnamese (vi_VN), Chinese (zh_CN), Afrikaans (af_ZA), Azerbaijani (az_AZ), Bengali (bn_IN), Persian (fa_IR), Hebrew (he_IL), Croatian (hr_HR), Indonesian (id_ID), Georgian (ka_GE), Khmer (km_KH), Macedonian (mk_MK), Malayalam (ml_IN), Mongolian (mn_MN), Marathi (mr_IN), Polish (pl_PL), Pashto (ps_AF), Portuguese (pt_XX), Swedish (sv_SE), Swahili (sw_KE), Tamil (ta_IN), Telugu (te_IN), Thai (th_TH), Tagalog (tl_XX), Ukrainian (uk_UA), Urdu (ur_PK), Xhosa (xh_ZA), Galician (gl_ES), Slovene (sl_SI)\"\nl = langlist_str.split(\", \")\nlanglist = []\nfor k in l:\n    if k != \"\":\n        langlist.append(k[-6:-1])\n#print(langlist)\n", "#print(langlist)\n\n\ncuda_opt = -1\nto_device = \"cpu\"\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"MBART 50 Translate\", # name\n        \"version\": \"2.0\", # version\n\n        \"translate\": {\n            \"fb_mbart50\": (init,translate) # 1 function - init, 2 - translate\n        },\n\n        \"default_options\": {\n            \"model\": \"facebook/mbart-large-50-many-to-many-mmt\",  # key model\n            \"cuda\": -1, # -1 if you want run on CPU, 0 - if on CUDA\n        },\n    }\n    return manifest", "\ndef start_with_options(core:OneRingCore, manifest:dict):\n    global cuda_opt\n    global to_device\n    cuda_opt = manifest[\"options\"].get(\"cuda\")\n    if cuda_opt == -1:\n        to_device = \"cpu\"\n    else:\n        to_device = \"cuda:{0}\".format(cuda_opt)\n    pass", "\ndef init(core:OneRingCore):\n    from transformers import MBartForConditionalGeneration\n\n    global model\n\n    #print(to_device)\n    model = MBartForConditionalGeneration.from_pretrained(core.plugin_options(modname).get(\"model\")).to(to_device)\n\n\n    pass", "\ndef convert_lang(input_lang:str) -> str:\n    if len(input_lang) == 2:\n        # if input_lang == \"en\" or input_lang == \"eng\":\n        #     return \"eng_Latn\"\n        # if input_lang == \"ru\":\n        #     return \"rus_Cyrl\"\n\n        for lang in langlist:\n            if lang.startswith(input_lang):\n                return lang\n\n    else:\n        return input_lang", "\ndef translate(core:OneRingCore, text:str, from_lang:str = \"\", to_lang:str = \"\", add_params:str = \"\"):\n    from transformers import MBartForConditionalGeneration, MBart50Tokenizer\n\n    from_lang_tr = convert_lang(from_lang)\n    to_lang_tr = convert_lang(to_lang)\n\n    full_id = f\"{from_lang_tr}__{to_lang_tr}\"\n\n    # print(from_lang_tr)\n    # print(to_lang_tr)\n\n    if tokenizers.get(full_id) is None:\n        tokenizers[full_id] = MBart50Tokenizer.from_pretrained(core.plugin_options(modname).get(\"model\"), src_lang=from_lang_tr, tgt_lang=to_lang_tr)\n    # if tokenizers.get(to_lang_tr) is None:\n    #     tokenizers[to_lang_tr] = AutoTokenizer.from_pretrained(core.plugin_options(modname).get(\"model\"), src_lang=to_lang_tr)\n\n    tokenizer_from = tokenizers.get(full_id)\n    inputs = tokenizer_from(text, return_tensors=\"pt\").to(to_device)\n\n    translated_tokens = model.generate(\n                            #**inputs, forced_bos_token_id=tokenizer_from.lang_code_to_id[to_lang_tr], max_length=int(len(text)*5)\n                            **inputs, forced_bos_token_id=tokenizer_from.lang_code_to_id[to_lang_tr], max_length=int(len(text) * 5)\n                        )\n    res = tokenizer_from.batch_decode(translated_tokens, skip_special_tokens=True)[0]\n\n\n\n    return res", "\n"]}
{"filename": "plugins/plugin_multi_sources.py", "chunked_list": ["# Multisources\n# gain translations from different sources and try to select one best\n# author: Vladislav Janvarev\nimport asyncio\n\nfrom oneringcore import OneRingCore\nimport os\n\nmodname = os.path.basename(__file__)[:-3] # calculating modname\n", "modname = os.path.basename(__file__)[:-3] # calculating modname\n\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"Multi sources plugin\", # name\n        \"version\": \"1.3\", # version\n\n        # this is DEFAULT options\n        # ACTUAL options is in options/<plugin_name>.json after first run\n        \"default_options\": {\n            \"model\": \"google_translate,deepl\",  # plugins that will be processed\n            \"min_symbols_to_full_model\": 30,\n            \"min_plugin\": \"google_translate\", # if symbols less than min, this will be used\n            \"multithread_model\": True, # use this if you use different plugins in model - this speedup by multithread tasks\n        },\n\n        \"translate\": {\n            \"multi_sources\": (init,translate) # 1 function - init, 2 - translate\n        }\n    }\n    return manifest", "\ndef start_with_options(core:OneRingCore, manifest:dict):\n    pass\n\ndef init(core:OneRingCore):\n    from comet import download_model, load_from_checkpoint\n    print(\"Activating COMET model...\")\n    model_path = download_model(\"Unbabel/wmt20-comet-qe-da\")\n    core.comet_model_multi_sources = load_from_checkpoint(model_path)\n    print(\"COMET model activated!\")\n    pass", "\nasync def run_list(tasks_lists):\n    return await asyncio.gather(*tasks_lists)\ndef translate(core:OneRingCore, text:str, from_lang:str = \"\", to_lang:str = \"\", add_params:str = \"\"):\n    plugins: str = core.plugin_options(modname).get(\"model\").split(\",\")\n\n    min_plugin: str = core.plugin_options(modname).get(\"min_plugin\")\n    min_symbols: int = core.plugin_options(modname).get(\"min_symbols_to_full_model\")\n    is_multithread_model: bool = core.plugin_options(modname).get(\"multithread_model\")\n    #print(len(text), min_symbols)\n    if len(text) < min_symbols:\n        res_text = core.translate(text, from_lang, to_lang, min_plugin, add_params).get(\"result\")\n        print(f\"Min transl {min_plugin}: {res_text}\")\n        return res_text\n\n\n    data0 = []\n    if not is_multithread_model:\n        data0 = []\n        for plugin in plugins:\n            data0.append(core.translate(text,from_lang,to_lang,plugin))\n    else:\n        # ---------- async version - not work inside FastAPI\n\n        # data_async_tasks = []\n        # for plugin in plugins:\n        #     data_async_tasks.append(asyncio.to_thread(core.translate, text, from_lang, to_lang, plugin,\n        #                               add_params))\n        #\n        # #data0 = asyncio.run(run_list(data_async_tasks))\n        # loop = asyncio.new_event_loop()\n        # data0 = loop.run_until_complete(run_list(data_async_tasks))\n\n        # ----------- multithread version -----------\n\n        import concurrent.futures\n\n        data0 = []\n        with concurrent.futures.ThreadPoolExecutor() as executor:\n            futures = [executor.submit(core.translate, text, from_lang, to_lang, plugin) for plugin in plugins]\n            for future in concurrent.futures.as_completed(futures):\n                result = future.result()\n                data0.append(result)\n\n\n    data = []\n    for mt_res in data0:\n        data.append({\"src\":text,\"mt\":mt_res.get(\"result\")})\n\n    #print(data)\n\n    pred = core.comet_model_multi_sources.predict(data, batch_size=8, gpus=0)\n    #print(model_output)\n    scores = pred.get(\"scores\")\n\n    max_ind = scores.index(max(scores))\n    #print('Scores:',scores, max_ind)\n\n\n    return data[max_ind][\"mt\"]", ""]}
{"filename": "plugins/plugin_fb_nllb_translate.py", "chunked_list": ["# nllb plugin\n# author: Vladislav Janvarev\n\n# from https://github.com/facebookresearch/fairseq/tree/nllb\n\nfrom oneringcore import OneRingCore\nimport os\n\nmodname = os.path.basename(__file__)[:-3] # calculating modname\n", "modname = os.path.basename(__file__)[:-3] # calculating modname\n\nmodel = None\ntokenizers:dict = {}\n\n# -------- lang list\n\nlanglist_str = \"\"\"\nace_Arab    | Acehnese (Arabic script)\nace_Latn    | Acehnese (Latin script)", "ace_Arab    | Acehnese (Arabic script)\nace_Latn    | Acehnese (Latin script)\nacm_Arab    | Mesopotamian Arabic\nacq_Arab    | Ta\u2019izzi-Adeni Arabic\naeb_Arab    | Tunisian Arabic\nafr_Latn    | Afrikaans\najp_Arab    | South Levantine Arabic\naka_Latn    | Akan\nals_Latn    | Tosk Albanian\namh_Ethi    | Amharic", "als_Latn    | Tosk Albanian\namh_Ethi    | Amharic\napc_Arab    | North Levantine Arabic\narb_Arab    | Modern Standard Arabic\narb_Latn    | Modern Standard Arabic (Romanized)\nars_Arab    | Najdi Arabic\nary_Arab    | Moroccan Arabic\narz_Arab    | Egyptian Arabic\nasm_Beng    | Assamese\nast_Latn    | Asturian", "asm_Beng    | Assamese\nast_Latn    | Asturian\nawa_Deva    | Awadhi\nayr_Latn    | Central Aymara\nazb_Arab    | South Azerbaijani\nazj_Latn    | North Azerbaijani\nbak_Cyrl    | Bashkir\nbam_Latn    | Bambara\nban_Latn    | Balinese\nbel_Cyrl    | Belarusian", "ban_Latn    | Balinese\nbel_Cyrl    | Belarusian\nbem_Latn    | Bemba\nben_Beng    | Bengali\nbho_Deva    | Bhojpuri\nbjn_Arab    | Banjar (Arabic script)\nbjn_Latn    | Banjar (Latin script)\nbod_Tibt    | Standard Tibetan\nbos_Latn    | Bosnian\nbug_Latn    | Buginese", "bos_Latn    | Bosnian\nbug_Latn    | Buginese\nbul_Cyrl    | Bulgarian\ncat_Latn    | Catalan\nceb_Latn    | Cebuano\nces_Latn    | Czech\ncjk_Latn    | Chokwe\nckb_Arab    | Central Kurdish\ncrh_Latn    | Crimean Tatar\ncym_Latn    | Welsh", "crh_Latn    | Crimean Tatar\ncym_Latn    | Welsh\ndan_Latn    | Danish\ndeu_Latn    | German\ndik_Latn    | Southwestern Dinka\ndyu_Latn    | Dyula\ndzo_Tibt    | Dzongkha\nell_Grek    | Greek\neng_Latn    | English\nepo_Latn    | Esperanto", "eng_Latn    | English\nepo_Latn    | Esperanto\nest_Latn    | Estonian\neus_Latn    | Basque\newe_Latn    | Ewe\nfao_Latn    | Faroese\nfij_Latn    | Fijian\nfin_Latn    | Finnish\nfon_Latn    | Fon\nfra_Latn    | French", "fon_Latn    | Fon\nfra_Latn    | French\nfur_Latn    | Friulian\nfuv_Latn    | Nigerian Fulfulde\ngaz_Latn    | West Central Oromo\ngla_Latn    | Scottish Gaelic\ngle_Latn    | Irish\nglg_Latn    | Galician\ngrn_Latn    | Guarani\nguj_Gujr    | Gujarati", "grn_Latn    | Guarani\nguj_Gujr    | Gujarati\nhat_Latn    | Haitian Creole\nhau_Latn    | Hausa\nheb_Hebr    | Hebrew\nhin_Deva    | Hindi\nhne_Deva    | Chhattisgarhi\nhrv_Latn    | Croatian\nhun_Latn    | Hungarian\nhye_Armn    | Armenian", "hun_Latn    | Hungarian\nhye_Armn    | Armenian\nibo_Latn    | Igbo\nilo_Latn    | Ilocano\nind_Latn    | Indonesian\nisl_Latn    | Icelandic\nita_Latn    | Italian\njav_Latn    | Javanese\njpn_Jpan    | Japanese\nkab_Latn    | Kabyle", "jpn_Jpan    | Japanese\nkab_Latn    | Kabyle\nkac_Latn    | Jingpho\nkam_Latn    | Kamba\nkan_Knda    | Kannada\nkas_Arab    | Kashmiri (Arabic script)\nkas_Deva    | Kashmiri (Devanagari script)\nkat_Geor    | Georgian\nkaz_Cyrl    | Kazakh\nkbp_Latn    | Kabiy\u00e8", "kaz_Cyrl    | Kazakh\nkbp_Latn    | Kabiy\u00e8\nkea_Latn    | Kabuverdianu\nkhk_Cyrl    | Halh Mongolian\nkhm_Khmr    | Khmer\nkik_Latn    | Kikuyu\nkin_Latn    | Kinyarwanda\nkir_Cyrl    | Kyrgyz\nkmb_Latn    | Kimbundu\nkmr_Latn    | Northern Kurdish", "kmb_Latn    | Kimbundu\nkmr_Latn    | Northern Kurdish\nknc_Arab    | Central Kanuri (Arabic script)\nknc_Latn    | Central Kanuri (Latin script)\nkon_Latn    | Kikongo\nkor_Hang    | Korean\nlao_Laoo    | Lao\nlij_Latn    | Ligurian\nlim_Latn    | Limburgish\nlin_Latn    | Lingala", "lim_Latn    | Limburgish\nlin_Latn    | Lingala\nlit_Latn    | Lithuanian\nlmo_Latn    | Lombard\nltg_Latn    | Latgalian\nltz_Latn    | Luxembourgish\nlua_Latn    | Luba-Kasai\nlug_Latn    | Ganda\nluo_Latn    | Luo\nlus_Latn    | Mizo", "luo_Latn    | Luo\nlus_Latn    | Mizo\nlvs_Latn    | Standard Latvian\nmag_Deva    | Magahi\nmai_Deva    | Maithili\nmal_Mlym    | Malayalam\nmar_Deva    | Marathi\nmin_Arab    | Minangkabau (Arabic script)\nmin_Latn    | Minangkabau (Latin script)\nmkd_Cyrl    | Macedonian", "min_Latn    | Minangkabau (Latin script)\nmkd_Cyrl    | Macedonian\nmlt_Latn    | Maltese\nmni_Beng    | Meitei (Bengali script)\nmos_Latn    | Mossi\nmri_Latn    | Maori\nmya_Mymr    | Burmese\nnld_Latn    | Dutch\nnno_Latn    | Norwegian Nynorsk\nnob_Latn    | Norwegian Bokm\u00e5l", "nno_Latn    | Norwegian Nynorsk\nnob_Latn    | Norwegian Bokm\u00e5l\nnpi_Deva    | Nepali\nnso_Latn    | Northern Sotho\nnus_Latn    | Nuer\nnya_Latn    | Nyanja\noci_Latn    | Occitan\nory_Orya    | Odia\npag_Latn    | Pangasinan\npan_Guru    | Eastern Panjabi", "pag_Latn    | Pangasinan\npan_Guru    | Eastern Panjabi\npap_Latn    | Papiamento\npbt_Arab    | Southern Pashto\npes_Arab    | Western Persian\nplt_Latn    | Plateau Malagasy\npol_Latn    | Polish\npor_Latn    | Portuguese\nprs_Arab    | Dari\nquy_Latn    | Ayacucho Quechua", "prs_Arab    | Dari\nquy_Latn    | Ayacucho Quechua\nron_Latn    | Romanian\nrun_Latn    | Rundi\nrus_Cyrl    | Russian\nsag_Latn    | Sango\nsan_Deva    | Sanskrit\nsat_Olck    | Santali\nscn_Latn    | Sicilian\nshn_Mymr    | Shan", "scn_Latn    | Sicilian\nshn_Mymr    | Shan\nsin_Sinh    | Sinhala\nslk_Latn    | Slovak\nslv_Latn    | Slovenian\nsmo_Latn    | Samoan\nsna_Latn    | Shona\nsnd_Arab    | Sindhi\nsom_Latn    | Somali\nsot_Latn    | Southern Sotho", "som_Latn    | Somali\nsot_Latn    | Southern Sotho\nspa_Latn    | Spanish\nsrd_Latn    | Sardinian\nsrp_Cyrl    | Serbian\nssw_Latn    | Swati\nsun_Latn    | Sundanese\nswe_Latn    | Swedish\nswh_Latn    | Swahili\nszl_Latn    | Silesian", "swh_Latn    | Swahili\nszl_Latn    | Silesian\ntam_Taml    | Tamil\ntaq_Latn    | Tamasheq (Latin script)\ntaq_Tfng    | Tamasheq (Tifinagh script)\ntat_Cyrl    | Tatar\ntel_Telu    | Telugu\ntgk_Cyrl    | Tajik\ntgl_Latn    | Tagalog\ntha_Thai    | Thai", "tgl_Latn    | Tagalog\ntha_Thai    | Thai\ntir_Ethi    | Tigrinya\ntpi_Latn    | Tok Pisin\ntsn_Latn    | Tswana\ntso_Latn    | Tsonga\ntuk_Latn    | Turkmen\ntum_Latn    | Tumbuka\ntur_Latn    | Turkish\ntwi_Latn    | Twi", "tur_Latn    | Turkish\ntwi_Latn    | Twi\ntzm_Tfng    | Central Atlas Tamazight\nuig_Arab    | Uyghur\nukr_Cyrl    | Ukrainian\numb_Latn    | Umbundu\nurd_Arab    | Urdu\nuzn_Latn    | Northern Uzbek\nvec_Latn    | Venetian\nvie_Latn    | Vietnamese", "vec_Latn    | Venetian\nvie_Latn    | Vietnamese\nwar_Latn    | Waray\nwol_Latn    | Wolof\nxho_Latn    | Xhosa\nydd_Hebr    | Eastern Yiddish\nyor_Latn    | Yoruba\nyue_Hant    | Yue Chinese\nzho_Hans    | Chinese (Simplified)\nzho_Hant    | Chinese (Traditional)", "zho_Hans    | Chinese (Simplified)\nzho_Hant    | Chinese (Traditional)\nzsm_Latn    | Standard Malay\nzul_Latn    | Zulu\n\"\"\"\n\nl = langlist_str.split(\"\\n\")\nlanglist = []\nfor k in l:\n    if k != \"\":\n        langlist.append(k[0:8])", "for k in l:\n    if k != \"\":\n        langlist.append(k[0:8])\n\n#print(langlist)\n\n\ncuda_opt = -1\nto_device = \"cpu\"\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"NLLB Translate\", # name\n        \"version\": \"2.0\", # version\n\n        \"translate\": {\n            \"fb_nllb_translate\": (init,translate) # 1 function - init, 2 - translate\n        },\n\n        \"default_options\": {\n            \"model\": \"facebook/nllb-200-distilled-600M\",  # key model\n            \"cuda\": -1, # -1 if you want run on CPU, 0 - if on CUDA\n        },\n    }\n    return manifest", "to_device = \"cpu\"\n# start function\ndef start(core:OneRingCore):\n    manifest = { # plugin settings\n        \"name\": \"NLLB Translate\", # name\n        \"version\": \"2.0\", # version\n\n        \"translate\": {\n            \"fb_nllb_translate\": (init,translate) # 1 function - init, 2 - translate\n        },\n\n        \"default_options\": {\n            \"model\": \"facebook/nllb-200-distilled-600M\",  # key model\n            \"cuda\": -1, # -1 if you want run on CPU, 0 - if on CUDA\n        },\n    }\n    return manifest", "\ndef start_with_options(core:OneRingCore, manifest:dict):\n    global cuda_opt\n    global to_device\n    cuda_opt = manifest[\"options\"].get(\"cuda\")\n    if cuda_opt == -1:\n        to_device = \"cpu\"\n    else:\n        to_device = \"cuda:{0}\".format(cuda_opt)\n    pass", "\ndef init(core:OneRingCore):\n    from transformers import AutoModelForSeq2SeqLM, AutoTokenizer\n\n    global model\n\n    #print(to_device)\n    model = AutoModelForSeq2SeqLM.from_pretrained(core.plugin_options(modname).get(\"model\")).to(to_device)\n\n\n    pass", "\ndef convert_lang(input_lang:str) -> str:\n    if len(input_lang) == 2 or len(input_lang) == 3:\n        if input_lang == \"en\" or input_lang == \"eng\":\n            return \"eng_Latn\"\n        if input_lang == \"ru\":\n            return \"rus_Cyrl\"\n\n        for lang in langlist:\n            if lang.startswith(input_lang):\n                return lang\n\n    else:\n        return input_lang", "\ndef translate(core:OneRingCore, text:str, from_lang:str = \"\", to_lang:str = \"\", add_params:str = \"\"):\n    from transformers import AutoModelForSeq2SeqLM, AutoTokenizer\n\n    from_lang_tr = convert_lang(from_lang)\n    to_lang_tr = convert_lang(to_lang)\n    if tokenizers.get(from_lang_tr) is None:\n        tokenizers[from_lang_tr] = AutoTokenizer.from_pretrained(core.plugin_options(modname).get(\"model\"), src_lang=from_lang_tr)\n    # if tokenizers.get(to_lang_tr) is None:\n    #     tokenizers[to_lang_tr] = AutoTokenizer.from_pretrained(core.plugin_options(modname).get(\"model\"), src_lang=to_lang_tr)\n\n    tokenizer_from = tokenizers.get(from_lang_tr)\n    inputs = tokenizer_from(text, return_tensors=\"pt\").to(to_device)\n\n    translated_tokens = model.generate(\n                            **inputs, forced_bos_token_id=tokenizer_from.lang_code_to_id[to_lang_tr], max_length=int(len(text)*5)\n                        )\n    res = tokenizer_from.batch_decode(translated_tokens, skip_special_tokens=True)[0]\n\n\n\n    return res", "\n"]}
{"filename": "plugins/plugin_openrouter_chat.py", "chunked_list": ["# Translation throw OpenRouter\n# author: Vladislav Janvarev\n\nimport os\nimport openai\n\nfrom oneringcore import OneRingCore\n\nimport json\n", "import json\n\nmodname = os.path.basename(__file__)[:-3] # calculating modname\n\n# \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043d\u0430 \u0441\u0442\u0430\u0440\u0442\u0435\ndef start(core:OneRingCore):\n    manifest = {\n        \"name\": \"Translation through OpenRouter\",\n        \"version\": \"3.1\",\n        \"description\": \"After define apiKey allow to translate through OpenRouter.\",\n\n        \"options_label\": {\n            \"apiKey\": \"API-key OpenAI\", #\n            \"apiBaseUrl\": \"URL for OpenAI (allow OpenAI emulation servers)\",  #\n            \"system\": \"System input string.\"\n        },\n\n        # this is DEFAULT options\n        # ACTUAL options is in options/<plugin_name>.json after first run\n        \"default_options\": {\n            \"apiKey\": \"\", #\n            \"apiBaseUrl\": \"https://openrouter.ai/api/v1\",  #\n            \"system\": \"Please translate the user message from {0} to {1}. Make the translation sound as natural as possible. Don't use any non-related phrases in result, answer with only translation text.\",\n            \"prompt\": \"{2}\",\n            \"model\": \"\",\n        },\n\n        \"translate\": {\n            \"openrouter_chat\": (init, translate)  # 1 function - init, 2 - translate\n        }\n\n    }\n    return manifest", "\ndef start_with_options(core:OneRingCore, manifest:dict):\n    pass\n\ndef init(core:OneRingCore):\n    options = core.plugin_options(modname)\n\n    if options[\"apiKey\"] == \"\" and options[\"apiBaseUrl\"] == \"\":\n        raise ValueError(\"Needed API KEY for access\")\n\n    openai.api_key = options[\"apiKey\"]\n\n    if options[\"apiBaseUrl\"] != \"\":\n        openai.api_base = options[\"apiBaseUrl\"]", "\n\ndef translate(core:OneRingCore, text:str, from_lang:str = \"\", to_lang:str = \"\", add_params:str = \"\"):\n    options = core.plugin_options(modname)\n\n    from_full_lang = core.dict_2let_to_lang.get(from_lang)\n    to_full_lang = core.dict_2let_to_lang.get(to_lang)\n\n    #prompt = f\"Instruction: Translate this text from {from_full_lang} to {to_full_lang}:\\n\\n{text}\"\n    prompt = str(options[\"prompt\"]).format(from_full_lang,to_full_lang,text)\n    system_text = str(options[\"system\"]).format(from_full_lang,to_full_lang,text)\n\n    messages = []\n    messages.append({\"role\": \"system\", \"content\": system_text})\n    messages.append({\"role\": \"user\", \"content\": prompt})\n\n    response_big = openai.ChatCompletion.create(\n        model=str(options[\"model\"]),\n        messages=messages,\n        temperature=0.7,\n        n=1,\n        max_tokens=int(len(prompt) * 1.5),\n        headers= { \"HTTP-Referer\": \"https://github.com/janvarev/OneRingTranslator\",\n          \"X-Title\": \"OneRingTranslator\" },\n    )\n    response = response_big[\"choices\"][0][\"message\"]\n\n    #core.chatapp = ChatApp(model=str(options[\"model\"]),system=system_text) # create new chat\n\n    #response = core.chatapp.chat(prompt)  # generate_response(phrase)\n    #print(response)\n    res = str(response[\"content\"]).strip()\n    #print(res)\n    return res", "\n"]}
