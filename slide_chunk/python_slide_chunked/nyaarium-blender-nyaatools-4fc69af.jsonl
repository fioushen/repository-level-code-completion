{"filename": "NyaaTools/consts.py", "chunked_list": ["EXPORT_COLLECTION = \"Export\"\nPROP_AVATAR_NAME = \"avatar_name\"\nPROP_AVATAR_EXPORT_PATH = \"avatar_export_path\"\nPROP_AVATAR_LAYERS = \"avatar_layers\"\nA_POSE_SHOULDER_ANGLE = 15\nSHAPE_KEY_TOLERANCE = 0.001\nUPDATE_URL = \"https://github.com/nyaarium/blender-nyaatools/releases\"\nISSUES_URL = \"https://github.com/nyaarium/blender-nyaatools/issues\"\n\n", "\n\n# Managed by GitHub, don't touch:\nVERSION = (0, 0, 0)\n"]}
{"filename": "NyaaTools/bone_desc_map.py", "chunked_list": ["# This bone description map is used to\nBONE_DESC_MAP = {\n    # Bone Descriptions\n    \"Hips\": {\n        \"common_names\": [\"Hips\", \"Hip\", \"Pelvis\"],\n        \"parent\": None,\n        \"children\": [\"Spine\", \"Thigh.L\", \"Thigh.R\"],\n        \"mirror\": None,\n    },\n    \"Spine\": {", "    },\n    \"Spine\": {\n        \"common_names\": [\"Spine\"],\n        \"parent\": \"Hips\",\n        \"children\": [\"Chest\"],\n        \"mirror\": None,\n        \"connected\": True,\n    },\n    \"Chest\": {\n        \"common_names\": [\"Chest\", \"Breast Root\", \"Shoulder.L\", \"Shoulder.R\"],", "    \"Chest\": {\n        \"common_names\": [\"Chest\", \"Breast Root\", \"Shoulder.L\", \"Shoulder.R\"],\n        \"parent\": \"Spine\",\n        \"children\": [\"Neck\", \"Breast Root\"],\n        \"mirror\": None,\n        \"connected\": True,\n    },\n    \"Neck\": {\n        \"common_names\": [\"Neck\"],\n        \"parent\": \"Chest\",", "        \"common_names\": [\"Neck\"],\n        \"parent\": \"Chest\",\n        \"children\": [\"Head\"],\n        \"mirror\": None,\n    },\n    \"Head\": {\n        \"common_names\": [\"Head\"],\n        \"parent\": \"Neck\",\n        \"children\": [\"Eye.L\", \"Eye.R\"],\n        \"mirror\": None,", "        \"children\": [\"Eye.L\", \"Eye.R\"],\n        \"mirror\": None,\n        \"connected\": True,\n    },\n    \"Eye.L\": {\n        \"common_names\": [\"Eye.L\", \"Left Eye\"],\n        \"parent\": \"Head\",\n        \"children\": None,\n        \"mirror\": \"Eye.R\",\n    },", "        \"mirror\": \"Eye.R\",\n    },\n    \"Eye.R\": {\n        \"common_names\": [\"Eye.R\", \"Right Eye\"],\n        \"parent\": \"Head\",\n        \"children\": None,\n        \"mirror\": \"Eye.L\",\n    },\n    \"Breast Root\": {\n        \"common_names\": [", "    \"Breast Root\": {\n        \"common_names\": [\n            \"Breast Root\",\n            \"Boob Root\",\n            \"Breast Dynamic\",\n            \"Root_BreastUpper2\",\n        ],\n        \"parent\": \"Chest\",\n        \"children\": [\"Breast.R\", \"Breast.L\"],\n        \"mirror\": None,", "        \"children\": [\"Breast.R\", \"Breast.L\"],\n        \"mirror\": None,\n        \"optional\": True,\n    },\n    \"Breast.L\": {\n        \"common_names\": [\n            \"Breast\",\n            \"BreastUpper2_L\",\n            \"Left Breast\",\n            \"Left Boob\",", "            \"Left Breast\",\n            \"Left Boob\",\n            \"Boob_L\",\n        ],\n        \"parent\": \"Breast Root\",\n        \"children\": None,\n        \"mirror\": \"Breast.R\",\n        \"optional\": True,\n    },\n    \"Breast.R\": {", "    },\n    \"Breast.R\": {\n        \"common_names\": [\n            \"Breast\",\n            \"BreastUpper2_R\",\n            \"Right Breast\",\n            \"Right Boob\",\n            \"Boob_R\",\n        ],\n        \"parent\": \"Breast Root\",", "        ],\n        \"parent\": \"Breast Root\",\n        \"children\": None,\n        \"mirror\": \"Breast.L\",\n        \"optional\": True,\n    },\n    \"Upper Leg.L\": {\n        \"common_names\": [\"Upper Leg.L\", \"Thigh.L\", \"Leg.L\", \"Left Leg\"],\n        \"parent\": \"Hips\",\n        \"children\": [\"Lower Leg.L\"],", "        \"parent\": \"Hips\",\n        \"children\": [\"Lower Leg.L\"],\n        \"mirror\": \"Upper Leg.R\",\n        \"roll\": 0,\n    },\n    \"Lower Leg.L\": {\n        \"common_names\": [\"Lower Leg.L\", \"Knee.L\", \"Left Knee\"],\n        \"parent\": \"Upper Leg.L\",\n        \"children\": [\"Foot.L\"],\n        \"mirror\": \"Lower Leg.R\",", "        \"children\": [\"Foot.L\"],\n        \"mirror\": \"Lower Leg.R\",\n        \"connected\": True,\n        \"roll\": 0,\n    },\n    \"Foot.L\": {\n        \"common_names\": [\"Foot.L\", \"Ankle.L\", \"Left Ankle\", \"Left Foot\"],\n        \"parent\": \"Lower Leg.L\",\n        \"children\": [\"Toes.L\"],\n        \"mirror\": \"Foot.R\",", "        \"children\": [\"Toes.L\"],\n        \"mirror\": \"Foot.R\",\n        \"connected\": True,\n        \"roll\": 180,\n    },\n    \"Toes.L\": {\n        \"common_names\": [\"Toes.L\", \"Toe.L\", \"Left Toe\"],\n        \"parent\": \"Foot.L\",\n        \"children\": None,\n        \"mirror\": \"Toes.R\",", "        \"children\": None,\n        \"mirror\": \"Toes.R\",\n        \"optional\": True,\n        \"roll\": 180,\n    },\n    \"Upper Leg.R\": {\n        \"common_names\": [\"Upper Leg.R\", \"Thigh.R\", \"Leg.R\", \"Right Leg\"],\n        \"parent\": \"Hips\",\n        \"children\": [\"Lower Leg.R\"],\n        \"mirror\": \"Upper Leg.L\",", "        \"children\": [\"Lower Leg.R\"],\n        \"mirror\": \"Upper Leg.L\",\n        \"roll\": 0,\n    },\n    \"Lower Leg.R\": {\n        \"common_names\": [\"Lower Leg.R\", \"Knee.R\", \"Right Knee\"],\n        \"parent\": \"Upper Leg.R\",\n        \"children\": [\"Foot.R\"],\n        \"mirror\": \"Lower Leg.L\",\n        \"connected\": True,", "        \"mirror\": \"Lower Leg.L\",\n        \"connected\": True,\n        \"roll\": 0,\n    },\n    \"Foot.R\": {\n        \"common_names\": [\"Foot.R\", \"Ankle.R\", \"Right Ankle\", \"Right Foot\"],\n        \"parent\": \"Lower Leg.R\",\n        \"children\": [\"Toes.R\"],\n        \"mirror\": \"Foot.L\",\n        \"connected\": True,", "        \"mirror\": \"Foot.L\",\n        \"connected\": True,\n        \"roll\": 180,\n    },\n    \"Toes.R\": {\n        \"common_names\": [\"Toes.R\", \"Toe.R\", \"Right Toe\"],\n        \"parent\": \"Foot.R\",\n        \"children\": None,\n        \"mirror\": \"Toes.L\",\n        \"optional\": True,", "        \"mirror\": \"Toes.L\",\n        \"optional\": True,\n        \"roll\": 180,\n    },\n    \"Shoulder.L\": {\n        \"common_names\": [\"Shoulder.L\", \"Left Shoulder\"],\n        \"parent\": \"Chest\",\n        \"children\": [\"Arm.L\"],\n        \"mirror\": \"Shoulder.R\",\n    },", "        \"mirror\": \"Shoulder.R\",\n    },\n    \"Upper Arm.L\": {\n        \"common_names\": [\"Upper Arm.L\", \"Arm.L\", \"Left Arm\"],\n        \"parent\": \"Shoulder.L\",\n        \"children\": [\"Lower Arm.L\"],\n        \"mirror\": \"Upper Arm.R\",\n        \"connected\": True,\n        \"roll\": 180,\n    },", "        \"roll\": 180,\n    },\n    \"Lower Arm.L\": {\n        \"common_names\": [\"Lower Arm.L\", \"Elbow.L\", \"Left Elbow\"],\n        \"parent\": \"Upper Arm.L\",\n        \"children\": [\"Hand.L\"],\n        \"mirror\": \"Lower Arm.R\",\n        \"connected\": True,\n        \"roll\": 90,\n    },", "        \"roll\": 90,\n    },\n    \"Hand.L\": {\n        \"common_names\": [\"Hand.L\", \"Wrist.L\", \"Left Wrist\"],\n        \"parent\": \"Lower Arm.L\",\n        \"children\": [\n            \"Thumb 1.L\",\n            \"Little Finger 1.L\",\n            \"Ring Finger 1.L\",\n            \"Middle Finger 1.L\",", "            \"Ring Finger 1.L\",\n            \"Middle Finger 1.L\",\n            \"Index Finger 1.L\",\n        ],\n        \"mirror\": \"Hand.R\",\n        \"connected\": True,\n        \"roll\": 180,\n    },\n    \"Shoulder.R\": {\n        \"common_names\": [\"Shoulder.R\", \"Right Shoulder\"],", "    \"Shoulder.R\": {\n        \"common_names\": [\"Shoulder.R\", \"Right Shoulder\"],\n        \"parent\": \"Chest\",\n        \"children\": [\"Arm.R\"],\n        \"mirror\": \"Shoulder.L\",\n    },\n    \"Upper Arm.R\": {\n        \"common_names\": [\"Upper Arm.R\", \"Arm.R\", \"Right Arm\"],\n        \"parent\": \"Shoulder.R\",\n        \"children\": [\"Lower Arm.R\"],", "        \"parent\": \"Shoulder.R\",\n        \"children\": [\"Lower Arm.R\"],\n        \"mirror\": \"Upper Arm.L\",\n        \"connected\": True,\n        \"roll\": 180,\n    },\n    \"Lower Arm.R\": {\n        \"common_names\": [\"Lower Arm.R\", \"Elbow.R\", \"Right Elbow\"],\n        \"parent\": \"Upper Arm.R\",\n        \"children\": [\"Hand.R\"],", "        \"parent\": \"Upper Arm.R\",\n        \"children\": [\"Hand.R\"],\n        \"mirror\": \"Lower Arm.L\",\n        \"connected\": True,\n        \"roll\": -90,\n    },\n    \"Hand.R\": {\n        \"common_names\": [\"Hand.R\", \"Wrist.R\", \"Right Wrist\"],\n        \"parent\": \"Lower Arm.R\",\n        \"children\": [", "        \"parent\": \"Lower Arm.R\",\n        \"children\": [\n            \"Thumb 1.R\",\n            \"Little Finger 1.R\",\n            \"Ring Finger 1.R\",\n            \"Middle Finger 1.R\",\n            \"Index Finger 1.R\",\n        ],\n        \"mirror\": \"Hand.L\",\n        \"connected\": True,", "        \"mirror\": \"Hand.L\",\n        \"connected\": True,\n        \"roll\": 180,\n    },\n    \"Thumb 1.L\": {\n        \"common_names\": [\"Thumb 1.L\", \"Thumb0.L\", \"Thumb.L\", \"Thumb Proximal.L\"],\n        \"parent\": \"Hand.L\",\n        \"children\": [\"Thumb 2.L\"],\n        \"mirror\": \"Thumb 1.R\",\n        \"roll\": -90,", "        \"mirror\": \"Thumb 1.R\",\n        \"roll\": -90,\n    },\n    \"Thumb 2.L\": {\n        \"common_names\": [\"Thumb 2.L\", \"Thumb1.L\", \"Thumb Intermediate.L\"],\n        \"parent\": \"Thumb 1.L\",\n        \"children\": [\"Thumb 3.L\"],\n        \"mirror\": \"Thumb 2.R\",\n        \"connected\": True,\n        \"roll\": -90,", "        \"connected\": True,\n        \"roll\": -90,\n    },\n    \"Thumb 3.L\": {\n        \"common_names\": [\"Thumb 3.L\", \"Thumb2.L\", \"Thumb Distal.L\"],\n        \"parent\": \"Thumb 2.L\",\n        \"children\": None,\n        \"mirror\": \"Thumb 3.R\",\n        \"connected\": True,\n        \"roll\": -90,", "        \"connected\": True,\n        \"roll\": -90,\n    },\n    \"Index Finger 1.L\": {\n        \"common_names\": [\n            \"Index Finger 1.L\",\n            \"IndexFinger1.L\",\n            \"Index Finger Left\",\n            \"Index Proximal.L\",\n        ],", "            \"Index Proximal.L\",\n        ],\n        \"parent\": \"Hand.L\",\n        \"children\": [\"Index Finger 2.L\"],\n        \"mirror\": \"Index Finger 1.R\",\n        \"roll\": 180,\n    },\n    \"Index Finger 2.L\": {\n        \"common_names\": [\n            \"Index Finger 2.L\",", "        \"common_names\": [\n            \"Index Finger 2.L\",\n            \"IndexFinger2.L\",\n            \"Index Finger Left\",\n            \"Index Intermediate.L\",\n        ],\n        \"parent\": \"Index Finger 1.L\",\n        \"children\": [\"Index Finger 3.L\"],\n        \"mirror\": \"Index Finger 2.R\",\n        \"roll\": 180,", "        \"mirror\": \"Index Finger 2.R\",\n        \"roll\": 180,\n        \"connected\": True,\n    },\n    \"Index Finger 3.L\": {\n        \"common_names\": [\n            \"Index Finger 3.L\",\n            \"IndexFinger3.L\",\n            \"Index Finger Left\",\n            \"Index Distal.L\",", "            \"Index Finger Left\",\n            \"Index Distal.L\",\n        ],\n        \"parent\": \"Index Finger 2.L\",\n        \"children\": None,\n        \"mirror\": \"Index Finger 3.R\",\n        \"roll\": 180,\n        \"connected\": True,\n    },\n    \"Middle Finger 1.L\": {", "    },\n    \"Middle Finger 1.L\": {\n        \"common_names\": [\n            \"Middle Finger 1.L\",\n            \"MiddleFinger1.L\",\n            \"Middle Finger Left\",\n            \"Middle Proximal.L\",\n        ],\n        \"parent\": \"Hand.L\",\n        \"children\": [\"Middle Finger 2.L\"],", "        \"parent\": \"Hand.L\",\n        \"children\": [\"Middle Finger 2.L\"],\n        \"mirror\": \"Middle Finger 1.R\",\n        \"roll\": 180,\n    },\n    \"Middle Finger 2.L\": {\n        \"common_names\": [\n            \"Middle Finger 2.L\",\n            \"MiddleFinger2.L\",\n            \"Middle Finger Left\",", "            \"MiddleFinger2.L\",\n            \"Middle Finger Left\",\n            \"Middle Intermediate.L\",\n        ],\n        \"parent\": \"Middle Finger 1.L\",\n        \"children\": [\"Middle Finger 3.L\"],\n        \"mirror\": \"Middle Finger 2.R\",\n        \"roll\": 180,\n        \"connected\": True,\n    },", "        \"connected\": True,\n    },\n    \"Middle Finger 3.L\": {\n        \"common_names\": [\n            \"Middle Finger 3.L\",\n            \"MiddleFinger3.L\",\n            \"Middle Finger Left\",\n            \"Middle Distal.L\",\n        ],\n        \"parent\": \"Middle Finger 2.L\",", "        ],\n        \"parent\": \"Middle Finger 2.L\",\n        \"children\": None,\n        \"mirror\": \"Middle Finger 3.R\",\n        \"roll\": 180,\n        \"connected\": True,\n    },\n    \"Ring Finger 1.L\": {\n        \"common_names\": [\n            \"Ring Finger 1.L\",", "        \"common_names\": [\n            \"Ring Finger 1.L\",\n            \"RingFinger1.L\",\n            \"Ring Finger Left\",\n            \"Ring Proximal.L\",\n        ],\n        \"parent\": \"Hand.L\",\n        \"children\": [\"Ring Finger 2.L\"],\n        \"mirror\": \"Ring Finger 1.R\",\n        \"roll\": 180,", "        \"mirror\": \"Ring Finger 1.R\",\n        \"roll\": 180,\n    },\n    \"Ring Finger 2.L\": {\n        \"common_names\": [\n            \"Ring Finger 2.L\",\n            \"RingFinger2.L\",\n            \"Ring Finger Left\",\n            \"Ring Intermediate.L\",\n        ],", "            \"Ring Intermediate.L\",\n        ],\n        \"parent\": \"Ring Finger 1.L\",\n        \"children\": [\"Ring Finger 3.L\"],\n        \"mirror\": \"Ring Finger 2.R\",\n        \"roll\": 180,\n        \"connected\": True,\n    },\n    \"Ring Finger 3.L\": {\n        \"common_names\": [", "    \"Ring Finger 3.L\": {\n        \"common_names\": [\n            \"Ring Finger 3.L\",\n            \"RingFinger3.L\",\n            \"Ring Finger Left\",\n            \"Ring Distal.L\",\n        ],\n        \"parent\": \"Ring Finger 2.L\",\n        \"children\": None,\n        \"mirror\": \"Ring Finger 3.R\",", "        \"children\": None,\n        \"mirror\": \"Ring Finger 3.R\",\n        \"roll\": 180,\n        \"connected\": True,\n    },\n    \"Little Finger 1.L\": {\n        \"common_names\": [\n            \"Little Finger 1.L\",\n            \"LittleFinger1.L\",\n            \"Little Finger Left\",", "            \"LittleFinger1.L\",\n            \"Little Finger Left\",\n            \"Little Proximal.L\",\n        ],\n        \"parent\": \"Hand.L\",\n        \"children\": [\"Little Finger 2.L\"],\n        \"mirror\": \"Little Finger 1.R\",\n        \"roll\": 180,\n    },\n    \"Little Finger 2.L\": {", "    },\n    \"Little Finger 2.L\": {\n        \"common_names\": [\n            \"Little Finger 2.L\",\n            \"LittleFinger2.L\",\n            \"Little Finger Left\",\n            \"Little Intermediate.L\",\n        ],\n        \"parent\": \"Little Finger 1.L\",\n        \"children\": [\"Little Finger 3.L\"],", "        \"parent\": \"Little Finger 1.L\",\n        \"children\": [\"Little Finger 3.L\"],\n        \"mirror\": \"Little Finger 2.R\",\n        \"roll\": 180,\n        \"connected\": True,\n    },\n    \"Little Finger 3.L\": {\n        \"common_names\": [\n            \"Little Finger 3.L\",\n            \"LittleFinger3.L\",", "            \"Little Finger 3.L\",\n            \"LittleFinger3.L\",\n            \"Little Finger Left\",\n            \"Little Distal.L\",\n        ],\n        \"parent\": \"Little Finger 2.L\",\n        \"children\": None,\n        \"mirror\": \"Little Finger 3.R\",\n        \"roll\": 180,\n        \"connected\": True,", "        \"roll\": 180,\n        \"connected\": True,\n    },\n    \"Thumb 1.R\": {\n        \"common_names\": [\"Thumb 1.R\", \"Thumb0.R\", \"Thumb.R\", \"Thumb Proximal.R\"],\n        \"parent\": \"Hand.R\",\n        \"children\": [\"Thumb 2.R\"],\n        \"mirror\": \"Thumb 1.L\",\n        \"roll\": 90,\n    },", "        \"roll\": 90,\n    },\n    \"Thumb 2.R\": {\n        \"common_names\": [\"Thumb 2.R\", \"Thumb1.R\", \"Thumb Intermediate.R\"],\n        \"parent\": \"Thumb 1.R\",\n        \"children\": [\"Thumb 3.R\"],\n        \"mirror\": \"Thumb 2.L\",\n        \"connected\": True,\n        \"roll\": 90,\n    },", "        \"roll\": 90,\n    },\n    \"Thumb 3.R\": {\n        \"common_names\": [\"Thumb 3.R\", \"Thumb2.R\", \"Thumb Distal.R\"],\n        \"parent\": \"Thumb 2.R\",\n        \"children\": None,\n        \"mirror\": \"Thumb 3.L\",\n        \"connected\": True,\n        \"roll\": 90,\n    },", "        \"roll\": 90,\n    },\n    \"Index Finger 1.R\": {\n        \"common_names\": [\n            \"Index Finger 1.R\",\n            \"IndexFinger1.R\",\n            \"Index Finger Right\",\n            \"Index Proximal.R\",\n        ],\n        \"parent\": \"Hand.R\",", "        ],\n        \"parent\": \"Hand.R\",\n        \"children\": [\"Index Finger 2.R\"],\n        \"mirror\": \"Index Finger 1.L\",\n        \"roll\": 180,\n    },\n    \"Index Finger 2.R\": {\n        \"common_names\": [\n            \"Index Finger 2.R\",\n            \"IndexFinger2.R\",", "            \"Index Finger 2.R\",\n            \"IndexFinger2.R\",\n            \"Index Finger Right\",\n            \"Index Intermediate.R\",\n        ],\n        \"parent\": \"Index Finger 1.R\",\n        \"children\": [\"Index Finger 3.R\"],\n        \"mirror\": \"Index Finger 2.L\",\n        \"roll\": 180,\n        \"connected\": True,", "        \"roll\": 180,\n        \"connected\": True,\n    },\n    \"Index Finger 3.R\": {\n        \"common_names\": [\n            \"Index Finger 3.R\",\n            \"IndexFinger3.R\",\n            \"Index Finger Right\",\n            \"Index Distal.R\",\n        ],", "            \"Index Distal.R\",\n        ],\n        \"parent\": \"Index Finger 2.R\",\n        \"children\": None,\n        \"mirror\": \"Index Finger 3.L\",\n        \"roll\": 180,\n        \"connected\": True,\n    },\n    \"Middle Finger 1.R\": {\n        \"common_names\": [", "    \"Middle Finger 1.R\": {\n        \"common_names\": [\n            \"Middle Finger 1.R\",\n            \"MiddleFinger1.R\",\n            \"Middle Finger Right\",\n            \"Middle Proximal.R\",\n        ],\n        \"parent\": \"Hand.R\",\n        \"children\": [\"Middle Finger 2.R\"],\n        \"mirror\": \"Middle Finger 1.L\",", "        \"children\": [\"Middle Finger 2.R\"],\n        \"mirror\": \"Middle Finger 1.L\",\n        \"roll\": 180,\n    },\n    \"Middle Finger 2.R\": {\n        \"common_names\": [\n            \"Middle Finger 2.R\",\n            \"MiddleFinger2.R\",\n            \"Middle Finger Right\",\n            \"Middle Intermediate.R\",", "            \"Middle Finger Right\",\n            \"Middle Intermediate.R\",\n        ],\n        \"parent\": \"Middle Finger 1.R\",\n        \"children\": [\"Middle Finger 3.R\"],\n        \"mirror\": \"Middle Finger 2.L\",\n        \"roll\": 180,\n        \"connected\": True,\n    },\n    \"Middle Finger 3.R\": {", "    },\n    \"Middle Finger 3.R\": {\n        \"common_names\": [\n            \"Middle Finger 3.R\",\n            \"MiddleFinger3.R\",\n            \"Middle Finger Right\",\n            \"Middle Distal.R\",\n        ],\n        \"parent\": \"Middle Finger 2.R\",\n        \"children\": None,", "        \"parent\": \"Middle Finger 2.R\",\n        \"children\": None,\n        \"mirror\": \"Middle Finger 3.L\",\n        \"roll\": 180,\n        \"connected\": True,\n    },\n    \"Ring Finger 1.R\": {\n        \"common_names\": [\n            \"Ring Finger 1.R\",\n            \"RingFinger1.R\",", "            \"Ring Finger 1.R\",\n            \"RingFinger1.R\",\n            \"Ring Finger Right\",\n            \"Ring Proximal.R\",\n        ],\n        \"parent\": \"Hand.R\",\n        \"children\": [\"Ring Finger 2.R\"],\n        \"mirror\": \"Ring Finger 1.L\",\n        \"roll\": 180,\n    },", "        \"roll\": 180,\n    },\n    \"Ring Finger 2.R\": {\n        \"common_names\": [\n            \"Ring Finger 2.R\",\n            \"RingFinger2.R\",\n            \"Ring Finger Right\",\n            \"Ring Intermediate.R\",\n        ],\n        \"parent\": \"Ring Finger 1.R\",", "        ],\n        \"parent\": \"Ring Finger 1.R\",\n        \"children\": [\"Ring Finger 3.R\"],\n        \"mirror\": \"Ring Finger 2.L\",\n        \"roll\": 180,\n        \"connected\": True,\n    },\n    \"Ring Finger 3.R\": {\n        \"common_names\": [\n            \"Ring Finger 3.R\",", "        \"common_names\": [\n            \"Ring Finger 3.R\",\n            \"RingFinger3.R\",\n            \"Ring Finger Right\",\n            \"Ring Distal.R\",\n        ],\n        \"parent\": \"Ring Finger 2.R\",\n        \"children\": None,\n        \"mirror\": \"Ring Finger 3.L\",\n        \"roll\": 180,", "        \"mirror\": \"Ring Finger 3.L\",\n        \"roll\": 180,\n        \"connected\": True,\n    },\n    \"Little Finger 1.R\": {\n        \"common_names\": [\n            \"Little Finger 1.R\",\n            \"LittleFinger1.R\",\n            \"Little Finger Right\",\n            \"Little Proximal.R\",", "            \"Little Finger Right\",\n            \"Little Proximal.R\",\n        ],\n        \"parent\": \"Hand.R\",\n        \"children\": [\"Little Finger 2.R\"],\n        \"mirror\": \"Little Finger 1.L\",\n        \"roll\": 180,\n    },\n    \"Little Finger 2.R\": {\n        \"common_names\": [", "    \"Little Finger 2.R\": {\n        \"common_names\": [\n            \"Little Finger 2.R\",\n            \"LittleFinger2.R\",\n            \"Little Finger Right\",\n            \"Little Intermediate.R\",\n        ],\n        \"parent\": \"Little Finger 1.R\",\n        \"children\": [\"Little Finger 3.R\"],\n        \"mirror\": \"Little Finger 2.L\",", "        \"children\": [\"Little Finger 3.R\"],\n        \"mirror\": \"Little Finger 2.L\",\n        \"roll\": 180,\n        \"connected\": True,\n    },\n    \"Little Finger 3.R\": {\n        \"common_names\": [\n            \"Little Finger 3.R\",\n            \"LittleFinger3.R\",\n            \"Little Finger Right\",", "            \"LittleFinger3.R\",\n            \"Little Finger Right\",\n            \"Little Distal.R\",\n        ],\n        \"parent\": \"Little Finger 2.R\",\n        \"children\": None,\n        \"mirror\": \"Little Finger 3.L\",\n        \"roll\": 180,\n        \"connected\": True,\n    },", "        \"connected\": True,\n    },\n}\n"]}
{"filename": "NyaaTools/__init__.py", "chunked_list": ["import bpy\n\nfrom .operators.NyaaPanel import NyaaPanel\nfrom .operators.NyaaToolsAddModifier import NyaaToolsAddModifier\nfrom .operators.NyaaToolsAvatarMergeExport import NyaaToolsAvatarMergeExport\nfrom .operators.NyaaToolsConfigureAvatarArmature import NyaaToolsConfigureAvatarArmature\nfrom .operators.NyaaToolsConfigureMeshesOnAvatar import NyaaToolsConfigureMeshesOnAvatar\nfrom .operators.NyaaToolsMeshCleanup import NyaaToolsMeshCleanup\nfrom .operators.NyaaToolsNormalizeArmatureATPose import NyaaToolsNormalizeArmatureATPose\nfrom .operators.NyaaToolsRemoveMeshesFromAvatar import NyaaToolsRemoveMeshesFromAvatar", "from .operators.NyaaToolsNormalizeArmatureATPose import NyaaToolsNormalizeArmatureATPose\nfrom .operators.NyaaToolsRemoveMeshesFromAvatar import NyaaToolsRemoveMeshesFromAvatar\nfrom .operators.NyaaSelectStandardBones import NyaaSelectStandardBones\nfrom .operators.PrzemirApplyTopModifier import PrzemirApplyTopModifier\nfrom .operators.LinkButton import LinkButton\n\n\nbl_info = {\n    \"name\": \"NyaaTools\",\n    \"author\": \"Nyaarium\",", "    \"name\": \"NyaaTools\",\n    \"author\": \"Nyaarium\",\n    \"blender\": (3, 0, 0),\n    \"version\": (1, 4, 0),\n    \"description\": \"Various Nyaarium tools to normalize & fast-export avatar FBX's\",\n    \"location\": \"Tool > NyaaTools\",\n    \"category\": \"Object\",\n}\n\n", "\n\nclasses = [\n    NyaaPanel,\n    NyaaToolsAddModifier,\n    NyaaToolsAvatarMergeExport,\n    NyaaToolsConfigureAvatarArmature,\n    NyaaToolsConfigureMeshesOnAvatar,\n    NyaaToolsMeshCleanup,\n    NyaaToolsNormalizeArmatureATPose,", "    NyaaToolsMeshCleanup,\n    NyaaToolsNormalizeArmatureATPose,\n    NyaaToolsRemoveMeshesFromAvatar,\n    NyaaSelectStandardBones,\n    PrzemirApplyTopModifier,\n    LinkButton,\n]\n\n\ndef register():\n    for cls in reversed(classes):\n        bpy.utils.register_class(cls)", "\ndef register():\n    for cls in reversed(classes):\n        bpy.utils.register_class(cls)\n\n\ndef unregister():\n    for cls in classes:\n        bpy.utils.unregister_class(cls)\n", ""]}
{"filename": "NyaaTools/operators/NyaaPanel.py", "chunked_list": ["import bpy\nfrom bpy.props import StringProperty\n\nfrom ..avatar.get_avatar_layers import get_avatar_layers\nfrom ..common.get_prop import get_prop\nfrom ..common.has_value import has_value\nfrom ..consts import (\n    PROP_AVATAR_EXPORT_PATH,\n    PROP_AVATAR_NAME,\n    ISSUES_URL,", "    PROP_AVATAR_NAME,\n    ISSUES_URL,\n    UPDATE_URL,\n    VERSION,\n)\n\n\nclass NyaaPanel(bpy.types.Panel):\n    bl_label = \"NyaaTools v\" + \".\".join(str(i) for i in VERSION)\n    bl_idname = \"OBJECT_PT_NYAAPANEL\"\n    bl_category = \"Tool\"\n    bl_space_type = \"VIEW_3D\"\n    bl_region_type = \"UI\"\n\n    # TODO: Reimplement to not operate in draw context\n    # Modal? Something else?\n    def draw(self, context):\n        error = None\n\n        # Don't consider it a selection if active object with no selection\n        has_selection = False\n\n        is_armature = False\n        is_avatar = False\n        is_mesh = False\n        armature = None\n        avatar_name = None\n        export_path = None\n\n        selected_armatures = []\n        selected_meshes = []\n\n        all_selected_meshes_using_this_avatar = True\n        no_selected_meshes_using_this_avatar = True\n\n        # Dict of [path_layer_name] = [meshes]\n        selected_avatar_layers = {}\n        unassigned_meshes = []\n\n        avatar_layers = {}\n        mesh_layers_count = 0\n\n        #############################################\n\n        try:\n            # Determine mesh & armature selection\n            for obj in bpy.context.selected_objects:\n                if obj.type == \"ARMATURE\":\n                    selected_armatures.append(obj)\n\n                    if len(selected_armatures) == 1:\n                        # Select this armature\n                        armature = obj\n                        is_armature = True\n                        avatar_name = get_prop(armature, PROP_AVATAR_NAME)\n                        export_path = get_prop(armature, PROP_AVATAR_EXPORT_PATH)\n                        is_avatar = has_value(avatar_name)\n                    elif 1 < len(selected_armatures):\n                        # Deselect armature\n                        armature = None\n                        is_armature = False\n                        avatar_name = None\n                        export_path = None\n                        is_avatar = False\n\n                elif obj.type == \"MESH\":\n                    selected_meshes.append(obj)\n\n                    is_mesh = True\n\n            if is_avatar:\n                for mesh in selected_meshes:\n                    # Pairs of [path_avatar_name, path_layer_name]\n                    layers = get_avatar_layers(mesh)\n\n                    is_using_this_avatar = False\n                    for layer in layers:\n                        path_avatar_name = layer[0]\n                        path_layer_name = layer[1]\n                        if path_avatar_name == avatar_name:\n                            is_using_this_avatar = True\n\n                            # Add to selected_avatar_layers\n                            if not path_layer_name in selected_avatar_layers:\n                                selected_avatar_layers[path_layer_name] = []\n                            selected_avatar_layers[path_layer_name].append(mesh)\n\n                            break\n                    if is_using_this_avatar:\n                        no_selected_meshes_using_this_avatar = False\n                    else:\n                        all_selected_meshes_using_this_avatar = False\n                        unassigned_meshes.append(mesh)\n\n                # ISSUE: This is expensive in larger scenes. Maybe remove this section\n                # If avatar selection, check avatar layers (meshes using this)\n                for mesh in bpy.data.objects:\n                    # Pairs of [path_avatar_name, path_layer_name]\n                    layers = get_avatar_layers(mesh)\n\n                    # Filter layers to only those using this avatar\n                    for layer in layers:\n                        path_avatar_name = layer[0]\n                        path_layer_name = layer[1]\n                        if path_avatar_name == avatar_name:\n                            # If not defined, init array\n                            if not path_layer_name in avatar_layers:\n                                avatar_layers[path_layer_name] = []\n\n                            avatar_layers[path_layer_name].append(mesh)\n\n                            mesh_layers_count += 1\n\n            has_selection = is_armature or is_mesh\n\n        except Exception as e:\n            error = e\n            print(\"Error in NyaaPanel:\")\n            print(e)\n\n        #############################################\n        #############################################\n        # Begin layout\n\n        layout = self.layout\n\n        if error != None:\n            box = layout.box()\n            box.label(text=\"An error occurred.\")\n            box.label(text=\"Please report the issue.\")\n            box.label(text=\"\")\n            box.label(text=str(error))\n\n        #############################################\n        # Avatar Armature\n\n        if is_armature:\n            title_text = \"Avatar (not configured)\"\n            if is_avatar:\n                title_text = \"Avatar: \" + avatar_name\n\n            box = layout.box()\n            box.label(text=title_text, icon=\"OUTLINER_OB_ARMATURE\")\n            row = box.row(align=True)\n\n            if is_avatar:\n                op = row.operator(\n                    \"nyaa.configure_avatar_armature\", text=\"\ud83d\udd27 Reconfigure\"\n                )\n                op.avatar_name = avatar_name\n                op.export_path = export_path\n\n                row = box.row(align=True)\n\n                if 0 < mesh_layers_count:\n                    op = row.operator(\n                        \"nyaa.avatar_merge_export\", text=\"\ud83d\udce6 Merge & Export\"\n                    )\n                    op.avatar_name = avatar_name\n                else:\n                    box.label(text=\"No meshes assigned\", icon=\"ERROR\")\n                    box.label(text=\"Select this armature and some meshes\")\n\n            else:\n                op = row.operator(\n                    \"nyaa.configure_avatar_armature\", text=\"Make New Avatar\"\n                )\n                op.avatar_name = \"\"\n                op.export_path = \"./Export.fbx\"\n\n        elif 1 < len(selected_armatures):\n            box = layout.box()\n            box.label(text=\"Avatar Armature\", icon=\"OUTLINER_OB_ARMATURE\")\n            box.label(text=\"Select only 1 armature\")\n\n        else:\n            box = layout.box()\n            box.label(text=\"Avatar Armature\", icon=\"OUTLINER_OB_ARMATURE\")\n            box.label(text=\"Select an armature\")\n\n        #############################################\n        # Selected Avatar Meshes\n\n        if is_mesh:\n            box = layout.box()\n            box.label(text=\"Selected Avatar Meshes\", icon=\"OUTLINER_OB_MESH\")\n            row = box.row(align=True)\n\n            if is_avatar:\n                if 0 < len(selected_avatar_layers):\n                    # List meshes in selected_avatar_layers\n                    for path_layer_name in selected_avatar_layers:\n                        # Display layer name\n                        row.label(text=path_layer_name)\n\n                        meshes = selected_avatar_layers[path_layer_name]\n                        for mesh in meshes:\n                            row = box.row(align=True)\n                            split = row.split(factor=0.1)\n                            split.label(text=\"\")\n                            split.label(text=mesh.name)\n\n                        row = box.row(align=True)\n\n                    if 0 < len(unassigned_meshes):\n                        # Display unassigned meshes\n                        row.label(text=\"(Unassigned)\")\n                        for mesh in unassigned_meshes:\n                            row = box.row(align=True)\n                            split = row.split(factor=0.1)\n                            split.label(text=\"\")\n                            split.label(text=mesh.name)\n                else:\n                    box.label(text=\"(no meshes assigned)\")\n\n                row = box.row(align=True)\n\n                c = str(len(selected_meshes))\n                if all_selected_meshes_using_this_avatar:\n                    # Remove selection action\n                    op = row.operator(\n                        \"nyaa.remove_meshes_from_avatar\",\n                        text=\"\u2796 Remove \" + c + \" from avatar\",\n                    )\n                elif no_selected_meshes_using_this_avatar:\n                    # Add selection action\n                    text = \"\"\n                    if len(selected_meshes) == 1:\n                        text = \"\u2795 Add \" + c + \" to avatar\"\n                    else:\n                        text = \"\ud83d\udd17 Combine \" + c + \" to single layer\"\n                    op = row.operator(\"nyaa.configure_meshes_on_avatar\", text=text)\n                    if len(selected_meshes) == 1:\n                        op.layer_name = selected_meshes[0].name\n                    else:\n                        op.layer_name = \"\"\n                else:\n                    # Recombine selection action\n                    op = row.operator(\n                        \"nyaa.configure_meshes_on_avatar\",\n                        text=\"\ud83d\udd17 Recombine \" + c + \" to single layer\",\n                    )\n                    op.layer_name = \"\"\n\n            else:\n                row.label(text=\"(no armature selected)\")\n\n        elif len(selected_meshes) == 0:\n            box = layout.box()\n            box.label(text=\"Selected Avatar Meshes\", icon=\"OUTLINER_OB_MESH\")\n            box.label(text=\"Select some meshes\")\n\n        #############################################\n        # Mesh Tools\n\n        if is_mesh:\n            box = layout.box()\n            box.label(text=\"Mesh Cleanup\", icon=\"OUTLINER_OB_MESH\")\n            row = box.row(align=True)\n\n            op = row.operator(\"nyaa.mesh_cleanup\", text=\"All\")\n            op.vg = True\n            op.sk = True\n            op.mat = True\n\n            op = row.operator(\"nyaa.mesh_cleanup\", text=\"Vertex Groups\")\n            op.vg = True\n            op.sk = False\n            op.mat = False\n            row = box.row(align=True)\n\n            op = row.operator(\"nyaa.mesh_cleanup\", text=\"Shape Keys\")\n            op.vg = False\n            op.sk = True\n            op.mat = False\n\n            op = row.operator(\"nyaa.mesh_cleanup\", text=\"Materials\")\n            op.vg = False\n            op.sk = False\n            op.mat = True\n\n            box.label(text=\"Add Modifiers\", icon=\"TOOL_SETTINGS\")\n            row = box.row(align=True)\n\n            op = row.operator(\"nyaa.add_modifier\", text=\"Armature\")\n            op.which_modifier = \"Armature\"\n\n            op = row.operator(\"nyaa.add_modifier\", text=\"Data Transfer\")\n            op.which_modifier = \"DataTransfer\"\n\n            row = box.row(align=True)\n\n            op = row.operator(\"nyaa.add_modifier\", text=\"Decimate\")\n            op.which_modifier = \"Decimate\"\n\n            op = row.operator(\"nyaa.add_modifier\", text=\"Outline\")\n            op.which_modifier = \"Outline\"\n\n            # To fill in an empty cell\n            # row = row.split(factor=0.5)\n\n            box.label(text=\"Modifier with Shape Keys\", icon=\"SHAPEKEY_DATA\")\n            row = box.row(align=True)\n\n            row.operator(\"przemir.apply_top_modifier\", text=\"Apply Top Modifier\")\n\n        elif not has_selection:\n            box = layout.box()\n            box.label(text=\"Mesh\", icon=\"OUTLINER_OB_MESH\")\n            box.label(text=\"Select a mesh to edit.\")\n\n        #############################################\n        # Armature Tools\n\n        if is_armature:\n            box = layout.box()\n            box.label(text=\"Armature\", icon=\"OUTLINER_OB_ARMATURE\")\n            row = box.row(align=True)\n\n            op = row.operator(\n                \"nyaa.select_standard_bones\", text=\"Select Standard Bones\"\n            )\n\n            box = layout.box()\n            box.label(text=\"Nyaa's Normalization\", icon=\"OUTLINER_OB_ARMATURE\")\n\n            row = box.row(align=True)\n            row.label(text=\"Don't touch unless you're\")\n            row = box.row(align=True)\n            row.label(text=\"mocap/animating in Blender\")\n\n            row = box.row(align=True)\n\n            op = row.operator(\n                \"nyaa.normalize_armature_at_pose\", text=\"A-Pose\", icon=\"ERROR\"\n            )\n            op.which_pose = \"a-pose\"\n            op.apply_pose = True\n\n            op = row.operator(\n                \"nyaa.normalize_armature_at_pose\", text=\"T-Pose\", icon=\"ERROR\"\n            )\n            op.which_pose = \"t-pose\"\n            op.apply_pose = True\n\n            # box.label(text=\"Quick Pose\", icon=\"OUTLINER_OB_ARMATURE\")\n            # row = box.row(align=True)\n\n            # op = row.operator(\"nyaa.normalize_armature_at_pose\", text=\"Set A-Pose\")\n            # op.which_pose = \"a-pose\"\n            # op.apply_pose = False\n\n            # op = row.operator(\"nyaa.normalize_armature_at_pose\", text=\"Set T-Pose\")\n            # op.which_pose = \"t-pose\"\n            # op.apply_pose = False\n\n        elif not has_selection:\n            box = layout.box()\n            box.label(text=\"Armature\", icon=\"OUTLINER_OB_ARMATURE\")\n            box.label(text=\"Select an armature to edit\")\n\n        #############################################\n\n        if not has_selection:\n            box = layout.box()\n            box.label(text=\"Atelier Nyaarium\", icon=\"INFO\")\n\n            row = box.row(align=True)\n\n            row.operator(\"ops.open_link\", text=\"Updates\", icon=\"WORLD\").url = UPDATE_URL\n\n            row.operator(\"ops.open_link\", text=\"Issues?\", icon=\"WORLD\").url = ISSUES_URL", ""]}
{"filename": "NyaaTools/operators/NyaaToolsNormalizeArmatureATPose.py", "chunked_list": ["import traceback\nimport bpy\nfrom bpy.props import BoolProperty, StringProperty\n\n\nfrom ..armature.estimate_is_normalized import estimate_is_normalized\nfrom ..armature.find_meshes_affected_by_armature_modifier import (\n    find_meshes_affected_by_armature_modifier,\n)\nfrom ..armature.normalize_armature_pose import normalize_armature_pose", ")\nfrom ..armature.normalize_armature_pose import normalize_armature_pose\nfrom ..armature.normalize_armature_rename_bones import normalize_armature_rename_bones\nfrom ..armature.normalize_armature_roll_bones import normalize_armature_roll_bones\nfrom ..common.selection_get_armature import selection_get_armature\nfrom ..bone_desc_map import BONE_DESC_MAP\n\n\nclass NyaaToolsNormalizeArmatureATPose(bpy.types.Operator):\n    \"\"\"Normalizes armatures to my preferred A or T pose layout\"\"\"\n\n    bl_idname = \"nyaa.normalize_armature_at_pose\"\n    bl_label = \"Enforce Pose\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    which_pose: StringProperty(name=\"Which Pose\", default=\"\")\n    apply_pose: BoolProperty(name=\"Apply Pose\", default=True)\n\n    apply_roll: BoolProperty(\n        name=\"Roll Bones\",\n        description=\"Roll bones such that rotation on local X rotates along the joint. Suitable for posing and animating in Blender. Not so suitable for game character mods.\",\n        default=False,\n    )\n\n    def execute(self, context):\n        try:\n            armature = selection_get_armature()\n\n            if self.apply_pose:\n                perform_normalize_armature(armature, self.which_pose, self.apply_roll)\n            else:\n                perform_fast_pose(armature, self.which_pose)\n            return {\"FINISHED\"}\n        except Exception as error:\n            print(traceback.format_exc())\n            self.report({\"ERROR\"}, str(error))\n            return {\"CANCELLED\"}", "class NyaaToolsNormalizeArmatureATPose(bpy.types.Operator):\n    \"\"\"Normalizes armatures to my preferred A or T pose layout\"\"\"\n\n    bl_idname = \"nyaa.normalize_armature_at_pose\"\n    bl_label = \"Enforce Pose\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    which_pose: StringProperty(name=\"Which Pose\", default=\"\")\n    apply_pose: BoolProperty(name=\"Apply Pose\", default=True)\n\n    apply_roll: BoolProperty(\n        name=\"Roll Bones\",\n        description=\"Roll bones such that rotation on local X rotates along the joint. Suitable for posing and animating in Blender. Not so suitable for game character mods.\",\n        default=False,\n    )\n\n    def execute(self, context):\n        try:\n            armature = selection_get_armature()\n\n            if self.apply_pose:\n                perform_normalize_armature(armature, self.which_pose, self.apply_roll)\n            else:\n                perform_fast_pose(armature, self.which_pose)\n            return {\"FINISHED\"}\n        except Exception as error:\n            print(traceback.format_exc())\n            self.report({\"ERROR\"}, str(error))\n            return {\"CANCELLED\"}", "\n\ndef perform_normalize_armature(armature, which_pose, apply_roll=False):\n    if armature == None or armature.type != \"ARMATURE\":\n        raise Exception(\"Expected an armature\")\n\n    if not which_pose in {\"a-pose\", \"t-pose\"}:\n        raise Exception(\"which_pose must be a-pose or t-pose\")\n\n    if not isinstance(apply_roll, bool):\n        raise Exception(\"apply_roll must be a boolean\")\n\n    wm = bpy.context.window_manager\n\n    # Progress count, total\n    progress = [0]\n    progress_total = 0\n\n    def callback_progress_tick():\n        progress[0] = progress[0] + 1\n        wm.progress_update(progress[0] / progress_total * 100)\n\n    # Progress Total: T-Pose is:\n    # - Fixed count of callback_progress_tick() in the function\n    # - Total number of affected meshes\n    # - Total number of shape keys in affected meshes\n    progress_total += 36\n    total_shapekeys = 0\n\n    affected_meshes = find_meshes_affected_by_armature_modifier(armature)\n    progress_total += 2 * len(affected_meshes)\n    for mesh, modifier in affected_meshes:\n        if mesh.data.shape_keys != None:\n            total_shapekeys += len(mesh.data.shape_keys.key_blocks)\n\n    progress_total += total_shapekeys\n\n    ######################\n    ##  Begin progress  ##\n\n    # Make armature active\n    bpy.ops.object.mode_set(mode=\"OBJECT\")\n    bpy.context.view_layer.objects.active = armature\n\n    wm.progress_begin(0, 100)\n\n    # Rename bones\n    normalize_armature_rename_bones(armature)\n\n    # Set T-Pose\n    normalize_armature_pose(armature, which_pose, True, callback_progress_tick)\n\n    # Set roll\n    normalize_armature_roll_bones(armature, which_pose, apply_roll)\n\n    bpy.ops.object.mode_set(mode=\"OBJECT\")\n\n    wm.progress_end()\n\n    print(\"Done!\")", "\n\ndef perform_fast_pose(armature, which_pose):\n    if armature == None or armature.type != \"ARMATURE\":\n        raise Exception(\"Expected an armature\")\n\n    if not which_pose in {\"a-pose\", \"t-pose\"}:\n        raise Exception(\"which_pose must be a-pose or t-pose\")\n\n    wm = bpy.context.window_manager\n\n    # Progress count, total\n    progress = [0]\n    progress_total = 0\n\n    def callback_progress_tick():\n        progress[0] = progress[0] + 1\n        wm.progress_update(progress[0] / progress_total * 100)\n\n    # Progress Total: Rename bones is the length of the bone descriptors\n    progress_total += len(BONE_DESC_MAP)\n\n    ######################\n    ##  Begin progress  ##\n\n    # Make armature active\n    bpy.ops.object.mode_set(mode=\"OBJECT\")\n    bpy.context.view_layer.objects.active = armature\n\n    if estimate_is_normalized(armature):\n        wm.progress_begin(0, 100)\n\n        normalize_armature_pose(armature, which_pose, False, callback_progress_tick)\n\n        bpy.ops.object.mode_set(mode=\"OBJECT\")\n\n        wm.progress_end()\n    else:\n        raise Exception(\"Armature is not Nyaa-normalized! Please normalize first.\")", ""]}
{"filename": "NyaaTools/operators/NyaaToolsAvatarMergeExport.py", "chunked_list": ["import traceback\nimport bpy\nfrom bpy.props import StringProperty\n\nfrom ..mesh.cleanup_mesh import cleanup_mesh\nfrom ..consts import EXPORT_COLLECTION, PROP_AVATAR_EXPORT_PATH\nfrom ..common.deselect_all import deselect_all\nfrom ..common.selection_add import selection_add\nfrom ..common.select_collection import select_collection\nfrom ..common.get_prop import get_prop", "from ..common.select_collection import select_collection\nfrom ..common.get_prop import get_prop\nfrom ..avatar.merge_onto_avatar_layer import merge_onto_avatar_layer\nfrom ..avatar.get_avatar_meshes import get_avatar_meshes\nfrom ..avatar.get_avatar_layers import get_avatar_layers\nfrom ..avatar.get_avatar_armature import get_avatar_armature\n\n\nclass NyaaToolsAvatarMergeExport(bpy.types.Operator):\n    \"\"\"Merge and export the avatar. If you have an export path defined, it will export there\"\"\"\n\n    bl_idname = \"nyaa.avatar_merge_export\"\n    bl_label = \"Merge & Export\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    avatar_name: StringProperty(name=\"Avatar Name\", default=\"\")\n    # TODO: additional options\n\n    def execute(self, context):\n        try:\n            if not self.avatar_name:\n                self.report({\"ERROR\"}, \"Specify an avatar name.\")\n                return {\"CANCELLED\"}\n\n            perform_merge_export(\n                self.avatar_name,\n                # TODO: additional options\n            )\n            return {\"FINISHED\"}\n        except Exception as error:\n            print(traceback.format_exc())\n            self.report({\"ERROR\"}, str(error))\n            return {\"CANCELLED\"}", "class NyaaToolsAvatarMergeExport(bpy.types.Operator):\n    \"\"\"Merge and export the avatar. If you have an export path defined, it will export there\"\"\"\n\n    bl_idname = \"nyaa.avatar_merge_export\"\n    bl_label = \"Merge & Export\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    avatar_name: StringProperty(name=\"Avatar Name\", default=\"\")\n    # TODO: additional options\n\n    def execute(self, context):\n        try:\n            if not self.avatar_name:\n                self.report({\"ERROR\"}, \"Specify an avatar name.\")\n                return {\"CANCELLED\"}\n\n            perform_merge_export(\n                self.avatar_name,\n                # TODO: additional options\n            )\n            return {\"FINISHED\"}\n        except Exception as error:\n            print(traceback.format_exc())\n            self.report({\"ERROR\"}, str(error))\n            return {\"CANCELLED\"}", "\n\ndef perform_merge_export(avatar_name):\n    def debug_print(*msgs):\n        print(\"   \", *msgs)\n        return\n\n    bpy.ops.object.mode_set(mode=\"OBJECT\")\n\n    armature = get_avatar_armature(avatar_name)\n\n    # Show all collections\n    for col in bpy.context.scene.collection.children:\n        col.hide_viewport = False\n\n    # Create export collection\n    export_col = bpy.data.collections.new(\"__Export Temp__\")\n    bpy.context.scene.collection.children.link(export_col)\n    export_col.color_tag = \"COLOR_01\"\n\n    # Rename all objects to avoid collisions\n    for obj in bpy.data.objects:\n        obj.name = \"____\" + obj.name\n\n    # Rename & move Armature to exports\n    armature.name = \"Armature\"\n    armature.data.name = \"Armature\"\n    armature.parent = None\n\n    # Link to soon-to-be Export collection\n    try:\n        selection_add(armature)\n        bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n        bpy.data.collections[\"__Export Temp__\"].objects.link(armature)\n    except:\n        None\n\n    # Unlink from Scene Collection\n    try:\n        bpy.context.scene.collection.objects.unlink(armature)\n    except:\n        None\n\n    # Perform layer merges on meshes\n    for meshName in get_avatar_meshes(avatar_name):\n        mesh = bpy.context.scene.objects.get(meshName)\n        if mesh != None:\n            # Get pairs [path_avatar_name, path_layer_name]\n            # If avatar_name == path_avatar_name, merge\n            layers = get_avatar_layers(mesh)\n            for path_avatar_name, path_layer_name in layers:\n                if avatar_name == path_avatar_name:\n                    merge_onto_avatar_layer(path_layer_name, meshName, armature)\n\n        else:\n            print(\"    BUG: Mesh doesn't exist, skipping for now:  \" + meshName)\n\n    # Cleanup temp objects\n    for obj in bpy.data.objects:\n        if obj.name.startswith(\"____\"):\n            bpy.data.objects.remove(obj)\n\n    # Optimize meshes\n    for obj in bpy.data.objects:\n        if obj.type == \"MESH\":\n            cleanup_mesh(obj)\n\n    for col in bpy.context.scene.collection.children:\n        if col.name != \"__Export Temp__\":\n            bpy.data.collections.remove(col)\n\n    # Export\n    export_col.name = EXPORT_COLLECTION\n    select_collection(EXPORT_COLLECTION)\n\n    deselect_all()\n    selection_add(armature)\n\n    if get_prop(armature, PROP_AVATAR_EXPORT_PATH):\n        path = get_prop(armature, PROP_AVATAR_EXPORT_PATH)\n        if path:\n            # Replace all slashes\n            path = path.replace(\"\\\\\", \"/\")\n\n            file_path = \"\"\n            file_name = \"\"\n\n            # Get path parts\n            if path.endswith(\".fbx\"):\n                file_name = path.split(\"/\")[-1]\n                file_path = path[: -len(file_name) - 1]\n            else:\n                file_name = avatar_name + \".fbx\"\n                file_path = path\n\n            if len(file_path) == 0:\n                file_path = \"./\"\n\n            print(file_path)\n            print(file_name)\n\n            # A. Absolute paths (D:\\Path)\n            # B. Network path (\\\\Network Path)\n            # C. Relative paths\n            if 2 <= len(file_path) and file_path[1] == \":\":\n                path = file_path + \"/\" + file_name\n            elif file_path.startswith(\"//\"):\n                path = file_path + \"/\" + file_name\n            else:\n                path = bpy.path.abspath(\"//\" + file_path + \"/\" + file_name)\n\n        bpy.ops.export_scene.fbx(\n            filepath=path,\n            check_existing=False,\n            filter_glob=\"*.fbx\",\n            use_active_collection=True,\n            apply_scale_options=\"FBX_SCALE_UNITS\",\n            axis_forward=\"-Y\",\n            axis_up=\"Z\",\n            use_mesh_modifiers=False,\n            mesh_smooth_type=\"FACE\",\n            # primary_bone_axis=\"X\",\n            # secondary_bone_axis=\"-Y\",\n            add_leaf_bones=False,\n            bake_anim=False\n            # bake_anim_use_all_actions=False,\n        )", ""]}
{"filename": "NyaaTools/operators/LinkButton.py", "chunked_list": ["import webbrowser\nimport bpy\nfrom bpy.props import StringProperty\n\n\nclass LinkButton(bpy.types.Operator):\n    \"\"\"Open links in a web browser\"\"\"\n    bl_idname = \"ops.open_link\"\n    bl_label = \"Open Link in web browser\"\n    bl_options = {\"REGISTER\"}\n\n    url: StringProperty(name=\"URL\",\n                        description=\"URL\",\n                        default=\"\"\n                        )\n\n    def execute(self, context):\n        webbrowser.open_new(self.url)  # opens in default browser\n        return {\"FINISHED\"}", ""]}
{"filename": "NyaaTools/operators/NyaaToolsRemoveMeshesFromAvatar.py", "chunked_list": ["import bpy\nfrom bpy.props import StringProperty\nimport traceback\n\nfrom ..avatar.get_avatar_armature import get_avatar_armature\nfrom ..avatar.remove_from_avatar_layers import remove_from_avatar_layers\nfrom ..common.get_prop import get_prop\nfrom ..common.has_value import has_value\nfrom ..common.selection_get_armature import selection_get_armature\nfrom ..common.selection_get_meshes import selection_get_meshes", "from ..common.selection_get_armature import selection_get_armature\nfrom ..common.selection_get_meshes import selection_get_meshes\nfrom ..consts import PROP_AVATAR_NAME\n\n\nclass NyaaToolsRemoveMeshesFromAvatar(bpy.types.Operator):\n    \"\"\"Remove meshes from avatar\"\"\"\n    bl_idname = \"nyaa.remove_meshes_from_avatar\"\n    bl_label = \"Remove Meshes from Avatar\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    def execute(self, context):\n        try:\n            armature = selection_get_armature()\n            meshes = selection_get_meshes()\n\n            perform_remove_meshes_from_avatar(armature, meshes)\n            return {\"FINISHED\"}\n        except Exception as error:\n            print(traceback.format_exc())\n            self.report({\"ERROR\"}, str(error))\n            return {\"CANCELLED\"}", "\n\ndef perform_remove_meshes_from_avatar(armature, meshes):\n    if not isinstance(meshes, list) or len(meshes) == 0:\n        raise Exception(\"Expected at least one mesh\")\n\n    if armature == None or armature.type != \"ARMATURE\":\n        raise Exception(\"Expected an armature\")\n\n    avatar_name = get_prop(armature, PROP_AVATAR_NAME)\n\n    if not has_value(avatar_name):\n        raise Exception(\"Expected an avatar name\")\n\n    # Remove all meshes from the avatar\n    for mesh in meshes:\n        remove_from_avatar_layers(avatar_name, mesh)", ""]}
{"filename": "NyaaTools/operators/NyaaSelectStandardBones.py", "chunked_list": ["import traceback\nimport bpy\nfrom bpy.props import BoolProperty\n\nfrom ..common.selection_get_armature import selection_get_armature\nfrom ..bone_desc_map import BONE_DESC_MAP\n\n\nclass NyaaSelectStandardBones(bpy.types.Operator):\n    \"\"\"Select only the standard bones of a humanoid armature. Must be Nyaa Normalized.\"\"\"\n\n    bl_idname = \"nyaa.select_standard_bones\"\n    bl_label = \"Select standard bones (in edit or pose mode)\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    include_breast_bones: BoolProperty(\n        name=\"Include Breasts\",\n        description=\"Include breast bones in selection\",\n        default=True,\n    )\n\n    def execute(self, context):\n        try:\n            armature = selection_get_armature()\n\n            perform_select_standard_bones(\n                armature, include_breast_bones=self.include_breast_bones\n            )\n\n            return {\"FINISHED\"}\n        except Exception as error:\n            print(traceback.format_exc())\n            self.report({\"ERROR\"}, str(error))\n            return {\"CANCELLED\"}", "class NyaaSelectStandardBones(bpy.types.Operator):\n    \"\"\"Select only the standard bones of a humanoid armature. Must be Nyaa Normalized.\"\"\"\n\n    bl_idname = \"nyaa.select_standard_bones\"\n    bl_label = \"Select standard bones (in edit or pose mode)\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    include_breast_bones: BoolProperty(\n        name=\"Include Breasts\",\n        description=\"Include breast bones in selection\",\n        default=True,\n    )\n\n    def execute(self, context):\n        try:\n            armature = selection_get_armature()\n\n            perform_select_standard_bones(\n                armature, include_breast_bones=self.include_breast_bones\n            )\n\n            return {\"FINISHED\"}\n        except Exception as error:\n            print(traceback.format_exc())\n            self.report({\"ERROR\"}, str(error))\n            return {\"CANCELLED\"}", "\n\ndef perform_select_standard_bones(armature, include_breast_bones=True):\n    if armature == None or armature.type != \"ARMATURE\":\n        raise Exception(\"Expected an armature\")\n\n    currentMode = bpy.context.mode\n\n    if currentMode == \"EDIT_ARMATURE\":\n        bpy.ops.armature.select_all(action=\"DESELECT\")\n\n        # Loop over names in BONE_DESC_MAP and select just those edit bones\n        for bone_desc_name in BONE_DESC_MAP:\n            if bone_desc_name not in armature.data.edit_bones:\n                raise Exception(\n                    bone_desc_name + \" not found. Is this armature Nyaa Normalized?\"\n                )\n\n            eb = armature.data.edit_bones[bone_desc_name]\n\n            if bone_desc_name.startswith(\"Breast\"):\n                if include_breast_bones:\n                    eb.select = True\n            else:\n                eb.select = True\n\n    elif currentMode == \"POSE\":\n        bpy.ops.pose.select_all(action=\"DESELECT\")\n\n        # Loop over names in BONE_DESC_MAP and select just those pose bones\n        for bone_desc_name in BONE_DESC_MAP:\n            if bone_desc_name not in armature.pose.bones:\n                raise Exception(\n                    bone_desc_name + \" not found. Is this armature Nyaa Normalized?\"\n                )\n\n            pb = armature.pose.bones[bone_desc_name]\n\n            if bone_desc_name.startswith(\"Breast\"):\n                if include_breast_bones:\n                    pb.bone.select = True\n            else:\n                pb.bone.select = True\n\n    else:\n        raise Exception(\"Switch to edit or pose mode first\")", ""]}
{"filename": "NyaaTools/operators/NyaaToolsConfigureAvatarArmature.py", "chunked_list": ["import traceback\nimport bpy\nfrom bpy.props import StringProperty\n\nfrom ..avatar.get_avatar_armature import get_avatar_armature\nfrom ..common.get_prop import get_prop\nfrom ..common.has_value import has_value\nfrom ..common.selection_get_armature import selection_get_armature\nfrom ..common.selection_get_meshes import selection_get_meshes\nfrom ..common.set_prop import set_prop", "from ..common.selection_get_meshes import selection_get_meshes\nfrom ..common.set_prop import set_prop\nfrom ..consts import PROP_AVATAR_EXPORT_PATH, PROP_AVATAR_NAME\n\n\nclass NyaaToolsConfigureAvatarArmature(bpy.types.Operator):\n    \"\"\"Configure this armature as an Avatar\"\"\"\n    bl_idname = \"nyaa.configure_avatar_armature\"\n    bl_label = \"Configure Avatar\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    avatar_name: StringProperty(name=\"Avatar Name\", default=\"\")\n    export_path: StringProperty(name=\"Export Path\", default=\"Export.fbx\")\n\n    def execute(self, context):\n        try:\n            if not has_value(self.avatar_name):\n                self.report({\"INFO\"}, \"Please enter an avatar name\")\n                return {\"FINISHED\"}\n\n            armature = selection_get_armature()\n\n            perform_configure_avatar_armature(\n                armature,\n                self.avatar_name,\n                self.export_path\n            )\n            return {\"FINISHED\"}\n        except Exception as error:\n            print(traceback.format_exc())\n            self.report({\"ERROR\"}, str(error))\n            return {\"CANCELLED\"}", "\n\ndef perform_configure_avatar_armature(armature, avatar_name, export_path):\n    if armature == None or armature.type != \"ARMATURE\":\n        raise Exception(\"Expected an armature\")\n\n    # TODO: Check if avatar name already exists. Error if it does\n\n    set_prop(armature, PROP_AVATAR_NAME, avatar_name)\n    set_prop(armature, PROP_AVATAR_EXPORT_PATH, export_path)", "\n    # TODO: Rename all existing mesh layers of this avatar (remove layer, then add layer)\n"]}
{"filename": "NyaaTools/operators/NyaaToolsMeshCleanup.py", "chunked_list": ["import traceback\nimport bpy\nfrom bpy.props import BoolProperty\n\nfrom ..common.selection_get_meshes import selection_get_meshes\nfrom ..mesh.remove_unused_materials import remove_unused_materials\nfrom ..mesh.remove_unused_shape_keys import remove_unused_shape_keys\nfrom ..mesh.remove_unused_vertex_groups import remove_unused_vertex_groups\n\n\nclass NyaaToolsMeshCleanup(bpy.types.Operator):\n    \"\"\"Removes unused vertex groups, shape keys, and materials from a mesh object\"\"\"\n    bl_idname = \"nyaa.mesh_cleanup\"\n    bl_label = \"Mesh Cleanup\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    vg: BoolProperty(name=\"Vertex Groups\", default=False)\n    sk: BoolProperty(name=\"Shape Keys\", default=False)\n    mat: BoolProperty(name=\"Materials\", default=False)\n\n    def execute(self, context):\n        try:\n            meshes = selection_get_meshes()\n\n            perform_cleanup(meshes, self.vg, self.sk, self.mat)\n            return {\"FINISHED\"}\n        except Exception as error:\n            print(traceback.format_exc())\n            self.report({\"ERROR\"}, str(error))\n            return {\"CANCELLED\"}", "\n\nclass NyaaToolsMeshCleanup(bpy.types.Operator):\n    \"\"\"Removes unused vertex groups, shape keys, and materials from a mesh object\"\"\"\n    bl_idname = \"nyaa.mesh_cleanup\"\n    bl_label = \"Mesh Cleanup\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    vg: BoolProperty(name=\"Vertex Groups\", default=False)\n    sk: BoolProperty(name=\"Shape Keys\", default=False)\n    mat: BoolProperty(name=\"Materials\", default=False)\n\n    def execute(self, context):\n        try:\n            meshes = selection_get_meshes()\n\n            perform_cleanup(meshes, self.vg, self.sk, self.mat)\n            return {\"FINISHED\"}\n        except Exception as error:\n            print(traceback.format_exc())\n            self.report({\"ERROR\"}, str(error))\n            return {\"CANCELLED\"}", "\n\ndef perform_cleanup(meshes, vg, sk, mat):\n    if not isinstance(meshes, list) or len(meshes) == 0:\n        raise Exception(\"Please select at least 1 mesh object!\")\n\n    bpy.ops.object.mode_set(mode=\"OBJECT\")\n\n    for mesh in meshes:\n        if vg:\n            remove_unused_vertex_groups(mesh)\n        if sk:\n            remove_unused_shape_keys(mesh)\n        if mat:\n            remove_unused_materials(mesh)", ""]}
{"filename": "NyaaTools/operators/NyaaToolsAddModifier.py", "chunked_list": ["import traceback\nimport bpy\nfrom bpy.props import StringProperty\n\nfrom ..avatar.get_avatar_armature import get_avatar_armature\nfrom ..common.get_prop import get_prop\nfrom ..common.selection_get_meshes import selection_get_meshes\nfrom ..consts import PROP_AVATAR_LAYERS\n\n\nclass NyaaToolsAddModifier(bpy.types.Operator):\n    \"\"\"Adds a modifier to the selected objects\"\"\"\n\n    bl_idname = \"nyaa.add_modifier\"\n    bl_label = \"Add Modifier\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    # Armature\n    # DataTransfer\n    # Decimate\n    which_modifier: StringProperty(name=\"Which Modifier\", default=\"\")\n\n    def execute(self, context):\n        try:\n            meshes = selection_get_meshes()\n\n            perform_add_modifier(meshes, self.which_modifier)\n            return {\"FINISHED\"}\n        except Exception as error:\n            print(traceback.format_exc())\n            self.report({\"ERROR\"}, str(error))\n            return {\"CANCELLED\"}", "\n\nclass NyaaToolsAddModifier(bpy.types.Operator):\n    \"\"\"Adds a modifier to the selected objects\"\"\"\n\n    bl_idname = \"nyaa.add_modifier\"\n    bl_label = \"Add Modifier\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    # Armature\n    # DataTransfer\n    # Decimate\n    which_modifier: StringProperty(name=\"Which Modifier\", default=\"\")\n\n    def execute(self, context):\n        try:\n            meshes = selection_get_meshes()\n\n            perform_add_modifier(meshes, self.which_modifier)\n            return {\"FINISHED\"}\n        except Exception as error:\n            print(traceback.format_exc())\n            self.report({\"ERROR\"}, str(error))\n            return {\"CANCELLED\"}", "\n\ndef perform_add_modifier(meshes, which_modifier):\n    def move_modifier_to_top(modifier):\n        for i in range(len(modifier.id_data.modifiers)):\n            if modifier == modifier.id_data.modifiers[0]:\n                break\n            bpy.ops.object.modifier_move_up(modifier=modifier.name)\n\n    def search_for_avatar_armature(mesh):\n        key = get_prop(mesh, PROP_AVATAR_LAYERS)\n        if key != None:\n            keySplit = key.split(\",\") if key != \"\" else []\n            for path in keySplit:\n                pathParts = path.split(\"/\") if path != \"\" else []\n                targetAvatarName = pathParts[0].strip()\n                return get_avatar_armature(targetAvatarName)\n        return None\n\n    # Only returns an armature if there is only 1 armature in the scene\n    def search_for_only_armature():\n        ret = None\n        for obj in bpy.data.objects:\n            if obj.type == \"ARMATURE\":\n                if ret != None:\n                    return None\n                ret = obj\n        return ret\n\n    if len(meshes) == 0:\n        raise Exception(\"Please select at least 1 mesh object!\")\n\n    bpy.ops.object.mode_set(mode=\"OBJECT\")\n\n    if which_modifier == \"Armature\":\n        for mesh in meshes:\n            if mesh.type != \"MESH\":\n                continue\n            bpy.context.view_layer.objects.active = mesh\n            name = \"Armature\"\n            mod = mesh.modifiers.get(name)\n            if mod:\n                mesh.modifiers.remove(mod)\n            mod = mesh.modifiers.new(name, \"ARMATURE\")\n            move_modifier_to_top(mod)\n            mod.object = search_for_avatar_armature(mesh)\n            if mod.object == None:\n                mod.object = search_for_only_armature()\n            mod.show_expanded = mod.object == None\n            mod.show_on_cage = True\n            mod.show_in_editmode = True\n            mod.show_viewport = True\n            mod.show_render = True\n            mod.use_deform_preserve_volume = True\n\n    elif which_modifier == \"DataTransfer\":\n        for mesh in meshes:\n            if mesh.type != \"MESH\":\n                continue\n            bpy.context.view_layer.objects.active = mesh\n            name = \"DataTransfer\"\n            mod = mesh.modifiers.get(name)\n            if mod:\n                mesh.modifiers.remove(mod)\n            mod = mesh.modifiers.new(name, \"DATA_TRANSFER\")\n            move_modifier_to_top(mod)\n            mod.show_expanded = True\n            mod.show_on_cage = True\n            mod.show_in_editmode = True\n            mod.use_vert_data = True\n            mod.data_types_verts = {\"VGROUP_WEIGHTS\"}\n            mod.vert_mapping = \"POLYINTERP_NEAREST\"\n\n    elif which_modifier == \"Decimate\":\n        for mesh in meshes:\n            if mesh.type != \"MESH\":\n                continue\n            bpy.context.view_layer.objects.active = mesh\n            name = \"Final - Decimate\"\n            mod = mesh.modifiers.get(name)\n            if mod:\n                mesh.modifiers.remove(mod)\n            mod = mesh.modifiers.new(name, \"DECIMATE\")\n            mod.show_expanded = False\n            mod.show_render = False\n            mod.decimate_type = \"COLLAPSE\"\n            mod.ratio = 0.75\n            mod.delimit = {\"NORMAL\", \"MATERIAL\", \"SEAM\", \"SHARP\", \"UV\"}\n            mod.use_dissolve_boundaries = True\n\n            name = \"Final - Triangulate\"\n            mod = mesh.modifiers.get(name)\n            if mod:\n                mesh.modifiers.remove(mod)\n            mod = mesh.modifiers.new(name, \"TRIANGULATE\")\n            mod.show_expanded = False\n            mod.show_in_editmode = False\n            mod.show_render = False\n            mod.min_vertices = 5\n\n    elif which_modifier == \"Outline\":\n        for mesh in meshes:\n            if mesh.type != \"MESH\":\n                continue\n            bpy.context.view_layer.objects.active = mesh\n            name = \"-- Outline\"\n            mod = mesh.modifiers.get(name)\n            if mod:\n                mesh.modifiers.remove(mod)\n            mod = mesh.modifiers.new(name, \"SOLIDIFY\")\n            move_modifier_to_top(mod)\n            mod.show_expanded = False\n            mod.show_on_cage = False\n            mod.show_in_editmode = False\n            mod.thickness = -0.001\n            mod.use_rim = True\n            mod.use_rim_only = False\n            mod.use_flip_normals = True\n            mod.material_offset = 100\n            mod.material_offset_rim = 100\n            mod.use_quality_normals = True\n\n            if \"-- Outline\" in mesh.vertex_groups:\n                mod.vertex_group = \"-- Outline\"\n\n            # If anywhere in the list, remove\n            for i in reversed(range(len(mesh.material_slots))):\n                if mesh.material_slots[i].name.startswith(\"-- Outline\"):\n                    mesh.active_material_index = i\n                    bpy.ops.object.material_slot_remove()\n\n            try:\n                mat_outline = bpy.data.materials[\"-- Outline - Black\"]\n            except:\n                # Create it if it doesn't exist\n\n                mat_outline = bpy.data.materials.new(name=\"-- Outline - Black\")\n                mesh.active_material_index = len(mesh.material_slots) - 1\n\n            # Reconfigure\n            mat_outline.use_backface_culling = True\n            mat_outline.blend_method = \"HASHED\"\n            mat_outline.shadow_method = \"NONE\"\n            mat_outline.use_screen_refraction = True\n\n            # Principled BSDF - Transparent Black\n            mat_outline.use_nodes = True\n            mat_outline.node_tree.nodes.clear()\n\n            # Nodes\n            output = mat_outline.node_tree.nodes.new(\"ShaderNodeOutputMaterial\")\n            mix = mat_outline.node_tree.nodes.new(\"ShaderNodeMixShader\")\n            geometry = mat_outline.node_tree.nodes.new(\"ShaderNodeNewGeometry\")\n            transparent = mat_outline.node_tree.nodes.new(\"ShaderNodeBsdfTransparent\")\n            principled = mat_outline.node_tree.nodes.new(\"ShaderNodeBsdfPrincipled\")\n\n            # Mix Shader\n            mat_outline.node_tree.links.new(mix.outputs[0], output.inputs[0])\n\n            # Geomety \"Backface\" to \"Factor\"\n            mat_outline.node_tree.links.new(geometry.outputs[6], mix.inputs[0])\n\n            # Principled to Mix Shader 1st\n            mat_outline.node_tree.links.new(principled.outputs[0], mix.inputs[1])\n            principled.inputs[0].default_value = (0.0, 0.0, 0.0, 1.0)\n            principled.inputs[6].default_value = 0  # Metallic\n            principled.inputs[7].default_value = 0  # Specular\n            principled.inputs[9].default_value = 1  # Roughness\n            principled.inputs[21].default_value = 0.5  # Alpha\n\n            # Transparent to Mix Shader 2nd\n            mat_outline.node_tree.links.new(transparent.outputs[0], mix.inputs[2])\n\n            mesh.data.materials.append(mat_outline)\n\n    else:\n        raise Exception(\"Unknown modifier: \" + which_modifier)", ""]}
{"filename": "NyaaTools/operators/PrzemirApplyTopModifier.py", "chunked_list": ["import traceback\nimport bpy\n\nfrom ..common.deselect_all import deselect_all\nfrom ..common.selection_get_meshes import selection_get_meshes\nfrom .._external.przemir.helper import applyModifierForObjectWithShapeKeys\n\n\nclass PrzemirApplyTopModifier(bpy.types.Operator):\n    \"\"\"Apply the topmost modifier for object with shape keys (GitHub/przemir)\"\"\"\n\n    bl_idname = \"przemir.apply_top_modifier\"\n    bl_label = \"Add Modifier\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    def execute(self, context):\n        try:\n            meshes = selection_get_meshes()\n\n            perform_apply_top_modifier(meshes)\n            return {\"FINISHED\"}\n        except Exception as error:\n            print(traceback.format_exc())\n            self.report({\"ERROR\"}, str(error))\n            return {\"CANCELLED\"}", "class PrzemirApplyTopModifier(bpy.types.Operator):\n    \"\"\"Apply the topmost modifier for object with shape keys (GitHub/przemir)\"\"\"\n\n    bl_idname = \"przemir.apply_top_modifier\"\n    bl_label = \"Add Modifier\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    def execute(self, context):\n        try:\n            meshes = selection_get_meshes()\n\n            perform_apply_top_modifier(meshes)\n            return {\"FINISHED\"}\n        except Exception as error:\n            print(traceback.format_exc())\n            self.report({\"ERROR\"}, str(error))\n            return {\"CANCELLED\"}", "\n\ndef perform_apply_top_modifier(meshes):\n    if not isinstance(meshes, list) or len(meshes) == 0:\n        raise Exception(\"Please select at least 1 mesh object!\")\n\n    wm = bpy.context.window_manager\n\n    # Progress count, total\n    progress = [0]\n    progress_total = 0\n\n    def callback_progress_tick():\n        progress[0] = progress[0] + 1\n        wm.progress_update(progress[0] / progress_total * 100)\n\n    # Progress Total: Shape key apply is:\n    # - Total number meshes\n    # - Total number of shape keys in all meshes\n    progress_total += len(meshes)\n    for mesh in meshes:\n        if mesh.data.shape_keys != None:\n            progress_total += len(mesh.data.shape_keys.key_blocks)\n\n    ######################\n    ##  Begin progress  ##\n\n    bpy.ops.object.mode_set(mode=\"OBJECT\")\n\n    wm.progress_begin(0, 100)\n\n    for mesh in meshes:\n        if 0 < len(mesh.modifiers):\n            bpy.context.view_layer.objects.active = mesh\n\n            modifier = mesh.modifiers[0]\n\n            applyModifierForObjectWithShapeKeys(\n                bpy.context,\n                [modifier.name],\n                True,\n                callback_progress_tick,\n            )\n\n    wm.progress_end()", ""]}
{"filename": "NyaaTools/operators/NyaaToolsConfigureMeshesOnAvatar.py", "chunked_list": ["import bpy\nfrom bpy.props import StringProperty\nimport traceback\n\nfrom ..avatar.add_to_avatar_layer import add_to_avatar_layer\nfrom ..avatar.get_avatar_armature import get_avatar_armature\nfrom ..common.get_prop import get_prop\nfrom ..common.has_value import has_value\nfrom ..common.selection_get_armature import selection_get_armature\nfrom ..common.selection_get_meshes import selection_get_meshes", "from ..common.selection_get_armature import selection_get_armature\nfrom ..common.selection_get_meshes import selection_get_meshes\nfrom ..consts import PROP_AVATAR_NAME\n\n\nclass NyaaToolsConfigureMeshesOnAvatar(bpy.types.Operator):\n    \"\"\"Configure meshes on avatar\"\"\"\n    bl_idname = \"nyaa.configure_meshes_on_avatar\"\n    bl_label = \"Add Meshes to Avatar\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    layer_name: StringProperty(name=\"Layer Name\", default=\"\")\n\n    def execute(self, context):\n        try:\n            if not has_value(self.layer_name):\n                self.report({\"INFO\"}, \"Please enter a layer name\")\n                return {\"FINISHED\"}\n\n            armature = selection_get_armature()\n            meshes = selection_get_meshes()\n\n            perform_add_meshes_to_avatar(\n                armature,\n                meshes,\n                self.layer_name,\n            )\n            self.report({\"INFO\"},\n                        str(len(meshes)) + \" assigned to \" + self.layer_name)\n            return {\"FINISHED\"}\n        except Exception as error:\n            print(traceback.format_exc())\n            self.report({\"ERROR\"}, str(error))\n            return {\"CANCELLED\"}", "\n\ndef perform_add_meshes_to_avatar(armature, meshes, layer_name):\n    if not isinstance(meshes, list) or len(meshes) == 0:\n        raise Exception(\"Expected at least one mesh\")\n\n    if armature == None or armature.type != \"ARMATURE\":\n        raise Exception(\"Expected an armature\")\n\n    avatar_name = get_prop(armature, PROP_AVATAR_NAME)\n\n    if not has_value(avatar_name):\n        raise Exception(\"Expected an avatar name\")\n\n    if not has_value(layer_name):\n        raise Exception(\"Expected a layer name\")\n\n    # Add all meshes to the avatar layer\n    for mesh in meshes:\n        add_to_avatar_layer(avatar_name, layer_name, mesh)", ""]}
{"filename": "NyaaTools/avatar/remove_from_avatar_layers.py", "chunked_list": ["from .get_avatar_layers import get_avatar_layers\nfrom ..common.set_prop import set_prop\nfrom ..consts import PROP_AVATAR_LAYERS\n\n\ndef remove_from_avatar_layers(avatar_name, mesh):\n    layers = get_avatar_layers(mesh)\n    layers = [layer for layer in layers if layer[0] != avatar_name]\n\n    # Map and join pairs with /\n    layers = [\"/\".join(pair) for pair in layers]\n\n    # Join strings with ,\n    layers = \",\".join(layers)\n\n    set_prop(mesh, PROP_AVATAR_LAYERS, layers)", ""]}
{"filename": "NyaaTools/avatar/get_avatar_layers.py", "chunked_list": ["from ..common.get_prop import get_prop\nfrom ..consts import PROP_AVATAR_LAYERS\n\n\ndef get_avatar_layers(mesh):\n    ret = []\n    layers = get_prop(mesh, PROP_AVATAR_LAYERS)\n    if (layers != None):\n        split = layers.split(\",\") if layers != \"\" else []\n        for path in split:\n            path_parts = path.split(\"/\") if path != \"\" else []\n            path_avatar_name = path_parts[0]\n            path_layer_name = path_parts[1]\n            ret.append([path_avatar_name, path_layer_name])\n    return ret", ""]}
{"filename": "NyaaTools/avatar/asserts.py", "chunked_list": ["import bpy\n\n\ndef assert_uv_match(obj1, obj2):\n    if (obj1 == None):\n        raise BaseException(\"assertUVMatch() :: Expected an object, got: None\")\n    if (obj2 == None):\n        raise BaseException(\"assertUVMatch() :: Expected an object, got: None\")\n\n    if (len(obj1.data.uv_layers) != len(obj2.data.uv_layers)):\n        raise BaseException(\n            \"Objects have mismatched UV sets: [\" + obj1.name + \"] [\" + obj2.name + \"]\")", "\n\ndef assert_exists(name):\n    obj = bpy.context.scene.objects.get(name)\n    obj.hide_set(False)\n    obj.select_set(False)\n"]}
{"filename": "NyaaTools/avatar/add_to_avatar_layer.py", "chunked_list": ["from .get_avatar_layers import get_avatar_layers\nfrom ..common.set_prop import set_prop\nfrom ..consts import PROP_AVATAR_LAYERS\n\n\ndef add_to_avatar_layer(avatar_name, layer_name, mesh):\n    if (avatar_name.find(\"/\") != -1 or avatar_name.find(\",\") != -1):\n        raise BaseException(\"Avatar name cannot contain '/' or ','\")\n    if (layer_name.find(\"/\") != -1 or layer_name.find(\",\") != -1):\n        raise BaseException(\"Layer name cannot contain '/' or ','\")\n\n    layers = get_avatar_layers(mesh)\n\n    for i in range(len(layers)):\n        if (layers[i][0] == avatar_name):\n            layers.pop(i)\n            break\n\n    layers.append([avatar_name, layer_name])\n\n    # Map and join pairs with /\n    layers = [\"/\".join(pair) for pair in layers]\n\n    # Join strings with ,\n    layers = \",\".join(layers)\n\n    set_prop(mesh, PROP_AVATAR_LAYERS, layers)", ""]}
{"filename": "NyaaTools/avatar/merge_onto_avatar_layer.py", "chunked_list": ["import bpy\n\nfrom ..avatar.asserts import assert_uv_match\nfrom ..common.deselect_all import deselect_all\nfrom ..common.selection_add import selection_add\nfrom ..mesh.apply_modifiers import apply_modifiers\n\n\ndef merge_onto_avatar_layer(targetName, sourceName, armature=None):\n    def clone_to_export(obj):\n        if obj == None:\n            raise BaseException(\"cloneToExport() :: Expected a mesh object, got: None\")\n\n        copied = obj.copy()\n        if obj.type == \"MESH\":\n            copied.data = copied.data.copy()\n        bpy.data.collections[\"__Export Temp__\"].objects.link(copied)\n        return copied\n\n    source = bpy.context.scene.objects.get(sourceName)\n\n    # Create target if it doesn't exist\n    target = bpy.context.scene.objects.get(targetName)\n    if target != None:\n        # Clone source to be merged onto the target\n        source = clone_to_export(source)\n        apply_modifiers(source)\n\n        # print(\"    [ merge layer ] Copied  \" + source.name + \"  to merge on  \" + targetName)\n\n        # Ensure UV Maps match\n        assert_uv_match(target, source)\n\n        # Merge source onto target\n        deselect_all()\n        selection_add(source)\n        selection_add(target)\n\n        # Join\n        bpy.ops.object.join()\n    else:\n        # Clone source to be renamed as the new target\n        source = clone_to_export(source)\n        source.name = targetName\n        source.data.name = targetName\n        apply_modifiers(source)\n\n        # print(\"    [ new layer ] Copied  \" + source.name + \"  as  \" + targetName)\n\n        if armature != None:\n            source.modifiers.new(name=\"Armature\", type=\"ARMATURE\")\n            source.modifiers[\"Armature\"].object = armature\n            source.parent = armature\n        else:\n            source.parent = None", "def merge_onto_avatar_layer(targetName, sourceName, armature=None):\n    def clone_to_export(obj):\n        if obj == None:\n            raise BaseException(\"cloneToExport() :: Expected a mesh object, got: None\")\n\n        copied = obj.copy()\n        if obj.type == \"MESH\":\n            copied.data = copied.data.copy()\n        bpy.data.collections[\"__Export Temp__\"].objects.link(copied)\n        return copied\n\n    source = bpy.context.scene.objects.get(sourceName)\n\n    # Create target if it doesn't exist\n    target = bpy.context.scene.objects.get(targetName)\n    if target != None:\n        # Clone source to be merged onto the target\n        source = clone_to_export(source)\n        apply_modifiers(source)\n\n        # print(\"    [ merge layer ] Copied  \" + source.name + \"  to merge on  \" + targetName)\n\n        # Ensure UV Maps match\n        assert_uv_match(target, source)\n\n        # Merge source onto target\n        deselect_all()\n        selection_add(source)\n        selection_add(target)\n\n        # Join\n        bpy.ops.object.join()\n    else:\n        # Clone source to be renamed as the new target\n        source = clone_to_export(source)\n        source.name = targetName\n        source.data.name = targetName\n        apply_modifiers(source)\n\n        # print(\"    [ new layer ] Copied  \" + source.name + \"  as  \" + targetName)\n\n        if armature != None:\n            source.modifiers.new(name=\"Armature\", type=\"ARMATURE\")\n            source.modifiers[\"Armature\"].object = armature\n            source.parent = armature\n        else:\n            source.parent = None", ""]}
{"filename": "NyaaTools/avatar/list_avatar_armatures.py", "chunked_list": ["import bpy\n\nfrom ..common.get_prop import get_prop\nfrom ..consts import PROP_AVATAR_NAME\n\n\ndef list_avatar_armatures():\n    armatures = []\n    for obj in bpy.data.objects:\n        if (obj.type == \"ARMATURE\"):\n            key = get_prop(obj, PROP_AVATAR_NAME)\n            if (key != None and key not in armatures):\n                armatures.append(obj.name)\n    return armatures", ""]}
{"filename": "NyaaTools/avatar/get_avatar_armature.py", "chunked_list": ["import bpy\n\nfrom ..common.get_prop import get_prop\nfrom ..consts import PROP_AVATAR_NAME\n\n\ndef get_avatar_armature(avatar_name):\n    for obj in bpy.data.objects:\n        if (obj.type == \"ARMATURE\"):\n            key = get_prop(obj, PROP_AVATAR_NAME)\n            if (key != None):\n                if (key == avatar_name):\n                    return obj\n    return None", ""]}
{"filename": "NyaaTools/avatar/get_avatar_meshes.py", "chunked_list": ["import bpy\n\nfrom ..consts import PROP_AVATAR_LAYERS\nfrom ..common.get_prop import get_prop\n\n\ndef get_avatar_meshes(avatar):\n    meshes = []\n    for obj in bpy.data.objects:\n        if (obj.type == \"MESH\"):\n            key = get_prop(obj, PROP_AVATAR_LAYERS)\n            if (key != None):\n                keySplit = key.split(\",\") if key != \"\" else []\n                for path in keySplit:\n                    pathStart = path.strip()[:len(avatar) + 1]\n                    if (pathStart == avatar + \"/\"):\n                        meshes.append(obj.name)\n    return meshes", ""]}
{"filename": "NyaaTools/armature/clear_pose.py", "chunked_list": ["def clear_pose(armature):\n    for bone in armature.pose.bones:\n        bone.matrix_basis.identity()\n"]}
{"filename": "NyaaTools/armature/normalize_armature_rename_bones.py", "chunked_list": ["import bpy\n\nfrom ..armature.find_bone import find_bone\nfrom ..bone_desc_map import BONE_DESC_MAP\n\n\ndef normalize_armature_rename_bones(armature: bpy.types.Armature):\n    def debug_print(*msgs):\n        print(\"   \", *msgs)\n        return\n\n    def perform_rename(bone_desc_name, bone):\n        if bone.name == bone_desc_name:\n            debug_print(\"Name is good: \", bone.name)\n        else:\n            debug_print(\"Renaming: \", bone.name, \" to \", bone_desc_name)\n            bone.name = bone_desc_name\n\n    debug_print(\"Starting normalize_armature_rename_bones()\")\n\n    # Iterate over descriptors in BONE_DESC_MAP & rename if not the desired name\n    # Breast bones are handled separately\n    for bone_desc_name in BONE_DESC_MAP:\n        bone_desc = BONE_DESC_MAP[bone_desc_name]\n\n        if bone_desc_name.startswith(\"Breast\"):\n            continue\n\n        bone = find_bone(\"edit\", armature, bone_desc_name)\n        if bone == None:\n            if \"optional\" in bone_desc and bone_desc[\"optional\"]:\n                continue\n            else:\n                raise TypeError(\"Couldn't find bone: \" + bone_desc_name)\n\n        perform_rename(bone_desc_name, bone)\n\n        # Check if bone is connected\n        if \"connected\" in bone_desc and bone_desc[\"connected\"]:\n            if not bone.use_connect:\n                debug_print(\"Connecting bone: \", bone.name)\n\n                # Move parent's tail to this head\n                bone.parent.tail = bone.head\n\n                bone.use_connect = True\n        else:\n            if bone.use_connect:\n                debug_print(\"Detaching bone: \", bone.name)\n\n                bone.use_connect = False\n\n    # Handle breast bones\n    using_breast_bones = (\n        find_bone(\"edit\", armature, \"Breast Root\") != None\n        or find_bone(\"edit\", armature, \"Breast.L\") != None\n        or find_bone(\"edit\", armature, \"Breast.R\") != None\n        or find_bone(\"edit\", armature, \"Breast.L\", \"Chest\") != None\n        or find_bone(\"edit\", armature, \"Breast.R\", \"Chest\") != None\n    )\n    if using_breast_bones:\n        breastRoot = find_bone(\"edit\", armature, \"Breast Root\")\n        if breastRoot != None:\n            # Root already exists, just rename it\n            if breastRoot.name == \"Breast Root\":\n                debug_print(\"Name is good: \", breastRoot.name)\n            else:\n                debug_print(\"Renaming: \", breastRoot.name, \" to \", \"Breast Root\")\n                breastRoot.name = \"Breast Root\"\n        else:\n            # No root bone, but there are breast bones, create a new root\n            breastL = find_bone(\"edit\", armature, \"Breast.L\", \"Chest\")\n            breastR = find_bone(\"edit\", armature, \"Breast.R\", \"Chest\")\n\n            if breastL != None and breastR != None:\n                new_z = breastL.head.z\n\n                breastRoot = armature.data.edit_bones.new(\"Breast Root\")\n                breastRoot.head = (0, -0.02, new_z)\n                breastRoot.tail = (0, -0.02, new_z + 0.05)\n                breastRoot.parent = find_bone(\"edit\", armature, \"Chest\")\n                breastL.parent = breastRoot\n                breastR.parent = breastRoot\n\n                debug_print(\"Created new bone: Breast Root\")\n\n        breastL = find_bone(\"edit\", armature, \"Breast.L\")\n        perform_rename(\"Breast.L\", breastL)\n\n        breastR = find_bone(\"edit\", armature, \"Breast.R\")\n        perform_rename(\"Breast.R\", breastR)", ""]}
{"filename": "NyaaTools/armature/find_bone.py", "chunked_list": ["import bpy\n\nfrom .similarity_to_common_names import similarity_to_common_names\nfrom ..bone_desc_map import BONE_DESC_MAP\n\n\n# returns bone or None that is most likely to be the bone_desc_name described in bones_map\ndef find_bone(\n    which,\n    armature: bpy.types.Armature,\n    bone_desc_name: str,\n    parent_override=None,\n) -> bpy.types.EditBone:\n    def debug_print(*msgs):\n        # print(\"   \", *msgs)\n        return\n\n    if which not in [\"edit\", \"pose\"]:\n        raise TypeError(\"which must be either 'edit' or 'pose'\")\n\n    if not isinstance(bone_desc_name, str):\n        raise TypeError(\"bone_desc_name must be type str\")\n\n    # If bone_name not in bones_map, throw exception\n    if bone_desc_name not in BONE_DESC_MAP:\n        raise TypeError(\n            \"[\"\n            + bone_desc_name\n            + \"] not in bones_map! Expected an exact name of a Bone Descriptor.\"\n        )\n\n    def probability_parent(bone_desc_name, bone, stop_counter=0):\n        def debug_print(*msgs):\n            # print(\"   \", \"   \", *msgs)\n            return\n\n        if not isinstance(bone_desc_name, str):\n            raise TypeError(\"bone_desc_name must be type str\")\n\n        # This check only happens if there is a parent to compare\n        if bone.parent and stop_counter < 3:\n            parent_name = bone.parent.name\n            parent_desc_name = \"\"\n\n            if parent_override != None:\n                parent_desc_name = parent_override\n            elif BONE_DESC_MAP[bone_desc_name][\"parent\"]:\n                parent_desc_name = BONE_DESC_MAP[bone_desc_name][\"parent\"]\n\n            if parent_desc_name:\n                # If exact match, return bone\n                if parent_name == parent_desc_name:\n                    debug_print(\"* Exact match \", parent_name, \" == \", parent_desc_name)\n                    return 1\n\n                debug_print(\"Comparing \", parent_name, \" to \", parent_desc_name)\n\n                # If the parent is a match, return the bone\n                if 0.8 <= similarity_to_common_names(parent_name, parent_desc_name):\n                    debug_print(bone.name, \" seems to be \", bone_desc_name)\n                    return probability_parent(\n                        parent_desc_name, bone.parent, stop_counter + 1\n                    )\n                else:\n                    debug_print(\"* Not a match!\")\n                    return 0\n\n        s = similarity_to_common_names(bone.name, bone_desc_name)\n        s += 0.1 * stop_counter\n        if 0.8 <= s:\n            debug_print(\"* Likely match: \", bone.name, \" == \", bone_desc_name)\n            return s\n        else:\n            debug_print(\"* Not a match!\")\n            return 0\n\n    def check_child(bone_desc_name, bone):\n        def debug_print(*msgs):\n            # print(\"   \", \"   \", *msgs)\n            return\n\n        if not isinstance(bone_desc_name, str):\n            raise TypeError(\"bone_desc_name must be type str\")\n\n        for child_bone in bone.children:\n            child_name = child_bone.name\n\n            debug_print(\"Checking child:\", child_name)\n\n            bone_desc = BONE_DESC_MAP[bone_desc_name]\n\n            # Child descriptor\n            if bone_desc[\"children\"]:\n                for child_desc_name in bone_desc[\"children\"]:\n                    debug_print(\"Comparing it to:\", child_desc_name)\n\n                    # If exact match, return bone\n                    if child_name == child_desc_name:\n                        debug_print(\n                            \"* Exact match \", child_name, \" == \", child_desc_name\n                        )\n                        return True\n\n                    # If the child is a match, return the bone\n                    if 0.8 <= similarity_to_common_names(child_name, child_desc_name):\n                        debug_print(\n                            \"* Child is a good match\", bone.name, \" is \", bone_desc_name\n                        )\n                        return True\n\n        return False\n\n    bones = []\n    if which == \"edit\":\n        bpy.ops.object.mode_set(mode=\"EDIT\")\n        bones = armature.data.edit_bones\n    elif which == \"pose\":\n        bpy.ops.object.mode_set(mode=\"POSE\")\n        bones = armature.pose.bones\n\n    bone_matches = []\n\n    # All bones in armature that are similar to the common_names\n    for bone in bones:\n        # If exact match, return bone\n        if bone.name == bone_desc_name:\n            return bone\n\n        # If exists in BONE_DESC_MAP as a different bone, skip\n        if bone.name in BONE_DESC_MAP:\n            continue\n\n        # Depending on mirrorness and x-threshold, skip\n        if BONE_DESC_MAP[bone_desc_name][\"mirror\"]:\n            if abs(bone.head.x) <= 0.001 and abs(bone.tail.x) <= 0.001:\n                continue\n        else:\n            if not (abs(bone.head.x) <= 0.001 and abs(bone.tail.x) <= 0.001):\n                continue\n\n        # If wrong x-axis side, skip\n        if BONE_DESC_MAP[bone_desc_name][\"mirror\"]:\n            if bone_desc_name.endswith(\".L\"):\n                if bone.head.x < 0:\n                    continue\n            elif bone_desc_name.endswith(\".R\"):\n                if 0 < bone.head.x:\n                    continue\n\n        if 0.75 <= similarity_to_common_names(bone.name, bone_desc_name):\n            bone_matches.append(bone)\n\n    debug_print(bone_desc_name + \": Similar names:\", [b.name for b in bone_matches])\n\n    if len(bone_matches) == 0:\n        return None\n\n    # Loop over bone_matches and store pairs of [likeliness, bone]\n    likely_bone = []\n    for bone in bone_matches:\n        if bone.parent:\n            if probability_parent(bone_desc_name, bone):\n                likely_bone.append(\n                    [similarity_to_common_names(bone.name, bone_desc_name), bone]\n                )\n\n    # If a likely one was found, return the max of likely_bone[1]\n    if len(likely_bone):\n        debug_print(\n            bone_desc_name + \": Very likely matches:\",\n            [(b[1].name) for b in likely_bone],\n        )\n        return max(likely_bone, key=lambda b: b[0])[1]\n\n    elif parent_override == None:\n        # Check immediate bones, and if they look like what BONE_DESC_MAP describes, add them to likely_bone\n        for bone in bone_matches:\n            if bone.children:\n                for bone in bone_matches:\n                    if check_child(bone_desc_name, bone):\n                        likely_bone.append(\n                            [\n                                similarity_to_common_names(bone.name, bone_desc_name),\n                                bone,\n                            ]\n                        )\n\n                debug_print(\n                    bone_desc_name + \": Likely matches:\",\n                    [(b[1].name) for b in likely_bone],\n                )\n\n                # If a likely one was found, return it\n                if len(likely_bone):\n                    debug_print(\n                        bone_desc_name + \": Very likely matches:\",\n                        [(b[1].name) for b in likely_bone],\n                    )\n                    return max(likely_bone, key=lambda b: b[0])[1]\n\n    return None", ""]}
{"filename": "NyaaTools/armature/find_meshes_affected_by_armature_modifier.py", "chunked_list": ["import bpy\n\n\ndef find_meshes_affected_by_armature_modifier(armature):\n    ret = []\n    for obj in bpy.data.objects:\n        # Must be a mesh\n        if obj.type != \"MESH\":\n            continue\n\n        mesh = obj\n\n        # Must be using this armature in the \"Armature\" modifier\n        # KNOWN ISSUE: If the mesh uses this armature in 2 armature modifiers, something not good will happen\n        using_armature = False\n        which_modifier = None\n        for mod in mesh.modifiers:\n            if mod.type == \"ARMATURE\":\n                if mod.object == armature:\n                    using_armature = True\n                    which_modifier = mod\n                    break\n        if not using_armature:\n            continue\n\n        # Add to affected_meshes pair: [ mesh, modifier ]\n        ret.append([mesh, which_modifier])\n\n    return ret", ""]}
{"filename": "NyaaTools/armature/align_bone_to_axis.py", "chunked_list": ["import bpy\nfrom mathutils import Matrix, Vector\n\nfrom .find_bone import find_bone\nfrom ..bone_desc_map import BONE_DESC_MAP\n\n\ndef align_bone_to_axis(armature, bone, axis_x, axis_y, axis_z):\n    def debug_print(*msgs):\n        print(\"   \", *msgs)\n        return\n\n    def needs_align(bone, axis_x, axis_y, axis_z):\n        debug_print(\"Checking if bone \", bone.name, \" needs alignment\")\n        head = bone.head\n        tail = bone.tail\n\n        # Offset axis_x, axis_y, axis_z by head\n        target = Vector((head[0] + axis_x, head[1] + axis_y, head[2] + axis_z))\n\n        # Vector from head to tail\n        tv = target - head\n        bv = tail - head\n        rot = tv.rotation_difference(bv)\n\n        # If bone rotation is already aligned, return False\n        if rot.angle == 0:\n            debug_print(\"Bone \", bone.name, \" is already aligned\")\n            return False\n\n        # If the bone is not aligned, return True\n        debug_print(\"Bone \", bone.name, \" is not aligned\")\n        return True\n\n    def _helper_align(bone, axis_x, axis_y, axis_z):\n        # Set target to be 1 meter in an axis direction away from head\n        head = bone.head\n        tail = bone.tail\n\n        # Offset axis_x, axis_y, axis_z by head\n        target = Vector((head[0] + axis_x, head[1] + axis_y, head[2] + axis_z))\n\n        # Vector from head to tail\n        tv = target - head\n        bv = tail - head\n\n        # Quaternion that rotates bv to v\n        rd = bv.rotation_difference(tv)\n        debug_print(\"Rotating bone \", bone.name, \" by \", rd.angle)\n\n        # Matrix that rotates bone to v\n        M = (\n            Matrix.Translation(head)\n            @ rd.to_matrix().to_4x4()\n            @ Matrix.Translation(-head)\n        )\n\n        bone.matrix = M @ bone.matrix\n\n    def set_mode():\n        if isinstance(bone, bpy.types.EditBone):\n            bpy.ops.object.mode_set(mode=\"EDIT\")\n        else:\n            bpy.ops.object.mode_set(mode=\"POSE\")\n\n    # type check\n    if bone == None:\n        raise TypeError(\"Bone was not found\")\n\n    if not isinstance(bone, bpy.types.EditBone) and not isinstance(\n        bone, bpy.types.PoseBone\n    ):\n        raise TypeError(\"Bone must be a EditBone or PoseBone\")\n\n    if isinstance(bone, bpy.types.EditBone):\n        debug_print(\"Aligning bone \", bone.name, \" (EditBone)\")\n    else:\n        debug_print(\"Aligning bone \", bone.name, \" (PoseBone)\")\n\n    set_mode()\n\n    alignment_changed = False\n\n    # If bone ends in .L or .R, apply it on the mirrored bone as well\n    if bone.name.endswith(\".L\") or bone.name.endswith(\".R\"):\n        # Run on bone\n        if needs_align(bone, axis_x, axis_y, axis_z):\n            _helper_align(bone, axis_x, axis_y, axis_z)\n            alignment_changed = True\n\n        # And then the mirrored bone\n        mirrored_bone_name = BONE_DESC_MAP[bone.name][\"mirror\"]\n        debug_print(\"Mirrored bone name: \", mirrored_bone_name)\n\n        if isinstance(bone, bpy.types.EditBone):\n            mirrored_bone = find_bone(\"edit\", armature, mirrored_bone_name)\n        else:\n            mirrored_bone = find_bone(\"pose\", armature, mirrored_bone_name)\n\n        set_mode()\n\n        if mirrored_bone != None:\n            debug_print(\"Mirrored bone found: \", mirrored_bone_name)\n\n            # Run on mirrored bone\n            if needs_align(mirrored_bone, -axis_x, axis_y, axis_z):\n                _helper_align(mirrored_bone, -axis_x, axis_y, axis_z)\n                alignment_changed = True\n    else:\n        # Run it as requested\n        if needs_align(bone, axis_x, axis_y, axis_z):\n            _helper_align(bone, axis_x, axis_y, axis_z)\n            alignment_changed = True\n\n    return alignment_changed", ""]}
{"filename": "NyaaTools/armature/estimate_is_normalized.py", "chunked_list": ["import bpy\n\nfrom ..armature.find_bone import find_bone\nfrom ..bone_desc_map import BONE_DESC_MAP\n\n\ndef estimate_is_normalized(armature: bpy.types.Armature):\n    # Iterate over descriptors in BONE_DESC_MAP & rename if not the desired name\n    for bone_desc_name in BONE_DESC_MAP:\n        bone_desc = BONE_DESC_MAP[bone_desc_name]\n\n        if bone_desc_name.startswith(\"Hand\"):\n            # This is good enough of an estimate.\n            return True\n\n        bone = find_bone(\"edit\", armature, bone_desc_name)\n        if bone == None:\n            return False\n\n        if bone.name != bone_desc_name:\n            return False\n\n        if bone.name == bone_desc_name:\n            # Check if bone is connected\n            if \"connected\" in bone_desc and bone_desc[\"connected\"]:\n                if not bone.use_connect:\n                    return False\n            else:\n                if bone.use_connect:\n                    return False\n\n    # All are good\n    return True", ""]}
{"filename": "NyaaTools/armature/similarity_to_common_names.py", "chunked_list": ["from ..common.string_similarity import string_similarity\nfrom ..bone_desc_map import BONE_DESC_MAP\n\n\ndef similarity_to_common_names(bone_name: str, bone_desc_name: str) -> float:\n    if not isinstance(bone_desc_name, str):\n        raise TypeError(\"bone_desc_name must be type str\")\n\n    common_names = BONE_DESC_MAP[bone_desc_name][\"common_names\"]\n    if common_names:\n        # Return largest string_similarity value\n        return max(\n            string_similarity(bone_name, common_name)\n            for common_name in common_names\n        )\n    else:\n        return string_similarity(bone_name, bone_desc_name)", ""]}
{"filename": "NyaaTools/armature/normalize_armature_roll_bones.py", "chunked_list": ["import math\nimport bpy\n\nfrom ..bone_desc_map import BONE_DESC_MAP\nfrom ..consts import A_POSE_SHOULDER_ANGLE\n\n\ndef normalize_armature_roll_bones(\n    armature: bpy.types.Armature, which_pose, apply_roll=False\n):\n    def debug_print(*msgs):\n        print(\"   \", *msgs)\n        return\n\n    if not isinstance(apply_roll, bool):\n        raise Exception(\"apply_roll must be a boolean\")\n\n    debug_print(\"Starting normalize_armature_roll_bones()\")\n\n    # Switch to edit mode\n    bpy.ops.object.mode_set(mode=\"EDIT\")\n\n    # Iterate over descriptors in BONE_DESC_MAP & reset their roll\n    for bone_desc_name in BONE_DESC_MAP:\n        bone_desc = BONE_DESC_MAP[bone_desc_name]\n\n        if not bone_desc_name in armature.data.edit_bones:\n            continue\n\n        # Get bone\n        bone = armature.data.edit_bones[bone_desc_name]\n\n        # Clear roll instead if !apply_roll\n        if not apply_roll:\n            debug_print(\"Clearing roll of\", bone.name)\n            bone.roll = 0\n            continue\n\n        desc_roll = 0\n\n        if \"roll\" in bone_desc and bone_desc[\"roll\"] != None:\n            desc_roll = bone_desc[\"roll\"]\n\n        if which_pose == \"a-pose\":\n            sw = bone_desc_name.startswith\n\n            # Shoulder\n            if sw(\"Shoulder\"):\n                r = A_POSE_SHOULDER_ANGLE\n                if bone_desc_name.endswith(\".R\"):\n                    r *= -1\n                desc_roll += r\n                debug_print(\"For A-Pose, shoulder\", desc_roll)\n\n            # Arm and below:\n            if (\n                sw(\"Upper Arm\")\n                or sw(\"Lower Arm\")\n                or sw(\"Hand\")\n                or sw(\"Thumb\")\n                or sw(\"Index\")\n                or sw(\"Middle\")\n                or sw(\"Ring\")\n                or sw(\"Little\")\n            ):\n                r = 45\n                if bone_desc_name.endswith(\".R\"):\n                    r *= -1\n                desc_roll += r\n                debug_print(\"For A-Pose, arm and below\", desc_roll)\n\n        if bone.roll != desc_roll:\n            debug_print(\"Setting roll of\", bone.name, \"to\", desc_roll)\n            bone.roll = math.radians(desc_roll)", ""]}
{"filename": "NyaaTools/armature/apply_pose.py", "chunked_list": ["\nimport bpy\n\nfrom .._external.przemir.helper import applyModifierForObjectWithShapeKeys\n\n\ndef apply_pose(armature, mesh_modifier_pairs, callback_progress_tick=None):\n    def debug_print(*msgs):\n        print(\"   \", *msgs)\n        return\n\n    bpy.ops.object.mode_set(mode=\"OBJECT\")\n\n    bpy.ops.object.select_all(action=\"DESELECT\")\n\n    for mesh, modifier in mesh_modifier_pairs:\n        if callback_progress_tick != None:\n            if callback_progress_tick != None:\n                callback_progress_tick()\n\n        # Select the mesh\n        mesh.select_set(True)\n        bpy.context.view_layer.objects.active = mesh\n\n        debug_print(\"Applying pose to mesh \", mesh.name, modifier.name)\n        # Duplicate modifier & apply it\n        modifier_copy = mesh.modifiers.new(modifier.name, modifier.type)\n        debug_print(\"Copied modifier\", modifier_copy.name)\n        modifier_copy.object = modifier.object\n        modifier_copy.use_deform_preserve_volume = True\n\n        # If shape keys exist (note that shape_keys may be None)\n        if mesh.data.shape_keys != None:\n            applyModifierForObjectWithShapeKeys(\n                bpy.context,\n                [modifier_copy.name],\n                True,\n                callback_progress_tick\n            )\n\n        else:\n            bpy.ops.object.modifier_apply(modifier=modifier_copy.name)\n\n        # Unselect\n        mesh.select_set(False)\n        bpy.context.view_layer.objects.active = None\n\n    # Select the armature\n    armature.select_set(True)\n    bpy.context.view_layer.objects.active = armature\n\n    # Set pose as rest pose\n    bpy.ops.object.mode_set(mode=\"POSE\")\n    bpy.ops.pose.armature_apply()", ""]}
{"filename": "NyaaTools/armature/normalize_armature_pose.py", "chunked_list": ["import math\nimport bpy\nfrom mathutils import Vector\n\nfrom .align_bone_to_axis import align_bone_to_axis as abta\nfrom .apply_pose import apply_pose\nfrom .clear_pose import clear_pose\nfrom .find_bone import find_bone\nfrom .find_meshes_affected_by_armature_modifier import (\n    find_meshes_affected_by_armature_modifier,", "from .find_meshes_affected_by_armature_modifier import (\n    find_meshes_affected_by_armature_modifier,\n)\nfrom ..common.deselect_all import deselect_all\nfrom ..common.selection_add import selection_add\nfrom ..consts import A_POSE_SHOULDER_ANGLE\n\n\ndef normalize_armature_pose(\n    armature: bpy.types.Armature,\n    which_pose,\n    apply_rest_pose,\n    callback_progress_tick=None,\n):\n    def debug_print(*msgs):\n        print(\"   \", *msgs)\n        return\n\n    debug_print(\"Starting normalize_armature_pose()\")\n\n    #################\n    # Find all meshes that have an armature modifier with this armature\n    affected_meshes = find_meshes_affected_by_armature_modifier(armature)\n    total_shapekeys = 0\n    for mesh, modifier in affected_meshes:\n        # Show in viewport\n        selection_add(mesh)\n        modifier.show_viewport = True\n        modifier.use_deform_preserve_volume = True\n        mesh.hide_viewport = False\n\n        if mesh.data.shape_keys != None:\n            total_shapekeys += len(mesh.data.shape_keys.key_blocks)\n\n        if callback_progress_tick != None:\n            callback_progress_tick()\n\n    deselect_all()\n    #################\n\n    selection_add(armature)\n    clear_pose(armature)\n\n    should_apply = False\n\n    ################\n    # Ankle Initialization - Point Ankle bone forward without affecting pose\n\n    if abta(armature, find_bone(\"edit\", armature, \"Foot.L\"), 0, -1, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align ankle to y-axis\n\n    eb_toes_l = find_bone(\"edit\", armature, \"Toes.L\")\n    if eb_toes_l:\n        if abta(armature, eb_toes_l, 0, -1, 0):\n            should_apply = True\n        if callback_progress_tick != None:\n            callback_progress_tick()\n\n    eb_toes_r = find_bone(\"edit\", armature, \"Toes.R\")\n    if eb_toes_r:\n        if abta(armature, eb_toes_r, 0, -1, 0):\n            should_apply = True\n        if callback_progress_tick != None:\n            callback_progress_tick()\n\n    ################\n    # Arm\n\n    # Align shoulder to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Shoulder.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align upper arm to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Upper Arm.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align elbow to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Lower Arm.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align wrist to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Hand.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    ################\n    # Shoulder Realignment - Make a temp bone for later\n\n    if apply_rest_pose:\n        pb_shoulder_y = find_bone(\"pose\", armature, \"Shoulder.L\").head.y\n        pb_shoulder_z = find_bone(\"pose\", armature, \"Shoulder.L\").head.z\n\n        bpy.ops.object.mode_set(mode=\"EDIT\")\n        eb_realign_shoulder = armature.data.edit_bones.new(\"__ Shoulder Realign __\")\n\n        eb_shoulder_l = find_bone(\"edit\", armature, \"Shoulder.L\")\n        eb_chest = find_bone(\"edit\", armature, \"Chest\")\n\n        y = eb_shoulder_l.head.y + (eb_shoulder_l.head.y - pb_shoulder_y)\n        z = eb_shoulder_l.head.z + (eb_shoulder_l.head.z - pb_shoulder_z)\n\n        eb_realign_shoulder.head = Vector((0, y, z))\n        eb_realign_shoulder.tail = Vector((0, y, z + 0.1))\n        eb_realign_shoulder.parent = eb_chest\n\n    ################\n    # Body Round 1\n\n    # Edit move hips to thigh's yz-plane\n    hips = find_bone(\"edit\", armature, \"Hips\")\n    thigh = find_bone(\"edit\", armature, \"Upper Leg.L\")\n    if thigh.matrix.translation.z != 0:\n        thigh.matrix.translation.z = 0\n        hips.head.y = thigh.matrix.translation.y\n        hips.head.z = thigh.matrix.translation.z\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align hips to z-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Hips\"), 0, 0, 1):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Move hips to y=0\n    hips = find_bone(\"pose\", armature, \"Hips\")\n    if hips.matrix.translation.y != 0:\n        hips.matrix.translation.y = 0\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    ################\n    # Body Round 2\n\n    # Align spine to z-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Spine\"), 0, 0, 1):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align thigh to z-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Upper Leg.L\"), 0, 0, -1):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Move thigh to y=0\n    thigh_l = find_bone(\"pose\", armature, \"Upper Leg.L\")\n    thigh_r = find_bone(\"pose\", armature, \"Upper Leg.R\")\n    if thigh_l.matrix.translation.y != 0:\n        thigh_l.matrix.translation.y = 0\n        thigh_r.matrix.translation.y = 0\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    ################\n    # Body Round 3\n\n    # Align chest to z-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Chest\"), 0, 0, 1):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align knee to z-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Lower Leg.L\"), 0, 0, -1):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    ################\n    # Body Round 4\n\n    neck = find_bone(\"pose\", armature, \"Neck\")\n\n    # Move neck to z=0\n    if neck.matrix.translation.y != 0:\n        neck.matrix.translation.y = 0\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align neck to z-axis\n    if abta(armature, neck, 0, 0, 1):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Move shoulder to z=0\n    pb_shoulder_l = find_bone(\"pose\", armature, \"Shoulder.L\")\n    pb_shoulder_r = find_bone(\"pose\", armature, \"Shoulder.R\")\n    if (\n        pb_shoulder_l.matrix.translation.y != 0\n        or pb_shoulder_r.matrix.translation.y != 0\n    ):\n        pb_shoulder_l.matrix.translation.y = 0\n        pb_shoulder_r.matrix.translation.y = 0\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align ankle to y-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Foot.L\"), 0, -1, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    ################\n    # Body Round 5\n\n    # Align head to z-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Head\"), 0, 0, 1):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align toes to y-axis\n    pb_toes_l = find_bone(\"pose\", armature, \"Toes.L\")\n    if pb_toes_l:\n        if abta(armature, pb_toes_l, 0, -1, 0):\n            should_apply = True\n        if callback_progress_tick != None:\n            callback_progress_tick()\n\n    ################\n    # Shoulder Realignment - Temporarily attach to realign_temp_bone\n\n    if apply_rest_pose:\n        bpy.ops.object.mode_set(mode=\"EDIT\")\n        eb_realign_shoulder = armature.data.edit_bones[\"__ Shoulder Realign __\"]\n        eb_shoulder_l = find_bone(\"edit\", armature, \"Shoulder.L\")\n        eb_shoulder_r = find_bone(\"edit\", armature, \"Shoulder.R\")\n        eb_shoulder_l.parent = eb_realign_shoulder\n        eb_shoulder_r.parent = eb_realign_shoulder\n\n        bpy.ops.object.mode_set(mode=\"POSE\")\n        pb_realign_shoulder = armature.pose.bones[\"__ Shoulder Realign __\"]\n        if abta(armature, pb_realign_shoulder, 0, 0, 1):\n            should_apply = True\n\n    ################\n    # Fingers Round 1\n\n    # Align \"Thumb 1\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Thumb 1.L\"), 1, -1, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Index Finger 1\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Index Finger 1.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Middle Finger 1\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Middle Finger 1.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Ring Finger 1\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Ring Finger 1.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Little Finger 1\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Little Finger 1.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    ################\n    # Fingers Round 2\n\n    # Align \"Thumb 2\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Thumb 2.L\"), 1, -1, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Index Finger 2\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Index Finger 2.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Middle Finger 2\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Middle Finger 2.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Ring Finger 2\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Ring Finger 2.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Little Finger 2\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Little Finger 2.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    ################\n    # Fingers Round 3\n\n    # Align \"Thumb 3\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Thumb 3.L\"), 1, -1, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Index Finger 3\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Index Finger 3.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Middle Finger 3\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Middle Finger 3.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Ring Finger 3\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Ring Finger 3.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Little Finger 3\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Little Finger 3.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # A-Pose only\n    if which_pose == \"a-pose\":\n        a = A_POSE_SHOULDER_ANGLE\n        z = math.sin(math.radians(a)) / math.sin(math.radians(90 - a))\n\n        abta(armature, find_bone(\"pose\", armature, \"Shoulder.L\"), 1, 0, -z)\n        abta(armature, find_bone(\"pose\", armature, \"Upper Arm.L\"), 1, 0, -1)\n\n    ################\n    # Apply to all meshes / shape keys\n\n    if apply_rest_pose and should_apply:\n        apply_pose(armature, affected_meshes, callback_progress_tick)\n        clear_pose(armature)\n\n    ################\n    # Shoulder Realignment - Remove temporary realign_temp_bone\n\n    if apply_rest_pose:\n        bpy.ops.object.mode_set(mode=\"EDIT\")\n        eb_realign_shoulder = armature.data.edit_bones[\"__ Shoulder Realign __\"]\n        eb_shoulder_l = find_bone(\"edit\", armature, \"Shoulder.L\")\n        eb_shoulder_r = find_bone(\"edit\", armature, \"Shoulder.R\")\n        eb_chest = find_bone(\"edit\", armature, \"Chest\")\n        eb_shoulder_l.parent = eb_chest\n        eb_shoulder_r.parent = eb_chest\n        armature.data.edit_bones.remove(eb_realign_shoulder)\n\n    ################\n    # Eye Length\n\n    DEFAULT_LENGTH = 0.05\n    eb_eye_l = find_bone(\"edit\", armature, \"Eye.L\")\n    eb_eye_r = find_bone(\"edit\", armature, \"Eye.R\")\n    if (eb_eye_l.tail.z - eb_eye_l.head.z) != DEFAULT_LENGTH:\n        eb_eye_l.tail.x = eb_eye_l.head.x\n        eb_eye_l.tail.y = eb_eye_l.head.y\n        eb_eye_l.tail.z = eb_eye_l.head.z + DEFAULT_LENGTH\n\n        eb_eye_r.tail.x = eb_eye_r.head.x\n        eb_eye_r.tail.y = eb_eye_r.head.y\n        eb_eye_r.tail.z = eb_eye_r.head.z + DEFAULT_LENGTH\n\n    ################\n    # Breast Root\n\n    eb_breast_root = find_bone(\"edit\", armature, \"Breast Root\")\n    if eb_breast_root:\n        eb_chest = find_bone(\"edit\", armature, \"Chest\")\n        eb_breast_l = find_bone(\"edit\", armature, \"Breast.L\")\n\n        eb_breast_root.head = (\n            0,\n            eb_chest.head.y - 0.02,\n            eb_breast_l.head.z,\n        )\n\n        eb_breast_root.tail = (\n            0,\n            eb_chest.head.y - 0.02,\n            eb_breast_l.head.z + DEFAULT_LENGTH,\n        )", "def normalize_armature_pose(\n    armature: bpy.types.Armature,\n    which_pose,\n    apply_rest_pose,\n    callback_progress_tick=None,\n):\n    def debug_print(*msgs):\n        print(\"   \", *msgs)\n        return\n\n    debug_print(\"Starting normalize_armature_pose()\")\n\n    #################\n    # Find all meshes that have an armature modifier with this armature\n    affected_meshes = find_meshes_affected_by_armature_modifier(armature)\n    total_shapekeys = 0\n    for mesh, modifier in affected_meshes:\n        # Show in viewport\n        selection_add(mesh)\n        modifier.show_viewport = True\n        modifier.use_deform_preserve_volume = True\n        mesh.hide_viewport = False\n\n        if mesh.data.shape_keys != None:\n            total_shapekeys += len(mesh.data.shape_keys.key_blocks)\n\n        if callback_progress_tick != None:\n            callback_progress_tick()\n\n    deselect_all()\n    #################\n\n    selection_add(armature)\n    clear_pose(armature)\n\n    should_apply = False\n\n    ################\n    # Ankle Initialization - Point Ankle bone forward without affecting pose\n\n    if abta(armature, find_bone(\"edit\", armature, \"Foot.L\"), 0, -1, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align ankle to y-axis\n\n    eb_toes_l = find_bone(\"edit\", armature, \"Toes.L\")\n    if eb_toes_l:\n        if abta(armature, eb_toes_l, 0, -1, 0):\n            should_apply = True\n        if callback_progress_tick != None:\n            callback_progress_tick()\n\n    eb_toes_r = find_bone(\"edit\", armature, \"Toes.R\")\n    if eb_toes_r:\n        if abta(armature, eb_toes_r, 0, -1, 0):\n            should_apply = True\n        if callback_progress_tick != None:\n            callback_progress_tick()\n\n    ################\n    # Arm\n\n    # Align shoulder to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Shoulder.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align upper arm to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Upper Arm.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align elbow to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Lower Arm.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align wrist to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Hand.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    ################\n    # Shoulder Realignment - Make a temp bone for later\n\n    if apply_rest_pose:\n        pb_shoulder_y = find_bone(\"pose\", armature, \"Shoulder.L\").head.y\n        pb_shoulder_z = find_bone(\"pose\", armature, \"Shoulder.L\").head.z\n\n        bpy.ops.object.mode_set(mode=\"EDIT\")\n        eb_realign_shoulder = armature.data.edit_bones.new(\"__ Shoulder Realign __\")\n\n        eb_shoulder_l = find_bone(\"edit\", armature, \"Shoulder.L\")\n        eb_chest = find_bone(\"edit\", armature, \"Chest\")\n\n        y = eb_shoulder_l.head.y + (eb_shoulder_l.head.y - pb_shoulder_y)\n        z = eb_shoulder_l.head.z + (eb_shoulder_l.head.z - pb_shoulder_z)\n\n        eb_realign_shoulder.head = Vector((0, y, z))\n        eb_realign_shoulder.tail = Vector((0, y, z + 0.1))\n        eb_realign_shoulder.parent = eb_chest\n\n    ################\n    # Body Round 1\n\n    # Edit move hips to thigh's yz-plane\n    hips = find_bone(\"edit\", armature, \"Hips\")\n    thigh = find_bone(\"edit\", armature, \"Upper Leg.L\")\n    if thigh.matrix.translation.z != 0:\n        thigh.matrix.translation.z = 0\n        hips.head.y = thigh.matrix.translation.y\n        hips.head.z = thigh.matrix.translation.z\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align hips to z-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Hips\"), 0, 0, 1):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Move hips to y=0\n    hips = find_bone(\"pose\", armature, \"Hips\")\n    if hips.matrix.translation.y != 0:\n        hips.matrix.translation.y = 0\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    ################\n    # Body Round 2\n\n    # Align spine to z-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Spine\"), 0, 0, 1):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align thigh to z-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Upper Leg.L\"), 0, 0, -1):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Move thigh to y=0\n    thigh_l = find_bone(\"pose\", armature, \"Upper Leg.L\")\n    thigh_r = find_bone(\"pose\", armature, \"Upper Leg.R\")\n    if thigh_l.matrix.translation.y != 0:\n        thigh_l.matrix.translation.y = 0\n        thigh_r.matrix.translation.y = 0\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    ################\n    # Body Round 3\n\n    # Align chest to z-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Chest\"), 0, 0, 1):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align knee to z-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Lower Leg.L\"), 0, 0, -1):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    ################\n    # Body Round 4\n\n    neck = find_bone(\"pose\", armature, \"Neck\")\n\n    # Move neck to z=0\n    if neck.matrix.translation.y != 0:\n        neck.matrix.translation.y = 0\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align neck to z-axis\n    if abta(armature, neck, 0, 0, 1):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Move shoulder to z=0\n    pb_shoulder_l = find_bone(\"pose\", armature, \"Shoulder.L\")\n    pb_shoulder_r = find_bone(\"pose\", armature, \"Shoulder.R\")\n    if (\n        pb_shoulder_l.matrix.translation.y != 0\n        or pb_shoulder_r.matrix.translation.y != 0\n    ):\n        pb_shoulder_l.matrix.translation.y = 0\n        pb_shoulder_r.matrix.translation.y = 0\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align ankle to y-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Foot.L\"), 0, -1, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    ################\n    # Body Round 5\n\n    # Align head to z-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Head\"), 0, 0, 1):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align toes to y-axis\n    pb_toes_l = find_bone(\"pose\", armature, \"Toes.L\")\n    if pb_toes_l:\n        if abta(armature, pb_toes_l, 0, -1, 0):\n            should_apply = True\n        if callback_progress_tick != None:\n            callback_progress_tick()\n\n    ################\n    # Shoulder Realignment - Temporarily attach to realign_temp_bone\n\n    if apply_rest_pose:\n        bpy.ops.object.mode_set(mode=\"EDIT\")\n        eb_realign_shoulder = armature.data.edit_bones[\"__ Shoulder Realign __\"]\n        eb_shoulder_l = find_bone(\"edit\", armature, \"Shoulder.L\")\n        eb_shoulder_r = find_bone(\"edit\", armature, \"Shoulder.R\")\n        eb_shoulder_l.parent = eb_realign_shoulder\n        eb_shoulder_r.parent = eb_realign_shoulder\n\n        bpy.ops.object.mode_set(mode=\"POSE\")\n        pb_realign_shoulder = armature.pose.bones[\"__ Shoulder Realign __\"]\n        if abta(armature, pb_realign_shoulder, 0, 0, 1):\n            should_apply = True\n\n    ################\n    # Fingers Round 1\n\n    # Align \"Thumb 1\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Thumb 1.L\"), 1, -1, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Index Finger 1\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Index Finger 1.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Middle Finger 1\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Middle Finger 1.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Ring Finger 1\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Ring Finger 1.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Little Finger 1\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Little Finger 1.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    ################\n    # Fingers Round 2\n\n    # Align \"Thumb 2\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Thumb 2.L\"), 1, -1, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Index Finger 2\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Index Finger 2.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Middle Finger 2\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Middle Finger 2.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Ring Finger 2\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Ring Finger 2.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Little Finger 2\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Little Finger 2.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    ################\n    # Fingers Round 3\n\n    # Align \"Thumb 3\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Thumb 3.L\"), 1, -1, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Index Finger 3\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Index Finger 3.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Middle Finger 3\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Middle Finger 3.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Ring Finger 3\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Ring Finger 3.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # Align \"Little Finger 3\" to x-axis\n    if abta(armature, find_bone(\"pose\", armature, \"Little Finger 3.L\"), 1, 0, 0):\n        should_apply = True\n    if callback_progress_tick != None:\n        callback_progress_tick()\n\n    # A-Pose only\n    if which_pose == \"a-pose\":\n        a = A_POSE_SHOULDER_ANGLE\n        z = math.sin(math.radians(a)) / math.sin(math.radians(90 - a))\n\n        abta(armature, find_bone(\"pose\", armature, \"Shoulder.L\"), 1, 0, -z)\n        abta(armature, find_bone(\"pose\", armature, \"Upper Arm.L\"), 1, 0, -1)\n\n    ################\n    # Apply to all meshes / shape keys\n\n    if apply_rest_pose and should_apply:\n        apply_pose(armature, affected_meshes, callback_progress_tick)\n        clear_pose(armature)\n\n    ################\n    # Shoulder Realignment - Remove temporary realign_temp_bone\n\n    if apply_rest_pose:\n        bpy.ops.object.mode_set(mode=\"EDIT\")\n        eb_realign_shoulder = armature.data.edit_bones[\"__ Shoulder Realign __\"]\n        eb_shoulder_l = find_bone(\"edit\", armature, \"Shoulder.L\")\n        eb_shoulder_r = find_bone(\"edit\", armature, \"Shoulder.R\")\n        eb_chest = find_bone(\"edit\", armature, \"Chest\")\n        eb_shoulder_l.parent = eb_chest\n        eb_shoulder_r.parent = eb_chest\n        armature.data.edit_bones.remove(eb_realign_shoulder)\n\n    ################\n    # Eye Length\n\n    DEFAULT_LENGTH = 0.05\n    eb_eye_l = find_bone(\"edit\", armature, \"Eye.L\")\n    eb_eye_r = find_bone(\"edit\", armature, \"Eye.R\")\n    if (eb_eye_l.tail.z - eb_eye_l.head.z) != DEFAULT_LENGTH:\n        eb_eye_l.tail.x = eb_eye_l.head.x\n        eb_eye_l.tail.y = eb_eye_l.head.y\n        eb_eye_l.tail.z = eb_eye_l.head.z + DEFAULT_LENGTH\n\n        eb_eye_r.tail.x = eb_eye_r.head.x\n        eb_eye_r.tail.y = eb_eye_r.head.y\n        eb_eye_r.tail.z = eb_eye_r.head.z + DEFAULT_LENGTH\n\n    ################\n    # Breast Root\n\n    eb_breast_root = find_bone(\"edit\", armature, \"Breast Root\")\n    if eb_breast_root:\n        eb_chest = find_bone(\"edit\", armature, \"Chest\")\n        eb_breast_l = find_bone(\"edit\", armature, \"Breast.L\")\n\n        eb_breast_root.head = (\n            0,\n            eb_chest.head.y - 0.02,\n            eb_breast_l.head.z,\n        )\n\n        eb_breast_root.tail = (\n            0,\n            eb_chest.head.y - 0.02,\n            eb_breast_l.head.z + DEFAULT_LENGTH,\n        )", ""]}
{"filename": "NyaaTools/common/show_message_box.py", "chunked_list": ["import bpy\n\n\ndef show_message_box(message=\"\", title=\"Message Box\", icon=\"INFO\"):\n    def draw(self, context):\n        self.layout.label(text=message)\n\n    bpy.context.window_manager.popup_menu(draw, title=title, icon=icon)\n", ""]}
{"filename": "NyaaTools/common/selection_get_meshes.py", "chunked_list": ["import bpy\n\n\ndef selection_get_meshes():\n    selected_meshes = []\n    for obj in bpy.context.selected_objects:\n        if obj.type == \"MESH\":\n            selected_meshes.append(obj)\n\n    return selected_meshes", ""]}
{"filename": "NyaaTools/common/selection_get_armature.py", "chunked_list": ["import bpy\n\n\ndef selection_get_armature():\n    armature = None\n\n    selected_armatures = []\n    for obj in bpy.context.selected_objects:\n        if obj.type == \"ARMATURE\":\n            selected_armatures.append(obj)\n\n            if len(selected_armatures) == 1:\n                armature = obj\n            else:\n                armature = None\n                break\n\n    return armature", ""]}
{"filename": "NyaaTools/common/select_collection.py", "chunked_list": ["import bpy\n\n\ndef select_collection(name):\n    collections = bpy.context.view_layer.layer_collection.children\n    for collection in collections:\n        if collection.name == name:\n            bpy.context.view_layer.active_layer_collection = collection\n            return collection\n    return None", ""]}
{"filename": "NyaaTools/common/selection_add.py", "chunked_list": ["import bpy\n\n\ndef selection_add(obj, state=True):\n    for col in obj.users_collection:\n        col.hide_viewport = False\n    obj.hide_set(False)\n    obj.select_set(state)\n    bpy.context.view_layer.objects.active = obj\n", ""]}
{"filename": "NyaaTools/common/string_similarity.py", "chunked_list": ["from collections import defaultdict\nimport re\n\n\ndef string_similarity(str1: str, str2: str) -> float:\n    if not isinstance(str1, str):\n        raise TypeError(\"str1 must be str type\")\n    if not isinstance(str2, str):\n        raise TypeError(\"str2 must be str type\")\n\n    # Regex removes substr .001, .002, 01, 02, etc. from name\n    str1 = re.sub(r\"\\.\\d{3}\", \"\", str1)  # Lazy duplicates\n    str1 = re.sub(r\"([^a-z0-9])0+(\\d)\", r\"\\1\\2\", str1)  # Leading 0's\n    str1 = re.sub(r\"(?:_|\\.)\", \" \", str1)  # Underscores & periods\n\n    str2 = re.sub(r\"\\.\\d{3}\", \"\", str2)  # Lazy duplicates\n    str2 = re.sub(r\"([^a-z0-9])0+(\\d)\", r\"\\1\\2\", str2)  # Leading 0's\n    str2 = re.sub(r\"(?:_|\\.)\", \" \", str2)  # Underscores & periods\n\n    # , substring_length: Optional[int] = 2, case_sensitive: Optional[bool] = False\n    substring_length = 2\n    case_sensitive = False\n\n    if not case_sensitive:\n        str1 = str1.lower()\n        str2 = str2.lower()\n    if len(str1) < substring_length or len(str2) < substring_length:\n        return 0\n    substr_count1 = defaultdict(int)\n    for i in range(len(str1) - substring_length + 1):\n        substr1 = str1[i : i + substring_length]\n        substr_count1[substr1] += 1\n    match = 0\n    for j in range(len(str2) - substring_length + 1):\n        substr2 = str2[j : j + substring_length]\n        count = substr_count1[substr2]\n        if count > 0:\n            substr_count1[substr2] = count - 1\n            match += 1\n    return (match * 2) / (len(str1) + len(str2) - ((substring_length - 1) * 2))", ""]}
{"filename": "NyaaTools/common/assertExists.py", "chunked_list": [""]}
{"filename": "NyaaTools/common/set_prop.py", "chunked_list": ["from ..consts import PROP_AVATAR_EXPORT_PATH, PROP_AVATAR_LAYERS, PROP_AVATAR_NAME\n\n\ndef set_prop(obj, key, value):\n    if obj == None:\n        raise Exception(\"Expected an object\")\n\n    # v0 -> v1 Migration\n    fallback_key = None\n    if (key == PROP_AVATAR_NAME):\n        fallback_key = \"avatar\"\n    elif (key == PROP_AVATAR_LAYERS):\n        fallback_key = \"targetAvatars\"\n    elif (key == PROP_AVATAR_EXPORT_PATH):\n        fallback_key = \"exportPath\"\n\n    if fallback_key != None:\n        try:\n            obj[fallback_key] = \"\"\n            del obj[fallback_key]\n        except:\n            pass\n\n    obj[key] = value", ""]}
{"filename": "NyaaTools/common/deselect_all.py", "chunked_list": ["import bpy\n\n\ndef deselect_all():\n    bpy.ops.object.mode_set(mode=\"OBJECT\")\n    bpy.ops.object.select_all(action=\"DESELECT\")\n"]}
{"filename": "NyaaTools/common/get_prop.py", "chunked_list": ["from ..consts import PROP_AVATAR_EXPORT_PATH, PROP_AVATAR_LAYERS, PROP_AVATAR_NAME\n\n\ndef get_prop(obj, key):\n    if obj == None:\n        raise Exception(\"Expected an object\")\n\n    # v0 -> v1 Migration\n    fallback_key = None\n    if (key == PROP_AVATAR_NAME):\n        fallback_key = \"avatar\"\n    elif (key == PROP_AVATAR_LAYERS):\n        fallback_key = \"targetAvatars\"\n    elif (key == PROP_AVATAR_EXPORT_PATH):\n        fallback_key = \"exportPath\"\n\n    if (key in obj.keys()):\n        return obj[key]\n    elif (fallback_key != None and fallback_key in obj.keys()):\n        return obj[fallback_key]\n\n    return None", ""]}
{"filename": "NyaaTools/common/has_value.py", "chunked_list": ["# Primitive positive value check\ndef has_value(value):\n    # check type\n    if value == None:\n        return False\n    if isinstance(value, str):\n        return value.strip() != \"\"\n    elif isinstance(value, bool):\n        return value\n    elif isinstance(value, int) or isinstance(value, float):\n        return value != 0\n    return True", ""]}
{"filename": "NyaaTools/mesh/remove_unused_materials.py", "chunked_list": ["import bpy\n\nfrom ..common.selection_add import selection_add\n\n\ndef remove_unused_materials(obj):\n    def debug_print(*msgs):\n        print(\"   \", *msgs)\n        return\n\n    if obj.type == None:\n        raise BaseException(\"Expected a mesh object, got: None\")\n    if obj.type != \"MESH\":\n        raise BaseException(\"Expected a mesh object, got: \" + obj.type)\n\n    mat_slots = {}\n    for p in obj.data.polygons:\n        mat_slots[p.material_index] = 1\n\n    mat_slots = mat_slots.keys()\n\n    for i in reversed(range(len(obj.material_slots))):\n        if i not in mat_slots:\n            mat_name = obj.material_slots[i].name\n            if mat_name != \"\":\n                mat_name = \" (\" + mat_name + \")\"\n            debug_print(\"Removing material slot: \", obj.name,\n                        \" -> \", i, mat_name)\n\n            selection_add(obj)\n            obj.active_material_index = i\n            bpy.ops.object.material_slot_remove()", ""]}
{"filename": "NyaaTools/mesh/apply_modifiers.py", "chunked_list": ["import bpy\n\nfrom ..common.deselect_all import deselect_all\nfrom ..common.selection_add import selection_add\n\n\ndef apply_modifiers(obj):\n    if (obj == None):\n        raise BaseException(\n            \"applyModifiers() :: Expected a mesh object, got: None\")\n\n    selection_add(obj)\n\n    for modifier in obj.modifiers:\n        if (modifier.name == \"Armature\" or modifier.name.startswith(\"--\")):\n            bpy.ops.object.modifier_remove(modifier=modifier.name)\n        else:\n            bpy.ops.object.modifier_apply(modifier=modifier.name)\n\n    try:\n        bpy.ops.object.transform_apply(\n            location=True, rotation=True, scale=True)\n    except:\n        None\n\n    deselect_all()", ""]}
{"filename": "NyaaTools/mesh/remove_unused_vertex_groups.py", "chunked_list": ["\nimport re\n\n\ndef remove_unused_vertex_groups(obj):\n    def debug_print(*msgs):\n        print(\"   \", *msgs)\n        return\n\n    if obj.type == None:\n        raise BaseException(\"Expected a mesh object, got: None\")\n    if obj.type != \"MESH\":\n        raise BaseException(\"Expected a mesh object, got: \" + obj.type)\n\n    obj.update_from_editmode()\n\n    for i, v in sorted(obj.vertex_groups.items(), reverse=True):\n        if (v.name.startswith(\"--\")):\n            obj.vertex_groups.remove(obj.vertex_groups[i])\n\n    vgroup_used = {i: False for i, k in enumerate(obj.vertex_groups)}\n    vgroup_names = {i: k.name for i, k in enumerate(obj.vertex_groups)}\n\n    for v in obj.data.vertices:\n        for g in v.groups:\n            if g.weight > 0.0:\n                vgroup_used[g.group] = True\n                vgroup_name = vgroup_names[g.group]\n                armatch = re.search(\n                    '((.R|.L)(.(\\d){1,}){0,1})(?!.)', vgroup_name)\n                if armatch != None:\n                    tag = armatch.group()\n                    mirror_tag = tag.replace(\".R\", \".L\") if armatch.group(\n                        2) == \".R\" else tag.replace(\".L\", \".R\")\n                    mirror_vgname = vgroup_name.replace(tag, mirror_tag)\n                    for i, name in sorted(vgroup_names.items(), reverse=True):\n                        if mirror_vgname == name:\n                            vgroup_used[i] = True\n                            break\n\n    for i, used in sorted(vgroup_used.items(), reverse=True):\n        if not used:\n            debug_print(\"Removing vertex group: \",\n                        obj.name, \" -> \", vgroup_names[i])\n            obj.vertex_groups.remove(obj.vertex_groups[i])", ""]}
{"filename": "NyaaTools/mesh/cleanup_mesh.py", "chunked_list": ["from .remove_unused_vertex_groups import remove_unused_vertex_groups\nfrom .remove_unused_shape_keys import remove_unused_shape_keys\nfrom .remove_unused_materials import remove_unused_materials\n\n\ndef cleanup_mesh(obj):\n    if (obj == None):\n        raise BaseException(\n            \"cleanupMesh() :: Expected a mesh object, got: None\")\n    if (obj.type != \"MESH\"):\n        raise BaseException(\"cleanupMesh() :: Expected a mesh object\")\n\n    remove_unused_vertex_groups(obj)\n    remove_unused_shape_keys(obj)\n    remove_unused_materials(obj)", ""]}
{"filename": "NyaaTools/mesh/remove_unused_shape_keys.py", "chunked_list": ["from ..consts import SHAPE_KEY_TOLERANCE\nimport numpy\n\n\ndef remove_unused_shape_keys(obj):\n    def debug_print(*msgs):\n        print(\"   \", *msgs)\n        return\n\n    if obj.type == None:\n        raise BaseException(\"Expected a mesh object, got: None\")\n    if obj.type != \"MESH\":\n        raise BaseException(\"Expected a mesh object, got: \" + obj.type)\n    if not obj.data.shape_keys:\n        debug_print(\"No shape keys. Skipping\", obj.name)\n        return\n    if not obj.data.shape_keys.use_relative:\n        debug_print(\"Shape keys not using relative mode. Skipping\", obj.name)\n        return\n\n    # Get all the key blocks (shape keys) for the mesh\n    kbs = obj.data.shape_keys.key_blocks\n    nverts = len(obj.data.vertices)\n    to_delete = []\n    cache = {}\n\n    # Create an array to store the vertex locations\n    locs = numpy.empty(3 * nverts, dtype=numpy.float32)\n\n    # Loop through all the shape keys for the mesh\n    for kb in kbs:\n        # Skip self\n        if kb == kb.relative_key:\n            continue\n\n        # Get the vertex locations for this shape key\n        kb.data.foreach_get(\"co\", locs)\n\n        # If we haven't already cached the relative key for this shape key,\n        # get the vertex locations for the relative key and cache them\n        if kb.relative_key.name not in cache:\n            rel_locs = numpy.empty(3 * nverts, dtype=numpy.float32)\n            kb.relative_key.data.foreach_get(\"co\", rel_locs)\n            cache[kb.relative_key.name] = rel_locs\n\n        # Get the cached relative key vertex locations\n        rel_locs = cache[kb.relative_key.name]\n\n        # Calculate the largest distance between the relative key and the shape key\n        distances = numpy.abs(locs - rel_locs)\n        largestDistance = numpy.amax(distances)\n\n        # Print the largest distance\n        # debug_print(\"Largest distance for\", kb.name, \"is\", largestDistance)\n\n        # Check if all the vertex locations are within the tolerance\n        if (distances < SHAPE_KEY_TOLERANCE).all():\n            # If so, add this shape key to the list to delete\n            to_delete.append(kb.name)\n\n    # Loop through all the shape keys to delete and remove them from the mesh\n    for kb_name in to_delete:\n        debug_print(\"Removing shape key: \", obj.name, \" -> \", kb_name)\n        obj.shape_key_remove(obj.data.shape_keys.key_blocks[kb_name])\n\n    if len(obj.data.shape_keys.key_blocks) == 1:\n        kb = obj.data.shape_keys.key_blocks[0]\n        debug_print(\"Removing shape key: \", obj.name, \" -> \", kb.name)\n        obj.shape_key_remove(kb)", ""]}
{"filename": "NyaaTools/_external/przemir/helper.py", "chunked_list": ["# ------------------------------------------------------------------------------\n# The MIT License (MIT)\n#\n# Copyright (c) 2015 Przemys\u0142aw B\u0105gard\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is", "# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE", "# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n# ------------------------------------------------------------------------------\n\n# Date: 01 February 2015\n# Blender script", "# Date: 01 February 2015\n# Blender script\n# Description: Apply modifier and remove from the stack for object with shape keys\n# (Pushing 'Apply' button in 'Object modifiers' tab result in an error 'Modifier cannot be applied to a mesh with shape keys').\n\n\nimport bpy\nimport math\nimport time\nfrom bpy.utils import register_class", "import time\nfrom bpy.utils import register_class\nfrom bpy.props import *\n\n\ndef applyModifierForObjectWithShapeKeys(context, selectedModifiers, disable_armatures, callback_progress_tick=None):\n\n    list_properties = []\n    properties = [\"interpolation\", \"mute\", \"name\", \"relative_key\",\n                  \"slider_max\", \"slider_min\", \"value\", \"vertex_group\"]\n    shapesCount = 0\n    vertCount = -1\n    startTime = time.time()\n\n    disabled_armature_modifiers = []\n    if disable_armatures:\n        for modifier in context.object.modifiers:\n            if modifier.name not in selectedModifiers and modifier.type == 'ARMATURE' and modifier.show_viewport == True:\n                disabled_armature_modifiers.append(modifier)\n                modifier.show_viewport = False\n\n    if context.object.data.shape_keys:\n        shapesCount = len(context.object.data.shape_keys.key_blocks)\n\n    if (shapesCount == 0):\n        for modifierName in selectedModifiers:\n            bpy.ops.object.modifier_apply(modifier=modifierName)\n        return (True, None)\n\n    # We want to preserve original object, so all shapes will be joined to it.\n    originalObject = context.view_layer.objects.active\n    bpy.ops.object.select_all(action='DESELECT')\n    originalObject.select_set(True)\n\n    # Copy object which will holds all shape keys.\n    bpy.ops.object.duplicate_move(OBJECT_OT_duplicate={\"linked\": False, \"mode\": 'TRANSLATION'}, TRANSFORM_OT_translate={\"value\": (0, 0, 0), \"orient_type\": 'GLOBAL', \"orient_matrix\": ((1, 0, 0), (0, 1, 0), (0, 0, 1)), \"orient_matrix_type\": 'GLOBAL', \"constraint_axis\": (False, False, False), \"mirror\": True, \"use_proportional_edit\": False, \"proportional_edit_falloff\": 'SMOOTH',\n                                  \"proportional_size\": 1, \"use_proportional_connected\": False, \"use_proportional_projected\": False, \"snap\": False, \"snap_target\": 'CLOSEST', \"snap_point\": (0, 0, 0), \"snap_align\": False, \"snap_normal\": (0, 0, 0), \"gpencil_strokes\": False, \"cursor_transform\": False, \"texture_space\": False, \"remove_on_cancel\": False, \"release_confirm\": False, \"use_accurate\": False})\n    copyObject = context.view_layer.objects.active\n    copyObject.select_set(False)\n\n    # Return selection to originalObject.\n    context.view_layer.objects.active = originalObject\n    originalObject.select_set(True)\n\n    # Save key shape properties\n    for i in range(0, shapesCount):\n        key_b = originalObject.data.shape_keys.key_blocks[i]\n        print(originalObject.data.shape_keys.key_blocks[i].name, key_b.name)\n        properties_object = {p: None for p in properties}\n        properties_object[\"name\"] = key_b.name\n        properties_object[\"mute\"] = key_b.mute\n        properties_object[\"interpolation\"] = key_b.interpolation\n        properties_object[\"relative_key\"] = key_b.relative_key.name\n        properties_object[\"slider_max\"] = key_b.slider_max\n        properties_object[\"slider_min\"] = key_b.slider_min\n        properties_object[\"value\"] = key_b.value\n        properties_object[\"vertex_group\"] = key_b.vertex_group\n        list_properties.append(properties_object)\n\n    # Handle base shape in \"originalObject\"\n    print(\"applyModifierForObjectWithShapeKeys: Applying base shape key\")\n    bpy.ops.object.shape_key_remove(all=True)\n    for modifierName in selectedModifiers:\n        bpy.ops.object.modifier_apply(modifier=modifierName)\n    vertCount = len(originalObject.data.vertices)\n    bpy.ops.object.shape_key_add(from_mix=False)\n    originalObject.select_set(False)\n\n    # Handle other shape-keys: copy object, get right shape-key, apply modifiers and merge with originalObject.\n    # We handle one object at time here.\n    for i in range(1, shapesCount):\n        ###############################\n        # Progress bar callback - Nyaarium\n        if callback_progress_tick != None:\n            callback_progress_tick()\n        ###############################\n\n        currTime = time.time()\n        elapsedTime = currTime - startTime\n\n        print(\"applyModifierForObjectWithShapeKeys: Applying shape key %d/%d ('%s', %0.2f seconds since start)\" %\n              (i+1, shapesCount, list_properties[i][\"name\"], elapsedTime))\n        context.view_layer.objects.active = copyObject\n        copyObject.select_set(True)\n\n        # Copy temp object.\n        bpy.ops.object.duplicate_move(OBJECT_OT_duplicate={\"linked\": False, \"mode\": 'TRANSLATION'}, TRANSFORM_OT_translate={\"value\": (0, 0, 0), \"orient_type\": 'GLOBAL', \"orient_matrix\": ((1, 0, 0), (0, 1, 0), (0, 0, 1)), \"orient_matrix_type\": 'GLOBAL', \"constraint_axis\": (False, False, False), \"mirror\": True, \"use_proportional_edit\": False, \"proportional_edit_falloff\": 'SMOOTH',\n                                      \"proportional_size\": 1, \"use_proportional_connected\": False, \"use_proportional_projected\": False, \"snap\": False, \"snap_target\": 'CLOSEST', \"snap_point\": (0, 0, 0), \"snap_align\": False, \"snap_normal\": (0, 0, 0), \"gpencil_strokes\": False, \"cursor_transform\": False, \"texture_space\": False, \"remove_on_cancel\": False, \"release_confirm\": False, \"use_accurate\": False})\n        tmpObject = context.view_layer.objects.active\n        bpy.ops.object.shape_key_remove(all=True)\n        copyObject.select_set(True)\n        copyObject.active_shape_key_index = i\n\n        # Get right shape-key.\n        bpy.ops.object.shape_key_transfer()\n        context.object.active_shape_key_index = 0\n        bpy.ops.object.shape_key_remove()\n        bpy.ops.object.shape_key_remove(all=True)\n\n        # Time to apply modifiers.\n        for modifierName in selectedModifiers:\n            bpy.ops.object.modifier_apply(modifier=modifierName)\n\n        # Verify number of vertices.\n        if vertCount != len(tmpObject.data.vertices):\n            errorInfo = (\"Shape keys ended up with different number of vertices!\\n\"\n                         \"All shape keys needs to have the same number of vertices after modifier is applied.\\n\"\n                         \"Otherwise joining such shape keys will fail!\")\n            return (False, errorInfo)\n\n        # Join with originalObject\n        copyObject.select_set(False)\n        context.view_layer.objects.active = originalObject\n        originalObject.select_set(True)\n        bpy.ops.object.join_shapes()\n        originalObject.select_set(False)\n        context.view_layer.objects.active = tmpObject\n\n        # Remove tmpObject\n        bpy.ops.object.delete(use_global=False)\n\n    # Restore shape key properties like name, mute etc.\n    context.view_layer.objects.active = originalObject\n    for i in range(0, shapesCount):\n        key_b = context.view_layer.objects.active.data.shape_keys.key_blocks[i]\n        key_b.name = list_properties[i][\"name\"]\n        key_b.interpolation = list_properties[i][\"interpolation\"]\n        key_b.mute = list_properties[i][\"mute\"]\n        key_b.slider_max = list_properties[i][\"slider_max\"]\n        key_b.slider_min = list_properties[i][\"slider_min\"]\n        key_b.value = list_properties[i][\"value\"]\n        key_b.vertex_group = list_properties[i][\"vertex_group\"]\n        rel_key = list_properties[i][\"relative_key\"]\n\n        for j in range(0, shapesCount):\n            key_brel = context.view_layer.objects.active.data.shape_keys.key_blocks[j]\n            if rel_key == key_brel.name:\n                key_b.relative_key = key_brel\n                break\n\n    # Remove copyObject.\n    originalObject.select_set(False)\n    context.view_layer.objects.active = copyObject\n    copyObject.select_set(True)\n    bpy.ops.object.delete(use_global=False)\n\n    # Select originalObject.\n    context.view_layer.objects.active = originalObject\n    context.view_layer.objects.active.select_set(True)\n\n    if disable_armatures:\n        for modifier in disabled_armature_modifiers:\n            modifier.show_viewport = True\n\n    return (True, None)", ""]}
