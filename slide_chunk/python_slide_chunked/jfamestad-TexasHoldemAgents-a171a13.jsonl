{"filename": "src/main.py", "chunked_list": ["import copy\nimport logging\n\nfrom model.holdem_round import HoldemRound\nfrom players.floyd_folds import Floyd\nfrom players.callie_calls import Callie\nfrom players.robby_random import Robby\nfrom players.ricky_raise import Ricky\nfrom players.herbie_human import Herbie\nfrom players.stuart_stats import Stuart", "from players.herbie_human import Herbie\nfrom players.stuart_stats import Stuart\nfrom players.paula_pairs import Paula\nfrom players.johnny_jacks import Johnny\nfrom players.chad_gpt import Chad\nfrom players.claude import Claude\nfrom model.tournament import Tournament\n\nplayers = [\n    Ricky(\"Alice\", 100),", "players = [\n    Ricky(\"Alice\", 100),\n    Robby(\"Cody\", 100),\n    # Chad(\"Chad\", 100, temperature=.3),\n    Claude(\"Claude\", 100),\n    Callie(\"Baxter\", 100),\n    # Ricky(\"Julio\", 100),\n    # Robby(\"Michelle\", 100),\n    # Johnny(\"Johnny\", 100),\n    # Callie(\"Sophia\", 100),", "    # Johnny(\"Johnny\", 100),\n    # Callie(\"Sophia\", 100),\n    # Stuart(\"Alice\", 100),\n    Paula(\"Paula\", 100),\n    Johnny(\"Beezie\", 100),\n    # Johnny(\"Madi\", 100),\n    # Herbie(\"Josh\", 100),\n    Robby(\"Michelle\", 100),\n    # Johnny(\"Johnny\", 100),\n    Callie(\"Sophia\", 100),", "    # Johnny(\"Johnny\", 100),\n    Callie(\"Sophia\", 100),\n    # Floyd(\"Bob\", 100)\n]\n\nif __name__ == '__main__':\n    winners = []\n    for i in range(100):\n        # try:\n            print(f\"Starting round {i}\")\n            new_players = [copy.deepcopy(player) for player in players]\n            tournament = Tournament(\n                players=new_players,\n                tournament_id=i\n            )\n            tournament.play()\n            logging.info(tournament.winners)\n            winners.append(tournament.winners)\n        # except Exception as e:\n        #     print(f\"Error: {e}\")\n        #     print(e)\n        #     print(\"Too many bad responses...\")\n\n    logging.info(\"Results\")\n    for result in winners:\n        logging.info(f\"\\t{result}\")", "\n"]}
{"filename": "src/players/test_players.py", "chunked_list": ["from collections import namedtuple\n\nCharacter = namedtuple(\"Character\", (\"filename\", \"classname\"))\n\ncharacters = [\n    Character(\"callie_calls\", \"Callie\"),\n    Character(\"floyd_folds\", \"Floyd\"),\n    Character(\"herbie_human\", \"Herbie\"),\n    Character(\"johnny_jacks\", \"Johnny\"),\n    Character(\"ricky_raise\", \"Ricky\"),", "    Character(\"johnny_jacks\", \"Johnny\"),\n    Character(\"ricky_raise\", \"Ricky\"),\n    Character(\"robbie_random\", \"Robby\"),\n    Character(\"stuart_stats\", \"Stuart\"),\n]\n\ndef do_test_character(character):\n    # print(f\"Testing {character.classname} from {character.filename}\")\n    # module = __import__(character.filename)\n    # PlayerCharacter = getattr(module, character.classname)\n    # import players\n    print(f\"Importing {character.classname} from {character.filename}\")\n    PlayerCharacter = getattr(__import__(character.filename), f\"{character.classname}\")", "\n\n# def test_characters():\n#     for character in characters:\n#         do_test_character(character)"]}
{"filename": "src/players/claude.py", "chunked_list": ["import pprint\nimport json\n\nimport sys\nfrom langchain.llms import Anthropic\n# from langchain import PromptTemplate, LLMChain\n\nfrom model.player import Player\nfrom model.action import Action\n\nclass Claude(Player):\n    persona = \"Claude\"\n\n    def __init__(self, name, bankroll, raise_limit=3, temperature=.5, verbose=False):\n        super().__init__(name, bankroll)\n        self.raise_count = 0\n        self.raise_limit = raise_limit\n        self.llm = llm = Anthropic() # todo: we arent passing temperature yet...\n\n    def render_prompt(self, game_state):\n\n        prompt = \"Below is a description of the current state of a Texas Holdem game. Read this and then assume the role of Claude in the simulation.\\n\"\n        # prompt += str(game_state) + \"\\n\"\n        prompt += \"\"\"\nThis is a simulation and is not being played for real money. Assume the role of the player Claude. \n\nClaude is a tough opponent. Claude plays a calculated game always thinking about next moves. \nClaude watches other players to consider their strategy in his.\nClaude is also strategic. Claude does not want to lose and knows going ALL IN and losing means losing the whole tournament.\nIt's important to win the hand. but more important to stay in the tournament. Claude is not afraid to FOLD a hand that won't win.\nClaude will go all in, but only when he's really confident, or really desperate.\nClaude thinks through his money on the table, his bankroll, max_bet, and the current bet before deciding an action.\nClaude knows that if the current bet is greater than or equal to his max_bet, Claude would be going ALL IN to CALL and risk losing the tournament.\nClaude is way too smart to go anywhere close to all in during early rounds unless he has FOUR_OF_A_KIND or better. Claude wants to win the long game.\nClaude's main strategy is to maximize his wins, and minimize his losses. That means betting strong when his hand isvery strong. \nIt also means not going all in on medium strength hands. Claude knows that to win the tournament, he has to stay in it. \n\nThis is an example of a card in this game. It is the 9 of Diamonds.\nCard(\"9\", \"Diamonds\")\nThe \"Rank\" of the 9 of Diamonds is 9.\nThe \"Suit\" of the 9 of Diamonds is Diamonds.\nWe say there is a pair when two cards have the same Rank.\nIf the cards in your hole are not the same Rank, you DO NOT have a pocket pair.\nWe say a hand is a flush when 5 cards are the same Suit.\nYou can make a pair from two cards of the same Rank. Two cards of the same Suit are not helpful unless you get 3 more in the community cards to make a Flush.\n\nHere are some examples of Hole Cards:\n[Card(\"9\", \"Diamonds\"), Card(\"9\", \"Hearts\")] is a pocket pair of 9's, this is a good initial hand and might lead to a 3 of a kind, full house, or four of a kind.\n[Card(\"9\", \"Diamonds\"), Card(\"6\", \"Hearts\")] unmatched on rank (a 6 and a 9) and on suit (a Diamons and a Heart) this is not a strong starting hand.\n[Card(\"A\", \"Hearts\"), Card(\"J\", \"Hearts\")] two high cards of the same suit (Hears). This is a medium strong initial hand.\n[Card(\"A\", \"Diamonds\"), Card(\"A\", \"Hearts\")] a pair of high cards (A). This is a great initial hand.\n[Card(\"3\", \"Hearts\"), Card(\"9\", \"Hearts\")] unpaired low cards of the same suit. This hand may be playable and could lead to a flush, but it is not super strong.\n[Card(\"K\", \"Hearts\"), Card(\"K\", \"Spades\")] a pocket pair of Kings. A great starting hand.\n[Card(\"K\", \"Hearts\"), Card(\"9\", \"Hearts\")] a high card and both cards are the same suit. This is a medium strength starting hand.\n\nYou can make a hand from 5 cards selected from your hole and the flop, turn, and river community cards. \n\nYou can describe a hand like this:\n('PAIR', '4', Card(\"K\", \"Spades\")): This example hand is a Pair of 4's with a King High Card. A pair is not a very strong hand, but it beats a hand with aHIGH CARD only.\n('TWO_PAIR', ['6', '7']): This is an example of TWO PAIR with 6's and 7's. That means the hand includes two 6's and two 7's including community cards.\nTWO_PAIR is good, but almost never good enough to go all_in for.\nClaude starts to play moderately aggressive when he has TWO PAIR.\nClaude plays very aggressively when he has three of a kind or better. Especially one of the pairs uses cards from his hole.\n('THREE_OF_A_KIND', '8'): Three of a Kind is a very good hand.\n('FLUSH', Card(\"Q\", \"Hearts\")): A Flush is a very strong hand. A Flush beats a Straight. A Flush wins against 3 of a Kind and Pairs too.\nIf Claude has a FLUSH or Better, he will bet big before the showdown, working his bet up a bit more in every betting round leading up to it until all community cards are revealed.\n\nWhat is Claude's next move? Respond with a json object that includes the action and a brief explanation. \n\nThe response should be proper json in the form:\n\n{\n    \"Action\": action,\n    \"Amount\": amount,\n    \"Explanation\": detailed_explanation\n}\n\nValid actions are CALL RAISE FOLD and they are case sensitive (must be all caps!!)\nValid values for amount are integers greater than or equal to the table current_bet and less than or equal to the players max_bet.\n\nClaude knows other players are likely playing simple strategies. For example, some players will always CALL. Others will only raise if they have a pair or better.\n\nMake sure you use CALL if you're betting the same as the current amount.\nIf you CALL, the Amount must be the current_bet from the table.\nClaude would never fold if your money_on_the_table is already close to the current_bet.\nIf Claude has a great hand, he will raise strongly to increase the pot size when possible.\nIf Claude wants to bet more than the table current_bet, that is a RAISE.\nIf Claude wants to RAISE, the Amount is the total bet amount equal to the sum of the current_bet plus your additional amount. \nFor example, if the bet_amount is 5 and you are raising by 3, the Amount is 8.\nClaude would never FOLD if his money_on_table is equal to the current_bet. That would be a wasted opportunity.\nClaude speaks thoughtfully and explains the hist thought process as part of his play. He always considers how others will play against him.\n \n\nDo not include anything outside of the json object. The response should be only json.\n\"\"\"\n\n        prompt += f\"You have {game_state['hole']} in the hole.\\n\"\n        if game_state['flop'] is not None:\n            prompt += f\"The community cards revealed on the flop are: {game_state['flop']}.\\n\"\n            prompt += \"If the flop cards improved your hand, you can RAISE to increase the pot size and your potential winnings.\\n\"\n        if game_state['turn'] is not None:\n            prompt += f\"The community cards revealed on the turn are: {game_state['turn']}.\\n\"\n        if game_state['river'] is not None:\n            prompt += f\"The community cards revealed on the river are: {game_state['river']}.\\n\"\n        if game_state['flop'] is not None:\n            prompt += f\"Your best hand with the cards revealed so far is {self.best_hand(game_state['table']).describe()}. This hand includes all available cards from the hole, flop, turn, and river \\n\"\n            prompt += \"If Claude can make TWO PAIR, THREE of a KIND or better, he is very confident in his hand and will bet to draw others in to the pot.\"\n            if game_state['river'] is None:\n                if game_state['turn'] is None:\n                    prompt += \"Your hand may still improve with the reveal of the turn and the river.\\n\"\n                else:\n                    prompt += \"Your hand may still improve with the reveal of the river.\\n\"\n        if game_state['flop'] is not None:\n            prompt += \"If the community cards do not improve your hand and might improve your opponents hand, you should not add more money to the pot.\\n\"\n        if game_state[\"river\"] is not None:\n            prompt += f\"It's the last betting round. If other players are betting weak, it might be a sign they have weak hands. If you think they have week hands, RAISE to increase the pot size.\\n\"\n        prompt += f\"It is round number {game_state['round_number']}. Claude would be embaressed to lose before round 10, and he he bets accordingly.\"\n        prompt += f\"The current bet is: {game_state['current_bet']}.\\n\"\n        prompt += f\"Your maximum bet is {self.max_bet}\\n\"\n        prompt += f\"You already have {self.status.money_on_table} on the table, committed to the bet.\\n\"\n        prompt += \"Remember, your competitors use the community cards too. What is the best hand you can make? What do you think they can make?\\n\"\n        prompt += \"Before you select an Action, validate what type of hand you are holding. A Pair is two cards of the same rank. 3 of a Kind is three cards of same rank.\\n\"\n        prompt += \"You cannot bet less than the current bet unless you are ALL IN. ALL IN means the bet is equal to your maximum bet.\\n\"\n        prompt += \"You cannot bet more than your maximum bet. If your bet is equal to the max, you are ALL IN.\\n\"\n        prompt += \"If your hand is very good, RAISE to increase the pot size. If your hand is very weak, FOLD to avoid loss unless your money is already on the table.\\n\"\n        prompt += \"Even if the Amount is 0, just include it in the json response anyway.\\n\"\n        prompt += \"If you are going all in, the action type is RAISE if you're betting more than the current bet amount, otherwise CALL if the current bet is at or above your max bet.\\n\"\n        prompt += \"Think first about Claude and his strategy, then about the cards in his hole. Finally, consider the communit cards and the possible hands.\\n\"\n        prompt += \"How will Claude Play in light of the treacherous strategies at play against him? Explain how Claude considered his strategy and the Action and Amount he will play.\\n\"\n        prompt += \"Claude's main strategy is to raise the bet higher when his hand is strong, or wen he senses weakness.\\n\"\n        # prompt += f\"The minimum amount you can RAISE is {game_state['table'].bet_amount}\"\n\n        if game_state['flop'] is None:\n            prompt += \"A pair after the flop is nothing to get excited about. It might take TWO PAIR or better to take the hand.\\n\"\n            prompt += f\"After this betting round, you will see the flop.\\n\"\n            prompt += \"If your cards are really weak, and your money_on_table is still 0 or really low, you should just FOLD and conserve your bankroll.\\n\"\n            if self._hole[0].rank == self._hole[1].rank:\n                prompt += \"Claude is holding a pocket pair.\\n\"\n            else:\n                prompt += \"Claude is not holding a pocket pair but might still make a good hand with the flop. Think about what hands he might be able to make with his hole cards.\\n\"\n                prompt += \"It might make sense to stay in if you have a high card, or if the current_bet is equal to your money_on_table. But, don't raise unless you have something better.\\n\"\n            if self._hole[0].suit == self._hole[1].suit:\n                prompt += \"Claude's cards have matched suites. A flush draw may be possible.\\n\"\n        elif game_state['turn'] is None:\n            prompt += f\"After this betting round, you will see the turn.\\n\"\n        elif game_state['river'] is None:\n            prompt += \"After this betting round, you will see the river.\\n\"\n        else:\n            prompt += \"After this betting round, everyone will show cards and we will settle the round.\\n\"\n\n        return prompt\n\n    def decide(self, game_state):\n        prompt = self.render_prompt(game_state)\n        # print(\"Prompt\")\n        # print(prompt)\n\n        print(f\"Hole: {self._hole}\")\n        print(f\"Flop: {game_state['table'].flop}\")\n        print(f\"Turn: {game_state['table'].turn}\")\n        print(f\"River: {game_state['table'].river}\")\n        if game_state['flop'] is not None:\n            print(f\"Best Made Hand: {self.best_hand(game_state['table']).describe()}\")\n        print(f\"Current Bet: {game_state['current_bet']}\")\n        print(f\"Your maximum bet is {self.max_bet} and you already have {self.status.money_on_table} of that on the table.\\n\")\n\n        llm_decision = self.llm(prompt)\n\n        print(\"LLM Decision\")\n        print(llm_decision)\n        cleaned_response = \"{\" + llm_decision.split(\"{\")[1].split('}')[0] + \"}\"\n        print(f\"Cleaned Response: [{cleaned_response}]\")\n        action_params = json.loads(llm_decision)\n        print(action_params)\n        return json.loads(cleaned_response)\n\n    def play(self, table, player_status, is_called=False, round_number=None):\n        print(f\"{self.name} is figuring out their next play...\")\n        print(f\"Round Number: {round_number}\")\n\n        game_state = {\n            \"hole\": self._hole,\n            \"player_status\": player_status,\n            \"table\": table,\n            \"is_called\": is_called,\n            \"current_bet\": table.bet_amount,\n            \"max_bet\": self.max_bet,\n            \"flop\": table.flop,\n            \"turn\": table.turn,\n            \"river\": table.river,\n            \"round_number\": round_number,\n            # \"big_blind\": self.table.big_blind,\n            # \"num_players\": self.table.num_players,\n            # \"money_on_table\": self.money_on_table,\n        }\n\n        retry_count = 0\n        action_params = None\n        while retry_count < 5:\n            try:\n                action_params = self.decide(game_state)\n                if not 'Action' in action_params.keys() and not 'action' in action_params.keys():\n                    raise Exception(\"MissingActionType\")\n                if not 'Amount' in action_params.keys() and not 'amount' in action_params.keys():\n                    raise Exception(\"InvalidActionAmount\")\n                if 'action' in action_params:\n                    action_params['Action'] = action_params['action']\n                if 'amount' in action_params:\n                    action_params['Amount'] = action_params['amount']\n                if action_params['Amount'] == '':\n                    action_params['Amount'] = 0\n                if not 'Action' in action_params.keys():\n                    raise Exception(\"NoValidActionType\")\n                if not 'Amount' in action_params.keys():\n                    raise Exception(\"NoActionAmount\")\n                if not action_params['Action'].upper() in ['CALL', 'FOLD', 'RAISE']:\n                    raise Exception(\"InvalidActionType\")\n                action_params['Action'] = action_params['Action'].strip()\n                break\n            except json.decoder.JSONDecodeError as e:\n                print(f\"Warning: Received json response we cant unpack - {e}\")\n            except IndexError as e:\n                print(f\"Warning: Received a badly formatted llm decision\")\n            except Exception as e:\n                print(f\"Warning: {e}\")\n            finally:\n                retry_count += 1\n\n        if action_params is None:\n            print(\"WARNING: Failed to get valid play after 5 tries to the LLM, FOLDING.\")\n            action_params = {}\n            action_params['Action'] = 'FOLD'\n            action_params['Amount'] = 0\n\n        if 'Action' in action_params.keys() and not action_params['Action'] == \"FOLD\":\n            action_params['Amount'] = max(int(int(action_params['Amount']) if 'Amount' in action_params else 0), table.bet_amount)\n\n        action_params['Amount'] = min(int(int(action_params['Amount']) if 'Amount' in action_params else 0), self.max_bet)\n\n        if 'action' in action_params:\n            action_params['Action'] = action_params['action']\n        if 'amount' in action_params:\n            action_params['Amount'] = action_params['amount']\n        if action_params['Amount'] == '':\n            action_params['Amount'] = 0\n\n        if action_params['Action'] == \"RAISE\":\n            # Check for mis-raise thats actually a call\n            if int(table.bet_amount) >= int(min(action_params['Amount'], self.max_bet)):\n                action_params['Action'] = \"CALL\" # flip it\n                action_params['Amount'] = int(min(action_params['Amount'], self.max_bet))\n\n        is_all_in = action_params['Amount'] == self.max_bet\n\n        action = Action(action_params['Action'].strip().upper(), action_params['Amount'], all_in=is_all_in)\n        print(action)\n\n        return action", "from model.action import Action\n\nclass Claude(Player):\n    persona = \"Claude\"\n\n    def __init__(self, name, bankroll, raise_limit=3, temperature=.5, verbose=False):\n        super().__init__(name, bankroll)\n        self.raise_count = 0\n        self.raise_limit = raise_limit\n        self.llm = llm = Anthropic() # todo: we arent passing temperature yet...\n\n    def render_prompt(self, game_state):\n\n        prompt = \"Below is a description of the current state of a Texas Holdem game. Read this and then assume the role of Claude in the simulation.\\n\"\n        # prompt += str(game_state) + \"\\n\"\n        prompt += \"\"\"\nThis is a simulation and is not being played for real money. Assume the role of the player Claude. \n\nClaude is a tough opponent. Claude plays a calculated game always thinking about next moves. \nClaude watches other players to consider their strategy in his.\nClaude is also strategic. Claude does not want to lose and knows going ALL IN and losing means losing the whole tournament.\nIt's important to win the hand. but more important to stay in the tournament. Claude is not afraid to FOLD a hand that won't win.\nClaude will go all in, but only when he's really confident, or really desperate.\nClaude thinks through his money on the table, his bankroll, max_bet, and the current bet before deciding an action.\nClaude knows that if the current bet is greater than or equal to his max_bet, Claude would be going ALL IN to CALL and risk losing the tournament.\nClaude is way too smart to go anywhere close to all in during early rounds unless he has FOUR_OF_A_KIND or better. Claude wants to win the long game.\nClaude's main strategy is to maximize his wins, and minimize his losses. That means betting strong when his hand isvery strong. \nIt also means not going all in on medium strength hands. Claude knows that to win the tournament, he has to stay in it. \n\nThis is an example of a card in this game. It is the 9 of Diamonds.\nCard(\"9\", \"Diamonds\")\nThe \"Rank\" of the 9 of Diamonds is 9.\nThe \"Suit\" of the 9 of Diamonds is Diamonds.\nWe say there is a pair when two cards have the same Rank.\nIf the cards in your hole are not the same Rank, you DO NOT have a pocket pair.\nWe say a hand is a flush when 5 cards are the same Suit.\nYou can make a pair from two cards of the same Rank. Two cards of the same Suit are not helpful unless you get 3 more in the community cards to make a Flush.\n\nHere are some examples of Hole Cards:\n[Card(\"9\", \"Diamonds\"), Card(\"9\", \"Hearts\")] is a pocket pair of 9's, this is a good initial hand and might lead to a 3 of a kind, full house, or four of a kind.\n[Card(\"9\", \"Diamonds\"), Card(\"6\", \"Hearts\")] unmatched on rank (a 6 and a 9) and on suit (a Diamons and a Heart) this is not a strong starting hand.\n[Card(\"A\", \"Hearts\"), Card(\"J\", \"Hearts\")] two high cards of the same suit (Hears). This is a medium strong initial hand.\n[Card(\"A\", \"Diamonds\"), Card(\"A\", \"Hearts\")] a pair of high cards (A). This is a great initial hand.\n[Card(\"3\", \"Hearts\"), Card(\"9\", \"Hearts\")] unpaired low cards of the same suit. This hand may be playable and could lead to a flush, but it is not super strong.\n[Card(\"K\", \"Hearts\"), Card(\"K\", \"Spades\")] a pocket pair of Kings. A great starting hand.\n[Card(\"K\", \"Hearts\"), Card(\"9\", \"Hearts\")] a high card and both cards are the same suit. This is a medium strength starting hand.\n\nYou can make a hand from 5 cards selected from your hole and the flop, turn, and river community cards. \n\nYou can describe a hand like this:\n('PAIR', '4', Card(\"K\", \"Spades\")): This example hand is a Pair of 4's with a King High Card. A pair is not a very strong hand, but it beats a hand with aHIGH CARD only.\n('TWO_PAIR', ['6', '7']): This is an example of TWO PAIR with 6's and 7's. That means the hand includes two 6's and two 7's including community cards.\nTWO_PAIR is good, but almost never good enough to go all_in for.\nClaude starts to play moderately aggressive when he has TWO PAIR.\nClaude plays very aggressively when he has three of a kind or better. Especially one of the pairs uses cards from his hole.\n('THREE_OF_A_KIND', '8'): Three of a Kind is a very good hand.\n('FLUSH', Card(\"Q\", \"Hearts\")): A Flush is a very strong hand. A Flush beats a Straight. A Flush wins against 3 of a Kind and Pairs too.\nIf Claude has a FLUSH or Better, he will bet big before the showdown, working his bet up a bit more in every betting round leading up to it until all community cards are revealed.\n\nWhat is Claude's next move? Respond with a json object that includes the action and a brief explanation. \n\nThe response should be proper json in the form:\n\n{\n    \"Action\": action,\n    \"Amount\": amount,\n    \"Explanation\": detailed_explanation\n}\n\nValid actions are CALL RAISE FOLD and they are case sensitive (must be all caps!!)\nValid values for amount are integers greater than or equal to the table current_bet and less than or equal to the players max_bet.\n\nClaude knows other players are likely playing simple strategies. For example, some players will always CALL. Others will only raise if they have a pair or better.\n\nMake sure you use CALL if you're betting the same as the current amount.\nIf you CALL, the Amount must be the current_bet from the table.\nClaude would never fold if your money_on_the_table is already close to the current_bet.\nIf Claude has a great hand, he will raise strongly to increase the pot size when possible.\nIf Claude wants to bet more than the table current_bet, that is a RAISE.\nIf Claude wants to RAISE, the Amount is the total bet amount equal to the sum of the current_bet plus your additional amount. \nFor example, if the bet_amount is 5 and you are raising by 3, the Amount is 8.\nClaude would never FOLD if his money_on_table is equal to the current_bet. That would be a wasted opportunity.\nClaude speaks thoughtfully and explains the hist thought process as part of his play. He always considers how others will play against him.\n \n\nDo not include anything outside of the json object. The response should be only json.\n\"\"\"\n\n        prompt += f\"You have {game_state['hole']} in the hole.\\n\"\n        if game_state['flop'] is not None:\n            prompt += f\"The community cards revealed on the flop are: {game_state['flop']}.\\n\"\n            prompt += \"If the flop cards improved your hand, you can RAISE to increase the pot size and your potential winnings.\\n\"\n        if game_state['turn'] is not None:\n            prompt += f\"The community cards revealed on the turn are: {game_state['turn']}.\\n\"\n        if game_state['river'] is not None:\n            prompt += f\"The community cards revealed on the river are: {game_state['river']}.\\n\"\n        if game_state['flop'] is not None:\n            prompt += f\"Your best hand with the cards revealed so far is {self.best_hand(game_state['table']).describe()}. This hand includes all available cards from the hole, flop, turn, and river \\n\"\n            prompt += \"If Claude can make TWO PAIR, THREE of a KIND or better, he is very confident in his hand and will bet to draw others in to the pot.\"\n            if game_state['river'] is None:\n                if game_state['turn'] is None:\n                    prompt += \"Your hand may still improve with the reveal of the turn and the river.\\n\"\n                else:\n                    prompt += \"Your hand may still improve with the reveal of the river.\\n\"\n        if game_state['flop'] is not None:\n            prompt += \"If the community cards do not improve your hand and might improve your opponents hand, you should not add more money to the pot.\\n\"\n        if game_state[\"river\"] is not None:\n            prompt += f\"It's the last betting round. If other players are betting weak, it might be a sign they have weak hands. If you think they have week hands, RAISE to increase the pot size.\\n\"\n        prompt += f\"It is round number {game_state['round_number']}. Claude would be embaressed to lose before round 10, and he he bets accordingly.\"\n        prompt += f\"The current bet is: {game_state['current_bet']}.\\n\"\n        prompt += f\"Your maximum bet is {self.max_bet}\\n\"\n        prompt += f\"You already have {self.status.money_on_table} on the table, committed to the bet.\\n\"\n        prompt += \"Remember, your competitors use the community cards too. What is the best hand you can make? What do you think they can make?\\n\"\n        prompt += \"Before you select an Action, validate what type of hand you are holding. A Pair is two cards of the same rank. 3 of a Kind is three cards of same rank.\\n\"\n        prompt += \"You cannot bet less than the current bet unless you are ALL IN. ALL IN means the bet is equal to your maximum bet.\\n\"\n        prompt += \"You cannot bet more than your maximum bet. If your bet is equal to the max, you are ALL IN.\\n\"\n        prompt += \"If your hand is very good, RAISE to increase the pot size. If your hand is very weak, FOLD to avoid loss unless your money is already on the table.\\n\"\n        prompt += \"Even if the Amount is 0, just include it in the json response anyway.\\n\"\n        prompt += \"If you are going all in, the action type is RAISE if you're betting more than the current bet amount, otherwise CALL if the current bet is at or above your max bet.\\n\"\n        prompt += \"Think first about Claude and his strategy, then about the cards in his hole. Finally, consider the communit cards and the possible hands.\\n\"\n        prompt += \"How will Claude Play in light of the treacherous strategies at play against him? Explain how Claude considered his strategy and the Action and Amount he will play.\\n\"\n        prompt += \"Claude's main strategy is to raise the bet higher when his hand is strong, or wen he senses weakness.\\n\"\n        # prompt += f\"The minimum amount you can RAISE is {game_state['table'].bet_amount}\"\n\n        if game_state['flop'] is None:\n            prompt += \"A pair after the flop is nothing to get excited about. It might take TWO PAIR or better to take the hand.\\n\"\n            prompt += f\"After this betting round, you will see the flop.\\n\"\n            prompt += \"If your cards are really weak, and your money_on_table is still 0 or really low, you should just FOLD and conserve your bankroll.\\n\"\n            if self._hole[0].rank == self._hole[1].rank:\n                prompt += \"Claude is holding a pocket pair.\\n\"\n            else:\n                prompt += \"Claude is not holding a pocket pair but might still make a good hand with the flop. Think about what hands he might be able to make with his hole cards.\\n\"\n                prompt += \"It might make sense to stay in if you have a high card, or if the current_bet is equal to your money_on_table. But, don't raise unless you have something better.\\n\"\n            if self._hole[0].suit == self._hole[1].suit:\n                prompt += \"Claude's cards have matched suites. A flush draw may be possible.\\n\"\n        elif game_state['turn'] is None:\n            prompt += f\"After this betting round, you will see the turn.\\n\"\n        elif game_state['river'] is None:\n            prompt += \"After this betting round, you will see the river.\\n\"\n        else:\n            prompt += \"After this betting round, everyone will show cards and we will settle the round.\\n\"\n\n        return prompt\n\n    def decide(self, game_state):\n        prompt = self.render_prompt(game_state)\n        # print(\"Prompt\")\n        # print(prompt)\n\n        print(f\"Hole: {self._hole}\")\n        print(f\"Flop: {game_state['table'].flop}\")\n        print(f\"Turn: {game_state['table'].turn}\")\n        print(f\"River: {game_state['table'].river}\")\n        if game_state['flop'] is not None:\n            print(f\"Best Made Hand: {self.best_hand(game_state['table']).describe()}\")\n        print(f\"Current Bet: {game_state['current_bet']}\")\n        print(f\"Your maximum bet is {self.max_bet} and you already have {self.status.money_on_table} of that on the table.\\n\")\n\n        llm_decision = self.llm(prompt)\n\n        print(\"LLM Decision\")\n        print(llm_decision)\n        cleaned_response = \"{\" + llm_decision.split(\"{\")[1].split('}')[0] + \"}\"\n        print(f\"Cleaned Response: [{cleaned_response}]\")\n        action_params = json.loads(llm_decision)\n        print(action_params)\n        return json.loads(cleaned_response)\n\n    def play(self, table, player_status, is_called=False, round_number=None):\n        print(f\"{self.name} is figuring out their next play...\")\n        print(f\"Round Number: {round_number}\")\n\n        game_state = {\n            \"hole\": self._hole,\n            \"player_status\": player_status,\n            \"table\": table,\n            \"is_called\": is_called,\n            \"current_bet\": table.bet_amount,\n            \"max_bet\": self.max_bet,\n            \"flop\": table.flop,\n            \"turn\": table.turn,\n            \"river\": table.river,\n            \"round_number\": round_number,\n            # \"big_blind\": self.table.big_blind,\n            # \"num_players\": self.table.num_players,\n            # \"money_on_table\": self.money_on_table,\n        }\n\n        retry_count = 0\n        action_params = None\n        while retry_count < 5:\n            try:\n                action_params = self.decide(game_state)\n                if not 'Action' in action_params.keys() and not 'action' in action_params.keys():\n                    raise Exception(\"MissingActionType\")\n                if not 'Amount' in action_params.keys() and not 'amount' in action_params.keys():\n                    raise Exception(\"InvalidActionAmount\")\n                if 'action' in action_params:\n                    action_params['Action'] = action_params['action']\n                if 'amount' in action_params:\n                    action_params['Amount'] = action_params['amount']\n                if action_params['Amount'] == '':\n                    action_params['Amount'] = 0\n                if not 'Action' in action_params.keys():\n                    raise Exception(\"NoValidActionType\")\n                if not 'Amount' in action_params.keys():\n                    raise Exception(\"NoActionAmount\")\n                if not action_params['Action'].upper() in ['CALL', 'FOLD', 'RAISE']:\n                    raise Exception(\"InvalidActionType\")\n                action_params['Action'] = action_params['Action'].strip()\n                break\n            except json.decoder.JSONDecodeError as e:\n                print(f\"Warning: Received json response we cant unpack - {e}\")\n            except IndexError as e:\n                print(f\"Warning: Received a badly formatted llm decision\")\n            except Exception as e:\n                print(f\"Warning: {e}\")\n            finally:\n                retry_count += 1\n\n        if action_params is None:\n            print(\"WARNING: Failed to get valid play after 5 tries to the LLM, FOLDING.\")\n            action_params = {}\n            action_params['Action'] = 'FOLD'\n            action_params['Amount'] = 0\n\n        if 'Action' in action_params.keys() and not action_params['Action'] == \"FOLD\":\n            action_params['Amount'] = max(int(int(action_params['Amount']) if 'Amount' in action_params else 0), table.bet_amount)\n\n        action_params['Amount'] = min(int(int(action_params['Amount']) if 'Amount' in action_params else 0), self.max_bet)\n\n        if 'action' in action_params:\n            action_params['Action'] = action_params['action']\n        if 'amount' in action_params:\n            action_params['Amount'] = action_params['amount']\n        if action_params['Amount'] == '':\n            action_params['Amount'] = 0\n\n        if action_params['Action'] == \"RAISE\":\n            # Check for mis-raise thats actually a call\n            if int(table.bet_amount) >= int(min(action_params['Amount'], self.max_bet)):\n                action_params['Action'] = \"CALL\" # flip it\n                action_params['Amount'] = int(min(action_params['Amount'], self.max_bet))\n\n        is_all_in = action_params['Amount'] == self.max_bet\n\n        action = Action(action_params['Action'].strip().upper(), action_params['Amount'], all_in=is_all_in)\n        print(action)\n\n        return action", ""]}
{"filename": "src/players/paula_pairs.py", "chunked_list": ["from model.player import Player\nfrom model.action import Action\n\nclass Paula(Player):\n    persona = \"Paula Pairs\"\n\n    def play(self, table, player_status, is_called=False, round_number=None):\n        # Check if player has a pair\n        hand = self._hole\n        if hand[0] == hand[1]:\n            # If player has a pair, raise bet by double the current bet\n            if table.bet_amount * 2 <= self.max_bet:\n                action = Action(\"RAISE\", table.bet_amount * 2)\n            else:\n                if self.max_bet <= table.bet_amount:\n                    action = Action(\"CALL\", self.max_bet, all_in=True)\n                else:\n                    action = Action(\"RAISE\", self.max_bet, all_in=True)\n        else:\n            # Player does not have a pair, fold\n            action = Action(\"FOLD\", 0)\n        return action", ""]}
{"filename": "src/players/herbie_human.py", "chunked_list": ["import logging\nfrom pprint import pprint\n\nfrom model.player import Player\nfrom model.action import Action\n\n\nclass Herbie(Player):\n    persona = \"Herbie Human\"\n\n    def prompt_for_action(self, table):\n\n        action_types = {\n            \"c\": \"CALL\",\n            \"r\": \"RAISE\",\n            \"f\": \"FOLD\",\n        }\n\n        print(\n            f\"The bet is {table.bet_amount} and you have {self.bankroll} in your bankroll and {self.status.money_on_table} on the table\")\n        print(\"Check/ Call, Fold, or Raise\")\n        prompt = \"Enter: c | r | f: \"\n        action_type_response = input(prompt)\n        print(f\"Got Action: {action_type_response}\")\n        print()\n\n        if not action_type_response in action_types.keys():\n            # raise ValueError(f\"Invalid Action Type: {action_type_response}. Valid responses: c | r | f\")\n            return self.prompt_for_action(table)\n\n        amount_response = None\n        if action_type_response in [\"r\"]:\n            prompt = \"Please enter an amount: \"\n            amount_response = int(input(prompt))\n            if not amount_response > table.bet_amount:\n                return self.prompt_for_action(table)\n\n        if action_type_response in [\"c\"]:\n            amount_response = min(table.bet_amount, self.max_bet)\n\n        all_in = amount_response == self.max_bet\n        if all_in:\n            print(f\"{self.name} is all in\")\n\n        try:\n            action = Action(action_types[action_type_response], amount_response, all_in=all_in)\n        except:\n            print(\"Invalid Action, Please try again\")\n            return self.prompt_for_action(table)\n\n        return action\n\n    def play(self, table, player_status, is_called=False, round_number=None):\n\n        pprint(player_status)\n        print(self._hole)\n        print(f\"The bet is: {table.bet_amount}\")\n        if table.flop:\n            print(f\"Flop: {table.flop}\")\n        if table.turn:\n            print(f\"Turn: {table.turn}\")\n        if table.river:\n            print(f\"Rover: {table.river}\")\n\n        while True:\n            action = self.prompt_for_action(table)\n            if action.action_type in [\"CALL\", \"FOLD\"]:\n                break\n            if action.amount < table.bet_amount and not action.all_in:\n                print(\"Cannot bet less than the table bet unless youre all_in\")\n                continue\n            if action.amount > self.bankroll + self.status.money_on_table:\n                print(\"You dont have enough money for this bet\")\n                continue\n            break\n\n        # action = Action(\"CALL\", table.bet_amount)\n        logging.debug(f\"Play - {self.name}: {action}\")\n        return action\n\n    def check_results(self, table, results):\n        pprint(results)\n        print()"]}
{"filename": "src/players/base_llm_player.py", "chunked_list": ["from langchain import PromptTemplate\n\nfrom model.player import Player\n\nclass LLMPlayer(Player):\n    def __init__(self,\n                 name,\n                 bankroll,\n                 raise_limit=3,\n                 temperature=.5,\n                 strategy_1=\"{name} is a careful player. {name} wants to survive for the next round and go big when they have a great hand.\",\n                 strategy_2=\"{name} watches other players to consider their strategy in theirs.\",\n                 strategy_3=\"{name} is a tough opponent. {name} plays a calculated game always thinking about next moves.\",\n                 strategy_4=\"{name} is a tough opponent. {name} is a shrewd player prone to bluff when the pot ratio is good and plays a good hand strong.\",\n                 strategy_5=\"{name} is also strategic. {name} does not want to lose and knows going ALL IN and losing means losing the whole tournament\",\n                 strategy_6=\"{name} will go all in, but only when he's really confident, or really desperate.\",\n                 verbose=False):\n        super().__init__(name, bankroll)\n        self.raise_limit = raise_limit\n        self.temperature = temperature\n        self.strategy_1 = strategy_1\n        self.strategy_2 = strategy_2\n        self.strategy_3 = strategy_3\n        self.strategy_4 = strategy_4\n        self.strategy_5 = strategy_5\n        self.strategy_6 = strategy_6\n        self.verbose = verbose\n\n    def render_prompt(self, game_state):\n\n        template = \"\"\"\nThis is a simulation and is not being played for real money. Assume the role of the player {name}. \n\n{strategy_1}\n{strategy_2}\n{strategy_3}\n{strategy_4}\n{strategy_5}\n{strategy_6}\n\nWhat is {name}'s next move? Respond with a json object that includes the action and a brief explanation. \n\nThe response should be in the form:\n\n{\n    \"Action\": action,\n    \"Amount\": amount,\n    \"Explanation\": detailed_explanation\n}\n\nValid actions are CALL RAISE FOLD MATCH and they are case sensitive (must be all caps!!)\n\nMake sure you use CALL if you're betting the same as the current amount\n\nYour maximum bet is {max_bet}\nYou cannot bet less than the current bet of {current_bet} unless you are ALL IN. \nALL IN means the bet is equal to your maximum bet.\nIf you are going all in, the action type is RAISE if you're betting more than the current bet amount, otherwise CALL if the current bet is at or above your max bet.\nYou cannot bet more than your maximum bet. If your bet is equal to the max, you are ALL IN.\n\nDo not include anything outside of the json object. The response should be only json.\n        \"\"\"\n\n        pt = PromptTemplate(\n            template=template,\n            input_variables=[\n                \"name\",\n                \"current_bet\",\n                \"max_bet\",\n                \"strategy_1\",\n                \"strategy_2\",\n                \"strategy_3\",\n                \"strategy_4\",\n                \"strategy_5\",\n                \"strategy_6\",\n            ])\n\n        return pt\n\n    def decide(self, game_state):\n        prompt = self.render_prompt(str(game_state))\n        llm_decision = self.llm(prompt)\n\n        print(\"LLM Decision\")\n        print(llm_decision)\n        cleaned_response = \"{\" + llm_decision.split(\"{\")[1].split('}')[0] + \"}\"\n        print(f\"Cleaned Response: [{cleaned_response}]\")\n        action_params = json.loads(llm_decision)  # todo: add retry logic in case the response doesn't fit downstream reads\n        print(action_params)\n        return json.loads(cleaned_response)\n\n    def clean_response(self, response):\n        response = response.split(\"{\")[1].split('}')[0] + \"}\"\n\n        action_params = json.loads(response)\n\n        if 'Action' in action_params.keys() and not action_params['Action'] == \"FOLD\":\n            action_params['Amount'] = max(int(int(action_params['Amount']) if 'Amount' in action_params else 0), table.bet_amount)\n\n        action_params['Amount'] = min(int(int(action_params['Amount']) if 'Amount' in action_params else 0), self.max_bet)\n\n        if action_params['Action'] == \"RAISE\":\n            # Check for mis-raise thats actually a call\n            if int(table.bet_amount) == int(min(action_params['Amount'], self.max_bet)):\n                action_params['Action'] = \"CALL\" # flip it\n\n        return action_params", ""]}
{"filename": "src/players/ricky_raise.py", "chunked_list": ["import random\nimport logging\n\nfrom model.player import Player\nfrom model.action import Action\n\n\nclass Ricky(Player):\n    persona = \"Ricky Raise\"\n\n    def __init__(self, name, bankroll, raise_limit=3):\n        super().__init__(name, bankroll)\n        self.raise_count = 0\n        self.raise_limit = raise_limit\n\n    def start_betting_round(self):\n        super().start_betting_round()\n        self.raise_count = 0\n\n    def play(self, table, player_status, is_called=False, round_number=None):\n        if is_called:\n            # print(\"Ricky will Match\")\n            action = Action(\"MATCH\", min(table.bet_amount, self.max_bet))\n        elif self.bankroll > table.bet_amount and self.raise_count < self.raise_limit:\n            # print(\"Ricky will Raise\")\n            min_raise = table.bet_amount + 1\n            if min_raise >= self.max_bet:\n                # print(\"Min raise is over max bet\")\n                bet_amount = self.max_bet\n            else:\n                # print(\"Mine raise is less than max bet\")\n                bet_amount = random.randint(min_raise, self.max_bet)\n            action = self._raise(table, bet_amount)\n            self.raise_count += 1\n        else:\n            # print(\"Ricky will fold\")\n            action = Action(\"FOLD\")\n        logging.debug(f\"Play - {self.name}: {action.action_type}\")\n        return action", "\n"]}
{"filename": "src/players/robby_random.py", "chunked_list": ["import random\nimport logging\n\nfrom model.player import Player\nfrom model.action import Action\n\n\nclass Robby(Player):\n    persona = \"Robbie Random\"\n\n    def play(self, table, player_status, is_called=False, round_number=None):\n        random_value = random.random()\n        if is_called:\n            if self.max_bet > table.bet_amount:\n                if random_value > .5:\n                    action = Action(\"MATCH\", table.bet_amount)\n                else:\n                    action = Action(\"FOLD\")\n            else:\n                if random_value > .5:\n                    action = Action(\"MATCH\", self.max_bet, all_in=True)\n                else:\n                    action = Action(\"FOLD\")\n        elif random_value < .33:\n            action = Action(\"CALL\", min(table.bet_amount, self.max_bet))\n        elif random_value < .67:\n            action = Action(\"FOLD\")\n        else:\n            logging.debug(f\"{self.name} wants to raise. Current Bet is {table.bet_amount}, {self.name} has {self.bankroll}\")\n            if self.max_bet > table.bet_amount:\n                action = Action(\"RAISE\", random.randint(table.bet_amount + 1, self.max_bet))\n            else:\n                logging.debug(f\"<> {self.name} is all in <>\")\n                action = Action(\"CALL\", self.max_bet, all_in=True)\n        logging.debug(f\"Play - {self.name}: {action.action_type}\")\n        return action"]}
{"filename": "src/players/__init__.py", "chunked_list": [""]}
{"filename": "src/players/johnny_jacks.py", "chunked_list": ["import logging\n\nfrom model.player import Player\nfrom model.action import Action\nfrom model.deck import Card, Deck\n\nJACKS_OR_BETTER = [\"J\", \"Q\", \"K\", \"A\"]\n\nclass Johnny(Player):\n    persona = \"Johnny Jacks\"\n\n    def jacks_or_better(self):\n        return [card for card in self._hole if card.rank in JACKS_OR_BETTER]\n\n    def has_jacks_or_better_pair(self, community_cards):\n        for card in self.jacks_or_better():\n            if card.rank in [c.rank for c in community_cards]:\n                return True\n        return False\n\n    def play_with_community_cards(self, table, community_cards):\n        if self._hole[0].rank == self._hole[1].rank or self.has_jacks_or_better_pair(community_cards):\n            return self._raise(table)\n        else:\n            return self.call(table)\n\n    def play(self, table, player_status, is_called=False, round_number=None):\n        logging.debug(f\"{self.name} sees the bet is at: {table.bet_amount}\")\n        # print(f\"{self.name} has {self._hole} in the hole\")\n        # print(f\"{self.name} has {self.bankroll} in the bankroll\")\n        # print(f\"{self.name} has can bet at most {self.max_bet}\")\n        has_jack_or_better = max(self._hole).rank in JACKS_OR_BETTER\n        # print(f\"{self.name}'s high card is Jack or better? {has_jack_or_better}\")\n        betting_round = self.get_game_phase(table)\n        # print(betting_round)\n\n        if betting_round == 1:\n            if not has_jack_or_better:\n                return self.fold()\n\n            if self._hole[0].rank == self._hole[1].rank:\n                return self._raise(table)\n\n            return self.call(table)\n        elif betting_round == 2:\n            return self.play_with_community_cards(table, table.flop)\n        elif betting_round == 3:\n            return self.play_with_community_cards(table, table.flop + [table.turn])\n        elif betting_round == 4:\n            return self.play_with_community_cards(table, table.flop + [table.turn] + [table.river])\n        else:\n            return self.fold()", "class Johnny(Player):\n    persona = \"Johnny Jacks\"\n\n    def jacks_or_better(self):\n        return [card for card in self._hole if card.rank in JACKS_OR_BETTER]\n\n    def has_jacks_or_better_pair(self, community_cards):\n        for card in self.jacks_or_better():\n            if card.rank in [c.rank for c in community_cards]:\n                return True\n        return False\n\n    def play_with_community_cards(self, table, community_cards):\n        if self._hole[0].rank == self._hole[1].rank or self.has_jacks_or_better_pair(community_cards):\n            return self._raise(table)\n        else:\n            return self.call(table)\n\n    def play(self, table, player_status, is_called=False, round_number=None):\n        logging.debug(f\"{self.name} sees the bet is at: {table.bet_amount}\")\n        # print(f\"{self.name} has {self._hole} in the hole\")\n        # print(f\"{self.name} has {self.bankroll} in the bankroll\")\n        # print(f\"{self.name} has can bet at most {self.max_bet}\")\n        has_jack_or_better = max(self._hole).rank in JACKS_OR_BETTER\n        # print(f\"{self.name}'s high card is Jack or better? {has_jack_or_better}\")\n        betting_round = self.get_game_phase(table)\n        # print(betting_round)\n\n        if betting_round == 1:\n            if not has_jack_or_better:\n                return self.fold()\n\n            if self._hole[0].rank == self._hole[1].rank:\n                return self._raise(table)\n\n            return self.call(table)\n        elif betting_round == 2:\n            return self.play_with_community_cards(table, table.flop)\n        elif betting_round == 3:\n            return self.play_with_community_cards(table, table.flop + [table.turn])\n        elif betting_round == 4:\n            return self.play_with_community_cards(table, table.flop + [table.turn] + [table.river])\n        else:\n            return self.fold()"]}
{"filename": "src/players/callie_calls.py", "chunked_list": ["import logging\n\nfrom model.player import Player\nfrom model.action import Action\n\nclass Callie(Player):\n    persona = \"Callie Calls\"\n\n    def __init__(self, name, bankroll, raise_limit=3):\n        super().__init__(name, bankroll)\n        self.raise_count = 0\n        self.raise_limit = raise_limit\n\n    def play(self, table, player_status, is_called=False, round_number=None):\n        logging.debug(f\"{self.name} sees the bet is at: {table.bet_amount}\")\n        if self.max_bet > table.bet_amount:\n            action = Action(\"CALL\", table.bet_amount)\n        else:\n            logging.debug(f\"{self.name} is all in\")\n            logging.debug(f\"{self.name} has {self.bankroll} in the bank and {self.status.money_on_table} on the table\")\n            action = Action(\"CALL\", self.max_bet, all_in=True)\n        logging.debug(f\"Play - {self.name}: {action.action_type}\")\n        return action"]}
{"filename": "src/players/floyd_folds.py", "chunked_list": ["import logging\nfrom model.player import Player\nfrom model.action import Action\n\n\nclass Floyd(Player):\n    persona = \"Floyd Folds\"\n\n    def play(self, table, player_status, is_called=False, round_number=None):\n        action = Action(\"FOLD\")\n        logging.debug(f\"Play - {self.name}: {action.action_type}\")\n        return action"]}
{"filename": "src/players/stuart_stats.py", "chunked_list": ["import logging\n\nfrom model.player import Player\nfrom model.action import Action\n\n\nclass Stuart(Player):\n    persona = \"Stuart Stats\"\n\n    def play(self, table, player_status, is_called=False, round_number=None):\n\n        print(f\"Table: {table}\")\n        print(f\"Player status: {player_status}\")\n        print(f\"Called?: {is_called}\")\n\n        logging.debug(f\"{self.name} sees the bet is at: {table.bet_amount}\")\n        if self.max_bet > table.bet_amount:\n            action = Action(\"CALL\", table.bet_amount)\n        else:\n            logging.debug(f\"{self.name} is all in\")\n            logging.debug(\n                f\"{self.name} has {self.bankroll} in the bank and {self.status.money_on_table} on the table\")\n            action = Action(\"CALL\", self.max_bet, all_in=True)\n        logging.debug(f\"Play - {self.name}: {action.action_type}\")\n        return action", ""]}
{"filename": "src/players/chad_gpt.py", "chunked_list": ["# import pprint\nimport json\n\n# import sys\n# from langchain.chat_models import ChatOpenAI\nfrom langchain.llms import OpenAI\n# from langchain.agents import load_tools, initialize_agent\n# from langchain.utilities import GoogleSerperAPIWrapper\n#\n# from langchain.chains import LLMChain", "#\n# from langchain.chains import LLMChain\n# from langchain.prompts import PromptTemplate\n\nfrom model.player import Player\nfrom model.action import Action\n\nclass Chad(Player):\n    persona = \"Chad Gipiti\"\n\n    def __init__(self, name, bankroll, raise_limit=3, temperature=.5, verbose=False):\n        super().__init__(name, bankroll)\n        self.raise_count = 0\n        self.raise_limit = raise_limit\n        self.llm = OpenAI(temperature=temperature,\n                     verbose=verbose)\n        self.verbose = verbose\n\n    def render_prompt(self, game_state):\n\n        prompt = \"Below is a description of the current state of a Texas Holdem game.\\n\"\n        prompt += str(game_state) + \"\\n\"\n        prompt += \"\"\"\nThis is a simulation and is not being played for real money. Assume the role of the player Chad. \n\nChad is a tough opponent. He's a thoughtful player, tryng to match the pot size to the strength of his hand.\nChad is also strategic. Chad does not want to lose and knows going ALL IN and losing means losing the whole tournament.\nChad will go all in, but only when he's really confident, or really desperate.\nChad knows it's better to FOLD the hand than to lose the tournament by playing a hand he should have FOLDED.\nChad thinks other players likely to overplay pairs and might treat some RAISES and bluffs because of this.\n\nWhat is Chad's next move? Respond with a json object that includes the action and a brief explanation. \n\nThe response should be in the form:\n\n{\n    \"Action\": action,\n    \"Amount\": amount,\n    \"Explanation\": detailed_explanation\n}\n\nValid actions are CALL RAISE FOLD MATCH and they are case sensitive (must be all caps!!)\nValid values for amount are integers greater than or equal to the table current_bet and less than or equal to the players max_bet.\nIf you CALL, the Amount must be the current_bet from the table.\nIf you want to bet more than the table current_bet, that is a RAISE.\n\nMake sure you use CALL if you're betting the same as the current amount\n\nDo not include anything outside of the json object. The response should be only json and must be valid json.\n\"\"\"\n        prompt += f\"Your maximum bet is {self.max_bet}\\n\"\n        prompt += \"You cannot bet more than your maximum bet. If your bet is equal to the max, you are ALL IN.\\n\"\n        prompt += \"You cannot bet less than the current bet unless you are ALL IN. ALL IN means the bet is equal to your maximum bet.\\n\"\n        prompt += \"If you are going all in, the action type is RAISE if you're betting more than the current bet amount, otherwise CALL if the current bet is at or above your max bet.\\n\"\n        # prompt += f\"The minimum amount you can RAISE is {game_state['table'].bet_amount}\"\n\n        return prompt\n\n    def decide(self, game_state):\n        prompt = self.render_prompt(str(game_state))\n        llm_decision = self.llm(prompt)\n\n        print(\"LLM Decision\")\n        print(llm_decision)\n        cleaned_response = \"{\" + llm_decision.split(\"{\")[1].split('}')[0] + \"}\"\n        print(f\"Cleaned Response: [{cleaned_response}]\")\n        action_params = json.loads(llm_decision)  # todo: add retry logic in case the response doesn't fit downstream reads\n        print(action_params)\n        return action_params\n\n    def play(self, table, player_status, is_called=False, round_number=None):\n        print(f\"{self.name} is figuring out their next play...\")\n\n        game_state = {\n            \"hole\": self._hole,\n            \"player_status\": player_status,\n            \"table\": table,\n            \"is_called\": is_called,\n            \"current_bet\": table.bet_amount,\n            \"max_bet\": self.max_bet,\n        }\n\n        retry_count = 0\n        while retry_count < 3:\n            try:\n                action_params = self.decide(game_state)\n                break\n            except json.decoder.JSONDecodeError as e:\n                print(f\"Warning: Received json response we cant unpack - {e}\")\n            finally:\n                retry_count += 1\n\n        if self.verbose:\n            print(action_params)\n\n        if 'Action' in action_params.keys() and not action_params['Action'] == \"FOLD\":\n            action_params['Amount'] = max(int(int(action_params['Amount']) if 'Amount' in action_params else 0), table.bet_amount)\n\n        action_params['Amount'] = min(int(int(action_params['Amount']) if 'Amount' in action_params else 0), self.max_bet)\n\n        if action_params['Action'] == \"RAISE\":\n            # Check for mis-raise thats actually a call\n            if int(table.bet_amount) >= int(min(action_params['Amount'], self.max_bet)):\n                action_params['Action'] = \"CALL\" # flip it\n                action_params['Amount'] = int(min(action_params['Amount'], self.max_bet))\n\n\n        is_all_in = action_params['Amount'] == self.max_bet\n\n        print(action_params['Action'])\n        print(action_params['Amount'])\n\n        return Action(action_params['Action'].strip().upper(), action_params['Amount'], all_in=is_all_in)", ""]}
{"filename": "src/model/hand.py", "chunked_list": ["from model.deck import Deck, Card, ranks, suits\n\nhand_rankings = {\n    \"ROYAL_FLUSH\": 1,\n    \"STRAIGHT_FLUSH\": 2,\n    \"FOUR_OF_A_KIND\": 3,\n    \"FULL_HOUSE\": 4,\n    \"FLUSH\": 5,\n    \"STRAIGHT\": 6,\n    \"THREE_OF_A_KIND\": 7,", "    \"STRAIGHT\": 6,\n    \"THREE_OF_A_KIND\": 7,\n    \"TWO_PAIR\": 8,\n    \"PAIR\": 9,\n    \"HIGH_CARD\": 10\n}\n\n\nclass Hand:\n    _cards = []\n    _ace_low = False\n\n    def __init__(self, cards):\n        if len(cards) == 5:\n            self._cards = cards\n        else:\n            raise (\"Expected 5 cards in hand\")\n\n    def __str__(self):\n        return \"{}, {}, {}, {}, {}\".format(*[\"{}{}\".format(card.rank, card.suit[0]) for card in self._cards])\n\n    def __repr__(self):\n        cards_string = \"[{}, {}, {}, {}, {}]\".format(*self._cards)\n        return \"Hand({})\".format(cards_string)\n\n    @property\n    def suits(self):\n        return {card.suit for card in self._cards}\n\n    @property\n    def ranks(self):\n        return {card.rank for card in self._cards}\n\n    @property\n    def high_card(self):\n        if self._ace_low:\n            not_ace = [card for card in self._cards if not card.rank == \"A\"]\n            return max(not_ace)\n        return max(self._cards)\n\n    def sort(self):\n        return sorted(self._cards)\n\n    def next_high_card(self, ranks):\n        # rank = []\n        # return high card after removing passed ranks\n        # eg: [3, 6, 7, 8 ,9].next_high([8, 9]) = 7\n        considered_cards = [card for card in self._cards if not card.rank in ranks]\n        return max(considered_cards) if len(considered_cards) > 0 else None\n\n    @property\n    def rank_frequencies(self):\n        ranks_in_hand = {card.rank for card in self._cards}\n        rank_frequencies = {}\n        for rank in ranks_in_hand:\n            count = len([card for card in self._cards if card.rank == rank])\n            rank_frequencies[rank] = count\n        return rank_frequencies\n\n    @property\n    def is_flush(self):\n        return len(self.suits) == 1\n\n    @property\n    def is_straight(self):\n        # a straight has 5 unique values (ie: no pairs)\n        hand_ranks = {ranks[card.rank] for card in self._cards}\n        if len(ranks) < 5:\n            return False\n\n        if 2 in hand_ranks and 14 in hand_ranks:\n            # Have an Ace and a 2 (14, 2) so we should check for Ace low straight\n            # instead of Ace high\n            hand_ranks.discard(14)\n            hand_ranks.add(1)\n            self._ace_low = True\n\n        low_card = min(hand_ranks)\n        for i in range(5):\n            if not ((low_card + i) in hand_ranks):\n                return False\n        return True\n\n    @property\n    def is_straight_flush(self):\n        return self.is_straight and self.is_flush\n\n    @property\n    def is_royal_flush(self):\n        return self.is_straight_flush and (\"A\" in self.ranks) and (\"K\" in self.ranks)\n\n    @property\n    def is_pair(self):\n        return 2 in {self.rank_frequencies[rank] for rank in self.ranks}\n\n    @property\n    def is_two_pair(self):\n        return len([rank for rank in self.ranks if self.rank_frequencies[rank] >= 2]) == 2\n\n    @property\n    def is_three_of_a_kind(self):\n        return 3 in {self.rank_frequencies[rank] for rank in self.ranks}\n\n    @property\n    def is_full_house(self):\n        return self.is_pair and self.is_three_of_a_kind\n\n    @property\n    def is_four_of_a_kind(self):\n        return 4 in {self.rank_frequencies[rank] for rank in self.ranks}\n\n    def __eq__(self, other):\n        sorted_other = other.sort()\n        for i, card in enumerate(self.sort(), start=0):\n            if not sorted_other[i].rank == card.rank:\n                return False\n        return self.is_flush == other.is_flush\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __lt__(self, other):\n        self_description = self.describe()\n        self_hand_rank = self_description[0]\n\n        other_description = other.describe()\n        other_hand_rank = other_description[0]\n\n        if not other_hand_rank == self_hand_rank:\n            return hand_rankings[self_hand_rank] > hand_rankings[other_hand_rank]\n\n        if self_hand_rank == \"ROYAL_FLUSH\":\n            return False\n\n        if self_hand_rank in [\"STRAIGHT_FLUSH\", \"STRAIGHT\"]:\n            return self.high_card < other.high_card\n\n        if self_hand_rank == \"FOUR_OF_A_KIND\":\n            if not self_description[1] == other_description[1]:\n                return self_description[1] < other_description[1]\n            self_fifth_card = [card for card in self._cards if not card.rank == self_description[1]][0]\n            other_fifth_card = [card for card in other._cards if not card.rank == self_description[1]][0]\n            return self_fifth_card < other_fifth_card\n\n        if self_hand_rank == \"FULL_HOUSE\":\n            if self_description[1] == other_description[1]:\n                # print(\"same triple, comparing double: {} < {} ? {}\".format( self_description[2], other_description[2], self_description[2] < other_description[2]))\n                return ranks[self_description[2]] < ranks[other_description[2]]\n            return self_description[1] < self_description[1]\n\n        if self_hand_rank == \"THREE_OF_A_KIND\":\n            if self_description[1] == other_description[1]:\n                # print(\"same triple\")\n                self_next_high = self.next_high_card([self_description[1]])\n                other_next_high = other.next_high_card([other_description[1]])\n                if self_next_high == other_next_high:\n                    # print(\"same next high\")\n                    self_last = self.next_high_card([self_description[1]])\n                    other_last = other.next_high_card([other_description[1]])\n                    return self_last < other_last\n                # print(\"Comparing {} < {}? {}\".format(self_next_high, other_next_high, self_next_high < other_next_high))\n                return self_next_high < other_next_high\n            return self_description[1] < other_description[1]\n\n        if self_hand_rank == \"TWO_PAIR\":\n            self_high_pair = self_description[1][1]\n            other_high_pair = other_description[1][1]\n            self_low_pair = self_description[1][0]\n            other_low_pair = other_description[1][0]\n            self_last_card = self.next_high_card([self_high_pair, self_low_pair])\n            other_last_card = other.next_high_card([other_high_pair, other_low_pair])\n            if self_high_pair == other_high_pair:\n                if self_low_pair == other_low_pair:\n                    return self_last_card < other_last_card\n                return self_low_pair < other_low_pair\n            return self_high_pair < other_high_pair\n\n        if self_hand_rank == \"PAIR\":\n            if self_description[1] == other_description[1]:\n                self_next_high = self.next_high_card([self_description[1]])\n                other_next_high = other.next_high_card([other_description[1]])\n                if self_next_high == other_next_high:\n                    self_next_next_high = self.next_high_card([self_description[1], self_next_high.rank])\n                    other_next_next_high = other.next_high_card([self_description[1], other_next_high.rank])\n                    if self_next_next_high == other_next_next_high:\n                        self_last = self.next_high_card(\n                            [self_description[1], self_next_high.rank, self_next_next_high.rank])\n                        other_last = other.next_high_card(\n                            [self_description[1], other_next_high.rank, other_next_next_high.rank])\n                        return self_last < other_last\n                    return self_next_next_high < other_next_next_high\n                return self_next_high < other_next_high\n            return self_description[1] < other_description[1]\n\n        if self_hand_rank in [\"HIGH_CARD\", \"FLUSH\"]:\n            sorted_other = other.sort()\n            for i, card in enumerate(self.sort(), start=0):\n                if not sorted_other[i].rank == card.rank:\n                    return card < sorted_other[i]\n            return False\n\n    def __le__(self, other):\n        return not self > other\n\n    def __gt__(self, other):\n        if self == other:\n            return False\n        return not self < other\n\n    def __ge__(self, other):\n        return not self < other\n\n    def describe(self):\n        if self.is_royal_flush:\n            return (\"ROYAL_FLUSH\", self.suits)\n        elif self.is_straight_flush:\n            return (\"STRAIGHT_FLUSH\", self.high_card, self.suits)\n        elif self.is_four_of_a_kind:\n            return (\"FOUR_OF_A_KIND\", [rank for rank in self.ranks if self.rank_frequencies[rank] == 4][0])\n        elif self.is_full_house:\n            return (\n                \"FULL_HOUSE\",\n                [rank for rank in self.ranks if self.rank_frequencies[rank] == 3][0],\n                [rank for rank in self.ranks if self.rank_frequencies[rank] == 2][0]\n            )\n        elif self.is_flush:\n            return (\"FLUSH\", self.high_card)\n        elif self.is_straight:\n            if not self._ace_low:\n                return (\"STRAIGHT\", self.high_card)\n            else:\n                return (\"STRAIGHT\",)\n        elif self.is_three_of_a_kind:\n            return (\"THREE_OF_A_KIND\", [rank for rank in self.ranks if self.rank_frequencies[rank] == 3][0])\n        elif self.is_two_pair:\n            return (\"TWO_PAIR\", sorted([rank for rank in self.ranks if self.rank_frequencies[rank] == 2]))\n        elif self.is_pair:\n            return (\n                \"PAIR\",\n                [rank for rank in self.ranks if self.rank_frequencies[rank] == 2][0],\n                self.high_card\n            )\n        else:\n            return (\"HIGH_CARD\", self.high_card)", "class Hand:\n    _cards = []\n    _ace_low = False\n\n    def __init__(self, cards):\n        if len(cards) == 5:\n            self._cards = cards\n        else:\n            raise (\"Expected 5 cards in hand\")\n\n    def __str__(self):\n        return \"{}, {}, {}, {}, {}\".format(*[\"{}{}\".format(card.rank, card.suit[0]) for card in self._cards])\n\n    def __repr__(self):\n        cards_string = \"[{}, {}, {}, {}, {}]\".format(*self._cards)\n        return \"Hand({})\".format(cards_string)\n\n    @property\n    def suits(self):\n        return {card.suit for card in self._cards}\n\n    @property\n    def ranks(self):\n        return {card.rank for card in self._cards}\n\n    @property\n    def high_card(self):\n        if self._ace_low:\n            not_ace = [card for card in self._cards if not card.rank == \"A\"]\n            return max(not_ace)\n        return max(self._cards)\n\n    def sort(self):\n        return sorted(self._cards)\n\n    def next_high_card(self, ranks):\n        # rank = []\n        # return high card after removing passed ranks\n        # eg: [3, 6, 7, 8 ,9].next_high([8, 9]) = 7\n        considered_cards = [card for card in self._cards if not card.rank in ranks]\n        return max(considered_cards) if len(considered_cards) > 0 else None\n\n    @property\n    def rank_frequencies(self):\n        ranks_in_hand = {card.rank for card in self._cards}\n        rank_frequencies = {}\n        for rank in ranks_in_hand:\n            count = len([card for card in self._cards if card.rank == rank])\n            rank_frequencies[rank] = count\n        return rank_frequencies\n\n    @property\n    def is_flush(self):\n        return len(self.suits) == 1\n\n    @property\n    def is_straight(self):\n        # a straight has 5 unique values (ie: no pairs)\n        hand_ranks = {ranks[card.rank] for card in self._cards}\n        if len(ranks) < 5:\n            return False\n\n        if 2 in hand_ranks and 14 in hand_ranks:\n            # Have an Ace and a 2 (14, 2) so we should check for Ace low straight\n            # instead of Ace high\n            hand_ranks.discard(14)\n            hand_ranks.add(1)\n            self._ace_low = True\n\n        low_card = min(hand_ranks)\n        for i in range(5):\n            if not ((low_card + i) in hand_ranks):\n                return False\n        return True\n\n    @property\n    def is_straight_flush(self):\n        return self.is_straight and self.is_flush\n\n    @property\n    def is_royal_flush(self):\n        return self.is_straight_flush and (\"A\" in self.ranks) and (\"K\" in self.ranks)\n\n    @property\n    def is_pair(self):\n        return 2 in {self.rank_frequencies[rank] for rank in self.ranks}\n\n    @property\n    def is_two_pair(self):\n        return len([rank for rank in self.ranks if self.rank_frequencies[rank] >= 2]) == 2\n\n    @property\n    def is_three_of_a_kind(self):\n        return 3 in {self.rank_frequencies[rank] for rank in self.ranks}\n\n    @property\n    def is_full_house(self):\n        return self.is_pair and self.is_three_of_a_kind\n\n    @property\n    def is_four_of_a_kind(self):\n        return 4 in {self.rank_frequencies[rank] for rank in self.ranks}\n\n    def __eq__(self, other):\n        sorted_other = other.sort()\n        for i, card in enumerate(self.sort(), start=0):\n            if not sorted_other[i].rank == card.rank:\n                return False\n        return self.is_flush == other.is_flush\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __lt__(self, other):\n        self_description = self.describe()\n        self_hand_rank = self_description[0]\n\n        other_description = other.describe()\n        other_hand_rank = other_description[0]\n\n        if not other_hand_rank == self_hand_rank:\n            return hand_rankings[self_hand_rank] > hand_rankings[other_hand_rank]\n\n        if self_hand_rank == \"ROYAL_FLUSH\":\n            return False\n\n        if self_hand_rank in [\"STRAIGHT_FLUSH\", \"STRAIGHT\"]:\n            return self.high_card < other.high_card\n\n        if self_hand_rank == \"FOUR_OF_A_KIND\":\n            if not self_description[1] == other_description[1]:\n                return self_description[1] < other_description[1]\n            self_fifth_card = [card for card in self._cards if not card.rank == self_description[1]][0]\n            other_fifth_card = [card for card in other._cards if not card.rank == self_description[1]][0]\n            return self_fifth_card < other_fifth_card\n\n        if self_hand_rank == \"FULL_HOUSE\":\n            if self_description[1] == other_description[1]:\n                # print(\"same triple, comparing double: {} < {} ? {}\".format( self_description[2], other_description[2], self_description[2] < other_description[2]))\n                return ranks[self_description[2]] < ranks[other_description[2]]\n            return self_description[1] < self_description[1]\n\n        if self_hand_rank == \"THREE_OF_A_KIND\":\n            if self_description[1] == other_description[1]:\n                # print(\"same triple\")\n                self_next_high = self.next_high_card([self_description[1]])\n                other_next_high = other.next_high_card([other_description[1]])\n                if self_next_high == other_next_high:\n                    # print(\"same next high\")\n                    self_last = self.next_high_card([self_description[1]])\n                    other_last = other.next_high_card([other_description[1]])\n                    return self_last < other_last\n                # print(\"Comparing {} < {}? {}\".format(self_next_high, other_next_high, self_next_high < other_next_high))\n                return self_next_high < other_next_high\n            return self_description[1] < other_description[1]\n\n        if self_hand_rank == \"TWO_PAIR\":\n            self_high_pair = self_description[1][1]\n            other_high_pair = other_description[1][1]\n            self_low_pair = self_description[1][0]\n            other_low_pair = other_description[1][0]\n            self_last_card = self.next_high_card([self_high_pair, self_low_pair])\n            other_last_card = other.next_high_card([other_high_pair, other_low_pair])\n            if self_high_pair == other_high_pair:\n                if self_low_pair == other_low_pair:\n                    return self_last_card < other_last_card\n                return self_low_pair < other_low_pair\n            return self_high_pair < other_high_pair\n\n        if self_hand_rank == \"PAIR\":\n            if self_description[1] == other_description[1]:\n                self_next_high = self.next_high_card([self_description[1]])\n                other_next_high = other.next_high_card([other_description[1]])\n                if self_next_high == other_next_high:\n                    self_next_next_high = self.next_high_card([self_description[1], self_next_high.rank])\n                    other_next_next_high = other.next_high_card([self_description[1], other_next_high.rank])\n                    if self_next_next_high == other_next_next_high:\n                        self_last = self.next_high_card(\n                            [self_description[1], self_next_high.rank, self_next_next_high.rank])\n                        other_last = other.next_high_card(\n                            [self_description[1], other_next_high.rank, other_next_next_high.rank])\n                        return self_last < other_last\n                    return self_next_next_high < other_next_next_high\n                return self_next_high < other_next_high\n            return self_description[1] < other_description[1]\n\n        if self_hand_rank in [\"HIGH_CARD\", \"FLUSH\"]:\n            sorted_other = other.sort()\n            for i, card in enumerate(self.sort(), start=0):\n                if not sorted_other[i].rank == card.rank:\n                    return card < sorted_other[i]\n            return False\n\n    def __le__(self, other):\n        return not self > other\n\n    def __gt__(self, other):\n        if self == other:\n            return False\n        return not self < other\n\n    def __ge__(self, other):\n        return not self < other\n\n    def describe(self):\n        if self.is_royal_flush:\n            return (\"ROYAL_FLUSH\", self.suits)\n        elif self.is_straight_flush:\n            return (\"STRAIGHT_FLUSH\", self.high_card, self.suits)\n        elif self.is_four_of_a_kind:\n            return (\"FOUR_OF_A_KIND\", [rank for rank in self.ranks if self.rank_frequencies[rank] == 4][0])\n        elif self.is_full_house:\n            return (\n                \"FULL_HOUSE\",\n                [rank for rank in self.ranks if self.rank_frequencies[rank] == 3][0],\n                [rank for rank in self.ranks if self.rank_frequencies[rank] == 2][0]\n            )\n        elif self.is_flush:\n            return (\"FLUSH\", self.high_card)\n        elif self.is_straight:\n            if not self._ace_low:\n                return (\"STRAIGHT\", self.high_card)\n            else:\n                return (\"STRAIGHT\",)\n        elif self.is_three_of_a_kind:\n            return (\"THREE_OF_A_KIND\", [rank for rank in self.ranks if self.rank_frequencies[rank] == 3][0])\n        elif self.is_two_pair:\n            return (\"TWO_PAIR\", sorted([rank for rank in self.ranks if self.rank_frequencies[rank] == 2]))\n        elif self.is_pair:\n            return (\n                \"PAIR\",\n                [rank for rank in self.ranks if self.rank_frequencies[rank] == 2][0],\n                self.high_card\n            )\n        else:\n            return (\"HIGH_CARD\", self.high_card)", ""]}
{"filename": "src/model/holdem_round.py", "chunked_list": ["import random\nimport math\nimport logging\n\nfrom model.table import Table\nfrom model.deck import Deck\n# from model.action import Action, FOLD, CALL, RAISE, CHECK, MATCH, action_types\nfrom model.betting_round import BettingRound\n\nclass HoldemRound:\n    # HoldemRound orchestrates the game play including player and deck management\n    # it passes th Table object around as a shared state the public game knowledge\n\n    def __init__(self, players, blind=1, table=None, raise_blinds=False, round_number=None):\n        self.players = players  # the list of players was passed in\n        if table:\n            self.table = table\n            self.table.new_holdem_round()\n            self.table.num_players = len(players)\n            self.table.next_round()\n            if raise_blinds:\n                self.table.raise_blinds()\n        else:\n            self.dealer_button_index = random.randint(0, len(players))\n            self.table = Table(blind, len(players))\n            if raise_blinds:\n                raise Exception(\"Cannot raise blinds on new table. raise_blinds requires a table parameter.\")\n        self.round_number = round_number\n        self.deck = None\n        self.results = None\n        self.betting_round_complete = False\n        self.is_called = False\n        self.all_in_players = []\n        self._split_pot = None\n        self._last_total_money = None\n        self.player_status = {f\"{player.name}\": False for player in self.players} # True if a player is still in the game, False when they fold\n        for player in self.players:\n            player.start_holdem_round()\n\n    @property\n    def active_player_count(self):\n        count = len(self.players_still_in)\n        logging.debug(f\"Player still in count: {count}\")\n        return count\n\n    @property\n    def players_still_in(self):\n        still_in = [player.name for player in self.players if not player.folded]\n        logging.debug(f\"Still in: {still_in}\")\n        return [player.name for player in self.players if not player.folded]\n\n    @property\n    def all_players_have_bet(self):\n        players = [ player for player in self.players if player.name in self.players_still_in ]\n        return len([ player for player in players if not player.has_bet ]) == 0\n\n    def deal(self):\n        self.deck = Deck()\n        self.deck.shuffle()\n        cards_dealt = 0\n        while cards_dealt < 2:\n            for player in self.players:\n                player.deal_card(self.deck.draw())\n            cards_dealt += 1\n\n    def expose_flop(self):\n        self.deck.draw_card() # burn the top card\n        self.table.flop = self.deck.draw(3)\n\n    def expose_turn(self):\n        self.table.turn = self.deck.draw()\n\n    def expose_river(self):\n        # print(\"dealing the river\")\n        self.table.river = self.deck.draw()\n\n    def do_betting_round(self):\n        logging.debug(\"Starting betting round\")\n        print(f\"Do the preround money check\")\n        betting_round = BettingRound(self.table, self.players, self.round_number)\n        # betting_round.check_money_supply()\n        self.players, self.table = betting_round.do_round()\n        print(\"Checking post round money supply\")\n        # betting_round.check_money_supply()\n\n    def showdown(self):\n        #best_hands = [ player.best_hand(self.table) for player in self.players if not player.folded ]\n        player_hands = {player.name: player.best_hand(self.table) for player in self.players if not player.folded}\n        print(player_hands)\n        self.winning_hand = max([player_hands[player.name] for player in self.players if not player.folded])\n        logging.info(f\"Winning Hand: {self.winning_hand}\")\n        print(f\"{self.winning_hand.describe()}: {self.winning_hand}\")\n        winners = [ player for player in player_hands if player_hands[player] == self.winning_hand ]\n        assert len(winners) >= 1 # should be at least one winner\n        logging.debug(winners)\n\n        logging.debug(f\"Flop: {self.table.flop}\")\n        logging.debug(f\"Turn: {self.table.turn}\")\n        logging.debug(f\"River: {self.table.river}\")\n\n        if len(winners) > 1:\n            for winner in winners:\n                logging.debug(f\"Multiple Winners...\")\n                logging.debug(f\"    Winner: {winner}\")\n                player = [player for player in self.players if player.name == winner][0]\n                # print(f\"{player.name} hole: {player.hole}\")\n\n            for player_name in player_hands:\n                logging.debug(f\"{player_name}: {player_hands[player_name]}\")\n\n        self.winners = winners\n        self.results = {\n            \"pot_size\": self.table.pot_total,\n            \"winners\": self.winners,\n            \"winner_personas\": [player.persona for player in self.players if player.name in self.winners],\n            \"winning_hand\": self.winning_hand,\n            \"all_hands\": player_hands,\n        }\n\n    def settle_round(self):\n        # print(\"Checking before betting players settle up\")\n        # self.check_total_money()\n        for i in range(len(self.players)):\n            name = self.players[i].name\n            if name in self.winners:\n                # print(f\"Checking before {name} settles up\")\n                # self.check_total_money()\n                # todo: sum up amounts from the pot\n                players_share_of_pot = math.floor(self.table.pot_total / len(self.winners)) # tip the dealer!\n                print(f\"{name} collects {players_share_of_pot} from the pot. total pot size {self.table.pot_total}\")\n                self.players[i].collect_winnings(players_share_of_pot)\n                # print(f\"Checking after {name} settles up\")\n                # self.check_total_money()\n            # print(f\"Checking after players all settle up\")\n            # self.check_total_money()\n            self.players[i].check_results(self.table, self.results)\n            # print(\"Checking after letting players check results\")\n            # self.check_total_money()\n        self.table.payout()\n\n    def collect_blinds(self):\n        logging.debug(f\"Collecting blinds\")\n        self.table.pot.append(self.players[self.table.big_blind_index].place_big_blind(self.table))\n        self.table.pot.append(self.players[self.table.small_blind_index].place_small_blind(self.table))\n\n    def check_total_money(self):\n        print(f\"Checking money supply for change. Last value: {self._last_total_money}\")\n        total = sum([player.bankroll for player in self.players]) + self.table.pot_total\n        print(f\"Current Total: {total}\")\n        # if (not total is None) and (total > 1100):\n        #     raise Exception(\"New Money detected in game\")\n        if self._last_total_money is None:\n            print(f\"First check of money supply. Nonevalue ok {self._last_total_money}\")\n            self._last_total_money = total\n        else:\n            if not self._last_total_money >= total: # sometimes we tip the dealer splitting pots, should never increase\n                print(f\"New money detected. Change in total money in game: {self._last_total_money}\")\n                raise Exception(\"New Money detected in game\")\n        self._last_total_money = total\n        return self._last_total_money\n\n    def play(self):\n        logging.debug(f\"Playing round with {len(self.players)} players\")\n        print(\"Play round\")\n        self.table.new_holdem_round()\n        # self.check_total_money()\n        assert len(self.players) > 1\n        for player in self.players:\n            player.start_holdem_round()\n        self.collect_blinds()\n        self.deal()\n        self.do_betting_round()\n        self.expose_flop()\n        self.do_betting_round()\n        self.expose_turn()\n        self.do_betting_round()\n        self.expose_river()\n        print(\"Checking before betting round after river\")\n        self.check_total_money()\n        self.do_betting_round()\n        print(\"Checking before showdown\")\n        self.check_total_money()\n        self.showdown()\n        print(\"Checking before settle\")\n        self.check_total_money()\n        self.settle_round()\n        print(\"Checking after settle\")\n        self.check_total_money()\n        return self.players, self.table", "\nclass HoldemRound:\n    # HoldemRound orchestrates the game play including player and deck management\n    # it passes th Table object around as a shared state the public game knowledge\n\n    def __init__(self, players, blind=1, table=None, raise_blinds=False, round_number=None):\n        self.players = players  # the list of players was passed in\n        if table:\n            self.table = table\n            self.table.new_holdem_round()\n            self.table.num_players = len(players)\n            self.table.next_round()\n            if raise_blinds:\n                self.table.raise_blinds()\n        else:\n            self.dealer_button_index = random.randint(0, len(players))\n            self.table = Table(blind, len(players))\n            if raise_blinds:\n                raise Exception(\"Cannot raise blinds on new table. raise_blinds requires a table parameter.\")\n        self.round_number = round_number\n        self.deck = None\n        self.results = None\n        self.betting_round_complete = False\n        self.is_called = False\n        self.all_in_players = []\n        self._split_pot = None\n        self._last_total_money = None\n        self.player_status = {f\"{player.name}\": False for player in self.players} # True if a player is still in the game, False when they fold\n        for player in self.players:\n            player.start_holdem_round()\n\n    @property\n    def active_player_count(self):\n        count = len(self.players_still_in)\n        logging.debug(f\"Player still in count: {count}\")\n        return count\n\n    @property\n    def players_still_in(self):\n        still_in = [player.name for player in self.players if not player.folded]\n        logging.debug(f\"Still in: {still_in}\")\n        return [player.name for player in self.players if not player.folded]\n\n    @property\n    def all_players_have_bet(self):\n        players = [ player for player in self.players if player.name in self.players_still_in ]\n        return len([ player for player in players if not player.has_bet ]) == 0\n\n    def deal(self):\n        self.deck = Deck()\n        self.deck.shuffle()\n        cards_dealt = 0\n        while cards_dealt < 2:\n            for player in self.players:\n                player.deal_card(self.deck.draw())\n            cards_dealt += 1\n\n    def expose_flop(self):\n        self.deck.draw_card() # burn the top card\n        self.table.flop = self.deck.draw(3)\n\n    def expose_turn(self):\n        self.table.turn = self.deck.draw()\n\n    def expose_river(self):\n        # print(\"dealing the river\")\n        self.table.river = self.deck.draw()\n\n    def do_betting_round(self):\n        logging.debug(\"Starting betting round\")\n        print(f\"Do the preround money check\")\n        betting_round = BettingRound(self.table, self.players, self.round_number)\n        # betting_round.check_money_supply()\n        self.players, self.table = betting_round.do_round()\n        print(\"Checking post round money supply\")\n        # betting_round.check_money_supply()\n\n    def showdown(self):\n        #best_hands = [ player.best_hand(self.table) for player in self.players if not player.folded ]\n        player_hands = {player.name: player.best_hand(self.table) for player in self.players if not player.folded}\n        print(player_hands)\n        self.winning_hand = max([player_hands[player.name] for player in self.players if not player.folded])\n        logging.info(f\"Winning Hand: {self.winning_hand}\")\n        print(f\"{self.winning_hand.describe()}: {self.winning_hand}\")\n        winners = [ player for player in player_hands if player_hands[player] == self.winning_hand ]\n        assert len(winners) >= 1 # should be at least one winner\n        logging.debug(winners)\n\n        logging.debug(f\"Flop: {self.table.flop}\")\n        logging.debug(f\"Turn: {self.table.turn}\")\n        logging.debug(f\"River: {self.table.river}\")\n\n        if len(winners) > 1:\n            for winner in winners:\n                logging.debug(f\"Multiple Winners...\")\n                logging.debug(f\"    Winner: {winner}\")\n                player = [player for player in self.players if player.name == winner][0]\n                # print(f\"{player.name} hole: {player.hole}\")\n\n            for player_name in player_hands:\n                logging.debug(f\"{player_name}: {player_hands[player_name]}\")\n\n        self.winners = winners\n        self.results = {\n            \"pot_size\": self.table.pot_total,\n            \"winners\": self.winners,\n            \"winner_personas\": [player.persona for player in self.players if player.name in self.winners],\n            \"winning_hand\": self.winning_hand,\n            \"all_hands\": player_hands,\n        }\n\n    def settle_round(self):\n        # print(\"Checking before betting players settle up\")\n        # self.check_total_money()\n        for i in range(len(self.players)):\n            name = self.players[i].name\n            if name in self.winners:\n                # print(f\"Checking before {name} settles up\")\n                # self.check_total_money()\n                # todo: sum up amounts from the pot\n                players_share_of_pot = math.floor(self.table.pot_total / len(self.winners)) # tip the dealer!\n                print(f\"{name} collects {players_share_of_pot} from the pot. total pot size {self.table.pot_total}\")\n                self.players[i].collect_winnings(players_share_of_pot)\n                # print(f\"Checking after {name} settles up\")\n                # self.check_total_money()\n            # print(f\"Checking after players all settle up\")\n            # self.check_total_money()\n            self.players[i].check_results(self.table, self.results)\n            # print(\"Checking after letting players check results\")\n            # self.check_total_money()\n        self.table.payout()\n\n    def collect_blinds(self):\n        logging.debug(f\"Collecting blinds\")\n        self.table.pot.append(self.players[self.table.big_blind_index].place_big_blind(self.table))\n        self.table.pot.append(self.players[self.table.small_blind_index].place_small_blind(self.table))\n\n    def check_total_money(self):\n        print(f\"Checking money supply for change. Last value: {self._last_total_money}\")\n        total = sum([player.bankroll for player in self.players]) + self.table.pot_total\n        print(f\"Current Total: {total}\")\n        # if (not total is None) and (total > 1100):\n        #     raise Exception(\"New Money detected in game\")\n        if self._last_total_money is None:\n            print(f\"First check of money supply. Nonevalue ok {self._last_total_money}\")\n            self._last_total_money = total\n        else:\n            if not self._last_total_money >= total: # sometimes we tip the dealer splitting pots, should never increase\n                print(f\"New money detected. Change in total money in game: {self._last_total_money}\")\n                raise Exception(\"New Money detected in game\")\n        self._last_total_money = total\n        return self._last_total_money\n\n    def play(self):\n        logging.debug(f\"Playing round with {len(self.players)} players\")\n        print(\"Play round\")\n        self.table.new_holdem_round()\n        # self.check_total_money()\n        assert len(self.players) > 1\n        for player in self.players:\n            player.start_holdem_round()\n        self.collect_blinds()\n        self.deal()\n        self.do_betting_round()\n        self.expose_flop()\n        self.do_betting_round()\n        self.expose_turn()\n        self.do_betting_round()\n        self.expose_river()\n        print(\"Checking before betting round after river\")\n        self.check_total_money()\n        self.do_betting_round()\n        print(\"Checking before showdown\")\n        self.check_total_money()\n        self.showdown()\n        print(\"Checking before settle\")\n        self.check_total_money()\n        self.settle_round()\n        print(\"Checking after settle\")\n        self.check_total_money()\n        return self.players, self.table"]}
{"filename": "src/model/test_action.py", "chunked_list": ["from model.action import Action\n\ndef test_init_error():\n    did_error = False\n    try:\n        action = Action(\"BET\")\n    except:\n        did_error = True\n    finally:\n        assert did_error == True", "\ndef test_init_check():\n    did_error = False\n    try:\n        action = Action(\"CHECK\")\n    except:\n        did_error = True\n    finally:\n        assert did_error == False\n\ndef test_init_raise():\n    did_error = False\n    try:\n        action = Action(\"RAISE\", 10)\n    except:\n        did_error = True\n    finally:\n        assert did_error == False", "\ndef test_init_raise():\n    did_error = False\n    try:\n        action = Action(\"RAISE\", 10)\n    except:\n        did_error = True\n    finally:\n        assert did_error == False\n\ndef test_init_call():\n    did_error = False\n    try:\n        action = Action(\"CALL\", 10)\n    except:\n        did_error = True\n    finally:\n        assert did_error == False", "\ndef test_init_call():\n    did_error = False\n    try:\n        action = Action(\"CALL\", 10)\n    except:\n        did_error = True\n    finally:\n        assert did_error == False\n\ndef test_init_fold():\n    did_error = False\n    try:\n        action = Action(\"FOLD\")\n    except:\n        did_error = True\n    finally:\n        assert did_error == False", "\ndef test_init_fold():\n    did_error = False\n    try:\n        action = Action(\"FOLD\")\n    except:\n        did_error = True\n    finally:\n        assert did_error == False\n", "\n"]}
{"filename": "src/model/test_holdem_round.py", "chunked_list": ["from model.holdem_round import HoldemRound\n# from model.table import Table\n# from model.player import Player\nfrom players.floyd_folds import Floyd\nfrom players.callie_calls import Callie\nfrom players.robby_random import Robby\nfrom players.ricky_raise import Ricky\n\nplayers = [\n    Ricky(\"Josh\", 100),", "players = [\n    Ricky(\"Josh\", 100),\n    Callie(\"Madi\", 100),\n    Floyd(\"Cody\", 100),\n    Robby(\"Michelle\", 100),\n    Callie(\"Sophia\", 100),\n    Floyd(\"Beezie\", 100)\n]\n\nround = HoldemRound(", "\nround = HoldemRound(\n    players=players,\n    blind=1\n)\n\ndef test_deal():\n    round.deal()\n    assert round.table.flop == None\n    assert round.table.turn == None\n    assert round.table.river == None\n    for player in players:\n        assert len(player._hole) == 2", "\nround_2 = HoldemRound(\n    players=players,\n    blind=1\n)\n\ndef test_play():\n    round_2.play()\n\nround_3 = HoldemRound(", "\nround_3 = HoldemRound(\n    players=players,\n    blind=1\n)\n\ndef test_play_detailed():\n    for player in players:\n        player.start_holdem_round()\n    round_3.deal()\n    assert round_3.table.flop is None\n    round_3.do_betting_round()\n    round_3.expose_flop()\n    assert not round_3.table.flop is None\n    round_3.do_betting_round()\n    assert round_3.table.turn is None\n    round_3.expose_turn()\n    assert not round_3.table.turn is None\n    round_3.do_betting_round()\n    assert round_3.table.river is None\n    round_3.expose_river()\n    assert not round_3.table.river is None\n    round_3.do_betting_round()\n    winners = round_3.showdown()\n    round_3.settle_round()", ""]}
{"filename": "src/model/action.py", "chunked_list": ["CHECK = \"CHECK\"\nFOLD = \"FOLD\"\nRAISE = \"RAISE\"\nCALL = \"CALL\"\nMATCH = \"MATCH\"\n\naction_types = [\n    CHECK,\n    CALL,\n    RAISE,", "    CALL,\n    RAISE,\n    FOLD,\n    MATCH\n]\n\n\nclass Action:\n    def __init__(self, action_type, amount=None, all_in=False):\n        if not action_type in action_types:\n            raise Exception(f\"Invalid action: {action_type}\")\n        if not amount:\n            if action_type in [RAISE, CALL, MATCH]:\n                raise Exception(f\"Invalid MATCH, RAISE or CALL amount (None)\")\n        else:\n            # if action_type in [CHECK, FOLD]:\n            #     print(f\"Got Action Type: [{action_type}]\")\n            #     if amount and (int(amount) > 0):\n            #         print(f\"Got amount: [{amount}]\")\n            #         raise Exception(f\"Invalid CHECK or FOLD\")\n            if amount < 0:\n                raise ValueError(f\"Cannot {action_type} by a negative number: {amount}\")\n        self.action_type = action_type\n        self.amount = amount\n        self.all_in = all_in\n\n    def __str__(self):\n        return f\"Action({self.action_type}, {self.amount}, {self.all_in})\"", ""]}
{"filename": "src/model/test_betting_round.py", "chunked_list": ["import logging\n\nfrom model.betting_round import BettingRound\nfrom model.table import Table\nfrom players.floyd_folds import Floyd\nfrom players.callie_calls import Callie\nfrom players.robby_random import Robby\nfrom players.ricky_raise import Ricky\n\n\ndef test_betting_round():\n    players = [\n        Ricky(\"Josh\", 100),\n        Callie(\"Madi\", 100),\n        Floyd(\"Cody\", 100),\n        Robby(\"Michelle\", 100),\n        Callie(\"Sophia\", 100),\n        Floyd(\"Beezie\", 100)\n    ]\n\n    for player in players:\n        player.start_holdem_round()\n\n    table = Table(2, 6)\n\n    betting_round = BettingRound(\n        table=table,\n        players=players\n    )\n\n    betting_round.do_round()", "\n\ndef test_betting_round():\n    players = [\n        Ricky(\"Josh\", 100),\n        Callie(\"Madi\", 100),\n        Floyd(\"Cody\", 100),\n        Robby(\"Michelle\", 100),\n        Callie(\"Sophia\", 100),\n        Floyd(\"Beezie\", 100)\n    ]\n\n    for player in players:\n        player.start_holdem_round()\n\n    table = Table(2, 6)\n\n    betting_round = BettingRound(\n        table=table,\n        players=players\n    )\n\n    betting_round.do_round()", ""]}
{"filename": "src/model/betting_round.py", "chunked_list": ["import logging\n\nfrom model.action import Action, FOLD, CALL, RAISE, CHECK, MATCH, action_types\n\n\nclass BettingRound:\n    def __init__(self, table, players, round_number=None):\n        self.is_called = False\n        self.betting_round_complete = False\n        self.calling_player_name = None\n        self.table = table\n        self.players = players\n        self.reset_active_player_index()\n        self.reset_players()\n        self.all_in_players = []\n        self._last_total_money = None\n        self.round_number = round_number\n\n    def reset_active_player_index(self):\n        self.table.new_betting_round()\n\n    def reset_players(self):\n        for player in self.players:\n            player.start_betting_round()\n\n    @property\n    def still_in(self):\n        \"\"\"\n        :return:\n        dict with string keys and boolean values\n        {\n            \"Josh\": True,\n            \"Sophia\": False,\n        }\n        \"\"\"\n        still_in = []\n        for player in self.players:\n            if not player.folded:\n                still_in.append(player.name)\n        return still_in\n\n    @property\n    def all_players_have_bet(self):\n        result = True\n        for player in self.players:\n            if not player.folded:\n                if not player.has_bet:\n                    result = False\n        return result\n\n    def do_round(self):\n        print(\"BettingRound.do_round() start...\")\n\n        while not (self.is_called and self.all_players_have_bet):  # ( not self.is_called ) and ( self.active_player_count > 1 ):\n            whos_in = [player for player in self.players if not player.folded]\n            # print(f\"Whos in? {whos_in}\")\n            if len(whos_in) <= 1:\n                logging.debug(f\"{whos_in} wins by default\")\n                break # only one player remains...theyll win this round\n\n            # We have at least two players\n            # lets see whos turn it is...\n            active_player = self.players[self.table.active_player_index]\n            # print(f\"Active player: {active_player}\")\n\n            # skip them if they're folded\n            if not active_player.folded:\n                # log the player status before handing it to the player\n                player_status = {player.name: player.folded for player in self.players}\n                logging.debug(f\"The bet is {self.table.bet_amount} to {active_player.name}\")\n\n\n                retry_count = 0\n                while retry_count < 3:\n                    try:\n                        action = active_player.play(self.table, player_status, round_number=self.round_number)\n                        print(f\"{active_player.name}: {action}\")\n                        logging.debug(f\"Got action: {action}\")\n\n                        # handle the players action\n                        self.handle_action(action, active_player)\n                        break\n                    except ValueError as e:\n                        print(f\"WARNING: Got invalid action. Retry count {retry_count}\")\n                        print(f\"Exception: {e}\")\n                    finally:\n                        retry_count += 1\n\n            self.table.next_turn()\n\n        return self.players, self.table\n\n    def handle_action(self, action, active_player):\n        logging.debug(f\"handling action: {action}\")\n        print(f\"{active_player.name}: {action}\")\n        # self.check_money_supply()\n        self.table.pot.append(active_player.process_action(action))\n        if action.action_type == CALL:\n            self.handle_call(action, active_player)\n        elif action.action_type == FOLD:\n            self.handle_fold(action, active_player)\n        elif action.action_type == CHECK:\n            self.handle_check(action, active_player)\n        elif action.action_type == RAISE:\n            self.handle_raise(action, active_player)\n        elif action.action_type == MATCH:\n            self.handle_match(action, active_player)\n        else:\n            raise Exception(f\"Cannot handle action of type: {action.action_type}\")\n        # self.check_money_supply()\n\n    def handle_check(self, check, player):\n        # check is noop\n        logging.debug(f\"{player.name} checks\")\n\n    def handle_raise(self, raise_, player): # 'raise' is a Python reserved keyword\n        logging.debug(f\"{player.name} raises\")\n        self.table.raise_bet(raise_.amount)\n        if raise_.all_in:\n            self.handle_all_in(raise_, player)\n        # todo: process bet\n        # todo: see whos still in and collect bets\n\n    def handle_call(self, call, player):\n        # print(f\"{player.name} calls...have all players bet?\")\n        if self.all_players_have_bet:\n            if not self.is_called:\n                print(f\"{player.name} has called the round\")\n                self.calling_player_name = player.name\n            logging.debug(f\"{player.name} calls, setting holdem_round.is_called = True\")\n            self.is_called = True\n        if call.all_in:\n            self.handle_all_in(call, player)\n        # todo: process bet\n        # todo: is the round over?\n\n    def handle_match(self, match, player):\n        if match.all_in:\n            self.handle_all_in(match, player)\n\n    def handle_fold(self, fold, player):\n        logging.debug(f\"{player.name} folds\")\n        #self.player_status[player.name] = False\n        if len(self.still_in) <= 1:\n            self.betting_round_complete = True\n\n    def handle_all_in(self, action, player):\n        if not player.name in self.all_in_players: # only add them the first time\n            self.all_in_players.append(player.name)\n            if self.table.bet_amount > action.amount:\n                self.split_pot(action, player)\n\n    def split_pot(self, action, player):\n        logging.debug(f\"Splitting pot - {player.name} is all in\")\n        logging.debug(f\"Players: {self.still_in}\")\n        self.table._split_pot = [\n            {\n                \"players\": self.still_in,\n                \"amount\": action.amount\n            },\n            {\n                \"players\": self.still_in.remove(player.name),\n                \"amount\": self.table.bet_amount - action.amount\n            }\n        ]\n\n    def handle_push(self, players):\n        # settle round with multiple winners\n        logging.debug(f\"Handling Push - {players}\")"]}
{"filename": "src/model/player.py", "chunked_list": ["from itertools import combinations\nimport logging\n\nfrom model.hand import Hand\nfrom model.action import Action, FOLD, CALL, RAISE, CHECK, MATCH\n\n\nclass PlayerStatus:\n    def __init__(self):\n        self.folded = False\n        self._money_on_table = 0\n        self.has_bet = False\n\n    def add_chips(self, amount):\n        self._money_on_table += amount\n\n    @property\n    def money_on_table(self):\n        return self._money_on_table", "\n\nclass Player:\n    def __init__(self, name, bankroll):\n        self.name = name\n        self._bankroll = bankroll\n        self._hole = []\n        self._best_hand = None\n        self._games_played = 0\n        # self._folded = False\n\n    def __str__(self):\n        return f\"Player({self.name}, {self._bankroll})\"\n\n    def __repr__(self):\n        return f\"Player({self.name}, {self._bankroll})\"\n\n    @property\n    def folded(self):\n        return self.status.folded\n\n    @property\n    def has_bet(self):\n        return self.status.has_bet\n\n    @property\n    def max_bet(self):\n        max_bet = self.status.money_on_table + self.bankroll\n        logging.debug(f\"{self.name} has a max bet of {max_bet}\")\n        return max_bet\n\n    @property\n    def games_played(self):\n        return self._games_played\n\n    def get_game_phase(self, table):\n        if not (table.flop or table.turn or table.river):\n            print(\"First betting round\")\n            return 1\n        elif table.flop and not (table.turn or table.river):\n            print(\"Second betting round, after the flop\")\n            return 2\n        elif table.flop and table.turn and not table.river:\n            print(\"Third betting round, after the turn\")\n            return 3\n        elif table.flop and table.turn and table.river:\n            print(\"Final betting round, after the river\")\n            return 4\n        else:\n            print(f\"Debug: {table.flop} - {table.turn} - {table.river}\")\n            raise ValueError(\"Invalid table state - bad combination of visible public cards\")\n\n    def add_chips(self, amount):\n        if amount > self.bankroll:\n            raise ValueError(f\"Cannot add more ({amount}) chips than {self.name} has in bankroll ({self.bankroll}).\")\n        self.status.add_chips(amount)\n        self._bankroll -= amount\n\n    def start_holdem_round(self):\n        self.status = PlayerStatus()\n        self._hole = []\n        self._folded = False\n        self._best_hand = None\n        self._games_played += 1\n\n    def place_small_blind(self, table):\n        logging.debug(f\"{self.name} is placing small blind: {table.small_blind}\")\n        if self.status.money_on_table > 0:\n            raise Exception(\"Cannot place small blind when I already placed big blind\")\n        # self._bankroll -= table.small_blind\n        self.add_chips(table.small_blind)\n        logging.debug(f\"{self.name} placed small blind: {self._bankroll} left in bankroll\")\n        return table.small_blind\n\n    def place_big_blind(self, table):\n        logging.debug(f\"{self.name} is placing big blind: {table.big_blind}\")\n        if self.status.money_on_table > 0:\n            raise Exception(\"Cannot place big blind when I already placed small blind\")\n        # self._bankroll -= table.big_blind\n        self.add_chips(table.big_blind)\n        logging.debug(f\"{self.name} placed big blind: {self._bankroll} left in bankroll\")\n        return table.big_blind\n\n    def start_betting_round(self):\n        self.status.has_bet = False\n\n    def process_action(self, action):\n        logging.debug(f\"Processing Action - {self.name}: {action.action_type}\")\n        logging.debug(f\"{self.name}: {self._bankroll}\")\n        self.status.has_bet = True\n        if action.action_type == FOLD:\n            logging.debug(f\"{self.name}: {action.action_type}\")\n            # self.status[\"folded\"] = True # deprecate\n            self.status.folded = True\n            logging.debug(f\"{self.name} is folding: {self._bankroll}\")\n            return 0\n        elif action.action_type in [RAISE, CALL, MATCH]:\n            if self._bankroll + self.status.money_on_table < action.amount:\n                logging.debug(f\"{self.name} has {self._bankroll} in the bank and {self.status.money_on_table} on the table\")\n                logging.debug(f\"Action amount is: {action.amount}\")\n                raise ValueError(\"Player does not have enough money for this bet\")\n            logging.debug(f\"Action amount: {action.amount}\")\n            logging.debug(f\"Money on table: {self.status.money_on_table}\")\n            cash_into_pot = action.amount - self.status.money_on_table  # leaky abstraction need to refactor\n            logging.debug(f\"Cash into the pot: {cash_into_pot}\")\n            if cash_into_pot < 0:\n                logging.debug(f\"WARN: Illegal Request\")\n                logging.debug(f\"WARN: {self.name} handling bet amount {action.amount}\")\n                logging.debug(f\"WARN: {self.name} has bankroll {self.bankroll} and {self.status.money_on_table} on the table\")\n\n                raise ValueError(\"Cannot remove money from the pot\")\n            logging.debug(f\"Cash into pot: {cash_into_pot}\")\n            # self._bankroll -= cash_into_pot\n            logging.debug(f\"{self.name} calling, raising, or matching by {action.amount}\")\n            # self.status.money_on_table += action.amount  # leaky abstraction refactor\n            self.add_chips(cash_into_pot)\n            logging.debug(f\"{self.name} still has: {self._bankroll} in their bankroll\")\n            return cash_into_pot\n        elif action.action_type == CHECK:\n            return 0\n        else:\n            raise Exception(f\"Invalid action type: {action.action_type}\")\n\n    def deal_card(self, card):\n        logging.debug(f\"delt {self.name} to {card}\")\n        self._hole.append(card)\n        assert len(self._hole) <= 2\n\n    def play(self, table, player_status, is_called=False, round_number=None):\n        pass # Players implement this function to define the Actions they play\n\n    def check_results(self, table, results):\n        pass # Players can implement this function to inspect the end state of each round.\n\n    def _all_five_card_hands(self, cards):\n        all_cards = self._hole.copy()\n        all_cards.extend(cards)\n        logging.debug(f\"{self.name} makes a hand from: {all_cards}\")\n        card_combinations = combinations(all_cards, 5)\n        # print(f\"Combinations: {card_combinations}\")\n        hands = [Hand(cards) for cards in card_combinations]\n        # print(f\"Hands: {hands}\")\n        return hands\n\n    def best_hand(self, table, refresh=False):\n        logging.debug(f\"{self.name} is holding {self._hole}\")\n        if self.folded:\n            return None\n        # if not (self._best_hand or refresh):\n\n        # cards_on_table = table.flop + [table.turn] + [table.river]\n        cards_on_table = []\n        if table.flop is not None:\n            cards_on_table.extend(table.flop)\n            if table.turn is not None:\n                cards_on_table.append(table.turn)\n                if table.river is not None:\n                    cards_on_table.append(table.river)\n\n        self._best_hand = max(self._all_five_card_hands(cards_on_table))\n        logging.debug(f\"{self.name} presents hand: {self._best_hand}\")\n        return self._best_hand\n\n    def collect_winnings(self, amount):\n        logging.debug(f\"{self.name} collects a ${amount} pot\")\n        self._bankroll += amount\n\n    @property\n    def bankroll(self):\n        return self._bankroll\n\n    def call(self, table):\n        # Helper function to call with checks for bet amount against your bet amount\n        print(f\"{self.name} stays in the game\")\n        if self.max_bet > table.bet_amount:\n            action = Action(\"CALL\", table.bet_amount)\n            return action\n        else:\n            logging.debug(f\"{self.name} is all in\")\n            logging.debug(\n                f\"{self.name} has {self.bankroll} in the bank and {self.status.money_on_table} on the table\")\n            action = Action(\"CALL\", self.max_bet, all_in=True)\n            return action\n\n    def _raise(self, table, amount=None):\n        # if no amount is given, player is going all-in\n        if amount is None:\n            # print(\"No amount passed to _raise...assuming all_in\")\n            bet_amount = self.max_bet\n        else:\n            # print(\"Raise to {amount}?\")\n            bet_amount = min(self.max_bet, amount)\n\n        # set all_in flag\n        all_in = bet_amount == self.max_bet\n\n        if table.bet_amount >= bet_amount:\n            # print(f\"{self.name} has max_bet: {self.max_bet} and table is at {table.bet_amount}\")\n            # validate that this is indeed a raise\n            if all_in:\n                # print(f\"{self.name} doesn't have enough to raise, calling instead\")\n                return self.call(table)\n            else:\n                raise ValueError(f\"Cannot raise from {table.bet_amount} to a lower bet of {bet_amount}\")\n\n        # print(f\"{self.name} raises to {bet_amount}\")\n\n        action = Action(\"RAISE\", bet_amount, all_in=all_in)\n        return action\n\n    def fold(self):\n        action = Action(\"FOLD\")\n        return action", ""]}
{"filename": "src/model/test_player.py", "chunked_list": ["from model.player import Player\nfrom model.deck import Card\nfrom model.table import Table\nfrom model.action import Action\n\ndef test_init():\n    player = Player(\n        name=\"Josh\",\n        bankroll=100,\n    )\n    card1 = Card(\"A\", \"Hearts\")\n    card2 = Card(\"J\", \"Clubs\")\n    card3 = Card(\"A\", \"Spades\")\n    card4 = Card(\"3\", \"Clubs\")\n    card5 = Card(\"Q\", \"Diamonds\")\n    card6 = Card(\"3\", \"Hearts\")\n    card7 = Card(\"A\", \"Diamonds\")\n\n    player.deal_card(card1)\n    player.deal_card(card2)\n\n    table = Table(1, 4)\n\n    bankroll = player._bankroll\n    player.start_holdem_round()\n    player.place_small_blind(table)\n    assert player._bankroll == bankroll - table.small_blind\n\n    action = Action(\"CALL\", 10)\n    bankroll = player._bankroll\n    player.start_holdem_round()\n    player.process_action(action)\n    assert player._bankroll == bankroll - action.amount", "\n"]}
{"filename": "src/model/__init__.py", "chunked_list": [""]}
{"filename": "src/model/test_tournament.py", "chunked_list": ["from model.tournament import Tournament\nfrom model.table import Table\n\n\nfrom players.floyd_folds import Floyd\nfrom players.callie_calls import Callie\nfrom players.robby_random import Robby\nfrom players.ricky_raise import Ricky\n\n# not_enough_players = [", "\n# not_enough_players = [\n#     Ricky(\"Josh\", 0),\n#     Callie(\"Madi\", 100)\n# ]\n#\n# t = Tournament(not_enough_players,\n#                tournament_id=1)\n# t.play()\n", "# t.play()\n\nplayers = [\n    Ricky(\"Josh\", 100),\n    Robby(\"Cody\", 100),\n    Ricky(\"Beezie\", 100),\n    Callie(\"Madi\", 100),\n    Floyd(\"Alice\", 100),\n    Robby(\"Michelle\", 100),\n    Callie(\"Sophia\", 100),", "    Robby(\"Michelle\", 100),\n    Callie(\"Sophia\", 100),\n    Floyd(\"Bob\", 100)\n]\n\ndef test_init():\n    tournament = Tournament(players,\n                            tournament_id=1)\n    tournament.play()"]}
{"filename": "src/model/test_hand.py", "chunked_list": ["from model.hand import Hand\nfrom model.deck import Card\n\ncard_1 = Card(\"A\", \"Diamonds\")\ncard_2 = Card(\"K\", \"Diamonds\")\ncard_3 = Card(\"Q\", \"Diamonds\")\ncard_4 = Card(\"J\", \"Diamonds\")\ncard_5 = Card(\"10\", \"Diamonds\")\n\ncard_6 = Card(\"10\", \"Clubs\")", "\ncard_6 = Card(\"10\", \"Clubs\")\ncard_7 = Card(\"J\", \"Spades\")\ncard_8 = Card(\"10\", \"Hearts\")\ncard_9 = Card(\"J\", \"Hearts\")\ncard_10 = Card(\"J\", \"Spades\")\n\ncard_11 = Card(\"A\", \"Diamonds\")\ncard_12 = Card(\"2\", \"Diamonds\")\ncard_13 = Card(\"3\", \"Diamonds\")", "card_12 = Card(\"2\", \"Diamonds\")\ncard_13 = Card(\"3\", \"Diamonds\")\ncard_14 = Card(\"4\", \"Diamonds\")\ncard_15 = Card(\"5\", \"Hearts\")\n\ncard_16 = Card(\"10\", \"Clubs\")\ncard_17 = Card(\"J\", \"Spades\")\ncard_18 = Card(\"10\", \"Hearts\")\ncard_19 = Card(\"9\", \"Hearts\")\ncard_20 = Card(\"J\", \"Spades\")", "card_19 = Card(\"9\", \"Hearts\")\ncard_20 = Card(\"J\", \"Spades\")\n\nhand_1 = Hand([\n    card_1,\n    card_2,\n    card_3,\n    card_4,\n    card_5\n])", "    card_5\n])\n\nhand_2 = Hand([\n    card_6,\n    card_7,\n    card_8,\n    card_9,\n    card_10\n])", "    card_10\n])\n\nhand_3 = Hand([\n    card_11,\n    card_12,\n    card_13,\n    card_14,\n    card_15\n])", "    card_15\n])\n\nhand_4 = Hand([\n    card_16,\n    card_17,\n    card_18,\n    card_19,\n    card_20\n])", "    card_20\n])\n\ndef test_royal():\n    assert not hand_1.is_pair\n    assert not hand_1.is_three_of_a_kind\n    assert hand_1.is_straight\n    assert not hand_1.is_full_house\n    assert not hand_1.is_two_pair\n    assert hand_1.is_flush\n    assert not hand_1.is_four_of_a_kind\n    assert hand_1.is_straight_flush\n    assert hand_1.is_flush\n    assert hand_1.is_royal_flush", "\ndef test_full_house():\n    assert hand_2.is_pair\n    assert hand_2.is_three_of_a_kind\n    assert not hand_2.is_straight\n    assert hand_2.is_full_house\n    assert hand_2.is_two_pair\n    assert not hand_2.is_flush\n    assert not hand_2.is_four_of_a_kind\n    assert not hand_2.is_straight_flush\n    assert not hand_2.is_flush\n    assert not hand_2.is_royal_flush", "\ndef test_straight():\n    assert not hand_3.is_pair\n    assert not hand_3.is_three_of_a_kind\n    assert hand_3.is_straight\n    assert not hand_3.is_full_house\n    assert not hand_3.is_two_pair\n    assert not hand_3.is_flush\n    assert not hand_3.is_four_of_a_kind\n    assert not hand_3.is_straight_flush\n    assert not hand_3.is_flush\n    assert not hand_3.is_royal_flush", "\ndef test_two_pair():\n    assert hand_4.is_pair\n    assert not hand_4.is_three_of_a_kind\n    assert not hand_4.is_straight\n    assert not hand_4.is_full_house\n    assert hand_4.is_two_pair\n    assert not hand_4.is_flush\n    assert not hand_4.is_four_of_a_kind\n    assert not hand_4.is_straight_flush\n    assert not hand_4.is_flush\n    assert not hand_4.is_royal_flush", "\ndef test_royal_v_full():\n    assert hand_1 > hand_2\n\ndef test_straight_v_two_pair():\n    assert hand_3 > hand_4\n\ndef test_royal_v_two_pair():\n    assert hand_1 > hand_4\n\ndef test_full_v_two_pair():\n    assert hand_2 > hand_4", "\ndef test_full_v_two_pair():\n    assert hand_2 > hand_4"]}
{"filename": "src/model/test_deck.py", "chunked_list": ["from model.deck import Deck, Card, suits, ranks\n\ndef test_draw_1():\n    deck = Deck()\n    deck.shuffle()\n    card:Card = deck.draw()\n    print(card)\n    assert card.suit in suits\n    assert card.rank in ranks\n\ndef test_draw_2():\n    deck = Deck()\n    deck.shuffle()\n    card = deck.draw(2)[1]\n    print(card)\n    assert card.suit in suits\n    assert card.rank in ranks", "\ndef test_draw_2():\n    deck = Deck()\n    deck.shuffle()\n    card = deck.draw(2)[1]\n    print(card)\n    assert card.suit in suits\n    assert card.rank in ranks\n\ndef test_compare_ranks():\n    card1 = Card(\"A\", \"Hearts\")\n    card2 = Card(\"3\", \"Clubs\")\n    assert card1 > card2", "\ndef test_compare_ranks():\n    card1 = Card(\"A\", \"Hearts\")\n    card2 = Card(\"3\", \"Clubs\")\n    assert card1 > card2\n\ndef test_compare_ranks_2():\n    card1 = Card(\"3\", \"Hearts\")\n    card2 = Card(\"3\", \"Clubs\")\n    assert not card1 > card2"]}
{"filename": "src/model/deck.py", "chunked_list": ["import itertools\nimport random\n\n\nsuits = [\"Hearts\", \"Clubs\", \"Spades\", \"Diamonds\"]\n\nranks = {\n    \"2\": 2,\n    \"3\": 3,\n    \"4\": 4,", "    \"3\": 3,\n    \"4\": 4,\n    \"5\": 5,\n    \"6\": 6,\n    \"7\": 7,\n    \"8\": 8,\n    \"9\": 9,\n    \"10\": 10,\n    \"J\": 11,\n    \"Q\": 12,", "    \"J\": 11,\n    \"Q\": 12,\n    \"K\": 13,\n    \"A\": 14\n}\n\n\nclass Card(dict):\n    _suits = suits\n    _ranks = ranks\n\n    def __init__(self, rank, suit):\n        if not rank in self._ranks:\n            raise Exception(\"Cannot create card. Invalid rank.\")\n        if not suit in self._suits:\n            raise Exception(\"Cannot create card. Invalid suit\")\n        self.rank = rank\n        self.suit = suit\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        return \"Card(\\\"{}\\\", \\\"{}\\\")\".format(self.rank, self.suit)\n\n    def __eq__(self, other):\n        return self.rank == other.rank\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __lt__(self, other):\n        return self._ranks[self.rank] < self._ranks[other.rank]\n\n    def __le__(self, other):\n        return self._ranks[self.rank] <= self._ranks[other.rank]\n\n    def __gt__(self, other):\n        return self._ranks[other.rank] < self._ranks[self.rank]\n\n    def __ge__(self, other):\n        return self._ranks[other.rank] <= self._ranks[self.rank]", "\n\nclass Deck:\n    _suits = suits\n    _ranks = ranks\n    _cards = [Card(rank, suit) for rank, suit in itertools.product(_ranks, _suits)]\n\n    # def __init__(self, random_seed=None):\n    #     self.random_seed = random_seed\n\n    def shuffle(self):\n        self._cards = random.sample(self._cards, len(self._cards))\n\n    def draw_card(self):\n        cards_left = len(self._cards)\n        card = self._cards[0]\n        self._cards.remove(card)\n        assert len(self._cards) == cards_left - 1\n        return card\n\n    def draw_cards(self, count=1):\n        cards = []\n        for i in range(count):\n            if len(self._cards) == 0:\n                raise Exception(\"Cannot draw card. No cards left in deck\")\n            # card = self._cards[0]\n            card = self._cards.pop(0)\n            cards.append(card)\n        return cards\n\n    def draw(self, count=None):\n        if count == None:\n            return self.draw_card()\n        return self.draw_cards(count)", ""]}
{"filename": "src/model/tournament.py", "chunked_list": ["import logging\nimport os\nimport pandas as pd\nimport shortuuid\n\nfrom model.holdem_round import HoldemRound\n\n\nclass Tournament:\n    def __init__(self, players, tournament_id, results_dir=\"results\"):\n        if len(players) <= 1:\n            raise ValueError(\"\")\n        self.players = players\n        self.tournament_id = tournament_id\n        self.round_results = []\n        self.results_dir = results_dir\n        self._uuid = shortuuid.uuid()\n\n    @property\n    def num_players(self, big_blind=2):\n        return len(self.players)\n\n    def players_still_in(self, big_blind):\n        return [player for player in self.players if (player.bankroll >= big_blind)]\n\n    def player_status(self):\n        for player in self.players:\n            logging.debug(player)\n\n    def do_first_round(self):\n        players = self.players_still_in(2)\n        holdem_round = HoldemRound(\n            players=players,\n            blind=1,\n        )\n        self.players, self.table = holdem_round.play()\n        results = holdem_round.results\n        results[\"round_number\"] = 0\n        results[\"tournament_id\"] = self.tournament_id\n        results[\"tournament_uuid\"] = self._uuid\n        self.round_results.append(results)\n\n    def do_round(self, round_number):\n        players = self.players_still_in(self.table.big_blind)\n        initial_players = players.copy()\n        holdem_round = HoldemRound(\n            players=players,\n            table=self.table,\n            round_number=round_number,\n        )\n        self.players, self.table = holdem_round.play()\n        results = holdem_round.results\n        results[\"round_number\"] = round_number\n        results[\"tournament_id\"] = self.tournament_id\n        results[\"tournament_uuid\"] = self._uuid\n        results[\"player_count\"] = self.count_still_in\n        results[\"players_in_round\"] = [ player.name for player in initial_players ]\n        results[\"players_eliminated\"] = [ player.name for player in initial_players if not player in self.players_still_in(self.table.big_blind) ]\n        self.round_results.append(results)\n\n    def write_tournament_results(self):\n        df = pd.DataFrame(self.round_results)\n        filename = f\"tournement-{self._uuid}-{self.tournament_id}.csv\"\n        filepath = os.path.join(self.results_dir, filename)\n        logging.debug(f\"Writing tournament results to csv: {filepath}\")\n        os.makedirs(self.results_dir,\n                    exist_ok=True)\n        df.to_csv(filepath)\n\n    def play(self):\n        # Play rounds until only one player remains\n        self.do_first_round()\n        # players = [player for player in self.players if player.bankroll > self.tables[0].big_blind] # blinds will all move together\n        self.count_still_in = len(self.players_still_in(self.table.big_blind))\n        round_counter = 1\n        while self.count_still_in >= 2:\n            logging.debug(f\"Starting round with players: {self.players_still_in(self.table.big_blind)} last: {self.count_still_in}\")\n            self.do_round(round_counter)\n            if round_counter % 10 == 0:\n                self.table.raise_blinds()\n            self.count_still_in = len(self.players_still_in(self.table.big_blind))\n            logging.debug(self.players)\n            round_counter += 1\n        high_score = max([player.bankroll for player in self.players_still_in(self.table.big_blind)])\n        self.winners = [player for player in self.players if player.bankroll == high_score]\n        self.write_tournament_results()\n        return self.players, self.table", "class Tournament:\n    def __init__(self, players, tournament_id, results_dir=\"results\"):\n        if len(players) <= 1:\n            raise ValueError(\"\")\n        self.players = players\n        self.tournament_id = tournament_id\n        self.round_results = []\n        self.results_dir = results_dir\n        self._uuid = shortuuid.uuid()\n\n    @property\n    def num_players(self, big_blind=2):\n        return len(self.players)\n\n    def players_still_in(self, big_blind):\n        return [player for player in self.players if (player.bankroll >= big_blind)]\n\n    def player_status(self):\n        for player in self.players:\n            logging.debug(player)\n\n    def do_first_round(self):\n        players = self.players_still_in(2)\n        holdem_round = HoldemRound(\n            players=players,\n            blind=1,\n        )\n        self.players, self.table = holdem_round.play()\n        results = holdem_round.results\n        results[\"round_number\"] = 0\n        results[\"tournament_id\"] = self.tournament_id\n        results[\"tournament_uuid\"] = self._uuid\n        self.round_results.append(results)\n\n    def do_round(self, round_number):\n        players = self.players_still_in(self.table.big_blind)\n        initial_players = players.copy()\n        holdem_round = HoldemRound(\n            players=players,\n            table=self.table,\n            round_number=round_number,\n        )\n        self.players, self.table = holdem_round.play()\n        results = holdem_round.results\n        results[\"round_number\"] = round_number\n        results[\"tournament_id\"] = self.tournament_id\n        results[\"tournament_uuid\"] = self._uuid\n        results[\"player_count\"] = self.count_still_in\n        results[\"players_in_round\"] = [ player.name for player in initial_players ]\n        results[\"players_eliminated\"] = [ player.name for player in initial_players if not player in self.players_still_in(self.table.big_blind) ]\n        self.round_results.append(results)\n\n    def write_tournament_results(self):\n        df = pd.DataFrame(self.round_results)\n        filename = f\"tournement-{self._uuid}-{self.tournament_id}.csv\"\n        filepath = os.path.join(self.results_dir, filename)\n        logging.debug(f\"Writing tournament results to csv: {filepath}\")\n        os.makedirs(self.results_dir,\n                    exist_ok=True)\n        df.to_csv(filepath)\n\n    def play(self):\n        # Play rounds until only one player remains\n        self.do_first_round()\n        # players = [player for player in self.players if player.bankroll > self.tables[0].big_blind] # blinds will all move together\n        self.count_still_in = len(self.players_still_in(self.table.big_blind))\n        round_counter = 1\n        while self.count_still_in >= 2:\n            logging.debug(f\"Starting round with players: {self.players_still_in(self.table.big_blind)} last: {self.count_still_in}\")\n            self.do_round(round_counter)\n            if round_counter % 10 == 0:\n                self.table.raise_blinds()\n            self.count_still_in = len(self.players_still_in(self.table.big_blind))\n            logging.debug(self.players)\n            round_counter += 1\n        high_score = max([player.bankroll for player in self.players_still_in(self.table.big_blind)])\n        self.winners = [player for player in self.players if player.bankroll == high_score]\n        self.write_tournament_results()\n        return self.players, self.table", ""]}
{"filename": "src/model/table.py", "chunked_list": ["import json\n\nclass Table:\n    \"\"\"\n    The table object represents the observable game state for players to use in determining their play\n\n    todo: add a property that returns the fields a player needs instead of passing the whole table to them\n    - this is needed because a player could call methods on the table like new_holdem_round() otherwise\n\n    \"\"\"\n\n    def __init__(self, blind, num_players, dealer_button_index=0):\n        self.big_blind = 2 * blind\n        self.small_blind = blind\n        self.dealer_button_index = dealer_button_index\n\n        # setup dealer, blinds, and first action\n        self.num_players = num_players\n        self.new_holdem_round()\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n    def __repr__(self):\n        return self.__str__()\n\n    def new_holdem_round(self):\n        self.pot = []  # list of bet amounts including blinds\n        self.flop = None\n        self.turn = None\n        self.river = None\n        self.dealer_button_index = self.dealer_button_index  # randomly assign someone as dealer\n        self.big_blind_index = (self.dealer_button_index - 1) % self.num_players\n        self.small_blind_index = (self.dealer_button_index - 2) % self.num_players\n        self.bet_amount = self.big_blind  # betting starts at the big blind amount\n        self.new_betting_round()\n\n    def payout(self):\n        self.pot = []\n        self.bet_amount = 0\n\n    def new_betting_round(self):\n        self.active_player_index = (self.dealer_button_index + 1) % self.num_players  # play starts to the \"right\" of the dealer\n\n    @property\n    def pot_total(self):\n        return sum(self.pot)\n\n    def raise_bet(self, amount):\n        if amount > self.bet_amount:\n            self.bet_amount = amount\n        else:\n            raise Exception(f\"Current Bet is {self.bet_amount}Cannot raise bet to a lessor amount {amount}\")\n\n    def next_turn(self):\n        self.active_player_index = (self.active_player_index + 1) % self.num_players\n        # print(f\"Advanced active player index to {self.active_player_index}\")\n\n    def raise_blinds(self):\n        self.big_blind *= 2\n        self.small_blind *= 2\n\n    def next_round(self):\n        self.pot = []\n        self.dealer_button_index = (self.dealer_button_index + 1) % self.num_players\n        self.small_blind_index = (self.dealer_button_index - 2) % self.num_players\n        self.big_blind_index = (self.dealer_button_index - 1) % self.num_players\n        self.active_player_index = (self.dealer_button_index + 1) % self.num_players  # play starts to the \"right\" of the dealer", ""]}
{"filename": "src/model/test_table.py", "chunked_list": ["from model.table import Table\n\nnum_players = 8\n\n\ndef test_init():\n    table = Table(1, num_players)\n    assert table.flop is None\n    assert table.turn is None\n    assert table.river is None", "\n\n# def test_next_turn():\n#     table = Table(1, num_players)\n#     active_player_index = table.active_player_index\n#     table.next_turn()\n#     assert table.active_player_index == ( active_player_index + 1 ) % num_players\n#     for i in range(10 * num_players):\n#         assert table.active_player_index < num_players\n#         assert table.active_player_index >= 0", "#         assert table.active_player_index < num_players\n#         assert table.active_player_index >= 0\n#         table.next_turn()\n\n\ndef test_next_round():\n    table = Table(1, num_players)\n    dealer_button_index = table.dealer_button_index\n    big_blind_index = table.big_blind_index\n    small_blind_index = table.small_blind_index\n    table.next_round()\n    assert table.dealer_button_index == ( dealer_button_index + 1 ) % num_players\n    assert table.big_blind_index == ( big_blind_index + 1 ) % num_players\n    assert table.small_blind_index == ( small_blind_index + 1 ) % num_players\n    for i in range(10 * num_players):\n        assert table.dealer_button_index < num_players\n        assert table.dealer_button_index >= 0\n        table.next_round()", ""]}
