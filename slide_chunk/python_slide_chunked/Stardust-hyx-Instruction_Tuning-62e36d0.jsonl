{"filename": "ft_chatglm_lora/tokenization_chatglm.py", "chunked_list": ["\"\"\"Tokenization classes for ChatGLM.\"\"\"\nfrom typing import List, Optional, Union\nimport os\n\nfrom transformers.tokenization_utils import PreTrainedTokenizer\nfrom transformers.utils import logging, PaddingStrategy\nfrom transformers.tokenization_utils_base import EncodedInput, BatchEncoding\nfrom typing import Dict\nimport sentencepiece as spm\nimport numpy as np", "import sentencepiece as spm\nimport numpy as np\n\nlogger = logging.get_logger(__name__)\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \"THUDM/chatglm-6b\": 2048,\n}\n\n\nclass TextTokenizer:\n    def __init__(self, model_path):\n        self.sp = spm.SentencePieceProcessor()\n        self.sp.Load(model_path)\n        self.num_tokens = self.sp.vocab_size()\n\n    def encode(self, text):\n        return self.sp.EncodeAsIds(text)\n\n    def decode(self, ids: List[int]):\n        return self.sp.DecodeIds(ids)\n\n    def tokenize(self, text):\n        return self.sp.EncodeAsPieces(text)\n\n    def convert_tokens_to_ids(self, tokens):\n        return [self.sp.PieceToId(token) for token in tokens]\n\n    def convert_token_to_id(self, token):\n        return self.sp.PieceToId(token)\n\n    def convert_id_to_token(self, idx):\n        return self.sp.IdToPiece(idx)\n\n    def __len__(self):\n        return self.num_tokens", "\n\nclass TextTokenizer:\n    def __init__(self, model_path):\n        self.sp = spm.SentencePieceProcessor()\n        self.sp.Load(model_path)\n        self.num_tokens = self.sp.vocab_size()\n\n    def encode(self, text):\n        return self.sp.EncodeAsIds(text)\n\n    def decode(self, ids: List[int]):\n        return self.sp.DecodeIds(ids)\n\n    def tokenize(self, text):\n        return self.sp.EncodeAsPieces(text)\n\n    def convert_tokens_to_ids(self, tokens):\n        return [self.sp.PieceToId(token) for token in tokens]\n\n    def convert_token_to_id(self, token):\n        return self.sp.PieceToId(token)\n\n    def convert_id_to_token(self, idx):\n        return self.sp.IdToPiece(idx)\n\n    def __len__(self):\n        return self.num_tokens", "\n\nclass SPTokenizer:\n    def __init__(\n            self,\n            vocab_file,\n            num_image_tokens=20000,\n            max_blank_length=80,\n            byte_fallback=True,\n    ):\n        assert vocab_file is not None\n        self.vocab_file = vocab_file\n        self.num_image_tokens = num_image_tokens\n        self.special_tokens = [\"[MASK]\", \"[gMASK]\", \"[sMASK]\", \"<unused_0>\", \"<sop>\", \"<eop>\", \"<ENC>\", \"<dBLOCK>\"]\n        self.max_blank_length = max_blank_length\n        self.byte_fallback = byte_fallback\n        self.text_tokenizer = TextTokenizer(vocab_file)\n\n    def _get_text_tokenizer(self):\n        return self.text_tokenizer\n\n    @staticmethod\n    def get_blank_token(length: int):\n        assert length >= 2\n        return f\"<|blank_{length}|>\"\n\n    @staticmethod\n    def get_tab_token():\n        return f\"<|tab|>\"\n\n    @property\n    def num_text_tokens(self):\n        return self.text_tokenizer.num_tokens\n\n    @property\n    def num_tokens(self):\n        return self.num_image_tokens + self.num_text_tokens\n\n    @staticmethod\n    def _encode_whitespaces(text: str, max_len: int = 80):\n        text = text.replace(\"\\t\", SPTokenizer.get_tab_token())\n        for i in range(max_len, 1, -1):\n            text = text.replace(\" \" * i, SPTokenizer.get_blank_token(i))\n        return text\n\n    def _preprocess(self, text: str, linebreak=True, whitespaces=True):\n        if linebreak:\n            text = text.replace(\"\\n\", \"<n>\")\n        if whitespaces:\n            text = self._encode_whitespaces(text, max_len=self.max_blank_length)\n        return text\n\n    def encode(\n            self, text: str, linebreak=True, whitespaces=True, add_dummy_prefix=True\n    ) -> List[int]:\n        \"\"\"\n        @param text: Text to encode.\n        @param linebreak: Whether to encode newline (\\n) in text.\n        @param whitespaces: Whether to encode multiple whitespaces or tab in text, useful for source code encoding.\n        @param special_tokens: Whether to encode special token ([MASK], [gMASK], etc.) in text.\n        @param add_dummy_prefix: Whether to add dummy blank space in the beginning.\n        \"\"\"\n        text = self._preprocess(text, linebreak, whitespaces)\n        if not add_dummy_prefix:\n            text = \"<n>\" + text\n        tmp = self._get_text_tokenizer().encode(text)\n        tokens = [x + self.num_image_tokens for x in tmp]\n        return tokens if add_dummy_prefix else tokens[2:]\n\n    def decode(self, text_ids: List[int]) -> str:\n        ids = [int(_id) - self.num_image_tokens for _id in text_ids]\n        ids = [_id for _id in ids if _id >= 0]\n        text = self._get_text_tokenizer().decode(ids)\n        text = text.replace(\"<n>\", \"\\n\")\n        text = text.replace(SPTokenizer.get_tab_token(), \"\\t\")\n        for i in range(2, self.max_blank_length + 1):\n            text = text.replace(self.get_blank_token(i), \" \" * i)\n        return text\n\n    def tokenize(\n            self, text: str, linebreak=True, whitespaces=True, add_dummy_prefix=True\n    ) -> List[str]:\n        \"\"\"\n        @param text: Text to encode.\n        @param linebreak: Whether to encode newline (\\n) in text.\n        @param whitespaces: Whether to encode multiple whitespaces or tab in text, useful for source code encoding.\n        @param special_tokens: Whether to encode special token ([MASK], [gMASK], etc.) in text.\n        @param add_dummy_prefix: Whether to add dummy blank space in the beginning.\n        \"\"\"\n        text = self._preprocess(text, linebreak, whitespaces)\n        if not add_dummy_prefix:\n            text = \"<n>\" + text\n        tokens = self._get_text_tokenizer().tokenize(text)\n        return tokens if add_dummy_prefix else tokens[2:]\n\n    def __getitem__(self, x: Union[int, str]):\n        if isinstance(x, int):\n            if x < self.num_image_tokens:\n                return \"<image_{}>\".format(x)\n            else:\n                return self.text_tokenizer.convert_id_to_token(x - self.num_image_tokens)\n        elif isinstance(x, str):\n            if x.startswith(\"<image_\") and x.endswith(\">\") and x[7:-1].isdigit():\n                return int(x[7:-1])\n            else:\n                return self.text_tokenizer.convert_token_to_id(x) + self.num_image_tokens\n        else:\n            raise ValueError(\"The key should be str or int.\")", "\n\nclass ChatGLMTokenizer(PreTrainedTokenizer):\n    \"\"\"\n    Construct a ChatGLM tokenizer. Based on byte-level Byte-Pair-Encoding.\n\n    Args:\n        vocab_file (`str`):\n            Path to the vocabulary file.\n    \"\"\"\n\n    vocab_files_names = {\"vocab_file\": \"ice_text.model\"}\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n    model_input_names = [\"input_ids\", \"attention_mask\", \"position_ids\"]\n\n    def __init__(\n            self,\n            vocab_file,\n            do_lower_case=False,\n            remove_space=False,\n            bos_token='<sop>',\n            eos_token='<eop>',\n            end_token='</s>',\n            mask_token='[MASK]',\n            gmask_token='[gMASK]',\n            padding_side=\"left\",\n            pad_token=\"<pad>\",\n            unk_token=\"<unk>\",\n            num_image_tokens=20000,\n            **kwargs\n    ) -> None:\n        super().__init__(\n            do_lower_case=do_lower_case,\n            remove_space=remove_space,\n            padding_side=padding_side,\n            bos_token=bos_token,\n            eos_token=eos_token,\n            end_token=end_token,\n            mask_token=mask_token,\n            gmask_token=gmask_token,\n            pad_token=pad_token,\n            unk_token=unk_token,\n            num_image_tokens=num_image_tokens,\n            **kwargs\n        )\n\n        self.do_lower_case = do_lower_case\n        self.remove_space = remove_space\n        self.vocab_file = vocab_file\n\n        self.bos_token = bos_token\n        self.eos_token = eos_token\n        self.end_token = end_token\n        self.mask_token = mask_token\n        self.gmask_token = gmask_token\n\n        self.sp_tokenizer = SPTokenizer(vocab_file, num_image_tokens=num_image_tokens)\n\n        \"\"\" Initialisation \"\"\"\n\n    @property\n    def gmask_token_id(self) -> Optional[int]:\n        if self.gmask_token is None:\n            return None\n        return self.convert_tokens_to_ids(self.gmask_token)\n\n    @property\n    def end_token_id(self) -> Optional[int]:\n        \"\"\"\n        `Optional[int]`: Id of the end of context token in the vocabulary. Returns `None` if the token has not been\n        set.\n        \"\"\"\n        if self.end_token is None:\n            return None\n        return self.convert_tokens_to_ids(self.end_token)\n\n    @property\n    def vocab_size(self):\n        \"\"\" Returns vocab size \"\"\"\n        return self.sp_tokenizer.num_tokens\n\n    def get_vocab(self):\n        \"\"\" Returns vocab as a dict \"\"\"\n        vocab = {self._convert_id_to_token(i): i for i in range(self.vocab_size)}\n        vocab.update(self.added_tokens_encoder)\n        return vocab\n\n    def preprocess_text(self, inputs):\n        if self.remove_space:\n            outputs = \" \".join(inputs.strip().split())\n        else:\n            outputs = inputs\n\n        if self.do_lower_case:\n            outputs = outputs.lower()\n\n        return outputs\n\n    def _tokenize(self, text, **kwargs):\n        \"\"\" Returns a tokenized string. \"\"\"\n        text = self.preprocess_text(text)\n\n        seq = self.sp_tokenizer.tokenize(text)\n\n        return seq\n\n    def _decode(\n            self,\n            token_ids: Union[int, List[int]],\n            skip_special_tokens: bool = False,\n            clean_up_tokenization_spaces: bool = True,\n            **kwargs\n    ) -> str:\n        if isinstance(token_ids, int):\n            token_ids = [token_ids]\n        if len(token_ids) == 0:\n            return \"\"\n        if self.pad_token_id in token_ids:  # remove pad\n            token_ids = list(filter((self.pad_token_id).__ne__, token_ids))\n        return self.sp_tokenizer.decode(token_ids)\n\n    def _convert_token_to_id(self, token):\n        \"\"\" Converts a token (str) in an id using the vocab. \"\"\"\n        return self.sp_tokenizer[token]\n\n    def _convert_id_to_token(self, index):\n        \"\"\"Converts an index (integer) in a token (str) using the vocab.\"\"\"\n        return self.sp_tokenizer[index]\n\n    def save_vocabulary(self, save_directory, filename_prefix=None):\n        \"\"\"\n        Save the vocabulary and special tokens file to a directory.\n\n        Args:\n            save_directory (`str`):\n                The directory in which to save the vocabulary.\n            filename_prefix (`str`, *optional*):\n                An optional prefix to add to the named of the saved files.\n\n        Returns:\n            `Tuple(str)`: Paths to the files saved.\n        \"\"\"\n        if os.path.isdir(save_directory):\n            vocab_file = os.path.join(\n                save_directory, self.vocab_files_names[\"vocab_file\"]\n            )\n        else:\n            vocab_file = save_directory\n\n        with open(self.vocab_file, 'rb') as fin:\n            proto_str = fin.read()\n\n        with open(vocab_file, \"wb\") as writer:\n            writer.write(proto_str)\n\n        return (vocab_file,)\n\n    def build_inputs_with_special_tokens(\n            self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None\n    ) -> List[int]:\n        \"\"\"\n        Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and\n        adding special tokens. A BERT sequence has the following format:\n\n        - single sequence: `[CLS] X [SEP]`\n        - pair of sequences: `[CLS] A [SEP] B [SEP]`\n\n        Args:\n            token_ids_0 (`List[int]`):\n                List of IDs to which the special tokens will be added.\n            token_ids_1 (`List[int]`, *optional*):\n                Optional second list of IDs for sequence pairs.\n\n        Returns:\n            `List[int]`: List of [input IDs](../glossary#input-ids) with the appropriate special tokens.\n        \"\"\"\n        gmask_id = self.sp_tokenizer[self.gmask_token]\n        eos_id = self.sp_tokenizer[self.eos_token]\n        token_ids_0 = token_ids_0 + [gmask_id, self.sp_tokenizer[self.bos_token]]\n        if token_ids_1 is not None:\n            token_ids_0 = token_ids_0 + token_ids_1 + [eos_id]\n        return token_ids_0\n\n    def _pad(\n            self,\n            encoded_inputs: Union[Dict[str, EncodedInput], BatchEncoding],\n            max_length: Optional[int] = None,\n            padding_strategy: PaddingStrategy = PaddingStrategy.DO_NOT_PAD,\n            pad_to_multiple_of: Optional[int] = None,\n            return_attention_mask: Optional[bool] = None,\n    ) -> dict:\n        \"\"\"\n        Pad encoded inputs (on left/right and up to predefined length or max length in the batch)\n\n        Args:\n            encoded_inputs:\n                Dictionary of tokenized inputs (`List[int]`) or batch of tokenized inputs (`List[List[int]]`).\n            max_length: maximum length of the returned list and optionally padding length (see below).\n                Will truncate by taking into account the special tokens.\n            padding_strategy: PaddingStrategy to use for padding.\n\n                - PaddingStrategy.LONGEST Pad to the longest sequence in the batch\n                - PaddingStrategy.MAX_LENGTH: Pad to the max length (default)\n                - PaddingStrategy.DO_NOT_PAD: Do not pad\n                The tokenizer padding sides are defined in self.padding_side:\n\n                    - 'left': pads on the left of the sequences\n                    - 'right': pads on the right of the sequences\n            pad_to_multiple_of: (optional) Integer if set will pad the sequence to a multiple of the provided value.\n                This is especially useful to enable the use of Tensor Core on NVIDIA hardware with compute capability\n                `>= 7.5` (Volta).\n            return_attention_mask:\n                (optional) Set to False to avoid returning attention mask (default: set to model specifics)\n        \"\"\"\n        # Load from model defaults\n        bos_token_id = self.sp_tokenizer[self.bos_token]\n        mask_token_id = self.sp_tokenizer[self.mask_token]\n        gmask_token_id = self.sp_tokenizer[self.gmask_token]\n        assert self.padding_side == \"left\"\n\n        required_input = encoded_inputs[self.model_input_names[0]]\n        seq_length = len(required_input)\n\n        if padding_strategy == PaddingStrategy.LONGEST:\n            max_length = len(required_input)\n\n        if max_length is not None and pad_to_multiple_of is not None and (max_length % pad_to_multiple_of != 0):\n            max_length = ((max_length // pad_to_multiple_of) + 1) * pad_to_multiple_of\n\n        needs_to_be_padded = padding_strategy != PaddingStrategy.DO_NOT_PAD and len(required_input) != max_length\n\n        # Initialize attention mask if not present.\n        if max_length is not None:\n            if \"attention_mask\" not in encoded_inputs:\n                if bos_token_id in required_input:\n                    context_length = required_input.index(bos_token_id)\n                else:\n                    context_length = seq_length\n                attention_mask = np.ones((1, seq_length, seq_length))\n                attention_mask = np.tril(attention_mask)\n                attention_mask[:, :, :context_length] = 1\n                attention_mask = np.bool_(attention_mask < 0.5)\n                encoded_inputs[\"attention_mask\"] = attention_mask\n\n            if \"position_ids\" not in encoded_inputs:\n                if bos_token_id in required_input:\n                    context_length = required_input.index(bos_token_id)\n                else:\n                    context_length = seq_length\n                position_ids = np.arange(seq_length, dtype=np.int64)\n                mask_token = mask_token_id if mask_token_id in required_input else gmask_token_id\n                if mask_token in required_input:\n                    mask_position = required_input.index(mask_token)\n                    position_ids[context_length:] = mask_position\n                block_position_ids = np.concatenate(\n                    [np.zeros(context_length, dtype=np.int64),\n                     np.arange(1, seq_length - context_length + 1, dtype=np.int64)])\n                encoded_inputs[\"position_ids\"] = np.stack([position_ids, block_position_ids], axis=0)\n\n        if needs_to_be_padded:\n            difference = max_length - len(required_input)\n\n            if \"attention_mask\" in encoded_inputs:\n                encoded_inputs[\"attention_mask\"] = np.pad(encoded_inputs[\"attention_mask\"],\n                                                          pad_width=[(0, 0), (difference, 0), (difference, 0)],\n                                                          mode='constant', constant_values=True)\n            if \"token_type_ids\" in encoded_inputs:\n                encoded_inputs[\"token_type_ids\"] = [self.pad_token_type_id] * difference + encoded_inputs[\n                    \"token_type_ids\"\n                ]\n            if \"special_tokens_mask\" in encoded_inputs:\n                encoded_inputs[\"special_tokens_mask\"] = [1] * difference + encoded_inputs[\"special_tokens_mask\"]\n            if \"position_ids\" in encoded_inputs:\n                encoded_inputs[\"position_ids\"] = np.pad(encoded_inputs[\"position_ids\"],\n                                                        pad_width=[(0, 0), (difference, 0)])\n            encoded_inputs[self.model_input_names[0]] = [self.pad_token_id] * difference + required_input\n\n        return encoded_inputs", ""]}
{"filename": "ft_chatglm_lora/modeling_chatglm.py", "chunked_list": ["\"\"\" PyTorch ChatGLM model. \"\"\"\n\nimport math\nimport copy\nimport os\nimport warnings\nimport re\nimport sys\n\nimport torch", "\nimport torch\nimport torch.utils.checkpoint\nimport torch.nn.functional as F\nfrom torch import nn\nfrom torch.nn import CrossEntropyLoss, LayerNorm\nfrom torch.nn.utils import skip_init\nfrom typing import Optional, Tuple, Union, List, Callable, Dict, Any\n\nfrom transformers.utils import (", "\nfrom transformers.utils import (\n    add_code_sample_docstrings,\n    add_start_docstrings,\n    add_start_docstrings_to_model_forward,\n)\nfrom transformers.modeling_outputs import (\n    BaseModelOutputWithPast,\n    CausalLMOutputWithPast,\n    BaseModelOutputWithPastAndCrossAttentions,", "    CausalLMOutputWithPast,\n    BaseModelOutputWithPastAndCrossAttentions,\n)\nfrom transformers.modeling_utils import PreTrainedModel\nfrom transformers.utils import logging\nfrom transformers.generation.logits_process import LogitsProcessor\nfrom transformers.generation.utils import LogitsProcessorList, StoppingCriteriaList, GenerationConfig, ModelOutput\n\nfrom configuration_chatglm import ChatGLMConfig\n", "from configuration_chatglm import ChatGLMConfig\n\n# flags required to enable jit fusion kernels\n\nif sys.platform != 'darwin':\n    torch._C._jit_set_profiling_mode(False)\n    torch._C._jit_set_profiling_executor(False)\n    torch._C._jit_override_can_fuse_on_cpu(True)\n    torch._C._jit_override_can_fuse_on_gpu(True)\n", "\nlogger = logging.get_logger(__name__)\n\n_CHECKPOINT_FOR_DOC = \"THUDM/ChatGLM-6B\"\n_CONFIG_FOR_DOC = \"ChatGLM6BConfig\"\n\nCHATGLM_6B_PRETRAINED_MODEL_ARCHIVE_LIST = [\n    \"THUDM/chatglm-6b\",\n    # See all ChatGLM-6B models at https://huggingface.co/models?filter=chatglm\n]", "    # See all ChatGLM-6B models at https://huggingface.co/models?filter=chatglm\n]\n\n\nclass InvalidScoreLogitsProcessor(LogitsProcessor):\n    def __call__(self, input_ids: torch.LongTensor, scores: torch.FloatTensor) -> torch.FloatTensor:\n        if torch.isnan(scores).any() or torch.isinf(scores).any():\n            scores.zero_()\n            scores[..., 5] = 5e4\n        return scores", "\n\ndef load_tf_weights_in_chatglm_6b(model, config, tf_checkpoint_path):\n    \"\"\"Load tf checkpoints in a pytorch model.\"\"\"\n    try:\n        import re\n\n        import numpy as np\n        import tensorflow as tf\n    except ImportError:\n        logger.error(\n            \"Loading a TensorFlow model in PyTorch, requires TensorFlow to be installed. Please see \"\n            \"https://www.tensorflow.org/install/ for installation instructions.\"\n        )\n        raise\n    tf_path = os.path.abspath(tf_checkpoint_path)\n    logger.info(f\"Converting TensorFlow checkpoint from {tf_path}\")\n    # Load weights from TF model\n    init_vars = tf.train.list_variables(tf_path)\n    names = []\n    arrays = []\n    for name, shape in init_vars:\n        logger.info(f\"Loading TF weight {name} with shape {shape}\")\n        array = tf.train.load_variable(tf_path, name)\n        names.append(name)\n        arrays.append(array)\n\n    for name, array in zip(names, arrays):\n        name = name.split(\"/\")\n        # adam_v and adam_m are variables used in AdamWeightDecayOptimizer to calculated m and v\n        # which are not required for using pretrained model\n        if any(\n                n in [\"adam_v\", \"adam_m\", \"AdamWeightDecayOptimizer\", \"AdamWeightDecayOptimizer_1\", \"global_step\"]\n                for n in name\n        ):\n            logger.info(f\"Skipping {'/'.join(name)}\")\n            continue\n        pointer = model\n        for m_name in name:\n            if re.fullmatch(r\"[A-Za-z]+_\\d+\", m_name):\n                scope_names = re.split(r\"_(\\d+)\", m_name)\n            else:\n                scope_names = [m_name]\n            if scope_names[0] == \"kernel\" or scope_names[0] == \"gamma\":\n                pointer = getattr(pointer, \"weight\")\n            elif scope_names[0] == \"output_bias\" or scope_names[0] == \"beta\":\n                pointer = getattr(pointer, \"bias\")\n            elif scope_names[0] == \"output_weights\":\n                pointer = getattr(pointer, \"weight\")\n            elif scope_names[0] == \"squad\":\n                pointer = getattr(pointer, \"classifier\")\n            else:\n                try:\n                    pointer = getattr(pointer, scope_names[0])\n                except AttributeError:\n                    logger.info(f\"Skipping {'/'.join(name)}\")\n                    continue\n            if len(scope_names) >= 2:\n                num = int(scope_names[1])\n                pointer = pointer[num]\n        if m_name[-11:] == \"_embeddings\":\n            pointer = getattr(pointer, \"weight\")\n        elif m_name == \"kernel\":\n            array = np.transpose(array)\n        try:\n            assert (\n                    pointer.shape == array.shape\n            ), f\"Pointer shape {pointer.shape} and array shape {array.shape} mismatched\"\n        except AssertionError as e:\n            e.args += (pointer.shape, array.shape)\n            raise\n        logger.info(f\"Initialize PyTorch weight {name}\")\n        pointer.data = torch.from_numpy(array)\n    return model", "\n\nclass PrefixEncoder(torch.nn.Module):\n    \"\"\"\n    The torch.nn model to encode the prefix\n    Input shape: (batch-size, prefix-length)\n    Output shape: (batch-size, prefix-length, 2*layers*hidden)\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.prefix_projection = config.prefix_projection\n        if self.prefix_projection:\n            # Use a two-layer MLP to encode the prefix\n            self.embedding = torch.nn.Embedding(config.pre_seq_len, config.hidden_size)\n            self.trans = torch.nn.Sequential(\n                torch.nn.Linear(config.hidden_size, config.hidden_size),\n                torch.nn.Tanh(),\n                torch.nn.Linear(config.hidden_size, config.num_layers * config.hidden_size * 2)\n            )\n        else:\n            self.embedding = torch.nn.Embedding(config.pre_seq_len, config.num_layers * config.hidden_size * 2)\n\n    def forward(self, prefix: torch.Tensor):\n        if self.prefix_projection:\n            prefix_tokens = self.embedding(prefix)\n            past_key_values = self.trans(prefix_tokens)\n        else:\n            past_key_values = self.embedding(prefix)\n        return past_key_values", "\n\n@torch.jit.script\ndef gelu_impl(x):\n    \"\"\"OpenAI's gelu implementation.\"\"\"\n    return 0.5 * x * (1.0 + torch.tanh(0.7978845608028654 * x *\n                                       (1.0 + 0.044715 * x * x)))\n\n\ndef gelu(x):\n    return gelu_impl(x)", "\ndef gelu(x):\n    return gelu_impl(x)\n\n\nclass RotaryEmbedding(torch.nn.Module):\n    def __init__(self, dim, base=10000, precision=torch.half, learnable=False):\n        super().__init__()\n        inv_freq = 1. / (base ** (torch.arange(0, dim, 2).float() / dim))\n        inv_freq = inv_freq.half()\n        self.learnable = learnable\n        if learnable:\n            self.inv_freq = torch.nn.Parameter(inv_freq)\n            self.max_seq_len_cached = None\n        else:\n            self.register_buffer('inv_freq', inv_freq)\n            self.max_seq_len_cached = None\n            self.cos_cached = None\n            self.sin_cached = None\n        self.precision = precision\n\n    def _load_from_state_dict(self, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys,\n                              error_msgs):\n        pass\n\n    def forward(self, x, seq_dim=1, seq_len=None):\n        if seq_len is None:\n            seq_len = x.shape[seq_dim]\n        if self.max_seq_len_cached is None or (seq_len > self.max_seq_len_cached):\n            self.max_seq_len_cached = None if self.learnable else seq_len\n            t = torch.arange(seq_len, device=x.device, dtype=self.inv_freq.dtype)\n            freqs = torch.einsum('i,j->ij', t, self.inv_freq)\n            # Different from paper, but it uses a different permutation in order to obtain the same calculation\n            emb = torch.cat((freqs, freqs), dim=-1).to(x.device)\n            if self.precision == torch.bfloat16:\n                emb = emb.float()\n\n            # [sx, 1 (b * np), hn]\n            cos_cached = emb.cos()[:, None, :]\n            sin_cached = emb.sin()[:, None, :]\n            if self.precision == torch.bfloat16:\n                cos_cached = cos_cached.bfloat16()\n                sin_cached = sin_cached.bfloat16()\n            if self.learnable:\n                return cos_cached, sin_cached\n            self.cos_cached, self.sin_cached = cos_cached, sin_cached\n        return self.cos_cached[:seq_len, ...], self.sin_cached[:seq_len, ...]\n\n    def _apply(self, fn):\n        if self.cos_cached is not None:\n            self.cos_cached = fn(self.cos_cached)\n        if self.sin_cached is not None:\n            self.sin_cached = fn(self.sin_cached)\n        return super()._apply(fn)", "\n\ndef rotate_half(x):\n    x1, x2 = x[..., :x.shape[-1] // 2], x[..., x.shape[-1] // 2:]\n    return torch.cat((-x2, x1), dim=x1.ndim - 1)  # dim=-1 triggers a bug in earlier torch versions\n\n\n@torch.jit.script\ndef apply_rotary_pos_emb_index(q, k, cos, sin, position_id):\n    # position_id: [sq, b], q, k: [sq, b, np, hn], cos: [sq, 1, hn] -> [sq, b, 1, hn]\n    cos, sin = F.embedding(position_id, cos.squeeze(1)).unsqueeze(2), \\\n        F.embedding(position_id, sin.squeeze(1)).unsqueeze(2)\n    q, k = (q * cos) + (rotate_half(q) * sin), (k * cos) + (rotate_half(k) * sin)\n    return q, k", "def apply_rotary_pos_emb_index(q, k, cos, sin, position_id):\n    # position_id: [sq, b], q, k: [sq, b, np, hn], cos: [sq, 1, hn] -> [sq, b, 1, hn]\n    cos, sin = F.embedding(position_id, cos.squeeze(1)).unsqueeze(2), \\\n        F.embedding(position_id, sin.squeeze(1)).unsqueeze(2)\n    q, k = (q * cos) + (rotate_half(q) * sin), (k * cos) + (rotate_half(k) * sin)\n    return q, k\n\n\ndef attention_fn(\n        self,\n        query_layer,\n        key_layer,\n        value_layer,\n        attention_mask,\n        hidden_size_per_partition,\n        layer_id,\n        layer_past=None,\n        scaling_attention_score=True,\n        use_cache=False,\n):\n    if layer_past is not None:\n        past_key, past_value = layer_past[0], layer_past[1]\n        key_layer = torch.cat((past_key, key_layer), dim=0)\n        value_layer = torch.cat((past_value, value_layer), dim=0)\n\n    # seqlen, batch, num_attention_heads, hidden_size_per_attention_head\n    seq_len, b, nh, hidden_size = key_layer.shape\n\n    if use_cache:\n        present = (key_layer, value_layer)\n    else:\n        present = None\n\n    query_key_layer_scaling_coeff = float(layer_id + 1)\n    if scaling_attention_score:\n        query_layer = query_layer / (math.sqrt(hidden_size) * query_key_layer_scaling_coeff)\n\n    # ===================================\n    # Raw attention scores. [b, np, s, s]\n    # ===================================\n\n    # [b, np, sq, sk]\n    output_size = (query_layer.size(1), query_layer.size(2), query_layer.size(0), key_layer.size(0))\n\n    # [sq, b, np, hn] -> [sq, b * np, hn]\n    query_layer = query_layer.view(output_size[2], output_size[0] * output_size[1], -1)\n    # [sk, b, np, hn] -> [sk, b * np, hn]\n    key_layer = key_layer.view(output_size[3], output_size[0] * output_size[1], -1)\n\n    matmul_result = torch.zeros(\n        1, 1, 1,\n        dtype=query_layer.dtype,\n        device=query_layer.device,\n    )\n\n    matmul_result = torch.baddbmm(\n        matmul_result,\n        query_layer.transpose(0, 1),  # [b * np, sq, hn]\n        key_layer.transpose(0, 1).transpose(1, 2),  # [b * np, hn, sk]\n        beta=0.0,\n        alpha=1.0,\n    )\n\n    # change view to [b, np, sq, sk]\n    attention_scores = matmul_result.view(*output_size)\n\n    if self.scale_mask_softmax:\n        self.scale_mask_softmax.scale = query_key_layer_scaling_coeff\n        attention_probs = self.scale_mask_softmax(attention_scores, attention_mask.contiguous())\n    else:\n        if not (attention_mask == 0).all():\n            # if auto-regressive, skip\n            attention_scores.masked_fill_(attention_mask, -10000.0)\n        dtype = attention_scores.dtype\n        attention_scores = attention_scores.float()\n        attention_scores = attention_scores * query_key_layer_scaling_coeff\n\n        attention_probs = F.softmax(attention_scores, dim=-1)\n\n        attention_probs = attention_probs.type(dtype)\n\n    # =========================\n    # Context layer. [sq, b, hp]\n    # =========================\n\n    # value_layer -> context layer.\n    # [sk, b, np, hn] --> [b, np, sq, hn]\n\n    # context layer shape: [b, np, sq, hn]\n    output_size = (value_layer.size(1), value_layer.size(2), query_layer.size(0), value_layer.size(3))\n\n    # change view [sk, b * np, hn]\n    value_layer = value_layer.view(value_layer.size(0), output_size[0] * output_size[1], -1)\n\n    # change view [b * np, sq, sk]\n    attention_probs = attention_probs.view(output_size[0] * output_size[1], output_size[2], -1)\n\n    # matmul: [b * np, sq, hn]\n    context_layer = torch.bmm(attention_probs, value_layer.transpose(0, 1))\n\n    # change view [b, np, sq, hn]\n    context_layer = context_layer.view(*output_size)\n\n    # [b, np, sq, hn] --> [sq, b, np, hn]\n    context_layer = context_layer.permute(2, 0, 1, 3).contiguous()\n\n    # [sq, b, np, hn] --> [sq, b, hp]\n    new_context_layer_shape = context_layer.size()[:-2] + (hidden_size_per_partition,)\n    context_layer = context_layer.view(*new_context_layer_shape)\n\n    outputs = (context_layer, present, attention_probs)\n\n    return outputs", "def attention_fn(\n        self,\n        query_layer,\n        key_layer,\n        value_layer,\n        attention_mask,\n        hidden_size_per_partition,\n        layer_id,\n        layer_past=None,\n        scaling_attention_score=True,\n        use_cache=False,\n):\n    if layer_past is not None:\n        past_key, past_value = layer_past[0], layer_past[1]\n        key_layer = torch.cat((past_key, key_layer), dim=0)\n        value_layer = torch.cat((past_value, value_layer), dim=0)\n\n    # seqlen, batch, num_attention_heads, hidden_size_per_attention_head\n    seq_len, b, nh, hidden_size = key_layer.shape\n\n    if use_cache:\n        present = (key_layer, value_layer)\n    else:\n        present = None\n\n    query_key_layer_scaling_coeff = float(layer_id + 1)\n    if scaling_attention_score:\n        query_layer = query_layer / (math.sqrt(hidden_size) * query_key_layer_scaling_coeff)\n\n    # ===================================\n    # Raw attention scores. [b, np, s, s]\n    # ===================================\n\n    # [b, np, sq, sk]\n    output_size = (query_layer.size(1), query_layer.size(2), query_layer.size(0), key_layer.size(0))\n\n    # [sq, b, np, hn] -> [sq, b * np, hn]\n    query_layer = query_layer.view(output_size[2], output_size[0] * output_size[1], -1)\n    # [sk, b, np, hn] -> [sk, b * np, hn]\n    key_layer = key_layer.view(output_size[3], output_size[0] * output_size[1], -1)\n\n    matmul_result = torch.zeros(\n        1, 1, 1,\n        dtype=query_layer.dtype,\n        device=query_layer.device,\n    )\n\n    matmul_result = torch.baddbmm(\n        matmul_result,\n        query_layer.transpose(0, 1),  # [b * np, sq, hn]\n        key_layer.transpose(0, 1).transpose(1, 2),  # [b * np, hn, sk]\n        beta=0.0,\n        alpha=1.0,\n    )\n\n    # change view to [b, np, sq, sk]\n    attention_scores = matmul_result.view(*output_size)\n\n    if self.scale_mask_softmax:\n        self.scale_mask_softmax.scale = query_key_layer_scaling_coeff\n        attention_probs = self.scale_mask_softmax(attention_scores, attention_mask.contiguous())\n    else:\n        if not (attention_mask == 0).all():\n            # if auto-regressive, skip\n            attention_scores.masked_fill_(attention_mask, -10000.0)\n        dtype = attention_scores.dtype\n        attention_scores = attention_scores.float()\n        attention_scores = attention_scores * query_key_layer_scaling_coeff\n\n        attention_probs = F.softmax(attention_scores, dim=-1)\n\n        attention_probs = attention_probs.type(dtype)\n\n    # =========================\n    # Context layer. [sq, b, hp]\n    # =========================\n\n    # value_layer -> context layer.\n    # [sk, b, np, hn] --> [b, np, sq, hn]\n\n    # context layer shape: [b, np, sq, hn]\n    output_size = (value_layer.size(1), value_layer.size(2), query_layer.size(0), value_layer.size(3))\n\n    # change view [sk, b * np, hn]\n    value_layer = value_layer.view(value_layer.size(0), output_size[0] * output_size[1], -1)\n\n    # change view [b * np, sq, sk]\n    attention_probs = attention_probs.view(output_size[0] * output_size[1], output_size[2], -1)\n\n    # matmul: [b * np, sq, hn]\n    context_layer = torch.bmm(attention_probs, value_layer.transpose(0, 1))\n\n    # change view [b, np, sq, hn]\n    context_layer = context_layer.view(*output_size)\n\n    # [b, np, sq, hn] --> [sq, b, np, hn]\n    context_layer = context_layer.permute(2, 0, 1, 3).contiguous()\n\n    # [sq, b, np, hn] --> [sq, b, hp]\n    new_context_layer_shape = context_layer.size()[:-2] + (hidden_size_per_partition,)\n    context_layer = context_layer.view(*new_context_layer_shape)\n\n    outputs = (context_layer, present, attention_probs)\n\n    return outputs", "\n\ndef default_init(cls, *args, **kwargs):\n    return cls(*args, **kwargs)\n\n\nclass SelfAttention(torch.nn.Module):\n    def __init__(self, hidden_size, num_attention_heads,\n                 layer_id, hidden_size_per_attention_head=None, bias=True,\n                 params_dtype=torch.float, position_encoding_2d=True, empty_init=True):\n        if empty_init:\n            init_method = skip_init\n        else:\n            init_method = default_init\n        super(SelfAttention, self).__init__()\n\n        self.layer_id = layer_id\n        self.hidden_size = hidden_size\n        self.hidden_size_per_partition = hidden_size\n        self.num_attention_heads = num_attention_heads\n        self.num_attention_heads_per_partition = num_attention_heads\n        self.position_encoding_2d = position_encoding_2d\n        self.rotary_emb = RotaryEmbedding(\n            self.hidden_size // (self.num_attention_heads * 2)\n            if position_encoding_2d\n            else self.hidden_size // self.num_attention_heads,\n            base=10000,\n            precision=torch.half,\n            learnable=False,\n        )\n\n        self.scale_mask_softmax = None\n\n        if hidden_size_per_attention_head is None:\n            self.hidden_size_per_attention_head = hidden_size // num_attention_heads\n        else:\n            self.hidden_size_per_attention_head = hidden_size_per_attention_head\n\n        self.inner_hidden_size = num_attention_heads * self.hidden_size_per_attention_head\n\n        # Strided linear layer.\n        self.query_key_value = init_method(\n            torch.nn.Linear,\n            hidden_size,\n            3 * self.inner_hidden_size,\n            bias=bias,\n            dtype=params_dtype,\n        )\n\n        self.dense = init_method(\n            torch.nn.Linear,\n            self.inner_hidden_size,\n            hidden_size,\n            bias=bias,\n            dtype=params_dtype,\n        )\n\n    @staticmethod\n    def attention_mask_func(attention_scores, attention_mask):\n        attention_scores.masked_fill_(attention_mask, -10000.0)\n        return attention_scores\n\n    def split_tensor_along_last_dim(self, tensor, num_partitions,\n                                    contiguous_split_chunks=False):\n        \"\"\"Split a tensor along its last dimension.\n        Arguments:\n            tensor: input tensor.\n            num_partitions: number of partitions to split the tensor\n            contiguous_split_chunks: If True, make each chunk contiguous\n                                    in memory.\n        \"\"\"\n        # Get the size and dimension.\n        last_dim = tensor.dim() - 1\n        last_dim_size = tensor.size()[last_dim] // num_partitions\n        # Split.\n        tensor_list = torch.split(tensor, last_dim_size, dim=last_dim)\n        # Note: torch.split does not create contiguous tensors by default.\n        if contiguous_split_chunks:\n            return tuple(chunk.contiguous() for chunk in tensor_list)\n\n        return tensor_list\n\n    def forward(\n            self,\n            hidden_states: torch.Tensor,\n            position_ids,\n            attention_mask: torch.Tensor,\n            layer_id,\n            layer_past: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,\n            use_cache: bool = False,\n            output_attentions: bool = False,\n    ):\n        \"\"\"\n        hidden_states: [seq_len, batch, hidden_size]\n        attention_mask: [(1, 1), seq_len, seq_len]\n        \"\"\"\n\n        # [seq_len, batch, 3 * hidden_size]\n        mixed_raw_layer = self.query_key_value(hidden_states)\n\n        # [seq_len, batch, 3 * hidden_size] --> [seq_len, batch, num_attention_heads, 3 * hidden_size_per_attention_head]\n        new_tensor_shape = mixed_raw_layer.size()[:-1] + (\n            self.num_attention_heads_per_partition,\n            3 * self.hidden_size_per_attention_head,\n        )\n        mixed_raw_layer = mixed_raw_layer.view(*new_tensor_shape)\n\n        # [seq_len, batch, num_attention_heads, hidden_size_per_attention_head]\n        (query_layer, key_layer, value_layer) = self.split_tensor_along_last_dim(mixed_raw_layer, 3)\n\n        if self.position_encoding_2d:\n            q1, q2 = query_layer.chunk(2, dim=(query_layer.ndim - 1))\n            k1, k2 = key_layer.chunk(2, dim=(key_layer.ndim - 1))\n            cos, sin = self.rotary_emb(q1, seq_len=position_ids.max() + 1)\n            position_ids, block_position_ids = position_ids[:, 0, :].transpose(0, 1).contiguous(), \\\n                position_ids[:, 1, :].transpose(0, 1).contiguous()\n            q1, k1 = apply_rotary_pos_emb_index(q1, k1, cos, sin, position_ids)\n            q2, k2 = apply_rotary_pos_emb_index(q2, k2, cos, sin, block_position_ids)\n            query_layer = torch.concat([q1, q2], dim=(q1.ndim - 1))\n            key_layer = torch.concat([k1, k2], dim=(k1.ndim - 1))\n        else:\n            position_ids = position_ids.transpose(0, 1)\n            cos, sin = self.rotary_emb(value_layer, seq_len=position_ids.max() + 1)\n            # [seq_len, batch, num_attention_heads, hidden_size_per_attention_head]\n            query_layer, key_layer = apply_rotary_pos_emb_index(query_layer, key_layer, cos, sin, position_ids)\n\n        # [seq_len, batch, hidden_size]\n        context_layer, present, attention_probs = attention_fn(\n            self=self,\n            query_layer=query_layer,\n            key_layer=key_layer,\n            value_layer=value_layer,\n            attention_mask=attention_mask,\n            hidden_size_per_partition=self.hidden_size_per_partition,\n            layer_id=layer_id,\n            layer_past=layer_past,\n            use_cache=use_cache\n        )\n\n        output = self.dense(context_layer)\n\n        outputs = (output, present)\n\n        if output_attentions:\n            outputs += (attention_probs,)\n\n        return outputs  # output, present, attention_probs", "\n\nclass GEGLU(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.activation_fn = F.gelu\n\n    def forward(self, x):\n        # dim=-1 breaks in jit for pt<1.10\n        x1, x2 = x.chunk(2, dim=(x.ndim - 1))\n        return x1 * self.activation_fn(x2)", "\n\nclass GLU(torch.nn.Module):\n    def __init__(self, hidden_size, inner_hidden_size=None,\n                 layer_id=None, bias=True, activation_func=gelu, params_dtype=torch.float, empty_init=True):\n        super(GLU, self).__init__()\n        if empty_init:\n            init_method = skip_init\n        else:\n            init_method = default_init\n        self.layer_id = layer_id\n        self.activation_func = activation_func\n\n        # Project to 4h.\n        self.hidden_size = hidden_size\n        if inner_hidden_size is None:\n            inner_hidden_size = 4 * hidden_size\n        self.inner_hidden_size = inner_hidden_size\n        self.dense_h_to_4h = init_method(\n            torch.nn.Linear,\n            self.hidden_size,\n            self.inner_hidden_size,\n            bias=bias,\n            dtype=params_dtype,\n        )\n        # Project back to h.\n        self.dense_4h_to_h = init_method(\n            torch.nn.Linear,\n            self.inner_hidden_size,\n            self.hidden_size,\n            bias=bias,\n            dtype=params_dtype,\n        )\n\n    def forward(self, hidden_states):\n        \"\"\"\n        hidden_states: [seq_len, batch, hidden_size]\n        \"\"\"\n\n        # [seq_len, batch, inner_hidden_size]\n        intermediate_parallel = self.dense_h_to_4h(hidden_states)\n\n        intermediate_parallel = self.activation_func(intermediate_parallel)\n\n        output = self.dense_4h_to_h(intermediate_parallel)\n\n        return output", "\n\nclass GLMBlock(torch.nn.Module):\n    def __init__(\n            self,\n            hidden_size,\n            num_attention_heads,\n            layernorm_epsilon,\n            layer_id,\n            inner_hidden_size=None,\n            hidden_size_per_attention_head=None,\n            layernorm=LayerNorm,\n            use_bias=True,\n            params_dtype=torch.float,\n            num_layers=28,\n            position_encoding_2d=True,\n            empty_init=True\n    ):\n        super(GLMBlock, self).__init__()\n        # Set output layer initialization if not provided.\n\n        self.layer_id = layer_id\n\n        # Layernorm on the input data.\n        self.input_layernorm = layernorm(hidden_size, eps=layernorm_epsilon)\n\n        self.position_encoding_2d = position_encoding_2d\n\n        # Self attention.\n        self.attention = SelfAttention(\n            hidden_size,\n            num_attention_heads,\n            layer_id,\n            hidden_size_per_attention_head=hidden_size_per_attention_head,\n            bias=use_bias,\n            params_dtype=params_dtype,\n            position_encoding_2d=self.position_encoding_2d,\n            empty_init=empty_init\n        )\n\n        # Layernorm on the input data.\n        self.post_attention_layernorm = layernorm(hidden_size, eps=layernorm_epsilon)\n\n        self.num_layers = num_layers\n\n        # GLU\n        self.mlp = GLU(\n            hidden_size,\n            inner_hidden_size=inner_hidden_size,\n            bias=use_bias,\n            layer_id=layer_id,\n            params_dtype=params_dtype,\n            empty_init=empty_init\n        )\n\n    def forward(\n            self,\n            hidden_states: torch.Tensor,\n            position_ids,\n            attention_mask: torch.Tensor,\n            layer_id,\n            layer_past: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,\n            use_cache: bool = False,\n            output_attentions: bool = False,\n    ):\n        \"\"\"\n        hidden_states: [seq_len, batch, hidden_size]\n        attention_mask: [(1, 1), seq_len, seq_len]\n        \"\"\"\n\n        # Layer norm at the begining of the transformer layer.\n        # [seq_len, batch, hidden_size]\n        attention_input = self.input_layernorm(hidden_states)\n\n        # Self attention.\n        attention_outputs = self.attention(\n            attention_input,\n            position_ids,\n            attention_mask=attention_mask,\n            layer_id=layer_id,\n            layer_past=layer_past,\n            use_cache=use_cache,\n            output_attentions=output_attentions\n        )\n\n        attention_output = attention_outputs[0]\n\n        outputs = attention_outputs[1:]\n\n        # Residual connection.\n        alpha = (2 * self.num_layers) ** 0.5\n        hidden_states = attention_input * alpha + attention_output\n\n        mlp_input = self.post_attention_layernorm(hidden_states)\n\n        # MLP.\n        mlp_output = self.mlp(mlp_input)\n\n        # Second residual connection.\n        output = mlp_input * alpha + mlp_output\n\n        if use_cache:\n            outputs = (output,) + outputs\n        else:\n            outputs = (output,) + outputs[1:]\n\n        return outputs  # hidden_states, present, attentions", "\n\nclass ChatGLMPreTrainedModel(PreTrainedModel):\n    \"\"\"\n    An abstract class to handle weights initialization and\n    a simple interface for downloading and loading pretrained models.\n    \"\"\"\n\n    is_parallelizable = False\n    supports_gradient_checkpointing = True\n    config_class = ChatGLMConfig\n    base_model_prefix = \"transformer\"\n    _no_split_modules = [\"GLMBlock\"]\n\n    def __init__(self, *inputs, **kwargs):\n        super().__init__(*inputs, **kwargs)\n\n    def _init_weights(self, module: nn.Module):\n        \"\"\"Initialize the weights.\"\"\"\n        return\n\n    def get_masks(self, input_ids, device):\n        batch_size, seq_length = input_ids.shape\n        context_lengths = [seq.tolist().index(self.config.bos_token_id) for seq in input_ids]\n        attention_mask = torch.ones((batch_size, seq_length, seq_length), device=device)\n        attention_mask.tril_()\n        for i, context_length in enumerate(context_lengths):\n            attention_mask[i, :, :context_length] = 1\n        attention_mask.unsqueeze_(1)\n        attention_mask = (attention_mask < 0.5).bool()\n\n        return attention_mask\n\n    def get_position_ids(self, input_ids, mask_positions, device, use_gmasks=None):\n        batch_size, seq_length = input_ids.shape\n        if use_gmasks is None:\n            use_gmasks = [False] * batch_size\n        context_lengths = [seq.tolist().index(self.config.bos_token_id) for seq in input_ids]\n        if self.position_encoding_2d:\n            position_ids = torch.arange(seq_length, dtype=torch.long, device=device).unsqueeze(0).repeat(batch_size, 1)\n            for i, context_length in enumerate(context_lengths):\n                position_ids[i, context_length:] = mask_positions[i]\n            block_position_ids = [torch.cat((\n                torch.zeros(context_length, dtype=torch.long, device=device),\n                torch.arange(seq_length - context_length, dtype=torch.long, device=device) + 1\n            )) for context_length in context_lengths]\n            block_position_ids = torch.stack(block_position_ids, dim=0)\n            position_ids = torch.stack((position_ids, block_position_ids), dim=1)\n        else:\n            position_ids = torch.arange(seq_length, dtype=torch.long, device=device).unsqueeze(0).repeat(batch_size, 1)\n            for i, context_length in enumerate(context_lengths):\n                if not use_gmasks[i]:\n                    position_ids[i, context_length:] = mask_positions[i]\n\n        return position_ids\n\n    def _set_gradient_checkpointing(self, module, value=False):\n        if isinstance(module, ChatGLMModel):\n            module.gradient_checkpointing = value", "\n\nCHATGLM_6B_START_DOCSTRING = r\"\"\"\n    This model is a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) sub-class.\n    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general\n    usage and behavior.\n\n    Parameters:\n        config ([`~ChatGLM6BConfig`]): Model configuration class with all the parameters of the model.\n            Initializing with a config file does not load the weights associated with the model, only the configuration.", "        config ([`~ChatGLM6BConfig`]): Model configuration class with all the parameters of the model.\n            Initializing with a config file does not load the weights associated with the model, only the configuration.\n            Check out the [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n\"\"\"\n\nCHATGLM_6B_INPUTS_DOCSTRING = r\"\"\"\n    Args:\n        input_ids (`torch.LongTensor` of shape `({0})`):\n            Indices of input sequence tokens in the vocabulary.\n", "            Indices of input sequence tokens in the vocabulary.\n\n            Indices can be obtained using [`ChatGLM6BTokenizer`].\n            See [`PreTrainedTokenizer.encode`] and\n            [`PreTrainedTokenizer.__call__`] for details.\n\n            [What are input IDs?](../glossary#input-ids)\n        attention_mask (`torch.FloatTensor` of shape `({0})`, *optional*):\n            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n", "            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n\n            - 1 for tokens that are **not masked**,\n            - 0 for tokens that are **masked**.\n\n            [What are attention masks?](../glossary#attention-mask)\n        token_type_ids (`torch.LongTensor` of shape `({0})`, *optional*):\n            Segment token indices to indicate first and second portions of the inputs. Indices are selected in `[0, 1]`:\n\n            - 0 corresponds to a *sentence A* token,", "\n            - 0 corresponds to a *sentence A* token,\n            - 1 corresponds to a *sentence B* token.\n\n            [What are token type IDs?](../glossary#token-type-ids)\n        position_ids (`torch.LongTensor` of shape `({0})`, *optional*):\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range `[0, config.max_position_embeddings - 1]`.\n\n            [What are position IDs?](../glossary#position-ids)", "\n            [What are position IDs?](../glossary#position-ids)\n        head_mask (`torch.FloatTensor` of shape `(num_heads,)` or `(num_layers, num_heads)`, *optional*):\n            Mask to nullify selected heads of the self-attention modules. Mask values selected in `[0, 1]`:\n\n            - 1 indicates the head is **not masked**,\n            - 0 indicates the head is **masked**.\n\n        inputs_embeds (`torch.FloatTensor` of shape `({0}, hidden_size)`, *optional*):\n            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation.", "        inputs_embeds (`torch.FloatTensor` of shape `({0}, hidden_size)`, *optional*):\n            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation.\n            This is useful if you want more control over how to convert *input_ids* indices into associated vectors\n            than the model's internal embedding lookup matrix.\n        output_attentions (`bool`, *optional*):\n            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n            tensors for more detail.\n        output_hidden_states (`bool`, *optional*):\n            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n            more detail.", "            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n            more detail.\n        return_dict (`bool`, *optional*):\n            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n\"\"\"\n\n\n@add_start_docstrings(\n    \"The bare ChatGLM-6B Model transformer outputting raw hidden-states without any specific head on top.\",\n    CHATGLM_6B_START_DOCSTRING,", "    \"The bare ChatGLM-6B Model transformer outputting raw hidden-states without any specific head on top.\",\n    CHATGLM_6B_START_DOCSTRING,\n)\nclass ChatGLMModel(ChatGLMPreTrainedModel):\n    \"\"\"\n\n    The model can behave as an encoder (with only self-attention) as well\n    as a decoder, in which case a layer of cross-attention is added between\n    the self-attention layers, following the architecture described in [Attention is\n    all you need](https://arxiv.org/abs/1706.03762) by Ashish Vaswani,\n    Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser and Illia Polosukhin.\n\n    To behave as an decoder the model needs to be initialized with the\n    `is_decoder` argument of the configuration set to `True`.\n    To be used in a Seq2Seq model, the model needs to initialized with both `is_decoder`\n    argument and `add_cross_attention` set to `True`; an\n    `encoder_hidden_states` is then expected as an input to the forward pass.\n    \"\"\"\n\n    def __init__(self, config: ChatGLMConfig, empty_init=True):\n        super().__init__(config)\n        if empty_init:\n            init_method = skip_init\n        else:\n            init_method = default_init\n        # recording parameters\n        self.max_sequence_length = config.max_sequence_length\n        self.hidden_size = config.hidden_size\n        self.params_dtype = torch.half\n        self.num_attention_heads = config.num_attention_heads\n        self.vocab_size = config.vocab_size\n        self.num_layers = config.num_layers\n        self.layernorm_epsilon = config.layernorm_epsilon\n        self.inner_hidden_size = config.inner_hidden_size\n        self.hidden_size_per_attention_head = self.hidden_size // self.num_attention_heads\n        self.position_encoding_2d = config.position_encoding_2d\n        self.pre_seq_len = config.pre_seq_len\n        self.prefix_projection = config.prefix_projection\n\n        self.word_embeddings = init_method(\n            torch.nn.Embedding,\n            num_embeddings=self.vocab_size, embedding_dim=self.hidden_size,\n            dtype=self.params_dtype\n        )\n        self.gradient_checkpointing = False\n\n        def get_layer(layer_id):\n            return GLMBlock(\n                self.hidden_size,\n                self.num_attention_heads,\n                self.layernorm_epsilon,\n                layer_id,\n                inner_hidden_size=self.inner_hidden_size,\n                hidden_size_per_attention_head=self.hidden_size_per_attention_head,\n                layernorm=LayerNorm,\n                use_bias=True,\n                params_dtype=self.params_dtype,\n                position_encoding_2d=self.position_encoding_2d,\n                empty_init=empty_init\n            )\n\n        self.layers = torch.nn.ModuleList(\n            [get_layer(layer_id) for layer_id in range(self.num_layers)]\n        )\n\n        # Final layer norm before output.\n        self.final_layernorm = LayerNorm(self.hidden_size, eps=self.layernorm_epsilon)\n\n        if self.pre_seq_len is not None:\n            for param in self.parameters():\n                param.requires_grad = False\n            self.prefix_tokens = torch.arange(self.pre_seq_len).long()\n            self.prefix_encoder = PrefixEncoder(config)\n            self.dropout = torch.nn.Dropout(0.1)\n\n            # total_params = sum(p.numel() for p in self.parameters())\n            # trainable_params = sum(p.numel() for p in self.parameters() if p.requires_grad)\n            # print(\"Using p-tuning v2: # trainable_params = {} / {}\".format(trainable_params, total_params))\n\n    def get_input_embeddings(self):\n        return self.word_embeddings\n\n    def set_input_embeddings(self, new_embeddings: torch.Tensor):\n        self.word_embeddings = new_embeddings\n\n    def get_prompt(self, batch_size, device, dtype=torch.half):\n        prefix_tokens = self.prefix_tokens.unsqueeze(0).expand(batch_size, -1).to(device)\n        past_key_values = self.prefix_encoder(prefix_tokens).type(dtype)\n        past_key_values = past_key_values.view(\n            batch_size,\n            self.pre_seq_len,\n            self.num_layers * 2,\n            self.num_attention_heads,\n            self.hidden_size // self.num_attention_heads\n        )\n        # seq_len, b, nh, hidden_size\n        past_key_values = self.dropout(past_key_values)\n        past_key_values = past_key_values.permute([2, 1, 0, 3, 4]).split(2)\n        # past_key_values = [(v[0], v[1]) for v in past_key_values]\n        return past_key_values\n\n    @add_start_docstrings_to_model_forward(CHATGLM_6B_INPUTS_DOCSTRING.format(\"batch_size, sequence_length\"))\n    @add_code_sample_docstrings(\n        checkpoint=_CHECKPOINT_FOR_DOC,\n        output_type=BaseModelOutputWithPastAndCrossAttentions,\n        config_class=_CONFIG_FOR_DOC,\n    )\n    def forward(\n            self,\n            input_ids: Optional[torch.LongTensor] = None,\n            position_ids: Optional[torch.LongTensor] = None,\n            attention_mask: Optional[torch.Tensor] = None,\n            past_key_values: Optional[Tuple[Tuple[torch.Tensor, torch.Tensor], ...]] = None,\n            inputs_embeds: Optional[torch.LongTensor] = None,\n            use_cache: Optional[bool] = None,\n            output_attentions: Optional[bool] = None,\n            output_hidden_states: Optional[bool] = None,\n            return_dict: Optional[bool] = None,\n    ) -> Union[Tuple[torch.Tensor, ...], BaseModelOutputWithPast]:\n\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        if self.gradient_checkpointing and self.training:\n            if use_cache:\n                logger.warning_once(\n                    \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`...\"\n                )\n                use_cache = False\n\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n        elif input_ids is not None:\n            batch_size, seq_length = input_ids.shape[:2]\n        elif inputs_embeds is not None:\n            batch_size, seq_length = inputs_embeds.shape[:2]\n        else:\n            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n        if inputs_embeds is None:\n            inputs_embeds = self.word_embeddings(input_ids)\n\n        if past_key_values is None:\n            if self.pre_seq_len is not None:\n                past_key_values = self.get_prompt(batch_size=input_ids.shape[0], device=input_ids.device,\n                                                  dtype=inputs_embeds.dtype)\n            else:\n                past_key_values = tuple([None] * len(self.layers))\n\n            if attention_mask is None:\n                attention_mask = self.get_masks(\n                    input_ids,\n                    device=input_ids.device\n                )\n\n\n            if position_ids is None:\n                MASK, gMASK = self.config.mask_token_id, self.config.gmask_token_id\n                seqs = input_ids.tolist()\n\n                mask_positions, use_gmasks = [], []\n                for seq in seqs:\n                    mask_token = gMASK if gMASK in seq else MASK\n                    use_gmask = mask_token == gMASK\n                    mask_positions.append(seq.index(mask_token))\n                    use_gmasks.append(use_gmask)\n\n                position_ids = self.get_position_ids(\n                    input_ids,\n                    mask_positions=mask_positions,\n                    device=input_ids.device,\n                    use_gmasks=use_gmasks\n                )\n\n        if self.pre_seq_len is not None and attention_mask is not None:\n            prefix_attention_mask = torch.ones(batch_size, 1, input_ids.size(-1), self.pre_seq_len).to(\n                attention_mask.device)\n            prefix_attention_mask = (prefix_attention_mask < 0.5).bool()\n            attention_mask = torch.cat((prefix_attention_mask, attention_mask), dim=3)\n\n        # [seq_len, batch, hidden_size]\n        hidden_states = inputs_embeds.transpose(0, 1)\n\n        presents = () if use_cache else None\n        all_self_attentions = () if output_attentions else None\n        all_hidden_states = () if output_hidden_states else None\n\n        if attention_mask is None:\n            attention_mask = torch.zeros(1, 1, device=input_ids.device).bool()\n        else:\n            attention_mask = attention_mask.to(hidden_states.device)\n\n        for i, layer in enumerate(self.layers):\n\n            if output_hidden_states:\n                all_hidden_states = all_hidden_states + (hidden_states,)\n            layer_past = past_key_values[i]\n\n            if self.gradient_checkpointing and self.training:\n                layer_ret = torch.utils.checkpoint.checkpoint(\n                    layer,\n                    hidden_states,\n                    position_ids,\n                    attention_mask,\n                    torch.tensor(i),\n                    layer_past,\n                    use_cache,\n                    output_attentions\n                )\n            else:\n                layer_ret = layer(\n                    hidden_states,\n                    position_ids=position_ids,\n                    attention_mask=attention_mask,\n                    layer_id=torch.tensor(i),\n                    layer_past=layer_past,\n                    use_cache=use_cache,\n                    output_attentions=output_attentions\n                )\n\n            hidden_states = layer_ret[0]\n\n            if use_cache:\n                presents = presents + (layer_ret[1],)\n\n            if output_attentions:\n                all_self_attentions = all_self_attentions + (layer_ret[2 if use_cache else 1],)\n\n        # Final layer norm.\n        hidden_states = self.final_layernorm(hidden_states)\n\n        if output_hidden_states:\n            all_hidden_states = all_hidden_states + (hidden_states,)\n\n        if not return_dict:\n            return tuple(v for v in [hidden_states, presents, all_hidden_states, all_self_attentions] if v is not None)\n\n        return BaseModelOutputWithPast(\n            last_hidden_state=hidden_states,\n            past_key_values=presents,\n            hidden_states=all_hidden_states,\n            attentions=all_self_attentions,\n        )", "\n\nclass ChatGLMForConditionalGeneration(ChatGLMPreTrainedModel):\n    def __init__(self, config: ChatGLMConfig, empty_init=True):\n        super().__init__(config)\n        if empty_init:\n            init_method = skip_init\n        else:\n            init_method = default_init\n\n        # self.hidden_size = config.hidden_size\n        # self.params_dtype = torch.half\n        # self.vocab_size = config.vocab_size\n        self.max_sequence_length = config.max_sequence_length\n\n        self.position_encoding_2d = config.position_encoding_2d\n\n        self.transformer = ChatGLMModel(config, empty_init=empty_init)\n\n        self.lm_head = init_method(\n            nn.Linear,\n            config.hidden_size,\n            config.vocab_size,\n            bias=False,\n            dtype=torch.half\n        )\n\n        self.config = config\n\n        self.quantized = False\n\n        if self.config.quantization_bit:\n            self.quantize(self.config.quantization_bit, empty_init=True)\n\n    def get_output_embeddings(self):\n        return self.lm_head\n\n    def set_output_embeddings(self, new_embeddings):\n        self.lm_head = new_embeddings\n\n    def _update_model_kwargs_for_generation(\n        self,\n        outputs: ModelOutput,\n        model_kwargs: Dict[str, Any],\n        is_encoder_decoder: bool = False,\n        standardize_cache_format: bool = False,\n    ) -> Dict[str, Any]:\n        # update past_key_values\n        model_kwargs[\"past_key_values\"] = self._extract_past_from_model_output(\n            outputs, standardize_cache_format=standardize_cache_format\n        )\n\n        # update attention mask\n        if \"attention_mask\" in model_kwargs:\n            attention_mask = model_kwargs[\"attention_mask\"]\n            if attention_mask is not None and attention_mask.dtype == torch.bool:\n                attention_mask = torch.cat(\n                    [attention_mask, attention_mask.new_ones((*attention_mask.shape[:3], 1))], dim=3)\n                new_attention_mask = attention_mask[:, :, -1:].clone()\n                new_attention_mask[..., -1] = False\n                model_kwargs[\"attention_mask\"] = torch.cat(\n                    [attention_mask, new_attention_mask], dim=2\n                )\n\n        # update position ids\n        if \"position_ids\" in model_kwargs:\n            position_ids = model_kwargs[\"position_ids\"]\n            new_position_id = position_ids[..., -1:].clone()\n            new_position_id[:, 1, :] += 1\n            model_kwargs[\"position_ids\"] = torch.cat(\n                [position_ids, new_position_id], dim=-1\n            )\n\n        return model_kwargs\n\n    def prepare_inputs_for_generation(\n            self,\n            input_ids: torch.LongTensor,\n            past: Optional[torch.Tensor] = None,\n            past_key_values: Optional[torch.Tensor] = None,\n            attention_mask: Optional[torch.Tensor] = None,\n            position_ids: Optional[torch.Tensor] = None,\n            **kwargs\n    ) -> dict:\n        batch_size, seq_length = input_ids.shape\n        MASK, gMASK = self.config.mask_token_id, self.config.gmask_token_id\n        seqs = input_ids.tolist()\n        mask_positions, use_gmasks = [], []\n        for seq in seqs:\n            mask_token = gMASK if gMASK in seq else MASK\n            use_gmask = mask_token == gMASK\n            mask_positions.append(seq.index(mask_token))\n            use_gmasks.append(use_gmask)\n\n        # only last token for input_ids if past is not None\n        if past is not None or past_key_values is not None:\n            last_token = input_ids[:, -1].unsqueeze(-1)\n            if attention_mask is not None and attention_mask.dtype == torch.bool:\n                attention_mask = attention_mask[:, :, -1:]\n            else:\n                attention_mask = None\n            if position_ids is not None:\n                position_ids = position_ids[..., -1:]\n            else:\n                context_lengths = [seq.index(self.config.bos_token_id) for seq in seqs]\n                if self.position_encoding_2d:\n                    position_ids = torch.tensor(\n                        [[mask_position, seq_length - context_length] for mask_position, context_length in\n                         zip(mask_positions, context_lengths)], dtype=torch.long, device=input_ids.device).unsqueeze(-1)\n                else:\n                    position_ids = torch.tensor([mask_position for mask_position in mask_positions], dtype=torch.long,\n                                                device=input_ids.device).unsqueeze(-1)\n\n            if past is None:\n                past = past_key_values\n            return {\n                \"input_ids\": last_token,\n                \"past_key_values\": past,\n                \"position_ids\": position_ids,\n                \"attention_mask\": attention_mask\n            }\n        else:\n            if attention_mask is not None and attention_mask.dtype != torch.bool:\n                logger.warning_once(f\"The dtype of attention mask ({attention_mask.dtype}) is not bool\")\n                attention_mask = None\n            if attention_mask is None:\n                attention_mask = self.get_masks(\n                    input_ids,\n                    device=input_ids.device\n                )\n            if position_ids is None:\n                position_ids = self.get_position_ids(\n                    input_ids,\n                    device=input_ids.device,\n                    mask_positions=mask_positions,\n                    use_gmasks=use_gmasks\n                )\n\n            return {\n                \"input_ids\": input_ids,\n                \"past_key_values\": past,\n                \"position_ids\": position_ids,\n                \"attention_mask\": attention_mask\n            }\n\n    def forward(\n            self,\n            input_ids: Optional[torch.Tensor] = None,\n            position_ids: Optional[torch.Tensor] = None,\n            attention_mask: Optional[torch.Tensor] = None,\n            past_key_values: Optional[Tuple[torch.FloatTensor]] = None,\n            inputs_embeds: Optional[torch.Tensor] = None,\n            labels: Optional[torch.Tensor] = None,\n            use_cache: Optional[bool] = None,\n            output_attentions: Optional[bool] = None,\n            output_hidden_states: Optional[bool] = None,\n            return_dict: Optional[bool] = None,\n    ):\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        # print(\"input_ids: \", input_ids.shape)\n        # print(\"input_ids: \", input_ids.shape)\n        transformer_outputs = self.transformer(\n            input_ids=input_ids,\n            position_ids=position_ids,\n            attention_mask=attention_mask,\n            past_key_values=past_key_values,\n            inputs_embeds=inputs_embeds,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n\n        hidden_states = transformer_outputs[0]\n\n        lm_logits = self.lm_head(hidden_states).permute(1, 0, 2).contiguous()\n\n        loss = None\n        if labels is not None:\n            lm_logits = lm_logits.to(torch.float32)\n\n            # Shift so that tokens < n predict n\n            shift_logits = lm_logits[..., :-1, :].contiguous()\n            shift_labels = labels[..., 1:].contiguous()\n            # Flatten the tokens\n            loss_fct = CrossEntropyLoss(ignore_index=-100)\n            loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)), shift_labels.view(-1))\n\n            lm_logits = lm_logits.to(hidden_states.dtype)\n            loss = loss.to(hidden_states.dtype)\n\n        if not return_dict:\n            output = (lm_logits,) + transformer_outputs[1:]\n            return ((loss,) + output) if loss is not None else output\n\n        return CausalLMOutputWithPast(\n            loss=loss,\n            logits=lm_logits,\n            past_key_values=transformer_outputs.past_key_values,\n            hidden_states=transformer_outputs.hidden_states,\n            attentions=transformer_outputs.attentions,\n        )\n\n    @staticmethod\n    def _reorder_cache(\n            past: Tuple[Tuple[torch.Tensor, torch.Tensor], ...], beam_idx: torch.LongTensor\n    ) -> Tuple[Tuple[torch.Tensor, torch.Tensor], ...]:\n        \"\"\"\n        This function is used to re-order the `past_key_values` cache if [`~PreTrainedModel.beam_search`] or\n        [`~PreTrainedModel.beam_sample`] is called. This is required to match `past_key_values` with the correct\n        beam_idx at every generation step.\n\n        Output shares the same memory storage as `past`.\n        \"\"\"\n        return tuple(\n            (\n                layer_past[0].index_select(1, beam_idx.to(layer_past[0].device)),\n                layer_past[1].index_select(1, beam_idx.to(layer_past[1].device)),\n            )\n            for layer_past in past\n        )\n\n    def process_response(self, response):\n        response = response.strip()\n        response = response.replace(\"[[\u8bad\u7ec3\u65f6\u95f4]]\", \"2023\u5e74\")\n        punkts = [\n            [\",\", \"\uff0c\"],\n            [\"!\", \"\uff01\"],\n            [\":\", \"\uff1a\"],\n            [\";\", \"\uff1b\"],\n            [\"\\?\", \"\uff1f\"],\n        ]\n        for item in punkts:\n            response = re.sub(r\"([\\u4e00-\\u9fff])%s\" % item[0], r\"\\1%s\" % item[1], response)\n            response = re.sub(r\"%s([\\u4e00-\\u9fff])\" % item[0], r\"%s\\1\" % item[1], response)\n        return response\n\n    @torch.no_grad()\n    def chat(self, tokenizer, query: str, history: List[Tuple[str, str]] = None, max_length: int = 2048, num_beams=1,\n             do_sample=True, top_p=0.7, temperature=0.95, logits_processor=None, **kwargs):\n        if history is None:\n            history = []\n        if logits_processor is None:\n            logits_processor = LogitsProcessorList()\n        logits_processor.append(InvalidScoreLogitsProcessor())\n        gen_kwargs = {\"max_length\": max_length, \"num_beams\": num_beams, \"do_sample\": do_sample, \"top_p\": top_p,\n                      \"temperature\": temperature, \"logits_processor\": logits_processor, **kwargs}\n        if not history:\n            prompt = query\n        else:\n            prompt = \"\"\n            for i, (old_query, response) in enumerate(history):\n                prompt += \"[Round {}]\\n\u95ee\uff1a{}\\n\u7b54\uff1a{}\\n\".format(i, old_query, response)\n            prompt += \"[Round {}]\\n\u95ee\uff1a{}\\n\u7b54\uff1a\".format(len(history), query)\n        inputs = tokenizer([prompt], return_tensors=\"pt\")\n        inputs = inputs.to(self.device)\n        outputs = self.generate(**inputs, **gen_kwargs)\n        outputs = outputs.tolist()[0][len(inputs[\"input_ids\"][0]):]\n        response = tokenizer.decode(outputs)\n        response = self.process_response(response)\n        history = history + [(query, response)]\n        return response, history\n\n    @torch.no_grad()\n    def stream_chat(self, tokenizer, query: str, history: List[Tuple[str, str]] = None, max_length: int = 2048,\n                    do_sample=True, top_p=0.7, temperature=0.95, logits_processor=None, **kwargs):\n        if history is None:\n            history = []\n        if logits_processor is None:\n            logits_processor = LogitsProcessorList()\n        logits_processor.append(InvalidScoreLogitsProcessor())\n        gen_kwargs = {\"max_length\": max_length, \"do_sample\": do_sample, \"top_p\": top_p,\n                      \"temperature\": temperature, \"logits_processor\": logits_processor, **kwargs}\n        if not history:\n            prompt = query\n        else:\n            prompt = \"\"\n            for i, (old_query, response) in enumerate(history):\n                prompt += \"[Round {}]\\n\u95ee\uff1a{}\\n\u7b54\uff1a{}\\n\".format(i, old_query, response)\n            prompt += \"[Round {}]\\n\u95ee\uff1a{}\\n\u7b54\uff1a\".format(len(history), query)\n        inputs = tokenizer([prompt], return_tensors=\"pt\")\n        inputs = inputs.to(self.device)\n        for outputs in self.stream_generate(**inputs, **gen_kwargs):\n            outputs = outputs.tolist()[0][len(inputs[\"input_ids\"][0]):]\n            response = tokenizer.decode(outputs)\n            response = self.process_response(response)\n            new_history = history + [(query, response)]\n            yield response, new_history\n\n    @torch.no_grad()\n    def stream_generate(\n            self,\n            input_ids,\n            generation_config: Optional[GenerationConfig] = None,\n            logits_processor: Optional[LogitsProcessorList] = None,\n            stopping_criteria: Optional[StoppingCriteriaList] = None,\n            prefix_allowed_tokens_fn: Optional[Callable[[int, torch.Tensor], List[int]]] = None,\n            **kwargs,\n    ):\n        batch_size, input_ids_seq_length = input_ids.shape[0], input_ids.shape[-1]\n\n        if generation_config is None:\n            generation_config = self.generation_config\n        generation_config = copy.deepcopy(generation_config)\n        model_kwargs = generation_config.update(**kwargs)\n        bos_token_id, eos_token_id = generation_config.bos_token_id, generation_config.eos_token_id\n\n        if isinstance(eos_token_id, int):\n            eos_token_id = [eos_token_id]\n\n        has_default_max_length = kwargs.get(\"max_length\") is None and generation_config.max_length is not None\n        if has_default_max_length and generation_config.max_new_tokens is None:\n            warnings.warn(\n                f\"Using `max_length`'s default ({generation_config.max_length}) to control the generation length. \"\n                \"This behaviour is deprecated and will be removed from the config in v5 of Transformers -- we\"\n                \" recommend using `max_new_tokens` to control the maximum length of the generation.\",\n                UserWarning,\n            )\n        elif generation_config.max_new_tokens is not None:\n            generation_config.max_length = generation_config.max_new_tokens + input_ids_seq_length\n            if not has_default_max_length:\n                logger.warn(\n                    f\"Both `max_new_tokens` (={generation_config.max_new_tokens}) and `max_length`(=\"\n                    f\"{generation_config.max_length}) seem to have been set. `max_new_tokens` will take precedence. \"\n                    \"Please refer to the documentation for more information. \"\n                    \"(https://huggingface.co/docs/transformers/main/en/main_classes/text_generation)\",\n                    UserWarning,\n                )\n\n        if input_ids_seq_length >= generation_config.max_length:\n            input_ids_string = \"decoder_input_ids\" if self.config.is_encoder_decoder else \"input_ids\"\n            logger.warning(\n                f\"Input length of {input_ids_string} is {input_ids_seq_length}, but `max_length` is set to\"\n                f\" {generation_config.max_length}. This can lead to unexpected behavior. You should consider\"\n                \" increasing `max_new_tokens`.\"\n            )\n\n        # 2. Set generation parameters if not already defined\n        logits_processor = logits_processor if logits_processor is not None else LogitsProcessorList()\n        stopping_criteria = stopping_criteria if stopping_criteria is not None else StoppingCriteriaList()\n\n        logits_processor = self._get_logits_processor(\n            generation_config=generation_config,\n            input_ids_seq_length=input_ids_seq_length,\n            encoder_input_ids=input_ids,\n            prefix_allowed_tokens_fn=prefix_allowed_tokens_fn,\n            logits_processor=logits_processor,\n        )\n\n        stopping_criteria = self._get_stopping_criteria(\n            generation_config=generation_config, stopping_criteria=stopping_criteria\n        )\n        logits_warper = self._get_logits_warper(generation_config)\n\n        unfinished_sequences = input_ids.new(input_ids.shape[0]).fill_(1)\n        scores = None\n        while True:\n            model_inputs = self.prepare_inputs_for_generation(input_ids, **model_kwargs)\n            # forward pass to get next token\n            outputs = self(\n                **model_inputs,\n                return_dict=True,\n                output_attentions=False,\n                output_hidden_states=False,\n            )\n\n            next_token_logits = outputs.logits[:, -1, :]\n\n            # pre-process distribution\n            next_token_scores = logits_processor(input_ids, next_token_logits)\n            next_token_scores = logits_warper(input_ids, next_token_scores)\n\n            # sample\n            probs = nn.functional.softmax(next_token_scores, dim=-1)\n            if generation_config.do_sample:\n                next_tokens = torch.multinomial(probs, num_samples=1).squeeze(1)\n            else:\n                next_tokens = torch.argmax(probs, dim=-1)\n\n            # update generated ids, model inputs, and length for next step\n            input_ids = torch.cat([input_ids, next_tokens[:, None]], dim=-1)\n            model_kwargs = self._update_model_kwargs_for_generation(\n                outputs, model_kwargs, is_encoder_decoder=self.config.is_encoder_decoder\n            )\n            unfinished_sequences = unfinished_sequences.mul((sum(next_tokens != i for i in eos_token_id)).long())\n\n            # stop when each sentence is finished, or if we exceed the maximum length\n            if unfinished_sequences.max() == 0 or stopping_criteria(input_ids, scores):\n                break\n            yield input_ids\n\n    def quantize(self, bits: int, empty_init=False, **kwargs):\n        if bits == 0:\n            return\n\n        from .quantization import quantize\n\n        if self.quantized:\n            logger.info(\"Already quantized.\")\n            return self\n\n        self.quantized = True\n\n        self.config.quantization_bit = bits\n\n        self.transformer = quantize(self.transformer, bits, empty_init=empty_init, **kwargs)\n        return self", ""]}
{"filename": "ft_chatglm_lora/arguments.py", "chunked_list": ["from dataclasses import dataclass, field\nfrom typing import Optional\n\n\n@dataclass\nclass ModelArguments:\n    \"\"\"\n    Arguments pertaining to which model/config/tokenizer we are going to fine-tune from.\n    \"\"\"\n\n    model_name_or_path: str = field(\n        metadata={\"help\": \"Path to pretrained model or model identifier from huggingface.co/models\"}\n    )\n    ptuning_checkpoint: str = field(\n        default=None, metadata={\"help\": \"Path to p-tuning v2 checkpoints\"}\n    )\n    config_name: Optional[str] = field(\n        default=None, metadata={\"help\": \"Pretrained config name or path if not the same as model_name\"}\n    )\n    tokenizer_name: Optional[str] = field(\n        default=None, metadata={\"help\": \"Pretrained tokenizer name or path if not the same as model_name\"}\n    )\n    cache_dir: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"Where to store the pretrained models downloaded from huggingface.co\"},\n    )\n    use_fast_tokenizer: bool = field(\n        default=True,\n        metadata={\"help\": \"Whether to use one of the fast tokenizer (backed by the tokenizers library) or not.\"},\n    )\n    model_revision: str = field(\n        default=\"main\",\n        metadata={\"help\": \"The specific model version to use (can be a branch name, tag name or commit id).\"},\n    )\n    use_auth_token: bool = field(\n        default=False,\n        metadata={\n            \"help\": (\n                \"Will use the token generated when running `huggingface-cli login` (necessary to use this script \"\n                \"with private models).\"\n            )\n        },\n    )\n    resize_position_embeddings: Optional[bool] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"Whether to automatically resize the position embeddings if `max_source_length` exceeds \"\n                \"the model's position embeddings.\"\n            )\n        },\n    )\n    quantization_bit: Optional[int] = field(\n        default=None\n    )\n    pre_seq_len: Optional[int] = field(\n        default=None\n    )\n    prefix_projection: bool = field(\n        default=False\n    )\n\n    trainable: Optional[str] = field(default=\"q_proj,v_proj\")\n    lora_rank: Optional[int] = field(default=8)\n    lora_dropout: Optional[float] = field(default=0.1)\n    lora_alpha: Optional[float] = field(default=32.)\n    modules_to_save: Optional[str] = field(default='embed_tokens,lm_head')\n    debug_mode: Optional[bool] = field(default=False)\n    peft_path: Optional[str] = field(default=None)", "\n\n@dataclass\nclass DataTrainingArguments:\n    \"\"\"\n    Arguments pertaining to what data we are going to input our model for training and eval.\n    \"\"\"\n\n    lang: Optional[str] = field(default=None, metadata={\"help\": \"Language id for summarization.\"})\n\n    dataset_name: Optional[str] = field(\n        default=None, metadata={\"help\": \"The name of the dataset to use (via the datasets library).\"}\n    )\n    dataset_config_name: Optional[str] = field(\n        default=None, metadata={\"help\": \"The configuration name of the dataset to use (via the datasets library).\"}\n    )\n    prompt_column: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"The name of the column in the datasets containing the full texts (for summarization).\"},\n    )\n    response_column: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"The name of the column in the datasets containing the summaries (for summarization).\"},\n    )\n    history_column: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"The name of the column in the datasets containing the history of chat.\"},\n    )\n    train_file: Optional[str] = field(\n        default=None, metadata={\"help\": \"The input training data file (a jsonlines or csv file).\"}\n    )\n    validation_file: Optional[str] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"An optional input evaluation data file to evaluate the metrics (rouge) on (a jsonlines or csv file).\"\n            )\n        },\n    )\n    test_file: Optional[str] = field(\n        default=None,\n        metadata={\n            \"help\": \"An optional input test data file to evaluate the metrics (rouge) on (a jsonlines or csv file).\"\n        },\n    )\n    overwrite_cache: bool = field(\n        default=True, metadata={\"help\": \"Overwrite the cached training and evaluation sets\"}\n    )\n    preprocessing_num_workers: Optional[int] = field(\n        default=None,\n        metadata={\"help\": \"The number of processes to use for the preprocessing.\"},\n    )\n    max_source_length: Optional[int] = field(\n        default=1024,\n        metadata={\n            \"help\": (\n                \"The maximum total input sequence length after tokenization. Sequences longer \"\n                \"than this will be truncated, sequences shorter will be padded.\"\n            )\n        },\n    )\n    max_target_length: Optional[int] = field(\n        default=128,\n        metadata={\n            \"help\": (\n                \"The maximum total sequence length for target text after tokenization. Sequences longer \"\n                \"than this will be truncated, sequences shorter will be padded.\"\n            )\n        },\n    )\n    val_max_target_length: Optional[int] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"The maximum total sequence length for validation target text after tokenization. Sequences longer \"\n                \"than this will be truncated, sequences shorter will be padded. Will default to `max_target_length`.\"\n                \"This argument is also used to override the ``max_length`` param of ``model.generate``, which is used \"\n                \"during ``evaluate`` and ``predict``.\"\n            )\n        },\n    )\n    pad_to_max_length: bool = field(\n        default=False,\n        metadata={\n            \"help\": (\n                \"Whether to pad all samples to model maximum sentence length. \"\n                \"If False, will pad the samples dynamically when batching to the maximum length in the batch. More \"\n                \"efficient on GPU but very bad for TPU.\"\n            )\n        },\n    )\n    max_train_samples: Optional[int] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"For debugging purposes or quicker training, truncate the number of training examples to this \"\n                \"value if set.\"\n            )\n        },\n    )\n    max_eval_samples: Optional[int] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"For debugging purposes or quicker training, truncate the number of evaluation examples to this \"\n                \"value if set.\"\n            )\n        },\n    )\n    max_predict_samples: Optional[int] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"For debugging purposes or quicker training, truncate the number of prediction examples to this \"\n                \"value if set.\"\n            )\n        },\n    )\n    num_beams: Optional[int] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"Number of beams to use for evaluation. This argument will be passed to ``model.generate``, \"\n                \"which is used during ``evaluate`` and ``predict``.\"\n            )\n        },\n    )\n    ignore_pad_token_for_loss: bool = field(\n        default=True,\n        metadata={\n            \"help\": \"Whether to ignore the tokens corresponding to padded labels in the loss computation or not.\"\n        },\n    )\n    source_prefix: Optional[str] = field(\n        default=\"\", metadata={\"help\": \"A prefix to add before every source text (useful for T5 models).\"}\n    )\n\n    forced_bos_token: Optional[str] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"The token to force as the first generated token after the decoder_start_token_id.\"\n                \"Useful for multilingual models like mBART where the first generated token\"\n                \"needs to be the target language token (Usually it is the target language token)\"\n            )\n        },\n    )\n\n    \n\n    def __post_init__(self):\n        if self.dataset_name is None and self.train_file is None and self.validation_file is None and self.test_file is None:\n            raise ValueError(\"Need either a dataset name or a training/validation/test file.\")\n        else:\n            if self.train_file is not None:\n                extension = self.train_file.split(\".\")[-1]\n                assert extension in [\"csv\", \"json\"], \"`train_file` should be a csv or a json file.\"\n            if self.validation_file is not None:\n                extension = self.validation_file.split(\".\")[-1]\n                assert extension in [\"csv\", \"json\"], \"`validation_file` should be a csv or a json file.\"\n        if self.val_max_target_length is None:\n            self.val_max_target_length = self.max_target_length", "\n"]}
{"filename": "ft_chatglm_lora/configuration_chatglm.py", "chunked_list": ["\"\"\" ChatGLM model configuration \"\"\"\n\nfrom transformers.configuration_utils import PretrainedConfig\nfrom transformers.utils import logging\n\nlogger = logging.get_logger(__name__)\n\n\nclass ChatGLMConfig(PretrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`~ChatGLMModel`].\n    It is used to instantiate an ChatGLM model according to the specified arguments, defining the model\n    architecture. Instantiating a configuration with the defaults will yield a similar configuration to that of\n    the ChatGLM-6B [THUDM/ChatGLM-6B](https://huggingface.co/THUDM/chatglm-6b) architecture.\n\n    Configuration objects inherit from  [`PretrainedConfig`] and can be used\n    to control the model outputs. Read the documentation from  [`PretrainedConfig`]\n    for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*, defaults to 150528):\n            Vocabulary size of the ChatGLM-6B model. Defines the number of different tokens that can be represented by the\n            `inputs_ids` passed when calling [`~ChatGLMModel`] or\n            [`~TFChatGLMModel`].\n        hidden_size (`int`, *optional*, defaults to 4096):\n            Dimension of the encoder layers and the pooler layer.\n        num_hidden_layers (`int`, *optional*, defaults to 28):\n            Number of hidden layers in the Transformer encoder.\n        num_attention_heads (`int`, *optional*, defaults to 32):\n            Number of attention heads for each attention layer in the Transformer encoder.\n        inner_hidden_size (`int`, *optional*, defaults to 16384):\n            Dimension of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n        max_sequence_length (`int`, *optional*, defaults to 512):\n            The maximum sequence length that this model might ever be used with.\n            Typically set this to something large just in case (e.g., 512 or 1024 or 2048).\n        layernorm_epsilon (`float`, *optional*, defaults to 1e-5):\n            The epsilon used by the layer normalization layers.\n        use_cache (`bool`, *optional*, defaults to `True`):\n            Whether the model should return the last key/values attentions (not used by all models).\n        Example:\n\n    ```python\n    >>> from configuration_chatglm import ChatGLMConfig\n    >>> from modeling_chatglm import ChatGLMModel\n\n    >>> # Initializing a ChatGLM-6B THUDM/ChatGLM-6B style configuration\n    >>> configuration = ChatGLMConfig()\n\n    >>> # Initializing a model from the THUDM/ChatGLM-6B style configuration\n    >>> model = ChatGLMModel(configuration)\n\n    >>> # Accessing the model configuration\n    >>> configuration = model.config\n    ```\n\"\"\"\n    model_type = \"chatglm\"\n\n    def __init__(\n            self,\n            vocab_size=150528,\n            hidden_size=4096,\n            num_layers=28,\n            num_attention_heads=32,\n            layernorm_epsilon=1e-5,\n            use_cache=False,\n            bos_token_id=150004,\n            eos_token_id=150005,\n            mask_token_id=150000,\n            gmask_token_id=150001,\n            pad_token_id=0,\n            max_sequence_length=2048,\n            inner_hidden_size=16384,\n            position_encoding_2d=True,\n            quantization_bit=0,\n            pre_seq_len=None,\n            prefix_projection=False,\n            **kwargs\n    ):\n        self.num_layers = num_layers\n        self.vocab_size = vocab_size\n        self.hidden_size = hidden_size\n        self.num_attention_heads = num_attention_heads\n        self.max_sequence_length = max_sequence_length\n        self.layernorm_epsilon = layernorm_epsilon\n        self.inner_hidden_size = inner_hidden_size\n        self.use_cache = use_cache\n        self.bos_token_id = bos_token_id\n        self.eos_token_id = eos_token_id\n        self.pad_token_id = pad_token_id\n        self.mask_token_id = mask_token_id\n        self.gmask_token_id = gmask_token_id\n        self.position_encoding_2d = position_encoding_2d\n        self.quantization_bit = quantization_bit\n        self.pre_seq_len = pre_seq_len\n        self.prefix_projection = prefix_projection\n\n        super().__init__(\n            pad_token_id=pad_token_id,\n            bos_token_id=bos_token_id,\n            eos_token_id=eos_token_id,\n            **kwargs\n        )", "class ChatGLMConfig(PretrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`~ChatGLMModel`].\n    It is used to instantiate an ChatGLM model according to the specified arguments, defining the model\n    architecture. Instantiating a configuration with the defaults will yield a similar configuration to that of\n    the ChatGLM-6B [THUDM/ChatGLM-6B](https://huggingface.co/THUDM/chatglm-6b) architecture.\n\n    Configuration objects inherit from  [`PretrainedConfig`] and can be used\n    to control the model outputs. Read the documentation from  [`PretrainedConfig`]\n    for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*, defaults to 150528):\n            Vocabulary size of the ChatGLM-6B model. Defines the number of different tokens that can be represented by the\n            `inputs_ids` passed when calling [`~ChatGLMModel`] or\n            [`~TFChatGLMModel`].\n        hidden_size (`int`, *optional*, defaults to 4096):\n            Dimension of the encoder layers and the pooler layer.\n        num_hidden_layers (`int`, *optional*, defaults to 28):\n            Number of hidden layers in the Transformer encoder.\n        num_attention_heads (`int`, *optional*, defaults to 32):\n            Number of attention heads for each attention layer in the Transformer encoder.\n        inner_hidden_size (`int`, *optional*, defaults to 16384):\n            Dimension of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n        max_sequence_length (`int`, *optional*, defaults to 512):\n            The maximum sequence length that this model might ever be used with.\n            Typically set this to something large just in case (e.g., 512 or 1024 or 2048).\n        layernorm_epsilon (`float`, *optional*, defaults to 1e-5):\n            The epsilon used by the layer normalization layers.\n        use_cache (`bool`, *optional*, defaults to `True`):\n            Whether the model should return the last key/values attentions (not used by all models).\n        Example:\n\n    ```python\n    >>> from configuration_chatglm import ChatGLMConfig\n    >>> from modeling_chatglm import ChatGLMModel\n\n    >>> # Initializing a ChatGLM-6B THUDM/ChatGLM-6B style configuration\n    >>> configuration = ChatGLMConfig()\n\n    >>> # Initializing a model from the THUDM/ChatGLM-6B style configuration\n    >>> model = ChatGLMModel(configuration)\n\n    >>> # Accessing the model configuration\n    >>> configuration = model.config\n    ```\n\"\"\"\n    model_type = \"chatglm\"\n\n    def __init__(\n            self,\n            vocab_size=150528,\n            hidden_size=4096,\n            num_layers=28,\n            num_attention_heads=32,\n            layernorm_epsilon=1e-5,\n            use_cache=False,\n            bos_token_id=150004,\n            eos_token_id=150005,\n            mask_token_id=150000,\n            gmask_token_id=150001,\n            pad_token_id=0,\n            max_sequence_length=2048,\n            inner_hidden_size=16384,\n            position_encoding_2d=True,\n            quantization_bit=0,\n            pre_seq_len=None,\n            prefix_projection=False,\n            **kwargs\n    ):\n        self.num_layers = num_layers\n        self.vocab_size = vocab_size\n        self.hidden_size = hidden_size\n        self.num_attention_heads = num_attention_heads\n        self.max_sequence_length = max_sequence_length\n        self.layernorm_epsilon = layernorm_epsilon\n        self.inner_hidden_size = inner_hidden_size\n        self.use_cache = use_cache\n        self.bos_token_id = bos_token_id\n        self.eos_token_id = eos_token_id\n        self.pad_token_id = pad_token_id\n        self.mask_token_id = mask_token_id\n        self.gmask_token_id = gmask_token_id\n        self.position_encoding_2d = position_encoding_2d\n        self.quantization_bit = quantization_bit\n        self.pre_seq_len = pre_seq_len\n        self.prefix_projection = prefix_projection\n\n        super().__init__(\n            pad_token_id=pad_token_id,\n            bos_token_id=bos_token_id,\n            eos_token_id=eos_token_id,\n            **kwargs\n        )", ""]}
{"filename": "ft_chatglm_lora/main.py", "chunked_list": ["#!/usr/bin/env python\n# coding=utf-8\n# Copyright 2021 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"\nFine-tuning the library models for sequence to sequence.\n\"\"\"", "Fine-tuning the library models for sequence to sequence.\n\"\"\"\n# You can also adapt this script on your own sequence to sequence task. Pointers for this are left as comments.\n\nimport logging\nimport os\nimport sys\nimport json\n\nimport numpy as np", "\nimport numpy as np\nfrom datasets import load_dataset\nimport jieba \nfrom rouge_chinese import Rouge\nfrom nltk.translate.bleu_score import sentence_bleu, SmoothingFunction\nfrom text2dt_eval.parser import parsing\nfrom text2dt_eval.metric import text2dt_metric\nimport torch\n", "import torch\n\nimport transformers\nfrom transformers import (\n    AutoConfig,\n    AutoModel,\n    AutoTokenizer,\n    AutoTokenizer,\n    DataCollatorForSeq2Seq,\n    HfArgumentParser,", "    DataCollatorForSeq2Seq,\n    HfArgumentParser,\n    Seq2SeqTrainingArguments,\n    set_seed,\n)\n\nimport sys\nsys.path.append(\"./\")\n\nfrom tokenization_chatglm import ChatGLMTokenizer", "\nfrom tokenization_chatglm import ChatGLMTokenizer\nfrom configuration_chatglm import ChatGLMConfig\nfrom modeling_chatglm import ChatGLMForConditionalGeneration\nfrom trainer_seq2seq import Seq2SeqTrainer\nfrom arguments import ModelArguments, DataTrainingArguments\n\nfrom peft import PeftModel, LoraConfig, TaskType, get_peft_model, get_peft_model_state_dict\n\nlogger = logging.getLogger(__name__)", "\nlogger = logging.getLogger(__name__)\n\ndef main():\n    instruct = \"\u8bf7\u5f62\u5f0f\u5316\u5730\u63cf\u8ff0\u4ee5\u4e0b\u533b\u7597\u6587\u672c\u6240\u8868\u8fbe\u7684\u8bca\u7597\u51b3\u7b56\u8fc7\u7a0b\uff0c\u76ee\u6807\u8f93\u51fa\u683c\u5f0f\u4e3a\u201c\u82e5...[\u82e5...]\uff0c\u5219...\uff0c\u5426\u5219\uff0c\u82e5...[\u82e5...]\uff0c\u5219...\uff0c\u5426\u5219...\u201d\u3002\u4e09\u5143\u7ec4\u5173\u7cfb\u7c7b\u578b\u5305\u62ec\u201c\u4e34\u5e8a\u8868\u73b0\uff0c\u7528\u836f\uff0c\u6cbb\u7597\u65b9\u6848\uff0c\u7528\u6cd5\uff0c\u57fa\u672c\u60c5\u51b5\uff0c\u614e\u7528\u201d\u3002\\n\u8f93\u5165\u6587\u672c\uff1a\"\n    RE_instruct = \"\u8bf7\u627e\u51fa\u4ee5\u4e0b\u533b\u7597\u6587\u672c\u4e2d\u51fa\u73b0\u7684\u5173\u7cfb\u4e09\u5143\u7ec4\uff0c\u5e76\u6309\u7167\u201c[(\u5934\u5b9e\u4f531, \u5173\u7cfb\u7c7b\u578b1, \u5c3e\u5b9e\u4f531), (\u5934\u5b9e\u4f532, \u5173\u7cfb\u7c7b\u578b2, \u5c3e\u5b9e\u4f532), ...]\u201d\u7684\u683c\u5f0f\u8f93\u51fa\uff0c\u76ee\u6807\u5173\u7cfb\u7c7b\u578b\u5305\u62ec\u201c\u4e34\u5e8a\u8868\u73b0\uff0c\u7528\u836f\uff0c\u6cbb\u7597\u65b9\u6848\uff0c\u7528\u6cd5\uff0c\u57fa\u672c\u60c5\u51b5\uff0c\u614e\u7528\u201d\u3002\\n\u8f93\u5165\u6587\u672c\uff1a\"\n    TreeS_instruct = \"\u8bf7\u7528\u201c\u82e5\u201d\uff0c\u201c\u5219\u201d\uff0c\u201c\u5426\u5219\u201d\uff0c\u201c\u6216\u201d\uff0c\u201c\u4e14\u201d\uff0c\u201c\u548c\u201d\u5927\u81f4\u8868\u793a\u4ee5\u4e0b\u533b\u7597\u6587\u672c\u7684\u8bca\u7597\u903b\u8f91\u6846\u67b6\u3002\\n\u8f93\u5165\u6587\u672c\uff1a\"\n\n    parser = HfArgumentParser((ModelArguments, DataTrainingArguments, Seq2SeqTrainingArguments))\n    if len(sys.argv) == 2 and sys.argv[1].endswith(\".json\"):\n        # If we pass only one argument to the script and it's the path to a json file,\n        # let's parse it to get our arguments.\n        model_args, data_args, training_args = parser.parse_json_file(json_file=os.path.abspath(sys.argv[1]))\n    else:\n        model_args, data_args, training_args = parser.parse_args_into_dataclasses()\n\n    # Setup logging\n    logging.basicConfig(\n        format=\"%(asctime)s - %(levelname)s - %(name)s - %(message)s\",\n        datefmt=\"%m/%d/%Y %H:%M:%S\",\n        handlers=[logging.StreamHandler(sys.stdout)],\n    )\n\n    if training_args.should_log:\n        # The default of training_args.log_level is passive, so we set log level at info here to have that default.\n        transformers.utils.logging.set_verbosity_info()\n\n    log_level = training_args.get_process_log_level()\n    logger.setLevel(log_level)\n    # datasets.utils.logging.set_verbosity(log_level)\n    transformers.utils.logging.set_verbosity(log_level)\n    transformers.utils.logging.enable_default_handler()\n    transformers.utils.logging.enable_explicit_format()\n\n    # Log on each process the small summary:\n    logger.warning(\n        f\"Process rank: {training_args.local_rank}, device: {training_args.device}, n_gpu: {training_args.n_gpu}\"\n        + f\"distributed training: {bool(training_args.local_rank != -1)}, 16-bits training: {training_args.fp16}\"\n    )\n    logger.info(f\"Data parameters {data_args}\")\n    logger.info(f\"Training/evaluation parameters {training_args}\")\n\n    # Set seed before initializing model.\n    set_seed(training_args.seed)\n\n    # Load dataset\n    data_files = {}\n    if data_args.train_file is not None:\n        data_files[\"train\"] = data_args.train_file\n        extension = data_args.train_file.split(\".\")[-1]\n    if data_args.validation_file is not None:\n        data_files[\"validation\"] = data_args.validation_file\n        extension = data_args.validation_file.split(\".\")[-1]\n    if data_args.test_file is not None:\n        data_files[\"test\"] = data_args.test_file\n        extension = data_args.test_file.split(\".\")[-1]\n\n    raw_datasets = load_dataset(\n        extension,\n        data_files=data_files,\n        cache_dir=model_args.cache_dir,\n        use_auth_token=True if model_args.use_auth_token else None,\n    )\n    print(\"raw_datasets: \", raw_datasets)\n    # print(\"raw_datasets: \", len(raw_datasets[\"train\"]))\n\n    # Load pretrained model and tokenizer\n    config = ChatGLMConfig.from_pretrained(\n        model_args.model_name_or_path,\n        # trust_remote_code=True\n    )\n    config.pre_seq_len = model_args.pre_seq_len\n    config.prefix_projection = model_args.prefix_projection\n\n    tokenizer = ChatGLMTokenizer.from_pretrained(\n        model_args.model_name_or_path,\n        # trust_remote_code=True\n    )\n    print(tokenizer.tokenize(instruct))\n\n    model = ChatGLMForConditionalGeneration.from_pretrained(\n        model_args.model_name_or_path,\n        config=config,\n    ).half().cuda()\n\n    # for n, p in model.named_parameters():\n    #     print(n, p.requires_grad)\n\n    if model_args.peft_path is not None:\n        logger.info(\"Peft from pre-trained model\")\n        model = PeftModel.from_pretrained(model, model_args.peft_path)\n    else:\n        logger.info(\"Init new peft model\")\n        target_modules = model_args.trainable.split(',')\n        modules_to_save = model_args.modules_to_save.split(',') if model_args.modules_to_save!=\"null\" else None\n        lora_rank = model_args.lora_rank\n        lora_dropout = model_args.lora_dropout\n        lora_alpha = model_args.lora_alpha\n        print(target_modules)\n        print(lora_rank)\n        peft_config = LoraConfig(\n            task_type=TaskType.CAUSAL_LM,\n            target_modules=target_modules,\n            inference_mode=False,\n            r=lora_rank, lora_alpha=lora_alpha,\n            lora_dropout=lora_dropout,\n            modules_to_save=modules_to_save\n        )\n        model = get_peft_model(model, peft_config)\n    model.print_trainable_parameters()\n\n    # for n, p in model.named_parameters():\n    #     print(n, p.requires_grad, p.numel())\n\n    prefix = data_args.source_prefix if data_args.source_prefix is not None else \"\"\n\n    # Preprocessing the datasets.\n    # We need to tokenize inputs and targets.\n    if training_args.do_train:\n        column_names = raw_datasets[\"train\"].column_names\n    elif training_args.do_eval:\n        column_names = raw_datasets[\"validation\"].column_names\n    elif training_args.do_predict:\n        column_names = raw_datasets[\"test\"].column_names\n    else:\n        logger.info(\"There is nothing to do. Please pass `do_train`, `do_eval` and/or `do_predict`.\")\n        return\n\n    # Get the column names for input/target.\n    prompt_column = data_args.prompt_column\n    response_column = data_args.response_column\n    history_column = data_args.history_column\n    RE_response_column = 'RE_target'\n    TreeS_response_column = 'TreeS_target'\n    \n    # Temporarily set max_target_length for training.\n    max_target_length = data_args.max_target_length\n\n    def preprocess_function_eval(examples):\n        inputs, targets = [], []\n        for i in range(len(examples[prompt_column])):\n            if not examples[response_column][i]:\n                targets.append(\"filled in !\")\n            else:\n                targets.append(examples[response_column][i])\n\n            if examples[prompt_column][i]:\n                query = examples[prompt_column][i]\n                query = instruct + query + \"\\n\u8f93\u51fa\uff1a\"\n\n                if history_column is None or len(examples[history_column][i]) == 0:\n                    prompt = query\n                else:\n                    prompt = \"\"\n                    history = examples[history_column][i]\n                    for turn_idx, (old_query, response) in enumerate(history):\n                        prompt += \"[Round {}]\\n\u95ee\uff1a{}\\n\u7b54\uff1a{}\\n\".format(turn_idx, old_query, response)\n                    prompt += \"[Round {}]\\n\u95ee\uff1a{}\\n\u7b54\uff1a\".format(len(history), query)\n                inputs.append(prompt)\n\n        inputs = [prefix + inp for inp in inputs]\n        model_inputs = tokenizer(inputs,\n                                 max_length=data_args.max_source_length,\n                                 truncation=True,\n                                 padding=True)\n        labels = tokenizer(text_target=targets, max_length=max_target_length, truncation=True)\n\n        if data_args.ignore_pad_token_for_loss:\n            labels[\"input_ids\"] = [\n                [(l if l != tokenizer.pad_token_id else -100) for l in label] for label in labels[\"input_ids\"]\n            ]\n        model_inputs[\"labels\"] = labels[\"input_ids\"]\n\n        return model_inputs\n\n    def preprocess_function_train(examples, repeat_main_task=1, aug_start_index=1e10):\n        max_seq_length = data_args.max_source_length + data_args.max_target_length\n\n        model_inputs = {\n            \"input_ids\": [],\n            \"labels\": [],\n        }\n        for i in range(len(examples[prompt_column])):\n            # sample for main task training\n            if examples[prompt_column][i] and examples[response_column][i]:\n                input_ids, labels = construct_train_sample(\n                    instruct,\n                    examples[prompt_column][i],\n                    examples[response_column][i],\n                    max_seq_length,\n                    None if history_column is None else examples[history_column][i]\n                )\n                # oversampling to balance # main-task-samples amd # auxilary-task-samples\n                for _ in range(repeat_main_task):\n                    model_inputs[\"input_ids\"].append(input_ids)\n                    model_inputs[\"labels\"].append(labels)\n                \n            # sample for auxiliary RE task training\n            if examples[prompt_column][i] and examples[RE_response_column][i]:\n                # using all non-augmented data as well as hard augmented data (\u6761\u4ef6\u7ed3\u70b9\u6570\u91cf\u5927\u4e8e2)\n                if i < aug_start_index or examples[response_column][i].count('\u82e5') > 2:\n                    print(i, 'RE_response_column', examples[RE_response_column][i])\n                    input_ids, labels = construct_train_sample(\n                        RE_instruct,\n                        examples[prompt_column][i],\n                        examples[RE_response_column][i],\n                        max_seq_length,\n                        None if history_column is None else examples[history_column][i]\n                    )\n                    model_inputs[\"input_ids\"].append(input_ids)\n                    model_inputs[\"labels\"].append(labels)\n\n            # sample for auxiliary TreeS task training\n            if examples[prompt_column][i] and examples[TreeS_response_column][i]:\n                # using all non-augmented data as well as hard augmented data (\u6761\u4ef6\u7ed3\u70b9\u6570\u91cf\u5927\u4e8e2)\n                if i < aug_start_index or examples[response_column][i].count('\u82e5') > 2:\n                    print(i, 'TreeS_response_column', examples[TreeS_response_column][i])\n                    input_ids, labels = construct_train_sample(\n                        TreeS_instruct,\n                        examples[prompt_column][i],\n                        examples[TreeS_response_column][i],\n                        max_seq_length,\n                        None if history_column is None else examples[history_column][i]\n                    )\n                    model_inputs[\"input_ids\"].append(input_ids)\n                    model_inputs[\"labels\"].append(labels)\n\n        return model_inputs\n    \n    def construct_train_sample(instruct, query, answer, max_seq_length, history=None):\n        query = instruct + query + \"\\n\u8f93\u51fa\uff1a\"\n\n        if history is None:\n            prompt = query\n        else:\n            prompt = \"\"\n            for turn_idx, (old_query, response) in enumerate(history):\n                prompt += \"[Round {}]\\n\u95ee\uff1a{}\\n\u7b54\uff1a{}\\n\".format(turn_idx, old_query, response)\n            prompt += \"[Round {}]\\n\u95ee\uff1a{}\\n\u7b54\uff1a\".format(len(history), query)\n\n        prompt = prefix + prompt\n        a_ids = tokenizer.encode(text=prompt, add_special_tokens=False)\n        b_ids = tokenizer.encode(text=answer, add_special_tokens=False)\n\n        if len(a_ids) > data_args.max_source_length - 1:\n            a_ids = a_ids[: data_args.max_source_length - 1]\n\n        if len(b_ids) > data_args.max_target_length - 2:\n            b_ids = b_ids[: data_args.max_target_length - 2]\n\n        input_ids = tokenizer.build_inputs_with_special_tokens(a_ids, b_ids)\n\n        context_length = input_ids.index(tokenizer.bos_token_id)\n        mask_position = context_length - 1\n        labels = [-100] * context_length + input_ids[mask_position+1:]\n        \n        pad_len = max_seq_length - len(input_ids)\n        input_ids = input_ids + [tokenizer.pad_token_id] * pad_len\n        labels = labels + [tokenizer.pad_token_id] * pad_len\n        # print(\"input_ids: \", len(input_ids))\n        # print(\"labels: \", len(labels))\n\n        if data_args.ignore_pad_token_for_loss:\n            labels = [(l if l != tokenizer.pad_token_id else -100) for l in labels]\n\n        return input_ids, labels\n        \n    def print_dataset_example(example):\n        print(\"\\ninput_ids: \",example[\"input_ids\"])\n        print(\"inputs: \", tokenizer.decode(example[\"input_ids\"]))\n        print(\"label_ids: \", example[\"labels\"])\n        print(\"labels: \", tokenizer.decode(example[\"labels\"]))\n\n    if training_args.do_train:\n        if \"train\" not in raw_datasets:\n            raise ValueError(\"--do_train requires a train dataset\")\n        train_dataset = raw_datasets[\"train\"]\n        if data_args.max_train_samples is not None:\n            max_train_samples = min(len(train_dataset), data_args.max_train_samples)\n            train_dataset = train_dataset.select(range(max_train_samples))\n        with training_args.main_process_first(desc=\"train dataset map pre-processing\"):\n            train_dataset = train_dataset.map(\n                preprocess_function_train,\n                fn_kwargs={'repeat_main_task': 2, 'aug_start_index': 400},\n                batched=True,\n                num_proc=data_args.preprocessing_num_workers,\n                remove_columns=column_names,\n                load_from_cache_file=False,\n                desc=\"Running tokenizer on train dataset\",\n            )\n        print_dataset_example(train_dataset[0])\n\n    if training_args.do_eval:\n        max_target_length = data_args.val_max_target_length\n        if \"validation\" not in raw_datasets:\n            raise ValueError(\"--do_eval requires a validation dataset\")\n        eval_dataset = raw_datasets[\"validation\"]\n        if data_args.max_eval_samples is not None:\n            max_eval_samples = min(len(eval_dataset), data_args.max_eval_samples)\n            eval_dataset = eval_dataset.select(range(max_eval_samples))\n        with training_args.main_process_first(desc=\"validation dataset map pre-processing\"):\n            eval_dataset = eval_dataset.map(\n                preprocess_function_eval,\n                batched=True,\n                num_proc=data_args.preprocessing_num_workers,\n                remove_columns=column_names,\n                load_from_cache_file=False,\n                desc=\"Running tokenizer on validation dataset\",\n            )\n        print_dataset_example(eval_dataset[0])\n\n    if training_args.do_predict:\n        max_target_length = data_args.val_max_target_length\n        if \"test\" not in raw_datasets:\n            raise ValueError(\"--do_predict requires a test dataset\")\n        predict_dataset = raw_datasets[\"test\"]\n        if data_args.max_predict_samples is not None:\n            max_predict_samples = min(len(predict_dataset), data_args.max_predict_samples)\n            predict_dataset = predict_dataset.select(range(max_predict_samples))\n        with training_args.main_process_first(desc=\"prediction dataset map pre-processing\"):\n            predict_dataset = predict_dataset.map(\n                preprocess_function_eval,\n                batched=True,\n                num_proc=data_args.preprocessing_num_workers,\n                remove_columns=column_names,\n                load_from_cache_file=False,\n                desc=\"Running tokenizer on prediction dataset\",\n            )\n        print_dataset_example(predict_dataset[0])\n\n    # Data collator\n    label_pad_token_id = -100 if data_args.ignore_pad_token_for_loss else tokenizer.pad_token_id\n    data_collator = DataCollatorForSeq2Seq(\n        tokenizer,\n        model=model,\n        label_pad_token_id=label_pad_token_id,\n        pad_to_multiple_of=None,\n        padding=False\n    )\n\n    # Metric\n    def compute_metrics(eval_preds):\n        preds, labels = eval_preds\n        if isinstance(preds, tuple):\n            preds = preds[0]\n        decoded_preds = tokenizer.batch_decode(preds, skip_special_tokens=True)\n        if data_args.ignore_pad_token_for_loss:\n            # Replace -100 in the labels as we can't decode them.\n            labels = np.where(labels != -100, labels, tokenizer.pad_token_id)\n        decoded_labels = tokenizer.batch_decode(labels, skip_special_tokens=True)\n        # print('decoded_labels', decoded_labels)\n        # print('decoded_preds', decoded_preds)\n\n        score_dict = dict()\n        gold_trees = list(map(parsing, decoded_labels))\n        pred_trees = list(map(parsing, decoded_preds))\n        text2dt_scores = text2dt_metric(gold_trees, pred_trees)\n        score_dict.update(text2dt_scores)\n        \n        return score_dict\n\n    # Override the decoding parameters of Seq2SeqTrainer\n    training_args.generation_max_length = (\n        training_args.generation_max_length\n        if training_args.generation_max_length is not None\n        else data_args.val_max_target_length\n    )\n    training_args.generation_num_beams = (\n        data_args.num_beams if data_args.num_beams is not None else training_args.generation_num_beams\n    )\n    # Initialize our Trainer\n    trainer = Seq2SeqTrainer(\n        model=model,\n        args=training_args,\n        train_dataset=train_dataset if training_args.do_train else None,\n        eval_dataset=eval_dataset if training_args.do_eval else None,\n        tokenizer=tokenizer,\n        data_collator=data_collator,\n        compute_metrics=compute_metrics if training_args.predict_with_generate else None,\n        save_prefixencoder=model_args.pre_seq_len is not None\n    )\n\n    # Training\n    if training_args.do_train:\n        checkpoint = None\n        if training_args.resume_from_checkpoint is not None:\n            checkpoint = training_args.resume_from_checkpoint\n        # elif last_checkpoint is not None:\n        #     checkpoint = last_checkpoint\n        model.gradient_checkpointing_enable()\n        model.enable_input_require_grads()\n        train_result = trainer.train(resume_from_checkpoint=checkpoint)\n        # trainer.save_model()  # Saves the tokenizer too for easy upload\n\n        metrics = train_result.metrics\n        max_train_samples = (\n            data_args.max_train_samples if data_args.max_train_samples is not None else len(train_dataset)\n        )\n        metrics[\"train_samples\"] = min(max_train_samples, len(train_dataset))\n\n        trainer.log_metrics(\"train\", metrics)\n        trainer.save_metrics(\"train\", metrics)\n        trainer.save_state()\n\n    # Evaluation\n    results = {}\n    max_seq_length = data_args.max_source_length + data_args.max_target_length + 1\n    if training_args.do_eval:\n        logger.info(\"*** Evaluate ***\")\n        metrics = trainer.evaluate(metric_key_prefix=\"eval\", do_sample=False, top_p=0.7, max_length=max_seq_length, temperature=0.95)\n        max_eval_samples = data_args.max_eval_samples if data_args.max_eval_samples is not None else len(eval_dataset)\n        metrics[\"eval_samples\"] = min(max_eval_samples, len(eval_dataset))\n\n        trainer.log_metrics(\"eval\", metrics)\n        trainer.save_metrics(\"eval\", metrics)\n\n    if training_args.do_predict:\n        logger.info(\"*** Predict ***\")\n\n        # \u8bfb\u53d6\u539ftest file\n        list_test_samples = []\n        with open(data_args.test_file, \"r\", encoding=\"utf-8\") as f:\n            for line in f:\n                line = json.loads(line)\n                list_test_samples.append(line)\n\n        predict_results = trainer.predict(\n            predict_dataset,\n            metric_key_prefix=\"predict\",\n            max_new_tokens=data_args.max_target_length,\n            do_sample=False,\n            top_p=0.7,\n            temperature=0.95,\n        )\n        metrics = predict_results.metrics\n        max_predict_samples = (\n            data_args.max_predict_samples if data_args.max_predict_samples is not None else len(predict_dataset)\n        )\n        metrics[\"predict_samples\"] = min(max_predict_samples, len(predict_dataset))\n\n        trainer.log_metrics(\"predict\", metrics)\n        trainer.save_metrics(\"predict\", metrics)\n\n        if trainer.is_world_process_zero():\n            if training_args.predict_with_generate:\n                predictions = tokenizer.batch_decode(\n                    predict_results.predictions, skip_special_tokens=True, clean_up_tokenization_spaces=True\n                )\n                predictions = [pred.strip() for pred in predictions]\n                labels = tokenizer.batch_decode(\n                    predict_results.label_ids, skip_special_tokens=True, clean_up_tokenization_spaces=True\n                )\n                labels = [label.strip() for label in labels]\n                assert len(labels) == len(list_test_samples)\n\n                output_prediction_file = os.path.join(training_args.output_dir, \"pred_trees.json\")\n\n                with open(output_prediction_file, \"w\", encoding=\"utf-8\") as writer:\n                    list_res = []\n                    for idx, (p, l) in enumerate(zip(predictions, labels)):\n                        text = list_test_samples[idx]['input']\n                        res = {'text': text, 'tree': parsing(p)}\n                        list_res.append(res)\n                    json.dump(list_res, writer, ensure_ascii=False, indent=2)\n\n    return results", "\n\ndef _mp_fn(index):\n    # For xla_spawn (TPUs)\n    main()\n\n\nif __name__ == \"__main__\":\n    main()\n", ""]}
{"filename": "ft_chatglm_lora/trainer_seq2seq.py", "chunked_list": ["# Copyright 2020 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom typing import Any, Dict, List, Optional, Tuple, Union\n\nimport torch\nfrom torch import nn", "import torch\nfrom torch import nn\nfrom torch.utils.data import Dataset\n\nfrom transformers.deepspeed import is_deepspeed_zero3_enabled\n\nfrom transformers.trainer_utils import PredictionOutput\nfrom transformers.utils import logging\n\n", "\n\nfrom trainer import Trainer\n\nlogger = logging.get_logger(__name__)\n\n\nclass Seq2SeqTrainer(Trainer):\n    def evaluate(\n        self,\n        eval_dataset: Optional[Dataset] = None,\n        ignore_keys: Optional[List[str]] = None,\n        metric_key_prefix: str = \"eval\",\n        **gen_kwargs\n    ) -> Dict[str, float]:\n        \"\"\"\n        Run evaluation and returns metrics.\n\n        The calling script will be responsible for providing a method to compute metrics, as they are task-dependent\n        (pass it to the init `compute_metrics` argument).\n\n        You can also subclass and override this method to inject custom behavior.\n\n        Args:\n            eval_dataset (`Dataset`, *optional*):\n                Pass a dataset if you wish to override `self.eval_dataset`. If it is an [`~datasets.Dataset`], columns\n                not accepted by the `model.forward()` method are automatically removed. It must implement the `__len__`\n                method.\n            ignore_keys (`List[str]`, *optional*):\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions.\n            metric_key_prefix (`str`, *optional*, defaults to `\"eval\"`):\n                An optional prefix to be used as the metrics key prefix. For example the metrics \"bleu\" will be named\n                \"eval_bleu\" if the prefix is `\"eval\"` (default)\n            max_length (`int`, *optional*):\n                The maximum target length to use when predicting with the generate method.\n            num_beams (`int`, *optional*):\n                Number of beams for beam search that will be used when predicting with the generate method. 1 means no\n                beam search.\n            gen_kwargs:\n                Additional `generate` specific kwargs.\n\n        Returns:\n            A dictionary containing the evaluation loss and the potential metrics computed from the predictions. The\n            dictionary also contains the epoch number which comes from the training state.\n        \"\"\"\n\n        gen_kwargs = gen_kwargs.copy()\n        if gen_kwargs.get(\"max_length\") is None and gen_kwargs.get(\"max_new_tokens\") is None:\n            gen_kwargs[\"max_length\"] = self.args.generation_max_length\n        gen_kwargs[\"num_beams\"] = (\n            gen_kwargs[\"num_beams\"] if gen_kwargs.get(\"num_beams\") is not None else self.args.generation_num_beams\n        )\n        self._gen_kwargs = gen_kwargs\n\n        return super().evaluate(eval_dataset, ignore_keys=ignore_keys, metric_key_prefix=metric_key_prefix)\n\n    def predict(\n        self,\n        test_dataset: Dataset,\n        ignore_keys: Optional[List[str]] = None,\n        metric_key_prefix: str = \"test\",\n        **gen_kwargs\n    ) -> PredictionOutput:\n        \"\"\"\n        Run prediction and returns predictions and potential metrics.\n\n        Depending on the dataset and your use case, your test dataset may contain labels. In that case, this method\n        will also return metrics, like in `evaluate()`.\n\n        Args:\n            test_dataset (`Dataset`):\n                Dataset to run the predictions on. If it is a [`~datasets.Dataset`], columns not accepted by the\n                `model.forward()` method are automatically removed. Has to implement the method `__len__`\n            ignore_keys (`List[str]`, *optional*):\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions.\n            metric_key_prefix (`str`, *optional*, defaults to `\"eval\"`):\n                An optional prefix to be used as the metrics key prefix. For example the metrics \"bleu\" will be named\n                \"eval_bleu\" if the prefix is `\"eval\"` (default)\n            max_length (`int`, *optional*):\n                The maximum target length to use when predicting with the generate method.\n            num_beams (`int`, *optional*):\n                Number of beams for beam search that will be used when predicting with the generate method. 1 means no\n                beam search.\n            gen_kwargs:\n                Additional `generate` specific kwargs.\n\n        <Tip>\n\n        If your predictions or labels have different sequence lengths (for instance because you're doing dynamic\n        padding in a token classification task) the predictions will be padded (on the right) to allow for\n        concatenation into one array. The padding index is -100.\n\n        </Tip>\n\n        Returns: *NamedTuple* A namedtuple with the following keys:\n\n            - predictions (`np.ndarray`): The predictions on `test_dataset`.\n            - label_ids (`np.ndarray`, *optional*): The labels (if the dataset contained some).\n            - metrics (`Dict[str, float]`, *optional*): The potential dictionary of metrics (if the dataset contained\n              labels).\n        \"\"\"\n\n        gen_kwargs = gen_kwargs.copy()\n        if gen_kwargs.get(\"max_length\") is None and gen_kwargs.get(\"max_new_tokens\") is None:\n            gen_kwargs[\"max_length\"] = self.args.generation_max_length\n        gen_kwargs[\"num_beams\"] = (\n            gen_kwargs[\"num_beams\"] if gen_kwargs.get(\"num_beams\") is not None else self.args.generation_num_beams\n        )\n        self._gen_kwargs = gen_kwargs\n\n\n        return super().predict(test_dataset, ignore_keys=ignore_keys, metric_key_prefix=metric_key_prefix)\n\n    def prediction_step(\n        self,\n        model: nn.Module,\n        inputs: Dict[str, Union[torch.Tensor, Any]],\n        prediction_loss_only: bool,\n        ignore_keys: Optional[List[str]] = None,\n    ) -> Tuple[Optional[float], Optional[torch.Tensor], Optional[torch.Tensor]]:\n        \"\"\"\n        Perform an evaluation step on `model` using `inputs`.\n\n        Subclass and override to inject custom behavior.\n\n        Args:\n            model (`nn.Module`):\n                The model to evaluate.\n            inputs (`Dict[str, Union[torch.Tensor, Any]]`):\n                The inputs and targets of the model.\n\n                The dictionary will be unpacked before being fed to the model. Most models expect the targets under the\n                argument `labels`. Check your model's documentation for all accepted arguments.\n            prediction_loss_only (`bool`):\n                Whether or not to return the loss only.\n\n        Return:\n            Tuple[Optional[float], Optional[torch.Tensor], Optional[torch.Tensor]]: A tuple with the loss, logits and\n            labels (each being optional).\n        \"\"\"\n\n        if not self.args.predict_with_generate or prediction_loss_only:\n            return super().prediction_step(\n                model, inputs, prediction_loss_only=prediction_loss_only, ignore_keys=ignore_keys\n            )\n\n        has_labels = \"labels\" in inputs\n        inputs = self._prepare_inputs(inputs)\n\n        # XXX: adapt synced_gpus for fairscale as well\n        gen_kwargs = self._gen_kwargs.copy()\n        if gen_kwargs.get(\"max_length\") is None and gen_kwargs.get(\"max_new_tokens\") is None:\n            gen_kwargs[\"max_length\"] = self.model.config.max_length\n        gen_kwargs[\"num_beams\"] = (\n            gen_kwargs[\"num_beams\"] if gen_kwargs.get(\"num_beams\") is not None else self.model.config.num_beams\n        )\n        default_synced_gpus = True if is_deepspeed_zero3_enabled() else False\n        gen_kwargs[\"synced_gpus\"] = (\n            gen_kwargs[\"synced_gpus\"] if gen_kwargs.get(\"synced_gpus\") is not None else default_synced_gpus\n        )\n\n        if \"attention_mask\" in inputs:\n            gen_kwargs[\"attention_mask\"] = inputs.get(\"attention_mask\", None)\n        if \"position_ids\" in inputs:\n            gen_kwargs[\"position_ids\"] = inputs.get(\"position_ids\", None)\n        if \"global_attention_mask\" in inputs:\n            gen_kwargs[\"global_attention_mask\"] = inputs.get(\"global_attention_mask\", None)\n\n        # prepare generation inputs\n        # some encoder-decoder models can have varying encoder's and thus\n        # varying model input names\n        if hasattr(self.model, \"encoder\") and self.model.encoder.main_input_name != self.model.main_input_name:\n            generation_inputs = inputs[self.model.encoder.main_input_name]\n        else:\n            generation_inputs = inputs[self.model.main_input_name]\n\n        gen_kwargs[\"input_ids\"] = generation_inputs\n        generated_tokens = self.model.generate(**gen_kwargs)\n        generated_tokens = generated_tokens[:, generation_inputs.size()[-1]:]\n\n        # in case the batch is shorter than max length, the output should be padded\n        if gen_kwargs.get(\"max_length\") is not None and generated_tokens.shape[-1] < gen_kwargs[\"max_length\"]:\n            generated_tokens = self._pad_tensors_to_max_len(generated_tokens, gen_kwargs[\"max_length\"])\n        elif gen_kwargs.get(\"max_new_tokens\") is not None and generated_tokens.shape[-1] < (\n            gen_kwargs[\"max_new_tokens\"] + 1\n        ):\n            generated_tokens = self._pad_tensors_to_max_len(generated_tokens, gen_kwargs[\"max_new_tokens\"] + 1)\n\n        loss = None\n\n        if self.args.prediction_loss_only:\n            return (loss, None, None)\n\n        if has_labels:\n            labels = inputs[\"labels\"]\n            if gen_kwargs.get(\"max_length\") is not None and labels.shape[-1] < gen_kwargs[\"max_length\"]:\n                labels = self._pad_tensors_to_max_len(labels, gen_kwargs[\"max_length\"])\n            elif gen_kwargs.get(\"max_new_tokens\") is not None and labels.shape[-1] < (\n                gen_kwargs[\"max_new_tokens\"] + 1\n            ):\n                labels = self._pad_tensors_to_max_len(labels, (gen_kwargs[\"max_new_tokens\"] + 1))\n        else:\n            labels = None\n\n        return (loss, generated_tokens, labels)\n\n    def _pad_tensors_to_max_len(self, tensor, max_length):\n        if self.tokenizer is not None and hasattr(self.tokenizer, \"pad_token_id\"):\n            # If PAD token is not defined at least EOS token has to be defined\n            pad_token_id = (\n                self.tokenizer.pad_token_id if self.tokenizer.pad_token_id is not None else self.tokenizer.eos_token_id\n            )\n        else:\n            if self.model.config.pad_token_id is not None:\n                pad_token_id = self.model.config.pad_token_id\n            else:\n                raise ValueError(\"Pad_token_id must be set in the configuration of the model, in order to pad tensors\")\n\n        padded_tensor = pad_token_id * torch.ones(\n            (tensor.shape[0], max_length), dtype=tensor.dtype, device=tensor.device\n        )\n        padded_tensor[:, : tensor.shape[-1]] = tensor\n        return padded_tensor\n\n    def _maybe_log_save_evaluate(self, tr_loss, model, trial, epoch, ignore_keys_for_eval):\n        if self.control.should_log:\n            logs: Dict[str, float] = {}\n\n            # all_gather + mean() to get average loss over all processes\n            tr_loss_scalar = self._nested_gather(tr_loss).mean().item()\n\n            # reset tr_loss to zero\n            tr_loss -= tr_loss\n\n            logs[\"loss\"] = round(tr_loss_scalar / (self.state.global_step - self._globalstep_last_logged), 4)\n            logs[\"learning_rate\"] = self._get_learning_rate()\n\n            self._total_loss_scalar += tr_loss_scalar\n            self._globalstep_last_logged = self.state.global_step\n            self.store_flos()\n\n            self.log(logs)\n\n        metrics = None\n        if self.control.should_evaluate:\n            if isinstance(self.eval_dataset, dict):\n                for eval_dataset_name, eval_dataset in self.eval_dataset.items():\n                    metrics = self.evaluate(\n                        eval_dataset=eval_dataset,\n                        ignore_keys=ignore_keys_for_eval,\n                        metric_key_prefix=f\"eval_{eval_dataset_name}\",\n                        do_sample=False, max_new_tokens=512, top_p=0.7, temperature=0.95\n                    )\n            else:\n                metrics = self.evaluate(ignore_keys=ignore_keys_for_eval,\n                                        do_sample=False, max_new_tokens=512, top_p=0.7, temperature=0.95)\n            self._report_to_hp_search(trial, self.state.global_step, metrics)\n\n        if self.control.should_save:\n            self._save_checkpoint(model, trial, metrics=metrics)\n            self.control = self.callback_handler.on_save(self.args, self.state, self.control)"]}
{"filename": "ft_chatglm_lora/trainer.py", "chunked_list": ["# coding=utf-8\n# Copyright 2020-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"\nThe Trainer class, to easily train a \ud83e\udd17 Transformers from scratch or finetune it on a new task.\n\"\"\"\n", "\"\"\"\n\nimport contextlib\nimport functools\nimport glob\nimport inspect\nimport math\nimport os\nimport random\nimport re", "import random\nimport re\nimport shutil\nimport sys\nimport time\nimport warnings\nfrom collections.abc import Mapping\nfrom distutils.util import strtobool\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union", "from pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union\n\nfrom tqdm.auto import tqdm\n\n\n# Integrations must be imported before ML frameworks:\n# isort: off\nfrom transformers.integrations import (\n    default_hp_search_backend,", "from transformers.integrations import (\n    default_hp_search_backend,\n    get_reporting_integration_callbacks,\n    hp_params,\n    is_fairscale_available,\n    is_optuna_available,\n    is_ray_tune_available,\n    is_sigopt_available,\n    is_wandb_available,\n    run_hp_search_optuna,", "    is_wandb_available,\n    run_hp_search_optuna,\n    run_hp_search_ray,\n    run_hp_search_sigopt,\n    run_hp_search_wandb,\n)\n\n# isort: on\n\nimport numpy as np", "\nimport numpy as np\nimport torch\nimport torch.distributed as dist\nfrom huggingface_hub import Repository, create_repo\nfrom packaging import version\nfrom torch import nn\nfrom torch.utils.data import DataLoader, Dataset, RandomSampler, SequentialSampler\nfrom torch.utils.data.distributed import DistributedSampler\n", "from torch.utils.data.distributed import DistributedSampler\n\nfrom transformers import __version__\nfrom transformers.configuration_utils import PretrainedConfig\nfrom transformers.data.data_collator import DataCollator, DataCollatorWithPadding, default_data_collator\nfrom transformers.debug_utils import DebugOption, DebugUnderflowOverflow\nfrom transformers.deepspeed import deepspeed_init, is_deepspeed_zero3_enabled\nfrom transformers.dependency_versions_check import dep_version_check\nfrom transformers.modelcard import TrainingSummary\nfrom transformers.modeling_utils import PreTrainedModel, load_sharded_checkpoint, unwrap_model", "from transformers.modelcard import TrainingSummary\nfrom transformers.modeling_utils import PreTrainedModel, load_sharded_checkpoint, unwrap_model\nfrom transformers.models.auto.modeling_auto import MODEL_FOR_CAUSAL_LM_MAPPING_NAMES, MODEL_MAPPING_NAMES\nfrom transformers.optimization import Adafactor, get_scheduler\nfrom transformers.pytorch_utils import ALL_LAYERNORM_LAYERS, is_torch_greater_or_equal_than_1_10, is_torch_less_than_1_11\nfrom transformers.tokenization_utils_base import PreTrainedTokenizerBase\nfrom transformers.trainer_callback import (\n    CallbackHandler,\n    DefaultFlowCallback,\n    PrinterCallback,", "    DefaultFlowCallback,\n    PrinterCallback,\n    ProgressCallback,\n    TrainerCallback,\n    TrainerControl,\n    TrainerState,\n)\nfrom transformers.trainer_pt_utils import (\n    DistributedLengthGroupedSampler,\n    DistributedSamplerWithLoop,", "    DistributedLengthGroupedSampler,\n    DistributedSamplerWithLoop,\n    DistributedTensorGatherer,\n    IterableDatasetShard,\n    LabelSmoother,\n    LengthGroupedSampler,\n    SequentialDistributedSampler,\n    ShardSampler,\n    distributed_broadcast_scalars,\n    distributed_concat,", "    distributed_broadcast_scalars,\n    distributed_concat,\n    find_batch_size,\n    get_module_class_from_name,\n    get_parameter_names,\n    nested_concat,\n    nested_detach,\n    nested_numpify,\n    nested_truncate,\n    nested_xla_mesh_reduce,", "    nested_truncate,\n    nested_xla_mesh_reduce,\n    reissue_pt_warnings,\n)\nfrom transformers.trainer_utils import (\n    PREFIX_CHECKPOINT_DIR,\n    BestRun,\n    EvalLoopOutput,\n    EvalPrediction,\n    FSDPOption,", "    EvalPrediction,\n    FSDPOption,\n    HPSearchBackend,\n    HubStrategy,\n    IntervalStrategy,\n    PredictionOutput,\n    RemoveColumnsCollator,\n    ShardedDDPOption,\n    TrainerMemoryTracker,\n    TrainOutput,", "    TrainerMemoryTracker,\n    TrainOutput,\n    default_compute_objective,\n    default_hp_space,\n    denumpify_detensorize,\n    enable_full_determinism,\n    find_executable_batch_size,\n    get_last_checkpoint,\n    has_length,\n    number_of_arguments,", "    has_length,\n    number_of_arguments,\n    seed_worker,\n    set_seed,\n    speed_metrics,\n)\nfrom transformers.training_args import OptimizerNames, ParallelMode, TrainingArguments\nfrom transformers.utils import (\n    WEIGHTS_INDEX_NAME,\n    can_return_loss,", "    WEIGHTS_INDEX_NAME,\n    can_return_loss,\n    find_labels,\n    get_full_repo_name,\n    is_accelerate_available,\n    is_apex_available,\n    is_datasets_available,\n    is_in_notebook,\n    is_ipex_available,\n    is_sagemaker_dp_enabled,", "    is_ipex_available,\n    is_sagemaker_dp_enabled,\n    is_sagemaker_mp_enabled,\n    is_torch_compile_available,\n    is_torch_neuroncore_available,\n    is_torch_tpu_available,\n    logging,\n)\nfrom transformers.utils.generic import ContextManagers\n", "from transformers.utils.generic import ContextManagers\n\n# Following PEFT Lora\nWEIGHTS_NAME = \"adapter_model.bin\"\nCONFIG_NAME = \"adapter_config.json\"\nfrom peft.utils.save_and_load import set_peft_model_state_dict\n\n_is_native_cpu_amp_available = is_torch_greater_or_equal_than_1_10\n\nDEFAULT_CALLBACKS = [DefaultFlowCallback]", "\nDEFAULT_CALLBACKS = [DefaultFlowCallback]\nDEFAULT_PROGRESS_CALLBACK = ProgressCallback\n\nif is_in_notebook():\n    from transformers.utils.notebook import NotebookProgressCallback\n\n    DEFAULT_PROGRESS_CALLBACK = NotebookProgressCallback\n\nif is_apex_available():\n    from apex import amp", "\nif is_apex_available():\n    from apex import amp\n\nif is_datasets_available():\n    import datasets\n\nif is_torch_tpu_available(check_device=False):\n    import torch_xla.core.xla_model as xm\n    import torch_xla.debug.metrics as met\n    import torch_xla.distributed.parallel_loader as pl", "\nif is_fairscale_available():\n    dep_version_check(\"fairscale\")\n    import fairscale\n    from fairscale.nn.data_parallel import FullyShardedDataParallel as FullyShardedDDP\n    from fairscale.nn.data_parallel import ShardedDataParallel as ShardedDDP\n    from fairscale.nn.wrap import auto_wrap\n    from fairscale.optim import OSS\n    from fairscale.optim.grad_scaler import ShardedGradScaler\n", "\n\nif is_sagemaker_mp_enabled():\n    import smdistributed.modelparallel.torch as smp\n    from smdistributed.modelparallel import __version__ as SMP_VERSION\n\n    IS_SAGEMAKER_MP_POST_1_10 = version.parse(SMP_VERSION) >= version.parse(\"1.10\")\n\n    from transformers.trainer_pt_utils import smp_forward_backward, smp_forward_only, smp_gather, smp_nested_concat\nelse:\n    IS_SAGEMAKER_MP_POST_1_10 = False", "\n\nskip_first_batches = None\nif is_accelerate_available():\n    from accelerate import __version__ as accelerate_version\n\n    if version.parse(accelerate_version) >= version.parse(\"0.16\"):\n        from accelerate import skip_first_batches\n\n\nif TYPE_CHECKING:\n    import optuna", "\n\nif TYPE_CHECKING:\n    import optuna\n\nlogger = logging.get_logger(__name__)\n\n\n# Name of the files used for checkpointing\nTRAINING_ARGS_NAME = \"training_args.bin\"", "# Name of the files used for checkpointing\nTRAINING_ARGS_NAME = \"training_args.bin\"\nTRAINER_STATE_NAME = \"trainer_state.json\"\nOPTIMIZER_NAME = \"optimizer.pt\"\nSCHEDULER_NAME = \"scheduler.pt\"\nSCALER_NAME = \"scaler.pt\"\n\n\nclass Trainer:\n    \"\"\"\n    Trainer is a simple but feature-complete training and eval loop for PyTorch, optimized for \ud83e\udd17 Transformers.\n\n    Args:\n        model ([`PreTrainedModel`] or `torch.nn.Module`, *optional*):\n            The model to train, evaluate or use for predictions. If not provided, a `model_init` must be passed.\n\n            <Tip>\n\n            [`Trainer`] is optimized to work with the [`PreTrainedModel`] provided by the library. You can still use\n            your own models defined as `torch.nn.Module` as long as they work the same way as the \ud83e\udd17 Transformers\n            models.\n\n            </Tip>\n\n        args ([`TrainingArguments`], *optional*):\n            The arguments to tweak for training. Will default to a basic instance of [`TrainingArguments`] with the\n            `output_dir` set to a directory named *tmp_trainer* in the current directory if not provided.\n        data_collator (`DataCollator`, *optional*):\n            The function to use to form a batch from a list of elements of `train_dataset` or `eval_dataset`. Will\n            default to [`default_data_collator`] if no `tokenizer` is provided, an instance of\n            [`DataCollatorWithPadding`] otherwise.\n        train_dataset (`torch.utils.data.Dataset` or `torch.utils.data.IterableDataset`, *optional*):\n            The dataset to use for training. If it is a [`~datasets.Dataset`], columns not accepted by the\n            `model.forward()` method are automatically removed.\n\n            Note that if it's a `torch.utils.data.IterableDataset` with some randomization and you are training in a\n            distributed fashion, your iterable dataset should either use a internal attribute `generator` that is a\n            `torch.Generator` for the randomization that must be identical on all processes (and the Trainer will\n            manually set the seed of this `generator` at each epoch) or have a `set_epoch()` method that internally\n            sets the seed of the RNGs used.\n        eval_dataset (Union[`torch.utils.data.Dataset`, Dict[str, `torch.utils.data.Dataset`]), *optional*):\n             The dataset to use for evaluation. If it is a [`~datasets.Dataset`], columns not accepted by the\n             `model.forward()` method are automatically removed. If it is a dictionary, it will evaluate on each\n             dataset prepending the dictionary key to the metric name.\n        tokenizer ([`PreTrainedTokenizerBase`], *optional*):\n            The tokenizer used to preprocess the data. If provided, will be used to automatically pad the inputs to the\n            maximum length when batching inputs, and it will be saved along the model to make it easier to rerun an\n            interrupted training or reuse the fine-tuned model.\n        model_init (`Callable[[], PreTrainedModel]`, *optional*):\n            A function that instantiates the model to be used. If provided, each call to [`~Trainer.train`] will start\n            from a new instance of the model as given by this function.\n\n            The function may have zero argument, or a single one containing the optuna/Ray Tune/SigOpt trial object, to\n            be able to choose different architectures according to hyper parameters (such as layer count, sizes of\n            inner layers, dropout probabilities etc).\n        compute_metrics (`Callable[[EvalPrediction], Dict]`, *optional*):\n            The function that will be used to compute metrics at evaluation. Must take a [`EvalPrediction`] and return\n            a dictionary string to metric values.\n        callbacks (List of [`TrainerCallback`], *optional*):\n            A list of callbacks to customize the training loop. Will add those to the list of default callbacks\n            detailed in [here](callback).\n\n            If you want to remove one of the default callbacks used, use the [`Trainer.remove_callback`] method.\n        optimizers (`Tuple[torch.optim.Optimizer, torch.optim.lr_scheduler.LambdaLR]`, *optional*): A tuple\n            containing the optimizer and the scheduler to use. Will default to an instance of [`AdamW`] on your model\n            and a scheduler given by [`get_linear_schedule_with_warmup`] controlled by `args`.\n        preprocess_logits_for_metrics (`Callable[[torch.Tensor, torch.Tensor], torch.Tensor]`, *optional*):\n            A function that preprocess the logits right before caching them at each evaluation step. Must take two\n            tensors, the logits and the labels, and return the logits once processed as desired. The modifications made\n            by this function will be reflected in the predictions received by `compute_metrics`.\n\n            Note that the labels (second parameter) will be `None` if the dataset does not have them.\n\n    Important attributes:\n\n        - **model** -- Always points to the core model. If using a transformers model, it will be a [`PreTrainedModel`]\n          subclass.\n        - **model_wrapped** -- Always points to the most external model in case one or more other modules wrap the\n          original model. This is the model that should be used for the forward pass. For example, under `DeepSpeed`,\n          the inner model is wrapped in `DeepSpeed` and then again in `torch.nn.DistributedDataParallel`. If the inner\n          model hasn't been wrapped, then `self.model_wrapped` is the same as `self.model`.\n        - **is_model_parallel** -- Whether or not a model has been switched to a model parallel mode (different from\n          data parallelism, this means some of the model layers are split on different GPUs).\n        - **place_model_on_device** -- Whether or not to automatically place the model on the device - it will be set\n          to `False` if model parallel or deepspeed is used, or if the default\n          `TrainingArguments.place_model_on_device` is overridden to return `False` .\n        - **is_in_train** -- Whether or not a model is currently running `train` (e.g. when `evaluate` is called while\n          in `train`)\n\n    \"\"\"\n\n    from transformers.trainer_pt_utils import _get_learning_rate, log_metrics, metrics_format, save_metrics, save_state\n\n    def __init__(\n        self,\n        model: Union[PreTrainedModel, nn.Module] = None,\n        args: TrainingArguments = None,\n        data_collator: Optional[DataCollator] = None,\n        train_dataset: Optional[Dataset] = None,\n        eval_dataset: Optional[Union[Dataset, Dict[str, Dataset]]] = None,\n        tokenizer: Optional[PreTrainedTokenizerBase] = None,\n        model_init: Optional[Callable[[], PreTrainedModel]] = None,\n        compute_metrics: Optional[Callable[[EvalPrediction], Dict]] = None,\n        callbacks: Optional[List[TrainerCallback]] = None,\n        optimizers: Tuple[torch.optim.Optimizer, torch.optim.lr_scheduler.LambdaLR] = (None, None),\n        preprocess_logits_for_metrics: Optional[Callable[[torch.Tensor, torch.Tensor], torch.Tensor]] = None,\n        save_prefixencoder: bool = False,\n    ):\n        self.save_prefixencoder = save_prefixencoder\n        if args is None:\n            output_dir = \"tmp_trainer\"\n            logger.info(f\"No `TrainingArguments` passed, using `output_dir={output_dir}`.\")\n            args = TrainingArguments(output_dir=output_dir)\n        self.args = args\n        # Seed must be set before instantiating the model when using model\n        enable_full_determinism(self.args.seed) if self.args.full_determinism else set_seed(self.args.seed)\n        self.hp_name = None\n        self.deepspeed = None\n        self.is_in_train = False\n\n        # memory metrics - must set up as early as possible\n        self._memory_tracker = TrainerMemoryTracker(self.args.skip_memory_metrics)\n        self._memory_tracker.start()\n\n        # set the correct log level depending on the node\n        log_level = args.get_process_log_level()\n        logging.set_verbosity(log_level)\n\n        # force device and distributed setup init explicitly\n        args._setup_devices\n\n        if model is None:\n            if model_init is not None:\n                self.model_init = model_init\n                model = self.call_model_init()\n            else:\n                raise RuntimeError(\"`Trainer` requires either a `model` or `model_init` argument\")\n        else:\n            if model_init is not None:\n                warnings.warn(\n                    \"`Trainer` requires either a `model` or `model_init` argument, but not both. `model_init` will\"\n                    \" overwrite your model when calling the `train` method. This will become a fatal error in the next\"\n                    \" release.\",\n                    FutureWarning,\n                )\n            self.model_init = model_init\n\n        if model.__class__.__name__ in MODEL_MAPPING_NAMES:\n            raise ValueError(\n                f\"The model you have picked ({model.__class__.__name__}) cannot be used as is for training: it only \"\n                \"computes hidden states and does not accept any labels. You should choose a model with a head \"\n                \"suitable for your task like any of the `AutoModelForXxx` listed at \"\n                \"https://huggingface.co/docs/transformers/model_doc/auto.\"\n            )\n\n        if hasattr(model, \"is_parallelizable\") and model.is_parallelizable and model.model_parallel:\n            self.is_model_parallel = True\n        else:\n            self.is_model_parallel = False\n\n        # At this stage the model is already loaded\n        if getattr(model, \"is_loaded_in_8bit\", False):\n            if getattr(model, \"_is_int8_training_enabled\", False):\n                logger.info(\n                    \"The model is loaded in 8-bit precision. To train this model you need to add additional modules\"\n                    \" inside the model such as adapters using `peft` library and freeze the model weights. Please\"\n                    \" check \"\n                    \" the examples in https://github.com/huggingface/peft for more details.\"\n                )\n            else:\n                raise ValueError(\n                    \"The model you want to train is loaded in 8-bit precision.  if you want to fine-tune an 8-bit\"\n                    \" model, please make sure that you have installed `bitsandbytes>=0.37.0`. \"\n                )\n\n        # Setup Sharded DDP training\n        self.sharded_ddp = None\n        if len(args.sharded_ddp) > 0:\n            if args.deepspeed:\n                raise ValueError(\n                    \"Using --sharded_ddp xxx together with --deepspeed is not possible, deactivate one of those flags.\"\n                )\n            if len(args.fsdp) > 0:\n                raise ValueError(\n                    \"Using --sharded_ddp xxx together with --fsdp is not possible, deactivate one of those flags.\"\n                )\n\n            if args.local_rank == -1:\n                raise ValueError(\"Using sharded DDP only works in distributed training.\")\n            elif not is_fairscale_available():\n                raise ImportError(\"Sharded DDP training requires fairscale: `pip install fairscale`.\")\n            elif ShardedDDPOption.SIMPLE not in args.sharded_ddp and FullyShardedDDP is None:\n                raise ImportError(\n                    \"Sharded DDP in a mode other than simple training requires fairscale version >= 0.3, found \"\n                    f\"{fairscale.__version__}. Upgrade your fairscale library: `pip install --upgrade fairscale`.\"\n                )\n            elif ShardedDDPOption.SIMPLE in args.sharded_ddp:\n                self.sharded_ddp = ShardedDDPOption.SIMPLE\n            elif ShardedDDPOption.ZERO_DP_2 in args.sharded_ddp:\n                self.sharded_ddp = ShardedDDPOption.ZERO_DP_2\n            elif ShardedDDPOption.ZERO_DP_3 in args.sharded_ddp:\n                self.sharded_ddp = ShardedDDPOption.ZERO_DP_3\n\n        self.fsdp = None\n        if len(args.fsdp) > 0:\n            if args.deepspeed:\n                raise ValueError(\n                    \"Using --fsdp xxx together with --deepspeed is not possible, deactivate one of those flags.\"\n                )\n            if not args.fsdp_config[\"xla\"] and args.local_rank == -1:\n                raise ValueError(\"Using fsdp only works in distributed training.\")\n\n            # dep_version_check(\"torch>=1.12.0\")\n            # Would have to update setup.py with torch>=1.12.0\n            # which isn't ideally given that it will force people not using FSDP to also use torch>=1.12.0\n            # below is the current alternative.\n            if version.parse(version.parse(torch.__version__).base_version) < version.parse(\"1.12.0\"):\n                raise ValueError(\"FSDP requires PyTorch >= 1.12.0\")\n\n            from torch.distributed.fsdp.fully_sharded_data_parallel import BackwardPrefetch, ShardingStrategy\n\n            if FSDPOption.FULL_SHARD in args.fsdp:\n                self.fsdp = ShardingStrategy.FULL_SHARD\n            elif FSDPOption.SHARD_GRAD_OP in args.fsdp:\n                self.fsdp = ShardingStrategy.SHARD_GRAD_OP\n            elif FSDPOption.NO_SHARD in args.fsdp:\n                self.fsdp = ShardingStrategy.NO_SHARD\n\n            self.backward_prefetch = BackwardPrefetch.BACKWARD_PRE\n            if \"backward_prefetch\" in self.args.fsdp_config and \"backward_pos\" not in self.backward_prefetch:\n                self.backward_prefetch = BackwardPrefetch.BACKWARD_POST\n\n            self.forword_prefetch = False\n            if self.args.fsdp_config.get(\"forword_prefect\", False):\n                self.forword_prefetch = True\n\n            self.limit_all_gathers = False\n            if self.args.fsdp_config.get(\"limit_all_gathers\", False):\n                self.limit_all_gathers = True\n\n        # one place to sort out whether to place the model on device or not\n        # postpone switching model to cuda when:\n        # 1. MP - since we are trying to fit a much bigger than 1 gpu model\n        # 2. fp16-enabled DeepSpeed loads the model in half the size and it doesn't need .to() anyway,\n        #    and we only use deepspeed for training at the moment\n        # 3. full bf16 or fp16 eval - since the model needs to be cast to the right dtype first\n        # 4. Sharded DDP - same as MP\n        # 5. FSDP - same as MP\n        self.place_model_on_device = args.place_model_on_device\n        if (\n            self.is_model_parallel\n            or args.deepspeed\n            or ((args.fp16_full_eval or args.bf16_full_eval) and not args.do_train)\n            or (self.sharded_ddp in [ShardedDDPOption.ZERO_DP_2, ShardedDDPOption.ZERO_DP_3])\n            or (self.fsdp is not None)\n        ):\n            self.place_model_on_device = False\n\n        default_collator = default_data_collator if tokenizer is None else DataCollatorWithPadding(tokenizer)\n        self.data_collator = data_collator if data_collator is not None else default_collator\n        self.train_dataset = train_dataset\n        self.eval_dataset = eval_dataset\n        self.tokenizer = tokenizer\n\n        if self.place_model_on_device and not getattr(model, \"is_loaded_in_8bit\", False):\n            self._move_model_to_device(model, args.device)\n\n        # Force n_gpu to 1 to avoid DataParallel as MP will manage the GPUs\n        if self.is_model_parallel:\n            self.args._n_gpu = 1\n\n        # later use `self.model is self.model_wrapped` to check if it's wrapped or not\n        self.model_wrapped = model\n        self.model = model\n\n        self.compute_metrics = compute_metrics\n        self.preprocess_logits_for_metrics = preprocess_logits_for_metrics\n        self.optimizer, self.lr_scheduler = optimizers\n        if model_init is not None and (self.optimizer is not None or self.lr_scheduler is not None):\n            raise RuntimeError(\n                \"Passing a `model_init` is incompatible with providing the `optimizers` argument. \"\n                \"You should subclass `Trainer` and override the `create_optimizer_and_scheduler` method.\"\n            )\n        if is_torch_tpu_available() and self.optimizer is not None:\n            for param in self.model.parameters():\n                model_device = param.device\n                break\n            for param_group in self.optimizer.param_groups:\n                if len(param_group[\"params\"]) > 0:\n                    optimizer_device = param_group[\"params\"][0].device\n                    break\n            if model_device != optimizer_device:\n                raise ValueError(\n                    \"The model and the optimizer parameters are not on the same device, which probably means you\"\n                    \" created an optimizer around your model **before** putting on the device and passing it to the\"\n                    \" `Trainer`. Make sure the lines `import torch_xla.core.xla_model as xm` and\"\n                    \" `model.to(xm.xla_device())` is performed before the optimizer creation in your script.\"\n                )\n        if ((self.sharded_ddp is not None) or args.deepspeed or (self.fsdp is not None)) and (\n            self.optimizer is not None or self.lr_scheduler is not None\n        ):\n            raise RuntimeError(\n                \"Passing `optimizers` is not allowed if Fairscale, Deepspeed or PyTorch FSDP is enabled.\"\n                \"You should subclass `Trainer` and override the `create_optimizer_and_scheduler` method.\"\n            )\n        default_callbacks = DEFAULT_CALLBACKS + get_reporting_integration_callbacks(self.args.report_to)\n        callbacks = default_callbacks if callbacks is None else default_callbacks + callbacks\n        self.callback_handler = CallbackHandler(\n            callbacks, self.model, self.tokenizer, self.optimizer, self.lr_scheduler\n        )\n        self.add_callback(PrinterCallback if self.args.disable_tqdm else DEFAULT_PROGRESS_CALLBACK)\n\n        # Will be set to True by `self._setup_loggers()` on first call to `self.log()`.\n        self._loggers_initialized = False\n\n        # Create clone of distant repo and output directory if needed\n        if self.args.push_to_hub:\n            self.init_git_repo(at_init=True)\n            # In case of pull, we need to make sure every process has the latest.\n            if is_torch_tpu_available():\n                xm.rendezvous(\"init git repo\")\n            elif args.local_rank != -1:\n                dist.barrier()\n\n        if self.args.should_save:\n            os.makedirs(self.args.output_dir, exist_ok=True)\n\n        if not callable(self.data_collator) and callable(getattr(self.data_collator, \"collate_batch\", None)):\n            raise ValueError(\"The `data_collator` should be a simple callable (function, class with `__call__`).\")\n\n        if args.max_steps > 0:\n            logger.info(\"max_steps is given, it will override any value given in num_train_epochs\")\n\n        if train_dataset is not None and not has_length(train_dataset) and args.max_steps <= 0:\n            raise ValueError(\"train_dataset does not implement __len__, max_steps has to be specified\")\n\n        if (\n            train_dataset is not None\n            and isinstance(train_dataset, torch.utils.data.IterableDataset)\n            and args.group_by_length\n        ):\n            raise ValueError(\"the `--group_by_length` option is only available for `Dataset`, not `IterableDataset\")\n\n        self._signature_columns = None\n\n        # Mixed precision setup\n        self.use_apex = False\n        self.use_cuda_amp = False\n        self.use_cpu_amp = False\n\n        # Mixed precision setup for SageMaker Model Parallel\n        if is_sagemaker_mp_enabled():\n            # BF16 + model parallelism in SageMaker: currently not supported, raise an error\n            if args.bf16:\n                raise ValueError(\"SageMaker Model Parallelism does not support BF16 yet. Please use FP16 instead \")\n\n            if IS_SAGEMAKER_MP_POST_1_10:\n                # When there's mismatch between SMP config and trainer argument, use SMP config as truth\n                if args.fp16 != smp.state.cfg.fp16:\n                    logger.warning(\n                        f\"FP16 provided in SM_HP_MP_PARAMETERS is {smp.state.cfg.fp16},\"\n                        f\"but FP16 provided in trainer argument is {args.fp16},\"\n                        f\"setting to {smp.state.cfg.fp16}\"\n                    )\n                    args.fp16 = smp.state.cfg.fp16\n            else:\n                # smp < 1.10 does not support fp16 in trainer.\n                if hasattr(smp.state.cfg, \"fp16\"):\n                    logger.warning(\n                        f\"FP16 provided in SM_HP_MP_PARAMETERS is {smp.state.cfg.fp16}, \"\n                        \"but SageMaker Model Parallelism < 1.10 does not support FP16 in trainer.\"\n                    )\n\n        if args.fp16 or args.bf16:\n            if args.half_precision_backend == \"auto\":\n                if args.device == torch.device(\"cpu\"):\n                    if args.fp16:\n                        raise ValueError(\"Tried to use `fp16` but it is not supported on cpu\")\n                    elif _is_native_cpu_amp_available:\n                        args.half_precision_backend = \"cpu_amp\"\n                    else:\n                        raise ValueError(\"Tried to use cpu amp but native cpu amp is not available\")\n                else:\n                    args.half_precision_backend = \"cuda_amp\"\n\n            logger.info(f\"Using {args.half_precision_backend} half precision backend\")\n\n        self.do_grad_scaling = False\n        if (args.fp16 or args.bf16) and not (args.deepspeed or is_sagemaker_mp_enabled() or is_torch_tpu_available()):\n            # deepspeed and SageMaker Model Parallel manage their own half precision\n            if args.half_precision_backend == \"cuda_amp\":\n                self.use_cuda_amp = True\n                self.amp_dtype = torch.float16 if args.fp16 else torch.bfloat16\n                #  bf16 does not need grad scaling\n                self.do_grad_scaling = self.amp_dtype == torch.float16\n                if self.do_grad_scaling:\n                    if self.sharded_ddp is not None:\n                        self.scaler = ShardedGradScaler()\n                    elif self.fsdp is not None:\n                        from torch.distributed.fsdp.sharded_grad_scaler import (\n                            ShardedGradScaler as FSDPShardedGradScaler,\n                        )\n\n                        self.scaler = FSDPShardedGradScaler()\n                    elif is_torch_tpu_available():\n                        from torch_xla.amp import GradScaler\n\n                        self.scaler = GradScaler()\n                    else:\n                        self.scaler = torch.cuda.amp.GradScaler()\n            elif args.half_precision_backend == \"cpu_amp\":\n                self.use_cpu_amp = True\n                self.amp_dtype = torch.bfloat16\n            else:\n                if not is_apex_available():\n                    raise ImportError(\n                        \"Using FP16 with APEX but APEX is not installed, please refer to\"\n                        \" https://www.github.com/nvidia/apex.\"\n                    )\n                self.use_apex = True\n\n        # FP16 + model parallelism in SageMaker: gradient clipping does not work for now so we raise a helpful error.\n        if (\n            is_sagemaker_mp_enabled()\n            and self.use_cuda_amp\n            and args.max_grad_norm is not None\n            and args.max_grad_norm > 0\n        ):\n            raise ValueError(\n                \"SageMaker Model Parallelism in mixed precision mode does not support gradient clipping yet. Pass \"\n                \"along 'max_grad_norm': 0 in your hyperparameters.\"\n            )\n\n        # Label smoothing\n        if self.args.label_smoothing_factor != 0:\n            self.label_smoother = LabelSmoother(epsilon=self.args.label_smoothing_factor)\n        else:\n            self.label_smoother = None\n\n        self.state = TrainerState(\n            is_local_process_zero=self.is_local_process_zero(),\n            is_world_process_zero=self.is_world_process_zero(),\n        )\n\n        self.control = TrainerControl()\n        # Internal variable to count flos in each process, will be accumulated in `self.state.total_flos` then\n        # returned to 0 every time flos need to be logged\n        self.current_flos = 0\n        self.hp_search_backend = None\n        self.use_tune_checkpoints = False\n        default_label_names = find_labels(self.model.__class__)\n        self.label_names = default_label_names if self.args.label_names is None else self.args.label_names\n        self.can_return_loss = can_return_loss(self.model.__class__)\n        self.control = self.callback_handler.on_init_end(self.args, self.state, self.control)\n\n        # Internal variables to keep track of the original batch size\n        self._train_batch_size = args.train_batch_size\n\n        # very last\n        self._memory_tracker.stop_and_update_metrics()\n\n        # torch.compile\n        if args.torch_compile and not is_torch_compile_available():\n            raise RuntimeError(\"Using torch.compile requires PyTorch 2.0 or higher.\")\n\n    def add_callback(self, callback):\n        \"\"\"\n        Add a callback to the current list of [`~transformer.TrainerCallback`].\n\n        Args:\n           callback (`type` or [`~transformer.TrainerCallback`]):\n               A [`~transformer.TrainerCallback`] class or an instance of a [`~transformer.TrainerCallback`]. In the\n               first case, will instantiate a member of that class.\n        \"\"\"\n        self.callback_handler.add_callback(callback)\n\n    def pop_callback(self, callback):\n        \"\"\"\n        Remove a callback from the current list of [`~transformer.TrainerCallback`] and returns it.\n\n        If the callback is not found, returns `None` (and no error is raised).\n\n        Args:\n           callback (`type` or [`~transformer.TrainerCallback`]):\n               A [`~transformer.TrainerCallback`] class or an instance of a [`~transformer.TrainerCallback`]. In the\n               first case, will pop the first member of that class found in the list of callbacks.\n\n        Returns:\n            [`~transformer.TrainerCallback`]: The callback removed, if found.\n        \"\"\"\n        return self.callback_handler.pop_callback(callback)\n\n    def remove_callback(self, callback):\n        \"\"\"\n        Remove a callback from the current list of [`~transformer.TrainerCallback`].\n\n        Args:\n           callback (`type` or [`~transformer.TrainerCallback`]):\n               A [`~transformer.TrainerCallback`] class or an instance of a [`~transformer.TrainerCallback`]. In the\n               first case, will remove the first member of that class found in the list of callbacks.\n        \"\"\"\n        self.callback_handler.remove_callback(callback)\n\n    def _move_model_to_device(self, model, device):\n        model = model.to(device)\n        # Moving a model to an XLA device disconnects the tied weights, so we have to retie them.\n        if self.args.parallel_mode == ParallelMode.TPU and hasattr(model, \"tie_weights\"):\n            model.tie_weights()\n\n    def _set_signature_columns_if_needed(self):\n        if self._signature_columns is None:\n            # Inspect model forward signature to keep only the arguments it accepts.\n            signature = inspect.signature(self.model.forward)\n            self._signature_columns = list(signature.parameters.keys())\n            # Labels may be named label or label_ids, the default data collator handles that.\n            self._signature_columns += list(set([\"label\", \"label_ids\"] + self.label_names))\n\n    def _remove_unused_columns(self, dataset: \"datasets.Dataset\", description: Optional[str] = None):\n        if not self.args.remove_unused_columns:\n            return dataset\n        self._set_signature_columns_if_needed()\n        signature_columns = self._signature_columns\n\n        ignored_columns = list(set(dataset.column_names) - set(signature_columns))\n        if len(ignored_columns) > 0:\n            dset_description = \"\" if description is None else f\"in the {description} set\"\n            logger.info(\n                f\"The following columns {dset_description} don't have a corresponding argument in \"\n                f\"`{self.model.__class__.__name__}.forward` and have been ignored: {', '.join(ignored_columns)}.\"\n                f\" If {', '.join(ignored_columns)} are not expected by `{self.model.__class__.__name__}.forward`, \"\n                \" you can safely ignore this message.\"\n            )\n\n        columns = [k for k in signature_columns if k in dataset.column_names]\n\n        if version.parse(datasets.__version__) < version.parse(\"1.4.0\"):\n            dataset.set_format(\n                type=dataset.format[\"type\"], columns=columns, format_kwargs=dataset.format[\"format_kwargs\"]\n            )\n            return dataset\n        else:\n            return dataset.remove_columns(ignored_columns)\n\n    def _get_collator_with_removed_columns(\n        self, data_collator: Callable, description: Optional[str] = None\n    ) -> Callable:\n        \"\"\"Wrap the data collator in a callable removing unused columns.\"\"\"\n        if not self.args.remove_unused_columns:\n            return data_collator\n        self._set_signature_columns_if_needed()\n        signature_columns = self._signature_columns\n\n        remove_columns_collator = RemoveColumnsCollator(\n            data_collator=data_collator,\n            signature_columns=signature_columns,\n            logger=logger,\n            description=description,\n            model_name=self.model.__class__.__name__,\n        )\n        return remove_columns_collator\n\n    def _get_train_sampler(self) -> Optional[torch.utils.data.Sampler]:\n        if self.train_dataset is None or not has_length(self.train_dataset):\n            return None\n\n        generator = None\n        if self.args.world_size <= 1:\n            generator = torch.Generator()\n            # for backwards compatibility, we generate a seed here (which is sampled from a generator seeded with\n            # `args.seed`) if data_seed isn't provided.\n            # Further on in this method, we default to `args.seed` instead.\n            if self.args.data_seed is None:\n                seed = int(torch.empty((), dtype=torch.int64).random_().item())\n            else:\n                seed = self.args.data_seed\n            generator.manual_seed(seed)\n\n        seed = self.args.data_seed if self.args.data_seed is not None else self.args.seed\n\n        # Build the sampler.\n        if self.args.group_by_length:\n            if is_datasets_available() and isinstance(self.train_dataset, datasets.Dataset):\n                lengths = (\n                    self.train_dataset[self.args.length_column_name]\n                    if self.args.length_column_name in self.train_dataset.column_names\n                    else None\n                )\n            else:\n                lengths = None\n            model_input_name = self.tokenizer.model_input_names[0] if self.tokenizer is not None else None\n            if self.args.world_size <= 1:\n                return LengthGroupedSampler(\n                    self.args.train_batch_size * self.args.gradient_accumulation_steps,\n                    dataset=self.train_dataset,\n                    lengths=lengths,\n                    model_input_name=model_input_name,\n                    generator=generator,\n                )\n            else:\n                return DistributedLengthGroupedSampler(\n                    self.args.train_batch_size * self.args.gradient_accumulation_steps,\n                    dataset=self.train_dataset,\n                    num_replicas=self.args.world_size,\n                    rank=self.args.process_index,\n                    lengths=lengths,\n                    model_input_name=model_input_name,\n                    seed=seed,\n                )\n\n        else:\n            if self.args.world_size <= 1:\n                return RandomSampler(self.train_dataset, generator=generator)\n            elif (\n                self.args.parallel_mode in [ParallelMode.TPU, ParallelMode.SAGEMAKER_MODEL_PARALLEL]\n                and not self.args.dataloader_drop_last\n            ):\n                # Use a loop for TPUs when drop_last is False to have all batches have the same size.\n                return DistributedSamplerWithLoop(\n                    self.train_dataset,\n                    batch_size=self.args.per_device_train_batch_size,\n                    num_replicas=self.args.world_size,\n                    rank=self.args.process_index,\n                    seed=seed,\n                )\n            else:\n                return DistributedSampler(\n                    self.train_dataset,\n                    num_replicas=self.args.world_size,\n                    rank=self.args.process_index,\n                    seed=seed,\n                )\n\n    def get_train_dataloader(self) -> DataLoader:\n        \"\"\"\n        Returns the training [`~torch.utils.data.DataLoader`].\n\n        Will use no sampler if `train_dataset` does not implement `__len__`, a random sampler (adapted to distributed\n        training if necessary) otherwise.\n\n        Subclass and override this method if you want to inject some custom behavior.\n        \"\"\"\n        if self.train_dataset is None:\n            raise ValueError(\"Trainer: training requires a train_dataset.\")\n\n        train_dataset = self.train_dataset\n        data_collator = self.data_collator\n        if is_datasets_available() and isinstance(train_dataset, datasets.Dataset):\n            train_dataset = self._remove_unused_columns(train_dataset, description=\"training\")\n        else:\n            data_collator = self._get_collator_with_removed_columns(data_collator, description=\"training\")\n\n        if isinstance(train_dataset, torch.utils.data.IterableDataset):\n            if self.args.world_size > 1:\n                train_dataset = IterableDatasetShard(\n                    train_dataset,\n                    batch_size=self._train_batch_size,\n                    drop_last=self.args.dataloader_drop_last,\n                    num_processes=self.args.world_size,\n                    process_index=self.args.process_index,\n                )\n\n            return DataLoader(\n                train_dataset,\n                batch_size=self._train_batch_size,\n                collate_fn=data_collator,\n                num_workers=self.args.dataloader_num_workers,\n                pin_memory=self.args.dataloader_pin_memory,\n            )\n\n        train_sampler = self._get_train_sampler()\n\n        return DataLoader(\n            train_dataset,\n            batch_size=self._train_batch_size,\n            sampler=train_sampler,\n            collate_fn=data_collator,\n            drop_last=self.args.dataloader_drop_last,\n            num_workers=self.args.dataloader_num_workers,\n            pin_memory=self.args.dataloader_pin_memory,\n            worker_init_fn=seed_worker,\n        )\n\n    def _get_eval_sampler(self, eval_dataset: Dataset) -> Optional[torch.utils.data.Sampler]:\n        # Deprecated code\n        if self.args.use_legacy_prediction_loop:\n            if is_torch_tpu_available():\n                return SequentialDistributedSampler(\n                    eval_dataset, num_replicas=xm.xrt_world_size(), rank=xm.get_ordinal()\n                )\n            elif is_sagemaker_mp_enabled():\n                return SequentialDistributedSampler(\n                    eval_dataset,\n                    num_replicas=smp.dp_size(),\n                    rank=smp.dp_rank(),\n                    batch_size=self.args.per_device_eval_batch_size,\n                )\n            elif self.args.local_rank != -1:\n                return SequentialDistributedSampler(eval_dataset)\n            else:\n                return SequentialSampler(eval_dataset)\n\n        if self.args.world_size <= 1:\n            return SequentialSampler(eval_dataset)\n        else:\n            return ShardSampler(\n                eval_dataset,\n                batch_size=self.args.per_device_eval_batch_size,\n                num_processes=self.args.world_size,\n                process_index=self.args.process_index,\n            )\n\n    def get_eval_dataloader(self, eval_dataset: Optional[Dataset] = None) -> DataLoader:\n        \"\"\"\n        Returns the evaluation [`~torch.utils.data.DataLoader`].\n\n        Subclass and override this method if you want to inject some custom behavior.\n\n        Args:\n            eval_dataset (`torch.utils.data.Dataset`, *optional*):\n                If provided, will override `self.eval_dataset`. If it is a [`~datasets.Dataset`], columns not accepted\n                by the `model.forward()` method are automatically removed. It must implement `__len__`.\n        \"\"\"\n        if eval_dataset is None and self.eval_dataset is None:\n            raise ValueError(\"Trainer: evaluation requires an eval_dataset.\")\n        eval_dataset = eval_dataset if eval_dataset is not None else self.eval_dataset\n        data_collator = self.data_collator\n\n        if is_datasets_available() and isinstance(eval_dataset, datasets.Dataset):\n            eval_dataset = self._remove_unused_columns(eval_dataset, description=\"evaluation\")\n        else:\n            data_collator = self._get_collator_with_removed_columns(data_collator, description=\"evaluation\")\n\n        if isinstance(eval_dataset, torch.utils.data.IterableDataset):\n            if self.args.world_size > 1:\n                eval_dataset = IterableDatasetShard(\n                    eval_dataset,\n                    batch_size=self.args.per_device_eval_batch_size,\n                    drop_last=self.args.dataloader_drop_last,\n                    num_processes=self.args.world_size,\n                    process_index=self.args.process_index,\n                )\n            return DataLoader(\n                eval_dataset,\n                batch_size=self.args.eval_batch_size,\n                collate_fn=data_collator,\n                num_workers=self.args.dataloader_num_workers,\n                pin_memory=self.args.dataloader_pin_memory,\n            )\n\n        eval_sampler = self._get_eval_sampler(eval_dataset)\n\n        return DataLoader(\n            eval_dataset,\n            sampler=eval_sampler,\n            batch_size=self.args.eval_batch_size,\n            collate_fn=data_collator,\n            drop_last=self.args.dataloader_drop_last,\n            num_workers=self.args.dataloader_num_workers,\n            pin_memory=self.args.dataloader_pin_memory,\n        )\n\n    def get_test_dataloader(self, test_dataset: Dataset) -> DataLoader:\n        \"\"\"\n        Returns the test [`~torch.utils.data.DataLoader`].\n\n        Subclass and override this method if you want to inject some custom behavior.\n\n        Args:\n            test_dataset (`torch.utils.data.Dataset`, *optional*):\n                The test dataset to use. If it is a [`~datasets.Dataset`], columns not accepted by the\n                `model.forward()` method are automatically removed. It must implement `__len__`.\n        \"\"\"\n        data_collator = self.data_collator\n\n        if is_datasets_available() and isinstance(test_dataset, datasets.Dataset):\n            test_dataset = self._remove_unused_columns(test_dataset, description=\"test\")\n        else:\n            data_collator = self._get_collator_with_removed_columns(data_collator, description=\"test\")\n\n        if isinstance(test_dataset, torch.utils.data.IterableDataset):\n            if self.args.world_size > 1:\n                test_dataset = IterableDatasetShard(\n                    test_dataset,\n                    batch_size=self.args.eval_batch_size,\n                    drop_last=self.args.dataloader_drop_last,\n                    num_processes=self.args.world_size,\n                    process_index=self.args.process_index,\n                )\n            return DataLoader(\n                test_dataset,\n                batch_size=self.args.eval_batch_size,\n                collate_fn=data_collator,\n                num_workers=self.args.dataloader_num_workers,\n                pin_memory=self.args.dataloader_pin_memory,\n            )\n\n        test_sampler = self._get_eval_sampler(test_dataset)\n\n        # We use the same batch_size as for eval.\n        return DataLoader(\n            test_dataset,\n            sampler=test_sampler,\n            batch_size=self.args.eval_batch_size,\n            collate_fn=data_collator,\n            drop_last=self.args.dataloader_drop_last,\n            num_workers=self.args.dataloader_num_workers,\n            pin_memory=self.args.dataloader_pin_memory,\n        )\n\n    def create_optimizer_and_scheduler(self, num_training_steps: int):\n        \"\"\"\n        Setup the optimizer and the learning rate scheduler.\n\n        We provide a reasonable default that works well. If you want to use something else, you can pass a tuple in the\n        Trainer's init through `optimizers`, or subclass and override this method (or `create_optimizer` and/or\n        `create_scheduler`) in a subclass.\n        \"\"\"\n        self.create_optimizer()\n        if IS_SAGEMAKER_MP_POST_1_10 and smp.state.cfg.fp16:\n            # If smp >= 1.10 and fp16 is enabled, we unwrap the optimizer\n            optimizer = self.optimizer.optimizer\n        else:\n            optimizer = self.optimizer\n        self.create_scheduler(num_training_steps=num_training_steps, optimizer=optimizer)\n\n    def create_optimizer(self):\n        \"\"\"\n        Setup the optimizer.\n\n        We provide a reasonable default that works well. If you want to use something else, you can pass a tuple in the\n        Trainer's init through `optimizers`, or subclass and override this method in a subclass.\n        \"\"\"\n        opt_model = self.model_wrapped if is_sagemaker_mp_enabled() else self.model\n\n        if self.optimizer is None:\n            decay_parameters = get_parameter_names(opt_model, ALL_LAYERNORM_LAYERS)\n            decay_parameters = [name for name in decay_parameters if \"bias\" not in name]\n            optimizer_grouped_parameters = [\n                {\n                    \"params\": [\n                        p for n, p in opt_model.named_parameters() if (n in decay_parameters and p.requires_grad)\n                    ],\n                    \"weight_decay\": self.args.weight_decay,\n                },\n                {\n                    \"params\": [\n                        p for n, p in opt_model.named_parameters() if (n not in decay_parameters and p.requires_grad)\n                    ],\n                    \"weight_decay\": 0.0,\n                },\n            ]\n\n            optimizer_cls, optimizer_kwargs = Trainer.get_optimizer_cls_and_kwargs(self.args)\n\n            if self.sharded_ddp == ShardedDDPOption.SIMPLE:\n                self.optimizer = OSS(\n                    params=optimizer_grouped_parameters,\n                    optim=optimizer_cls,\n                    **optimizer_kwargs,\n                )\n            else:\n                self.optimizer = optimizer_cls(optimizer_grouped_parameters, **optimizer_kwargs)\n                if optimizer_cls.__name__ == \"Adam8bit\":\n                    import bitsandbytes\n\n                    manager = bitsandbytes.optim.GlobalOptimManager.get_instance()\n\n                    skipped = 0\n                    for module in opt_model.modules():\n                        if isinstance(module, nn.Embedding):\n                            skipped += sum({p.data_ptr(): p.numel() for p in module.parameters()}.values())\n                            print(f\"skipped {module}: {skipped/2**20}M params\")\n                            manager.register_module_override(module, \"weight\", {\"optim_bits\": 32})\n                            logger.debug(f\"bitsandbytes: will optimize {module} in fp32\")\n                    print(f\"skipped: {skipped/2**20}M params\")\n\n        if is_sagemaker_mp_enabled():\n            self.optimizer = smp.DistributedOptimizer(self.optimizer)\n\n        return self.optimizer\n\n    @staticmethod\n    def get_optimizer_cls_and_kwargs(args: TrainingArguments) -> Tuple[Any, Any]:\n        \"\"\"\n        Returns the optimizer class and optimizer parameters based on the training arguments.\n\n        Args:\n            args (`transformers.training_args.TrainingArguments`):\n                The training arguments for the training session.\n\n        \"\"\"\n\n        # parse args.optim_args\n        optim_args = {}\n        if args.optim_args:\n            for mapping in args.optim_args.replace(\" \", \"\").split(\",\"):\n                key, value = mapping.split(\"=\")\n                optim_args[key] = value\n\n        optimizer_kwargs = {\"lr\": args.learning_rate}\n\n        adam_kwargs = {\n            \"betas\": (args.adam_beta1, args.adam_beta2),\n            \"eps\": args.adam_epsilon,\n        }\n        if args.optim == OptimizerNames.ADAFACTOR:\n            optimizer_cls = Adafactor\n            optimizer_kwargs.update({\"scale_parameter\": False, \"relative_step\": False})\n        elif args.optim == OptimizerNames.ADAMW_HF:\n            from transformers.optimization import AdamW\n\n            optimizer_cls = AdamW\n            optimizer_kwargs.update(adam_kwargs)\n        elif args.optim in [OptimizerNames.ADAMW_TORCH, OptimizerNames.ADAMW_TORCH_FUSED]:\n            from torch.optim import AdamW\n\n            optimizer_cls = AdamW\n            optimizer_kwargs.update(adam_kwargs)\n            if args.optim == OptimizerNames.ADAMW_TORCH_FUSED:\n                optimizer_kwargs.update({\"fused\": True})\n        elif args.optim == OptimizerNames.ADAMW_TORCH_XLA:\n            try:\n                from torch_xla.amp.syncfree import AdamW\n\n                optimizer_cls = AdamW\n                optimizer_kwargs.update(adam_kwargs)\n            except ImportError:\n                raise ValueError(\"Trainer failed to import syncfree AdamW from torch_xla.\")\n        elif args.optim == OptimizerNames.ADAMW_APEX_FUSED:\n            try:\n                from apex.optimizers import FusedAdam\n\n                optimizer_cls = FusedAdam\n                optimizer_kwargs.update(adam_kwargs)\n            except ImportError:\n                raise ValueError(\"Trainer tried to instantiate apex FusedAdam but apex is not installed!\")\n        elif args.optim == OptimizerNames.ADAMW_BNB:\n            try:\n                from bitsandbytes.optim import Adam8bit\n\n                optimizer_cls = Adam8bit\n                optimizer_kwargs.update(adam_kwargs)\n            except ImportError:\n                raise ValueError(\"Trainer tried to instantiate bnb Adam8bit but bnb is not installed!\")\n        elif args.optim == OptimizerNames.ADAMW_ANYPRECISION:\n            try:\n                from torchdistx.optimizers import AnyPrecisionAdamW\n\n                optimizer_cls = AnyPrecisionAdamW\n                optimizer_kwargs.update(adam_kwargs)\n\n                # TODO Change dtypes back to M=FP32, Var = BF16, Kahan = False once they can be cast together in torchdistx.\n                optimizer_kwargs.update(\n                    {\n                        \"use_kahan_summation\": strtobool(optim_args.get(\"use_kahan_summation\", \"False\")),\n                        \"momentum_dtype\": getattr(torch, optim_args.get(\"momentum_dtype\", \"float32\")),\n                        \"variance_dtype\": getattr(torch, optim_args.get(\"variance_dtype\", \"float32\")),\n                        \"compensation_buffer_dtype\": getattr(\n                            torch, optim_args.get(\"compensation_buffer_dtype\", \"bfloat16\")\n                        ),\n                    }\n                )\n            except ImportError:\n                raise ValueError(\"Please install https://github.com/pytorch/torchdistx\")\n        elif args.optim == OptimizerNames.SGD:\n            optimizer_cls = torch.optim.SGD\n        elif args.optim == OptimizerNames.ADAGRAD:\n            optimizer_cls = torch.optim.Adagrad\n        else:\n            raise ValueError(f\"Trainer cannot instantiate unsupported optimizer: {args.optim}\")\n        return optimizer_cls, optimizer_kwargs\n\n    def create_scheduler(self, num_training_steps: int, optimizer: torch.optim.Optimizer = None):\n        \"\"\"\n        Setup the scheduler. The optimizer of the trainer must have been set up either before this method is called or\n        passed as an argument.\n\n        Args:\n            num_training_steps (int): The number of training steps to do.\n        \"\"\"\n        if self.lr_scheduler is None:\n            self.lr_scheduler = get_scheduler(\n                self.args.lr_scheduler_type,\n                optimizer=self.optimizer if optimizer is None else optimizer,\n                num_warmup_steps=self.args.get_warmup_steps(num_training_steps),\n                num_training_steps=num_training_steps,\n            )\n        return self.lr_scheduler\n\n    def num_examples(self, dataloader: DataLoader) -> int:\n        \"\"\"\n        Helper to get number of samples in a [`~torch.utils.data.DataLoader`] by accessing its dataset. When\n        dataloader.dataset does not exist or has no length, estimates as best it can\n        \"\"\"\n        try:\n            dataset = dataloader.dataset\n            # Special case for IterableDatasetShard, we need to dig deeper\n            if isinstance(dataset, IterableDatasetShard):\n                return len(dataloader.dataset.dataset)\n            return len(dataloader.dataset)\n        except (NameError, AttributeError, TypeError):  # no dataset or length, estimate by length of dataloader\n            return len(dataloader) * self.args.per_device_train_batch_size\n\n    def _hp_search_setup(self, trial: Union[\"optuna.Trial\", Dict[str, Any]]):\n        \"\"\"HP search setup code\"\"\"\n        self._trial = trial\n\n        if self.hp_search_backend is None or trial is None:\n            return\n        if self.hp_search_backend == HPSearchBackend.OPTUNA:\n            params = self.hp_space(trial)\n        elif self.hp_search_backend == HPSearchBackend.RAY:\n            params = trial\n            params.pop(\"wandb\", None)\n        elif self.hp_search_backend == HPSearchBackend.SIGOPT:\n            params = {k: int(v) if isinstance(v, str) else v for k, v in trial.assignments.items()}\n        elif self.hp_search_backend == HPSearchBackend.WANDB:\n            params = trial\n\n        for key, value in params.items():\n            if not hasattr(self.args, key):\n                logger.warning(\n                    f\"Trying to set {key} in the hyperparameter search but there is no corresponding field in\"\n                    \" `TrainingArguments`.\"\n                )\n                continue\n            old_attr = getattr(self.args, key, None)\n            # Casting value to the proper type\n            if old_attr is not None:\n                value = type(old_attr)(value)\n            setattr(self.args, key, value)\n        if self.hp_search_backend == HPSearchBackend.OPTUNA:\n            logger.info(f\"Trial: {trial.params}\")\n        if self.hp_search_backend == HPSearchBackend.SIGOPT:\n            logger.info(f\"SigOpt Assignments: {trial.assignments}\")\n        if self.hp_search_backend == HPSearchBackend.WANDB:\n            logger.info(f\"W&B Sweep parameters: {trial}\")\n        if self.args.deepspeed:\n            # Rebuild the deepspeed config to reflect the updated training parameters\n            from transformers.deepspeed import HfTrainerDeepSpeedConfig\n\n            self.args.hf_deepspeed_config = HfTrainerDeepSpeedConfig(self.args.deepspeed)\n            self.args.hf_deepspeed_config.trainer_config_process(self.args)\n\n    def _report_to_hp_search(self, trial: Union[\"optuna.Trial\", Dict[str, Any]], step: int, metrics: Dict[str, float]):\n        if self.hp_search_backend is None or trial is None:\n            return\n        self.objective = self.compute_objective(metrics.copy())\n        if self.hp_search_backend == HPSearchBackend.OPTUNA:\n            import optuna\n\n            trial.report(self.objective, step)\n            if trial.should_prune():\n                self.callback_handler.on_train_end(self.args, self.state, self.control)\n                raise optuna.TrialPruned()\n        elif self.hp_search_backend == HPSearchBackend.RAY:\n            from ray import tune\n\n            if self.control.should_save:\n                self._tune_save_checkpoint()\n            tune.report(objective=self.objective, **metrics)\n\n    def _tune_save_checkpoint(self):\n        from ray import tune\n\n        if not self.use_tune_checkpoints:\n            return\n        with tune.checkpoint_dir(step=self.state.global_step) as checkpoint_dir:\n            output_dir = os.path.join(checkpoint_dir, f\"{PREFIX_CHECKPOINT_DIR}-{self.state.global_step}\")\n            self.save_model(output_dir, _internal_call=True)\n            if self.args.should_save:\n                self.state.save_to_json(os.path.join(output_dir, TRAINER_STATE_NAME))\n                torch.save(self.optimizer.state_dict(), os.path.join(output_dir, OPTIMIZER_NAME))\n                torch.save(self.lr_scheduler.state_dict(), os.path.join(output_dir, SCHEDULER_NAME))\n\n    def call_model_init(self, trial=None):\n        model_init_argcount = number_of_arguments(self.model_init)\n        if model_init_argcount == 0:\n            model = self.model_init()\n        elif model_init_argcount == 1:\n            model = self.model_init(trial)\n        else:\n            raise RuntimeError(\"model_init should have 0 or 1 argument.\")\n\n        if model is None:\n            raise RuntimeError(\"model_init should not return None.\")\n\n        return model\n\n    def torch_jit_model_eval(self, model, dataloader, training=False):\n        if not training:\n            if dataloader is None:\n                logger.warning(\"failed to use PyTorch jit mode due to current dataloader is none.\")\n                return model\n            example_batch = next(iter(dataloader))\n            example_batch = self._prepare_inputs(example_batch)\n            try:\n                jit_model = model.eval()\n                with ContextManagers([self.autocast_smart_context_manager(cache_enabled=False), torch.no_grad()]):\n                    if version.parse(version.parse(torch.__version__).base_version) >= version.parse(\"1.14.0\"):\n                        if isinstance(example_batch, dict):\n                            jit_model = torch.jit.trace(jit_model, example_kwarg_inputs=example_batch, strict=False)\n                        else:\n                            jit_model = torch.jit.trace(\n                                jit_model,\n                                example_kwarg_inputs={key: example_batch[key] for key in example_batch},\n                                strict=False,\n                            )\n                    else:\n                        jit_inputs = []\n                        for key in example_batch:\n                            example_tensor = torch.ones_like(example_batch[key])\n                            jit_inputs.append(example_tensor)\n                        jit_inputs = tuple(jit_inputs)\n                        jit_model = torch.jit.trace(jit_model, jit_inputs, strict=False)\n                jit_model = torch.jit.freeze(jit_model)\n                with torch.no_grad():\n                    jit_model(**example_batch)\n                    jit_model(**example_batch)\n                model = jit_model\n                self.use_cpu_amp = False\n                self.use_cuda_amp = False\n            except (RuntimeError, TypeError, ValueError, NameError, IndexError) as e:\n                logger.warning(f\"failed to use PyTorch jit mode due to: {e}.\")\n\n        return model\n\n    def ipex_optimize_model(self, model, training=False, dtype=torch.float32):\n        if not is_ipex_available():\n            raise ImportError(\n                \"Using IPEX but IPEX is not installed or IPEX's version does not match current PyTorch, please refer\"\n                \" to https://github.com/intel/intel-extension-for-pytorch.\"\n            )\n\n        import intel_extension_for_pytorch as ipex\n\n        if not training:\n            model.eval()\n            dtype = torch.bfloat16 if not self.is_in_train and self.args.bf16_full_eval else dtype\n            # conv_bn_folding is disabled as it fails in symbolic tracing, resulting in ipex warnings\n            model = ipex.optimize(model, dtype=dtype, level=\"O1\", conv_bn_folding=False, inplace=not self.is_in_train)\n        else:\n            if not model.training:\n                model.train()\n            model, self.optimizer = ipex.optimize(\n                model, dtype=dtype, optimizer=self.optimizer, inplace=True, level=\"O1\"\n            )\n\n        return model\n\n    def _wrap_model(self, model, training=True, dataloader=None):\n        if self.args.torch_compile:\n            model = torch.compile(model, backend=self.args.torch_compile_backend, mode=self.args.torch_compile_mode)\n\n        if self.args.use_ipex:\n            dtype = torch.bfloat16 if self.use_cpu_amp else torch.float32\n            model = self.ipex_optimize_model(model, training, dtype=dtype)\n\n        if is_sagemaker_mp_enabled():\n            # Wrapping the base model twice in a DistributedModel will raise an error.\n            if isinstance(self.model_wrapped, smp.model.DistributedModel):\n                return self.model_wrapped\n            return smp.DistributedModel(model, backward_passes_per_step=self.args.gradient_accumulation_steps)\n\n        # already initialized its own DDP and AMP\n        if self.deepspeed:\n            return self.deepspeed\n\n        # train/eval could be run multiple-times - if already wrapped, don't re-wrap it again\n        if unwrap_model(model) is not model:\n            return model\n\n        # Mixed precision training with apex (torch < 1.6)\n        if self.use_apex and training:\n            model, self.optimizer = amp.initialize(model, self.optimizer, opt_level=self.args.fp16_opt_level)\n\n        # Multi-gpu training (should be after apex fp16 initialization)\n        if self.args.n_gpu > 1:\n            model = nn.DataParallel(model)\n\n        if self.args.jit_mode_eval:\n            start_time = time.time()\n            model = self.torch_jit_model_eval(model, dataloader, training)\n            self.jit_compilation_time = round(time.time() - start_time, 4)\n\n        # Note: in torch.distributed mode, there's no point in wrapping the model\n        # inside a DistributedDataParallel as we'll be under `no_grad` anyways.\n        if not training:\n            return model\n\n        # Distributed training (should be after apex fp16 initialization)\n        if self.sharded_ddp is not None:\n            # Sharded DDP!\n            if self.sharded_ddp == ShardedDDPOption.SIMPLE:\n                model = ShardedDDP(model, self.optimizer)\n            else:\n                mixed_precision = self.args.fp16 or self.args.bf16\n                cpu_offload = ShardedDDPOption.OFFLOAD in self.args.sharded_ddp\n                zero_3 = self.sharded_ddp == ShardedDDPOption.ZERO_DP_3\n                # XXX: Breaking the self.model convention but I see no way around it for now.\n                if ShardedDDPOption.AUTO_WRAP in self.args.sharded_ddp:\n                    model = auto_wrap(model)\n                self.model = model = FullyShardedDDP(\n                    model,\n                    mixed_precision=mixed_precision,\n                    reshard_after_forward=zero_3,\n                    cpu_offload=cpu_offload,\n                ).to(self.args.device)\n        # Distributed training using PyTorch FSDP\n        elif self.fsdp is not None:\n            if not self.args.fsdp_config[\"xla\"]:\n                # PyTorch FSDP!\n                from torch.distributed.fsdp.fully_sharded_data_parallel import CPUOffload, MixedPrecision\n                from torch.distributed.fsdp.fully_sharded_data_parallel import FullyShardedDataParallel as FSDP\n                from torch.distributed.fsdp.wrap import size_based_auto_wrap_policy, transformer_auto_wrap_policy\n\n                if FSDPOption.OFFLOAD in self.args.fsdp:\n                    cpu_offload = CPUOffload(offload_params=True)\n                else:\n                    cpu_offload = CPUOffload(offload_params=False)\n\n                auto_wrap_policy = None\n\n                if FSDPOption.AUTO_WRAP in self.args.fsdp:\n                    if self.args.fsdp_config[\"fsdp_min_num_params\"] > 0:\n                        auto_wrap_policy = functools.partial(\n                            size_based_auto_wrap_policy, min_num_params=self.args.fsdp_config[\"fsdp_min_num_params\"]\n                        )\n                    elif self.args.fsdp_config.get(\"fsdp_transformer_layer_cls_to_wrap\", None) is not None:\n                        transformer_cls_to_wrap = set()\n                        for layer_class in self.args.fsdp_config[\"fsdp_transformer_layer_cls_to_wrap\"]:\n                            transformer_cls = get_module_class_from_name(model, layer_class)\n                            if transformer_cls is None:\n                                raise Exception(\"Could not find the transformer layer class to wrap in the model.\")\n                            else:\n                                transformer_cls_to_wrap.add(transformer_cls)\n                        auto_wrap_policy = functools.partial(\n                            transformer_auto_wrap_policy,\n                            # Transformer layer class to wrap\n                            transformer_layer_cls=transformer_cls_to_wrap,\n                        )\n                mixed_precision_policy = None\n                dtype = None\n                if self.args.fp16:\n                    dtype = torch.float16\n                elif self.args.bf16:\n                    dtype = torch.bfloat16\n                if dtype is not None:\n                    mixed_precision_policy = MixedPrecision(param_dtype=dtype, reduce_dtype=dtype, buffer_dtype=dtype)\n                if type(model) != FSDP:\n                    # XXX: Breaking the self.model convention but I see no way around it for now.\n                    self.model = model = FSDP(\n                        model,\n                        sharding_strategy=self.fsdp,\n                        cpu_offload=cpu_offload,\n                        auto_wrap_policy=auto_wrap_policy,\n                        mixed_precision=mixed_precision_policy,\n                        device_id=self.args.device,\n                        backward_prefetch=self.backward_prefetch,\n                        forward_prefetch=self.forword_prefetch,\n                        limit_all_gathers=self.limit_all_gathers,\n                    )\n            else:\n                try:\n                    from torch_xla.distributed.fsdp import XlaFullyShardedDataParallel as FSDP\n                    from torch_xla.distributed.fsdp import checkpoint_module\n                    from torch_xla.distributed.fsdp.wrap import (\n                        size_based_auto_wrap_policy,\n                        transformer_auto_wrap_policy,\n                    )\n                except ImportError:\n                    raise ImportError(\"Missing XLA FSDP related module; please make sure to use torch-xla >= 2.0.\")\n                auto_wrap_policy = None\n                auto_wrapper_callable = None\n                if self.args.fsdp_config[\"fsdp_min_num_params\"] > 0:\n                    auto_wrap_policy = functools.partial(\n                        size_based_auto_wrap_policy, min_num_params=self.args.fsdp_config[\"fsdp_min_num_params\"]\n                    )\n                elif self.args.fsdp_config.get(\"fsdp_transformer_layer_cls_to_wrap\", None) is not None:\n                    transformer_cls_to_wrap = set()\n                    for layer_class in self.args.fsdp_config[\"fsdp_transformer_layer_cls_to_wrap\"]:\n                        transformer_cls = get_module_class_from_name(model, layer_class)\n                        if transformer_cls is None:\n                            raise Exception(\"Could not find the transformer layer class to wrap in the model.\")\n                        else:\n                            transformer_cls_to_wrap.add(transformer_cls)\n                    auto_wrap_policy = functools.partial(\n                        transformer_auto_wrap_policy,\n                        # Transformer layer class to wrap\n                        transformer_layer_cls=transformer_cls_to_wrap,\n                    )\n                fsdp_kwargs = self.args.xla_fsdp_config\n                if self.args.fsdp_config[\"xla_fsdp_grad_ckpt\"]:\n                    # Apply gradient checkpointing to auto-wrapped sub-modules if specified\n                    def auto_wrapper_callable(m, *args, **kwargs):\n                        return FSDP(checkpoint_module(m), *args, **kwargs)\n\n                # Wrap the base model with an outer FSDP wrapper\n                self.model = model = FSDP(\n                    model,\n                    auto_wrap_policy=auto_wrap_policy,\n                    auto_wrapper_callable=auto_wrapper_callable,\n                    **fsdp_kwargs,\n                )\n\n                # Patch `xm.optimizer_step` should not reduce gradients in this case,\n                # as FSDP does not need gradient reduction over sharded parameters.\n                def patched_optimizer_step(optimizer, barrier=False, optimizer_args={}):\n                    loss = optimizer.step(**optimizer_args)\n                    if barrier:\n                        xm.mark_step()\n                    return loss\n\n                xm.optimizer_step = patched_optimizer_step\n        elif is_sagemaker_dp_enabled():\n            model = nn.parallel.DistributedDataParallel(\n                model, device_ids=[int(os.getenv(\"SMDATAPARALLEL_LOCAL_RANK\"))]\n            )\n        elif self.args.local_rank != -1:\n            kwargs = {}\n            if self.args.ddp_find_unused_parameters is not None:\n                kwargs[\"find_unused_parameters\"] = self.args.ddp_find_unused_parameters\n            elif isinstance(model, PreTrainedModel):\n                # find_unused_parameters breaks checkpointing as per\n                # https://github.com/huggingface/transformers/pull/4659#issuecomment-643356021\n                kwargs[\"find_unused_parameters\"] = not model.is_gradient_checkpointing\n            else:\n                kwargs[\"find_unused_parameters\"] = True\n\n            if self.args.ddp_bucket_cap_mb is not None:\n                kwargs[\"bucket_cap_mb\"] = self.args.ddp_bucket_cap_mb\n            if is_torch_neuroncore_available():\n                return model\n            model = nn.parallel.DistributedDataParallel(\n                model,\n                device_ids=[self.args.local_rank] if self.args._n_gpu != 0 else None,\n                output_device=self.args.local_rank if self.args._n_gpu != 0 else None,\n                **kwargs,\n            )\n\n        return model\n\n    def train(\n        self,\n        resume_from_checkpoint: Optional[Union[str, bool]] = None,\n        trial: Union[\"optuna.Trial\", Dict[str, Any]] = None,\n        ignore_keys_for_eval: Optional[List[str]] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Main training entry point.\n\n        Args:\n            resume_from_checkpoint (`str` or `bool`, *optional*):\n                If a `str`, local path to a saved checkpoint as saved by a previous instance of [`Trainer`]. If a\n                `bool` and equals `True`, load the last checkpoint in *args.output_dir* as saved by a previous instance\n                of [`Trainer`]. If present, training will resume from the model/optimizer/scheduler states loaded here.\n            trial (`optuna.Trial` or `Dict[str, Any]`, *optional*):\n                The trial run or the hyperparameter dictionary for hyperparameter search.\n            ignore_keys_for_eval (`List[str]`, *optional*)\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions for evaluation during the training.\n            kwargs:\n                Additional keyword arguments used to hide deprecated arguments\n        \"\"\"\n        if resume_from_checkpoint is False:\n            resume_from_checkpoint = None\n\n        # memory metrics - must set up as early as possible\n        self._memory_tracker.start()\n\n        args = self.args\n\n        self.is_in_train = True\n\n        # do_train is not a reliable argument, as it might not be set and .train() still called, so\n        # the following is a workaround:\n        if (args.fp16_full_eval or args.bf16_full_eval) and not args.do_train:\n            self._move_model_to_device(self.model, args.device)\n\n        if \"model_path\" in kwargs:\n            resume_from_checkpoint = kwargs.pop(\"model_path\")\n            warnings.warn(\n                \"`model_path` is deprecated and will be removed in a future version. Use `resume_from_checkpoint` \"\n                \"instead.\",\n                FutureWarning,\n            )\n        if len(kwargs) > 0:\n            raise TypeError(f\"train() received got unexpected keyword arguments: {', '.join(list(kwargs.keys()))}.\")\n        # This might change the seed so needs to run first.\n        self._hp_search_setup(trial)\n        self._train_batch_size = self.args.train_batch_size\n\n        # Model re-init\n        model_reloaded = False\n        if self.model_init is not None:\n            # Seed must be set before instantiating the model when using model_init.\n            enable_full_determinism(self.args.seed) if self.args.full_determinism else set_seed(self.args.seed)\n            self.model = self.call_model_init(trial)\n            model_reloaded = True\n            # Reinitializes optimizer and scheduler\n            self.optimizer, self.lr_scheduler = None, None\n\n        # Load potential model checkpoint\n        if isinstance(resume_from_checkpoint, bool) and resume_from_checkpoint:\n            resume_from_checkpoint = get_last_checkpoint(args.output_dir)\n            if resume_from_checkpoint is None:\n                raise ValueError(f\"No valid checkpoint found in output directory ({args.output_dir})\")\n\n        if resume_from_checkpoint is not None and not is_sagemaker_mp_enabled() and args.deepspeed is None:\n            self._load_from_checkpoint(resume_from_checkpoint)\n\n        # If model was re-initialized, put it on the right device and update self.model_wrapped\n        if model_reloaded:\n            if self.place_model_on_device:\n                self._move_model_to_device(self.model, args.device)\n            self.model_wrapped = self.model\n\n        inner_training_loop = find_executable_batch_size(\n            self._inner_training_loop, self._train_batch_size, args.auto_find_batch_size\n        )\n        return inner_training_loop(\n            args=args,\n            resume_from_checkpoint=resume_from_checkpoint,\n            trial=trial,\n            ignore_keys_for_eval=ignore_keys_for_eval,\n        )\n\n    def _inner_training_loop(\n        self, batch_size=None, args=None, resume_from_checkpoint=None, trial=None, ignore_keys_for_eval=None\n    ):\n        self._train_batch_size = batch_size\n        # Data loader and number of training steps\n        train_dataloader = self.get_train_dataloader()\n\n        # Setting up training control variables:\n        # number of training epochs: num_train_epochs\n        # number of training steps per epoch: num_update_steps_per_epoch\n        # total number of training steps to execute: max_steps\n        total_train_batch_size = args.train_batch_size * args.gradient_accumulation_steps * args.world_size\n\n        len_dataloader = None\n        if has_length(train_dataloader):\n            len_dataloader = len(train_dataloader)\n            num_update_steps_per_epoch = len_dataloader // args.gradient_accumulation_steps\n            num_update_steps_per_epoch = max(num_update_steps_per_epoch, 1)\n            num_examples = self.num_examples(train_dataloader)\n            if args.max_steps > 0:\n                max_steps = args.max_steps\n                num_train_epochs = args.max_steps // num_update_steps_per_epoch + int(\n                    args.max_steps % num_update_steps_per_epoch > 0\n                )\n                # May be slightly incorrect if the last batch in the training dataloader has a smaller size but it's\n                # the best we can do.\n                num_train_samples = args.max_steps * total_train_batch_size\n            else:\n                max_steps = math.ceil(args.num_train_epochs * num_update_steps_per_epoch)\n                num_train_epochs = math.ceil(args.num_train_epochs)\n                num_train_samples = self.num_examples(train_dataloader) * args.num_train_epochs\n        elif args.max_steps > 0:  # Rely on max_steps when dataloader does not have a working size\n            max_steps = args.max_steps\n            # Setting a very large number of epochs so we go as many times as necessary over the iterator.\n            num_train_epochs = sys.maxsize\n            num_update_steps_per_epoch = max_steps\n            num_examples = total_train_batch_size * args.max_steps\n            num_train_samples = args.max_steps * total_train_batch_size\n        else:\n            raise ValueError(\n                \"args.max_steps must be set to a positive value if dataloader does not have a length, was\"\n                f\" {args.max_steps}\"\n            )\n\n        if DebugOption.UNDERFLOW_OVERFLOW in self.args.debug:\n            if self.args.n_gpu > 1:\n                # nn.DataParallel(model) replicates the model, creating new variables and module\n                # references registered here no longer work on other gpus, breaking the module\n                raise ValueError(\n                    \"Currently --debug underflow_overflow is not supported under DP. Please use DDP\"\n                    \" (torch.distributed.launch).\"\n                )\n            else:\n                debug_overflow = DebugUnderflowOverflow(self.model)  # noqa\n\n        delay_optimizer_creation = (\n            self.sharded_ddp is not None\n            and self.sharded_ddp != ShardedDDPOption.SIMPLE\n            or is_sagemaker_mp_enabled()\n            or self.fsdp is not None\n        )\n        if args.deepspeed:\n            deepspeed_engine, optimizer, lr_scheduler = deepspeed_init(\n                self, num_training_steps=max_steps, resume_from_checkpoint=resume_from_checkpoint\n            )\n            self.model = deepspeed_engine.module\n            self.model_wrapped = deepspeed_engine\n            self.deepspeed = deepspeed_engine\n            self.optimizer = optimizer\n            self.lr_scheduler = lr_scheduler\n        elif not delay_optimizer_creation:\n            self.create_optimizer_and_scheduler(num_training_steps=max_steps)\n\n        self.state = TrainerState()\n        self.state.is_hyper_param_search = trial is not None\n\n        # Activate gradient checkpointing if needed\n        if args.gradient_checkpointing:\n            self.model.gradient_checkpointing_enable()\n\n        model = self._wrap_model(self.model_wrapped)\n\n        if is_sagemaker_mp_enabled() and resume_from_checkpoint is not None:\n            self._load_from_checkpoint(resume_from_checkpoint, model)\n\n        # for the rest of this function `model` is the outside model, whether it was wrapped or not\n        if model is not self.model:\n            self.model_wrapped = model\n\n        if delay_optimizer_creation:\n            self.create_optimizer_and_scheduler(num_training_steps=max_steps)\n\n        # Check if saved optimizer or scheduler states exist\n        self._load_optimizer_and_scheduler(resume_from_checkpoint)\n\n        # important: at this point:\n        # self.model         is the Transformers Model\n        # self.model_wrapped is DDP(Transformers Model), Deepspeed(Transformers Model), etc.\n\n        # Train!\n        logger.info(\"***** Running training *****\")\n        logger.info(f\"  Num examples = {num_examples}\")\n        logger.info(f\"  Num Epochs = {num_train_epochs}\")\n        logger.info(f\"  Instantaneous batch size per device = {args.per_device_train_batch_size}\")\n        logger.info(f\"  Total train batch size (w. parallel, distributed & accumulation) = {total_train_batch_size}\")\n        logger.info(f\"  Gradient Accumulation steps = {args.gradient_accumulation_steps}\")\n        logger.info(f\"  Total optimization steps = {max_steps}\")\n        logger.info(\n            f\"  Number of trainable parameters = {sum(p.numel() for p in model.parameters() if p.requires_grad)}\"\n        )\n\n        self.state.epoch = 0\n        start_time = time.time()\n        epochs_trained = 0\n        steps_trained_in_current_epoch = 0\n        steps_trained_progress_bar = None\n\n        # Check if continuing training from a checkpoint\n        if resume_from_checkpoint is not None and os.path.isfile(\n            os.path.join(resume_from_checkpoint, TRAINER_STATE_NAME)\n        ):\n            self.state = TrainerState.load_from_json(os.path.join(resume_from_checkpoint, TRAINER_STATE_NAME))\n            epochs_trained = self.state.global_step // num_update_steps_per_epoch\n            if not args.ignore_data_skip:\n                steps_trained_in_current_epoch = self.state.global_step % (num_update_steps_per_epoch)\n                steps_trained_in_current_epoch *= args.gradient_accumulation_steps\n            else:\n                steps_trained_in_current_epoch = 0\n\n            logger.info(\"  Continuing training from checkpoint, will skip to saved global_step\")\n            logger.info(f\"  Continuing training from epoch {epochs_trained}\")\n            logger.info(f\"  Continuing training from global step {self.state.global_step}\")\n            if not args.ignore_data_skip:\n                if skip_first_batches is None:\n                    logger.info(\n                        f\"  Will skip the first {epochs_trained} epochs then the first\"\n                        f\" {steps_trained_in_current_epoch} batches in the first epoch. If this takes a lot of time,\"\n                        \" you can install the latest version of Accelerate with `pip install -U accelerate`.You can\"\n                        \" also add the `--ignore_data_skip` flag to your launch command, but you will resume the\"\n                        \" training on data already seen by your model.\"\n                    )\n                else:\n                    logger.info(\n                        f\"  Will skip the first {epochs_trained} epochs then the first\"\n                        f\" {steps_trained_in_current_epoch} batches in the first epoch.\"\n                    )\n                if self.is_local_process_zero() and not args.disable_tqdm and skip_first_batches is None:\n                    steps_trained_progress_bar = tqdm(total=steps_trained_in_current_epoch)\n                    steps_trained_progress_bar.set_description(\"Skipping the first batches\")\n\n        # Update the references\n        self.callback_handler.model = self.model\n        self.callback_handler.optimizer = self.optimizer\n        self.callback_handler.lr_scheduler = self.lr_scheduler\n        self.callback_handler.train_dataloader = train_dataloader\n        if self.hp_name is not None and self._trial is not None:\n            # use self._trial because the SigOpt/Optuna hpo only call `_hp_search_setup(trial)` instead of passing trial\n            # parameter to Train when using DDP.\n            self.state.trial_name = self.hp_name(self._trial)\n        if trial is not None:\n            assignments = trial.assignments if self.hp_search_backend == HPSearchBackend.SIGOPT else trial\n            self.state.trial_params = hp_params(assignments)\n        else:\n            self.state.trial_params = None\n        # This should be the same if the state has been saved but in case the training arguments changed, it's safer\n        # to set this after the load.\n        self.state.max_steps = max_steps\n        self.state.num_train_epochs = num_train_epochs\n        self.state.is_local_process_zero = self.is_local_process_zero()\n        self.state.is_world_process_zero = self.is_world_process_zero()\n\n        # tr_loss is a tensor to avoid synchronization of TPUs through .item()\n        tr_loss = torch.tensor(0.0).to(args.device)\n        # _total_loss_scalar is updated everytime .item() has to be called on tr_loss and stores the sum of all losses\n        self._total_loss_scalar = 0.0\n        self._globalstep_last_logged = self.state.global_step\n        model.zero_grad()\n\n        self.control = self.callback_handler.on_train_begin(args, self.state, self.control)\n\n        # Skip the first epochs_trained epochs to get the random state of the dataloader at the right point.\n        if not args.ignore_data_skip:\n            for epoch in range(epochs_trained):\n                is_random_sampler = hasattr(train_dataloader, \"sampler\") and isinstance(\n                    train_dataloader.sampler, RandomSampler\n                )\n                if is_torch_less_than_1_11 or not is_random_sampler:\n                    # We just need to begin an iteration to create the randomization of the sampler.\n                    # That was before PyTorch 1.11 however...\n                    for _ in train_dataloader:\n                        break\n                else:\n                    # Otherwise we need to call the whooooole sampler cause there is some random operation added\n                    # AT THE VERY END!\n                    _ = list(train_dataloader.sampler)\n\n        total_batched_samples = 0\n        for epoch in range(epochs_trained, num_train_epochs):\n            if isinstance(train_dataloader, DataLoader) and isinstance(train_dataloader.sampler, DistributedSampler):\n                train_dataloader.sampler.set_epoch(epoch)\n            elif hasattr(train_dataloader, \"dataset\") and isinstance(train_dataloader.dataset, IterableDatasetShard):\n                train_dataloader.dataset.set_epoch(epoch)\n\n            if is_torch_tpu_available():\n                parallel_loader = pl.ParallelLoader(train_dataloader, [args.device]).per_device_loader(args.device)\n                epoch_iterator = parallel_loader\n            else:\n                epoch_iterator = train_dataloader\n\n            # Reset the past mems state at the beginning of each epoch if necessary.\n            if args.past_index >= 0:\n                self._past = None\n\n            steps_in_epoch = (\n                len(epoch_iterator)\n                if len_dataloader is not None\n                else args.max_steps * args.gradient_accumulation_steps\n            )\n            self.control = self.callback_handler.on_epoch_begin(args, self.state, self.control)\n\n            if epoch == epochs_trained and resume_from_checkpoint is not None and steps_trained_in_current_epoch == 0:\n                self._load_rng_state(resume_from_checkpoint)\n\n            rng_to_sync = False\n            steps_skipped = 0\n            if skip_first_batches is not None and steps_trained_in_current_epoch > 0:\n                epoch_iterator = skip_first_batches(epoch_iterator, steps_trained_in_current_epoch)\n                steps_skipped = steps_trained_in_current_epoch\n                steps_trained_in_current_epoch = 0\n                rng_to_sync = True\n\n            step = -1\n            for step, inputs in enumerate(epoch_iterator):\n                total_batched_samples += 1\n                if rng_to_sync:\n                    self._load_rng_state(resume_from_checkpoint)\n                    rng_to_sync = False\n\n                # Skip past any already trained steps if resuming training\n                if steps_trained_in_current_epoch > 0:\n                    steps_trained_in_current_epoch -= 1\n                    if steps_trained_progress_bar is not None:\n                        steps_trained_progress_bar.update(1)\n                    if steps_trained_in_current_epoch == 0:\n                        self._load_rng_state(resume_from_checkpoint)\n                    continue\n                elif steps_trained_progress_bar is not None:\n                    steps_trained_progress_bar.close()\n                    steps_trained_progress_bar = None\n\n                if step % args.gradient_accumulation_steps == 0:\n                    self.control = self.callback_handler.on_step_begin(args, self.state, self.control)\n\n                if (\n                    (total_batched_samples % args.gradient_accumulation_steps != 0)\n                    and args.local_rank != -1\n                    and args._no_sync_in_gradient_accumulation\n                ):\n                    # Avoid unnecessary DDP synchronization since there will be no backward pass on this example.\n                    with model.no_sync():\n                        tr_loss_step = self.training_step(model, inputs)\n                else:\n                    tr_loss_step = self.training_step(model, inputs)\n\n                if (\n                    args.logging_nan_inf_filter\n                    and not is_torch_tpu_available()\n                    and (torch.isnan(tr_loss_step) or torch.isinf(tr_loss_step))\n                ):\n                    # if loss is nan or inf simply add the average of previous logged losses\n                    tr_loss += tr_loss / (1 + self.state.global_step - self._globalstep_last_logged)\n                else:\n                    tr_loss += tr_loss_step\n\n                self.current_flos += float(self.floating_point_ops(inputs))\n\n                # Optimizer step for deepspeed must be called on every step regardless of the value of gradient_accumulation_steps\n                if self.deepspeed:\n                    self.deepspeed.step()\n\n                if total_batched_samples % args.gradient_accumulation_steps == 0 or (\n                    # last step in epoch but step is always smaller than gradient_accumulation_steps\n                    steps_in_epoch <= args.gradient_accumulation_steps\n                    and (step + 1) == steps_in_epoch\n                ):\n                    # Gradient clipping\n                    if args.max_grad_norm is not None and args.max_grad_norm > 0 and not self.deepspeed:\n                        # deepspeed does its own clipping\n\n                        if self.do_grad_scaling:\n                            # Reduce gradients first for XLA\n                            if is_torch_tpu_available():\n                                gradients = xm._fetch_gradients(self.optimizer)\n                                xm.all_reduce(\"sum\", gradients, scale=1.0 / xm.xrt_world_size())\n                            # AMP: gradients need unscaling\n                            self.scaler.unscale_(self.optimizer)\n\n                        if is_sagemaker_mp_enabled() and args.fp16:\n                            self.optimizer.clip_master_grads(args.max_grad_norm)\n                        elif hasattr(self.optimizer, \"clip_grad_norm\"):\n                            # Some optimizers (like the sharded optimizer) have a specific way to do gradient clipping\n                            self.optimizer.clip_grad_norm(args.max_grad_norm)\n                        elif hasattr(model, \"clip_grad_norm_\"):\n                            # Some models (like FullyShardedDDP) have a specific way to do gradient clipping\n                            model.clip_grad_norm_(args.max_grad_norm)\n                        else:\n                            # Revert to normal clipping otherwise, handling Apex or full precision\n                            nn.utils.clip_grad_norm_(\n                                amp.master_params(self.optimizer) if self.use_apex else model.parameters(),\n                                args.max_grad_norm,\n                            )\n\n                    # Optimizer step\n                    optimizer_was_run = True\n                    if self.deepspeed:\n                        pass  # called outside the loop\n                    elif is_torch_tpu_available():\n                        if self.do_grad_scaling:\n                            self.scaler.step(self.optimizer)\n                            self.scaler.update()\n                        else:\n                            xm.optimizer_step(self.optimizer)\n                    elif self.do_grad_scaling:\n                        scale_before = self.scaler.get_scale()\n                        self.scaler.step(self.optimizer)\n                        self.scaler.update()\n                        scale_after = self.scaler.get_scale()\n                        optimizer_was_run = scale_before <= scale_after\n                    else:\n                        self.optimizer.step()\n\n                    if optimizer_was_run and not self.deepspeed:\n                        self.lr_scheduler.step()\n\n                    model.zero_grad()\n                    self.state.global_step += 1\n                    self.state.epoch = epoch + (step + 1 + steps_skipped) / steps_in_epoch\n                    self.control = self.callback_handler.on_step_end(args, self.state, self.control)\n\n                    self._maybe_log_save_evaluate(tr_loss, model, trial, epoch, ignore_keys_for_eval)\n                else:\n                    self.control = self.callback_handler.on_substep_end(args, self.state, self.control)\n\n                if self.control.should_epoch_stop or self.control.should_training_stop:\n                    break\n            if step < 0:\n                logger.warning(\n                    \"There seems to be not a single sample in your epoch_iterator, stopping training at step\"\n                    f\" {self.state.global_step}! This is expected if you're using an IterableDataset and set\"\n                    f\" num_steps ({max_steps}) higher than the number of available samples.\"\n                )\n                self.control.should_training_stop = True\n\n            self.control = self.callback_handler.on_epoch_end(args, self.state, self.control)\n            self._maybe_log_save_evaluate(tr_loss, model, trial, epoch, ignore_keys_for_eval)\n\n            if DebugOption.TPU_METRICS_DEBUG in self.args.debug:\n                if is_torch_tpu_available():\n                    # tpu-comment: Logging debug metrics for PyTorch/XLA (compile, execute times, ops, etc.)\n                    xm.master_print(met.metrics_report())\n                else:\n                    logger.warning(\n                        \"You enabled PyTorch/XLA debug metrics but you don't have a TPU \"\n                        \"configured. Check your training configuration if this is unexpected.\"\n                    )\n            if self.control.should_training_stop:\n                break\n\n        if args.past_index and hasattr(self, \"_past\"):\n            # Clean the state at the end of training\n            delattr(self, \"_past\")\n\n        logger.info(\"\\n\\nTraining completed. Do not forget to share your model on huggingface.co/models =)\\n\\n\")\n        if args.load_best_model_at_end and self.state.best_model_checkpoint is not None:\n            # Wait for everyone to get here so we are sur the model has been saved by process 0.\n            if is_torch_tpu_available():\n                xm.rendezvous(\"load_best_model_at_end\")\n            elif args.local_rank != -1:\n                dist.barrier()\n            elif is_sagemaker_mp_enabled():\n                smp.barrier()\n\n            self._load_best_model()\n\n        # add remaining tr_loss\n        self._total_loss_scalar += tr_loss.item()\n        train_loss = self._total_loss_scalar / self.state.global_step\n\n        metrics = speed_metrics(\"train\", start_time, num_samples=num_train_samples, num_steps=self.state.max_steps)\n        self.store_flos()\n        metrics[\"total_flos\"] = self.state.total_flos\n        metrics[\"train_loss\"] = train_loss\n\n        self.is_in_train = False\n\n        self._memory_tracker.stop_and_update_metrics(metrics)\n\n        self.log(metrics)\n\n        run_dir = self._get_output_dir(trial)\n        checkpoints_sorted = self._sorted_checkpoints(use_mtime=False, output_dir=run_dir)\n\n        # Delete the last checkpoint when save_total_limit=1 if it's different from the best checkpoint and process allowed to save.\n        if self.args.should_save and self.state.best_model_checkpoint is not None and self.args.save_total_limit == 1:\n            for checkpoint in checkpoints_sorted:\n                if checkpoint != self.state.best_model_checkpoint:\n                    logger.info(f\"Deleting older checkpoint [{checkpoint}] due to args.save_total_limit\")\n                    shutil.rmtree(checkpoint)\n\n        self.control = self.callback_handler.on_train_end(args, self.state, self.control)\n\n        return TrainOutput(self.state.global_step, train_loss, metrics)\n\n    def _get_output_dir(self, trial):\n        if self.hp_search_backend is not None and trial is not None:\n            if self.hp_search_backend == HPSearchBackend.OPTUNA:\n                run_id = trial.number\n            elif self.hp_search_backend == HPSearchBackend.RAY:\n                from ray import tune\n\n                run_id = tune.get_trial_id()\n            elif self.hp_search_backend == HPSearchBackend.SIGOPT:\n                run_id = trial.id\n            elif self.hp_search_backend == HPSearchBackend.WANDB:\n                import wandb\n\n                run_id = wandb.run.id\n            run_name = self.hp_name(trial) if self.hp_name is not None else f\"run-{run_id}\"\n            run_dir = os.path.join(self.args.output_dir, run_name)\n        else:\n            run_dir = self.args.output_dir\n        return run_dir\n\n    def _load_from_checkpoint(self, resume_from_checkpoint, model=None):\n        if model is None:\n            model = self.model\n\n        if not os.path.isfile(os.path.join(resume_from_checkpoint, WEIGHTS_NAME)) and not os.path.isfile(\n            os.path.join(resume_from_checkpoint, WEIGHTS_INDEX_NAME)\n        ):\n            raise ValueError(f\"Can't find a valid checkpoint at {resume_from_checkpoint}\")\n\n        logger.info(f\"Loading model from {resume_from_checkpoint}.\")\n\n        if os.path.isfile(os.path.join(resume_from_checkpoint, CONFIG_NAME)):\n            config = PretrainedConfig.from_json_file(os.path.join(resume_from_checkpoint, CONFIG_NAME))\n            checkpoint_version = config.transformers_version\n            if checkpoint_version is not None and checkpoint_version != __version__:\n                logger.warning(\n                    f\"You are resuming training from a checkpoint trained with {checkpoint_version} of \"\n                    f\"Transformers but your current version is {__version__}. This is not recommended and could \"\n                    \"yield to errors or unwanted behaviors.\"\n                )\n\n        if os.path.isfile(os.path.join(resume_from_checkpoint, WEIGHTS_NAME)):\n            # If the model is on the GPU, it still works!\n            if is_sagemaker_mp_enabled():\n                if os.path.isfile(os.path.join(resume_from_checkpoint, \"user_content.pt\")):\n                    # If the 'user_content.pt' file exists, load with the new smp api.\n                    # Checkpoint must have been saved with the new smp api.\n                    smp.resume_from_checkpoint(\n                        path=resume_from_checkpoint, tag=WEIGHTS_NAME, partial=False, load_optimizer=False\n                    )\n                else:\n                    # If the 'user_content.pt' file does NOT exist, load with the old smp api.\n                    # Checkpoint must have been saved with the old smp api.\n                    if hasattr(self.args, \"fp16\") and self.args.fp16 is True:\n                        logger.warning(\n                            \"Enabling FP16 and loading from smp < 1.10 checkpoint together is not suppported.\"\n                        )\n                    state_dict = torch.load(os.path.join(resume_from_checkpoint, WEIGHTS_NAME), map_location=\"cpu\")\n                    # Required for smp to not auto-translate state_dict from hf to smp (is already smp).\n                    state_dict[\"_smp_is_partial\"] = False\n                    load_result = model.load_state_dict(state_dict, strict=True)\n                    # release memory\n                    del state_dict\n            else:\n                # We load the model state dict on the CPU to avoid an OOM error.\n                state_dict = torch.load(os.path.join(resume_from_checkpoint, WEIGHTS_NAME), map_location=\"cpu\")\n                # workaround for FSDP bug https://github.com/pytorch/pytorch/issues/82963\n                # which takes *args instead of **kwargs\n                load_result = model.load_state_dict(state_dict, False)\n                # release memory\n                del state_dict\n                self._issue_warnings_after_load(load_result)\n        else:\n            # We load the sharded checkpoint\n            load_result = load_sharded_checkpoint(model, resume_from_checkpoint, strict=is_sagemaker_mp_enabled())\n            if not is_sagemaker_mp_enabled():\n                self._issue_warnings_after_load(load_result)\n\n    def _load_best_model(self):\n        logger.info(f\"Loading best model from {self.state.best_model_checkpoint} (score: {self.state.best_metric}).\")\n        best_model_path = os.path.join(self.state.best_model_checkpoint, WEIGHTS_NAME)\n        model = self.model_wrapped if is_sagemaker_mp_enabled() else self.model\n        if os.path.exists(best_model_path):\n            if self.deepspeed:\n                if self.model_wrapped is not None:\n                    # this removes the pre-hooks from the previous engine\n                    self.model_wrapped.destroy()\n                    self.model_wrapped = None\n\n                # temp hack until Deepspeed fixes the problem with resume from an existing engine that did some stepping\n                deepspeed_engine, optimizer, lr_scheduler = deepspeed_init(\n                    self,\n                    num_training_steps=self.args.max_steps,\n                    resume_from_checkpoint=self.state.best_model_checkpoint,\n                )\n                self.model = deepspeed_engine.module\n                self.model_wrapped = deepspeed_engine\n                self.deepspeed = deepspeed_engine\n                self.optimizer = optimizer\n                self.lr_scheduler = lr_scheduler\n            else:\n                if is_sagemaker_mp_enabled():\n                    if os.path.isfile(os.path.join(self.state.best_model_checkpoint, \"user_content.pt\")):\n                        # If the 'user_content.pt' file exists, load with the new smp api.\n                        # Checkpoint must have been saved with the new smp api.\n                        smp.resume_from_checkpoint(\n                            path=self.state.best_model_checkpoint,\n                            tag=WEIGHTS_NAME,\n                            partial=False,\n                            load_optimizer=False,\n                        )\n                    else:\n                        # If the 'user_content.pt' file does NOT exist, load with the old smp api.\n                        # Checkpoint must have been saved with the old smp api.\n                        state_dict = torch.load(best_model_path, map_location=\"cpu\")\n                        state_dict[\"_smp_is_partial\"] = False\n                        # load_result = model.load_state_dict(state_dict, strict=True)\n                        set_peft_model_state_dict(model, state_dict) # For PEFT Lora\n                else:\n                    # We load the model state dict on the CPU to avoid an OOM error.\n                    state_dict = torch.load(best_model_path, map_location=\"cpu\")\n                    # If the model is on the GPU, it still works!\n                    # workaround for FSDP bug https://github.com/pytorch/pytorch/issues/82963\n                    # which takes *args instead of **kwargs\n                    # load_result = model.load_state_dict(state_dict, False)\n                    set_peft_model_state_dict(model, state_dict) # For PEFT Lora\n        elif os.path.exists(os.path.join(self.state.best_model_checkpoint, WEIGHTS_INDEX_NAME)):\n            # load_result = load_sharded_checkpoint(\n            #     model, self.state.best_model_checkpoint, strict=is_sagemaker_mp_enabled()\n            # )\n            # if not is_sagemaker_mp_enabled():\n            #     self._issue_warnings_after_load(load_result)\n            logger.error(\"load_sharded_checkpoint is unsupported for PEFT Lora\")\n        else:\n            logger.warning(\n                f\"Could not locate the best model at {best_model_path}, if you are running a distributed training \"\n                \"on multiple nodes, you should activate `--save_on_each_node`.\"\n            )\n\n    def _issue_warnings_after_load(self, load_result):\n        if len(load_result.missing_keys) != 0:\n            if self.model._keys_to_ignore_on_save is not None and set(load_result.missing_keys) == set(\n                self.model._keys_to_ignore_on_save\n            ):\n                self.model.tie_weights()\n            else:\n                logger.warning(f\"There were missing keys in the checkpoint model loaded: {load_result.missing_keys}.\")\n        if len(load_result.unexpected_keys) != 0:\n            logger.warning(\n                f\"There were unexpected keys in the checkpoint model loaded: {load_result.unexpected_keys}.\"\n            )\n\n    def _maybe_log_save_evaluate(self, tr_loss, model, trial, epoch, ignore_keys_for_eval):\n        if self.control.should_log:\n            if is_torch_tpu_available():\n                xm.mark_step()\n\n            logs: Dict[str, float] = {}\n\n            # all_gather + mean() to get average loss over all processes\n            tr_loss_scalar = self._nested_gather(tr_loss).mean().item()\n\n            # reset tr_loss to zero\n            tr_loss -= tr_loss\n\n            logs[\"loss\"] = round(tr_loss_scalar / (self.state.global_step - self._globalstep_last_logged), 4)\n            logs[\"learning_rate\"] = self._get_learning_rate()\n\n            self._total_loss_scalar += tr_loss_scalar\n            self._globalstep_last_logged = self.state.global_step\n            self.store_flos()\n\n            self.log(logs)\n\n        metrics = None\n        if self.control.should_evaluate:\n            if isinstance(self.eval_dataset, dict):\n                for eval_dataset_name, eval_dataset in self.eval_dataset.items():\n                    metrics = self.evaluate(\n                        eval_dataset=eval_dataset,\n                        ignore_keys=ignore_keys_for_eval,\n                        metric_key_prefix=f\"eval_{eval_dataset_name}\",\n                    )\n            else:\n                metrics = self.evaluate(ignore_keys=ignore_keys_for_eval)\n            self._report_to_hp_search(trial, self.state.global_step, metrics)\n\n        if self.control.should_save:\n            self._save_checkpoint(model, trial, metrics=metrics)\n            self.control = self.callback_handler.on_save(self.args, self.state, self.control)\n\n    def _load_rng_state(self, checkpoint):\n        # Load RNG states from `checkpoint`\n        if checkpoint is None:\n            return\n\n        if self.args.world_size > 1:\n            process_index = self.args.process_index\n            rng_file = os.path.join(checkpoint, f\"rng_state_{process_index}.pth\")\n            if not os.path.isfile(rng_file):\n                logger.info(\n                    f\"Didn't find an RNG file for process {process_index}, if you are resuming a training that \"\n                    \"wasn't launched in a distributed fashion, reproducibility is not guaranteed.\"\n                )\n                return\n        else:\n            rng_file = os.path.join(checkpoint, \"rng_state.pth\")\n            if not os.path.isfile(rng_file):\n                logger.info(\n                    \"Didn't find an RNG file, if you are resuming a training that was launched in a distributed \"\n                    \"fashion, reproducibility is not guaranteed.\"\n                )\n                return\n\n        checkpoint_rng_state = torch.load(rng_file)\n        random.setstate(checkpoint_rng_state[\"python\"])\n        np.random.set_state(checkpoint_rng_state[\"numpy\"])\n        torch.random.set_rng_state(checkpoint_rng_state[\"cpu\"])\n        if torch.cuda.is_available():\n            if self.args.local_rank != -1:\n                torch.cuda.random.set_rng_state(checkpoint_rng_state[\"cuda\"])\n            else:\n                try:\n                    torch.cuda.random.set_rng_state_all(checkpoint_rng_state[\"cuda\"])\n                except Exception as e:\n                    logger.info(\n                        f\"Didn't manage to set back the RNG states of the GPU because of the following error:\\n {e}\"\n                        \"\\nThis won't yield the same results as if the training had not been interrupted.\"\n                    )\n        if is_torch_tpu_available():\n            xm.set_rng_state(checkpoint_rng_state[\"xla\"])\n\n    def _save_checkpoint(self, model, trial, metrics=None):\n        # In all cases, including ddp/dp/deepspeed, self.model is always a reference to the model we\n        # want to save except FullyShardedDDP.\n        # assert unwrap_model(model) is self.model, \"internal model should be a reference to self.model\"\n\n        # Save model checkpoint\n        checkpoint_folder = f\"{PREFIX_CHECKPOINT_DIR}-{self.state.global_step}\"\n\n        if self.hp_search_backend is None and trial is None:\n            self.store_flos()\n\n        run_dir = self._get_output_dir(trial=trial)\n        output_dir = os.path.join(run_dir, checkpoint_folder)\n        self.save_model(output_dir, _internal_call=True)\n        if self.deepspeed:\n            # under zero3 model file itself doesn't get saved since it's bogus! Unless deepspeed\n            # config `stage3_gather_16bit_weights_on_model_save` is True\n            self.deepspeed.save_checkpoint(output_dir)\n\n        # Save optimizer and scheduler\n        if self.sharded_ddp == ShardedDDPOption.SIMPLE:\n            self.optimizer.consolidate_state_dict()\n\n        if is_torch_tpu_available():\n            xm.rendezvous(\"saving_optimizer_states\")\n            xm.save(self.optimizer.state_dict(), os.path.join(output_dir, OPTIMIZER_NAME))\n            with warnings.catch_warnings(record=True) as caught_warnings:\n                xm.save(self.lr_scheduler.state_dict(), os.path.join(output_dir, SCHEDULER_NAME))\n                reissue_pt_warnings(caught_warnings)\n        elif is_sagemaker_mp_enabled():\n            opt_state_dict = self.optimizer.local_state_dict(gather_if_shard=False)\n            smp.barrier()\n            if smp.rdp_rank() == 0 or smp.state.cfg.shard_optimizer_state:\n                smp.save(\n                    opt_state_dict,\n                    os.path.join(output_dir, OPTIMIZER_NAME),\n                    partial=True,\n                    v3=smp.state.cfg.shard_optimizer_state,\n                )\n            if self.args.should_save:\n                with warnings.catch_warnings(record=True) as caught_warnings:\n                    torch.save(self.lr_scheduler.state_dict(), os.path.join(output_dir, SCHEDULER_NAME))\n                reissue_pt_warnings(caught_warnings)\n                if self.do_grad_scaling:\n                    torch.save(self.scaler.state_dict(), os.path.join(output_dir, SCALER_NAME))\n        elif self.args.should_save and not self.deepspeed:\n            # deepspeed.save_checkpoint above saves model/optim/sched\n            torch.save(self.optimizer.state_dict(), os.path.join(output_dir, OPTIMIZER_NAME))\n            with warnings.catch_warnings(record=True) as caught_warnings:\n                torch.save(self.lr_scheduler.state_dict(), os.path.join(output_dir, SCHEDULER_NAME))\n            reissue_pt_warnings(caught_warnings)\n            if self.do_grad_scaling:\n                torch.save(self.scaler.state_dict(), os.path.join(output_dir, SCALER_NAME))\n\n        # Determine the new best metric / best model checkpoint\n        if metrics is not None and self.args.metric_for_best_model is not None:\n            metric_to_check = self.args.metric_for_best_model\n            if not metric_to_check.startswith(\"eval_\"):\n                metric_to_check = f\"eval_{metric_to_check}\"\n            metric_value = metrics[metric_to_check]\n\n            operator = np.greater if self.args.greater_is_better else np.less\n            if (\n                self.state.best_metric is None\n                or self.state.best_model_checkpoint is None\n                or operator(metric_value, self.state.best_metric)\n            ):\n                self.state.best_metric = metric_value\n                self.state.best_model_checkpoint = output_dir\n\n        # Save the Trainer state\n        if self.args.should_save:\n            self.state.save_to_json(os.path.join(output_dir, TRAINER_STATE_NAME))\n\n        # Save RNG state in non-distributed training\n        rng_states = {\n            \"python\": random.getstate(),\n            \"numpy\": np.random.get_state(),\n            \"cpu\": torch.random.get_rng_state(),\n        }\n        if torch.cuda.is_available():\n            if self.args.local_rank == -1:\n                # In non distributed, we save the global CUDA RNG state (will take care of DataParallel)\n                rng_states[\"cuda\"] = torch.cuda.random.get_rng_state_all()\n            else:\n                rng_states[\"cuda\"] = torch.cuda.random.get_rng_state()\n\n        if is_torch_tpu_available():\n            rng_states[\"xla\"] = xm.get_rng_state()\n\n        # A process can arrive here before the process 0 has a chance to save the model, in which case output_dir may\n        # not yet exist.\n        os.makedirs(output_dir, exist_ok=True)\n\n        if self.args.world_size <= 1:\n            torch.save(rng_states, os.path.join(output_dir, \"rng_state.pth\"))\n        else:\n            torch.save(rng_states, os.path.join(output_dir, f\"rng_state_{self.args.process_index}.pth\"))\n\n        if self.args.push_to_hub:\n            self._push_from_checkpoint(output_dir)\n\n        # Maybe delete some older checkpoints.\n        if self.args.should_save:\n            self._rotate_checkpoints(use_mtime=True, output_dir=run_dir)\n\n    def _load_optimizer_and_scheduler(self, checkpoint):\n        \"\"\"If optimizer and scheduler states exist, load them.\"\"\"\n        if checkpoint is None:\n            return\n\n        if self.deepspeed:\n            # deepspeed loads optimizer/lr_scheduler together with the model in deepspeed_init\n            return\n\n        checkpoint_file_exists = (\n            glob.glob(os.path.join(checkpoint, OPTIMIZER_NAME) + \"_*\")\n            if is_sagemaker_mp_enabled()\n            else os.path.isfile(os.path.join(checkpoint, OPTIMIZER_NAME))\n        )\n        if checkpoint_file_exists and os.path.isfile(os.path.join(checkpoint, SCHEDULER_NAME)):\n            # Load in optimizer and scheduler states\n            if is_torch_tpu_available():\n                # On TPU we have to take some extra precautions to properly load the states on the right device.\n                optimizer_state = torch.load(os.path.join(checkpoint, OPTIMIZER_NAME), map_location=\"cpu\")\n                with warnings.catch_warnings(record=True) as caught_warnings:\n                    lr_scheduler_state = torch.load(os.path.join(checkpoint, SCHEDULER_NAME), map_location=\"cpu\")\n                reissue_pt_warnings(caught_warnings)\n\n                xm.send_cpu_data_to_device(optimizer_state, self.args.device)\n                xm.send_cpu_data_to_device(lr_scheduler_state, self.args.device)\n\n                self.optimizer.load_state_dict(optimizer_state)\n                self.lr_scheduler.load_state_dict(lr_scheduler_state)\n            else:\n                map_location = \"cpu\" if is_sagemaker_mp_enabled() else self.args.device\n                if is_sagemaker_mp_enabled():\n                    if os.path.isfile(os.path.join(checkpoint, \"user_content.pt\")):\n                        # Optimizer checkpoint was saved with smp >= 1.10\n                        def opt_load_hook(mod, opt):\n                            opt.load_state_dict(smp.load(os.path.join(checkpoint, OPTIMIZER_NAME), partial=True))\n\n                    else:\n                        # Optimizer checkpoint was saved with smp < 1.10\n                        def opt_load_hook(mod, opt):\n                            if IS_SAGEMAKER_MP_POST_1_10:\n                                opt.load_state_dict(\n                                    smp.load(os.path.join(checkpoint, OPTIMIZER_NAME), partial=True, back_compat=True)\n                                )\n                            else:\n                                opt.load_state_dict(smp.load(os.path.join(checkpoint, OPTIMIZER_NAME), partial=True))\n\n                    self.model_wrapped.register_post_step_hook(opt_load_hook)\n                else:\n                    self.optimizer.load_state_dict(\n                        torch.load(os.path.join(checkpoint, OPTIMIZER_NAME), map_location=map_location)\n                    )\n                with warnings.catch_warnings(record=True) as caught_warnings:\n                    self.lr_scheduler.load_state_dict(torch.load(os.path.join(checkpoint, SCHEDULER_NAME)))\n                reissue_pt_warnings(caught_warnings)\n                if self.do_grad_scaling and os.path.isfile(os.path.join(checkpoint, SCALER_NAME)):\n                    self.scaler.load_state_dict(torch.load(os.path.join(checkpoint, SCALER_NAME)))\n\n    def hyperparameter_search(\n        self,\n        hp_space: Optional[Callable[[\"optuna.Trial\"], Dict[str, float]]] = None,\n        compute_objective: Optional[Callable[[Dict[str, float]], float]] = None,\n        n_trials: int = 20,\n        direction: str = \"minimize\",\n        backend: Optional[Union[\"str\", HPSearchBackend]] = None,\n        hp_name: Optional[Callable[[\"optuna.Trial\"], str]] = None,\n        **kwargs,\n    ) -> BestRun:\n        \"\"\"\n        Launch an hyperparameter search using `optuna` or `Ray Tune` or `SigOpt`. The optimized quantity is determined\n        by `compute_objective`, which defaults to a function returning the evaluation loss when no metric is provided,\n        the sum of all metrics otherwise.\n\n        <Tip warning={true}>\n\n        To use this method, you need to have provided a `model_init` when initializing your [`Trainer`]: we need to\n        reinitialize the model at each new run. This is incompatible with the `optimizers` argument, so you need to\n        subclass [`Trainer`] and override the method [`~Trainer.create_optimizer_and_scheduler`] for custom\n        optimizer/scheduler.\n\n        </Tip>\n\n        Args:\n            hp_space (`Callable[[\"optuna.Trial\"], Dict[str, float]]`, *optional*):\n                A function that defines the hyperparameter search space. Will default to\n                [`~trainer_utils.default_hp_space_optuna`] or [`~trainer_utils.default_hp_space_ray`] or\n                [`~trainer_utils.default_hp_space_sigopt`] depending on your backend.\n            compute_objective (`Callable[[Dict[str, float]], float]`, *optional*):\n                A function computing the objective to minimize or maximize from the metrics returned by the `evaluate`\n                method. Will default to [`~trainer_utils.default_compute_objective`].\n            n_trials (`int`, *optional*, defaults to 100):\n                The number of trial runs to test.\n            direction (`str`, *optional*, defaults to `\"minimize\"`):\n                Whether to optimize greater or lower objects. Can be `\"minimize\"` or `\"maximize\"`, you should pick\n                `\"minimize\"` when optimizing the validation loss, `\"maximize\"` when optimizing one or several metrics.\n            backend (`str` or [`~training_utils.HPSearchBackend`], *optional*):\n                The backend to use for hyperparameter search. Will default to optuna or Ray Tune or SigOpt, depending\n                on which one is installed. If all are installed, will default to optuna.\n            hp_name (`Callable[[\"optuna.Trial\"], str]]`, *optional*):\n                A function that defines the trial/run name. Will default to None.\n            kwargs (`Dict[str, Any]`, *optional*):\n                Additional keyword arguments passed along to `optuna.create_study` or `ray.tune.run`. For more\n                information see:\n\n                - the documentation of\n                  [optuna.create_study](https://optuna.readthedocs.io/en/stable/reference/generated/optuna.study.create_study.html)\n                - the documentation of [tune.run](https://docs.ray.io/en/latest/tune/api_docs/execution.html#tune-run)\n                - the documentation of [sigopt](https://app.sigopt.com/docs/endpoints/experiments/create)\n\n        Returns:\n            [`trainer_utils.BestRun`]: All the information about the best run. Experiment summary can be found in\n            `run_summary` attribute for Ray backend.\n        \"\"\"\n        if backend is None:\n            backend = default_hp_search_backend()\n            if backend is None:\n                raise RuntimeError(\n                    \"At least one of optuna or ray should be installed. \"\n                    \"To install optuna run `pip install optuna`. \"\n                    \"To install ray run `pip install ray[tune]`. \"\n                    \"To install sigopt run `pip install sigopt`.\"\n                )\n        backend = HPSearchBackend(backend)\n        if backend == HPSearchBackend.OPTUNA and not is_optuna_available():\n            raise RuntimeError(\"You picked the optuna backend, but it is not installed. Use `pip install optuna`.\")\n        if backend == HPSearchBackend.RAY and not is_ray_tune_available():\n            raise RuntimeError(\n                \"You picked the Ray Tune backend, but it is not installed. Use `pip install 'ray[tune]'`.\"\n            )\n        if backend == HPSearchBackend.SIGOPT and not is_sigopt_available():\n            raise RuntimeError(\"You picked the sigopt backend, but it is not installed. Use `pip install sigopt`.\")\n        if backend == HPSearchBackend.WANDB and not is_wandb_available():\n            raise RuntimeError(\"You picked the wandb backend, but it is not installed. Use `pip install wandb`.\")\n        self.hp_search_backend = backend\n        if self.model_init is None:\n            raise RuntimeError(\n                \"To use hyperparameter search, you need to pass your model through a model_init function.\"\n            )\n\n        self.hp_space = default_hp_space[backend] if hp_space is None else hp_space\n        self.hp_name = hp_name\n        self.compute_objective = default_compute_objective if compute_objective is None else compute_objective\n\n        backend_dict = {\n            HPSearchBackend.OPTUNA: run_hp_search_optuna,\n            HPSearchBackend.RAY: run_hp_search_ray,\n            HPSearchBackend.SIGOPT: run_hp_search_sigopt,\n            HPSearchBackend.WANDB: run_hp_search_wandb,\n        }\n        best_run = backend_dict[backend](self, n_trials, direction, **kwargs)\n\n        self.hp_search_backend = None\n        return best_run\n\n    def log(self, logs: Dict[str, float]) -> None:\n        \"\"\"\n        Log `logs` on the various objects watching training.\n\n        Subclass and override this method to inject custom behavior.\n\n        Args:\n            logs (`Dict[str, float]`):\n                The values to log.\n        \"\"\"\n        if self.state.epoch is not None:\n            logs[\"epoch\"] = round(self.state.epoch, 2)\n\n        output = {**logs, **{\"step\": self.state.global_step}}\n        self.state.log_history.append(output)\n        self.control = self.callback_handler.on_log(self.args, self.state, self.control, logs)\n\n    def _prepare_input(self, data: Union[torch.Tensor, Any]) -> Union[torch.Tensor, Any]:\n        \"\"\"\n        Prepares one `data` before feeding it to the model, be it a tensor or a nested list/dictionary of tensors.\n        \"\"\"\n        if isinstance(data, Mapping):\n            return type(data)({k: self._prepare_input(v) for k, v in data.items()})\n        elif isinstance(data, (tuple, list)):\n            return type(data)(self._prepare_input(v) for v in data)\n        elif isinstance(data, torch.Tensor):\n            kwargs = {\"device\": self.args.device}\n            if self.deepspeed and (torch.is_floating_point(data) or torch.is_complex(data)):\n                # NLP models inputs are int/uint and those get adjusted to the right dtype of the\n                # embedding. Other models such as wav2vec2's inputs are already float and thus\n                # may need special handling to match the dtypes of the model\n                kwargs.update({\"dtype\": self.args.hf_deepspeed_config.dtype()})\n            return data.to(**kwargs)\n        return data\n\n    def _prepare_inputs(self, inputs: Dict[str, Union[torch.Tensor, Any]]) -> Dict[str, Union[torch.Tensor, Any]]:\n        \"\"\"\n        Prepare `inputs` before feeding them to the model, converting them to tensors if they are not already and\n        handling potential state.\n        \"\"\"\n        inputs = self._prepare_input(inputs)\n        if len(inputs) == 0:\n            raise ValueError(\n                \"The batch received was empty, your model won't be able to train on it. Double-check that your \"\n                f\"training dataset contains keys expected by the model: {','.join(self._signature_columns)}.\"\n            )\n        if self.args.past_index >= 0 and self._past is not None:\n            inputs[\"mems\"] = self._past\n\n        return inputs\n\n    def compute_loss_context_manager(self):\n        \"\"\"\n        A helper wrapper to group together context managers.\n        \"\"\"\n        return self.autocast_smart_context_manager()\n\n    def autocast_smart_context_manager(self, cache_enabled: Optional[bool] = True):\n        \"\"\"\n        A helper wrapper that creates an appropriate context manager for `autocast` while feeding it the desired\n        arguments, depending on the situation.\n        \"\"\"\n        if self.use_cuda_amp or self.use_cpu_amp:\n            if is_torch_greater_or_equal_than_1_10:\n                ctx_manager = (\n                    torch.cpu.amp.autocast(cache_enabled=cache_enabled, dtype=self.amp_dtype)\n                    if self.use_cpu_amp\n                    else torch.cuda.amp.autocast(cache_enabled=cache_enabled, dtype=self.amp_dtype)\n                )\n            else:\n                ctx_manager = torch.cuda.amp.autocast()\n        else:\n            ctx_manager = contextlib.nullcontext() if sys.version_info >= (3, 7) else contextlib.suppress()\n\n        return ctx_manager\n\n    def training_step(self, model: nn.Module, inputs: Dict[str, Union[torch.Tensor, Any]]) -> torch.Tensor:\n        \"\"\"\n        Perform a training step on a batch of inputs.\n\n        Subclass and override to inject custom behavior.\n\n        Args:\n            model (`nn.Module`):\n                The model to train.\n            inputs (`Dict[str, Union[torch.Tensor, Any]]`):\n                The inputs and targets of the model.\n\n                The dictionary will be unpacked before being fed to the model. Most models expect the targets under the\n                argument `labels`. Check your model's documentation for all accepted arguments.\n\n        Return:\n            `torch.Tensor`: The tensor with training loss on this batch.\n        \"\"\"\n        model.train()\n        inputs = self._prepare_inputs(inputs)\n\n        if is_sagemaker_mp_enabled():\n            loss_mb = smp_forward_backward(model, inputs, self.args.gradient_accumulation_steps)\n            return loss_mb.reduce_mean().detach().to(self.args.device)\n\n        with self.compute_loss_context_manager():\n            loss = self.compute_loss(model, inputs)\n\n        if self.args.n_gpu > 1:\n            loss = loss.mean()  # mean() to average on multi-gpu parallel training\n\n        if self.args.gradient_accumulation_steps > 1 and not self.deepspeed:\n            # deepspeed handles loss scaling by gradient_accumulation_steps in its `backward`\n            loss = loss / self.args.gradient_accumulation_steps\n\n        if self.do_grad_scaling:\n            self.scaler.scale(loss).backward()\n        elif self.use_apex:\n            with amp.scale_loss(loss, self.optimizer) as scaled_loss:\n                scaled_loss.backward()\n        elif self.deepspeed:\n            # loss gets scaled under gradient_accumulation_steps in deepspeed\n            loss = self.deepspeed.backward(loss)\n        else:\n            loss.backward()\n\n        return loss.detach()\n\n    def compute_loss(self, model, inputs, return_outputs=False):\n        \"\"\"\n        How the loss is computed by Trainer. By default, all models return the loss in the first element.\n\n        Subclass and override for custom behavior.\n        \"\"\"\n        if self.label_smoother is not None and \"labels\" in inputs:\n            labels = inputs.pop(\"labels\")\n        else:\n            labels = None\n        outputs = model(**inputs)\n        # Save past state if it exists\n        # TODO: this needs to be fixed and made cleaner later.\n        if self.args.past_index >= 0:\n            self._past = outputs[self.args.past_index]\n\n        if labels is not None:\n            if unwrap_model(model)._get_name() in MODEL_FOR_CAUSAL_LM_MAPPING_NAMES.values():\n                loss = self.label_smoother(outputs, labels, shift_labels=True)\n            else:\n                loss = self.label_smoother(outputs, labels)\n        else:\n            if isinstance(outputs, dict) and \"loss\" not in outputs:\n                raise ValueError(\n                    \"The model did not return a loss from the inputs, only the following keys: \"\n                    f\"{','.join(outputs.keys())}. For reference, the inputs it received are {','.join(inputs.keys())}.\"\n                )\n            # We don't use .loss here since the model may return tuples instead of ModelOutput.\n            loss = outputs[\"loss\"] if isinstance(outputs, dict) else outputs[0]\n\n        return (loss, outputs) if return_outputs else loss\n\n    def is_local_process_zero(self) -> bool:\n        \"\"\"\n        Whether or not this process is the local (e.g., on one machine if training in a distributed fashion on several\n        machines) main process.\n        \"\"\"\n        return self.args.local_process_index == 0\n\n    def is_world_process_zero(self) -> bool:\n        \"\"\"\n        Whether or not this process is the global main process (when training in a distributed fashion on several\n        machines, this is only going to be `True` for one process).\n        \"\"\"\n        # Special case for SageMaker ModelParallel since there process_index is dp_process_index, not the global\n        # process index.\n        if is_sagemaker_mp_enabled():\n            return smp.rank() == 0\n        else:\n            return self.args.process_index == 0\n\n    def save_model(self, output_dir: Optional[str] = None, _internal_call: bool = False):\n        \"\"\"\n        Will save the model, so you can reload it using `from_pretrained()`.\n\n        Will only save from the main process.\n        \"\"\"\n\n        if output_dir is None:\n            output_dir = self.args.output_dir\n\n        if is_torch_tpu_available():\n            self._save_tpu(output_dir)\n        elif is_sagemaker_mp_enabled():\n            # Calling the state_dict needs to be done on the wrapped model and on all processes.\n            os.makedirs(output_dir, exist_ok=True)\n            state_dict = self.model_wrapped.state_dict()\n            if self.args.should_save:\n                self._save(output_dir, state_dict=state_dict)\n            if IS_SAGEMAKER_MP_POST_1_10:\n                # 'user_content.pt' indicates model state_dict saved with smp >= 1.10\n                Path(os.path.join(output_dir, \"user_content.pt\")).touch()\n        elif (\n            ShardedDDPOption.ZERO_DP_2 in self.args.sharded_ddp\n            or ShardedDDPOption.ZERO_DP_3 in self.args.sharded_ddp\n            or self.fsdp is not None\n        ):\n            state_dict = self.model.state_dict()\n\n            if self.args.should_save:\n                self._save(output_dir, state_dict=state_dict)\n        elif self.deepspeed:\n            # this takes care of everything as long as we aren't under zero3\n            if self.args.should_save:\n                self._save(output_dir)\n\n            if is_deepspeed_zero3_enabled():\n                # It's too complicated to try to override different places where the weights dump gets\n                # saved, so since under zero3 the file is bogus, simply delete it. The user should\n                # either user deepspeed checkpoint to resume or to recover full weights use\n                # zero_to_fp32.py stored in the checkpoint.\n                if self.args.should_save:\n                    file = os.path.join(output_dir, WEIGHTS_NAME)\n                    if os.path.isfile(file):\n                        # logger.info(f\"deepspeed zero3: removing {file}, see zero_to_fp32.py to recover weights\")\n                        os.remove(file)\n\n                # now save the real model if stage3_gather_16bit_weights_on_model_save=True\n                # if false it will not be saved.\n                # This must be called on all ranks\n                if not self.deepspeed.save_16bit_model(output_dir, WEIGHTS_NAME):\n                    logger.warning(\n                        \"deepspeed.save_16bit_model didn't save the model, since\"\n                        \" stage3_gather_16bit_weights_on_model_save=false. Saving the full checkpoint instead, use\"\n                        \" zero_to_fp32.py to recover weights\"\n                    )\n                    self.deepspeed.save_checkpoint(output_dir)\n\n        elif self.args.should_save:\n            self._save(output_dir)\n\n        # Push to the Hub when `save_model` is called by the user.\n        if self.args.push_to_hub and not _internal_call:\n            self.push_to_hub(commit_message=\"Model save\")\n\n    def _save_tpu(self, output_dir: Optional[str] = None):\n        output_dir = output_dir if output_dir is not None else self.args.output_dir\n        logger.info(f\"Saving model checkpoint to {output_dir}\")\n\n        if xm.is_master_ordinal():\n            os.makedirs(output_dir, exist_ok=True)\n            torch.save(self.args, os.path.join(output_dir, TRAINING_ARGS_NAME))\n\n        # Save a trained model and configuration using `save_pretrained()`.\n        # They can then be reloaded using `from_pretrained()`\n        xm.rendezvous(\"saving_checkpoint\")\n        if not isinstance(self.model, PreTrainedModel):\n            if isinstance(unwrap_model(self.model), PreTrainedModel):\n                unwrap_model(self.model).save_pretrained(\n                    output_dir,\n                    is_main_process=self.args.should_save,\n                    state_dict=self.model.state_dict(),\n                    save_function=xm.save,\n                )\n            else:\n                logger.info(\"Trainer.model is not a `PreTrainedModel`, only saving its state dict.\")\n                state_dict = self.model.state_dict()\n                xm.save(state_dict, os.path.join(output_dir, WEIGHTS_NAME))\n        else:\n            self.model.save_pretrained(output_dir, is_main_process=self.args.should_save, save_function=xm.save)\n        if self.tokenizer is not None and self.args.should_save:\n            self.tokenizer.save_pretrained(output_dir)\n\n    def _save(self, output_dir: Optional[str] = None, state_dict=None):\n        # If we are executing this function, we are the process zero, so we don't check for that.\n        output_dir = output_dir if output_dir is not None else self.args.output_dir\n        os.makedirs(output_dir, exist_ok=True)\n        logger.info(f\"Saving model checkpoint to {output_dir}\")\n        # Save a trained model and configuration using `save_pretrained()`.\n        # They can then be reloaded using `from_pretrained()`\n\n        self.model.save_pretrained(output_dir)\n\n        # if not isinstance(self.model, PreTrainedModel):\n        #     if isinstance(unwrap_model(self.model), PreTrainedModel):\n        #         if state_dict is None:\n        #             state_dict = self.model.state_dict()\n        #         unwrap_model(self.model).save_pretrained(output_dir, state_dict=filtered_state_dict)\n        #     else:\n        #         logger.info(\"Trainer.model is not a `PreTrainedModel`, only saving its state dict.\")\n        #         if state_dict is None:\n        #             state_dict = self.model.state_dict()\n        #         torch.save(state_dict, os.path.join(output_dir, WEIGHTS_NAME))\n        # else:\n        #     if self.save_prefixencoder:\n        #         print(\"Saving PrefixEncoder\")\n        #         state_dict = self.model.state_dict()\n        #         filtered_state_dict = {}\n        #         for k, v in self.model.named_parameters():\n        #             if v.requires_grad:\n        #                 filtered_state_dict[k] = state_dict[k]\n        #         self.model.save_pretrained(output_dir, state_dict=filtered_state_dict)\n        #     else:\n        #         print(\"Saving the whole model\")\n        #         self.model.save_pretrained(output_dir, state_dict=state_dict)\n\n        if self.tokenizer is not None:\n            self.tokenizer.save_pretrained(output_dir)\n\n        # Good practice: save your training arguments together with the trained model\n        torch.save(self.args, os.path.join(output_dir, TRAINING_ARGS_NAME))\n\n    def store_flos(self):\n        # Storing the number of floating-point operations that went into the model\n        if self.args.local_rank != -1:\n            self.state.total_flos += (\n                distributed_broadcast_scalars([self.current_flos], device=self.args.device).sum().item()\n            )\n            self.current_flos = 0\n        else:\n            self.state.total_flos += self.current_flos\n            self.current_flos = 0\n\n    def _sorted_checkpoints(\n        self, output_dir=None, checkpoint_prefix=PREFIX_CHECKPOINT_DIR, use_mtime=False\n    ) -> List[str]:\n        ordering_and_checkpoint_path = []\n\n        glob_checkpoints = [str(x) for x in Path(output_dir).glob(f\"{checkpoint_prefix}-*\") if os.path.isdir(x)]\n\n        for path in glob_checkpoints:\n            if use_mtime:\n                ordering_and_checkpoint_path.append((os.path.getmtime(path), path))\n            else:\n                regex_match = re.match(f\".*{checkpoint_prefix}-([0-9]+)\", path)\n                if regex_match is not None and regex_match.groups() is not None:\n                    ordering_and_checkpoint_path.append((int(regex_match.groups()[0]), path))\n\n        checkpoints_sorted = sorted(ordering_and_checkpoint_path)\n        checkpoints_sorted = [checkpoint[1] for checkpoint in checkpoints_sorted]\n        # Make sure we don't delete the best model.\n        if self.state.best_model_checkpoint is not None:\n            best_model_index = checkpoints_sorted.index(str(Path(self.state.best_model_checkpoint)))\n            for i in range(best_model_index, len(checkpoints_sorted) - 2):\n                checkpoints_sorted[i], checkpoints_sorted[i + 1] = checkpoints_sorted[i + 1], checkpoints_sorted[i]\n        return checkpoints_sorted\n\n    def _rotate_checkpoints(self, use_mtime=False, output_dir=None) -> None:\n        if self.args.save_total_limit is None or self.args.save_total_limit <= 0:\n            return\n\n        # Check if we should delete older checkpoint(s)\n        checkpoints_sorted = self._sorted_checkpoints(use_mtime=use_mtime, output_dir=output_dir)\n        if len(checkpoints_sorted) <= self.args.save_total_limit:\n            return\n\n        # If save_total_limit=1 with load_best_model_at_end=True, we could end up deleting the last checkpoint, which\n        # we don't do to allow resuming.\n        save_total_limit = self.args.save_total_limit\n        if (\n            self.state.best_model_checkpoint is not None\n            and self.args.save_total_limit == 1\n            and checkpoints_sorted[-1] != self.state.best_model_checkpoint\n        ):\n            save_total_limit = 2\n\n        number_of_checkpoints_to_delete = max(0, len(checkpoints_sorted) - save_total_limit)\n        checkpoints_to_be_deleted = checkpoints_sorted[:number_of_checkpoints_to_delete]\n        for checkpoint in checkpoints_to_be_deleted:\n            logger.info(f\"Deleting older checkpoint [{checkpoint}] due to args.save_total_limit\")\n            shutil.rmtree(checkpoint, ignore_errors=True)\n\n    def evaluate(\n        self,\n        eval_dataset: Optional[Dataset] = None,\n        ignore_keys: Optional[List[str]] = None,\n        metric_key_prefix: str = \"eval\",\n    ) -> Dict[str, float]:\n        \"\"\"\n        Run evaluation and returns metrics.\n\n        The calling script will be responsible for providing a method to compute metrics, as they are task-dependent\n        (pass it to the init `compute_metrics` argument).\n\n        You can also subclass and override this method to inject custom behavior.\n\n        Args:\n            eval_dataset (`Dataset`, *optional*):\n                Pass a dataset if you wish to override `self.eval_dataset`. If it is a [`~datasets.Dataset`], columns\n                not accepted by the `model.forward()` method are automatically removed. It must implement the `__len__`\n                method.\n            ignore_keys (`Lst[str]`, *optional*):\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions.\n            metric_key_prefix (`str`, *optional*, defaults to `\"eval\"`):\n                An optional prefix to be used as the metrics key prefix. For example the metrics \"bleu\" will be named\n                \"eval_bleu\" if the prefix is \"eval\" (default)\n\n        Returns:\n            A dictionary containing the evaluation loss and the potential metrics computed from the predictions. The\n            dictionary also contains the epoch number which comes from the training state.\n        \"\"\"\n        # memory metrics - must set up as early as possible\n        self._memory_tracker.start()\n\n        eval_dataloader = self.get_eval_dataloader(eval_dataset)\n        start_time = time.time()\n\n        eval_loop = self.prediction_loop if self.args.use_legacy_prediction_loop else self.evaluation_loop\n        output = eval_loop(\n            eval_dataloader,\n            description=\"Evaluation\",\n            # No point gathering the predictions if there are no metrics, otherwise we defer to\n            # self.args.prediction_loss_only\n            prediction_loss_only=True if self.compute_metrics is None else None,\n            ignore_keys=ignore_keys,\n            metric_key_prefix=metric_key_prefix,\n        )\n\n        total_batch_size = self.args.eval_batch_size * self.args.world_size\n        if f\"{metric_key_prefix}_jit_compilation_time\" in output.metrics:\n            start_time += output.metrics[f\"{metric_key_prefix}_jit_compilation_time\"]\n        output.metrics.update(\n            speed_metrics(\n                metric_key_prefix,\n                start_time,\n                num_samples=output.num_samples,\n                num_steps=math.ceil(output.num_samples / total_batch_size),\n            )\n        )\n\n        self.log(output.metrics)\n\n        if DebugOption.TPU_METRICS_DEBUG in self.args.debug:\n            # tpu-comment: Logging debug metrics for PyTorch/XLA (compile, execute times, ops, etc.)\n            xm.master_print(met.metrics_report())\n\n        self.control = self.callback_handler.on_evaluate(self.args, self.state, self.control, output.metrics)\n\n        self._memory_tracker.stop_and_update_metrics(output.metrics)\n\n        return output.metrics\n\n    def predict(\n        self, test_dataset: Dataset, ignore_keys: Optional[List[str]] = None, metric_key_prefix: str = \"test\"\n    ) -> PredictionOutput:\n        \"\"\"\n        Run prediction and returns predictions and potential metrics.\n\n        Depending on the dataset and your use case, your test dataset may contain labels. In that case, this method\n        will also return metrics, like in `evaluate()`.\n\n        Args:\n            test_dataset (`Dataset`):\n                Dataset to run the predictions on. If it is an `datasets.Dataset`, columns not accepted by the\n                `model.forward()` method are automatically removed. Has to implement the method `__len__`\n            ignore_keys (`Lst[str]`, *optional*):\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions.\n            metric_key_prefix (`str`, *optional*, defaults to `\"test\"`):\n                An optional prefix to be used as the metrics key prefix. For example the metrics \"bleu\" will be named\n                \"test_bleu\" if the prefix is \"test\" (default)\n\n        <Tip>\n\n        If your predictions or labels have different sequence length (for instance because you're doing dynamic padding\n        in a token classification task) the predictions will be padded (on the right) to allow for concatenation into\n        one array. The padding index is -100.\n\n        </Tip>\n\n        Returns: *NamedTuple* A namedtuple with the following keys:\n\n            - predictions (`np.ndarray`): The predictions on `test_dataset`.\n            - label_ids (`np.ndarray`, *optional*): The labels (if the dataset contained some).\n            - metrics (`Dict[str, float]`, *optional*): The potential dictionary of metrics (if the dataset contained\n              labels).\n        \"\"\"\n        # memory metrics - must set up as early as possible\n        self._memory_tracker.start()\n\n        test_dataloader = self.get_test_dataloader(test_dataset)\n        start_time = time.time()\n\n        eval_loop = self.prediction_loop if self.args.use_legacy_prediction_loop else self.evaluation_loop\n        output = eval_loop(\n            test_dataloader, description=\"Prediction\", ignore_keys=ignore_keys, metric_key_prefix=metric_key_prefix\n        )\n        total_batch_size = self.args.eval_batch_size * self.args.world_size\n        if f\"{metric_key_prefix}_jit_compilation_time\" in output.metrics:\n            start_time += output.metrics[f\"{metric_key_prefix}_jit_compilation_time\"]\n        output.metrics.update(\n            speed_metrics(\n                metric_key_prefix,\n                start_time,\n                num_samples=output.num_samples,\n                num_steps=math.ceil(output.num_samples / total_batch_size),\n            )\n        )\n\n        self.control = self.callback_handler.on_predict(self.args, self.state, self.control, output.metrics)\n        self._memory_tracker.stop_and_update_metrics(output.metrics)\n\n        return PredictionOutput(predictions=output.predictions, label_ids=output.label_ids, metrics=output.metrics)\n\n    def evaluation_loop(\n        self,\n        dataloader: DataLoader,\n        description: str,\n        prediction_loss_only: Optional[bool] = None,\n        ignore_keys: Optional[List[str]] = None,\n        metric_key_prefix: str = \"eval\",\n    ) -> EvalLoopOutput:\n        \"\"\"\n        Prediction/evaluation loop, shared by `Trainer.evaluate()` and `Trainer.predict()`.\n\n        Works both with or without labels.\n        \"\"\"\n        args = self.args\n\n        prediction_loss_only = prediction_loss_only if prediction_loss_only is not None else args.prediction_loss_only\n\n        # if eval is called w/o train init deepspeed here\n        if args.deepspeed and not self.deepspeed:\n            # XXX: eval doesn't have `resume_from_checkpoint` arg but we should be able to do eval\n            # from the checkpoint eventually\n            deepspeed_engine, _, _ = deepspeed_init(\n                self, num_training_steps=0, resume_from_checkpoint=None, inference=True\n            )\n            self.model = deepspeed_engine.module\n            self.model_wrapped = deepspeed_engine\n            self.deepspeed = deepspeed_engine\n\n        model = self._wrap_model(self.model, training=False, dataloader=dataloader)\n\n        # if full fp16 or bf16 eval is wanted and this ``evaluation`` or ``predict`` isn't called\n        # while ``train`` is running, cast it to the right dtype first and then put on device\n        if not self.is_in_train:\n            if args.fp16_full_eval:\n                model = model.to(dtype=torch.float16, device=args.device)\n            elif args.bf16_full_eval:\n                model = model.to(dtype=torch.bfloat16, device=args.device)\n\n        batch_size = self.args.eval_batch_size\n\n        logger.info(f\"***** Running {description} *****\")\n        if has_length(dataloader):\n            logger.info(f\"  Num examples = {self.num_examples(dataloader)}\")\n        else:\n            logger.info(\"  Num examples: Unknown\")\n        logger.info(f\"  Batch size = {batch_size}\")\n\n        model.eval()\n\n        self.callback_handler.eval_dataloader = dataloader\n        # Do this before wrapping.\n        eval_dataset = getattr(dataloader, \"dataset\", None)\n\n        if is_torch_tpu_available():\n            dataloader = pl.ParallelLoader(dataloader, [args.device]).per_device_loader(args.device)\n\n        if args.past_index >= 0:\n            self._past = None\n\n        # Initialize containers\n        # losses/preds/labels on GPU/TPU (accumulated for eval_accumulation_steps)\n        losses_host = None\n        preds_host = None\n        labels_host = None\n        inputs_host = None\n\n        # losses/preds/labels on CPU (final containers)\n        all_losses = None\n        all_preds = None\n        all_labels = None\n        all_inputs = None\n        # Will be useful when we have an iterable dataset so don't know its length.\n\n        observed_num_examples = 0\n        # Main evaluation loop\n        for step, inputs in enumerate(dataloader):\n            # Update the observed num examples\n            observed_batch_size = find_batch_size(inputs)\n            if observed_batch_size is not None:\n                observed_num_examples += observed_batch_size\n                # For batch samplers, batch_size is not known by the dataloader in advance.\n                if batch_size is None:\n                    batch_size = observed_batch_size\n\n            # Prediction step\n            loss, logits, labels = self.prediction_step(model, inputs, prediction_loss_only, ignore_keys=ignore_keys)\n            inputs_decode = self._prepare_input(inputs[\"input_ids\"]) if args.include_inputs_for_metrics else None\n\n            if is_torch_tpu_available():\n                xm.mark_step()\n\n            # Update containers on host\n            if loss is not None:\n                losses = self._nested_gather(loss.repeat(batch_size))\n                losses_host = losses if losses_host is None else torch.cat((losses_host, losses), dim=0)\n            if labels is not None:\n                labels = self._pad_across_processes(labels)\n                labels = self._nested_gather(labels)\n                labels_host = labels if labels_host is None else nested_concat(labels_host, labels, padding_index=-100)\n            if inputs_decode is not None:\n                inputs_decode = self._pad_across_processes(inputs_decode)\n                inputs_decode = self._nested_gather(inputs_decode)\n                inputs_host = (\n                    inputs_decode\n                    if inputs_host is None\n                    else nested_concat(inputs_host, inputs_decode, padding_index=-100)\n                )\n            if logits is not None:\n                logits = self._pad_across_processes(logits)\n                logits = self._nested_gather(logits)\n                if self.preprocess_logits_for_metrics is not None:\n                    logits = self.preprocess_logits_for_metrics(logits, labels)\n                preds_host = logits if preds_host is None else nested_concat(preds_host, logits, padding_index=-100)\n            self.control = self.callback_handler.on_prediction_step(args, self.state, self.control)\n\n            # Gather all tensors and put them back on the CPU if we have done enough accumulation steps.\n            if args.eval_accumulation_steps is not None and (step + 1) % args.eval_accumulation_steps == 0:\n                if losses_host is not None:\n                    losses = nested_numpify(losses_host)\n                    all_losses = losses if all_losses is None else np.concatenate((all_losses, losses), axis=0)\n                if preds_host is not None:\n                    logits = nested_numpify(preds_host)\n                    all_preds = logits if all_preds is None else nested_concat(all_preds, logits, padding_index=-100)\n                if inputs_host is not None:\n                    inputs_decode = nested_numpify(inputs_host)\n                    all_inputs = (\n                        inputs_decode\n                        if all_inputs is None\n                        else nested_concat(all_inputs, inputs_decode, padding_index=-100)\n                    )\n                if labels_host is not None:\n                    labels = nested_numpify(labels_host)\n                    all_labels = (\n                        labels if all_labels is None else nested_concat(all_labels, labels, padding_index=-100)\n                    )\n\n                # Set back to None to begin a new accumulation\n                losses_host, preds_host, inputs_host, labels_host = None, None, None, None\n\n        if args.past_index and hasattr(self, \"_past\"):\n            # Clean the state at the end of the evaluation loop\n            delattr(self, \"_past\")\n\n        # Gather all remaining tensors and put them back on the CPU\n        if losses_host is not None:\n            losses = nested_numpify(losses_host)\n            all_losses = losses if all_losses is None else np.concatenate((all_losses, losses), axis=0)\n        if preds_host is not None:\n            logits = nested_numpify(preds_host)\n            all_preds = logits if all_preds is None else nested_concat(all_preds, logits, padding_index=-100)\n        if inputs_host is not None:\n            inputs_decode = nested_numpify(inputs_host)\n            all_inputs = (\n                inputs_decode if all_inputs is None else nested_concat(all_inputs, inputs_decode, padding_index=-100)\n            )\n        if labels_host is not None:\n            labels = nested_numpify(labels_host)\n            all_labels = labels if all_labels is None else nested_concat(all_labels, labels, padding_index=-100)\n\n        # Number of samples\n        if has_length(eval_dataset):\n            num_samples = len(eval_dataset)\n        # The instance check is weird and does not actually check for the type, but whether the dataset has the right\n        # methods. Therefore we need to make sure it also has the attribute.\n        elif isinstance(eval_dataset, IterableDatasetShard) and getattr(eval_dataset, \"num_examples\", 0) > 0:\n            num_samples = eval_dataset.num_examples\n        else:\n            if has_length(dataloader):\n                num_samples = self.num_examples(dataloader)\n            else:  # both len(dataloader.dataset) and len(dataloader) fail\n                num_samples = observed_num_examples\n        if num_samples == 0 and observed_num_examples > 0:\n            num_samples = observed_num_examples\n\n        # Number of losses has been rounded to a multiple of batch_size and in a distributed training, the number of\n        # samplers has been rounded to a multiple of batch_size, so we truncate.\n        if all_losses is not None:\n            all_losses = all_losses[:num_samples]\n        if all_preds is not None:\n            all_preds = nested_truncate(all_preds, num_samples)\n        if all_labels is not None:\n            all_labels = nested_truncate(all_labels, num_samples)\n        if all_inputs is not None:\n            all_inputs = nested_truncate(all_inputs, num_samples)\n\n        # Metrics!\n        if self.compute_metrics is not None and all_preds is not None and all_labels is not None:\n            if args.include_inputs_for_metrics:\n                metrics = self.compute_metrics(\n                    EvalPrediction(predictions=all_preds, label_ids=all_labels, inputs=all_inputs)\n                )\n            else:\n                metrics = self.compute_metrics(EvalPrediction(predictions=all_preds, label_ids=all_labels))\n        else:\n            metrics = {}\n\n        # To be JSON-serializable, we need to remove numpy types or zero-d tensors\n        metrics = denumpify_detensorize(metrics)\n\n        if all_losses is not None:\n            metrics[f\"{metric_key_prefix}_loss\"] = all_losses.mean().item()\n        if hasattr(self, \"jit_compilation_time\"):\n            metrics[f\"{metric_key_prefix}_jit_compilation_time\"] = self.jit_compilation_time\n\n        # Prefix all keys with metric_key_prefix + '_'\n        for key in list(metrics.keys()):\n            if not key.startswith(f\"{metric_key_prefix}_\"):\n                metrics[f\"{metric_key_prefix}_{key}\"] = metrics.pop(key)\n\n        return EvalLoopOutput(predictions=all_preds, label_ids=all_labels, metrics=metrics, num_samples=num_samples)\n\n    def _nested_gather(self, tensors, name=None):\n        \"\"\"\n        Gather value of `tensors` (tensor or list/tuple of nested tensors) and convert them to numpy before\n        concatenating them to `gathered`\n        \"\"\"\n        if tensors is None:\n            return\n        if is_torch_tpu_available():\n            if name is None:\n                name = \"nested_gather\"\n            tensors = nested_xla_mesh_reduce(tensors, name)\n        elif is_sagemaker_mp_enabled():\n            tensors = smp_gather(tensors)\n        elif self.args.local_rank != -1:\n            tensors = distributed_concat(tensors)\n        return tensors\n\n    # Copied from Accelerate.\n    def _pad_across_processes(self, tensor, pad_index=-100):\n        \"\"\"\n        Recursively pad the tensors in a nested list/tuple/dictionary of tensors from all devices to the same size so\n        they can safely be gathered.\n        \"\"\"\n        if isinstance(tensor, (list, tuple)):\n            return type(tensor)(self._pad_across_processes(t, pad_index=pad_index) for t in tensor)\n        elif isinstance(tensor, dict):\n            return type(tensor)({k: self._pad_across_processes(v, pad_index=pad_index) for k, v in tensor.items()})\n        elif not isinstance(tensor, torch.Tensor):\n            raise TypeError(\n                f\"Can't pad the values of type {type(tensor)}, only of nested list/tuple/dicts of tensors.\"\n            )\n\n        if len(tensor.shape) < 2:\n            return tensor\n        # Gather all sizes\n        size = torch.tensor(tensor.shape, device=tensor.device)[None]\n        sizes = self._nested_gather(size).cpu()\n\n        max_size = max(s[1] for s in sizes)\n        # When extracting XLA graphs for compilation, max_size is 0,\n        # so use inequality to avoid errors.\n        if tensor.shape[1] >= max_size:\n            return tensor\n\n        # Then pad to the maximum size\n        old_size = tensor.shape\n        new_size = list(old_size)\n        new_size[1] = max_size\n        new_tensor = tensor.new_zeros(tuple(new_size)) + pad_index\n        new_tensor[:, : old_size[1]] = tensor\n        return new_tensor\n\n    def prediction_step(\n        self,\n        model: nn.Module,\n        inputs: Dict[str, Union[torch.Tensor, Any]],\n        prediction_loss_only: bool,\n        ignore_keys: Optional[List[str]] = None,\n    ) -> Tuple[Optional[torch.Tensor], Optional[torch.Tensor], Optional[torch.Tensor]]:\n        \"\"\"\n        Perform an evaluation step on `model` using `inputs`.\n\n        Subclass and override to inject custom behavior.\n\n        Args:\n            model (`nn.Module`):\n                The model to evaluate.\n            inputs (`Dict[str, Union[torch.Tensor, Any]]`):\n                The inputs and targets of the model.\n\n                The dictionary will be unpacked before being fed to the model. Most models expect the targets under the\n                argument `labels`. Check your model's documentation for all accepted arguments.\n            prediction_loss_only (`bool`):\n                Whether or not to return the loss only.\n            ignore_keys (`Lst[str]`, *optional*):\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions.\n\n        Return:\n            Tuple[Optional[torch.Tensor], Optional[torch.Tensor], Optional[torch.Tensor]]: A tuple with the loss,\n            logits and labels (each being optional).\n        \"\"\"\n        has_labels = False if len(self.label_names) == 0 else all(inputs.get(k) is not None for k in self.label_names)\n        # For CLIP-like models capable of returning loss values.\n        # If `return_loss` is not specified or being `None` in `inputs`, we check if the default value of `return_loss`\n        # is `True` in `model.forward`.\n        return_loss = inputs.get(\"return_loss\", None)\n        if return_loss is None:\n            return_loss = self.can_return_loss\n        loss_without_labels = True if len(self.label_names) == 0 and return_loss else False\n\n        inputs = self._prepare_inputs(inputs)\n        if ignore_keys is None:\n            if hasattr(self.model, \"config\"):\n                ignore_keys = getattr(self.model.config, \"keys_to_ignore_at_inference\", [])\n            else:\n                ignore_keys = []\n\n        # labels may be popped when computing the loss (label smoothing for instance) so we grab them first.\n        if has_labels or loss_without_labels:\n            labels = nested_detach(tuple(inputs.get(name) for name in self.label_names))\n            if len(labels) == 1:\n                labels = labels[0]\n        else:\n            labels = None\n\n        with torch.no_grad():\n            if is_sagemaker_mp_enabled():\n                raw_outputs = smp_forward_only(model, inputs)\n                if has_labels or loss_without_labels:\n                    if isinstance(raw_outputs, dict):\n                        loss_mb = raw_outputs[\"loss\"]\n                        logits_mb = tuple(v for k, v in raw_outputs.items() if k not in ignore_keys + [\"loss\"])\n                    else:\n                        loss_mb = raw_outputs[0]\n                        logits_mb = raw_outputs[1:]\n\n                    loss = loss_mb.reduce_mean().detach().cpu()\n                    logits = smp_nested_concat(logits_mb)\n                else:\n                    loss = None\n                    if isinstance(raw_outputs, dict):\n                        logits_mb = tuple(v for k, v in raw_outputs.items() if k not in ignore_keys)\n                    else:\n                        logits_mb = raw_outputs\n                    logits = smp_nested_concat(logits_mb)\n            else:\n                if has_labels or loss_without_labels:\n                    with self.compute_loss_context_manager():\n                        loss, outputs = self.compute_loss(model, inputs, return_outputs=True)\n                    loss = loss.mean().detach()\n\n                    if isinstance(outputs, dict):\n                        logits = tuple(v for k, v in outputs.items() if k not in ignore_keys + [\"loss\"])\n                    else:\n                        logits = outputs[1:]\n                else:\n                    loss = None\n                    with self.compute_loss_context_manager():\n                        outputs = model(**inputs)\n                    if isinstance(outputs, dict):\n                        logits = tuple(v for k, v in outputs.items() if k not in ignore_keys)\n                    else:\n                        logits = outputs\n                    # TODO: this needs to be fixed and made cleaner later.\n                    if self.args.past_index >= 0:\n                        self._past = outputs[self.args.past_index - 1]\n\n        if prediction_loss_only:\n            return (loss, None, None)\n\n        logits = nested_detach(logits)\n        if len(logits) == 1:\n            logits = logits[0]\n\n        return (loss, logits, labels)\n\n    def floating_point_ops(self, inputs: Dict[str, Union[torch.Tensor, Any]]):\n        \"\"\"\n        For models that inherit from [`PreTrainedModel`], uses that method to compute the number of floating point\n        operations for every backward + forward pass. If using another model, either implement such a method in the\n        model or subclass and override this method.\n\n        Args:\n            inputs (`Dict[str, Union[torch.Tensor, Any]]`):\n                The inputs and targets of the model.\n\n        Returns:\n            `int`: The number of floating-point operations.\n        \"\"\"\n        if hasattr(self.model, \"floating_point_ops\"):\n            return self.model.floating_point_ops(inputs)\n        else:\n            return 0\n\n    def init_git_repo(self, at_init: bool = False):\n        \"\"\"\n        Initializes a git repo in `self.args.hub_model_id`.\n\n        Args:\n            at_init (`bool`, *optional*, defaults to `False`):\n                Whether this function is called before any training or not. If `self.args.overwrite_output_dir` is\n                `True` and `at_init` is `True`, the path to the repo (which is `self.args.output_dir`) might be wiped\n                out.\n        \"\"\"\n        if not self.is_world_process_zero():\n            return\n        if self.args.hub_model_id is None:\n            repo_name = Path(self.args.output_dir).absolute().name\n        else:\n            repo_name = self.args.hub_model_id\n        if \"/\" not in repo_name:\n            repo_name = get_full_repo_name(repo_name, token=self.args.hub_token)\n\n        # Make sure the repo exists.\n        create_repo(repo_name, token=self.args.hub_token, private=self.args.hub_private_repo, exist_ok=True)\n        try:\n            self.repo = Repository(self.args.output_dir, clone_from=repo_name, token=self.args.hub_token)\n        except EnvironmentError:\n            if self.args.overwrite_output_dir and at_init:\n                # Try again after wiping output_dir\n                shutil.rmtree(self.args.output_dir)\n                self.repo = Repository(self.args.output_dir, clone_from=repo_name, token=self.args.hub_token)\n            else:\n                raise\n\n        self.repo.git_pull()\n\n        # By default, ignore the checkpoint folders\n        if (\n            not os.path.exists(os.path.join(self.args.output_dir, \".gitignore\"))\n            and self.args.hub_strategy != HubStrategy.ALL_CHECKPOINTS\n        ):\n            with open(os.path.join(self.args.output_dir, \".gitignore\"), \"w\", encoding=\"utf-8\") as writer:\n                writer.writelines([\"checkpoint-*/\"])\n\n        # Add \"*.sagemaker\" to .gitignore if using SageMaker\n        if os.environ.get(\"SM_TRAINING_ENV\"):\n            self._add_sm_patterns_to_gitignore()\n\n        self.push_in_progress = None\n\n    def create_model_card(\n        self,\n        language: Optional[str] = None,\n        license: Optional[str] = None,\n        tags: Union[str, List[str], None] = None,\n        model_name: Optional[str] = None,\n        finetuned_from: Optional[str] = None,\n        tasks: Union[str, List[str], None] = None,\n        dataset_tags: Union[str, List[str], None] = None,\n        dataset: Union[str, List[str], None] = None,\n        dataset_args: Union[str, List[str], None] = None,\n    ):\n        \"\"\"\n        Creates a draft of a model card using the information available to the `Trainer`.\n\n        Args:\n            language (`str`, *optional*):\n                The language of the model (if applicable)\n            license (`str`, *optional*):\n                The license of the model. Will default to the license of the pretrained model used, if the original\n                model given to the `Trainer` comes from a repo on the Hub.\n            tags (`str` or `List[str]`, *optional*):\n                Some tags to be included in the metadata of the model card.\n            model_name (`str`, *optional*):\n                The name of the model.\n            finetuned_from (`str`, *optional*):\n                The name of the model used to fine-tune this one (if applicable). Will default to the name of the repo\n                of the original model given to the `Trainer` (if it comes from the Hub).\n            tasks (`str` or `List[str]`, *optional*):\n                One or several task identifiers, to be included in the metadata of the model card.\n            dataset_tags (`str` or `List[str]`, *optional*):\n                One or several dataset tags, to be included in the metadata of the model card.\n            dataset (`str` or `List[str]`, *optional*):\n                One or several dataset identifiers, to be included in the metadata of the model card.\n            dataset_args (`str` or `List[str]`, *optional*):\n               One or several dataset arguments, to be included in the metadata of the model card.\n        \"\"\"\n        if not self.is_world_process_zero():\n            return\n\n        training_summary = TrainingSummary.from_trainer(\n            self,\n            language=language,\n            license=license,\n            tags=tags,\n            model_name=model_name,\n            finetuned_from=finetuned_from,\n            tasks=tasks,\n            dataset_tags=dataset_tags,\n            dataset=dataset,\n            dataset_args=dataset_args,\n        )\n        model_card = training_summary.to_model_card()\n        with open(os.path.join(self.args.output_dir, \"README.md\"), \"w\") as f:\n            f.write(model_card)\n\n    def _push_from_checkpoint(self, checkpoint_folder):\n        # Only push from one node.\n        if not self.is_world_process_zero() or self.args.hub_strategy == HubStrategy.END:\n            return\n        # If we haven't finished the last push, we don't do this one.\n        if self.push_in_progress is not None and not self.push_in_progress.is_done:\n            return\n\n        output_dir = self.args.output_dir\n        # To avoid a new synchronization of all model weights, we just copy the file from the checkpoint folder\n        modeling_files = [CONFIG_NAME, WEIGHTS_NAME]\n        for modeling_file in modeling_files:\n            if os.path.isfile(os.path.join(checkpoint_folder, modeling_file)):\n                shutil.copy(os.path.join(checkpoint_folder, modeling_file), os.path.join(output_dir, modeling_file))\n        # Saving the tokenizer is fast and we don't know how many files it may have spawned, so we resave it to be sure.\n        if self.tokenizer is not None:\n            self.tokenizer.save_pretrained(output_dir)\n        # Same for the training arguments\n        torch.save(self.args, os.path.join(output_dir, TRAINING_ARGS_NAME))\n\n        try:\n            if self.args.hub_strategy == HubStrategy.CHECKPOINT:\n                # Temporarily move the checkpoint just saved for the push\n                tmp_checkpoint = os.path.join(output_dir, \"last-checkpoint\")\n                # We have to remove the \"last-checkpoint\" dir if it exists, otherwise the checkpoint is moved as a\n                # subfolder.\n                if os.path.isdir(tmp_checkpoint):\n                    shutil.rmtree(tmp_checkpoint)\n                shutil.move(checkpoint_folder, tmp_checkpoint)\n\n            if self.args.save_strategy == IntervalStrategy.STEPS:\n                commit_message = f\"Training in progress, step {self.state.global_step}\"\n            else:\n                commit_message = f\"Training in progress, epoch {int(self.state.epoch)}\"\n            _, self.push_in_progress = self.repo.push_to_hub(\n                commit_message=commit_message, blocking=False, auto_lfs_prune=True\n            )\n        finally:\n            if self.args.hub_strategy == HubStrategy.CHECKPOINT:\n                # Move back the checkpoint to its place\n                shutil.move(tmp_checkpoint, checkpoint_folder)\n\n    def push_to_hub(self, commit_message: Optional[str] = \"End of training\", blocking: bool = True, **kwargs) -> str:\n        \"\"\"\n        Upload *self.model* and *self.tokenizer* to the \ud83e\udd17 model hub on the repo *self.args.hub_model_id*.\n\n        Parameters:\n            commit_message (`str`, *optional*, defaults to `\"End of training\"`):\n                Message to commit while pushing.\n            blocking (`bool`, *optional*, defaults to `True`):\n                Whether the function should return only when the `git push` has finished.\n            kwargs:\n                Additional keyword arguments passed along to [`~Trainer.create_model_card`].\n\n        Returns:\n            The url of the commit of your model in the given repository if `blocking=False`, a tuple with the url of\n            the commit and an object to track the progress of the commit if `blocking=True`\n        \"\"\"\n        # If a user calls manually `push_to_hub` with `self.args.push_to_hub = False`, we try to create the repo but\n        # it might fail.\n        if not hasattr(self, \"repo\"):\n            self.init_git_repo()\n\n        model_name = kwargs.pop(\"model_name\", None)\n        if model_name is None and self.args.should_save:\n            if self.args.hub_model_id is None:\n                model_name = Path(self.args.output_dir).name\n            else:\n                model_name = self.args.hub_model_id.split(\"/\")[-1]\n\n        # Needs to be executed on all processes for TPU training, but will only save on the processed determined by\n        # self.args.should_save.\n        self.save_model(_internal_call=True)\n\n        # Only push from one node.\n        if not self.is_world_process_zero():\n            return\n\n        # Cancel any async push in progress if blocking=True. The commits will all be pushed together.\n        if blocking and self.push_in_progress is not None and not self.push_in_progress.is_done:\n            self.push_in_progress._process.kill()\n            self.push_in_progress = None\n\n        git_head_commit_url = self.repo.push_to_hub(\n            commit_message=commit_message, blocking=blocking, auto_lfs_prune=True\n        )\n        # push separately the model card to be independant from the rest of the model\n        if self.args.should_save:\n            self.create_model_card(model_name=model_name, **kwargs)\n            try:\n                self.repo.push_to_hub(\n                    commit_message=\"update model card README.md\", blocking=blocking, auto_lfs_prune=True\n                )\n            except EnvironmentError as exc:\n                logger.error(f\"Error pushing update to the model card. Please read logs and retry.\\n${exc}\")\n\n        return git_head_commit_url\n\n    #\n    # Deprecated code\n    #\n\n    def prediction_loop(\n        self,\n        dataloader: DataLoader,\n        description: str,\n        prediction_loss_only: Optional[bool] = None,\n        ignore_keys: Optional[List[str]] = None,\n        metric_key_prefix: str = \"eval\",\n    ) -> EvalLoopOutput:\n        \"\"\"\n        Prediction/evaluation loop, shared by `Trainer.evaluate()` and `Trainer.predict()`.\n\n        Works both with or without labels.\n        \"\"\"\n        args = self.args\n\n        if not has_length(dataloader):\n            raise ValueError(\"dataloader must implement a working __len__\")\n\n        prediction_loss_only = prediction_loss_only if prediction_loss_only is not None else args.prediction_loss_only\n\n        # if eval is called w/o train init deepspeed here\n        if args.deepspeed and not self.deepspeed:\n            # XXX: eval doesn't have `resume_from_checkpoint` arg but we should be able to do eval\n            # from the checkpoint eventually\n            deepspeed_engine, _, _ = deepspeed_init(self, num_training_steps=0, resume_from_checkpoint=None)\n            self.model = deepspeed_engine.module\n            self.model_wrapped = deepspeed_engine\n            self.deepspeed = deepspeed_engine\n            # XXX: we don't need optim/sched for inference, but this needs to be sorted out, since\n            # for example the Z3-optimizer is a must for zero3 to work even for inference - what we\n            # don't need is the deepspeed basic optimizer which is self.optimizer.optimizer\n            deepspeed_engine.optimizer.optimizer = None\n            deepspeed_engine.lr_scheduler = None\n\n        model = self._wrap_model(self.model, training=False, dataloader=dataloader)\n\n        # if full fp16 or bf16 eval is wanted and this ``evaluation`` or ``predict`` isn't called\n        # while ``train`` is running, cast it to the right dtype first and then put on device\n        if not self.is_in_train:\n            if args.fp16_full_eval:\n                model = model.to(dtype=torch.float16, device=args.device)\n            elif args.bf16_full_eval:\n                model = model.to(dtype=torch.bfloat16, device=args.device)\n\n        batch_size = dataloader.batch_size\n        num_examples = self.num_examples(dataloader)\n        logger.info(f\"***** Running {description} *****\")\n        logger.info(f\"  Num examples = {num_examples}\")\n        logger.info(f\"  Batch size = {batch_size}\")\n        losses_host: torch.Tensor = None\n        preds_host: Union[torch.Tensor, List[torch.Tensor]] = None\n        labels_host: Union[torch.Tensor, List[torch.Tensor]] = None\n        inputs_host: Union[torch.Tensor, List[torch.Tensor]] = None\n\n        world_size = max(1, args.world_size)\n\n        eval_losses_gatherer = DistributedTensorGatherer(world_size, num_examples, make_multiple_of=batch_size)\n        if not prediction_loss_only:\n            # The actual number of eval_sample can be greater than num_examples in distributed settings (when we pass\n            # a batch size to the sampler)\n            make_multiple_of = None\n            if hasattr(dataloader, \"sampler\") and isinstance(dataloader.sampler, SequentialDistributedSampler):\n                make_multiple_of = dataloader.sampler.batch_size\n            preds_gatherer = DistributedTensorGatherer(world_size, num_examples, make_multiple_of=make_multiple_of)\n            labels_gatherer = DistributedTensorGatherer(world_size, num_examples, make_multiple_of=make_multiple_of)\n            inputs_gatherer = DistributedTensorGatherer(world_size, num_examples, make_multiple_of=make_multiple_of)\n\n        model.eval()\n\n        if is_torch_tpu_available():\n            dataloader = pl.ParallelLoader(dataloader, [args.device]).per_device_loader(args.device)\n\n        if args.past_index >= 0:\n            self._past = None\n\n        self.callback_handler.eval_dataloader = dataloader\n\n        for step, inputs in enumerate(dataloader):\n            loss, logits, labels = self.prediction_step(model, inputs, prediction_loss_only, ignore_keys=ignore_keys)\n            inputs_decode = self._prepare_input(inputs[\"input_ids\"]) if args.include_inputs_for_metrics else None\n\n            if loss is not None:\n                losses = loss.repeat(batch_size)\n                losses_host = losses if losses_host is None else torch.cat((losses_host, losses), dim=0)\n            if logits is not None:\n                preds_host = logits if preds_host is None else nested_concat(preds_host, logits, padding_index=-100)\n            if labels is not None:\n                labels_host = labels if labels_host is None else nested_concat(labels_host, labels, padding_index=-100)\n            if inputs_decode is not None:\n                inputs_host = (\n                    inputs_decode\n                    if inputs_host is None\n                    else nested_concat(inputs_host, inputs_decode, padding_index=-100)\n                )\n            self.control = self.callback_handler.on_prediction_step(args, self.state, self.control)\n\n            # Gather all tensors and put them back on the CPU if we have done enough accumulation steps.\n            if args.eval_accumulation_steps is not None and (step + 1) % args.eval_accumulation_steps == 0:\n                eval_losses_gatherer.add_arrays(self._gather_and_numpify(losses_host, \"eval_losses\"))\n                if not prediction_loss_only:\n                    preds_gatherer.add_arrays(self._gather_and_numpify(preds_host, \"eval_preds\"))\n                    labels_gatherer.add_arrays(self._gather_and_numpify(labels_host, \"eval_label_ids\"))\n                    inputs_gatherer.add_arrays(self._gather_and_numpify(inputs_host, \"eval_inputs_ids\"))\n\n                # Set back to None to begin a new accumulation\n                losses_host, preds_host, labels_host, inputs_host = None, None, None, None\n\n        if args.past_index and hasattr(self, \"_past\"):\n            # Clean the state at the end of the evaluation loop\n            delattr(self, \"_past\")\n\n        # Gather all remaining tensors and put them back on the CPU\n        eval_losses_gatherer.add_arrays(self._gather_and_numpify(losses_host, \"eval_losses\"))\n        if not prediction_loss_only:\n            preds_gatherer.add_arrays(self._gather_and_numpify(preds_host, \"eval_preds\"))\n            labels_gatherer.add_arrays(self._gather_and_numpify(labels_host, \"eval_label_ids\"))\n            inputs_gatherer.add_arrays(self._gather_and_numpify(inputs_host, \"eval_inputs_ids\"))\n\n        eval_loss = eval_losses_gatherer.finalize()\n        preds = preds_gatherer.finalize() if not prediction_loss_only else None\n        label_ids = labels_gatherer.finalize() if not prediction_loss_only else None\n        inputs_ids = inputs_gatherer.finalize() if not prediction_loss_only else None\n\n        if self.compute_metrics is not None and preds is not None and label_ids is not None:\n            if args.include_inputs_for_metrics:\n                metrics = self.compute_metrics(\n                    EvalPrediction(predictions=preds, label_ids=label_ids, inputs=inputs_ids)\n                )\n            else:\n                metrics = self.compute_metrics(EvalPrediction(predictions=preds, label_ids=label_ids))\n        else:\n            metrics = {}\n\n        # To be JSON-serializable, we need to remove numpy types or zero-d tensors\n        metrics = denumpify_detensorize(metrics)\n\n        if eval_loss is not None:\n            metrics[f\"{metric_key_prefix}_loss\"] = eval_loss.mean().item()\n\n        # Prefix all keys with metric_key_prefix + '_'\n        for key in list(metrics.keys()):\n            if not key.startswith(f\"{metric_key_prefix}_\"):\n                metrics[f\"{metric_key_prefix}_{key}\"] = metrics.pop(key)\n\n        return EvalLoopOutput(predictions=preds, label_ids=label_ids, metrics=metrics, num_samples=num_examples)\n\n    def _gather_and_numpify(self, tensors, name):\n        \"\"\"\n        Gather value of `tensors` (tensor or list/tuple of nested tensors) and convert them to numpy before\n        concatenating them to `gathered`\n        \"\"\"\n        if tensors is None:\n            return\n        if is_torch_tpu_available():\n            tensors = nested_xla_mesh_reduce(tensors, name)\n        elif is_sagemaker_mp_enabled():\n            tensors = smp_gather(tensors)\n        elif self.args.local_rank != -1:\n            tensors = distributed_concat(tensors)\n\n        return nested_numpify(tensors)\n\n    def _add_sm_patterns_to_gitignore(self) -> None:\n        \"\"\"Add SageMaker Checkpointing patterns to .gitignore file.\"\"\"\n        # Make sure we only do this on the main process\n        if not self.is_world_process_zero():\n            return\n\n        patterns = [\"*.sagemaker-uploading\", \"*.sagemaker-uploaded\"]\n\n        # Get current .gitignore content\n        if os.path.exists(os.path.join(self.repo.local_dir, \".gitignore\")):\n            with open(os.path.join(self.repo.local_dir, \".gitignore\"), \"r\") as f:\n                current_content = f.read()\n        else:\n            current_content = \"\"\n\n        # Add the patterns to .gitignore\n        content = current_content\n        for pattern in patterns:\n            if pattern not in content:\n                if content.endswith(\"\\n\"):\n                    content += pattern\n                else:\n                    content += f\"\\n{pattern}\"\n\n        # Write the .gitignore file if it has changed\n        if content != current_content:\n            with open(os.path.join(self.repo.local_dir, \".gitignore\"), \"w\") as f:\n                logger.debug(f\"Writing .gitignore file. Content: {content}\")\n                f.write(content)\n\n        self.repo.git_add(\".gitignore\")\n\n        # avoid race condition with git status\n        time.sleep(0.5)\n\n        if not self.repo.is_repo_clean():\n            self.repo.git_commit(\"Add *.sagemaker patterns to .gitignore.\")\n            self.repo.git_push()", "class Trainer:\n    \"\"\"\n    Trainer is a simple but feature-complete training and eval loop for PyTorch, optimized for \ud83e\udd17 Transformers.\n\n    Args:\n        model ([`PreTrainedModel`] or `torch.nn.Module`, *optional*):\n            The model to train, evaluate or use for predictions. If not provided, a `model_init` must be passed.\n\n            <Tip>\n\n            [`Trainer`] is optimized to work with the [`PreTrainedModel`] provided by the library. You can still use\n            your own models defined as `torch.nn.Module` as long as they work the same way as the \ud83e\udd17 Transformers\n            models.\n\n            </Tip>\n\n        args ([`TrainingArguments`], *optional*):\n            The arguments to tweak for training. Will default to a basic instance of [`TrainingArguments`] with the\n            `output_dir` set to a directory named *tmp_trainer* in the current directory if not provided.\n        data_collator (`DataCollator`, *optional*):\n            The function to use to form a batch from a list of elements of `train_dataset` or `eval_dataset`. Will\n            default to [`default_data_collator`] if no `tokenizer` is provided, an instance of\n            [`DataCollatorWithPadding`] otherwise.\n        train_dataset (`torch.utils.data.Dataset` or `torch.utils.data.IterableDataset`, *optional*):\n            The dataset to use for training. If it is a [`~datasets.Dataset`], columns not accepted by the\n            `model.forward()` method are automatically removed.\n\n            Note that if it's a `torch.utils.data.IterableDataset` with some randomization and you are training in a\n            distributed fashion, your iterable dataset should either use a internal attribute `generator` that is a\n            `torch.Generator` for the randomization that must be identical on all processes (and the Trainer will\n            manually set the seed of this `generator` at each epoch) or have a `set_epoch()` method that internally\n            sets the seed of the RNGs used.\n        eval_dataset (Union[`torch.utils.data.Dataset`, Dict[str, `torch.utils.data.Dataset`]), *optional*):\n             The dataset to use for evaluation. If it is a [`~datasets.Dataset`], columns not accepted by the\n             `model.forward()` method are automatically removed. If it is a dictionary, it will evaluate on each\n             dataset prepending the dictionary key to the metric name.\n        tokenizer ([`PreTrainedTokenizerBase`], *optional*):\n            The tokenizer used to preprocess the data. If provided, will be used to automatically pad the inputs to the\n            maximum length when batching inputs, and it will be saved along the model to make it easier to rerun an\n            interrupted training or reuse the fine-tuned model.\n        model_init (`Callable[[], PreTrainedModel]`, *optional*):\n            A function that instantiates the model to be used. If provided, each call to [`~Trainer.train`] will start\n            from a new instance of the model as given by this function.\n\n            The function may have zero argument, or a single one containing the optuna/Ray Tune/SigOpt trial object, to\n            be able to choose different architectures according to hyper parameters (such as layer count, sizes of\n            inner layers, dropout probabilities etc).\n        compute_metrics (`Callable[[EvalPrediction], Dict]`, *optional*):\n            The function that will be used to compute metrics at evaluation. Must take a [`EvalPrediction`] and return\n            a dictionary string to metric values.\n        callbacks (List of [`TrainerCallback`], *optional*):\n            A list of callbacks to customize the training loop. Will add those to the list of default callbacks\n            detailed in [here](callback).\n\n            If you want to remove one of the default callbacks used, use the [`Trainer.remove_callback`] method.\n        optimizers (`Tuple[torch.optim.Optimizer, torch.optim.lr_scheduler.LambdaLR]`, *optional*): A tuple\n            containing the optimizer and the scheduler to use. Will default to an instance of [`AdamW`] on your model\n            and a scheduler given by [`get_linear_schedule_with_warmup`] controlled by `args`.\n        preprocess_logits_for_metrics (`Callable[[torch.Tensor, torch.Tensor], torch.Tensor]`, *optional*):\n            A function that preprocess the logits right before caching them at each evaluation step. Must take two\n            tensors, the logits and the labels, and return the logits once processed as desired. The modifications made\n            by this function will be reflected in the predictions received by `compute_metrics`.\n\n            Note that the labels (second parameter) will be `None` if the dataset does not have them.\n\n    Important attributes:\n\n        - **model** -- Always points to the core model. If using a transformers model, it will be a [`PreTrainedModel`]\n          subclass.\n        - **model_wrapped** -- Always points to the most external model in case one or more other modules wrap the\n          original model. This is the model that should be used for the forward pass. For example, under `DeepSpeed`,\n          the inner model is wrapped in `DeepSpeed` and then again in `torch.nn.DistributedDataParallel`. If the inner\n          model hasn't been wrapped, then `self.model_wrapped` is the same as `self.model`.\n        - **is_model_parallel** -- Whether or not a model has been switched to a model parallel mode (different from\n          data parallelism, this means some of the model layers are split on different GPUs).\n        - **place_model_on_device** -- Whether or not to automatically place the model on the device - it will be set\n          to `False` if model parallel or deepspeed is used, or if the default\n          `TrainingArguments.place_model_on_device` is overridden to return `False` .\n        - **is_in_train** -- Whether or not a model is currently running `train` (e.g. when `evaluate` is called while\n          in `train`)\n\n    \"\"\"\n\n    from transformers.trainer_pt_utils import _get_learning_rate, log_metrics, metrics_format, save_metrics, save_state\n\n    def __init__(\n        self,\n        model: Union[PreTrainedModel, nn.Module] = None,\n        args: TrainingArguments = None,\n        data_collator: Optional[DataCollator] = None,\n        train_dataset: Optional[Dataset] = None,\n        eval_dataset: Optional[Union[Dataset, Dict[str, Dataset]]] = None,\n        tokenizer: Optional[PreTrainedTokenizerBase] = None,\n        model_init: Optional[Callable[[], PreTrainedModel]] = None,\n        compute_metrics: Optional[Callable[[EvalPrediction], Dict]] = None,\n        callbacks: Optional[List[TrainerCallback]] = None,\n        optimizers: Tuple[torch.optim.Optimizer, torch.optim.lr_scheduler.LambdaLR] = (None, None),\n        preprocess_logits_for_metrics: Optional[Callable[[torch.Tensor, torch.Tensor], torch.Tensor]] = None,\n        save_prefixencoder: bool = False,\n    ):\n        self.save_prefixencoder = save_prefixencoder\n        if args is None:\n            output_dir = \"tmp_trainer\"\n            logger.info(f\"No `TrainingArguments` passed, using `output_dir={output_dir}`.\")\n            args = TrainingArguments(output_dir=output_dir)\n        self.args = args\n        # Seed must be set before instantiating the model when using model\n        enable_full_determinism(self.args.seed) if self.args.full_determinism else set_seed(self.args.seed)\n        self.hp_name = None\n        self.deepspeed = None\n        self.is_in_train = False\n\n        # memory metrics - must set up as early as possible\n        self._memory_tracker = TrainerMemoryTracker(self.args.skip_memory_metrics)\n        self._memory_tracker.start()\n\n        # set the correct log level depending on the node\n        log_level = args.get_process_log_level()\n        logging.set_verbosity(log_level)\n\n        # force device and distributed setup init explicitly\n        args._setup_devices\n\n        if model is None:\n            if model_init is not None:\n                self.model_init = model_init\n                model = self.call_model_init()\n            else:\n                raise RuntimeError(\"`Trainer` requires either a `model` or `model_init` argument\")\n        else:\n            if model_init is not None:\n                warnings.warn(\n                    \"`Trainer` requires either a `model` or `model_init` argument, but not both. `model_init` will\"\n                    \" overwrite your model when calling the `train` method. This will become a fatal error in the next\"\n                    \" release.\",\n                    FutureWarning,\n                )\n            self.model_init = model_init\n\n        if model.__class__.__name__ in MODEL_MAPPING_NAMES:\n            raise ValueError(\n                f\"The model you have picked ({model.__class__.__name__}) cannot be used as is for training: it only \"\n                \"computes hidden states and does not accept any labels. You should choose a model with a head \"\n                \"suitable for your task like any of the `AutoModelForXxx` listed at \"\n                \"https://huggingface.co/docs/transformers/model_doc/auto.\"\n            )\n\n        if hasattr(model, \"is_parallelizable\") and model.is_parallelizable and model.model_parallel:\n            self.is_model_parallel = True\n        else:\n            self.is_model_parallel = False\n\n        # At this stage the model is already loaded\n        if getattr(model, \"is_loaded_in_8bit\", False):\n            if getattr(model, \"_is_int8_training_enabled\", False):\n                logger.info(\n                    \"The model is loaded in 8-bit precision. To train this model you need to add additional modules\"\n                    \" inside the model such as adapters using `peft` library and freeze the model weights. Please\"\n                    \" check \"\n                    \" the examples in https://github.com/huggingface/peft for more details.\"\n                )\n            else:\n                raise ValueError(\n                    \"The model you want to train is loaded in 8-bit precision.  if you want to fine-tune an 8-bit\"\n                    \" model, please make sure that you have installed `bitsandbytes>=0.37.0`. \"\n                )\n\n        # Setup Sharded DDP training\n        self.sharded_ddp = None\n        if len(args.sharded_ddp) > 0:\n            if args.deepspeed:\n                raise ValueError(\n                    \"Using --sharded_ddp xxx together with --deepspeed is not possible, deactivate one of those flags.\"\n                )\n            if len(args.fsdp) > 0:\n                raise ValueError(\n                    \"Using --sharded_ddp xxx together with --fsdp is not possible, deactivate one of those flags.\"\n                )\n\n            if args.local_rank == -1:\n                raise ValueError(\"Using sharded DDP only works in distributed training.\")\n            elif not is_fairscale_available():\n                raise ImportError(\"Sharded DDP training requires fairscale: `pip install fairscale`.\")\n            elif ShardedDDPOption.SIMPLE not in args.sharded_ddp and FullyShardedDDP is None:\n                raise ImportError(\n                    \"Sharded DDP in a mode other than simple training requires fairscale version >= 0.3, found \"\n                    f\"{fairscale.__version__}. Upgrade your fairscale library: `pip install --upgrade fairscale`.\"\n                )\n            elif ShardedDDPOption.SIMPLE in args.sharded_ddp:\n                self.sharded_ddp = ShardedDDPOption.SIMPLE\n            elif ShardedDDPOption.ZERO_DP_2 in args.sharded_ddp:\n                self.sharded_ddp = ShardedDDPOption.ZERO_DP_2\n            elif ShardedDDPOption.ZERO_DP_3 in args.sharded_ddp:\n                self.sharded_ddp = ShardedDDPOption.ZERO_DP_3\n\n        self.fsdp = None\n        if len(args.fsdp) > 0:\n            if args.deepspeed:\n                raise ValueError(\n                    \"Using --fsdp xxx together with --deepspeed is not possible, deactivate one of those flags.\"\n                )\n            if not args.fsdp_config[\"xla\"] and args.local_rank == -1:\n                raise ValueError(\"Using fsdp only works in distributed training.\")\n\n            # dep_version_check(\"torch>=1.12.0\")\n            # Would have to update setup.py with torch>=1.12.0\n            # which isn't ideally given that it will force people not using FSDP to also use torch>=1.12.0\n            # below is the current alternative.\n            if version.parse(version.parse(torch.__version__).base_version) < version.parse(\"1.12.0\"):\n                raise ValueError(\"FSDP requires PyTorch >= 1.12.0\")\n\n            from torch.distributed.fsdp.fully_sharded_data_parallel import BackwardPrefetch, ShardingStrategy\n\n            if FSDPOption.FULL_SHARD in args.fsdp:\n                self.fsdp = ShardingStrategy.FULL_SHARD\n            elif FSDPOption.SHARD_GRAD_OP in args.fsdp:\n                self.fsdp = ShardingStrategy.SHARD_GRAD_OP\n            elif FSDPOption.NO_SHARD in args.fsdp:\n                self.fsdp = ShardingStrategy.NO_SHARD\n\n            self.backward_prefetch = BackwardPrefetch.BACKWARD_PRE\n            if \"backward_prefetch\" in self.args.fsdp_config and \"backward_pos\" not in self.backward_prefetch:\n                self.backward_prefetch = BackwardPrefetch.BACKWARD_POST\n\n            self.forword_prefetch = False\n            if self.args.fsdp_config.get(\"forword_prefect\", False):\n                self.forword_prefetch = True\n\n            self.limit_all_gathers = False\n            if self.args.fsdp_config.get(\"limit_all_gathers\", False):\n                self.limit_all_gathers = True\n\n        # one place to sort out whether to place the model on device or not\n        # postpone switching model to cuda when:\n        # 1. MP - since we are trying to fit a much bigger than 1 gpu model\n        # 2. fp16-enabled DeepSpeed loads the model in half the size and it doesn't need .to() anyway,\n        #    and we only use deepspeed for training at the moment\n        # 3. full bf16 or fp16 eval - since the model needs to be cast to the right dtype first\n        # 4. Sharded DDP - same as MP\n        # 5. FSDP - same as MP\n        self.place_model_on_device = args.place_model_on_device\n        if (\n            self.is_model_parallel\n            or args.deepspeed\n            or ((args.fp16_full_eval or args.bf16_full_eval) and not args.do_train)\n            or (self.sharded_ddp in [ShardedDDPOption.ZERO_DP_2, ShardedDDPOption.ZERO_DP_3])\n            or (self.fsdp is not None)\n        ):\n            self.place_model_on_device = False\n\n        default_collator = default_data_collator if tokenizer is None else DataCollatorWithPadding(tokenizer)\n        self.data_collator = data_collator if data_collator is not None else default_collator\n        self.train_dataset = train_dataset\n        self.eval_dataset = eval_dataset\n        self.tokenizer = tokenizer\n\n        if self.place_model_on_device and not getattr(model, \"is_loaded_in_8bit\", False):\n            self._move_model_to_device(model, args.device)\n\n        # Force n_gpu to 1 to avoid DataParallel as MP will manage the GPUs\n        if self.is_model_parallel:\n            self.args._n_gpu = 1\n\n        # later use `self.model is self.model_wrapped` to check if it's wrapped or not\n        self.model_wrapped = model\n        self.model = model\n\n        self.compute_metrics = compute_metrics\n        self.preprocess_logits_for_metrics = preprocess_logits_for_metrics\n        self.optimizer, self.lr_scheduler = optimizers\n        if model_init is not None and (self.optimizer is not None or self.lr_scheduler is not None):\n            raise RuntimeError(\n                \"Passing a `model_init` is incompatible with providing the `optimizers` argument. \"\n                \"You should subclass `Trainer` and override the `create_optimizer_and_scheduler` method.\"\n            )\n        if is_torch_tpu_available() and self.optimizer is not None:\n            for param in self.model.parameters():\n                model_device = param.device\n                break\n            for param_group in self.optimizer.param_groups:\n                if len(param_group[\"params\"]) > 0:\n                    optimizer_device = param_group[\"params\"][0].device\n                    break\n            if model_device != optimizer_device:\n                raise ValueError(\n                    \"The model and the optimizer parameters are not on the same device, which probably means you\"\n                    \" created an optimizer around your model **before** putting on the device and passing it to the\"\n                    \" `Trainer`. Make sure the lines `import torch_xla.core.xla_model as xm` and\"\n                    \" `model.to(xm.xla_device())` is performed before the optimizer creation in your script.\"\n                )\n        if ((self.sharded_ddp is not None) or args.deepspeed or (self.fsdp is not None)) and (\n            self.optimizer is not None or self.lr_scheduler is not None\n        ):\n            raise RuntimeError(\n                \"Passing `optimizers` is not allowed if Fairscale, Deepspeed or PyTorch FSDP is enabled.\"\n                \"You should subclass `Trainer` and override the `create_optimizer_and_scheduler` method.\"\n            )\n        default_callbacks = DEFAULT_CALLBACKS + get_reporting_integration_callbacks(self.args.report_to)\n        callbacks = default_callbacks if callbacks is None else default_callbacks + callbacks\n        self.callback_handler = CallbackHandler(\n            callbacks, self.model, self.tokenizer, self.optimizer, self.lr_scheduler\n        )\n        self.add_callback(PrinterCallback if self.args.disable_tqdm else DEFAULT_PROGRESS_CALLBACK)\n\n        # Will be set to True by `self._setup_loggers()` on first call to `self.log()`.\n        self._loggers_initialized = False\n\n        # Create clone of distant repo and output directory if needed\n        if self.args.push_to_hub:\n            self.init_git_repo(at_init=True)\n            # In case of pull, we need to make sure every process has the latest.\n            if is_torch_tpu_available():\n                xm.rendezvous(\"init git repo\")\n            elif args.local_rank != -1:\n                dist.barrier()\n\n        if self.args.should_save:\n            os.makedirs(self.args.output_dir, exist_ok=True)\n\n        if not callable(self.data_collator) and callable(getattr(self.data_collator, \"collate_batch\", None)):\n            raise ValueError(\"The `data_collator` should be a simple callable (function, class with `__call__`).\")\n\n        if args.max_steps > 0:\n            logger.info(\"max_steps is given, it will override any value given in num_train_epochs\")\n\n        if train_dataset is not None and not has_length(train_dataset) and args.max_steps <= 0:\n            raise ValueError(\"train_dataset does not implement __len__, max_steps has to be specified\")\n\n        if (\n            train_dataset is not None\n            and isinstance(train_dataset, torch.utils.data.IterableDataset)\n            and args.group_by_length\n        ):\n            raise ValueError(\"the `--group_by_length` option is only available for `Dataset`, not `IterableDataset\")\n\n        self._signature_columns = None\n\n        # Mixed precision setup\n        self.use_apex = False\n        self.use_cuda_amp = False\n        self.use_cpu_amp = False\n\n        # Mixed precision setup for SageMaker Model Parallel\n        if is_sagemaker_mp_enabled():\n            # BF16 + model parallelism in SageMaker: currently not supported, raise an error\n            if args.bf16:\n                raise ValueError(\"SageMaker Model Parallelism does not support BF16 yet. Please use FP16 instead \")\n\n            if IS_SAGEMAKER_MP_POST_1_10:\n                # When there's mismatch between SMP config and trainer argument, use SMP config as truth\n                if args.fp16 != smp.state.cfg.fp16:\n                    logger.warning(\n                        f\"FP16 provided in SM_HP_MP_PARAMETERS is {smp.state.cfg.fp16},\"\n                        f\"but FP16 provided in trainer argument is {args.fp16},\"\n                        f\"setting to {smp.state.cfg.fp16}\"\n                    )\n                    args.fp16 = smp.state.cfg.fp16\n            else:\n                # smp < 1.10 does not support fp16 in trainer.\n                if hasattr(smp.state.cfg, \"fp16\"):\n                    logger.warning(\n                        f\"FP16 provided in SM_HP_MP_PARAMETERS is {smp.state.cfg.fp16}, \"\n                        \"but SageMaker Model Parallelism < 1.10 does not support FP16 in trainer.\"\n                    )\n\n        if args.fp16 or args.bf16:\n            if args.half_precision_backend == \"auto\":\n                if args.device == torch.device(\"cpu\"):\n                    if args.fp16:\n                        raise ValueError(\"Tried to use `fp16` but it is not supported on cpu\")\n                    elif _is_native_cpu_amp_available:\n                        args.half_precision_backend = \"cpu_amp\"\n                    else:\n                        raise ValueError(\"Tried to use cpu amp but native cpu amp is not available\")\n                else:\n                    args.half_precision_backend = \"cuda_amp\"\n\n            logger.info(f\"Using {args.half_precision_backend} half precision backend\")\n\n        self.do_grad_scaling = False\n        if (args.fp16 or args.bf16) and not (args.deepspeed or is_sagemaker_mp_enabled() or is_torch_tpu_available()):\n            # deepspeed and SageMaker Model Parallel manage their own half precision\n            if args.half_precision_backend == \"cuda_amp\":\n                self.use_cuda_amp = True\n                self.amp_dtype = torch.float16 if args.fp16 else torch.bfloat16\n                #  bf16 does not need grad scaling\n                self.do_grad_scaling = self.amp_dtype == torch.float16\n                if self.do_grad_scaling:\n                    if self.sharded_ddp is not None:\n                        self.scaler = ShardedGradScaler()\n                    elif self.fsdp is not None:\n                        from torch.distributed.fsdp.sharded_grad_scaler import (\n                            ShardedGradScaler as FSDPShardedGradScaler,\n                        )\n\n                        self.scaler = FSDPShardedGradScaler()\n                    elif is_torch_tpu_available():\n                        from torch_xla.amp import GradScaler\n\n                        self.scaler = GradScaler()\n                    else:\n                        self.scaler = torch.cuda.amp.GradScaler()\n            elif args.half_precision_backend == \"cpu_amp\":\n                self.use_cpu_amp = True\n                self.amp_dtype = torch.bfloat16\n            else:\n                if not is_apex_available():\n                    raise ImportError(\n                        \"Using FP16 with APEX but APEX is not installed, please refer to\"\n                        \" https://www.github.com/nvidia/apex.\"\n                    )\n                self.use_apex = True\n\n        # FP16 + model parallelism in SageMaker: gradient clipping does not work for now so we raise a helpful error.\n        if (\n            is_sagemaker_mp_enabled()\n            and self.use_cuda_amp\n            and args.max_grad_norm is not None\n            and args.max_grad_norm > 0\n        ):\n            raise ValueError(\n                \"SageMaker Model Parallelism in mixed precision mode does not support gradient clipping yet. Pass \"\n                \"along 'max_grad_norm': 0 in your hyperparameters.\"\n            )\n\n        # Label smoothing\n        if self.args.label_smoothing_factor != 0:\n            self.label_smoother = LabelSmoother(epsilon=self.args.label_smoothing_factor)\n        else:\n            self.label_smoother = None\n\n        self.state = TrainerState(\n            is_local_process_zero=self.is_local_process_zero(),\n            is_world_process_zero=self.is_world_process_zero(),\n        )\n\n        self.control = TrainerControl()\n        # Internal variable to count flos in each process, will be accumulated in `self.state.total_flos` then\n        # returned to 0 every time flos need to be logged\n        self.current_flos = 0\n        self.hp_search_backend = None\n        self.use_tune_checkpoints = False\n        default_label_names = find_labels(self.model.__class__)\n        self.label_names = default_label_names if self.args.label_names is None else self.args.label_names\n        self.can_return_loss = can_return_loss(self.model.__class__)\n        self.control = self.callback_handler.on_init_end(self.args, self.state, self.control)\n\n        # Internal variables to keep track of the original batch size\n        self._train_batch_size = args.train_batch_size\n\n        # very last\n        self._memory_tracker.stop_and_update_metrics()\n\n        # torch.compile\n        if args.torch_compile and not is_torch_compile_available():\n            raise RuntimeError(\"Using torch.compile requires PyTorch 2.0 or higher.\")\n\n    def add_callback(self, callback):\n        \"\"\"\n        Add a callback to the current list of [`~transformer.TrainerCallback`].\n\n        Args:\n           callback (`type` or [`~transformer.TrainerCallback`]):\n               A [`~transformer.TrainerCallback`] class or an instance of a [`~transformer.TrainerCallback`]. In the\n               first case, will instantiate a member of that class.\n        \"\"\"\n        self.callback_handler.add_callback(callback)\n\n    def pop_callback(self, callback):\n        \"\"\"\n        Remove a callback from the current list of [`~transformer.TrainerCallback`] and returns it.\n\n        If the callback is not found, returns `None` (and no error is raised).\n\n        Args:\n           callback (`type` or [`~transformer.TrainerCallback`]):\n               A [`~transformer.TrainerCallback`] class or an instance of a [`~transformer.TrainerCallback`]. In the\n               first case, will pop the first member of that class found in the list of callbacks.\n\n        Returns:\n            [`~transformer.TrainerCallback`]: The callback removed, if found.\n        \"\"\"\n        return self.callback_handler.pop_callback(callback)\n\n    def remove_callback(self, callback):\n        \"\"\"\n        Remove a callback from the current list of [`~transformer.TrainerCallback`].\n\n        Args:\n           callback (`type` or [`~transformer.TrainerCallback`]):\n               A [`~transformer.TrainerCallback`] class or an instance of a [`~transformer.TrainerCallback`]. In the\n               first case, will remove the first member of that class found in the list of callbacks.\n        \"\"\"\n        self.callback_handler.remove_callback(callback)\n\n    def _move_model_to_device(self, model, device):\n        model = model.to(device)\n        # Moving a model to an XLA device disconnects the tied weights, so we have to retie them.\n        if self.args.parallel_mode == ParallelMode.TPU and hasattr(model, \"tie_weights\"):\n            model.tie_weights()\n\n    def _set_signature_columns_if_needed(self):\n        if self._signature_columns is None:\n            # Inspect model forward signature to keep only the arguments it accepts.\n            signature = inspect.signature(self.model.forward)\n            self._signature_columns = list(signature.parameters.keys())\n            # Labels may be named label or label_ids, the default data collator handles that.\n            self._signature_columns += list(set([\"label\", \"label_ids\"] + self.label_names))\n\n    def _remove_unused_columns(self, dataset: \"datasets.Dataset\", description: Optional[str] = None):\n        if not self.args.remove_unused_columns:\n            return dataset\n        self._set_signature_columns_if_needed()\n        signature_columns = self._signature_columns\n\n        ignored_columns = list(set(dataset.column_names) - set(signature_columns))\n        if len(ignored_columns) > 0:\n            dset_description = \"\" if description is None else f\"in the {description} set\"\n            logger.info(\n                f\"The following columns {dset_description} don't have a corresponding argument in \"\n                f\"`{self.model.__class__.__name__}.forward` and have been ignored: {', '.join(ignored_columns)}.\"\n                f\" If {', '.join(ignored_columns)} are not expected by `{self.model.__class__.__name__}.forward`, \"\n                \" you can safely ignore this message.\"\n            )\n\n        columns = [k for k in signature_columns if k in dataset.column_names]\n\n        if version.parse(datasets.__version__) < version.parse(\"1.4.0\"):\n            dataset.set_format(\n                type=dataset.format[\"type\"], columns=columns, format_kwargs=dataset.format[\"format_kwargs\"]\n            )\n            return dataset\n        else:\n            return dataset.remove_columns(ignored_columns)\n\n    def _get_collator_with_removed_columns(\n        self, data_collator: Callable, description: Optional[str] = None\n    ) -> Callable:\n        \"\"\"Wrap the data collator in a callable removing unused columns.\"\"\"\n        if not self.args.remove_unused_columns:\n            return data_collator\n        self._set_signature_columns_if_needed()\n        signature_columns = self._signature_columns\n\n        remove_columns_collator = RemoveColumnsCollator(\n            data_collator=data_collator,\n            signature_columns=signature_columns,\n            logger=logger,\n            description=description,\n            model_name=self.model.__class__.__name__,\n        )\n        return remove_columns_collator\n\n    def _get_train_sampler(self) -> Optional[torch.utils.data.Sampler]:\n        if self.train_dataset is None or not has_length(self.train_dataset):\n            return None\n\n        generator = None\n        if self.args.world_size <= 1:\n            generator = torch.Generator()\n            # for backwards compatibility, we generate a seed here (which is sampled from a generator seeded with\n            # `args.seed`) if data_seed isn't provided.\n            # Further on in this method, we default to `args.seed` instead.\n            if self.args.data_seed is None:\n                seed = int(torch.empty((), dtype=torch.int64).random_().item())\n            else:\n                seed = self.args.data_seed\n            generator.manual_seed(seed)\n\n        seed = self.args.data_seed if self.args.data_seed is not None else self.args.seed\n\n        # Build the sampler.\n        if self.args.group_by_length:\n            if is_datasets_available() and isinstance(self.train_dataset, datasets.Dataset):\n                lengths = (\n                    self.train_dataset[self.args.length_column_name]\n                    if self.args.length_column_name in self.train_dataset.column_names\n                    else None\n                )\n            else:\n                lengths = None\n            model_input_name = self.tokenizer.model_input_names[0] if self.tokenizer is not None else None\n            if self.args.world_size <= 1:\n                return LengthGroupedSampler(\n                    self.args.train_batch_size * self.args.gradient_accumulation_steps,\n                    dataset=self.train_dataset,\n                    lengths=lengths,\n                    model_input_name=model_input_name,\n                    generator=generator,\n                )\n            else:\n                return DistributedLengthGroupedSampler(\n                    self.args.train_batch_size * self.args.gradient_accumulation_steps,\n                    dataset=self.train_dataset,\n                    num_replicas=self.args.world_size,\n                    rank=self.args.process_index,\n                    lengths=lengths,\n                    model_input_name=model_input_name,\n                    seed=seed,\n                )\n\n        else:\n            if self.args.world_size <= 1:\n                return RandomSampler(self.train_dataset, generator=generator)\n            elif (\n                self.args.parallel_mode in [ParallelMode.TPU, ParallelMode.SAGEMAKER_MODEL_PARALLEL]\n                and not self.args.dataloader_drop_last\n            ):\n                # Use a loop for TPUs when drop_last is False to have all batches have the same size.\n                return DistributedSamplerWithLoop(\n                    self.train_dataset,\n                    batch_size=self.args.per_device_train_batch_size,\n                    num_replicas=self.args.world_size,\n                    rank=self.args.process_index,\n                    seed=seed,\n                )\n            else:\n                return DistributedSampler(\n                    self.train_dataset,\n                    num_replicas=self.args.world_size,\n                    rank=self.args.process_index,\n                    seed=seed,\n                )\n\n    def get_train_dataloader(self) -> DataLoader:\n        \"\"\"\n        Returns the training [`~torch.utils.data.DataLoader`].\n\n        Will use no sampler if `train_dataset` does not implement `__len__`, a random sampler (adapted to distributed\n        training if necessary) otherwise.\n\n        Subclass and override this method if you want to inject some custom behavior.\n        \"\"\"\n        if self.train_dataset is None:\n            raise ValueError(\"Trainer: training requires a train_dataset.\")\n\n        train_dataset = self.train_dataset\n        data_collator = self.data_collator\n        if is_datasets_available() and isinstance(train_dataset, datasets.Dataset):\n            train_dataset = self._remove_unused_columns(train_dataset, description=\"training\")\n        else:\n            data_collator = self._get_collator_with_removed_columns(data_collator, description=\"training\")\n\n        if isinstance(train_dataset, torch.utils.data.IterableDataset):\n            if self.args.world_size > 1:\n                train_dataset = IterableDatasetShard(\n                    train_dataset,\n                    batch_size=self._train_batch_size,\n                    drop_last=self.args.dataloader_drop_last,\n                    num_processes=self.args.world_size,\n                    process_index=self.args.process_index,\n                )\n\n            return DataLoader(\n                train_dataset,\n                batch_size=self._train_batch_size,\n                collate_fn=data_collator,\n                num_workers=self.args.dataloader_num_workers,\n                pin_memory=self.args.dataloader_pin_memory,\n            )\n\n        train_sampler = self._get_train_sampler()\n\n        return DataLoader(\n            train_dataset,\n            batch_size=self._train_batch_size,\n            sampler=train_sampler,\n            collate_fn=data_collator,\n            drop_last=self.args.dataloader_drop_last,\n            num_workers=self.args.dataloader_num_workers,\n            pin_memory=self.args.dataloader_pin_memory,\n            worker_init_fn=seed_worker,\n        )\n\n    def _get_eval_sampler(self, eval_dataset: Dataset) -> Optional[torch.utils.data.Sampler]:\n        # Deprecated code\n        if self.args.use_legacy_prediction_loop:\n            if is_torch_tpu_available():\n                return SequentialDistributedSampler(\n                    eval_dataset, num_replicas=xm.xrt_world_size(), rank=xm.get_ordinal()\n                )\n            elif is_sagemaker_mp_enabled():\n                return SequentialDistributedSampler(\n                    eval_dataset,\n                    num_replicas=smp.dp_size(),\n                    rank=smp.dp_rank(),\n                    batch_size=self.args.per_device_eval_batch_size,\n                )\n            elif self.args.local_rank != -1:\n                return SequentialDistributedSampler(eval_dataset)\n            else:\n                return SequentialSampler(eval_dataset)\n\n        if self.args.world_size <= 1:\n            return SequentialSampler(eval_dataset)\n        else:\n            return ShardSampler(\n                eval_dataset,\n                batch_size=self.args.per_device_eval_batch_size,\n                num_processes=self.args.world_size,\n                process_index=self.args.process_index,\n            )\n\n    def get_eval_dataloader(self, eval_dataset: Optional[Dataset] = None) -> DataLoader:\n        \"\"\"\n        Returns the evaluation [`~torch.utils.data.DataLoader`].\n\n        Subclass and override this method if you want to inject some custom behavior.\n\n        Args:\n            eval_dataset (`torch.utils.data.Dataset`, *optional*):\n                If provided, will override `self.eval_dataset`. If it is a [`~datasets.Dataset`], columns not accepted\n                by the `model.forward()` method are automatically removed. It must implement `__len__`.\n        \"\"\"\n        if eval_dataset is None and self.eval_dataset is None:\n            raise ValueError(\"Trainer: evaluation requires an eval_dataset.\")\n        eval_dataset = eval_dataset if eval_dataset is not None else self.eval_dataset\n        data_collator = self.data_collator\n\n        if is_datasets_available() and isinstance(eval_dataset, datasets.Dataset):\n            eval_dataset = self._remove_unused_columns(eval_dataset, description=\"evaluation\")\n        else:\n            data_collator = self._get_collator_with_removed_columns(data_collator, description=\"evaluation\")\n\n        if isinstance(eval_dataset, torch.utils.data.IterableDataset):\n            if self.args.world_size > 1:\n                eval_dataset = IterableDatasetShard(\n                    eval_dataset,\n                    batch_size=self.args.per_device_eval_batch_size,\n                    drop_last=self.args.dataloader_drop_last,\n                    num_processes=self.args.world_size,\n                    process_index=self.args.process_index,\n                )\n            return DataLoader(\n                eval_dataset,\n                batch_size=self.args.eval_batch_size,\n                collate_fn=data_collator,\n                num_workers=self.args.dataloader_num_workers,\n                pin_memory=self.args.dataloader_pin_memory,\n            )\n\n        eval_sampler = self._get_eval_sampler(eval_dataset)\n\n        return DataLoader(\n            eval_dataset,\n            sampler=eval_sampler,\n            batch_size=self.args.eval_batch_size,\n            collate_fn=data_collator,\n            drop_last=self.args.dataloader_drop_last,\n            num_workers=self.args.dataloader_num_workers,\n            pin_memory=self.args.dataloader_pin_memory,\n        )\n\n    def get_test_dataloader(self, test_dataset: Dataset) -> DataLoader:\n        \"\"\"\n        Returns the test [`~torch.utils.data.DataLoader`].\n\n        Subclass and override this method if you want to inject some custom behavior.\n\n        Args:\n            test_dataset (`torch.utils.data.Dataset`, *optional*):\n                The test dataset to use. If it is a [`~datasets.Dataset`], columns not accepted by the\n                `model.forward()` method are automatically removed. It must implement `__len__`.\n        \"\"\"\n        data_collator = self.data_collator\n\n        if is_datasets_available() and isinstance(test_dataset, datasets.Dataset):\n            test_dataset = self._remove_unused_columns(test_dataset, description=\"test\")\n        else:\n            data_collator = self._get_collator_with_removed_columns(data_collator, description=\"test\")\n\n        if isinstance(test_dataset, torch.utils.data.IterableDataset):\n            if self.args.world_size > 1:\n                test_dataset = IterableDatasetShard(\n                    test_dataset,\n                    batch_size=self.args.eval_batch_size,\n                    drop_last=self.args.dataloader_drop_last,\n                    num_processes=self.args.world_size,\n                    process_index=self.args.process_index,\n                )\n            return DataLoader(\n                test_dataset,\n                batch_size=self.args.eval_batch_size,\n                collate_fn=data_collator,\n                num_workers=self.args.dataloader_num_workers,\n                pin_memory=self.args.dataloader_pin_memory,\n            )\n\n        test_sampler = self._get_eval_sampler(test_dataset)\n\n        # We use the same batch_size as for eval.\n        return DataLoader(\n            test_dataset,\n            sampler=test_sampler,\n            batch_size=self.args.eval_batch_size,\n            collate_fn=data_collator,\n            drop_last=self.args.dataloader_drop_last,\n            num_workers=self.args.dataloader_num_workers,\n            pin_memory=self.args.dataloader_pin_memory,\n        )\n\n    def create_optimizer_and_scheduler(self, num_training_steps: int):\n        \"\"\"\n        Setup the optimizer and the learning rate scheduler.\n\n        We provide a reasonable default that works well. If you want to use something else, you can pass a tuple in the\n        Trainer's init through `optimizers`, or subclass and override this method (or `create_optimizer` and/or\n        `create_scheduler`) in a subclass.\n        \"\"\"\n        self.create_optimizer()\n        if IS_SAGEMAKER_MP_POST_1_10 and smp.state.cfg.fp16:\n            # If smp >= 1.10 and fp16 is enabled, we unwrap the optimizer\n            optimizer = self.optimizer.optimizer\n        else:\n            optimizer = self.optimizer\n        self.create_scheduler(num_training_steps=num_training_steps, optimizer=optimizer)\n\n    def create_optimizer(self):\n        \"\"\"\n        Setup the optimizer.\n\n        We provide a reasonable default that works well. If you want to use something else, you can pass a tuple in the\n        Trainer's init through `optimizers`, or subclass and override this method in a subclass.\n        \"\"\"\n        opt_model = self.model_wrapped if is_sagemaker_mp_enabled() else self.model\n\n        if self.optimizer is None:\n            decay_parameters = get_parameter_names(opt_model, ALL_LAYERNORM_LAYERS)\n            decay_parameters = [name for name in decay_parameters if \"bias\" not in name]\n            optimizer_grouped_parameters = [\n                {\n                    \"params\": [\n                        p for n, p in opt_model.named_parameters() if (n in decay_parameters and p.requires_grad)\n                    ],\n                    \"weight_decay\": self.args.weight_decay,\n                },\n                {\n                    \"params\": [\n                        p for n, p in opt_model.named_parameters() if (n not in decay_parameters and p.requires_grad)\n                    ],\n                    \"weight_decay\": 0.0,\n                },\n            ]\n\n            optimizer_cls, optimizer_kwargs = Trainer.get_optimizer_cls_and_kwargs(self.args)\n\n            if self.sharded_ddp == ShardedDDPOption.SIMPLE:\n                self.optimizer = OSS(\n                    params=optimizer_grouped_parameters,\n                    optim=optimizer_cls,\n                    **optimizer_kwargs,\n                )\n            else:\n                self.optimizer = optimizer_cls(optimizer_grouped_parameters, **optimizer_kwargs)\n                if optimizer_cls.__name__ == \"Adam8bit\":\n                    import bitsandbytes\n\n                    manager = bitsandbytes.optim.GlobalOptimManager.get_instance()\n\n                    skipped = 0\n                    for module in opt_model.modules():\n                        if isinstance(module, nn.Embedding):\n                            skipped += sum({p.data_ptr(): p.numel() for p in module.parameters()}.values())\n                            print(f\"skipped {module}: {skipped/2**20}M params\")\n                            manager.register_module_override(module, \"weight\", {\"optim_bits\": 32})\n                            logger.debug(f\"bitsandbytes: will optimize {module} in fp32\")\n                    print(f\"skipped: {skipped/2**20}M params\")\n\n        if is_sagemaker_mp_enabled():\n            self.optimizer = smp.DistributedOptimizer(self.optimizer)\n\n        return self.optimizer\n\n    @staticmethod\n    def get_optimizer_cls_and_kwargs(args: TrainingArguments) -> Tuple[Any, Any]:\n        \"\"\"\n        Returns the optimizer class and optimizer parameters based on the training arguments.\n\n        Args:\n            args (`transformers.training_args.TrainingArguments`):\n                The training arguments for the training session.\n\n        \"\"\"\n\n        # parse args.optim_args\n        optim_args = {}\n        if args.optim_args:\n            for mapping in args.optim_args.replace(\" \", \"\").split(\",\"):\n                key, value = mapping.split(\"=\")\n                optim_args[key] = value\n\n        optimizer_kwargs = {\"lr\": args.learning_rate}\n\n        adam_kwargs = {\n            \"betas\": (args.adam_beta1, args.adam_beta2),\n            \"eps\": args.adam_epsilon,\n        }\n        if args.optim == OptimizerNames.ADAFACTOR:\n            optimizer_cls = Adafactor\n            optimizer_kwargs.update({\"scale_parameter\": False, \"relative_step\": False})\n        elif args.optim == OptimizerNames.ADAMW_HF:\n            from transformers.optimization import AdamW\n\n            optimizer_cls = AdamW\n            optimizer_kwargs.update(adam_kwargs)\n        elif args.optim in [OptimizerNames.ADAMW_TORCH, OptimizerNames.ADAMW_TORCH_FUSED]:\n            from torch.optim import AdamW\n\n            optimizer_cls = AdamW\n            optimizer_kwargs.update(adam_kwargs)\n            if args.optim == OptimizerNames.ADAMW_TORCH_FUSED:\n                optimizer_kwargs.update({\"fused\": True})\n        elif args.optim == OptimizerNames.ADAMW_TORCH_XLA:\n            try:\n                from torch_xla.amp.syncfree import AdamW\n\n                optimizer_cls = AdamW\n                optimizer_kwargs.update(adam_kwargs)\n            except ImportError:\n                raise ValueError(\"Trainer failed to import syncfree AdamW from torch_xla.\")\n        elif args.optim == OptimizerNames.ADAMW_APEX_FUSED:\n            try:\n                from apex.optimizers import FusedAdam\n\n                optimizer_cls = FusedAdam\n                optimizer_kwargs.update(adam_kwargs)\n            except ImportError:\n                raise ValueError(\"Trainer tried to instantiate apex FusedAdam but apex is not installed!\")\n        elif args.optim == OptimizerNames.ADAMW_BNB:\n            try:\n                from bitsandbytes.optim import Adam8bit\n\n                optimizer_cls = Adam8bit\n                optimizer_kwargs.update(adam_kwargs)\n            except ImportError:\n                raise ValueError(\"Trainer tried to instantiate bnb Adam8bit but bnb is not installed!\")\n        elif args.optim == OptimizerNames.ADAMW_ANYPRECISION:\n            try:\n                from torchdistx.optimizers import AnyPrecisionAdamW\n\n                optimizer_cls = AnyPrecisionAdamW\n                optimizer_kwargs.update(adam_kwargs)\n\n                # TODO Change dtypes back to M=FP32, Var = BF16, Kahan = False once they can be cast together in torchdistx.\n                optimizer_kwargs.update(\n                    {\n                        \"use_kahan_summation\": strtobool(optim_args.get(\"use_kahan_summation\", \"False\")),\n                        \"momentum_dtype\": getattr(torch, optim_args.get(\"momentum_dtype\", \"float32\")),\n                        \"variance_dtype\": getattr(torch, optim_args.get(\"variance_dtype\", \"float32\")),\n                        \"compensation_buffer_dtype\": getattr(\n                            torch, optim_args.get(\"compensation_buffer_dtype\", \"bfloat16\")\n                        ),\n                    }\n                )\n            except ImportError:\n                raise ValueError(\"Please install https://github.com/pytorch/torchdistx\")\n        elif args.optim == OptimizerNames.SGD:\n            optimizer_cls = torch.optim.SGD\n        elif args.optim == OptimizerNames.ADAGRAD:\n            optimizer_cls = torch.optim.Adagrad\n        else:\n            raise ValueError(f\"Trainer cannot instantiate unsupported optimizer: {args.optim}\")\n        return optimizer_cls, optimizer_kwargs\n\n    def create_scheduler(self, num_training_steps: int, optimizer: torch.optim.Optimizer = None):\n        \"\"\"\n        Setup the scheduler. The optimizer of the trainer must have been set up either before this method is called or\n        passed as an argument.\n\n        Args:\n            num_training_steps (int): The number of training steps to do.\n        \"\"\"\n        if self.lr_scheduler is None:\n            self.lr_scheduler = get_scheduler(\n                self.args.lr_scheduler_type,\n                optimizer=self.optimizer if optimizer is None else optimizer,\n                num_warmup_steps=self.args.get_warmup_steps(num_training_steps),\n                num_training_steps=num_training_steps,\n            )\n        return self.lr_scheduler\n\n    def num_examples(self, dataloader: DataLoader) -> int:\n        \"\"\"\n        Helper to get number of samples in a [`~torch.utils.data.DataLoader`] by accessing its dataset. When\n        dataloader.dataset does not exist or has no length, estimates as best it can\n        \"\"\"\n        try:\n            dataset = dataloader.dataset\n            # Special case for IterableDatasetShard, we need to dig deeper\n            if isinstance(dataset, IterableDatasetShard):\n                return len(dataloader.dataset.dataset)\n            return len(dataloader.dataset)\n        except (NameError, AttributeError, TypeError):  # no dataset or length, estimate by length of dataloader\n            return len(dataloader) * self.args.per_device_train_batch_size\n\n    def _hp_search_setup(self, trial: Union[\"optuna.Trial\", Dict[str, Any]]):\n        \"\"\"HP search setup code\"\"\"\n        self._trial = trial\n\n        if self.hp_search_backend is None or trial is None:\n            return\n        if self.hp_search_backend == HPSearchBackend.OPTUNA:\n            params = self.hp_space(trial)\n        elif self.hp_search_backend == HPSearchBackend.RAY:\n            params = trial\n            params.pop(\"wandb\", None)\n        elif self.hp_search_backend == HPSearchBackend.SIGOPT:\n            params = {k: int(v) if isinstance(v, str) else v for k, v in trial.assignments.items()}\n        elif self.hp_search_backend == HPSearchBackend.WANDB:\n            params = trial\n\n        for key, value in params.items():\n            if not hasattr(self.args, key):\n                logger.warning(\n                    f\"Trying to set {key} in the hyperparameter search but there is no corresponding field in\"\n                    \" `TrainingArguments`.\"\n                )\n                continue\n            old_attr = getattr(self.args, key, None)\n            # Casting value to the proper type\n            if old_attr is not None:\n                value = type(old_attr)(value)\n            setattr(self.args, key, value)\n        if self.hp_search_backend == HPSearchBackend.OPTUNA:\n            logger.info(f\"Trial: {trial.params}\")\n        if self.hp_search_backend == HPSearchBackend.SIGOPT:\n            logger.info(f\"SigOpt Assignments: {trial.assignments}\")\n        if self.hp_search_backend == HPSearchBackend.WANDB:\n            logger.info(f\"W&B Sweep parameters: {trial}\")\n        if self.args.deepspeed:\n            # Rebuild the deepspeed config to reflect the updated training parameters\n            from transformers.deepspeed import HfTrainerDeepSpeedConfig\n\n            self.args.hf_deepspeed_config = HfTrainerDeepSpeedConfig(self.args.deepspeed)\n            self.args.hf_deepspeed_config.trainer_config_process(self.args)\n\n    def _report_to_hp_search(self, trial: Union[\"optuna.Trial\", Dict[str, Any]], step: int, metrics: Dict[str, float]):\n        if self.hp_search_backend is None or trial is None:\n            return\n        self.objective = self.compute_objective(metrics.copy())\n        if self.hp_search_backend == HPSearchBackend.OPTUNA:\n            import optuna\n\n            trial.report(self.objective, step)\n            if trial.should_prune():\n                self.callback_handler.on_train_end(self.args, self.state, self.control)\n                raise optuna.TrialPruned()\n        elif self.hp_search_backend == HPSearchBackend.RAY:\n            from ray import tune\n\n            if self.control.should_save:\n                self._tune_save_checkpoint()\n            tune.report(objective=self.objective, **metrics)\n\n    def _tune_save_checkpoint(self):\n        from ray import tune\n\n        if not self.use_tune_checkpoints:\n            return\n        with tune.checkpoint_dir(step=self.state.global_step) as checkpoint_dir:\n            output_dir = os.path.join(checkpoint_dir, f\"{PREFIX_CHECKPOINT_DIR}-{self.state.global_step}\")\n            self.save_model(output_dir, _internal_call=True)\n            if self.args.should_save:\n                self.state.save_to_json(os.path.join(output_dir, TRAINER_STATE_NAME))\n                torch.save(self.optimizer.state_dict(), os.path.join(output_dir, OPTIMIZER_NAME))\n                torch.save(self.lr_scheduler.state_dict(), os.path.join(output_dir, SCHEDULER_NAME))\n\n    def call_model_init(self, trial=None):\n        model_init_argcount = number_of_arguments(self.model_init)\n        if model_init_argcount == 0:\n            model = self.model_init()\n        elif model_init_argcount == 1:\n            model = self.model_init(trial)\n        else:\n            raise RuntimeError(\"model_init should have 0 or 1 argument.\")\n\n        if model is None:\n            raise RuntimeError(\"model_init should not return None.\")\n\n        return model\n\n    def torch_jit_model_eval(self, model, dataloader, training=False):\n        if not training:\n            if dataloader is None:\n                logger.warning(\"failed to use PyTorch jit mode due to current dataloader is none.\")\n                return model\n            example_batch = next(iter(dataloader))\n            example_batch = self._prepare_inputs(example_batch)\n            try:\n                jit_model = model.eval()\n                with ContextManagers([self.autocast_smart_context_manager(cache_enabled=False), torch.no_grad()]):\n                    if version.parse(version.parse(torch.__version__).base_version) >= version.parse(\"1.14.0\"):\n                        if isinstance(example_batch, dict):\n                            jit_model = torch.jit.trace(jit_model, example_kwarg_inputs=example_batch, strict=False)\n                        else:\n                            jit_model = torch.jit.trace(\n                                jit_model,\n                                example_kwarg_inputs={key: example_batch[key] for key in example_batch},\n                                strict=False,\n                            )\n                    else:\n                        jit_inputs = []\n                        for key in example_batch:\n                            example_tensor = torch.ones_like(example_batch[key])\n                            jit_inputs.append(example_tensor)\n                        jit_inputs = tuple(jit_inputs)\n                        jit_model = torch.jit.trace(jit_model, jit_inputs, strict=False)\n                jit_model = torch.jit.freeze(jit_model)\n                with torch.no_grad():\n                    jit_model(**example_batch)\n                    jit_model(**example_batch)\n                model = jit_model\n                self.use_cpu_amp = False\n                self.use_cuda_amp = False\n            except (RuntimeError, TypeError, ValueError, NameError, IndexError) as e:\n                logger.warning(f\"failed to use PyTorch jit mode due to: {e}.\")\n\n        return model\n\n    def ipex_optimize_model(self, model, training=False, dtype=torch.float32):\n        if not is_ipex_available():\n            raise ImportError(\n                \"Using IPEX but IPEX is not installed or IPEX's version does not match current PyTorch, please refer\"\n                \" to https://github.com/intel/intel-extension-for-pytorch.\"\n            )\n\n        import intel_extension_for_pytorch as ipex\n\n        if not training:\n            model.eval()\n            dtype = torch.bfloat16 if not self.is_in_train and self.args.bf16_full_eval else dtype\n            # conv_bn_folding is disabled as it fails in symbolic tracing, resulting in ipex warnings\n            model = ipex.optimize(model, dtype=dtype, level=\"O1\", conv_bn_folding=False, inplace=not self.is_in_train)\n        else:\n            if not model.training:\n                model.train()\n            model, self.optimizer = ipex.optimize(\n                model, dtype=dtype, optimizer=self.optimizer, inplace=True, level=\"O1\"\n            )\n\n        return model\n\n    def _wrap_model(self, model, training=True, dataloader=None):\n        if self.args.torch_compile:\n            model = torch.compile(model, backend=self.args.torch_compile_backend, mode=self.args.torch_compile_mode)\n\n        if self.args.use_ipex:\n            dtype = torch.bfloat16 if self.use_cpu_amp else torch.float32\n            model = self.ipex_optimize_model(model, training, dtype=dtype)\n\n        if is_sagemaker_mp_enabled():\n            # Wrapping the base model twice in a DistributedModel will raise an error.\n            if isinstance(self.model_wrapped, smp.model.DistributedModel):\n                return self.model_wrapped\n            return smp.DistributedModel(model, backward_passes_per_step=self.args.gradient_accumulation_steps)\n\n        # already initialized its own DDP and AMP\n        if self.deepspeed:\n            return self.deepspeed\n\n        # train/eval could be run multiple-times - if already wrapped, don't re-wrap it again\n        if unwrap_model(model) is not model:\n            return model\n\n        # Mixed precision training with apex (torch < 1.6)\n        if self.use_apex and training:\n            model, self.optimizer = amp.initialize(model, self.optimizer, opt_level=self.args.fp16_opt_level)\n\n        # Multi-gpu training (should be after apex fp16 initialization)\n        if self.args.n_gpu > 1:\n            model = nn.DataParallel(model)\n\n        if self.args.jit_mode_eval:\n            start_time = time.time()\n            model = self.torch_jit_model_eval(model, dataloader, training)\n            self.jit_compilation_time = round(time.time() - start_time, 4)\n\n        # Note: in torch.distributed mode, there's no point in wrapping the model\n        # inside a DistributedDataParallel as we'll be under `no_grad` anyways.\n        if not training:\n            return model\n\n        # Distributed training (should be after apex fp16 initialization)\n        if self.sharded_ddp is not None:\n            # Sharded DDP!\n            if self.sharded_ddp == ShardedDDPOption.SIMPLE:\n                model = ShardedDDP(model, self.optimizer)\n            else:\n                mixed_precision = self.args.fp16 or self.args.bf16\n                cpu_offload = ShardedDDPOption.OFFLOAD in self.args.sharded_ddp\n                zero_3 = self.sharded_ddp == ShardedDDPOption.ZERO_DP_3\n                # XXX: Breaking the self.model convention but I see no way around it for now.\n                if ShardedDDPOption.AUTO_WRAP in self.args.sharded_ddp:\n                    model = auto_wrap(model)\n                self.model = model = FullyShardedDDP(\n                    model,\n                    mixed_precision=mixed_precision,\n                    reshard_after_forward=zero_3,\n                    cpu_offload=cpu_offload,\n                ).to(self.args.device)\n        # Distributed training using PyTorch FSDP\n        elif self.fsdp is not None:\n            if not self.args.fsdp_config[\"xla\"]:\n                # PyTorch FSDP!\n                from torch.distributed.fsdp.fully_sharded_data_parallel import CPUOffload, MixedPrecision\n                from torch.distributed.fsdp.fully_sharded_data_parallel import FullyShardedDataParallel as FSDP\n                from torch.distributed.fsdp.wrap import size_based_auto_wrap_policy, transformer_auto_wrap_policy\n\n                if FSDPOption.OFFLOAD in self.args.fsdp:\n                    cpu_offload = CPUOffload(offload_params=True)\n                else:\n                    cpu_offload = CPUOffload(offload_params=False)\n\n                auto_wrap_policy = None\n\n                if FSDPOption.AUTO_WRAP in self.args.fsdp:\n                    if self.args.fsdp_config[\"fsdp_min_num_params\"] > 0:\n                        auto_wrap_policy = functools.partial(\n                            size_based_auto_wrap_policy, min_num_params=self.args.fsdp_config[\"fsdp_min_num_params\"]\n                        )\n                    elif self.args.fsdp_config.get(\"fsdp_transformer_layer_cls_to_wrap\", None) is not None:\n                        transformer_cls_to_wrap = set()\n                        for layer_class in self.args.fsdp_config[\"fsdp_transformer_layer_cls_to_wrap\"]:\n                            transformer_cls = get_module_class_from_name(model, layer_class)\n                            if transformer_cls is None:\n                                raise Exception(\"Could not find the transformer layer class to wrap in the model.\")\n                            else:\n                                transformer_cls_to_wrap.add(transformer_cls)\n                        auto_wrap_policy = functools.partial(\n                            transformer_auto_wrap_policy,\n                            # Transformer layer class to wrap\n                            transformer_layer_cls=transformer_cls_to_wrap,\n                        )\n                mixed_precision_policy = None\n                dtype = None\n                if self.args.fp16:\n                    dtype = torch.float16\n                elif self.args.bf16:\n                    dtype = torch.bfloat16\n                if dtype is not None:\n                    mixed_precision_policy = MixedPrecision(param_dtype=dtype, reduce_dtype=dtype, buffer_dtype=dtype)\n                if type(model) != FSDP:\n                    # XXX: Breaking the self.model convention but I see no way around it for now.\n                    self.model = model = FSDP(\n                        model,\n                        sharding_strategy=self.fsdp,\n                        cpu_offload=cpu_offload,\n                        auto_wrap_policy=auto_wrap_policy,\n                        mixed_precision=mixed_precision_policy,\n                        device_id=self.args.device,\n                        backward_prefetch=self.backward_prefetch,\n                        forward_prefetch=self.forword_prefetch,\n                        limit_all_gathers=self.limit_all_gathers,\n                    )\n            else:\n                try:\n                    from torch_xla.distributed.fsdp import XlaFullyShardedDataParallel as FSDP\n                    from torch_xla.distributed.fsdp import checkpoint_module\n                    from torch_xla.distributed.fsdp.wrap import (\n                        size_based_auto_wrap_policy,\n                        transformer_auto_wrap_policy,\n                    )\n                except ImportError:\n                    raise ImportError(\"Missing XLA FSDP related module; please make sure to use torch-xla >= 2.0.\")\n                auto_wrap_policy = None\n                auto_wrapper_callable = None\n                if self.args.fsdp_config[\"fsdp_min_num_params\"] > 0:\n                    auto_wrap_policy = functools.partial(\n                        size_based_auto_wrap_policy, min_num_params=self.args.fsdp_config[\"fsdp_min_num_params\"]\n                    )\n                elif self.args.fsdp_config.get(\"fsdp_transformer_layer_cls_to_wrap\", None) is not None:\n                    transformer_cls_to_wrap = set()\n                    for layer_class in self.args.fsdp_config[\"fsdp_transformer_layer_cls_to_wrap\"]:\n                        transformer_cls = get_module_class_from_name(model, layer_class)\n                        if transformer_cls is None:\n                            raise Exception(\"Could not find the transformer layer class to wrap in the model.\")\n                        else:\n                            transformer_cls_to_wrap.add(transformer_cls)\n                    auto_wrap_policy = functools.partial(\n                        transformer_auto_wrap_policy,\n                        # Transformer layer class to wrap\n                        transformer_layer_cls=transformer_cls_to_wrap,\n                    )\n                fsdp_kwargs = self.args.xla_fsdp_config\n                if self.args.fsdp_config[\"xla_fsdp_grad_ckpt\"]:\n                    # Apply gradient checkpointing to auto-wrapped sub-modules if specified\n                    def auto_wrapper_callable(m, *args, **kwargs):\n                        return FSDP(checkpoint_module(m), *args, **kwargs)\n\n                # Wrap the base model with an outer FSDP wrapper\n                self.model = model = FSDP(\n                    model,\n                    auto_wrap_policy=auto_wrap_policy,\n                    auto_wrapper_callable=auto_wrapper_callable,\n                    **fsdp_kwargs,\n                )\n\n                # Patch `xm.optimizer_step` should not reduce gradients in this case,\n                # as FSDP does not need gradient reduction over sharded parameters.\n                def patched_optimizer_step(optimizer, barrier=False, optimizer_args={}):\n                    loss = optimizer.step(**optimizer_args)\n                    if barrier:\n                        xm.mark_step()\n                    return loss\n\n                xm.optimizer_step = patched_optimizer_step\n        elif is_sagemaker_dp_enabled():\n            model = nn.parallel.DistributedDataParallel(\n                model, device_ids=[int(os.getenv(\"SMDATAPARALLEL_LOCAL_RANK\"))]\n            )\n        elif self.args.local_rank != -1:\n            kwargs = {}\n            if self.args.ddp_find_unused_parameters is not None:\n                kwargs[\"find_unused_parameters\"] = self.args.ddp_find_unused_parameters\n            elif isinstance(model, PreTrainedModel):\n                # find_unused_parameters breaks checkpointing as per\n                # https://github.com/huggingface/transformers/pull/4659#issuecomment-643356021\n                kwargs[\"find_unused_parameters\"] = not model.is_gradient_checkpointing\n            else:\n                kwargs[\"find_unused_parameters\"] = True\n\n            if self.args.ddp_bucket_cap_mb is not None:\n                kwargs[\"bucket_cap_mb\"] = self.args.ddp_bucket_cap_mb\n            if is_torch_neuroncore_available():\n                return model\n            model = nn.parallel.DistributedDataParallel(\n                model,\n                device_ids=[self.args.local_rank] if self.args._n_gpu != 0 else None,\n                output_device=self.args.local_rank if self.args._n_gpu != 0 else None,\n                **kwargs,\n            )\n\n        return model\n\n    def train(\n        self,\n        resume_from_checkpoint: Optional[Union[str, bool]] = None,\n        trial: Union[\"optuna.Trial\", Dict[str, Any]] = None,\n        ignore_keys_for_eval: Optional[List[str]] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Main training entry point.\n\n        Args:\n            resume_from_checkpoint (`str` or `bool`, *optional*):\n                If a `str`, local path to a saved checkpoint as saved by a previous instance of [`Trainer`]. If a\n                `bool` and equals `True`, load the last checkpoint in *args.output_dir* as saved by a previous instance\n                of [`Trainer`]. If present, training will resume from the model/optimizer/scheduler states loaded here.\n            trial (`optuna.Trial` or `Dict[str, Any]`, *optional*):\n                The trial run or the hyperparameter dictionary for hyperparameter search.\n            ignore_keys_for_eval (`List[str]`, *optional*)\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions for evaluation during the training.\n            kwargs:\n                Additional keyword arguments used to hide deprecated arguments\n        \"\"\"\n        if resume_from_checkpoint is False:\n            resume_from_checkpoint = None\n\n        # memory metrics - must set up as early as possible\n        self._memory_tracker.start()\n\n        args = self.args\n\n        self.is_in_train = True\n\n        # do_train is not a reliable argument, as it might not be set and .train() still called, so\n        # the following is a workaround:\n        if (args.fp16_full_eval or args.bf16_full_eval) and not args.do_train:\n            self._move_model_to_device(self.model, args.device)\n\n        if \"model_path\" in kwargs:\n            resume_from_checkpoint = kwargs.pop(\"model_path\")\n            warnings.warn(\n                \"`model_path` is deprecated and will be removed in a future version. Use `resume_from_checkpoint` \"\n                \"instead.\",\n                FutureWarning,\n            )\n        if len(kwargs) > 0:\n            raise TypeError(f\"train() received got unexpected keyword arguments: {', '.join(list(kwargs.keys()))}.\")\n        # This might change the seed so needs to run first.\n        self._hp_search_setup(trial)\n        self._train_batch_size = self.args.train_batch_size\n\n        # Model re-init\n        model_reloaded = False\n        if self.model_init is not None:\n            # Seed must be set before instantiating the model when using model_init.\n            enable_full_determinism(self.args.seed) if self.args.full_determinism else set_seed(self.args.seed)\n            self.model = self.call_model_init(trial)\n            model_reloaded = True\n            # Reinitializes optimizer and scheduler\n            self.optimizer, self.lr_scheduler = None, None\n\n        # Load potential model checkpoint\n        if isinstance(resume_from_checkpoint, bool) and resume_from_checkpoint:\n            resume_from_checkpoint = get_last_checkpoint(args.output_dir)\n            if resume_from_checkpoint is None:\n                raise ValueError(f\"No valid checkpoint found in output directory ({args.output_dir})\")\n\n        if resume_from_checkpoint is not None and not is_sagemaker_mp_enabled() and args.deepspeed is None:\n            self._load_from_checkpoint(resume_from_checkpoint)\n\n        # If model was re-initialized, put it on the right device and update self.model_wrapped\n        if model_reloaded:\n            if self.place_model_on_device:\n                self._move_model_to_device(self.model, args.device)\n            self.model_wrapped = self.model\n\n        inner_training_loop = find_executable_batch_size(\n            self._inner_training_loop, self._train_batch_size, args.auto_find_batch_size\n        )\n        return inner_training_loop(\n            args=args,\n            resume_from_checkpoint=resume_from_checkpoint,\n            trial=trial,\n            ignore_keys_for_eval=ignore_keys_for_eval,\n        )\n\n    def _inner_training_loop(\n        self, batch_size=None, args=None, resume_from_checkpoint=None, trial=None, ignore_keys_for_eval=None\n    ):\n        self._train_batch_size = batch_size\n        # Data loader and number of training steps\n        train_dataloader = self.get_train_dataloader()\n\n        # Setting up training control variables:\n        # number of training epochs: num_train_epochs\n        # number of training steps per epoch: num_update_steps_per_epoch\n        # total number of training steps to execute: max_steps\n        total_train_batch_size = args.train_batch_size * args.gradient_accumulation_steps * args.world_size\n\n        len_dataloader = None\n        if has_length(train_dataloader):\n            len_dataloader = len(train_dataloader)\n            num_update_steps_per_epoch = len_dataloader // args.gradient_accumulation_steps\n            num_update_steps_per_epoch = max(num_update_steps_per_epoch, 1)\n            num_examples = self.num_examples(train_dataloader)\n            if args.max_steps > 0:\n                max_steps = args.max_steps\n                num_train_epochs = args.max_steps // num_update_steps_per_epoch + int(\n                    args.max_steps % num_update_steps_per_epoch > 0\n                )\n                # May be slightly incorrect if the last batch in the training dataloader has a smaller size but it's\n                # the best we can do.\n                num_train_samples = args.max_steps * total_train_batch_size\n            else:\n                max_steps = math.ceil(args.num_train_epochs * num_update_steps_per_epoch)\n                num_train_epochs = math.ceil(args.num_train_epochs)\n                num_train_samples = self.num_examples(train_dataloader) * args.num_train_epochs\n        elif args.max_steps > 0:  # Rely on max_steps when dataloader does not have a working size\n            max_steps = args.max_steps\n            # Setting a very large number of epochs so we go as many times as necessary over the iterator.\n            num_train_epochs = sys.maxsize\n            num_update_steps_per_epoch = max_steps\n            num_examples = total_train_batch_size * args.max_steps\n            num_train_samples = args.max_steps * total_train_batch_size\n        else:\n            raise ValueError(\n                \"args.max_steps must be set to a positive value if dataloader does not have a length, was\"\n                f\" {args.max_steps}\"\n            )\n\n        if DebugOption.UNDERFLOW_OVERFLOW in self.args.debug:\n            if self.args.n_gpu > 1:\n                # nn.DataParallel(model) replicates the model, creating new variables and module\n                # references registered here no longer work on other gpus, breaking the module\n                raise ValueError(\n                    \"Currently --debug underflow_overflow is not supported under DP. Please use DDP\"\n                    \" (torch.distributed.launch).\"\n                )\n            else:\n                debug_overflow = DebugUnderflowOverflow(self.model)  # noqa\n\n        delay_optimizer_creation = (\n            self.sharded_ddp is not None\n            and self.sharded_ddp != ShardedDDPOption.SIMPLE\n            or is_sagemaker_mp_enabled()\n            or self.fsdp is not None\n        )\n        if args.deepspeed:\n            deepspeed_engine, optimizer, lr_scheduler = deepspeed_init(\n                self, num_training_steps=max_steps, resume_from_checkpoint=resume_from_checkpoint\n            )\n            self.model = deepspeed_engine.module\n            self.model_wrapped = deepspeed_engine\n            self.deepspeed = deepspeed_engine\n            self.optimizer = optimizer\n            self.lr_scheduler = lr_scheduler\n        elif not delay_optimizer_creation:\n            self.create_optimizer_and_scheduler(num_training_steps=max_steps)\n\n        self.state = TrainerState()\n        self.state.is_hyper_param_search = trial is not None\n\n        # Activate gradient checkpointing if needed\n        if args.gradient_checkpointing:\n            self.model.gradient_checkpointing_enable()\n\n        model = self._wrap_model(self.model_wrapped)\n\n        if is_sagemaker_mp_enabled() and resume_from_checkpoint is not None:\n            self._load_from_checkpoint(resume_from_checkpoint, model)\n\n        # for the rest of this function `model` is the outside model, whether it was wrapped or not\n        if model is not self.model:\n            self.model_wrapped = model\n\n        if delay_optimizer_creation:\n            self.create_optimizer_and_scheduler(num_training_steps=max_steps)\n\n        # Check if saved optimizer or scheduler states exist\n        self._load_optimizer_and_scheduler(resume_from_checkpoint)\n\n        # important: at this point:\n        # self.model         is the Transformers Model\n        # self.model_wrapped is DDP(Transformers Model), Deepspeed(Transformers Model), etc.\n\n        # Train!\n        logger.info(\"***** Running training *****\")\n        logger.info(f\"  Num examples = {num_examples}\")\n        logger.info(f\"  Num Epochs = {num_train_epochs}\")\n        logger.info(f\"  Instantaneous batch size per device = {args.per_device_train_batch_size}\")\n        logger.info(f\"  Total train batch size (w. parallel, distributed & accumulation) = {total_train_batch_size}\")\n        logger.info(f\"  Gradient Accumulation steps = {args.gradient_accumulation_steps}\")\n        logger.info(f\"  Total optimization steps = {max_steps}\")\n        logger.info(\n            f\"  Number of trainable parameters = {sum(p.numel() for p in model.parameters() if p.requires_grad)}\"\n        )\n\n        self.state.epoch = 0\n        start_time = time.time()\n        epochs_trained = 0\n        steps_trained_in_current_epoch = 0\n        steps_trained_progress_bar = None\n\n        # Check if continuing training from a checkpoint\n        if resume_from_checkpoint is not None and os.path.isfile(\n            os.path.join(resume_from_checkpoint, TRAINER_STATE_NAME)\n        ):\n            self.state = TrainerState.load_from_json(os.path.join(resume_from_checkpoint, TRAINER_STATE_NAME))\n            epochs_trained = self.state.global_step // num_update_steps_per_epoch\n            if not args.ignore_data_skip:\n                steps_trained_in_current_epoch = self.state.global_step % (num_update_steps_per_epoch)\n                steps_trained_in_current_epoch *= args.gradient_accumulation_steps\n            else:\n                steps_trained_in_current_epoch = 0\n\n            logger.info(\"  Continuing training from checkpoint, will skip to saved global_step\")\n            logger.info(f\"  Continuing training from epoch {epochs_trained}\")\n            logger.info(f\"  Continuing training from global step {self.state.global_step}\")\n            if not args.ignore_data_skip:\n                if skip_first_batches is None:\n                    logger.info(\n                        f\"  Will skip the first {epochs_trained} epochs then the first\"\n                        f\" {steps_trained_in_current_epoch} batches in the first epoch. If this takes a lot of time,\"\n                        \" you can install the latest version of Accelerate with `pip install -U accelerate`.You can\"\n                        \" also add the `--ignore_data_skip` flag to your launch command, but you will resume the\"\n                        \" training on data already seen by your model.\"\n                    )\n                else:\n                    logger.info(\n                        f\"  Will skip the first {epochs_trained} epochs then the first\"\n                        f\" {steps_trained_in_current_epoch} batches in the first epoch.\"\n                    )\n                if self.is_local_process_zero() and not args.disable_tqdm and skip_first_batches is None:\n                    steps_trained_progress_bar = tqdm(total=steps_trained_in_current_epoch)\n                    steps_trained_progress_bar.set_description(\"Skipping the first batches\")\n\n        # Update the references\n        self.callback_handler.model = self.model\n        self.callback_handler.optimizer = self.optimizer\n        self.callback_handler.lr_scheduler = self.lr_scheduler\n        self.callback_handler.train_dataloader = train_dataloader\n        if self.hp_name is not None and self._trial is not None:\n            # use self._trial because the SigOpt/Optuna hpo only call `_hp_search_setup(trial)` instead of passing trial\n            # parameter to Train when using DDP.\n            self.state.trial_name = self.hp_name(self._trial)\n        if trial is not None:\n            assignments = trial.assignments if self.hp_search_backend == HPSearchBackend.SIGOPT else trial\n            self.state.trial_params = hp_params(assignments)\n        else:\n            self.state.trial_params = None\n        # This should be the same if the state has been saved but in case the training arguments changed, it's safer\n        # to set this after the load.\n        self.state.max_steps = max_steps\n        self.state.num_train_epochs = num_train_epochs\n        self.state.is_local_process_zero = self.is_local_process_zero()\n        self.state.is_world_process_zero = self.is_world_process_zero()\n\n        # tr_loss is a tensor to avoid synchronization of TPUs through .item()\n        tr_loss = torch.tensor(0.0).to(args.device)\n        # _total_loss_scalar is updated everytime .item() has to be called on tr_loss and stores the sum of all losses\n        self._total_loss_scalar = 0.0\n        self._globalstep_last_logged = self.state.global_step\n        model.zero_grad()\n\n        self.control = self.callback_handler.on_train_begin(args, self.state, self.control)\n\n        # Skip the first epochs_trained epochs to get the random state of the dataloader at the right point.\n        if not args.ignore_data_skip:\n            for epoch in range(epochs_trained):\n                is_random_sampler = hasattr(train_dataloader, \"sampler\") and isinstance(\n                    train_dataloader.sampler, RandomSampler\n                )\n                if is_torch_less_than_1_11 or not is_random_sampler:\n                    # We just need to begin an iteration to create the randomization of the sampler.\n                    # That was before PyTorch 1.11 however...\n                    for _ in train_dataloader:\n                        break\n                else:\n                    # Otherwise we need to call the whooooole sampler cause there is some random operation added\n                    # AT THE VERY END!\n                    _ = list(train_dataloader.sampler)\n\n        total_batched_samples = 0\n        for epoch in range(epochs_trained, num_train_epochs):\n            if isinstance(train_dataloader, DataLoader) and isinstance(train_dataloader.sampler, DistributedSampler):\n                train_dataloader.sampler.set_epoch(epoch)\n            elif hasattr(train_dataloader, \"dataset\") and isinstance(train_dataloader.dataset, IterableDatasetShard):\n                train_dataloader.dataset.set_epoch(epoch)\n\n            if is_torch_tpu_available():\n                parallel_loader = pl.ParallelLoader(train_dataloader, [args.device]).per_device_loader(args.device)\n                epoch_iterator = parallel_loader\n            else:\n                epoch_iterator = train_dataloader\n\n            # Reset the past mems state at the beginning of each epoch if necessary.\n            if args.past_index >= 0:\n                self._past = None\n\n            steps_in_epoch = (\n                len(epoch_iterator)\n                if len_dataloader is not None\n                else args.max_steps * args.gradient_accumulation_steps\n            )\n            self.control = self.callback_handler.on_epoch_begin(args, self.state, self.control)\n\n            if epoch == epochs_trained and resume_from_checkpoint is not None and steps_trained_in_current_epoch == 0:\n                self._load_rng_state(resume_from_checkpoint)\n\n            rng_to_sync = False\n            steps_skipped = 0\n            if skip_first_batches is not None and steps_trained_in_current_epoch > 0:\n                epoch_iterator = skip_first_batches(epoch_iterator, steps_trained_in_current_epoch)\n                steps_skipped = steps_trained_in_current_epoch\n                steps_trained_in_current_epoch = 0\n                rng_to_sync = True\n\n            step = -1\n            for step, inputs in enumerate(epoch_iterator):\n                total_batched_samples += 1\n                if rng_to_sync:\n                    self._load_rng_state(resume_from_checkpoint)\n                    rng_to_sync = False\n\n                # Skip past any already trained steps if resuming training\n                if steps_trained_in_current_epoch > 0:\n                    steps_trained_in_current_epoch -= 1\n                    if steps_trained_progress_bar is not None:\n                        steps_trained_progress_bar.update(1)\n                    if steps_trained_in_current_epoch == 0:\n                        self._load_rng_state(resume_from_checkpoint)\n                    continue\n                elif steps_trained_progress_bar is not None:\n                    steps_trained_progress_bar.close()\n                    steps_trained_progress_bar = None\n\n                if step % args.gradient_accumulation_steps == 0:\n                    self.control = self.callback_handler.on_step_begin(args, self.state, self.control)\n\n                if (\n                    (total_batched_samples % args.gradient_accumulation_steps != 0)\n                    and args.local_rank != -1\n                    and args._no_sync_in_gradient_accumulation\n                ):\n                    # Avoid unnecessary DDP synchronization since there will be no backward pass on this example.\n                    with model.no_sync():\n                        tr_loss_step = self.training_step(model, inputs)\n                else:\n                    tr_loss_step = self.training_step(model, inputs)\n\n                if (\n                    args.logging_nan_inf_filter\n                    and not is_torch_tpu_available()\n                    and (torch.isnan(tr_loss_step) or torch.isinf(tr_loss_step))\n                ):\n                    # if loss is nan or inf simply add the average of previous logged losses\n                    tr_loss += tr_loss / (1 + self.state.global_step - self._globalstep_last_logged)\n                else:\n                    tr_loss += tr_loss_step\n\n                self.current_flos += float(self.floating_point_ops(inputs))\n\n                # Optimizer step for deepspeed must be called on every step regardless of the value of gradient_accumulation_steps\n                if self.deepspeed:\n                    self.deepspeed.step()\n\n                if total_batched_samples % args.gradient_accumulation_steps == 0 or (\n                    # last step in epoch but step is always smaller than gradient_accumulation_steps\n                    steps_in_epoch <= args.gradient_accumulation_steps\n                    and (step + 1) == steps_in_epoch\n                ):\n                    # Gradient clipping\n                    if args.max_grad_norm is not None and args.max_grad_norm > 0 and not self.deepspeed:\n                        # deepspeed does its own clipping\n\n                        if self.do_grad_scaling:\n                            # Reduce gradients first for XLA\n                            if is_torch_tpu_available():\n                                gradients = xm._fetch_gradients(self.optimizer)\n                                xm.all_reduce(\"sum\", gradients, scale=1.0 / xm.xrt_world_size())\n                            # AMP: gradients need unscaling\n                            self.scaler.unscale_(self.optimizer)\n\n                        if is_sagemaker_mp_enabled() and args.fp16:\n                            self.optimizer.clip_master_grads(args.max_grad_norm)\n                        elif hasattr(self.optimizer, \"clip_grad_norm\"):\n                            # Some optimizers (like the sharded optimizer) have a specific way to do gradient clipping\n                            self.optimizer.clip_grad_norm(args.max_grad_norm)\n                        elif hasattr(model, \"clip_grad_norm_\"):\n                            # Some models (like FullyShardedDDP) have a specific way to do gradient clipping\n                            model.clip_grad_norm_(args.max_grad_norm)\n                        else:\n                            # Revert to normal clipping otherwise, handling Apex or full precision\n                            nn.utils.clip_grad_norm_(\n                                amp.master_params(self.optimizer) if self.use_apex else model.parameters(),\n                                args.max_grad_norm,\n                            )\n\n                    # Optimizer step\n                    optimizer_was_run = True\n                    if self.deepspeed:\n                        pass  # called outside the loop\n                    elif is_torch_tpu_available():\n                        if self.do_grad_scaling:\n                            self.scaler.step(self.optimizer)\n                            self.scaler.update()\n                        else:\n                            xm.optimizer_step(self.optimizer)\n                    elif self.do_grad_scaling:\n                        scale_before = self.scaler.get_scale()\n                        self.scaler.step(self.optimizer)\n                        self.scaler.update()\n                        scale_after = self.scaler.get_scale()\n                        optimizer_was_run = scale_before <= scale_after\n                    else:\n                        self.optimizer.step()\n\n                    if optimizer_was_run and not self.deepspeed:\n                        self.lr_scheduler.step()\n\n                    model.zero_grad()\n                    self.state.global_step += 1\n                    self.state.epoch = epoch + (step + 1 + steps_skipped) / steps_in_epoch\n                    self.control = self.callback_handler.on_step_end(args, self.state, self.control)\n\n                    self._maybe_log_save_evaluate(tr_loss, model, trial, epoch, ignore_keys_for_eval)\n                else:\n                    self.control = self.callback_handler.on_substep_end(args, self.state, self.control)\n\n                if self.control.should_epoch_stop or self.control.should_training_stop:\n                    break\n            if step < 0:\n                logger.warning(\n                    \"There seems to be not a single sample in your epoch_iterator, stopping training at step\"\n                    f\" {self.state.global_step}! This is expected if you're using an IterableDataset and set\"\n                    f\" num_steps ({max_steps}) higher than the number of available samples.\"\n                )\n                self.control.should_training_stop = True\n\n            self.control = self.callback_handler.on_epoch_end(args, self.state, self.control)\n            self._maybe_log_save_evaluate(tr_loss, model, trial, epoch, ignore_keys_for_eval)\n\n            if DebugOption.TPU_METRICS_DEBUG in self.args.debug:\n                if is_torch_tpu_available():\n                    # tpu-comment: Logging debug metrics for PyTorch/XLA (compile, execute times, ops, etc.)\n                    xm.master_print(met.metrics_report())\n                else:\n                    logger.warning(\n                        \"You enabled PyTorch/XLA debug metrics but you don't have a TPU \"\n                        \"configured. Check your training configuration if this is unexpected.\"\n                    )\n            if self.control.should_training_stop:\n                break\n\n        if args.past_index and hasattr(self, \"_past\"):\n            # Clean the state at the end of training\n            delattr(self, \"_past\")\n\n        logger.info(\"\\n\\nTraining completed. Do not forget to share your model on huggingface.co/models =)\\n\\n\")\n        if args.load_best_model_at_end and self.state.best_model_checkpoint is not None:\n            # Wait for everyone to get here so we are sur the model has been saved by process 0.\n            if is_torch_tpu_available():\n                xm.rendezvous(\"load_best_model_at_end\")\n            elif args.local_rank != -1:\n                dist.barrier()\n            elif is_sagemaker_mp_enabled():\n                smp.barrier()\n\n            self._load_best_model()\n\n        # add remaining tr_loss\n        self._total_loss_scalar += tr_loss.item()\n        train_loss = self._total_loss_scalar / self.state.global_step\n\n        metrics = speed_metrics(\"train\", start_time, num_samples=num_train_samples, num_steps=self.state.max_steps)\n        self.store_flos()\n        metrics[\"total_flos\"] = self.state.total_flos\n        metrics[\"train_loss\"] = train_loss\n\n        self.is_in_train = False\n\n        self._memory_tracker.stop_and_update_metrics(metrics)\n\n        self.log(metrics)\n\n        run_dir = self._get_output_dir(trial)\n        checkpoints_sorted = self._sorted_checkpoints(use_mtime=False, output_dir=run_dir)\n\n        # Delete the last checkpoint when save_total_limit=1 if it's different from the best checkpoint and process allowed to save.\n        if self.args.should_save and self.state.best_model_checkpoint is not None and self.args.save_total_limit == 1:\n            for checkpoint in checkpoints_sorted:\n                if checkpoint != self.state.best_model_checkpoint:\n                    logger.info(f\"Deleting older checkpoint [{checkpoint}] due to args.save_total_limit\")\n                    shutil.rmtree(checkpoint)\n\n        self.control = self.callback_handler.on_train_end(args, self.state, self.control)\n\n        return TrainOutput(self.state.global_step, train_loss, metrics)\n\n    def _get_output_dir(self, trial):\n        if self.hp_search_backend is not None and trial is not None:\n            if self.hp_search_backend == HPSearchBackend.OPTUNA:\n                run_id = trial.number\n            elif self.hp_search_backend == HPSearchBackend.RAY:\n                from ray import tune\n\n                run_id = tune.get_trial_id()\n            elif self.hp_search_backend == HPSearchBackend.SIGOPT:\n                run_id = trial.id\n            elif self.hp_search_backend == HPSearchBackend.WANDB:\n                import wandb\n\n                run_id = wandb.run.id\n            run_name = self.hp_name(trial) if self.hp_name is not None else f\"run-{run_id}\"\n            run_dir = os.path.join(self.args.output_dir, run_name)\n        else:\n            run_dir = self.args.output_dir\n        return run_dir\n\n    def _load_from_checkpoint(self, resume_from_checkpoint, model=None):\n        if model is None:\n            model = self.model\n\n        if not os.path.isfile(os.path.join(resume_from_checkpoint, WEIGHTS_NAME)) and not os.path.isfile(\n            os.path.join(resume_from_checkpoint, WEIGHTS_INDEX_NAME)\n        ):\n            raise ValueError(f\"Can't find a valid checkpoint at {resume_from_checkpoint}\")\n\n        logger.info(f\"Loading model from {resume_from_checkpoint}.\")\n\n        if os.path.isfile(os.path.join(resume_from_checkpoint, CONFIG_NAME)):\n            config = PretrainedConfig.from_json_file(os.path.join(resume_from_checkpoint, CONFIG_NAME))\n            checkpoint_version = config.transformers_version\n            if checkpoint_version is not None and checkpoint_version != __version__:\n                logger.warning(\n                    f\"You are resuming training from a checkpoint trained with {checkpoint_version} of \"\n                    f\"Transformers but your current version is {__version__}. This is not recommended and could \"\n                    \"yield to errors or unwanted behaviors.\"\n                )\n\n        if os.path.isfile(os.path.join(resume_from_checkpoint, WEIGHTS_NAME)):\n            # If the model is on the GPU, it still works!\n            if is_sagemaker_mp_enabled():\n                if os.path.isfile(os.path.join(resume_from_checkpoint, \"user_content.pt\")):\n                    # If the 'user_content.pt' file exists, load with the new smp api.\n                    # Checkpoint must have been saved with the new smp api.\n                    smp.resume_from_checkpoint(\n                        path=resume_from_checkpoint, tag=WEIGHTS_NAME, partial=False, load_optimizer=False\n                    )\n                else:\n                    # If the 'user_content.pt' file does NOT exist, load with the old smp api.\n                    # Checkpoint must have been saved with the old smp api.\n                    if hasattr(self.args, \"fp16\") and self.args.fp16 is True:\n                        logger.warning(\n                            \"Enabling FP16 and loading from smp < 1.10 checkpoint together is not suppported.\"\n                        )\n                    state_dict = torch.load(os.path.join(resume_from_checkpoint, WEIGHTS_NAME), map_location=\"cpu\")\n                    # Required for smp to not auto-translate state_dict from hf to smp (is already smp).\n                    state_dict[\"_smp_is_partial\"] = False\n                    load_result = model.load_state_dict(state_dict, strict=True)\n                    # release memory\n                    del state_dict\n            else:\n                # We load the model state dict on the CPU to avoid an OOM error.\n                state_dict = torch.load(os.path.join(resume_from_checkpoint, WEIGHTS_NAME), map_location=\"cpu\")\n                # workaround for FSDP bug https://github.com/pytorch/pytorch/issues/82963\n                # which takes *args instead of **kwargs\n                load_result = model.load_state_dict(state_dict, False)\n                # release memory\n                del state_dict\n                self._issue_warnings_after_load(load_result)\n        else:\n            # We load the sharded checkpoint\n            load_result = load_sharded_checkpoint(model, resume_from_checkpoint, strict=is_sagemaker_mp_enabled())\n            if not is_sagemaker_mp_enabled():\n                self._issue_warnings_after_load(load_result)\n\n    def _load_best_model(self):\n        logger.info(f\"Loading best model from {self.state.best_model_checkpoint} (score: {self.state.best_metric}).\")\n        best_model_path = os.path.join(self.state.best_model_checkpoint, WEIGHTS_NAME)\n        model = self.model_wrapped if is_sagemaker_mp_enabled() else self.model\n        if os.path.exists(best_model_path):\n            if self.deepspeed:\n                if self.model_wrapped is not None:\n                    # this removes the pre-hooks from the previous engine\n                    self.model_wrapped.destroy()\n                    self.model_wrapped = None\n\n                # temp hack until Deepspeed fixes the problem with resume from an existing engine that did some stepping\n                deepspeed_engine, optimizer, lr_scheduler = deepspeed_init(\n                    self,\n                    num_training_steps=self.args.max_steps,\n                    resume_from_checkpoint=self.state.best_model_checkpoint,\n                )\n                self.model = deepspeed_engine.module\n                self.model_wrapped = deepspeed_engine\n                self.deepspeed = deepspeed_engine\n                self.optimizer = optimizer\n                self.lr_scheduler = lr_scheduler\n            else:\n                if is_sagemaker_mp_enabled():\n                    if os.path.isfile(os.path.join(self.state.best_model_checkpoint, \"user_content.pt\")):\n                        # If the 'user_content.pt' file exists, load with the new smp api.\n                        # Checkpoint must have been saved with the new smp api.\n                        smp.resume_from_checkpoint(\n                            path=self.state.best_model_checkpoint,\n                            tag=WEIGHTS_NAME,\n                            partial=False,\n                            load_optimizer=False,\n                        )\n                    else:\n                        # If the 'user_content.pt' file does NOT exist, load with the old smp api.\n                        # Checkpoint must have been saved with the old smp api.\n                        state_dict = torch.load(best_model_path, map_location=\"cpu\")\n                        state_dict[\"_smp_is_partial\"] = False\n                        # load_result = model.load_state_dict(state_dict, strict=True)\n                        set_peft_model_state_dict(model, state_dict) # For PEFT Lora\n                else:\n                    # We load the model state dict on the CPU to avoid an OOM error.\n                    state_dict = torch.load(best_model_path, map_location=\"cpu\")\n                    # If the model is on the GPU, it still works!\n                    # workaround for FSDP bug https://github.com/pytorch/pytorch/issues/82963\n                    # which takes *args instead of **kwargs\n                    # load_result = model.load_state_dict(state_dict, False)\n                    set_peft_model_state_dict(model, state_dict) # For PEFT Lora\n        elif os.path.exists(os.path.join(self.state.best_model_checkpoint, WEIGHTS_INDEX_NAME)):\n            # load_result = load_sharded_checkpoint(\n            #     model, self.state.best_model_checkpoint, strict=is_sagemaker_mp_enabled()\n            # )\n            # if not is_sagemaker_mp_enabled():\n            #     self._issue_warnings_after_load(load_result)\n            logger.error(\"load_sharded_checkpoint is unsupported for PEFT Lora\")\n        else:\n            logger.warning(\n                f\"Could not locate the best model at {best_model_path}, if you are running a distributed training \"\n                \"on multiple nodes, you should activate `--save_on_each_node`.\"\n            )\n\n    def _issue_warnings_after_load(self, load_result):\n        if len(load_result.missing_keys) != 0:\n            if self.model._keys_to_ignore_on_save is not None and set(load_result.missing_keys) == set(\n                self.model._keys_to_ignore_on_save\n            ):\n                self.model.tie_weights()\n            else:\n                logger.warning(f\"There were missing keys in the checkpoint model loaded: {load_result.missing_keys}.\")\n        if len(load_result.unexpected_keys) != 0:\n            logger.warning(\n                f\"There were unexpected keys in the checkpoint model loaded: {load_result.unexpected_keys}.\"\n            )\n\n    def _maybe_log_save_evaluate(self, tr_loss, model, trial, epoch, ignore_keys_for_eval):\n        if self.control.should_log:\n            if is_torch_tpu_available():\n                xm.mark_step()\n\n            logs: Dict[str, float] = {}\n\n            # all_gather + mean() to get average loss over all processes\n            tr_loss_scalar = self._nested_gather(tr_loss).mean().item()\n\n            # reset tr_loss to zero\n            tr_loss -= tr_loss\n\n            logs[\"loss\"] = round(tr_loss_scalar / (self.state.global_step - self._globalstep_last_logged), 4)\n            logs[\"learning_rate\"] = self._get_learning_rate()\n\n            self._total_loss_scalar += tr_loss_scalar\n            self._globalstep_last_logged = self.state.global_step\n            self.store_flos()\n\n            self.log(logs)\n\n        metrics = None\n        if self.control.should_evaluate:\n            if isinstance(self.eval_dataset, dict):\n                for eval_dataset_name, eval_dataset in self.eval_dataset.items():\n                    metrics = self.evaluate(\n                        eval_dataset=eval_dataset,\n                        ignore_keys=ignore_keys_for_eval,\n                        metric_key_prefix=f\"eval_{eval_dataset_name}\",\n                    )\n            else:\n                metrics = self.evaluate(ignore_keys=ignore_keys_for_eval)\n            self._report_to_hp_search(trial, self.state.global_step, metrics)\n\n        if self.control.should_save:\n            self._save_checkpoint(model, trial, metrics=metrics)\n            self.control = self.callback_handler.on_save(self.args, self.state, self.control)\n\n    def _load_rng_state(self, checkpoint):\n        # Load RNG states from `checkpoint`\n        if checkpoint is None:\n            return\n\n        if self.args.world_size > 1:\n            process_index = self.args.process_index\n            rng_file = os.path.join(checkpoint, f\"rng_state_{process_index}.pth\")\n            if not os.path.isfile(rng_file):\n                logger.info(\n                    f\"Didn't find an RNG file for process {process_index}, if you are resuming a training that \"\n                    \"wasn't launched in a distributed fashion, reproducibility is not guaranteed.\"\n                )\n                return\n        else:\n            rng_file = os.path.join(checkpoint, \"rng_state.pth\")\n            if not os.path.isfile(rng_file):\n                logger.info(\n                    \"Didn't find an RNG file, if you are resuming a training that was launched in a distributed \"\n                    \"fashion, reproducibility is not guaranteed.\"\n                )\n                return\n\n        checkpoint_rng_state = torch.load(rng_file)\n        random.setstate(checkpoint_rng_state[\"python\"])\n        np.random.set_state(checkpoint_rng_state[\"numpy\"])\n        torch.random.set_rng_state(checkpoint_rng_state[\"cpu\"])\n        if torch.cuda.is_available():\n            if self.args.local_rank != -1:\n                torch.cuda.random.set_rng_state(checkpoint_rng_state[\"cuda\"])\n            else:\n                try:\n                    torch.cuda.random.set_rng_state_all(checkpoint_rng_state[\"cuda\"])\n                except Exception as e:\n                    logger.info(\n                        f\"Didn't manage to set back the RNG states of the GPU because of the following error:\\n {e}\"\n                        \"\\nThis won't yield the same results as if the training had not been interrupted.\"\n                    )\n        if is_torch_tpu_available():\n            xm.set_rng_state(checkpoint_rng_state[\"xla\"])\n\n    def _save_checkpoint(self, model, trial, metrics=None):\n        # In all cases, including ddp/dp/deepspeed, self.model is always a reference to the model we\n        # want to save except FullyShardedDDP.\n        # assert unwrap_model(model) is self.model, \"internal model should be a reference to self.model\"\n\n        # Save model checkpoint\n        checkpoint_folder = f\"{PREFIX_CHECKPOINT_DIR}-{self.state.global_step}\"\n\n        if self.hp_search_backend is None and trial is None:\n            self.store_flos()\n\n        run_dir = self._get_output_dir(trial=trial)\n        output_dir = os.path.join(run_dir, checkpoint_folder)\n        self.save_model(output_dir, _internal_call=True)\n        if self.deepspeed:\n            # under zero3 model file itself doesn't get saved since it's bogus! Unless deepspeed\n            # config `stage3_gather_16bit_weights_on_model_save` is True\n            self.deepspeed.save_checkpoint(output_dir)\n\n        # Save optimizer and scheduler\n        if self.sharded_ddp == ShardedDDPOption.SIMPLE:\n            self.optimizer.consolidate_state_dict()\n\n        if is_torch_tpu_available():\n            xm.rendezvous(\"saving_optimizer_states\")\n            xm.save(self.optimizer.state_dict(), os.path.join(output_dir, OPTIMIZER_NAME))\n            with warnings.catch_warnings(record=True) as caught_warnings:\n                xm.save(self.lr_scheduler.state_dict(), os.path.join(output_dir, SCHEDULER_NAME))\n                reissue_pt_warnings(caught_warnings)\n        elif is_sagemaker_mp_enabled():\n            opt_state_dict = self.optimizer.local_state_dict(gather_if_shard=False)\n            smp.barrier()\n            if smp.rdp_rank() == 0 or smp.state.cfg.shard_optimizer_state:\n                smp.save(\n                    opt_state_dict,\n                    os.path.join(output_dir, OPTIMIZER_NAME),\n                    partial=True,\n                    v3=smp.state.cfg.shard_optimizer_state,\n                )\n            if self.args.should_save:\n                with warnings.catch_warnings(record=True) as caught_warnings:\n                    torch.save(self.lr_scheduler.state_dict(), os.path.join(output_dir, SCHEDULER_NAME))\n                reissue_pt_warnings(caught_warnings)\n                if self.do_grad_scaling:\n                    torch.save(self.scaler.state_dict(), os.path.join(output_dir, SCALER_NAME))\n        elif self.args.should_save and not self.deepspeed:\n            # deepspeed.save_checkpoint above saves model/optim/sched\n            torch.save(self.optimizer.state_dict(), os.path.join(output_dir, OPTIMIZER_NAME))\n            with warnings.catch_warnings(record=True) as caught_warnings:\n                torch.save(self.lr_scheduler.state_dict(), os.path.join(output_dir, SCHEDULER_NAME))\n            reissue_pt_warnings(caught_warnings)\n            if self.do_grad_scaling:\n                torch.save(self.scaler.state_dict(), os.path.join(output_dir, SCALER_NAME))\n\n        # Determine the new best metric / best model checkpoint\n        if metrics is not None and self.args.metric_for_best_model is not None:\n            metric_to_check = self.args.metric_for_best_model\n            if not metric_to_check.startswith(\"eval_\"):\n                metric_to_check = f\"eval_{metric_to_check}\"\n            metric_value = metrics[metric_to_check]\n\n            operator = np.greater if self.args.greater_is_better else np.less\n            if (\n                self.state.best_metric is None\n                or self.state.best_model_checkpoint is None\n                or operator(metric_value, self.state.best_metric)\n            ):\n                self.state.best_metric = metric_value\n                self.state.best_model_checkpoint = output_dir\n\n        # Save the Trainer state\n        if self.args.should_save:\n            self.state.save_to_json(os.path.join(output_dir, TRAINER_STATE_NAME))\n\n        # Save RNG state in non-distributed training\n        rng_states = {\n            \"python\": random.getstate(),\n            \"numpy\": np.random.get_state(),\n            \"cpu\": torch.random.get_rng_state(),\n        }\n        if torch.cuda.is_available():\n            if self.args.local_rank == -1:\n                # In non distributed, we save the global CUDA RNG state (will take care of DataParallel)\n                rng_states[\"cuda\"] = torch.cuda.random.get_rng_state_all()\n            else:\n                rng_states[\"cuda\"] = torch.cuda.random.get_rng_state()\n\n        if is_torch_tpu_available():\n            rng_states[\"xla\"] = xm.get_rng_state()\n\n        # A process can arrive here before the process 0 has a chance to save the model, in which case output_dir may\n        # not yet exist.\n        os.makedirs(output_dir, exist_ok=True)\n\n        if self.args.world_size <= 1:\n            torch.save(rng_states, os.path.join(output_dir, \"rng_state.pth\"))\n        else:\n            torch.save(rng_states, os.path.join(output_dir, f\"rng_state_{self.args.process_index}.pth\"))\n\n        if self.args.push_to_hub:\n            self._push_from_checkpoint(output_dir)\n\n        # Maybe delete some older checkpoints.\n        if self.args.should_save:\n            self._rotate_checkpoints(use_mtime=True, output_dir=run_dir)\n\n    def _load_optimizer_and_scheduler(self, checkpoint):\n        \"\"\"If optimizer and scheduler states exist, load them.\"\"\"\n        if checkpoint is None:\n            return\n\n        if self.deepspeed:\n            # deepspeed loads optimizer/lr_scheduler together with the model in deepspeed_init\n            return\n\n        checkpoint_file_exists = (\n            glob.glob(os.path.join(checkpoint, OPTIMIZER_NAME) + \"_*\")\n            if is_sagemaker_mp_enabled()\n            else os.path.isfile(os.path.join(checkpoint, OPTIMIZER_NAME))\n        )\n        if checkpoint_file_exists and os.path.isfile(os.path.join(checkpoint, SCHEDULER_NAME)):\n            # Load in optimizer and scheduler states\n            if is_torch_tpu_available():\n                # On TPU we have to take some extra precautions to properly load the states on the right device.\n                optimizer_state = torch.load(os.path.join(checkpoint, OPTIMIZER_NAME), map_location=\"cpu\")\n                with warnings.catch_warnings(record=True) as caught_warnings:\n                    lr_scheduler_state = torch.load(os.path.join(checkpoint, SCHEDULER_NAME), map_location=\"cpu\")\n                reissue_pt_warnings(caught_warnings)\n\n                xm.send_cpu_data_to_device(optimizer_state, self.args.device)\n                xm.send_cpu_data_to_device(lr_scheduler_state, self.args.device)\n\n                self.optimizer.load_state_dict(optimizer_state)\n                self.lr_scheduler.load_state_dict(lr_scheduler_state)\n            else:\n                map_location = \"cpu\" if is_sagemaker_mp_enabled() else self.args.device\n                if is_sagemaker_mp_enabled():\n                    if os.path.isfile(os.path.join(checkpoint, \"user_content.pt\")):\n                        # Optimizer checkpoint was saved with smp >= 1.10\n                        def opt_load_hook(mod, opt):\n                            opt.load_state_dict(smp.load(os.path.join(checkpoint, OPTIMIZER_NAME), partial=True))\n\n                    else:\n                        # Optimizer checkpoint was saved with smp < 1.10\n                        def opt_load_hook(mod, opt):\n                            if IS_SAGEMAKER_MP_POST_1_10:\n                                opt.load_state_dict(\n                                    smp.load(os.path.join(checkpoint, OPTIMIZER_NAME), partial=True, back_compat=True)\n                                )\n                            else:\n                                opt.load_state_dict(smp.load(os.path.join(checkpoint, OPTIMIZER_NAME), partial=True))\n\n                    self.model_wrapped.register_post_step_hook(opt_load_hook)\n                else:\n                    self.optimizer.load_state_dict(\n                        torch.load(os.path.join(checkpoint, OPTIMIZER_NAME), map_location=map_location)\n                    )\n                with warnings.catch_warnings(record=True) as caught_warnings:\n                    self.lr_scheduler.load_state_dict(torch.load(os.path.join(checkpoint, SCHEDULER_NAME)))\n                reissue_pt_warnings(caught_warnings)\n                if self.do_grad_scaling and os.path.isfile(os.path.join(checkpoint, SCALER_NAME)):\n                    self.scaler.load_state_dict(torch.load(os.path.join(checkpoint, SCALER_NAME)))\n\n    def hyperparameter_search(\n        self,\n        hp_space: Optional[Callable[[\"optuna.Trial\"], Dict[str, float]]] = None,\n        compute_objective: Optional[Callable[[Dict[str, float]], float]] = None,\n        n_trials: int = 20,\n        direction: str = \"minimize\",\n        backend: Optional[Union[\"str\", HPSearchBackend]] = None,\n        hp_name: Optional[Callable[[\"optuna.Trial\"], str]] = None,\n        **kwargs,\n    ) -> BestRun:\n        \"\"\"\n        Launch an hyperparameter search using `optuna` or `Ray Tune` or `SigOpt`. The optimized quantity is determined\n        by `compute_objective`, which defaults to a function returning the evaluation loss when no metric is provided,\n        the sum of all metrics otherwise.\n\n        <Tip warning={true}>\n\n        To use this method, you need to have provided a `model_init` when initializing your [`Trainer`]: we need to\n        reinitialize the model at each new run. This is incompatible with the `optimizers` argument, so you need to\n        subclass [`Trainer`] and override the method [`~Trainer.create_optimizer_and_scheduler`] for custom\n        optimizer/scheduler.\n\n        </Tip>\n\n        Args:\n            hp_space (`Callable[[\"optuna.Trial\"], Dict[str, float]]`, *optional*):\n                A function that defines the hyperparameter search space. Will default to\n                [`~trainer_utils.default_hp_space_optuna`] or [`~trainer_utils.default_hp_space_ray`] or\n                [`~trainer_utils.default_hp_space_sigopt`] depending on your backend.\n            compute_objective (`Callable[[Dict[str, float]], float]`, *optional*):\n                A function computing the objective to minimize or maximize from the metrics returned by the `evaluate`\n                method. Will default to [`~trainer_utils.default_compute_objective`].\n            n_trials (`int`, *optional*, defaults to 100):\n                The number of trial runs to test.\n            direction (`str`, *optional*, defaults to `\"minimize\"`):\n                Whether to optimize greater or lower objects. Can be `\"minimize\"` or `\"maximize\"`, you should pick\n                `\"minimize\"` when optimizing the validation loss, `\"maximize\"` when optimizing one or several metrics.\n            backend (`str` or [`~training_utils.HPSearchBackend`], *optional*):\n                The backend to use for hyperparameter search. Will default to optuna or Ray Tune or SigOpt, depending\n                on which one is installed. If all are installed, will default to optuna.\n            hp_name (`Callable[[\"optuna.Trial\"], str]]`, *optional*):\n                A function that defines the trial/run name. Will default to None.\n            kwargs (`Dict[str, Any]`, *optional*):\n                Additional keyword arguments passed along to `optuna.create_study` or `ray.tune.run`. For more\n                information see:\n\n                - the documentation of\n                  [optuna.create_study](https://optuna.readthedocs.io/en/stable/reference/generated/optuna.study.create_study.html)\n                - the documentation of [tune.run](https://docs.ray.io/en/latest/tune/api_docs/execution.html#tune-run)\n                - the documentation of [sigopt](https://app.sigopt.com/docs/endpoints/experiments/create)\n\n        Returns:\n            [`trainer_utils.BestRun`]: All the information about the best run. Experiment summary can be found in\n            `run_summary` attribute for Ray backend.\n        \"\"\"\n        if backend is None:\n            backend = default_hp_search_backend()\n            if backend is None:\n                raise RuntimeError(\n                    \"At least one of optuna or ray should be installed. \"\n                    \"To install optuna run `pip install optuna`. \"\n                    \"To install ray run `pip install ray[tune]`. \"\n                    \"To install sigopt run `pip install sigopt`.\"\n                )\n        backend = HPSearchBackend(backend)\n        if backend == HPSearchBackend.OPTUNA and not is_optuna_available():\n            raise RuntimeError(\"You picked the optuna backend, but it is not installed. Use `pip install optuna`.\")\n        if backend == HPSearchBackend.RAY and not is_ray_tune_available():\n            raise RuntimeError(\n                \"You picked the Ray Tune backend, but it is not installed. Use `pip install 'ray[tune]'`.\"\n            )\n        if backend == HPSearchBackend.SIGOPT and not is_sigopt_available():\n            raise RuntimeError(\"You picked the sigopt backend, but it is not installed. Use `pip install sigopt`.\")\n        if backend == HPSearchBackend.WANDB and not is_wandb_available():\n            raise RuntimeError(\"You picked the wandb backend, but it is not installed. Use `pip install wandb`.\")\n        self.hp_search_backend = backend\n        if self.model_init is None:\n            raise RuntimeError(\n                \"To use hyperparameter search, you need to pass your model through a model_init function.\"\n            )\n\n        self.hp_space = default_hp_space[backend] if hp_space is None else hp_space\n        self.hp_name = hp_name\n        self.compute_objective = default_compute_objective if compute_objective is None else compute_objective\n\n        backend_dict = {\n            HPSearchBackend.OPTUNA: run_hp_search_optuna,\n            HPSearchBackend.RAY: run_hp_search_ray,\n            HPSearchBackend.SIGOPT: run_hp_search_sigopt,\n            HPSearchBackend.WANDB: run_hp_search_wandb,\n        }\n        best_run = backend_dict[backend](self, n_trials, direction, **kwargs)\n\n        self.hp_search_backend = None\n        return best_run\n\n    def log(self, logs: Dict[str, float]) -> None:\n        \"\"\"\n        Log `logs` on the various objects watching training.\n\n        Subclass and override this method to inject custom behavior.\n\n        Args:\n            logs (`Dict[str, float]`):\n                The values to log.\n        \"\"\"\n        if self.state.epoch is not None:\n            logs[\"epoch\"] = round(self.state.epoch, 2)\n\n        output = {**logs, **{\"step\": self.state.global_step}}\n        self.state.log_history.append(output)\n        self.control = self.callback_handler.on_log(self.args, self.state, self.control, logs)\n\n    def _prepare_input(self, data: Union[torch.Tensor, Any]) -> Union[torch.Tensor, Any]:\n        \"\"\"\n        Prepares one `data` before feeding it to the model, be it a tensor or a nested list/dictionary of tensors.\n        \"\"\"\n        if isinstance(data, Mapping):\n            return type(data)({k: self._prepare_input(v) for k, v in data.items()})\n        elif isinstance(data, (tuple, list)):\n            return type(data)(self._prepare_input(v) for v in data)\n        elif isinstance(data, torch.Tensor):\n            kwargs = {\"device\": self.args.device}\n            if self.deepspeed and (torch.is_floating_point(data) or torch.is_complex(data)):\n                # NLP models inputs are int/uint and those get adjusted to the right dtype of the\n                # embedding. Other models such as wav2vec2's inputs are already float and thus\n                # may need special handling to match the dtypes of the model\n                kwargs.update({\"dtype\": self.args.hf_deepspeed_config.dtype()})\n            return data.to(**kwargs)\n        return data\n\n    def _prepare_inputs(self, inputs: Dict[str, Union[torch.Tensor, Any]]) -> Dict[str, Union[torch.Tensor, Any]]:\n        \"\"\"\n        Prepare `inputs` before feeding them to the model, converting them to tensors if they are not already and\n        handling potential state.\n        \"\"\"\n        inputs = self._prepare_input(inputs)\n        if len(inputs) == 0:\n            raise ValueError(\n                \"The batch received was empty, your model won't be able to train on it. Double-check that your \"\n                f\"training dataset contains keys expected by the model: {','.join(self._signature_columns)}.\"\n            )\n        if self.args.past_index >= 0 and self._past is not None:\n            inputs[\"mems\"] = self._past\n\n        return inputs\n\n    def compute_loss_context_manager(self):\n        \"\"\"\n        A helper wrapper to group together context managers.\n        \"\"\"\n        return self.autocast_smart_context_manager()\n\n    def autocast_smart_context_manager(self, cache_enabled: Optional[bool] = True):\n        \"\"\"\n        A helper wrapper that creates an appropriate context manager for `autocast` while feeding it the desired\n        arguments, depending on the situation.\n        \"\"\"\n        if self.use_cuda_amp or self.use_cpu_amp:\n            if is_torch_greater_or_equal_than_1_10:\n                ctx_manager = (\n                    torch.cpu.amp.autocast(cache_enabled=cache_enabled, dtype=self.amp_dtype)\n                    if self.use_cpu_amp\n                    else torch.cuda.amp.autocast(cache_enabled=cache_enabled, dtype=self.amp_dtype)\n                )\n            else:\n                ctx_manager = torch.cuda.amp.autocast()\n        else:\n            ctx_manager = contextlib.nullcontext() if sys.version_info >= (3, 7) else contextlib.suppress()\n\n        return ctx_manager\n\n    def training_step(self, model: nn.Module, inputs: Dict[str, Union[torch.Tensor, Any]]) -> torch.Tensor:\n        \"\"\"\n        Perform a training step on a batch of inputs.\n\n        Subclass and override to inject custom behavior.\n\n        Args:\n            model (`nn.Module`):\n                The model to train.\n            inputs (`Dict[str, Union[torch.Tensor, Any]]`):\n                The inputs and targets of the model.\n\n                The dictionary will be unpacked before being fed to the model. Most models expect the targets under the\n                argument `labels`. Check your model's documentation for all accepted arguments.\n\n        Return:\n            `torch.Tensor`: The tensor with training loss on this batch.\n        \"\"\"\n        model.train()\n        inputs = self._prepare_inputs(inputs)\n\n        if is_sagemaker_mp_enabled():\n            loss_mb = smp_forward_backward(model, inputs, self.args.gradient_accumulation_steps)\n            return loss_mb.reduce_mean().detach().to(self.args.device)\n\n        with self.compute_loss_context_manager():\n            loss = self.compute_loss(model, inputs)\n\n        if self.args.n_gpu > 1:\n            loss = loss.mean()  # mean() to average on multi-gpu parallel training\n\n        if self.args.gradient_accumulation_steps > 1 and not self.deepspeed:\n            # deepspeed handles loss scaling by gradient_accumulation_steps in its `backward`\n            loss = loss / self.args.gradient_accumulation_steps\n\n        if self.do_grad_scaling:\n            self.scaler.scale(loss).backward()\n        elif self.use_apex:\n            with amp.scale_loss(loss, self.optimizer) as scaled_loss:\n                scaled_loss.backward()\n        elif self.deepspeed:\n            # loss gets scaled under gradient_accumulation_steps in deepspeed\n            loss = self.deepspeed.backward(loss)\n        else:\n            loss.backward()\n\n        return loss.detach()\n\n    def compute_loss(self, model, inputs, return_outputs=False):\n        \"\"\"\n        How the loss is computed by Trainer. By default, all models return the loss in the first element.\n\n        Subclass and override for custom behavior.\n        \"\"\"\n        if self.label_smoother is not None and \"labels\" in inputs:\n            labels = inputs.pop(\"labels\")\n        else:\n            labels = None\n        outputs = model(**inputs)\n        # Save past state if it exists\n        # TODO: this needs to be fixed and made cleaner later.\n        if self.args.past_index >= 0:\n            self._past = outputs[self.args.past_index]\n\n        if labels is not None:\n            if unwrap_model(model)._get_name() in MODEL_FOR_CAUSAL_LM_MAPPING_NAMES.values():\n                loss = self.label_smoother(outputs, labels, shift_labels=True)\n            else:\n                loss = self.label_smoother(outputs, labels)\n        else:\n            if isinstance(outputs, dict) and \"loss\" not in outputs:\n                raise ValueError(\n                    \"The model did not return a loss from the inputs, only the following keys: \"\n                    f\"{','.join(outputs.keys())}. For reference, the inputs it received are {','.join(inputs.keys())}.\"\n                )\n            # We don't use .loss here since the model may return tuples instead of ModelOutput.\n            loss = outputs[\"loss\"] if isinstance(outputs, dict) else outputs[0]\n\n        return (loss, outputs) if return_outputs else loss\n\n    def is_local_process_zero(self) -> bool:\n        \"\"\"\n        Whether or not this process is the local (e.g., on one machine if training in a distributed fashion on several\n        machines) main process.\n        \"\"\"\n        return self.args.local_process_index == 0\n\n    def is_world_process_zero(self) -> bool:\n        \"\"\"\n        Whether or not this process is the global main process (when training in a distributed fashion on several\n        machines, this is only going to be `True` for one process).\n        \"\"\"\n        # Special case for SageMaker ModelParallel since there process_index is dp_process_index, not the global\n        # process index.\n        if is_sagemaker_mp_enabled():\n            return smp.rank() == 0\n        else:\n            return self.args.process_index == 0\n\n    def save_model(self, output_dir: Optional[str] = None, _internal_call: bool = False):\n        \"\"\"\n        Will save the model, so you can reload it using `from_pretrained()`.\n\n        Will only save from the main process.\n        \"\"\"\n\n        if output_dir is None:\n            output_dir = self.args.output_dir\n\n        if is_torch_tpu_available():\n            self._save_tpu(output_dir)\n        elif is_sagemaker_mp_enabled():\n            # Calling the state_dict needs to be done on the wrapped model and on all processes.\n            os.makedirs(output_dir, exist_ok=True)\n            state_dict = self.model_wrapped.state_dict()\n            if self.args.should_save:\n                self._save(output_dir, state_dict=state_dict)\n            if IS_SAGEMAKER_MP_POST_1_10:\n                # 'user_content.pt' indicates model state_dict saved with smp >= 1.10\n                Path(os.path.join(output_dir, \"user_content.pt\")).touch()\n        elif (\n            ShardedDDPOption.ZERO_DP_2 in self.args.sharded_ddp\n            or ShardedDDPOption.ZERO_DP_3 in self.args.sharded_ddp\n            or self.fsdp is not None\n        ):\n            state_dict = self.model.state_dict()\n\n            if self.args.should_save:\n                self._save(output_dir, state_dict=state_dict)\n        elif self.deepspeed:\n            # this takes care of everything as long as we aren't under zero3\n            if self.args.should_save:\n                self._save(output_dir)\n\n            if is_deepspeed_zero3_enabled():\n                # It's too complicated to try to override different places where the weights dump gets\n                # saved, so since under zero3 the file is bogus, simply delete it. The user should\n                # either user deepspeed checkpoint to resume or to recover full weights use\n                # zero_to_fp32.py stored in the checkpoint.\n                if self.args.should_save:\n                    file = os.path.join(output_dir, WEIGHTS_NAME)\n                    if os.path.isfile(file):\n                        # logger.info(f\"deepspeed zero3: removing {file}, see zero_to_fp32.py to recover weights\")\n                        os.remove(file)\n\n                # now save the real model if stage3_gather_16bit_weights_on_model_save=True\n                # if false it will not be saved.\n                # This must be called on all ranks\n                if not self.deepspeed.save_16bit_model(output_dir, WEIGHTS_NAME):\n                    logger.warning(\n                        \"deepspeed.save_16bit_model didn't save the model, since\"\n                        \" stage3_gather_16bit_weights_on_model_save=false. Saving the full checkpoint instead, use\"\n                        \" zero_to_fp32.py to recover weights\"\n                    )\n                    self.deepspeed.save_checkpoint(output_dir)\n\n        elif self.args.should_save:\n            self._save(output_dir)\n\n        # Push to the Hub when `save_model` is called by the user.\n        if self.args.push_to_hub and not _internal_call:\n            self.push_to_hub(commit_message=\"Model save\")\n\n    def _save_tpu(self, output_dir: Optional[str] = None):\n        output_dir = output_dir if output_dir is not None else self.args.output_dir\n        logger.info(f\"Saving model checkpoint to {output_dir}\")\n\n        if xm.is_master_ordinal():\n            os.makedirs(output_dir, exist_ok=True)\n            torch.save(self.args, os.path.join(output_dir, TRAINING_ARGS_NAME))\n\n        # Save a trained model and configuration using `save_pretrained()`.\n        # They can then be reloaded using `from_pretrained()`\n        xm.rendezvous(\"saving_checkpoint\")\n        if not isinstance(self.model, PreTrainedModel):\n            if isinstance(unwrap_model(self.model), PreTrainedModel):\n                unwrap_model(self.model).save_pretrained(\n                    output_dir,\n                    is_main_process=self.args.should_save,\n                    state_dict=self.model.state_dict(),\n                    save_function=xm.save,\n                )\n            else:\n                logger.info(\"Trainer.model is not a `PreTrainedModel`, only saving its state dict.\")\n                state_dict = self.model.state_dict()\n                xm.save(state_dict, os.path.join(output_dir, WEIGHTS_NAME))\n        else:\n            self.model.save_pretrained(output_dir, is_main_process=self.args.should_save, save_function=xm.save)\n        if self.tokenizer is not None and self.args.should_save:\n            self.tokenizer.save_pretrained(output_dir)\n\n    def _save(self, output_dir: Optional[str] = None, state_dict=None):\n        # If we are executing this function, we are the process zero, so we don't check for that.\n        output_dir = output_dir if output_dir is not None else self.args.output_dir\n        os.makedirs(output_dir, exist_ok=True)\n        logger.info(f\"Saving model checkpoint to {output_dir}\")\n        # Save a trained model and configuration using `save_pretrained()`.\n        # They can then be reloaded using `from_pretrained()`\n\n        self.model.save_pretrained(output_dir)\n\n        # if not isinstance(self.model, PreTrainedModel):\n        #     if isinstance(unwrap_model(self.model), PreTrainedModel):\n        #         if state_dict is None:\n        #             state_dict = self.model.state_dict()\n        #         unwrap_model(self.model).save_pretrained(output_dir, state_dict=filtered_state_dict)\n        #     else:\n        #         logger.info(\"Trainer.model is not a `PreTrainedModel`, only saving its state dict.\")\n        #         if state_dict is None:\n        #             state_dict = self.model.state_dict()\n        #         torch.save(state_dict, os.path.join(output_dir, WEIGHTS_NAME))\n        # else:\n        #     if self.save_prefixencoder:\n        #         print(\"Saving PrefixEncoder\")\n        #         state_dict = self.model.state_dict()\n        #         filtered_state_dict = {}\n        #         for k, v in self.model.named_parameters():\n        #             if v.requires_grad:\n        #                 filtered_state_dict[k] = state_dict[k]\n        #         self.model.save_pretrained(output_dir, state_dict=filtered_state_dict)\n        #     else:\n        #         print(\"Saving the whole model\")\n        #         self.model.save_pretrained(output_dir, state_dict=state_dict)\n\n        if self.tokenizer is not None:\n            self.tokenizer.save_pretrained(output_dir)\n\n        # Good practice: save your training arguments together with the trained model\n        torch.save(self.args, os.path.join(output_dir, TRAINING_ARGS_NAME))\n\n    def store_flos(self):\n        # Storing the number of floating-point operations that went into the model\n        if self.args.local_rank != -1:\n            self.state.total_flos += (\n                distributed_broadcast_scalars([self.current_flos], device=self.args.device).sum().item()\n            )\n            self.current_flos = 0\n        else:\n            self.state.total_flos += self.current_flos\n            self.current_flos = 0\n\n    def _sorted_checkpoints(\n        self, output_dir=None, checkpoint_prefix=PREFIX_CHECKPOINT_DIR, use_mtime=False\n    ) -> List[str]:\n        ordering_and_checkpoint_path = []\n\n        glob_checkpoints = [str(x) for x in Path(output_dir).glob(f\"{checkpoint_prefix}-*\") if os.path.isdir(x)]\n\n        for path in glob_checkpoints:\n            if use_mtime:\n                ordering_and_checkpoint_path.append((os.path.getmtime(path), path))\n            else:\n                regex_match = re.match(f\".*{checkpoint_prefix}-([0-9]+)\", path)\n                if regex_match is not None and regex_match.groups() is not None:\n                    ordering_and_checkpoint_path.append((int(regex_match.groups()[0]), path))\n\n        checkpoints_sorted = sorted(ordering_and_checkpoint_path)\n        checkpoints_sorted = [checkpoint[1] for checkpoint in checkpoints_sorted]\n        # Make sure we don't delete the best model.\n        if self.state.best_model_checkpoint is not None:\n            best_model_index = checkpoints_sorted.index(str(Path(self.state.best_model_checkpoint)))\n            for i in range(best_model_index, len(checkpoints_sorted) - 2):\n                checkpoints_sorted[i], checkpoints_sorted[i + 1] = checkpoints_sorted[i + 1], checkpoints_sorted[i]\n        return checkpoints_sorted\n\n    def _rotate_checkpoints(self, use_mtime=False, output_dir=None) -> None:\n        if self.args.save_total_limit is None or self.args.save_total_limit <= 0:\n            return\n\n        # Check if we should delete older checkpoint(s)\n        checkpoints_sorted = self._sorted_checkpoints(use_mtime=use_mtime, output_dir=output_dir)\n        if len(checkpoints_sorted) <= self.args.save_total_limit:\n            return\n\n        # If save_total_limit=1 with load_best_model_at_end=True, we could end up deleting the last checkpoint, which\n        # we don't do to allow resuming.\n        save_total_limit = self.args.save_total_limit\n        if (\n            self.state.best_model_checkpoint is not None\n            and self.args.save_total_limit == 1\n            and checkpoints_sorted[-1] != self.state.best_model_checkpoint\n        ):\n            save_total_limit = 2\n\n        number_of_checkpoints_to_delete = max(0, len(checkpoints_sorted) - save_total_limit)\n        checkpoints_to_be_deleted = checkpoints_sorted[:number_of_checkpoints_to_delete]\n        for checkpoint in checkpoints_to_be_deleted:\n            logger.info(f\"Deleting older checkpoint [{checkpoint}] due to args.save_total_limit\")\n            shutil.rmtree(checkpoint, ignore_errors=True)\n\n    def evaluate(\n        self,\n        eval_dataset: Optional[Dataset] = None,\n        ignore_keys: Optional[List[str]] = None,\n        metric_key_prefix: str = \"eval\",\n    ) -> Dict[str, float]:\n        \"\"\"\n        Run evaluation and returns metrics.\n\n        The calling script will be responsible for providing a method to compute metrics, as they are task-dependent\n        (pass it to the init `compute_metrics` argument).\n\n        You can also subclass and override this method to inject custom behavior.\n\n        Args:\n            eval_dataset (`Dataset`, *optional*):\n                Pass a dataset if you wish to override `self.eval_dataset`. If it is a [`~datasets.Dataset`], columns\n                not accepted by the `model.forward()` method are automatically removed. It must implement the `__len__`\n                method.\n            ignore_keys (`Lst[str]`, *optional*):\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions.\n            metric_key_prefix (`str`, *optional*, defaults to `\"eval\"`):\n                An optional prefix to be used as the metrics key prefix. For example the metrics \"bleu\" will be named\n                \"eval_bleu\" if the prefix is \"eval\" (default)\n\n        Returns:\n            A dictionary containing the evaluation loss and the potential metrics computed from the predictions. The\n            dictionary also contains the epoch number which comes from the training state.\n        \"\"\"\n        # memory metrics - must set up as early as possible\n        self._memory_tracker.start()\n\n        eval_dataloader = self.get_eval_dataloader(eval_dataset)\n        start_time = time.time()\n\n        eval_loop = self.prediction_loop if self.args.use_legacy_prediction_loop else self.evaluation_loop\n        output = eval_loop(\n            eval_dataloader,\n            description=\"Evaluation\",\n            # No point gathering the predictions if there are no metrics, otherwise we defer to\n            # self.args.prediction_loss_only\n            prediction_loss_only=True if self.compute_metrics is None else None,\n            ignore_keys=ignore_keys,\n            metric_key_prefix=metric_key_prefix,\n        )\n\n        total_batch_size = self.args.eval_batch_size * self.args.world_size\n        if f\"{metric_key_prefix}_jit_compilation_time\" in output.metrics:\n            start_time += output.metrics[f\"{metric_key_prefix}_jit_compilation_time\"]\n        output.metrics.update(\n            speed_metrics(\n                metric_key_prefix,\n                start_time,\n                num_samples=output.num_samples,\n                num_steps=math.ceil(output.num_samples / total_batch_size),\n            )\n        )\n\n        self.log(output.metrics)\n\n        if DebugOption.TPU_METRICS_DEBUG in self.args.debug:\n            # tpu-comment: Logging debug metrics for PyTorch/XLA (compile, execute times, ops, etc.)\n            xm.master_print(met.metrics_report())\n\n        self.control = self.callback_handler.on_evaluate(self.args, self.state, self.control, output.metrics)\n\n        self._memory_tracker.stop_and_update_metrics(output.metrics)\n\n        return output.metrics\n\n    def predict(\n        self, test_dataset: Dataset, ignore_keys: Optional[List[str]] = None, metric_key_prefix: str = \"test\"\n    ) -> PredictionOutput:\n        \"\"\"\n        Run prediction and returns predictions and potential metrics.\n\n        Depending on the dataset and your use case, your test dataset may contain labels. In that case, this method\n        will also return metrics, like in `evaluate()`.\n\n        Args:\n            test_dataset (`Dataset`):\n                Dataset to run the predictions on. If it is an `datasets.Dataset`, columns not accepted by the\n                `model.forward()` method are automatically removed. Has to implement the method `__len__`\n            ignore_keys (`Lst[str]`, *optional*):\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions.\n            metric_key_prefix (`str`, *optional*, defaults to `\"test\"`):\n                An optional prefix to be used as the metrics key prefix. For example the metrics \"bleu\" will be named\n                \"test_bleu\" if the prefix is \"test\" (default)\n\n        <Tip>\n\n        If your predictions or labels have different sequence length (for instance because you're doing dynamic padding\n        in a token classification task) the predictions will be padded (on the right) to allow for concatenation into\n        one array. The padding index is -100.\n\n        </Tip>\n\n        Returns: *NamedTuple* A namedtuple with the following keys:\n\n            - predictions (`np.ndarray`): The predictions on `test_dataset`.\n            - label_ids (`np.ndarray`, *optional*): The labels (if the dataset contained some).\n            - metrics (`Dict[str, float]`, *optional*): The potential dictionary of metrics (if the dataset contained\n              labels).\n        \"\"\"\n        # memory metrics - must set up as early as possible\n        self._memory_tracker.start()\n\n        test_dataloader = self.get_test_dataloader(test_dataset)\n        start_time = time.time()\n\n        eval_loop = self.prediction_loop if self.args.use_legacy_prediction_loop else self.evaluation_loop\n        output = eval_loop(\n            test_dataloader, description=\"Prediction\", ignore_keys=ignore_keys, metric_key_prefix=metric_key_prefix\n        )\n        total_batch_size = self.args.eval_batch_size * self.args.world_size\n        if f\"{metric_key_prefix}_jit_compilation_time\" in output.metrics:\n            start_time += output.metrics[f\"{metric_key_prefix}_jit_compilation_time\"]\n        output.metrics.update(\n            speed_metrics(\n                metric_key_prefix,\n                start_time,\n                num_samples=output.num_samples,\n                num_steps=math.ceil(output.num_samples / total_batch_size),\n            )\n        )\n\n        self.control = self.callback_handler.on_predict(self.args, self.state, self.control, output.metrics)\n        self._memory_tracker.stop_and_update_metrics(output.metrics)\n\n        return PredictionOutput(predictions=output.predictions, label_ids=output.label_ids, metrics=output.metrics)\n\n    def evaluation_loop(\n        self,\n        dataloader: DataLoader,\n        description: str,\n        prediction_loss_only: Optional[bool] = None,\n        ignore_keys: Optional[List[str]] = None,\n        metric_key_prefix: str = \"eval\",\n    ) -> EvalLoopOutput:\n        \"\"\"\n        Prediction/evaluation loop, shared by `Trainer.evaluate()` and `Trainer.predict()`.\n\n        Works both with or without labels.\n        \"\"\"\n        args = self.args\n\n        prediction_loss_only = prediction_loss_only if prediction_loss_only is not None else args.prediction_loss_only\n\n        # if eval is called w/o train init deepspeed here\n        if args.deepspeed and not self.deepspeed:\n            # XXX: eval doesn't have `resume_from_checkpoint` arg but we should be able to do eval\n            # from the checkpoint eventually\n            deepspeed_engine, _, _ = deepspeed_init(\n                self, num_training_steps=0, resume_from_checkpoint=None, inference=True\n            )\n            self.model = deepspeed_engine.module\n            self.model_wrapped = deepspeed_engine\n            self.deepspeed = deepspeed_engine\n\n        model = self._wrap_model(self.model, training=False, dataloader=dataloader)\n\n        # if full fp16 or bf16 eval is wanted and this ``evaluation`` or ``predict`` isn't called\n        # while ``train`` is running, cast it to the right dtype first and then put on device\n        if not self.is_in_train:\n            if args.fp16_full_eval:\n                model = model.to(dtype=torch.float16, device=args.device)\n            elif args.bf16_full_eval:\n                model = model.to(dtype=torch.bfloat16, device=args.device)\n\n        batch_size = self.args.eval_batch_size\n\n        logger.info(f\"***** Running {description} *****\")\n        if has_length(dataloader):\n            logger.info(f\"  Num examples = {self.num_examples(dataloader)}\")\n        else:\n            logger.info(\"  Num examples: Unknown\")\n        logger.info(f\"  Batch size = {batch_size}\")\n\n        model.eval()\n\n        self.callback_handler.eval_dataloader = dataloader\n        # Do this before wrapping.\n        eval_dataset = getattr(dataloader, \"dataset\", None)\n\n        if is_torch_tpu_available():\n            dataloader = pl.ParallelLoader(dataloader, [args.device]).per_device_loader(args.device)\n\n        if args.past_index >= 0:\n            self._past = None\n\n        # Initialize containers\n        # losses/preds/labels on GPU/TPU (accumulated for eval_accumulation_steps)\n        losses_host = None\n        preds_host = None\n        labels_host = None\n        inputs_host = None\n\n        # losses/preds/labels on CPU (final containers)\n        all_losses = None\n        all_preds = None\n        all_labels = None\n        all_inputs = None\n        # Will be useful when we have an iterable dataset so don't know its length.\n\n        observed_num_examples = 0\n        # Main evaluation loop\n        for step, inputs in enumerate(dataloader):\n            # Update the observed num examples\n            observed_batch_size = find_batch_size(inputs)\n            if observed_batch_size is not None:\n                observed_num_examples += observed_batch_size\n                # For batch samplers, batch_size is not known by the dataloader in advance.\n                if batch_size is None:\n                    batch_size = observed_batch_size\n\n            # Prediction step\n            loss, logits, labels = self.prediction_step(model, inputs, prediction_loss_only, ignore_keys=ignore_keys)\n            inputs_decode = self._prepare_input(inputs[\"input_ids\"]) if args.include_inputs_for_metrics else None\n\n            if is_torch_tpu_available():\n                xm.mark_step()\n\n            # Update containers on host\n            if loss is not None:\n                losses = self._nested_gather(loss.repeat(batch_size))\n                losses_host = losses if losses_host is None else torch.cat((losses_host, losses), dim=0)\n            if labels is not None:\n                labels = self._pad_across_processes(labels)\n                labels = self._nested_gather(labels)\n                labels_host = labels if labels_host is None else nested_concat(labels_host, labels, padding_index=-100)\n            if inputs_decode is not None:\n                inputs_decode = self._pad_across_processes(inputs_decode)\n                inputs_decode = self._nested_gather(inputs_decode)\n                inputs_host = (\n                    inputs_decode\n                    if inputs_host is None\n                    else nested_concat(inputs_host, inputs_decode, padding_index=-100)\n                )\n            if logits is not None:\n                logits = self._pad_across_processes(logits)\n                logits = self._nested_gather(logits)\n                if self.preprocess_logits_for_metrics is not None:\n                    logits = self.preprocess_logits_for_metrics(logits, labels)\n                preds_host = logits if preds_host is None else nested_concat(preds_host, logits, padding_index=-100)\n            self.control = self.callback_handler.on_prediction_step(args, self.state, self.control)\n\n            # Gather all tensors and put them back on the CPU if we have done enough accumulation steps.\n            if args.eval_accumulation_steps is not None and (step + 1) % args.eval_accumulation_steps == 0:\n                if losses_host is not None:\n                    losses = nested_numpify(losses_host)\n                    all_losses = losses if all_losses is None else np.concatenate((all_losses, losses), axis=0)\n                if preds_host is not None:\n                    logits = nested_numpify(preds_host)\n                    all_preds = logits if all_preds is None else nested_concat(all_preds, logits, padding_index=-100)\n                if inputs_host is not None:\n                    inputs_decode = nested_numpify(inputs_host)\n                    all_inputs = (\n                        inputs_decode\n                        if all_inputs is None\n                        else nested_concat(all_inputs, inputs_decode, padding_index=-100)\n                    )\n                if labels_host is not None:\n                    labels = nested_numpify(labels_host)\n                    all_labels = (\n                        labels if all_labels is None else nested_concat(all_labels, labels, padding_index=-100)\n                    )\n\n                # Set back to None to begin a new accumulation\n                losses_host, preds_host, inputs_host, labels_host = None, None, None, None\n\n        if args.past_index and hasattr(self, \"_past\"):\n            # Clean the state at the end of the evaluation loop\n            delattr(self, \"_past\")\n\n        # Gather all remaining tensors and put them back on the CPU\n        if losses_host is not None:\n            losses = nested_numpify(losses_host)\n            all_losses = losses if all_losses is None else np.concatenate((all_losses, losses), axis=0)\n        if preds_host is not None:\n            logits = nested_numpify(preds_host)\n            all_preds = logits if all_preds is None else nested_concat(all_preds, logits, padding_index=-100)\n        if inputs_host is not None:\n            inputs_decode = nested_numpify(inputs_host)\n            all_inputs = (\n                inputs_decode if all_inputs is None else nested_concat(all_inputs, inputs_decode, padding_index=-100)\n            )\n        if labels_host is not None:\n            labels = nested_numpify(labels_host)\n            all_labels = labels if all_labels is None else nested_concat(all_labels, labels, padding_index=-100)\n\n        # Number of samples\n        if has_length(eval_dataset):\n            num_samples = len(eval_dataset)\n        # The instance check is weird and does not actually check for the type, but whether the dataset has the right\n        # methods. Therefore we need to make sure it also has the attribute.\n        elif isinstance(eval_dataset, IterableDatasetShard) and getattr(eval_dataset, \"num_examples\", 0) > 0:\n            num_samples = eval_dataset.num_examples\n        else:\n            if has_length(dataloader):\n                num_samples = self.num_examples(dataloader)\n            else:  # both len(dataloader.dataset) and len(dataloader) fail\n                num_samples = observed_num_examples\n        if num_samples == 0 and observed_num_examples > 0:\n            num_samples = observed_num_examples\n\n        # Number of losses has been rounded to a multiple of batch_size and in a distributed training, the number of\n        # samplers has been rounded to a multiple of batch_size, so we truncate.\n        if all_losses is not None:\n            all_losses = all_losses[:num_samples]\n        if all_preds is not None:\n            all_preds = nested_truncate(all_preds, num_samples)\n        if all_labels is not None:\n            all_labels = nested_truncate(all_labels, num_samples)\n        if all_inputs is not None:\n            all_inputs = nested_truncate(all_inputs, num_samples)\n\n        # Metrics!\n        if self.compute_metrics is not None and all_preds is not None and all_labels is not None:\n            if args.include_inputs_for_metrics:\n                metrics = self.compute_metrics(\n                    EvalPrediction(predictions=all_preds, label_ids=all_labels, inputs=all_inputs)\n                )\n            else:\n                metrics = self.compute_metrics(EvalPrediction(predictions=all_preds, label_ids=all_labels))\n        else:\n            metrics = {}\n\n        # To be JSON-serializable, we need to remove numpy types or zero-d tensors\n        metrics = denumpify_detensorize(metrics)\n\n        if all_losses is not None:\n            metrics[f\"{metric_key_prefix}_loss\"] = all_losses.mean().item()\n        if hasattr(self, \"jit_compilation_time\"):\n            metrics[f\"{metric_key_prefix}_jit_compilation_time\"] = self.jit_compilation_time\n\n        # Prefix all keys with metric_key_prefix + '_'\n        for key in list(metrics.keys()):\n            if not key.startswith(f\"{metric_key_prefix}_\"):\n                metrics[f\"{metric_key_prefix}_{key}\"] = metrics.pop(key)\n\n        return EvalLoopOutput(predictions=all_preds, label_ids=all_labels, metrics=metrics, num_samples=num_samples)\n\n    def _nested_gather(self, tensors, name=None):\n        \"\"\"\n        Gather value of `tensors` (tensor or list/tuple of nested tensors) and convert them to numpy before\n        concatenating them to `gathered`\n        \"\"\"\n        if tensors is None:\n            return\n        if is_torch_tpu_available():\n            if name is None:\n                name = \"nested_gather\"\n            tensors = nested_xla_mesh_reduce(tensors, name)\n        elif is_sagemaker_mp_enabled():\n            tensors = smp_gather(tensors)\n        elif self.args.local_rank != -1:\n            tensors = distributed_concat(tensors)\n        return tensors\n\n    # Copied from Accelerate.\n    def _pad_across_processes(self, tensor, pad_index=-100):\n        \"\"\"\n        Recursively pad the tensors in a nested list/tuple/dictionary of tensors from all devices to the same size so\n        they can safely be gathered.\n        \"\"\"\n        if isinstance(tensor, (list, tuple)):\n            return type(tensor)(self._pad_across_processes(t, pad_index=pad_index) for t in tensor)\n        elif isinstance(tensor, dict):\n            return type(tensor)({k: self._pad_across_processes(v, pad_index=pad_index) for k, v in tensor.items()})\n        elif not isinstance(tensor, torch.Tensor):\n            raise TypeError(\n                f\"Can't pad the values of type {type(tensor)}, only of nested list/tuple/dicts of tensors.\"\n            )\n\n        if len(tensor.shape) < 2:\n            return tensor\n        # Gather all sizes\n        size = torch.tensor(tensor.shape, device=tensor.device)[None]\n        sizes = self._nested_gather(size).cpu()\n\n        max_size = max(s[1] for s in sizes)\n        # When extracting XLA graphs for compilation, max_size is 0,\n        # so use inequality to avoid errors.\n        if tensor.shape[1] >= max_size:\n            return tensor\n\n        # Then pad to the maximum size\n        old_size = tensor.shape\n        new_size = list(old_size)\n        new_size[1] = max_size\n        new_tensor = tensor.new_zeros(tuple(new_size)) + pad_index\n        new_tensor[:, : old_size[1]] = tensor\n        return new_tensor\n\n    def prediction_step(\n        self,\n        model: nn.Module,\n        inputs: Dict[str, Union[torch.Tensor, Any]],\n        prediction_loss_only: bool,\n        ignore_keys: Optional[List[str]] = None,\n    ) -> Tuple[Optional[torch.Tensor], Optional[torch.Tensor], Optional[torch.Tensor]]:\n        \"\"\"\n        Perform an evaluation step on `model` using `inputs`.\n\n        Subclass and override to inject custom behavior.\n\n        Args:\n            model (`nn.Module`):\n                The model to evaluate.\n            inputs (`Dict[str, Union[torch.Tensor, Any]]`):\n                The inputs and targets of the model.\n\n                The dictionary will be unpacked before being fed to the model. Most models expect the targets under the\n                argument `labels`. Check your model's documentation for all accepted arguments.\n            prediction_loss_only (`bool`):\n                Whether or not to return the loss only.\n            ignore_keys (`Lst[str]`, *optional*):\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions.\n\n        Return:\n            Tuple[Optional[torch.Tensor], Optional[torch.Tensor], Optional[torch.Tensor]]: A tuple with the loss,\n            logits and labels (each being optional).\n        \"\"\"\n        has_labels = False if len(self.label_names) == 0 else all(inputs.get(k) is not None for k in self.label_names)\n        # For CLIP-like models capable of returning loss values.\n        # If `return_loss` is not specified or being `None` in `inputs`, we check if the default value of `return_loss`\n        # is `True` in `model.forward`.\n        return_loss = inputs.get(\"return_loss\", None)\n        if return_loss is None:\n            return_loss = self.can_return_loss\n        loss_without_labels = True if len(self.label_names) == 0 and return_loss else False\n\n        inputs = self._prepare_inputs(inputs)\n        if ignore_keys is None:\n            if hasattr(self.model, \"config\"):\n                ignore_keys = getattr(self.model.config, \"keys_to_ignore_at_inference\", [])\n            else:\n                ignore_keys = []\n\n        # labels may be popped when computing the loss (label smoothing for instance) so we grab them first.\n        if has_labels or loss_without_labels:\n            labels = nested_detach(tuple(inputs.get(name) for name in self.label_names))\n            if len(labels) == 1:\n                labels = labels[0]\n        else:\n            labels = None\n\n        with torch.no_grad():\n            if is_sagemaker_mp_enabled():\n                raw_outputs = smp_forward_only(model, inputs)\n                if has_labels or loss_without_labels:\n                    if isinstance(raw_outputs, dict):\n                        loss_mb = raw_outputs[\"loss\"]\n                        logits_mb = tuple(v for k, v in raw_outputs.items() if k not in ignore_keys + [\"loss\"])\n                    else:\n                        loss_mb = raw_outputs[0]\n                        logits_mb = raw_outputs[1:]\n\n                    loss = loss_mb.reduce_mean().detach().cpu()\n                    logits = smp_nested_concat(logits_mb)\n                else:\n                    loss = None\n                    if isinstance(raw_outputs, dict):\n                        logits_mb = tuple(v for k, v in raw_outputs.items() if k not in ignore_keys)\n                    else:\n                        logits_mb = raw_outputs\n                    logits = smp_nested_concat(logits_mb)\n            else:\n                if has_labels or loss_without_labels:\n                    with self.compute_loss_context_manager():\n                        loss, outputs = self.compute_loss(model, inputs, return_outputs=True)\n                    loss = loss.mean().detach()\n\n                    if isinstance(outputs, dict):\n                        logits = tuple(v for k, v in outputs.items() if k not in ignore_keys + [\"loss\"])\n                    else:\n                        logits = outputs[1:]\n                else:\n                    loss = None\n                    with self.compute_loss_context_manager():\n                        outputs = model(**inputs)\n                    if isinstance(outputs, dict):\n                        logits = tuple(v for k, v in outputs.items() if k not in ignore_keys)\n                    else:\n                        logits = outputs\n                    # TODO: this needs to be fixed and made cleaner later.\n                    if self.args.past_index >= 0:\n                        self._past = outputs[self.args.past_index - 1]\n\n        if prediction_loss_only:\n            return (loss, None, None)\n\n        logits = nested_detach(logits)\n        if len(logits) == 1:\n            logits = logits[0]\n\n        return (loss, logits, labels)\n\n    def floating_point_ops(self, inputs: Dict[str, Union[torch.Tensor, Any]]):\n        \"\"\"\n        For models that inherit from [`PreTrainedModel`], uses that method to compute the number of floating point\n        operations for every backward + forward pass. If using another model, either implement such a method in the\n        model or subclass and override this method.\n\n        Args:\n            inputs (`Dict[str, Union[torch.Tensor, Any]]`):\n                The inputs and targets of the model.\n\n        Returns:\n            `int`: The number of floating-point operations.\n        \"\"\"\n        if hasattr(self.model, \"floating_point_ops\"):\n            return self.model.floating_point_ops(inputs)\n        else:\n            return 0\n\n    def init_git_repo(self, at_init: bool = False):\n        \"\"\"\n        Initializes a git repo in `self.args.hub_model_id`.\n\n        Args:\n            at_init (`bool`, *optional*, defaults to `False`):\n                Whether this function is called before any training or not. If `self.args.overwrite_output_dir` is\n                `True` and `at_init` is `True`, the path to the repo (which is `self.args.output_dir`) might be wiped\n                out.\n        \"\"\"\n        if not self.is_world_process_zero():\n            return\n        if self.args.hub_model_id is None:\n            repo_name = Path(self.args.output_dir).absolute().name\n        else:\n            repo_name = self.args.hub_model_id\n        if \"/\" not in repo_name:\n            repo_name = get_full_repo_name(repo_name, token=self.args.hub_token)\n\n        # Make sure the repo exists.\n        create_repo(repo_name, token=self.args.hub_token, private=self.args.hub_private_repo, exist_ok=True)\n        try:\n            self.repo = Repository(self.args.output_dir, clone_from=repo_name, token=self.args.hub_token)\n        except EnvironmentError:\n            if self.args.overwrite_output_dir and at_init:\n                # Try again after wiping output_dir\n                shutil.rmtree(self.args.output_dir)\n                self.repo = Repository(self.args.output_dir, clone_from=repo_name, token=self.args.hub_token)\n            else:\n                raise\n\n        self.repo.git_pull()\n\n        # By default, ignore the checkpoint folders\n        if (\n            not os.path.exists(os.path.join(self.args.output_dir, \".gitignore\"))\n            and self.args.hub_strategy != HubStrategy.ALL_CHECKPOINTS\n        ):\n            with open(os.path.join(self.args.output_dir, \".gitignore\"), \"w\", encoding=\"utf-8\") as writer:\n                writer.writelines([\"checkpoint-*/\"])\n\n        # Add \"*.sagemaker\" to .gitignore if using SageMaker\n        if os.environ.get(\"SM_TRAINING_ENV\"):\n            self._add_sm_patterns_to_gitignore()\n\n        self.push_in_progress = None\n\n    def create_model_card(\n        self,\n        language: Optional[str] = None,\n        license: Optional[str] = None,\n        tags: Union[str, List[str], None] = None,\n        model_name: Optional[str] = None,\n        finetuned_from: Optional[str] = None,\n        tasks: Union[str, List[str], None] = None,\n        dataset_tags: Union[str, List[str], None] = None,\n        dataset: Union[str, List[str], None] = None,\n        dataset_args: Union[str, List[str], None] = None,\n    ):\n        \"\"\"\n        Creates a draft of a model card using the information available to the `Trainer`.\n\n        Args:\n            language (`str`, *optional*):\n                The language of the model (if applicable)\n            license (`str`, *optional*):\n                The license of the model. Will default to the license of the pretrained model used, if the original\n                model given to the `Trainer` comes from a repo on the Hub.\n            tags (`str` or `List[str]`, *optional*):\n                Some tags to be included in the metadata of the model card.\n            model_name (`str`, *optional*):\n                The name of the model.\n            finetuned_from (`str`, *optional*):\n                The name of the model used to fine-tune this one (if applicable). Will default to the name of the repo\n                of the original model given to the `Trainer` (if it comes from the Hub).\n            tasks (`str` or `List[str]`, *optional*):\n                One or several task identifiers, to be included in the metadata of the model card.\n            dataset_tags (`str` or `List[str]`, *optional*):\n                One or several dataset tags, to be included in the metadata of the model card.\n            dataset (`str` or `List[str]`, *optional*):\n                One or several dataset identifiers, to be included in the metadata of the model card.\n            dataset_args (`str` or `List[str]`, *optional*):\n               One or several dataset arguments, to be included in the metadata of the model card.\n        \"\"\"\n        if not self.is_world_process_zero():\n            return\n\n        training_summary = TrainingSummary.from_trainer(\n            self,\n            language=language,\n            license=license,\n            tags=tags,\n            model_name=model_name,\n            finetuned_from=finetuned_from,\n            tasks=tasks,\n            dataset_tags=dataset_tags,\n            dataset=dataset,\n            dataset_args=dataset_args,\n        )\n        model_card = training_summary.to_model_card()\n        with open(os.path.join(self.args.output_dir, \"README.md\"), \"w\") as f:\n            f.write(model_card)\n\n    def _push_from_checkpoint(self, checkpoint_folder):\n        # Only push from one node.\n        if not self.is_world_process_zero() or self.args.hub_strategy == HubStrategy.END:\n            return\n        # If we haven't finished the last push, we don't do this one.\n        if self.push_in_progress is not None and not self.push_in_progress.is_done:\n            return\n\n        output_dir = self.args.output_dir\n        # To avoid a new synchronization of all model weights, we just copy the file from the checkpoint folder\n        modeling_files = [CONFIG_NAME, WEIGHTS_NAME]\n        for modeling_file in modeling_files:\n            if os.path.isfile(os.path.join(checkpoint_folder, modeling_file)):\n                shutil.copy(os.path.join(checkpoint_folder, modeling_file), os.path.join(output_dir, modeling_file))\n        # Saving the tokenizer is fast and we don't know how many files it may have spawned, so we resave it to be sure.\n        if self.tokenizer is not None:\n            self.tokenizer.save_pretrained(output_dir)\n        # Same for the training arguments\n        torch.save(self.args, os.path.join(output_dir, TRAINING_ARGS_NAME))\n\n        try:\n            if self.args.hub_strategy == HubStrategy.CHECKPOINT:\n                # Temporarily move the checkpoint just saved for the push\n                tmp_checkpoint = os.path.join(output_dir, \"last-checkpoint\")\n                # We have to remove the \"last-checkpoint\" dir if it exists, otherwise the checkpoint is moved as a\n                # subfolder.\n                if os.path.isdir(tmp_checkpoint):\n                    shutil.rmtree(tmp_checkpoint)\n                shutil.move(checkpoint_folder, tmp_checkpoint)\n\n            if self.args.save_strategy == IntervalStrategy.STEPS:\n                commit_message = f\"Training in progress, step {self.state.global_step}\"\n            else:\n                commit_message = f\"Training in progress, epoch {int(self.state.epoch)}\"\n            _, self.push_in_progress = self.repo.push_to_hub(\n                commit_message=commit_message, blocking=False, auto_lfs_prune=True\n            )\n        finally:\n            if self.args.hub_strategy == HubStrategy.CHECKPOINT:\n                # Move back the checkpoint to its place\n                shutil.move(tmp_checkpoint, checkpoint_folder)\n\n    def push_to_hub(self, commit_message: Optional[str] = \"End of training\", blocking: bool = True, **kwargs) -> str:\n        \"\"\"\n        Upload *self.model* and *self.tokenizer* to the \ud83e\udd17 model hub on the repo *self.args.hub_model_id*.\n\n        Parameters:\n            commit_message (`str`, *optional*, defaults to `\"End of training\"`):\n                Message to commit while pushing.\n            blocking (`bool`, *optional*, defaults to `True`):\n                Whether the function should return only when the `git push` has finished.\n            kwargs:\n                Additional keyword arguments passed along to [`~Trainer.create_model_card`].\n\n        Returns:\n            The url of the commit of your model in the given repository if `blocking=False`, a tuple with the url of\n            the commit and an object to track the progress of the commit if `blocking=True`\n        \"\"\"\n        # If a user calls manually `push_to_hub` with `self.args.push_to_hub = False`, we try to create the repo but\n        # it might fail.\n        if not hasattr(self, \"repo\"):\n            self.init_git_repo()\n\n        model_name = kwargs.pop(\"model_name\", None)\n        if model_name is None and self.args.should_save:\n            if self.args.hub_model_id is None:\n                model_name = Path(self.args.output_dir).name\n            else:\n                model_name = self.args.hub_model_id.split(\"/\")[-1]\n\n        # Needs to be executed on all processes for TPU training, but will only save on the processed determined by\n        # self.args.should_save.\n        self.save_model(_internal_call=True)\n\n        # Only push from one node.\n        if not self.is_world_process_zero():\n            return\n\n        # Cancel any async push in progress if blocking=True. The commits will all be pushed together.\n        if blocking and self.push_in_progress is not None and not self.push_in_progress.is_done:\n            self.push_in_progress._process.kill()\n            self.push_in_progress = None\n\n        git_head_commit_url = self.repo.push_to_hub(\n            commit_message=commit_message, blocking=blocking, auto_lfs_prune=True\n        )\n        # push separately the model card to be independant from the rest of the model\n        if self.args.should_save:\n            self.create_model_card(model_name=model_name, **kwargs)\n            try:\n                self.repo.push_to_hub(\n                    commit_message=\"update model card README.md\", blocking=blocking, auto_lfs_prune=True\n                )\n            except EnvironmentError as exc:\n                logger.error(f\"Error pushing update to the model card. Please read logs and retry.\\n${exc}\")\n\n        return git_head_commit_url\n\n    #\n    # Deprecated code\n    #\n\n    def prediction_loop(\n        self,\n        dataloader: DataLoader,\n        description: str,\n        prediction_loss_only: Optional[bool] = None,\n        ignore_keys: Optional[List[str]] = None,\n        metric_key_prefix: str = \"eval\",\n    ) -> EvalLoopOutput:\n        \"\"\"\n        Prediction/evaluation loop, shared by `Trainer.evaluate()` and `Trainer.predict()`.\n\n        Works both with or without labels.\n        \"\"\"\n        args = self.args\n\n        if not has_length(dataloader):\n            raise ValueError(\"dataloader must implement a working __len__\")\n\n        prediction_loss_only = prediction_loss_only if prediction_loss_only is not None else args.prediction_loss_only\n\n        # if eval is called w/o train init deepspeed here\n        if args.deepspeed and not self.deepspeed:\n            # XXX: eval doesn't have `resume_from_checkpoint` arg but we should be able to do eval\n            # from the checkpoint eventually\n            deepspeed_engine, _, _ = deepspeed_init(self, num_training_steps=0, resume_from_checkpoint=None)\n            self.model = deepspeed_engine.module\n            self.model_wrapped = deepspeed_engine\n            self.deepspeed = deepspeed_engine\n            # XXX: we don't need optim/sched for inference, but this needs to be sorted out, since\n            # for example the Z3-optimizer is a must for zero3 to work even for inference - what we\n            # don't need is the deepspeed basic optimizer which is self.optimizer.optimizer\n            deepspeed_engine.optimizer.optimizer = None\n            deepspeed_engine.lr_scheduler = None\n\n        model = self._wrap_model(self.model, training=False, dataloader=dataloader)\n\n        # if full fp16 or bf16 eval is wanted and this ``evaluation`` or ``predict`` isn't called\n        # while ``train`` is running, cast it to the right dtype first and then put on device\n        if not self.is_in_train:\n            if args.fp16_full_eval:\n                model = model.to(dtype=torch.float16, device=args.device)\n            elif args.bf16_full_eval:\n                model = model.to(dtype=torch.bfloat16, device=args.device)\n\n        batch_size = dataloader.batch_size\n        num_examples = self.num_examples(dataloader)\n        logger.info(f\"***** Running {description} *****\")\n        logger.info(f\"  Num examples = {num_examples}\")\n        logger.info(f\"  Batch size = {batch_size}\")\n        losses_host: torch.Tensor = None\n        preds_host: Union[torch.Tensor, List[torch.Tensor]] = None\n        labels_host: Union[torch.Tensor, List[torch.Tensor]] = None\n        inputs_host: Union[torch.Tensor, List[torch.Tensor]] = None\n\n        world_size = max(1, args.world_size)\n\n        eval_losses_gatherer = DistributedTensorGatherer(world_size, num_examples, make_multiple_of=batch_size)\n        if not prediction_loss_only:\n            # The actual number of eval_sample can be greater than num_examples in distributed settings (when we pass\n            # a batch size to the sampler)\n            make_multiple_of = None\n            if hasattr(dataloader, \"sampler\") and isinstance(dataloader.sampler, SequentialDistributedSampler):\n                make_multiple_of = dataloader.sampler.batch_size\n            preds_gatherer = DistributedTensorGatherer(world_size, num_examples, make_multiple_of=make_multiple_of)\n            labels_gatherer = DistributedTensorGatherer(world_size, num_examples, make_multiple_of=make_multiple_of)\n            inputs_gatherer = DistributedTensorGatherer(world_size, num_examples, make_multiple_of=make_multiple_of)\n\n        model.eval()\n\n        if is_torch_tpu_available():\n            dataloader = pl.ParallelLoader(dataloader, [args.device]).per_device_loader(args.device)\n\n        if args.past_index >= 0:\n            self._past = None\n\n        self.callback_handler.eval_dataloader = dataloader\n\n        for step, inputs in enumerate(dataloader):\n            loss, logits, labels = self.prediction_step(model, inputs, prediction_loss_only, ignore_keys=ignore_keys)\n            inputs_decode = self._prepare_input(inputs[\"input_ids\"]) if args.include_inputs_for_metrics else None\n\n            if loss is not None:\n                losses = loss.repeat(batch_size)\n                losses_host = losses if losses_host is None else torch.cat((losses_host, losses), dim=0)\n            if logits is not None:\n                preds_host = logits if preds_host is None else nested_concat(preds_host, logits, padding_index=-100)\n            if labels is not None:\n                labels_host = labels if labels_host is None else nested_concat(labels_host, labels, padding_index=-100)\n            if inputs_decode is not None:\n                inputs_host = (\n                    inputs_decode\n                    if inputs_host is None\n                    else nested_concat(inputs_host, inputs_decode, padding_index=-100)\n                )\n            self.control = self.callback_handler.on_prediction_step(args, self.state, self.control)\n\n            # Gather all tensors and put them back on the CPU if we have done enough accumulation steps.\n            if args.eval_accumulation_steps is not None and (step + 1) % args.eval_accumulation_steps == 0:\n                eval_losses_gatherer.add_arrays(self._gather_and_numpify(losses_host, \"eval_losses\"))\n                if not prediction_loss_only:\n                    preds_gatherer.add_arrays(self._gather_and_numpify(preds_host, \"eval_preds\"))\n                    labels_gatherer.add_arrays(self._gather_and_numpify(labels_host, \"eval_label_ids\"))\n                    inputs_gatherer.add_arrays(self._gather_and_numpify(inputs_host, \"eval_inputs_ids\"))\n\n                # Set back to None to begin a new accumulation\n                losses_host, preds_host, labels_host, inputs_host = None, None, None, None\n\n        if args.past_index and hasattr(self, \"_past\"):\n            # Clean the state at the end of the evaluation loop\n            delattr(self, \"_past\")\n\n        # Gather all remaining tensors and put them back on the CPU\n        eval_losses_gatherer.add_arrays(self._gather_and_numpify(losses_host, \"eval_losses\"))\n        if not prediction_loss_only:\n            preds_gatherer.add_arrays(self._gather_and_numpify(preds_host, \"eval_preds\"))\n            labels_gatherer.add_arrays(self._gather_and_numpify(labels_host, \"eval_label_ids\"))\n            inputs_gatherer.add_arrays(self._gather_and_numpify(inputs_host, \"eval_inputs_ids\"))\n\n        eval_loss = eval_losses_gatherer.finalize()\n        preds = preds_gatherer.finalize() if not prediction_loss_only else None\n        label_ids = labels_gatherer.finalize() if not prediction_loss_only else None\n        inputs_ids = inputs_gatherer.finalize() if not prediction_loss_only else None\n\n        if self.compute_metrics is not None and preds is not None and label_ids is not None:\n            if args.include_inputs_for_metrics:\n                metrics = self.compute_metrics(\n                    EvalPrediction(predictions=preds, label_ids=label_ids, inputs=inputs_ids)\n                )\n            else:\n                metrics = self.compute_metrics(EvalPrediction(predictions=preds, label_ids=label_ids))\n        else:\n            metrics = {}\n\n        # To be JSON-serializable, we need to remove numpy types or zero-d tensors\n        metrics = denumpify_detensorize(metrics)\n\n        if eval_loss is not None:\n            metrics[f\"{metric_key_prefix}_loss\"] = eval_loss.mean().item()\n\n        # Prefix all keys with metric_key_prefix + '_'\n        for key in list(metrics.keys()):\n            if not key.startswith(f\"{metric_key_prefix}_\"):\n                metrics[f\"{metric_key_prefix}_{key}\"] = metrics.pop(key)\n\n        return EvalLoopOutput(predictions=preds, label_ids=label_ids, metrics=metrics, num_samples=num_examples)\n\n    def _gather_and_numpify(self, tensors, name):\n        \"\"\"\n        Gather value of `tensors` (tensor or list/tuple of nested tensors) and convert them to numpy before\n        concatenating them to `gathered`\n        \"\"\"\n        if tensors is None:\n            return\n        if is_torch_tpu_available():\n            tensors = nested_xla_mesh_reduce(tensors, name)\n        elif is_sagemaker_mp_enabled():\n            tensors = smp_gather(tensors)\n        elif self.args.local_rank != -1:\n            tensors = distributed_concat(tensors)\n\n        return nested_numpify(tensors)\n\n    def _add_sm_patterns_to_gitignore(self) -> None:\n        \"\"\"Add SageMaker Checkpointing patterns to .gitignore file.\"\"\"\n        # Make sure we only do this on the main process\n        if not self.is_world_process_zero():\n            return\n\n        patterns = [\"*.sagemaker-uploading\", \"*.sagemaker-uploaded\"]\n\n        # Get current .gitignore content\n        if os.path.exists(os.path.join(self.repo.local_dir, \".gitignore\")):\n            with open(os.path.join(self.repo.local_dir, \".gitignore\"), \"r\") as f:\n                current_content = f.read()\n        else:\n            current_content = \"\"\n\n        # Add the patterns to .gitignore\n        content = current_content\n        for pattern in patterns:\n            if pattern not in content:\n                if content.endswith(\"\\n\"):\n                    content += pattern\n                else:\n                    content += f\"\\n{pattern}\"\n\n        # Write the .gitignore file if it has changed\n        if content != current_content:\n            with open(os.path.join(self.repo.local_dir, \".gitignore\"), \"w\") as f:\n                logger.debug(f\"Writing .gitignore file. Content: {content}\")\n                f.write(content)\n\n        self.repo.git_add(\".gitignore\")\n\n        # avoid race condition with git status\n        time.sleep(0.5)\n\n        if not self.repo.is_repo_clean():\n            self.repo.git_commit(\"Add *.sagemaker patterns to .gitignore.\")\n            self.repo.git_push()", ""]}
{"filename": "ft_chatglm_lora/peft/peft_model.py", "chunked_list": ["# coding=utf-8\n# Copyright 2023-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport inspect\nimport os\nimport warnings", "import os\nimport warnings\nfrom contextlib import contextmanager\n\nimport torch\nfrom accelerate import dispatch_model, infer_auto_device_map\nfrom accelerate.hooks import AlignDevicesHook, add_hook_to_module, remove_hook_from_submodules\nfrom accelerate.utils import get_balanced_memory\nfrom huggingface_hub import hf_hub_download\nfrom torch.nn import BCEWithLogitsLoss, CrossEntropyLoss, MSELoss", "from huggingface_hub import hf_hub_download\nfrom torch.nn import BCEWithLogitsLoss, CrossEntropyLoss, MSELoss\nfrom transformers import PreTrainedModel\nfrom transformers.modeling_outputs import SequenceClassifierOutput, TokenClassifierOutput\nfrom transformers.utils import PushToHubMixin\n\nfrom .tuners import (\n    AdaLoraModel,\n    AdaptionPromptModel,\n    LoraModel,", "    AdaptionPromptModel,\n    LoraModel,\n    PrefixEncoder,\n    PromptEmbedding,\n    PromptEncoder,\n)\nfrom .utils import (\n    TRANSFORMERS_MODELS_TO_PREFIX_TUNING_POSTPROCESS_MAPPING,\n    WEIGHTS_NAME,\n    PeftConfig,", "    WEIGHTS_NAME,\n    PeftConfig,\n    PeftType,\n    PromptLearningConfig,\n    TaskType,\n    _set_adapter,\n    _set_trainable,\n    get_peft_model_state_dict,\n    set_peft_model_state_dict,\n    shift_tokens_right,", "    set_peft_model_state_dict,\n    shift_tokens_right,\n)\n\n\nPEFT_TYPE_TO_MODEL_MAPPING = {\n    PeftType.LORA: LoraModel,\n    PeftType.PROMPT_TUNING: PromptEmbedding,\n    PeftType.P_TUNING: PromptEncoder,\n    PeftType.PREFIX_TUNING: PrefixEncoder,", "    PeftType.P_TUNING: PromptEncoder,\n    PeftType.PREFIX_TUNING: PrefixEncoder,\n    PeftType.ADALORA: AdaLoraModel,\n    PeftType.ADAPTION_PROMPT: AdaptionPromptModel,\n}\n\n\nclass PeftModel(PushToHubMixin, torch.nn.Module):\n    \"\"\"\n    Base model encompassing various Peft methods.\n\n    Args:\n        model ([`~transformers.PreTrainedModel`]): The base transformer model used for Peft.\n        peft_config ([`PeftConfig`]): The configuration of the Peft model.\n\n\n    **Attributes**:\n        - **base_model** ([`~transformers.PreTrainedModel`]) -- The base transformer model used for Peft.\n        - **peft_config** ([`PeftConfig`]) -- The configuration of the Peft model.\n        - **modules_to_save** (`list` of `str`) -- The list of sub-module names to save when\n        saving the model.\n        - **prompt_encoder** ([`PromptEncoder`]) -- The prompt encoder used for Peft if\n        using [`PromptLearningConfig`].\n        - **prompt_tokens** (`torch.Tensor`) -- The virtual prompt tokens used for Peft if\n        using [`PromptLearningConfig`].\n        - **transformer_backbone_name** (`str`) -- The name of the transformer\n        backbone in the base model if using [`PromptLearningConfig`].\n        - **word_embeddings** (`torch.nn.Embedding`) -- The word embeddings of the transformer backbone\n        in the base model if using [`PromptLearningConfig`].\n    \"\"\"\n\n    def __init__(self, model, peft_config: PeftConfig, adapter_name=\"default\"):\n        super().__init__()\n        self.base_model = model\n        self.config = self.base_model.config\n        self.modules_to_save = None\n        self.peft_config = {}\n        self.active_adapter = adapter_name\n        self.peft_type = peft_config.peft_type\n        self.base_model_torch_dtype = getattr(model, \"dtype\", None)\n        if not isinstance(peft_config, PromptLearningConfig):\n            self.peft_config[adapter_name] = peft_config\n            self.base_model = PEFT_TYPE_TO_MODEL_MAPPING[peft_config.peft_type](\n                self.base_model, self.peft_config, adapter_name\n            )\n            self.set_additional_trainable_modules(peft_config, adapter_name)\n        else:\n            self.add_adapter(adapter_name, peft_config)\n\n    def save_pretrained(self, save_directory, **kwargs):\n        r\"\"\"\n        This function saves the adapter model and the adapter configuration files to a directory, so that it can be\n        reloaded using the [`LoraModel.from_pretrained`] class method, and also used by the [`LoraModel.push_to_hub`]\n        method.\n\n        Args:\n            save_directory (`str`):\n                Directory where the adapter model and configuration files will be saved (will be created if it does not\n                exist).\n            kwargs (additional keyword arguments, *optional*):\n                Additional keyword arguments passed along to the `push_to_hub` method.\n        \"\"\"\n        if os.path.isfile(save_directory):\n            raise ValueError(f\"Provided path ({save_directory}) should be a directory, not a file\")\n        os.makedirs(save_directory, exist_ok=True)\n\n        for adapter_name, peft_config in self.peft_config.items():\n            # save only the trainable weights\n            output_state_dict = get_peft_model_state_dict(\n                self, state_dict=kwargs.get(\"state_dict\", None), adapter_name=adapter_name\n            )\n            output_dir = os.path.join(save_directory, adapter_name) if adapter_name != \"default\" else save_directory\n            os.makedirs(output_dir, exist_ok=True)\n            torch.save(output_state_dict, os.path.join(output_dir, WEIGHTS_NAME))\n\n            # save the config and change the inference mode to `True`\n            if peft_config.base_model_name_or_path is None:\n                peft_config.base_model_name_or_path = (\n                    self.base_model.__dict__.get(\"name_or_path\", None)\n                    if isinstance(peft_config, PromptLearningConfig)\n                    else self.base_model.model.__dict__.get(\"name_or_path\", None)\n                )\n            inference_mode = peft_config.inference_mode\n            peft_config.inference_mode = True\n            peft_config.save_pretrained(output_dir)\n            peft_config.inference_mode = inference_mode\n\n    @classmethod\n    def from_pretrained(cls, model, model_id, adapter_name=\"default\", is_trainable=False, **kwargs):\n        r\"\"\"\n        Instantiate a [`LoraModel`] from a pretrained Lora configuration and weights.\n\n        Args:\n            model ([`~transformers.PreTrainedModel`]):\n                The model to be adapted. The model should be initialized with the\n                [`~transformers.PreTrainedModel.from_pretrained`] method from the \ud83e\udd17 Transformers library.\n            model_id (`str` or `os.PathLike`):\n                The name of the Lora configuration to use. Can be either:\n                    - A string, the `model id` of a Lora configuration hosted inside a model repo on the Hugging Face\n                      Hub.\n                    - A path to a directory containing a Lora configuration file saved using the `save_pretrained`\n                      method (`./my_lora_config_directory/`).\n        \"\"\"\n        from .mapping import MODEL_TYPE_TO_PEFT_MODEL_MAPPING, PEFT_TYPE_TO_CONFIG_MAPPING\n\n        # load the config\n        config = PEFT_TYPE_TO_CONFIG_MAPPING[\n            PeftConfig.from_pretrained(model_id, subfolder=kwargs.get(\"subfolder\", None)).peft_type\n        ].from_pretrained(model_id, subfolder=kwargs.get(\"subfolder\", None))\n\n        if (getattr(model, \"hf_device_map\", None) is not None) and len(\n            set(model.hf_device_map.values()).intersection({\"cpu\", \"disk\"})\n        ) > 0:\n            remove_hook_from_submodules(model)\n\n        if isinstance(config, PromptLearningConfig) and is_trainable:\n            raise ValueError(\"Cannot set a prompt learning adapter to trainable when loading pretrained adapter.\")\n        else:\n            config.inference_mode = not is_trainable\n\n        if config.task_type not in MODEL_TYPE_TO_PEFT_MODEL_MAPPING.keys():\n            model = cls(model, config, adapter_name)\n        else:\n            model = MODEL_TYPE_TO_PEFT_MODEL_MAPPING[config.task_type](model, config, adapter_name)\n        model.load_adapter(model_id, adapter_name, **kwargs)\n        return model\n\n    def _setup_prompt_encoder(self, adapter_name):\n        config = self.peft_config[adapter_name]\n        self.prompt_encoder = torch.nn.ModuleDict({})\n        self.prompt_tokens = {}\n        transformer_backbone = None\n        for name, module in self.base_model.named_children():\n            for param in module.parameters():\n                param.requires_grad = False\n            if isinstance(module, PreTrainedModel):\n                # Make sure to freeze Tranformers model\n                if transformer_backbone is None:\n                    transformer_backbone = module\n                    self.transformer_backbone_name = name\n\n        if config.num_transformer_submodules is None:\n            config.num_transformer_submodules = 2 if config.task_type == TaskType.SEQ_2_SEQ_LM else 1\n\n        for named_param, value in list(transformer_backbone.named_parameters()):\n            if value.shape[0] == self.base_model.config.vocab_size:\n                self.word_embeddings = transformer_backbone.get_submodule(named_param.replace(\".weight\", \"\"))\n                break\n\n        if config.peft_type == PeftType.PROMPT_TUNING:\n            prompt_encoder = PromptEmbedding(config, self.word_embeddings)\n        elif config.peft_type == PeftType.P_TUNING:\n            prompt_encoder = PromptEncoder(config)\n        elif config.peft_type == PeftType.PREFIX_TUNING:\n            prompt_encoder = PrefixEncoder(config)\n        else:\n            raise ValueError(\"Not supported\")\n        self.prompt_encoder.update(torch.nn.ModuleDict({adapter_name: prompt_encoder}))\n        self.prompt_tokens[adapter_name] = torch.arange(\n            config.num_virtual_tokens * config.num_transformer_submodules\n        ).long()\n\n    def get_prompt_embedding_to_save(self, adapter_name):\n        \"\"\"\n        Returns the prompt embedding to save when saving the model. Only applicable when `peft_config.peft_type !=\n        PeftType.LORA`.\n        \"\"\"\n        prompt_tokens = self.prompt_tokens[adapter_name].unsqueeze(0).expand(1, -1).to(self.device)\n        if self.peft_config[adapter_name].peft_type == PeftType.PREFIX_TUNING:\n            prompt_tokens = prompt_tokens[:, : self.peft_config[adapter_name].num_virtual_tokens]\n        prompt_embeddings = self.prompt_encoder[adapter_name](prompt_tokens)\n        return prompt_embeddings[0].detach().cpu()\n\n    def get_prompt(self, batch_size):\n        \"\"\"\n        Returns the virtual prompts to use for Peft. Only applicable when `peft_config.peft_type != PeftType.LORA`.\n        \"\"\"\n        peft_config = self.active_peft_config\n        prompt_encoder = self.prompt_encoder[self.active_adapter]\n        prompt_tokens = self.prompt_tokens[self.active_adapter].unsqueeze(0).expand(batch_size, -1).to(self.device)\n        if peft_config.peft_type == PeftType.PREFIX_TUNING:\n            prompt_tokens = prompt_tokens[:, : peft_config.num_virtual_tokens]\n            if peft_config.inference_mode:\n                past_key_values = prompt_encoder.embedding.weight.repeat(batch_size, 1, 1)\n            else:\n                past_key_values = prompt_encoder(prompt_tokens)\n            past_key_values = past_key_values.view(\n                batch_size,\n                peft_config.num_virtual_tokens,\n                peft_config.num_layers * 2,\n                peft_config.num_attention_heads,\n                peft_config.token_dim // peft_config.num_attention_heads,\n            )\n            if peft_config.num_transformer_submodules == 2:\n                past_key_values = torch.cat([past_key_values, past_key_values], dim=2)\n            past_key_values = past_key_values.permute([2, 0, 3, 1, 4]).split(\n                peft_config.num_transformer_submodules * 2\n            )\n            if TRANSFORMERS_MODELS_TO_PREFIX_TUNING_POSTPROCESS_MAPPING.get(self.config.model_type, None) is not None:\n                post_process_fn = TRANSFORMERS_MODELS_TO_PREFIX_TUNING_POSTPROCESS_MAPPING[self.config.model_type]\n                past_key_values = post_process_fn(past_key_values)\n            return past_key_values\n        else:\n            if peft_config.inference_mode:\n                prompts = prompt_encoder.embedding.weight.repeat(batch_size, 1, 1)\n            else:\n                prompts = prompt_encoder(prompt_tokens)\n            return prompts\n\n    def print_trainable_parameters(self):\n        \"\"\"\n        Prints the number of trainable parameters in the model.\n        \"\"\"\n        trainable_params = 0\n        all_param = 0\n        for _, param in self.named_parameters():\n            num_params = param.numel()\n            # if using DS Zero 3 and the weights are initialized empty\n            if num_params == 0 and hasattr(param, \"ds_numel\"):\n                num_params = param.ds_numel\n\n            all_param += num_params\n            if param.requires_grad:\n                trainable_params += num_params\n        print(\n            f\"trainable params: {trainable_params} || all params: {all_param} || trainable%: {100 * trainable_params / all_param}\"\n        )\n\n    def __getattr__(self, name: str):\n        \"\"\"Forward missing attributes to the wrapped module.\"\"\"\n        try:\n            return super().__getattr__(name)  # defer to nn.Module's logic\n        except AttributeError:\n            return getattr(self.base_model, name)\n\n    def forward(self, *args, **kwargs):\n        \"\"\"\n        Forward pass of the model.\n        \"\"\"\n        return self.get_base_model()(*args, **kwargs)\n\n    @contextmanager\n    def disable_adapter(self):\n        \"\"\"\n        Disables the adapter module.\n        \"\"\"\n        try:\n            if isinstance(self.peft_config, PromptLearningConfig):\n                old_forward = self.forward\n                self.forward = self.base_model.forward\n            else:\n                self.base_model.disable_adapter_layers()\n            yield\n        finally:\n            if isinstance(self.peft_config, PromptLearningConfig):\n                self.forward = old_forward\n            else:\n                self.base_model.enable_adapter_layers()\n\n    def get_base_model(self):\n        \"\"\"\n        Returns the base model.\n        \"\"\"\n        return self.base_model if isinstance(self.active_peft_config, PromptLearningConfig) else self.base_model.model\n\n    def add_adapter(self, adapter_name, peft_config):\n        if peft_config.peft_type != self.peft_type:\n            raise ValueError(\n                f\"Cannot combine adapters with different peft types. \"\n                f\"Found {self.peft_type} and {peft_config.peft_type}.\"\n            )\n        self.peft_config[adapter_name] = peft_config\n        if isinstance(peft_config, PromptLearningConfig):\n            self._setup_prompt_encoder(adapter_name)\n        else:\n            self.base_model.add_adapter(adapter_name, peft_config)\n\n        self.set_additional_trainable_modules(peft_config, adapter_name)\n\n    def set_additional_trainable_modules(self, peft_config, adapter_name):\n        if getattr(peft_config, \"modules_to_save\", None) is not None:\n            if self.modules_to_save is None:\n                self.modules_to_save = set(peft_config.modules_to_save)\n            else:\n                self.modules_to_save.update(peft_config.modules_to_save)\n            _set_trainable(self, adapter_name)\n\n    def load_adapter(self, model_id, adapter_name, is_trainable=False, **kwargs):\n        from .mapping import PEFT_TYPE_TO_CONFIG_MAPPING\n\n        if adapter_name not in self.peft_config:\n            # load the config\n            peft_config = PEFT_TYPE_TO_CONFIG_MAPPING[\n                PeftConfig.from_pretrained(model_id, subfolder=kwargs.get(\"subfolder\", None)).peft_type\n            ].from_pretrained(model_id, subfolder=kwargs.get(\"subfolder\", None))\n            if isinstance(peft_config, PromptLearningConfig) and is_trainable:\n                raise ValueError(\"Cannot set a prompt learning adapter to trainable when loading pretrained adapter.\")\n            else:\n                peft_config.inference_mode = not is_trainable\n            self.add_adapter(adapter_name, peft_config)\n\n        # load weights if any\n        path = os.path.join(model_id, kwargs[\"subfolder\"]) if kwargs.get(\"subfolder\", None) is not None else model_id\n\n        if os.path.exists(os.path.join(path, WEIGHTS_NAME)):\n            filename = os.path.join(path, WEIGHTS_NAME)\n        else:\n            try:\n                filename = hf_hub_download(model_id, WEIGHTS_NAME, subfolder=kwargs.get(\"subfolder\", None))\n            except:  # noqa\n                raise ValueError(\n                    f\"Can't find weights for {model_id} in {model_id} or in the Hugging Face Hub. \"\n                    f\"Please check that the file {WEIGHTS_NAME} is present at {model_id}.\"\n                )\n\n        adapters_weights = torch.load(\n            filename, map_location=torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n        )\n        # load the weights into the model\n        set_peft_model_state_dict(self, adapters_weights, adapter_name=adapter_name)\n        if (\n            (getattr(self, \"hf_device_map\", None) is not None)\n            and (len(set(self.hf_device_map.values()).intersection({\"cpu\", \"disk\"})) > 0)\n            and len(self.peft_config) == 1\n        ):\n            device_map = kwargs.get(\"device_map\", \"auto\")\n            max_memory = kwargs.get(\"max_memory\", None)\n            offload_dir = kwargs.get(\"offload_folder\", None)\n            offload_index = kwargs.get(\"offload_index\", None)\n\n            dispatch_model_kwargs = {}\n            # Safety checker for previous `accelerate` versions\n            # `offload_index` was introduced in https://github.com/huggingface/accelerate/pull/873/\n            if \"offload_index\" in inspect.signature(dispatch_model).parameters:\n                dispatch_model_kwargs[\"offload_index\"] = offload_index\n\n            no_split_module_classes = self._no_split_modules\n\n            if device_map != \"sequential\":\n                max_memory = get_balanced_memory(\n                    self,\n                    max_memory=max_memory,\n                    no_split_module_classes=no_split_module_classes,\n                    low_zero=(device_map == \"balanced_low_0\"),\n                )\n            if isinstance(device_map, str):\n                device_map = infer_auto_device_map(\n                    self, max_memory=max_memory, no_split_module_classes=no_split_module_classes\n                )\n            dispatch_model(\n                self,\n                device_map=device_map,\n                offload_dir=offload_dir,\n                **dispatch_model_kwargs,\n            )\n            hook = AlignDevicesHook(io_same_device=True)\n            if isinstance(self.peft_config[adapter_name], PromptLearningConfig):\n                remove_hook_from_submodules(self.prompt_encoder)\n            add_hook_to_module(self.get_base_model(), hook)\n\n        # Set model in evaluation mode to deactivate Dropout modules by default\n        self.eval()\n\n    def set_adapter(self, adapter_name):\n        \"\"\"\n        Sets the active adapter.\n        \"\"\"\n        if adapter_name not in self.peft_config:\n            raise ValueError(f\"Adapter {adapter_name} not found.\")\n        self.active_adapter = adapter_name\n        if not isinstance(self.peft_config[adapter_name], PromptLearningConfig):\n            self.base_model.set_adapter(adapter_name)\n        _set_adapter(self, adapter_name)\n\n    @property\n    def active_peft_config(self):\n        return self.peft_config[self.active_adapter]", "\n\nclass PeftModelForSequenceClassification(PeftModel):\n    \"\"\"\n    Peft model for sequence classification tasks.\n\n    Args:\n        model ([`~transformers.PreTrainedModel`]): Base transformer model.\n        peft_config ([`PeftConfig`]): Peft config.\n\n    **Attributes**:\n        - **config** ([`~transformers.PretrainedConfig`]) -- The configuration object of the base model.\n        - **cls_layer_name** (`str`) -- The name of the classification layer.\n\n    Example:\n\n        ```py\n        >>> from transformers import AutoModelForSequenceClassification\n        >>> from peft import PeftModelForSequenceClassification, get_peft_config\n\n        >>> config = {\n        ...     \"peft_type\": \"PREFIX_TUNING\",\n        ...     \"task_type\": \"SEQ_CLS\",\n        ...     \"inference_mode\": False,\n        ...     \"num_virtual_tokens\": 20,\n        ...     \"token_dim\": 768,\n        ...     \"num_transformer_submodules\": 1,\n        ...     \"num_attention_heads\": 12,\n        ...     \"num_layers\": 12,\n        ...     \"encoder_hidden_size\": 768,\n        ...     \"prefix_projection\": False,\n        ...     \"postprocess_past_key_value_function\": None,\n        ... }\n\n        >>> peft_config = get_peft_config(config)\n        >>> model = AutoModelForSequenceClassification.from_pretrained(\"bert-base-cased\")\n        >>> peft_model = PeftModelForSequenceClassification(model, peft_config)\n        >>> peft_model.print_trainable_parameters()\n        trainable params: 370178 || all params: 108680450 || trainable%: 0.3406113979101117\n        ```\n    \"\"\"\n\n    def __init__(self, model, peft_config: PeftConfig, adapter_name=\"default\"):\n        super().__init__(model, peft_config, adapter_name)\n        if self.modules_to_save is None:\n            self.modules_to_save = {\"classifier\", \"score\"}\n        else:\n            self.modules_to_save.update({\"classifier\", \"score\"})\n\n        for name, _ in self.base_model.named_children():\n            if any(module_name in name for module_name in self.modules_to_save):\n                self.cls_layer_name = name\n                break\n\n        # to make sure classifier layer is trainable\n        _set_trainable(self, adapter_name)\n\n    def forward(\n        self,\n        input_ids=None,\n        attention_mask=None,\n        inputs_embeds=None,\n        labels=None,\n        output_attentions=None,\n        output_hidden_states=None,\n        return_dict=None,\n        **kwargs,\n    ):\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        peft_config = self.active_peft_config\n        if not isinstance(peft_config, PromptLearningConfig):\n            return self.base_model(\n                input_ids=input_ids,\n                attention_mask=attention_mask,\n                inputs_embeds=inputs_embeds,\n                labels=labels,\n                output_attentions=output_attentions,\n                output_hidden_states=output_hidden_states,\n                return_dict=return_dict,\n                **kwargs,\n            )\n\n        batch_size = input_ids.shape[0]\n        if attention_mask is not None:\n            # concat prompt attention mask\n            prefix_attention_mask = torch.ones(batch_size, peft_config.num_virtual_tokens).to(self.device)\n            attention_mask = torch.cat((prefix_attention_mask, attention_mask), dim=1)\n        if kwargs.get(\"position_ids\", None) is not None:\n            warnings.warn(\"Position ids are not supported for parameter efficient tuning. Ignoring position ids.\")\n            kwargs[\"position_ids\"] = None\n        kwargs.update(\n            {\n                \"attention_mask\": attention_mask,\n                \"labels\": labels,\n                \"output_attentions\": output_attentions,\n                \"output_hidden_states\": output_hidden_states,\n                \"return_dict\": return_dict,\n            }\n        )\n\n        if peft_config.peft_type == PeftType.PREFIX_TUNING:\n            return self._prefix_tuning_forward(input_ids=input_ids, **kwargs)\n        else:\n            if kwargs.get(\"token_type_ids\", None) is not None:\n                kwargs[\"token_type_ids\"] = torch.cat(\n                    (\n                        torch.zeros(batch_size, peft_config.num_virtual_tokens).to(self.device),\n                        kwargs[\"token_type_ids\"],\n                    ),\n                    dim=1,\n                ).long()\n            if inputs_embeds is None:\n                inputs_embeds = self.word_embeddings(input_ids)\n            prompts = self.get_prompt(batch_size=batch_size)\n            prompts = prompts.to(inputs_embeds.dtype)\n            inputs_embeds = torch.cat((prompts, inputs_embeds), dim=1)\n            return self.base_model(inputs_embeds=inputs_embeds, **kwargs)\n\n    def _prefix_tuning_forward(\n        self,\n        input_ids=None,\n        attention_mask=None,\n        inputs_embeds=None,\n        labels=None,\n        output_attentions=None,\n        output_hidden_states=None,\n        return_dict=None,\n        **kwargs,\n    ):\n        batch_size = input_ids.shape[0]\n        past_key_values = self.get_prompt(batch_size)\n        fwd_params = list(inspect.signature(self.base_model.forward).parameters.keys())\n        kwargs.update(\n            {\n                \"input_ids\": input_ids,\n                \"attention_mask\": attention_mask,\n                \"inputs_embeds\": inputs_embeds,\n                \"output_attentions\": output_attentions,\n                \"output_hidden_states\": output_hidden_states,\n                \"return_dict\": return_dict,\n                \"past_key_values\": past_key_values,\n            }\n        )\n        if \"past_key_values\" in fwd_params:\n            return self.base_model(labels=labels, **kwargs)\n        else:\n            transformer_backbone_name = self.base_model.get_submodule(self.transformer_backbone_name)\n            fwd_params = list(inspect.signature(transformer_backbone_name.forward).parameters.keys())\n            if \"past_key_values\" not in fwd_params:\n                raise ValueError(\"Model does not support past key values which are required for prefix tuning.\")\n            outputs = transformer_backbone_name(**kwargs)\n            pooled_output = outputs[1] if len(outputs) > 1 else outputs[0]\n            if \"dropout\" in [name for name, _ in list(self.base_model.named_children())]:\n                pooled_output = self.base_model.dropout(pooled_output)\n            logits = self.base_model.get_submodule(self.cls_layer_name)(pooled_output)\n\n            loss = None\n            if labels is not None:\n                if self.config.problem_type is None:\n                    if self.base_model.num_labels == 1:\n                        self.config.problem_type = \"regression\"\n                    elif self.base_model.num_labels > 1 and (labels.dtype == torch.long or labels.dtype == torch.int):\n                        self.config.problem_type = \"single_label_classification\"\n                    else:\n                        self.config.problem_type = \"multi_label_classification\"\n\n                if self.config.problem_type == \"regression\":\n                    loss_fct = MSELoss()\n                    if self.base_model.num_labels == 1:\n                        loss = loss_fct(logits.squeeze(), labels.squeeze())\n                    else:\n                        loss = loss_fct(logits, labels)\n                elif self.config.problem_type == \"single_label_classification\":\n                    loss_fct = CrossEntropyLoss()\n                    loss = loss_fct(logits.view(-1, self.base_model.num_labels), labels.view(-1))\n                elif self.config.problem_type == \"multi_label_classification\":\n                    loss_fct = BCEWithLogitsLoss()\n                    loss = loss_fct(logits, labels)\n            if not return_dict:\n                output = (logits,) + outputs[2:]\n                return ((loss,) + output) if loss is not None else output\n\n            return SequenceClassifierOutput(\n                loss=loss,\n                logits=logits,\n                hidden_states=outputs.hidden_states,\n                attentions=outputs.attentions,\n            )", "\n\nclass PeftModelForCausalLM(PeftModel):\n    \"\"\"\n    Peft model for causal language modeling.\n\n    Args:\n        model ([`~transformers.PreTrainedModel`]): Base transformer model.\n        peft_config ([`PeftConfig`]): Peft config.\n\n\n    Example:\n\n        ```py\n        >>> from transformers import AutoModelForCausalLM\n        >>> from peft import PeftModelForCausalLM, get_peft_config\n\n        >>> config = {\n        ...     \"peft_type\": \"PREFIX_TUNING\",\n        ...     \"task_type\": \"CAUSAL_LM\",\n        ...     \"inference_mode\": False,\n        ...     \"num_virtual_tokens\": 20,\n        ...     \"token_dim\": 1280,\n        ...     \"num_transformer_submodules\": 1,\n        ...     \"num_attention_heads\": 20,\n        ...     \"num_layers\": 36,\n        ...     \"encoder_hidden_size\": 1280,\n        ...     \"prefix_projection\": False,\n        ...     \"postprocess_past_key_value_function\": None,\n        ... }\n\n        >>> peft_config = get_peft_config(config)\n        >>> model = AutoModelForCausalLM.from_pretrained(\"gpt2-large\")\n        >>> peft_model = PeftModelForCausalLM(model, peft_config)\n        >>> peft_model.print_trainable_parameters()\n        trainable params: 1843200 || all params: 775873280 || trainable%: 0.23756456724479544\n        ```\n    \"\"\"\n\n    def __init__(self, model, peft_config: PeftConfig, adapter_name=\"default\"):\n        super().__init__(model, peft_config, adapter_name)\n        self.base_model_prepare_inputs_for_generation = self.base_model.prepare_inputs_for_generation\n\n    def forward(\n        self,\n        input_ids=None,\n        attention_mask=None,\n        inputs_embeds=None,\n        labels=None,\n        output_attentions=None,\n        output_hidden_states=None,\n        return_dict=None,\n        **kwargs,\n    ):\n        peft_config = self.active_peft_config\n        if not isinstance(peft_config, PromptLearningConfig):\n            return self.base_model(\n                input_ids=input_ids,\n                attention_mask=attention_mask,\n                inputs_embeds=inputs_embeds,\n                labels=labels,\n                output_attentions=output_attentions,\n                output_hidden_states=output_hidden_states,\n                return_dict=return_dict,\n                **kwargs,\n            )\n\n        batch_size = input_ids.shape[0]\n        if attention_mask is not None:\n            # concat prompt attention mask\n            prefix_attention_mask = torch.ones(batch_size, peft_config.num_virtual_tokens).to(self.device)\n            attention_mask = torch.cat((prefix_attention_mask, attention_mask), dim=1)\n\n        if kwargs.get(\"position_ids\", None) is not None:\n            warnings.warn(\"Position ids are not supported for parameter efficient tuning. Ignoring position ids.\")\n            kwargs[\"position_ids\"] = None\n        if kwargs.get(\"token_type_ids\", None) is not None:\n            warnings.warn(\"Token type ids are not supported for parameter efficient tuning. Ignoring token type ids\")\n            kwargs[\"token_type_ids\"] = None\n        kwargs.update(\n            {\n                \"attention_mask\": attention_mask,\n                \"labels\": labels,\n                \"output_attentions\": output_attentions,\n                \"output_hidden_states\": output_hidden_states,\n                \"return_dict\": return_dict,\n            }\n        )\n\n        if peft_config.peft_type == PeftType.PREFIX_TUNING:\n            past_key_values = self.get_prompt(batch_size)\n            return self.base_model(input_ids=input_ids, past_key_values=past_key_values, **kwargs)\n        else:\n            if inputs_embeds is None:\n                inputs_embeds = self.word_embeddings(input_ids)\n            # concat prompt labels\n            if labels is not None:\n                prefix_labels = torch.full((batch_size, peft_config.num_virtual_tokens), -100).to(self.device)\n                kwargs[\"labels\"] = torch.cat((prefix_labels, labels), dim=1)\n            prompts = self.get_prompt(batch_size=batch_size)\n            prompts = prompts.to(inputs_embeds.dtype)\n            inputs_embeds = torch.cat((prompts, inputs_embeds), dim=1)\n            return self.base_model(inputs_embeds=inputs_embeds, **kwargs)\n\n    def generate(self, **kwargs):\n        peft_config = self.active_peft_config\n        self.base_model.prepare_inputs_for_generation = self.prepare_inputs_for_generation\n        try:\n            if not isinstance(peft_config, PromptLearningConfig):\n                outputs = self.base_model.generate(**kwargs)\n            else:\n                if \"input_ids\" not in kwargs:\n                    raise ValueError(\"input_ids must be provided for Peft model generation\")\n                # For gpt2 models, we construct postion_ids on the fly by using attention mask, and position ids need to match input_shape.\n                # for prefix tuning, input shape is determined using `input_ids`. Thus we should not expand 'attention_mask' here\n                # for prompt tuning input_ids is not passed but a concatenated input_embeds is passed. Thus attention_mask needs to be of same size of num_virtual_tokens + input_ids\n                if kwargs.get(\"attention_mask\", None) is not None and peft_config.peft_type in [\n                    PeftType.PROMPT_TUNING,\n                    PeftType.P_TUNING,\n                ]:\n                    # concat prompt attention mask\n                    prefix_attention_mask = torch.ones(\n                        kwargs[\"input_ids\"].shape[0], peft_config.num_virtual_tokens\n                    ).to(kwargs[\"input_ids\"].device)\n                    kwargs[\"attention_mask\"] = torch.cat((prefix_attention_mask, kwargs[\"attention_mask\"]), dim=1)\n\n                if kwargs.get(\"position_ids\", None) is not None:\n                    warnings.warn(\n                        \"Position ids are not supported for parameter efficient tuning. Ignoring position ids.\"\n                    )\n                    kwargs[\"position_ids\"] = None\n                if kwargs.get(\"token_type_ids\", None) is not None:\n                    warnings.warn(\n                        \"Token type ids are not supported for parameter efficient tuning. Ignoring token type ids\"\n                    )\n                    kwargs[\"token_type_ids\"] = None\n\n                outputs = self.base_model.generate(**kwargs)\n        except:\n            self.base_model.prepare_inputs_for_generation = self.base_model_prepare_inputs_for_generation\n            raise\n        else:\n            self.base_model.prepare_inputs_for_generation = self.base_model_prepare_inputs_for_generation\n            return outputs\n\n    def prepare_inputs_for_generation(self, *args, **kwargs):\n        peft_config = self.active_peft_config\n        model_kwargs = self.base_model_prepare_inputs_for_generation(*args, **kwargs)\n        if isinstance(peft_config, PromptLearningConfig):\n            if peft_config.peft_type == PeftType.PREFIX_TUNING:\n                prefix_attention_mask = torch.ones(\n                    model_kwargs[\"input_ids\"].shape[0], peft_config.num_virtual_tokens\n                ).to(model_kwargs[\"input_ids\"].device)\n                model_kwargs[\"attention_mask\"] = torch.cat(\n                    (prefix_attention_mask, model_kwargs[\"attention_mask\"]), dim=1\n                )\n\n            if model_kwargs[\"past_key_values\"] is None and peft_config.peft_type == PeftType.PREFIX_TUNING:\n                past_key_values = self.get_prompt(batch_size=model_kwargs[\"input_ids\"].shape[0])\n\n                if self.base_model_torch_dtype is not None:\n                    # handle the case for Bloom where it outputs tuple of tuples\n                    if isinstance(past_key_values[0], tuple):\n                        past_key_values = tuple(\n                            tuple(\n                                past_key_value.to(self.base_model_torch_dtype)\n                                for past_key_value in past_key_value_tuple\n                            )\n                            for past_key_value_tuple in past_key_values\n                        )\n                    else:\n                        past_key_values = tuple(\n                            past_key_value.to(self.base_model_torch_dtype) for past_key_value in past_key_values\n                        )\n\n                model_kwargs[\"past_key_values\"] = past_key_values\n            else:\n                if model_kwargs[\"past_key_values\"] is None:\n                    inputs_embeds = self.word_embeddings(model_kwargs[\"input_ids\"])\n                    prompts = self.get_prompt(batch_size=model_kwargs[\"input_ids\"].shape[0])\n                    prompts = prompts.to(inputs_embeds.dtype)\n                    model_kwargs[\"inputs_embeds\"] = torch.cat((prompts, inputs_embeds), dim=1)\n                    model_kwargs[\"input_ids\"] = None\n\n        return model_kwargs", "\n\nclass PeftModelForSeq2SeqLM(PeftModel):\n    \"\"\"\n    Peft model for sequence-to-sequence language modeling.\n\n    Args:\n        model ([`~transformers.PreTrainedModel`]): Base transformer model.\n        peft_config ([`PeftConfig`]): Peft config.\n\n\n    Example:\n\n        ```py\n        >>> from transformers import AutoModelForSeq2SeqLM\n        >>> from peft import PeftModelForSeq2SeqLM, get_peft_config\n\n        >>> config = {\n        ...     \"peft_type\": \"LORA\",\n        ...     \"task_type\": \"SEQ_2_SEQ_LM\",\n        ...     \"inference_mode\": False,\n        ...     \"r\": 8,\n        ...     \"target_modules\": [\"q\", \"v\"],\n        ...     \"lora_alpha\": 32,\n        ...     \"lora_dropout\": 0.1,\n        ...     \"merge_weights\": False,\n        ...     \"fan_in_fan_out\": False,\n        ...     \"enable_lora\": None,\n        ...     \"bias\": \"none\",\n        ... }\n\n        >>> peft_config = get_peft_config(config)\n        >>> model = AutoModelForSeq2SeqLM.from_pretrained(\"t5-base\")\n        >>> peft_model = PeftModelForSeq2SeqLM(model, peft_config)\n        >>> peft_model.print_trainable_parameters()\n        trainable params: 884736 || all params: 223843584 || trainable%: 0.3952474242013566\n        ```\n    \"\"\"\n\n    def __init__(self, model, peft_config: PeftConfig, adapter_name=\"default\"):\n        super().__init__(model, peft_config, adapter_name)\n        self.base_model_prepare_inputs_for_generation = self.base_model.prepare_inputs_for_generation\n        self.base_model_prepare_encoder_decoder_kwargs_for_generation = (\n            self.base_model._prepare_encoder_decoder_kwargs_for_generation\n        )\n\n    def forward(\n        self,\n        input_ids=None,\n        attention_mask=None,\n        inputs_embeds=None,\n        decoder_input_ids=None,\n        decoder_attention_mask=None,\n        decoder_inputs_embeds=None,\n        labels=None,\n        output_attentions=None,\n        output_hidden_states=None,\n        return_dict=None,\n        **kwargs,\n    ):\n        peft_config = self.active_peft_config\n        if not isinstance(peft_config, PromptLearningConfig):\n            return self.base_model(\n                input_ids=input_ids,\n                attention_mask=attention_mask,\n                inputs_embeds=inputs_embeds,\n                decoder_input_ids=decoder_input_ids,\n                decoder_attention_mask=decoder_attention_mask,\n                decoder_inputs_embeds=decoder_inputs_embeds,\n                labels=labels,\n                output_attentions=output_attentions,\n                output_hidden_states=output_hidden_states,\n                return_dict=return_dict,\n                **kwargs,\n            )\n\n        batch_size = input_ids.shape[0]\n        if decoder_attention_mask is not None:\n            # concat prompt attention mask\n            prefix_attention_mask = torch.ones(batch_size, peft_config.num_virtual_tokens).to(self.device)\n            decoder_attention_mask = torch.cat((prefix_attention_mask, decoder_attention_mask), dim=1)\n\n        if kwargs.get(\"position_ids\", None) is not None:\n            warnings.warn(\"Position ids are not supported for parameter efficient tuning. Ignoring position ids.\")\n            kwargs[\"position_ids\"] = None\n        if kwargs.get(\"token_type_ids\", None) is not None:\n            warnings.warn(\"Token type ids are not supported for parameter efficient tuning. Ignoring token type ids\")\n            kwargs[\"token_type_ids\"] = None\n        kwargs.update(\n            {\n                \"attention_mask\": attention_mask,\n                \"decoder_attention_mask\": decoder_attention_mask,\n                \"labels\": labels,\n                \"output_attentions\": output_attentions,\n                \"output_hidden_states\": output_hidden_states,\n                \"return_dict\": return_dict,\n            }\n        )\n\n        if peft_config.peft_type == PeftType.PREFIX_TUNING:\n            past_key_values = self.get_prompt(batch_size)\n            return self.base_model(\n                input_ids=input_ids, decoder_input_ids=decoder_input_ids, past_key_values=past_key_values, **kwargs\n            )\n        else:\n            if inputs_embeds is None:\n                inputs_embeds = self.word_embeddings(input_ids)\n            if decoder_inputs_embeds is None and decoder_input_ids is None:\n                decoder_input_ids = shift_tokens_right(\n                    labels, self.config.pad_token_id, self.config.decoder_start_token_id\n                )\n                decoder_inputs_embeds = self.word_embeddings(decoder_input_ids)\n\n            if attention_mask is not None:\n                # concat prompt attention mask\n                prefix_attention_mask = torch.ones(batch_size, peft_config.num_virtual_tokens).to(self.device)\n                kwargs[\"attention_mask\"] = torch.cat((prefix_attention_mask, attention_mask), dim=1)\n            # concat prompt labels\n            if labels is not None:\n                if peft_config.num_transformer_submodules == 1:\n                    kwargs[\"labels\"] = labels\n                elif peft_config.num_transformer_submodules == 2:\n                    prefix_labels = torch.full((batch_size, peft_config.num_virtual_tokens), -100).to(self.device)\n                    kwargs[\"labels\"] = torch.cat((prefix_labels, labels), dim=1)\n            prompts = self.get_prompt(batch_size=batch_size)\n            prompts = prompts.to(inputs_embeds.dtype)\n            inputs_embeds = torch.cat((prompts[:, : peft_config.num_virtual_tokens], inputs_embeds), dim=1)\n            if peft_config.num_transformer_submodules == 1:\n                return self.base_model(inputs_embeds=inputs_embeds, **kwargs)\n            elif peft_config.num_transformer_submodules == 2:\n                decoder_inputs_embeds = torch.cat(\n                    (prompts[:, peft_config.num_virtual_tokens :], decoder_inputs_embeds), dim=1\n                )\n                return self.base_model(\n                    inputs_embeds=inputs_embeds, decoder_inputs_embeds=decoder_inputs_embeds, **kwargs\n                )\n\n    def generate(self, **kwargs):\n        peft_config = self.active_peft_config\n        self.base_model.prepare_inputs_for_generation = self.prepare_inputs_for_generation\n        self.base_model._prepare_encoder_decoder_kwargs_for_generation = (\n            self._prepare_encoder_decoder_kwargs_for_generation\n        )\n        try:\n            if not isinstance(peft_config, PromptLearningConfig):\n                outputs = self.base_model.generate(**kwargs)\n            else:\n                if \"input_ids\" not in kwargs:\n                    raise ValueError(\"input_ids must be provided for Peft model generation\")\n                if kwargs.get(\"position_ids\", None) is not None:\n                    warnings.warn(\n                        \"Position ids are not supported for parameter efficient tuning. Ignoring position ids.\"\n                    )\n                    kwargs[\"position_ids\"] = None\n                if kwargs.get(\"token_type_ids\", None) is not None:\n                    warnings.warn(\n                        \"Token type ids are not supported for parameter efficient tuning. Ignoring token type ids\"\n                    )\n                    kwargs[\"token_type_ids\"] = None\n\n                if peft_config.peft_type == PeftType.PREFIX_TUNING:\n                    outputs = self.base_model.generate(**kwargs)\n                else:\n                    raise NotImplementedError\n        except:\n            self.base_model.prepare_inputs_for_generation = self.base_model_prepare_inputs_for_generation\n            self.base_model._prepare_encoder_decoder_kwargs_for_generation = (\n                self.base_model_prepare_encoder_decoder_kwargs_for_generation\n            )\n            raise\n        else:\n            self.base_model.prepare_inputs_for_generation = self.base_model_prepare_inputs_for_generation\n            self.base_model._prepare_encoder_decoder_kwargs_for_generation = (\n                self.base_model_prepare_encoder_decoder_kwargs_for_generation\n            )\n            return outputs\n\n    def prepare_inputs_for_generation(self, *args, **kwargs):\n        peft_config = self.active_peft_config\n        model_kwargs = self.base_model_prepare_inputs_for_generation(*args, **kwargs)\n        if model_kwargs[\"past_key_values\"] is None and peft_config.peft_type == PeftType.PREFIX_TUNING:\n            batch_size = model_kwargs[\"decoder_input_ids\"].shape[0]\n            past_key_values = self.get_prompt(batch_size)\n            if self.base_model_torch_dtype is not None:\n                # handle the case for Bloom where it outputs tuple of tuples\n                if isinstance(past_key_values[0], tuple):\n                    past_key_values = tuple(\n                        tuple(\n                            past_key_value.to(self.base_model_torch_dtype) for past_key_value in past_key_value_tuple\n                        )\n                        for past_key_value_tuple in past_key_values\n                    )\n                else:\n                    past_key_values = tuple(\n                        past_key_value.to(self.base_model_torch_dtype) for past_key_value in past_key_values\n                    )\n            model_kwargs[\"past_key_values\"] = past_key_values\n\n        return model_kwargs", "\n\nclass PeftModelForTokenClassification(PeftModel):\n    \"\"\"\n    Peft model for token classification tasks.\n\n    Args:\n        model ([`~transformers.PreTrainedModel`]): Base transformer model.\n        peft_config ([`PeftConfig`]): Peft config.\n\n    **Attributes**:\n        - **config** ([`~transformers.PretrainedConfig`]) -- The configuration object of the base model.\n        - **cls_layer_name** (`str`) -- The name of the classification layer.\n\n    Example:\n\n        ```py\n        >>> from transformers import AutoModelForSequenceClassification\n        >>> from peft import PeftModelForTokenClassification, get_peft_config\n\n        >>> config = {\n        ...     \"peft_type\": \"PREFIX_TUNING\",\n        ...     \"task_type\": \"TOKEN_CLS\",\n        ...     \"inference_mode\": False,\n        ...     \"num_virtual_tokens\": 20,\n        ...     \"token_dim\": 768,\n        ...     \"num_transformer_submodules\": 1,\n        ...     \"num_attention_heads\": 12,\n        ...     \"num_layers\": 12,\n        ...     \"encoder_hidden_size\": 768,\n        ...     \"prefix_projection\": False,\n        ...     \"postprocess_past_key_value_function\": None,\n        ... }\n\n        >>> peft_config = get_peft_config(config)\n        >>> model = AutoModelForTokenClassification.from_pretrained(\"bert-base-cased\")\n        >>> peft_model = PeftModelForTokenClassification(model, peft_config)\n        >>> peft_model.print_trainable_parameters()\n        trainable params: 370178 || all params: 108680450 || trainable%: 0.3406113979101117\n        ```\n    \"\"\"\n\n    def __init__(self, model, peft_config: PeftConfig = None, adapter_name=\"default\"):\n        super().__init__(model, peft_config, adapter_name)\n        if self.modules_to_save is None:\n            self.modules_to_save = {\"classifier\", \"score\"}\n        else:\n            self.modules_to_save.update({\"classifier\", \"score\"})\n\n        for name, _ in self.base_model.named_children():\n            if any(module_name in name for module_name in self.modules_to_save):\n                self.cls_layer_name = name\n                break\n\n        # to make sure classifier layer is trainable\n        _set_trainable(self, adapter_name)\n\n    def forward(\n        self,\n        input_ids=None,\n        attention_mask=None,\n        inputs_embeds=None,\n        labels=None,\n        output_attentions=None,\n        output_hidden_states=None,\n        return_dict=None,\n        **kwargs,\n    ):\n        peft_config = self.active_peft_config\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        if not isinstance(peft_config, PromptLearningConfig):\n            return self.base_model(\n                input_ids=input_ids,\n                attention_mask=attention_mask,\n                inputs_embeds=inputs_embeds,\n                labels=labels,\n                output_attentions=output_attentions,\n                output_hidden_states=output_hidden_states,\n                return_dict=return_dict,\n                **kwargs,\n            )\n\n        batch_size = input_ids.shape[0]\n        if attention_mask is not None:\n            # concat prompt attention mask\n            prefix_attention_mask = torch.ones(batch_size, peft_config.num_virtual_tokens).to(self.device)\n            attention_mask = torch.cat((prefix_attention_mask, attention_mask), dim=1)\n        if kwargs.get(\"position_ids\", None) is not None:\n            warnings.warn(\"Position ids are not supported for parameter efficient tuning. Ignoring position ids.\")\n            kwargs[\"position_ids\"] = None\n        kwargs.update(\n            {\n                \"attention_mask\": attention_mask,\n                \"labels\": labels,\n                \"output_attentions\": output_attentions,\n                \"output_hidden_states\": output_hidden_states,\n                \"return_dict\": return_dict,\n            }\n        )\n\n        if peft_config.peft_type == PeftType.PREFIX_TUNING:\n            return self._prefix_tuning_forward(input_ids=input_ids, **kwargs)\n        else:\n            if kwargs.get(\"token_type_ids\", None) is not None:\n                kwargs[\"token_type_ids\"] = torch.cat(\n                    (\n                        torch.zeros(batch_size, peft_config.num_virtual_tokens).to(self.device),\n                        kwargs[\"token_type_ids\"],\n                    ),\n                    dim=1,\n                ).long()\n            if inputs_embeds is None:\n                inputs_embeds = self.word_embeddings(input_ids)\n            prompts = self.get_prompt(batch_size=batch_size)\n            prompts = prompts.to(inputs_embeds.dtype)\n            inputs_embeds = torch.cat((prompts, inputs_embeds), dim=1)\n            return self.base_model(inputs_embeds=inputs_embeds, **kwargs)\n\n    def _prefix_tuning_forward(\n        self,\n        input_ids=None,\n        attention_mask=None,\n        inputs_embeds=None,\n        labels=None,\n        output_attentions=None,\n        output_hidden_states=None,\n        return_dict=None,\n        **kwargs,\n    ):\n        batch_size = input_ids.shape[0]\n        past_key_values = self.get_prompt(batch_size)\n        fwd_params = list(inspect.signature(self.base_model.forward).parameters.keys())\n        kwargs.update(\n            {\n                \"input_ids\": input_ids,\n                \"attention_mask\": attention_mask,\n                \"inputs_embeds\": inputs_embeds,\n                \"output_attentions\": output_attentions,\n                \"output_hidden_states\": output_hidden_states,\n                \"return_dict\": return_dict,\n                \"past_key_values\": past_key_values,\n            }\n        )\n        if \"past_key_values\" in fwd_params:\n            return self.base_model(labels=labels, **kwargs)\n        else:\n            transformer_backbone_name = self.base_model.get_submodule(self.transformer_backbone_name)\n            fwd_params = list(inspect.signature(transformer_backbone_name.forward).parameters.keys())\n            if \"past_key_values\" not in fwd_params:\n                raise ValueError(\"Model does not support past key values which are required for prefix tuning.\")\n            outputs = transformer_backbone_name(**kwargs)\n            sequence_output = outputs[0]\n            if \"dropout\" in [name for name, _ in list(self.base_model.named_children())]:\n                sequence_output = self.base_model.dropout(sequence_output)\n            logits = self.base_model.get_submodule(self.cls_layer_name)(sequence_output)\n\n            loss = None\n            loss = None\n            if labels is not None:\n                loss_fct = CrossEntropyLoss()\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n\n            if not return_dict:\n                output = (logits,) + outputs[2:]\n                return ((loss,) + output) if loss is not None else output\n\n            return TokenClassifierOutput(\n                loss=loss,\n                logits=logits,\n                hidden_states=outputs.hidden_states,\n                attentions=outputs.attentions,\n            )", ""]}
{"filename": "ft_chatglm_lora/peft/mapping.py", "chunked_list": ["# coding=utf-8\n# Copyright 2023-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom .peft_model import (\n    PeftModel,\n    PeftModelForCausalLM,", "    PeftModel,\n    PeftModelForCausalLM,\n    PeftModelForSeq2SeqLM,\n    PeftModelForSequenceClassification,\n    PeftModelForTokenClassification,\n)\nfrom .tuners import (\n    AdaLoraConfig,\n    AdaptionPromptConfig,\n    LoraConfig,", "    AdaptionPromptConfig,\n    LoraConfig,\n    PrefixTuningConfig,\n    PromptEncoderConfig,\n    PromptTuningConfig,\n)\nfrom .utils import PromptLearningConfig\n\n\nMODEL_TYPE_TO_PEFT_MODEL_MAPPING = {", "\nMODEL_TYPE_TO_PEFT_MODEL_MAPPING = {\n    \"SEQ_CLS\": PeftModelForSequenceClassification,\n    \"SEQ_2_SEQ_LM\": PeftModelForSeq2SeqLM,\n    \"CAUSAL_LM\": PeftModelForCausalLM,\n    \"TOKEN_CLS\": PeftModelForTokenClassification,\n}\n\nPEFT_TYPE_TO_CONFIG_MAPPING = {\n    \"ADAPTION_PROMPT\": AdaptionPromptConfig,", "PEFT_TYPE_TO_CONFIG_MAPPING = {\n    \"ADAPTION_PROMPT\": AdaptionPromptConfig,\n    \"PROMPT_TUNING\": PromptTuningConfig,\n    \"PREFIX_TUNING\": PrefixTuningConfig,\n    \"P_TUNING\": PromptEncoderConfig,\n    \"LORA\": LoraConfig,\n    \"ADALORA\": AdaLoraConfig,\n}\n\n\ndef get_peft_config(config_dict):\n    \"\"\"\n    Returns a Peft config object from a dictionary.\n\n    Args:\n        config_dict (`Dict[str, Any]`): Dictionary containing the configuration parameters.\n    \"\"\"\n\n    return PEFT_TYPE_TO_CONFIG_MAPPING[config_dict[\"peft_type\"]](**config_dict)", "\n\ndef get_peft_config(config_dict):\n    \"\"\"\n    Returns a Peft config object from a dictionary.\n\n    Args:\n        config_dict (`Dict[str, Any]`): Dictionary containing the configuration parameters.\n    \"\"\"\n\n    return PEFT_TYPE_TO_CONFIG_MAPPING[config_dict[\"peft_type\"]](**config_dict)", "\n\ndef _prepare_prompt_learning_config(peft_config, model_config):\n    if peft_config.num_layers is None:\n        if \"num_hidden_layers\" in model_config:\n            num_layers = model_config[\"num_hidden_layers\"]\n        elif \"num_layers\" in model_config:\n            num_layers = model_config[\"num_layers\"]\n        elif \"n_layer\" in model_config:\n            num_layers = model_config[\"n_layer\"]\n        else:\n            raise ValueError(\"Please specify `num_layers` in `peft_config`\")\n        peft_config.num_layers = num_layers\n\n    if peft_config.token_dim is None:\n        if \"hidden_size\" in model_config:\n            token_dim = model_config[\"hidden_size\"]\n        elif \"n_embd\" in model_config:\n            token_dim = model_config[\"n_embd\"]\n        elif \"d_model\" in model_config:\n            token_dim = model_config[\"d_model\"]\n        else:\n            raise ValueError(\"Please specify `token_dim` in `peft_config`\")\n        peft_config.token_dim = token_dim\n\n    if peft_config.num_attention_heads is None:\n        if \"num_attention_heads\" in model_config:\n            num_attention_heads = model_config[\"num_attention_heads\"]\n        elif \"n_head\" in model_config:\n            num_attention_heads = model_config[\"n_head\"]\n        elif \"num_heads\" in model_config:\n            num_attention_heads = model_config[\"num_heads\"]\n        elif \"encoder_attention_heads\" in model_config:\n            num_attention_heads = model_config[\"encoder_attention_heads\"]\n        else:\n            raise ValueError(\"Please specify `num_attention_heads` in `peft_config`\")\n        peft_config.num_attention_heads = num_attention_heads\n\n    if getattr(peft_config, \"encoder_hidden_size\", None) is None:\n        setattr(peft_config, \"encoder_hidden_size\", token_dim)\n\n    return peft_config", "\n\ndef get_peft_model(model, peft_config):\n    \"\"\"\n    Returns a Peft model object from a model and a config.\n\n    Args:\n        model ([`transformers.PreTrainedModel`]): Model to be wrapped.\n        peft_config ([`PeftConfig`]): Configuration object containing the parameters of the Peft model.\n    \"\"\"\n    model_config = model.config.to_dict() if hasattr(model.config, \"to_dict\") else model.config\n    peft_config.base_model_name_or_path = model.__dict__.get(\"name_or_path\", None)\n    if peft_config.task_type not in MODEL_TYPE_TO_PEFT_MODEL_MAPPING.keys() and not isinstance(\n        peft_config, PromptLearningConfig\n    ):\n        return PeftModel(model, peft_config)\n    if isinstance(peft_config, PromptLearningConfig):\n        peft_config = _prepare_prompt_learning_config(peft_config, model_config)\n    return MODEL_TYPE_TO_PEFT_MODEL_MAPPING[peft_config.task_type](model, peft_config)", ""]}
{"filename": "ft_chatglm_lora/peft/import_utils.py", "chunked_list": ["# coding=utf-8\n# Copyright 2023-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport importlib\n\n\ndef is_bnb_available():\n    return importlib.util.find_spec(\"bitsandbytes\") is not None", "\ndef is_bnb_available():\n    return importlib.util.find_spec(\"bitsandbytes\") is not None\n"]}
{"filename": "ft_chatglm_lora/peft/__init__.py", "chunked_list": ["# flake8: noqa\n# There's no way to ignore \"F401 '...' imported but unused\" warnings in this\n# module, but to preserve other warnings. So, don't check this module at all.\n\n# coding=utf-8\n# Copyright 2023-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n__version__ = \"0.3.0.dev0\"\n\nfrom .mapping import MODEL_TYPE_TO_PEFT_MODEL_MAPPING, PEFT_TYPE_TO_CONFIG_MAPPING, get_peft_config, get_peft_model\nfrom .peft_model import (\n    PeftModel,\n    PeftModelForCausalLM,\n    PeftModelForSeq2SeqLM,", "    PeftModelForCausalLM,\n    PeftModelForSeq2SeqLM,\n    PeftModelForSequenceClassification,\n    PeftModelForTokenClassification,\n)\nfrom .tuners import (\n    AdaptionPromptConfig,\n    AdaptionPromptModel,\n    LoraConfig,\n    LoraModel,", "    LoraConfig,\n    LoraModel,\n    AdaLoraConfig,\n    AdaLoraModel,\n    PrefixEncoder,\n    PrefixTuningConfig,\n    PromptEmbedding,\n    PromptEncoder,\n    PromptEncoderConfig,\n    PromptEncoderReparameterizationType,", "    PromptEncoderConfig,\n    PromptEncoderReparameterizationType,\n    PromptTuningConfig,\n    PromptTuningInit,\n)\nfrom .utils import (\n    TRANSFORMERS_MODELS_TO_PREFIX_TUNING_POSTPROCESS_MAPPING,\n    PeftConfig,\n    PeftType,\n    PromptLearningConfig,", "    PeftType,\n    PromptLearningConfig,\n    TaskType,\n    bloom_model_postprocess_past_key_value,\n    get_peft_model_state_dict,\n    prepare_model_for_int8_training,\n    set_peft_model_state_dict,\n    shift_tokens_right,\n)\n", ")\n"]}
{"filename": "ft_chatglm_lora/peft/utils/save_and_load.py", "chunked_list": ["# coding=utf-8\n# Copyright 2023-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom .config import PeftType, PromptLearningConfig\n\n\ndef get_peft_model_state_dict(model, state_dict=None, adapter_name=\"default\"):\n    \"\"\"\n    Get the state dict of the Peft model.\n\n    Args:\n        model ([`PeftModel`]): The Peft model. When using torch.nn.DistributedDataParallel, DeepSpeed or FSDP,\n        the model should be the underlying model/unwrapped model (i.e. model.module).\n        state_dict (`dict`, *optional*, defaults to `None`):\n            The state dict of the model. If not provided, the state dict of the model\n        will be used.\n    \"\"\"\n    config = model.peft_config[adapter_name]\n    if state_dict is None:\n        state_dict = model.state_dict()\n    if config.peft_type in (PeftType.LORA, PeftType.ADALORA):\n        # to_return = lora_state_dict(model, bias=model.peft_config.bias)\n        # adapted from `https://github.com/microsoft/LoRA/blob/main/loralib/utils.py`\n        # to be used directly with the state dict which is necessary when using DeepSpeed or FSDP\n        bias = config.bias\n        if bias == \"none\":\n            to_return = {k: state_dict[k] for k in state_dict if \"lora_\" in k}\n        elif bias == \"all\":\n            to_return = {k: state_dict[k] for k in state_dict if \"lora_\" in k or \"bias\" in k}\n        elif bias == \"lora_only\":\n            to_return = {}\n            for k in state_dict:\n                if \"lora_\" in k:\n                    to_return[k] = state_dict[k]\n                    bias_name = k.split(\"lora_\")[0] + \"bias\"\n                    if bias_name in state_dict:\n                        to_return[bias_name] = state_dict[bias_name]\n        else:\n            raise NotImplementedError\n        to_return = {k: v for k, v in to_return.items() if ((\"lora_\" in k and adapter_name in k) or (\"bias\" in k))}\n        if config.peft_type == PeftType.ADALORA:\n            rank_pattern = config.rank_pattern\n            if rank_pattern is not None:\n                rank_pattern = {k.replace(f\".{adapter_name}\", \"\"): v for k, v in rank_pattern.items()}\n                config.rank_pattern = rank_pattern\n                to_return = model.resize_state_dict_by_rank_pattern(rank_pattern, to_return, adapter_name)\n\n    elif config.peft_type == PeftType.ADAPTION_PROMPT:\n        to_return = {k: state_dict[k] for k in state_dict if k.split(\".\")[-1].startswith(\"adaption_\")}\n    elif isinstance(config, PromptLearningConfig):\n        to_return = {}\n        if config.inference_mode:\n            prompt_embeddings = model.prompt_encoder[adapter_name].embedding.weight\n        else:\n            prompt_embeddings = model.get_prompt_embedding_to_save(adapter_name)\n        to_return[\"prompt_embeddings\"] = prompt_embeddings\n    else:\n        raise NotImplementedError\n    if model.modules_to_save is not None:\n        for key, value in state_dict.items():\n            if any(f\"{module_name}.modules_to_save.{adapter_name}\" in key for module_name in model.modules_to_save):\n                to_return[key.replace(\"modules_to_save.\", \"\")] = value\n\n    to_return = {k.replace(f\".{adapter_name}\", \"\"): v for k, v in to_return.items()}\n    return to_return", "\n\ndef get_peft_model_state_dict(model, state_dict=None, adapter_name=\"default\"):\n    \"\"\"\n    Get the state dict of the Peft model.\n\n    Args:\n        model ([`PeftModel`]): The Peft model. When using torch.nn.DistributedDataParallel, DeepSpeed or FSDP,\n        the model should be the underlying model/unwrapped model (i.e. model.module).\n        state_dict (`dict`, *optional*, defaults to `None`):\n            The state dict of the model. If not provided, the state dict of the model\n        will be used.\n    \"\"\"\n    config = model.peft_config[adapter_name]\n    if state_dict is None:\n        state_dict = model.state_dict()\n    if config.peft_type in (PeftType.LORA, PeftType.ADALORA):\n        # to_return = lora_state_dict(model, bias=model.peft_config.bias)\n        # adapted from `https://github.com/microsoft/LoRA/blob/main/loralib/utils.py`\n        # to be used directly with the state dict which is necessary when using DeepSpeed or FSDP\n        bias = config.bias\n        if bias == \"none\":\n            to_return = {k: state_dict[k] for k in state_dict if \"lora_\" in k}\n        elif bias == \"all\":\n            to_return = {k: state_dict[k] for k in state_dict if \"lora_\" in k or \"bias\" in k}\n        elif bias == \"lora_only\":\n            to_return = {}\n            for k in state_dict:\n                if \"lora_\" in k:\n                    to_return[k] = state_dict[k]\n                    bias_name = k.split(\"lora_\")[0] + \"bias\"\n                    if bias_name in state_dict:\n                        to_return[bias_name] = state_dict[bias_name]\n        else:\n            raise NotImplementedError\n        to_return = {k: v for k, v in to_return.items() if ((\"lora_\" in k and adapter_name in k) or (\"bias\" in k))}\n        if config.peft_type == PeftType.ADALORA:\n            rank_pattern = config.rank_pattern\n            if rank_pattern is not None:\n                rank_pattern = {k.replace(f\".{adapter_name}\", \"\"): v for k, v in rank_pattern.items()}\n                config.rank_pattern = rank_pattern\n                to_return = model.resize_state_dict_by_rank_pattern(rank_pattern, to_return, adapter_name)\n\n    elif config.peft_type == PeftType.ADAPTION_PROMPT:\n        to_return = {k: state_dict[k] for k in state_dict if k.split(\".\")[-1].startswith(\"adaption_\")}\n    elif isinstance(config, PromptLearningConfig):\n        to_return = {}\n        if config.inference_mode:\n            prompt_embeddings = model.prompt_encoder[adapter_name].embedding.weight\n        else:\n            prompt_embeddings = model.get_prompt_embedding_to_save(adapter_name)\n        to_return[\"prompt_embeddings\"] = prompt_embeddings\n    else:\n        raise NotImplementedError\n    if model.modules_to_save is not None:\n        for key, value in state_dict.items():\n            if any(f\"{module_name}.modules_to_save.{adapter_name}\" in key for module_name in model.modules_to_save):\n                to_return[key.replace(\"modules_to_save.\", \"\")] = value\n\n    to_return = {k.replace(f\".{adapter_name}\", \"\"): v for k, v in to_return.items()}\n    return to_return", "\n\ndef set_peft_model_state_dict(model, peft_model_state_dict, adapter_name=\"default\"):\n    \"\"\"\n    Set the state dict of the Peft model.\n\n    Args:\n        model ([`PeftModel`]): The Peft model.\n        peft_model_state_dict (`dict`): The state dict of the Peft model.\n    \"\"\"\n    config = model.peft_config[adapter_name]\n    state_dict = {}\n    if model.modules_to_save is not None:\n        for key, value in peft_model_state_dict.items():\n            if any(module_name in key for module_name in model.modules_to_save):\n                for module_name in model.modules_to_save:\n                    if module_name in key:\n                        key = key.replace(module_name, f\"{module_name}.modules_to_save.{adapter_name}\")\n                        break\n            state_dict[key] = value\n    else:\n        state_dict = peft_model_state_dict\n\n    if config.peft_type in (PeftType.LORA, PeftType.ADALORA):\n        peft_model_state_dict = {}\n        for k, v in state_dict.items():\n            if \"lora_\" in k:\n                suffix = k.split(\"lora_\")[1]\n                if \".\" in suffix:\n                    suffix_to_replace = \".\".join(suffix.split(\".\")[1:])\n                    k = k.replace(suffix_to_replace, f\"{adapter_name}.{suffix_to_replace}\")\n                else:\n                    k = f\"{k}.{adapter_name}\"\n                peft_model_state_dict[k] = v\n            else:\n                peft_model_state_dict[k] = v\n        if config.peft_type == PeftType.ADALORA:\n            rank_pattern = config.rank_pattern\n            if rank_pattern is not None:\n                model.resize_modules_by_rank_pattern(rank_pattern, adapter_name)\n    elif isinstance(config, PromptLearningConfig) or config.peft_type == PeftType.ADAPTION_PROMPT:\n        peft_model_state_dict = state_dict\n    else:\n        raise NotImplementedError\n\n    model.load_state_dict(peft_model_state_dict, strict=False)\n    if isinstance(config, PromptLearningConfig):\n        model.prompt_encoder[adapter_name].embedding.load_state_dict(\n            {\"weight\": peft_model_state_dict[\"prompt_embeddings\"]}, strict=True\n        )", ""]}
{"filename": "ft_chatglm_lora/peft/utils/other.py", "chunked_list": ["# coding=utf-8\n# Copyright 2023-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport copy\n\nimport torch", "\nimport torch\n\n\n# needed for prefix-tuning of bloom model\ndef bloom_model_postprocess_past_key_value(past_key_values):\n    past_key_values = torch.cat(past_key_values)\n    total_layers, batch_size, num_attention_heads, num_virtual_tokens, head_dim = past_key_values.shape\n    keys = past_key_values[: total_layers // 2]\n    keys = keys.transpose(2, 3).reshape(\n        total_layers // 2, batch_size * num_attention_heads, head_dim, num_virtual_tokens\n    )\n    values = past_key_values[total_layers // 2 :]\n    values = values.reshape(total_layers // 2, batch_size * num_attention_heads, num_virtual_tokens, head_dim)\n\n    return tuple(zip(keys, values))", "\n\ndef prepare_model_for_int8_training(\n    model, output_embedding_layer_name=\"lm_head\", use_gradient_checkpointing=True, layer_norm_names=[\"layer_norm\"]\n):\n    r\"\"\"\n    This method wraps the entire protocol for preparing a model before running a training. This includes:\n        1- Cast the layernorm in fp32 2- making output embedding layer require grads 3- Add the upcasting of the lm\n        head to fp32\n\n    Args:\n        model, (`transformers.PreTrainedModel`):\n            The loaded model from `transformers`\n    \"\"\"\n    loaded_in_8bit = getattr(model, \"is_loaded_in_8bit\", False)\n\n    for name, param in model.named_parameters():\n        # freeze base model's layers\n        param.requires_grad = False\n\n        if loaded_in_8bit:\n            # cast layer norm in fp32 for stability for 8bit models\n            if param.ndim == 1 and any(layer_norm_name in name for layer_norm_name in layer_norm_names):\n                param.data = param.data.to(torch.float32)\n\n    if loaded_in_8bit and use_gradient_checkpointing:\n        # For backward compatibility\n        if hasattr(model, \"enable_input_require_grads\"):\n            model.enable_input_require_grads()\n        else:\n\n            def make_inputs_require_grad(module, input, output):\n                output.requires_grad_(True)\n\n            model.get_input_embeddings().register_forward_hook(make_inputs_require_grad)\n\n        # enable gradient checkpointing for memory efficiency\n        model.gradient_checkpointing_enable()\n\n    if hasattr(model, output_embedding_layer_name):\n        output_embedding_layer = getattr(model, output_embedding_layer_name)\n        input_dtype = output_embedding_layer.weight.dtype\n\n        class CastOutputToFloat(torch.nn.Sequential):\n            r\"\"\"\n            Manually cast to the expected dtype of the lm_head as sometimes there is a final layer norm that is casted\n            in fp32\n\n            \"\"\"\n\n            def forward(self, x):\n                return super().forward(x.to(input_dtype)).to(torch.float32)\n\n        setattr(model, output_embedding_layer_name, CastOutputToFloat(output_embedding_layer))\n\n    return model", "\n\n# copied from transformers.models.bart.modeling_bart\ndef shift_tokens_right(input_ids: torch.Tensor, pad_token_id: int, decoder_start_token_id: int):\n    \"\"\"\n    Shift input ids one token to the right.\n\n    Args:\n        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`): input ids\n        pad_token_id (`int`): The id of the `padding` token.\n        decoder_start_token_id (`int`): The id of the `start` token.\n    \"\"\"\n    shifted_input_ids = input_ids.new_zeros(input_ids.shape)\n    shifted_input_ids[:, 1:] = input_ids[:, :-1].clone()\n    shifted_input_ids[:, 0] = decoder_start_token_id\n\n    if pad_token_id is None:\n        raise ValueError(\"self.model.config.pad_token_id has to be defined.\")\n    # replace possible -100 values in labels by `pad_token_id`\n    shifted_input_ids.masked_fill_(shifted_input_ids == -100, pad_token_id)\n\n    return shifted_input_ids", "\n\nclass ModulesToSaveWrapper(torch.nn.Module):\n    def __init__(self, module_to_save, adapter_name):\n        super().__init__()\n        self.original_module = module_to_save\n        self.modules_to_save = torch.nn.ModuleDict({})\n        self.update(adapter_name)\n        self.active_adapter = adapter_name\n\n    def update(self, adapter_name):\n        self.modules_to_save.update(torch.nn.ModuleDict({adapter_name: copy.deepcopy(self.original_module)}))\n\n    def forward(self, *args, **kwargs):\n        if self.active_adapter not in self.modules_to_save:\n            return self.original_module(*args, **kwargs)\n        return self.modules_to_save[self.active_adapter](*args, **kwargs)", "\n\ndef _get_submodules(model, key):\n    parent = model.get_submodule(\".\".join(key.split(\".\")[:-1]))\n    target_name = key.split(\".\")[-1]\n    target = model.get_submodule(key)\n    return parent, target, target_name\n\n\ndef _freeze_adapter(model, adapter_name):\n    for n, p in model.named_parameters():\n        if adapter_name in n:\n            p.requires_grad = False", "\ndef _freeze_adapter(model, adapter_name):\n    for n, p in model.named_parameters():\n        if adapter_name in n:\n            p.requires_grad = False\n\n\ndef _set_trainable(model, adapter_name):\n    key_list = [key for key, _ in model.named_modules()]\n    for key in key_list:\n        target_module_found = any(key.endswith(target_key) for target_key in model.modules_to_save)\n        if target_module_found:\n            parent, target, target_name = _get_submodules(model, key)\n            if isinstance(target, ModulesToSaveWrapper):\n                target.update(adapter_name)\n            else:\n                for param in target.parameters():\n                    param.requires_grad = True\n                setattr(parent, target_name, ModulesToSaveWrapper(target, adapter_name))", "\n\ndef _set_adapter(model, adapter_name):\n    for module in model.modules():\n        if isinstance(module, ModulesToSaveWrapper):\n            module.active_adapter = adapter_name\n\n\ndef fsdp_auto_wrap_policy(model):\n    import functools\n    import os\n\n    from accelerate import FullyShardedDataParallelPlugin\n    from torch.distributed.fsdp.wrap import _or_policy, lambda_auto_wrap_policy, transformer_auto_wrap_policy\n\n    from ..tuners import PrefixEncoder, PromptEmbedding, PromptEncoder\n\n    def lambda_policy_fn(module):\n        if (\n            len(list(module.named_children())) == 0\n            and getattr(module, \"weight\", None) is not None\n            and module.weight.requires_grad\n        ):\n            return True\n        return False\n\n    lambda_policy = functools.partial(lambda_auto_wrap_policy, lambda_fn=lambda_policy_fn)\n    transformer_wrap_policy = functools.partial(\n        transformer_auto_wrap_policy,\n        transformer_layer_cls=(\n            PrefixEncoder,\n            PromptEncoder,\n            PromptEmbedding,\n            FullyShardedDataParallelPlugin.get_module_class_from_name(\n                model, os.environ.get(\"FSDP_TRANSFORMER_CLS_TO_WRAP\", \"\")\n            ),\n        ),\n    )\n\n    auto_wrap_policy = functools.partial(_or_policy, policies=[lambda_policy, transformer_wrap_policy])\n    return auto_wrap_policy", "def fsdp_auto_wrap_policy(model):\n    import functools\n    import os\n\n    from accelerate import FullyShardedDataParallelPlugin\n    from torch.distributed.fsdp.wrap import _or_policy, lambda_auto_wrap_policy, transformer_auto_wrap_policy\n\n    from ..tuners import PrefixEncoder, PromptEmbedding, PromptEncoder\n\n    def lambda_policy_fn(module):\n        if (\n            len(list(module.named_children())) == 0\n            and getattr(module, \"weight\", None) is not None\n            and module.weight.requires_grad\n        ):\n            return True\n        return False\n\n    lambda_policy = functools.partial(lambda_auto_wrap_policy, lambda_fn=lambda_policy_fn)\n    transformer_wrap_policy = functools.partial(\n        transformer_auto_wrap_policy,\n        transformer_layer_cls=(\n            PrefixEncoder,\n            PromptEncoder,\n            PromptEmbedding,\n            FullyShardedDataParallelPlugin.get_module_class_from_name(\n                model, os.environ.get(\"FSDP_TRANSFORMER_CLS_TO_WRAP\", \"\")\n            ),\n        ),\n    )\n\n    auto_wrap_policy = functools.partial(_or_policy, policies=[lambda_policy, transformer_wrap_policy])\n    return auto_wrap_policy", "\n\ndef transpose(weight, fan_in_fan_out):\n    return weight.T if fan_in_fan_out else weight\n\n\nTRANSFORMERS_MODELS_TO_LORA_TARGET_MODULES_MAPPING = {\n    \"t5\": [\"q\", \"v\"],\n    \"mt5\": [\"q\", \"v\"],\n    \"bart\": [\"q_proj\", \"v_proj\"],", "    \"mt5\": [\"q\", \"v\"],\n    \"bart\": [\"q_proj\", \"v_proj\"],\n    \"gpt2\": [\"c_attn\"],\n    \"bloom\": [\"query_key_value\"],\n    \"blip-2\": [\"q\", \"v\", \"q_proj\", \"v_proj\"],\n    \"opt\": [\"q_proj\", \"v_proj\"],\n    \"gptj\": [\"q_proj\", \"v_proj\"],\n    \"gpt_neox\": [\"query_key_value\"],\n    \"gpt_neo\": [\"q_proj\", \"v_proj\"],\n    \"bert\": [\"query\", \"value\"],", "    \"gpt_neo\": [\"q_proj\", \"v_proj\"],\n    \"bert\": [\"query\", \"value\"],\n    \"roberta\": [\"query\", \"value\"],\n    \"xlm-roberta\": [\"query\", \"value\"],\n    \"electra\": [\"query\", \"value\"],\n    \"deberta-v2\": [\"query_proj\", \"value_proj\"],\n    \"deberta\": [\"in_proj\"],\n    \"layoutlm\": [\"query\", \"value\"],\n    \"llama\": [\"q_proj\", \"v_proj\"],\n    \"chatglm\": [\"query_key_value\"],", "    \"llama\": [\"q_proj\", \"v_proj\"],\n    \"chatglm\": [\"query_key_value\"],\n}\n\nTRANSFORMERS_MODELS_TO_ADALORA_TARGET_MODULES_MAPPING = {\n    \"t5\": [\"q\", \"k\", \"v\", \"o\", \"wi\", \"wo\"],\n    \"mt5\": [\"q\", \"k\", \"v\", \"o\", \"wi_0\", \"wi_1\", \"wo\"],\n    \"bart\": [\"q_proj\", \"k_proj\", \"v_proj\", \"out_proj\", \"fc1\", \"fc2\"],\n    # \"gpt2\": [\"c_attn\"],\n    # \"bloom\": [\"query_key_value\"],", "    # \"gpt2\": [\"c_attn\"],\n    # \"bloom\": [\"query_key_value\"],\n    \"opt\": [\"q_proj\", \"k_proj\", \"v_proj\", \"out_proj\", \"fc1\", \"fc2\"],\n    # \"gptj\": [\"q_proj\", \"v_proj\"],\n    # \"gpt_neox\": [\"query_key_value\"],\n    # \"gpt_neo\": [\"q_proj\", \"v_proj\"],\n    # \"bert\": [\"query\", \"value\"],\n    \"roberta\": [\"query\", \"key\", \"value\", \"dense\"],\n    # \"xlm-roberta\": [\"query\", \"value\"],\n    # \"electra\": [\"query\", \"value\"],", "    # \"xlm-roberta\": [\"query\", \"value\"],\n    # \"electra\": [\"query\", \"value\"],\n    \"deberta-v2\": [\"query_proj\", \"key_proj\", \"value_proj\", \"dense\"],\n    # \"deberta\": [\"in_proj\"],\n    # \"layoutlm\": [\"query\", \"value\"],\n}\n\nTRANSFORMERS_MODELS_TO_PREFIX_TUNING_POSTPROCESS_MAPPING = {\n    \"bloom\": bloom_model_postprocess_past_key_value,\n}", "    \"bloom\": bloom_model_postprocess_past_key_value,\n}\n\nWEIGHTS_NAME = \"adapter_model.bin\"\nCONFIG_NAME = \"adapter_config.json\"\n"]}
{"filename": "ft_chatglm_lora/peft/utils/config.py", "chunked_list": ["# coding=utf-8\n# Copyright 2023-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport enum\nimport json\nimport os\nfrom dataclasses import asdict, dataclass, field", "import os\nfrom dataclasses import asdict, dataclass, field\nfrom typing import Optional, Union\n\nfrom huggingface_hub import hf_hub_download\nfrom transformers.utils import PushToHubMixin\n\nfrom .other import CONFIG_NAME\n\n\nclass PeftType(str, enum.Enum):\n    PROMPT_TUNING = \"PROMPT_TUNING\"\n    P_TUNING = \"P_TUNING\"\n    PREFIX_TUNING = \"PREFIX_TUNING\"\n    LORA = \"LORA\"\n    ADALORA = \"ADALORA\"\n    ADAPTION_PROMPT = \"ADAPTION_PROMPT\"", "\n\nclass PeftType(str, enum.Enum):\n    PROMPT_TUNING = \"PROMPT_TUNING\"\n    P_TUNING = \"P_TUNING\"\n    PREFIX_TUNING = \"PREFIX_TUNING\"\n    LORA = \"LORA\"\n    ADALORA = \"ADALORA\"\n    ADAPTION_PROMPT = \"ADAPTION_PROMPT\"\n", "\n\nclass TaskType(str, enum.Enum):\n    SEQ_CLS = \"SEQ_CLS\"\n    SEQ_2_SEQ_LM = \"SEQ_2_SEQ_LM\"\n    CAUSAL_LM = \"CAUSAL_LM\"\n    TOKEN_CLS = \"TOKEN_CLS\"\n\n\n@dataclass\nclass PeftConfigMixin(PushToHubMixin):\n    r\"\"\"\n    This is the base configuration class for PEFT adapter models. It contains all the methods that are common to all\n    PEFT adapter models. This class inherits from [`~transformers.utils.PushToHubMixin`] which contains the methods to\n    push your model to the Hub. The method `save_pretrained` will save the configuration of your adapter model in a\n    directory. The method `from_pretrained` will load the configuration of your adapter model from a directory.\n\n    Args:\n        peft_type (Union[[`~peft.utils.config.PeftType`], `str`]): The type of Peft method to use.\n    \"\"\"\n    peft_type: Optional[PeftType] = field(default=None, metadata={\"help\": \"The type of PEFT model.\"})\n\n    @property\n    def __dict__(self):\n        return asdict(self)\n\n    def to_dict(self):\n        return self.__dict__\n\n    def save_pretrained(self, save_directory, **kwargs):\n        r\"\"\"\n        This method saves the configuration of your adapter model in a directory.\n\n        Args:\n            save_directory (`str`):\n                The directory where the configuration will be saved.\n            kwargs (additional keyword arguments, *optional*):\n                Additional keyword arguments passed along to the [`~transformers.utils.PushToHubMixin.push_to_hub`]\n                method.\n        \"\"\"\n        if os.path.isfile(save_directory):\n            raise AssertionError(f\"Provided path ({save_directory}) should be a directory, not a file\")\n\n        os.makedirs(save_directory, exist_ok=True)\n\n        output_dict = self.__dict__\n        output_path = os.path.join(save_directory, CONFIG_NAME)\n\n        # save it\n        with open(output_path, \"w\") as writer:\n            writer.write(json.dumps(output_dict, indent=2, sort_keys=True))\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, subfolder=None, **kwargs):\n        r\"\"\"\n        This method loads the configuration of your adapter model from a directory.\n\n        Args:\n            pretrained_model_name_or_path (`str`):\n                The directory or the Hub repository id where the configuration is saved.\n            kwargs (additional keyword arguments, *optional*):\n                Additional keyword arguments passed along to the child class initialization.\n        \"\"\"\n        path = (\n            os.path.join(pretrained_model_name_or_path, subfolder)\n            if subfolder is not None\n            else pretrained_model_name_or_path\n        )\n        if os.path.isfile(os.path.join(path, CONFIG_NAME)):\n            config_file = os.path.join(path, CONFIG_NAME)\n        else:\n            try:\n                config_file = hf_hub_download(pretrained_model_name_or_path, CONFIG_NAME, subfolder=subfolder)\n            except Exception:\n                raise ValueError(f\"Can't find '{CONFIG_NAME}' at '{pretrained_model_name_or_path}'\")\n\n        loaded_attributes = cls.from_json_file(config_file)\n\n        config = cls(**kwargs)\n\n        for key, value in loaded_attributes.items():\n            if hasattr(config, key):\n                setattr(config, key, value)\n\n        return config\n\n    @classmethod\n    def from_json_file(cls, path_json_file, **kwargs):\n        r\"\"\"\n        Loads a configuration file from a json file.\n\n        Args:\n            path_json_file (`str`):\n                The path to the json file.\n        \"\"\"\n        with open(path_json_file, \"r\") as file:\n            json_object = json.load(file)\n\n        return json_object", "\n@dataclass\nclass PeftConfigMixin(PushToHubMixin):\n    r\"\"\"\n    This is the base configuration class for PEFT adapter models. It contains all the methods that are common to all\n    PEFT adapter models. This class inherits from [`~transformers.utils.PushToHubMixin`] which contains the methods to\n    push your model to the Hub. The method `save_pretrained` will save the configuration of your adapter model in a\n    directory. The method `from_pretrained` will load the configuration of your adapter model from a directory.\n\n    Args:\n        peft_type (Union[[`~peft.utils.config.PeftType`], `str`]): The type of Peft method to use.\n    \"\"\"\n    peft_type: Optional[PeftType] = field(default=None, metadata={\"help\": \"The type of PEFT model.\"})\n\n    @property\n    def __dict__(self):\n        return asdict(self)\n\n    def to_dict(self):\n        return self.__dict__\n\n    def save_pretrained(self, save_directory, **kwargs):\n        r\"\"\"\n        This method saves the configuration of your adapter model in a directory.\n\n        Args:\n            save_directory (`str`):\n                The directory where the configuration will be saved.\n            kwargs (additional keyword arguments, *optional*):\n                Additional keyword arguments passed along to the [`~transformers.utils.PushToHubMixin.push_to_hub`]\n                method.\n        \"\"\"\n        if os.path.isfile(save_directory):\n            raise AssertionError(f\"Provided path ({save_directory}) should be a directory, not a file\")\n\n        os.makedirs(save_directory, exist_ok=True)\n\n        output_dict = self.__dict__\n        output_path = os.path.join(save_directory, CONFIG_NAME)\n\n        # save it\n        with open(output_path, \"w\") as writer:\n            writer.write(json.dumps(output_dict, indent=2, sort_keys=True))\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, subfolder=None, **kwargs):\n        r\"\"\"\n        This method loads the configuration of your adapter model from a directory.\n\n        Args:\n            pretrained_model_name_or_path (`str`):\n                The directory or the Hub repository id where the configuration is saved.\n            kwargs (additional keyword arguments, *optional*):\n                Additional keyword arguments passed along to the child class initialization.\n        \"\"\"\n        path = (\n            os.path.join(pretrained_model_name_or_path, subfolder)\n            if subfolder is not None\n            else pretrained_model_name_or_path\n        )\n        if os.path.isfile(os.path.join(path, CONFIG_NAME)):\n            config_file = os.path.join(path, CONFIG_NAME)\n        else:\n            try:\n                config_file = hf_hub_download(pretrained_model_name_or_path, CONFIG_NAME, subfolder=subfolder)\n            except Exception:\n                raise ValueError(f\"Can't find '{CONFIG_NAME}' at '{pretrained_model_name_or_path}'\")\n\n        loaded_attributes = cls.from_json_file(config_file)\n\n        config = cls(**kwargs)\n\n        for key, value in loaded_attributes.items():\n            if hasattr(config, key):\n                setattr(config, key, value)\n\n        return config\n\n    @classmethod\n    def from_json_file(cls, path_json_file, **kwargs):\n        r\"\"\"\n        Loads a configuration file from a json file.\n\n        Args:\n            path_json_file (`str`):\n                The path to the json file.\n        \"\"\"\n        with open(path_json_file, \"r\") as file:\n            json_object = json.load(file)\n\n        return json_object", "\n\n@dataclass\nclass PeftConfig(PeftConfigMixin):\n    \"\"\"\n    This is the base configuration class to store the configuration of a [`PeftModel`].\n\n    Args:\n        peft_type (Union[[`~peft.utils.config.PeftType`], `str`]): The type of Peft method to use.\n        task_type (Union[[`~peft.utils.config.TaskType`], `str`]): The type of task to perform.\n        inference_mode (`bool`, defaults to `False`): Whether to use the Peft model in inference mode.\n    \"\"\"\n\n    base_model_name_or_path: str = field(default=None, metadata={\"help\": \"The name of the base model to use.\"})\n    peft_type: Union[str, PeftType] = field(default=None, metadata={\"help\": \"Peft type\"})\n    task_type: Union[str, TaskType] = field(default=None, metadata={\"help\": \"Task type\"})\n    inference_mode: bool = field(default=False, metadata={\"help\": \"Whether to use inference mode\"})", "\n\n@dataclass\nclass PromptLearningConfig(PeftConfig):\n    \"\"\"\n    This is the base configuration class to store the configuration of [`PrefixTuning`], [`PromptEncoder`], or\n    [`PromptTuning`].\n\n    Args:\n        num_virtual_tokens (`int`): The number of virtual tokens to use.\n        token_dim (`int`): The hidden embedding dimension of the base transformer model.\n        num_transformer_submodules (`int`): The number of transformer submodules in the base transformer model.\n        num_attention_heads (`int`): The number of attention heads in the base transformer model.\n        num_layers (`int`): The number of layers in the base transformer model.\n    \"\"\"\n\n    num_virtual_tokens: int = field(default=None, metadata={\"help\": \"Number of virtual tokens\"})\n    token_dim: int = field(\n        default=None, metadata={\"help\": \"The hidden embedding dimension of the base transformer model\"}\n    )\n    num_transformer_submodules: Optional[int] = field(\n        default=None, metadata={\"help\": \"Number of transformer submodules\"}\n    )\n    num_attention_heads: Optional[int] = field(default=None, metadata={\"help\": \"Number of attention heads\"})\n    num_layers: Optional[int] = field(default=None, metadata={\"help\": \"Number of transformer layers\"})", ""]}
{"filename": "ft_chatglm_lora/peft/utils/__init__.py", "chunked_list": ["# flake8: noqa\n# There's no way to ignore \"F401 '...' imported but unused\" warnings in this\n# module, but to preserve other warnings. So, don't check this module at all\n\n# coding=utf-8\n# Copyright 2023-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom .config import PeftConfig, PeftType, PromptLearningConfig, TaskType\nfrom .other import (\n    TRANSFORMERS_MODELS_TO_PREFIX_TUNING_POSTPROCESS_MAPPING,\n    TRANSFORMERS_MODELS_TO_LORA_TARGET_MODULES_MAPPING,\n    TRANSFORMERS_MODELS_TO_ADALORA_TARGET_MODULES_MAPPING,\n    CONFIG_NAME,\n    WEIGHTS_NAME,", "    CONFIG_NAME,\n    WEIGHTS_NAME,\n    _set_trainable,\n    bloom_model_postprocess_past_key_value,\n    prepare_model_for_int8_training,\n    shift_tokens_right,\n    transpose,\n    _get_submodules,\n    _set_adapter,\n    _freeze_adapter,", "    _set_adapter,\n    _freeze_adapter,\n    ModulesToSaveWrapper,\n)\nfrom .save_and_load import get_peft_model_state_dict, set_peft_model_state_dict\n"]}
{"filename": "ft_chatglm_lora/peft/tuners/prompt_tuning.py", "chunked_list": ["# coding=utf-8\n# Copyright 2023-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport enum\nimport math\nfrom dataclasses import dataclass, field", "import math\nfrom dataclasses import dataclass, field\nfrom typing import Optional, Union\n\nimport torch\n\nfrom ..utils import PeftType, PromptLearningConfig\n\n\nclass PromptTuningInit(str, enum.Enum):\n    TEXT = \"TEXT\"\n    RANDOM = \"RANDOM\"", "\nclass PromptTuningInit(str, enum.Enum):\n    TEXT = \"TEXT\"\n    RANDOM = \"RANDOM\"\n\n\n@dataclass\nclass PromptTuningConfig(PromptLearningConfig):\n    \"\"\"\n    This is the configuration class to store the configuration of a [`PromptEmbedding`].\n\n    Args:\n        prompt_tuning_init (Union[[`PromptTuningInit`], `str`]): The initialization of the prompt embedding.\n        prompt_tuning_init_text (`str`, *optional*):\n            The text to initialize the prompt embedding. Only used if `prompt_tuning_init` is `TEXT`.\n        tokenizer_name_or_path (`str`, *optional*):\n            The name or path of the tokenizer. Only used if `prompt_tuning_init` is `TEXT`.\n    \"\"\"\n\n    prompt_tuning_init: Union[PromptTuningInit, str] = field(\n        default=PromptTuningInit.RANDOM,\n        metadata={\"help\": \"How to initialize the prompt tuning parameters\"},\n    )\n    prompt_tuning_init_text: Optional[str] = field(\n        default=None,\n        metadata={\n            \"help\": \"The text to use for prompt tuning initialization. Only used if prompt_tuning_init is `TEXT`\"\n        },\n    )\n    tokenizer_name_or_path: Optional[str] = field(\n        default=None,\n        metadata={\n            \"help\": \"The tokenizer to use for prompt tuning initialization. Only used if prompt_tuning_init is `TEXT`\"\n        },\n    )\n\n    def __post_init__(self):\n        self.peft_type = PeftType.PROMPT_TUNING", "\n\nclass PromptEmbedding(torch.nn.Module):\n    \"\"\"\n    The model to encode virtual tokens into prompt embeddings.\n\n    Args:\n        config ([`PromptTuningConfig`]): The configuration of the prompt embedding.\n        word_embeddings (`torch.nn.Module`): The word embeddings of the base transformer model.\n\n    **Attributes**:\n        - **embedding** (`torch.nn.Embedding`) -- The embedding layer of the prompt embedding.\n\n    Example:\n\n    ```py\n    >>> from peft import PromptEmbedding, PromptTuningConfig\n\n    >>> config = PromptTuningConfig(\n    ...     peft_type=\"PROMPT_TUNING\",\n    ...     task_type=\"SEQ_2_SEQ_LM\",\n    ...     num_virtual_tokens=20,\n    ...     token_dim=768,\n    ...     num_transformer_submodules=1,\n    ...     num_attention_heads=12,\n    ...     num_layers=12,\n    ...     prompt_tuning_init=\"TEXT\",\n    ...     prompt_tuning_init_text=\"Predict if sentiment of this review is positive, negative or neutral\",\n    ...     tokenizer_name_or_path=\"t5-base\",\n    ... )\n\n    >>> # t5_model.shared is the word embeddings of the base model\n    >>> prompt_embedding = PromptEmbedding(config, t5_model.shared)\n    ```\n\n    Input Shape: (`batch_size`, `total_virtual_tokens`)\n\n    Output Shape: (`batch_size`, `total_virtual_tokens`, `token_dim`)\n    \"\"\"\n\n    def __init__(self, config, word_embeddings):\n        super().__init__()\n\n        total_virtual_tokens = config.num_virtual_tokens * config.num_transformer_submodules\n        self.embedding = torch.nn.Embedding(total_virtual_tokens, config.token_dim)\n        if config.prompt_tuning_init == PromptTuningInit.TEXT:\n            from transformers import AutoTokenizer\n\n            tokenizer = AutoTokenizer.from_pretrained(config.tokenizer_name_or_path)\n            init_text = config.prompt_tuning_init_text\n            init_token_ids = tokenizer(init_text)[\"input_ids\"]\n            # Trim or iterate until num_text_tokens matches total_virtual_tokens\n            num_text_tokens = len(init_token_ids)\n            if num_text_tokens > total_virtual_tokens:\n                init_token_ids = init_token_ids[:total_virtual_tokens]\n            elif num_text_tokens < total_virtual_tokens:\n                num_reps = math.ceil(total_virtual_tokens / num_text_tokens)\n                init_token_ids = init_token_ids * num_reps\n            init_token_ids = init_token_ids[:total_virtual_tokens]\n\n            word_embedding_weights = word_embeddings(torch.LongTensor(init_token_ids)).detach().clone()\n            word_embedding_weights = word_embedding_weights.to(torch.float32)\n            self.embedding.weight = torch.nn.Parameter(word_embedding_weights)\n\n    def forward(self, indices):\n        # Just get embeddings\n        prompt_embeddings = self.embedding(indices)\n        return prompt_embeddings", ""]}
{"filename": "ft_chatglm_lora/peft/tuners/p_tuning.py", "chunked_list": ["# coding=utf-8\n# Copyright 2023-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport enum\nimport warnings\nfrom dataclasses import dataclass, field", "import warnings\nfrom dataclasses import dataclass, field\nfrom typing import Union\n\nimport torch\n\nfrom ..utils import PeftType, PromptLearningConfig\n\n\nclass PromptEncoderReparameterizationType(str, enum.Enum):\n    MLP = \"MLP\"\n    LSTM = \"LSTM\"", "\nclass PromptEncoderReparameterizationType(str, enum.Enum):\n    MLP = \"MLP\"\n    LSTM = \"LSTM\"\n\n\n@dataclass\nclass PromptEncoderConfig(PromptLearningConfig):\n    \"\"\"\n    This is the configuration class to store the configuration of a [`PromptEncoder`].\n\n    Args:\n        encoder_reparameterization_type (Union[[`PromptEncoderReparameterizationType`], `str`]):\n            The type of reparameterization to use.\n        encoder_hidden_size (`int`): The hidden size of the prompt encoder.\n        encoder_num_layers (`int`): The number of layers of the prompt encoder.\n        encoder_dropout (`float`): The dropout probability of the prompt encoder.\n    \"\"\"\n\n    encoder_reparameterization_type: Union[str, PromptEncoderReparameterizationType] = field(\n        default=PromptEncoderReparameterizationType.MLP,\n        metadata={\"help\": \"How to reparameterize the prompt encoder\"},\n    )\n    encoder_hidden_size: int = field(\n        default=None,\n        metadata={\"help\": \"The hidden size of the prompt encoder\"},\n    )\n    encoder_num_layers: int = field(\n        default=2,\n        metadata={\"help\": \"The number of layers of the prompt encoder\"},\n    )\n    encoder_dropout: float = field(\n        default=0.0,\n        metadata={\"help\": \"The dropout of the prompt encoder\"},\n    )\n\n    def __post_init__(self):\n        self.peft_type = PeftType.P_TUNING", "\n\n# Based on https://github.com/NVIDIA/NeMo/blob/main/nemo/collections/nlp/modules/common/prompt_encoder.py\n# with some refactor\nclass PromptEncoder(torch.nn.Module):\n    \"\"\"\n    The prompt encoder network that is used to generate the virtual token embeddings for p-tuning.\n\n    Args:\n        config ([`PromptEncoderConfig`]): The configuration of the prompt encoder.\n\n    Example:\n\n    ```py\n    >>> from peft import PromptEncoder, PromptEncoderConfig\n\n    >>> config = PromptEncoderConfig(\n    ...     peft_type=\"P_TUNING\",\n    ...     task_type=\"SEQ_2_SEQ_LM\",\n    ...     num_virtual_tokens=20,\n    ...     token_dim=768,\n    ...     num_transformer_submodules=1,\n    ...     num_attention_heads=12,\n    ...     num_layers=12,\n    ...     encoder_reparameterization_type=\"MLP\",\n    ...     encoder_hidden_size=768,\n    ... )\n\n    >>> prompt_encoder = PromptEncoder(config)\n    ```\n\n    **Attributes**:\n        - **embedding** (`torch.nn.Embedding`) -- The embedding layer of the prompt encoder.\n        - **mlp_head** (`torch.nn.Sequential`) -- The MLP head of the prompt encoder if `inference_mode=False`.\n        - **lstm_head** (`torch.nn.LSTM`) -- The LSTM head of the prompt encoder if `inference_mode=False` and\n        `encoder_reparameterization_type=\"LSTM\"`.\n        - **token_dim** (`int`) -- The hidden embedding dimension of the base transformer model.\n        - **input_size** (`int`) -- The input size of the prompt encoder.\n        - **output_size** (`int`) -- The output size of the prompt encoder.\n        - **hidden_size** (`int`) -- The hidden size of the prompt encoder.\n        - **total_virtual_tokens** (`int`): The total number of virtual tokens of the\n        prompt encoder.\n        - **encoder_type** (Union[[`PromptEncoderReparameterizationType`], `str`]): The encoder type of the prompt\n          encoder.\n\n\n    Input shape: (`batch_size`, `total_virtual_tokens`)\n\n    Output shape: (`batch_size`, `total_virtual_tokens`, `token_dim`)\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.token_dim = config.token_dim\n        self.input_size = self.token_dim\n        self.output_size = self.token_dim\n        self.hidden_size = config.encoder_hidden_size\n        self.total_virtual_tokens = config.num_virtual_tokens * config.num_transformer_submodules\n        self.encoder_type = config.encoder_reparameterization_type\n\n        # embedding\n        self.embedding = torch.nn.Embedding(self.total_virtual_tokens, self.token_dim)\n        if not config.inference_mode:\n            if self.encoder_type == PromptEncoderReparameterizationType.LSTM:\n                lstm_dropout = config.encoder_dropout\n                num_layers = config.encoder_num_layers\n                # LSTM\n                self.lstm_head = torch.nn.LSTM(\n                    input_size=self.input_size,\n                    hidden_size=self.hidden_size,\n                    num_layers=num_layers,\n                    dropout=lstm_dropout,\n                    bidirectional=True,\n                    batch_first=True,\n                )\n\n                self.mlp_head = torch.nn.Sequential(\n                    torch.nn.Linear(self.hidden_size * 2, self.hidden_size * 2),\n                    torch.nn.ReLU(),\n                    torch.nn.Linear(self.hidden_size * 2, self.output_size),\n                )\n\n            elif self.encoder_type == PromptEncoderReparameterizationType.MLP:\n                warnings.warn(\n                    f\"for {self.encoder_type}, the `encoder_num_layers` is ignored. Exactly 2 MLP layers are used.\"\n                )\n                layers = [\n                    torch.nn.Linear(self.input_size, self.hidden_size),\n                    torch.nn.ReLU(),\n                    torch.nn.Linear(self.hidden_size, self.hidden_size),\n                    torch.nn.ReLU(),\n                    torch.nn.Linear(self.hidden_size, self.output_size),\n                ]\n                self.mlp_head = torch.nn.Sequential(*layers)\n\n            else:\n                raise ValueError(\"Prompt encoder type not recognized. Please use one of MLP (recommended) or LSTM.\")\n\n    def forward(self, indices):\n        input_embeds = self.embedding(indices)\n        if self.encoder_type == PromptEncoderReparameterizationType.LSTM:\n            output_embeds = self.mlp_head(self.lstm_head(input_embeds)[0])\n        elif self.encoder_type == PromptEncoderReparameterizationType.MLP:\n            output_embeds = self.mlp_head(input_embeds)\n        else:\n            raise ValueError(\"Prompt encoder type not recognized. Please use one of MLP (recommended) or LSTM.\")\n\n        return output_embeds", ""]}
{"filename": "ft_chatglm_lora/peft/tuners/prefix_tuning.py", "chunked_list": ["# coding=utf-8\n# Copyright 2023-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom dataclasses import dataclass, field\n", "from dataclasses import dataclass, field\n\nimport torch\n\nfrom ..utils import PeftType, PromptLearningConfig\n\n\n@dataclass\nclass PrefixTuningConfig(PromptLearningConfig):\n    \"\"\"\n    This is the configuration class to store the configuration of a [`PrefixEncoder`].\n\n    Args:\n        encoder_hidden_size (`int`): The hidden size of the prompt encoder.\n        prefix_projection (`bool`): Whether to project the prefix embeddings.\n    \"\"\"\n\n    encoder_hidden_size: int = field(\n        default=None,\n        metadata={\"help\": \"The hidden size of the encoder\"},\n    )\n    prefix_projection: bool = field(\n        default=False,\n        metadata={\"help\": \"Whether to project the prefix tokens\"},\n    )\n\n    def __post_init__(self):\n        self.peft_type = PeftType.PREFIX_TUNING", "class PrefixTuningConfig(PromptLearningConfig):\n    \"\"\"\n    This is the configuration class to store the configuration of a [`PrefixEncoder`].\n\n    Args:\n        encoder_hidden_size (`int`): The hidden size of the prompt encoder.\n        prefix_projection (`bool`): Whether to project the prefix embeddings.\n    \"\"\"\n\n    encoder_hidden_size: int = field(\n        default=None,\n        metadata={\"help\": \"The hidden size of the encoder\"},\n    )\n    prefix_projection: bool = field(\n        default=False,\n        metadata={\"help\": \"Whether to project the prefix tokens\"},\n    )\n\n    def __post_init__(self):\n        self.peft_type = PeftType.PREFIX_TUNING", "\n\n# Based on https://github.com/THUDM/P-tuning-v2/blob/main/model/prefix_encoder.py\n# with some refactor\nclass PrefixEncoder(torch.nn.Module):\n    r\"\"\"\n    The `torch.nn` model to encode the prefix.\n\n    Args:\n        config ([`PrefixTuningConfig`]): The configuration of the prefix encoder.\n\n    Example:\n\n    ```py\n    >>> from peft import PrefixEncoder, PrefixTuningConfig\n\n    >>> config = PrefixTuningConfig(\n    ...     peft_type=\"PREFIX_TUNING\",\n    ...     task_type=\"SEQ_2_SEQ_LM\",\n    ...     num_virtual_tokens=20,\n    ...     token_dim=768,\n    ...     num_transformer_submodules=1,\n    ...     num_attention_heads=12,\n    ...     num_layers=12,\n    ...     encoder_hidden_size=768,\n    ... )\n    >>> prefix_encoder = PrefixEncoder(config)\n    ```\n\n    **Attributes**:\n        - **embedding** (`torch.nn.Embedding`) -- The embedding layer of the prefix encoder.\n        - **transform** (`torch.nn.Sequential`) -- The two-layer MLP to transform the prefix embeddings if\n          `prefix_projection` is `True`.\n        - **prefix_projection** (`bool`) -- Whether to project the prefix embeddings.\n\n    Input shape: (`batch_size`, `num_virtual_tokens`)\n\n    Output shape: (`batch_size`, `num_virtual_tokens`, `2*layers*hidden`)\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.prefix_projection = config.prefix_projection\n        token_dim = config.token_dim\n        num_layers = config.num_layers\n        encoder_hidden_size = config.encoder_hidden_size\n        num_virtual_tokens = config.num_virtual_tokens\n        if self.prefix_projection and not config.inference_mode:\n            # Use a two-layer MLP to encode the prefix\n            self.embedding = torch.nn.Embedding(num_virtual_tokens, token_dim)\n            self.transform = torch.nn.Sequential(\n                torch.nn.Linear(token_dim, encoder_hidden_size),\n                torch.nn.Tanh(),\n                torch.nn.Linear(encoder_hidden_size, num_layers * 2 * token_dim),\n            )\n        else:\n            self.embedding = torch.nn.Embedding(num_virtual_tokens, num_layers * 2 * token_dim)\n\n    def forward(self, prefix: torch.Tensor):\n        if self.prefix_projection:\n            prefix_tokens = self.embedding(prefix)\n            past_key_values = self.transform(prefix_tokens)\n        else:\n            past_key_values = self.embedding(prefix)\n        return past_key_values", ""]}
{"filename": "ft_chatglm_lora/peft/tuners/__init__.py", "chunked_list": ["# flake8: noqa\n# There's no way to ignore \"F401 '...' imported but unused\" warnings in this\n# module, but to preserve other warnings. So, don't check this module at all\n\n# coding=utf-8\n# Copyright 2023-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom .adaption_prompt import AdaptionPromptConfig, AdaptionPromptModel\nfrom .lora import LoraConfig, LoraModel\nfrom .adalora import AdaLoraConfig, AdaLoraModel\nfrom .p_tuning import PromptEncoder, PromptEncoderConfig, PromptEncoderReparameterizationType\nfrom .prefix_tuning import PrefixEncoder, PrefixTuningConfig\nfrom .prompt_tuning import PromptEmbedding, PromptTuningConfig, PromptTuningInit\n", "from .prompt_tuning import PromptEmbedding, PromptTuningConfig, PromptTuningInit\n"]}
{"filename": "ft_chatglm_lora/peft/tuners/lora.py", "chunked_list": ["# coding=utf-8\n# Copyright 2023-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport math\nimport re\nimport warnings\nfrom dataclasses import asdict, dataclass, field", "import warnings\nfrom dataclasses import asdict, dataclass, field\nfrom enum import Enum\nfrom typing import List, Optional, Union\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom transformers.pytorch_utils import Conv1D\n", "from transformers.pytorch_utils import Conv1D\n\nfrom ..import_utils import is_bnb_available\nfrom ..utils import (\n    TRANSFORMERS_MODELS_TO_LORA_TARGET_MODULES_MAPPING,\n    ModulesToSaveWrapper,\n    PeftConfig,\n    PeftType,\n    _freeze_adapter,\n    _get_submodules,", "    _freeze_adapter,\n    _get_submodules,\n    transpose,\n)\n\n\nif is_bnb_available():\n    import bitsandbytes as bnb\n\n", "\n\n@dataclass\nclass LoraConfig(PeftConfig):\n    \"\"\"\n    This is the configuration class to store the configuration of a [`LoraModel`].\n\n    Args:\n        r (`int`): Lora attention dimension.\n        target_modules (`Union[List[str],str]`): The names of the modules to apply Lora to.\n        lora_alpha (`float`): The alpha parameter for Lora scaling.\n        lora_dropout (`float`): The dropout probability for Lora layers.\n        fan_in_fan_out (`bool`): Set this to True if the layer to replace stores weight like (fan_in, fan_out).\n        For example, gpt-2 uses `Conv1D` which stores weights like (fan_in, fan_out) and hence this should be set to `True`.:\n        bias (`str`): Bias type for Lora. Can be 'none', 'all' or 'lora_only'\n        modules_to_save (`List[str]`):List of modules apart from LoRA layers to be set as trainable\n            and saved in the final checkpoint.\n    \"\"\"\n\n    r: int = field(default=8, metadata={\"help\": \"Lora attention dimension\"})\n    target_modules: Optional[Union[List[str], str]] = field(\n        default=None,\n        metadata={\n            \"help\": \"List of module names or regex expression of the module names to replace with Lora.\"\n            \"For example, ['q', 'v'] or '.*decoder.*(SelfAttention|EncDecAttention).*(q|v)$' \"\n        },\n    )\n    lora_alpha: int = field(default=None, metadata={\"help\": \"Lora alpha\"})\n    lora_dropout: float = field(default=None, metadata={\"help\": \"Lora dropout\"})\n    fan_in_fan_out: bool = field(\n        default=False,\n        metadata={\"help\": \"Set this to True if the layer to replace stores weight like (fan_in, fan_out)\"},\n    )\n    bias: str = field(default=\"none\", metadata={\"help\": \"Bias type for Lora. Can be 'none', 'all' or 'lora_only'\"})\n    modules_to_save: Optional[List[str]] = field(\n        default=None,\n        metadata={\n            \"help\": \"List of modules apart from LoRA layers to be set as trainable and saved in the final checkpoint. \"\n            \"For example, in Sequence Classification or Token Classification tasks, \"\n            \"the final layer `classifier/score` are randomly initialized and as such need to be trainable and saved.\"\n        },\n    )\n    init_lora_weights: bool = field(\n        default=True,\n        metadata={\"help\": \"Whether to initialize the weights of the Lora layers.\"},\n    )\n\n    def __post_init__(self):\n        self.peft_type = PeftType.LORA", "\n\nclass LoraModel(torch.nn.Module):\n    \"\"\"\n    Creates Low Rank Adapter (Lora) model from a pretrained transformers model.\n\n    Args:\n        model ([`~transformers.PreTrainedModel`]): The model to be adapted.\n        config ([`LoraConfig`]): The configuration of the Lora model.\n\n    Returns:\n        `torch.nn.Module`: The Lora model.\n\n    Example:\n\n        ```py\n        >>> from transformers import AutoModelForSeq2SeqLM, LoraConfig\n        >>> from peft import LoraModel, LoraConfig\n\n        >>> config = LoraConfig(\n        ...     peft_type=\"LORA\",\n        ...     task_type=\"SEQ_2_SEQ_LM\",\n        ...     r=8,\n        ...     lora_alpha=32,\n        ...     target_modules=[\"q\", \"v\"],\n        ...     lora_dropout=0.01,\n        ... )\n\n        >>> model = AutoModelForSeq2SeqLM.from_pretrained(\"t5-base\")\n        >>> lora_model = LoraModel(config, model)\n        ```\n\n    **Attributes**:\n        - **model** ([`~transformers.PreTrainedModel`]) -- The model to be adapted.\n        - **peft_config** ([`LoraConfig`]): The configuration of the Lora model.\n    \"\"\"\n\n    def __init__(self, model, config, adapter_name):\n        super().__init__()\n        self.model = model\n        self.forward = self.model.forward\n        self.peft_config = config\n        self.add_adapter(adapter_name, self.peft_config[adapter_name])\n\n    def add_adapter(self, adapter_name, config=None):\n        if config is not None:\n            model_config = self.model.config.to_dict() if hasattr(self.model.config, \"to_dict\") else self.model.config\n            config = self._prepare_lora_config(config, model_config)\n            self.peft_config[adapter_name] = config\n        self._find_and_replace(adapter_name)\n        if len(self.peft_config) > 1 and self.peft_config[adapter_name].bias != \"none\":\n            raise ValueError(\n                \"LoraModel supports only 1 adapter with bias. When using multiple adapters, set bias to 'none' for all adapters.\"\n            )\n        mark_only_lora_as_trainable(self.model, self.peft_config[adapter_name].bias)\n        if self.peft_config[adapter_name].inference_mode:\n            _freeze_adapter(self.model, adapter_name)\n\n    def _find_and_replace(self, adapter_name):\n        lora_config = self.peft_config[adapter_name]\n        loaded_in_8bit = getattr(self.model, \"is_loaded_in_8bit\", False)\n        if loaded_in_8bit and not is_bnb_available():\n            raise ImportError(\n                \"To use Lora with 8-bit quantization, please install the `bitsandbytes` package. \"\n                \"You can install it with `pip install bitsandbytes`.\"\n            )\n        is_target_modules_in_base_model = False\n        kwargs = {\n            \"r\": lora_config.r,\n            \"lora_alpha\": lora_config.lora_alpha,\n            \"lora_dropout\": lora_config.lora_dropout,\n            \"fan_in_fan_out\": lora_config.fan_in_fan_out,\n            \"init_lora_weights\": lora_config.init_lora_weights,\n        }\n        key_list = [key for key, _ in self.model.named_modules()]\n        for key in key_list:\n            if isinstance(lora_config.target_modules, str):\n                target_module_found = re.fullmatch(lora_config.target_modules, key)\n            else:\n                target_module_found = any(key.endswith(target_key) for target_key in lora_config.target_modules)\n            if target_module_found:\n                if not is_target_modules_in_base_model:\n                    is_target_modules_in_base_model = True\n                parent, target, target_name = _get_submodules(self.model, key)\n                bias = target.bias is not None\n                if isinstance(target, LoraLayer):\n                    target.update_layer(\n                        adapter_name,\n                        lora_config.r,\n                        lora_config.lora_alpha,\n                        lora_config.lora_dropout,\n                        lora_config.init_lora_weights,\n                    )\n                else:\n                    if loaded_in_8bit and isinstance(target, bnb.nn.Linear8bitLt):\n                        eightbit_kwargs = kwargs.copy()\n                        eightbit_kwargs.update(\n                            {\n                                \"has_fp16_weights\": target.state.has_fp16_weights,\n                                \"memory_efficient_backward\": target.state.memory_efficient_backward,\n                                \"threshold\": target.state.threshold,\n                                \"index\": target.index,\n                            }\n                        )\n                        new_module = Linear8bitLt(\n                            adapter_name, target.in_features, target.out_features, bias=bias, **eightbit_kwargs\n                        )\n                    else:\n                        if isinstance(target, torch.nn.Linear):\n                            in_features, out_features = target.in_features, target.out_features\n                            if kwargs[\"fan_in_fan_out\"]:\n                                warnings.warn(\n                                    \"fan_in_fan_out is set to True but the target module is `torch.nn.Linear`. \"\n                                    \"Setting fan_in_fan_out to False.\"\n                                )\n                                kwargs[\"fan_in_fan_out\"] = lora_config.fan_in_fan_out = False\n                        elif isinstance(target, Conv1D):\n                            in_features, out_features = (\n                                target.weight.ds_shape if hasattr(target.weight, \"ds_shape\") else target.weight.shape\n                            )\n                            if not kwargs[\"fan_in_fan_out\"]:\n                                warnings.warn(\n                                    \"fan_in_fan_out is set to False but the target module is `Conv1D`. \"\n                                    \"Setting fan_in_fan_out to True.\"\n                                )\n                                kwargs[\"fan_in_fan_out\"] = lora_config.fan_in_fan_out = True\n                        else:\n                            raise ValueError(\n                                f\"Target module {target} is not supported. \"\n                                f\"Currently, only `torch.nn.Linear` and `Conv1D` are supported.\"\n                            )\n                        new_module = Linear(adapter_name, in_features, out_features, bias=bias, **kwargs)\n\n                    self._replace_module(parent, target_name, new_module, target)\n        if not is_target_modules_in_base_model:\n            raise ValueError(\n                f\"Target modules {lora_config.target_modules} not found in the base model. \"\n                f\"Please check the target modules and try again.\"\n            )\n\n    def _replace_module(self, parent_module, child_name, new_module, old_module):\n        setattr(parent_module, child_name, new_module)\n        new_module.weight = old_module.weight\n        if old_module.bias is not None:\n            new_module.bias = old_module.bias\n        if getattr(old_module, \"state\", None) is not None:\n            new_module.state = old_module.state\n            new_module.to(old_module.weight.device)\n\n        # dispatch to correct device\n        for name, module in new_module.named_modules():\n            if \"lora_\" in name:\n                module.to(old_module.weight.device)\n\n    def __getattr__(self, name: str):\n        \"\"\"Forward missing attributes to the wrapped module.\"\"\"\n        try:\n            return super().__getattr__(name)  # defer to nn.Module's logic\n        except AttributeError:\n            return getattr(self.model, name)\n\n    def get_peft_config_as_dict(self, inference: bool = False):\n        config_dict = {}\n        for key, value in self.peft_config.items():\n            config = {k: v.value if isinstance(v, Enum) else v for k, v in asdict(value).items()}\n            if inference:\n                config[\"inference_mode\"] = True\n        config_dict[key] = config\n        return config\n\n    def _set_adapter_layers(self, enabled=True):\n        for module in self.model.modules():\n            if isinstance(module, LoraLayer):\n                module.disable_adapters = False if enabled else True\n\n    def enable_adapter_layers(self):\n        self._set_adapter_layers(enabled=True)\n\n    def disable_adapter_layers(self):\n        self._set_adapter_layers(enabled=False)\n\n    def set_adapter(self, adapter_name):\n        for module in self.model.modules():\n            if isinstance(module, LoraLayer):\n                if module.merged:\n                    warnings.warn(\"Adapter cannot be set when the model is merged. Unmerging the model first.\")\n                    module.unmerge()\n                module.active_adapter = adapter_name\n\n    def merge_adapter(self):\n        for module in self.model.modules():\n            if isinstance(module, LoraLayer):\n                module.merge()\n\n    def unmerge_adapter(self):\n        for module in self.model.modules():\n            if isinstance(module, LoraLayer):\n                module.unmerge()\n\n    @staticmethod\n    def _prepare_lora_config(peft_config, model_config):\n        if peft_config.target_modules is None:\n            if model_config[\"model_type\"] not in TRANSFORMERS_MODELS_TO_LORA_TARGET_MODULES_MAPPING:\n                raise ValueError(\"Please specify `target_modules` in `peft_config`\")\n            peft_config.target_modules = TRANSFORMERS_MODELS_TO_LORA_TARGET_MODULES_MAPPING[model_config[\"model_type\"]]\n        if peft_config.inference_mode:\n            peft_config.merge_weights = True\n        return peft_config\n\n    def merge_and_unload(self):\n        r\"\"\"\n        This method merges the LoRa layers into the base model. This is needed if someone wants to use the base model\n        as a standalone model.\n        \"\"\"\n        if getattr(self.config, \"model_type\", None) == \"gpt2\":\n            raise ValueError(\"GPT2 models are not supported for merging LORA layers\")\n\n        if getattr(self.model, \"is_loaded_in_8bit\", False):\n            raise ValueError(\"Cannot merge LORA layers when the model is loaded in 8-bit mode\")\n\n        key_list = [key for key, _ in self.model.named_modules() if \"lora\" not in key]\n        for key in key_list:\n            try:\n                parent, target, target_name = _get_submodules(self.model, key)\n            except AttributeError:\n                continue\n            if isinstance(target, LoraLayer):\n                bias = target.bias is not None\n                new_module = torch.nn.Linear(target.in_features, target.out_features, bias=bias)\n                target.merge()\n                self._replace_module(parent, target_name, new_module, target)\n\n            # save any additional trainable modules part of `modules_to_save`\n            if isinstance(target, ModulesToSaveWrapper):\n                setattr(parent, target_name, target.modules_to_save[target.active_adapter])\n\n        return self.model\n\n    def add_weighted_adapter(self, adapters, weights, adapter_name):\n        if len({self.peft_config[adapter].r for adapter in adapters}) != 1:\n            raise ValueError(\"All adapters must have the same r value\")\n        self.peft_config[adapter_name] = self.peft_config[adapters[0]]\n        self.peft_config[adapter_name].lora_alpha = self.peft_config[adapters[0]].r\n        self._find_and_replace(adapter_name)\n        mark_only_lora_as_trainable(self.model, self.peft_config[adapter_name].bias)\n        _freeze_adapter(self.model, adapter_name)\n        key_list = [key for key, _ in self.model.named_modules() if \"lora\" not in key]\n        for key in key_list:\n            _, target, _ = _get_submodules(self.model, key)\n            if isinstance(target, LoraLayer):\n                target.lora_A[adapter_name].weight.data = target.lora_A[adapter_name].weight.data * 0.0\n                target.lora_B[adapter_name].weight.data = target.lora_B[adapter_name].weight.data * 0.0\n                for adapter, weight in zip(adapters, weights):\n                    if adapter not in target.lora_A:\n                        continue\n                    target.lora_A[adapter_name].weight.data += (\n                        target.lora_A[adapter].weight.data * weight * target.scaling[adapter]\n                    )\n                    target.lora_B[adapter_name].weight.data += target.lora_B[adapter].weight.data * weight", "\n\n# Below code is based on https://github.com/microsoft/LoRA/blob/main/loralib/layers.py\n# and modified to work with PyTorch FSDP\n\n\n#  ------------------------------------------------------------------------------------------\n#  Copyright (c) Microsoft Corporation. All rights reserved.\n#  Licensed under the MIT License (MIT). See LICENSE in the repo root for license information.\n#  ------------------------------------------------------------------------------------------", "#  Licensed under the MIT License (MIT). See LICENSE in the repo root for license information.\n#  ------------------------------------------------------------------------------------------\n\n\n# had to adapt it for `lora_only` to work\ndef mark_only_lora_as_trainable(model: nn.Module, bias: str = \"none\") -> None:\n    for n, p in model.named_parameters():\n        if \"lora_\" not in n:\n            p.requires_grad = False\n    if bias == \"none\":\n        return\n    elif bias == \"all\":\n        for n, p in model.named_parameters():\n            if \"bias\" in n:\n                p.requires_grad = True\n    elif bias == \"lora_only\":\n        for m in model.modules():\n            if isinstance(m, LoraLayer) and hasattr(m, \"bias\") and m.bias is not None:\n                m.bias.requires_grad = True\n    else:\n        raise NotImplementedError", "\n\nclass LoraLayer:\n    def __init__(\n        self,\n        in_features: int,\n        out_features: int,\n    ):\n        self.r = {}\n        self.lora_alpha = {}\n        self.scaling = {}\n        self.lora_dropout = nn.ModuleDict({})\n        self.lora_A = nn.ModuleDict({})\n        self.lora_B = nn.ModuleDict({})\n        # Mark the weight as unmerged\n        self.merged = False\n        self.disable_adapters = False\n        self.in_features = in_features\n        self.out_features = out_features\n\n    def update_layer(self, adapter_name, r, lora_alpha, lora_dropout, init_lora_weights):\n        self.r[adapter_name] = r\n        self.lora_alpha[adapter_name] = lora_alpha\n        if lora_dropout > 0.0:\n            lora_dropout_layer = nn.Dropout(p=lora_dropout)\n        else:\n            lora_dropout_layer = nn.Identity()\n\n        self.lora_dropout.update(nn.ModuleDict({adapter_name: lora_dropout_layer}))\n        # Actual trainable parameters\n        if r > 0:\n            self.lora_A.update(nn.ModuleDict({adapter_name: nn.Linear(self.in_features, r, bias=False)}))\n            self.lora_B.update(nn.ModuleDict({adapter_name: nn.Linear(r, self.out_features, bias=False)}))\n            self.scaling[adapter_name] = lora_alpha / r\n        if init_lora_weights:\n            self.reset_lora_parameters(adapter_name)\n        self.to(self.weight.device)\n\n    def reset_lora_parameters(self, adapter_name):\n        if adapter_name in self.lora_A.keys():\n            # initialize A the same way as the default for nn.Linear and B to zero\n            nn.init.kaiming_uniform_(self.lora_A[adapter_name].weight, a=math.sqrt(5))\n            nn.init.zeros_(self.lora_B[adapter_name].weight)", "\n\nclass Linear(nn.Linear, LoraLayer):\n    # Lora implemented in a dense layer\n    def __init__(\n        self,\n        adapter_name: str,\n        in_features: int,\n        out_features: int,\n        r: int = 0,\n        lora_alpha: int = 1,\n        lora_dropout: float = 0.0,\n        fan_in_fan_out: bool = False,  # Set this to True if the layer to replace stores weight like (fan_in, fan_out)\n        **kwargs,\n    ):\n        init_lora_weights = kwargs.pop(\"init_lora_weights\", True)\n\n        nn.Linear.__init__(self, in_features, out_features, **kwargs)\n        LoraLayer.__init__(self, in_features=in_features, out_features=out_features)\n        # Freezing the pre-trained weight matrix\n        self.weight.requires_grad = False\n\n        self.fan_in_fan_out = fan_in_fan_out\n        if fan_in_fan_out:\n            self.weight.data = self.weight.data.T\n\n        nn.Linear.reset_parameters(self)\n        self.update_layer(adapter_name, r, lora_alpha, lora_dropout, init_lora_weights)\n        self.active_adapter = adapter_name\n\n    def merge(self):\n        if self.active_adapter not in self.lora_A.keys():\n            return\n        if self.merged:\n            warnings.warn(\"Already merged. Nothing to do.\")\n            return\n        if self.r[self.active_adapter] > 0:\n            self.weight.data += (\n                transpose(\n                    self.lora_B[self.active_adapter].weight @ self.lora_A[self.active_adapter].weight,\n                    self.fan_in_fan_out,\n                )\n                * self.scaling[self.active_adapter]\n            )\n            self.merged = True\n\n    def unmerge(self):\n        if self.active_adapter not in self.lora_A.keys():\n            return\n        if not self.merged:\n            warnings.warn(\"Already unmerged. Nothing to do.\")\n            return\n        if self.r[self.active_adapter] > 0:\n            self.weight.data -= (\n                transpose(\n                    self.lora_B[self.active_adapter].weight @ self.lora_A[self.active_adapter].weight,\n                    self.fan_in_fan_out,\n                )\n                * self.scaling[self.active_adapter]\n            )\n            self.merged = False\n\n    def forward(self, x: torch.Tensor):\n        previous_dtype = x.dtype\n\n        if self.active_adapter not in self.lora_A.keys():\n            return F.linear(x, transpose(self.weight, self.fan_in_fan_out), bias=self.bias)\n        if self.disable_adapters:\n            if self.r[self.active_adapter] > 0 and self.merged:\n                self.unmerge()\n            result = F.linear(x, transpose(self.weight, self.fan_in_fan_out), bias=self.bias)\n        elif self.r[self.active_adapter] > 0 and not self.merged:\n            result = F.linear(x, transpose(self.weight, self.fan_in_fan_out), bias=self.bias)\n\n            x = x.to(self.lora_A[self.active_adapter].weight.dtype)\n\n            result += (\n                self.lora_B[self.active_adapter](\n                    self.lora_A[self.active_adapter](self.lora_dropout[self.active_adapter](x))\n                )\n                * self.scaling[self.active_adapter]\n            )\n        else:\n            result = F.linear(x, transpose(self.weight, self.fan_in_fan_out), bias=self.bias)\n\n        result = result.to(previous_dtype)\n\n        return result", "\n\nif is_bnb_available():\n\n    class Linear8bitLt(bnb.nn.Linear8bitLt, LoraLayer):\n        # Lora implemented in a dense layer\n        def __init__(\n            self,\n            adapter_name,\n            in_features,\n            out_features,\n            r: int = 0,\n            lora_alpha: int = 1,\n            lora_dropout: float = 0.0,\n            **kwargs,\n        ):\n            bnb.nn.Linear8bitLt.__init__(\n                self,\n                in_features,\n                out_features,\n                bias=kwargs.get(\"bias\", True),\n                has_fp16_weights=kwargs.get(\"has_fp16_weights\", True),\n                memory_efficient_backward=kwargs.get(\"memory_efficient_backward\", False),\n                threshold=kwargs.get(\"threshold\", 0.0),\n                index=kwargs.get(\"index\", None),\n            )\n            LoraLayer.__init__(self, in_features=in_features, out_features=out_features)\n\n            # Freezing the pre-trained weight matrix\n            self.weight.requires_grad = False\n\n            init_lora_weights = kwargs.pop(\"init_lora_weights\", True)\n            self.update_layer(adapter_name, r, lora_alpha, lora_dropout, init_lora_weights)\n            self.active_adapter = adapter_name\n\n        def forward(self, x: torch.Tensor):\n            result = super().forward(x)\n\n            if self.disable_adapters or self.active_adapter not in self.lora_A.keys():\n                return result\n            elif self.r[self.active_adapter] > 0:\n                if not torch.is_autocast_enabled():\n                    expected_dtype = result.dtype\n\n                    if x.dtype != torch.float32:\n                        x = x.float()\n                    output = (\n                        self.lora_B[self.active_adapter](\n                            self.lora_A[self.active_adapter](self.lora_dropout[self.active_adapter](x))\n                        ).to(expected_dtype)\n                        * self.scaling[self.active_adapter]\n                    )\n                else:\n                    output = (\n                        self.lora_B[self.active_adapter](\n                            self.lora_A[self.active_adapter](self.lora_dropout[self.active_adapter](x))\n                        )\n                        * self.scaling[self.active_adapter]\n                    )\n                result += output\n            return result", ""]}
{"filename": "ft_chatglm_lora/peft/tuners/adalora.py", "chunked_list": ["import importlib\nimport re\nimport warnings\nfrom dataclasses import dataclass, field\nfrom typing import Optional\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom transformers.pytorch_utils import Conv1D", "import torch.nn.functional as F\nfrom transformers.pytorch_utils import Conv1D\n\nfrom ..utils import (\n    TRANSFORMERS_MODELS_TO_ADALORA_TARGET_MODULES_MAPPING,\n    PeftType,\n    _freeze_adapter,\n    _get_submodules,\n    transpose,\n)", "    transpose,\n)\nfrom .lora import (\n    LoraConfig,\n    LoraLayer,\n    LoraModel,\n    mark_only_lora_as_trainable,\n)\n\n\ndef is_bnb_available():\n    return importlib.util.find_spec(\"bitsandbytes\") is not None", "\n\ndef is_bnb_available():\n    return importlib.util.find_spec(\"bitsandbytes\") is not None\n\n\nif is_bnb_available():\n    import bitsandbytes as bnb\n\n", "\n\n@dataclass\nclass AdaLoraConfig(LoraConfig):\n    \"\"\"\n    This is the configuration class to store the configuration of a [`~peft.AdaLora`].\n\n    Args:\n        target_r (`int`): The target average rank of incremental matrix.\n        init_r (`int`): The initial rank for each incremental matrix.\n        tinit (`int`): The steps of initial fine-tuning warmup.\n        tfinal (`int`): The step of final fine-tuning.\n        deltaT (`int`): The time internval between two budget allocations.\n        beta1 (`float`): The hyperparameter of EMA for sensitivity smoothing.\n        beta2 (`float`): The hyperparameter of EMA for undertainty quantification.\n        orth_reg_weight (`float`): The coefficient of orthogonal regularization.\n        total_step (`int`): The total training steps that should be specified before training.\n        rank_pattern (`list`): The allocated rank for each weight matrix by RankAllocator.\n    \"\"\"\n\n    target_r: int = field(default=8, metadata={\"help\": \"Target Lora matrix dimension.\"})\n    init_r: int = field(default=12, metadata={\"help\": \"Intial Lora matrix dimension.\"})\n    tinit: int = field(default=0, metadata={\"help\": \"The steps of initial warmup.\"})\n    tfinal: int = field(default=0, metadata={\"help\": \"The steps of final warmup.\"})\n    deltaT: int = field(default=1, metadata={\"help\": \"Step interval of rank allocation.\"})\n    beta1: float = field(default=0.85, metadata={\"help\": \"Hyperparameter of EMA.\"})\n    beta2: float = field(default=0.85, metadata={\"help\": \"Hyperparameter of EMA.\"})\n    orth_reg_weight: float = field(default=0.5, metadata={\"help\": \"The orthogonal regularization coefficient.\"})\n    total_step: Optional[int] = field(default=None, metadata={\"help\": \"The total training steps.\"})\n    rank_pattern: Optional[dict] = field(default=None, metadata={\"help\": \"The saved rank pattern.\"})\n\n    def __post_init__(self):\n        self.peft_type = PeftType.ADALORA", "\n\nclass AdaLoraModel(LoraModel):\n    \"\"\"\n    Creates AdaLoRA (Adaptive LoRA) model from a pretrained transformers model. Paper:\n    https://openreview.net/pdf?id=lq62uWRJjiY\n\n    Args:\n        model ([`transformers.PreTrainedModel`]): The model to be adapted.\n        config ([`AdaLoraConfig`]): The configuration of the AdaLora model.\n\n    Returns:\n        `torch.nn.Module`: The AdaLora model.\n\n    Example::\n\n        >>> from transformers import AutoModelForSeq2SeqLM, LoraConfig >>> from peft import AdaLoraModel, AdaLoraConfig\n        >>> config = AdaLoraConfig(\n                peft_type=\"ADALORA\", task_type=\"SEQ_2_SEQ_LM\", r=8, lora_alpha=32, target_modules=[\"q\", \"v\"],\n                lora_dropout=0.01,\n            )\n        >>> model = AutoModelForSeq2SeqLM.from_pretrained(\"t5-base\") >>> model = AdaLoraModel(config, model)\n\n    **Attributes**:\n        - **model** ([`transformers.PreTrainedModel`]) -- The model to be adapted.\n        - **peft_config** ([`AdaLoraConfig`]): The configuration of the AdaLora model.\n    \"\"\"\n\n    def __init__(self, model, config, adapter_name):\n        nn.Module.__init__(self)\n        self.model = model\n        self.peft_config = config\n        self.add_adapter(adapter_name, self.peft_config[adapter_name])\n\n    def add_adapter(self, adapter_name, config=None):\n        if config is not None:\n            model_config = self.model.config.to_dict() if hasattr(self.model.config, \"to_dict\") else self.model.config\n            config = self._prepare_adalora_config(config, model_config)\n            self.peft_config[adapter_name] = config\n        self._find_and_replace(adapter_name)\n        if len(self.peft_config) > 1 and self.peft_config[adapter_name].bias != \"none\":\n            raise ValueError(\n                \"AdaLoraModel supports only 1 adapter with bias. When using multiple adapters, set bias to 'none' for all adapters.\"\n            )\n        traininable_mode_counter = 0\n        for config in self.peft_config.values():\n            if not config.inference_mode:\n                traininable_mode_counter += 1\n\n        if traininable_mode_counter > 1:\n            raise ValueError(\n                \"AdaLoraModel supports only 1 trainable adapter. \"\n                \"When using multiple adapters, set inference_mode to True for all adapters except the one you want to train.\"\n            )\n\n        mark_only_lora_as_trainable(self.model, self.peft_config[adapter_name].bias)\n        if self.peft_config[adapter_name].inference_mode:\n            _freeze_adapter(self.model, adapter_name)\n        else:\n            self.trainable_adapter_name = adapter_name\n            self.rankallocator = RankAllocator(self.model, self.peft_config[adapter_name], self.trainable_adapter_name)\n\n    def _find_and_replace(self, adapter_name):\n        lora_config = self.peft_config[adapter_name]\n        loaded_in_8bit = getattr(self.model, \"is_loaded_in_8bit\", False)\n        if loaded_in_8bit and not is_bnb_available():\n            raise ImportError(\n                \"To use Lora with 8-bit quantization, please install the `bitsandbytes` package. \"\n                \"You can install it with `pip install bitsandbytes`.\"\n            )\n        is_target_modules_in_base_model = False\n        kwargs = {\n            \"r\": lora_config.init_r,\n            \"lora_alpha\": lora_config.lora_alpha,\n            \"lora_dropout\": lora_config.lora_dropout,\n            \"fan_in_fan_out\": lora_config.fan_in_fan_out,\n            \"init_lora_weights\": lora_config.init_lora_weights,\n        }\n        key_list = [key for key, _ in self.model.named_modules()]\n        for key in key_list:\n            if isinstance(lora_config.target_modules, str):\n                target_module_found = re.fullmatch(lora_config.target_modules, key)\n            else:\n                target_module_found = any(key.endswith(target_key) for target_key in lora_config.target_modules)\n            if target_module_found:\n                if not is_target_modules_in_base_model:\n                    is_target_modules_in_base_model = True\n                parent, target, target_name = _get_submodules(self.model, key)\n                bias = target.bias is not None\n                if isinstance(target, LoraLayer):\n                    target.update_layer(\n                        adapter_name,\n                        lora_config.init_r,\n                        lora_config.lora_alpha,\n                        lora_config.lora_dropout,\n                        lora_config.init_lora_weights,\n                    )\n                else:\n                    if loaded_in_8bit and isinstance(target, bnb.nn.Linear8bitLt):\n                        kwargs.update(\n                            {\n                                \"has_fp16_weights\": target.state.has_fp16_weights,\n                                \"memory_efficient_backward\": target.state.memory_efficient_backward,\n                                \"threshold\": target.state.threshold,\n                                \"index\": target.index,\n                            }\n                        )\n                        new_module = SVDLinear8bitLt(\n                            adapter_name, target.in_features, target.out_features, bias=bias, **kwargs\n                        )\n                    else:\n                        if isinstance(target, torch.nn.Linear):\n                            in_features, out_features = target.in_features, target.out_features\n                            if kwargs[\"fan_in_fan_out\"]:\n                                warnings.warn(\n                                    \"fan_in_fan_out is set to True but the target module is `torch.nn.Linear`. \"\n                                    \"Setting fan_in_fan_out to False.\"\n                                )\n                                kwargs[\"fan_in_fan_out\"] = lora_config.fan_in_fan_out = False\n                        elif isinstance(target, Conv1D):\n                            in_features, out_features = (\n                                target.weight.ds_shape if hasattr(target.weight, \"ds_shape\") else target.weight.shape\n                            )\n                            if not kwargs[\"fan_in_fan_out\"]:\n                                warnings.warn(\n                                    \"fan_in_fan_out is set to False but the target module is `Conv1D`. \"\n                                    \"Setting fan_in_fan_out to True.\"\n                                )\n                                kwargs[\"fan_in_fan_out\"] = lora_config.fan_in_fan_out = True\n                        else:\n                            raise ValueError(\n                                f\"Target module {target} is not supported. \"\n                                f\"Currently, only `torch.nn.Linear` and `Conv1D` are supported.\"\n                            )\n                        new_module = SVDLinear(adapter_name, in_features, out_features, bias=bias, **kwargs)\n\n                    self._replace_module(parent, target_name, new_module, target)\n        if not is_target_modules_in_base_model:\n            raise ValueError(\n                f\"Target modules {lora_config.target_modules} not found in the base model. \"\n                f\"Please check the target modules and try again.\"\n            )\n\n    def __getattr__(self, name: str):\n        \"\"\"Forward missing attributes to the wrapped module.\"\"\"\n        try:\n            return super().__getattr__(name)  # defer to nn.Module's logic\n        except AttributeError:\n            return getattr(self.model, name)\n\n    def forward(self, *args, **kwargs):\n        outputs = self.model.forward(*args, **kwargs)\n\n        # Calculate the orthogonal regularization\n        orth_reg_weight = self.peft_config[self.trainable_adapter_name].orth_reg_weight\n        assert orth_reg_weight > 0\n\n        if hasattr(outputs, \"loss\"):\n            regu_loss = 0\n            num_param = 0\n            for n, p in self.model.named_parameters():\n                if (\"lora_A\" in n or \"lora_B\" in n) and self.trainable_adapter_name in n:\n                    para_cov = p @ p.T if \"lora_A\" in n else p.T @ p\n                    I = torch.eye(*para_cov.size(), out=torch.empty_like(para_cov))\n                    I.requires_grad = False\n                    num_param += 1\n                    regu_loss += torch.norm(para_cov - I, p=\"fro\")\n            regu_loss = regu_loss / num_param\n            outputs.loss += orth_reg_weight * regu_loss\n        return outputs\n\n    def resize_modules_by_rank_pattern(self, rank_pattern, adapter_name):\n        lora_config = self.peft_config[adapter_name]\n        for name, rank_idx in rank_pattern.items():\n            if isinstance(rank_idx, list):\n                rank = sum(rank_idx)\n            elif isinstance(rank_idx, torch.Tensor):\n                rank_idx = rank_idx.view(-1)\n                rank = rank_idx.sum().item()\n            else:\n                raise ValueError(\"Unexcepted type of rank_idx\")\n            key = \".\".join(name.split(\".\")[0:-2]) if adapter_name in name else \".\".join(name.split(\".\")[0:-1])\n            _, target, _ = _get_submodules(self.model, key)\n            lora_E_weights = target.lora_E[adapter_name][rank_idx]\n            lora_A_weights = target.lora_A[adapter_name][rank_idx]\n            lora_B_weights = target.lora_B[adapter_name][:, rank_idx]\n            ranknum = target.ranknum[adapter_name]\n            target.update_layer(\n                adapter_name,\n                rank,\n                lora_config.lora_alpha,\n                lora_config.lora_dropout,\n                lora_config.init_lora_weights,\n            )\n            with torch.no_grad():\n                if rank > 0:\n                    target.lora_E[adapter_name].copy_(lora_E_weights)\n                    target.lora_A[adapter_name].copy_(lora_A_weights)\n                    target.lora_B[adapter_name].copy_(lora_B_weights)\n                    # The scaling is exactly as the previous\n                    target.ranknum[adapter_name].copy_(ranknum)\n\n    def resize_state_dict_by_rank_pattern(self, rank_pattern, state_dict, adapter_name):\n        for name, rank_idx in rank_pattern.items():\n            rank = sum(rank_idx)\n            prefix = \".\".join(name.split(\".\")[0:-2]) if adapter_name in name else \".\".join(name.split(\".\")[0:-1])\n            for layer in [\"lora_E\", \"lora_A\", \"lora_B\"]:\n                key = f\"base_model.model.{prefix}.{layer}.{adapter_name}\"\n                if layer != \"lora_B\":\n                    state_dict[key] = (\n                        state_dict[key][rank_idx] if rank != state_dict[key].shape[0] else state_dict[key]\n                    )\n                else:\n                    state_dict[key] = (\n                        state_dict[key][:, rank_idx] if rank != state_dict[key].shape[1] else state_dict[key]\n                    )\n        return state_dict\n\n    def update_and_allocate(self, global_step):\n        lora_config = self.peft_config[self.trainable_adapter_name]\n        # Update the importance score and allocate the budget\n        if global_step < lora_config.total_step - lora_config.tfinal:\n            _, rank_pattern = self.rankallocator.update_and_allocate(self.model, global_step)\n            if rank_pattern:\n                lora_config.rank_pattern = rank_pattern\n        # Finalize the budget allocation\n        elif global_step == lora_config.total_step - lora_config.tfinal:\n            _, rank_pattern = self.rankallocator.update_and_allocate(self.model, global_step, force_mask=True)\n            # for some reason, this freezes the trainable parameters and nothing gets updates\n            # self.resize_modules_by_rank_pattern(rank_pattern, self.trainable_adapter_name)\n            lora_config.rank_pattern = rank_pattern\n            self.rankallocator.reset_ipt()\n        # Currently using inefficient way to mask the unimportant weights using the rank pattern\n        #  due to problem mentioned above\n        elif global_step > lora_config.total_step - lora_config.tfinal:\n            self.rankallocator.mask_using_rank_pattern(self.model, lora_config.rank_pattern)\n        # Pass the function and do forward propagation\n        else:\n            return None\n\n    @staticmethod\n    def _prepare_adalora_config(peft_config, model_config):\n        if peft_config.target_modules is None:\n            if model_config[\"model_type\"] not in TRANSFORMERS_MODELS_TO_ADALORA_TARGET_MODULES_MAPPING:\n                raise ValueError(\"Please specify `target_modules` in `peft_config`\")\n            peft_config.target_modules = TRANSFORMERS_MODELS_TO_ADALORA_TARGET_MODULES_MAPPING[\n                model_config[\"model_type\"]\n            ]\n        if peft_config.inference_mode:\n            peft_config.merge_weights = True\n        return peft_config", "\n\nclass AdaLoraLayer(LoraLayer):\n    def __init__(\n        self,\n        in_features: int,\n        out_features: int,\n    ):\n        super().__init__(in_features, out_features)\n        self.lora_E = nn.ParameterDict({})\n        self.lora_A = nn.ParameterDict({})\n        self.lora_B = nn.ParameterDict({})\n        self.ranknum = nn.ParameterDict({})\n\n    def update_layer(self, adapter_name, r, lora_alpha, lora_dropout, init_lora_weights):\n        self.r[adapter_name] = r\n        self.lora_alpha[adapter_name] = lora_alpha\n        if lora_dropout > 0.0:\n            lora_dropout_layer = nn.Dropout(p=lora_dropout)\n        else:\n\n            def lora_dropout_layer(x):\n                return x\n\n        self.lora_dropout.update(nn.ModuleDict({adapter_name: lora_dropout_layer}))\n        # Actual trainable parameters\n        # Right singular vectors\n        self.lora_A.update(nn.ParameterDict({adapter_name: nn.Parameter(torch.zeros(r, self.in_features))}))\n        # Singular values\n        self.lora_E.update(nn.ParameterDict({adapter_name: nn.Parameter(torch.zeros(r, 1))}))\n        # Left singular vectors\n        self.lora_B.update(nn.ParameterDict({adapter_name: nn.Parameter(torch.zeros(self.out_features, r))}))\n        # The current rank\n        self.ranknum.update(nn.ParameterDict({adapter_name: nn.Parameter(torch.zeros(1), requires_grad=False)}))\n        self.ranknum[adapter_name].data.fill_(float(r))\n        self.ranknum[adapter_name].requires_grad = False\n        self.scaling[adapter_name] = lora_alpha if lora_alpha > 0 else float(r)\n        if init_lora_weights:\n            self.reset_lora_parameters(adapter_name)\n        self.to(self.weight.device)\n\n    def reset_lora_parameters(self, adapter_name):\n        if adapter_name in self.lora_A.keys():\n            nn.init.zeros_(self.lora_E[adapter_name])\n            nn.init.normal_(self.lora_A[adapter_name], mean=0.0, std=0.02)\n            nn.init.normal_(self.lora_B[adapter_name], mean=0.0, std=0.02)", "\n\nclass SVDLinear(nn.Linear, AdaLoraLayer):\n    # SVD-based adaptation by a dense layer\n    def __init__(\n        self,\n        adapter_name: str,\n        in_features: int,\n        out_features: int,\n        r: int = 0,\n        lora_alpha: int = 1,\n        lora_dropout: float = 0.0,\n        fan_in_fan_out: bool = False,\n        **kwargs,\n    ):\n        init_lora_weights = kwargs.pop(\"init_lora_weights\", True)\n        nn.Linear.__init__(self, in_features, out_features, **kwargs)\n        AdaLoraLayer.__init__(self, in_features=in_features, out_features=out_features)\n        # Freezing the pre-trained weight matrix\n        self.weight.requires_grad = False\n\n        self.fan_in_fan_out = fan_in_fan_out\n        if fan_in_fan_out:\n            self.weight.data = self.weight.data.T\n\n        nn.Linear.reset_parameters(self)\n        self.update_layer(adapter_name, r, lora_alpha, lora_dropout, init_lora_weights)\n        self.active_adapter = adapter_name\n\n    def merge(self):\n        if self.active_adapter not in self.lora_A.keys():\n            return\n        if self.merged:\n            warnings.warn(\"Already merged. Nothing to do.\")\n            return\n        if self.r[self.active_adapter] > 0:\n            self.weight.data += (\n                transpose(\n                    self.lora_B[self.active_adapter]\n                    @ (self.lora_A[self.active_adapter] * self.lora_E[self.active_adapter])\n                )\n                * self.scaling[self.active_adapter]\n                / (self.ranknum[self.active_adapter] + 1e-5)\n            )\n            self.merged = True\n\n    def unmerge(self):\n        if self.active_adapter not in self.lora_A.keys():\n            return\n        if not self.merged:\n            warnings.warn(\"Already unmerged. Nothing to do.\")\n            return\n        if self.r[self.active_adapter] > 0:\n            self.weight.data -= (\n                transpose(\n                    self.lora_B[self.active_adapter]\n                    @ (self.lora_A[self.active_adapter] * self.lora_E[self.active_adapter])\n                )\n                * self.scaling[self.active_adapter]\n                / (self.ranknum[self.active_adapter] + 1e-5)\n            )\n            self.merged = False\n\n    def forward(self, x: torch.Tensor):\n        if self.active_adapter not in self.lora_A.keys():\n            return F.linear(x, transpose(self.weight, self.fan_in_fan_out), bias=self.bias)\n        if self.disable_adapters:\n            if self.r[self.active_adapter] > 0 and self.merged:\n                self.unmerge()\n            result = F.linear(x, transpose(self.weight, self.fan_in_fan_out), bias=self.bias)\n        elif self.r[self.active_adapter] > 0 and not self.merged:\n            result = F.linear(x, transpose(self.weight, self.fan_in_fan_out), bias=self.bias)\n            result += (\n                (\n                    self.lora_dropout[self.active_adapter](x)\n                    @ (self.lora_A[self.active_adapter] * self.lora_E[self.active_adapter]).T\n                    @ self.lora_B[self.active_adapter].T\n                )\n                * self.scaling[self.active_adapter]\n                / (self.ranknum[self.active_adapter] + 1e-5)\n            )\n        else:\n            result = F.linear(x, transpose(self.weight, self.fan_in_fan_out), bias=self.bias)\n        return result", "\n\nif is_bnb_available():\n\n    class SVDLinear8bitLt(bnb.nn.Linear8bitLt, AdaLoraLayer):\n        # Low-rank matrix for SVD-based adaptation\n        def __init__(\n            self,\n            adapter_name,\n            in_features,\n            out_features,\n            r: int = 0,\n            lora_alpha: int = 1,\n            lora_dropout: float = 0.0,\n            **kwargs,\n        ):\n            bnb.nn.Linear8bitLt.__init__(\n                self,\n                in_features,\n                out_features,\n                bias=kwargs.get(\"bias\", True),\n                has_fp16_weights=kwargs.get(\"has_fp16_weights\", True),\n                memory_efficient_backward=kwargs.get(\"memory_efficient_backward\", False),\n                threshold=kwargs.get(\"threshold\", 0.0),\n                index=kwargs.get(\"index\", None),\n            )\n            AdaLoraLayer.__init__(self, in_features=in_features, out_features=out_features)\n            # Freezing the pre-trained weight matrix\n            self.weight.requires_grad = False\n\n            init_lora_weights = kwargs.pop(\"init_lora_weights\", True)\n            self.update_layer(adapter_name, r, lora_alpha, lora_dropout, init_lora_weights)\n            self.active_adapter = adapter_name\n\n        def forward(self, x: torch.Tensor):\n            result = super().forward(x)\n\n            if self.disable_adapters or self.active_adapter not in self.lora_A.keys():\n                return result\n            elif self.r[self.active_adapter] > 0:\n                if not torch.is_autocast_enabled():\n                    expected_dtype = result.dtype\n\n                    if x.dtype != torch.float32:\n                        x = x.float()\n                    output = (\n                        (\n                            self.lora_dropout[self.active_adapter](x)\n                            @ (self.lora_A[self.active_adapter] * self.lora_E[self.active_adapter]).T\n                            @ self.lora_B[self.active_adapter].T\n                        ).to(expected_dtype)\n                        * self.scaling[self.active_adapter]\n                        / (self.ranknum[self.active_adapter] + 1e-5)\n                    )\n                else:\n                    output = (\n                        (\n                            self.lora_dropout[self.active_adapter](x)\n                            @ (self.lora_A[self.active_adapter] * self.lora_E[self.active_adapter]).T\n                            @ self.lora_B[self.active_adapter].T\n                        )\n                        * self.scaling[self.active_adapter]\n                        / (self.ranknum[self.active_adapter] + 1e-5)\n                    )\n                result += output\n            return result", "\n\nclass RankAllocator(object):\n    \"\"\"\n    The RankAllocator for AdaLoraModel. Paper: https://openreview.net/pdf?id=lq62uWRJjiY\n\n    Args:\n        config ([`AdaLoraConfig`]): The configuration of the AdaLora model.\n        model: the model that we apply AdaLoRA to.\n\n    \"\"\"\n\n    def __init__(self, model, peft_config, adapter_name):\n        self.peft_config = peft_config\n        self.adapter_name = adapter_name\n        self.beta1 = peft_config.beta1\n        self.beta2 = peft_config.beta2\n        assert self.beta1 > 0 and self.beta1 < 1\n        assert self.beta2 > 0 and self.beta2 < 1\n\n        self.reset_ipt()\n        self._set_budget_scheduler(model)\n\n    def set_total_step(self, total_step):\n        self.peft_config.total_step = total_step\n\n    def reset_ipt(self):\n        self.ipt = {}\n        self.exp_avg_ipt = {}\n        self.exp_avg_unc = {}\n\n    def _set_budget_scheduler(self, model):\n        self.init_bgt = 0\n        self.name_set = set()\n        for n, p in model.named_parameters():\n            if f\"lora_A.{self.adapter_name}\" in n:\n                self.init_bgt += p.size(0)\n                self.name_set.add(n.replace(\"lora_A\", \"%s\"))\n        self.name_set = sorted(self.name_set)\n        # The total final rank budget\n        self.target_bgt = self.peft_config.target_r * len(self.name_set)\n\n    def budget_schedule(self, step: int):\n        tinit = self.peft_config.tinit\n        tfinal = self.peft_config.tfinal\n        total_step = self.peft_config.total_step\n        # Initial warmup\n        if step <= tinit:\n            budget = self.init_bgt\n            mask_ind = False\n        # Final fine-tuning\n        elif step > total_step - tfinal:\n            budget = self.target_bgt\n            mask_ind = True\n        else:\n            # Budget decreasing with a cubic scheduler\n            mul_coeff = 1 - (step - tinit) / (total_step - tfinal - tinit)\n            budget = int((self.init_bgt - self.target_bgt) * (mul_coeff**3) + self.target_bgt)\n            mask_ind = True if step % self.peft_config.deltaT == 0 else False\n        return budget, mask_ind\n\n    def update_ipt(self, model):\n        # Update the sensitivity and uncertainty for every weight\n        for n, p in model.named_parameters():\n            if \"lora_\" in n and self.adapter_name in n:\n                if n not in self.ipt:\n                    self.ipt[n] = torch.zeros_like(p)\n                    self.exp_avg_ipt[n] = torch.zeros_like(p)\n                    self.exp_avg_unc[n] = torch.zeros_like(p)\n                with torch.no_grad():\n                    self.ipt[n] = (p * p.grad).abs().detach()\n                    # Sensitivity smoothing\n                    self.exp_avg_ipt[n] = self.beta1 * self.exp_avg_ipt[n] + (1 - self.beta1) * self.ipt[n]\n                    # Uncertainty quantification\n                    self.exp_avg_unc[n] = (\n                        self.beta2 * self.exp_avg_unc[n] + (1 - self.beta2) * (self.ipt[n] - self.exp_avg_ipt[n]).abs()\n                    )\n\n    def _element_score(self, n):\n        return self.exp_avg_ipt[n] * self.exp_avg_unc[n]\n\n    def _combine_ipt(self, ipt_E, ipt_AB):\n        ipt_AB = ipt_AB.sum(dim=1, keepdim=False)\n        sum_ipt = ipt_E.view(-1) + ipt_AB.view(-1)\n        return sum_ipt\n\n    def mask_to_budget(self, model, budget):\n        value_ipt = {}\n        vector_ipt = {}\n        triplet_ipt = {}\n        # Get the importance score for A, E, B\n        for n, p in model.named_parameters():\n            if f\"lora_A.{self.adapter_name}\" in n:\n                entry_ipt = self._element_score(n)\n                comb_ipt = torch.mean(entry_ipt, dim=1, keepdim=True)\n                name_m = n.replace(\"lora_A\", \"%s\")\n                if name_m not in vector_ipt:\n                    vector_ipt[name_m] = [comb_ipt]\n                else:\n                    vector_ipt[name_m].append(comb_ipt)\n            if f\"lora_B.{self.adapter_name}\" in n:\n                entry_ipt = self._element_score(n)\n                comb_ipt = torch.mean(entry_ipt, dim=0, keepdim=False).view(-1, 1)\n                name_m = n.replace(\"lora_B\", \"%s\")\n                if name_m not in vector_ipt:\n                    vector_ipt[name_m] = [comb_ipt]\n                else:\n                    vector_ipt[name_m].append(comb_ipt)\n            if f\"lora_E.{self.adapter_name}\" in n:\n                entry_ipt = self._element_score(n)\n                name_m = n.replace(\"lora_E\", \"%s\")\n                value_ipt[name_m] = entry_ipt\n\n        all_score = []\n        # Calculate the score for each triplet\n        for name_m in vector_ipt:\n            ipt_E = value_ipt[name_m]\n            ipt_AB = torch.cat(vector_ipt[name_m], dim=1)\n            sum_ipt = self._combine_ipt(ipt_E, ipt_AB)\n            name_E = name_m % \"lora_E\"\n            triplet_ipt[name_E] = sum_ipt.view(-1, 1)\n            all_score.append(sum_ipt.view(-1))\n\n        # Get the threshold by ranking ipt\n        mask_threshold = torch.kthvalue(\n            torch.cat(all_score),\n            k=self.init_bgt - budget,\n        )[0].item()\n\n        rank_pattern = {}\n        # Mask the unimportant triplets\n        with torch.no_grad():\n            for n, p in model.named_parameters():\n                if f\"lora_E.{self.adapter_name}\" in n:\n                    p.masked_fill_(triplet_ipt[n] <= mask_threshold, 0.0)\n                    rank_pattern[n] = (~(triplet_ipt[n] <= mask_threshold)).view(-1).tolist()\n        return rank_pattern\n\n    def update_and_allocate(self, model, global_step, force_mask=False):\n        # # Update the importance score and allocate the budget\n        if global_step < self.peft_config.total_step - self.peft_config.tfinal:\n            self.update_ipt(model)\n        budget, mask_ind = self.budget_schedule(global_step)\n        # Allocate the budget according to importance scores\n        if mask_ind or force_mask:\n            rank_pattern = self.mask_to_budget(model, budget)\n        else:\n            rank_pattern = None\n        return budget, rank_pattern\n\n    def mask_using_rank_pattern(self, model, rank_pattern):\n        # Mask the unimportant triplets\n        is_adapter_name_truncated = False\n        if self.adapter_name not in next(iter(rank_pattern.keys())):\n            is_adapter_name_truncated = True\n\n        with torch.no_grad():\n            for n, p in model.named_parameters():\n                if f\"lora_E.{self.adapter_name}\" in n:\n                    key = n if not is_adapter_name_truncated else n.replace(f\".{self.adapter_name}\", \"\")\n                    mask = torch.Tensor(rank_pattern[key]).unsqueeze(-1).to(p.device)\n                    p.masked_fill_(~mask.bool(), 0.0)", ""]}
{"filename": "ft_chatglm_lora/peft/tuners/adaption_prompt.py", "chunked_list": ["# coding=utf-8\n# Copyright 2023-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport math\nfrom collections import namedtuple\nfrom dataclasses import dataclass, field", "from collections import namedtuple\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom peft.utils.config import PeftConfig, PeftType\nfrom peft.utils.other import _freeze_adapter, _get_submodules", "from peft.utils.config import PeftConfig, PeftType\nfrom peft.utils.other import _freeze_adapter, _get_submodules\n\n\ndef llama_rotate_half(x: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Rotate half the hidden dims of the input.\n\n    This function was duplicated verbatim from:\n    https://github.com/huggingface/transformers/blob/1de8ce9ee1191ba761a593ac15d9ccbf5851bfc5/src/transformers/models/llama/modeling_llama.py#L126\n\n    This was done to eliminate the Llama transformers implementation as a dependency of this file. Note that some other\n    functions were also adapted from the transformers implementation but were modified.\n    \"\"\"\n    x1 = x[..., : x.shape[-1] // 2]\n    x2 = x[..., x.shape[-1] // 2 :]\n    return torch.cat((-x2, x1), dim=-1)", "\n\ndef llama_apply_rotary_pos_emb(q, cos, sin, position_ids):\n    \"\"\"\n    Apply rotary position embedding to query states in the Llama model.\n\n    This function was adapted from:\n    https://github.com/huggingface/transformers/blob/1de8ce9ee1191ba761a593ac15d9ccbf5851bfc5/src/transformers/models/llama/modeling_llama.py#L133\n\n    It was modified to remove unnecessary processing of key states.\n    \"\"\"\n    gather_indices = position_ids[:, None, :, None]  # [bs, 1, seq_len, 1]\n    gather_indices = gather_indices.repeat(1, cos.shape[1], 1, cos.shape[3])\n    cos = torch.gather(cos.repeat(gather_indices.shape[0], 1, 1, 1), 2, gather_indices)\n    sin = torch.gather(sin.repeat(gather_indices.shape[0], 1, 1, 1), 2, gather_indices)\n    q_embed = (q * cos) + (llama_rotate_half(q) * sin)\n    return q_embed", "\n\ndef llama_compute_query_states(model: nn.Module, **kwargs) -> torch.Tensor:\n    \"\"\"\n    Compute query states for Llama models specifically.\n\n    They need to be recomputed as the forward() method of the original LlamaModel in the transformers library does not\n    return them. See the related discussion in the PR: https://github.com/huggingface/peft/pull/268\n    \"\"\"\n    hidden_states = kwargs.get(\"hidden_states\")\n    position_ids = kwargs.get(\"position_ids\")\n    past_key_value = kwargs.get(\"past_key_value\")\n    bsz, q_len, _ = hidden_states.size()\n    query_states = model.q_proj(hidden_states).view(bsz, q_len, model.num_heads, model.head_dim).transpose(1, 2)\n    value_states = model.v_proj(hidden_states).view(bsz, q_len, model.num_heads, model.head_dim).transpose(1, 2)\n\n    seq_len = q_len\n    if past_key_value is not None:\n        seq_len += past_key_value[0].shape[-2]\n    cos, sin = model.rotary_emb(value_states, seq_len=seq_len)\n\n    return llama_apply_rotary_pos_emb(query_states, cos, sin, position_ids)", "\n\n# Contains the config that is specific to a transformers model type.\nModelTypeConfig = namedtuple(\n    \"ModelTypeConfig\", [\"compute_query_states\", \"target_modules\", \"k_proj_layer\", \"v_proj_layer\", \"o_proj_layer\"]\n)\n# Mapping of transformers model types to their specific configuration.\nTRANSFORMERS_MODEL_CONFIG = {\n    \"llama\": ModelTypeConfig(\n        compute_query_states=llama_compute_query_states,", "    \"llama\": ModelTypeConfig(\n        compute_query_states=llama_compute_query_states,\n        target_modules=\"self_attn\",\n        k_proj_layer=\"k_proj\",\n        v_proj_layer=\"v_proj\",\n        o_proj_layer=\"o_proj\",\n    ),\n}\n\n\ndef is_adaption_prompt_trainable(params: str) -> bool:\n    \"\"\"Return True if module is trainable under adaption prompt fine-tuning.\"\"\"\n    return params.split(\".\")[-1].startswith(\"adaption_\")", "\n\ndef is_adaption_prompt_trainable(params: str) -> bool:\n    \"\"\"Return True if module is trainable under adaption prompt fine-tuning.\"\"\"\n    return params.split(\".\")[-1].startswith(\"adaption_\")\n\n\n@dataclass\nclass AdaptionPromptConfig(PeftConfig):\n    \"\"\"Stores the configuration of an [`AdaptionPromptModel`].\"\"\"\n\n    target_modules: str = field(\n        default=None, metadata={\"help\": \"Name of the attention submodules to insert adaption prompts into.\"}\n    )\n    adapter_len: int = field(default=None, metadata={\"help\": \"Number of adapter tokens to insert\"})\n    adapter_layers: int = field(default=None, metadata={\"help\": \"Number of adapter layers (from the top)\"})\n\n    def __post_init__(self):\n        self.peft_type = PeftType.ADAPTION_PROMPT", "class AdaptionPromptConfig(PeftConfig):\n    \"\"\"Stores the configuration of an [`AdaptionPromptModel`].\"\"\"\n\n    target_modules: str = field(\n        default=None, metadata={\"help\": \"Name of the attention submodules to insert adaption prompts into.\"}\n    )\n    adapter_len: int = field(default=None, metadata={\"help\": \"Number of adapter tokens to insert\"})\n    adapter_layers: int = field(default=None, metadata={\"help\": \"Number of adapter layers (from the top)\"})\n\n    def __post_init__(self):\n        self.peft_type = PeftType.ADAPTION_PROMPT", "\n\ndef prepare_config(\n    peft_config: AdaptionPromptConfig,\n    model,\n) -> AdaptionPromptConfig:\n    \"\"\"Prepare the config based on the llama model type.\"\"\"\n    if model.config.model_type not in TRANSFORMERS_MODEL_CONFIG:\n        raise ValueError(\"Unsupported model type for adaption prompt: '{model.config.model_type}'.\")\n\n    model_config = TRANSFORMERS_MODEL_CONFIG[model.config.model_type]\n\n    if peft_config.target_modules is None:\n        peft_config.target_modules = model_config.target_modules\n\n    return peft_config", "\n\nclass AdaptionPromptModel(nn.Module):\n    \"\"\"\n    Implements adaption prompts as described in https://arxiv.org/pdf/2303.16199.pdf.\n\n    The top L attention modules are replaced with AdaptedAttention modules that wrap the original ones, but insert\n    trainable prompts with gates (for zero init).\n\n    Notes on the multi-adapter pattern:\n    - We store the states of different adapters by keeping a dictionary of AdaptedAttention modules indexed by adapter\n      name.\n    - Every time we switch adapters, we remove the modules of the currently active adapter from the model, store them\n      in the dictionary, and replace them with the modules of the new adapter.\n    - To avoid duplicated and potentially inconsistent state, the currently active adapter is always removed from the\n      dictionary.\n    - Disabling the adapter would also result in the modules being removed from the model.\n    \"\"\"\n\n    def __init__(self, model, configs: Dict, adapter_name: str):\n        super().__init__()\n        self.model = model\n        # Store adapter configs by name.\n        self._configs: Dict[str, AdaptionPromptConfig] = {}\n        # Store lists of the parents of the affected attention modules by adapter name.\n        # We keep references to the parents so we can swap the adapters in-and-out of the model.\n        self._parents: Dict[str, List[nn.Module]] = {}\n        # Store lists of cached AdaptedAttention modules by name.\n        self._cached_adapters: Dict[str, List] = {}\n        # The name of the currently active adapter.\n        self._active_adapter = None\n        # Whether the adapter is enabled.\n        self._enabled = True\n        self.forward = self.model.forward\n        self.add_adapter(adapter_name, configs[adapter_name])\n        self._mark_only_adaption_prompts_as_trainable()\n\n    def add_adapter(self, adapter_name: str, config: AdaptionPromptConfig) -> None:\n        \"\"\"Add an adapter with the given name and config.\"\"\"\n        config = prepare_config(config, self.model)\n        if adapter_name in self._configs:\n            raise ValueError(f\"Adapter with name '{adapter_name}' already exists.\")\n\n        parents = []\n        for name, _ in self.model.named_modules():\n            if name.endswith(config.target_modules):\n                par, _, _ = _get_submodules(self.model, name)\n                parents.append(par)\n        if len(parents) < config.adapter_layers:\n            raise ValueError(\n                f\"Config specifies more adapter layers '{config.adapter_layers}'\"\n                f\" than the model has '{len(parents)}'.\"\n            )\n        # Note that if the target modules are not in Sequential, ModuleList, or\n        # some other PyTorch ordered container, the behavior is undefined as we\n        # assume here that the order of the modules is the same as the order of\n        # the transformer decoder layers.\n        parents = parents[-config.adapter_layers :]\n        self._parents[adapter_name] = parents\n\n        # It is only None during initialization.\n        # If it is disabled, we don't have to remove the modules.\n        if self._active_adapter is not None and self._enabled:\n            self._remove_adapted_attentions(self._active_adapter)\n        self._active_adapter = adapter_name\n        self._configs[adapter_name] = config\n        self._create_adapted_attentions(config, parents)\n        if not self._enabled:\n            self._remove_adapted_attentions(self._active_adapter)\n\n        if config.inference_mode:\n            _freeze_adapter(self.model, adapter_name)\n\n    def set_adapter(self, adapter_name: str) -> None:\n        \"\"\"Set the model to use the adapter with the given name.\"\"\"\n        if self._active_adapter == adapter_name:\n            return\n        if adapter_name not in self._configs:\n            raise ValueError(f\"Adapter with name '{adapter_name}' does not exist.\")\n\n        if self._enabled:\n            self._remove_adapted_attentions(self._active_adapter)\n            self._set_adapted_attentions(adapter_name)\n\n        self._active_adapter = adapter_name\n\n    def enable_adapter_layers(self):\n        \"\"\"Enable adapter layers by swapping in cached AdaptedAttention modules.\"\"\"\n        self._enabled = True\n        self._set_adapted_attentions(self._active_adapter)\n\n    def disable_adapter_layers(self):\n        \"\"\"Disable adapter layers by swapping out AdaptedAttention modules.\"\"\"\n        self._enabled = False\n        self._remove_adapted_attentions(self._active_adapter)\n\n    def _create_adapted_attentions(self, config: AdaptionPromptConfig, parents: List[nn.Module]) -> None:\n        \"\"\"Wrap LlamaAttention modules with newly created AdaptedAttention modules.\"\"\"\n        for par in parents:\n            attn = AdaptedAttention(\n                model_type=self.model.config.model_type,\n                adapter_len=config.adapter_len,\n                model=getattr(par, config.target_modules),\n            )\n            setattr(par, config.target_modules, attn)\n\n    def _set_adapted_attentions(self, adapter_name: str) -> None:\n        \"\"\"Replace LlamaAttention modules with cached AdaptedAttention modules.\"\"\"\n        cached = self._cached_adapters[adapter_name]\n        del self._cached_adapters[adapter_name]\n        config = self._configs[adapter_name]\n        for i, par in enumerate(self._parents[adapter_name]):\n            setattr(par, config.target_modules, cached[i])\n\n    def _remove_adapted_attentions(self, adapter_name: str) -> None:\n        \"\"\"Remove AdaptedAttention modules from the model and store them in the cache.\"\"\"\n        config = self._configs[adapter_name]\n        adapted_attentions = []\n        for par in self._parents[adapter_name]:\n            attn = getattr(par, config.target_modules)\n            adapted_attentions.append(attn)\n            setattr(par, config.target_modules, attn.model)\n        self._cached_adapters[adapter_name] = adapted_attentions\n\n    def _mark_only_adaption_prompts_as_trainable(self) -> None:\n        \"\"\"Freeze all parameters of the model except the adaption prompts.\"\"\"\n        for n, p in self.model.named_parameters():\n            if not is_adaption_prompt_trainable(n):\n                p.requires_grad = False\n\n    def __getattr__(self, name: str):\n        \"\"\"Forward missing attributes to the wrapped module.\"\"\"\n        try:\n            return super().__getattr__(name)  # defer to nn.Module's logic\n        except AttributeError:\n            # This is necessary as e.g. causal models have various methods that we\n            # don't want to re-implement here.\n            return getattr(self.model, name)", "\n\nclass AdaptedAttention(nn.Module):\n    \"\"\"This module wraps a LLamaAttention module and injects adaption prompts.\"\"\"\n\n    def __init__(self, model_type: str, adapter_len: int, model):\n        \"\"\"\n        Initialize object.\n\n        Args:\n            model_type: The transformer model type. This is used to retrieve the right method to\n                compute query states.\n            adapter_len: The length of the adaption prompt to insert.\n            model: The original transformer attention module that is being wrapped.\n        \"\"\"\n        assert not isinstance(model, AdaptedAttention)\n        super().__init__()\n        self.model_type = model_type\n        self.model = model\n        self.adapter_len = adapter_len\n        # Assume all parameters of the attention model we are wrapping are on the same device.\n        device = next(model.parameters()).device\n        # Don't think this was specified in the paper, but we follow the official repo which used an Embedding\n        # which initializes the tokens with standard normal values.\n        # https://github.com/ZrrSkywalker/LLaMA-Adapter/blob/41c3546fe1997ab8a65809dc8d8f9252b19d9faf/llama/model.py#L234\n        # (bsz, adapter_len, hidden_size)\n        self.adaption_prompt = nn.Parameter(\n            torch.empty(1, adapter_len, self.model.hidden_size, device=device).normal_()\n        )\n        # Initialize the gate to 0 as this is \"zero-init\".\n        self.adaption_gate = nn.Parameter(torch.zeros(1, device=device))\n\n    def forward(self, **kwargs):\n        \"\"\"\n        Forward pass for the adapter which wraps the original LlamaAttention module.\n\n        \"Official\" paper implementation:\n        https://github.com/ZrrSkywalker/LLaMA-Adapter/blob/41c3546fe1997ab8a65809dc8d8f9252b19d9faf/llama/model.py#L141\n\n        Args:\n            kwargs: See the original LlamaAttention module.\n        \"\"\"\n        if kwargs.get(\"output_attention\", False):\n            raise NotImplementedError(\"output_attention is not currently supported.\")\n\n        output, _, past_key_value = self.model(**kwargs)\n        bsz = output.shape[0]\n        q_len = output.shape[1]\n        embed_dim = output.shape[2]\n        k_proj_layer = TRANSFORMERS_MODEL_CONFIG[self.model_type].k_proj_layer\n        v_proj_layer = TRANSFORMERS_MODEL_CONFIG[self.model_type].v_proj_layer\n        o_proj_layer = TRANSFORMERS_MODEL_CONFIG[self.model_type].o_proj_layer\n\n        if k_proj_layer == v_proj_layer:\n            _, key, value = getattr(self.model, k_proj_layer)(self.adaption_prompt).split(embed_dim, dim=2)\n        else:\n            key = getattr(self.model, k_proj_layer)(self.adaption_prompt)\n            value = getattr(self.model, v_proj_layer)(self.adaption_prompt)\n        # (bsz, num_heads, adapter_len, head_dim)\n        adapter_k = (\n            key.view(1, self.adapter_len, self.model.num_heads, self.model.head_dim)\n            .repeat(bsz, 1, 1, 1)\n            .transpose(1, 2)\n        )\n        # (bsz, num_heads, adapter_len, head_dim)\n        adapter_v = (\n            value.view(1, self.adapter_len, self.model.num_heads, self.model.head_dim)\n            .repeat(bsz, 1, 1, 1)\n            .transpose(1, 2)\n        )\n\n        # Recompute query states.\n        compute_query_states = TRANSFORMERS_MODEL_CONFIG[self.model_type].compute_query_states\n        # (bsz, num_heads, q_len, head_dim)\n        query_states = compute_query_states(model=self.model, **kwargs)\n\n        # (bsz, num_heads, q_len, adapter_len)\n        scores = torch.matmul(query_states, adapter_k.transpose(2, 3)) / math.sqrt(self.model.head_dim)\n        # Upcast attention to fp32\n        # (bsz, num_heads, q_len, adapter_len)\n        scores = self.adaption_gate * F.softmax(scores, dim=-1, dtype=torch.float32).to(query_states.dtype)\n        # (bsz, q_len, num_heads * head_dim)\n        adapter_output = torch.matmul(scores, adapter_v).transpose(1, 2).reshape(bsz, q_len, -1)\n        # (bsz, q_len, hidden_size)\n        if o_proj_layer is not None:\n            adapter_output = getattr(self.model, o_proj_layer)(adapter_output)\n\n        # Add adaption prompt output to original output.\n        output = output + adapter_output\n        return output, None, past_key_value", ""]}
{"filename": "ft_chatglm_lora/text2dt_eval/parser.py", "chunked_list": ["import re\nfrom collections import Counter\n\nrel_name_2_label = {\n    \"\u4e34\u5e8a\u8868\u73b0\": \"\u4e34\u5e8a\u8868\u73b0\",\n    \"\u7528\u836f\": \"\u6cbb\u7597\u836f\u7269\",\n    \"\u6cbb\u7597\u65b9\u6848\": \"\u6cbb\u7597\u65b9\u6848\",\n    \"\u7528\u6cd5\": \"\u7528\u6cd5\u7528\u91cf\",\n    \"\u57fa\u672c\u60c5\u51b5\": \"\u57fa\u672c\u60c5\u51b5\",\n    \"\u614e\u7528\": \"\u7981\u7528\u836f\u7269\",", "    \"\u57fa\u672c\u60c5\u51b5\": \"\u57fa\u672c\u60c5\u51b5\",\n    \"\u614e\u7528\": \"\u7981\u7528\u836f\u7269\",\n}\n\ndef parsing(seq):\n    # print('seq', seq)\n    res, _, _ = scan_seq([], seq, 0)\n    # print('res', res)\n    return res\n\ndef scan_seq(tgt, seq, start, num_leaf=0, num_inner=0):\n\n    flag, _ = is_completed(tgt, 0)\n    if start >= len(seq) or flag:\n        return tgt, num_leaf, num_inner\n\n    if seq[start: start+4] == '\u5426\u5219,\u82e5':\n        role = 'C'\n        node_triples, logical_rel, end = get_node(seq, start+4, role)\n        tgt.append({'role': role, 'triples': node_triples, 'logical_rel': logical_rel})\n\n        tgt, num_leaf_, num_inner_ = scan_seq(tgt, seq, end+1, 0, 1)\n\n        if num_leaf_ < num_inner_ + 1:\n            tgt += [{'role': 'D', 'triples': [], 'logical_rel': 'null'}] * (num_inner_ + 1 - num_leaf_)\n            num_leaf_ = num_inner_ + 1\n\n        return tgt, num_leaf+num_leaf_, num_inner+num_inner_\n\n    elif seq[start: start+2] == '\u5426\u5219':\n        role = 'D'\n        node_triples, logical_rel, end = get_node(seq, start+2, role)\n\n        if len(node_triples) > 0:\n            tgt.append({'role': role, 'triples': node_triples, 'logical_rel': logical_rel})\n            num_leaf += 1\n        tgt, num_leaf, num_inner = scan_seq(tgt, seq, end+1, num_leaf, num_inner)\n\n        return tgt, num_leaf, num_inner\n\n    elif seq[start: start+1] == '\u5219':\n        role = 'D'\n        node_triples, logical_rel, end = get_node(seq, start+1, role)\n\n        if len(node_triples) > 0:\n            tgt.append({'role': role, 'triples': node_triples, 'logical_rel': logical_rel})\n            num_leaf += 1\n        tgt, num_leaf, num_inner = scan_seq(tgt, seq, end+1, num_leaf, num_inner)\n\n        return tgt, num_leaf, num_inner\n\n    elif seq[start: start+1] == '\u82e5':\n        role = 'C'\n        node_triples, logical_rel, end = get_node(seq, start+1, role)\n        tgt.append({'role': role, 'triples': node_triples, 'logical_rel': logical_rel})\n\n        tgt, num_leaf_, num_inner_ = scan_seq(tgt, seq, end+1, 0, 1)\n\n        if num_leaf_ < num_inner_ + 1:\n            tgt += [{'role': 'D', 'triples': [], 'logical_rel': 'null'}] * (num_inner_ + 1 - num_leaf_)\n            num_leaf_ = num_inner_ + 1\n\n        return tgt, num_leaf+num_leaf_, num_inner+num_inner_\n\n    else:\n        return tgt, num_leaf, num_inner", "\ndef scan_seq(tgt, seq, start, num_leaf=0, num_inner=0):\n\n    flag, _ = is_completed(tgt, 0)\n    if start >= len(seq) or flag:\n        return tgt, num_leaf, num_inner\n\n    if seq[start: start+4] == '\u5426\u5219,\u82e5':\n        role = 'C'\n        node_triples, logical_rel, end = get_node(seq, start+4, role)\n        tgt.append({'role': role, 'triples': node_triples, 'logical_rel': logical_rel})\n\n        tgt, num_leaf_, num_inner_ = scan_seq(tgt, seq, end+1, 0, 1)\n\n        if num_leaf_ < num_inner_ + 1:\n            tgt += [{'role': 'D', 'triples': [], 'logical_rel': 'null'}] * (num_inner_ + 1 - num_leaf_)\n            num_leaf_ = num_inner_ + 1\n\n        return tgt, num_leaf+num_leaf_, num_inner+num_inner_\n\n    elif seq[start: start+2] == '\u5426\u5219':\n        role = 'D'\n        node_triples, logical_rel, end = get_node(seq, start+2, role)\n\n        if len(node_triples) > 0:\n            tgt.append({'role': role, 'triples': node_triples, 'logical_rel': logical_rel})\n            num_leaf += 1\n        tgt, num_leaf, num_inner = scan_seq(tgt, seq, end+1, num_leaf, num_inner)\n\n        return tgt, num_leaf, num_inner\n\n    elif seq[start: start+1] == '\u5219':\n        role = 'D'\n        node_triples, logical_rel, end = get_node(seq, start+1, role)\n\n        if len(node_triples) > 0:\n            tgt.append({'role': role, 'triples': node_triples, 'logical_rel': logical_rel})\n            num_leaf += 1\n        tgt, num_leaf, num_inner = scan_seq(tgt, seq, end+1, num_leaf, num_inner)\n\n        return tgt, num_leaf, num_inner\n\n    elif seq[start: start+1] == '\u82e5':\n        role = 'C'\n        node_triples, logical_rel, end = get_node(seq, start+1, role)\n        tgt.append({'role': role, 'triples': node_triples, 'logical_rel': logical_rel})\n\n        tgt, num_leaf_, num_inner_ = scan_seq(tgt, seq, end+1, 0, 1)\n\n        if num_leaf_ < num_inner_ + 1:\n            tgt += [{'role': 'D', 'triples': [], 'logical_rel': 'null'}] * (num_inner_ + 1 - num_leaf_)\n            num_leaf_ = num_inner_ + 1\n\n        return tgt, num_leaf+num_leaf_, num_inner+num_inner_\n\n    else:\n        return tgt, num_leaf, num_inner", "\ndef get_node(seq, start, role):\n    cursor = start\n    node_triples = []\n    logical_rels = []\n    num_or = 0\n    num_and = 0\n\n    while cursor < len(seq):\n        if seq[cursor] == \"(\":\n            # matching for (xxx, xxx, xxx)\n            triple_span = re.match(r'\\(.*?,.*?,[^\\n\\r\\(]*?(\\(.*?\\))*?[^\\n\\r\\(]*?\\)', seq[cursor:])\n            if triple_span is None:\n                # print(seq[cursor:])\n                cursor += 1\n                continue\n\n            triple_span = triple_span.span()\n            triple_str = seq[cursor+triple_span[0]: cursor+triple_span[1]]\n            len_span = len(triple_str)\n            cursor += len_span\n            \n            triple_split = triple_str[1:-1].split(',')\n            triple = [x.strip() for x in triple_split]\n\n            if len(triple_split) == 3 and triple[1] in rel_name_2_label:\n                rel_label = rel_name_2_label[triple[1]]\n            else:\n                # print(triple_split)\n                continue\n\n            triple = (triple[0], rel_label, triple[2])\n            if triple not in node_triples:\n                node_triples.append(triple)\n\n        elif seq[cursor] in ['\u6216']:\n            logical_rels.append('or')\n            num_or += 1\n            cursor += 1\n\n        elif seq[cursor] in ['\u4e14']:\n            logical_rels.append('and')\n            num_and += 1\n            cursor += 1\n        \n        elif seq[cursor] in ['\u548c']:\n            logical_rels.append('and')\n            num_and += 1\n            cursor += 1\n\n        elif seq[cursor] in [',', '\u3002']:\n            break\n\n        else:\n            cursor += 1\n\n    logical_rel = 'null'\n    if len(node_triples) > 1:\n        if num_or > num_and:\n            logical_rel = 'or'\n        else:\n            logical_rel = 'and'\n\n    return node_triples, logical_rel, cursor", "\ndef is_completed(tree, start):\n    if start >= len(tree):\n        return False, start\n\n    if tree[start]['role'] == 'D':\n        return True, start\n\n    elif tree[start]['role'] == 'C':\n        left_flag, left_end = is_completed(tree, start+1)\n        right_flag, right_end = is_completed(tree, left_end+1)\n\n        flag = left_flag and right_flag\n        return flag, right_end", ""]}
{"filename": "ft_chatglm_lora/text2dt_eval/metric.py", "chunked_list": ["\nfrom text2dt_eval.eval_func import eval\n\ndef text2dt_metric(gold_data, predict_data):\n    gold_tree_num, correct_tree_num = 0.000001, 0.000001\n    gold_triplet_num, predict_triplet_num, correct_triplet_num = 0.000001, 0.000001, 0.000001\n    gold_path_num, predict_path_num, correct_path_num= 0.000001, 0.000001, 0.000001\n    gold_node_num, predict_node_num, correct_node_num = 0.000001, 0.000001, 0.000001\n\n    edit_dis = 0\n\n    for i in range(len(predict_data)):\n        # print(i)\n        tmp= eval(predict_data[i], gold_data[i])\n        gold_tree_num += tmp[0]\n        correct_tree_num += tmp[1]\n        correct_triplet_num += tmp[2]\n        predict_triplet_num += tmp[3]\n        gold_triplet_num += tmp[4]\n        correct_path_num += tmp[5]\n        predict_path_num += tmp[6]\n        gold_path_num += tmp[7]\n        edit_dis += tmp[8]\n        correct_node_num += tmp[9]\n        predict_node_num += tmp[10]\n        gold_node_num += tmp[11]\n\n    tree_acc= correct_tree_num/gold_tree_num\n    triple_p = correct_triplet_num/predict_triplet_num\n    triple_r = correct_triplet_num/gold_triplet_num\n    triple_f1 = 2 * triple_p * triple_r / (triple_p + triple_r)\n    path_f1 =2* (correct_path_num/predict_path_num) *(correct_path_num/gold_path_num)/(correct_path_num/predict_path_num + correct_path_num/gold_path_num)\n    tree_edit_distance=edit_dis/gold_tree_num\n    node_f1 =2* (correct_node_num/predict_node_num) *(correct_node_num/gold_node_num)/(correct_node_num/predict_node_num + correct_node_num/gold_node_num)\n\n    print('[Triple_P]: %.6f;\\t [Triple_R]: %.6f\\t [Triple_F1]: %.6f' % (triple_p, triple_r, triple_f1), flush=True)\n    print(\"[Node_F1] : %.6f;\\t [Path_F1] : %.6f\\t [Edit_Dist]: %.6f\" % (node_f1, path_f1, tree_edit_distance), flush=True)\n    print('[Tree_ACC]: %.6f' % tree_acc, flush=True)\n\n    return {'triple_f1': triple_f1, 'node_f1': node_f1, 'path_f1': path_f1, 'tree_acc': tree_acc, 'path_tree_avg': (path_f1+tree_acc)/2}", ""]}
{"filename": "ft_chatglm_lora/text2dt_eval/eval_func.py", "chunked_list": ["\n# \u5c06\u7b26\u5408\u8bca\u7597\u51b3\u7b56\u6811\u7ea6\u675f\u7684\u8282\u70b9\u524d\u5e8f\u5e8f\u5217\u8f6c\u5316\u4e3a\u4ee3\u8868\u8bca\u7597\u51b3\u7b56\u6811\u7ed3\u6784\u7684\u8282\u70b9\u77e9\u9635\uff0cmatrix[i][j]='F'/'L'/'R'\u8868\u793a\u7b2cj\u4e2a\u8282\u70b9\u662f\u7b2ci\u4e2a\u8282\u70b9\u7684\u7236/\u5de6\u5b50/\u53f3\u5b50\u8282\u70b9\n\ndef nodematrix(tree):\n    nodelist=[]\n    for i in range(len(tree)):\n        nodelist.append(tree[i][\"role\"])\n\n    # print('*'*10)\n    # print(tree)\n    # print(nodelist)\n    # print('*'*10)\n    node_matrix = [[0 for i in range(len(nodelist))] for j in range(len(nodelist))]\n    if len(nodelist) == 0:\n        return node_matrix\n    while (nodelist[0] != 'D'):\n        for i in range(len(nodelist)):\n            if nodelist[i] == 'C':\n                flag, leaf1, leaf2 = 0, 0, 0\n                for j in range(i+1,len(nodelist)):\n                    if nodelist[j]=='D' and flag==0:\n                        flag = 1\n                        leaf1 = j\n                    elif nodelist[j]=='X' :\n                        continue\n                    elif nodelist[j]=='D' and flag==1:\n                        #print(i)\n                        leaf2 = j\n                        nodelist[i]='D'\n                        node_matrix[leaf1][i]= 'F'\n                        node_matrix[leaf2][i] = 'F'\n                        node_matrix[i][leaf1] = 'L'\n                        node_matrix[i][leaf2] = 'R'\n                        for k in range(i+1,leaf2+1):\n                            nodelist[k]='X'\n                        flag = 2\n                        break\n                    elif nodelist[j]=='C':\n                        break\n                if flag == 2:\n                    break\n    return(node_matrix)", "\n# \u8ba1\u7b97\u4e24\u4e2a\u8282\u70b9\u7684\u8ddd\u79bb\ndef node_dis(node1,node2):\n    if node2 is None :\n        node2 = {\"role\":\"\",\"triples\": [],\"logical_rel\": \"\"}\n    dis=0\n    if node1[\"role\"] != node2[\"role\"]:\n        dis += 1\n    #print(dis)\n    if node1[\"logical_rel\"] != node2[\"logical_rel\"]:\n        dis += 1\n    dis += len(list((set(node1[\"triples\"])|set(node2[\"triples\"]))-(set(node1[\"triples\"])&set(node2[\"triples\"]))))\n    return(dis)", "\ndef is_path_equal(path1,path2):\n    if (len(path1)!=len(path2)):\n        return False\n    for i in range(len(path1)):\n        if isinstance(path1[i],dict) and isinstance(path2[i],dict):\n            if path1[i]['role'] == path2[i]['role'] and path1[i]['logical_rel'] == path2[i]['logical_rel'] and set(path1[i]['triples']) == set(path2[i]['triples']):\n                continue\n            else:\n                return False\n        elif path1[i] != path2[i]:\n            return False\n    return True", "\ndef is_tree_equal(predict_tree,gold_tree):\n    if len(predict_tree) != len(gold_tree):\n        return 0\n    else:\n        for i in range(len(predict_tree)):\n            if predict_tree[i]['role'] == gold_tree[i]['role'] and predict_tree[i]['logical_rel'] == gold_tree[i]['logical_rel'] and set(\n                predict_tree[i]['triples']) == set(gold_tree[i]['triples']):\n                continue\n            else:\n                return 0\n    return 1", "\n# \u8ba1\u7b97\u6a21\u578b\u9884\u6d4b\u7684\u8bca\u7597\u51b3\u7b56\u6811\u548cground turth\u7684\u8ddd\u79bb\uff0c\u8ddd\u79bb\u8d8a\u5c0f\u8868\u793a\u4e24\u6811\u8d8a\u76f8\u4f3c\ndef edit_distance(predict_tree, gold_tree, predict_matrix, gold_matrix):\n    dis = 0\n    if len(predict_matrix) == 0:\n        for node in gold_tree:\n            dis += node_dis(node, None)\n        return dis\n        \n    stack1 = [0]\n    stack2 = [0]\n    while stack1:\n        s1=stack1.pop()\n        s2=stack2.pop()\n        if ('L' not in predict_matrix[s1] and 'R' not in predict_matrix[s1]) and ('L' in gold_matrix[s2] or 'R' in gold_matrix[s2]):\n            dis += node_dis(predict_tree[s1], gold_tree[s2])\n            stack_tmp=[]\n            stack_tmp.append(gold_matrix[s2].index('R'))\n            stack_tmp.append(gold_matrix[s2].index('L'))\n            while stack_tmp:\n                s_tmp=stack_tmp.pop()\n                dis += node_dis(gold_tree[s_tmp],None)\n                if ('L' in gold_matrix[s_tmp] and 'R' in gold_matrix[s_tmp]):\n                    stack_tmp.append(gold_matrix[s_tmp].index('R'))\n                    stack_tmp.append(gold_matrix[s_tmp].index('L'))\n        elif  ('L' in predict_matrix[s1] and 'R' in predict_matrix[s1]) and ('L' not in gold_matrix[s2] or 'R' not in gold_matrix[s2]):\n            dis += node_dis(predict_tree[s1], gold_tree[s2])\n            stack_tmp=[]\n            stack_tmp.append(predict_matrix[s1].index('R'))\n            stack_tmp.append(predict_matrix[s1].index('L'))\n            while stack_tmp:\n                s_tmp=stack_tmp.pop()\n                dis += node_dis(predict_tree[s_tmp], None)\n                if ('L' in predict_matrix[s_tmp] and 'R' in predict_matrix[s_tmp]):\n                    stack_tmp.append(predict_matrix[s_tmp].index('R'))\n                    stack_tmp.append(predict_matrix[s_tmp].index('L'))\n        elif ('L' not in predict_matrix[s1] and 'R' not in predict_matrix[s1]) and ('L' not in gold_matrix[s2] and 'R' not in gold_matrix[s2]):\n            dis += node_dis(predict_tree[s1], gold_tree[s2])\n        else:\n            stack1.append(predict_matrix[s1].index('R'))\n            stack1.append(predict_matrix[s1].index('L'))\n            stack2.append(gold_matrix[s2].index('R'))\n            stack2.append(gold_matrix[s2].index('L'))\n            dis += node_dis(predict_tree[s1], gold_tree[s2])\n    return dis", "\n# \u8ba1\u7b97\u51b3\u7b56\u8def\u5f84\u62bd\u53d6\u7684TP,TP+FP,TP+FN\ndef decision_path(predict_tree, gold_tree, predict_matrix, gold_matrix):\n    leaf1, leaf2, paths1, paths2 = [], [], [], []\n    for i in range(len(predict_matrix)):\n        if ('L' not in predict_matrix[i] and 'R' not in predict_matrix[i]):\n            leaf1.append(i)\n    for node in leaf1:\n        path=[predict_tree[node]]\n        while node !=0:\n            # print(predict_matrix)\n            # print(node)\n            # print(predict_matrix[node])\n            # print()\n            path.append(predict_matrix[predict_matrix[node].index('F')][node])\n            path.append(predict_tree[predict_matrix[node].index('F')])\n            node =predict_matrix[node].index('F')\n        paths1.append(path)\n    for i in range(len(gold_matrix)):\n        if ('L' not in gold_matrix[i] and 'R' not in gold_matrix[i]):\n            leaf2.append(i)\n    for node in leaf2:\n        path=[gold_tree[node]]\n        while node !=0:\n            path.append(gold_matrix[gold_matrix[node].index('F')][node])\n            path.append(gold_tree[gold_matrix[node].index('F')])\n            node =gold_matrix[node].index('F')\n        paths2.append(path)\n    res = 0\n    for path1 in paths1:\n        for path2 in paths2:\n            if is_path_equal(path1, path2):\n                res += 1\n                break\n\n    return res,len(paths1),len(paths2)", "\n# \u8ba1\u7b97\u4e09\u5143\u7ec4\u62bd\u53d6\u7684TP,TP+FP,TP+FN\ndef triplet_extraction(predict_tree, gold_tree):\n    predict_triplet, gold_triplet = [], []\n    for i in range(len(predict_tree)):\n        for triplet in predict_tree[i][\"triples\"]:\n            predict_triplet.append(triplet)\n    for i in range(len(gold_tree)):\n        for triplet in gold_tree[i][\"triples\"]:\n            gold_triplet.append(triplet)\n    predict_triplet_num = len(list(set(predict_triplet)))\n    gold_triplet_num = len(list(set(gold_triplet)))\n    correct_triplet_num =len(list(set(gold_triplet)&set(predict_triplet)))\n    return [correct_triplet_num, predict_triplet_num, gold_triplet_num]", "\ndef node_extraction(predict_tree, gold_tree):\n    predict_node, gold_node = [], []\n    for i in range(len(predict_tree)):\n        if len(predict_tree[i]['triples'])>0:\n            predict_node.append(predict_tree[i])\n    for i in range(len(gold_tree)):\n        if len(gold_tree[i]['triples']) > 0:\n            gold_node.append(gold_tree[i])\n\n    predict_triplet_num = len(predict_node)\n    gold_triplet_num = len(gold_node)\n    correct_triplet_num = 0\n    for node1 in predict_node:\n        for node2 in gold_node:\n            if len(node1['triples'])>0 and node1['role'] == node2['role'] and node1['logical_rel'] == node2['logical_rel'] and set(node1['triples']) == set(node2['triples']):\n                correct_triplet_num +=1\n    return [correct_triplet_num, predict_triplet_num, gold_triplet_num]", "#\u8bc4\u6d4b\u51fd\u6570\uff0c\u5171\u8ba1\u7b97\u56db\u4e2a\u6307\u6807: \u51b3\u7b56\u6811\u7684Acc\uff1b\u4e09\u5143\u7ec4\u62bd\u53d6\u7684F1\uff1b\u51b3\u7b56\u8def\u5f84\u7684F1; \u6811\u7684\u7f16\u8f91\u8ddd\u79bb\n\ndef eval(predict_tree, gold_tree):\n    # \u5c06\u7b26\u5408\u8bca\u7597\u51b3\u7b56\u6811\u7684\u8282\u70b9\u524d\u5e8f\u5e8f\u5217\u8f6c\u5316\u4e3a\u4ee3\u8868\u8bca\u7597\u51b3\u7b56\u6811\u7ed3\u6784\u7684\u8282\u70b9\u77e9\u9635\uff0cmatrix[i][j]='F'/'L'/'R'\u8868\u793a\u7b2cj\u4e2a\u8282\u70b9\u662f\u7b2ci\u4e2a\u8282\u70b9\u7684\u7236/\u5de6\u5b50/\u53f3\u5b50\u8282\u70b9\n    for node in predict_tree:\n        for i in range(len(node['triples'])):\n            node['triples'][i]=(node['triples'][i][0].lower(), node['triples'][i][1].lower(), node['triples'][i][2].lower())\n    for node in gold_tree:\n        for i in range(len(node['triples'])):\n            node['triples'][i]=(node['triples'][i][0].lower(), node['triples'][i][1].lower(), node['triples'][i][2].lower())\n\n\n    predict_matrix = nodematrix(predict_tree)\n    gold_matrix = nodematrix(gold_tree)\n\n\n\n    # \u7528\u4e8e\u8ba1\u7b97\u751f\u6210\u6811\u7684Acc\n    tree_num = (0 if predict_tree == [] else 1)\n    correct_tree_num = is_tree_equal(predict_tree,gold_tree)\n\n    # \u7528\u4e8e\u8ba1\u7b97triplet\u62bd\u53d6\u7684F1\n    correct_triplet_num, predict_triplet_num, gold_triplet_num = triplet_extraction(predict_tree, gold_tree)\n\n    # \u7528\u4e8e\u8ba1\u7b97\u51b3\u7b56\u8def\u5f84\u7684F1\n    correct_path_num, predict_path_num, gold_path_num = decision_path(predict_tree, gold_tree, predict_matrix, gold_matrix)\n\n    # \u7528\u4e8e\u8ba1\u7b97\u6811\u7684\u7f16\u8f91\u8ddd\u79bb\n    edit_dis = edit_distance(predict_tree, gold_tree, predict_matrix, gold_matrix)\n\n    correct_node_num, predict_node_num, gold_node_num = node_extraction(predict_tree, gold_tree)\n\n    return tree_num,correct_tree_num, correct_triplet_num, predict_triplet_num, gold_triplet_num, correct_path_num, predict_path_num, gold_path_num, edit_dis,correct_node_num, predict_node_num, gold_node_num", "\n\n\n\n\n"]}
{"filename": "datasets/Text2DT/convert.py", "chunked_list": ["import os, json\n\nrel_label_mapping = {\n    \"\u4e34\u5e8a\u8868\u73b0\": \"\u4e34\u5e8a\u8868\u73b0\",\n    \"\u6cbb\u7597\u836f\u7269\": \"\u7528\u836f\",\n    \"\u6cbb\u7597\u65b9\u6848\": \"\u6cbb\u7597\u65b9\u6848\",\n    \"\u7528\u6cd5\u7528\u91cf\": \"\u7528\u6cd5\",\n    \"\u57fa\u672c\u60c5\u51b5\": \"\u57fa\u672c\u60c5\u51b5\",\n    \"\u7981\u7528\u836f\u7269\": \"\u614e\u7528\",\n}", "    \"\u7981\u7528\u836f\u7269\": \"\u614e\u7528\",\n}\n\ndef preorder_traverse(tree, start, list_triple2relID, relations, side='left', TreeS=False):\n    if start >= len(tree):\n        return None, ''\n\n    root = tree[start]\n    triple2relID = list_triple2relID[start]\n    role = root['role']\n    tgt_seq = ''\n\n    if role == 'C':\n        if side == 'left':\n            tgt_seq += '\u82e5'\n        else:\n            tgt_seq += '\u5426\u5219\uff0c\u82e5'\n\n        tgt_seq += read_node(root, triple2relID, relations, TreeS)\n        tgt_seq += '\uff0c'\n\n        left_end, left_tgt_seq = preorder_traverse(tree, start+1, list_triple2relID, relations, TreeS=TreeS)\n        tgt_seq += left_tgt_seq\n\n        right_end, right_tgt_seq = preorder_traverse(tree, left_end+1, list_triple2relID, relations, side='right', TreeS=TreeS)\n        tgt_seq += right_tgt_seq\n\n        end = right_end\n\n    elif role == 'D':\n        if len(root['triples']) > 0:\n            if side == 'left':\n                tgt_seq += '\u5219'\n            else:\n                tgt_seq += '\u5426\u5219'\n\n            tgt_seq += read_node(root, triple2relID, relations, TreeS)\n            tgt_seq += '\uff0c' if any([len(x['triples']) > 0 for x in tree[start+1:]]) else '\u3002'\n        \n        end = start\n\n    return end, tgt_seq", "\n\ndef read_node(node, triple2relID, relations, TreeS=False):\n    role = node['role']\n    triples = [tuple(t) for t in node['triples']]\n    logical_rel = node['logical_rel']\n\n    if logical_rel == 'or':\n        conjunction = '\u6216'\n    elif role == 'C':\n        conjunction = '\u4e14'\n    else:\n        conjunction = '\u548c'\n\n    clauses = []\n    visited = set()\n    for i, t1 in enumerate(triples):\n        if t1 in visited:\n            continue\n        id1 = triple2relID[t1]\n\n        clause = [id1]\n        visited.add(t1)\n\n        for t2 in triples[i+1:]:\n            if t2 in visited:\n                continue\n\n            if t1[-1] == t2[0] or t1[0] == t2[-1]:\n                id2 = triple2relID[t2]\n                clause.append(id2)\n                visited.add(t2)\n\n        # if len(clause) > 2:\n        #     print([relations[id] for id in clause])\n\n        try:\n            clause = sorted(clause, key=lambda x: location(x, relations))\n        except:\n            pass\n\n        clauses.append(clause)\n\n    try:\n        clauses = sorted(clauses, key=lambda x: clause_location(x, relations))\n    except:\n        pass\n\n    if TreeS:\n        clauses = conjunction.join(['...' for clause in clauses])\n    else:\n        clauses = conjunction.join([''.join([linearize_triple(relations[x]) for x in clause]) for clause in clauses])\n\n    return clauses", "\ndef location(relID, relations):\n    rel = relations[relID]\n    return sum(rel[0][:2] + rel[2][:2])\n    # return (sum(rel[2][:2]), sum(rel[0][:2]))\n\ndef clause_location(clause, relations):\n    return min([location(relID, relations) for relID in clause])\n\n# def linearize_clause(clause, relations):", "\n# def linearize_clause(clause, relations):\n#     for tripleID in clause:\n#         triple = relations[tripleID]\n#     return\n\ndef linearize_triple(triple):\n    return '('+ triple[0][-1] + ', ' + rel_label_mapping[triple[1]] + ', ' + triple[2][-1] + ')'\n\n\ndef convert_sample(input_doc, RE=False, TreeS=False):\n    samples = []\n\n    with open(input_doc) as f:\n        lines = f.readlines()\n        lines = [eval(ele) for ele in lines]\n    for idx, line in enumerate(lines):\n        # print(line)\n        text = line[\"text\"]\n        tree = line[\"tree\"]\n        triples = line[\"relations\"]\n        \n        list_triple2relID = []\n        visited = set()\n        for node in tree:\n            triple2relID = dict()\n            for triple in node['triples']:\n                triple = tuple(triple)\n                candidates = []\n                for relID, rel in enumerate(line[\"relations\"]):\n                    if (rel[0][-1], rel[1], rel[2][-1]) == triple:\n                        candidates.append(relID)\n                        if relID not in visited:\n                            triple2relID[triple] = relID\n                            visited.add(relID)\n                            break\n                if triple not in triple2relID:\n                    triple2relID[triple] = candidates[-1]\n\n            list_triple2relID.append(triple2relID)\n\n        _, tgt_seq = preorder_traverse(tree, 0, list_triple2relID, triples)\n\n        sample = {'input': text, 'target': tgt_seq, 'RE_target': '', 'TreeS_target': ''}\n        # print(text)\n        # print(tgt_seq)\n\n        if RE:\n            triples_seq = '[' + ', '.join([linearize_triple(x) for x in triples]) + ']'\n            sample['RE_target'] = triples_seq\n\n        if TreeS:\n            _, tgt_seq = preorder_traverse(tree, 0, list_triple2relID, triples, TreeS=True)\n            sample['TreeS_target'] = tgt_seq\n\n        samples.append(sample)\n\n    return samples", "\n\ndef convert_sample(input_doc, RE=False, TreeS=False):\n    samples = []\n\n    with open(input_doc) as f:\n        lines = f.readlines()\n        lines = [eval(ele) for ele in lines]\n    for idx, line in enumerate(lines):\n        # print(line)\n        text = line[\"text\"]\n        tree = line[\"tree\"]\n        triples = line[\"relations\"]\n        \n        list_triple2relID = []\n        visited = set()\n        for node in tree:\n            triple2relID = dict()\n            for triple in node['triples']:\n                triple = tuple(triple)\n                candidates = []\n                for relID, rel in enumerate(line[\"relations\"]):\n                    if (rel[0][-1], rel[1], rel[2][-1]) == triple:\n                        candidates.append(relID)\n                        if relID not in visited:\n                            triple2relID[triple] = relID\n                            visited.add(relID)\n                            break\n                if triple not in triple2relID:\n                    triple2relID[triple] = candidates[-1]\n\n            list_triple2relID.append(triple2relID)\n\n        _, tgt_seq = preorder_traverse(tree, 0, list_triple2relID, triples)\n\n        sample = {'input': text, 'target': tgt_seq, 'RE_target': '', 'TreeS_target': ''}\n        # print(text)\n        # print(tgt_seq)\n\n        if RE:\n            triples_seq = '[' + ', '.join([linearize_triple(x) for x in triples]) + ']'\n            sample['RE_target'] = triples_seq\n\n        if TreeS:\n            _, tgt_seq = preorder_traverse(tree, 0, list_triple2relID, triples, TreeS=True)\n            sample['TreeS_target'] = tgt_seq\n\n        samples.append(sample)\n\n    return samples", "\nif __name__ == '__main__':\n    in_dir = 'raw_data'\n    out_dir = './'\n\n    os.makedirs(out_dir, exist_ok=True)\n\n    for root, dirs, files in os.walk(in_dir):\n        for fn in files:\n            if fn[-4:] != '.txt':\n                continue\n\n            print(fn)\n            samples = convert_sample(os.path.join(in_dir, fn), RE=True, TreeS=True)\n            fname = fn.split('.')[0]\n\n            json_f = open(os.path.join(out_dir, fname + '.json'), 'w', encoding='utf-8')\n            for sample in samples:\n                json_line = json.dumps(sample, ensure_ascii=False)\n                print(json_line, file=json_f)", ""]}
{"filename": "datasets/Text2DT/raw_data/data_augment.py", "chunked_list": ["import random\nimport copy\n\ndef data_augmentation(ori_fn, tgt_fn, type_len_2_mentions=None, repeat=1):\n    random.seed(2021)\n\n    with open(ori_fn) as f:\n        lines = f.readlines()\n        lines = [eval(ele) for ele in lines]\n\n    if type_len_2_mentions is None:\n        type_len_2_mentions = dict()\n        for line in lines:\n            entities = line[\"entities\"]\n            for ent in entities:\n                mention = ent[2]\n                mention_len = len(mention)\n                etype = ent[-1]\n\n                if (etype, mention_len) not in type_len_2_mentions:\n                    type_len_2_mentions[(etype, mention_len)] = []\n                if mention not in type_len_2_mentions[(etype, mention_len)]:\n                    type_len_2_mentions[(etype, mention_len)].append(mention)\n\n    new_lines = []\n\n    for line in lines:\n        text = line[\"text\"]\n        relations = line[\"relations\"]\n        entities = line[\"entities\"]\n        tree = line[\"tree\"]\n\n        skip_mentions = set()\n        for i, e1 in enumerate(entities):\n            for j, e2 in enumerate(entities):\n                if e1 == e2:\n                    continue\n                mention1 = e1[2]\n                mention2 = e2[2]\n                max_len_LCS = LCS(mention1, mention2)\n                if overlap(e1, e2) or max_len_LCS > max(len(mention1), len(mention2))/2:\n                    skip_mentions.add(mention1)\n                    skip_mentions.add(mention2)\n\n        for _ in range(repeat):\n            type_len_2_mentions_ = copy.deepcopy(type_len_2_mentions)\n            text_ = text\n            entites_ = []\n            mention_2_substitute = dict()\n            for i, ent in enumerate(entities):\n                ent_start, ent_end, mention, etype = ent\n\n                if mention in mention_2_substitute:\n                    substitute = mention_2_substitute[mention]\n\n                else:\n                    candidates = type_len_2_mentions_[(etype, len(mention))]\n                    \n                    if len(candidates) == 1 or mention in skip_mentions:\n                        substitute = mention\n                    else:\n                        substitute = random.choice(candidates)\n\n                    mention_2_substitute[mention] = substitute\n                \n                text_ = text_[:ent_start] + substitute + text_[ent_end:]\n                entites_.append((ent_start, ent_end, substitute, etype))\n\n            relations_ = []\n            triple2substitute = dict()\n\n            for relation in relations:\n                head, rel_type, tail = relation\n                h_start, h_end, h_mention = head\n                t_start, t_end, t_mention = tail\n                triple = (h_mention, rel_type, t_mention)\n\n                if triple in triple2substitute:\n                    h_mention_ = triple2substitute[triple][0]\n                    t_mention_ = triple2substitute[triple][-1]\n\n                else:\n                    h_mention_ = mention_2_substitute[h_mention]\n                    t_mention_ = mention_2_substitute[t_mention]\n                    triple2substitute[triple] = (h_mention_, rel_type, t_mention_)\n\n                head_ = (h_start, h_end, h_mention_)\n                tail_ = (t_start, t_end, t_mention_)\n                relations_.append((head_, rel_type, tail_))\n\n            tree_ = []\n            for node in tree:\n                role = node['role']\n                triples = node['triples']\n                logical_rel = node['logical_rel']\n\n                triples_ = []\n                for triple in triples:\n                    triple_ = triple2substitute[tuple(triple)]\n                    triples_.append(triple_)\n                \n                tree_.append({'role': role, 'triples': triples_, 'logical_rel': logical_rel})\n\n            # print(text)\n            # print(text_)\n            # print()\n                \n            new_line = {'text': text_, 'relations': relations_, 'entities': entites_, 'tree': tree_}\n            new_lines.append(new_line)\n    \n    \n    out_f = open(tgt_fn, 'w')\n    for new_line in new_lines:\n        print(new_line, file=out_f)", "\ndef overlap(span1, span2):\n    return not (span1[1] <= span2[0] or span2[1] <= span1[0])\n\ndef LCS(text1: str, text2: str) -> int:\n    n = len(text1)\n    m = len(text2)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n    return dp[n][m]", "\nif __name__ == '__main__':\n    data_augmentation(\"train_dev_dt.txt\", \"aug_dt.txt\")\n    "]}
