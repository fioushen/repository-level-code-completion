{"filename": "frogmouth/__main__.py", "chunked_list": ["\"\"\"The package entry point into the application.\"\"\"\n\nfrom .app import run\n\nif __name__ == \"__main__\":\n    run()\n"]}
{"filename": "frogmouth/__init__.py", "chunked_list": ["\"\"\"A terminal-based Markdown document viewer, written in Textual.\"\"\"\n\n__author__ = \"Textualize, Inc\"\n__copyright__ = \"Copyright Textualize, Inc\"\n__credits__ = [\"Dave Pearson\"]\n__maintainer__ = \"Dave Pearson\"\n__email__ = \"dave@textualize.io\"\n__version__ = \"0.9.0\"\n__licence__ = \"MIT\"\n", "__licence__ = \"MIT\"\n"]}
{"filename": "frogmouth/widgets/viewer.py", "chunked_list": ["\"\"\"The markdown viewer itself.\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections import deque\nfrom pathlib import Path\nfrom typing import Callable\nfrom webbrowser import open as open_url\n\nfrom httpx import URL, AsyncClient, HTTPStatusError, RequestError", "\nfrom httpx import URL, AsyncClient, HTTPStatusError, RequestError\nfrom textual import work\nfrom textual.app import ComposeResult\nfrom textual.binding import Binding\nfrom textual.containers import VerticalScroll\nfrom textual.message import Message\nfrom textual.reactive import var\nfrom textual.widgets import Markdown\nfrom typing_extensions import Final", "from textual.widgets import Markdown\nfrom typing_extensions import Final\n\nfrom .. import __version__\nfrom ..dialogs import ErrorDialog\nfrom ..utility.advertising import APPLICATION_TITLE, USER_AGENT\n\nPLACEHOLDER = f\"\"\"\\\n# {APPLICATION_TITLE} {__version__}\n", "# {APPLICATION_TITLE} {__version__}\n\nWelcome to {APPLICATION_TITLE}!\n\"\"\"\n\n\nclass History:\n    \"\"\"Holds the browsing history for the viewer.\"\"\"\n\n    MAXIMUM_HISTORY_LENGTH: Final[int] = 256\n    \"\"\"The maximum number of items we'll keep in history.\"\"\"\n\n    def __init__(self, history: list[Path | URL] | None = None) -> None:\n        \"\"\"Initialise the history object.\"\"\"\n        self._history: deque[Path | URL] = deque(\n            history or [], maxlen=self.MAXIMUM_HISTORY_LENGTH\n        )\n        \"\"\"The list that holds the history of locations visited.\"\"\"\n        self._current: int = max(len(self._history) - 1, 0)\n        \"\"\"The current location.\"\"\"\n\n    @property\n    def location(self) -> Path | URL | None:\n        \"\"\"The current location in the history.\"\"\"\n        try:\n            return self._history[self._current]\n        except IndexError:\n            return None\n\n    @property\n    def current(self) -> int | None:\n        \"\"\"The current location in history, or None if there is no current location.\"\"\"\n        return None if self.location is None else self._current\n\n    @property\n    def locations(self) -> list[Path | URL]:\n        \"\"\"The locations in the history.\"\"\"\n        return list(self._history)\n\n    def remember(self, location: Path | URL) -> None:\n        \"\"\"Remember a new location in the history.\n\n        Args:\n            location: The location to remember.\n        \"\"\"\n        self._history.append(location)\n        self._current = len(self._history) - 1\n\n    def back(self) -> bool:\n        \"\"\"Go back in the history.\n\n        Returns:\n            `True` if the location changed, `False` if not.\n        \"\"\"\n        if self._current:\n            self._current -= 1\n            return True\n        return False\n\n    def forward(self) -> bool:\n        \"\"\"Go forward in the history.\n\n        Returns:\n            `True` if the location changed, `False` if not.\n        \"\"\"\n        if self._current < len(self._history) - 1:\n            self._current += 1\n            return True\n        return False\n\n    def __delitem__(self, index: int) -> None:\n        del self._history[index]\n        self._current = max(len(self._history) - 1, self._current)", "\n\nclass Viewer(VerticalScroll, can_focus=True, can_focus_children=True):\n    \"\"\"The markdown viewer class.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    Viewer {\n        width: 1fr;\n        scrollbar-gutter: stable;\n    }\n    \"\"\"\n\n    BINDINGS = [\n        Binding(\"w,k\", \"scroll_up\", \"\", show=False),\n        Binding(\"s,j\", \"scroll_down\", \"\", show=False),\n        Binding(\"space\", \"page_down\", \"\", show=False),\n        Binding(\"b\", \"page_up\", \"\", show=False),\n    ]\n    \"\"\"Bindings for the Markdown viewer widget.\"\"\"\n\n    history: var[History] = var(History)\n    \"\"\"The browsing history.\"\"\"\n\n    viewing_location: var[bool] = var(False)\n    \"\"\"Is an actual location being viewed?\"\"\"\n\n    class ViewerMessage(Message):\n        \"\"\"Base class for viewer messages.\"\"\"\n\n        def __init__(self, viewer: Viewer) -> None:\n            \"\"\"Initialise the message.\n\n            Args:\n                viewer: The viewer sending the message.\n            \"\"\"\n            super().__init__()\n            self.viewer: Viewer = viewer\n            \"\"\"The viewer that sent the message.\"\"\"\n\n    class LocationChanged(ViewerMessage):\n        \"\"\"Message sent when the viewer location changes.\"\"\"\n\n    class HistoryUpdated(ViewerMessage):\n        \"\"\"Message sent when the history is updated.\"\"\"\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the markdown viewer.\"\"\"\n        yield Markdown(PLACEHOLDER)\n\n    @property\n    def document(self) -> Markdown:\n        \"\"\"The markdown document.\"\"\"\n        return self.query_one(Markdown)\n\n    @property\n    def location(self) -> Path | URL | None:\n        \"\"\"The location that is currently being visited.\"\"\"\n        return self.history.location if self.viewing_location else None\n\n    def scroll_to_block(self, block_id: str) -> None:\n        \"\"\"Scroll the document to the given block ID.\n\n        Args:\n            block_id: The ID of the block to scroll to.\n        \"\"\"\n        self.scroll_to_widget(self.document.query_one(f\"#{block_id}\"), top=True)\n\n    def _post_load(self, location: Path | URL, remember: bool = True) -> None:\n        \"\"\"Perform some post-load tasks.\n\n        Args:\n            location: The location that has been loaded.\n            remember: Should we remember the location in the history?\n        \"\"\"\n        # We've loaded something fresh, ensure we're at the top.\n        self.scroll_home(animate=False)\n        # If we've made it in here we are viewing an actual location.\n        self.viewing_location = True\n        # Remember the location in the history if we're supposed to.\n        if remember:\n            self.history.remember(location)\n            self.post_message(self.HistoryUpdated(self))\n        # Let anyone else know we've changed location.\n        self.post_message(self.LocationChanged(self))\n\n    @work(exclusive=True)\n    async def _local_load(self, location: Path, remember: bool = True) -> None:\n        \"\"\"Load a Markdown document from a local file.\n\n        Args:\n            location: The location to load from.\n            remember: Should we remember the location in th ehistory?\n        \"\"\"\n        try:\n            await self.document.load(location)\n        except OSError as error:\n            self.app.push_screen(\n                ErrorDialog(\n                    \"Error loading local document\",\n                    f\"{location}\\n\\n{error}.\",\n                )\n            )\n        else:\n            self._post_load(location, remember)\n\n    @work(exclusive=True)\n    async def _remote_load(self, location: URL, remember: bool = True) -> None:\n        \"\"\"Load a Markdown document from a URL.\n\n        Args:\n            location: The location to load from.\n            remember: Should we remember the location in the history?\n        \"\"\"\n\n        try:\n            async with AsyncClient() as client:\n                response = await client.get(\n                    location,\n                    follow_redirects=True,\n                    headers={\"user-agent\": USER_AGENT},\n                )\n        except RequestError as error:\n            self.app.push_screen(ErrorDialog(\"Error getting document\", str(error)))\n            return\n\n        try:\n            response.raise_for_status()\n        except HTTPStatusError as error:\n            self.app.push_screen(ErrorDialog(\"Error getting document\", str(error)))\n            return\n\n        # There didn't seem to be an error transporting the data, and\n        # neither did there seem to be an error with the resource itself. So\n        # at this point we should hopefully have the document's content.\n        # However... it's possible we've been fooled into loading up\n        # something that looked like it was a markdown file, but really it's\n        # a web-rendering of such a file; so as a final check we make sure\n        # we're looking at something that's plain text, or actually\n        # Markdown.\n        content_type = response.headers.get(\"content-type\", \"\")\n        if any(\n            content_type.startswith(f\"text/{sub_type}\")\n            for sub_type in (\"plain\", \"markdown\", \"x-markdown\")\n        ):\n            self.document.update(response.text)\n            self._post_load(location, remember)\n        else:\n            # Didn't look like something we could handle with the Markdown\n            # viewer. We could throw up an error, or we could just be nice\n            # to the user. Let's be nice...\n            open_url(str(location))\n\n    def visit(self, location: Path | URL, remember: bool = True) -> None:\n        \"\"\"Visit a location.\n\n        Args:\n            location: The location to visit.\n            remember: Should this visit be added to the history?\n        \"\"\"\n        # Based on the type of the location, load up the content.\n        if isinstance(location, Path):\n            self._local_load(location.expanduser().resolve(), remember)\n        elif isinstance(location, URL):\n            self._remote_load(location, remember)\n        else:\n            raise ValueError(\"Unknown location type passed to the Markdown viewer\")\n\n    def reload(self) -> None:\n        \"\"\"Reload the current location.\"\"\"\n        if self.location is not None:\n            self.visit(self.location, False)\n\n    def show(self, content: str) -> None:\n        \"\"\"Show some direct text in the viewer.\n\n        Args:\n            content: The text to show.\n        \"\"\"\n        self.viewing_location = False\n        self.document.update(content)\n        self.scroll_home(animate=False)\n\n    def _jump(self, direction: Callable[[], bool]) -> None:\n        \"\"\"Jump in a particular direction within the history.\n\n        Args:\n            direction: A function that jumps in the desired direction.\n        \"\"\"\n        if direction():\n            if self.history.location is not None:\n                self.visit(self.history.location, remember=False)\n\n    def back(self) -> None:\n        \"\"\"Go back in the viewer history.\"\"\"\n        self._jump(self.history.back)\n\n    def forward(self) -> None:\n        \"\"\"Go forward in the viewer history.\"\"\"\n        self._jump(self.history.forward)\n\n    def load_history(self, history: list[Path | URL]) -> None:\n        \"\"\"Load up a history list from the given history.\n\n        Args:\n            history: The history load up from.\n        \"\"\"\n        self.history = History(history)\n        self.post_message(self.HistoryUpdated(self))\n\n    def delete_history(self, history_id: int) -> None:\n        \"\"\"Delete an item from the history.\n\n        Args:\n            history_id: The ID of the history item to delete.\n        \"\"\"\n        try:\n            del self.history[history_id]\n        except IndexError:\n            pass\n        else:\n            self.post_message(self.HistoryUpdated(self))\n\n    def clear_history(self) -> None:\n        \"\"\"Clear down the whole of history.\"\"\"\n        self.load_history([])", ""]}
{"filename": "frogmouth/widgets/__init__.py", "chunked_list": ["\"\"\"The major widgets for the application.\"\"\"\n\nfrom .navigation import Navigation\nfrom .omnibox import Omnibox\nfrom .viewer import Viewer\n\n__all__ = [\"Navigation\", \"Omnibox\", \"Viewer\"]\n"]}
{"filename": "frogmouth/widgets/omnibox.py", "chunked_list": ["\"\"\"Provides the viewer's omnibox widget.\"\"\"\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom re import compile as compile_regexp\nfrom typing import Type\nfrom webbrowser import open as open_url\n\nfrom httpx import URL", "\nfrom httpx import URL\nfrom textual.message import Message\nfrom textual.reactive import var\nfrom textual.widgets import Input\n\nfrom ..utility import is_likely_url\nfrom ..utility.advertising import DISCORD, ORGANISATION_NAME, PACKAGE_NAME\n\n\nclass Omnibox(Input):\n    \"\"\"The command and location input widget for the viewer.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    Omnibox {\n        dock: top;\n        padding: 0;\n        height: 3;\n    }\n\n    Omnibox .input--placeholder {\n        color: $text 50%;\n    }\n    \"\"\"\n    \"\"\"Default styling for the omnibox.\"\"\"\n\n    visiting: var[str] = var(\"\")\n    \"\"\"The location that is being visited.\"\"\"\n\n    def watch_visiting(self) -> None:\n        \"\"\"Watch the visiting reactive variable.\"\"\"\n        self.placeholder = self.visiting or \"Enter a location or command\"\n        if self.visiting:\n            self.value = self.visiting\n\n    _ALIASES: dict[str, str] = {\n        \"a\": \"about\",\n        \"b\": \"bookmarks\",\n        \"bm\": \"bookmarks\",\n        \"bb\": \"bitbucket\",\n        \"c\": \"contents\",\n        \"cb\": \"codeberg\",\n        \"cd\": \"chdir\",\n        \"cl\": \"changelog\",\n        \"gh\": \"github\",\n        \"gl\": \"gitlab\",\n        \"h\": \"history\",\n        \"l\": \"local\",\n        \"obs\": \"obsidian\",\n        \"toc\": \"contents\",\n        \"q\": \"quit\",\n        \"?\": \"help\",\n    }\n    \"\"\"Command aliases.\"\"\"\n\n    @staticmethod\n    def _split_command(value: str) -> list[str]:\n        \"\"\"Split a value into a command and argument tail.\n\n        Args:\n            value: The value to split.\n\n        Returns:\n            A list of the command and the argument(s).\n        \"\"\"\n        command = value.split(None, 1)\n        return [*command, \"\"] if len(command) == 1 else command\n\n    def _is_command(self, value: str) -> bool:\n        \"\"\"Is the given string a known command?\n\n        Args:\n            value: The value to check.\n\n        Returns:\n            `True` if the string is a known command, `False` if not.\n        \"\"\"\n        command, *_ = self._split_command(value)\n        return (\n            getattr(self, f\"command_{self._ALIASES.get(command, command)}\", None)\n            is not None\n        )\n\n    def _execute_command(self, command: str) -> None:\n        \"\"\"Execute the given command.\n\n        Args:\n            command: The comment to execute.\n        \"\"\"\n        command, arguments = self._split_command(command)\n        getattr(self, f\"command_{self._ALIASES.get(command, command)}\")(\n            arguments.strip()\n        )\n\n    class LocalViewCommand(Message):\n        \"\"\"The local file view command.\"\"\"\n\n        def __init__(self, path: Path) -> None:\n            \"\"\"Initialise the local view command.\n\n            Args:\n                path: The path to view.\n            \"\"\"\n            super().__init__()\n            self.path = path\n            \"\"\"The path of the file to view.\"\"\"\n\n    class RemoteViewCommand(Message):\n        \"\"\"The remote file view command.\"\"\"\n\n        def __init__(self, url: URL) -> None:\n            \"\"\"Initialise the remove view command.\n\n            Args:\n                url: The URL of the remote file to view.\n            \"\"\"\n            super().__init__()\n            self.url = url\n            \"\"\"The URL of the file to view.\"\"\"\n\n    class LocalChdirCommand(Message):\n        \"\"\"Command for changing the local files directory.\"\"\"\n\n        def __init__(self, target: Path) -> None:\n            \"\"\"Initialise the local files chdir command.\"\"\"\n            super().__init__()\n            self.target = target\n            \"\"\"The target directory to change to.\"\"\"\n\n    def on_input_submitted(self, event: Input.Submitted) -> None:\n        \"\"\"Handle the user submitting the input.\n\n        Args:\n            event: The submit event.\n        \"\"\"\n\n        # Clean up whatever the user input.\n        submitted = self.value.strip()\n\n        # Now that we've got it, empty the value. We'll put it back\n        # depending on the outcome.\n        self.value = \"\"\n\n        # Work through the possible options for what the user entered.\n        if is_likely_url(submitted):\n            # It looks like it's an URL of some description so try and load\n            # it as such.\n            self.post_message(self.RemoteViewCommand(URL(submitted)))\n        elif (path := Path(submitted).expanduser().resolve()).exists():\n            # It's a match for something in the local filesystem. Is it...\n            if path.is_file():\n                # a file! Try and open it for viewing.\n                self.post_message(self.LocalViewCommand(path))\n                self.value = str(path)\n            elif path.is_dir():\n                # Nope, it's a directory. Take that to be a request to open\n                # the local file selection navigation pane with the\n                # directory as the root.\n                self.post_message(self.LocalChdirCommand(path))\n            else:\n                # It's something that exists in the filesystem, but it's not\n                # a directory or a file. Let's nope on that for now.\n                return\n        elif self._is_command(command := submitted.lower()):\n            # Having checked for URLs and existing filesystem things, it's\n            # now safe to look for commands. Having got here, it is a match\n            # for a command so we handle it as such.\n            self._execute_command(command)\n        else:\n            # Having got this far, the best thing to do now is assume that\n            # the user was attempting to enter a filename to view and got it\n            # wrong. So that they get some sort of feedback, let's attempt\n            # to view it anyway.\n            self.post_message(self.LocalViewCommand(Path(submitted)))\n            # Because it'll raise an error and the user may want to edit the\n            # input to get it right, we put the original input back in\n            # place.\n            self.value = submitted\n\n        # If we got a match above stop the event.\n        event.stop()\n\n    class ContentsCommand(Message):\n        \"\"\"The table of contents command.\"\"\"\n\n    def command_contents(self, _: str) -> None:\n        \"\"\"Handle the table of contents command.\"\"\"\n        self.post_message(self.ContentsCommand())\n\n    class LocalFilesCommand(Message):\n        \"\"\"The local files command.\"\"\"\n\n    def command_local(self, _: str) -> None:\n        \"\"\"View the local files.\"\"\"\n        self.post_message(self.LocalFilesCommand())\n\n    class BookmarksCommand(Message):\n        \"\"\"The bookmarks command.\"\"\"\n\n    def command_bookmarks(self, _: str) -> None:\n        \"\"\"View the bookmarks.\"\"\"\n        self.post_message(self.BookmarksCommand())\n\n    class QuitCommand(Message):\n        \"\"\"The quit command.\"\"\"\n\n    def command_quit(self, _: str) -> None:\n        \"\"\"The quit command.\"\"\"\n        self.post_message(self.QuitCommand())\n\n    class HistoryCommand(Message):\n        \"\"\"The history command.\"\"\"\n\n    def command_history(self, _: str) -> None:\n        \"\"\"The history command.\"\"\"\n        self.post_message(self.HistoryCommand())\n\n    class AboutCommand(Message):\n        \"\"\"The about command.\"\"\"\n\n    def command_about(self, _: str) -> None:\n        \"\"\"The about command.\"\"\"\n        self.post_message(self.AboutCommand())\n\n    class HelpCommand(Message):\n        \"\"\"The help command.\"\"\"\n\n    def command_help(self, _: str) -> None:\n        \"\"\"The help command.\"\"\"\n        self.post_message(self.HelpCommand())\n\n    def command_chdir(self, target: str) -> None:\n        \"\"\"The chdir command.\n\n        Args:\n            target: The target directory to change to.\n        \"\"\"\n        self.post_message(\n            self.LocalChdirCommand(Path(target or \"~\").expanduser().resolve())\n        )\n\n    _GUESS_BRANCH = compile_regexp(\n        r\"^(?P<owner>[^/ ]+)[/ ](?P<repo>[^ :]+)(?: +(?P<file>[^ ]+))?$\"\n    )\n    \"\"\"Regular expression for matching a repo and file where we'll guess the branch.\"\"\"\n\n    _SPECIFIC_BRANCH = compile_regexp(\n        r\"^(?P<owner>[^/ ]+)[/ ](?P<repo>[^ :]+):(?P<branch>[^ ]+)(?: +(?P<file>[^ ]+))?$\"\n    )\n    \"\"\"Regular expression for matching a repo and file where the branch is also given.\"\"\"\n\n    class ForgeCommand(Message):\n        \"\"\"The base git forge quick load command.\"\"\"\n\n        def __init__(\n            self,\n            owner: str,\n            repository: str,\n            branch: str | None = None,\n            desired_file: str | None = None,\n        ) -> None:\n            \"\"\"Initialise the git forge quick load command.\"\"\"\n            super().__init__()\n            self.owner = owner\n            \"\"\"The owner of the repository.\"\"\"\n            self.repository = repository\n            \"\"\"The repository.\"\"\"\n            self.branch: str | None = branch\n            \"\"\"The optional branch to attempt to pull the file from.\"\"\"\n            self.desired_file: str | None = desired_file\n            \"\"\"The optional file the user wants from the repository.\"\"\"\n\n    def _forge_quick_look(self, command: Type[ForgeCommand], tail: str) -> None:\n        \"\"\"Core forge quick look support method.\n\n        Args:\n            command: The command message to be posted.\n            tail: The tail of the command to be parsed.\n        \"\"\"\n        tail = tail.strip()\n        if hit := self._GUESS_BRANCH.match(tail):\n            self.post_message(\n                command(hit[\"owner\"], hit[\"repo\"], desired_file=hit[\"file\"])\n            )\n        elif hit := self._SPECIFIC_BRANCH.match(tail):\n            self.post_message(\n                command(\n                    hit[\"owner\"],\n                    hit[\"repo\"],\n                    branch=hit[\"branch\"],\n                    desired_file=hit[\"file\"],\n                )\n            )\n\n    class GitHubCommand(ForgeCommand):\n        \"\"\"The GitHub quick load command.\"\"\"\n\n    def command_github(self, tail: str) -> None:\n        \"\"\"The github command.\n\n        Args:\n            tail: The tail of the command.\n        \"\"\"\n        self._forge_quick_look(self.GitHubCommand, tail)\n\n    class GitLabCommand(ForgeCommand):\n        \"\"\"The GitLab quick load command.\"\"\"\n\n    def command_gitlab(self, tail: str) -> None:\n        \"\"\"The Gitlab command.\n\n        Args:\n            tail: The tail of the command.\n        \"\"\"\n        self._forge_quick_look(self.GitLabCommand, tail)\n\n    class BitBucketCommand(ForgeCommand):\n        \"\"\"The BitBucket quick load command.\"\"\"\n\n    def command_bitbucket(self, tail: str) -> None:\n        \"\"\"The BitBucket command.\n\n        Args:\n            tail: The tail of the command.\n        \"\"\"\n        self._forge_quick_look(self.BitBucketCommand, tail)\n\n    class CodebergCommand(ForgeCommand):\n        \"\"\"The Codeberg quick load command.\"\"\"\n\n    def command_codeberg(self, tail: str) -> None:\n        \"\"\"The Codeberg command.\n\n        Args:\n            tail: The tail of the command.\n        \"\"\"\n        self._forge_quick_look(self.CodebergCommand, tail)\n\n    def command_discord(self, _: str) -> None:\n        \"\"\"The command to visit the Textualize discord server.\"\"\"\n        open_url(DISCORD)\n\n    def command_changelog(self, _: str) -> None:\n        \"\"\"The command to show the application's own ChangeLog\"\"\"\n        self.command_github(f\"{ORGANISATION_NAME}/{PACKAGE_NAME} ChangeLog.md\")\n\n    def command_obsidian(self, vault: str) -> None:\n        \"\"\"The command to visit an obsidian vault, if one can be seen.\n\n        Args:\n            vault: The vault to visit.\n\n        If the vault name is empty, an attempt will be made to visit the\n        root level of all Obsidian vaults.\n\n        Note:\n            At the moment this will only work with Obsidian on macOS where\n            the vaults are being held in iCloud.\n        \"\"\"\n        # Right now this will only work on macOS. I've not used Obsidian on\n        # any other OS so I'm unsure where the vault will be stored. I'll\n        # add to this once I've found out.\n        if (\n            target := (\n                Path(\n                    \"~/Library/Mobile Documents/iCloud~md~obsidian/Documents\"\n                ).expanduser()\n                / vault\n            )\n        ).exists():\n            self.command_chdir(str(target))", "\n\nclass Omnibox(Input):\n    \"\"\"The command and location input widget for the viewer.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    Omnibox {\n        dock: top;\n        padding: 0;\n        height: 3;\n    }\n\n    Omnibox .input--placeholder {\n        color: $text 50%;\n    }\n    \"\"\"\n    \"\"\"Default styling for the omnibox.\"\"\"\n\n    visiting: var[str] = var(\"\")\n    \"\"\"The location that is being visited.\"\"\"\n\n    def watch_visiting(self) -> None:\n        \"\"\"Watch the visiting reactive variable.\"\"\"\n        self.placeholder = self.visiting or \"Enter a location or command\"\n        if self.visiting:\n            self.value = self.visiting\n\n    _ALIASES: dict[str, str] = {\n        \"a\": \"about\",\n        \"b\": \"bookmarks\",\n        \"bm\": \"bookmarks\",\n        \"bb\": \"bitbucket\",\n        \"c\": \"contents\",\n        \"cb\": \"codeberg\",\n        \"cd\": \"chdir\",\n        \"cl\": \"changelog\",\n        \"gh\": \"github\",\n        \"gl\": \"gitlab\",\n        \"h\": \"history\",\n        \"l\": \"local\",\n        \"obs\": \"obsidian\",\n        \"toc\": \"contents\",\n        \"q\": \"quit\",\n        \"?\": \"help\",\n    }\n    \"\"\"Command aliases.\"\"\"\n\n    @staticmethod\n    def _split_command(value: str) -> list[str]:\n        \"\"\"Split a value into a command and argument tail.\n\n        Args:\n            value: The value to split.\n\n        Returns:\n            A list of the command and the argument(s).\n        \"\"\"\n        command = value.split(None, 1)\n        return [*command, \"\"] if len(command) == 1 else command\n\n    def _is_command(self, value: str) -> bool:\n        \"\"\"Is the given string a known command?\n\n        Args:\n            value: The value to check.\n\n        Returns:\n            `True` if the string is a known command, `False` if not.\n        \"\"\"\n        command, *_ = self._split_command(value)\n        return (\n            getattr(self, f\"command_{self._ALIASES.get(command, command)}\", None)\n            is not None\n        )\n\n    def _execute_command(self, command: str) -> None:\n        \"\"\"Execute the given command.\n\n        Args:\n            command: The comment to execute.\n        \"\"\"\n        command, arguments = self._split_command(command)\n        getattr(self, f\"command_{self._ALIASES.get(command, command)}\")(\n            arguments.strip()\n        )\n\n    class LocalViewCommand(Message):\n        \"\"\"The local file view command.\"\"\"\n\n        def __init__(self, path: Path) -> None:\n            \"\"\"Initialise the local view command.\n\n            Args:\n                path: The path to view.\n            \"\"\"\n            super().__init__()\n            self.path = path\n            \"\"\"The path of the file to view.\"\"\"\n\n    class RemoteViewCommand(Message):\n        \"\"\"The remote file view command.\"\"\"\n\n        def __init__(self, url: URL) -> None:\n            \"\"\"Initialise the remove view command.\n\n            Args:\n                url: The URL of the remote file to view.\n            \"\"\"\n            super().__init__()\n            self.url = url\n            \"\"\"The URL of the file to view.\"\"\"\n\n    class LocalChdirCommand(Message):\n        \"\"\"Command for changing the local files directory.\"\"\"\n\n        def __init__(self, target: Path) -> None:\n            \"\"\"Initialise the local files chdir command.\"\"\"\n            super().__init__()\n            self.target = target\n            \"\"\"The target directory to change to.\"\"\"\n\n    def on_input_submitted(self, event: Input.Submitted) -> None:\n        \"\"\"Handle the user submitting the input.\n\n        Args:\n            event: The submit event.\n        \"\"\"\n\n        # Clean up whatever the user input.\n        submitted = self.value.strip()\n\n        # Now that we've got it, empty the value. We'll put it back\n        # depending on the outcome.\n        self.value = \"\"\n\n        # Work through the possible options for what the user entered.\n        if is_likely_url(submitted):\n            # It looks like it's an URL of some description so try and load\n            # it as such.\n            self.post_message(self.RemoteViewCommand(URL(submitted)))\n        elif (path := Path(submitted).expanduser().resolve()).exists():\n            # It's a match for something in the local filesystem. Is it...\n            if path.is_file():\n                # a file! Try and open it for viewing.\n                self.post_message(self.LocalViewCommand(path))\n                self.value = str(path)\n            elif path.is_dir():\n                # Nope, it's a directory. Take that to be a request to open\n                # the local file selection navigation pane with the\n                # directory as the root.\n                self.post_message(self.LocalChdirCommand(path))\n            else:\n                # It's something that exists in the filesystem, but it's not\n                # a directory or a file. Let's nope on that for now.\n                return\n        elif self._is_command(command := submitted.lower()):\n            # Having checked for URLs and existing filesystem things, it's\n            # now safe to look for commands. Having got here, it is a match\n            # for a command so we handle it as such.\n            self._execute_command(command)\n        else:\n            # Having got this far, the best thing to do now is assume that\n            # the user was attempting to enter a filename to view and got it\n            # wrong. So that they get some sort of feedback, let's attempt\n            # to view it anyway.\n            self.post_message(self.LocalViewCommand(Path(submitted)))\n            # Because it'll raise an error and the user may want to edit the\n            # input to get it right, we put the original input back in\n            # place.\n            self.value = submitted\n\n        # If we got a match above stop the event.\n        event.stop()\n\n    class ContentsCommand(Message):\n        \"\"\"The table of contents command.\"\"\"\n\n    def command_contents(self, _: str) -> None:\n        \"\"\"Handle the table of contents command.\"\"\"\n        self.post_message(self.ContentsCommand())\n\n    class LocalFilesCommand(Message):\n        \"\"\"The local files command.\"\"\"\n\n    def command_local(self, _: str) -> None:\n        \"\"\"View the local files.\"\"\"\n        self.post_message(self.LocalFilesCommand())\n\n    class BookmarksCommand(Message):\n        \"\"\"The bookmarks command.\"\"\"\n\n    def command_bookmarks(self, _: str) -> None:\n        \"\"\"View the bookmarks.\"\"\"\n        self.post_message(self.BookmarksCommand())\n\n    class QuitCommand(Message):\n        \"\"\"The quit command.\"\"\"\n\n    def command_quit(self, _: str) -> None:\n        \"\"\"The quit command.\"\"\"\n        self.post_message(self.QuitCommand())\n\n    class HistoryCommand(Message):\n        \"\"\"The history command.\"\"\"\n\n    def command_history(self, _: str) -> None:\n        \"\"\"The history command.\"\"\"\n        self.post_message(self.HistoryCommand())\n\n    class AboutCommand(Message):\n        \"\"\"The about command.\"\"\"\n\n    def command_about(self, _: str) -> None:\n        \"\"\"The about command.\"\"\"\n        self.post_message(self.AboutCommand())\n\n    class HelpCommand(Message):\n        \"\"\"The help command.\"\"\"\n\n    def command_help(self, _: str) -> None:\n        \"\"\"The help command.\"\"\"\n        self.post_message(self.HelpCommand())\n\n    def command_chdir(self, target: str) -> None:\n        \"\"\"The chdir command.\n\n        Args:\n            target: The target directory to change to.\n        \"\"\"\n        self.post_message(\n            self.LocalChdirCommand(Path(target or \"~\").expanduser().resolve())\n        )\n\n    _GUESS_BRANCH = compile_regexp(\n        r\"^(?P<owner>[^/ ]+)[/ ](?P<repo>[^ :]+)(?: +(?P<file>[^ ]+))?$\"\n    )\n    \"\"\"Regular expression for matching a repo and file where we'll guess the branch.\"\"\"\n\n    _SPECIFIC_BRANCH = compile_regexp(\n        r\"^(?P<owner>[^/ ]+)[/ ](?P<repo>[^ :]+):(?P<branch>[^ ]+)(?: +(?P<file>[^ ]+))?$\"\n    )\n    \"\"\"Regular expression for matching a repo and file where the branch is also given.\"\"\"\n\n    class ForgeCommand(Message):\n        \"\"\"The base git forge quick load command.\"\"\"\n\n        def __init__(\n            self,\n            owner: str,\n            repository: str,\n            branch: str | None = None,\n            desired_file: str | None = None,\n        ) -> None:\n            \"\"\"Initialise the git forge quick load command.\"\"\"\n            super().__init__()\n            self.owner = owner\n            \"\"\"The owner of the repository.\"\"\"\n            self.repository = repository\n            \"\"\"The repository.\"\"\"\n            self.branch: str | None = branch\n            \"\"\"The optional branch to attempt to pull the file from.\"\"\"\n            self.desired_file: str | None = desired_file\n            \"\"\"The optional file the user wants from the repository.\"\"\"\n\n    def _forge_quick_look(self, command: Type[ForgeCommand], tail: str) -> None:\n        \"\"\"Core forge quick look support method.\n\n        Args:\n            command: The command message to be posted.\n            tail: The tail of the command to be parsed.\n        \"\"\"\n        tail = tail.strip()\n        if hit := self._GUESS_BRANCH.match(tail):\n            self.post_message(\n                command(hit[\"owner\"], hit[\"repo\"], desired_file=hit[\"file\"])\n            )\n        elif hit := self._SPECIFIC_BRANCH.match(tail):\n            self.post_message(\n                command(\n                    hit[\"owner\"],\n                    hit[\"repo\"],\n                    branch=hit[\"branch\"],\n                    desired_file=hit[\"file\"],\n                )\n            )\n\n    class GitHubCommand(ForgeCommand):\n        \"\"\"The GitHub quick load command.\"\"\"\n\n    def command_github(self, tail: str) -> None:\n        \"\"\"The github command.\n\n        Args:\n            tail: The tail of the command.\n        \"\"\"\n        self._forge_quick_look(self.GitHubCommand, tail)\n\n    class GitLabCommand(ForgeCommand):\n        \"\"\"The GitLab quick load command.\"\"\"\n\n    def command_gitlab(self, tail: str) -> None:\n        \"\"\"The Gitlab command.\n\n        Args:\n            tail: The tail of the command.\n        \"\"\"\n        self._forge_quick_look(self.GitLabCommand, tail)\n\n    class BitBucketCommand(ForgeCommand):\n        \"\"\"The BitBucket quick load command.\"\"\"\n\n    def command_bitbucket(self, tail: str) -> None:\n        \"\"\"The BitBucket command.\n\n        Args:\n            tail: The tail of the command.\n        \"\"\"\n        self._forge_quick_look(self.BitBucketCommand, tail)\n\n    class CodebergCommand(ForgeCommand):\n        \"\"\"The Codeberg quick load command.\"\"\"\n\n    def command_codeberg(self, tail: str) -> None:\n        \"\"\"The Codeberg command.\n\n        Args:\n            tail: The tail of the command.\n        \"\"\"\n        self._forge_quick_look(self.CodebergCommand, tail)\n\n    def command_discord(self, _: str) -> None:\n        \"\"\"The command to visit the Textualize discord server.\"\"\"\n        open_url(DISCORD)\n\n    def command_changelog(self, _: str) -> None:\n        \"\"\"The command to show the application's own ChangeLog\"\"\"\n        self.command_github(f\"{ORGANISATION_NAME}/{PACKAGE_NAME} ChangeLog.md\")\n\n    def command_obsidian(self, vault: str) -> None:\n        \"\"\"The command to visit an obsidian vault, if one can be seen.\n\n        Args:\n            vault: The vault to visit.\n\n        If the vault name is empty, an attempt will be made to visit the\n        root level of all Obsidian vaults.\n\n        Note:\n            At the moment this will only work with Obsidian on macOS where\n            the vaults are being held in iCloud.\n        \"\"\"\n        # Right now this will only work on macOS. I've not used Obsidian on\n        # any other OS so I'm unsure where the vault will be stored. I'll\n        # add to this once I've found out.\n        if (\n            target := (\n                Path(\n                    \"~/Library/Mobile Documents/iCloud~md~obsidian/Documents\"\n                ).expanduser()\n                / vault\n            )\n        ).exists():\n            self.command_chdir(str(target))", ""]}
{"filename": "frogmouth/widgets/navigation.py", "chunked_list": ["\"\"\"Provides the navigation panel widget.\"\"\"\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\n\nfrom textual.app import ComposeResult\nfrom textual.binding import Binding\nfrom textual.containers import Vertical\nfrom textual.message import Message", "from textual.containers import Vertical\nfrom textual.message import Message\nfrom textual.reactive import var\nfrom textual.widgets import TabbedContent, Tabs\nfrom typing_extensions import Self\n\nfrom ..data import load_config, save_config\nfrom .navigation_panes.bookmarks import Bookmarks\nfrom .navigation_panes.history import History\nfrom .navigation_panes.local_files import LocalFiles", "from .navigation_panes.history import History\nfrom .navigation_panes.local_files import LocalFiles\nfrom .navigation_panes.navigation_pane import NavigationPane\nfrom .navigation_panes.table_of_contents import TableOfContents\n\n\nclass Navigation(Vertical, can_focus=False, can_focus_children=True):\n    \"\"\"A navigation panel widget.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    Navigation {\n        width: 44;\n        background: $panel;\n        display: block;\n        dock: left;\n    }\n\n    Navigation.hidden {\n        display: none;\n    }\n\n    TabbedContent {\n        height: 100% !important;\n    }\n\n    ContentSwitcher {\n        height: 1fr !important;\n    }\n    \"\"\"\n\n    BINDINGS = [\n        Binding(\"comma,a,ctrl+left,shift+left,h\", \"previous_tab\", \"\", show=False),\n        Binding(\"full_stop,d,ctrl+right,shift+right,l\", \"next_tab\", \"\", show=False),\n        Binding(\"\\\\\", \"toggle_dock\", \"Dock left/right\"),\n    ]\n    \"\"\"Bindings local to the navigation pane.\"\"\"\n\n    popped_out: var[bool] = var(False)\n    \"\"\"Is the navigation popped out?\"\"\"\n\n    docked_left: var[bool] = var(True)\n    \"\"\"Should navigation be docked to the left side of the screen?\"\"\"\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the content of the navigation pane.\"\"\"\n        self.popped_out = False\n        # pylint:disable=attribute-defined-outside-init\n        self._contents = TableOfContents()\n        self._local_files = LocalFiles()\n        self._bookmarks = Bookmarks()\n        self._history = History()\n        with TabbedContent() as tabs:\n            self._tabs = tabs\n            yield self._contents\n            yield self._local_files\n            yield self._bookmarks\n            yield self._history\n\n    def on_mount(self) -> None:\n        \"\"\"Configure navigation once the DOM is set up.\"\"\"\n        self.docked_left = load_config().navigation_left\n\n    class Hidden(Message):\n        \"\"\"Message sent when the navigation is hidden.\"\"\"\n\n    def watch_popped_out(self) -> None:\n        \"\"\"Watch for changes to the popped out state.\"\"\"\n        self.set_class(not self.popped_out, \"hidden\")\n        if not self.popped_out:\n            self.post_message(self.Hidden())\n\n    def toggle(self) -> None:\n        \"\"\"Toggle the popped/unpopped state.\"\"\"\n        self.popped_out = not self.popped_out\n\n    def watch_docked_left(self) -> None:\n        \"\"\"Watch for changes to the left-docking status.\"\"\"\n        self.styles.dock = \"left\" if self.docked_left else \"right\"\n\n    @property\n    def table_of_contents(self) -> TableOfContents:\n        \"\"\"The table of contents widget.\"\"\"\n        return self._contents\n\n    @property\n    def local_files(self) -> LocalFiles:\n        \"\"\"The local files widget.\"\"\"\n        return self._local_files\n\n    @property\n    def bookmarks(self) -> Bookmarks:\n        \"\"\"The bookmarks widget.\"\"\"\n        return self._bookmarks\n\n    @property\n    def history(self) -> History:\n        \"\"\"The history widget.\"\"\"\n        return self._history\n\n    def jump_to_local_files(self, target: Path | None = None) -> Self:\n        \"\"\"Switch to and focus the local files pane.\n\n        Returns:\n            Self.\n        \"\"\"\n        if (\n            self.popped_out\n            and target is None\n            and self.query_one(Tabs).active == self._local_files.id\n        ):\n            self.popped_out = False\n        else:\n            self.popped_out = True\n            if target is not None:\n                self._local_files.chdir(target)\n            self._local_files.activate().set_focus_within()\n        return self\n\n    def jump_to_bookmarks(self) -> Self:\n        \"\"\"Switch to and focus the bookmarks pane.\n\n        Returns:\n            Self.\n        \"\"\"\n        if self.popped_out and self.query_one(Tabs).active == self._bookmarks.id:\n            self.popped_out = False\n        else:\n            self.popped_out = True\n            self._bookmarks.activate().set_focus_within()\n        return self\n\n    def jump_to_history(self) -> Self:\n        \"\"\"Switch to and focus the history pane.\n\n        Returns:\n            Self.\n        \"\"\"\n        if self.popped_out and self.query_one(Tabs).active == self._history.id:\n            self.popped_out = False\n        else:\n            self.popped_out = True\n            self._history.activate().set_focus_within()\n        return self\n\n    def jump_to_contents(self) -> Self:\n        \"\"\"Switch to and focus the table of contents pane.\n\n        Returns:\n            Self.\n        \"\"\"\n        if self.popped_out and self.query_one(Tabs).active == self._contents.id:\n            self.popped_out = False\n        else:\n            self.popped_out = True\n            self._contents.activate().set_focus_within()\n        return self\n\n    def action_previous_tab(self) -> None:\n        \"\"\"Switch to the previous tab in the navigation pane.\"\"\"\n        self.query_one(Tabs).action_previous_tab()\n        self.focus_tab()\n\n    def action_next_tab(self) -> None:\n        \"\"\"Switch to the next tab in the navigation pane.\"\"\"\n        self.query_one(Tabs).action_next_tab()\n        self.focus_tab()\n\n    def action_toggle_dock(self) -> None:\n        \"\"\"Toggle the dock side for the navigation.\"\"\"\n        config = load_config()\n        config.navigation_left = not config.navigation_left\n        save_config(config)\n        self.docked_left = config.navigation_left\n\n    def focus_tab(self) -> None:\n        \"\"\"Focus the currently active tab.\"\"\"\n        if active := self.query_one(Tabs).active:\n            self.query_one(\n                f\"NavigationPane#{active}\", NavigationPane\n            ).set_focus_within()", ""]}
{"filename": "frogmouth/widgets/navigation_panes/bookmarks.py", "chunked_list": ["\"\"\"Provides the bookmarks navigation pane.\"\"\"\n\nfrom __future__ import annotations\n\nfrom functools import partial\nfrom pathlib import Path\n\nfrom httpx import URL\nfrom rich.text import Text\nfrom textual.app import ComposeResult", "from rich.text import Text\nfrom textual.app import ComposeResult\nfrom textual.binding import Binding\nfrom textual.message import Message\nfrom textual.widgets import OptionList\nfrom textual.widgets.option_list import Option\n\nfrom ...data import Bookmark, load_bookmarks, save_bookmarks\nfrom ...dialogs import InputDialog, YesNoDialog\nfrom .navigation_pane import NavigationPane", "from ...dialogs import InputDialog, YesNoDialog\nfrom .navigation_pane import NavigationPane\n\n\nclass Entry(Option):\n    \"\"\"An entry in the bookmark list.\"\"\"\n\n    def __init__(self, bookmark: Bookmark) -> None:\n        super().__init__(self._as_prompt(bookmark))\n        self.bookmark = bookmark\n        \"\"\"The bookmark that this entry relates to.\"\"\"\n\n    @staticmethod\n    def _as_prompt(bookmark: Bookmark) -> Text:\n        \"\"\"Depict the bookmark as a decorated prompt.\n\n        Args:\n            bookmark: The bookmark to depict.\n\n        Returns:\n            A prompt with icon, etc.\n        \"\"\"\n        return Text.from_markup(\n            f\":{'page_facing_up' if isinstance(bookmark.location, Path) else 'globe_with_meridians'}: \"\n            f\"[bold]{bookmark.title}[/]\\n[dim]{bookmark.location}[/]\",\n            overflow=\"ellipsis\",\n        )", "\n\nclass Bookmarks(NavigationPane):\n    \"\"\"Bookmarks navigation pane.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    Bookmarks {\n        height: 100%;\n    }\n\n    Bookmarks > OptionList {\n        background: $panel;\n        border: none;\n        height: 1fr;\n    }\n\n    Bookmarks > OptionList:focus {\n        border: none;\n    }\n    \"\"\"\n    \"\"\"The default CSS for the bookmarks navigation pane.\"\"\"\n\n    BINDINGS = [\n        Binding(\"delete\", \"delete\", \"Delete the bookmark\"),\n        Binding(\"r\", \"rename\", \"Rename the bookmark\"),\n    ]\n    \"\"\"The bindings for the bookmarks navigation pane.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialise the bookmarks navigation pane.\"\"\"\n        super().__init__(\"Bookmarks\")\n        self._bookmarks: list[Bookmark] = load_bookmarks()\n        \"\"\"The internal list of bookmarks.\"\"\"\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the child widgets.\"\"\"\n        yield OptionList(*[Entry(bookmark) for bookmark in self._bookmarks])\n\n    def set_focus_within(self) -> None:\n        \"\"\"Focus the option list.\"\"\"\n        self.query_one(OptionList).focus(scroll_visible=False)\n\n    def _bookmarks_updated(self) -> None:\n        \"\"\"Handle the bookmarks being updated.\"\"\"\n        # It's slightly costly, but currently there's no easier way to do\n        # this; and really it's not going to be that frequent. Here we nuke\n        # the content of the OptionList and rebuild it based on the actual\n        # list of bookmarks.\n        bookmarks = self.query_one(OptionList)\n        old_position = bookmarks.highlighted\n        bookmarks.clear_options()\n        for bookmark in self._bookmarks:\n            bookmarks.add_option(Entry(bookmark))\n        save_bookmarks(self._bookmarks)\n        bookmarks.highlighted = old_position\n\n    def add_bookmark(self, title: str, location: Path | URL) -> None:\n        \"\"\"Add a new bookmark.\n\n        Args:\n            title: The title of the bookmark.\n            location: The location of the bookmark.\n        \"\"\"\n        self._bookmarks.append(Bookmark(title, location))\n        self._bookmarks = sorted(self._bookmarks, key=lambda bookmark: bookmark.title)\n        self._bookmarks_updated()\n\n    class Goto(Message):\n        \"\"\"Message that requests that the viewer goes to a given bookmark.\"\"\"\n\n        def __init__(self, bookmark: Bookmark) -> None:\n            \"\"\"Initialise the bookmark goto message.\n\n            Args:\n                bookmark: The bookmark to go to.\n            \"\"\"\n            super().__init__()\n            self.bookmark = bookmark\n\n    def on_option_list_option_selected(self, event: OptionList.OptionSelected) -> None:\n        \"\"\"Handle an entry in the bookmarks being selected.\n\n        Args:\n            event: The event to handle.\n        \"\"\"\n        event.stop()\n        assert isinstance(event.option, Entry)\n        self.post_message(self.Goto(event.option.bookmark))\n\n    def delete_bookmark(self, bookmark: int, delete_it: bool) -> None:\n        \"\"\"Delete a given bookmark.\n\n        Args:\n            bookmark: The bookmark to delete.\n            delete_it: Should it be deleted?\n        \"\"\"\n        if delete_it:\n            del self._bookmarks[bookmark]\n            self._bookmarks_updated()\n\n    def action_delete(self) -> None:\n        \"\"\"Delete the highlighted bookmark.\"\"\"\n        if (bookmark := self.query_one(OptionList).highlighted) is not None:\n            self.app.push_screen(\n                YesNoDialog(\n                    \"Delete bookmark\",\n                    \"Are you sure you want to delete the bookmark?\",\n                ),\n                partial(self.delete_bookmark, bookmark),\n            )\n\n    def rename_bookmark(self, bookmark: int, new_name: str) -> None:\n        \"\"\"Rename the current bookmark.\n\n        Args:\n            bookmark: The location of the bookmark to rename.\n            new_name: The input dialog result that is the new name.\n        \"\"\"\n        self._bookmarks[bookmark] = Bookmark(\n            new_name, self._bookmarks[bookmark].location\n        )\n        self._bookmarks_updated()\n\n    def action_rename(self) -> None:\n        \"\"\"Rename the highlighted bookmark.\"\"\"\n        if (bookmark := self.query_one(OptionList).highlighted) is not None:\n            self.app.push_screen(\n                InputDialog(\n                    \"Bookmark title:\",\n                    self._bookmarks[bookmark].title,\n                ),\n                partial(self.rename_bookmark, bookmark),\n            )", ""]}
{"filename": "frogmouth/widgets/navigation_panes/table_of_contents.py", "chunked_list": ["\"\"\"Provides the table of contents navigation pane.\"\"\"\n\nfrom textual.app import ComposeResult\nfrom textual.widgets import Markdown, Tree\nfrom textual.widgets.markdown import MarkdownTableOfContents\n\nfrom .navigation_pane import NavigationPane\n\n\nclass TableOfContents(NavigationPane):\n    \"\"\"Markdown document table of contents navigation pane.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    TableOfContents {\n        height: 100%;\n    }\n\n    TableOfContents > MarkdownTableOfContents {\n        background: $panel;\n        border: none;\n    }\n\n    TableOfContents > MarkdownTableOfContents > Tree {\n        width: 1fr;\n        background: $panel;\n        padding: 0;\n    }\n\n    TableOfContents > MarkdownTableOfContents > Tree:focus .tree--cursor, TableOfContents > MarkdownTableOfContents > Tree .tree--cursor {\n        background: $accent 50%;\n        color: $text;\n    }\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialise the table of contents navigation pane.\"\"\"\n        super().__init__(\"Contents\")\n\n    def set_focus_within(self) -> None:\n        \"\"\"Ensure the tree in the table of contents is focused.\"\"\"\n        self.query_one(\"MarkdownTableOfContents > Tree\", Tree).focus(\n            scroll_visible=False\n        )\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the child widgets.\"\"\"\n        # Note the use of a throwaway Markdown object. Textual 0.24\n        # introduced a requirement for MarkdownTableOfContents to take a\n        # reference to a Markdown document; this is a problem if you're\n        # composing the ToC in a location somewhere unrelated to the\n        # document itself, such that you can't guarantee the order in which\n        # they're compose. I'm not using the ToC in a way that's\n        # tightly-coupled to the document, neither am I using multiple ToCs\n        # and documents. So... we make one and ignore it.\n        #\n        # https://github.com/Textualize/textual/issues/2516\n        yield MarkdownTableOfContents(Markdown())\n\n    def on_table_of_contents_updated(\n        self, event: Markdown.TableOfContentsUpdated\n    ) -> None:\n        \"\"\"Handle a table of contents update event.\n\n        Args:\n            event: The table of content update event to handle.\n        \"\"\"\n        self.query_one(\n            MarkdownTableOfContents\n        ).table_of_contents = event.table_of_contents", "\nclass TableOfContents(NavigationPane):\n    \"\"\"Markdown document table of contents navigation pane.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    TableOfContents {\n        height: 100%;\n    }\n\n    TableOfContents > MarkdownTableOfContents {\n        background: $panel;\n        border: none;\n    }\n\n    TableOfContents > MarkdownTableOfContents > Tree {\n        width: 1fr;\n        background: $panel;\n        padding: 0;\n    }\n\n    TableOfContents > MarkdownTableOfContents > Tree:focus .tree--cursor, TableOfContents > MarkdownTableOfContents > Tree .tree--cursor {\n        background: $accent 50%;\n        color: $text;\n    }\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialise the table of contents navigation pane.\"\"\"\n        super().__init__(\"Contents\")\n\n    def set_focus_within(self) -> None:\n        \"\"\"Ensure the tree in the table of contents is focused.\"\"\"\n        self.query_one(\"MarkdownTableOfContents > Tree\", Tree).focus(\n            scroll_visible=False\n        )\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the child widgets.\"\"\"\n        # Note the use of a throwaway Markdown object. Textual 0.24\n        # introduced a requirement for MarkdownTableOfContents to take a\n        # reference to a Markdown document; this is a problem if you're\n        # composing the ToC in a location somewhere unrelated to the\n        # document itself, such that you can't guarantee the order in which\n        # they're compose. I'm not using the ToC in a way that's\n        # tightly-coupled to the document, neither am I using multiple ToCs\n        # and documents. So... we make one and ignore it.\n        #\n        # https://github.com/Textualize/textual/issues/2516\n        yield MarkdownTableOfContents(Markdown())\n\n    def on_table_of_contents_updated(\n        self, event: Markdown.TableOfContentsUpdated\n    ) -> None:\n        \"\"\"Handle a table of contents update event.\n\n        Args:\n            event: The table of content update event to handle.\n        \"\"\"\n        self.query_one(\n            MarkdownTableOfContents\n        ).table_of_contents = event.table_of_contents", ""]}
{"filename": "frogmouth/widgets/navigation_panes/history.py", "chunked_list": ["\"\"\"Provides the history navigation pane.\"\"\"\n\nfrom __future__ import annotations\n\nfrom functools import partial\nfrom pathlib import Path\n\nfrom httpx import URL\nfrom rich.text import Text\nfrom textual.app import ComposeResult", "from rich.text import Text\nfrom textual.app import ComposeResult\nfrom textual.binding import Binding\nfrom textual.message import Message\nfrom textual.widgets import OptionList\nfrom textual.widgets.option_list import Option\n\nfrom ...dialogs import YesNoDialog\nfrom .navigation_pane import NavigationPane\n", "from .navigation_pane import NavigationPane\n\n\nclass Entry(Option):\n    \"\"\"An entry in the history.\"\"\"\n\n    def __init__(self, history_id: int, location: Path | URL) -> None:\n        \"\"\"Initialise the history entry item.\n\n        Args:\n            history_id: The ID of the item of history.\n            location: The location being added to history.\n        \"\"\"\n        super().__init__(self._as_prompt(location))\n        self.history_id = history_id\n        \"\"\"The ID of the item of history.\"\"\"\n        self.location = location\n        \"\"\"The location for his entry in the history.\"\"\"\n\n    @staticmethod\n    def _as_prompt(location: Path | URL) -> Text:\n        \"\"\"Depict the location as a decorated prompt.\n\n        Args:\n            location: The location to depict.\n\n        Returns:\n            A prompt with icon, etc.\n        \"\"\"\n        if isinstance(location, Path):\n            return Text.from_markup(\n                f\":page_facing_up: [bold]{location.name}[/]\\n[dim]{location.parent}[/]\",\n                overflow=\"ellipsis\",\n            )\n        return Text.from_markup(\n            f\":globe_with_meridians: [bold]{Path(location.path).name}[/]\"\n            f\"\\n[dim]{Path(location.path).parent}\\n{location.host}[/]\",\n            overflow=\"ellipsis\",\n        )", "\n\nclass History(NavigationPane):\n    \"\"\"History navigation pane.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    History {\n        height: 100%;\n    }\n\n    History > OptionList {\n        background: $panel;\n        border: none;\n        height: 1fr;\n    }\n\n    History > OptionList:focus {\n        border: none;\n    }\n    \"\"\"\n\n    BINDINGS = [\n        Binding(\"delete\", \"delete\", \"Delete the history item\"),\n        Binding(\"backspace\", \"clear\", \"Clean the history\"),\n    ]\n    \"\"\"The bindings for the history navigation pane.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialise the history navigation pane.\"\"\"\n        super().__init__(\"History\")\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the child widgets.\"\"\"\n        yield OptionList()\n\n    def set_focus_within(self) -> None:\n        \"\"\"Focus the option list.\"\"\"\n        self.query_one(OptionList).focus(scroll_visible=False)\n\n    def update_from(self, locations: list[Path | URL]) -> None:\n        \"\"\"Update the history from the given list of locations.\n\n        Args:\n            locations: A list of locations to update the history with.\n\n        This call removes any existing history and sets it to the given\n        value.\n        \"\"\"\n        option_list = self.query_one(OptionList).clear_options()\n        for history_id, location in reversed(list(enumerate(locations))):\n            option_list.add_option(Entry(history_id, location))\n\n    class Goto(Message):\n        \"\"\"Message that requests the viewer goes to a given location.\"\"\"\n\n        def __init__(self, location: Path | URL) -> None:\n            \"\"\"Initialise the history goto message.\n\n            Args:\n                location: The location to go to.\n            \"\"\"\n            super().__init__()\n            self.location = location\n            \"\"\"The location to go to.\"\"\"\n\n    def on_option_list_option_selected(self, event: OptionList.OptionSelected) -> None:\n        \"\"\"Handle an entry in the history being selected.\n\n        Args:\n            event: The event to handle.\n        \"\"\"\n        event.stop()\n        assert isinstance(event.option, Entry)\n        self.post_message(self.Goto(event.option.location))\n\n    class Delete(Message):\n        \"\"\"Message that requests the viewer to delete an item of history.\"\"\"\n\n        def __init__(self, history_id: int) -> None:\n            \"\"\"initialise the history delete message.\n\n            args:\n                history_id: The ID of the item of history to delete.\n            \"\"\"\n            super().__init__()\n            self.history_id = history_id\n            \"\"\"The ID of the item of history to delete.\"\"\"\n\n    def delete_history(self, history_id: int, delete_it: bool) -> None:\n        \"\"\"Delete a given history entry.\n\n        Args:\n            history_id: The ID of the item of history to delete.\n            delete_it: Should it be deleted?\n        \"\"\"\n        if delete_it:\n            self.post_message(self.Delete(history_id))\n\n    def action_delete(self) -> None:\n        \"\"\"Delete the highlighted item from history.\"\"\"\n        history = self.query_one(OptionList)\n        if (item := history.highlighted) is not None:\n            assert isinstance(entry := history.get_option_at_index(item), Entry)\n            self.app.push_screen(\n                YesNoDialog(\n                    \"Delete history entry?\",\n                    \"Are you sure you want to delete the history entry?\",\n                ),\n                partial(self.delete_history, entry.history_id),\n            )\n\n    class Clear(Message):\n        \"\"\"Message that requests that the history be cleared.\"\"\"\n\n    def clear_history(self, clear_it: bool) -> None:\n        \"\"\"Perform a history clear.\n\n        Args:\n            clear_it: Should it be cleared?\n        \"\"\"\n        if clear_it:\n            self.post_message(self.Clear())\n\n    def action_clear(self) -> None:\n        \"\"\"Clear out the whole history.\"\"\"\n        self.app.push_screen(\n            YesNoDialog(\n                \"Clear history?\",\n                \"Are you sure you want to clear everything out of history?\",\n            ),\n            self.clear_history,\n        )", ""]}
{"filename": "frogmouth/widgets/navigation_panes/__init__.py", "chunked_list": ["\"\"\"Provides the panes that go into the main navigation area.\"\"\"\n\nfrom .bookmarks import Bookmarks\nfrom .history import History\nfrom .local_files import LocalFiles\nfrom .table_of_contents import TableOfContents\n\n__all__ = [\n    \"Bookmarks\",\n    \"History\",", "    \"Bookmarks\",\n    \"History\",\n    \"LocalFiles\",\n    \"TableOfContents\",\n]\n"]}
{"filename": "frogmouth/widgets/navigation_panes/navigation_pane.py", "chunked_list": ["\"\"\"Provides a base class for all navigation panes.\"\"\"\n\nfrom textual.widgets import TabbedContent, TabPane\nfrom typing_extensions import Self\n\n\nclass NavigationPane(TabPane):\n    \"\"\"Base class for panes within the navigation sidebar.\"\"\"\n\n    def set_focus_within(self) -> None:\n        \"\"\"Set the focus on the correct child within the navigation pane.\"\"\"\n\n    def activate(self) -> Self:\n        \"\"\"Activate the navigation pane.\n\n        Returns:\n            Self.\n        \"\"\"\n        assert self.parent is not None\n        if self.id is not None and isinstance(self.parent.parent, TabbedContent):\n            self.parent.parent.active = self.id\n        return self", ""]}
{"filename": "frogmouth/widgets/navigation_panes/local_files.py", "chunked_list": ["\"\"\"Provides the local files navigation pane.\"\"\"\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Iterable\n\nfrom httpx import URL\nfrom textual.app import ComposeResult\nfrom textual.message import Message", "from textual.app import ComposeResult\nfrom textual.message import Message\nfrom textual.widgets import DirectoryTree\n\nfrom ...utility import maybe_markdown\nfrom .navigation_pane import NavigationPane\n\n\nclass FilteredDirectoryTree(DirectoryTree):  # pylint:disable=too-many-ancestors\n    \"\"\"A `DirectoryTree` filtered for the markdown viewer.\"\"\"\n\n    def filter_paths(self, paths: Iterable[Path]) -> Iterable[Path]:\n        \"\"\"Filter the directory tree for the Markdown viewer.\n\n        Args:\n            paths: The paths to be filtered.\n\n        Returns:\n            The parts filtered for the Markdown viewer.\n\n        The filtered set will include all filesystem entries that aren't\n        hidden (in a Unix sense of hidden) which are either a directory or a\n        file that looks like it could be a Markdown document.\n        \"\"\"\n        try:\n            return [\n                path\n                for path in paths\n                if not path.name.startswith(\".\")\n                and path.is_dir()\n                or (path.is_file() and maybe_markdown(path))\n            ]\n        except PermissionError:\n            return []", "class FilteredDirectoryTree(DirectoryTree):  # pylint:disable=too-many-ancestors\n    \"\"\"A `DirectoryTree` filtered for the markdown viewer.\"\"\"\n\n    def filter_paths(self, paths: Iterable[Path]) -> Iterable[Path]:\n        \"\"\"Filter the directory tree for the Markdown viewer.\n\n        Args:\n            paths: The paths to be filtered.\n\n        Returns:\n            The parts filtered for the Markdown viewer.\n\n        The filtered set will include all filesystem entries that aren't\n        hidden (in a Unix sense of hidden) which are either a directory or a\n        file that looks like it could be a Markdown document.\n        \"\"\"\n        try:\n            return [\n                path\n                for path in paths\n                if not path.name.startswith(\".\")\n                and path.is_dir()\n                or (path.is_file() and maybe_markdown(path))\n            ]\n        except PermissionError:\n            return []", "\n\nclass LocalFiles(NavigationPane):\n    \"\"\"Local file picking navigation pane.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    LocalFiles {\n        height: 100%;\n    }\n\n    LocalFiles > DirectoryTree {\n        background: $panel;\n        width: 1fr;\n    }\n\n    LocalFiles > DirectoryTree:focus .tree--cursor, LocalFiles > DirectoryTree .tree--cursor {\n        background: $accent 50%;\n        color: $text;\n    }\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialise the local files navigation pane.\"\"\"\n        super().__init__(\"Local\")\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the child widgets.\"\"\"\n        yield FilteredDirectoryTree(Path(\"~\").expanduser())\n\n    def chdir(self, path: Path) -> None:\n        \"\"\"Change the filesystem view to the given directory.\n\n        Args:\n            path: The path to change to.\n        \"\"\"\n        self.query_one(FilteredDirectoryTree).path = path\n\n    def set_focus_within(self) -> None:\n        \"\"\"Focus the directory tree..\"\"\"\n        self.query_one(DirectoryTree).focus(scroll_visible=False)\n\n    class Goto(Message):\n        \"\"\"Message that requests the viewer goes to a given location.\"\"\"\n\n        def __init__(self, location: Path | URL) -> None:\n            \"\"\"Initialise the history goto message.\n\n            Args:\n                location: The location to go to.\n            \"\"\"\n            super().__init__()\n            self.location = location\n            \"\"\"The location to go to.\"\"\"\n\n    def on_directory_tree_file_selected(\n        self, event: DirectoryTree.FileSelected\n    ) -> None:\n        \"\"\"Handle a file being selected in the directory tree.\n\n        Args:\n            event: The direct tree selection event.\n        \"\"\"\n        event.stop()\n        self.post_message(self.Goto(Path(event.path)))", ""]}
{"filename": "frogmouth/data/data_directory.py", "chunked_list": ["\"\"\"Provides a function for working out the data directory location.\"\"\"\n\nfrom pathlib import Path\n\nfrom xdg import xdg_data_home\n\nfrom ..utility.advertising import ORGANISATION_NAME, PACKAGE_NAME\n\n\ndef data_directory() -> Path:\n    \"\"\"Get the location of the data directory.\n\n    Returns:\n        The location of the data directory.\n\n    Note:\n        As a side effect, if the directory doesn't exist it will be created.\n    \"\"\"\n    (target_directory := xdg_data_home() / ORGANISATION_NAME / PACKAGE_NAME).mkdir(\n        parents=True, exist_ok=True\n    )\n    return target_directory", "\ndef data_directory() -> Path:\n    \"\"\"Get the location of the data directory.\n\n    Returns:\n        The location of the data directory.\n\n    Note:\n        As a side effect, if the directory doesn't exist it will be created.\n    \"\"\"\n    (target_directory := xdg_data_home() / ORGANISATION_NAME / PACKAGE_NAME).mkdir(\n        parents=True, exist_ok=True\n    )\n    return target_directory", ""]}
{"filename": "frogmouth/data/bookmarks.py", "chunked_list": ["\"\"\"Provides code for saving and loading bookmarks.\"\"\"\n\nfrom __future__ import annotations\n\nfrom json import JSONEncoder, dumps, loads\nfrom pathlib import Path\nfrom typing import Any, NamedTuple\n\nfrom httpx import URL\n", "from httpx import URL\n\nfrom ..utility import is_likely_url\nfrom .data_directory import data_directory\n\n\nclass Bookmark(NamedTuple):\n    \"\"\"A bookmark.\"\"\"\n\n    title: str\n    \"\"\"The title of the bookmark.\"\"\"\n    location: Path | URL\n    \"\"\"The location of the bookmark.\"\"\"", "\n\ndef bookmarks_file() -> Path:\n    \"\"\"Get the location of the bookmarks file.\n\n    Returns:\n        The location of the bookmarks file.\n    \"\"\"\n    return data_directory() / \"bookmarks.json\"\n", "\n\nclass BookmarkEncoder(JSONEncoder):\n    \"\"\"JSON encoder for the bookmark data.\"\"\"\n\n    def default(self, o: object) -> Any:\n        \"\"\"Handle the Path and URL values.\n\n        Args:\n            o: The object to handle.\n\n        Return:\n            The encoded object.\n        \"\"\"\n        return str(o) if isinstance(o, (Path, URL)) else o", "\n\ndef save_bookmarks(bookmarks: list[Bookmark]) -> None:\n    \"\"\"Save the given bookmarks.\n\n    Args:\n        bookmarks: The bookmarks to save.\n    \"\"\"\n    bookmarks_file().write_text(dumps(bookmarks, indent=4, cls=BookmarkEncoder))\n", "\n\ndef load_bookmarks() -> list[Bookmark]:\n    \"\"\"Load the bookmarks.\n\n    Returns:\n        The bookmarks.\n    \"\"\"\n    return (\n        [\n            Bookmark(\n                title, URL(location) if is_likely_url(location) else Path(location)\n            )\n            for (title, location) in loads(bookmarks.read_text())\n        ]\n        if (bookmarks := bookmarks_file()).exists()\n        else []\n    )", ""]}
{"filename": "frogmouth/data/config.py", "chunked_list": ["\"\"\"Provides code for loading/saving configuration.\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import asdict, dataclass, field\nfrom functools import lru_cache\nfrom json import dumps, loads\nfrom pathlib import Path\n\nfrom xdg import xdg_config_home", "\nfrom xdg import xdg_config_home\n\nfrom ..utility.advertising import ORGANISATION_NAME, PACKAGE_NAME\n\n\n@dataclass\nclass Config:\n    \"\"\"The markdown viewer configuration.\"\"\"\n\n    light_mode: bool = False\n    \"\"\"Should we run in light mode?\"\"\"\n\n    markdown_extensions: list[str] = field(default_factory=lambda: [\".md\", \".markdown\"])\n    \"\"\"What Markdown extensions will we look for?\"\"\"\n\n    navigation_left: bool = True\n    \"\"\"Should navigation be docked to the left side of the screen?\"\"\"", "\n\ndef config_file() -> Path:\n    \"\"\"Get the path to the configuration file.\n\n    Returns:\n        The path to the configuration file.\n\n    Note:\n        As a side-effect, the configuration directory will be created if it\n        does not exist.\n    \"\"\"\n    (config_dir := xdg_config_home() / ORGANISATION_NAME / PACKAGE_NAME).mkdir(\n        parents=True, exist_ok=True\n    )\n    return config_dir / \"configuration.json\"", "\n\ndef save_config(config: Config) -> Config:\n    \"\"\"Save the given configuration to storage.\n\n    Args:\n        config: The configuration to save.\n\n    Returns:\n        The configuration.\n    \"\"\"\n    # Ensure any cached copy of the config is cleaned up.\n    load_config.cache_clear()\n    # Dump the given config to storage.\n    config_file().write_text(dumps(asdict(config), indent=4))\n    # Finally, load it up again. This is to make sure that the updated\n    # version is in the cache.\n    return load_config()", "\n\n@lru_cache(maxsize=None)\ndef load_config() -> Config:\n    \"\"\"Load the configuration from storage.\n\n    Returns:\n        The configuration.\n\n    Note:\n        As a side-effect, if the configuration doesn't exist a default one\n        will be saved to storage.\n\n        This function is designed so that it's safe and low-cost to\n        repeatedly call it. The configuration is cached and will only be\n        loaded from storage when necessary.\n    \"\"\"\n    source_file = config_file()\n    return (\n        Config(**loads(source_file.read_text()))\n        if source_file.exists()\n        else save_config(Config())\n    )", ""]}
{"filename": "frogmouth/data/history.py", "chunked_list": ["\"\"\"Provides code for saving and loading the history.\"\"\"\n\nfrom __future__ import annotations\n\nfrom json import JSONEncoder, dumps, loads\nfrom pathlib import Path\nfrom typing import Any\n\nfrom httpx import URL\n", "from httpx import URL\n\nfrom ..utility import is_likely_url\nfrom .data_directory import data_directory\n\n\ndef history_file() -> Path:\n    \"\"\"Get the location of the history file.\n\n    Returns:\n        The location of the history file.\n    \"\"\"\n    return data_directory() / \"history.json\"", "\n\nclass HistoryEncoder(JSONEncoder):\n    \"\"\"JSON encoder for the history data.\"\"\"\n\n    def default(self, o: object) -> Any:\n        \"\"\"Handle the Path and URL values.\n\n        Args:\n            o: The object to handle.\n\n        Return:\n            The encoded object.\n        \"\"\"\n        return str(o) if isinstance(o, (Path, URL)) else o", "\n\ndef save_history(history: list[Path | URL]) -> None:\n    \"\"\"Save the given history.\n\n    Args:\n        history: The history to save.\n    \"\"\"\n    history_file().write_text(dumps(history, indent=4, cls=HistoryEncoder))\n", "\n\ndef load_history() -> list[Path | URL]:\n    \"\"\"Load the history.\n\n    Returns:\n        The history.\n    \"\"\"\n    return (\n        [\n            URL(location) if is_likely_url(location) else Path(location)\n            for location in loads(history.read_text())\n        ]\n        if (history := history_file()).exists()\n        else []\n    )", ""]}
{"filename": "frogmouth/data/__init__.py", "chunked_list": ["\"\"\"Provides tools for saving and loading application data.\"\"\"\n\nfrom .bookmarks import Bookmark, load_bookmarks, save_bookmarks\nfrom .config import Config, load_config, save_config\nfrom .history import load_history, save_history\n\n__all__ = [\n    \"Bookmark\",\n    \"Config\",\n    \"load_bookmarks\",", "    \"Config\",\n    \"load_bookmarks\",\n    \"load_config\",\n    \"load_history\",\n    \"save_bookmarks\",\n    \"save_config\",\n    \"save_history\",\n]\n", ""]}
{"filename": "frogmouth/utility/type_tests.py", "chunked_list": ["\"\"\"Support code for testing files for their potential type.\"\"\"\n\nfrom functools import singledispatch\nfrom pathlib import Path\nfrom typing import Any\n\nfrom httpx import URL\n\nfrom ..data.config import load_config\n", "from ..data.config import load_config\n\n\n@singledispatch\ndef maybe_markdown(resource: Any) -> bool:\n    \"\"\"Does the given resource look like it's a Markdown file?\n\n    Args:\n        resource: The resource to test.\n\n    Returns:\n        `True` if the resources looks like a Markdown file, `False` if not.\n    \"\"\"\n    del resource\n    return False", "\n\n@maybe_markdown.register\ndef _(resource: Path) -> bool:\n    return resource.suffix.lower() in load_config().markdown_extensions\n\n\n@maybe_markdown.register\ndef _(resource: str) -> bool:\n    return maybe_markdown(Path(resource))", "def _(resource: str) -> bool:\n    return maybe_markdown(Path(resource))\n\n\n@maybe_markdown.register\ndef _(resource: URL) -> bool:\n    return maybe_markdown(resource.path)\n\n\ndef is_likely_url(candidate: str) -> bool:\n    \"\"\"Does the given value look something like a URL?\n\n    Args:\n        candidate: The candidate to check.\n\n    Returns:\n        `True` if the string is likely a URL, `False` if not.\n    \"\"\"\n    # Quick and dirty for now.\n    url = URL(candidate)\n    return url.is_absolute_url and url.scheme in (\"http\", \"https\")", "\ndef is_likely_url(candidate: str) -> bool:\n    \"\"\"Does the given value look something like a URL?\n\n    Args:\n        candidate: The candidate to check.\n\n    Returns:\n        `True` if the string is likely a URL, `False` if not.\n    \"\"\"\n    # Quick and dirty for now.\n    url = URL(candidate)\n    return url.is_absolute_url and url.scheme in (\"http\", \"https\")", ""]}
{"filename": "frogmouth/utility/advertising.py", "chunked_list": ["\"\"\"Provides the 'branding' for the application.\"\"\"\n\nfrom typing_extensions import Final\n\nfrom .. import __version__\n\nORGANISATION_NAME: Final[str] = \"textualize\"\n\"\"\"The organisation name to use when creating namespaced resources.\"\"\"\n\nORGANISATION_TITLE: Final[str] = \"Textualize\"", "\nORGANISATION_TITLE: Final[str] = \"Textualize\"\n\"\"\"The organisation title.\"\"\"\n\nORGANISATION_URL: Final[str] = \"https://www.textualize.io/\"\n\"\"\"The organisation URL.\"\"\"\n\nPACKAGE_NAME: Final[str] = \"frogmouth\"\n\"\"\"The name of the package.\"\"\"\n", "\"\"\"The name of the package.\"\"\"\n\nAPPLICATION_TITLE: Final[str] = \"Frogmouth\"\n\"\"\"The title of the application.\"\"\"\n\nUSER_AGENT: Final[str] = f\"{PACKAGE_NAME} v{__version__}\"\n\"\"\"The user agent to use when making web requests.\"\"\"\n\nDISCORD: Final[str] = \"https://discord.gg/Enf6Z3qhVr\"\n\"\"\"The link to the Textualize Discord server.\"\"\"", "DISCORD: Final[str] = \"https://discord.gg/Enf6Z3qhVr\"\n\"\"\"The link to the Textualize Discord server.\"\"\"\n\nTEXTUAL_URL: Final[str] = \"https://textual.textualize.io/\"\n\"\"\"The URL people should visit to find out more about Textual.\"\"\"\n"]}
{"filename": "frogmouth/utility/__init__.py", "chunked_list": ["\"\"\"General utility and support code.\"\"\"\n\nfrom .forge import (\n    build_raw_bitbucket_url,\n    build_raw_codeberg_url,\n    build_raw_github_url,\n    build_raw_gitlab_url,\n)\nfrom .type_tests import is_likely_url, maybe_markdown\n", "from .type_tests import is_likely_url, maybe_markdown\n\n__all__ = [\n    \"build_raw_bitbucket_url\",\n    \"build_raw_codeberg_url\",\n    \"build_raw_github_url\",\n    \"build_raw_gitlab_url\",\n    \"is_likely_url\",\n    \"maybe_markdown\",\n]", "    \"maybe_markdown\",\n]\n"]}
{"filename": "frogmouth/utility/forge.py", "chunked_list": ["\"\"\"Code for getting files from a forge.\"\"\"\n\nfrom __future__ import annotations\n\nfrom httpx import URL, AsyncClient, HTTPStatusError, RequestError\n\nfrom .advertising import USER_AGENT\n\n\nasync def build_raw_forge_url(", "\nasync def build_raw_forge_url(\n    url_format: str,\n    owner: str,\n    repository: str,\n    branch: str | None = None,\n    desired_file: str | None = None,\n) -> URL | None:\n    \"\"\"Attempt to get raw forge URL for the given file.\n", "    \"\"\"Attempt to get raw forge URL for the given file.\n\n    Args:\n        owner: The owner of the repository to look in.\n        repository: The repository to look in.\n        branch: The optional branch to look in.\n        desired_file: Optional name of the file to go looking for.\n\n    Returns:\n        The URL for the file, or `None` if none could be guessed.", "    Returns:\n        The URL for the file, or `None` if none could be guessed.\n\n    If the branch isn't supplied then `main` and `master` will be tested.\n\n    If the target file isn't supplied it's assumed that `README.md` is the\n    target.\n    \"\"\"\n    desired_file = desired_file or \"README.md\"\n    async with AsyncClient() as client:\n        for test_branch in (branch,) if branch else (\"main\", \"master\"):\n            url = url_format.format(\n                owner=owner,\n                repository=repository,\n                branch=test_branch,\n                file=desired_file,\n            )\n            try:\n                response = await client.head(\n                    url,\n                    follow_redirects=True,\n                    headers={\"user-agent\": USER_AGENT},\n                )\n            except RequestError:\n                # We've failed to even make the request, there's no point in\n                # trying to build anything here.\n                return None\n            try:\n                response.raise_for_status()\n                return URL(url)\n            except HTTPStatusError:\n                pass", "    desired_file = desired_file or \"README.md\"\n    async with AsyncClient() as client:\n        for test_branch in (branch,) if branch else (\"main\", \"master\"):\n            url = url_format.format(\n                owner=owner,\n                repository=repository,\n                branch=test_branch,\n                file=desired_file,\n            )\n            try:\n                response = await client.head(\n                    url,\n                    follow_redirects=True,\n                    headers={\"user-agent\": USER_AGENT},\n                )\n            except RequestError:\n                # We've failed to even make the request, there's no point in\n                # trying to build anything here.\n                return None\n            try:\n                response.raise_for_status()\n                return URL(url)\n            except HTTPStatusError:\n                pass", "    return None\n\n\nasync def build_raw_github_url(\n    owner: str,\n    repository: str,\n    branch: str | None = None,\n    desired_file: str | None = None,\n) -> URL | None:\n    \"\"\"Attempt to get the GitHub raw URL for the given file.", ") -> URL | None:\n    \"\"\"Attempt to get the GitHub raw URL for the given file.\n\n    Args:\n        owner: The owner of the repository to look in.\n        repository: The repository to look in.\n        branch: The optional branch to look in.\n        desired_file: Optional name of the file to go looking for.\n\n    Returns:", "\n    Returns:\n        The URL for the file, or `None` if none could be guessed.\n\n    If the branch isn't supplied then `main` and `master` will be tested.\n\n    If the target file isn't supplied it's assumed that `README.md` is the\n    target.\n    \"\"\"\n    return await build_raw_forge_url(", "    \"\"\"\n    return await build_raw_forge_url(\n        \"https://raw.githubusercontent.com/{owner}/{repository}/{branch}/{file}\",\n        owner,\n        repository,\n        branch,\n        desired_file,\n    )\n\n", "\n\nasync def build_raw_gitlab_url(\n    owner: str,\n    repository: str,\n    branch: str | None = None,\n    desired_file: str | None = None,\n) -> URL | None:\n    \"\"\"Attempt to get the GitLab raw URL for the given file.\n", "    \"\"\"Attempt to get the GitLab raw URL for the given file.\n\n    Args:\n        owner: The owner of the repository to look in.\n        repository: The repository to look in.\n        branch: The optional branch to look in.\n        desired_file: Optional name of the file to go looking for.\n\n    Returns:\n        The URL for the file, or `None` if none could be guessed.", "    Returns:\n        The URL for the file, or `None` if none could be guessed.\n\n    If the branch isn't supplied then `main` and `master` will be tested.\n\n    If the target file isn't supplied it's assumed that `README.md` is the\n    target.\n    \"\"\"\n    return await build_raw_forge_url(\n        \"https://gitlab.com/{owner}/{repository}/-/raw/{branch}/{file}\",", "    return await build_raw_forge_url(\n        \"https://gitlab.com/{owner}/{repository}/-/raw/{branch}/{file}\",\n        owner,\n        repository,\n        branch,\n        desired_file,\n    )\n\n\nasync def build_raw_bitbucket_url(", "\nasync def build_raw_bitbucket_url(\n    owner: str,\n    repository: str,\n    branch: str | None = None,\n    desired_file: str | None = None,\n) -> URL | None:\n    \"\"\"Attempt to get the BitBucket raw URL for the given file.\n\n    Args:", "\n    Args:\n        owner: The owner of the repository to look in.\n        repository: The repository to look in.\n        branch: The optional branch to look in.\n        desired_file: Optional name of the file to go looking for.\n\n    Returns:\n        The URL for the file, or `None` if none could be guessed.\n", "        The URL for the file, or `None` if none could be guessed.\n\n    If the branch isn't supplied then `main` and `master` will be tested.\n\n    If the target file isn't supplied it's assumed that `README.md` is the\n    target.\n    \"\"\"\n    return await build_raw_forge_url(\n        \"https://bitbucket.org/{owner}/{repository}/raw/{branch}/{file}\",\n        owner,", "        \"https://bitbucket.org/{owner}/{repository}/raw/{branch}/{file}\",\n        owner,\n        repository,\n        branch,\n        desired_file,\n    )\n\n\nasync def build_raw_codeberg_url(\n    owner: str,", "async def build_raw_codeberg_url(\n    owner: str,\n    repository: str,\n    branch: str | None = None,\n    desired_file: str | None = None,\n) -> URL | None:\n    \"\"\"Attempt to get the Codeberg raw URL for the given file.\n\n    Args:\n        owner: The owner of the repository to look in.", "    Args:\n        owner: The owner of the repository to look in.\n        repository: The repository to look in.\n        branch: The optional branch to look in.\n        desired_file: Optional name of the file to go looking for.\n\n    Returns:\n        The URL for the file, or `None` if none could be guessed.\n\n    If the branch isn't supplied then `main` and `master` will be tested.", "\n    If the branch isn't supplied then `main` and `master` will be tested.\n\n    If the target file isn't supplied it's assumed that `README.md` is the\n    target.\n    \"\"\"\n    return await build_raw_forge_url(\n        \"https://codeberg.org/{owner}/{repository}/raw//branch/{branch}/{file}\",\n        owner,\n        repository,", "        owner,\n        repository,\n        branch,\n        desired_file,\n    )\n"]}
{"filename": "frogmouth/dialogs/yes_no_dialog.py", "chunked_list": ["\"\"\"Provides a dialog for getting a yes/no response from the user.\"\"\"\n\nfrom __future__ import annotations\n\nfrom textual.app import ComposeResult\nfrom textual.binding import Binding\nfrom textual.containers import Center, Horizontal, Vertical\nfrom textual.screen import ModalScreen\nfrom textual.widgets import Button, Static\n", "from textual.widgets import Button, Static\n\n\nclass YesNoDialog(ModalScreen[bool]):\n    \"\"\"A dialog for asking a user a yes/no question.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    YesNoDialog {\n        align: center middle;\n    }\n\n    YesNoDialog > Vertical {\n        background: $panel;\n        height: auto;\n        width: auto;\n        border: thick $primary;\n    }\n\n    YesNoDialog > Vertical > * {\n        width: auto;\n        height: auto;\n    }\n\n    YesNoDialog Static {\n        width: auto;\n    }\n\n    YesNoDialog .spaced {\n        padding: 1;\n    }\n\n    YesNoDialog #question {\n        min-width: 100%;\n        border-top: solid $primary;\n        border-bottom: solid $primary;\n    }\n\n    YesNoDialog Button {\n        margin-right: 1;\n    }\n\n    YesNoDialog #buttons {\n        width: 100%;\n        align-horizontal: right;\n        padding-right: 1;\n    }\n    \"\"\"\n    \"\"\"The default CSS for the yes/no dialog.\"\"\"\n\n    BINDINGS = [\n        Binding(\"left,up\", \"focus_previous\", \"\", show=False),\n        Binding(\"right,down\", \"focus_next\", \"\", show=False),\n        Binding(\"escape\", \"app.pop_screen\", \"\", show=False),\n    ]\n    \"\"\"Bindings for the yes/no dialog.\"\"\"\n\n    def __init__(  # pylint:disable=too-many-arguments\n        self,\n        title: str,\n        question: str,\n        yes_label: str = \"Yes\",\n        no_label: str = \"No\",\n        yes_first: bool = True,\n    ) -> None:\n        \"\"\"Initialise the yes/no dialog.\n\n        Args:\n            requester: The widget requesting the input.\n            title: The title for the dialog.\n            question: The question to ask.\n            yes_label: The optional label for the yes button.\n            no_label: The optional label for the no button.\n            yes_first: Should the yes button come first?\n            cargo: Any cargo value for the question.\n            id: The ID for the dialog.\n        \"\"\"\n        super().__init__()\n        self._title = title\n        \"\"\"The title for the dialog.\"\"\"\n        self._question = question\n        \"\"\"The question to ask the user.\"\"\"\n        self._aye = yes_label\n        \"\"\"The label for the yes button.\"\"\"\n        self._naw = no_label\n        \"\"\"The label for the no button.\"\"\"\n        self._aye_first = yes_first\n        \"\"\"Should the positive button come first?\"\"\"\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the content of the dialog.\"\"\"\n        with Vertical():\n            with Center():\n                yield Static(self._title, classes=\"spaced\")\n            yield Static(self._question, id=\"question\", classes=\"spaced\")\n            with Horizontal(id=\"buttons\"):\n                aye = Button(self._aye, id=\"yes\")\n                naw = Button(self._naw, id=\"no\")\n                if self._aye_first:\n                    aye.variant = \"primary\"\n                    yield aye\n                    yield naw\n                else:\n                    naw.variant = \"primary\"\n                    yield naw\n                    yield aye\n\n    def on_mount(self) -> None:\n        \"\"\"Configure the dialog once the DOM is ready.\"\"\"\n        self.query(Button).first().focus()\n\n    def on_button_pressed(self, event: Button.Pressed) -> None:\n        \"\"\"Handle a button being pressed on the dialog.\n\n        Args:\n            event: The event to handle.\n        \"\"\"\n        self.dismiss(event.button.id == \"yes\")", ""]}
{"filename": "frogmouth/dialogs/help_dialog.py", "chunked_list": ["\"\"\"The main help dialog for the application.\"\"\"\n\nimport webbrowser\n\nfrom textual.app import ComposeResult\nfrom textual.binding import Binding\nfrom textual.containers import Center, Vertical, VerticalScroll\nfrom textual.screen import ModalScreen\nfrom textual.widgets import Button, Markdown\nfrom typing_extensions import Final", "from textual.widgets import Button, Markdown\nfrom typing_extensions import Final\n\nfrom .. import __version__\nfrom ..utility.advertising import APPLICATION_TITLE\n\nHELP: Final[\n    str\n] = f\"\"\"\\\n# {APPLICATION_TITLE} v{__version__} Help", "] = f\"\"\"\\\n# {APPLICATION_TITLE} v{__version__} Help\n\nWelcome to {APPLICATION_TITLE} Help!\n\n{APPLICATION_TITLE} was built with [Textual](https://github.com/Textualize/textual).\n\n\n## Navigation keys\n", "## Navigation keys\n\n| Key | Command |\n| -- | -- |\n| `/` | Focus the address bar (`ctrl+u` to clear address bar) |\n| `Escape` | Return to address bar / clear address bar / quit |\n| `Ctrl+n` | Show/hide the navigation |\n| `Ctrl+b` | Show the bookmarks |\n| `Ctrl+l` | Show the local file browser |\n| `Ctrl+t` | Show the table of contents |", "| `Ctrl+l` | Show the local file browser |\n| `Ctrl+t` | Show the table of contents |\n| `Ctrl+y` | Show the history |\n| `Ctrl+left` | Go backward in history |\n| `Ctrl+right` | Go forward in history |\n\n## General keys\n\n| Key | Command |\n| -- | -- |", "| Key | Command |\n| -- | -- |\n| `Ctrl+d` | Add the current document to the bookmarks |\n| `Ctrl+r` | Reload the current document |\n| `Ctrl+q` | Quit the application |\n| `F1` | This help |\n| `F2` | Details about {APPLICATION_TITLE} |\n| `F10` | Toggle dark/light theme |\n\n## Commands", "\n## Commands\n\nPress `/` or click the address bar, then enter any of the following commands:\n\n| Command | Aliases | Arguments | Command |\n| -- | -- | -- | -- |\n| `about` | `a` | | Show details about the application |\n| `bookmarks` | `b`, `bm` | | Show the bookmarks list |\n| `bitbucket` | `bb` | `<repo-info>` | View a file on BitBucket (see below) |", "| `bookmarks` | `b`, `bm` | | Show the bookmarks list |\n| `bitbucket` | `bb` | `<repo-info>` | View a file on BitBucket (see below) |\n| `codeberg` | `cb` | `<repo-info>` | View a file on Codeberg (see below) |\n| `changelog` | `cl` | | View the Frogmouth ChangeLog |\n| `chdir` | `cd` | `<dir>` | Switch the local file browser to a new directory |\n| `contents` | `c`, `toc` | | Show the table of contents for the document |\n| `discord` | | | Visit the Textualize Discord server |\n| `github` | `gh` | `<repo-info>` | View a file on GitHub (see below) |\n| `gitlab` | `gl` | `<repo-info>` | View a file on GitLab (see below) |\n| `help` | `?` | | Show this document |", "| `gitlab` | `gl` | `<repo-info>` | View a file on GitLab (see below) |\n| `help` | `?` | | Show this document |\n| `history` | `h` | | Show the history |\n| `local` | `l` | | Show the local file browser |\n| `quit` | `q` | | Quit the viewer |\n\n## Git forge quick view\n\nThe git forge quick view command can be used to quickly view a file on a git\nforge such as GitHub or GitLab. Various forms of specifying the repository,", "The git forge quick view command can be used to quickly view a file on a git\nforge such as GitHub or GitLab. Various forms of specifying the repository,\nbranch and file are supported. For example:\n\n- `<owner>`/`<repo>`\n- `<owner>`/`<repo>` `<file>`\n- `<owner>` `<repo>`\n- `<owner>` `<repo>` `<file>`\n- `<owner>`/`<repo>`:`<branch>`\n- `<owner>`/`<repo>`:`<branch>` `<file>`", "- `<owner>`/`<repo>`:`<branch>`\n- `<owner>`/`<repo>`:`<branch>` `<file>`\n- `<owner>` `<repo>`:`<branch>`\n- `<owner>` `<repo>`:`<branch>` `<file>`\n\nAnywhere where `<file>` is omitted it is assumed `README.md` is desired.\n\nAnywhere where `<branch>` is omitted a test is made for the desired file on\nfirst a `main` and then a `master` branch.\n\"\"\"", "first a `main` and then a `master` branch.\n\"\"\"\n\"\"\"The main help text for the application.\"\"\"\n\n\nclass HelpDialog(ModalScreen[None]):\n    \"\"\"Modal dialog that shows the application's help.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    HelpDialog {\n        align: center middle;\n    }\n\n    HelpDialog > Vertical {\n        border: thick $primary 50%;\n        width: 80%;\n        height: 80%;\n        background: $boost;\n    }\n\n    HelpDialog > Vertical > VerticalScroll {\n        height: 1fr;\n        margin: 1 2;\n    }\n\n    HelpDialog > Vertical > Center {\n        padding: 1;\n        height: auto;\n    }\n    \"\"\"\n\n    BINDINGS = [\n        Binding(\"escape,f1\", \"dismiss(None)\", \"\", show=False),\n    ]\n    \"\"\"Bindings for the help dialog.\"\"\"\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the help screen.\"\"\"\n        with Vertical():\n            with VerticalScroll():\n                yield Markdown(HELP)\n            with Center():\n                yield Button(\"Close\", variant=\"primary\")\n\n    def on_mount(self) -> None:\n        \"\"\"Configure the help screen once the DOM is ready.\"\"\"\n        # It seems that some things inside Markdown can still grab focus;\n        # which might not be right. Let's ensure that can't happen here.\n        self.query_one(Markdown).can_focus_children = False\n        self.query_one(\"Vertical > VerticalScroll\").focus()\n\n    def on_button_pressed(self) -> None:\n        \"\"\"React to button press.\"\"\"\n        self.dismiss(None)\n\n    def on_markdown_link_clicked(self, event: Markdown.LinkClicked) -> None:\n        \"\"\"A link was clicked in the help.\n\n        Args:\n            event: The link click event to handle.\n        \"\"\"\n        webbrowser.open(event.href)", ""]}
{"filename": "frogmouth/dialogs/text_dialog.py", "chunked_list": ["\"\"\"Provides a base modal dialog for showing text to the user.\"\"\"\n\nfrom rich.text import TextType\nfrom textual.app import ComposeResult\nfrom textual.binding import Binding\nfrom textual.containers import Center, Vertical\nfrom textual.screen import ModalScreen\nfrom textual.widgets import Button, Static\nfrom textual.widgets._button import ButtonVariant\n", "from textual.widgets._button import ButtonVariant\n\n\nclass TextDialog(ModalScreen[None]):\n    \"\"\"Base modal dialog for showing information.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    TextDialog {\n        align: center middle;\n    }\n\n    TextDialog Center {\n        width: 100%;\n    }\n\n    TextDialog > Vertical {\n        background: $boost;\n        min-width: 30%;\n        width: auto;\n        height: auto;\n        border: round $primary;\n    }\n\n    TextDialog Static {\n        width: auto;\n    }\n\n    TextDialog .spaced {\n        padding: 1 4;\n    }\n\n    TextDialog #message {\n        min-width: 100%;\n    }\n    \"\"\"\n    \"\"\"Default CSS for the base text modal dialog.\"\"\"\n\n    BINDINGS = [\n        Binding(\"escape\", \"dismiss(None)\", \"\", show=False),\n    ]\n    \"\"\"Bindings for the base text modal dialog.\"\"\"\n\n    def __init__(self, title: TextType, message: TextType) -> None:\n        \"\"\"Initialise the dialog.\n\n        Args:\n            title: The title for the dialog.\n            message: The message to show.\n        \"\"\"\n        super().__init__()\n        self._title = title\n        self._message = message\n\n    @property\n    def button_style(self) -> ButtonVariant:\n        \"\"\"The style for the dialog's button.\"\"\"\n        return \"primary\"\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the content of the modal dialog.\"\"\"\n        with Vertical():\n            with Center():\n                yield Static(self._title, classes=\"spaced\")\n            yield Static(self._message, id=\"message\", classes=\"spaced\")\n            with Center(classes=\"spaced\"):\n                yield Button(\"OK\", variant=self.button_style)\n\n    def on_mount(self) -> None:\n        \"\"\"Configure the dialog once the DOM has loaded.\"\"\"\n        self.query_one(Button).focus()\n\n    def on_button_pressed(self) -> None:\n        \"\"\"Handle the OK button being pressed.\"\"\"\n        self.dismiss(None)", ""]}
{"filename": "frogmouth/dialogs/__init__.py", "chunked_list": ["\"\"\"Provides useful dialogs for the application.\"\"\"\n\nfrom .error import ErrorDialog\nfrom .help_dialog import HelpDialog\nfrom .information import InformationDialog\nfrom .input_dialog import InputDialog\nfrom .yes_no_dialog import YesNoDialog\n\n__all__ = [\n    \"ErrorDialog\",", "__all__ = [\n    \"ErrorDialog\",\n    \"InformationDialog\",\n    \"InputDialog\",\n    \"HelpDialog\",\n    \"YesNoDialog\",\n]\n"]}
{"filename": "frogmouth/dialogs/input_dialog.py", "chunked_list": ["\"\"\"Provides a modal dialog for getting a value from the user.\"\"\"\n\nfrom __future__ import annotations\n\nfrom textual import on\nfrom textual.app import ComposeResult\nfrom textual.binding import Binding\nfrom textual.containers import Horizontal, Vertical\nfrom textual.screen import ModalScreen\nfrom textual.widgets import Button, Input, Label", "from textual.screen import ModalScreen\nfrom textual.widgets import Button, Input, Label\n\n\nclass InputDialog(ModalScreen[str]):\n    \"\"\"A modal dialog for getting a single input from the user.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    InputDialog {\n        align: center middle;\n    }\n\n    InputDialog > Vertical {\n        background: $panel;\n        height: auto;\n        width: auto;\n        border: thick $primary;\n    }\n\n    InputDialog > Vertical > * {\n        width: auto;\n        height: auto;\n    }\n\n    InputDialog Input {\n        width: 40;\n        margin: 1;\n    }\n\n    InputDialog Label {\n        margin-left: 2;\n    }\n\n    InputDialog Button {\n        margin-right: 1;\n    }\n\n    InputDialog #buttons {\n        width: 100%;\n        align-horizontal: right;\n        padding-right: 1;\n    }\n    \"\"\"\n    \"\"\"The default styling for the input dialog.\"\"\"\n\n    BINDINGS = [\n        Binding(\"escape\", \"app.pop_screen\", \"\", show=False),\n    ]\n    \"\"\"Bindings for the dialog.\"\"\"\n\n    def __init__(self, prompt: str, initial: str | None = None) -> None:\n        \"\"\"Initialise the input dialog.\n\n        Args:\n            prompt: The prompt for the input.\n            initial: The initial value for the input.\n        \"\"\"\n        super().__init__()\n        self._prompt = prompt\n        \"\"\"The prompt to display for the input.\"\"\"\n        self._initial = initial\n        \"\"\"The initial value to use for the input.\"\"\"\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the child widgets.\"\"\"\n        with Vertical():\n            with Vertical(id=\"input\"):\n                yield Label(self._prompt)\n                yield Input(self._initial or \"\")\n            with Horizontal(id=\"buttons\"):\n                yield Button(\"OK\", id=\"ok\", variant=\"primary\")\n                yield Button(\"Cancel\", id=\"cancel\")\n\n    def on_mount(self) -> None:\n        \"\"\"Set up the dialog once the DOM is ready.\"\"\"\n        self.query_one(Input).focus()\n\n    @on(Button.Pressed, \"#cancel\")\n    def cancel_input(self) -> None:\n        \"\"\"Cancel the input operation.\"\"\"\n        self.app.pop_screen()\n\n    @on(Input.Submitted)\n    @on(Button.Pressed, \"#ok\")\n    def accept_input(self) -> None:\n        \"\"\"Accept and return the input.\"\"\"\n        if value := self.query_one(Input).value.strip():\n            self.dismiss(value)", ""]}
{"filename": "frogmouth/dialogs/information.py", "chunked_list": ["\"\"\"Provides an information dialog.\"\"\"\n\nfrom .text_dialog import TextDialog\n\n\nclass InformationDialog(TextDialog):\n    \"\"\"Modal dialog that shows information.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    InformationDialog > Vertical {\n        border: thick $primary 50%;\n    }\n    \"\"\"", ""]}
{"filename": "frogmouth/dialogs/error.py", "chunked_list": ["\"\"\"Provides an error dialog.\"\"\"\n\nfrom textual.widgets._button import ButtonVariant\n\nfrom .text_dialog import TextDialog\n\n\nclass ErrorDialog(TextDialog):\n    \"\"\"Modal dialog for showing errors.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    ErrorDialog > Vertical {\n        background: $error 15%;\n        border: thick $error 50%;\n    }\n\n    ErrorDialog #message {\n        border-top: solid $panel;\n        border-bottom: solid $panel;\n    }\n    \"\"\"\n\n    @property\n    def button_style(self) -> ButtonVariant:\n        \"\"\"The style for the dialog's button.\"\"\"\n        return \"error\"", ""]}
{"filename": "frogmouth/screens/main.py", "chunked_list": ["\"\"\"The main screen for the application.\"\"\"\n\nfrom __future__ import annotations\n\nfrom functools import partial\nfrom pathlib import Path\nfrom typing import Awaitable, Callable\nfrom webbrowser import open as open_url\n\nfrom httpx import URL", "\nfrom httpx import URL\nfrom textual.app import ComposeResult\nfrom textual.binding import Binding\nfrom textual.containers import Horizontal\nfrom textual.events import Paste\nfrom textual.screen import Screen\nfrom textual.widgets import Footer, Markdown\n\nfrom .. import __version__", "\nfrom .. import __version__\nfrom ..data import load_config, load_history, save_config, save_history\nfrom ..dialogs import ErrorDialog, HelpDialog, InformationDialog, InputDialog\nfrom ..utility import (\n    build_raw_bitbucket_url,\n    build_raw_codeberg_url,\n    build_raw_github_url,\n    build_raw_gitlab_url,\n    is_likely_url,", "    build_raw_gitlab_url,\n    is_likely_url,\n    maybe_markdown,\n)\nfrom ..utility.advertising import (\n    APPLICATION_TITLE,\n    ORGANISATION_NAME,\n    ORGANISATION_TITLE,\n    ORGANISATION_URL,\n    PACKAGE_NAME,", "    ORGANISATION_URL,\n    PACKAGE_NAME,\n    TEXTUAL_URL,\n)\nfrom ..widgets import Navigation, Omnibox, Viewer\nfrom ..widgets.navigation_panes import Bookmarks, History, LocalFiles\n\n\nclass Main(Screen[None]):  # pylint:disable=too-many-public-methods\n    \"\"\"The main screen for the application.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    .focusable {\n        border: blank;\n    }\n\n    .focusable:focus {\n        border: heavy $accent !important;\n    }\n\n\n    Screen Tabs {\n        border: blank;\n        height: 5;\n    }\n\n    Screen Tabs:focus {\n        border: heavy $accent !important;\n        height: 5;\n    }\n\n    Screen TabbedContent TabPane {\n        padding: 0 1;\n        border: blank;\n    }\n\n    Screen TabbedContent TabPane:focus-within {\n        border: heavy $accent !important;\n    }\n    \"\"\"\n\n    BINDINGS = [\n        Binding(\"/,:\", \"omnibox\", \"Omnibox\", show=False),\n        Binding(\"ctrl+b\", \"bookmarks\", \"\", show=False),\n        Binding(\"ctrl+d\", \"bookmark_this\", \"\", show=False),\n        Binding(\"ctrl+l\", \"local_files\", \"\", show=False),\n        Binding(\"ctrl+left\", \"backward\", \"\", show=False),\n        Binding(\"ctrl+right\", \"forward\", \"\", show=False),\n        Binding(\"ctrl+r\", \"reload\", \"\", show=False),\n        Binding(\"ctrl+t\", \"table_of_contents\", \"\", show=False),\n        Binding(\"ctrl+y\", \"history\", \"\", show=False),\n        Binding(\"escape\", \"escape\", \"\", show=False),\n        Binding(\"f1\", \"help\", \"Help\"),\n        Binding(\"f2\", \"about\", \"About\"),\n        Binding(\"ctrl+n\", \"navigation\", \"Navigation\"),\n        Binding(\"ctrl+q\", \"app.quit\", \"Quit\"),\n        Binding(\"f10\", \"toggle_theme\", \"\", show=False),\n    ]\n    \"\"\"The keyboard bindings for the main screen.\"\"\"\n\n    def __init__(self, initial_location: str | None = None) -> None:\n        \"\"\"Initialise the main screen.\n\n        Args:\n            initial_location: The initial location to view.\n        \"\"\"\n        super().__init__()\n        self._initial_location = initial_location\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the main screen.\n\n        Returns:\n            The result of composing the screen.\n        \"\"\"\n        yield Omnibox(classes=\"focusable\")\n        with Horizontal():\n            yield Navigation()\n            yield Viewer(classes=\"focusable\")\n        yield Footer()\n\n    def visit(self, location: Path | URL, remember: bool = True) -> None:\n        \"\"\"Visit the given location.\n\n        Args:\n            location: The location to visit.\n            remember: Should the visit be added to the history?\n        \"\"\"\n        # If the location we've been given looks like it is markdown, be it\n        # locally in the filesystem or out on the web...\n        if maybe_markdown(location):\n            # ...attempt to visit it in the viewer.\n            self.query_one(Viewer).visit(location, remember)\n        elif isinstance(location, Path):\n            # So, it's not Markdown, but it *is* a Path of some sort. If the\n            # resource seems to exist...\n            if location.exists():\n                # ...ask the OS to open it.\n                open_url(f\"file:///{location.absolute()}\")\n            else:\n                # It's a Path but it doesn't exist, there's not much else we\n                # can do with it.\n                self.app.push_screen(\n                    ErrorDialog(\n                        \"Does not exist\",\n                        f\"Unable to open {location} because it does not exist.\",\n                    )\n                )\n        else:\n            # By this point all that's left is it's a URL that, on the\n            # surface, doesn't look like a Markdown file. Let's hand off to\n            # the operating system anyway.\n            open_url(str(location), new=2, autoraise=True)\n\n    async def on_mount(self) -> None:\n        \"\"\"Set up the main screen once the DOM is ready.\"\"\"\n\n        # Currently Textual's Markdown can steal focus, which gets confusing\n        # as it's not obvious *what* is focused. So let's stop it from\n        # allowing the content to get focus.\n        #\n        # https://github.com/Textualize/textual/issues/2380\n        self.query_one(Markdown).can_focus_children = False\n\n        # Load up any history that might be saved.\n        if history := load_history():\n            self.query_one(Viewer).load_history(history)\n\n        # If we've not been tasked to start up looking at a very specific\n        # location (in other words if no location was passed on the command\n        # line), and if there is some history...\n        if self._initial_location is None and history:\n            # ...start up revisiting the last location the user was looking\n            # at.\n            self.query_one(Viewer).visit(history[-1], remember=False)\n            self.query_one(Omnibox).value = str(history[-1])\n        elif self._initial_location is not None:\n            # Seems there is an initial location; so let's start up looking\n            # at that.\n            (omnibox := self.query_one(Omnibox)).value = self._initial_location\n            await omnibox.action_submit()\n\n    def on_navigation_hidden(self) -> None:\n        \"\"\"React to the navigation sidebar being hidden.\"\"\"\n        self.query_one(Viewer).focus()\n\n    def on_omnibox_local_view_command(self, event: Omnibox.LocalViewCommand) -> None:\n        \"\"\"Handle the omnibox asking us to view a particular file.\n\n        Args:\n            event: The local view command event.\n        \"\"\"\n        self.visit(event.path)\n\n    def on_omnibox_remote_view_command(self, event: Omnibox.RemoteViewCommand) -> None:\n        \"\"\"Handle the omnibox asking us to view a particular URL.\n\n        Args:\n            event: The remote view command event.\n        \"\"\"\n        self.visit(event.url)\n\n    def on_omnibox_contents_command(self) -> None:\n        \"\"\"Handle being asked to show the table of contents.\"\"\"\n        self.action_table_of_contents()\n\n    def on_omnibox_local_files_command(self) -> None:\n        \"\"\"Handle being asked to view the local files picker.\"\"\"\n        self.action_local_files()\n\n    def on_omnibox_bookmarks_command(self) -> None:\n        \"\"\"Handle being asked to view the bookmarks.\"\"\"\n        self.action_bookmarks()\n\n    def on_omnibox_local_chdir_command(self, event: Omnibox.LocalChdirCommand) -> None:\n        \"\"\"Handle being asked to view a new directory in the local files picker.\n\n        Args:\n            event: The chdir command event to handle.\n        \"\"\"\n        if not event.target.exists():\n            self.app.push_screen(\n                ErrorDialog(\"No such directory\", f\"{event.target} does not exist.\")\n            )\n        elif not event.target.is_dir():\n            self.app.push_screen(\n                ErrorDialog(\"Not a directory\", f\"{event.target} is not a directory.\")\n            )\n        else:\n            self.query_one(Navigation).jump_to_local_files(event.target)\n\n    def on_omnibox_history_command(self) -> None:\n        \"\"\"Handle being asked to view the history.\"\"\"\n        self.action_history()\n\n    async def _from_forge(\n        self,\n        forge: str,\n        event: Omnibox.ForgeCommand,\n        builder: Callable[[str, str, str | None, str | None], Awaitable[URL | None]],\n    ) -> None:\n        \"\"\"Build a URL for getting a file from a given forge.\n\n        Args:\n            forge: The display name of the forge.\n            event: The event that contains the request information for the file.\n            builder: The function that builds the URL.\n        \"\"\"\n        if url := await builder(\n            event.owner, event.repository, event.branch, event.desired_file\n        ):\n            self.visit(url)\n        else:\n            self.app.push_screen(\n                ErrorDialog(\n                    f\"Unable to work out a {forge} URL\",\n                    f\"After trying a few options it hasn't been possible to work out the {forge} URL.\\n\\n\"\n                    \"Perhaps the file you're after is on an unusual branch, or the spelling is wrong?\",\n                )\n            )\n\n    async def on_omnibox_git_hub_command(self, event: Omnibox.GitHubCommand) -> None:\n        \"\"\"Handle a GitHub file shortcut command.\n\n        Args:\n            event: The GitHub shortcut command event to handle.\n        \"\"\"\n        await self._from_forge(\"GitHub\", event, build_raw_github_url)\n\n    async def on_omnibox_git_lab_command(self, event: Omnibox.GitLabCommand) -> None:\n        \"\"\"Handle a GitLab file shortcut command.\n\n        Args:\n            event: The GitLab shortcut command event to handle.\n        \"\"\"\n        await self._from_forge(\"GitLab\", event, build_raw_gitlab_url)\n\n    async def on_omnibox_bit_bucket_command(\n        self, event: Omnibox.BitBucketCommand\n    ) -> None:\n        \"\"\"Handle a BitBucket shortcut command.\n\n        Args:\n            event: The BitBucket shortcut command event to handle.\n        \"\"\"\n        await self._from_forge(\"BitBucket\", event, build_raw_bitbucket_url)\n\n    async def on_omnibox_codeberg_command(self, event: Omnibox.CodebergCommand) -> None:\n        \"\"\"Handle a Codeberg shortcut command.\n\n        Args:\n            event: The Codeberg shortcut command event to handle.\n        \"\"\"\n        await self._from_forge(\"Codeberg\", event, build_raw_codeberg_url)\n\n    def on_omnibox_about_command(self) -> None:\n        \"\"\"Handle being asked to show the about dialog.\"\"\"\n        self.action_about()\n\n    def on_omnibox_help_command(self) -> None:\n        \"\"\"Handle being asked to show the help document.\"\"\"\n        self.action_help()\n\n    def on_omnibox_quit_command(self) -> None:\n        \"\"\"Handle being asked to quit.\"\"\"\n        self.app.exit()\n\n    def on_local_files_goto(self, event: LocalFiles.Goto) -> None:\n        \"\"\"Visit a local file in the viewer.\n\n        Args:\n            event: The local file visit request event.\n        \"\"\"\n        self.visit(event.location)\n\n    def on_history_goto(self, event: History.Goto) -> None:\n        \"\"\"Handle a request to go to a location from history.\n\n        Args:\n            event: The event to handle.\n        \"\"\"\n        self.visit(\n            event.location, remember=event.location != self.query_one(Viewer).location\n        )\n\n    def on_history_delete(self, event: History.Delete) -> None:\n        \"\"\"Handle a request to delete an item from history.\n\n        Args:\n            event: The event to handle.\n        \"\"\"\n        self.query_one(Viewer).delete_history(event.history_id)\n\n    def on_history_clear(self) -> None:\n        \"\"\"handle a request to clear down all of history.\"\"\"\n        self.query_one(Viewer).clear_history()\n\n    def on_bookmarks_goto(self, event: Bookmarks.Goto) -> None:\n        \"\"\"Handle a request to go to a bookmark.\n\n        Args:\n            event: The event to handle.\n        \"\"\"\n        self.visit(event.bookmark.location)\n\n    def on_viewer_location_changed(self, event: Viewer.LocationChanged) -> None:\n        \"\"\"Update for the location being changed.\n\n        Args:\n            event: The location change event.\n        \"\"\"\n        # Update the omnibox with whatever is appropriate for the new location.\n        self.query_one(Omnibox).visiting = (\n            str(event.viewer.location) if event.viewer.location is not None else \"\"\n        )\n        # Having safely arrived at a new location, that implies that we want\n        # to focus on the viewer.\n        self.query_one(Viewer).focus()\n\n    def on_viewer_history_updated(self, event: Viewer.HistoryUpdated) -> None:\n        \"\"\"Handle the viewer updating the history.\n\n        Args:\n            event: The history update event.\n        \"\"\"\n        self.query_one(Navigation).history.update_from(event.viewer.history.locations)\n        save_history(event.viewer.history.locations)\n\n    def on_markdown_table_of_contents_updated(\n        self, event: Markdown.TableOfContentsUpdated\n    ) -> None:\n        \"\"\"Handle the table of contents of the document being updated.\n\n        Args:\n            event: The table of contents update event to handle.\n        \"\"\"\n        # We don't handle this, the navigation pane does. Bounce the event\n        # over there.\n        self.query_one(Navigation).table_of_contents.on_table_of_contents_updated(event)\n\n    def on_markdown_table_of_contents_selected(\n        self, event: Markdown.TableOfContentsSelected\n    ) -> None:\n        \"\"\"Handle the user selecting something from the table of contents.\n\n        Args:\n            event: The table of contents selection event to handle.\n        \"\"\"\n        self.query_one(Viewer).scroll_to_block(event.block_id)\n\n    def on_markdown_link_clicked(self, event: Markdown.LinkClicked) -> None:\n        \"\"\"Handle a link being clicked in the Markdown document.\n\n        Args:\n            event: The Markdown link click event to handle.\n        \"\"\"\n        # We'll be using the current location to help work out some relative\n        # things.\n        current_location = self.query_one(Viewer).location\n        # If the link we're to handle obviously looks like URL...\n        if is_likely_url(event.href):\n            # ...handle it as such. No point in trying to do anything else.\n            self.visit(URL(event.href))\n        elif isinstance(current_location, URL):\n            # Seems we're currently visiting a remote location, and the href\n            # looks like a simple file path, so let's make a best effort to\n            # visit the file at the remote location.\n            self.visit(current_location.copy_with().join(event.href))\n        elif (local_file := Path(event.href)).exists():\n            # It looks like a local file and it exists...\n            self.visit(local_file)\n        elif (\n            isinstance(current_location, Path)\n            and (local_file := (current_location.parent / Path(event.href)))\n            .absolute()\n            .exists()\n        ):\n            # It looks like a local file, and tested relative to the\n            # document we found it exists in the local filesystem, so let's\n            # assume that's what we're supposed to handle.\n            self.visit(local_file)\n        else:\n            # Yeah, not sure *what* this link is. Rather than silently fail,\n            # let's let the user know we don't know how to process this.\n            self.app.push_screen(\n                ErrorDialog(\n                    \"Unable to handle link\",\n                    f\"Unable to work out how to handle this link:\\n\\n{event.href}\",\n                )\n            )\n\n    def on_paste(self, event: Paste) -> None:\n        \"\"\"Handle a paste event.\n\n        Args:\n            event: The paste event.\n\n        This method is here to capture paste events that look like the name\n        of a local file (later I may add URL support too). The main purpose\n        of this is to handle drag/drop into the terminal.\n        \"\"\"\n        if (candidate_file := Path(event.text)).exists():\n            self.visit(candidate_file)\n\n    def action_navigation(self) -> None:\n        \"\"\"Toggle the availability of the navigation sidebar.\"\"\"\n        self.query_one(Navigation).toggle()\n\n    def action_escape(self) -> None:\n        \"\"\"Process the escape key.\"\"\"\n        # Escape is designed to work backwards out of the application. If\n        # the viewer is focused, the omnibox gets focused, if omnibox has\n        # focus but it isn't empty, it gets emptied, if it's empty we exit\n        # the application. The idea being that folk who use this often want\n        # to build up muscle memory on the keyboard will know to camp on the\n        # escape key until they get to where they want to be.\n        if (omnibox := self.query_one(Omnibox)).has_focus:\n            if omnibox.value:\n                omnibox.value = \"\"\n            else:\n                self.app.exit()\n        else:\n            if self.query(\"Navigation:focus-within\"):\n                self.query_one(Navigation).popped_out = False\n            omnibox.focus()\n\n    def action_omnibox(self) -> None:\n        \"\"\"Jump to the omnibox.\"\"\"\n        self.query_one(Omnibox).focus()\n\n    def action_table_of_contents(self) -> None:\n        \"\"\"Display and focus the table of contents pane.\"\"\"\n        self.query_one(Navigation).jump_to_contents()\n\n    def action_local_files(self) -> None:\n        \"\"\"Display and focus the local files selection pane.\"\"\"\n        self.query_one(Navigation).jump_to_local_files()\n\n    def action_bookmarks(self) -> None:\n        \"\"\"Display and focus the bookmarks selection pane.\"\"\"\n        self.query_one(Navigation).jump_to_bookmarks()\n\n    def action_history(self) -> None:\n        \"\"\"Display and focus the history pane.\"\"\"\n        self.query_one(Navigation).jump_to_history()\n\n    def action_backward(self) -> None:\n        \"\"\"Go backward in the history.\"\"\"\n        self.query_one(Viewer).back()\n\n    def action_forward(self) -> None:\n        \"\"\"Go forward in the history.\"\"\"\n        self.query_one(Viewer).forward()\n\n    def action_help(self) -> None:\n        \"\"\"Show the help.\"\"\"\n        self.app.push_screen(HelpDialog())\n\n    def action_about(self) -> None:\n        \"\"\"Show the about dialog.\"\"\"\n        self.app.push_screen(\n            InformationDialog(\n                f\"{APPLICATION_TITLE} [b dim]v{__version__}\",\n                f\"Built with [@click=app.visit('{TEXTUAL_URL}')]Textual[/] \"\n                f\"by [@click=app.visit('{ORGANISATION_URL}')]{ORGANISATION_TITLE}[/].\\n\\n\"\n                f\"[@click=app.visit('https://github.com/{ORGANISATION_NAME}/{PACKAGE_NAME}')]\"\n                f\"https://github.com/{ORGANISATION_NAME}/{PACKAGE_NAME}[/]\",\n            )\n        )\n\n    def add_bookmark(self, location: Path | URL, bookmark: str) -> None:\n        \"\"\"Handle adding the bookmark.\n\n        Args:\n            location: The location to bookmark.\n            bookmark: The bookmark to add.\n        \"\"\"\n        self.query_one(Navigation).bookmarks.add_bookmark(bookmark, location)\n\n    def action_bookmark_this(self) -> None:\n        \"\"\"Add a bookmark for the currently-viewed file.\"\"\"\n\n        location = self.query_one(Viewer).location\n\n        # Only allow bookmarking if we're actually viewing something that\n        # can be bookmarked.\n        if not isinstance(location, (Path, URL)):\n            self.app.push_screen(\n                ErrorDialog(\n                    \"Not a bookmarkable location\",\n                    \"The current view can't be bookmarked.\",\n                )\n            )\n            return\n\n        # To make a bookmark, we need a title and a location. We've got a\n        # location; let's make the filename the default title.\n        title = (location if isinstance(location, Path) else Path(location.path)).name\n\n        # Give the user a chance to edit the title.\n        self.app.push_screen(\n            InputDialog(\"Bookmark title:\", title),\n            partial(self.add_bookmark, location),\n        )\n\n    def action_toggle_theme(self) -> None:\n        \"\"\"Toggle the light/dark mode theme.\"\"\"\n        config = load_config()\n        config.light_mode = not config.light_mode\n        save_config(config)\n        # pylint:disable=attribute-defined-outside-init\n        self.app.dark = not config.light_mode\n\n    def action_reload(self) -> None:\n        \"\"\"Reload the current document.\"\"\"\n        self.query_one(Viewer).reload()", "class Main(Screen[None]):  # pylint:disable=too-many-public-methods\n    \"\"\"The main screen for the application.\"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    .focusable {\n        border: blank;\n    }\n\n    .focusable:focus {\n        border: heavy $accent !important;\n    }\n\n\n    Screen Tabs {\n        border: blank;\n        height: 5;\n    }\n\n    Screen Tabs:focus {\n        border: heavy $accent !important;\n        height: 5;\n    }\n\n    Screen TabbedContent TabPane {\n        padding: 0 1;\n        border: blank;\n    }\n\n    Screen TabbedContent TabPane:focus-within {\n        border: heavy $accent !important;\n    }\n    \"\"\"\n\n    BINDINGS = [\n        Binding(\"/,:\", \"omnibox\", \"Omnibox\", show=False),\n        Binding(\"ctrl+b\", \"bookmarks\", \"\", show=False),\n        Binding(\"ctrl+d\", \"bookmark_this\", \"\", show=False),\n        Binding(\"ctrl+l\", \"local_files\", \"\", show=False),\n        Binding(\"ctrl+left\", \"backward\", \"\", show=False),\n        Binding(\"ctrl+right\", \"forward\", \"\", show=False),\n        Binding(\"ctrl+r\", \"reload\", \"\", show=False),\n        Binding(\"ctrl+t\", \"table_of_contents\", \"\", show=False),\n        Binding(\"ctrl+y\", \"history\", \"\", show=False),\n        Binding(\"escape\", \"escape\", \"\", show=False),\n        Binding(\"f1\", \"help\", \"Help\"),\n        Binding(\"f2\", \"about\", \"About\"),\n        Binding(\"ctrl+n\", \"navigation\", \"Navigation\"),\n        Binding(\"ctrl+q\", \"app.quit\", \"Quit\"),\n        Binding(\"f10\", \"toggle_theme\", \"\", show=False),\n    ]\n    \"\"\"The keyboard bindings for the main screen.\"\"\"\n\n    def __init__(self, initial_location: str | None = None) -> None:\n        \"\"\"Initialise the main screen.\n\n        Args:\n            initial_location: The initial location to view.\n        \"\"\"\n        super().__init__()\n        self._initial_location = initial_location\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the main screen.\n\n        Returns:\n            The result of composing the screen.\n        \"\"\"\n        yield Omnibox(classes=\"focusable\")\n        with Horizontal():\n            yield Navigation()\n            yield Viewer(classes=\"focusable\")\n        yield Footer()\n\n    def visit(self, location: Path | URL, remember: bool = True) -> None:\n        \"\"\"Visit the given location.\n\n        Args:\n            location: The location to visit.\n            remember: Should the visit be added to the history?\n        \"\"\"\n        # If the location we've been given looks like it is markdown, be it\n        # locally in the filesystem or out on the web...\n        if maybe_markdown(location):\n            # ...attempt to visit it in the viewer.\n            self.query_one(Viewer).visit(location, remember)\n        elif isinstance(location, Path):\n            # So, it's not Markdown, but it *is* a Path of some sort. If the\n            # resource seems to exist...\n            if location.exists():\n                # ...ask the OS to open it.\n                open_url(f\"file:///{location.absolute()}\")\n            else:\n                # It's a Path but it doesn't exist, there's not much else we\n                # can do with it.\n                self.app.push_screen(\n                    ErrorDialog(\n                        \"Does not exist\",\n                        f\"Unable to open {location} because it does not exist.\",\n                    )\n                )\n        else:\n            # By this point all that's left is it's a URL that, on the\n            # surface, doesn't look like a Markdown file. Let's hand off to\n            # the operating system anyway.\n            open_url(str(location), new=2, autoraise=True)\n\n    async def on_mount(self) -> None:\n        \"\"\"Set up the main screen once the DOM is ready.\"\"\"\n\n        # Currently Textual's Markdown can steal focus, which gets confusing\n        # as it's not obvious *what* is focused. So let's stop it from\n        # allowing the content to get focus.\n        #\n        # https://github.com/Textualize/textual/issues/2380\n        self.query_one(Markdown).can_focus_children = False\n\n        # Load up any history that might be saved.\n        if history := load_history():\n            self.query_one(Viewer).load_history(history)\n\n        # If we've not been tasked to start up looking at a very specific\n        # location (in other words if no location was passed on the command\n        # line), and if there is some history...\n        if self._initial_location is None and history:\n            # ...start up revisiting the last location the user was looking\n            # at.\n            self.query_one(Viewer).visit(history[-1], remember=False)\n            self.query_one(Omnibox).value = str(history[-1])\n        elif self._initial_location is not None:\n            # Seems there is an initial location; so let's start up looking\n            # at that.\n            (omnibox := self.query_one(Omnibox)).value = self._initial_location\n            await omnibox.action_submit()\n\n    def on_navigation_hidden(self) -> None:\n        \"\"\"React to the navigation sidebar being hidden.\"\"\"\n        self.query_one(Viewer).focus()\n\n    def on_omnibox_local_view_command(self, event: Omnibox.LocalViewCommand) -> None:\n        \"\"\"Handle the omnibox asking us to view a particular file.\n\n        Args:\n            event: The local view command event.\n        \"\"\"\n        self.visit(event.path)\n\n    def on_omnibox_remote_view_command(self, event: Omnibox.RemoteViewCommand) -> None:\n        \"\"\"Handle the omnibox asking us to view a particular URL.\n\n        Args:\n            event: The remote view command event.\n        \"\"\"\n        self.visit(event.url)\n\n    def on_omnibox_contents_command(self) -> None:\n        \"\"\"Handle being asked to show the table of contents.\"\"\"\n        self.action_table_of_contents()\n\n    def on_omnibox_local_files_command(self) -> None:\n        \"\"\"Handle being asked to view the local files picker.\"\"\"\n        self.action_local_files()\n\n    def on_omnibox_bookmarks_command(self) -> None:\n        \"\"\"Handle being asked to view the bookmarks.\"\"\"\n        self.action_bookmarks()\n\n    def on_omnibox_local_chdir_command(self, event: Omnibox.LocalChdirCommand) -> None:\n        \"\"\"Handle being asked to view a new directory in the local files picker.\n\n        Args:\n            event: The chdir command event to handle.\n        \"\"\"\n        if not event.target.exists():\n            self.app.push_screen(\n                ErrorDialog(\"No such directory\", f\"{event.target} does not exist.\")\n            )\n        elif not event.target.is_dir():\n            self.app.push_screen(\n                ErrorDialog(\"Not a directory\", f\"{event.target} is not a directory.\")\n            )\n        else:\n            self.query_one(Navigation).jump_to_local_files(event.target)\n\n    def on_omnibox_history_command(self) -> None:\n        \"\"\"Handle being asked to view the history.\"\"\"\n        self.action_history()\n\n    async def _from_forge(\n        self,\n        forge: str,\n        event: Omnibox.ForgeCommand,\n        builder: Callable[[str, str, str | None, str | None], Awaitable[URL | None]],\n    ) -> None:\n        \"\"\"Build a URL for getting a file from a given forge.\n\n        Args:\n            forge: The display name of the forge.\n            event: The event that contains the request information for the file.\n            builder: The function that builds the URL.\n        \"\"\"\n        if url := await builder(\n            event.owner, event.repository, event.branch, event.desired_file\n        ):\n            self.visit(url)\n        else:\n            self.app.push_screen(\n                ErrorDialog(\n                    f\"Unable to work out a {forge} URL\",\n                    f\"After trying a few options it hasn't been possible to work out the {forge} URL.\\n\\n\"\n                    \"Perhaps the file you're after is on an unusual branch, or the spelling is wrong?\",\n                )\n            )\n\n    async def on_omnibox_git_hub_command(self, event: Omnibox.GitHubCommand) -> None:\n        \"\"\"Handle a GitHub file shortcut command.\n\n        Args:\n            event: The GitHub shortcut command event to handle.\n        \"\"\"\n        await self._from_forge(\"GitHub\", event, build_raw_github_url)\n\n    async def on_omnibox_git_lab_command(self, event: Omnibox.GitLabCommand) -> None:\n        \"\"\"Handle a GitLab file shortcut command.\n\n        Args:\n            event: The GitLab shortcut command event to handle.\n        \"\"\"\n        await self._from_forge(\"GitLab\", event, build_raw_gitlab_url)\n\n    async def on_omnibox_bit_bucket_command(\n        self, event: Omnibox.BitBucketCommand\n    ) -> None:\n        \"\"\"Handle a BitBucket shortcut command.\n\n        Args:\n            event: The BitBucket shortcut command event to handle.\n        \"\"\"\n        await self._from_forge(\"BitBucket\", event, build_raw_bitbucket_url)\n\n    async def on_omnibox_codeberg_command(self, event: Omnibox.CodebergCommand) -> None:\n        \"\"\"Handle a Codeberg shortcut command.\n\n        Args:\n            event: The Codeberg shortcut command event to handle.\n        \"\"\"\n        await self._from_forge(\"Codeberg\", event, build_raw_codeberg_url)\n\n    def on_omnibox_about_command(self) -> None:\n        \"\"\"Handle being asked to show the about dialog.\"\"\"\n        self.action_about()\n\n    def on_omnibox_help_command(self) -> None:\n        \"\"\"Handle being asked to show the help document.\"\"\"\n        self.action_help()\n\n    def on_omnibox_quit_command(self) -> None:\n        \"\"\"Handle being asked to quit.\"\"\"\n        self.app.exit()\n\n    def on_local_files_goto(self, event: LocalFiles.Goto) -> None:\n        \"\"\"Visit a local file in the viewer.\n\n        Args:\n            event: The local file visit request event.\n        \"\"\"\n        self.visit(event.location)\n\n    def on_history_goto(self, event: History.Goto) -> None:\n        \"\"\"Handle a request to go to a location from history.\n\n        Args:\n            event: The event to handle.\n        \"\"\"\n        self.visit(\n            event.location, remember=event.location != self.query_one(Viewer).location\n        )\n\n    def on_history_delete(self, event: History.Delete) -> None:\n        \"\"\"Handle a request to delete an item from history.\n\n        Args:\n            event: The event to handle.\n        \"\"\"\n        self.query_one(Viewer).delete_history(event.history_id)\n\n    def on_history_clear(self) -> None:\n        \"\"\"handle a request to clear down all of history.\"\"\"\n        self.query_one(Viewer).clear_history()\n\n    def on_bookmarks_goto(self, event: Bookmarks.Goto) -> None:\n        \"\"\"Handle a request to go to a bookmark.\n\n        Args:\n            event: The event to handle.\n        \"\"\"\n        self.visit(event.bookmark.location)\n\n    def on_viewer_location_changed(self, event: Viewer.LocationChanged) -> None:\n        \"\"\"Update for the location being changed.\n\n        Args:\n            event: The location change event.\n        \"\"\"\n        # Update the omnibox with whatever is appropriate for the new location.\n        self.query_one(Omnibox).visiting = (\n            str(event.viewer.location) if event.viewer.location is not None else \"\"\n        )\n        # Having safely arrived at a new location, that implies that we want\n        # to focus on the viewer.\n        self.query_one(Viewer).focus()\n\n    def on_viewer_history_updated(self, event: Viewer.HistoryUpdated) -> None:\n        \"\"\"Handle the viewer updating the history.\n\n        Args:\n            event: The history update event.\n        \"\"\"\n        self.query_one(Navigation).history.update_from(event.viewer.history.locations)\n        save_history(event.viewer.history.locations)\n\n    def on_markdown_table_of_contents_updated(\n        self, event: Markdown.TableOfContentsUpdated\n    ) -> None:\n        \"\"\"Handle the table of contents of the document being updated.\n\n        Args:\n            event: The table of contents update event to handle.\n        \"\"\"\n        # We don't handle this, the navigation pane does. Bounce the event\n        # over there.\n        self.query_one(Navigation).table_of_contents.on_table_of_contents_updated(event)\n\n    def on_markdown_table_of_contents_selected(\n        self, event: Markdown.TableOfContentsSelected\n    ) -> None:\n        \"\"\"Handle the user selecting something from the table of contents.\n\n        Args:\n            event: The table of contents selection event to handle.\n        \"\"\"\n        self.query_one(Viewer).scroll_to_block(event.block_id)\n\n    def on_markdown_link_clicked(self, event: Markdown.LinkClicked) -> None:\n        \"\"\"Handle a link being clicked in the Markdown document.\n\n        Args:\n            event: The Markdown link click event to handle.\n        \"\"\"\n        # We'll be using the current location to help work out some relative\n        # things.\n        current_location = self.query_one(Viewer).location\n        # If the link we're to handle obviously looks like URL...\n        if is_likely_url(event.href):\n            # ...handle it as such. No point in trying to do anything else.\n            self.visit(URL(event.href))\n        elif isinstance(current_location, URL):\n            # Seems we're currently visiting a remote location, and the href\n            # looks like a simple file path, so let's make a best effort to\n            # visit the file at the remote location.\n            self.visit(current_location.copy_with().join(event.href))\n        elif (local_file := Path(event.href)).exists():\n            # It looks like a local file and it exists...\n            self.visit(local_file)\n        elif (\n            isinstance(current_location, Path)\n            and (local_file := (current_location.parent / Path(event.href)))\n            .absolute()\n            .exists()\n        ):\n            # It looks like a local file, and tested relative to the\n            # document we found it exists in the local filesystem, so let's\n            # assume that's what we're supposed to handle.\n            self.visit(local_file)\n        else:\n            # Yeah, not sure *what* this link is. Rather than silently fail,\n            # let's let the user know we don't know how to process this.\n            self.app.push_screen(\n                ErrorDialog(\n                    \"Unable to handle link\",\n                    f\"Unable to work out how to handle this link:\\n\\n{event.href}\",\n                )\n            )\n\n    def on_paste(self, event: Paste) -> None:\n        \"\"\"Handle a paste event.\n\n        Args:\n            event: The paste event.\n\n        This method is here to capture paste events that look like the name\n        of a local file (later I may add URL support too). The main purpose\n        of this is to handle drag/drop into the terminal.\n        \"\"\"\n        if (candidate_file := Path(event.text)).exists():\n            self.visit(candidate_file)\n\n    def action_navigation(self) -> None:\n        \"\"\"Toggle the availability of the navigation sidebar.\"\"\"\n        self.query_one(Navigation).toggle()\n\n    def action_escape(self) -> None:\n        \"\"\"Process the escape key.\"\"\"\n        # Escape is designed to work backwards out of the application. If\n        # the viewer is focused, the omnibox gets focused, if omnibox has\n        # focus but it isn't empty, it gets emptied, if it's empty we exit\n        # the application. The idea being that folk who use this often want\n        # to build up muscle memory on the keyboard will know to camp on the\n        # escape key until they get to where they want to be.\n        if (omnibox := self.query_one(Omnibox)).has_focus:\n            if omnibox.value:\n                omnibox.value = \"\"\n            else:\n                self.app.exit()\n        else:\n            if self.query(\"Navigation:focus-within\"):\n                self.query_one(Navigation).popped_out = False\n            omnibox.focus()\n\n    def action_omnibox(self) -> None:\n        \"\"\"Jump to the omnibox.\"\"\"\n        self.query_one(Omnibox).focus()\n\n    def action_table_of_contents(self) -> None:\n        \"\"\"Display and focus the table of contents pane.\"\"\"\n        self.query_one(Navigation).jump_to_contents()\n\n    def action_local_files(self) -> None:\n        \"\"\"Display and focus the local files selection pane.\"\"\"\n        self.query_one(Navigation).jump_to_local_files()\n\n    def action_bookmarks(self) -> None:\n        \"\"\"Display and focus the bookmarks selection pane.\"\"\"\n        self.query_one(Navigation).jump_to_bookmarks()\n\n    def action_history(self) -> None:\n        \"\"\"Display and focus the history pane.\"\"\"\n        self.query_one(Navigation).jump_to_history()\n\n    def action_backward(self) -> None:\n        \"\"\"Go backward in the history.\"\"\"\n        self.query_one(Viewer).back()\n\n    def action_forward(self) -> None:\n        \"\"\"Go forward in the history.\"\"\"\n        self.query_one(Viewer).forward()\n\n    def action_help(self) -> None:\n        \"\"\"Show the help.\"\"\"\n        self.app.push_screen(HelpDialog())\n\n    def action_about(self) -> None:\n        \"\"\"Show the about dialog.\"\"\"\n        self.app.push_screen(\n            InformationDialog(\n                f\"{APPLICATION_TITLE} [b dim]v{__version__}\",\n                f\"Built with [@click=app.visit('{TEXTUAL_URL}')]Textual[/] \"\n                f\"by [@click=app.visit('{ORGANISATION_URL}')]{ORGANISATION_TITLE}[/].\\n\\n\"\n                f\"[@click=app.visit('https://github.com/{ORGANISATION_NAME}/{PACKAGE_NAME}')]\"\n                f\"https://github.com/{ORGANISATION_NAME}/{PACKAGE_NAME}[/]\",\n            )\n        )\n\n    def add_bookmark(self, location: Path | URL, bookmark: str) -> None:\n        \"\"\"Handle adding the bookmark.\n\n        Args:\n            location: The location to bookmark.\n            bookmark: The bookmark to add.\n        \"\"\"\n        self.query_one(Navigation).bookmarks.add_bookmark(bookmark, location)\n\n    def action_bookmark_this(self) -> None:\n        \"\"\"Add a bookmark for the currently-viewed file.\"\"\"\n\n        location = self.query_one(Viewer).location\n\n        # Only allow bookmarking if we're actually viewing something that\n        # can be bookmarked.\n        if not isinstance(location, (Path, URL)):\n            self.app.push_screen(\n                ErrorDialog(\n                    \"Not a bookmarkable location\",\n                    \"The current view can't be bookmarked.\",\n                )\n            )\n            return\n\n        # To make a bookmark, we need a title and a location. We've got a\n        # location; let's make the filename the default title.\n        title = (location if isinstance(location, Path) else Path(location.path)).name\n\n        # Give the user a chance to edit the title.\n        self.app.push_screen(\n            InputDialog(\"Bookmark title:\", title),\n            partial(self.add_bookmark, location),\n        )\n\n    def action_toggle_theme(self) -> None:\n        \"\"\"Toggle the light/dark mode theme.\"\"\"\n        config = load_config()\n        config.light_mode = not config.light_mode\n        save_config(config)\n        # pylint:disable=attribute-defined-outside-init\n        self.app.dark = not config.light_mode\n\n    def action_reload(self) -> None:\n        \"\"\"Reload the current document.\"\"\"\n        self.query_one(Viewer).reload()", ""]}
{"filename": "frogmouth/screens/__init__.py", "chunked_list": ["\"\"\"The screens for the application.\"\"\"\n\nfrom .main import Main\n\n__all__ = [\"Main\"]\n"]}
{"filename": "frogmouth/app/app.py", "chunked_list": ["\"\"\"The main application class for the viewer.\"\"\"\n\nfrom argparse import ArgumentParser, Namespace\nfrom webbrowser import open as open_url\n\nfrom textual import __version__ as textual_version  # pylint: disable=no-name-in-module\nfrom textual.app import App\n\nfrom .. import __version__\nfrom ..data import load_config", "from .. import __version__\nfrom ..data import load_config\nfrom ..screens import Main\nfrom ..utility.advertising import APPLICATION_TITLE, PACKAGE_NAME\n\n\nclass MarkdownViewer(App[None]):\n    \"\"\"The main application class.\"\"\"\n\n    TITLE = APPLICATION_TITLE\n    \"\"\"The main title for the application.\"\"\"\n\n    def __init__(self, cli_args: Namespace) -> None:\n        \"\"\"Initialise the application.\n\n        Args:\n            cli_args: The command line arguments.\n        \"\"\"\n        super().__init__()\n        self._args = cli_args\n        self.dark = not load_config().light_mode\n\n    def on_mount(self) -> None:\n        \"\"\"Set up the application after the DOM is ready.\"\"\"\n        self.push_screen(Main(\" \".join(self._args.file) if self._args.file else None))\n\n    def action_visit(self, url: str) -> None:\n        \"\"\"Visit the given URL, via the operating system.\n\n        Args:\n            url: The URL to visit.\n        \"\"\"\n        open_url(url)", "\n\ndef get_args() -> Namespace:\n    \"\"\"Parse and return the command line arguments.\n\n    Returns:\n        The result of parsing the arguments.\n    \"\"\"\n\n    # Create the parser object.\n    parser = ArgumentParser(\n        prog=PACKAGE_NAME,\n        description=f\"{APPLICATION_TITLE} -- A Markdown viewer for the terminal.\",\n        epilog=f\"v{__version__}\",\n    )\n\n    # Add --version\n    parser.add_argument(\n        \"-v\",\n        \"--version\",\n        help=\"Show version information.\",\n        action=\"version\",\n        version=f\"%(prog)s {__version__} (Textual v{textual_version})\",\n    )\n\n    # The remainder is the file to view.\n    parser.add_argument(\"file\", help=\"The Markdown file to view\", nargs=\"*\")\n\n    # Finally, parse the command line.\n    return parser.parse_args()", "\n\ndef run() -> None:\n    \"\"\"Run the application.\"\"\"\n    MarkdownViewer(get_args()).run()\n"]}
{"filename": "frogmouth/app/__init__.py", "chunked_list": ["\"\"\"The main application code.\"\"\"\n\nfrom .app import run\n\n__all__ = [\"run\"]\n"]}
