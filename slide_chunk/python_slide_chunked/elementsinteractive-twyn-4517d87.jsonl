{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/conftest.py", "chunked_list": ["import os\n\nimport pytest\n\n\n@pytest.fixture\ndef requirements_txt_file(tmp_path):\n    requirements_txt_file = tmp_path / \"requirements.txt\"\n    requirements_txt_file.write_text(\n        \"\"\"\n        South==1.0.1 --hash=sha256:abcdefghijklmno\n        pycrypto>=2.6\n        \"\"\"\n    )\n    yield requirements_txt_file\n    os.remove(requirements_txt_file)", "\n\n@pytest.fixture\ndef poetry_lock_file_lt_1_5(tmp_path):\n    \"\"\"Poetry lock version < 1.5.\"\"\"\n    poetry_lock_file = tmp_path / \"poetry.lock\"\n    poetry_lock_file.write_text(\n        \"\"\"\n            [[package]]\n            name = \"charset-normalizer\"\n            version = \"3.0.1\"\n            description = \"The Real First Universal Charset Detector. Open, modern and \\\n                actively maintained alternative to Chardet.\"\n            category = \"main\"\n            optional = false\n            python-versions = \"*\"\n\n            [[package]]\n            name = \"flake8\"\n            version = \"5.0.4\"\n            description = \"the modular source code checker: pep8 pyflakes and co\"\n            category = \"dev\"\n            optional = false\n            python-versions = \">=3.6.1\"\n\n            [package.dependencies]\n            mccabe = \">=0.7.0,<0.8.0\"\n\n            [[package]]\n            name = \"mccabe\"\n            version = \"0.7.0\"\n            description = \"McCabe checker, plugin for flake8\"\n            category = \"dev\"\n            optional = false\n            python-versions = \">=3.6\"\n\n            [metadata]\n            lock-version = \"1.1\"\n            python-versions = \"^3.9\"\n            content-hash = \"d518428f67ed390edb669028a3136be9a363472e206d4dec455af35381e\"\n\n            [metadata.files]\n            charset-normalizer = []\n            flake8 = []\n            mccabe = []\n        \"\"\"\n    )\n    yield poetry_lock_file\n    os.remove(poetry_lock_file)", "\n\n@pytest.fixture\ndef poetry_lock_file_ge_1_5(tmp_path):\n    \"\"\"Poetry lock version >= 1.5.\"\"\"\n    poetry_lock_file = tmp_path / \"poetry.lock\"\n    poetry_lock_file.write_text(\n        \"\"\"\n            [[package]]\n            name = \"charset-normalizer\"\n            version = \"3.0.1\"\n            description = \"The Real First Universal Charset Detector. Open, modern and \\\n                actively maintained alternative to Chardet.\"\n            optional = false\n            python-versions = \"*\"\n\n            [[package]]\n            name = \"flake8\"\n            version = \"5.0.4\"\n            description = \"the modular source code checker: pep8 pyflakes and co\"\n            optional = false\n            python-versions = \">=3.6.1\"\n\n            [package.dependencies]\n            mccabe = \">=0.7.0,<0.8.0\"\n\n            [[package]]\n            name = \"mccabe\"\n            version = \"0.7.0\"\n            description = \"McCabe checker, plugin for flake8\"\n            optional = false\n            python-versions = \">=3.6\"\n\n            [metadata]\n            lock-version = \"1.1\"\n            python-versions = \"^3.9\"\n            content-hash = \"d518428f67ed390edb669028a3136be9a363472e206d4dec455af35381e\"\n\n            [metadata.files]\n            charset-normalizer = []\n            flake8 = []\n            mccabe = []\n        \"\"\"\n    )\n    yield poetry_lock_file\n    os.remove(poetry_lock_file)", "\n\n@pytest.fixture\ndef pyproject_toml_file(tmp_path):\n    pyproject_toml = tmp_path / \"pyproject.toml\"\n    pyproject_toml.write_text(\n        \"\"\"\n    [tool.poetry.dependencies]\n    python = \"^3.11\"\n    requests = \"^2.28.2\"\n    dparse = \"^0.6.2\"\n    click = \"^8.1.3\"\n    rich = \"^13.3.1\"\n    rapidfuzz = \"^2.13.7\"\n    regex = \"^2022.10.31\"\n\n    [tool.poetry.scripts]\n    twyn = \"twyn.cli:entry_point\"\n\n    [tool.twyn]\n    dependency_file=\"my_file.txt\"\n    selector_method=\"my_selector\"\n    logging_level=\"debug\"\n    allowlist=[\"boto4\", \"boto2\"]\n\n    \"\"\"\n    )\n    yield pyproject_toml\n    os.remove(pyproject_toml)", ""]}
{"filename": "tests/dependency_parser/__init__.py", "chunked_list": [""]}
{"filename": "tests/dependency_parser/test_dependency_parser.py", "chunked_list": ["from unittest.mock import patch\n\nimport pytest\nfrom twyn.base.exceptions import TwynError\nfrom twyn.dependency_parser import PoetryLockParser, RequirementsTxtParser\nfrom twyn.dependency_parser.abstract_parser import AbstractParser\nfrom twyn.dependency_parser.exceptions import PathIsNotFileError, PathNotFoundError\n\n\nclass TestAbstractParser:\n    class TemporaryParser(AbstractParser):\n        \"\"\"Subclass of AbstractParser to test methods.\"\"\"\n\n        def parse(self) -> set[str]:\n            self._read()\n            return set()\n\n    @patch(\"twyn.dependency_parser.abstract_parser.AbstractParser.raise_for_valid_file\")\n    def test_file_exists_success(self, _mock_raise_for_valid_file):\n        parser = self.TemporaryParser(\"fake_path.txt\")\n        assert parser.file_exists() is True\n\n    @patch(\"twyn.dependency_parser.abstract_parser.AbstractParser.raise_for_valid_file\")\n    def test_file_exists_fail(self, mock_raise_for_valid_file):\n        def raise_twyn_error():\n            raise TwynError\n\n        mock_raise_for_valid_file.side_effect = raise_twyn_error\n        parser = self.TemporaryParser(\"fake_path.txt\")\n        assert parser.file_exists() is False\n\n    @patch(\"pathlib.Path.exists\")\n    @patch(\"pathlib.Path.is_file\")\n    @pytest.mark.parametrize(\n        \"file_exists, is_file, exception\",\n        [[False, False, PathNotFoundError], [True, False, PathIsNotFileError]],\n    )\n    def test_raise_for_valid_file(\n        self, mock_is_file, mock_exists, file_exists, is_file, exception\n    ):\n        mock_exists.return_value = file_exists\n        mock_is_file.return_value = is_file\n\n        with pytest.raises(exception):\n            self.TemporaryParser(\"fake_path\").raise_for_valid_file()", "\nclass TestAbstractParser:\n    class TemporaryParser(AbstractParser):\n        \"\"\"Subclass of AbstractParser to test methods.\"\"\"\n\n        def parse(self) -> set[str]:\n            self._read()\n            return set()\n\n    @patch(\"twyn.dependency_parser.abstract_parser.AbstractParser.raise_for_valid_file\")\n    def test_file_exists_success(self, _mock_raise_for_valid_file):\n        parser = self.TemporaryParser(\"fake_path.txt\")\n        assert parser.file_exists() is True\n\n    @patch(\"twyn.dependency_parser.abstract_parser.AbstractParser.raise_for_valid_file\")\n    def test_file_exists_fail(self, mock_raise_for_valid_file):\n        def raise_twyn_error():\n            raise TwynError\n\n        mock_raise_for_valid_file.side_effect = raise_twyn_error\n        parser = self.TemporaryParser(\"fake_path.txt\")\n        assert parser.file_exists() is False\n\n    @patch(\"pathlib.Path.exists\")\n    @patch(\"pathlib.Path.is_file\")\n    @pytest.mark.parametrize(\n        \"file_exists, is_file, exception\",\n        [[False, False, PathNotFoundError], [True, False, PathIsNotFileError]],\n    )\n    def test_raise_for_valid_file(\n        self, mock_is_file, mock_exists, file_exists, is_file, exception\n    ):\n        mock_exists.return_value = file_exists\n        mock_is_file.return_value = is_file\n\n        with pytest.raises(exception):\n            self.TemporaryParser(\"fake_path\").raise_for_valid_file()", "\n\nclass TestRequirementsTxtParser:\n    def test_parse_requirements_txt_file(self, requirements_txt_file):\n        parser = RequirementsTxtParser(file_path=requirements_txt_file)\n        assert parser.parse() == {\"South\", \"pycrypto\"}\n\n\nclass TestPoetryLockParser:\n    def test_parse_poetry_lock_file_lt_1_5(self, poetry_lock_file_lt_1_5):\n        parser = PoetryLockParser(file_path=poetry_lock_file_lt_1_5)\n        assert parser.parse() == {\"charset-normalizer\", \"flake8\", \"mccabe\"}\n\n    def test_parse_poetry_lock_file_ge_1_5(self, poetry_lock_file_ge_1_5):\n        parser = PoetryLockParser(file_path=poetry_lock_file_ge_1_5)\n        assert parser.parse() == {\"charset-normalizer\", \"flake8\", \"mccabe\"}", "class TestPoetryLockParser:\n    def test_parse_poetry_lock_file_lt_1_5(self, poetry_lock_file_lt_1_5):\n        parser = PoetryLockParser(file_path=poetry_lock_file_lt_1_5)\n        assert parser.parse() == {\"charset-normalizer\", \"flake8\", \"mccabe\"}\n\n    def test_parse_poetry_lock_file_ge_1_5(self, poetry_lock_file_ge_1_5):\n        parser = PoetryLockParser(file_path=poetry_lock_file_ge_1_5)\n        assert parser.parse() == {\"charset-normalizer\", \"flake8\", \"mccabe\"}\n", ""]}
{"filename": "tests/dependency_parser/test_dependency_selector.py", "chunked_list": ["from unittest.mock import patch\n\nimport pytest\nfrom twyn.dependency_parser import PoetryLockParser, RequirementsTxtParser\nfrom twyn.dependency_parser.dependency_selector import DependencySelector\nfrom twyn.dependency_parser.exceptions import (\n    MultipleParsersError,\n    NoMatchingParserError,\n)\n", ")\n\n\nclass TestDependencySelector:\n    @patch(\"twyn.dependency_parser.poetry_lock.PoetryLockParser.file_exists\")\n    @patch(\"twyn.dependency_parser.requirements_txt.RequirementsTxtParser.file_exists\")\n    @patch(\"twyn.dependency_parser.abstract_parser.AbstractParser.raise_for_valid_file\")\n    @patch(\n        \"twyn.dependency_parser.dependency_selector.DependencySelector._raise_for_selected_parsers\"\n    )\n    @pytest.mark.parametrize(\n        \"file_name, requirements_exists, poetry_exists, parser_obj\",\n        [\n            (None, True, False, RequirementsTxtParser),  # auto detect requirements.txt\n            (None, False, True, PoetryLockParser),  # auto detect poetry.lock\n            (\n                \"requirements.txt\",\n                None,\n                None,\n                RequirementsTxtParser,\n            ),  # because file is specified, we won't autocheck\n            (\"poetry.lock\", None, None, PoetryLockParser),\n            (\"/some/path/poetry.lock\", None, None, PoetryLockParser),\n            (\"/some/path/requirements.txt\", None, None, RequirementsTxtParser),\n        ],\n    )\n    def test_get_dependency_parser(\n        self,\n        _raise_for_selected_parsers,\n        _raise_for_valid_file,\n        req_exists,\n        poet_exists,\n        file_name,\n        requirements_exists,\n        poetry_exists,\n        parser_obj,\n    ):\n        req_exists.return_value = requirements_exists\n        poet_exists.return_value = poetry_exists\n        parser = DependencySelector(file_name).get_dependency_parser()\n        assert isinstance(parser, parser_obj)\n\n    @pytest.mark.parametrize(\n        \"exists, exception\",\n        [(True, MultipleParsersError), (False, NoMatchingParserError)],\n    )\n    @patch(\"twyn.dependency_parser.abstract_parser.AbstractParser.file_exists\")\n    def test_auto_detect_dependency_file_parser_exceptions(\n        self, file_exists, exists, exception\n    ):\n        file_exists.return_value = exists\n        with pytest.raises(exception):\n            DependencySelector().get_dependency_parser()\n\n    @pytest.mark.parametrize(\"file_name\", [\"unknown.txt\", \"\"])\n    def test_get_dependency_file_parser_unknown_file_type(self, file_name):\n        with pytest.raises(NoMatchingParserError):\n            DependencySelector(file_name).get_dependency_file_parser_from_file_name()", ""]}
{"filename": "tests/trusted_packages/test_references.py", "chunked_list": ["from contextlib import contextmanager\nfrom unittest.mock import Mock, call, patch\n\nimport pytest\nimport requests\nfrom pyparsing import Iterable, Iterator\nfrom twyn.trusted_packages import TopPyPiReference\nfrom twyn.trusted_packages.exceptions import (\n    EmptyPackagesListError,\n    InvalidJSONError,", "    EmptyPackagesListError,\n    InvalidJSONError,\n    InvalidPyPiFormatError,\n)\nfrom twyn.trusted_packages.references import AbstractPackageReference\n\n\n@contextmanager\ndef patch_pypi_requests_get(packages: Iterable[str]) -> Iterator[Mock]:\n    \"\"\"Patcher of `requests.get` for Top PyPi list.\n\n    Replaces call with the output you would get from downloading the top PyPi packages list.\n    \"\"\"\n    json_response = {\"rows\": [{\"project\": name} for name in packages]}\n\n    with patch(\"requests.get\") as mock_get:\n        mock_get.return_value.json.return_value = json_response\n\n        yield mock_get", "def patch_pypi_requests_get(packages: Iterable[str]) -> Iterator[Mock]:\n    \"\"\"Patcher of `requests.get` for Top PyPi list.\n\n    Replaces call with the output you would get from downloading the top PyPi packages list.\n    \"\"\"\n    json_response = {\"rows\": [{\"project\": name} for name in packages]}\n\n    with patch(\"requests.get\") as mock_get:\n        mock_get.return_value.json.return_value = json_response\n\n        yield mock_get", "\n\nclass TestAbstractPackageReference:\n    class HardcodedPackageReference(AbstractPackageReference):\n        \"\"\"Returns always the same packages, used for testing the interface.\"\"\"\n\n        def get_packages(self) -> set[str]:\n            return {\"foo\", \"bar\"}\n\n    def test_get_packages(self):\n        assert self.HardcodedPackageReference().get_packages() == {\"foo\", \"bar\"}", "\n\nclass TestTopPyPiReference:\n    @patch_pypi_requests_get(packages=[\"boto3\", \"urllib3\", \"requests\"])\n    def test_get_trusted_packages(self):\n        top_pypi = TopPyPiReference(source=\"foo\")\n\n        assert top_pypi.get_packages() == {\"boto3\", \"urllib3\", \"requests\"}\n\n    def test__parse_no_rows(self):\n        data = {\"bananas\": 5}\n        top_pypi = TopPyPiReference(source=\"foo\")\n\n        with pytest.raises(InvalidPyPiFormatError, match=\"Invalid JSON format.\"):\n            top_pypi._parse(data)\n\n    def test_empty_packages_list_exception(self):\n        with pytest.raises(\n            EmptyPackagesListError,\n            match=\"Downloaded packages list is empty\",\n        ):\n            TopPyPiReference._parse({\"rows\": []})\n\n    def test__parse_retrieves_package_names(self):\n        data = {\"rows\": [{\"project\": \"boto3\"}, {\"project\": \"requests\"}]}\n        top_pypi = TopPyPiReference(source=\"foo\")\n\n        assert top_pypi._parse(data) == {\"boto3\", \"requests\"}\n\n    @pytest.mark.parametrize(\"source\", [\"foo.com\", \"bar.com\"])\n    def test_can_use_different_pypi_sources(self, source):\n        top_pypi = TopPyPiReference(source=source)\n\n        with patch_pypi_requests_get(packages=[\"foo\"]) as mock_get:\n            top_pypi.get_packages()\n\n        assert mock_get.call_args_list == [call(source)]\n\n    @patch(\"requests.get\")\n    def test__download_json_exception(self, mock_get):\n        mock_get.return_value.json.side_effect = requests.exceptions.JSONDecodeError(\n            \"This exception will be mapped and never shown\", \"\", 1\n        )\n        top_pypi = TopPyPiReference(source=\"foo\")\n\n        with pytest.raises(\n            InvalidJSONError,\n            match=\"Could not json decode the downloaded packages list\",\n        ):\n            top_pypi._download()\n\n    @patch_pypi_requests_get(packages=[\"boto3\", \"requests\"])\n    def test__download(self):\n        top_pypi = TopPyPiReference(source=\"foo\")\n\n        assert top_pypi._download() == {\n            \"rows\": [\n                {\"project\": \"boto3\"},\n                {\"project\": \"requests\"},\n            ]\n        }", ""]}
{"filename": "tests/trusted_packages/__init__.py", "chunked_list": [""]}
{"filename": "tests/trusted_packages/test_selectors.py", "chunked_list": ["import pytest\nfrom twyn.trusted_packages.exceptions import CharacterNotInMatrixError\nfrom twyn.trusted_packages.selectors import (\n    AllSimilar,\n    FirstLetterExact,\n    FirstLetterNearbyInKeyboard,\n)\n\nNAMES = {\"f\": {\"foo\", \"ffoo\"}, \"b\": {\"bar\"}, \"z\": {\"zoo\"}, \"d\": {\"dellows\"}}\n", "NAMES = {\"f\": {\"foo\", \"ffoo\"}, \"b\": {\"bar\"}, \"z\": {\"zoo\"}, \"d\": {\"dellows\"}}\n\n\nclass TestFirstLetterExact:\n    def test_select_similar_names(self):\n        selector = FirstLetterExact()\n        assert set(selector.select_similar_names(NAMES, \"fellows\")) == {\n            \"foo\",\n            \"ffoo\",\n        }", "\n\nclass TestFirstLetterNearbyInKeyboard:\n    def test_select_similar_names(self):\n        selector = FirstLetterNearbyInKeyboard()\n        assert set(selector.select_similar_names(NAMES, \"fellows\")) == {\n            \"foo\",\n            \"ffoo\",\n            \"dellows\",\n        }\n\n    def test__get_candidate_characters(self):\n        assert FirstLetterNearbyInKeyboard._get_candidate_characters(\"c\") == [\n            \"d\",\n            \"f\",\n            \"x\",\n            \"v\",\n            \"c\",\n        ]\n\n    def test_character_not_in_matrix(self):\n        with pytest.raises(\n            CharacterNotInMatrixError,\n            match=\"Character '.' not supported\",\n        ):\n            FirstLetterNearbyInKeyboard._get_candidate_characters(\".\")", "\n\nclass TestAllSimilar:\n    def test_select_similar_names(self):\n        selector = AllSimilar()\n        assert set(selector.select_similar_names(NAMES, \"fellows\")) == {\n            \"foo\",\n            \"ffoo\",\n            \"dellows\",\n            \"bar\",\n            \"zoo\",\n        }", ""]}
{"filename": "tests/trusted_packages/test_trusted_packages.py", "chunked_list": ["from unittest.mock import Mock\n\nimport pytest\nfrom twyn.similarity.algorithm import (\n    EditDistance,\n    SimilarityThreshold,\n)\nfrom twyn.trusted_packages.selectors import (\n    FirstLetterExact,\n    FirstLetterNearbyInKeyboard,", "    FirstLetterExact,\n    FirstLetterNearbyInKeyboard,\n)\nfrom twyn.trusted_packages.trusted_packages import (\n    TrustedPackages,\n    TyposquatCheckResult,\n)\n\n\nclass TestTrustedPackages:\n    @pytest.mark.parametrize(\n        \"package_name, is_a_trusted_package\",\n        [(\"foo\", True), (\"FOO\", False), (\"asdf\", False)],\n    )\n    def test_can_check_package_is_trusted(\n        self, package_name: str, is_a_trusted_package: bool\n    ):\n        trusted_packages = TrustedPackages(\n            names={\"foo\", \"bar\"},\n            algorithm=Mock(),\n            selector=Mock(),\n            threshold_class=Mock(),\n        )\n        assert (package_name in trusted_packages) is is_a_trusted_package\n\n    def test_tree_representation(self):\n        trusted_packages = TrustedPackages(\n            names={\"foo\", \"ffoo\", \"bar\", \"zoo\"},\n            algorithm=Mock(),\n            selector=Mock(),\n            threshold_class=Mock(),\n        )\n        assert trusted_packages.names == {\n            \"f\": {\"foo\", \"ffoo\"},\n            \"b\": {\"bar\"},\n            \"z\": {\"zoo\"},\n        }\n\n    @pytest.mark.parametrize(\n        \"package_name, trusted_packages, selector, matches\",\n        [\n            # First letter exact\n            (\n                \"foo\",\n                {\"foo\"},\n                FirstLetterExact(),\n                [],\n            ),  # shares first letter, distance is 0, below threshold\n            (\n                \"fooo\",\n                {\"foo\"},\n                FirstLetterExact(),\n                [\"foo\"],\n            ),  # shares first letter, distance is 1, inside threshold\n            (\n                \"foooo\",\n                {\"foo\"},\n                FirstLetterExact(),\n                [],\n            ),  # shares first letter, distance is 2, above threshold\n            (\n                \"numpy\",\n                {\"lumpy\"},\n                FirstLetterExact(),\n                [],\n            ),  # distance is 1, inside threshold, but start with different letter\n            (\n                \"abcdef\",\n                {\"abcdefgh\"},\n                FirstLetterExact(),\n                [\"abcdefgh\"],\n            ),  # distance is 2, inside threshold (because it's a longer word)\n            # Nearby letters\n            (\n                \"numpy\",\n                {\"numpy\"},\n                FirstLetterNearbyInKeyboard(),\n                [],\n            ),  # distance is 0, outside threshold.\n            (\n                \"lumpy\",\n                {\"numpy\"},\n                FirstLetterNearbyInKeyboard(),\n                [],\n            ),  # distance is 1, inside threshold. First letter is changed but not nearby\n            (\n                \"mumpy\",\n                {\"numpy\"},\n                FirstLetterNearbyInKeyboard(),\n                [\"numpy\"],\n            ),  # distance is 1, inside threshold. First letter is changed and nearby\n            (\n                \"mumpyy\",\n                {\"numpy\"},\n                FirstLetterNearbyInKeyboard(),\n                [\"numpy\"],\n            ),  # distance is 2, inside threshold. First letter is changed and nearby\n            (\n                \"rest_framework\",\n                {\"erst_framweork\"},\n                FirstLetterNearbyInKeyboard(),\n                [\"erst_framweork\"],\n            ),  # distance is 2, inside threshold (cause it's a long word). First letter is changed and nearby.\n        ],\n    )\n    def test_get_typosquat(self, package_name, trusted_packages, selector, matches):\n        trusted_packages = TrustedPackages(\n            names=trusted_packages,\n            algorithm=EditDistance(),\n            selector=selector,\n            threshold_class=SimilarityThreshold,\n        )\n\n        assert trusted_packages.get_typosquat(\n            package_name=package_name\n        ) == TyposquatCheckResult(\n            candidate_dependency=package_name, similar_dependencies=matches\n        )", "\nclass TestTrustedPackages:\n    @pytest.mark.parametrize(\n        \"package_name, is_a_trusted_package\",\n        [(\"foo\", True), (\"FOO\", False), (\"asdf\", False)],\n    )\n    def test_can_check_package_is_trusted(\n        self, package_name: str, is_a_trusted_package: bool\n    ):\n        trusted_packages = TrustedPackages(\n            names={\"foo\", \"bar\"},\n            algorithm=Mock(),\n            selector=Mock(),\n            threshold_class=Mock(),\n        )\n        assert (package_name in trusted_packages) is is_a_trusted_package\n\n    def test_tree_representation(self):\n        trusted_packages = TrustedPackages(\n            names={\"foo\", \"ffoo\", \"bar\", \"zoo\"},\n            algorithm=Mock(),\n            selector=Mock(),\n            threshold_class=Mock(),\n        )\n        assert trusted_packages.names == {\n            \"f\": {\"foo\", \"ffoo\"},\n            \"b\": {\"bar\"},\n            \"z\": {\"zoo\"},\n        }\n\n    @pytest.mark.parametrize(\n        \"package_name, trusted_packages, selector, matches\",\n        [\n            # First letter exact\n            (\n                \"foo\",\n                {\"foo\"},\n                FirstLetterExact(),\n                [],\n            ),  # shares first letter, distance is 0, below threshold\n            (\n                \"fooo\",\n                {\"foo\"},\n                FirstLetterExact(),\n                [\"foo\"],\n            ),  # shares first letter, distance is 1, inside threshold\n            (\n                \"foooo\",\n                {\"foo\"},\n                FirstLetterExact(),\n                [],\n            ),  # shares first letter, distance is 2, above threshold\n            (\n                \"numpy\",\n                {\"lumpy\"},\n                FirstLetterExact(),\n                [],\n            ),  # distance is 1, inside threshold, but start with different letter\n            (\n                \"abcdef\",\n                {\"abcdefgh\"},\n                FirstLetterExact(),\n                [\"abcdefgh\"],\n            ),  # distance is 2, inside threshold (because it's a longer word)\n            # Nearby letters\n            (\n                \"numpy\",\n                {\"numpy\"},\n                FirstLetterNearbyInKeyboard(),\n                [],\n            ),  # distance is 0, outside threshold.\n            (\n                \"lumpy\",\n                {\"numpy\"},\n                FirstLetterNearbyInKeyboard(),\n                [],\n            ),  # distance is 1, inside threshold. First letter is changed but not nearby\n            (\n                \"mumpy\",\n                {\"numpy\"},\n                FirstLetterNearbyInKeyboard(),\n                [\"numpy\"],\n            ),  # distance is 1, inside threshold. First letter is changed and nearby\n            (\n                \"mumpyy\",\n                {\"numpy\"},\n                FirstLetterNearbyInKeyboard(),\n                [\"numpy\"],\n            ),  # distance is 2, inside threshold. First letter is changed and nearby\n            (\n                \"rest_framework\",\n                {\"erst_framweork\"},\n                FirstLetterNearbyInKeyboard(),\n                [\"erst_framweork\"],\n            ),  # distance is 2, inside threshold (cause it's a long word). First letter is changed and nearby.\n        ],\n    )\n    def test_get_typosquat(self, package_name, trusted_packages, selector, matches):\n        trusted_packages = TrustedPackages(\n            names=trusted_packages,\n            algorithm=EditDistance(),\n            selector=selector,\n            threshold_class=SimilarityThreshold,\n        )\n\n        assert trusted_packages.get_typosquat(\n            package_name=package_name\n        ) == TyposquatCheckResult(\n            candidate_dependency=package_name, similar_dependencies=matches\n        )", ""]}
{"filename": "tests/main/test_main.py", "chunked_list": ["from unittest.mock import Mock, call, patch\n\nimport pytest\nfrom twyn.base.constants import AvailableLoggingLevels\nfrom twyn.dependency_parser import RequirementsTxtParser\nfrom twyn.main import (\n    check_dependencies,\n    get_configuration,\n    get_logging_level,\n    get_parsed_dependencies,", "    get_logging_level,\n    get_parsed_dependencies,\n)\n\n\n@pytest.mark.usefixtures(\"disable_track\")\nclass TestCheckDependencies:\n    @pytest.mark.parametrize(\n        \"selector_method, dependency_file, verbosity, config, expected_args, log_level\",\n        [\n            (\n                \"requirements.txt\",\n                \"first-letter\",\n                AvailableLoggingLevels.info,\n                {\n                    \"logging_level\": \"WARNING\",\n                    \"selector_method\": \"nearby-letter\",\n                    \"dependency_file\": \"poetry.lock\",\n                    \"allowlist\": {\"boto4\", \"boto2\"},\n                },\n                [\"first-letter\", \"requirements.txt\", {\"boto4\", \"boto2\"}],\n                AvailableLoggingLevels.info,\n            ),\n            (\n                None,\n                None,\n                AvailableLoggingLevels.none,\n                {\n                    \"logging_level\": \"debug\",\n                    \"selector_method\": \"nearby-letter\",\n                    \"dependency_file\": \"poetry.lock\",\n                    \"allowlist\": {\"boto4\", \"boto2\"},\n                },\n                [\"poetry.lock\", \"nearby-letter\", {\"boto4\", \"boto2\"}],\n                AvailableLoggingLevels.debug,\n            ),\n            (\n                None,\n                None,\n                AvailableLoggingLevels.none,\n                {\n                    \"logging_level\": None,\n                    \"selector_method\": None,\n                    \"dependency_file\": None,\n                    \"allowlist\": set(),\n                },\n                [None, \"all\", set()],\n                AvailableLoggingLevels.warning,\n            ),\n            (\n                None,\n                \"requirements.txt\",\n                AvailableLoggingLevels.debug,\n                {\n                    \"logging_level\": \"INFO\",\n                    \"selector_method\": None,\n                    \"dependency_file\": \"poetry.lock\",\n                    \"allowlist\": set(),\n                },\n                [\"requirements.txt\", \"all\", set()],\n                AvailableLoggingLevels.debug,\n            ),\n        ],\n    )\n    @patch(\"twyn.main.set_logging_level\")\n    def test_options_priorities_assignation(\n        self,\n        mock_logging_level,\n        selector_method,\n        dependency_file,\n        verbosity,\n        config,\n        expected_args,\n        log_level,\n    ):\n        \"\"\"\n        Checks that the configuration values are picked accordingly to the priority they have.\n\n        From more relevant to less:\n        1. command line\n        2. config file\n        3. default values\n\n        \"\"\"\n        with patch(\"twyn.main.ConfigHandler\", return_value=Mock(**config)):\n            config = get_configuration(\n                dependency_file=dependency_file,\n                config_file=None,\n                selector_method=selector_method,\n                verbosity=verbosity,\n            )\n        assert config.dependency_file == expected_args[0]\n        assert config.selector_method == expected_args[1]\n        assert config.allowlist == expected_args[2]\n\n        assert mock_logging_level.call_args == call(log_level)\n\n    @pytest.mark.parametrize(\n        \"passed_logging_level, config, logging_level\",\n        [\n            [AvailableLoggingLevels.none, None, AvailableLoggingLevels.warning],\n            [AvailableLoggingLevels.info, None, AvailableLoggingLevels.info],\n            [AvailableLoggingLevels.debug, None, AvailableLoggingLevels.debug],\n            [AvailableLoggingLevels.none, \"debug\", AvailableLoggingLevels.debug],\n        ],\n    )\n    def test_logging_level(self, passed_logging_level, config, logging_level):\n        log_level = get_logging_level(\n            logging_level=passed_logging_level,\n            config_logging_level=config,\n        )\n        assert log_level == logging_level\n\n    @pytest.mark.parametrize(\n        \"package_name\",\n        (\n            \"my.package\",\n            \"my-package\",\n            \"my_package\",\n            \"My.Package\",\n        ),\n    )\n    @patch(\"twyn.main.TopPyPiReference\")\n    @patch(\"twyn.main.get_parsed_dependencies\")\n    def test_check_dependencies_detects_typosquats(\n        self, mock_get_parsed_dependencies, mock_top_pypi_reference, package_name\n    ):\n        mock_top_pypi_reference.return_value.get_packages.return_value = {\"mypackage\"}\n        mock_get_parsed_dependencies.return_value = {package_name}\n\n        error = check_dependencies(\n            config_file=None,\n            dependency_file=None,\n            selector_method=\"first-letter\",\n        )\n\n        assert error is True\n\n    @pytest.mark.parametrize(\n        \"package_name\",\n        (\n            \"my.package\",\n            \"my-package\",\n            \"my_package\",\n            \"My.Package\",\n        ),\n    )\n    @patch(\"twyn.main.TopPyPiReference\")\n    @patch(\"twyn.main.get_parsed_dependencies\")\n    def test_check_dependencies_ignores_package_in_allowlist(\n        self, mock_get_parsed_dependencies, mock_top_pypi_reference, package_name\n    ):\n        mock_top_pypi_reference.return_value.get_packages.return_value = {\"mypackage\"}\n        mock_get_parsed_dependencies.return_value = {package_name}\n\n        m_config = Mock(\n            allowlist={package_name},\n            dependency_file=None,\n            selector_method=\"first-letter\",\n        )\n\n        with patch(\"twyn.main.get_configuration\", return_value=m_config):\n            error = check_dependencies(\n                config_file=None,\n                dependency_file=None,\n                selector_method=\"first-letter\",\n            )\n\n        assert error is False\n\n    @pytest.mark.parametrize(\n        \"package_name\", (\"my.package\", \"my-package\", \"my_package\", \"My.Package\")\n    )\n    @patch(\"twyn.main.TopPyPiReference\")\n    @patch(\"twyn.main.get_parsed_dependencies\")\n    def test_check_dependencies_does_not_error_on_same_package(\n        self, mock_get_parsed_dependencies, mock_top_pypi_reference, package_name\n    ):\n        mock_top_pypi_reference.return_value.get_packages.return_value = {\"my-package\"}\n        mock_get_parsed_dependencies.return_value = {package_name}\n\n        error = check_dependencies(\n            config_file=None,\n            dependency_file=None,\n            selector_method=\"first-letter\",\n        )\n\n        assert error is False\n\n    @patch(\n        \"twyn.dependency_parser.dependency_selector.DependencySelector.get_dependency_parser\"\n    )\n    @patch(\"twyn.dependency_parser.requirements_txt.RequirementsTxtParser.parse\")\n    def test_get_parsed_dependencies(self, mock_parse, mock_get_dependency_parser):\n        mock_get_dependency_parser.return_value = RequirementsTxtParser()\n        mock_parse.return_value = {\"boto3\"}\n        assert get_parsed_dependencies() == {\"boto3\"}", ""]}
{"filename": "tests/main/__init__.py", "chunked_list": [""]}
{"filename": "tests/main/test_cli.py", "chunked_list": ["from unittest.mock import call, patch\n\nimport pytest\nfrom click.testing import CliRunner\nfrom twyn import cli\nfrom twyn.base.constants import AvailableLoggingLevels\n\n\nclass TestCli:\n    @patch(\"twyn.core.config_handler.ConfigHandler.add_package_to_allowlist\")\n    def test_allowlist_add_package_to_allowlist(self, mock_allowlist_add):\n        runner = CliRunner()\n        runner.invoke(\n            cli.add,\n            [\"requests\"],\n        )\n\n        assert mock_allowlist_add.call_args == call(\"requests\")\n\n    @patch(\"twyn.core.config_handler.ConfigHandler.remove_package_from_allowlist\")\n    def test_allowlist_remove(self, mock_allowlist_add):\n        runner = CliRunner()\n        runner.invoke(\n            cli.remove,\n            [\"requests\"],\n        )\n\n        assert mock_allowlist_add.call_args == call(\"requests\")\n\n    @patch(\"twyn.cli.check_dependencies\")\n    def test_click_arguments(self, mock_check_dependencies):\n        runner = CliRunner()\n        runner.invoke(\n            cli.run,\n            [\n                \"--config\",\n                \"my-config\",\n                \"--selector-method\",\n                \"first-letter\",\n                \"--dependency-file\",\n                \"requirements.txt\",\n                \"-vv\",\n            ],\n        )\n\n        assert mock_check_dependencies.call_args_list == [\n            call(\n                config_file=\"my-config\",\n                dependency_file=\"requirements.txt\",\n                selector_method=\"first-letter\",\n                verbosity=AvailableLoggingLevels.debug,\n            )\n        ]\n\n    @patch(\"twyn.cli.check_dependencies\")\n    def test_click_arguments_default(self, mock_check_dependencies):\n        runner = CliRunner()\n        runner.invoke(cli.run)\n\n        assert mock_check_dependencies.call_args_list == [\n            call(\n                config_file=None,\n                dependency_file=None,\n                selector_method=None,\n                verbosity=AvailableLoggingLevels.none,\n            )\n        ]\n\n    def test_only_one_verbosity_level_is_allowed(self):\n        runner = CliRunner()\n        with pytest.raises(\n            ValueError,\n            match=\"Only one verbosity level is allowed. Choose either -v or -vv.\",\n        ):\n            runner.invoke(cli.run, [\"-v\", \"-vv\"], catch_exceptions=False)", "class TestCli:\n    @patch(\"twyn.core.config_handler.ConfigHandler.add_package_to_allowlist\")\n    def test_allowlist_add_package_to_allowlist(self, mock_allowlist_add):\n        runner = CliRunner()\n        runner.invoke(\n            cli.add,\n            [\"requests\"],\n        )\n\n        assert mock_allowlist_add.call_args == call(\"requests\")\n\n    @patch(\"twyn.core.config_handler.ConfigHandler.remove_package_from_allowlist\")\n    def test_allowlist_remove(self, mock_allowlist_add):\n        runner = CliRunner()\n        runner.invoke(\n            cli.remove,\n            [\"requests\"],\n        )\n\n        assert mock_allowlist_add.call_args == call(\"requests\")\n\n    @patch(\"twyn.cli.check_dependencies\")\n    def test_click_arguments(self, mock_check_dependencies):\n        runner = CliRunner()\n        runner.invoke(\n            cli.run,\n            [\n                \"--config\",\n                \"my-config\",\n                \"--selector-method\",\n                \"first-letter\",\n                \"--dependency-file\",\n                \"requirements.txt\",\n                \"-vv\",\n            ],\n        )\n\n        assert mock_check_dependencies.call_args_list == [\n            call(\n                config_file=\"my-config\",\n                dependency_file=\"requirements.txt\",\n                selector_method=\"first-letter\",\n                verbosity=AvailableLoggingLevels.debug,\n            )\n        ]\n\n    @patch(\"twyn.cli.check_dependencies\")\n    def test_click_arguments_default(self, mock_check_dependencies):\n        runner = CliRunner()\n        runner.invoke(cli.run)\n\n        assert mock_check_dependencies.call_args_list == [\n            call(\n                config_file=None,\n                dependency_file=None,\n                selector_method=None,\n                verbosity=AvailableLoggingLevels.none,\n            )\n        ]\n\n    def test_only_one_verbosity_level_is_allowed(self):\n        runner = CliRunner()\n        with pytest.raises(\n            ValueError,\n            match=\"Only one verbosity level is allowed. Choose either -v or -vv.\",\n        ):\n            runner.invoke(cli.run, [\"-v\", \"-vv\"], catch_exceptions=False)", ""]}
{"filename": "tests/main/conftest.py", "chunked_list": ["from unittest.mock import patch\n\nimport pytest\n\n\n@pytest.fixture(scope=\"module\")\ndef disable_track():\n    \"\"\"Disables the track UI for running tests.\"\"\"\n    with patch(\"twyn.main.track\") as m_track:\n        m_track.side_effect = lambda iterable, description: iterable\n        yield", ""]}
{"filename": "tests/core/__init__.py", "chunked_list": [""]}
{"filename": "tests/core/test_config_handler.py", "chunked_list": ["from unittest.mock import patch\n\nimport pytest\nfrom twyn.core.config_handler import ConfigHandler\nfrom twyn.core.exceptions import (\n    AllowlistPackageAlreadyExistsError,\n    AllowlistPackageDoesNotExistError,\n)\n\n\nclass TestConfig:\n    def throw_exception(self):\n        raise FileNotFoundError\n\n    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_file_pointer\")\n    def test_enforce_file_error(self, mock_is_file):\n        mock_is_file.side_effect = self.throw_exception\n        with pytest.raises(FileNotFoundError):\n            ConfigHandler(enforce_file=True)\n\n    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_file_pointer\")\n    def test_no_enforce_file_on_non_existent_file(self, mock_is_file):\n        mock_is_file.side_effect = self.throw_exception\n        config = ConfigHandler(enforce_file=False)\n\n        assert config.dependency_file is None\n        assert config.selector_method is None\n        assert config.logging_level is None\n        assert config.allowlist == set()\n\n    def test_config_raises_for_unknown_file(self):\n        with pytest.raises(FileNotFoundError):\n            ConfigHandler(file_path=\"non-existent-file.toml\")\n\n    def test_read_config_values(self, pyproject_toml_file):\n        config = ConfigHandler(file_path=pyproject_toml_file)\n        assert config.dependency_file == \"my_file.txt\"\n        assert config.selector_method == \"my_selector\"\n        assert config.logging_level == \"debug\"\n        assert config.allowlist == {\"boto4\", \"boto2\"}\n\n    def test_get_toml_as_dict(self, pyproject_toml_file):\n        config = ConfigHandler(file_path=pyproject_toml_file)\n        assert config._get_toml_as_dict() == {\n            \"tool\": {\n                \"poetry\": {\n                    \"dependencies\": {\n                        \"python\": \"^3.11\",\n                        \"requests\": \"^2.28.2\",\n                        \"dparse\": \"^0.6.2\",\n                        \"click\": \"^8.1.3\",\n                        \"rich\": \"^13.3.1\",\n                        \"rapidfuzz\": \"^2.13.7\",\n                        \"regex\": \"^2022.10.31\",\n                    },\n                    \"scripts\": {\"twyn\": \"twyn.cli:entry_point\"},\n                },\n                \"twyn\": {\n                    \"dependency_file\": \"my_file.txt\",\n                    \"selector_method\": \"my_selector\",\n                    \"logging_level\": \"debug\",\n                    \"allowlist\": [\"boto4\", \"boto2\"],\n                },\n            }\n        }\n\n    def test_write_toml(self, pyproject_toml_file):\n        config = ConfigHandler(file_path=pyproject_toml_file)\n        config._toml[\"tool\"][\"twyn\"] = {}\n        config._toml[\"tool\"][\"twyn\"][\"allowlist\"] = []\n        config._write_toml()\n        assert config._get_toml_as_dict() == {\n            \"tool\": {\n                \"poetry\": {\n                    \"dependencies\": {\n                        \"python\": \"^3.11\",\n                        \"requests\": \"^2.28.2\",\n                        \"dparse\": \"^0.6.2\",\n                        \"click\": \"^8.1.3\",\n                        \"rich\": \"^13.3.1\",\n                        \"rapidfuzz\": \"^2.13.7\",\n                        \"regex\": \"^2022.10.31\",\n                    },\n                    \"scripts\": {\"twyn\": \"twyn.cli:entry_point\"},\n                },\n                \"twyn\": {\"allowlist\": []},\n            }\n        }", "\n\nclass TestConfig:\n    def throw_exception(self):\n        raise FileNotFoundError\n\n    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_file_pointer\")\n    def test_enforce_file_error(self, mock_is_file):\n        mock_is_file.side_effect = self.throw_exception\n        with pytest.raises(FileNotFoundError):\n            ConfigHandler(enforce_file=True)\n\n    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_file_pointer\")\n    def test_no_enforce_file_on_non_existent_file(self, mock_is_file):\n        mock_is_file.side_effect = self.throw_exception\n        config = ConfigHandler(enforce_file=False)\n\n        assert config.dependency_file is None\n        assert config.selector_method is None\n        assert config.logging_level is None\n        assert config.allowlist == set()\n\n    def test_config_raises_for_unknown_file(self):\n        with pytest.raises(FileNotFoundError):\n            ConfigHandler(file_path=\"non-existent-file.toml\")\n\n    def test_read_config_values(self, pyproject_toml_file):\n        config = ConfigHandler(file_path=pyproject_toml_file)\n        assert config.dependency_file == \"my_file.txt\"\n        assert config.selector_method == \"my_selector\"\n        assert config.logging_level == \"debug\"\n        assert config.allowlist == {\"boto4\", \"boto2\"}\n\n    def test_get_toml_as_dict(self, pyproject_toml_file):\n        config = ConfigHandler(file_path=pyproject_toml_file)\n        assert config._get_toml_as_dict() == {\n            \"tool\": {\n                \"poetry\": {\n                    \"dependencies\": {\n                        \"python\": \"^3.11\",\n                        \"requests\": \"^2.28.2\",\n                        \"dparse\": \"^0.6.2\",\n                        \"click\": \"^8.1.3\",\n                        \"rich\": \"^13.3.1\",\n                        \"rapidfuzz\": \"^2.13.7\",\n                        \"regex\": \"^2022.10.31\",\n                    },\n                    \"scripts\": {\"twyn\": \"twyn.cli:entry_point\"},\n                },\n                \"twyn\": {\n                    \"dependency_file\": \"my_file.txt\",\n                    \"selector_method\": \"my_selector\",\n                    \"logging_level\": \"debug\",\n                    \"allowlist\": [\"boto4\", \"boto2\"],\n                },\n            }\n        }\n\n    def test_write_toml(self, pyproject_toml_file):\n        config = ConfigHandler(file_path=pyproject_toml_file)\n        config._toml[\"tool\"][\"twyn\"] = {}\n        config._toml[\"tool\"][\"twyn\"][\"allowlist\"] = []\n        config._write_toml()\n        assert config._get_toml_as_dict() == {\n            \"tool\": {\n                \"poetry\": {\n                    \"dependencies\": {\n                        \"python\": \"^3.11\",\n                        \"requests\": \"^2.28.2\",\n                        \"dparse\": \"^0.6.2\",\n                        \"click\": \"^8.1.3\",\n                        \"rich\": \"^13.3.1\",\n                        \"rapidfuzz\": \"^2.13.7\",\n                        \"regex\": \"^2022.10.31\",\n                    },\n                    \"scripts\": {\"twyn\": \"twyn.cli:entry_point\"},\n                },\n                \"twyn\": {\"allowlist\": []},\n            }\n        }", "\n\nclass TestAllowlistConfigHandler:\n    @patch(\"twyn.core.config_handler.ConfigHandler._write_toml\")\n    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_as_dict\")\n    def test_allowlist_add(self, mock_toml, mock_write_toml):\n        mock_toml.return_value = {}\n\n        config = ConfigHandler()\n        assert config._toml == {}\n\n        config.add_package_to_allowlist(\"mypackage\")\n        assert config._toml == {\"tool\": {\"twyn\": {\"allowlist\": [\"mypackage\"]}}}\n        assert mock_write_toml.called\n\n    @patch(\"twyn.core.config_handler.ConfigHandler._write_toml\")\n    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_as_dict\")\n    def test_allowlist_add_duplicate_error(self, mock_toml, mock_write_toml):\n        mock_toml.return_value = {\"tool\": {\"twyn\": {\"allowlist\": [\"mypackage\"]}}}\n\n        config = ConfigHandler()\n        with pytest.raises(\n            AllowlistPackageAlreadyExistsError,\n            match=\"Package 'mypackage' is already present in the allowlist. Skipping.\",\n        ):\n            config.add_package_to_allowlist(\"mypackage\")\n\n        assert not mock_write_toml.called\n\n    @pytest.mark.parametrize(\n        \"toml_content, expected\",\n        [\n            ({}, {\"tool\": {\"twyn\": {\"allowlist\": []}}}),\n            (\n                {\"tool\": {\"ruff\": {}}},\n                {\"tool\": {\"twyn\": {\"allowlist\": []}, \"ruff\": {}}},\n            ),\n            ({\"tool\": {\"twyn\": {}}}, {\"tool\": {\"twyn\": {\"allowlist\": []}}}),\n            (\n                {\"tool\": {\"twyn\": {\"allowlist\": []}}},\n                {\"tool\": {\"twyn\": {\"allowlist\": []}}},\n            ),\n            (\n                {\"tool\": {\"twyn\": {\"allowlist\": [\"requests\"]}}},\n                {\"tool\": {\"twyn\": {\"allowlist\": [\"requests\"]}}},\n            ),\n        ],\n    )\n    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_as_dict\")\n    def test_check_allowlist_integrity(self, mock_toml, toml_content, expected):\n        mock_toml.return_value = toml_content\n        config = ConfigHandler()\n        config._create_allowlist_in_toml_if_not_exists()\n        assert config._toml == expected\n\n    @patch(\"twyn.core.config_handler.ConfigHandler._write_toml\")\n    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_as_dict\")\n    def test_allowlist_remove(self, mock_toml, mock_write_toml):\n        mock_toml.return_value = {\"tool\": {\"twyn\": {\"allowlist\": [\"mypackage\"]}}}\n\n        config = ConfigHandler()\n\n        config.remove_package_from_allowlist(\"mypackage\")\n        assert config._toml == {\"tool\": {\"twyn\": {\"allowlist\": []}}}\n        assert mock_write_toml.called\n\n    @patch(\"twyn.core.config_handler.ConfigHandler._write_toml\")\n    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_as_dict\")\n    def test_allowlist_remove_non_existent_package_error(\n        self, mock_toml, mock_write_toml\n    ):\n        mock_toml.return_value = {\"tool\": {\"twyn\": {\"allowlist\": [\"mypackage\"]}}}\n\n        config = ConfigHandler()\n        with pytest.raises(\n            AllowlistPackageDoesNotExistError,\n            match=\"Package 'mypackage2' is not present in the allowlist. Skipping.\",\n        ):\n            config.remove_package_from_allowlist(\"mypackage2\")\n\n        assert not mock_write_toml.called", ""]}
{"filename": "tests/similarity/test_algorithm.py", "chunked_list": ["from typing import Union\n\nimport pytest\nfrom twyn.similarity.algorithm import (\n    AbstractSimilarityAlgorithm,\n    EditDistance,\n    SimilarityThreshold,\n)\nfrom twyn.similarity.exceptions import DistanceAlgorithmError, ThresholdError\n", "from twyn.similarity.exceptions import DistanceAlgorithmError, ThresholdError\n\n\nclass TestAbstractSimilarityAlgorithm:\n    class DifferentLettersSimilarityAlgorithm(AbstractSimilarityAlgorithm):\n        def _run_algorithm(\n            self, first_sequence: str, second_sequence: str\n        ) -> Union[float, int]:\n            first_letters = set(first_sequence)\n            second_letters = set(second_sequence)\n            return len(first_letters.symmetric_difference(second_letters))\n\n    @pytest.mark.parametrize(\n        \"word1, word2, expected_distance\",\n        [\n            (\"foo\", \"bar\", 5),\n            (\"foo\", \"foo\", 0),\n            (\"foo\", \"fooo\", 0),\n            (\"foo\", \"boo\", 2),\n        ],\n    )\n    def test_distance_between_words(self, word1, word2, expected_distance):\n        algorithm = self.DifferentLettersSimilarityAlgorithm()\n        assert algorithm.get_distance(word1, word2) == expected_distance", "\n\nclass TestEditDistance:\n    @pytest.mark.parametrize(\n        \"word1, word2, expected_distance\",\n        [\n            (\"requests\", \"requests\", 0),\n            (\"requests\", \"requets\", 1),\n            (\"reque\", \"requests\", 3),\n        ],\n    )\n    def test_distance_between_words(self, word1, word2, expected_distance):\n        algorithm = EditDistance()\n        assert algorithm.get_distance(word1, word2) == expected_distance", "\n\nclass TestExceptions:\n    class ExceptionAlgorithm(AbstractSimilarityAlgorithm):\n        def _run_algorithm(\n            self, first_sequence: str, second_sequence: str\n        ) -> Union[float, int]:\n            raise KeyError\n\n    def test_exception(self):\n        with pytest.raises(\n            DistanceAlgorithmError,\n            match=\"Exception raised while running distance algorithm\",\n        ):\n            self.ExceptionAlgorithm().get_distance(\"\", \"\")", "\n\nclass TestSimilarityThreshold:\n    def test_invalid_threshold(self):\n        with pytest.raises(ThresholdError):\n            SimilarityThreshold(max=0)\n"]}
{"filename": "tests/similarity/__init__.py", "chunked_list": [""]}
{"filename": "src/twyn/main.py", "chunked_list": ["import logging\nimport re\nfrom typing import Optional\n\nfrom rich.logging import RichHandler\nfrom rich.progress import track\n\nfrom twyn.base.constants import (\n    DEFAULT_SELECTOR_METHOD,\n    SELECTOR_METHOD_MAPPING,", "    DEFAULT_SELECTOR_METHOD,\n    SELECTOR_METHOD_MAPPING,\n    AvailableLoggingLevels,\n)\nfrom twyn.core.config_handler import ConfigHandler\nfrom twyn.dependency_parser.dependency_selector import DependencySelector\nfrom twyn.similarity.algorithm import EditDistance, SimilarityThreshold\nfrom twyn.trusted_packages import TopPyPiReference\nfrom twyn.trusted_packages.selectors import AbstractSelector\nfrom twyn.trusted_packages.trusted_packages import (", "from twyn.trusted_packages.selectors import AbstractSelector\nfrom twyn.trusted_packages.trusted_packages import (\n    TrustedPackages,\n    TyposquatCheckResult,\n)\n\nlogging.basicConfig(\n    format=\"%(message)s\",\n    datefmt=\"[%X]\",\n    handlers=[RichHandler(rich_tracebacks=True, show_path=False)],", "    datefmt=\"[%X]\",\n    handlers=[RichHandler(rich_tracebacks=True, show_path=False)],\n)\nlogger = logging.getLogger()\n\n\ndef check_dependencies(\n    config_file: Optional[str],\n    dependency_file: str,\n    selector_method: str,\n    verbosity: AvailableLoggingLevels = AvailableLoggingLevels.none,\n) -> bool:\n    \"\"\"Check if dependencies could be typosquats.\"\"\"\n    config = get_configuration(config_file, dependency_file, selector_method, verbosity)\n    trusted_packages = TrustedPackages(\n        names=TopPyPiReference().get_packages(),\n        algorithm=EditDistance(),\n        selector=get_candidate_selector(config.selector_method),\n        threshold_class=SimilarityThreshold,\n    )\n    normalized_allowlist_packages = normalize_packages(config.allowlist)\n    dependencies = get_parsed_dependencies(config.dependency_file)\n    normalized_dependencies = normalize_packages(dependencies)\n\n    errors: list[TyposquatCheckResult] = []\n    for dependency in track(normalized_dependencies, description=\"Processing...\"):\n        if dependency in normalized_allowlist_packages:\n            logger.info(f\"Dependency {dependency} is in the allowlist\")\n            continue\n\n        logger.info(f\"Analyzing {dependency}\")\n        if dependency not in trusted_packages and (\n            typosquat_results := trusted_packages.get_typosquat(dependency)\n        ):\n            errors.append(typosquat_results)\n\n    for possible_typosquats in errors:\n        logger.error(\n            f\"Possible typosquat detected: `{possible_typosquats.candidate_dependency}`, \"\n            f\"did you mean any of [{', '.join(possible_typosquats.similar_dependencies)}]?\"\n        )\n\n    return bool(errors)", "\n\ndef get_configuration(\n    config_file: Optional[str],\n    dependency_file: str,\n    selector_method: str,\n    verbosity: AvailableLoggingLevels,\n) -> ConfigHandler:\n    \"\"\"Read configuration and return configuration object.\n\n    Selects the appropriate values based on priorities between those in the file, and those directly provided.\n    \"\"\"\n    # Read config from file\n    config = ConfigHandler(file_path=config_file, enforce_file=False)\n\n    # Set logging level according to priority order\n    logging_level: AvailableLoggingLevels = get_logging_level(\n        logging_level=verbosity,\n        config_logging_level=config.logging_level,\n    )\n    set_logging_level(logging_level)\n    config.logging_level = logging_level.value\n\n    # Set selector method according to priority order\n    config.selector_method = (\n        selector_method or config.selector_method or DEFAULT_SELECTOR_METHOD\n    )\n\n    # Set dependency file according to priority order\n    config.dependency_file = dependency_file or config.dependency_file or None\n    return config", "\n\ndef get_logging_level(\n    logging_level: AvailableLoggingLevels,\n    config_logging_level: Optional[str],\n) -> AvailableLoggingLevels:\n    \"\"\"Return the appropriate logging level, considering that the one in config has less priority than the one passed directly.\"\"\"\n    if logging_level is AvailableLoggingLevels.none:\n        if config_logging_level:\n            return AvailableLoggingLevels[config_logging_level.lower()]\n        else:\n            # default logging level\n            return AvailableLoggingLevels.warning\n\n    return logging_level", "\n\ndef set_logging_level(logging_level: AvailableLoggingLevels) -> None:\n    logger.setLevel(logging_level.value)\n    logger.debug(f\"Logging level: {logging_level.value}\")\n\n\ndef get_candidate_selector(selector_method_name: Optional[str]) -> AbstractSelector:\n    logger.debug(f\"Selector method received {selector_method_name}\")\n    selector_method_name = selector_method_name or DEFAULT_SELECTOR_METHOD\n    selector_method = SELECTOR_METHOD_MAPPING[selector_method_name]()\n    logger.debug(f\"Instantiated {selector_method} selector\")\n    return selector_method", "\n\ndef get_parsed_dependencies(dependency_file: Optional[str] = None) -> set[str]:\n    dependency_parser = DependencySelector(dependency_file).get_dependency_parser()\n    dependencies = dependency_parser.parse()\n    logger.debug(\"Successfully parsed local dependencies file.\")\n    return dependencies\n\n\ndef normalize_packages(packages: set[str]) -> set[str]:\n    \"\"\"Normalize dependency names according to PyPi https://packaging.python.org/en/latest/specifications/name-normalization/.\"\"\"\n    return {re.sub(r\"[-_.]+\", \"-\", name).lower() for name in packages}", "\ndef normalize_packages(packages: set[str]) -> set[str]:\n    \"\"\"Normalize dependency names according to PyPi https://packaging.python.org/en/latest/specifications/name-normalization/.\"\"\"\n    return {re.sub(r\"[-_.]+\", \"-\", name).lower() for name in packages}\n"]}
{"filename": "src/twyn/__init__.py", "chunked_list": [""]}
{"filename": "src/twyn/__version__.py", "chunked_list": ["from importlib import metadata\n\n__version__: str = metadata.version(\"twyn\")\n"]}
{"filename": "src/twyn/cli.py", "chunked_list": ["import sys\n\nimport click\n\nfrom twyn.__version__ import __version__\nfrom twyn.base.constants import (\n    DEPENDENCY_FILE_MAPPING,\n    SELECTOR_METHOD_MAPPING,\n    AvailableLoggingLevels,\n)", "    AvailableLoggingLevels,\n)\nfrom twyn.core.config_handler import ConfigHandler\nfrom twyn.main import check_dependencies\n\n\n@click.group()\n@click.version_option(__version__, \"--version\")\ndef entry_point() -> None:\n    pass", "def entry_point() -> None:\n    pass\n\n\n@entry_point.command()\n@click.option(\"--config\", type=click.STRING)\n@click.option(\n    \"--dependency-file\",\n    type=click.Choice(list(DEPENDENCY_FILE_MAPPING.keys())),\n    help=(", "    type=click.Choice(list(DEPENDENCY_FILE_MAPPING.keys())),\n    help=(\n        \"Dependency file to analyze. By default, twyn will search in the current directory \"\n        \"for supported files, but this option will override that behavior.\"\n    ),\n)\n@click.option(\n    \"--selector-method\",\n    type=click.Choice(list(SELECTOR_METHOD_MAPPING.keys())),\n    help=(", "    type=click.Choice(list(SELECTOR_METHOD_MAPPING.keys())),\n    help=(\n        \"Which method twyn should use to select possible typosquats. \"\n        \"`first-letter` only compares dependencies that share the first letter, \"\n        \"while `nearby-letter` compares against dependencies whose first letter \"\n        \"is nearby in an English keyboard. `all` compares the given dependencies \"\n        \"against all of those in the reference.\"\n    ),\n)\n@click.option(", ")\n@click.option(\n    \"-v\",\n    default=False,\n    is_flag=True,\n)\n@click.option(\n    \"-vv\",\n    default=False,\n    is_flag=True,", "    default=False,\n    is_flag=True,\n)\ndef run(\n    config: str,\n    dependency_file: str,\n    selector_method: str,\n    v: bool,\n    vv: bool,\n) -> int:\n    if v and vv:\n        raise ValueError(\n            \"Only one verbosity level is allowed. Choose either -v or -vv.\"\n        )\n\n    if v:\n        verbosity = AvailableLoggingLevels.info\n    elif vv:\n        verbosity = AvailableLoggingLevels.debug\n    else:\n        verbosity = AvailableLoggingLevels.none\n\n    return int(\n        check_dependencies(\n            config_file=config,\n            dependency_file=dependency_file,\n            selector_method=selector_method,\n            verbosity=verbosity,\n        )\n    )", "\n\n@entry_point.group()\ndef allowlist() -> None:\n    pass\n\n\n@allowlist.command()\n@click.argument(\"package_name\")\ndef add(package_name: str) -> None:\n    ConfigHandler().add_package_to_allowlist(package_name)", "@click.argument(\"package_name\")\ndef add(package_name: str) -> None:\n    ConfigHandler().add_package_to_allowlist(package_name)\n\n\n@allowlist.command()\n@click.argument(\"package_name\")\ndef remove(package_name: str) -> None:\n    ConfigHandler().remove_package_from_allowlist(package_name)\n", "\n\nif __name__ == \"__main__\":\n    sys.exit(entry_point())\n"]}
{"filename": "src/twyn/dependency_parser/poetry_lock.py", "chunked_list": ["\"\"\"Parser for poetry.lock dependencies.\"\"\"\nimport tomllib\nfrom dparse import filetypes\n\nfrom twyn.dependency_parser.abstract_parser import AbstractParser\n\n\nclass PoetryLockParser(AbstractParser):\n    \"\"\"Parser for poetry.lock.\"\"\"\n\n    def __init__(self, file_path: str = filetypes.poetry_lock) -> None:\n        super().__init__(file_path)\n\n    def parse(self) -> set[str]:\n        \"\"\"Parse poetry.lock dependencies into set of dependency names.\"\"\"\n        data = tomllib.loads(self._read())\n        return {dependency[\"name\"] for dependency in data[\"package\"]}", ""]}
{"filename": "src/twyn/dependency_parser/requirements_txt.py", "chunked_list": ["\"\"\"Parser for requirements.txt dependencies.\"\"\"\n\n\nfrom dparse import filetypes, parse\nfrom dparse.dependencies import Dependency, DependencyFile\n\nfrom twyn.dependency_parser.abstract_parser import AbstractParser\n\n\nclass RequirementsTxtParser(AbstractParser):\n    \"\"\"Parser for requirements.txt dependencies.\"\"\"\n\n    def __init__(self, file_path: str = filetypes.requirements_txt) -> None:\n        super().__init__(file_path)\n\n    def parse(self) -> set[str]:\n        \"\"\"Parse requirements.txt dependencies into set of dependency names.\"\"\"\n        dependency_file: DependencyFile = parse(\n            self._read(), file_type=filetypes.requirements_txt\n        )\n        dependencies: list[Dependency] = dependency_file.resolved_dependencies\n        return {dependency.name for dependency in dependencies}", "\nclass RequirementsTxtParser(AbstractParser):\n    \"\"\"Parser for requirements.txt dependencies.\"\"\"\n\n    def __init__(self, file_path: str = filetypes.requirements_txt) -> None:\n        super().__init__(file_path)\n\n    def parse(self) -> set[str]:\n        \"\"\"Parse requirements.txt dependencies into set of dependency names.\"\"\"\n        dependency_file: DependencyFile = parse(\n            self._read(), file_type=filetypes.requirements_txt\n        )\n        dependencies: list[Dependency] = dependency_file.resolved_dependencies\n        return {dependency.name for dependency in dependencies}", ""]}
{"filename": "src/twyn/dependency_parser/dependency_selector.py", "chunked_list": ["import logging\nfrom typing import Optional\n\nfrom twyn.base.constants import DEPENDENCY_FILE_MAPPING\nfrom twyn.dependency_parser.abstract_parser import AbstractParser\nfrom twyn.dependency_parser.exceptions import (\n    MultipleParsersError,\n    NoMatchingParserError,\n)\n", ")\n\nlogger = logging.getLogger()\n\n\nclass DependencySelector:\n    def __init__(self, dependency_file: Optional[str] = None) -> None:\n        self.dependency_file = dependency_file or \"\"\n\n    @staticmethod\n    def _raise_for_selected_parsers(parsers) -> None:\n        if len(parsers) > 1:\n            raise MultipleParsersError\n\n        if not parsers:\n            raise NoMatchingParserError\n\n    def auto_detect_dependency_file_parser(self) -> type[AbstractParser]:\n        parsers = [\n            dependency_parser\n            for dependency_parser in DEPENDENCY_FILE_MAPPING.values()\n            if dependency_parser().file_exists()\n        ]\n        self._raise_for_selected_parsers(parsers)\n        logger.debug(\"Dependencies file found\")\n        return parsers[0]\n\n    def get_dependency_file_parser_from_file_name(\n        self,\n    ) -> type[AbstractParser]:\n        parsers = []\n        for known_dependency_file_name in DEPENDENCY_FILE_MAPPING:\n            if self.dependency_file.endswith(known_dependency_file_name):\n                parsers.append(DEPENDENCY_FILE_MAPPING[known_dependency_file_name])\n\n        self._raise_for_selected_parsers(parsers)\n        return parsers[0]\n\n    def get_dependency_parser(self) -> AbstractParser:\n        logger.debug(f\"Dependency file: {self.dependency_file}\")\n\n        if self.dependency_file:\n            logger.debug(\"Dependency file provided. Assigning a parser.\")\n            dependency_file_parser = self.get_dependency_file_parser_from_file_name()\n        else:\n            logger.debug(\"No dependency file provided. Attempting to locate one.\")\n            dependency_file_parser = self.auto_detect_dependency_file_parser()\n\n        file_parser = dependency_file_parser()\n        logger.debug(f\"Assigned {file_parser} parser for local dependencies file.\")\n        file_parser.raise_for_valid_file()\n\n        return file_parser", ""]}
{"filename": "src/twyn/dependency_parser/__init__.py", "chunked_list": ["\"\"\"Dependency parsers.\"\"\"\nfrom twyn.dependency_parser.poetry_lock import PoetryLockParser\nfrom twyn.dependency_parser.requirements_txt import RequirementsTxtParser\n\n__all__ = [\"RequirementsTxtParser\", \"PoetryLockParser\"]\n"]}
{"filename": "src/twyn/dependency_parser/exceptions.py", "chunked_list": ["from twyn.base.exceptions import TwynError\n\n\nclass PathIsNotFileError(TwynError):\n    message = \"Specified dependencies path is not a file\"\n\n\nclass PathNotFoundError(TwynError, FileNotFoundError):\n    message = \"Specified dependencies file path does not exist\"\n", "\n\nclass NoMatchingParserError(TwynError):\n    message = \"Could not assign a dependency file parser. Please specify it with --dependency-file\"\n\n\nclass MultipleParsersError(TwynError):\n    message = (\n        \"Can't auto detect dependencies file to parse. More than one format was found.\"\n    )", ""]}
{"filename": "src/twyn/dependency_parser/abstract_parser.py", "chunked_list": ["import logging\nimport os\nfrom abc import ABC, abstractmethod\nfrom pathlib import Path\n\nfrom twyn.base.exceptions import TwynError\nfrom twyn.dependency_parser.exceptions import (\n    PathIsNotFileError,\n    PathNotFoundError,\n)", "    PathNotFoundError,\n)\n\nlogger = logging.getLogger()\n\n\nclass AbstractParser(ABC):\n    def __init__(self, file_path: str = \"\") -> None:\n        self.file_path = Path(os.path.abspath(os.path.join(os.getcwd(), file_path)))\n\n    def __str__(self):\n        return self.__class__.__name__\n\n    def _read(self) -> str:\n        content = self.file_path.read_text()\n        logger.debug(\"Successfully read content from local dependencies file\")\n\n        return content\n\n    def file_exists(self) -> bool:\n        try:\n            self.raise_for_valid_file()\n        except TwynError:\n            return False\n        return True\n\n    def raise_for_valid_file(self) -> None:\n        if not self.file_path.exists():\n            raise PathNotFoundError\n\n        if not self.file_path.is_file():\n            raise PathIsNotFileError\n\n    @abstractmethod\n    def parse(self) -> set[str]:\n        \"\"\"\n        Parse text into dependencies set.\n\n        Parse the file's contents into a set of dependency names (type: str).\n        All data other than the dependency names (e.g. whether a dependency is\n        a dev dependency or main dependency; version constraints) is omitted.\n        \"\"\"", ""]}
{"filename": "src/twyn/trusted_packages/trusted_packages.py", "chunked_list": ["from collections import defaultdict\nfrom dataclasses import dataclass, field\nfrom typing import Any, Set\n\nfrom twyn.similarity.algorithm import (\n    AbstractSimilarityAlgorithm,\n    SimilarityThreshold,\n)\nfrom twyn.trusted_packages.selectors import AbstractSelector\n", "from twyn.trusted_packages.selectors import AbstractSelector\n\n_PackageNames = defaultdict[str, set[str]]\n\n\n@dataclass\nclass TyposquatCheckResult:\n    \"\"\"Represents the result of analyzing a dependency for a possible typosquat.\"\"\"\n\n    candidate_dependency: str\n    similar_dependencies: list[str] = field(default_factory=list)\n\n    def __bool__(self) -> bool:\n        return bool(self.similar_dependencies)\n\n    def add(self, similar_name: str) -> None:\n        \"\"\"Add a similar dependency to this typosquat check result.\"\"\"\n        self.similar_dependencies.append(similar_name)", "\n\nclass TrustedPackages:\n    \"\"\"Representation of packages that can be trusted.\"\"\"\n\n    def __init__(\n        self,\n        names: Set[str],\n        algorithm: AbstractSimilarityAlgorithm,\n        selector: AbstractSelector,\n        threshold_class: type[SimilarityThreshold],\n    ) -> None:\n        self.names: _PackageNames = self._create_names_dictionary(names)\n        self.threshold_class = threshold_class\n        self.selector = selector\n        self.algorithm = algorithm\n\n    def __eq__(self, obj: Any) -> bool:\n        return isinstance(obj, self.__class__) and self.names == obj.names\n\n    def __contains__(self, obj: Any) -> bool:\n        if isinstance(obj, str):\n            return obj in self.names[obj[0]]\n        return False\n\n    @staticmethod\n    def _create_names_dictionary(names: set[str]) -> _PackageNames:\n        \"\"\"Create a dictionary which will group all packages that start with the same letter under the same key.\"\"\"\n        first_letter_names = defaultdict(set)\n        for name in names:\n            first_letter_names[name[0]].add(name)\n        return first_letter_names\n\n    def get_typosquat(\n        self,\n        package_name: str,\n    ) -> TyposquatCheckResult:\n        \"\"\"Check if a given package name is similar to any trusted package and returns it.\n\n        Only if there is a match on the first letter can a package name be\n        considered similar to another one. The algorithm provided and the threshold\n        are used to determine if the package name can be considered similar.\n        \"\"\"\n        threshold = self.threshold_class.from_name(package_name)\n        typosquat_result = TyposquatCheckResult(package_name)\n        for trusted_package_name in self.selector.select_similar_names(\n            names=self.names, name=package_name\n        ):\n            distance = self.algorithm.get_distance(package_name, trusted_package_name)\n            if threshold.is_inside_threshold(distance):\n                typosquat_result.add(trusted_package_name)\n        return typosquat_result", ""]}
{"filename": "src/twyn/trusted_packages/references.py", "chunked_list": ["import logging\nfrom abc import ABC, abstractmethod\nfrom typing import Any\n\nimport requests\n\nfrom twyn.trusted_packages.constants import TOP_PYPI_PACKAGES, Url\nfrom twyn.trusted_packages.exceptions import (\n    EmptyPackagesListError,\n    InvalidJSONError,", "    EmptyPackagesListError,\n    InvalidJSONError,\n    InvalidPyPiFormatError,\n)\n\nlogger = logging.getLogger()\n\n\nclass AbstractPackageReference(ABC):\n    \"\"\"Represents a reference to retrieve trusted packages from.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n\n    @abstractmethod\n    def get_packages(self) -> set[str]:\n        \"\"\"Return the names of the trusted packages available in the reference.\"\"\"", "class AbstractPackageReference(ABC):\n    \"\"\"Represents a reference to retrieve trusted packages from.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n\n    @abstractmethod\n    def get_packages(self) -> set[str]:\n        \"\"\"Return the names of the trusted packages available in the reference.\"\"\"\n", "\n\nclass TopPyPiReference(AbstractPackageReference):\n    \"\"\"Top PyPi packages retrieved from an online source.\"\"\"\n\n    def __init__(\n        self, source: Url = TOP_PYPI_PACKAGES, *args: Any, **kwargs: Any\n    ) -> None:\n        super().__init__(*args, **kwargs)\n        self.source = source\n\n    def get_packages(self) -> set[str]:\n        \"\"\"Download and parse online source of top Python Package Index packages.\"\"\"\n        packages_info = self._download()\n        return self._parse(packages_info)\n\n    def _download(self) -> dict[str, Any]:\n        packages = requests.get(self.source)\n        packages.raise_for_status()\n        try:\n            packages_json: dict[str, Any] = packages.json()\n        except requests.exceptions.JSONDecodeError as err:\n            raise InvalidJSONError from err\n\n        logger.debug(\n            f\"Successfully downloaded trusted packages list from {self.source}\"\n        )\n\n        return packages_json\n\n    @staticmethod\n    def _parse(packages_info: dict[str, Any]) -> set[str]:\n        try:\n            names = {row[\"project\"] for row in packages_info[\"rows\"]}\n        except KeyError as err:\n            raise InvalidPyPiFormatError from err\n\n        if not names:\n            raise EmptyPackagesListError\n\n        logger.debug(\"Successfully parsed trusted packages list\")\n\n        return names", ""]}
{"filename": "src/twyn/trusted_packages/selectors.py", "chunked_list": ["from __future__ import annotations\n\nimport logging\nfrom abc import ABC, abstractmethod\nfrom typing import TYPE_CHECKING, Iterable\n\nfrom twyn.trusted_packages.constants import ADJACENCY_MATRIX\nfrom twyn.trusted_packages.exceptions import CharacterNotInMatrixError\n\nif TYPE_CHECKING:\n    from twyn.trusted_packages.trusted_packages import _PackageNames", "\nif TYPE_CHECKING:\n    from twyn.trusted_packages.trusted_packages import _PackageNames\n\nlogger = logging.getLogger()\n\n\nclass AbstractSelector(ABC):\n    @abstractmethod\n    def select_similar_names(self, names: _PackageNames, name: str) -> Iterable[str]:\n        \"\"\"Override this to select names that are similar to the provided one.\"\"\"\n\n    def __str__(self):\n        return self.__class__.__name__", "\n\nclass FirstLetterNearbyInKeyboard(AbstractSelector):\n    \"\"\"Selects names that start with a letter that is nearby in an English Keyboard.\"\"\"\n\n    def select_similar_names(self, names: _PackageNames, name: str) -> Iterable[str]:\n        candidate_characters = self._get_candidate_characters(name[0])\n        for letter in candidate_characters:\n            for candidate in names.get(letter, []):\n                yield candidate\n\n    @staticmethod\n    def _get_candidate_characters(character: str) -> list[str]:\n        if character not in ADJACENCY_MATRIX:\n            raise CharacterNotInMatrixError(f\"Character '{character}' not supported\")\n\n        return ADJACENCY_MATRIX[character] + [character]", "\n\nclass FirstLetterExact(AbstractSelector):\n    \"\"\"Selects names that share the same first letter.\"\"\"\n\n    def select_similar_names(self, names: _PackageNames, name: str) -> Iterable[str]:\n        for candidate in names[name[0]]:\n            yield candidate\n\n\nclass AllSimilar(AbstractSelector):\n    \"\"\"Consider all names to be similar.\"\"\"\n\n    def select_similar_names(self, names: _PackageNames, name: str) -> Iterable[str]:\n        for candidates in names.values():\n            for candidate in candidates:\n                yield candidate", "\n\nclass AllSimilar(AbstractSelector):\n    \"\"\"Consider all names to be similar.\"\"\"\n\n    def select_similar_names(self, names: _PackageNames, name: str) -> Iterable[str]:\n        for candidates in names.values():\n            for candidate in candidates:\n                yield candidate\n", ""]}
{"filename": "src/twyn/trusted_packages/__init__.py", "chunked_list": ["from twyn.trusted_packages.references import TopPyPiReference\nfrom twyn.trusted_packages.trusted_packages import (\n    TrustedPackages,\n)\n\n__all__ = [\"TopPyPiReference\", \"TrustedPackages\"]\n"]}
{"filename": "src/twyn/trusted_packages/constants.py", "chunked_list": ["from typing import NewType\n\nUrl = NewType(\"Url\", str)\n\nTOP_PYPI_PACKAGES = Url(\n    \"https://hugovk.github.io/top-pypi-packages/top-pypi-packages-30-days.min.json\"\n)\n\n\nADJACENCY_MATRIX = {", "\nADJACENCY_MATRIX = {\n    \"1\": [\"2\", \"q\", \"w\"],\n    \"2\": [\"1\", \"3\", \"q\", \"w\"],\n    \"3\": [\"2\", \"4\", \"w\", \"e\"],\n    \"4\": [\"3\", \"5\", \"e\", \"r\"],\n    \"5\": [\"4\", \"6\", \"r\", \"t\"],\n    \"6\": [\"5\", \"7\", \"t\", \"y\"],\n    \"7\": [\"6\", \"8\", \"y\", \"u\"],\n    \"8\": [\"7\", \"9\", \"u\", \"i\"],", "    \"7\": [\"6\", \"8\", \"y\", \"u\"],\n    \"8\": [\"7\", \"9\", \"u\", \"i\"],\n    \"9\": [\"8\", \"0\", \"i\", \"o\"],\n    \"0\": [\"9\", \"o\", \"p\"],\n    \"q\": [\"1\", \"2\", \"w\", \"a\"],\n    \"w\": [\"2\", \"3\", \"q\", \"e\", \"a\", \"s\", \"d\"],\n    \"e\": [\"3\", \"4\", \"w\", \"r\", \"s\", \"d\", \"f\"],\n    \"r\": [\"4\", \"5\", \"e\", \"t\", \"d\", \"f\", \"g\"],\n    \"t\": [\"5\", \"6\", \"r\", \"y\", \"f\", \"g\", \"h\"],\n    \"y\": [\"6\", \"7\", \"t\", \"u\", \"g\", \"h\", \"j\"],", "    \"t\": [\"5\", \"6\", \"r\", \"y\", \"f\", \"g\", \"h\"],\n    \"y\": [\"6\", \"7\", \"t\", \"u\", \"g\", \"h\", \"j\"],\n    \"u\": [\"7\", \"8\", \"y\", \"i\", \"h\", \"j\", \"k\"],\n    \"i\": [\"8\", \"9\", \"u\", \"o\", \"j\", \"k\", \"l\"],\n    \"o\": [\"9\", \"0\", \"i\", \"p\", \"k\", \"l\"],\n    \"p\": [\"0\", \"o\", \"l\"],\n    \"a\": [\"q\", \"w\", \"s\", \"z\"],\n    \"s\": [\"q\", \"w\", \"e\", \"a\", \"d\", \"z\", \"x\"],\n    \"d\": [\"w\", \"e\", \"r\", \"s\", \"f\", \"x\", \"c\"],\n    \"f\": [\"e\", \"r\", \"t\", \"d\", \"g\", \"c\", \"v\"],", "    \"d\": [\"w\", \"e\", \"r\", \"s\", \"f\", \"x\", \"c\"],\n    \"f\": [\"e\", \"r\", \"t\", \"d\", \"g\", \"c\", \"v\"],\n    \"g\": [\"r\", \"t\", \"y\", \"f\", \"h\", \"v\", \"b\"],\n    \"h\": [\"t\", \"y\", \"u\", \"g\", \"j\", \"b\", \"n\"],\n    \"j\": [\"y\", \"u\", \"i\", \"h\", \"k\", \"n\", \"m\"],\n    \"k\": [\"u\", \"i\", \"o\", \"j\", \"l\", \"m\"],\n    \"l\": [\"i\", \"o\", \"p\", \"k\"],\n    \"z\": [\"a\", \"s\", \"x\"],\n    \"x\": [\"s\", \"d\", \"z\", \"c\"],\n    \"c\": [\"d\", \"f\", \"x\", \"v\"],", "    \"x\": [\"s\", \"d\", \"z\", \"c\"],\n    \"c\": [\"d\", \"f\", \"x\", \"v\"],\n    \"v\": [\"f\", \"g\", \"c\", \"b\"],\n    \"b\": [\"g\", \"h\", \"v\", \"n\"],\n    \"n\": [\"h\", \"j\", \"b\", \"m\"],\n    \"m\": [\"j\", \"k\", \"n\"],\n}\n"]}
{"filename": "src/twyn/trusted_packages/exceptions.py", "chunked_list": ["from twyn.base.exceptions import TwynError\n\n\nclass InvalidJSONError(TwynError):\n    message = \"Could not json decode the downloaded packages list\"\n\n\nclass InvalidPyPiFormatError(TwynError, KeyError):\n    message = \"Invalid JSON format.\"\n", "\n\nclass EmptyPackagesListError(TwynError):\n    message = \"Downloaded packages list is empty\"\n\n\nclass CharacterNotInMatrixError(TwynError, KeyError):\n    ...\n", ""]}
{"filename": "src/twyn/base/__init__.py", "chunked_list": [""]}
{"filename": "src/twyn/base/constants.py", "chunked_list": ["from __future__ import annotations\n\nimport enum\nfrom typing import TYPE_CHECKING\n\nimport twyn.dependency_parser as dependency_parser\nfrom twyn.trusted_packages import selectors\n\nif TYPE_CHECKING:\n    from twyn.dependency_parser.abstract_parser import AbstractParser", "if TYPE_CHECKING:\n    from twyn.dependency_parser.abstract_parser import AbstractParser\n\nSELECTOR_METHOD_MAPPING: dict[str, type[selectors.AbstractSelector]] = {\n    \"first-letter\": selectors.FirstLetterExact,\n    \"nearby-letter\": selectors.FirstLetterNearbyInKeyboard,\n    \"all\": selectors.AllSimilar,\n}\n\nDEPENDENCY_FILE_MAPPING: dict[str, type[AbstractParser]] = {", "\nDEPENDENCY_FILE_MAPPING: dict[str, type[AbstractParser]] = {\n    \"requirements.txt\": dependency_parser.requirements_txt.RequirementsTxtParser,\n    \"poetry.lock\": dependency_parser.poetry_lock.PoetryLockParser,\n}\n\nDEFAULT_SELECTOR_METHOD = \"all\"\nDEFAULT_DEPENDENCY_FILE = \"requirements.txt\"\nDEFAULT_PROJECT_TOML_FILE = \"pyproject.toml\"\n", "DEFAULT_PROJECT_TOML_FILE = \"pyproject.toml\"\n\n\nclass AvailableLoggingLevels(enum.Enum):\n    none = \"NONE\"\n    debug = \"DEBUG\"\n    info = \"INFO\"\n    warning = \"WARNING\"\n", ""]}
{"filename": "src/twyn/base/exceptions.py", "chunked_list": ["class TwynError(Exception):\n    message = \"\"\n\n    def __init__(self, message: str = \"\") -> None:\n        super().__init__(message or self.message)\n"]}
{"filename": "src/twyn/core/config_handler.py", "chunked_list": ["import logging\nfrom os import getcwd\nfrom pathlib import Path\nfrom typing import Any, Optional\n\nfrom tomlkit import dumps, parse\n\nfrom twyn.base.constants import DEFAULT_PROJECT_TOML_FILE\nfrom twyn.core.exceptions import (\n    AllowlistPackageAlreadyExistsError,", "from twyn.core.exceptions import (\n    AllowlistPackageAlreadyExistsError,\n    AllowlistPackageDoesNotExistError,\n)\n\nlogger = logging.getLogger()\n\n\nclass ConfigHandler:\n    \"\"\"Read certain values into a central ConfigHandler object.\"\"\"\n\n    def __init__(self, file_path: Optional[str] = None, enforce_file: bool = True):\n        self._file_path = file_path or DEFAULT_PROJECT_TOML_FILE\n        self._enforce_file = enforce_file\n        self._toml = self._get_toml_as_dict()\n        self._twyn_data = self._get_twyn_data()\n\n        self.dependency_file: Optional[str] = self._twyn_data.get(\"dependency_file\")\n        self.selector_method: Optional[str] = self._twyn_data.get(\"selector_method\")\n        self.logging_level: Optional[str] = self._twyn_data.get(\"logging_level\")\n        self.allowlist: set[str] = set(self._twyn_data.get(\"allowlist\", []))\n\n    def add_package_to_allowlist(self, package_name: str) -> None:\n        if package_name in self.allowlist:\n            raise AllowlistPackageAlreadyExistsError(package_name)\n\n        self._create_allowlist_in_toml_if_not_exists()\n\n        self._toml[\"tool\"][\"twyn\"][\"allowlist\"].append(package_name)\n        self._write_toml()\n\n        logger.warning(f\"Package '{package_name}' successfully added to allowlist\")\n\n    def remove_package_from_allowlist(self, package_name: str) -> None:\n        if package_name not in self.allowlist:\n            raise AllowlistPackageDoesNotExistError(package_name)\n\n        self._toml[\"tool\"][\"twyn\"][\"allowlist\"].remove(package_name)\n        self._write_toml()\n        logger.warning(f\"Package '{package_name}' successfully removed from allowlist\")\n\n    def _get_twyn_data(self) -> dict[str, Any]:\n        return self._toml.get(\"tool\", {}).get(\"twyn\", {})\n\n    def _get_toml_file_pointer(self) -> Path:\n        \"\"\"Create a path for the toml file with the format <current working directory>/self.file_path.\"\"\"\n        fp = Path(getcwd()) / Path(self._file_path)\n\n        if not fp.is_file():\n            raise FileNotFoundError(f\"File not found at path '{fp}'.\")\n\n        return fp\n\n    def _write_toml(self) -> None:\n        with open(self._get_toml_file_pointer(), \"w\") as f:\n            f.write(dumps(self._toml))\n\n    def _get_toml_as_dict(self) -> dict[str, Any]:\n        \"\"\"Read TOML into a dictionary.\"\"\"\n        try:\n            fp = self._get_toml_file_pointer()\n        except FileNotFoundError:\n            if not self._enforce_file and self._file_path == DEFAULT_PROJECT_TOML_FILE:\n                return {}\n            raise\n\n        with open(fp, \"r\") as f:\n            content = parse(f.read())\n        return parse(dumps(content))\n\n    def _create_allowlist_in_toml_if_not_exists(self) -> None:\n        try:\n            isinstance(self._toml[\"tool\"][\"twyn\"][\"allowlist\"], list)\n        except KeyError:\n            if \"tool\" not in self._toml:\n                self._toml[\"tool\"] = {}\n\n            if \"twyn\" not in self._toml[\"tool\"]:\n                self._toml[\"tool\"][\"twyn\"] = {}\n\n            if \"allowlist\" not in self._toml[\"tool\"][\"twyn\"]:\n                self._toml[\"tool\"][\"twyn\"][\"allowlist\"] = []", "class ConfigHandler:\n    \"\"\"Read certain values into a central ConfigHandler object.\"\"\"\n\n    def __init__(self, file_path: Optional[str] = None, enforce_file: bool = True):\n        self._file_path = file_path or DEFAULT_PROJECT_TOML_FILE\n        self._enforce_file = enforce_file\n        self._toml = self._get_toml_as_dict()\n        self._twyn_data = self._get_twyn_data()\n\n        self.dependency_file: Optional[str] = self._twyn_data.get(\"dependency_file\")\n        self.selector_method: Optional[str] = self._twyn_data.get(\"selector_method\")\n        self.logging_level: Optional[str] = self._twyn_data.get(\"logging_level\")\n        self.allowlist: set[str] = set(self._twyn_data.get(\"allowlist\", []))\n\n    def add_package_to_allowlist(self, package_name: str) -> None:\n        if package_name in self.allowlist:\n            raise AllowlistPackageAlreadyExistsError(package_name)\n\n        self._create_allowlist_in_toml_if_not_exists()\n\n        self._toml[\"tool\"][\"twyn\"][\"allowlist\"].append(package_name)\n        self._write_toml()\n\n        logger.warning(f\"Package '{package_name}' successfully added to allowlist\")\n\n    def remove_package_from_allowlist(self, package_name: str) -> None:\n        if package_name not in self.allowlist:\n            raise AllowlistPackageDoesNotExistError(package_name)\n\n        self._toml[\"tool\"][\"twyn\"][\"allowlist\"].remove(package_name)\n        self._write_toml()\n        logger.warning(f\"Package '{package_name}' successfully removed from allowlist\")\n\n    def _get_twyn_data(self) -> dict[str, Any]:\n        return self._toml.get(\"tool\", {}).get(\"twyn\", {})\n\n    def _get_toml_file_pointer(self) -> Path:\n        \"\"\"Create a path for the toml file with the format <current working directory>/self.file_path.\"\"\"\n        fp = Path(getcwd()) / Path(self._file_path)\n\n        if not fp.is_file():\n            raise FileNotFoundError(f\"File not found at path '{fp}'.\")\n\n        return fp\n\n    def _write_toml(self) -> None:\n        with open(self._get_toml_file_pointer(), \"w\") as f:\n            f.write(dumps(self._toml))\n\n    def _get_toml_as_dict(self) -> dict[str, Any]:\n        \"\"\"Read TOML into a dictionary.\"\"\"\n        try:\n            fp = self._get_toml_file_pointer()\n        except FileNotFoundError:\n            if not self._enforce_file and self._file_path == DEFAULT_PROJECT_TOML_FILE:\n                return {}\n            raise\n\n        with open(fp, \"r\") as f:\n            content = parse(f.read())\n        return parse(dumps(content))\n\n    def _create_allowlist_in_toml_if_not_exists(self) -> None:\n        try:\n            isinstance(self._toml[\"tool\"][\"twyn\"][\"allowlist\"], list)\n        except KeyError:\n            if \"tool\" not in self._toml:\n                self._toml[\"tool\"] = {}\n\n            if \"twyn\" not in self._toml[\"tool\"]:\n                self._toml[\"tool\"][\"twyn\"] = {}\n\n            if \"allowlist\" not in self._toml[\"tool\"][\"twyn\"]:\n                self._toml[\"tool\"][\"twyn\"][\"allowlist\"] = []", ""]}
{"filename": "src/twyn/core/__init__.py", "chunked_list": [""]}
{"filename": "src/twyn/core/exceptions.py", "chunked_list": ["from twyn.base.exceptions import TwynError\n\n\nclass AllowlistError(TwynError):\n    def __init__(self, package_name: str = \"\"):\n        message = self.message.format(package_name) if package_name else self.message\n        super().__init__(message)\n\n\nclass AllowlistPackageAlreadyExistsError(AllowlistError):\n    message = \"Package '{}' is already present in the allowlist. Skipping.\"", "\nclass AllowlistPackageAlreadyExistsError(AllowlistError):\n    message = \"Package '{}' is already present in the allowlist. Skipping.\"\n\n\nclass AllowlistPackageDoesNotExistError(AllowlistError):\n    message = \"Package '{}' is not present in the allowlist. Skipping.\"\n"]}
{"filename": "src/twyn/similarity/algorithm.py", "chunked_list": ["from __future__ import annotations\n\nimport logging\nfrom abc import ABC, abstractmethod\n\nfrom rapidfuzz.distance import DamerauLevenshtein\n\nfrom twyn.similarity.exceptions import DistanceAlgorithmError, ThresholdError\n\nlogger = logging.getLogger()", "\nlogger = logging.getLogger()\n\n\nclass SimilarityThreshold:\n    LENGTH_CUTOFF = 5\n    MIN_VALUE = 1.0\n    MAX_FOR_SHORT_WORDS = 1.0\n    MAX_FOR_LONG_WORDS = 2.0\n\n    def __init__(self, max: float) -> None:\n        self.min = self.MIN_VALUE\n        self.max = max\n\n        if self.min > self.max:\n            raise ThresholdError\n\n    @classmethod\n    def from_name(cls, name: str) -> SimilarityThreshold:\n        name_length = len(name)\n        if name_length <= cls.LENGTH_CUTOFF:\n            logger.debug(f\"max length of {cls.MAX_FOR_SHORT_WORDS} selected for {name}\")\n            return cls(max=cls.MAX_FOR_SHORT_WORDS)\n        logger.debug(f\"max length of {cls.MAX_FOR_LONG_WORDS} selected for {name}\")\n        return cls(\n            max=cls.MAX_FOR_LONG_WORDS\n        )  # we allow more typos if the name is longer\n\n    def is_inside_threshold(self, value: float) -> bool:\n        return self.min <= value <= self.max", "\n\nclass AbstractSimilarityAlgorithm(ABC):\n    \"\"\"Algorithm that can compare sequences based of a particular similarity measure.\"\"\"\n\n    def get_distance(self, first_sequence: str, second_sequence: str) -> float | int:\n        \"\"\"\n        Perform the alignment between sequences and return the computed distance.\n\n        Will raise DistanceAlgorithmError if an exception occurs.\n        \"\"\"\n        try:\n            return self._run_algorithm(first_sequence, second_sequence)\n        except Exception as exc:\n            raise DistanceAlgorithmError from exc\n\n    @abstractmethod\n    def _run_algorithm(self, first_sequence: str, second_sequence: str) -> float | int:\n        \"\"\"Abstract method that runs the selected algorithm for computing the distance between two words.\"\"\"", "\n\nclass EditDistance(AbstractSimilarityAlgorithm):\n    \"\"\"Levenshtein algorithm that computes the edit distance between words.\"\"\"\n\n    def _run_algorithm(self, first_sequence: str, second_sequence: str) -> int:\n        return DamerauLevenshtein.distance(s1=first_sequence, s2=second_sequence)\n"]}
{"filename": "src/twyn/similarity/__init__.py", "chunked_list": [""]}
{"filename": "src/twyn/similarity/exceptions.py", "chunked_list": ["from twyn.base.exceptions import TwynError\n\n\nclass DistanceAlgorithmError(TwynError):\n    message = \"Exception raised while running distance algorithm\"\n\n\nclass ThresholdError(TwynError, ValueError):\n    message = \"Minimum threshold cannot be greater than maximum threshold.\"\n", ""]}
