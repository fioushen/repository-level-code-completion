{"filename": "__init__.py", "chunked_list": [""]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/common.py", "chunked_list": ["import pathlib\nimport shutil\n\nfrom gridded_etl_tools.dataset_manager import DatasetManager\n\n#\n# Functions common to more than one test that can be imported with:\n#\n#     from common import *\n#", "#     from common import *\n#\n# Or from within a subdirectory:\n#\n#     from ..common import *\n#\n\n\ndef remove_zarr_json():\n    \"\"\"\n    Remove the generated Zarr JSON\n    \"\"\"\n    for path in pathlib.Path(\".\").glob(\"*_zarr.json\"):\n        path.unlink(missing_ok=True)\n        print(f\"Cleaned up {path}\")", "def remove_zarr_json():\n    \"\"\"\n    Remove the generated Zarr JSON\n    \"\"\"\n    for path in pathlib.Path(\".\").glob(\"*_zarr.json\"):\n        path.unlink(missing_ok=True)\n        print(f\"Cleaned up {path}\")\n\n\ndef remove_dask_worker_dir():\n    \"\"\"\n    Remove the Dask worker space directory\n    \"\"\"\n    dask_worker_space_path = pathlib.Path(\"dask-worker-space\")\n    if dask_worker_space_path.exists():\n        shutil.rmtree(dask_worker_space_path)\n        print(f\"Cleaned up {dask_worker_space_path}\")", "\ndef remove_dask_worker_dir():\n    \"\"\"\n    Remove the Dask worker space directory\n    \"\"\"\n    dask_worker_space_path = pathlib.Path(\"dask-worker-space\")\n    if dask_worker_space_path.exists():\n        shutil.rmtree(dask_worker_space_path)\n        print(f\"Cleaned up {dask_worker_space_path}\")\n", "\n\ndef remove_performance_report():\n    \"\"\"\n    Remove the performance report\n    \"\"\"\n    for path in pathlib.Path(\".\").glob(\"performance_report_*.html\"):\n        path.unlink(missing_ok=True)\n        print(f\"Cleaned up {path}\")\n", "\n\ndef clean_up_input_paths(*args):\n    \"\"\"\n    Clean up hourly files and original copies in paths in `args`, which is a list of pathlib.Path objects\n    \"\"\"\n    for path in args:\n        if path.exists():\n            shutil.rmtree(path, ignore_errors=True)\n            print(f\"Cleaned up {path}\")\n        originals_path = pathlib.Path(f\"{path}_originals\")\n        if originals_path.exists():\n            shutil.rmtree(originals_path, ignore_errors=True)\n            print(f\"Cleaned up {originals_path}\")", "\n# Save the original IPNS publish function, so it can be mocked to force offline to True when the patched\n# IPNS publish is applied.\n\n\noriginal_ipns_publish = DatasetManager.ipns_publish\n\n\ndef offline_ipns_publish(self, key, cid, offline=False):\n    \"\"\"\n    A mock version of `DatasetManager.ipns_publish` which forces offline mode so tests can run faster.\n    \"\"\"\n    return original_ipns_publish(self, key, cid, offline=True)", "def offline_ipns_publish(self, key, cid, offline=False):\n    \"\"\"\n    A mock version of `DatasetManager.ipns_publish` which forces offline mode so tests can run faster.\n    \"\"\"\n    return original_ipns_publish(self, key, cid, offline=True)\n\n\ndef empty_ipns_publish(self, key, cid, offline=False):\n    \"\"\"\n    A mock version of `DatasetManager.ipns_publish` which forces offline mode so tests can run faster.\n    \"\"\"\n    return self.info(\"Skipping IPNS publish to preserve initial test dataset\")", "\n# Change the json_key used by IPNS publish to clearly mark the dataset as a test in your key list\n# This will allow other tests to reference the test dataset and prevent mixups with production data\n\n\noriginal_json_key = DatasetManager.json_key\n\n\ndef patched_json_key(self):\n    return f\"{self.name()}-{self.temporal_resolution()}_test_initial\"", "def patched_json_key(self):\n    return f\"{self.name()}-{self.temporal_resolution()}_test_initial\"\n\n\noriginal_zarr_json_path = DatasetManager.zarr_json_path\n\n\ndef patched_zarr_json_path(self):\n    return pathlib.Path(\".\") / f\"{self.name()}_zarr.json\"\n", "\n\noriginal_root_stac_catalog = DatasetManager.default_root_stac_catalog\n\n\ndef patched_root_stac_catalog(self):\n    return {\n        \"id\": f\"{self.host_organization()}_data_catalog_test\",\n        \"type\": \"Catalog\",\n        \"title\": f\"{self.host_organization()} Data Catalog - test\",\n        \"stac_version\": \"1.0.0\",\n        \"description\": f\"This catalog contains all the data uploaded by \\\n            {self.host_organization()} that has been issued STAC-compliant metadata. \\\n            The catalogs and collections describe single providers. Each may contain one or multiple datasets. \\\n            Each individual dataset has been documented as STAC Items.\"\n        }", ""]}
{"filename": "tests/test_log.py", "chunked_list": ["import os\nimport logging\nimport glob\nimport pytest\nimport pathlib\nfrom examples.managers.chirps import CHIRPSFinal25\n\n\n@pytest.fixture(scope=\"module\", autouse=True)\ndef teardown():\n    # Using yield will let the test code run first.\n    yield\n    # Then, delete any log files that were created.\n    for path in glob.glob(\"logs/*.log\"):\n        os.remove(path)", "@pytest.fixture(scope=\"module\", autouse=True)\ndef teardown():\n    # Using yield will let the test code run first.\n    yield\n    # Then, delete any log files that were created.\n    for path in glob.glob(\"logs/*.log\"):\n        os.remove(path)\n\n\ndef test_log():\n    \"\"\"\n    Test that logs are being created at the correct paths in the correct format. Test that multiple objects are not conflicting or\n    creating unnecessary duplicate log entries.\n    \"\"\"\n    # Create and log test statements in a ClimateSet\n    python_module_statement = \"<Python module log statement>\"\n    manager_class_method_statement = \"<Manager class method log statement>\"\n    manager = CHIRPSFinal25(console_log=True, global_log_level=logging.DEBUG)\n    info_log_handler = manager.log_to_file()\n    debug_log_handler = manager.log_to_file(level=logging.DEBUG)\n\n    # Make sure the level of the root logger is DEBUG\n    assert logging.getLogger().level == logging.DEBUG\n\n    # Check that INFO and DEBUG statements are being created and written correctly\n    for level in (logging.INFO, logging.DEBUG):\n        logging.getLogger().log(level, python_module_statement)\n        manager.log(manager_class_method_statement, level=level)\n        assert manager.default_log_path(level).exists()\n        with open(manager.default_log_path(level)) as log:\n            python_module_line, manager_class_method_line = log.readlines()[-2:]\n            assert python_module_line.strip().endswith(python_module_statement)\n            assert manager_class_method_line.strip().endswith(manager_class_method_statement)\n            assert logging.getLevelName(level) in manager_class_method_line\n\n    # Create a new ClimateSet for testing whether multiple objects is causing improper logging\n    extra_manager = CHIRPSFinal25(console_log=False, global_log_level=logging.DEBUG)\n    extra_handler = extra_manager.log_to_file()\n\n    # The handler just added should be the same handler added to the first manager because it is the same path. This check\n    # will make sure a redundant handler isn't being created and writing double log statements.\n    assert extra_handler == info_log_handler\n\n    # Start another log at a new path. This one should actually create a new handler.\n    extra_log_path = pathlib.Path(\"test.log\")\n    new_handler = extra_manager.log_to_file(extra_log_path)\n    assert extra_log_path.exists()\n    assert new_handler != info_log_handler\n\n    # The file handlers should be removed manually, otherwise they will continue to log the rest of the test suite.\n    logging.getLogger().removeHandler(info_log_handler)\n    logging.getLogger().removeHandler(debug_log_handler)", "\ndef test_log():\n    \"\"\"\n    Test that logs are being created at the correct paths in the correct format. Test that multiple objects are not conflicting or\n    creating unnecessary duplicate log entries.\n    \"\"\"\n    # Create and log test statements in a ClimateSet\n    python_module_statement = \"<Python module log statement>\"\n    manager_class_method_statement = \"<Manager class method log statement>\"\n    manager = CHIRPSFinal25(console_log=True, global_log_level=logging.DEBUG)\n    info_log_handler = manager.log_to_file()\n    debug_log_handler = manager.log_to_file(level=logging.DEBUG)\n\n    # Make sure the level of the root logger is DEBUG\n    assert logging.getLogger().level == logging.DEBUG\n\n    # Check that INFO and DEBUG statements are being created and written correctly\n    for level in (logging.INFO, logging.DEBUG):\n        logging.getLogger().log(level, python_module_statement)\n        manager.log(manager_class_method_statement, level=level)\n        assert manager.default_log_path(level).exists()\n        with open(manager.default_log_path(level)) as log:\n            python_module_line, manager_class_method_line = log.readlines()[-2:]\n            assert python_module_line.strip().endswith(python_module_statement)\n            assert manager_class_method_line.strip().endswith(manager_class_method_statement)\n            assert logging.getLevelName(level) in manager_class_method_line\n\n    # Create a new ClimateSet for testing whether multiple objects is causing improper logging\n    extra_manager = CHIRPSFinal25(console_log=False, global_log_level=logging.DEBUG)\n    extra_handler = extra_manager.log_to_file()\n\n    # The handler just added should be the same handler added to the first manager because it is the same path. This check\n    # will make sure a redundant handler isn't being created and writing double log statements.\n    assert extra_handler == info_log_handler\n\n    # Start another log at a new path. This one should actually create a new handler.\n    extra_log_path = pathlib.Path(\"test.log\")\n    new_handler = extra_manager.log_to_file(extra_log_path)\n    assert extra_log_path.exists()\n    assert new_handler != info_log_handler\n\n    # The file handlers should be removed manually, otherwise they will continue to log the rest of the test suite.\n    logging.getLogger().removeHandler(info_log_handler)\n    logging.getLogger().removeHandler(debug_log_handler)", ""]}
{"filename": "tests/conftest.py", "chunked_list": ["import pytest\nimport json\n\n#\n# Pytest fixtures, automatic fixtures, and plugins that will load automatically for the entire suite of tests.\n#\n# See the pytest_addoption notes for how to avoid option name conflicts.\n#\n\n\ndef pytest_addoption(parser):\n    \"\"\"\n    Automatically run by pytest at invocation. These options can be passed on the command line and will be forwarded\n    to all functions that include `requests` as a parameter and then can be accessed as `requests.config.option.[NAME]`.\n\n    Options are global whether they are defined in the root tests/ directory or in a subdirectory like tests/era5.\n    Therefore, option names in era5/conftest.py and prism_zarr/conftest.py cannot be the same.\n\n    For example, if you wanted an option like \"time_chunk\", it would either have to be defined here once and apply to\n    both ERA5 and PRISM or would have to have to be defined with a different name in each, like \"era5_time_chunk\" and\n    \"prism_time_chunk\".\n\n    Per subdirectory addoptions are not supported:\n    https://github.com/pytest-dev/pytest/issues/7974\n\n    Neither are per subdirectory INI files:\n    https://github.com/pytest-dev/pytest/discussions/7732\n    \"\"\"\n    # Remove pass statement and add global command line flags here\n    pass", "\n\ndef pytest_addoption(parser):\n    \"\"\"\n    Automatically run by pytest at invocation. These options can be passed on the command line and will be forwarded\n    to all functions that include `requests` as a parameter and then can be accessed as `requests.config.option.[NAME]`.\n\n    Options are global whether they are defined in the root tests/ directory or in a subdirectory like tests/era5.\n    Therefore, option names in era5/conftest.py and prism_zarr/conftest.py cannot be the same.\n\n    For example, if you wanted an option like \"time_chunk\", it would either have to be defined here once and apply to\n    both ERA5 and PRISM or would have to have to be defined with a different name in each, like \"era5_time_chunk\" and\n    \"prism_time_chunk\".\n\n    Per subdirectory addoptions are not supported:\n    https://github.com/pytest-dev/pytest/issues/7974\n\n    Neither are per subdirectory INI files:\n    https://github.com/pytest-dev/pytest/discussions/7732\n    \"\"\"\n    # Remove pass statement and add global command line flags here\n    pass", "\n\n@pytest.fixture\ndef create_heads_file_for_testing(heads_path):\n    \"\"\"\n    Create the heads file only if it doesn't exist\n    \"\"\"\n    if not heads_path.exists():\n        with open(heads_path, \"w\") as heads:\n            json.dump({}, heads)\n        print(f\"Created empty heads JSON at {heads_path}\")\n    else:\n        print(f\"Found existing heads JSON at {heads_path}\")", ""]}
{"filename": "tests/chirps/test_chirps.py", "chunked_list": ["### [test_chirps.py]\n###\n### included automatically in the run. The test functions check if CHIRPS data is being generated\n### correctly by the current state of the repository using test data saved in data/ that is\n### checked into the repository.\n###\n### With a running IPFS daemon and Python virtual environment set up as described in\n### doc/set_up_python_virtual_environment.md (including all CHIRPS specific dependencies), the tests\n### should complete successfully from the tests/ directory.\n###", "### should complete successfully from the tests/ directory.\n###\n###     $ pytest CHIRPS/\n###\n### Or just\n###\n###     $ pytest\n###\n### When `pytest -s` is run from the root tests/ directory, the test functions in this file will be\n### The test will generate a heads.json and input directories in the root defined in ./conftest.py. The input", "### When `pytest -s` is run from the root tests/ directory, the test functions in this file will be\n### The test will generate a heads.json and input directories in the root defined in ./conftest.py. The input\n### NCs are already checked into that root. These NCs are copied into the generated input directories to\n### simulate downloading them from a source. The input directories are passed into the CHIRPS instance. During\n### the course of running the manager, hourly files are generated in the input directories and originals are\n### copied to the \"_originals\" directory. After the test completes, the \"teardown_module\" function runs automatically\n### to erase everything that was generated (everything in the default root except for the input NCs).\n\n\nimport os", "\nimport os\nimport datetime\nimport pytest\nimport xarray\nimport shutil\nimport psutil\nimport multiprocessing\n\nfrom ..common import *  # import local functions common to all pytests", "\nfrom ..common import *  # import local functions common to all pytests\n\n\n@pytest.fixture\ndef create_input_directories(initial_input_path, appended_input_path):\n    \"\"\"\n    The testing directories for initial, append and insert will get created before each run\n    \"\"\"\n    for path in (initial_input_path, appended_input_path):\n        if not path.exists():\n            os.makedirs(path, 0o755, True)\n            print(f\"Created {path} for testing\")\n        else:\n            print(f\"Found existing {path}\")", "\n\n@pytest.fixture\ndef simulate_file_download(root, initial_input_path, appended_input_path):\n    \"\"\"\n    Copies the default input NCs into the default input paths, simulating a download of original data. Later, the input directories will be\n    deleted during clean up.\n    \"\"\"\n    # for chirps_init_fil in root.glob(\"*initial*\"):\n    #     shutil.copy(chirps_init_fil, initial_input_path)\n    shutil.copy(root / \"chirps_initial_dataset.nc\", initial_input_path)\n    shutil.copy(root / \"chirps_append_subset_0.nc\", appended_input_path)\n    shutil.copy(root / \"chirps_append_subset_1.nc\", appended_input_path)\n    print(\"Simulated downloading input files\")", "\n\n@pytest.fixture(scope='function', autouse=True)\ndef setup_and_teardown_per_test(mocker, request, initial_input_path, appended_input_path,\n                                create_heads_file_for_testing, create_input_directories, simulate_file_download):\n    \"\"\"\n    Call the setup functions first, in a chain ending with `simulate_file_download`.\n    Next run the test in question. Finally, remove generated inputs afterwards, even if the test fails.\n    \"\"\"\n    # Force ipns_publish to use offline mode to make tests run faster\n    mocker.patch(\"gridded_etl_tools.dataset_manager.DatasetManager.json_key\", patched_json_key)\n    mocker.patch(\"examples.managers.chirps.CHIRPS.collection\", return_value=\"CHIRPS_test\")\n    mocker.patch(\"gridded_etl_tools.dataset_manager.DatasetManager.zarr_json_path\", patched_zarr_json_path)\n    mocker.patch(\"gridded_etl_tools.dataset_manager.DatasetManager.default_root_stac_catalog\", patched_root_stac_catalog)\n    mocker.patch(\"gridded_etl_tools.dataset_manager.DatasetManager.ipns_publish\", empty_ipns_publish)\n    yield  # run the tests first\n    # delete temp files\n    remove_zarr_json()\n    remove_dask_worker_dir()\n    remove_performance_report()\n    # now clean up the various files created for each test\n    clean_up_input_paths(initial_input_path, appended_input_path)", "\n\n@pytest.fixture(scope='module', autouse=True)\ndef teardown_module(request, heads_path):\n    \"\"\"\n    Remove the heads file at the end of all tests\n    \"\"\"\n    def test_clean():\n        if heads_path.exists():\n            os.remove(heads_path)\n            print(f\"Cleaned up {heads_path}\")\n    request.addfinalizer(test_clean)", "\n\n@pytest.mark.order(1)\ndef test_initial(request, mocker, manager_class, heads_path, test_chunks, initial_input_path, root):\n    \"\"\"\n    Test a parse of CHIRPS data. This function is run automatically by pytest because the function name starts with \"test_\".\n    \"\"\"\n    # Get the CHIRPS manager with rebuild set\n    manager = manager_class(\n        custom_input_path=initial_input_path,\n        rebuild=True,\n        store='ipld')\n    manager.HASH_HEADS_PATH = heads_path\n    # Remove IPNS publish mocker on the first run of the dataset, so it lives as \"dataset_test\" in your IPNS registry\n    if manager.json_key() not in manager.ipns_key_list():\n        mocker.patch(\"gridded_etl_tools.dataset_manager.DatasetManager.ipns_publish\", offline_ipns_publish)\n    # Overriding the default time chunk to enable testing chunking with a smaller set of times\n    manager.requested_dask_chunks = test_chunks\n    manager.requested_zarr_chunks = test_chunks\n    # run ETL\n    manager.transform()\n    manager.parse()\n    manager.publish_metadata()\n    manager.zarr_json_path().unlink(missing_ok=True)\n    # Open the head with ipldstore + xarray.open_zarr and compare two data points with the same data points in a local GRIB file\n    generated_dataset = manager.zarr_hash_to_dataset(manager.latest_hash())\n    lat, lon = 14.625, -91.375\n    # Validate one row of data\n    output_value = generated_dataset[manager.data_var()].sel(\n        latitude=lat, longitude=lon, time=datetime.datetime(2003, 5, 12), method='nearest').values\n    original_dataset = xarray.open_dataset(root / \"chirps_initial_dataset.nc\", engine=\"netcdf4\")\n    orig_data_var = [key for key in original_dataset.data_vars][0]\n    original_value = original_dataset[orig_data_var].sel(\n        latitude=lat, longitude=lon, time=datetime.datetime(2003, 5, 12)).values\n    assert output_value == original_value", "\n\ndef test_append_only(mocker, request, manager_class, heads_path, test_chunks, appended_input_path, root):\n    \"\"\"\n    Test an update of chirps data by adding new data to the end of existing data.\n    \"\"\"\n    # Get a non-rebuild manager for testing append\n    manager = manager_class(custom_input_path=appended_input_path, store='ipld')\n    manager.HASH_HEADS_PATH = heads_path\n    manager.zarr_chunks = {}\n    # Overriding the default time chunk to enable testing chunking with a smaller set of times\n    manager.requested_dask_chunks = test_chunks\n    manager.requested_zarr_chunks = test_chunks\n    # run ETL\n    manager.transform()\n    manager.parse()\n    manager.publish_metadata()\n    # Open the head with ipldstore + xarray.open_zarr and compare two data points with the same data points in a local GRIB file\n    generated_dataset = manager.zarr_hash_to_dataset(manager.dataset_hash)\n    lat, lon = 14.625, -91.375\n    # Validate one row of data\n    output_value = generated_dataset[manager.data_var()].sel(\n        latitude=lat, longitude=lon, time=datetime.datetime(2003, 5, 25)).values\n    original_dataset = xarray.open_dataset(root / \"chirps_append_subset_0.nc\", engine=\"netcdf4\")\n    orig_data_var = [key for key in original_dataset.data_vars][0]\n    original_value = original_dataset[orig_data_var].sel(\n        latitude=lat, longitude=lon, time=datetime.datetime(2003, 5, 25)).values\n    assert output_value == original_value", "\n\ndef test_metadata(manager_class, heads_path):\n    \"\"\"\n    Test an update of CHIRPS metadata.\n\n    This function will only work after the test dataset's metadata has been populated into IPFS and the IPNS key list.\n    \"\"\"\n    # Get a non-rebuild manager for testing metadata creation\n    manager = manager_class(store='ipld')\n    manager.HASH_HEADS_PATH = heads_path\n    try:\n        manager.publish_metadata()\n    except Exception:\n        manager.fail(\"Metadata update failed\")", "\ndef test_thread_count(mocker, manager_class):\n    \"\"\"\n    Test if the thread count is the correct ratio to RAM size.\n    \"\"\"\n    # Create a fake return object for `psutil.virtual_memory` that will only contain the \"total\" field.\n    class MockMemoryStats:\n        pass\n    mock_vm_stats = MockMemoryStats()\n\n    # Test if 256GB RAM + 32 CPU == 24 threads\n    mock_vm_stats.total = 256 * 1000000000\n    mocker.patch(\"multiprocessing.cpu_count\", return_value=32)\n    mocker.patch(\"psutil.virtual_memory\", return_value=mock_vm_stats)\n    manager = manager_class()\n    assert(manager.dask_num_threads == 24)\n\n    # Test if 128GB RAM + 32 CPU == 12 threads\n    mock_vm_stats.total = 128 * 1000000000\n    mocker.patch(\"multiprocessing.cpu_count\", return_value=32)\n    mocker.patch(\"psutil.virtual_memory\", return_value=mock_vm_stats)\n    manager = manager_class()\n    assert(manager.dask_num_threads == 12)\n\n    # Test if 256GB RAM + 16 CPU == 16 threads\n    mock_vm_stats.total = 256 * 1000000000\n    mocker.patch(\"multiprocessing.cpu_count\", return_value=16)\n    mocker.patch(\"psutil.virtual_memory\", return_value=mock_vm_stats)\n    manager = manager_class()\n    assert(manager.dask_num_threads == 16)\n\n    # Test the edge case of targeting less than one CPU == 1 thread\n    mock_vm_stats.total = 8 * 1000000000\n    mocker.patch(\"multiprocessing.cpu_count\", return_value=8)\n    mocker.patch(\"psutil.virtual_memory\", return_value=mock_vm_stats)\n    manager = manager_class()\n    assert(manager.dask_num_threads == 1)\n\n    # Test the edge case of one CPU == 1 thread\n    mock_vm_stats.total = 32 * 1000000000\n    mocker.patch(\"multiprocessing.cpu_count\", return_value=1)\n    mocker.patch(\"psutil.virtual_memory\", return_value=mock_vm_stats)\n    manager = manager_class()\n    assert(manager.dask_num_threads == 1)", ""]}
{"filename": "tests/chirps/__init__.py", "chunked_list": [""]}
{"filename": "tests/chirps/conftest.py", "chunked_list": ["import pytest\nimport pathlib\n\nfrom examples.managers.chirps import CHIRPSFinal25\n\n#\n# Configuration fixtures defined here will be automatically loaded and available to tests in this directory\n#\n\n", "\n\n@pytest.fixture(scope=\"module\")\ndef root():\n    \"\"\"\n    Directory relative to tests/ where input GRIBs are and temporary input will be generated\n    \"\"\"\n    return pathlib.Path(__file__).parent / \"data\"\n\n", "\n\n@pytest.fixture(scope='module')\ndef heads_path(root):\n    \"\"\"\n    A local heads file for use during testing\n    \"\"\"\n    return root / \"heads.json\"\n\n", "\n\n@pytest.fixture\ndef initial_input_path(root):\n    \"\"\"\n    Paths where test_initial input will be generated\n    \"\"\"\n    return root / pathlib.Path(\"chirps_initial_input\")\n\n", "\n\n@pytest.fixture\ndef appended_input_path(root):\n    return root / pathlib.Path(\"chirps_appended_input\")\n\n\n@pytest.fixture\ndef manager_class():\n    \"\"\"\n    etls.managers.CHIRPSFinal25 child to run tests with\n    \"\"\"\n    return CHIRPSFinal25", "def manager_class():\n    \"\"\"\n    etls.managers.CHIRPSFinal25 child to run tests with\n    \"\"\"\n    return CHIRPSFinal25\n\n\n@pytest.fixture\ndef test_chunks():\n    \"\"\"\n    Time chunk value to use for tests instead of CHIRPS default\n    \"\"\"\n    return {\"time\": 50, \"latitude\": 40, \"longitude\": 40}", "def test_chunks():\n    \"\"\"\n    Time chunk value to use for tests instead of CHIRPS default\n    \"\"\"\n    return {\"time\": 50, \"latitude\": 40, \"longitude\": 40}\n"]}
{"filename": "gridded_etl_tools/dataset_manager.py", "chunked_list": ["# This is necessary for referencing types that aren't fully imported yet. See https://peps.python.org/pep-0563/\nfrom __future__ import annotations\n\nimport sys\nimport logging\nimport multiprocessing\nimport multiprocessing.pool\nimport argparse\nimport datetime\nimport psutil", "import datetime\nimport psutil\n\nfrom .utils.logging import Logging\nfrom .utils.zarr_methods import Publish\nfrom .utils.ipfs import IPFS\nfrom .utils.store import Local, IPLD, S3\nfrom abc import abstractmethod, ABC\nfrom collections.abc import Iterator\nfrom typing import Optional", "from collections.abc import Iterator\nfrom typing import Optional\n\nclass DatasetManager(Logging, Publish, ABC, IPFS):\n    \"\"\"\n    This is a base class for data parsers. It is intended to be inherited and implemented by child classes specific to\n    each data source.\n\n    It is the base class for any climate data set published in a format that is compatible with being opened in `xarray` and\n    transformed into a Zarr. Usable formats so far include netCDF and GRIB2.\n    Sets in this category include CHIRPS,CPC,ERA5,VHI,and RTMA.\n\n    For example,for data sourced from CHIRPS,there is a CHIRPS general class that implements most of CHIRPS parsing,\n    and further inheriting that class is a fully implemented CHIRPS05 class which updates,parses,and verifies CHIRPS .05 data\n    \"\"\"\n\n    SPAN_HOURLY = \"hourly\"\n    SPAN_DAILY = \"daily\"\n    SPAN_WEEKLY = \"weekly\"\n    SPAN_MONTHLY = \"monthly\"\n    SPAN_YEARLY = \"yearly\"\n    SPAN_SEASONAL = \"seasonal\"\n    DATE_FORMAT_FOLDER = \"%Y%m%d\"\n    DATE_HOURLY_FORMAT_FOLDER = \"%Y%m%d%H\"\n    DATE_FORMAT_METADATA = \"%Y/%m/%d\"\n\n    def __init__(\n        self,\n        requested_dask_chunks,\n        requested_zarr_chunks,\n        requested_ipfs_chunker=None,\n        rebuild_requested=False,\n        custom_output_path=None,\n        custom_latest_hash=None,\n        custom_input_path=None,\n        console_log=True,\n        global_log_level=logging.DEBUG,\n        store=None,\n        s3_bucket_name=None,\n        allow_overwrite=False,\n        ipfs_host=\"http://127.0.0.1:5001\",\n        dask_dashboard_address: str = \"127.0.0.1:8787\",\n        write_local_zarr_jsons: bool = False,\n        read_local_zarr_jsons: bool = False,\n        skip_prepare_input_files: bool = False,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Set member variables to defaults. Setup logging to console and any other requested logs.\n\n        Parameters\n        ----------\n        ipfs_host : str, optional\n            The address of the IPFS HTTP API to use for IPFS operations\n        rebuild_requested : bool, optional\n            Sets `DatasetManager.rebuild_requested`. If this parameter is set, the manager requests and parses all available data from beginning\n            to end.\n        custom_output_path : str, optional\n            Overrides the default path returned by `Convenience.output_path`\n        custom_latest_hash : str, optional\n            Overrides the default hash lookup defined in `IPFS.latest_hash`\n        custom_input_path : str, optional\n            A path to use for input files\n        console_log : bool, optional\n            Enable logging `logging.INFO` level and higher statements to console. For more customization, see `DatasetManager.log_to_console`\n        global_log_level : str, optional\n            The root logger `logger.getLogger()` will be set to this level. Recommended to be `logging.DEBUG`, so all logging\n            statements will be generated and then logging handlers can decide what to do with them.\n        store : str | None\n            A string indicating the type of filestore to use (one of, \"local\", \"ipld\" or \"s3\"). A corresponding store object will be initialized.\n            If `None`, the store is left unset and the default store interface defined in `Attributes.store` (local) is returned when the property is\n            accessed. If using S3, the environment variables `AWS_ACCESS_KEY_ID`and `AWS_SECRET_ACCESS_KEY` must be specified\n            in the ~/.aws/credentials file or set manually.\n        s3_bucket_name : str\n            Name of the S3 bucket where this dataset's Zarrs are stored. Only used if \"s3\" store is used.\n        allow_overwrite : bool\n            Unless this is set to `True`, inserting or overwriting data for dates before the dataset's current end date will fail with a\n            warning message.\n        \"\"\"\n        # call IPFS init\n        super().__init__(host=ipfs_host)\n        # Set member variable defaults\n        self.new_files = []\n        self.custom_output_path = custom_output_path\n        self.custom_latest_hash = custom_latest_hash\n        self.custom_input_path = custom_input_path\n        self.rebuild_requested = rebuild_requested\n        # Create certain paramters for development and debugging of certain dataset. All default to False.\n        self.write_local_zarr_jsons = write_local_zarr_jsons\n        self.read_local_zarr_jsons = read_local_zarr_jsons\n        self.skip_prepare_input_files = skip_prepare_input_files\n        # Create a store object based on the passed store string. If `None`, treat as \"local\". If any string other than \"local\", \"ipld\", or \"s3\" is\n        # passed, raise a `ValueError`.\n        if store is None or store == \"local\":\n            self.store = Local(self)\n        elif store == \"ipld\":\n            self.store = IPLD(self)\n        elif store == \"s3\":\n            self.store = S3(self, s3_bucket_name)\n        else:\n            raise ValueError(\"Store must be one of 'local', 'ipld', or 's3'\")\n\n        # Assign the allow overwrite flag. The value should always be either `True` or `False`.\n        # Always allow overwrites if IPLD for backwards compatibility\n        self.overwrite_allowed = allow_overwrite or isinstance(self.store, IPLD)\n\n        # Print log statements to console by default\n        if console_log:\n            self.log_to_console()\n\n        # Set the logging level of logger.getLogger(), which is the logging module's root logger and will control the level of log statements\n        # that are enabled globally. If this is set to `logging.DEBUG`, all log statements will be enabled by default and will be forwarded to\n        # handlers set by either `logging.Logger.addHandler`, `DatasetManager.log_to_file`, or `DatasetManager.log_to_console`.\n        logging.getLogger().setLevel(global_log_level)\n\n        # Add a custom exception handler that will print the traceback to loggers\n        sys.excepthook = self.log_except_hook\n\n        # set chunk sizes (usually specified in the ETL manager class init)\n        self.requested_dask_chunks = requested_dask_chunks\n        self.requested_zarr_chunks = requested_zarr_chunks\n        self.requested_ipfs_chunker = requested_ipfs_chunker\n\n        # set the dask dashboard address. Defaults to 127.0.0.1:8787 so it's only findable on the local machine\n        self.dask_dashboard_address = dask_dashboard_address\n\n        # Dask distributed configuration defaults, mostly related to memory usage\n        self.dask_scheduler_worker_saturation = 1.2\n        self.dask_worker_mem_target = 0.65\n        self.dask_worker_mem_spill = 0.65\n        self.dask_worker_mem_pause = 0.92\n        self.dask_worker_mem_terminate = 0.98\n\n        # Usually set to 1 to avoid data transfer between workers\n        self.dask_num_workers = 1\n\n        # Each thread will use a CPU if self.dask_num_workers is 1. The target ratio is 3 threads per 32 GB RAM. If there are not enough cores\n        # available to use the target number of threads, use the number of available cores. If the target thread count is less than one, set it\n        # to 1.\n        target_ratio = 3 / 32\n        total_memory_gb = psutil.virtual_memory().total / 1000000000\n        target_thread_count = int(target_ratio * total_memory_gb)\n        if target_thread_count > multiprocessing.cpu_count():\n            self.dask_num_threads = multiprocessing.cpu_count()\n        elif target_thread_count < 1:\n            self.dask_num_threads = 1\n        else:\n            self.dask_num_threads = target_thread_count\n        self.info(f\"Using {self.dask_num_threads} threads on a {multiprocessing.cpu_count()}-core system with {total_memory_gb:.2f}GB RAM\")\n\n    # SETUP\n\n    def __str__(self) -> str:\n        \"\"\"\n        Returns\n        -------\n        str\n            The name of the dataset\n        \"\"\"\n        return self.name()\n\n    def __eq__(self, other: DatasetManager) -> bool:\n        \"\"\"\n        All instances of this class will compare equal to each other.\n\n        Returns\n        -------\n        bool\n            If the other `DatasetManager` instance has the same name, return `True`\n        \"\"\"\n        return str(self) == other\n\n    def __hash__(self):\n        return hash(str(self))\n\n    # MINIMUM ETL METHODS\n\n    @abstractmethod\n    def static_metadata(self):\n        \"\"\"\n        Placeholder indicating necessity of instantiating static metadata at the top of an ETL manager script\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def extract(self, date_range: Optional[tuple[datetime.datetime, datetime.datetime]] = None):\n        \"\"\"\n        Check for updates to local input files (usually by checking a remote location where climate data publishers post updated\n        data). Highly customized for every ETL.\n        \"\"\"\n        if date_range and date_range[0] < self.dataset_start_date:\n            raise ValueError(f\"First datetime requested {date_range[0]} is before the start of the dataset in question. Please request a valid datetime.\")\n        self.new_files = []\n\n    def transform(self):\n        \"\"\"\n        Rework downloaded data into a virtual Zarr JSON conforming to Arbol's standard format for gridded datasets\n        \"\"\"\n        # Dynamically adjust metadata based on fields calculated during `extract`, if necessary (usually not)\n        self.populate_metadata()\n        # Create 1 file per measurement span (hour, day, week, etc.) so Kerchunk has consistently chunked inputs for MultiZarring\n        if not self.skip_prepare_input_files:  # in some circumstances it may be useful to skip file prep\n            self.prepare_input_files()\n        # Create Zarr JSON outside of Dask client so multiprocessing can use all workers / threads without interference from Dask\n        self.create_zarr_json()\n\n    @abstractmethod\n    def prepare_input_files(self, keep_originals: bool = True):\n        \"\"\"\n        Convert each of the input files (and associated metadata files) to a collection of daily netCDF4 classic files suitable for\n        reading by Kerchunk and intake into Xarray. This allows us to stack data into modern, performant N-Dimensional Zarr data.\n\n        Parameters\n        ----------\n\n        keep_originals : bool, optional\n            An optional flag to preserve the original files for debugging purposes. Defaults to True.\n        \"\"\"\n        pass\n\n    def populate_metadata(self):\n        \"\"\"\n        Fill the metadata with values describing this set, using the static_metadata as a base template.\n        \"\"\"\n        if hasattr(self, \"metadata\") and self.metadata is not None:\n            self.metadata = self.metadata.update(self.static_metadata)\n        else:\n            self.metadata = self.static_metadata\n\n    def set_zarr_metadata(self, dataset):\n        \"\"\"\n        Placeholder indicating necessity of possibly editing Zarr metadata within an ETL manager script\n        Method to align Zarr metadata with requirements of Zarr exports and STAC metadata format\n        Happens after `populate_metadata` and immediately before data publication.\n        \"\"\"\n        return super().set_zarr_metadata(dataset)\n\n    # ETL GENERATION FUNCTIONS\n\n    @classmethod\n    def get_subclasses(cls) -> Iterator:\n        \"\"\"Create a generator with all the subclasses and sub-subclasses of a parent class\"\"\"\n        for subclass in cls.__subclasses__():\n            yield from subclass.get_subclasses()\n            yield subclass\n\n    @classmethod\n    def get_subclass(cls, name: str) -> type:\n        \"\"\"\n        Method to return the subclass instance corresponding to the name provided when invoking the ETL\n\n        Parameters\n        ----------\n        name : str\n            The str returned by the name() property of the dataset to be parsed. Used to return that subclass's manager.\n            For example, 'chirps_final_05' will yield CHIRPSFinal05 if invoked for the CHIRPS manager\n\n        Returns\n        -------\n        type\n            A dataset source class\n        \"\"\"\n        for source in cls.get_subclasses():\n            if source.name() == name:\n                return source\n        print(\n            f\"failed to set manager from name {name}, could not find corresponding class\"\n        )\n\n    def parse_command_line(self) -> tuple[type | dict]:\n        \"\"\"\n        When this file is called as a script, this function will run automatically, reading input arguments and flags from the\n        command line\n\n        Returns\n        -------\n        tuple[ type | dict]\n            A tuple of a dataset source class and a dictionary of command line arguments to be used by `run_etl`\n\n        \"\"\"\n        parser = self.command_line_parser()\n        # use argparse to parse submitted CLI options\n        arguments = parser.parse_args()\n        # this replaces the passed string for each source with a set manager instance\n        arguments = vars(arguments)\n        return arguments\n\n    def command_line_parser(self) -> argparse.ArgumentParser:\n        \"\"\"\n        Build a parser and populate it with the argument defaults described in command_line_args\n\n        Returns\n        -------\n        parser | argparse.ArgumentParser\n            An ArgumentParser populated with valid command line flags for generating ETLs\n\n        \"\"\"\n        parser = argparse.ArgumentParser(\n            formatter_class=argparse.ArgumentDefaultsHelpFormatter\n        )\n\n        for argument, arg_opts in self.command_line_args.items():\n            parser.add_argument(argument, **arg_opts)\n\n        return parser\n\n    @property\n    def command_line_args(self) -> dict:\n        \"\"\"\n        Command line arguments for generate + their options and default values\n\n        Returns\n        -------\n        command_line_args | dict\n            A dictionary of command line arguments and their corresponding options\n\n        \"\"\"\n        command_line_args = {\n            \"source\": {\n                \"help\": \"a valid source key. Script will fail if an invalid string is passed\"\n            },\n            \"store\": {\n                \"help\": \"a valid store key. Accepts 's3', 'ipld', or 'local'. Script will fail if invalid string is passed\"\n            },\n            \"--s3-bucket\": {\n                \"help\": \"Name of the S3 bucket where this dataset's Zarrs are stored. Only used if 's3' store is used. Defaults to None\"\n            },\n            \"--rebuild\": {\n                \"action\": \"store_true\",\n                \"help\": \"rebuild from beginning of history and generate a new CID independent of any existing data\",\n            },\n            \"--date-range\": {\n                \"nargs\": 2,\n                \"metavar\": \"YYYY-MM-DD\",\n                \"type\": datetime.datetime.fromisoformat,\n                \"help\": \"if supported by any of the specified sets,you can specify a range of dates to parse instead of the entire set\",\n            },\n            \"--latitude-range\": {\n                \"nargs\": 2,\n                \"metavar\": (\"MIN\", \"MAX\"),\n                \"type\": float,\n                \"help\": \"if supported by any specified source,you can pass a latitude range to parse instead of the entire set\",\n            },\n            \"--longitude-range\": {\n                \"nargs\": 2,\n                \"metavar\": (\"MIN\", \"MAX\"),\n                \"type\": float,\n                \"help\": \"if supported by any specified source,you can pass a longitude range to parse instead of the entire set\",\n            },\n            \"--only-parse\": {\n                \"action\": \"store_true\",\n                \"help\": \"only run a parse,using locally availabe data\",\n            },\n            \"--only-metadata\": {\n                \"action\": \"store_true\",\n                \"help\": \"only update metadata,using data available on IPFS\",\n            },\n            \"--only-update-input\": {\n                \"action\": \"store_true\",\n                \"help\": \"only run the update local input function\",\n            },\n            \"--only-transform\": {\n                \"action\": \"store_true\",\n                \"help\": \"Instead of running the full parse,just run the dataset manager's populate_metada, prepare_input_files,\\\n                                and create_zarr_json methods. This will also run the update input function unless --only-parse \\\n                                has been specified as well.\",\n            },\n            \"--local-output\": {\n                \"action\": \"store_true\",\n                \"help\": \"write output Zarr to disk instead of IPFS\",\n            },\n            \"--custom-output-path\": {\n                \"help\": \"override the class's automatic output path generation\"\n            },\n            \"--custom-head-metadata\": {\n                \"help\": \"override the class's automatic head lookup\"\n            },\n            \"--custom-latest-hash\": {\n                \"help\": \"override the class's automatic latest hash lookup\"\n            },\n            \"--era5-enable-caching\": {\n                \"action\": \"store_true\",\n                \"help\": \"allow requests for cached files on ERA5\",\n            },\n            \"--era5-skip-finalization\": {\n                \"action\": \"store_true\",\n                \"help\": \"skip finalization check and overwriting\",\n            },\n        }\n        return command_line_args\n\n    def run_etl(\n        self,\n        dataset_name: str,\n        store: str,\n        s3_bucket_name: str = None,\n        date_range: list[datetime.datetime, datetime.datetime] = None,\n        rebuild: bool = False,\n        only_parse: bool = False,\n        only_update_input: bool = False,\n        only_transform: bool = False,\n        only_metadata: bool = False,\n        custom_output_path: str = None,\n        custom_latest_hash: str = None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Perform all the ETL steps requested by the combination of flags passed. Retrieve original published data by\n        checking remote locations for updates, parse it into Arbol's format, and add it to IPFS.\n\n        By default, this will run a full ETL on the dataset whose `name` corresponds to `dataset_name`,\n        meaning it will update input, parse input, and store the parsed output on the specified storage medium.\n\n        Read the code for `commmand_line_args` to understand how these kwargs are instantiated on the command line.\n\n        Parameters\n        ----------\n        dataset_name : str\n            The name() property of the dataset to be parsed\n\n        store : str\n            The store type of the dataset to be parsed. Accepts 's3', 'ipld', or 'local'.\n\n        s3_bucket_name : str\n            Name of the S3 bucket where this dataset's Zarrs are stored. Only used if \"s3\" store is used. Defaults to None\n\n        date_range : list[datetime.datetime, datetime.datetime], optional\n            A date range within which to download and parse data. Defaults to None.\n\n        rebuild : bool, optional\n            A boolean to fully rebuild the dataset, regardless of its current status. Defaults to False.\n\n        only_parse : bool, optional\n            A boolean to skip updating local data and only parse the data. Defaults to False.\n\n        only_update_input : bool, optional\n            A boolean to skip parsing data and only update local files. Defaults to False.\n\n        only_transform : bool, optional\n            A boolean to skip updating and parsing data and only prepare the local Zarr JSON. Defaults to False.\n\n        only_metadata : bool, optional\n            A boolean to only update a dataset's STAC metadata. Defaults to False.\n\n        custom_output_path : str, optional\n            A str indicating a custom local destination for a Zarr being output locally. Defaults to None.\n\n        custom_head_metadata : str, optional\n            A str hash pointing to a custom head for the metadata, instead of the latest corresponding STAC Item. Defaults to None.\n\n        custom_latest_hash : str, optional\n            A str hash pointing to a custom iteration of the dataset, instead of the latest corresponding hash. Defaults to None.\n\n        \"\"\"\n        # Find the dataset class (e.g. CHIRPSPrelim05) from its name string\n        dataset_class = self.get_subclass(dataset_name)\n        # Initialize a manager for the given class. For example,if class is ERA5Precip, the manager will be ERA5Precip([args]). This will create\n        # INFO and DEBUG logs in the current working directory.\n        manager = dataset_class(\n            store=store,\n            s3_bucket_name=s3_bucket_name,\n            custom_output_path=custom_output_path,\n            custom_latest_hash=custom_latest_hash,\n            rebuild=rebuild,\n        )\n        # Initialize logging for the ETL\n        manager.log_to_file()\n        manager.log_to_file(level=logging.DEBUG)\n        # Set parse to False by default, unless user specifies `only_parse`. This will be changed to True if new files found by extract\n        trigger_parse = only_parse\n        # update local files\n        if only_parse:\n            manager.info(\n                \"only parse flag present, skipping update of local input and using locally available data\"\n            )\n        elif only_metadata:\n            manager.info(\n                \"only metadata flag present,skipping update of local input and parse to update metadata using the existing Zarr on IPFS\"\n            )\n        else:\n            manager.info(\"updating local input\")\n            # extract will return True if parse should be triggered\n            trigger_parse = manager.extract(\n                rebuild=rebuild, date_range=date_range\n            )\n            if only_update_input:\n                # we're finished if only update input was set\n                manager.info(\"ending here because only update local input flag is set\")\n                return\n        # only update metadata and/or transform if these flags are specified\n        if only_metadata:\n            manager.info(f\"preparing metadata for {manager}\")\n            manager.publish_metadata()\n            manager.info(f\"Metadata for {manager} successfully updated\")\n        if only_transform:\n            manager.info(\n                \"Only transform requested, just preparing source files for parsing and creating corresponding Zarr JSON file\"\n            )\n            manager.transform()\n        # parse if only_parse flag is set or if parse was triggered by local input update return value\n        if trigger_parse:\n            # first transform data\n            manager.info(f\"transforming raw {manager} datasets\")\n            manager.transform()\n            manager.info(f\"data for {manager} successfully transformed\")\n            manager.info(f\"parsing {manager}\")\n            # parse will return `True` if new data was parsed\n            if manager.parse():\n                manager.info(f\"Data for {manager} successfully parsed\")\n            else:\n                manager.info(\"no new data parsed, ending here\")\n        else:\n            manager.info(\"no new data detected and parse not set to force, ending here\")\n\n    def run_etl_as_script(self):\n        \"\"\"\n        Run an ETL over the command line by invoking its name and any kwargs.\n        All possible kwargs described under `parse_command_line`.\n        Place this function in the '__main__' section of ETL manager scripts so they can be independently invoked\n        \"\"\"\n        # Get generation args and flags from the command line\n        generate_kwargs = self.parse_command_line()\n        dataset_name = generate_kwargs[\"source\"]\n        generate_kwargs.pop(\"source\")  # exclude the original source argument\n        # Pass the command line args to `generate`\n        self.run_etl(dataset_name, **generate_kwargs)", ""]}
{"filename": "gridded_etl_tools/__init__.py", "chunked_list": ["from pkg_resources import get_distribution, DistributionNotFound\n\ntry:\n    __version__ = get_distribution(__name__).version\nexcept DistributionNotFound:\n    pass  # package is not installed\n"]}
{"filename": "gridded_etl_tools/utils/zarr_methods.py", "chunked_list": ["import datetime\nimport multiprocessing\nimport time\nimport json\nimport re\nimport fsspec\nimport pprint\nimport dask\nimport pathlib\nimport glob", "import pathlib\nimport glob\nimport itertools\n\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\n\nfrom tqdm import tqdm\nfrom subprocess import Popen", "from tqdm import tqdm\nfrom subprocess import Popen\nfrom kerchunk.hdf import SingleHdf5ToZarr\nfrom kerchunk.grib2 import scan_grib\nfrom kerchunk.combine import MultiZarrToZarr\nfrom dask.distributed import Client, LocalCluster\n\nfrom .convenience import Convenience\nfrom .metadata import Metadata\nfrom .store import IPLD", "from .metadata import Metadata\nfrom .store import IPLD\n\n\nclass Creation(Convenience):\n    \"\"\"\n    Base class for transforming a collection of downloaded input files in NetCDF4 Classic format into\n    (sequentially) kerchunk JSONs, a MultiZarr Kerchunk JSON, and finally an Xarray Dataset based on that MultiZarr.\n    \"\"\"\n\n    # KERCHUNKING\n\n    def create_zarr_json(self, force_overwrite: bool = False):\n        \"\"\"\n        Convert list of local input files (MultiZarr) to a single JSON representing a \"virtual\" Zarr\n\n        Read each file in the local input directory and create an in-memory JSON object representing it as a Zarr,\n        then read that collection of JSONs (MultiZarr) into one master JSON formatted as a Zarr and hence openable as a single file\n\n        Note that MultiZarrToZarr will fail if chunk sizes are inconsistent due to inconsistently sized data inputs (e.g. different\n        numbers of steps in input datasets)\n\n        Parameters\n        ----------\n        force_overwrite : bool, optional\n            Switch to create (or not) a new JSON at `DatasetManager.zarr_json_path()` even if the path exists\n\n        \"\"\"\n        self.zarr_json_path().parent.mkdir(mode=0o755, exist_ok=True)\n        # Generate a multizarr if it doesn't exist. If one exists, use that.\n        if not self.zarr_json_path().exists() or force_overwrite:\n            start_kerchunking = time.time()\n            # Prepapre a list of zarr_jsons and feed that to MultiZarrtoZarr\n            if not hasattr(self, \"zarr_jsons\"):\n                input_files_list = [\n                    str(fil)\n                    for fil in self.input_files()\n                    if (fil.suffix == \".nc4\" or fil.suffix == \".nc\" or fil.suffix == '.grib' or fil.suffix == '.grb2')\n                ]\n                self.info(f\"Generating Zarr for {len(input_files_list)} files with {multiprocessing.cpu_count()} processors\")\n                self.zarr_jsons = list(map(self.kerchunkify, tqdm(input_files_list)))\n                mzz = MultiZarrToZarr(path=input_files_list, indicts=self.zarr_jsons, **self.mzz_opts())\n            # if remotely extracting JSONs from S3, self.zarr_jsons should already be prepared during the `extract` step\n            else:\n                self.info(f\"Generating Zarr for {len(self.zarr_jsons)} files with {multiprocessing.cpu_count()} processors\")\n                mzz = MultiZarrToZarr(path=self.zarr_jsons, **self.mzz_opts())  # There are no file names to pass `path` if reading remotely\n            # Translate the MultiZarr to a master JSON and save that out locally. Will fail if the input JSONs are misspecified.\n            mzz.translate(filename=self.zarr_json_path())\n            self.info(\n                f\"Kerchunking to Zarr --- {round((time.time() - start_kerchunking)/60,2)} minutes\"\n            )\n        else:\n            self.info(\"Existing Zarr found, using that\")\n\n    def kerchunkify(self, file_path: str, scan_indices: int = 0):\n        \"\"\"\n        Transform input NetCDF or GRIB into a JSON representing it as a Zarr. These JSONs can be merged into a MultiZarr that Xarray can open natively as a Zarr.\n\n        Read the input file either locally or remotely from S3, depending on whether an s3 bucket is specified in the file path.\n\n        NOTE under the hood there are several versions of GRIB files -- GRIB1 and GRIB2 -- and NetCDF files -- classic, netCDF-4 classic, 64-bit offset, etc.\n        Kerchunk will fail on some versions in undocumented ways. We have found consistent success with netCDF-4 classic files so presuppose using those.\n\n        The command line tool `nccopy -k 'netCDF-4 classic model' infile.nc outfile.nc` can convert between formats\n\n        Parameters\n        ----------\n        file_path : str\n            A file path to an input GRIB or NetCDF-4 Classic file. Can be local or on a remote S3 bucket that accepts anonymous access.\n        scan_indices : int, slice(int,int)\n            One or many indices to filter the JSONS returned by `scan_grib` when scanning remotely.\n            When multiple options are returned that usually means the provider prepares this data variable at multiple depth / surface layers.\n            We currently default to the 1st (index=0), as we tend to use the shallowest depth / surface layer in ETLs we've written.\n\n        \"\"\"\n        if not file_path.lower().startswith('s3://'):\n            try:\n                if self.file_type == 'NetCDF':\n                    fs = fsspec.filesystem(\"file\")\n                    with fs.open(file_path) as infile:\n                        scanned_zarr_json = SingleHdf5ToZarr(h5f=infile, url=file_path, inline_threshold=5000).translate()\n                elif self.file_type == 'GRIB':\n                        scanned_zarr_json = scan_grib(url=file_path, filter = self.grib_filter, inline_threshold=20)[scan_indices]\n            except OSError as e:\n                raise ValueError(\n                    f\"Error found with {file_path}, likely due to incomplete file. Full error message is {e}\"\n                )\n        elif file_path.lower().startswith('s3://'):\n            s3_so = {\n                'anon': True,\n                \"default_cache_type\": \"readahead\"\n                }\n            if self.file_type == 'NetCDF':\n                with self.store.fs().open(file_path, **s3_so) as infile:\n                    scanned_zarr_json = SingleHdf5ToZarr(h5f=infile, url=file_path).translate()\n            elif 'GRIB' in self.file_type:\n                scanned_zarr_json = scan_grib(url=file_path, storage_options= s3_so, filter = self.grib_filter, inline_threshold=20)[scan_indices]\n            # append/extend to self.zarr_jsons for later use in an ETL's `transform` step\n            if type(scanned_zarr_json) == dict:\n                self.zarr_jsons.append(scanned_zarr_json)\n            elif type(scanned_zarr_json) == list:\n                self.zarr_jsons.extend(scanned_zarr_json)\n\n        return scanned_zarr_json\n\n    @classmethod\n    def mzz_opts(cls) -> dict:\n        \"\"\"\n        Class method to populate with options to be passed to MultiZarrToZarr.\n        The options dict is by default populated with class variables instantiated above;\n        optional additional parameters can be added as per the needs of the input dataset\n\n        Returns\n        -------\n        opts : dict\n            Kwargs for kerchunk's MultiZarrToZarr method\n        \"\"\"\n        opts = dict(\n            remote_protocol=cls.remote_protocol(),\n            remote_options={'anon' : True},\n            identical_dims=cls.identical_dims(),\n            concat_dims=cls.concat_dims(),\n            preprocess=cls.preprocess_kerchunk,\n        )\n        return opts\n\n    # PRE AND POST PROCESSING\n\n    @classmethod\n    def preprocess_kerchunk(cls, refs: dict) -> dict:\n        \"\"\"\n        Class method to populate with the specific preprocessing routine of each child class (if relevant), whilst the file is being read by Kerchunk.\n        Note this function usually works by manipulating Kerchunk's internal \"refs\" -- the zarr dictionary generated by Kerchunk.\n\n        If no preprocessing is happening, return the dataset untouched\n\n        Parameters\n        ----------\n        refs : dict\n            Dataset attributes and information automatically supplied by Kerchunk\n\n        Returns\n        -------\n        refs : dict\n            Dataset attributes and information, transformed as needed\n\n        \"\"\"\n        ref_names = set()\n        file_match_pattern = \"(.*?)/\"\n        for ref in refs:\n            if re.match(file_match_pattern, ref) is not None:\n                ref_names.add(re.match(file_match_pattern, ref).group(1))\n        for ref in ref_names:\n            fill_value_fix = json.loads(refs[f\"{ref}/.zarray\"])\n            fill_value_fix[\"fill_value\"] = str(cls.missing_value_indicator())\n            refs[f\"{ref}/.zarray\"] = json.dumps(fill_value_fix)\n        return refs\n\n    def postprocess_zarr(self, dataset: xr.Dataset) -> xr.Dataset:\n        \"\"\"\n        Method to populate with the specific postprocessing routine of each child class (if relevant)\n\n        If no preprocessing is happening, return the dataset untouched\n\n        Parameters\n        ----------\n        dataset : xr.Dataset\n            The dataset being processed\n\n        Returns\n        -------\n        dataset : xr.Dataset\n            The dataset being processed\n\n        \"\"\"\n        return dataset\n\n    # CONVERT FILES\n\n    def parallel_subprocess_files(\n            self,\n            input_files: list[pathlib.Path],\n            command_text: list[str],\n            replacement_suffix: str,\n            keep_originals: bool = False\n    ):\n        \"\"\"\n        Run a command line operation on a set of input files. In most cases, replace each file with an alternative file.\n\n        Optionally, keep the original files for development and testing purposes.\n\n        Parameters\n        ----------\n        raw_files : list\n            A list of pathlib.Path objects referencing the original files prior to processing\n        command_text : list[str]\n            A list of strings to reconstruct into a shell command\n        replacement_suffix : str\n            The desired extension of the file(s) created by the shell routine. Replaces the old extension.\n        keep_originals : bool, optional\n            An optional flag to preserve the original files for debugging purposes. Defaults to False.\n        \"\"\"\n        # set up and run conversion subprocess on command line\n        commands = []\n        for existing_file in input_files:\n            new_file = existing_file.with_suffix(replacement_suffix)\n            commands.append(  # map will convert the file names to strings because some command line tools (e.g. gdal) don't like Pathlib objects\n                    list(map(str, command_text + [existing_file, new_file]))\n                 )\n        # Convert each comment to a Popen call b/c Popen doesn't block, hence processes will run in parallel\n        # Only run 100 processes at a time to prevent BlockingIOErrors\n        for index in range(0, len(commands), 100):\n            commands_slice = [ Popen(cmd) for cmd in commands[index:index+100]]\n            for command in commands_slice:\n                command.wait()\n        self.info(\n            f\"{(len(list(input_files)))} conversions finished, cleaning up original files\"\n        )\n        # Get rid of original files that were converted\n        self.delete_original_files(input_files, keep_originals)\n        self.info(\n            f\"Cleanup finished\"\n        )\n\n    def convert_to_lowest_common_time_denom(\n        self, raw_files: list, keep_originals: bool = False\n    ):\n        \"\"\"\n        Decompose a set of raw files aggregated by week, month, year, or other irregular time denominator\n        into a set of smaller files, one per the lowest common time denominator -- hour, day, etc.\n\n        Parameters\n        ----------\n        raw_files : list\n            A list of file path strings referencing the original files prior to processing\n        originals_dir : pathlib.Path\n            A path to a directory to hold the original files\n        keep_originals : bool, optional\n            An optional flag to preserve the original files for debugging purposes. Defaults to False.\n        \"\"\"\n        if len(list(raw_files)) == 0:\n            raise FileNotFoundError(\"No files found to convert, exiting script\")\n        command_text = [\"cdo\", \"-f\", \"nc4\", \"splitsel,1\"]\n        self.parallel_subprocess_files(raw_files, command_text, '', keep_originals)\n\n    def ncs_to_nc4s(self, keep_originals: bool = False):\n        \"\"\"\n        Find all NetCDF files in the input folder and batch convert them\n        in parallel to NetCDF4-Classic files that play nicely with Kerchunk\n\n        NOTE There are many versions of NetCDFs and some others seem to play nicely with Kerchunk.\n        NOTE To be safe we convert to NetCDF4 Classic as these are reliable and no data is lost.\n\n        Parameters\n        ----------\n        keep_originals : bool\n            A flag to preserve the original files for debugging purposes.\n        \"\"\"\n        # Build a list of files for manipulation\n        raw_files = [pathlib.Path(file) for file in glob.glob(str(self.local_input_path() / \"*.nc\"))]\n        if len(list(raw_files)) == 0:\n            raise FileNotFoundError(\"No files found to convert, exiting script\")\n        # convert raw NetCDFs to NetCDF4-Classics in parallel\n        self.info(\n            f\"Converting {(len(list(raw_files)))} NetCDFs to NetCDF4 Classic files\"\n        )\n        command_text = [\"nccopy\", \"-k\", \"netCDF-4 classic model\"]\n        self.parallel_subprocess_files(raw_files, command_text, '.nc4', keep_originals)\n\n    def delete_original_files(self, files: list, keep_originals: bool = False):\n        \"\"\"\n        Clean up original files\n        Optionally moves the original file to a \"<dataset_name>_originals\" folder for reference\n\n        Parameters\n        ----------\n        files : list\n            A list of original files to delete or save\n\n        keep_originals : bool\n            A boolean indicating whether to preserve the original files (for dev purposes)\n        \"\"\"\n        # use the first file to define the originals_dir path\n        first_file = files[0]\n        originals_dir = first_file.parents[1] / (first_file.stem + \"_originals\")\n        for file in files:\n            # keep or get rid of original files\n            if keep_originals:\n                pathlib.Path.mkdir(originals_dir, mode=0o755, parents=True, exist_ok=True)\n                file.rename(originals_dir / file.name)\n            else:\n                file.unlink()\n\n    # RETURN DATASET\n\n    def zarr_hash_to_dataset(self, ipfs_hash: str) -> xr.Dataset:\n        \"\"\"\n        Open a Zarr on IPLD at `ipfs_hash` as an `xr.Dataset` object\n\n        Parameters\n        ----------\n        ipfs_hash : str\n            The CID of the dataset\n\n        Returns\n        -------\n        dataset : xr.Dataset\n            Object representing the dataset described by the CID at `self.latest_hash()`\n\n        \"\"\"\n        mapper = self.store.mapper(set_root=False)\n        mapper.set_root(ipfs_hash)\n        dataset = xr.open_zarr(mapper)\n        return dataset\n\n    def zarr_json_to_dataset(self, zarr_json_path: str = None) -> xr.Dataset:\n        \"\"\"\n        Open the virtual zarr at `self.zarr_json_path()` and return as a xr.Dataset object\n\n        Parameters\n        ----------\n        zarr_json_path : str, optional\n            A path to a specific Zarr JSON prepared by Kerchunk. Primarily intended for debugging.\n            Defaults to None, which will trigger using the `zarr_json_path` for the dataset in question.\n\n        Returns\n        -------\n        xr.Dataset\n            Object representing the dataset described by the Zarr JSON file at `self.zarr_json_path()`\n\n        \"\"\"\n        if not zarr_json_path:\n            zarr_json_path = str(self.zarr_json_path())\n        dataset = xr.open_dataset(\n            \"reference://\",\n            engine=\"zarr\",\n            chunks={},\n            backend_kwargs={\n                \"storage_options\": {\n                    \"fo\": zarr_json_path,\n                    \"remote_protocol\": self.remote_protocol(),\n                    \"skip_instance_cache\": True,\n                    \"default_cache_type\": \"readahead\",\n                },\n                \"consolidated\": False,\n            },\n        )\n        # Apply any further postprocessing on the way out\n        return self.postprocess_zarr(dataset)", "\n\nclass Publish(Creation, Metadata):\n    \"\"\"\n    Base class for publishing methods -- both initial publication and updates\n    \"\"\"\n\n    # PARSING\n\n    def parse(self, *args, **kwargs) -> bool:\n        \"\"\"\n        Open all raw files in self.local_input_path(). Transform the data contained in them into Zarr format and write to the store specified\n        by `Attributes.store`.\n\n        If the store is IPLD or S3, an existing Zarr will be searched for to be opened and appended to by default. This can be overridden to force\n        writing the entire input data to a new Zarr by setting `Convenience.rebuild_requested` to `True`. If existing data is found,\n        `DatasetManager.overwrite_allowed` must also be `True`.\n\n        This is the core function for transforming and writing data (to disk, S3, or IPLD) and should be standard for all ETLs. Modify the\n        child methods it calls or the dask configuration settings to resolve any performance or parsing issues.\n\n        Parameters\n        ----------\n        args : list\n            Additional arguments passed from generate.py\n        kwargs : dict\n            Keyword arguments passed from generate.py\n\n        Returns\n        -------\n        bool\n            Flag indicating if new data was / was not parsed\n\n        \"\"\"\n        self.info(\"Running parse routine\")\n        # adjust default dask configuration parameters as needed\n        self.dask_configuration()\n        # Use a Dask client to open, process, and write the data\n        with LocalCluster(\n            processes=False,\n            dashboard_address=self.dask_dashboard_address,  # specify local IP to prevent exposing the dashboard\n            protocol=\"inproc://\",  # otherwise Dask may default to tcp or tls protocols and choke\n            threads_per_worker=self.dask_num_threads,\n            n_workers=self.dask_num_workers,\n        ) as cluster, Client(\n            cluster,\n        ) as client:\n            self.info(f\"Dask Dashboard for this parse can be found at {cluster.dashboard_link}\")\n            try:\n                # Attempt to find an existing Zarr, using the appropriate method for the store. If there is existing data and there is no\n                # rebuild requested, start an update. If there is no existing data, start an initial parse. If rebuild is requested and there is\n                # no existing data or allow overwrite has been set, write a new Zarr, overwriting (or in the case of IPLD, not using) any existing\n                # data. If rebuild is requested and there is existing data, but allow overwrite is not set, do not start parsing and issue a warning.\n                if self.store.has_existing and not self.rebuild_requested:\n                    self.info(f\"Updating existing data at {self.store}\")\n                    self.update_zarr()\n                elif not self.store.has_existing or (\n                    self.rebuild_requested and self.overwrite_allowed\n                ):\n                    if not self.store.has_existing:\n                        self.info(\n                            f\"No existing data found. Creating new Zarr at {self.store}.\"\n                        )\n                    else:\n                        self.info(f\"Data at {self.store} will be replaced.\")\n                    self.write_initial_zarr()\n                else:\n                    raise RuntimeError(\n                        \"There is already a zarr at the specified path and a rebuild is requested, \"\n                        \"but overwrites are not allowed.\"\n                    )\n            except KeyboardInterrupt:\n                self.info(\n                    \"CTRL-C Keyboard Interrupt detected, exiting Dask client before script terminates\"\n                )\n                client.close()\n\n        if hasattr(self, \"dataset_hash\") and self.dataset_hash:\n            self.info(\"Published dataset's IPFS hash is \" + str(self.dataset_hash))\n\n        return True\n\n    def publish_metadata(self):\n        \"\"\"\n        Publishes STAC metadata to the backing store\n        \"\"\"\n        current_zarr = self.store.dataset()\n        if not current_zarr:\n            raise RuntimeError(\"Attempting to write STAC metadata, but no zarr written yet\")\n\n        if not hasattr(self, \"metadata\"):\n            # This will occur when user is only updating metadata and has not parsed\n            self.populate_metadata()\n            self.set_key_dims()\n\n        # This will do nothing if catalog already exists\n        self.create_root_stac_catalog()\n\n        # This will update the stac collection if it already exists\n        self.create_stac_collection(current_zarr)\n\n        # Create and publish metadata as a STAC Item\n        self.create_stac_item(current_zarr)\n\n    def to_zarr(self, dataset: xr.Dataset, *args, **kwargs):\n        \"\"\"\n        Wrapper around `xr.Dataset.to_zarr`. `*args` and `**kwargs` are forwarded to `to_zarr`. The dataset to write to Zarr must be the first argument.\n\n        On S3 and local, pre and post update metadata edits are saved to the Zarr attrs at `Dataset.update_in_progress` to indicate during writing that\n        the data is being edited.\n\n        Parameters\n        ----------\n        dataset\n            Dataset to write to Zarr format\n        *args\n            Arguments to forward to `xr.Dataset.to_zarr`\n        **kwargs\n            Keyword arguments to forward to `xr.Dataset.to_zarr`\n        \"\"\"\n        # Skip update in-progress metadata flag on IPLD\n        if not isinstance(self.store, IPLD):\n            # Create an empty dataset that will be used to just write the metadata (there's probably a better way to do this? compute=False?).\n            dataset.attrs[\"update_in_progress\"] = True\n            empty_dataset = dataset\n            for coord in itertools.chain(dataset.coords, dataset.data_vars):\n                empty_dataset = empty_dataset.drop(coord)\n\n            # If there is an existing Zarr, indicate in the metadata that an update is in progress, and write the metadata before starting the real write.\n            if self.store.has_existing:\n                self.info(\"Pre-writing metadata to indicate an update is in progress\")\n                empty_dataset.to_zarr(\n                    self.store.mapper(refresh=True), append_dim=self.time_dim\n                )\n\n        # Write data to Zarr and log duration.\n        start_writing = time.perf_counter()\n        dataset.to_zarr(*args, **kwargs)\n        self.info(\n            f\"Writing Zarr took {datetime.timedelta(seconds=time.perf_counter() - start_writing)}\"\n        )\n\n        # Skip update in-progress metadata flag on IPLD\n        if not isinstance(self.store, IPLD):\n            # Indicate in metadata that update is complete.\n            empty_dataset.attrs[\"update_in_progress\"] = False\n            self.info(\n                \"Re-writing Zarr to indicate in the metadata that update is no longer in process.\"\n            )\n            empty_dataset.to_zarr(self.store.mapper(), append_dim=self.time_dim)\n\n    # SETUP\n\n    def dask_configuration(self):\n        \"\"\"\n        Convenience method to implement changes to the configuration of the dask client after instantiation\n\n        NOTE Some relevant paramters and console print statements we found useful during testing have been left\n        commented out at the bottom of this function. Consider activating them if you encounter trouble parsing\n        \"\"\"\n        self.info(\"Configuring Dask\")\n        dask.config.set(\n            {\n                \"distributed.scheduler.worker-saturation\": self.dask_scheduler_worker_saturation\n            }\n        )  # toggle upwards or downwards (minimum 1.0) depending on memory mgmt performance\n        dask.config.set(\n            {\"distributed.scheduler.worker-ttl\": None}\n        )  # will timeout on big tasks otherwise\n        dask.config.set(\n            {\"distributed.worker.memory.target\": self.dask_worker_mem_target}\n        )\n        dask.config.set({\"distributed.worker.memory.spill\": self.dask_worker_mem_spill})\n        dask.config.set({\"distributed.worker.memory.pause\": self.dask_worker_mem_pause})\n        dask.config.set(\n            {\"distributed.worker.memory.terminate\": self.dask_worker_mem_terminate}\n        )\n\n        # OTHER USEFUL SETTINGS, USE IF ENCOUNTERING PROBLEMS WITH PARSES\n        # dask.config.set({'scheduler' : 'threads'}) # default distributed scheduler does not allocate memory correctly for some parses\n        # dask.config.set({'nanny.environ.pre-spawn-environ.MALLOC_TRIM_THRESHOLD_' : 0}) # helps clear out unused memory\n        # dask.config.set({\"distributed.worker.memory.recent-to-old-time\": \"300s\"}) #???\n\n        # DEBUGGING\n        self.info(f\"dask.config.config is {pprint.pformat(dask.config.config)}\")\n\n    # INITIAL PUBLICATION\n\n    def pre_initial_dataset(self) -> xr.Dataset:\n        \"\"\"\n        Get an `xr.Dataset` that can be passed to the appropriate writing method when writing a new Zarr. Read the virtual Zarr JSON at the\n        path returned by `Creation.zarr_json_path`, normalize the axes, re-chunk the dataset according to this object's chunking parameters, and\n        add custom metadata defined by this class.\n\n        Returns\n        -------\n        xr.Dataset\n            The dataset from `Creation.zarr_json_to_dataset` with custom metadata, normalized axes, and rechunked\n        \"\"\"\n        # Transform the JSON Zarr into an xarray Dataset\n        dataset = self.zarr_json_to_dataset()\n\n        # Reset standard_dims to Arbol's standard now that loading + preprocessing on the original names is done\n        self.set_key_dims()\n        dataset = dataset.transpose(*self.standard_dims)\n\n        # Re-chunk\n        self.info(f\"Re-chunking dataset to {self.requested_dask_chunks}\")\n        dataset = dataset.chunk(self.requested_dask_chunks)\n        self.info(f\"Chunks after rechunk are {dataset.chunks}\")\n\n        # Add metadata to dataset\n        dataset = self.set_zarr_metadata(dataset)\n\n        # Log the state of the dataset before writing\n        self.info(f\"Initial dataset\\n{dataset}\")\n\n        return dataset\n\n    def write_initial_zarr(self):\n        \"\"\"\n        Writes the first iteration of zarr for the dataset to the store specified at\n        initialization. If the store is `IPLD`, does some additional metadata processing\n        \"\"\"\n        # Transform the JSON Zar\n        dataset = self.pre_initial_dataset()\n        mapper = self.store.mapper(set_root=False)\n\n        self.to_zarr(dataset, mapper, consolidated=True, mode=\"w\")\n        if isinstance(self.store, IPLD):\n            self.dataset_hash = str(mapper.freeze())\n\n    def set_key_dims(self):\n        \"\"\"\n        Convenience method to set the standard and time dimensions based on whether a dataset is a forecast or not\n        The self.forecast instance variable is set in the `init` of a dataset and defaults to False.\n        \"\"\"\n        if not self.forecast:\n            self.standard_dims = [\"time\", \"latitude\", \"longitude\"]\n            self.time_dim = \"time\"\n        else:\n            self.standard_dims = [\"forecast_reference_time\", \"step\", \"latitude\", \"longitude\"]\n            self.time_dim = \"forecast_reference_time\"\n\n    # UPDATES\n\n    def update_zarr(self):\n        \"\"\"\n        Update discrete regions of an N-D dataset saved to disk as a Zarr. If updates span multiple date ranges, pushes separate updates to each region.\n        If the IPLD store is in use, after updating the dataset, this function updates the corresponding STAC Item and summaries in the parent\n        STAC Collection.\n        \"\"\"\n        original_dataset = self.store.dataset()\n        update_dataset = self.zarr_json_to_dataset()\n\n        # Reset standard_dims to Arbol's standard now that loading + preprocessing on the original names is done\n        self.set_key_dims()\n        self.info(f\"Original dataset\\n{original_dataset}\")\n\n        # Prepare inputs for the update operation\n        insert_times, append_times = self.update_setup(original_dataset, update_dataset)\n\n        # Conduct update operations\n        self.update_parse_operations(\n            original_dataset, update_dataset, insert_times, append_times\n        )\n\n    def update_setup(\n        self, original_dataset: xr.Dataset, update_dataset: xr.Dataset\n    ) -> tuple[list, list]:\n        \"\"\"\n        Create needed inputs for the actual update parses: a variable to hold the hash and lists of any times to insert and/or append.\n\n        Parameters\n        ----------\n        original_dataset : xr.Dataset\n            The existing xr.Dataset\n        update_dataset : xr.Dataset\n            A dataset containing all updated (insert) and new (append) records\n\n        Returns\n        -------\n        insert_times : list\n            Datetimes corresponding to existing records to be replaced in the original dataset\n        append_times : list\n            Datetimes corresponding to all new records to append to the original dataset\n        \"\"\"\n        original_times = set(original_dataset[self.time_dim].values)\n        if (\n            type(update_dataset[self.time_dim].values) == np.datetime64\n        ):  # cannot perform iterative (set) operations on a single numpy.datetime64 value\n            update_times = set([update_dataset[self.time_dim].values])\n        else:  # many values will come as an iterable numpy.ndarray\n            update_times = set(update_dataset[self.time_dim].values)\n        insert_times = sorted(update_times.intersection(original_times))\n        append_times = sorted(update_times - original_times)\n\n        return insert_times, append_times\n\n    def update_parse_operations(\n        self,\n        original_dataset: xr.Dataset,\n        update_dataset: xr.Dataset,\n        insert_times: list,\n        append_times: list,\n    ):\n        \"\"\"\n        An enclosing method triggering insert and/or append operations based on the presence of valid records for either.\n\n        Parameters\n        ----------\n        original_dataset : xr.Dataset\n            The existing dataset\n        update_dataset : xr.Dataset\n            A dataset containing all updated (insert) and new (append) records\n        insert_times : list\n            Datetimes corresponding to existing records to be replaced in the original dataset\n        append_times : list\n            Datetimes corresponding to all new records to append to the original dataset\n        \"\"\"\n        # Raise an exception if there is no writable data\n        if not insert_times and not append_times:\n            raise ValueError(\n                \"Update started with no new records to insert or append to original zarr.\"\n            )\n\n        original_chunks = {\n            dim: val_tuple[0] for dim, val_tuple in original_dataset.chunks.items()\n        }\n        # First write out updates to existing data using the 'region=' command...\n        if len(insert_times) > 0:\n            if not self.overwrite_allowed:\n                self.warn(\n                    \"Not inserting records despite historical data detected. 'allow_overwrite'\"\n                    \"flag has not been set and store is not IPLD\"\n                )\n            else:\n                self.insert_into_dataset(\n                    original_dataset, update_dataset, insert_times, original_chunks\n                )\n        else:\n            self.info(\"No modified records to insert into original zarr\")\n        # ...then write new data (appends) using the 'append_dim=' command\n        if len(append_times) > 0:\n            self.append_to_dataset(update_dataset, append_times, original_chunks)\n        else:\n            self.info(\"No new records to append to original zarr\")\n\n    def insert_into_dataset(\n        self,\n        original_dataset: xr.Dataset,\n        update_dataset: xr.Dataset,\n        insert_times: list,\n        original_chunks: list,\n    ):\n        \"\"\"\n        Insert new records to an existing dataset along its time dimension using the `append_dim=` flag.\n\n        Parameters\n        ----------\n        original_dataset : xr.Dataset\n            The existing xr.Dataset\n        update_dataset : xr.Dataset\n            A dataset containing all updated (insert) and new (append) records\n        insert_times : list\n            Datetimes corresponding to existing records to be replaced in the original dataset\n        originaL_chunks : dict\n            A Dict containing the dimension:size parameters for the original dataset\n        \"\"\"\n        mapper = self.store.mapper()\n\n        insert_dataset = self.prep_update_dataset(\n            update_dataset, insert_times, original_chunks\n        )\n        date_ranges, regions = self.calculate_update_time_ranges(\n            original_dataset, insert_dataset\n        )\n        for dates, region in zip(date_ranges, regions):\n            insert_slice = insert_dataset.sel(**{self.time_dim : slice(dates[0], dates[1])})\n            insert_dataset.attrs[\"update_is_append_only\"] = False\n            self.info(\"Indicating the dataset is not appending data only.\")\n            self.to_zarr(\n                insert_slice.drop(self.standard_dims[1:]),\n                mapper,\n                region={self.time_dim: slice(region[0], region[1])},\n            )\n\n        self.info(\n            f\"Inserted records for {len(insert_dataset[self.time_dim].values)} times from {len(regions)} date range(s) to original zarr\"\n        )\n        # In the case of IPLD, store the hash for later use\n        if isinstance(self.store, IPLD):\n            self.dataset_hash = str(mapper.freeze())\n\n    def append_to_dataset(\n        self, update_dataset: xr.Dataset, append_times: list, original_chunks: dict\n    ):\n        \"\"\"\n        Append new records to an existing dataset along its time dimension using the `append_dim=` flag.\n\n        Parameters\n        ----------\n        update_dataset : xr.Dataset\n            A dataset containing all updated (insert) and new (append) records\n        append_times : list\n            Datetimes corresponding to all new records to append to the original dataset\n        originaL_chunks : dict\n            The dimension:size parameters for the original dataset\n        \"\"\"\n        append_dataset = self.prep_update_dataset(\n            update_dataset, append_times, original_chunks\n        )\n        mapper = self.store.mapper()\n\n        # Write the Zarr\n        append_dataset.attrs[\"update_is_append_only\"] = True\n        self.info(\"Indicating the dataset is appending data only.\")\n        self.to_zarr(append_dataset, mapper, consolidated=True, append_dim=self.time_dim)\n\n        self.info(\n            f\"Appended records for {len(append_dataset[self.time_dim].values)} datetimes to original zarr\"\n        )\n        # In the case of IPLD, store the hash for later use\n        if isinstance(self.store, IPLD):\n            self.dataset_hash = str(mapper.freeze())\n\n    def prep_update_dataset(\n        self, update_dataset: xr.Dataset, time_filter_vals: list, new_chunks: dict\n    ) -> xr.Dataset:\n        \"\"\"\n        Select out and format time ranges you wish to insert or append into the original dataset based on specified time range(s) and chunks\n\n        Parameters\n        ----------\n        update_dataset : xr.Dataset\n            A dataset containing all updated (insert) and new (append) records\n        time_filter_vals : list\n            Datetimes corresponding to all new records to insert or append\n        new_chunks : dict\n            A Dict containing the dimension:size parameters for the original dataset\n\n        Returns\n        -------\n        update_dataset : xr.Dataset\n            An xr.Dataset filtered to only the time values in `time_filter_vals`, with correct metadata\n        \"\"\"\n        # Xarray will automatically drop dimensions of size 1. A missing time dimension causes all manner of update failures.\n        if self.time_dim in update_dataset.dims:\n            update_dataset = update_dataset.sel(**{self.time_dim : time_filter_vals}).transpose(*self.standard_dims)\n        else:\n            update_dataset = update_dataset.expand_dims(self.time_dim).transpose(*self.standard_dims)\n        update_dataset = update_dataset.chunk(new_chunks)\n        update_dataset = self.set_zarr_metadata(update_dataset)\n\n        self.info(f\"Update dataset\\n{update_dataset}\")\n\n        return update_dataset\n\n    def calculate_update_time_ranges(\n        self, original_dataset: xr.Dataset, update_dataset: xr.Dataset\n    ) -> tuple[list[datetime.datetime], list[str]]:\n        \"\"\"\n        Calculate the start/end dates and index values for contiguous time ranges of updates.\n        Used by `update_zarr` to specify the location(s) of updates in a target Zarr dataset.\n\n        Parameters\n        ----------\n        original_dataset : xr.Dataset\n            The existing xr.Dataset\n        update_dataset : xr.Dataset\n            A dataset containing all updated (insert) and new (append) records\n\n        Returns\n        -------\n        datetime_ranges : list[datetime.datetime, datetime.datetime]\n            A List of (Datetime, Datetime) tuples defining the time ranges of records to insert\n        regions_indices: list[int, int]\n             A List of (int, int) tuples defining the indices of records to insert\n\n        \"\"\"\n        dataset_time_span = f\"1{self.temporal_resolution()[0]}\"  # NOTE this won't work for months (returns 1 minute), we could define a more precise method with if/else statements if needed.\n        complete_time_series = pd.Series(update_dataset[self.time_dim].values)\n        # Define datetime range starts as anything with > 1 unit diff with the previous value,\n        # and ends as > 1 unit diff with the following. First/Last will return NAs we must fill.\n        starts = (complete_time_series - complete_time_series.shift(1)).abs().fillna(\n            pd.Timedelta(dataset_time_span * 100)\n        ) > pd.Timedelta(dataset_time_span)\n        ends = (complete_time_series - complete_time_series.shift(-1)).abs().fillna(\n            pd.Timedelta(dataset_time_span * 100)\n        ) > pd.Timedelta(dataset_time_span)\n        # Filter down the update time series to just the range starts/ends\n        insert_datetimes = complete_time_series[starts + ends]\n        single_datetime_inserts = complete_time_series[starts & ends]\n        # Add single day insert datetimes once more so they can be represented as ranges, then sort for the correct order.\n        # Divide the result into a collection of start/end range arrays\n        insert_datetimes = np.sort(\n            pd.concat(\n                [insert_datetimes, single_datetime_inserts], ignore_index=True\n            ).values\n        )\n        datetime_ranges = np.array_split(insert_datetimes, (len(insert_datetimes) / 2))\n        # Calculate a tuple of the start/end indices for each datetime range\n        regions_indices = []\n        for date_pair in datetime_ranges:\n            start_int = list(original_dataset[self.time_dim].values).index(\\\n                original_dataset.sel(**{self.time_dim : date_pair[0], 'method' : 'nearest'})[self.time_dim]\n            )\n            end_int = (\n                list(original_dataset[self.time_dim].values).index(\n                    original_dataset.sel(**{self.time_dim : date_pair[1], 'method' : 'nearest'})[self.time_dim]\n                )\n                + 1\n            )\n            regions_indices.append((start_int, end_int))\n\n        return datetime_ranges, regions_indices", ""]}
{"filename": "gridded_etl_tools/utils/attributes.py", "chunked_list": ["from abc import ABC, abstractmethod\nfrom .store import StoreInterface, Local\n\n\nclass Attributes(ABC):\n    \"\"\"\n    Abstract base class containing default attributes of Zarr ETLs\n    These can be overriden in the ETL managers for a given ETL as needed\n    \"\"\"\n\n    @classmethod\n    def host_organization(self) -> str:\n        \"\"\"\n        Name of the organization (your organization) hosting the data being published. Used in STAC metadata.\n        \"\"\"\n        return \"\"  # e.g. \"Arbol\"\n\n    @classmethod\n    @abstractmethod\n    def name(cls) -> str:\n        \"\"\"\n        The name of each ETL is built recursively by appending each child class name to the inherited name\n\n        Returns\n        -------\n        str\n           Name of dataset\n\n        \"\"\"\n        ...\n\n    @classmethod\n    @abstractmethod\n    def collection(cls):\n        \"\"\"'\n        Placeholder class for collection name\n        \"\"\"\n        ...\n\n    @property\n    def file_type(cls):\n        \"\"\"\n        Class method to populate with a string representing the file type of each child class (and edition if relevant),\n        e.g. GRIB1 for ERA5 data, GRIB2 for RTMA, or NetCDF for Copernicus Marine Service\n\n        Used to trigger file format-appropriate functions and methods for Kerchunking and Xarray operations.\n        \"\"\"\n        ...\n\n    @classmethod\n    @abstractmethod\n    def remote_protocol(cls):\n        \"\"\"\n        Remote protocol string for MultiZarrToZarr and Xarray to use when opening input files. 'File' for local, 's3' for S3, etc.\n        See fsspec docs for more details.\n        \"\"\"\n        ...\n\n    @classmethod\n    @abstractmethod\n    def identical_dims(cls):\n        \"\"\"\n        List of dimension(s) whose values are identical in all input datasets. This saves Kerchunk time by having it read these\n        dimensions only one time, from the first input file\n        \"\"\"\n        ...\n\n    @classmethod\n    @abstractmethod\n    def concat_dims(cls):\n        \"\"\"\n        List of dimension(s) by which to concatenate input files' data variable(s) -- usually time, possibly with some other relevant dimension\n        \"\"\"\n        ...\n\n    @property\n    def data_var_dtype(self) -> str:\n        \"\"\"\n        Property specifying the data type of the data variable\n\n        Returns\n        -------\n        str\n            The final data type of the dataset's data variable\n        \"\"\"\n        return \"<f4\"\n\n    def spatial_resolution(self) -> float:\n        \"\"\"\n        Property specifying the spatial resolution of a dataset in decimal degrees\n\n        Returns\n        -------\n        float\n            The spatial resolution of a dataset\n        \"\"\"\n        ...\n\n    def spatial_precision(self) -> float:\n        \"\"\"\n        Property specifying the spatial resolution of a dataset in decimal degrees\n\n        Returns\n        -------\n        float\n            The spatial resolution of a dataset\n        \"\"\"\n        ...\n\n    @classmethod\n    @abstractmethod\n    def temporal_resolution(cls) -> str:\n        \"\"\"\n        Returns the time resolution of the dataset as a string (e.g. \"hourly\", \"daily\", \"monthly\", etc.)\n\n        Returns\n        -------\n        str\n           Temporal resolution of the dataset\n\n        \"\"\"\n        ...\n\n    @classmethod\n    def update_cadence(self) -> str:\n        \"\"\"\n        Property specifying the frequency with which a dataset is updated\n        Optional class method, may just be specified directly in the static metadata\n\n        Returns\n        -------\n        str\n            The update frequency of a dataset\n        \"\"\"\n        ...\n\n    @classmethod\n    def missing_value_indicator(cls) -> str:\n        \"\"\"\n        Default indicator of a missing value in a dataset\n\n        Returns\n        -------\n        str\n           Stand-in for a missing value\n\n        \"\"\"\n        return \"\"\n\n\n    @property\n    def tags(cls) -> list[str]:\n        \"\"\"\n        Default tag for a dataset. Prevents crashes on parse if no tags assigned.\n\n        Returns\n        -------\n        list[str]\n           Stand-in for a dataset's tags\n\n        \"\"\"\n        return [\"\"]\n\n    @property\n    def forecast(self) -> bool:\n        \"\"\"Forecast defaults to False, must override for actual forecast datasets\"\"\"\n        return False\n\n    @property\n    def bbox_rounding_value(self) -> int:\n        \"\"\"\n        Value to round bbox values by. Specify within the dataset for very high resolution datasets\n        to prevent mismatches with rounding behavior of old Arbol API.\n\n        Returns\n        -------\n        int\n            The number of decimal places to round bounding box values to.\n        \"\"\"\n        return 5\n\n    @property\n    def store(self) -> StoreInterface:\n        \"\"\"\n        Get the store interface object for the store the output will be written to.\n\n        If it has not been previously set, a `etls.utils.store.Local` will be initialized and returned.\n\n        Returns\n        -------\n        StoreInterface\n            Object for interfacing with a Zarr's data store.\n        \"\"\"\n        if not hasattr(self, \"_store\"):\n            self._store = Local(self)\n        return self._store\n\n    @store.setter\n    def store(self, value: StoreInterface):\n        \"\"\"\n        Assign a `StoreInterface` to the store property. If the assigned value is not an instance of `StoreInterface`,\n        a `ValueError` will be raised.\n\n        Parameters\n        ----------\n        value\n            An instance of `StoreInterface`\n\n        Raises\n        ------\n        ValueError\n            Raised if anything other than a `StoreInterface` is passed.\n        \"\"\"\n        if isinstance(value, StoreInterface):\n            self._store = value\n        else:\n            raise ValueError(f\"Store must be an instance of {StoreInterface}\")", ""]}
{"filename": "gridded_etl_tools/utils/store.py", "chunked_list": ["# The annotations dict and TYPE_CHECKING var are necessary for referencing types that aren't fully imported yet. See https://peps.python.org/pep-0563/\nfrom __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from .. import dataset_manager\n\nimport datetime\nimport json\n\nimport os", "\nimport os\nimport shutil\nimport s3fs\nimport xarray as xr\nimport ipldstore\nimport pathlib\nimport fsspec\nimport collections\n", "import collections\n\nfrom abc import abstractmethod, ABC\n\n\nclass StoreInterface(ABC):\n    \"\"\"\n    Base class for an interface that can be used to access a dataset's Zarr.\n\n    Zarrs can be stored in different types of data stores, for example IPLD, S3, and the local filesystem, each of which is accessed slightly\n    differently in Python. This class abstracts the access to the underlying data store by providing functions that access the Zarr on the store\n    in a uniform way, regardless of which is being used.\n    \"\"\"\n\n    def __init__(self, dm: dataset_manager.DatasetManager):\n        \"\"\"\n        Create a new `StoreInterface`. Pass the dataset manager this store is being associated with, so the interface will have access to\n        dataset properties.\n\n        Parameters\n        ----------\n        dm : dataset_manager.DatasetManager\n            The dataset to be read or written.\n        \"\"\"\n        self.dm = dm\n\n    @abstractmethod\n    def mapper(self, **kwargs: dict) -> collections.abc.MutableMapping:\n        \"\"\"\n        Parameters\n        ----------\n        **kwargs : dict\n            Implementation specific keywords\n\n        Returns\n        -------\n        collections.abc.MutableMapping\n            A key/value mapping of files to contents\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def has_existing(self) -> bool:\n        \"\"\"\n        Returns\n        -------\n        bool\n            Return `True` if there is existing data for this dataset on the store.\n        \"\"\"\n        pass\n\n    def dataset(self, **kwargs: dict) -> xr.Dataset | None:\n        \"\"\"\n        Parameters\n        ----------\n        **kwargs\n            Implementation specific keyword arguments to forward to `StoreInterface.mapper`. S3 and Local accept `refresh`, and IPLD accepts `set_root`.\n\n        Returns\n        -------\n        xr.Dataset | None\n            The dataset opened in xarray or None if there is no dataset currently stored.\n        \"\"\"\n        if self.has_existing:\n            return xr.open_zarr(self.mapper(**kwargs))\n        else:\n            return None", "\n\nclass S3(StoreInterface):\n    \"\"\"\n    Provides an interface for reading and writing a dataset's Zarr on S3.\n\n    To connect to a Zarr on S3 (i.e., at \"s3://[bucket]/[dataset_json_key].zarr\"), create a new S3 object using a `dataset_manager.DatasetManager` object\n    and bucket name, and define both `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` in the ~/.aws/credentials file or shell environment.\n\n    After initialization, use the member functions to access the Zarr. For example, call `S3.mapper` to get a `MutableMapping` that can be passed to\n    `xarray.open_zarr` and `xarray.to_zarr`.\n    \"\"\"\n\n    def __init__(self, dm: dataset_manager.DatasetManager, bucket: str):\n        \"\"\"\n        Get an interface to a dataset's Zarr on S3 in the specified bucket.\n\n        Parameters\n        ----------\n        dm : dataset_manager.DatasetManager\n            The dataset to be read or written.\n        bucket : str\n            The name of the S3 bucket to connect to (s3://[bucket])\n        \"\"\"\n        super().__init__(dm)\n        if not bucket:\n            raise ValueError(\"Must provide bucket name if parsing to S3\")\n        self.bucket = bucket\n\n    def fs(self, refresh: bool = False) -> s3fs.S3FileSystem:\n        \"\"\"\n        Get an `s3fs.S3FileSystem` object. No authentication is performed on this step. Authentication will be performed according to the rules\n        at https://s3fs.readthedocs.io/en/latest/#credentials when accessing the data.\n\n        By default, the filesystem is only created once, the first time this function is called. To force it create a new one, set `refresh`\n        to `True`.\n\n        Parameters\n        ----------\n        refresh : bool\n            If set to `True`, a new `s3fs.S3FileSystem` will be created even if this object has one already\n\n        Returns\n        -------\n        s3fs.S3FileSystem\n            A filesystem object for interfacing with S3\n        \"\"\"\n        if refresh or not hasattr(self, \"_fs\"):\n            self._fs = s3fs.S3FileSystem()\n            self.dm.info(\"Initialized S3 filesystem. Credentials will be looked up according to rules at https://s3fs.readthedocs.io/en/latest/#credentials\")\n        return self._fs\n\n    @property\n    def url(self) -> str:\n        \"\"\"\n        Get the S3-protocol URL to the parent `DatasetManager`'s Zarr .\n\n        Returns\n        -------\n        str\n            A URL string starting with \"s3://\" followed by the path to the Zarr.\n        \"\"\"\n        return f\"s3://{self.bucket}/datasets/{self.dm.json_key()}.zarr\"\n\n    def __str__(self) -> str:\n        return self.url\n\n    def mapper(self, refresh: bool = False, **kwargs: dict) -> fsspec.mapping.FSMap:\n        \"\"\"\n        Get a `MutableMapping` representing the S3 key/value store. By default, the mapper will be created only once, when this function is first\n        called. To force a new mapper, set `refresh` to `True`.\n\n        Parameters\n        ----------\n        refresh : bool\n            Set to `True` to force a new mapper to be created even if this object has one already\n        **kwargs : dict\n            Arbitrary keyword args supported for compatibility with IPLD.\n\n        Returns\n        -------\n        s3fs.S3Map\n            A `MutableMapping` which is the S3 key/value store\n        \"\"\"\n        if refresh or not hasattr(self, \"_mapper\"):\n            self._mapper = s3fs.S3Map(root=self.url, s3=self.fs())\n        return self._mapper\n\n    @property\n    def has_existing(self) -> bool:\n        \"\"\"\n        Returns\n        -------\n        bool\n            Return `True` if there is a Zarr at `S3.url`\n        \"\"\"\n        return self.fs().exists(self.url)\n\n    def push_metadata(self, title: str, stac_content: dict, stac_type: str):\n        \"\"\"\n        Publish metadata entity to s3 store. Tracks historical state\n        of metadata as well\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_content : dict\n            content of the stac entity\n        stac_type : StacType\n            Path part corresponding to type of STAC entity\n            (empty string for Catalog, 'collections' for Collection or 'datasets' for Item)\n        \"\"\"\n        metadata_path = self.get_metadata_path(title, stac_type)\n        if self.fs().exists(metadata_path):\n            # Generate history file\n            old_mod_time = self.fs().ls(metadata_path, detail=True)[0][\"LastModified\"]\n            history_file_name = f\"{title}-{old_mod_time.isoformat(sep='T')}.json\"\n            history_path = f\"s3://{self.bucket}/history/{title}/{history_file_name}\"\n            self.fs().copy(metadata_path, history_path)\n\n        self.fs().write_text(metadata_path, json.dumps(stac_content))\n\n    def retrieve_metadata(self, title: str, stac_type: str) -> tuple[dict, str]:\n        \"\"\"\n        Retrieve metadata entity from s3 store\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_type : StacType\n            Path part corresponding to type of STAC entity\n            (empty string for Catalog, 'collections' for Collection or 'datasets' for Item)\n\n        Returns\n        -------\n        dict\n            Tuple of content of stac entity as dict and the s3 path as a string\n        \"\"\"\n        metadata_path = self.get_metadata_path(title, stac_type)\n        return json.loads(self.fs().cat(metadata_path)), metadata_path\n\n    def metadata_exists(self, title: str, stac_type: str) -> bool:\n        \"\"\"\n        Check whether metadata exists at a given s3 path\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_type : StacType\n            Path part corresponding to type of STAC entity\n            (empty string for Catalog, 'collections' for Collection or 'datasets' for Item)\n\n        Returns\n        -------\n        bool\n            Whether metadata exists at path\n        \"\"\"\n        metadata_path = self.get_metadata_path(title, stac_type)\n        return self.fs().exists(metadata_path)\n\n    def get_metadata_path(self, title: str, stac_type: str) -> str:\n        \"\"\"\n        Get the s3 path for a given STAC title and type\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_type : StacType\n            Path part corresponding to type of STAC entity\n            (empty string for Catalog, 'collections' for Collection or 'datasets' for Item)\n\n        Returns\n        -------\n        str\n            The s3 path for this entity as a string\n        \"\"\"\n        if stac_type:\n            return f\"s3://{self.bucket}/metadata/{stac_type}/{title}.json\"\n        else:\n            return f\"s3://{self.bucket}/metadata/{title}.json\"", "\n\nclass IPLD(StoreInterface):\n    \"\"\"\n    Provides an interface for reading and writing a dataset's Zarr on IPLD.\n\n    If there is existing data for the dataset, it is assumed to be stored at the hash returned by `IPLD.dm.latest_hash`, and the mapper will\n    return a hash that can be used to retrieve the data. If there is no existing data, or the mapper is called without `set_root`, an unrooted\n    IPFS mapper will be returned that can be used to write new data to IPFS and generate a new recursive hash.\n    \"\"\"\n\n    def mapper(self, set_root: bool = True, refresh: bool = False, **kwargs: dict) -> ipldstore.IPLDStore:\n        \"\"\"\n        Get an IPLD mapper by delegating to `ipldstore.get_ipfs_mapper`, passing along an IPFS chunker value if the associated dataset's\n        `requested_ipfs_chunker` property has been set.\n\n        If `set_root` is `False`, the root will not be set to the latest hash, so the mapper can be used to open a new Zarr on the IPLD\n        datastore. Otherwise, `DatasetManager.latest_hash` will be used to get the latest hash (which is stored in the STAC at the IPNS key\n        for the dataset).\n\n        Parameters\n        ----------\n        set_root : bool\n            Return a mapper rooted at the dataset's latest hash if `True`, otherwise return a new mapper.\n        refresh : bool\n            Force getting a new mapper by checking the latest IPNS hash. Without this set, the mapper will only be set the first time this\n            function is called.\n        **kwargs\n            Arbitrary keyword args supported for compatibility with S3 and Local.\n\n        Returns\n        -------\n        ipldstore.IPLDStore\n            An IPLD `MutableMapping`, usable, for example, to open a Zarr with `xr.open_zarr`\n        \"\"\"\n        if refresh or not hasattr(self, \"_mapper\"):\n            if self.dm.requested_ipfs_chunker:\n                self._mapper = ipldstore.get_ipfs_mapper(host=self.dm._host, chunker=self.dm.requested_ipfs_chunker)\n            else:\n                self._mapper = ipldstore.get_ipfs_mapper(host=self.dm._host)\n            self.dm.info(f\"IPFS chunker is {self._mapper._store._chunker}\")\n            if set_root and self.dm.latest_hash():\n                self._mapper.set_root(self.dm.latest_hash())\n        return self._mapper\n\n    def __str__(self) -> str:\n        \"\"\"\n        Returns\n        -------\n        str\n            The path as \"/ipfs/[hash]\". If the hash has not been determined, just return \"/ipfs/\".\n        \"\"\"\n        if not self.dm.latest_hash():\n            return \"/ipfs/\"\n        else:\n            return f\"/ipfs/{self.dm.latest_hash()}\"\n\n    @property\n    def has_existing(self) -> bool:\n        \"\"\"\n        Returns\n        -------\n        bool\n            Return `True` if the dataset has a latest hash, or `False` otherwise.\n        \"\"\"\n        return bool(self.dm.latest_hash())", "\n\nclass Local(StoreInterface):\n    \"\"\"\n    Provides an interface for reading and writing a dataset's Zarr on the local filesystem.\n\n    The path of the Zarr is assumed to be the return value of `Local.dm.output_path`. That is the path used automatically under normal conditions, so this\n    class doesn't provide a way to use any other path.\n    \"\"\"\n\n    def fs(self, refresh: bool = False) -> fsspec.implementations.local.LocalFileSystem:\n        \"\"\"\n        Get an `fsspec.implementations.local.LocalFileSystem` object. By default, the filesystem is only created once, the first time this function is\n        called. To force it create a new one, set `refresh` to `True`.\n\n        Parameters\n        ----------\n        refresh : bool\n            If set to `True`, a new `fsspec.implementations.local.LocalFileSystem` will be created even if this object has one already\n\n        Returns\n        -------\n        fsspec.implementations.local.LocalFileSystem\n            A filesystem object for interfacing with the local filesystem\n        \"\"\"\n        if refresh or not hasattr(self, \"_fs\"):\n            self._fs = fsspec.filesystem(\"file\")\n        return self._fs\n\n    def mapper(self, refresh=False, **kwargs) -> fsspec.mapping.FSMap:\n        \"\"\"\n        Get a `MutableMapping` representing a local filesystem key/value store.\n        By default, the mapper will be created only once, when this function is first\n        called. To force a new mapper, set `refresh` to `True`.\n\n        Parameters\n        ----------\n        refresh : bool\n            Set to `True` to force a new mapper to be created even if this object has one already.\n        **kwargs : dict\n            Arbitrary keyword args supported for compatibility with IPLD.\n\n        Returns\n        -------\n        fsspec.mapping.FSMap\n            A `MutableMapping` which is a key/value representation of the local filesystem\n        \"\"\"\n        if refresh or not hasattr(self, \"_mapper\"):\n            self._mapper = self.fs().get_mapper(self.path)\n        return self._mapper\n\n    def __str__(self) -> str:\n        return str(self.path)\n\n    @property\n    def path(self) -> pathlib.Path:\n        \"\"\"\n        Returns\n        -------\n        pathlib.Path\n            Path to the Zarr on the local filesystem\n        \"\"\"\n        return self.dm.output_path().joinpath(f\"{self.dm.name()}.zarr\")\n\n    @property\n    def has_existing(self) -> bool:\n        \"\"\"\n        Returns\n        -------\n        bool\n            Return `True` if there is a local Zarr for this dataset, `False` otherwise.\n        \"\"\"\n        return self.path.exists()\n\n    def push_metadata(self, title: str, stac_content: dict, stac_type: str):\n        \"\"\"\n        Publish metadata entity to local store. Tracks historical state\n        of metadata as well\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_content : dict\n            content of the stac entity\n        stac_type : StacType\n            Path part corresponding to type of STAC entity\n            (empty string for Catalog, 'collections' for Collection or 'datasets' for Item)\n        \"\"\"\n        metadata_path = self.get_metadata_path(title, stac_type)\n        if pathlib.Path.exists(metadata_path):\n            # Generate history file\n            old_mod_time = datetime.datetime.fromtimestamp(\n                metadata_path.stat().st_mtime\n            )\n            history_path = (\n                pathlib.Path()\n                / \"history\"\n                / title\n                / f\"{title}-{old_mod_time.isoformat(sep='T')}.json\"\n            )\n            history_path.parent.mkdir(exist_ok=True, parents=True)\n            shutil.copy(metadata_path, history_path)\n\n        # Write new metadata to file (may overwrite)\n        metadata_path.parent.mkdir(exist_ok=True, parents=True)\n        with open(metadata_path, \"w\") as f:\n            json.dump(stac_content, f)\n\n    def retrieve_metadata(self, title: str, stac_type: str) -> tuple[dict, str]:\n        \"\"\"\n        Retrieve metadata entity from local store\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_type : StacType\n            Path part corresponding to type of STAC entity\n            (empty string for Catalog, 'collections' for Collection or 'datasets' for Item)\n\n        Returns\n        -------\n        dict\n            Tuple of content of stac entity as dict and the local path as a string\n        \"\"\"\n        metadata_path = self.get_metadata_path(title, stac_type)\n        with open(metadata_path) as f:\n            return json.load(f), str(metadata_path)\n\n    def metadata_exists(self, title: str, stac_type: str) -> bool:\n        \"\"\"\n        Check whether metadata exists at a given local path\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_type : StacType\n            Path part corresponding to type of STAC entity\n            (empty string for Catalog, 'collections' for Collection or 'datasets' for Item)\n\n        Returns\n        -------\n        bool\n            Whether metadata exists at path\n        \"\"\"\n        metadata_path = self.get_metadata_path(title, stac_type)\n        return pathlib.Path.exists(metadata_path)\n\n    def get_metadata_path(self, title: str, stac_type: str) -> pathlib.Path:\n        \"\"\"\n        Get the local path for a given STAC title and type\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_type : StacType\n            Path part corresponding to type of STAC entity\n            (empty string for Catalog, 'collections' for Collection or 'datasets' for Item)\n\n        Returns\n        -------\n        str\n            The s3 path for this entity as a pathlib.Path\n        \"\"\"\n        return (pathlib.Path() / \"metadata\" / stac_type / f\"{title}.json\").resolve()", ""]}
{"filename": "gridded_etl_tools/utils/metadata.py", "chunked_list": ["from enum import Enum\nimport json\nimport datetime\nimport shapely\nimport numcodecs\n\nimport numpy as np\nimport xarray as xr\n\nfrom shapely import geometry  # must be imported by name or shapely.geometry calls will fail", "\nfrom shapely import geometry  # must be imported by name or shapely.geometry calls will fail\nfrom .ipfs import IPFS\nfrom .convenience import Convenience\nfrom .store import IPLD, Local\n\nfrom abc import abstractmethod\nfrom requests.exceptions import Timeout as TimeoutError\n\n\nclass Metadata(Convenience, IPFS):\n    \"\"\"\n    Base class containing metadata creation and editing methods Zarr ETLs\n    Includes STAC Metadata templates for Items, Collections, and the root Catalog\n    \"\"\"\n\n    @classmethod\n    def default_stac_item(cls) -> dict:\n        \"\"\"\n        Default metadata template for STAC Items\n\n        Returns\n        -------\n        dict\n            The STAC Item metadata template with all pre-fillable values populated\n        \"\"\"\n        return {\n            \"stac_version\": \"1.0.0\",\n            \"type\": \"Feature\",\n            \"id\": cls.name(),\n            \"collection\": cls.collection(),\n            \"links\": [],\n            \"assets\": {\n                \"zmetadata\": {\n                    \"title\": cls.name(),\n                    \"type\": \"application/json\",\n                    \"description\": f\"Consolidated metadata file for {cls.name()} Zarr store, readable as a Zarr dataset by Xarray\",\n                    \"roles\": [\"metadata\", \"zarr-consolidated-metadata\"],\n                }\n            },\n        }\n\n    @property\n    def default_stac_collection(self) -> dict:\n        \"\"\"\n        Default metadata template for STAC collections\n\n        Returns\n        -------\n        dict\n            The STAC Collection metadata template with all pre-fillable values populated\n        \"\"\"\n        return {\n            \"id\": self.collection(),\n            \"type\": \"Collection\",\n            \"stac_extensions\": [\n                \"https://stac-extensions.github.io/projection/v1.0.0/schema.json\"\n            ],\n            \"stac_version\": \"1.0.0\",\n            \"description\": self.metadata[\"provider description\"],\n            \"license\": self.metadata[\"license\"],\n            \"collection\": self.collection(),\n            \"title\": self.metadata[\"title\"],\n            \"extent\": {\"spatial\": {\"bbox\": [[]]}, \"temporal\": {\"interval\": [[]]}},\n            \"links\": [\n                {\"rel\": \"self\", \"type\": \"application/json\", \"title\": self.collection()}\n            ],\n            \"providers\": [\n                {\n                    \"name\": f\"{self.host_organization()}\",\n                    \"description\": \"\",  # provide description for your organization here\n                    \"roles\": [\"processor\"],  #\n                    \"url\": \"\",  # provide URL for your organization here\n                },\n                {\n                    \"name\": self.metadata[\"publisher\"],\n                    \"description\": self.metadata[\"provider description\"],\n                    \"roles\": [\"producer\"],\n                    \"url\": self.metadata[\"provider url\"],\n                    \"terms of service\": self.metadata[\"terms of service\"],\n                },\n            ],\n            \"summaries\": {\"proj:epsg\": self.metadata[\"coordinate reference system\"]},\n        }\n\n    @classmethod\n    def default_root_stac_catalog(cls) -> dict:\n        \"\"\"\n        Default metadata template for the {self.host_organization()} root Catalog\n\n        Returns\n        -------\n        dict\n            The STAC Catalog metadata template with all pre-fillable values populated\n        \"\"\"\n        return {\n            \"id\": f\"{cls.host_organization()}_data_catalog\",\n            \"type\": \"Catalog\",\n            \"title\": f\"{cls.host_organization()} Data Catalog\",\n            \"stac_version\": \"1.0.0\",\n            \"description\": f\"This catalog contains all the data uploaded to {cls.host_organization()} \\\n                that has been issued STAC-compliant metadata. The catalogs and collections describe single providers. \\\n                Each may contain one or multiple datasets. Each individual dataset has been documented as STAC Items.\",\n        }\n\n    @abstractmethod\n    def static_metadata(cls):\n        \"\"\"\n        Placeholder for static metadata pertaining to each ETL\n        \"\"\"\n        ...\n\n    def check_stac_exists(self, title: str, stac_type: \"StacType\") -> bool:\n        \"\"\"Check if a STAC entity exists in the backing store\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_type : StacType\n            Type of STAC entity (Catalog, Collection or Item)\n\n        Returns\n        -------\n        bool\n            Whether the entity exists in the backing store\n        \"\"\"\n        if isinstance(self.store, IPLD):\n            return self.check_stac_on_ipns(title)\n        else:\n            return self.store.metadata_exists(title, stac_type.value)\n\n    def publish_stac(self, title: str, stac_content: dict, stac_type: \"StacType\"):\n        \"\"\"Publish a STAC entity to the backing store\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_content : dict\n            content of the stac entity\n        stac_type : StacType\n            Type of STAC entity (Catalog, Collection or Item)\n        \"\"\"\n        if isinstance(self.store, IPLD):\n            self.ipns_publish(title, self.ipfs_put(self.json_to_bytes(stac_content)))\n        else:\n            self.store.push_metadata(title, stac_content, stac_type.value)\n\n    def retrieve_stac(self, title: str, stac_type: \"StacType\") -> tuple[dict, str]:\n        \"\"\"Retrieve a STAC entity and its href from the backing store\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_type : StacType\n            Type of STAC entity (Catalog, Collection or Item)\n\n        Returns\n        -------\n        tuple[dict, str | pathlib.Path]\n            tuple of STAC content and the href for the STAC\n        \"\"\"\n        if isinstance(self.store, IPLD):\n            return self.ipns_retrieve_object(title)\n        else:\n            return self.store.retrieve_metadata(title, stac_type.value)\n\n    def get_href(self, title: str, stac_type: \"StacType\") -> str:\n        \"\"\"Get a STAC entity's href from the backing store. Might be\n        an IPNS name, a local path or a s3 path depending on the store\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_type : StacType\n            Type of STAC entity (Catalog, Collection or Item)\n\n        Returns\n        -------\n        str\n            string representation of href.\n        \"\"\"\n        if isinstance(self.store, IPLD):\n            return self.ipns_generate_name(key=title)\n        else:\n            return str(self.store.get_metadata_path(title, stac_type.value))\n\n    def create_root_stac_catalog(self):\n        \"\"\"\n        Prepare a root catalog for your organization if it doesn't already exist.\n        \"\"\"\n        root_catalog = self.default_root_stac_catalog()\n        root_catalog_exists = self.check_stac_exists(\n            root_catalog[\"title\"], StacType.CATALOG\n        )\n        if not root_catalog_exists:\n            # Publish the root catalog if it doesn't exist\n            self.info(f\"Publishing root {self.host_organization()} STAC Catalog\")\n            catalog_href = self.get_href(root_catalog[\"title\"], StacType.CATALOG)\n            root_catalog[\"links\"] = [\n                {\n                    \"rel\": \"root\",\n                    \"href\": catalog_href,\n                    \"type\": \"application/json\",\n                    \"title\": f\"{self.host_organization()} root catalog\",\n                },\n                {\n                    \"rel\": \"self\",\n                    \"href\": catalog_href,\n                    \"type\": \"application/json\",\n                    \"title\": f\"{self.host_organization()} root catalog\",\n                },\n            ]\n            self.publish_stac(root_catalog[\"title\"], root_catalog, StacType.CATALOG)\n        else:\n            self.info(\n                f\"Root {self.host_organization()} STAC Catalog already exists, building collection\"\n            )\n            ...\n\n    def create_stac_collection(self, dataset: xr.Dataset, rebuild: bool = False):\n        \"\"\"\n        Prepare a parent collection for the dataset the first time it's created.\n        In order to check for the collection's existence we must populate the relevant dictionary first in order to use its attributes.\n\n        Parameters\n        ----------\n        dataset : xr.Dataset\n            The dataset being published\n        rebuild : bool, optional\n            Whether to recreate the STAC Collection from scratch or not\n        Returns\n        -------\n        bool\n            Whether the stac collection was created\n        \"\"\"\n        stac_coll = self.default_stac_collection\n        # Check if the collection already exists to avoid duplication of effort\n        # Populate and publish a collection if one doesn't exist, or a rebuild was requested\n        if rebuild or not self.check_stac_exists(\n            self.collection(), StacType.COLLECTION\n        ):\n            if rebuild:\n                self.info(\n                    \"Collection rebuild requested. Creating new collection, pushing it to IPFS, and populating the main catalog\"\n                )\n            # Populate data-driven attributes of the collection\n            minx, miny, maxx, maxy = self.bbox_coords(dataset)\n            stac_coll[\"extent\"][\"spatial\"][\"bbox\"] = [[minx, miny, maxx, maxy]]\n            stac_coll[\"extent\"][\"temporal\"][\"interval\"] = [\n                [\n                    self.numpydate_to_py(dataset[self.time_dim].values.min()).isoformat() + \"Z\",\n                    self.numpydate_to_py(dataset[self.time_dim].values.max()).isoformat() + \"Z\",\n                ]\n            ]\n            # Create an href corresponding to the collection in order to note this in the collection and root catalog.\n            href = self.get_href(self.collection(), StacType.COLLECTION)\n            # Append collection to the root catalog if it doesn't already exist\n            root_catalog, root_catalog_href = self.retrieve_stac(\n                self.default_root_stac_catalog()[\"title\"], StacType.CATALOG\n            )\n            if not any(\n                stac_coll[\"title\"] in link_dict.values()\n                for link_dict in root_catalog[\"links\"]\n            ):\n                self.info(\n                    f\"Appending collection link to root {self.host_organization()} STAC Catalog\"\n                )\n                root_catalog[\"links\"].append(\n                    {\n                        \"rel\": \"child\",\n                        \"href\": href,\n                        \"type\": \"application/json\",\n                        \"title\": stac_coll[\"title\"],\n                    }\n                )\n                self.publish_stac(\n                    root_catalog[\"title\"],\n                    root_catalog,\n                    StacType.CATALOG,\n                )\n            # Add links and publish this collection\n            for link_dict in stac_coll[\"links\"]:\n                if link_dict[\"rel\"] == \"self\":\n                    link_dict[\"href\"] = href\n            stac_coll[\"links\"] = stac_coll[\"links\"] + [\n                {\n                    \"rel\": \"root\",\n                    \"href\": root_catalog_href,\n                    \"type\": \"application/json\",\n                    \"title\": f\"{self.host_organization()} root catalog\",\n                },\n                {\n                    \"rel\": \"parent\",\n                    \"href\": root_catalog_href,\n                    \"type\": \"application/json\",\n                    \"title\": f\"{self.host_organization()} root catalog\",\n                },\n            ]\n            self.publish_stac(self.collection(), stac_coll, StacType.COLLECTION)\n        else:\n            self.info(\n                \"Found existing STAC Collection for this dataset, skipping creation and updating instead\"\n            )\n            self.update_stac_collection(dataset)\n\n    def create_stac_item(self, dataset: xr.Dataset):\n        \"\"\"\n        Reformat previously prepared metadata and prepare key overviews of a dataset's spatial, temporal, and data dimensions into a STAC Item-compliant JSON.\n        Push this JSON to IPFS and its relevant parent STAC Collection via `register_stac_item`\n\n        Parameters\n        ----------\n        dataset : xr.Dataset\n            The dataset being published\n        \"\"\"\n        self.info(\"Creating STAC Item\")\n        stac_item = self.default_stac_item()\n        # Filter relevant existing metadata from the Zarr, flatten to a single level, and output as a dict for the \"properties\" key in STAC metadata\n        properties_dict = self.zarr_md_to_stac_format(dataset)\n        # Include the array size\n        properties_dict[\"array_size\"] = {\n            \"latitude\": dataset.latitude.size,\n            \"longitude\": dataset.longitude.size,\n            self.time_dim : dataset[self.time_dim].size,\n        }\n        if self.time_dim == 'forecast_reference_time':\n            properties_dict[\"array_size\"].update({\"step\" : dataset.step.size})\n        # Set up date items in STAC-compliant style\n        properties_dict[\"start_datetime\"] = (\n            self.numpydate_to_py(dataset[self.time_dim].values[0]).isoformat() + \"Z\"\n        )\n        properties_dict[\"end_datetime\"] = (\n            self.numpydate_to_py(dataset[self.time_dim].values[-1]).isoformat() + \"Z\"\n        )\n        properties_dict[\"updated\"] = (\n            datetime.datetime.utcnow()\n            .replace(tzinfo=datetime.timezone.utc)\n            .isoformat()[:-13]\n            + \"Z\"\n        )\n        # Populate the empty STAC Item\n        minx, miny, maxx, maxy = self.bbox_coords(dataset)\n        stac_item[\"bbox\"] = [minx, miny, maxx, maxy]\n        stac_item[\"geometry\"] = json.dumps(\n            shapely.geometry.mapping(shapely.geometry.box(minx, miny, maxx, maxy))\n        )\n        if isinstance(self.store, IPLD):\n            zarr_href = {\"/\": self.latest_hash()}\n        elif isinstance(self.store, Local):\n            zarr_href = str(self.store.path)\n        else:\n            zarr_href = self.store.url\n        stac_item[\"assets\"][\"zmetadata\"][\"href\"] = zarr_href\n        stac_item[\"properties\"] = properties_dict\n        # Push to backing store w/ link to href\n        self.register_stac_item(stac_item)\n\n    def zarr_md_to_stac_format(self, dataset: xr.Dataset) -> dict:\n        \"\"\"\n        Reduce attributes metadata of a Zarr dataset to a flat dictionary with STAC-compliant keys and values\n\n        Parameters\n        ----------\n        dataset : xr.Dataset\n            The dataset being published\n\n        Returns\n        -------\n        dict\n            Single-level dictionary containing all relevant metadata fields from the Zarr dataset with STAC-compliant names and formats\n        \"\"\"\n        # Filter down and name correctly needed attributes\n        zarr_attrs = {\n            \"missing value\",\n            \"dtype\",\n            \"preferred_chunks\",\n            \"Conventions\",\n            \"spatial resolution\",\n            \"spatial precision\",\n            \"temporal resolution\",\n            \"update cadence\",\n            \"unit of measurement\",\n            \"tags\",\n            \"standard name\",\n            \"long name\",\n            \"date range\",\n            \"dataset description\",\n            \"dataset download url\",\n            \"created\",\n            \"updated\",\n            \"finalization date\",\n            \"analysis data download url\",\n            \"reanalysis data download url\",\n            \"input history cid\",\n            \"input history JSON documentation\",\n        }\n        all_md = {\n            **dataset.attrs,\n            **dataset.encoding,\n            **dataset[self.data_var()].encoding,\n        }\n        all_md = {key: all_md[key] for key in zarr_attrs if key in all_md}\n        rename_dict = {\n            \"preferred_chunks\": \"Zarr chunk size\",\n            \"missing value\": \"Fill value\",\n            \"Conventions\": \"CF convention\",\n        }\n        properties_dict = {rename_dict.get(k, k): v for k, v in all_md.items()}\n        # Reformat attributes\n        for k, v in properties_dict.items():\n            if type(v) is np.float32:\n                properties_dict[k] = round(\n                    float(v), 8\n                )  # np.float32s aren't JSON serializable\n        properties_dict[\"dtype\"] = str(properties_dict[\"dtype\"])\n\n        return properties_dict\n\n    def register_stac_item(self, stac_item: dict):\n        \"\"\"'\n        Register a new dataset in an existing STAC Collection and/or replace a dataset's STAC Item with an updated one\n\n        Parameters\n        ----------\n        stac_item : dict\n            A dictionary of metadata prepared in `create_stac_item` for publication as a standalone STAC metadata file\n        \"\"\"\n        self.info(\"Registering STAC Item in IPFS and its parent STAC Collection\")\n        # Generate variables of interest\n        stac_coll, collection_href = self.retrieve_stac(\n            str(self.collection()), StacType.COLLECTION\n        )\n        # Register links\n        stac_item[\"links\"].append(\n            {\n                \"rel\": \"parent\",\n                \"href\": str(collection_href),\n                \"type\": \"application/geo+json\",\n                \"title\": stac_coll[\"title\"],\n            }\n        )\n        # Check if an older version of the STAC Item exists and if so create a \"previous\" link for them in the new STAC Item\n        try:\n            old_stac_item, href = self.retrieve_stac(self.json_key(), StacType.ITEM)\n            if isinstance(self.store, IPLD):\n                # If IPLD, generate the previous hash link\n                old_item_ipfs_hash = self.ipns_resolve(self.json_key())\n                self.info(\"Updating 'previous' link in dataset's STAC Item\")\n                stac_item[\"links\"].append(\n                    {\n                        \"rel\": \"prev\",\n                        \"href\": str(\n                            old_stac_item[\"assets\"][\"zmetadata\"][\"href\"].set(\n                                base=self._default_base\n                            )\n                        ),  # convert CID object back to hash str\n                        \"metadata href\": {\"/\": old_item_ipfs_hash},\n                        \"type\": \"application/geo+json\",\n                        \"title\": stac_item[\"assets\"][\"zmetadata\"][\"title\"],\n                    }\n                )\n        except (KeyError, TimeoutError, FileNotFoundError):\n            # Otherwise create a STAC name for your new dataset\n            self.info(\"No previous STAC Item found\")\n            href = self.get_href(self.json_key(), StacType.ITEM)\n        stac_item[\"links\"].append(\n            {\n                \"rel\": \"self\",\n                \"href\": str(href),\n                \"type\": \"application/geo+json\",\n                \"title\": f\"{self.name()} metadata\",\n            }\n        )\n        # push final STAC Item to backing store\n        self.info(\"Pushing STAC Item to backing store\")\n        self.publish_stac(self.json_key(), stac_item, StacType.ITEM)\n        # register item as a link in the relevant collection, if not already there, and push updated collection to IPFS\n        if any(\n            stac_item[\"assets\"][\"zmetadata\"][\"title\"] in link_dict[\"title\"]\n            for link_dict in stac_coll[\"links\"]\n            if \"title\" in link_dict.keys()\n        ):\n            self.info(\"Found existing STAC Item in STAC Collection\")\n            ...\n        else:\n            self.info(\n                \"No existing STAC Item found in this dataset's parent collection, inserting a child link\"\n            )\n            # register hrefs in both the Item and Collection and publish updated objects\n            stac_coll[\"links\"].append(\n                {\n                    \"rel\": \"item\",\n                    \"href\": str(href),\n                    \"type\": \"application/json\",\n                    \"title\": stac_item[\"assets\"][\"zmetadata\"][\"title\"],\n                }\n            )\n            self.publish_stac(self.collection(), stac_coll, StacType.COLLECTION)\n\n    def update_stac_collection(self, dataset: xr.Dataset):\n        \"\"\"'\n        Update fields in STAC Collection corresponding to a dataset\n\n        Parameters\n        ----------\n        dataset : xr.Dataset\n            The dataset being published\n        \"\"\"\n        self.info(\"Updating dataset's parent STAC Collection\")\n        # Get existing STAC Collection and add new datasets to it, if necessary\n        stac_coll = self.retrieve_stac(self.collection(), StacType.COLLECTION)[0]\n        # Update spatial extent\n        min_bbox_coords = np.minimum(\n            stac_coll[\"extent\"][\"spatial\"][\"bbox\"][0], [self.bbox_coords(dataset)]\n        )[0][0:2]\n        max_bbox_coords = np.maximum(\n            stac_coll[\"extent\"][\"spatial\"][\"bbox\"][0], [self.bbox_coords(dataset)]\n        )[0][2:4]\n        stac_coll[\"extent\"][\"spatial\"][\"bbox\"] = [\n            list(np.concatenate([min_bbox_coords, max_bbox_coords]))\n        ]\n        # Update time interval\n        stac_coll[\"extent\"][\"temporal\"][\"interval\"] = [\n            [\n                self.numpydate_to_py(dataset[self.time_dim].values.min()).isoformat() + \"Z\",\n                self.numpydate_to_py(dataset[self.time_dim].values.max()).isoformat() + \"Z\",\n            ]\n        ]\n        # Publish STAC Collection with updated fields\n        self.publish_stac(self.collection(), stac_coll, StacType.COLLECTION)\n\n    def load_stac_metadata(self, key: str = None) -> str | dict:\n        \"\"\"\n        Return the latest version of a dataset's STAC Item from IPFS\n\n        Parameters\n        ----------\n        key : str\n            The human readable IPNS key string referencing a given object\n\n        Returns\n        -------\n        str | dict\n            Either an IPNS name hash or an empty dictionary (if no IPNS name hash found)\n\n        \"\"\"\n        if isinstance(self.store, IPLD):\n            if not key:\n                key = self.json_key()\n            try:\n                return self.retrieve_stac(key, StacType.ITEM)[0]\n            except (KeyError, TimeoutError):\n                self.warn(\n                    \"STAC metadata requested but no STAC object found at the provided key. Returning empty dictionary\"\n                )\n                return {}\n\n    # NON-STAC METADATA\n\n    def populate_metadata(self):\n        \"\"\"\n        Fill the metadata with values describing this set, using the static_metadata as a base template.\n        \"\"\"\n        if hasattr(self, \"metadata\") and self.metadata is not None:\n            self.metadata = self.metadata.update(self.static_metadata)\n        else:\n            self.metadata = self.static_metadata\n\n    def set_zarr_metadata(self, dataset: xr.Dataset) -> xr.Dataset:\n        \"\"\"\n        Function to append to or update key metadata information to the attributes and encoding of the output Zarr.\n        Additionally filters out unwanted keys and fields.\n\n        Parameters\n        ----------\n        dataset : xarray.Dataset\n            The dataset being published, pre-metadata update\n\n        Returns\n        -------\n        dataset : xarray.Dataset\n            The dataset being published, after metadata update\n\n        \"\"\"\n        # Rename data variable to desired name, if necessary. Will ValueError out if the name already exists\n        try:\n            dataset = dataset.rename_vars(\n                {[key for key in dataset.data_vars][0]: self.data_var()}\n            )\n        except ValueError:\n            self.info(f\"Duplicate name conflict detected during rename, leaving {dataset.data_vars[0]} in place\")\n            pass\n\n        # Encode data types and missing value indicators for the data variable\n        dataset = self.encode_vars(dataset)\n\n        # Merge in relevant static / STAC metadata and create additional attributes\n        dataset = self.merge_in_outside_metadata(dataset)\n\n        # Set all fields to uncompressed and remove filters leftover from input files\n        dataset = self.remove_unwanted_fields(dataset)\n\n        # Xarray cannot export dictionaries or None as attributes (lists and tuples are OK)\n        for attr in dataset.attrs.keys():\n            if type(dataset.attrs[attr]) is dict or type(dataset.attrs[attr]) is None:\n                dataset.attrs[attr] = \"\"\n\n        return dataset\n\n    def encode_vars(self, dataset: xr.Dataset) -> xr.Dataset:\n        \"\"\"\n        Encode important data points related to the data variable.\n        These are useful both for reference and to control Xarray's reading/writing behavior.\n\n        Parameters\n        ----------\n        dataset : xarray.Dataset\n            The dataset being published, pre-metadata update\n\n        Returns\n        -------\n        dataset : xarray.Dataset\n            The dataset being published, after metadata update\n\n        \"\"\"\n        # Encode fields for the data variable in the main encoding dict and the data var's own encoding dict (for thoroughness)\n        dataset.encoding = {\n            self.data_var(): {\n                \"dtype\": self.data_var_dtype,\n                \"_FillValue\": self.missing_value_indicator(),\n                \"missing_value\": self.missing_value_indicator(),  # deprecated by NUG but maintained for backwards compatibility\n            }\n        }\n        dataset[self.data_var()].encoding.update(\n            {\n                \"units\": self.unit_of_measurement,\n                \"_FillValue\": self.missing_value_indicator(),\n                \"missing_value\": self.missing_value_indicator(),  # deprecated by NUG but maintained for backwards compatibility\n                \"chunks\": tuple(val for val in self.requested_zarr_chunks.values()),\n                \"preferred_chunks\": self.requested_zarr_chunks,\n            }\n        )\n        # Encode 'time' dimension with the Climate and Forecast Convention standards used by major climate data providers.\n        if \"time\" in dataset:\n            dataset.time.encoding.update(\n                {\n                    \"long_name\": \"time\",\n                    \"calendar\": \"gregorian\",\n                }\n            )\n        elif \"forecast_reference_time\" in dataset:\n            dataset.forecast_reference_time.encoding.update(\n                {\n                    \"long_name\": \"initial time of forecast\",\n                    \"standard_name\" : \"forecast_reference_time\",\n                    \"calendar\": \"proleptic_gregorian\",\n                }\n            )\n        if \"units\" not in dataset[self.time_dim].encoding.keys():\n            # reformat the dataset_start_date datetime to a CF compliant string if it exists....\n            if hasattr(self, \"dataset_start_date\"):\n                dataset[self.time_dim].encoding.update(\n                    {\n                        \"units\": f\"days since {self.dataset_start_date.isoformat().replace('T00:00:00', ' 0:0:0 0')}\",\n                    }\n                )\n            # otherwise use None to indicate this is unknown at present\n            else:\n                dataset[self.time_dim].encoding.update(\n                    {\n                        \"units\": None,\n                    }\n                )\n        return dataset\n\n    def merge_in_outside_metadata(self, dataset: xr.Dataset) -> xr.Dataset:\n        \"\"\"\n        Join static/STAC metadata fields to the dataset's metadata fields and adjust them as appropriate\n\n        Parameters\n        ----------\n        dataset : xarray.Dataset\n            The dataset being published, pre-metadata update\n\n        Returns\n        -------\n        dataset : xarray.Dataset\n            The dataset being published, after metadata update\n\n        \"\"\"\n        # Load static metadata into the dataset's attributes\n        dataset.attrs = {**dataset.attrs, **self.metadata}\n\n        # Determine date to use for \"created\" field. On S3 and local, use current time. On IPLD, look for an existing creation time.\n        now = (\n            datetime.datetime.utcnow()\n            .replace(tzinfo=datetime.timezone.utc)\n            .isoformat()[:-13]\n            + \"Z\"\n        )\n        if isinstance(self.store, IPLD):\n            existing_stac_metadata = self.load_stac_metadata()\n            if (\n                existing_stac_metadata\n                and \"created\" in existing_stac_metadata[\"properties\"]\n            ):\n                created = existing_stac_metadata[\"properties\"][\"created\"]\n            else:\n                created = now\n        else:\n            created = now\n        dataset.attrs[\"created\"] = created\n\n        # Write the date range. Use existing data if possible to get the original start date. Even though the date range can be parsed by\n        # opening the Zarr, it can be faster to access directly through the Zarr's `.zmetadata` file, so it gets written here.\n        if isinstance(self.store, IPLD):\n            # Set date range. Use start from previous dataset's metadata if it exists or the input dataset if this is the first run.\n            try:\n                stac_metadata = self.load_stac_metadata()\n                dataset.attrs[\"update_previous_end_date\"] = stac_metadata[\"properties\"][\n                    \"date range\"\n                ][1]\n                dataset.attrs[\"date range\"] = (\n                    stac_metadata[\"properties\"][\"date range\"][0],\n                    datetime.datetime.strftime(\n                        self.get_date_range_from_dataset(dataset)[1], \"%Y%m%d%H\"\n                    ),\n                )\n            except (KeyError, TimeoutError):\n                dataset.attrs[\"update_previous_end_date\"] = \"\"\n                dataset.attrs[\"date range\"] = self.date_range_to_string(\n                    self.get_date_range_from_dataset(dataset)\n                )\n        else:\n            # Use existing Zarr if possible, otherwise get the dates from the input dataset.\n            if self.store.has_existing:\n                previous_start, previous_end = self.store.dataset().attrs[\"date range\"]\n                dataset.attrs[\"update_previous_end_date\"] = previous_end\n                dataset.attrs[\"date range\"] = (\n                    previous_start,\n                    self.date_range_to_string(\n                        self.get_date_range_from_dataset(dataset)\n                    )[1],\n                )\n            else:\n                dataset.attrs[\"update_previous_end_date\"] = \"\"\n                dataset.attrs[\"date range\"] = self.date_range_to_string(\n                    self.get_date_range_from_dataset(dataset)\n                )\n\n        # Write the update date range by taking the date range of the xr.Dataset submitted to this function. This assumes this function\n        # is called and the metadata is written before the original xr.Dataset is combined with the insert xr.Dataset.\n        dataset.attrs[\"update_date_range\"] = self.date_range_to_string(\n            self.get_date_range_from_dataset(dataset)\n        )\n\n        # Include the bounding box in the Zarr metadata\n        dataset.attrs[\"bbox\"] = self.bbox_coords(dataset)\n\n        # This defaults to `True`, so set it here and it will be overwritten when it is determined there is data at previously existing dates\n        # being overwritten.\n        dataset.attrs[\"update_is_append_only\"] = True\n        self.info(\"If updating, indicating the dataset is only appending data\")\n\n        return dataset\n\n    def remove_unwanted_fields(self, dataset: xr.Dataset) -> xr.Dataset:\n        \"\"\"\n        Remove filters, compression, and other unwanted encoding/metadata inheritances from input files\n\n        Parameters\n        ----------\n        dataset : xarray.Dataset\n            The dataset being published, pre-metadata update\n\n        Returns\n        -------\n        dataset : xarray.Dataset\n            The dataset being published, after metadata update\n\n        \"\"\"\n        # Leave compression off for IPLD\n        if self.store == \"ipld\":\n            compressor = None\n        else:\n            compressor = numcodecs.Blosc()\n\n        for coord in [\"latitude\", \"longitude\"]:\n            dataset[coord].attrs.pop(\"chunks\", None)\n            dataset[coord].attrs.pop(\"preferred_chunks\", None)\n            dataset[coord].encoding.pop(\"_FillValue\", None)\n            dataset[coord].encoding.pop(\"missing_value\", None)\n            dataset[coord].encoding[\"compressor\"] = compressor\n        dataset[self.data_var()].encoding.pop(\"filters\", None)\n        dataset[self.data_var()].encoding[\"compressor\"] = compressor\n\n        return dataset", "\n\nclass Metadata(Convenience, IPFS):\n    \"\"\"\n    Base class containing metadata creation and editing methods Zarr ETLs\n    Includes STAC Metadata templates for Items, Collections, and the root Catalog\n    \"\"\"\n\n    @classmethod\n    def default_stac_item(cls) -> dict:\n        \"\"\"\n        Default metadata template for STAC Items\n\n        Returns\n        -------\n        dict\n            The STAC Item metadata template with all pre-fillable values populated\n        \"\"\"\n        return {\n            \"stac_version\": \"1.0.0\",\n            \"type\": \"Feature\",\n            \"id\": cls.name(),\n            \"collection\": cls.collection(),\n            \"links\": [],\n            \"assets\": {\n                \"zmetadata\": {\n                    \"title\": cls.name(),\n                    \"type\": \"application/json\",\n                    \"description\": f\"Consolidated metadata file for {cls.name()} Zarr store, readable as a Zarr dataset by Xarray\",\n                    \"roles\": [\"metadata\", \"zarr-consolidated-metadata\"],\n                }\n            },\n        }\n\n    @property\n    def default_stac_collection(self) -> dict:\n        \"\"\"\n        Default metadata template for STAC collections\n\n        Returns\n        -------\n        dict\n            The STAC Collection metadata template with all pre-fillable values populated\n        \"\"\"\n        return {\n            \"id\": self.collection(),\n            \"type\": \"Collection\",\n            \"stac_extensions\": [\n                \"https://stac-extensions.github.io/projection/v1.0.0/schema.json\"\n            ],\n            \"stac_version\": \"1.0.0\",\n            \"description\": self.metadata[\"provider description\"],\n            \"license\": self.metadata[\"license\"],\n            \"collection\": self.collection(),\n            \"title\": self.metadata[\"title\"],\n            \"extent\": {\"spatial\": {\"bbox\": [[]]}, \"temporal\": {\"interval\": [[]]}},\n            \"links\": [\n                {\"rel\": \"self\", \"type\": \"application/json\", \"title\": self.collection()}\n            ],\n            \"providers\": [\n                {\n                    \"name\": f\"{self.host_organization()}\",\n                    \"description\": \"\",  # provide description for your organization here\n                    \"roles\": [\"processor\"],  #\n                    \"url\": \"\",  # provide URL for your organization here\n                },\n                {\n                    \"name\": self.metadata[\"publisher\"],\n                    \"description\": self.metadata[\"provider description\"],\n                    \"roles\": [\"producer\"],\n                    \"url\": self.metadata[\"provider url\"],\n                    \"terms of service\": self.metadata[\"terms of service\"],\n                },\n            ],\n            \"summaries\": {\"proj:epsg\": self.metadata[\"coordinate reference system\"]},\n        }\n\n    @classmethod\n    def default_root_stac_catalog(cls) -> dict:\n        \"\"\"\n        Default metadata template for the {self.host_organization()} root Catalog\n\n        Returns\n        -------\n        dict\n            The STAC Catalog metadata template with all pre-fillable values populated\n        \"\"\"\n        return {\n            \"id\": f\"{cls.host_organization()}_data_catalog\",\n            \"type\": \"Catalog\",\n            \"title\": f\"{cls.host_organization()} Data Catalog\",\n            \"stac_version\": \"1.0.0\",\n            \"description\": f\"This catalog contains all the data uploaded to {cls.host_organization()} \\\n                that has been issued STAC-compliant metadata. The catalogs and collections describe single providers. \\\n                Each may contain one or multiple datasets. Each individual dataset has been documented as STAC Items.\",\n        }\n\n    @abstractmethod\n    def static_metadata(cls):\n        \"\"\"\n        Placeholder for static metadata pertaining to each ETL\n        \"\"\"\n        ...\n\n    def check_stac_exists(self, title: str, stac_type: \"StacType\") -> bool:\n        \"\"\"Check if a STAC entity exists in the backing store\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_type : StacType\n            Type of STAC entity (Catalog, Collection or Item)\n\n        Returns\n        -------\n        bool\n            Whether the entity exists in the backing store\n        \"\"\"\n        if isinstance(self.store, IPLD):\n            return self.check_stac_on_ipns(title)\n        else:\n            return self.store.metadata_exists(title, stac_type.value)\n\n    def publish_stac(self, title: str, stac_content: dict, stac_type: \"StacType\"):\n        \"\"\"Publish a STAC entity to the backing store\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_content : dict\n            content of the stac entity\n        stac_type : StacType\n            Type of STAC entity (Catalog, Collection or Item)\n        \"\"\"\n        if isinstance(self.store, IPLD):\n            self.ipns_publish(title, self.ipfs_put(self.json_to_bytes(stac_content)))\n        else:\n            self.store.push_metadata(title, stac_content, stac_type.value)\n\n    def retrieve_stac(self, title: str, stac_type: \"StacType\") -> tuple[dict, str]:\n        \"\"\"Retrieve a STAC entity and its href from the backing store\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_type : StacType\n            Type of STAC entity (Catalog, Collection or Item)\n\n        Returns\n        -------\n        tuple[dict, str | pathlib.Path]\n            tuple of STAC content and the href for the STAC\n        \"\"\"\n        if isinstance(self.store, IPLD):\n            return self.ipns_retrieve_object(title)\n        else:\n            return self.store.retrieve_metadata(title, stac_type.value)\n\n    def get_href(self, title: str, stac_type: \"StacType\") -> str:\n        \"\"\"Get a STAC entity's href from the backing store. Might be\n        an IPNS name, a local path or a s3 path depending on the store\n\n        Parameters\n        ----------\n        title : str\n            STAC Entity title\n        stac_type : StacType\n            Type of STAC entity (Catalog, Collection or Item)\n\n        Returns\n        -------\n        str\n            string representation of href.\n        \"\"\"\n        if isinstance(self.store, IPLD):\n            return self.ipns_generate_name(key=title)\n        else:\n            return str(self.store.get_metadata_path(title, stac_type.value))\n\n    def create_root_stac_catalog(self):\n        \"\"\"\n        Prepare a root catalog for your organization if it doesn't already exist.\n        \"\"\"\n        root_catalog = self.default_root_stac_catalog()\n        root_catalog_exists = self.check_stac_exists(\n            root_catalog[\"title\"], StacType.CATALOG\n        )\n        if not root_catalog_exists:\n            # Publish the root catalog if it doesn't exist\n            self.info(f\"Publishing root {self.host_organization()} STAC Catalog\")\n            catalog_href = self.get_href(root_catalog[\"title\"], StacType.CATALOG)\n            root_catalog[\"links\"] = [\n                {\n                    \"rel\": \"root\",\n                    \"href\": catalog_href,\n                    \"type\": \"application/json\",\n                    \"title\": f\"{self.host_organization()} root catalog\",\n                },\n                {\n                    \"rel\": \"self\",\n                    \"href\": catalog_href,\n                    \"type\": \"application/json\",\n                    \"title\": f\"{self.host_organization()} root catalog\",\n                },\n            ]\n            self.publish_stac(root_catalog[\"title\"], root_catalog, StacType.CATALOG)\n        else:\n            self.info(\n                f\"Root {self.host_organization()} STAC Catalog already exists, building collection\"\n            )\n            ...\n\n    def create_stac_collection(self, dataset: xr.Dataset, rebuild: bool = False):\n        \"\"\"\n        Prepare a parent collection for the dataset the first time it's created.\n        In order to check for the collection's existence we must populate the relevant dictionary first in order to use its attributes.\n\n        Parameters\n        ----------\n        dataset : xr.Dataset\n            The dataset being published\n        rebuild : bool, optional\n            Whether to recreate the STAC Collection from scratch or not\n        Returns\n        -------\n        bool\n            Whether the stac collection was created\n        \"\"\"\n        stac_coll = self.default_stac_collection\n        # Check if the collection already exists to avoid duplication of effort\n        # Populate and publish a collection if one doesn't exist, or a rebuild was requested\n        if rebuild or not self.check_stac_exists(\n            self.collection(), StacType.COLLECTION\n        ):\n            if rebuild:\n                self.info(\n                    \"Collection rebuild requested. Creating new collection, pushing it to IPFS, and populating the main catalog\"\n                )\n            # Populate data-driven attributes of the collection\n            minx, miny, maxx, maxy = self.bbox_coords(dataset)\n            stac_coll[\"extent\"][\"spatial\"][\"bbox\"] = [[minx, miny, maxx, maxy]]\n            stac_coll[\"extent\"][\"temporal\"][\"interval\"] = [\n                [\n                    self.numpydate_to_py(dataset[self.time_dim].values.min()).isoformat() + \"Z\",\n                    self.numpydate_to_py(dataset[self.time_dim].values.max()).isoformat() + \"Z\",\n                ]\n            ]\n            # Create an href corresponding to the collection in order to note this in the collection and root catalog.\n            href = self.get_href(self.collection(), StacType.COLLECTION)\n            # Append collection to the root catalog if it doesn't already exist\n            root_catalog, root_catalog_href = self.retrieve_stac(\n                self.default_root_stac_catalog()[\"title\"], StacType.CATALOG\n            )\n            if not any(\n                stac_coll[\"title\"] in link_dict.values()\n                for link_dict in root_catalog[\"links\"]\n            ):\n                self.info(\n                    f\"Appending collection link to root {self.host_organization()} STAC Catalog\"\n                )\n                root_catalog[\"links\"].append(\n                    {\n                        \"rel\": \"child\",\n                        \"href\": href,\n                        \"type\": \"application/json\",\n                        \"title\": stac_coll[\"title\"],\n                    }\n                )\n                self.publish_stac(\n                    root_catalog[\"title\"],\n                    root_catalog,\n                    StacType.CATALOG,\n                )\n            # Add links and publish this collection\n            for link_dict in stac_coll[\"links\"]:\n                if link_dict[\"rel\"] == \"self\":\n                    link_dict[\"href\"] = href\n            stac_coll[\"links\"] = stac_coll[\"links\"] + [\n                {\n                    \"rel\": \"root\",\n                    \"href\": root_catalog_href,\n                    \"type\": \"application/json\",\n                    \"title\": f\"{self.host_organization()} root catalog\",\n                },\n                {\n                    \"rel\": \"parent\",\n                    \"href\": root_catalog_href,\n                    \"type\": \"application/json\",\n                    \"title\": f\"{self.host_organization()} root catalog\",\n                },\n            ]\n            self.publish_stac(self.collection(), stac_coll, StacType.COLLECTION)\n        else:\n            self.info(\n                \"Found existing STAC Collection for this dataset, skipping creation and updating instead\"\n            )\n            self.update_stac_collection(dataset)\n\n    def create_stac_item(self, dataset: xr.Dataset):\n        \"\"\"\n        Reformat previously prepared metadata and prepare key overviews of a dataset's spatial, temporal, and data dimensions into a STAC Item-compliant JSON.\n        Push this JSON to IPFS and its relevant parent STAC Collection via `register_stac_item`\n\n        Parameters\n        ----------\n        dataset : xr.Dataset\n            The dataset being published\n        \"\"\"\n        self.info(\"Creating STAC Item\")\n        stac_item = self.default_stac_item()\n        # Filter relevant existing metadata from the Zarr, flatten to a single level, and output as a dict for the \"properties\" key in STAC metadata\n        properties_dict = self.zarr_md_to_stac_format(dataset)\n        # Include the array size\n        properties_dict[\"array_size\"] = {\n            \"latitude\": dataset.latitude.size,\n            \"longitude\": dataset.longitude.size,\n            self.time_dim : dataset[self.time_dim].size,\n        }\n        if self.time_dim == 'forecast_reference_time':\n            properties_dict[\"array_size\"].update({\"step\" : dataset.step.size})\n        # Set up date items in STAC-compliant style\n        properties_dict[\"start_datetime\"] = (\n            self.numpydate_to_py(dataset[self.time_dim].values[0]).isoformat() + \"Z\"\n        )\n        properties_dict[\"end_datetime\"] = (\n            self.numpydate_to_py(dataset[self.time_dim].values[-1]).isoformat() + \"Z\"\n        )\n        properties_dict[\"updated\"] = (\n            datetime.datetime.utcnow()\n            .replace(tzinfo=datetime.timezone.utc)\n            .isoformat()[:-13]\n            + \"Z\"\n        )\n        # Populate the empty STAC Item\n        minx, miny, maxx, maxy = self.bbox_coords(dataset)\n        stac_item[\"bbox\"] = [minx, miny, maxx, maxy]\n        stac_item[\"geometry\"] = json.dumps(\n            shapely.geometry.mapping(shapely.geometry.box(minx, miny, maxx, maxy))\n        )\n        if isinstance(self.store, IPLD):\n            zarr_href = {\"/\": self.latest_hash()}\n        elif isinstance(self.store, Local):\n            zarr_href = str(self.store.path)\n        else:\n            zarr_href = self.store.url\n        stac_item[\"assets\"][\"zmetadata\"][\"href\"] = zarr_href\n        stac_item[\"properties\"] = properties_dict\n        # Push to backing store w/ link to href\n        self.register_stac_item(stac_item)\n\n    def zarr_md_to_stac_format(self, dataset: xr.Dataset) -> dict:\n        \"\"\"\n        Reduce attributes metadata of a Zarr dataset to a flat dictionary with STAC-compliant keys and values\n\n        Parameters\n        ----------\n        dataset : xr.Dataset\n            The dataset being published\n\n        Returns\n        -------\n        dict\n            Single-level dictionary containing all relevant metadata fields from the Zarr dataset with STAC-compliant names and formats\n        \"\"\"\n        # Filter down and name correctly needed attributes\n        zarr_attrs = {\n            \"missing value\",\n            \"dtype\",\n            \"preferred_chunks\",\n            \"Conventions\",\n            \"spatial resolution\",\n            \"spatial precision\",\n            \"temporal resolution\",\n            \"update cadence\",\n            \"unit of measurement\",\n            \"tags\",\n            \"standard name\",\n            \"long name\",\n            \"date range\",\n            \"dataset description\",\n            \"dataset download url\",\n            \"created\",\n            \"updated\",\n            \"finalization date\",\n            \"analysis data download url\",\n            \"reanalysis data download url\",\n            \"input history cid\",\n            \"input history JSON documentation\",\n        }\n        all_md = {\n            **dataset.attrs,\n            **dataset.encoding,\n            **dataset[self.data_var()].encoding,\n        }\n        all_md = {key: all_md[key] for key in zarr_attrs if key in all_md}\n        rename_dict = {\n            \"preferred_chunks\": \"Zarr chunk size\",\n            \"missing value\": \"Fill value\",\n            \"Conventions\": \"CF convention\",\n        }\n        properties_dict = {rename_dict.get(k, k): v for k, v in all_md.items()}\n        # Reformat attributes\n        for k, v in properties_dict.items():\n            if type(v) is np.float32:\n                properties_dict[k] = round(\n                    float(v), 8\n                )  # np.float32s aren't JSON serializable\n        properties_dict[\"dtype\"] = str(properties_dict[\"dtype\"])\n\n        return properties_dict\n\n    def register_stac_item(self, stac_item: dict):\n        \"\"\"'\n        Register a new dataset in an existing STAC Collection and/or replace a dataset's STAC Item with an updated one\n\n        Parameters\n        ----------\n        stac_item : dict\n            A dictionary of metadata prepared in `create_stac_item` for publication as a standalone STAC metadata file\n        \"\"\"\n        self.info(\"Registering STAC Item in IPFS and its parent STAC Collection\")\n        # Generate variables of interest\n        stac_coll, collection_href = self.retrieve_stac(\n            str(self.collection()), StacType.COLLECTION\n        )\n        # Register links\n        stac_item[\"links\"].append(\n            {\n                \"rel\": \"parent\",\n                \"href\": str(collection_href),\n                \"type\": \"application/geo+json\",\n                \"title\": stac_coll[\"title\"],\n            }\n        )\n        # Check if an older version of the STAC Item exists and if so create a \"previous\" link for them in the new STAC Item\n        try:\n            old_stac_item, href = self.retrieve_stac(self.json_key(), StacType.ITEM)\n            if isinstance(self.store, IPLD):\n                # If IPLD, generate the previous hash link\n                old_item_ipfs_hash = self.ipns_resolve(self.json_key())\n                self.info(\"Updating 'previous' link in dataset's STAC Item\")\n                stac_item[\"links\"].append(\n                    {\n                        \"rel\": \"prev\",\n                        \"href\": str(\n                            old_stac_item[\"assets\"][\"zmetadata\"][\"href\"].set(\n                                base=self._default_base\n                            )\n                        ),  # convert CID object back to hash str\n                        \"metadata href\": {\"/\": old_item_ipfs_hash},\n                        \"type\": \"application/geo+json\",\n                        \"title\": stac_item[\"assets\"][\"zmetadata\"][\"title\"],\n                    }\n                )\n        except (KeyError, TimeoutError, FileNotFoundError):\n            # Otherwise create a STAC name for your new dataset\n            self.info(\"No previous STAC Item found\")\n            href = self.get_href(self.json_key(), StacType.ITEM)\n        stac_item[\"links\"].append(\n            {\n                \"rel\": \"self\",\n                \"href\": str(href),\n                \"type\": \"application/geo+json\",\n                \"title\": f\"{self.name()} metadata\",\n            }\n        )\n        # push final STAC Item to backing store\n        self.info(\"Pushing STAC Item to backing store\")\n        self.publish_stac(self.json_key(), stac_item, StacType.ITEM)\n        # register item as a link in the relevant collection, if not already there, and push updated collection to IPFS\n        if any(\n            stac_item[\"assets\"][\"zmetadata\"][\"title\"] in link_dict[\"title\"]\n            for link_dict in stac_coll[\"links\"]\n            if \"title\" in link_dict.keys()\n        ):\n            self.info(\"Found existing STAC Item in STAC Collection\")\n            ...\n        else:\n            self.info(\n                \"No existing STAC Item found in this dataset's parent collection, inserting a child link\"\n            )\n            # register hrefs in both the Item and Collection and publish updated objects\n            stac_coll[\"links\"].append(\n                {\n                    \"rel\": \"item\",\n                    \"href\": str(href),\n                    \"type\": \"application/json\",\n                    \"title\": stac_item[\"assets\"][\"zmetadata\"][\"title\"],\n                }\n            )\n            self.publish_stac(self.collection(), stac_coll, StacType.COLLECTION)\n\n    def update_stac_collection(self, dataset: xr.Dataset):\n        \"\"\"'\n        Update fields in STAC Collection corresponding to a dataset\n\n        Parameters\n        ----------\n        dataset : xr.Dataset\n            The dataset being published\n        \"\"\"\n        self.info(\"Updating dataset's parent STAC Collection\")\n        # Get existing STAC Collection and add new datasets to it, if necessary\n        stac_coll = self.retrieve_stac(self.collection(), StacType.COLLECTION)[0]\n        # Update spatial extent\n        min_bbox_coords = np.minimum(\n            stac_coll[\"extent\"][\"spatial\"][\"bbox\"][0], [self.bbox_coords(dataset)]\n        )[0][0:2]\n        max_bbox_coords = np.maximum(\n            stac_coll[\"extent\"][\"spatial\"][\"bbox\"][0], [self.bbox_coords(dataset)]\n        )[0][2:4]\n        stac_coll[\"extent\"][\"spatial\"][\"bbox\"] = [\n            list(np.concatenate([min_bbox_coords, max_bbox_coords]))\n        ]\n        # Update time interval\n        stac_coll[\"extent\"][\"temporal\"][\"interval\"] = [\n            [\n                self.numpydate_to_py(dataset[self.time_dim].values.min()).isoformat() + \"Z\",\n                self.numpydate_to_py(dataset[self.time_dim].values.max()).isoformat() + \"Z\",\n            ]\n        ]\n        # Publish STAC Collection with updated fields\n        self.publish_stac(self.collection(), stac_coll, StacType.COLLECTION)\n\n    def load_stac_metadata(self, key: str = None) -> str | dict:\n        \"\"\"\n        Return the latest version of a dataset's STAC Item from IPFS\n\n        Parameters\n        ----------\n        key : str\n            The human readable IPNS key string referencing a given object\n\n        Returns\n        -------\n        str | dict\n            Either an IPNS name hash or an empty dictionary (if no IPNS name hash found)\n\n        \"\"\"\n        if isinstance(self.store, IPLD):\n            if not key:\n                key = self.json_key()\n            try:\n                return self.retrieve_stac(key, StacType.ITEM)[0]\n            except (KeyError, TimeoutError):\n                self.warn(\n                    \"STAC metadata requested but no STAC object found at the provided key. Returning empty dictionary\"\n                )\n                return {}\n\n    # NON-STAC METADATA\n\n    def populate_metadata(self):\n        \"\"\"\n        Fill the metadata with values describing this set, using the static_metadata as a base template.\n        \"\"\"\n        if hasattr(self, \"metadata\") and self.metadata is not None:\n            self.metadata = self.metadata.update(self.static_metadata)\n        else:\n            self.metadata = self.static_metadata\n\n    def set_zarr_metadata(self, dataset: xr.Dataset) -> xr.Dataset:\n        \"\"\"\n        Function to append to or update key metadata information to the attributes and encoding of the output Zarr.\n        Additionally filters out unwanted keys and fields.\n\n        Parameters\n        ----------\n        dataset : xarray.Dataset\n            The dataset being published, pre-metadata update\n\n        Returns\n        -------\n        dataset : xarray.Dataset\n            The dataset being published, after metadata update\n\n        \"\"\"\n        # Rename data variable to desired name, if necessary. Will ValueError out if the name already exists\n        try:\n            dataset = dataset.rename_vars(\n                {[key for key in dataset.data_vars][0]: self.data_var()}\n            )\n        except ValueError:\n            self.info(f\"Duplicate name conflict detected during rename, leaving {dataset.data_vars[0]} in place\")\n            pass\n\n        # Encode data types and missing value indicators for the data variable\n        dataset = self.encode_vars(dataset)\n\n        # Merge in relevant static / STAC metadata and create additional attributes\n        dataset = self.merge_in_outside_metadata(dataset)\n\n        # Set all fields to uncompressed and remove filters leftover from input files\n        dataset = self.remove_unwanted_fields(dataset)\n\n        # Xarray cannot export dictionaries or None as attributes (lists and tuples are OK)\n        for attr in dataset.attrs.keys():\n            if type(dataset.attrs[attr]) is dict or type(dataset.attrs[attr]) is None:\n                dataset.attrs[attr] = \"\"\n\n        return dataset\n\n    def encode_vars(self, dataset: xr.Dataset) -> xr.Dataset:\n        \"\"\"\n        Encode important data points related to the data variable.\n        These are useful both for reference and to control Xarray's reading/writing behavior.\n\n        Parameters\n        ----------\n        dataset : xarray.Dataset\n            The dataset being published, pre-metadata update\n\n        Returns\n        -------\n        dataset : xarray.Dataset\n            The dataset being published, after metadata update\n\n        \"\"\"\n        # Encode fields for the data variable in the main encoding dict and the data var's own encoding dict (for thoroughness)\n        dataset.encoding = {\n            self.data_var(): {\n                \"dtype\": self.data_var_dtype,\n                \"_FillValue\": self.missing_value_indicator(),\n                \"missing_value\": self.missing_value_indicator(),  # deprecated by NUG but maintained for backwards compatibility\n            }\n        }\n        dataset[self.data_var()].encoding.update(\n            {\n                \"units\": self.unit_of_measurement,\n                \"_FillValue\": self.missing_value_indicator(),\n                \"missing_value\": self.missing_value_indicator(),  # deprecated by NUG but maintained for backwards compatibility\n                \"chunks\": tuple(val for val in self.requested_zarr_chunks.values()),\n                \"preferred_chunks\": self.requested_zarr_chunks,\n            }\n        )\n        # Encode 'time' dimension with the Climate and Forecast Convention standards used by major climate data providers.\n        if \"time\" in dataset:\n            dataset.time.encoding.update(\n                {\n                    \"long_name\": \"time\",\n                    \"calendar\": \"gregorian\",\n                }\n            )\n        elif \"forecast_reference_time\" in dataset:\n            dataset.forecast_reference_time.encoding.update(\n                {\n                    \"long_name\": \"initial time of forecast\",\n                    \"standard_name\" : \"forecast_reference_time\",\n                    \"calendar\": \"proleptic_gregorian\",\n                }\n            )\n        if \"units\" not in dataset[self.time_dim].encoding.keys():\n            # reformat the dataset_start_date datetime to a CF compliant string if it exists....\n            if hasattr(self, \"dataset_start_date\"):\n                dataset[self.time_dim].encoding.update(\n                    {\n                        \"units\": f\"days since {self.dataset_start_date.isoformat().replace('T00:00:00', ' 0:0:0 0')}\",\n                    }\n                )\n            # otherwise use None to indicate this is unknown at present\n            else:\n                dataset[self.time_dim].encoding.update(\n                    {\n                        \"units\": None,\n                    }\n                )\n        return dataset\n\n    def merge_in_outside_metadata(self, dataset: xr.Dataset) -> xr.Dataset:\n        \"\"\"\n        Join static/STAC metadata fields to the dataset's metadata fields and adjust them as appropriate\n\n        Parameters\n        ----------\n        dataset : xarray.Dataset\n            The dataset being published, pre-metadata update\n\n        Returns\n        -------\n        dataset : xarray.Dataset\n            The dataset being published, after metadata update\n\n        \"\"\"\n        # Load static metadata into the dataset's attributes\n        dataset.attrs = {**dataset.attrs, **self.metadata}\n\n        # Determine date to use for \"created\" field. On S3 and local, use current time. On IPLD, look for an existing creation time.\n        now = (\n            datetime.datetime.utcnow()\n            .replace(tzinfo=datetime.timezone.utc)\n            .isoformat()[:-13]\n            + \"Z\"\n        )\n        if isinstance(self.store, IPLD):\n            existing_stac_metadata = self.load_stac_metadata()\n            if (\n                existing_stac_metadata\n                and \"created\" in existing_stac_metadata[\"properties\"]\n            ):\n                created = existing_stac_metadata[\"properties\"][\"created\"]\n            else:\n                created = now\n        else:\n            created = now\n        dataset.attrs[\"created\"] = created\n\n        # Write the date range. Use existing data if possible to get the original start date. Even though the date range can be parsed by\n        # opening the Zarr, it can be faster to access directly through the Zarr's `.zmetadata` file, so it gets written here.\n        if isinstance(self.store, IPLD):\n            # Set date range. Use start from previous dataset's metadata if it exists or the input dataset if this is the first run.\n            try:\n                stac_metadata = self.load_stac_metadata()\n                dataset.attrs[\"update_previous_end_date\"] = stac_metadata[\"properties\"][\n                    \"date range\"\n                ][1]\n                dataset.attrs[\"date range\"] = (\n                    stac_metadata[\"properties\"][\"date range\"][0],\n                    datetime.datetime.strftime(\n                        self.get_date_range_from_dataset(dataset)[1], \"%Y%m%d%H\"\n                    ),\n                )\n            except (KeyError, TimeoutError):\n                dataset.attrs[\"update_previous_end_date\"] = \"\"\n                dataset.attrs[\"date range\"] = self.date_range_to_string(\n                    self.get_date_range_from_dataset(dataset)\n                )\n        else:\n            # Use existing Zarr if possible, otherwise get the dates from the input dataset.\n            if self.store.has_existing:\n                previous_start, previous_end = self.store.dataset().attrs[\"date range\"]\n                dataset.attrs[\"update_previous_end_date\"] = previous_end\n                dataset.attrs[\"date range\"] = (\n                    previous_start,\n                    self.date_range_to_string(\n                        self.get_date_range_from_dataset(dataset)\n                    )[1],\n                )\n            else:\n                dataset.attrs[\"update_previous_end_date\"] = \"\"\n                dataset.attrs[\"date range\"] = self.date_range_to_string(\n                    self.get_date_range_from_dataset(dataset)\n                )\n\n        # Write the update date range by taking the date range of the xr.Dataset submitted to this function. This assumes this function\n        # is called and the metadata is written before the original xr.Dataset is combined with the insert xr.Dataset.\n        dataset.attrs[\"update_date_range\"] = self.date_range_to_string(\n            self.get_date_range_from_dataset(dataset)\n        )\n\n        # Include the bounding box in the Zarr metadata\n        dataset.attrs[\"bbox\"] = self.bbox_coords(dataset)\n\n        # This defaults to `True`, so set it here and it will be overwritten when it is determined there is data at previously existing dates\n        # being overwritten.\n        dataset.attrs[\"update_is_append_only\"] = True\n        self.info(\"If updating, indicating the dataset is only appending data\")\n\n        return dataset\n\n    def remove_unwanted_fields(self, dataset: xr.Dataset) -> xr.Dataset:\n        \"\"\"\n        Remove filters, compression, and other unwanted encoding/metadata inheritances from input files\n\n        Parameters\n        ----------\n        dataset : xarray.Dataset\n            The dataset being published, pre-metadata update\n\n        Returns\n        -------\n        dataset : xarray.Dataset\n            The dataset being published, after metadata update\n\n        \"\"\"\n        # Leave compression off for IPLD\n        if self.store == \"ipld\":\n            compressor = None\n        else:\n            compressor = numcodecs.Blosc()\n\n        for coord in [\"latitude\", \"longitude\"]:\n            dataset[coord].attrs.pop(\"chunks\", None)\n            dataset[coord].attrs.pop(\"preferred_chunks\", None)\n            dataset[coord].encoding.pop(\"_FillValue\", None)\n            dataset[coord].encoding.pop(\"missing_value\", None)\n            dataset[coord].encoding[\"compressor\"] = compressor\n        dataset[self.data_var()].encoding.pop(\"filters\", None)\n        dataset[self.data_var()].encoding[\"compressor\"] = compressor\n\n        return dataset", "\n\nclass StacType(Enum):\n    ITEM = \"datasets\"\n    COLLECTION = \"collections\"\n    CATALOG = \"\"\n"]}
{"filename": "gridded_etl_tools/utils/__init__.py", "chunked_list": [""]}
{"filename": "gridded_etl_tools/utils/convenience.py", "chunked_list": ["import os\nimport gc\nimport pathlib\nimport natsort\nimport datetime\nimport re\nimport ftplib\nimport io\nimport json\n", "import json\n\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\n\nfrom .attributes import Attributes\nfrom .store import IPLD\n\n\nclass Convenience(Attributes):\n    \"\"\"\n    Base class holding convenience methods for Zarr ETLs\n    \"\"\"\n\n    # BASE DIRECTORIES\n\n    def root_directory(self, refresh: bool = False):\n        if refresh or not hasattr(self, \"_root_directory\"):  # ensure this is only calculated one time, at the beginning of the script\n            self._root_directory = pathlib.Path.cwd()  # Paths are relative to the working directory of the ETL manager, *not* the scripts\n        return self._root_directory\n\n    @property\n    def local_input_root(self):\n        return self.root_directory() / \"datasets\"\n\n    @property\n    def output_root(self):\n        return self.root_directory() / \"climate\"\n\n    # NAMES\n\n    def zarr_json_path(self) -> pathlib.Path:\n        \"\"\"\n        A path to the virtual Zarr\n\n        Returns\n        -------\n        pathlib.Path\n            The path to the virtual Zarr JSON file\n        \"\"\"\n        return self.root_directory() / f\"{self.name()}_zarr.json\"\n\n    @classmethod\n    def json_key(cls, append_date: bool = False) -> str:\n        \"\"\"\n        Returns the key value that can identify this set in a JSON file. JSON key takes the form of either name-measurement_span or name-today.\n        If `append_date` is True, add today's date to the end of the string\n\n        Parameters\n        ----------\n        append_date : bool, optional\n            Whether to add today's date to the end of the json_key string\n\n        Returns\n        -------\n        str\n            The formatted JSON key\n\n        \"\"\"\n        key = f\"{cls.name()}-{cls.temporal_resolution()}\"\n        if append_date:\n            key = f\"{key}-{datetime.datetime.now().strftime(cls.DATE_FORMAT_FOLDER)}\"\n        return key\n\n    # PATHS\n\n    def local_input_path(self) -> str:\n        \"\"\"\n        The path to local data is built recursively by appending each derivative's relative path to the previous derivative's\n        path. If a custom input path is set, force return the custom path.\n        \"\"\"\n        if self.custom_input_path:\n            return pathlib.Path(self.custom_input_path)\n        else:\n            path = pathlib.Path(self.local_input_root) / pathlib.Path(\n                self.relative_path()\n            )\n            # Create directory if necessary\n            path.mkdir(parents=True, mode=0o755, exist_ok=True)\n            return path\n\n    def relative_path(self) -> str:\n        \"\"\"\n        The file folder hierarchy for a set. This should be a relative path so it can be appended to other root paths like\n        `self.local_input_path()` and `self.output_path()`\n\n        Returns\n        -------\n        str\n            The relative path that should be used for this set's data\n\n        \"\"\"\n        return pathlib.Path(\".\")\n\n    def input_files(self) -> list:\n        \"\"\"\n        Iterator for iterating through the list of local input files\n\n        Returns\n        -------\n        list\n            List of input files from `self.local_input_path()`\n\n        \"\"\"\n        root = pathlib.Path(self.local_input_path())\n        for entry in natsort.natsorted(pathlib.Path(root).iterdir()):\n            if (\n                not entry.name.startswith(\".\")\n                and not entry.name.endswith(\".idx\")\n                and entry.is_file()\n            ):\n                yield pathlib.Path(root / entry.name)\n\n    def get_folder_path_from_date(\n        self, date: datetime.datetime, omit_root: bool = False\n    ) -> str:\n        \"\"\"\n        Return a folder path inside `self.output_root` with the folder name based on `self.temporal_resolution()`\n        and the passed `datetime`. If `omit_root` is set, remove `self.output_root` from the path.\n\n        Parameters\n        ----------\n        date : datetime.datetime\n            datetime.datetime object representing the date to be appended to the folder name\n        omit_root : bool, optional\n            If False, prepent `self.output_root` to the beginning of the path, otherwise leave it off. Defaults to False\n\n        Returns\n        -------\n        str\n            Directory path derived from the date provided\n\n        \"\"\"\n        if self.temporal_resolution() == self.SPAN_HOURLY:\n            date_format = self.DATE_HOURLY_FORMAT_FOLDER\n        else:\n            date_format = self.DATE_FORMAT_FOLDER\n        path = pathlib.Path(self.relative_path()) / date.strftime(date_format)\n        if not omit_root:\n            path = pathlib.Path(self.output_root) / path\n        return path\n\n    def output_path(self, omit_root: bool = False) -> str:\n        \"\"\"\n        Return the path to a directory where parsed climate data will be written, automatically determining the end date and\n        base on that. If `omit_root` is set, remove `self.output_root` from the path. Override with `self.custom_output_path`\n        if that member variable is set.\n\n        Parameters\n        ----------\n        omit_root : bool, optional\n            If False, prepend self.output_root to the beginning of the path, otherwise leave it off. Defaults to False.\n\n        Returns\n        -------\n        str\n            string representing the output directory path where climate data will be written\n        \"\"\"\n        if self.custom_output_path is not None:\n            return self.custom_output_path\n        else:\n            path = self.relative_path()\n            if not omit_root:\n                path = self.output_root / path\n            return path\n\n    def create_output_path(self):\n        \"\"\"\n        Make output directory\n        \"\"\"\n        os.makedirs(self.output_path(), 0o755, exist_ok=True)\n\n    # DATES\n\n    def get_metadata_date_range(self) -> dict:\n        \"\"\"\n        Returns the date range in the metadata as datetime objects in a dict with `start` and `end` keys.\n\n        On IPLD, uses STAC to get the date. On S3 and local, uses an existing Zarr.\n\n        Existing dates are assumed to be formatted as \"%Y%m%d%H\"\n\n        Returns\n        -------\n        dict\n            Two str: datetime.datetimes representing the start and end times in a STAC Item's metadata\n        \"\"\"\n        date_format = \"%Y%m%d%H\"\n        if isinstance(self.store, IPLD):\n            # Use STAC\n            metadata = self.load_stac_metadata()\n            return {\n                \"start\": datetime.datetime.strptime(\n                    metadata[\"properties\"][\"date range\"][0], date_format\n                ),\n                \"end\": datetime.datetime.strptime(\n                    metadata[\"properties\"][\"date range\"][1], date_format\n                ),\n            }\n        else:\n            # Use existing Zarr attrs or raise an exception if there is no usable date attribute\n            if self.store.has_existing:\n                dataset = self.store.dataset()\n                if \"date range\" in dataset.attrs:\n                    # Assume attr format is ['%Y%m%d%H', '%Y%m%d%H'], translate to datetime objects, then transform into a dict with \"start\" and \"end\" keys\n                    return dict(\n                        zip(\n                            (\"start\", \"end\"),\n                            (\n                                datetime.datetime.strptime(d, date_format)\n                                for d in dataset.attrs[\"date range\"]\n                            ),\n                        )\n                    )\n                else:\n                    raise ValueError(\n                        f\"Existing date range not found in {dataset} attributes\"\n                    )\n            else:\n                raise ValueError(\n                    f\"No existing dataset found to get date range from at {self.store}\"\n                )\n\n    def convert_date_range(\n        self, date_range: list\n    ) -> tuple[datetime.datetime, datetime.datetime]:\n        \"\"\"\n        Convert a JSON text/isoformat date range into a python datetime object range\n\n        Parameters\n        ----------\n        date_range : list\n            A list of length two containing isoformatted start and end date strings\n\n        Returns\n        -------\n        tuple[datetime.datetime, datetime.datetime]\n            A tuple of (datetime.datetime, datetime.datetime) representing a date range's start and end\n\n        \"\"\"\n        if re.match(\".+/.+/.+\", date_range[0]):\n            start, end = [\n                datetime.datetime.strptime(d, self.DATE_FORMAT_METADATA)\n                for d in date_range\n            ]\n        else:\n            start, end = [datetime.datetime.fromisoformat(d) for d in date_range]\n        return start, end\n\n    def iso_to_datetime(self, isodate: str) -> datetime.datetime:\n        \"\"\"\n        Get a datetime object from an ISO formatted date string\n\n        Parameters\n        ----------\n        isodate : str\n            An Isoformatted string representing a date\n\n        Returns\n        -------\n        datetime.datetime\n            The converted date\n\n        \"\"\"\n        return datetime.datetime.fromisoformat(isodate)\n\n    def numpydate_to_py(self, numpy_date: np.datetime64) -> datetime.datetime:\n        \"\"\"\n        Convert a numpy datetime object to a python standard library datetime object\n\n        Parameters\n        ----------\n        np.datetime64\n            A numpy.datetime64 object to be converted\n\n        Returns\n        -------\n        datetime.datetime\n            A datetime.datetime object\n\n        \"\"\"\n        return pd.Timestamp(numpy_date).to_pydatetime()\n\n    @staticmethod\n    def today() -> str:\n        \"\"\"\n        Convenience method to return today's date in Isoformat\n\n        Returns\n        -------\n        str\n            Today's date in Isoformat\n        \"\"\"\n        return datetime.date.today().isoformat()\n\n    # DATE RANGES\n\n    def get_date_range_from_dataset(\n        self, dataset: xr.Dataset\n    ) -> tuple[datetime.datetime, datetime.datetime]:\n        \"\"\"\n        Return the start and end date in a dataset's \"time\" dimension\n\n        Parameters\n        ----------\n        dataset : xr.Dataset\n            The xr.Dataset to be evaluated\n\n        Returns\n        -------\n        tuple[datetime.datetime, datetime.datetime]\n            A tuple defining the start and end date of a file's time dimension\n\n        \"\"\"\n        # use forecast times if they exist\n        if \"forecast_reference_time\" in dataset:\n            time_dim = \"forecast_reference_time\"\n        else:\n            time_dim = \"time\"\n        # if there is only one date, set start and end to the same value\n        if dataset[time_dim].size == 1:\n            value = dataset[time_dim].values\n            if isinstance(value, np.ndarray):\n                value = value[0]\n            start = self.numpydate_to_py(value)\n            end = start\n        else:\n            start = self.numpydate_to_py(dataset[time_dim][0].values)\n            end = self.numpydate_to_py(dataset[time_dim][-1].values)\n        return start, end\n\n    def get_date_range_from_file(\n        self, path: str, backend_kwargs: dict = None\n    ) -> tuple[datetime.datetime, datetime.datetime]:\n        \"\"\"\n        Open file and return the start and end date of the data. The dimension name used to store dates should be passed as `dimension`.\n\n        Parameters\n        ----------\n        path : str\n            Path to the input dataset file on disk\n        backend_kwargs : dict, optional\n            Backend arguments for the xr.open_dataset() method\n\n        Returns\n        -------\n        tuple\n            A tuple of datetime.datetime objects defining the start and end date of a file's time dimension\n\n        \"\"\"\n        dataset = xr.open_dataset(path, backend_kwargs=backend_kwargs)\n        date_range = self.get_date_range_from_dataset(dataset)\n        dataset.close()\n        del dataset\n        gc.collect()\n        return date_range\n\n    def date_range_to_string(self, date_range: tuple) -> tuple[str, str]:\n        \"\"\"\n        Convert a tuple of datetime objects to a tuple of parseable strings. Necessary for Xarray metadata parsing.\n\n        Parameters\n        ----------\n        date_range : tuple\n            A (datetime.datetime, datetime.datetime) tuple containing the start and end dates of a date range\n\n        Returns\n        -------\n        tuple\n            A tuple of `%Y%m%d%H` formatted start and end dates of a date range\n\n        \"\"\"\n        return (\n            datetime.datetime.strftime(date_range[0], \"%Y%m%d%H\"),\n            datetime.datetime.strftime(date_range[1], \"%Y%m%d%H\"),\n        )\n\n    def get_newest_file_date_range(self) -> datetime.datetime:\n        \"\"\"\n        Return the date range of the newest local file\n\n        Returns\n        -------\n        datetime.datetime\n            The start and end date of the newest local file\n\n        \"\"\"\n        return self.get_date_range_from_file(list(self.input_files())[-1])\n\n    # STRING TRANSFORMATIONS\n\n    def _coord_reformat(self, *args, pretty: bool = False, padding: int = 0) -> str:\n        \"\"\"\n        Return coordinates (individually or pair) as a single string value with 3 decimal places of precision. With `pretty` set\n        to False, return a string that can be used for a file name. With `pretty` set to True, return formatted coordinate string\n\n        Parameters\n        ----------\n        args : list\n            A list of (index, coordinate) tuples\n        pretty : bool, optional\n            A switch indicating whether to add a separator to the returned coordinates\n        padding : int\n            The number of zero padding spaces, in integer form, to add to returned coordinates\n\n        Returns\n        -------\n        str\n            Coordinates reformatted as specified\n\n        \"\"\"\n        if not pretty:\n            separator = \"_\"\n            coords = \"\"\n        else:\n            separator = \", \"\n            coords = \"(\"\n        for ii, coord in enumerate(args):\n            if ii > 0:\n                coords += separator\n            coords += f\"{float(coord):0{padding}.3f}\"\n        if pretty:\n            coords += \")\"\n        return coords\n\n    def coord_str(self, *args, pretty: bool = False, padding=0) -> str:\n        \"\"\"\n        Return coordinates (individually or pair) as a single string value with 3 decimal places of precision. With `pretty` set\n        to False, return a string that can be used for a file name. With `pretty` set to True, return formatted coordinate string\n\n\n        Parameters\n        ----------\n        args : list\n            A list of (index, coordinate) tuples\n        pretty : bool, optional\n            A switch indicating whether to add a separator to the returned coordinates\n        padding : int\n            The number of zero padding spaces, in integer form, to add to returned coordinates\n\n        Returns\n        -------\n        str\n            Coordinates reformatted as specified\n\n        \"\"\"\n        translated_args = []\n        for coord in args:\n            if isinstance(coord, xr.DataArray):\n                translated_args.append(coord.values)\n            else:\n                translated_args.append(coord)\n        return self._coord_reformat(*translated_args, pretty=pretty, padding=padding)\n\n    # FTP\n\n    def sync_ftp_files(\n        self,\n        server: str,\n        directory_path: str,\n        file_match_pattern: str,\n        include_size_check: bool = False,\n    ):\n        \"\"\"\n        Connect to `server` (currently only supports anonymous login), change to `directory_path`, pull new and updated files\n        that match `file_match_pattern` in that directory into `self.local_input_path()`. Store a list of newly downloaded\n        files in a member variable.\n\n        Parameters\n        ----------\n        server : str\n            The URL of the FTP server to check\n        directory_path: str\n            The path to the directory holding the desired FTP files on the server\n        file_match_pattern : str\n            A regex string to match file names (in directory_path) against\n        include_size_check : bool, optional\n            Switch to check (or not) the size of files against a maximum. Defaults to False.\n\n        \"\"\"\n        # Login to remote FTP server\n        with ftplib.FTP(server) as ftp:\n            self.info(\n                \"checking {}:{} for files that match {}\".format(\n                    server, directory_path, file_match_pattern\n                )\n            )\n            ftp.login()\n            ftp.cwd(directory_path)\n            # Loop through directory listing\n            for file_name in ftp.nlst():\n                if re.match(file_match_pattern, file_name):\n                    # path on our local filesystem\n                    local_file_path = pathlib.Path(self.local_input_path()) / file_name\n                    modification_timestamp = ftp.sendcmd(\"MDTM {}\".format(file_name))[\n                        4:\n                    ].strip()\n                    modification_time = datetime.datetime.strptime(\n                        modification_timestamp, \"%Y%m%d%H%M%S\"\n                    )\n                    # Retrieve this file unless we find conditions not to\n                    retrieve = True\n                    # Compare to local file of same name\n                    if local_file_path.exists():\n                        local_file_attributes = os.stat(local_file_path)\n                        local_file_mtime = datetime.datetime.fromtimestamp(\n                            local_file_attributes.st_mtime\n                        )\n                        local_file_size = local_file_attributes.st_size\n                        # Set to binary transfer mode\n                        ftp.sendcmd(\"TYPE I\")\n                        remote_file_size = ftp.size(file_name)\n                        if modification_time <= local_file_mtime and (\n                            not include_size_check\n                            or remote_file_size == local_file_size\n                        ):\n                            self.debug(\n                                \"local file {} does not need updating\".format(\n                                    local_file_path\n                                )\n                            )\n                            retrieve = False\n                        elif modification_time > local_file_mtime:\n                            self.debug(\n                                \"file {} local modification time {} less than remote modification time {}\".format(\n                                    local_file_path,\n                                    local_file_mtime.strftime(\"%Y/%m/%d\"),\n                                    modification_time.strftime(\"%Y/%m/%d\"),\n                                )\n                            )\n                        else:\n                            self.debug(\n                                \"mismatch between local and remote size for file {}\".format(\n                                    local_file_path\n                                )\n                            )\n                    else:\n                        self.debug(\"new remote file found {}\".format(file_name))\n                    # Write this file locally\n                    if retrieve:\n                        self.new_files.append(self.local_input_path() / file_name)\n                        self.info(\n                            \"downloading remote file {} to {}\".format(\n                                file_name, local_file_path\n                            )\n                        )\n                        with open(local_file_path, \"wb\") as fp:\n                            ftp.retrbinary(\"RETR {}\".format(file_name), fp.write)\n\n    # ETC\n\n    def array_has_data(self, array: np.ndarray) -> bool | np.ndarray:\n        \"\"\"\n        Convenience method to determine if an array has any data\n\n        Parameters\n        ----------\n        array : np.array\n            A numpy array to assess\n\n        Returns\n        -------\n        bool | np.array\n            Either a boolean indicating whether an array has data,\n            or an array containing multiple booleans indicating which arrays have data\n\n        \"\"\"\n        return not np.all(np.isnan(array))\n\n    def bbox_coords(self, dataset: xr.Dataset) -> tuple[float, float, float, float]:\n        \"\"\"\n        Calculate bounding box coordinates from an Xarray dataset\n\n        Parameters\n        ----------\n        dataset : xr.Dataset\n            The dataset to use for extent calculations\n\n        Returns\n        -------\n        tuple[float, float, float, float]\n            The minimum X, minimum Y, maximum X, and maximum Y values of the dataset's bounding box extent\n        \"\"\"\n        return (\n            round(float(dataset.longitude.values.min()), self.bbox_rounding_value),\n            round(float(dataset.latitude.values.min()), self.bbox_rounding_value),\n            round(float(dataset.longitude.values.max()), self.bbox_rounding_value),\n            round(float(dataset.latitude.values.max()), self.bbox_rounding_value),\n        )\n\n    def json_to_bytes(self, obj: dict) -> bytes:\n        \"\"\"\n        Convert a JSON object to a file type object (bytes). Primarily used for passing STAC metadata to IPFS\n\n        Parameters\n        ----------\n        obj : dict\n            The object (JSON) to be converted\n\n        Returns\n        -------\n        bytes\n            The json encoded as a file type object\n        \"\"\"\n        return io.BytesIO(json.dumps(obj).encode(\"utf-8\"))\n\n    def check_if_new_data(self, compare_date: datetime.datetime) -> bool:\n        \"\"\"\n        Check if the downloaded data contains any new records relative to the existing dataset.\n        Return a boolean indicating whether to proceed with a transform/parse based on the presence of new records.\n\n        Parameters\n        ==========\n        compare_date : datetime.datetime\n            A cutoff date to compare against downloaded data; if any downloaded data is newer, move ahead with the parse.\n            When updating, refers to the last datetime available in the existing dataset.\n\n        Returns\n        =======\n        bool\n            An indication of whether to proceed with a parse (True) or not (False)\n        \"\"\"\n\n        # check if newest file on our server has newer data\n        try:\n            newest_file_end_date = self.get_newest_file_date_range()[1]\n        except IndexError as e:\n            self.info(f\"Date range operation failed due to absence of input files. Exiting script. Full error message: {e}\")\n            return False\n        self.info(f\"newest file ends at {newest_file_end_date}\")\n        if newest_file_end_date >= compare_date:\n            self.info(f\"newest file has newer data than our end date {compare_date}, triggering parse\")\n            return True\n        else:\n            self.info(f\"newest file doesn't have data past our existing end date {compare_date}.\")\n            return False\n\n    @classmethod\n    def standardize_longitudes(cls, dataset: xr.Dataset) -> xr.Dataset:\n        \"\"\"\n        Convert the longitude coordinates of a dataset from 0 - 360 to -180 to 180.\n\n        Parameters\n        ----------\n        xr.Dataset\n            A dataset with longitudes from 0 to 360\n        Returns\n        -------\n        xr.Dataset\n            A dataset with longitudes from -180 to 180\n\n        \"\"\"\n        # Convert longitudes from 0 - 360 to -180 to 180\n        dataset = dataset.assign_coords(\n            longitude=(((dataset.longitude + 180) % 360) - 180)\n        )\n        # After converting, the longitudes may still start at zero. This reorders the longitude coordinates from -180 to 180 if necessary.\n        return dataset.sortby([\"latitude\", \"longitude\"])", "\n\nclass Convenience(Attributes):\n    \"\"\"\n    Base class holding convenience methods for Zarr ETLs\n    \"\"\"\n\n    # BASE DIRECTORIES\n\n    def root_directory(self, refresh: bool = False):\n        if refresh or not hasattr(self, \"_root_directory\"):  # ensure this is only calculated one time, at the beginning of the script\n            self._root_directory = pathlib.Path.cwd()  # Paths are relative to the working directory of the ETL manager, *not* the scripts\n        return self._root_directory\n\n    @property\n    def local_input_root(self):\n        return self.root_directory() / \"datasets\"\n\n    @property\n    def output_root(self):\n        return self.root_directory() / \"climate\"\n\n    # NAMES\n\n    def zarr_json_path(self) -> pathlib.Path:\n        \"\"\"\n        A path to the virtual Zarr\n\n        Returns\n        -------\n        pathlib.Path\n            The path to the virtual Zarr JSON file\n        \"\"\"\n        return self.root_directory() / f\"{self.name()}_zarr.json\"\n\n    @classmethod\n    def json_key(cls, append_date: bool = False) -> str:\n        \"\"\"\n        Returns the key value that can identify this set in a JSON file. JSON key takes the form of either name-measurement_span or name-today.\n        If `append_date` is True, add today's date to the end of the string\n\n        Parameters\n        ----------\n        append_date : bool, optional\n            Whether to add today's date to the end of the json_key string\n\n        Returns\n        -------\n        str\n            The formatted JSON key\n\n        \"\"\"\n        key = f\"{cls.name()}-{cls.temporal_resolution()}\"\n        if append_date:\n            key = f\"{key}-{datetime.datetime.now().strftime(cls.DATE_FORMAT_FOLDER)}\"\n        return key\n\n    # PATHS\n\n    def local_input_path(self) -> str:\n        \"\"\"\n        The path to local data is built recursively by appending each derivative's relative path to the previous derivative's\n        path. If a custom input path is set, force return the custom path.\n        \"\"\"\n        if self.custom_input_path:\n            return pathlib.Path(self.custom_input_path)\n        else:\n            path = pathlib.Path(self.local_input_root) / pathlib.Path(\n                self.relative_path()\n            )\n            # Create directory if necessary\n            path.mkdir(parents=True, mode=0o755, exist_ok=True)\n            return path\n\n    def relative_path(self) -> str:\n        \"\"\"\n        The file folder hierarchy for a set. This should be a relative path so it can be appended to other root paths like\n        `self.local_input_path()` and `self.output_path()`\n\n        Returns\n        -------\n        str\n            The relative path that should be used for this set's data\n\n        \"\"\"\n        return pathlib.Path(\".\")\n\n    def input_files(self) -> list:\n        \"\"\"\n        Iterator for iterating through the list of local input files\n\n        Returns\n        -------\n        list\n            List of input files from `self.local_input_path()`\n\n        \"\"\"\n        root = pathlib.Path(self.local_input_path())\n        for entry in natsort.natsorted(pathlib.Path(root).iterdir()):\n            if (\n                not entry.name.startswith(\".\")\n                and not entry.name.endswith(\".idx\")\n                and entry.is_file()\n            ):\n                yield pathlib.Path(root / entry.name)\n\n    def get_folder_path_from_date(\n        self, date: datetime.datetime, omit_root: bool = False\n    ) -> str:\n        \"\"\"\n        Return a folder path inside `self.output_root` with the folder name based on `self.temporal_resolution()`\n        and the passed `datetime`. If `omit_root` is set, remove `self.output_root` from the path.\n\n        Parameters\n        ----------\n        date : datetime.datetime\n            datetime.datetime object representing the date to be appended to the folder name\n        omit_root : bool, optional\n            If False, prepent `self.output_root` to the beginning of the path, otherwise leave it off. Defaults to False\n\n        Returns\n        -------\n        str\n            Directory path derived from the date provided\n\n        \"\"\"\n        if self.temporal_resolution() == self.SPAN_HOURLY:\n            date_format = self.DATE_HOURLY_FORMAT_FOLDER\n        else:\n            date_format = self.DATE_FORMAT_FOLDER\n        path = pathlib.Path(self.relative_path()) / date.strftime(date_format)\n        if not omit_root:\n            path = pathlib.Path(self.output_root) / path\n        return path\n\n    def output_path(self, omit_root: bool = False) -> str:\n        \"\"\"\n        Return the path to a directory where parsed climate data will be written, automatically determining the end date and\n        base on that. If `omit_root` is set, remove `self.output_root` from the path. Override with `self.custom_output_path`\n        if that member variable is set.\n\n        Parameters\n        ----------\n        omit_root : bool, optional\n            If False, prepend self.output_root to the beginning of the path, otherwise leave it off. Defaults to False.\n\n        Returns\n        -------\n        str\n            string representing the output directory path where climate data will be written\n        \"\"\"\n        if self.custom_output_path is not None:\n            return self.custom_output_path\n        else:\n            path = self.relative_path()\n            if not omit_root:\n                path = self.output_root / path\n            return path\n\n    def create_output_path(self):\n        \"\"\"\n        Make output directory\n        \"\"\"\n        os.makedirs(self.output_path(), 0o755, exist_ok=True)\n\n    # DATES\n\n    def get_metadata_date_range(self) -> dict:\n        \"\"\"\n        Returns the date range in the metadata as datetime objects in a dict with `start` and `end` keys.\n\n        On IPLD, uses STAC to get the date. On S3 and local, uses an existing Zarr.\n\n        Existing dates are assumed to be formatted as \"%Y%m%d%H\"\n\n        Returns\n        -------\n        dict\n            Two str: datetime.datetimes representing the start and end times in a STAC Item's metadata\n        \"\"\"\n        date_format = \"%Y%m%d%H\"\n        if isinstance(self.store, IPLD):\n            # Use STAC\n            metadata = self.load_stac_metadata()\n            return {\n                \"start\": datetime.datetime.strptime(\n                    metadata[\"properties\"][\"date range\"][0], date_format\n                ),\n                \"end\": datetime.datetime.strptime(\n                    metadata[\"properties\"][\"date range\"][1], date_format\n                ),\n            }\n        else:\n            # Use existing Zarr attrs or raise an exception if there is no usable date attribute\n            if self.store.has_existing:\n                dataset = self.store.dataset()\n                if \"date range\" in dataset.attrs:\n                    # Assume attr format is ['%Y%m%d%H', '%Y%m%d%H'], translate to datetime objects, then transform into a dict with \"start\" and \"end\" keys\n                    return dict(\n                        zip(\n                            (\"start\", \"end\"),\n                            (\n                                datetime.datetime.strptime(d, date_format)\n                                for d in dataset.attrs[\"date range\"]\n                            ),\n                        )\n                    )\n                else:\n                    raise ValueError(\n                        f\"Existing date range not found in {dataset} attributes\"\n                    )\n            else:\n                raise ValueError(\n                    f\"No existing dataset found to get date range from at {self.store}\"\n                )\n\n    def convert_date_range(\n        self, date_range: list\n    ) -> tuple[datetime.datetime, datetime.datetime]:\n        \"\"\"\n        Convert a JSON text/isoformat date range into a python datetime object range\n\n        Parameters\n        ----------\n        date_range : list\n            A list of length two containing isoformatted start and end date strings\n\n        Returns\n        -------\n        tuple[datetime.datetime, datetime.datetime]\n            A tuple of (datetime.datetime, datetime.datetime) representing a date range's start and end\n\n        \"\"\"\n        if re.match(\".+/.+/.+\", date_range[0]):\n            start, end = [\n                datetime.datetime.strptime(d, self.DATE_FORMAT_METADATA)\n                for d in date_range\n            ]\n        else:\n            start, end = [datetime.datetime.fromisoformat(d) for d in date_range]\n        return start, end\n\n    def iso_to_datetime(self, isodate: str) -> datetime.datetime:\n        \"\"\"\n        Get a datetime object from an ISO formatted date string\n\n        Parameters\n        ----------\n        isodate : str\n            An Isoformatted string representing a date\n\n        Returns\n        -------\n        datetime.datetime\n            The converted date\n\n        \"\"\"\n        return datetime.datetime.fromisoformat(isodate)\n\n    def numpydate_to_py(self, numpy_date: np.datetime64) -> datetime.datetime:\n        \"\"\"\n        Convert a numpy datetime object to a python standard library datetime object\n\n        Parameters\n        ----------\n        np.datetime64\n            A numpy.datetime64 object to be converted\n\n        Returns\n        -------\n        datetime.datetime\n            A datetime.datetime object\n\n        \"\"\"\n        return pd.Timestamp(numpy_date).to_pydatetime()\n\n    @staticmethod\n    def today() -> str:\n        \"\"\"\n        Convenience method to return today's date in Isoformat\n\n        Returns\n        -------\n        str\n            Today's date in Isoformat\n        \"\"\"\n        return datetime.date.today().isoformat()\n\n    # DATE RANGES\n\n    def get_date_range_from_dataset(\n        self, dataset: xr.Dataset\n    ) -> tuple[datetime.datetime, datetime.datetime]:\n        \"\"\"\n        Return the start and end date in a dataset's \"time\" dimension\n\n        Parameters\n        ----------\n        dataset : xr.Dataset\n            The xr.Dataset to be evaluated\n\n        Returns\n        -------\n        tuple[datetime.datetime, datetime.datetime]\n            A tuple defining the start and end date of a file's time dimension\n\n        \"\"\"\n        # use forecast times if they exist\n        if \"forecast_reference_time\" in dataset:\n            time_dim = \"forecast_reference_time\"\n        else:\n            time_dim = \"time\"\n        # if there is only one date, set start and end to the same value\n        if dataset[time_dim].size == 1:\n            value = dataset[time_dim].values\n            if isinstance(value, np.ndarray):\n                value = value[0]\n            start = self.numpydate_to_py(value)\n            end = start\n        else:\n            start = self.numpydate_to_py(dataset[time_dim][0].values)\n            end = self.numpydate_to_py(dataset[time_dim][-1].values)\n        return start, end\n\n    def get_date_range_from_file(\n        self, path: str, backend_kwargs: dict = None\n    ) -> tuple[datetime.datetime, datetime.datetime]:\n        \"\"\"\n        Open file and return the start and end date of the data. The dimension name used to store dates should be passed as `dimension`.\n\n        Parameters\n        ----------\n        path : str\n            Path to the input dataset file on disk\n        backend_kwargs : dict, optional\n            Backend arguments for the xr.open_dataset() method\n\n        Returns\n        -------\n        tuple\n            A tuple of datetime.datetime objects defining the start and end date of a file's time dimension\n\n        \"\"\"\n        dataset = xr.open_dataset(path, backend_kwargs=backend_kwargs)\n        date_range = self.get_date_range_from_dataset(dataset)\n        dataset.close()\n        del dataset\n        gc.collect()\n        return date_range\n\n    def date_range_to_string(self, date_range: tuple) -> tuple[str, str]:\n        \"\"\"\n        Convert a tuple of datetime objects to a tuple of parseable strings. Necessary for Xarray metadata parsing.\n\n        Parameters\n        ----------\n        date_range : tuple\n            A (datetime.datetime, datetime.datetime) tuple containing the start and end dates of a date range\n\n        Returns\n        -------\n        tuple\n            A tuple of `%Y%m%d%H` formatted start and end dates of a date range\n\n        \"\"\"\n        return (\n            datetime.datetime.strftime(date_range[0], \"%Y%m%d%H\"),\n            datetime.datetime.strftime(date_range[1], \"%Y%m%d%H\"),\n        )\n\n    def get_newest_file_date_range(self) -> datetime.datetime:\n        \"\"\"\n        Return the date range of the newest local file\n\n        Returns\n        -------\n        datetime.datetime\n            The start and end date of the newest local file\n\n        \"\"\"\n        return self.get_date_range_from_file(list(self.input_files())[-1])\n\n    # STRING TRANSFORMATIONS\n\n    def _coord_reformat(self, *args, pretty: bool = False, padding: int = 0) -> str:\n        \"\"\"\n        Return coordinates (individually or pair) as a single string value with 3 decimal places of precision. With `pretty` set\n        to False, return a string that can be used for a file name. With `pretty` set to True, return formatted coordinate string\n\n        Parameters\n        ----------\n        args : list\n            A list of (index, coordinate) tuples\n        pretty : bool, optional\n            A switch indicating whether to add a separator to the returned coordinates\n        padding : int\n            The number of zero padding spaces, in integer form, to add to returned coordinates\n\n        Returns\n        -------\n        str\n            Coordinates reformatted as specified\n\n        \"\"\"\n        if not pretty:\n            separator = \"_\"\n            coords = \"\"\n        else:\n            separator = \", \"\n            coords = \"(\"\n        for ii, coord in enumerate(args):\n            if ii > 0:\n                coords += separator\n            coords += f\"{float(coord):0{padding}.3f}\"\n        if pretty:\n            coords += \")\"\n        return coords\n\n    def coord_str(self, *args, pretty: bool = False, padding=0) -> str:\n        \"\"\"\n        Return coordinates (individually or pair) as a single string value with 3 decimal places of precision. With `pretty` set\n        to False, return a string that can be used for a file name. With `pretty` set to True, return formatted coordinate string\n\n\n        Parameters\n        ----------\n        args : list\n            A list of (index, coordinate) tuples\n        pretty : bool, optional\n            A switch indicating whether to add a separator to the returned coordinates\n        padding : int\n            The number of zero padding spaces, in integer form, to add to returned coordinates\n\n        Returns\n        -------\n        str\n            Coordinates reformatted as specified\n\n        \"\"\"\n        translated_args = []\n        for coord in args:\n            if isinstance(coord, xr.DataArray):\n                translated_args.append(coord.values)\n            else:\n                translated_args.append(coord)\n        return self._coord_reformat(*translated_args, pretty=pretty, padding=padding)\n\n    # FTP\n\n    def sync_ftp_files(\n        self,\n        server: str,\n        directory_path: str,\n        file_match_pattern: str,\n        include_size_check: bool = False,\n    ):\n        \"\"\"\n        Connect to `server` (currently only supports anonymous login), change to `directory_path`, pull new and updated files\n        that match `file_match_pattern` in that directory into `self.local_input_path()`. Store a list of newly downloaded\n        files in a member variable.\n\n        Parameters\n        ----------\n        server : str\n            The URL of the FTP server to check\n        directory_path: str\n            The path to the directory holding the desired FTP files on the server\n        file_match_pattern : str\n            A regex string to match file names (in directory_path) against\n        include_size_check : bool, optional\n            Switch to check (or not) the size of files against a maximum. Defaults to False.\n\n        \"\"\"\n        # Login to remote FTP server\n        with ftplib.FTP(server) as ftp:\n            self.info(\n                \"checking {}:{} for files that match {}\".format(\n                    server, directory_path, file_match_pattern\n                )\n            )\n            ftp.login()\n            ftp.cwd(directory_path)\n            # Loop through directory listing\n            for file_name in ftp.nlst():\n                if re.match(file_match_pattern, file_name):\n                    # path on our local filesystem\n                    local_file_path = pathlib.Path(self.local_input_path()) / file_name\n                    modification_timestamp = ftp.sendcmd(\"MDTM {}\".format(file_name))[\n                        4:\n                    ].strip()\n                    modification_time = datetime.datetime.strptime(\n                        modification_timestamp, \"%Y%m%d%H%M%S\"\n                    )\n                    # Retrieve this file unless we find conditions not to\n                    retrieve = True\n                    # Compare to local file of same name\n                    if local_file_path.exists():\n                        local_file_attributes = os.stat(local_file_path)\n                        local_file_mtime = datetime.datetime.fromtimestamp(\n                            local_file_attributes.st_mtime\n                        )\n                        local_file_size = local_file_attributes.st_size\n                        # Set to binary transfer mode\n                        ftp.sendcmd(\"TYPE I\")\n                        remote_file_size = ftp.size(file_name)\n                        if modification_time <= local_file_mtime and (\n                            not include_size_check\n                            or remote_file_size == local_file_size\n                        ):\n                            self.debug(\n                                \"local file {} does not need updating\".format(\n                                    local_file_path\n                                )\n                            )\n                            retrieve = False\n                        elif modification_time > local_file_mtime:\n                            self.debug(\n                                \"file {} local modification time {} less than remote modification time {}\".format(\n                                    local_file_path,\n                                    local_file_mtime.strftime(\"%Y/%m/%d\"),\n                                    modification_time.strftime(\"%Y/%m/%d\"),\n                                )\n                            )\n                        else:\n                            self.debug(\n                                \"mismatch between local and remote size for file {}\".format(\n                                    local_file_path\n                                )\n                            )\n                    else:\n                        self.debug(\"new remote file found {}\".format(file_name))\n                    # Write this file locally\n                    if retrieve:\n                        self.new_files.append(self.local_input_path() / file_name)\n                        self.info(\n                            \"downloading remote file {} to {}\".format(\n                                file_name, local_file_path\n                            )\n                        )\n                        with open(local_file_path, \"wb\") as fp:\n                            ftp.retrbinary(\"RETR {}\".format(file_name), fp.write)\n\n    # ETC\n\n    def array_has_data(self, array: np.ndarray) -> bool | np.ndarray:\n        \"\"\"\n        Convenience method to determine if an array has any data\n\n        Parameters\n        ----------\n        array : np.array\n            A numpy array to assess\n\n        Returns\n        -------\n        bool | np.array\n            Either a boolean indicating whether an array has data,\n            or an array containing multiple booleans indicating which arrays have data\n\n        \"\"\"\n        return not np.all(np.isnan(array))\n\n    def bbox_coords(self, dataset: xr.Dataset) -> tuple[float, float, float, float]:\n        \"\"\"\n        Calculate bounding box coordinates from an Xarray dataset\n\n        Parameters\n        ----------\n        dataset : xr.Dataset\n            The dataset to use for extent calculations\n\n        Returns\n        -------\n        tuple[float, float, float, float]\n            The minimum X, minimum Y, maximum X, and maximum Y values of the dataset's bounding box extent\n        \"\"\"\n        return (\n            round(float(dataset.longitude.values.min()), self.bbox_rounding_value),\n            round(float(dataset.latitude.values.min()), self.bbox_rounding_value),\n            round(float(dataset.longitude.values.max()), self.bbox_rounding_value),\n            round(float(dataset.latitude.values.max()), self.bbox_rounding_value),\n        )\n\n    def json_to_bytes(self, obj: dict) -> bytes:\n        \"\"\"\n        Convert a JSON object to a file type object (bytes). Primarily used for passing STAC metadata to IPFS\n\n        Parameters\n        ----------\n        obj : dict\n            The object (JSON) to be converted\n\n        Returns\n        -------\n        bytes\n            The json encoded as a file type object\n        \"\"\"\n        return io.BytesIO(json.dumps(obj).encode(\"utf-8\"))\n\n    def check_if_new_data(self, compare_date: datetime.datetime) -> bool:\n        \"\"\"\n        Check if the downloaded data contains any new records relative to the existing dataset.\n        Return a boolean indicating whether to proceed with a transform/parse based on the presence of new records.\n\n        Parameters\n        ==========\n        compare_date : datetime.datetime\n            A cutoff date to compare against downloaded data; if any downloaded data is newer, move ahead with the parse.\n            When updating, refers to the last datetime available in the existing dataset.\n\n        Returns\n        =======\n        bool\n            An indication of whether to proceed with a parse (True) or not (False)\n        \"\"\"\n\n        # check if newest file on our server has newer data\n        try:\n            newest_file_end_date = self.get_newest_file_date_range()[1]\n        except IndexError as e:\n            self.info(f\"Date range operation failed due to absence of input files. Exiting script. Full error message: {e}\")\n            return False\n        self.info(f\"newest file ends at {newest_file_end_date}\")\n        if newest_file_end_date >= compare_date:\n            self.info(f\"newest file has newer data than our end date {compare_date}, triggering parse\")\n            return True\n        else:\n            self.info(f\"newest file doesn't have data past our existing end date {compare_date}.\")\n            return False\n\n    @classmethod\n    def standardize_longitudes(cls, dataset: xr.Dataset) -> xr.Dataset:\n        \"\"\"\n        Convert the longitude coordinates of a dataset from 0 - 360 to -180 to 180.\n\n        Parameters\n        ----------\n        xr.Dataset\n            A dataset with longitudes from 0 to 360\n        Returns\n        -------\n        xr.Dataset\n            A dataset with longitudes from -180 to 180\n\n        \"\"\"\n        # Convert longitudes from 0 - 360 to -180 to 180\n        dataset = dataset.assign_coords(\n            longitude=(((dataset.longitude + 180) % 360) - 180)\n        )\n        # After converting, the longitudes may still start at zero. This reorders the longitude coordinates from -180 to 180 if necessary.\n        return dataset.sortby([\"latitude\", \"longitude\"])"]}
{"filename": "gridded_etl_tools/utils/ipfs.py", "chunked_list": ["import dag_cbor\nimport requests\n\n\nfrom multiformats import multicodec, multihash\n\nfrom requests.adapters import HTTPAdapter, Retry\nfrom requests.exceptions import Timeout as TimeoutError\nfrom requests.exceptions import HTTPError\n", "from requests.exceptions import HTTPError\n\n# Base methods\n\n\ndef get_retry_session() -> requests.Session:\n    session = requests.Session()\n    retries = Retry(connect=5, total=5, backoff_factor=4)\n    session.mount(\"http://\", HTTPAdapter(max_retries=retries))\n    return session", "\n\nclass IPFS:\n    \"\"\"\n    Methods to be inherited by a DatasetManager that needs to instantiate and interact with an IPFS client\n    \"\"\"\n\n    def __init__(\n        self,\n        host: str,\n        default_hash: str\n        | int\n        | multicodec.Multicodec\n        | multihash.Multihash = \"sha2-256\",\n        default_base: str = \"base32\",\n        default_timeout: int = 600,\n    ):\n        self._host = host\n        self._default_base = default_base\n        self._default_timeout = default_timeout\n        self._default_hash = default_hash\n\n        self.ipfs_session = get_retry_session()\n\n    # FUNDAMENTAL METHODS\n\n    def ipfs_get(self, cid: str) -> dict:\n        \"\"\"\n        Fetch a DAG CBOR object by its IPFS hash and return it as a JSON\n\n        Parameters\n        ----------\n        cid : str\n            The IPFS hash corresponding to a given object (implicitly DAG CBOR)\n\n        Returns\n        -------\n        dict\n            The referenced DAG CBOR object decoded as a JSON\n        \"\"\"\n        res = self.ipfs_session.post(\n            self._host + \"/api/v0/block/get\",\n            timeout=self._default_timeout,\n            params={\"arg\": str(cid)},\n        )\n        res.raise_for_status()\n        return dag_cbor.decode(res.content)\n\n    def ipfs_put(self, bytes_obj: bytes, should_pin: bool = True) -> str:\n        \"\"\"\n        Turn a bytes object (file type object) into a DAG CBOR object compatible with IPFS and return its corresponding multihash\n\n        Parameters\n        ----------\n        bytes_obj : bytes\n            A file type (io.BytesIO) object to be converted into a DAG object and put on IPFS\n\n        should_pin : bool, optional\n            Whether to automatically pin this object when converting it to a DAG. Defauls to True.\n\n        Returns\n        -------\n        str\n            The IPFS hash (base32 encoded) corresponding to the newly created DAG object\n        \"\"\"\n        res = self.ipfs_session.post(\n            self._host + \"/api/v0/dag/put\",\n            params={\n                \"store-codec\": \"dag-cbor\",\n                \"input-codec\": \"dag-json\",\n                \"pin\": should_pin,\n                \"hash\": self._default_hash,\n            },\n            files={\"dummy\": bytes_obj},\n        )\n        res.raise_for_status()\n        return res.json()[\"Cid\"][\"/\"]  # returns hash of DAG object created\n\n    # IPNS METHODS\n\n    def ipns_resolve(self, key: str) -> str:\n        \"\"\"\n        Resolve the IPFS hash corresponding to a given key\n\n        Parameters\n        ----------\n        key : str\n            The IPNS key (human readable name) referencing a given dataset\n\n        Returns\n        -------\n        str\n            The IPFS hash corresponding to a given IPNS name hash\n        \"\"\"\n        ipns_key = self.ipns_key_list()[key]\n        res = self.ipfs_session.post(\n            self._host + \"/api/v0/name/resolve\",\n            timeout=self._default_timeout,\n            params={\"arg\": ipns_key},\n        )\n        res.raise_for_status()\n        return res.json()[\"Path\"][6:]  # 6: shaves off leading '/ipfs/'\n\n    def ipns_publish(self, key: str, cid: str, offline: bool = False) -> str:\n        \"\"\"\n        Publish an IPNS key string and return the corresponding name hash\n\n        Parameters\n        ----------\n        key : str\n            The human readable key part of the IPNS key pair referencing an object\n        cid : str\n            The hash the key pair will resolve to\n        offline : bool, optional\n            An optional trigger to disable the publication of this IPNS key and name hash over the IPFS network.\n            Offline mode will be much faster but will not publish the key pair to peers' Distributed Hash Tables on the global network.\n\n        Returns\n        -------\n        str\n            The IPNS \"name\" hash corresponding to the published key\n        \"\"\"\n        # Pin the IPFS CID and publish your key, linking they key to the desired CID\n        res = self.ipfs_session.post(\n            self._host + \"/api/v0/name/publish\",\n            timeout=self._default_timeout,\n            params={\n                \"arg\": cid,\n                \"key\": key,\n                \"allow-offline\": offline,\n                \"offline\": offline,\n            },\n        )\n        res.raise_for_status()\n        ipns_name_hash = res.json()[\"Name\"]\n        self.info(\n            f\"Published CID {cid} for key {key} to name hash {ipns_name_hash} and pinned it in the process\"\n        )\n        return ipns_name_hash\n\n    def ipns_key_list(self) -> dict:\n        \"\"\"\n        Return IPFS's Key List as a dict corresponding of key strings and associated ipns name hashes\n\n        Returns\n        -------\n        ipns_key_hash_dict : dict\n            All the IPNS name hashes and keys in the local IPFS repository\n        \"\"\"\n        ipns_key_hash_dict = {}\n        for name_hash_pair in self.ipfs_session.post(\n            self._host + \"/api/v0/key/list\", timeout=self._default_timeout\n        ).json()[\"Keys\"]:\n            key, val = tuple(name_hash_pair.values())\n            ipns_key_hash_dict[key] = val\n        return ipns_key_hash_dict\n\n    def ipns_generate_name(self, key: str = None) -> str:\n        \"\"\"\n        Generate a stable IPNS name hash to populate the `href` field of any STAC Object.\n        If a name hash already exists, return it.\n\n        Parameters\n        ----------\n        key : str\n            The IPNS key string to be used to reference a given object\n\n        Returns\n        -------\n        ipns_name_hash : str\n            The IPNS name hash (str) resulting from the publication of an empty dict\n        \"\"\"\n        if key is None:\n            key = self.json_key()\n        # Only generate the key in IPFS's registry if it doesn't already exist\n        if key not in self.ipns_key_list():\n            res = self.ipfs_session.post(\n                self._host + \"/api/v0/key/gen\",\n                timeout=self._default_timeout,\n                params={\"arg\": key, \"type\": \"rsa\"},\n            )\n            self.info(f\"Key '{key}' generated in key list\")\n            res.raise_for_status()\n            return res.json()[\"Id\"]\n        else:\n            return self.ipns_key_list()[key]\n\n    def ipns_retrieve_object(self, ipns_name: str) -> tuple[dict, str]:\n        \"\"\"\n        Retrieve a JSON object using its human readable IPNS name key\n        (e.g. 'prism-precip-hourly).\n\n        Parameters\n        ----------\n        key : str\n            The IPNS key string referencing a given object\n        timeout : int, optional\n            Time in seconds to wait for a response from `ipfs.name.resolve` and `ipfs.dag.get` before failing. Defaults to 30.\n\n        Returns\n        -------\n        tuple[dict, str, str] | None\n            A tuple of the JSON and the hash part of the IPNS key pair\n        \"\"\"\n        ipns_key_hash = self.ipns_key_list()[ipns_name]\n        ipfs_hash = self.ipns_resolve(ipns_name)\n        json_obj = self.ipfs_get(ipfs_hash)\n        return json_obj, ipns_key_hash\n\n    # RETRIEVE LATEST OBJECT\n\n    def latest_hash(self, key: str = None) -> str | None:\n        \"\"\"\n        Get the latest hash of the climate data for this dataset. This hash can be loaded into xarray through xarray.open_zarr if\n        this is a Zarr compatible dataset. This will be the hash contained within the STAC metadata if this is STAC compatible dataset.\n\n        Parameters\n        ----------\n        key : str, optional\n            The name of the dataset in the format it is stored in the IPNS namespace. If `None`, the value of `self.json_key()`\n            will be used.\n\n        Returns\n        -------\n        str | None\n            The IPFS/IPLD hash corresponding to the climate data, or `None` if no data was found\n        \"\"\"\n        if self.custom_latest_hash is not None:\n            return self.custom_latest_hash\n        else:\n            if key is None:\n                key = self.json_key()\n            if hasattr(self, \"dataset_hash\") and self.dataset_hash:\n                return self.dataset_hash\n            elif self.check_stac_on_ipns(key):\n                # the dag_cbor.decode call in `self.ipfs_get` will auto-convert the `{'\\' : <CID>}``\n                # it finds to a CID object. Convert it back to a hash of type `str``\n                return str(\n                    self.load_stac_metadata(key)[\"assets\"][\"zmetadata\"][\"href\"].set(\n                        base=self._default_base\n                    )\n                )\n            else:\n                return None\n\n    def check_stac_on_ipns(self, key: str) -> bool:\n        \"\"\"\n        Convenience function to check whether a STAC object is registered with IPNS under the assigned key\n\n        Parameters\n        ----------\n        key : str\n            The IPNS key (human readable name) referencing a given dataset\n\n        Returns\n        -------\n        exists : bool\n            Whether the IPNS key exists in the IPFS key registry or not\n        \"\"\"\n        exists = True\n        try:\n            obj_json = self.ipns_retrieve_object(key)[0]\n            if \"stac_version\" not in obj_json:\n                raise TypeError\n        except TypeError:\n            self.info(f\"Non-STAC compliant object found for {key}\")\n            exists = False\n        except (KeyError, ValueError):\n            self.info(f\"No existing STAC-compliant object found for {key}.\")\n            exists = False\n        except (HTTPError, TimeoutError):\n            self.info(f\"No object found at {key}\")\n            exists = False\n        return exists", ""]}
{"filename": "gridded_etl_tools/utils/logging.py", "chunked_list": ["import sys\nimport logging\nimport pathlib\n\nfrom .attributes import Attributes\n\n\nclass Logging(Attributes):\n    \"\"\"\n    A base class holding logging methods for Zarr ETLs\n    \"\"\"\n\n    @classmethod\n    def log_to_file(\n        cls,\n        path: str = None,\n        level: str = logging.INFO,\n        log_format: str = \"%(asctime)s <%(name)s in %(threadName)s> %(levelname)-8s %(message)s\",\n        time_format: str = \"%Y/%m/%d %H:%M\",\n    ) -> logging.Handler:\n        \"\"\"\n        Attach a logging.handlers.WatchedFileHandler that will write log statements at `level` or higher to `path` in the requested formats.\n        Since this attaches the constructed handler to the root logger, this is basically a convenience function for creating a standard logging\n        module log handler and attaching it in the standard way. Since it is attached to the root logger, it will log all log statements sent to\n        Python's logging module, including both this application's and its underlying module's. If called with all defaults, this will create a log\n        in the current directory with the name based on this manager's name and the log level.\n\n        If there is already a handler attached to the root logger writing the same level log statements to the same path, set its formatting to\n        the requested format and do not attach a new handler.\n\n        Parameters\n        ----------\n        path : str\n            Path to a regular file to write log statements too, or None to build a default name in the current directory.\n        level : str, optional\n            Statements this level or higher will be printed (see logging module for levels). Defaults to 'logging.INFO'\n        log_format : str, optional.\n            The format of the log statement (see logging module for formatting options).\n            Defaults to \"%(asctime)s %(levelname)-8s <%(name)s> %(message)s\"\n        time_format:  str\n            The format of the timestamp printed at the beginning of the statement. Defaults to \"%Y/%m/%d %H:%M\".\n\n        Returns\n        -------\n        str\n            The logging.Handler that will be handling writing to the log file (this can be useful for manually removing the\n            handler from the root logger at a later time).\n\n        \"\"\"\n        # If no path was specified, build a path using the manager name and log level in the current directory\n        if path is None:\n            path = cls.default_log_path(level)\n\n        formatter = logging.Formatter(log_format, time_format)\n\n        # Search for an existing handler that already satisfies the requirements of the passed arguments so repeat log statements don't get\n        # logged. If an existing handler is found, set its formatting to the requested formatting and exit.\n        handler_already_exists = False\n        if logging.getLogger().hasHandlers():\n            for handler in logging.getLogger().handlers:\n                # Check if the handler is a WatchedFileHandler with the same level and path.\n                if (\n                    isinstance(handler, logging.handlers.WatchedFileHandler)\n                    and handler.level == level\n                    and pathlib.Path(handler.baseFilename).resolve()\n                    == pathlib.Path(path).resolve()\n                ):\n                    handler_already_exists = True\n                    handler.setFormatter(formatter)\n                    cls.info(f\"Found existing file log handler {handler}\")\n                    break\n\n        if not handler_already_exists:\n            # Use a standard file handler from the Python module\n            handler = logging.handlers.WatchedFileHandler(path)\n\n            # Apply requested formatting\n            handler.setFormatter(formatter)\n\n            # All log statments requested level or higher will be caught\n            handler.setLevel(level)\n\n            # Attach to root logger, catching every logger that doesn't have a handler attached to it, meaning this handler will catch\n            # all log statements from this repository that go through `self.log` (assuming a handler hasn't been added manually somewhere)\n            # and all log statements from Python modules that use standard logging practices (logging through the logging module and not\n            # attaching a handler).\n            logging.getLogger().addHandler(handler)\n\n        return handler\n\n    @classmethod\n    def log_to_console(\n        cls,\n        level: str = logging.INFO,\n        log_format: str = \"%(levelname)-8s <%(name)s in %(threadName)s> %(message)s\",\n    ):\n        \"\"\"\n        Attach a logging.StreamHandler that will write log statements at `level` or higher to the console. Since this attaches the stream handler\n        to the root logger, this is basically a convenience function for creating a standard stream handler and attaching it in the standard way.\n        Since it is attached to the root logger, it will log all log statements sent to Python's logging module, including both this application's\n        and its underlying module's.\n\n        If there is already a handler attached to the root logger writing to the console, set its formatting to the requested format and do not\n        attach a new handler.\n\n        Parameters\n        ----------\n        level : str, optional\n            Statements of this level or higher will be printed (see logging module for levels). Defaults to `logging.INFO`.\n        log_format : str, optional\n            The format of the log statement (see logging module for formatting options). Defaults to \"%(levelname)-8s <%(name)s> %(message)s\"\n\n        Returns\n        -------\n        str\n            The `logging.Handler` that will write the log statements to console (this can be useful for removing the handler\n            from the root logger manually at a later time).\n\n        \"\"\"\n        formatter = logging.Formatter(log_format)\n\n        # Search for an existing handler already writing to the console so repeat log statements don't get logged. If an existing handler is found,\n        # set its formatting to the requested formatting and exit.\n        handler_already_exists = False\n        if logging.getLogger().hasHandlers():\n            for handler in logging.getLogger().handlers:\n                # Check if the attached handler has a stream equal to stderr or stdout, meaning it is writing to the console.\n                if (\n                    hasattr(handler, \"stream\")\n                    and handler.level >= level\n                    and handler.stream in (sys.stderr, sys.stdout)\n                ):\n                    handler_already_exists = True\n                    # Apply requested formatting\n                    handler.setFormatter(formatter)\n                    cls.info(f\"Found existing console log handler {handler}\")\n                    break\n\n        if not handler_already_exists:\n            # Uses sys.stderr as the stream to write to by default. It would also make sense to write to sys.stdout, but since either stream\n            # could make sense, use the Python logging module default.\n            handler = logging.StreamHandler()\n\n            # Apply requested formatting\n            handler.setFormatter(formatter)\n\n            # All log statements requested level or higher will be caught.\n            handler.setLevel(level)\n\n            # See comment in self.log_to_file for information about what gets caught by this handler.\n            logging.getLogger().addHandler(handler)\n\n        return handler\n\n    @classmethod\n    def default_log_path(cls, level: str):\n        \"\"\"\n        Returns a default log path in a \"logs\" directory within the current working directory, incorporating level into the name.\n        Creates the \"logs\" directory if it doesn't already exist.\n        Probably only useful internally.\n\n        Parameters\n        ----------\n        level : str\n            The logging level to use. See logging module for log levels.\n\n        \"\"\"\n        pathlib.Path.mkdir(\n            pathlib.Path(\"./logs\"), mode=0o777, parents=False, exist_ok=True\n        )\n        return pathlib.Path(\"logs\") / f\"{cls.name()}_{logging.getLevelName(level)}.log\"\n\n    @classmethod\n    def log(cls, message: str, level: str = logging.INFO, **kwargs):\n        \"\"\"\n        This is basically a convenience function for calling logging.getLogger.log(`level`, `message`). The only difference is this uses\n        the manager name as the name of the log to enable log statements that include the name of the manager instead of \"root\". Since\n        logging module handlers at the root catch statements from all loggers that don't have a handler attached to them, the handlers\n        attached to the root (either through logging.Logger.addHandler, self.log_to_file, or self.log_to_console) will catch the `message`\n        logged with this function.\n\n        Parameters\n        ----------\n        message : str\n            Text to write to log.\n        level : str\n            Level of urgency of the message (see logging module for levels). Defaults to logging.INFO.\n        **kwargs : dict\n            Keyword arguments to forward to the logging.Logger. For example, `exc_info=True` can be used to print exception\n            information. See the logging module for all keyword arguments.\n\n        \"\"\"\n        logging.getLogger(cls.name()).log(level, message, **kwargs)\n\n    @classmethod\n    def info(cls, message: str, **kwargs):\n        \"\"\"\n        Log a message at `logging.INFO` level.\n\n        Parameters\n        ----------\n        message : str\n            Text to write to log.\n        **kwargs : dict\n            Keywords arguments passed to `logging.Logger.log`.\n\n        \"\"\"\n        cls.log(message, logging.INFO, **kwargs)\n\n    @classmethod\n    def debug(cls, message: str, **kwargs):\n        \"\"\"\n        Log a message at `loggging.DEBUG` level.\n\n        Parameters\n        ----------\n        message : str\n            Text to write to log.\n        **kwargs : dict\n            Keywords arguments passed to `logging.Logger.log`.\n\n        \"\"\"\n        cls.log(message, logging.DEBUG, **kwargs)\n\n    @classmethod\n    def warn(cls, message: str, **kwargs):\n        \"\"\"\n        Log a message at `loggging.WARN` level.\n\n        Parameters\n        ----------\n        message : str\n            Text to write to log.\n        **kwargs : dict\n            Keywords arguments passed to `logging.Logger.log`.\n        \"\"\"\n        cls.log(message, logging.WARN, **kwargs)\n\n    @classmethod\n    def error(cls, message: str, **kwargs):\n        \"\"\"\n        Log a message at `logging.ERROR` level.\n\n        Parameters\n        ----------\n        message : str\n            Text to write to log.\n        **kwargs : dict\n            Keywords arguments passed to `logging.Logger.log`.\n\n        \"\"\"\n        cls.log(message, logging.ERROR, **kwargs)\n\n    @classmethod\n    def log_except_hook(cls, exc_type, exc_value, exc_traceback):\n        cls.error(\"Uncaught exception\", exc_info=(exc_type, exc_value, exc_traceback))", ""]}
{"filename": "examples/__init__.py", "chunked_list": [""]}
{"filename": "examples/managers/my_new_etl.py", "chunked_list": ["##### my_new_etl.py\n#\n# Template classes for creating a new gridded climate data ETL.\n# All filled fields are examples that can be replaced; all unfilled fields must be filled by the user.\n\nimport datetime\nimport pathlib\n\nfrom gridded_etl_tools.dataset_manager import DatasetManager\n", "from gridded_etl_tools.dataset_manager import DatasetManager\n\n\nclass MyNewETL(DatasetManager):\n    \"\"\"\n    Base class for datasets from a provider. For example's sake assumes that such data are published in NetCDF format\n    \"\"\"\n\n    def __init__(\n            self, *args,\n            requested_dask_chunks={\"time\": 1769, \"latitude\": 24, \"longitude\": -1},\n            requested_zarr_chunks={\"time\": 1769, \"latitude\": 24, \"longitude\": 24},\n            requested_ipfs_chunker=\"size-2304\", **kwargs\n            ):\n        \"\"\"\n        Initialize a new ETL object with appropriate chunking parameters.\n        \"\"\"\n        super().__init__(requested_dask_chunks, requested_zarr_chunks, requested_ipfs_chunker, *args, **kwargs)\n        self.standard_dims = [\"latitude\", \"longitude\", \"time\"]\n\n    @property\n    def static_metadata(self) -> dict:\n        \"\"\"\n        dict containing static fields in the metadata\n        \"\"\"\n        static_metadata = {\n            \"coordinate reference system\": \"EPSG:4326\",\n            \"spatial resolution\": self.spatial_resolution,\n            \"spatial precision\": 0.01,\n            \"temporal resolution\": self.temporal_resolution(),\n            \"update cadence\": \"daily\",\n            \"provider url\": \"\",\n            \"data download url\": \"\",\n            \"publisher\": \"\",\n            \"title\": \"\",\n            \"provider description\": \"\",\n            \"dataset description\": \"\",\n            \"license\": \"\",\n            \"terms of service\": \"\",\n            \"name\": self.name(),\n            \"updated\": str(datetime.datetime.now()),\n            \"missing value\": self.missing_value_indicator(),\n            \"tags\": self.tags,\n            \"standard name\": self.standard_name,\n            \"long name\": self.long_name,\n            \"unit of measurement\": self.unit_of_measurement\n            }\n\n        return static_metadata\n\n    @classmethod\n    def collection(cls) -> str:\n        \"\"\"\n        Overall collection of data. Used for filling STAC Catalogue.\n        \"\"\"\n        return \"Dataset Collection\"\n\n    @classmethod\n    def name(cls) -> str:\n        \"\"\"\n        The name of the dataset.\n        Used as a command-line trigger and to populate directory names, so whitespaces must be undesrcored or hyphenated\n        \"\"\"\n        return \"dataset_name\"\n\n    @classmethod\n    def temporal_resolution(cls) -> str:\n        \"\"\"Incremental step size for temporal values in the dataset's time dimension\"\"\"\n        return cls.SPAN_DAILY\n\n    @property\n    def dataset_start_date(self) -> datetime.datetime:\n        \"\"\"First date in dataset. Used to populate corresponding encoding and metadata.\"\"\"\n        return datetime.datetime(1979, 1, 1, 0)\n\n    @classmethod\n    def missing_value_indicator(cls) -> str:\n        \"\"\"\n        What value should be interpreted and masked as NA.\n        Failure to specify this correctly may result in values incorrectly entering calculations and/or coordinate values being masked\n        \"\"\"\n        return -9.96921e+36  # replace\n\n    def relative_path(self) -> pathlib.Path:\n        \"\"\"Relative path in which to output raw files or a final zarr\"\"\"\n        return super().relative_path() / self.name()\n\n    @property\n    def file_type(cls) -> str:\n        \"\"\"\n        File type of raw data. Used to trigger file format-appropriate functions and methods for Kerchunking and Xarray operations.\n        \"\"\"\n        return \"NetCDF\"\n\n    @classmethod\n    def remote_protocol(cls) -> str:\n        \"\"\"\n        Remote protocol string for MultiZarrToZarr and Xarray to use when opening input files. 'File' for local, 's3' for S3, etc.\n        See fsspec docs for more details.\n        \"\"\"\n        return \"file\"\n\n    @classmethod\n    def identical_dims(cls) -> str:\n        \"\"\"\n        List of dimension(s) whose values are identical in all input datasets. This saves Kerchunk time by having it read these\n        dimensions only one time, from the first input file\n        \"\"\"\n        return [\"latitude\", \"longitude\"]\n\n    @classmethod\n    def concat_dims(cls) -> str:\n        \"\"\"\n        List of dimension(s) by which to concatenate input files' data variable(s) -- usually time, possibly with some other relevant dimension\n        \"\"\"\n        return [\"time\"]\n\n    def extract(self, rebuild: bool = False, date_range: list[datetime.datetime, datetime.datetime] = None, *args, **kwargs) -> bool:\n        \"\"\"\n        Check the remote from the end year of or after our data's end date. Download necessary files. Check\n        newest file and return `True` if it has newer data than us or `False` otherwise.\n\n        Pseudocode for the basic logic behind retrievals is provided below\n\n        Returns\n        -------\n        bool\n            A boolean indicating whether to proceed with a parse operation or not\n        \"\"\"\n        parsing_should_happen = False\n        # Insert custom retrieval code here\n        if rebuild:\n            # download everything, regardless of what data already exists\n            pass  # insert download everything logic here\n        elif date_range:\n            # only download for the selected date range\n            pass  # insert download everything logic here\n        else:\n            # if this is the first time an ETL is running, download all available data\n            # if this is an update to an existing dataset,download whatever new or updated data has been published since the last time the dataset was updated\n            new_data_found = False  # set conditions here\n            if new_data_found:\n                # download only the new data, then trigger a parse\n                parsing_should_happen = True\n\n        # Trigger a parse based on whether new data was found / rebuild flag provided\n        if parsing_should_happen | rebuild:\n            self.info(\"Conditions met to trigger a parse\")\n            return True\n        else:\n            self.info(\"Conditions not met to trigger a parse\")\n            return False\n\n    def prepare_input_files(self, keep_originals: bool = False):\n        \"\"\"\n        Command line tools converting raw downloaded data to daily / hourly data\n        Normally `convert_to_lowest_common_time_denom` and/or `ncs_to_nc4s` are used here,\n        perhaps in combinations, perhaps overloaded, perhaps paired with custom processing\n        \"\"\"\n        ...\n\n    @classmethod\n    def postprocess_zarr(self, dataset):\n        \"\"\"\n        Serves to rename dimensions, drop unneeded vars and dimensions, and generally reshape the overall Dataset\n\n        :param xarray.Dataset dataset: The dataset to manipulate. This is automatically supplied when this function is submitted under xarray.open_dataset()\n        \"\"\"\n\n        # Remove extraneous data variables and format dimensions/coordinates correctly\n        # unwanted_vars = [var for var in dataset.data_vars if var in ['time_bnds', 'lon_bnds', 'lat_bnds']]\n        # dataset = dataset.drop_vars(unwanted_vars)\n\n        # # Remove extraneous dimension\n        # dataset = dataset.drop_dims(\"extra_dim\")\n\n        # Rename lat and lon to latitude and longitude which are dClimate standard\n        # dataset = dataset.rename({\"lat\" : \"latitude\", \"lon\" : \"longitude\"})\n\n        # Convert longitudes to -180 to 180 as dClimate data is stored in this format\n        # dataset = dataset.assign_coords(longitude=(((dataset.longitude + 180) % 360) - 180))\n\n        # After converting, the longitudes may still start at zero. This converts the longitude coordinates to go from -180 to 180 if necessary.\n        # dataset = dataset.sortby(\"latitude\").sortby(\"longitude\")\n\n        return dataset\n    \n    def set_zarr_metadata(self, dataset):\n        \"\"\"\n        Function to append to or update key metadata information to the attributes and encoding of the output Zarr. \n        Extends existing class method to create attributes or encoding specific to dataset being converted.\n        Dunction and its sub-methods provide a stepwise process for fixing encoding issues and getting the metadata just right.\n\n        :param xr.Dataset dataset: The dataset prepared for parsing to IPLD\n        \"\"\"\n        dataset = super().set_zarr_metadata(dataset)", "        # Some example considerations for setting metadata below\n\n        # Some filters may carry over from the original datasets will result in the dataset being unwriteable b/c \"ValueError: codec not available: 'grib\"\n        # for coord in [\"latitude\",\"longitude\"]:\n        #     dataset[coord].encoding.pop(\"_FillValue\",None)\n        #     dataset[coord].encoding.pop(\"missing_value\",None)\n\n        # Remove extraneous data from the data variable's attributes\n        # keys_to_remove = [\"coordinates\", \"history\",\"CDO\",\"CDI\"]\n        # for key in keys_to_remove:", "        # keys_to_remove = [\"coordinates\", \"history\",\"CDO\",\"CDI\"]\n        # for key in keys_to_remove:\n        #     dataset.attrs.pop(key, None)\n        #     dataset[self.data_var()].attrs.pop(key, None)\n\n        # It is important to note the encoding of a dataset in particular if compression is enabled\n        # if zlib or other compression is enabled this will subvert IPFS de-duplication if the dataset\n        # is to be continuously updated in the future so it is important to set compression to false\n        # and chunk according to the ETL developer's manual. Otherwise if the dataset will only be converted\n        # once and not updated in the future then it is ok to leave compression enabled.", "        # and chunk according to the ETL developer's manual. Otherwise if the dataset will only be converted\n        # once and not updated in the future then it is ok to leave compression enabled.\n        # {'zlib': True,\n            # 'szip': False,\n            # 'zstd': False,\n            # 'bzip2': False,\n            # 'blosc': False,\n            # 'shuffle': True,\n            # 'complevel': 2,\n            # 'fletcher32': False,", "            # 'complevel': 2,\n            # 'fletcher32': False,\n            # 'contiguous': False,\n            # 'chunksizes': (1, 1801, 3600),\n            # 'source': '/Users/test/Desktop/Staging/nc_to_zarr/test.nc',\n            # 'original_shape': (10, 1801, 3600),\n            # 'dtype': dtype('float32'),\n            # 'missing_value': 9.96921e+36,\n            # '_FillValue': 9.96921e+36\n        # }", "            # '_FillValue': 9.96921e+36\n        # }\n\n        # Add a finalization date attribute to the Zarr metadata. Set the value to the object's finalization date if it is present in this object.\n        # If not, try to carry over the finalization date from an existing dataset. Finally, if there is no existing data, set the date attribute\n        # to an empty string. If the finalization date exists, format it to %Y%m%d%H.\n        # if hasattr(self, \"finalization_date\") and self.finalization_date is not None:\n        #     dataset.attrs[\"finalization date\"] = datetime.datetime.strftime(self.finalization_date, \"%Y%m%d%H\")\n        # else:\n        #     if self.store.has_existing and not self.rebuild_requested and \"finalization date\" in self.store.dataset().attrs:", "        # else:\n        #     if self.store.has_existing and not self.rebuild_requested and \"finalization date\" in self.store.dataset().attrs:\n        #         dataset.attrs[\"finalization date\"] = self.store.dataset().attrs[\"finalization date\"]\n        #         self.info(f'Finalization date not set previously, setting to existing finalization date: \"{dataset.attrs[\"finalization date\"]}\"')\n        #     else:\n        #         dataset.attrs[\"finalization date\"] = ''\n        #         self.info(\"Finalization date not set previously, setting to empty string\")\n\n        # return dataset\n", "        # return dataset\n\n\nclass MyNewETLPrecip(MyNewETL):\n    \"\"\"\n    Base class for precip sets\n    \"\"\"\n\n    @classmethod\n    def name(cls) -> str:\n        return f\"{super().name()}_precip\"\n\n    def relative_path(self) -> pathlib.Path:\n        \"\"\"\n        This will be used to create the path for files to be download to and read from\n        For example datasets/dataset_name/precip\n        \"\"\"\n        return super().relative_path() / \"precip\"\n\n    @property\n    def tags(self) -> list[str]:\n        \"\"\"Tags for data to enable filtering\"\"\"\n        return [\"Precipitation\"]\n\n    @property\n    def standard_name(self) -> str:\n        \"\"\"Short form name, as per the Climate and Forecasting Metadata Convention\"\"\"\n        return \"precipitation_amount\"\n\n    @property\n    def long_name(self) -> str:\n        \"\"\"Long form name, as per the Climate and Forecasting Metadata Convention\"\"\"\n        return \"Precipitation\"\n\n    @property\n    def unit_of_measurement(self) -> str:\n        return \"mm\"", "\n\nclass MyNewETLTemp(MyNewETL):\n    \"\"\"\n    Base class for gridded temperature data\n    \"\"\"\n\n    @classmethod\n    def name(cls) -> str:\n        return f\"{super().name()}_temp\"\n\n    def relative_path(self) -> pathlib.Path:\n        \"\"\"\n        This will be used to create the path for files to be download to and read from\n        For example datasets/dataset_name/temp\n        \"\"\"\n        return super().relative_path() / \"temp\"\n\n    @property\n    def tags(self) -> list[str]:\n        \"\"\"Tags for data to enable filtering\"\"\"\n        return [\"Temperature\"]\n\n    @property\n    def unit_of_measurement(self) -> str:\n        return \"degC\"\n\n    @property\n    def spatial_resolution(self) -> float:\n        return 0.5", "\n\nclass MyNewETLTempMin(MyNewETLTemp):\n    \"\"\"\n    Gridded minimum temperature data manager class\n    \"\"\"\n    @classmethod\n    def name(cls) -> str:\n        return f\"{super().name()}_min\"\n\n    def relative_path(self) -> pathlib.Path:\n        return super().relative_path() / \"min\"\n\n    def data_var(self) -> str:\n        \"\"\"\n        Name of the column in the original data\n        \"\"\"\n        return \"tmin\"\n\n    @property\n    def standard_name(self) -> str:\n        \"\"\"Short form name, as per the Climate and Forecasting Metadata Convention\"\"\"\n        return \"air_temperature\"\n\n    @property\n    def long_name(self) -> str:\n        \"\"\"Long form name, as per the Climate and Forecasting Metadata Convention\"\"\"\n        return \"Daily Minimum Near-Surface Air Temperature\"", "\n\nif __name__ == \"__main__\":\n    MyNewETL().run_etl_as_script()\n"]}
{"filename": "examples/managers/chirps.py", "chunked_list": ["##### CHIRPS_Zarr.py\n#\n# Classes for managing CHIRPS global, gridded precipitation data\n\nimport glob\nimport datetime\nimport pathlib\nimport re\nimport requests\nimport xarray as xr", "import requests\nimport xarray as xr\nfrom gridded_etl_tools.dataset_manager import DatasetManager\n\n\nclass CHIRPS(DatasetManager):\n    \"\"\"\n    The base class for any CHIRPS set using Arbol's data architecture. It is a superclass of both CHIRPS Final\n    (monthly updates of .05 and .25 resolution from 1981) and CHIRPS Prelim (weekly updates of 0.05 resolution, from 2016 to present).\n    \"\"\"\n    def __init__(\n            self, *args,\n            # 0.05 dataset size is time: 15000, latitude: 2000, longitude: 7200\n            requested_dask_chunks = {\"time\": 200, \"latitude\": 25, \"longitude\": -1},  # 144 MB\n            requested_zarr_chunks = {\"time\": 200, \"latitude\": 25, \"longitude\": 50},  # 1 MB\n            requested_ipfs_chunker = \"size-5000\",\n            **kwargs\n            ):\n        \"\"\"\n        Initialize a new CHIRPS object with appropriate chunking parameters.\n\n        0.05 dataset size is time: 15000, latitude: 2000, longitude: 7200\n        \"\"\"\n        super().__init__(requested_dask_chunks, requested_zarr_chunks, requested_ipfs_chunker, *args, **kwargs)\n        self.standard_dims = [\"latitude\", \"longitude\", \"time\"]\n\n    @property\n    def static_metadata(self):\n        \"\"\"\n        Dict containing static fields in the metadata. These will be populated into STAC metadata and Zarr metadata.\n        Fields that are static should be manually specified here.\n        Fields that change per child class should be defined as properties or class methods under the relevant child class\n        \"\"\"\n        static_metadata = {\n            \"coordinate reference system\": \"EPSG:4326\",\n            \"update cadence\": self.update_cadence,\n            \"temporal resolution\": self.temporal_resolution(),\n            \"spatial resolution\": self.spatial_resolution,\n            \"spatial precision\": 0.00001,\n            \"provider url\": \"http://chg.geog.ucsb.edu/\",\n            \"data download url\": self.dataset_download_url,\n            \"publisher\": \"Climate Hazards Group, University of California at Santa Barbara\",\n            \"title\": \"CHIRPS Version 2.0\",\n            \"provider description\": \"The Climate Hazards Center is an alliance of multidisciplinary scientists and food security analysts\"\n                                    \" utilizing climate and crop models, satellite-based earth observations, and socioeconomic data sets to\"\n                                    \" predict and monitor droughts and food shortages among the world's most vulnerable populations. Through\"\n                                    \" partnerships with USAID, USGS, and FEWS NET, the CHC provides early warning to save lives and secure livelihoods.\",\n            \"dataset description\": (\n                \"Climate Hazards center InfraRed Precipitation with Station data (CHIRPS) is a 30+ year quasi-global rainfall data set.\"\n                \" Spanning 50\u00b0S-50\u00b0N (and all longitudes), starting in 1981 to near-present, CHIRPS incorporates 0.05\u00b0 resolution satellite\"\n                \" imagery with in-situ station data to create gridded rainfall time series for trend analysis and seasonal drought monitoring. \"\n\n                \"For more information about CHIRPS data, visit http://chg.geog.ucsb.edu/data/chirps/index.html or\"\n                \" http://chg-wiki.geog.ucsb.edu/wiki/CHIRPS_FAQ. \"\n\n                \"For full technical documentation visit http://pubs.usgs.gov/ds/832/\"\n            ),\n            \"license\": \"Creative Commons Attribution 3.0\",\n            \"terms of service\": \"To the extent possible under the law, Pete Peterson has waived all copyright and related or neighboring\"\n                                \" rights to CHIRPS. CHIRPS data is in the public domain as registered with Creative Commons.\",\n            \"name\": self.name(),\n            \"updated\": str(datetime.datetime.now()),\n            \"missing value\": self.missing_value_indicator(),\n            \"tags\": self.tags,\n            \"standard name\": self.standard_name,\n            \"long name\": self.long_name,\n            \"unit of measurement\": self.unit_of_measurement\n            }\n\n        return static_metadata\n\n    @classmethod\n    def host_organization(cls) -> str:\n        return \"My Organization\"\n\n    @classmethod\n    def name(cls) -> str:\n        return \"chirps\"\n\n    def relative_path(self) -> str:\n        return super().relative_path() / \"chirps\"\n\n    @classmethod\n    def collection(cls) -> str:\n        \"\"\"Overall collection of data. Used for filling and referencing STAC Catalog.\"\"\"\n        return \"CHIRPS\"\n\n    @classmethod\n    def temporal_resolution(cls) -> str:\n        \"\"\"Increment size along the \"time\" coordinate axis\"\"\"\n        return cls.SPAN_DAILY\n\n    @classmethod\n    def data_var(self) -> str:\n        \"\"\"Name of the relevant data variable in the original dataset\"\"\"\n        return \"precip\"\n\n    @property\n    def standard_name(self):\n        \"\"\"Short form name, as per the Climate and Forecasting Metadata Convention\"\"\"\n        return \"precipitation_amount\"\n\n    @property\n    def long_name(self):\n        \"\"\"Long form name, as per the Climate and Forecasting Metadata Convention\"\"\"\n        return \"Precipitation\"\n\n    @property\n    def tags(self):\n        \"\"\"Tags for data to enable filtering\"\"\"\n        return [\"Precipitation\"]\n\n    @property\n    def unit_of_measurement(self):\n        \"\"\"Unit of measurement for the component key (data variable)\"\"\"\n        return \"mm\"\n\n    @property\n    def dataset_start_date(self):\n        \"\"\"First date in dataset. Used to populate corresponding encoding and metadata.\"\"\"\n        return datetime.datetime(1981, 1, 1, 0)\n\n    @classmethod\n    def missing_value_indicator(cls) -> int:\n        \"\"\"\n        Value within the source data that should be automatically converted to 'nan' by Xarray.\n        Cannot be empty/None or Kerchunk will fail, so use -9999 if no NoData value actually exists in the dataset.\n        \"\"\"\n        return -9999\n\n    @property\n    def dataset_download_url(self) -> str:\n        \"\"\"URL to download location of the dataset. May be an FTP site, API base URL, or otherwise.\"\"\"\n        return \"https://data.chc.ucsb.edu/products/CHIRPS-2.0\"\n\n    @property\n    def file_type(self) -> str:\n        \"\"\"\n        File type of raw data. Used to trigger file format-appropriate functions and methods for Kerchunking and Xarray operations.\n        \"\"\"\n        return 'NetCDF'\n\n    @classmethod\n    def remote_protocol(cls) -> str:\n        \"\"\"\n        Remote protocol string for MultiZarrToZarr and Xarray to use when opening input files. 'File' for local, 's3' for S3, etc.\n        See fsspec docs for more details.\n        \"\"\"\n        return 'file'\n\n    @classmethod\n    def identical_dims(cls) -> list[str]:\n        \"\"\"\n        List of dimension(s) whose values are identical in all input datasets. This saves Kerchunk time by having it read these\n        dimensions only one time, from the first input file\n        \"\"\"\n        return [\"latitude\", \"longitude\"]\n\n    @classmethod\n    def concat_dims(cls) -> list[str]:\n        \"\"\"\n        List of dimension(s) by which to concatenate input files' data variable(s) -- usually time, possibly with some other relevant dimension\n        \"\"\"\n        return [\"time\"]\n\n    @property\n    def bbox_rounding_value(self) -> int:\n        \"\"\"Value to round bbox values by\"\"\"\n        return 3\n\n    def extract(self, date_range: list[datetime.datetime, datetime.datetime] = None, *args, **kwargs) -> bool:\n        \"\"\"\n        Check CHIRPS HTTP server for files from the end year of or after our data's end date. Download necessary files. Check\n        newest file and return `True` if it has newer data than us or `False` otherwise.\n\n        Parameters\n        ----------\n        date_range: list, optional\n            A flag to specify a date range for download (and parsing). Assumes two isoformatted date strings. Defaults to None.\n\n        Returns\n        -------\n        bool\n            A boolean indicating whether to proceed with a parse operation or not\n        \"\"\"\n        # Find previous end date so the manager can start downloading the day after it\n        if not date_range:\n            try:\n                self.info(\"Calculating new start date based on end date in STAC metadata\")\n                end_date = self.get_metadata_date_range()[\"end\"] + datetime.timedelta(days=1)\n            except (KeyError, ValueError):\n                self.info(f\"Because no metadata found, starting file search from the dataset beginning of {self.dataset_start_date}\")\n                end_date = self.dataset_start_date\n            download_year_range = range(end_date.year, datetime.datetime.now().year + 1)\n        else:\n            self.info(\"Calculating start and end dates based on the provided date range.\")\n            end_date = date_range[1]\n            download_year_range = range(date_range[0].year, end_date.year + 1)\n        # find all files in the relevant remote server folder\n        url = f\"{self.dataset_download_url}/{self.remote_path}\"\n        self.info(f\"connecting to {url}\")\n        index = requests.get(url).text\n        # loop through every year from end date until present year and download any files that are newer than ones we have on our server\n        for year in download_year_range:\n            pattern = fr\"<a.+>(chirps-.+{year}.+\\.nc)</a></td><td[^>]+>([^<]+[0-9])\\s*</td>\"\n            matches = re.findall(pattern, index, re.MULTILINE)\n            if len(matches) > 0:\n                file_name, _ = matches[0]\n                local_path = self.local_input_path() / file_name\n                self.info(f\"downloading remote file {file_name}\")\n                remote_file = requests.get(f\"{url}{file_name}\").content\n                with open(local_path, 'wb') as local_file:\n                    local_file.write(remote_file)\n        # check if newest file on our server has newer data\n        try:\n            newest_file_end_date = self.get_newest_file_date_range()[1]\n        except IndexError as e:\n            self.info(f\"Date range operation failed due to absence of input files. Exiting script. Full error message: {e}\")\n            return False\n        self.info(f\"newest file ends at {newest_file_end_date}\")\n        if newest_file_end_date >= end_date:\n            self.info(f\"newest file has newer data than our end date {end_date}, triggering parse\")\n            return True\n        else:\n            self.info(f\"newest file doesn't have data past our existing end date {end_date}\")\n            return False\n\n    def prepare_input_files(self, keep_originals: bool = False):\n        \"\"\"\n        Convert each of the input files (and associated metadata files) to a collection of daily netCDF4 classic files suitable for\n        reading by Kerchunk and intake into Xarray. This allows us to stack data into modern, performant N-Dimensional Zarr data.\n\n        Parameters\n        ----------\n        keep_originals: bool, optional\n            A flag to preserve the original files for debugging purposes. Defaults to False.\n        \"\"\"\n        input_dir = pathlib.Path(self.local_input_path())\n        yearlies = [pathlib.Path(file) for file in glob.glob(str(input_dir / \"*.nc\"))]\n        if len(yearlies) == 0:\n            if glob.glob(str(input_dir / \"*.nc4\")):\n                self.info(\"Only converted NC4s found, skipping preparation step\")\n            if not glob.glob(str(input_dir / \"*.nc4\")):\n                raise FileNotFoundError(\"Neither yearly files nor converted NC4s found in input directory. Please provide data before processing\")\n        else:\n            # Convert input files to daily NetCDFs\n            self.info(f\"Converting {(len(list(yearlies)))} yearly NetCDF file(s) to daily NetCDFs\")\n            self.convert_to_lowest_common_time_denom(yearlies, keep_originals)\n            # Convert all NCs to NC4s\n            self.ncs_to_nc4s(keep_originals)\n\n        self.info(\"Finished preparing input files\")\n\n    def remove_unwanted_fields(self, dataset: xr.Dataset) -> xr.Dataset:\n        \"\"\"\n        Function to append to or update key metadata information to the attributes and encoding of the output Zarr.\n        Extends existing class method to create attributes or encoding specific to this dataset.\n\n        Parameters\n        ----------\n        dataset: xr.Dataset\n            The dataset prepared for parsing, before removing unwanted fields specific to the dataset\n\n        Returns\n        -------\n        dataset: xarray.Dataset dataset\n            The dataset prepared for parsing, after removing unwanted fields specific to the dataset\n        \"\"\"\n        dataset = super().remove_unwanted_fields(dataset)\n        for variable in dataset.variables:\n            dataset[variable].encoding[\"_FillValue\"] = self.missing_value_indicator()\n        # Remove extraneous data from the data variable's attributes\n        keys_to_remove = [\n            'Conventions', 'history', 'version', 'date_created',\n            'creator_name', 'creator_email', 'institution', 'documentation', 'reference',\n            'comments', 'acknowledgements', 'ftp_url', 'website', 'faq',\n            'zlib', 'shuffle', 'complevel', 'contiguous', 'source', 'original_shape', 'missing_value'\n            ]\n        for key in keys_to_remove:\n            dataset.attrs.pop(key, None)\n            dataset[self.data_var()].attrs.pop(key, None)\n            dataset[self.data_var()].encoding.pop(key, None)\n\n        return dataset", "\n\nclass CHIRPSFinal(CHIRPS):\n    \"\"\"\n    A class for finalized CHIRPS data\n    \"\"\"\n\n    @classmethod\n    def name(cls) -> str:\n        \"\"\"Name used to refer to the dataset where it's published\"\"\"\n        return f\"{super().name()}_final\"\n\n    def relative_path(self) -> pathlib.Path:\n        return super().relative_path() / \"final\"\n\n    @property\n    def update_cadence(self) -> str:\n        return \"monthly\"\n\n    def populate_metadata(self):\n        super().populate_metadata()\n        self.metadata[\"revision\"] = \"final\"", "\n\nclass CHIRPSFinal05(CHIRPSFinal):\n    \"\"\"\n    Finalized CHIRPS data at 0.05 resolution\n    \"\"\"\n    @classmethod\n    def name(cls) -> str:\n        \"\"\"Name used to refer to the dataset where it's published\"\"\"\n        return f\"{super().name()}_05\"\n\n    def relative_path(self) -> pathlib.Path:\n        \"\"\"Relative path used to store data under 'datasets' and 'climate' folders\"\"\"\n        return super().relative_path() / \"05\"\n\n    @property\n    def remote_path(self) -> str:\n        \"\"\"path on CHIRPS server to relevant files\"\"\"\n        return \"global_daily/netcdf/p05/\"\n\n    @property\n    def spatial_resolution(self) -> float:\n        \"\"\"Increment size along the latitude/longitude coordinate axis\"\"\"\n        return 0.05", "\n\nclass CHIRPSFinal25(CHIRPSFinal):\n    \"\"\"\n    Finalized CHIRPS data at 0.25 resolution\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Initialize a new CHIRPS object with appropriate chunking parameters.\n        \"\"\"\n        # 0.25 dataset size is time: 15000, latitude: 400, longitude: 1440\n        chunks = dict(\n            requested_dask_chunks={\"time\": 500, \"latitude\": 40, \"longitude\": -1},  # 115 MB\n            requested_zarr_chunks={\"time\": 500, \"latitude\": 40, \"longitude\": 40},  # 3.2 MB\n            requested_ipfs_chunker=\"size-6400\"\n            )\n        kwargs.update(chunks)\n        super().__init__(*args, **kwargs)\n\n    @classmethod\n    def name(cls) -> str:\n        \"\"\"Name used to refer to the dataset where it's published\"\"\"\n        return f\"{super().name()}_25\"\n\n    def relative_path(self) -> pathlib.Path:\n        \"\"\"Relative path used to store data under 'datasets' and 'climate' folders\"\"\"\n        return super().relative_path() / \"25\"\n\n    @property\n    def remote_path(self) -> str:\n        \"\"\"path on CHIRPS server to relevant files\"\"\"\n        return \"global_daily/netcdf/p25/\"\n\n    @property\n    def spatial_resolution(self) -> float:\n        \"\"\"Increment size along the latitude/longitude coordinate axis\"\"\"\n        return 0.25", "\n\nclass CHIRPSPrelim05(CHIRPS):\n    \"\"\"\n    Preliminary CHIRPS data at 0.05 resolution\n    \"\"\"\n\n    @classmethod\n    def name(cls) -> str:\n        \"\"\"Name used to refer to the dataset where it's published\"\"\"\n        return f\"{super().name()}_prelim_05\"\n\n    def relative_path(self) -> pathlib.Path:\n        \"\"\"Relative path used to store data under 'datasets' and 'climate' folders\"\"\"\n        return super().relative_path() / \"prelim\" / \"05\"\n\n    @property\n    def remote_path(self) -> str:\n        \"\"\"path on CHIRPS server to relevant files\"\"\"\n        return \"prelim/global_daily/netcdf/p05/\"\n\n    @property\n    def spatial_resolution(self) -> float:\n        \"\"\"Increment size along the latitude/longitude coordinate axis\"\"\"\n        return 0.05\n\n    @property\n    def dataset_start_date(self):\n        \"\"\"First date in dataset. Used to populate corresponding encoding and metadata.\"\"\"\n        return datetime.datetime(2019, 1, 1, 0)\n\n    @property\n    def update_cadence(self) -> str:\n        return \"weekly\"\n\n    def populate_metadata(self):\n        super().populate_metadata()\n        self.metadata[\"revision\"] = \"preliminary\"", "\n\nif __name__ == \"__main__\":\n    CHIRPS().run_etl_as_script()\n"]}
