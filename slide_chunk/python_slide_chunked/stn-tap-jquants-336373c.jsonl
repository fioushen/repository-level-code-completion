{"filename": "tap_jquants/auth.py", "chunked_list": ["\"\"\"Authentication for tap-jquants.\"\"\"\n\nfrom __future__ import annotations\n\nimport typing as t\n\nimport requests\nfrom singer_sdk.authenticators import BearerTokenAuthenticator, SingletonMeta\n\nfrom .exceptions import JQuantsError", "\nfrom .exceptions import JQuantsError\n\nif t.TYPE_CHECKING:\n    from .client import JQuantsStream\n\n\nclass JQuantsAuthenticator(BearerTokenAuthenticator, metaclass=SingletonMeta):\n    \"\"\"Authenticator class for J-Quants.\"\"\"\n\n    @classmethod\n    def _get_refresh_token(\n        cls: type[JQuantsAuthenticator],\n        stream: JQuantsStream,\n        session: requests.Session,\n    ) -> str:\n        \"\"\"Get a refresh token.\"\"\"\n        response = session.post(\n            url=f\"{stream.url_base}/token/auth_user\",\n            headers={\n                \"Content-Type\": \"application/json\",\n            },\n            json={\n                \"mailaddress\": stream.config[\"mail_address\"],\n                \"password\": stream.config[\"password\"],\n            },\n        )\n        if response.status_code != requests.codes.ok:\n            raise JQuantsError(response)\n        return response.json()[\"refreshToken\"]\n\n    @classmethod\n    def _get_id_token(\n        cls: type[JQuantsAuthenticator],\n        stream: JQuantsStream,\n        session: requests.Session,\n    ) -> str:\n        \"\"\"Get an id token.\"\"\"\n        refresh_token = cls._get_refresh_token(stream, session)\n        response = session.post(\n            url=f\"{stream.url_base}/token/auth_refresh?refreshtoken={refresh_token}\",\n            headers={\n                \"Content-Type\": \"application/json\",\n            },\n        )\n        if response.status_code != requests.codes.ok:\n            raise JQuantsError(response)\n        return response.json()[\"idToken\"]\n\n    @classmethod\n    def create_for_stream(\n        cls: type[JQuantsAuthenticator],\n        stream: JQuantsStream,\n    ) -> JQuantsAuthenticator:\n        \"\"\"Instantiate an authenticator for a specific Singer stream.\n\n        Args:\n            stream: The Singer stream instance.\n\n        Returns:\n            A new authenticator.\n        \"\"\"\n        with requests.Session() as session:\n            id_token = cls._get_id_token(stream, session)\n        return cls(\n            stream=stream,\n            token=id_token,\n        )", ""]}
{"filename": "tap_jquants/tap.py", "chunked_list": ["\"\"\"JQuants tap class.\"\"\"\n\nfrom __future__ import annotations\n\nimport typing as t\n\nfrom singer_sdk import Tap\nfrom singer_sdk import typing as th  # JSON schema typing helpers\n\nfrom . import streams", "\nfrom . import streams\n\nif t.TYPE_CHECKING:\n    from .client import JQuantsStream\n\n\nclass TapJQuants(Tap):\n    \"\"\"JQuants tap class.\"\"\"\n\n    name = \"tap-jquants\"\n\n    config_jsonschema = th.PropertiesList(\n        th.Property(\n            \"mail_address\",\n            th.StringType,\n            required=True,\n            description=\"The mail address to authenticate against J-Quants API\",\n        ),\n        th.Property(\n            \"password\",\n            th.StringType,\n            required=True,\n            secret=True,\n            description=\"The password to authenticate against J-Quants API\",\n        ),\n        th.Property(\n            \"start_date\",\n            th.DateTimeType,\n            description=\"The earliest record date to sync\",\n        ),\n    ).to_dict()\n\n    def discover_streams(self) -> list[JQuantsStream]:\n        \"\"\"Return a list of discovered streams.\n\n        Returns:\n            A list of discovered streams.\n        \"\"\"\n        return [\n            streams.AnnouncementStream(self),\n            streams.BreakdownStream(self),\n            streams.DailyQuotesStream(self),\n            streams.DividendStream(self),\n            streams.IndexOptionStream(self),\n            streams.TopixStream(self),\n            streams.ListedInfoStream(self),\n            streams.PricesAmStream(self),\n            streams.ShortSellingStream(self),\n            streams.StatementsStream(self),\n            streams.TradesSpecStream(self),\n            streams.TradingCalendarStream(self),\n            streams.WeeklyMarginInterestStream(self),\n        ]", "\n\nif __name__ == \"__main__\":\n    TapJQuants.cli()\n"]}
{"filename": "tap_jquants/pagination.py", "chunked_list": ["\"\"\"Generic paginator classes.\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport typing as t\n\nfrom singer_sdk.helpers.jsonpath import extract_jsonpath\nfrom singer_sdk.pagination import BaseAPIPaginator\n\nif t.TYPE_CHECKING:\n    from requests import Response", "from singer_sdk.pagination import BaseAPIPaginator\n\nif t.TYPE_CHECKING:\n    from requests import Response\n\nfrom .helpers import get_next_date\n\nT = t.TypeVar(\"T\")\nTPageToken = t.TypeVar(\"TPageToken\")\n", "TPageToken = t.TypeVar(\"TPageToken\")\n\nPAGINATOR_JSONPATH = \"$.pagination_key[*]\"\nDATE_PAT = re.compile(r\"date=(\\d{4}-\\d{2}-\\d{2})\")\n\n\nclass JQuantsDatePaginator(BaseAPIPaginator[t.Optional[t.Tuple[str, str]]]):\n    \"\"\"Paginator class for APIs returning a pagination token in the response body.\"\"\"\n\n    def __init__(\n        self,\n        *args: t.Any,\n        **kwargs: t.Any,\n    ) -> None:\n        \"\"\"Create a new paginator.\n\n        Args:\n            args: Paginator positional arguments for base class.\n            kwargs: Paginator keyword arguments for base class.\n        \"\"\"\n        super().__init__(None, *args, **kwargs)\n\n    def get_next(self, response: Response) -> tuple[str, str | None] | None:\n        \"\"\"Get the next page token.\n\n        Args:\n            response: API response object.\n\n        Returns:\n            The next page token.\n        \"\"\"\n        date_key = re.search(  # type: ignore[union-attr]\n            DATE_PAT,\n            response.request.url,  # type: ignore[arg-type]\n        ).group(\n            1,\n        )\n        pagination_key = next(\n            extract_jsonpath(PAGINATOR_JSONPATH, response.json()),\n            None,\n        )\n        if pagination_key is not None:\n            return date_key, pagination_key\n        date_key = get_next_date(date_key)\n        if date_key is None:\n            return None\n        return date_key, None", ""]}
{"filename": "tap_jquants/client.py", "chunked_list": ["\"\"\"REST client handling, including JQuantsStream base class.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nimport typing as t\nfrom pathlib import Path\nfrom typing import Any, Callable, Iterable\n\nimport requests", "\nimport requests\nfrom singer_sdk.helpers.jsonpath import extract_jsonpath\nfrom singer_sdk.streams import RESTStream\n\nfrom tap_jquants.auth import JQuantsAuthenticator\nfrom tap_jquants.pagination import JQuantsDatePaginator\n\nif sys.version_info >= (3, 8):\n    from functools import cached_property\nelse:\n    from cached_property import cached_property", "if sys.version_info >= (3, 8):\n    from functools import cached_property\nelse:\n    from cached_property import cached_property\n\nfrom .helpers import convert_json\n\nif t.TYPE_CHECKING:\n    from singer_sdk.pagination import BaseAPIPaginator\n", "\n\n_Auth = Callable[[requests.PreparedRequest], requests.PreparedRequest]\nSCHEMAS_DIR = Path(__file__).parent / Path(\"./schemas\")\n\n\nclass JQuantsStream(RESTStream):\n    \"\"\"JQuants stream class.\"\"\"\n\n    @property\n    def url_base(self) -> str:\n        \"\"\"Return the API URL root, configurable via tap settings.\"\"\"\n        return \"https://api.jquants.com/v1\"\n\n    next_page_token_jsonpath = \"$.pagination_key\"  # noqa: S105\n\n    @cached_property\n    def authenticator(self) -> _Auth:\n        \"\"\"Return a new authenticator object.\n\n        Returns:\n            An authenticator instance.\n        \"\"\"\n        return JQuantsAuthenticator.create_for_stream(self)\n\n    @property\n    def http_headers(self) -> dict:\n        \"\"\"Return the http headers needed.\n\n        Returns:\n            A dictionary of HTTP headers.\n        \"\"\"\n        headers = {}\n        if \"user_agent\" in self.config:\n            headers[\"User-Agent\"] = self.config.get(\"user_agent\")\n        return headers\n\n    def get_url_params(\n        self,\n        _context: dict | None,\n        next_page_token: Any | None,\n    ) -> dict[str, Any]:\n        \"\"\"Return a dictionary of values to be used in URL parameterization.\n\n        Args:\n            context: The stream context.\n            next_page_token: The next page index or value.\n\n        Returns:\n            A dictionary of URL query parameters.\n        \"\"\"\n        params: dict = {}\n        if next_page_token:\n            params[\"pagination_key\"] = next_page_token\n        return params\n\n    def parse_response(self, response: requests.Response) -> Iterable[dict]:\n        \"\"\"Parse the response and return an iterator of result records.\n\n        Args:\n            response: The HTTP ``requests.Response`` object.\n\n        Yields:\n            Each record from the source.\n        \"\"\"\n        yield from extract_jsonpath(\n            self.records_jsonpath,\n            input=convert_json(response.json()),\n        )", "\n\nclass JQuantsDateStream(JQuantsStream):\n    \"\"\"JQuants incremental stream class based on date.\"\"\"\n\n    def get_new_paginator(self) -> BaseAPIPaginator:\n        \"\"\"Return a new paginator object.\"\"\"\n        return JQuantsDatePaginator()\n\n    def get_url_params(\n        self,\n        context: dict | None,\n        next_page_token: Any | None,\n    ) -> dict[str, Any]:\n        \"\"\"Return a dictionary of parameters to use in the URL.\"\"\"\n        params: dict = {}\n        if next_page_token is not None:\n            date_key, pagination_key = next_page_token\n            if pagination_key:\n                params[\"pagination_key\"] = next_page_token\n            params[\"date\"] = date_key\n        else:\n            starting_date = self.get_starting_timestamp(context)\n            if starting_date:\n                params[\"date\"] = starting_date.strftime(\"%Y-%m-%d\")\n        self.logger.info(\"URL params: %s\", params)\n        return params", "\n\nclass JQuantsFromStream(JQuantsStream):\n    \"\"\"JQuants incremental stream class based on from.\"\"\"\n\n    def get_url_params(\n        self,\n        context: dict | None,\n        next_page_token: Any | None,\n    ) -> dict[str, Any]:\n        \"\"\"Return a dictionary of parameters to use in the URL.\"\"\"\n        params: dict = {}\n        if next_page_token is not None:\n            pagination_key = next_page_token\n            if pagination_key:\n                params[\"pagination_key\"] = next_page_token\n        starting_date = self.get_starting_timestamp(context)\n        if starting_date:\n            params[\"from\"] = starting_date.strftime(\"%Y-%m-%d\")\n        self.logger.info(\"URL params: %s\", params)\n        return params", ""]}
{"filename": "tap_jquants/__init__.py", "chunked_list": ["\"\"\"Tap for JQuants.\"\"\"\n"]}
{"filename": "tap_jquants/exceptions.py", "chunked_list": ["\"\"\"Exceptions for tap-jquants.\"\"\"\n\n\nclass JQuantsError(Exception):\n    \"\"\"JQuants error.\"\"\"\n"]}
{"filename": "tap_jquants/helpers.py", "chunked_list": ["\"\"\"Helper functions for tap-jquants.\"\"\"\n\nimport re\nimport typing as t\nfrom datetime import datetime, timedelta, timezone\n\n\ndef convert_key(name: str) -> str:\n    \"\"\"Converts a CamelCased word to snake case.\"\"\"\n    name = re.sub(r\"\\(\", \"_\", name)\n    name = re.sub(r\"\\)\", \"\", name)\n    return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", name).lower()", "\n\ndef convert_obj(obj: object) -> object:\n    \"\"\"Convert keys in the given object from camel case to snake case.\"\"\"\n    if isinstance(obj, dict):\n        return convert_json(obj)\n    if isinstance(obj, list):\n        return convert_array(obj)\n    return obj\n", "\n\ndef convert_array(arr: t.List) -> t.List:\n    \"\"\"Convert keys in json array from camel case to snake case.\"\"\"\n    return [convert_obj(elem) for elem in arr]\n\n\ndef convert_json(data: t.Dict) -> t.Dict:\n    \"\"\"Convert keys in the given object from camel case to snake case.\"\"\"\n    return {convert_key(key): convert_obj(value) for key, value in data.items()}", "\n\ndef get_next_date(date: str) -> t.Optional[str]:\n    \"\"\"Returns the next date.\"\"\"\n    jst = timezone(timedelta(hours=9))\n    dt = datetime.strptime(date, \"%Y-%m-%d\").astimezone(tz=jst)\n    new_dt = dt + timedelta(days=1)\n    if new_dt > datetime.now(tz=jst):\n        return None\n    return new_dt.strftime(\"%Y-%m-%d\")", ""]}
{"filename": "tap_jquants/streams/weekly_margin_interest.py", "chunked_list": ["\"\"\"\u4fe1\u7528\u53d6\u5f15\u9031\u672b\u6b8b\u9ad8 (/markets/weekly_margin_interest).\n\nhttps://jpx.gitbook.io/j-quants-ja/api-reference/weekly_margin_interest\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\n\nclass WeeklyMarginInterestStream(JQuantsDateStream):\n    \"\"\"the weekly_margin_interest stream.\"\"\"\n\n    name = \"weekly_margin_interest\"\n    path = \"/markets/weekly_margin_interest\"\n    primary_keys = [\"date\", \"code\"]\n    replication_key = \"date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"weekly_margin_interest.json\"\n    records_jsonpath = \"$.weekly_margin_interest[*]\"", "\n\nclass WeeklyMarginInterestStream(JQuantsDateStream):\n    \"\"\"the weekly_margin_interest stream.\"\"\"\n\n    name = \"weekly_margin_interest\"\n    path = \"/markets/weekly_margin_interest\"\n    primary_keys = [\"date\", \"code\"]\n    replication_key = \"date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"weekly_margin_interest.json\"\n    records_jsonpath = \"$.weekly_margin_interest[*]\"", ""]}
{"filename": "tap_jquants/streams/breakdown.py", "chunked_list": ["\"\"\"\u58f2\u8cb7\u5185\u8a33\u30c7\u30fc\u30bf (/markets/breakdown).\n\nhttps://jpx.gitbook.io/j-quants-ja/api-reference/breakdown\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\n\nclass BreakdownStream(JQuantsDateStream):\n    \"\"\"the breakdown stream.\"\"\"\n\n    name = \"breakdown\"\n    path = \"/markets/breakdown\"\n    primary_keys = [\"date\", \"code\"]\n    replication_key = \"date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"breakdown.json\"\n    records_jsonpath = \"$.breakdown[*]\"", "\n\nclass BreakdownStream(JQuantsDateStream):\n    \"\"\"the breakdown stream.\"\"\"\n\n    name = \"breakdown\"\n    path = \"/markets/breakdown\"\n    primary_keys = [\"date\", \"code\"]\n    replication_key = \"date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"breakdown.json\"\n    records_jsonpath = \"$.breakdown[*]\"", ""]}
{"filename": "tap_jquants/streams/trading_calendar.py", "chunked_list": ["\"\"\"\u53d6\u5f15\u30ab\u30ec\u30f3\u30c0\u30fc (/markets/trading_calendar).\n\nhttps://jpx.gitbook.io/j-quants-ja/api-reference/trading_calendar\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\nfrom tap_jquants.client import SCHEMAS_DIR, JQuantsStream", "\nfrom tap_jquants.client import SCHEMAS_DIR, JQuantsStream\n\n\nclass TradingCalendarStream(JQuantsStream):\n    \"\"\"the trading_calendar stream.\"\"\"\n\n    name = \"trading_calendar\"\n    path = \"/markets/trading_calendar\"\n    primary_keys = [\"date\"]\n    replication_key = None\n    schema_filepath = SCHEMAS_DIR / \"trading_calendar.json\"\n    records_jsonpath = \"$.trading_calendar[*]\"\n\n    def get_url_params(\n        self,\n        context: dict | None,\n        _next_page_token: Any | None,\n    ) -> dict[str, Any]:\n        \"\"\"Return a dictionary of parameters to use in the URL.\"\"\"\n        params: dict = {}\n        starting_date = self.get_starting_timestamp(context)\n        if starting_date:\n            params[\"from\"] = starting_date.strftime(\"%Y-%m-%d\")\n        return params", ""]}
{"filename": "tap_jquants/streams/topix.py", "chunked_list": ["\"\"\"TOPIX\u6307\u6570\u56db\u672c\u5024 (/indices/topix).\n\nhttps://jpx.gitbook.io/j-quants-ja/api-reference/topix\n\"\"\"\n\nfrom tap_jquants.client import SCHEMAS_DIR, JQuantsStream\n\n\nclass TopixStream(JQuantsStream):\n    \"\"\"the topix stream.\"\"\"\n\n    name = \"topix\"\n    path = \"/indices/topix\"\n    primary_keys = [\"date\"]\n    replication_key = None\n    schema_filepath = SCHEMAS_DIR / \"topix.json\"\n    records_jsonpath = \"$.topix[*]\"", "class TopixStream(JQuantsStream):\n    \"\"\"the topix stream.\"\"\"\n\n    name = \"topix\"\n    path = \"/indices/topix\"\n    primary_keys = [\"date\"]\n    replication_key = None\n    schema_filepath = SCHEMAS_DIR / \"topix.json\"\n    records_jsonpath = \"$.topix[*]\"\n", ""]}
{"filename": "tap_jquants/streams/daily_quotes.py", "chunked_list": ["\"\"\"\u682a\u4fa1\u56db\u672c\u5024 (/prices/daily_quotes).\n\nhttps://jpx.gitbook.io/j-quants-ja/api-reference/daily_quotes\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\n\nclass DailyQuotesStream(JQuantsDateStream):\n    \"\"\"the daily_quotes stream.\"\"\"\n\n    name = \"daily_quotes\"\n    path = \"/prices/daily_quotes\"\n    primary_keys = [\"date\", \"code\"]\n    replication_key = \"date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"daily_quotes.json\"\n    records_jsonpath = \"$.daily_quotes[*]\"", "\n\nclass DailyQuotesStream(JQuantsDateStream):\n    \"\"\"the daily_quotes stream.\"\"\"\n\n    name = \"daily_quotes\"\n    path = \"/prices/daily_quotes\"\n    primary_keys = [\"date\", \"code\"]\n    replication_key = \"date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"daily_quotes.json\"\n    records_jsonpath = \"$.daily_quotes[*]\"", ""]}
{"filename": "tap_jquants/streams/__init__.py", "chunked_list": ["\"\"\"Stream classes for tap-jquants.\"\"\"\n\nfrom tap_jquants.streams.announcement import AnnouncementStream\nfrom tap_jquants.streams.breakdown import BreakdownStream\nfrom tap_jquants.streams.daily_quotes import DailyQuotesStream\nfrom tap_jquants.streams.dividend import DividendStream\nfrom tap_jquants.streams.index_option import IndexOptionStream\nfrom tap_jquants.streams.listed_info import ListedInfoStream\nfrom tap_jquants.streams.prices_am import PricesAmStream\nfrom tap_jquants.streams.short_selling import ShortSellingStream", "from tap_jquants.streams.prices_am import PricesAmStream\nfrom tap_jquants.streams.short_selling import ShortSellingStream\nfrom tap_jquants.streams.statements import StatementsStream\nfrom tap_jquants.streams.topix import TopixStream\nfrom tap_jquants.streams.trades_spec import TradesSpecStream\nfrom tap_jquants.streams.trading_calendar import TradingCalendarStream\nfrom tap_jquants.streams.weekly_margin_interest import WeeklyMarginInterestStream\n\n__all__ = [\n    \"AnnouncementStream\",", "__all__ = [\n    \"AnnouncementStream\",\n    \"BreakdownStream\",\n    \"DailyQuotesStream\",\n    \"DividendStream\",\n    \"IndexOptionStream\",\n    \"TopixStream\",\n    \"ListedInfoStream\",\n    \"PricesAmStream\",\n    \"ShortSellingStream\",", "    \"PricesAmStream\",\n    \"ShortSellingStream\",\n    \"StatementsStream\",\n    \"TradesSpecStream\",\n    \"TradingCalendarStream\",\n    \"WeeklyMarginInterestStream\",\n]\n"]}
{"filename": "tap_jquants/streams/listed_info.py", "chunked_list": ["\"\"\"\u4e0a\u5834\u9298\u67c4\u4e00\u89a7 (/listed/info).\n\nhttps://jpx.gitbook.io/j-quants-ja/api-reference/listed_info\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\n\nclass ListedInfoStream(JQuantsDateStream):\n    \"\"\"the listed_info stream.\"\"\"\n\n    name = \"listed_info\"\n    path = \"/listed/info\"\n    primary_keys = [\"date\", \"code\"]\n    replication_key = \"date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"listed_info.json\"\n    records_jsonpath = \"$.info[*]\"", "\n\nclass ListedInfoStream(JQuantsDateStream):\n    \"\"\"the listed_info stream.\"\"\"\n\n    name = \"listed_info\"\n    path = \"/listed/info\"\n    primary_keys = [\"date\", \"code\"]\n    replication_key = \"date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"listed_info.json\"\n    records_jsonpath = \"$.info[*]\"", ""]}
{"filename": "tap_jquants/streams/index_option.py", "chunked_list": ["\"\"\"\u30aa\u30d7\u30b7\u30e7\u30f3\u56db\u672c\u5024 (/option/index_option).\n\nhttps://jpx.gitbook.io/j-quants-ja/api-reference/index_option\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\n\nclass IndexOptionStream(JQuantsDateStream):\n    \"\"\"the index_option stream.\"\"\"\n\n    name = \"index_option\"\n    path = \"/option/index_option\"\n    primary_keys = [\"date\", \"code\"]\n    replication_key = \"date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"index_option.json\"\n    records_jsonpath = \"$.index_option[*]\"\n\n    def post_process(\n        self,\n        row: dict,\n        _context: dict | None = None,\n    ) -> dict | None:\n        \"\"\"Fix empty string in some night session data to None.\"\"\"\n        if not row[\"night_session_open\"]:\n            row[\"night_session_open\"] = None\n            row[\"night_session_high\"] = None\n            row[\"night_session_low\"] = None\n            row[\"night_session_close\"] = None\n        return row", "\n\nclass IndexOptionStream(JQuantsDateStream):\n    \"\"\"the index_option stream.\"\"\"\n\n    name = \"index_option\"\n    path = \"/option/index_option\"\n    primary_keys = [\"date\", \"code\"]\n    replication_key = \"date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"index_option.json\"\n    records_jsonpath = \"$.index_option[*]\"\n\n    def post_process(\n        self,\n        row: dict,\n        _context: dict | None = None,\n    ) -> dict | None:\n        \"\"\"Fix empty string in some night session data to None.\"\"\"\n        if not row[\"night_session_open\"]:\n            row[\"night_session_open\"] = None\n            row[\"night_session_high\"] = None\n            row[\"night_session_low\"] = None\n            row[\"night_session_close\"] = None\n        return row", ""]}
{"filename": "tap_jquants/streams/trades_spec.py", "chunked_list": ["\"\"\"\u6295\u8cc7\u90e8\u9580\u5225\u60c5\u5831 (/markets/trades_spec).\n\nhttps://jpx.gitbook.io/j-quants-ja/api-reference/trades_spec\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom tap_jquants.client import SCHEMAS_DIR, JQuantsFromStream\n\n\nclass TradesSpecStream(JQuantsFromStream):\n    \"\"\"the trades_spec stream.\"\"\"\n\n    name = \"trades_spec\"\n    path = \"/markets/trades_spec\"\n    primary_keys = [\"published_date\", \"section\"]\n    replication_key = \"published_date\"\n    schema_filepath = SCHEMAS_DIR / \"trades_spec.json\"\n    records_jsonpath = \"$.trades_spec[*]\"", "\n\nclass TradesSpecStream(JQuantsFromStream):\n    \"\"\"the trades_spec stream.\"\"\"\n\n    name = \"trades_spec\"\n    path = \"/markets/trades_spec\"\n    primary_keys = [\"published_date\", \"section\"]\n    replication_key = \"published_date\"\n    schema_filepath = SCHEMAS_DIR / \"trades_spec.json\"\n    records_jsonpath = \"$.trades_spec[*]\"", ""]}
{"filename": "tap_jquants/streams/short_selling.py", "chunked_list": ["\"\"\"\u696d\u7a2e\u5225\u7a7a\u58f2\u308a\u6bd4\u7387 (/markets/short_selling).\n\nhttps://jpx.gitbook.io/j-quants-ja/api-reference/short_selling\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\n\nclass ShortSellingStream(JQuantsDateStream):\n    \"\"\"the short_selling stream.\"\"\"\n\n    name = \"short_selling\"\n    path = \"/markets/short_selling\"\n    primary_keys = [\"date\", \"sector33_code\"]\n    replication_key = \"date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"short_selling.json\"\n    records_jsonpath = \"$.short_selling[*]\"", "\n\nclass ShortSellingStream(JQuantsDateStream):\n    \"\"\"the short_selling stream.\"\"\"\n\n    name = \"short_selling\"\n    path = \"/markets/short_selling\"\n    primary_keys = [\"date\", \"sector33_code\"]\n    replication_key = \"date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"short_selling.json\"\n    records_jsonpath = \"$.short_selling[*]\"", ""]}
{"filename": "tap_jquants/streams/dividend.py", "chunked_list": ["\"\"\"\u914d\u5f53\u91d1\u60c5\u5831 (/fins/dividend).\n\nhttps://jpx.gitbook.io/j-quants-ja/api-reference/dividend\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\n\nclass DividendStream(JQuantsDateStream):\n    \"\"\"the dividend stream.\"\"\"\n\n    name = \"dividend\"\n    path = \"/fins/dividend\"\n    primary_keys = [\"announcement_date\", \"announcement_time\", \"code\"]\n    replication_key = \"announcement_date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"dividend.json\"\n    records_jsonpath = \"$.dividend[*]\"\n\n    def post_process(\n        self,\n        row: dict,\n        _context: dict | None = None,\n    ) -> dict | None:\n        \"\"\"Converts number or string properties.\"\"\"\n        for key in [\n            \"gross_dividend_rate\",\n            \"distribution_amount\",\n            \"retained_earnings\",\n            \"deemed_dividend\",\n            \"deemed_capital_gains\",\n            \"net_asset_decrease_ratio\",\n            \"commemorative_dividend_rate\",\n            \"special_dividend_rate\",\n        ]:\n            num_key = f\"{key}_num\"\n            if key not in row:\n                continue\n            value = row[key]\n            if isinstance(value, str):\n                if value and value != \"-\":\n                    row[num_key] = float(value)\n            else:\n                row[key] = str(value)\n                row[num_key] = value\n        return row", "\n\nclass DividendStream(JQuantsDateStream):\n    \"\"\"the dividend stream.\"\"\"\n\n    name = \"dividend\"\n    path = \"/fins/dividend\"\n    primary_keys = [\"announcement_date\", \"announcement_time\", \"code\"]\n    replication_key = \"announcement_date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"dividend.json\"\n    records_jsonpath = \"$.dividend[*]\"\n\n    def post_process(\n        self,\n        row: dict,\n        _context: dict | None = None,\n    ) -> dict | None:\n        \"\"\"Converts number or string properties.\"\"\"\n        for key in [\n            \"gross_dividend_rate\",\n            \"distribution_amount\",\n            \"retained_earnings\",\n            \"deemed_dividend\",\n            \"deemed_capital_gains\",\n            \"net_asset_decrease_ratio\",\n            \"commemorative_dividend_rate\",\n            \"special_dividend_rate\",\n        ]:\n            num_key = f\"{key}_num\"\n            if key not in row:\n                continue\n            value = row[key]\n            if isinstance(value, str):\n                if value and value != \"-\":\n                    row[num_key] = float(value)\n            else:\n                row[key] = str(value)\n                row[num_key] = value\n        return row", ""]}
{"filename": "tap_jquants/streams/prices_am.py", "chunked_list": ["\"\"\"\u524d\u5834\u56db\u672c\u5024 (/prices/prices_am).\n\nhttps://jpx.gitbook.io/j-quants-ja/api-reference/prices_am\n\"\"\"\n\nfrom tap_jquants.client import SCHEMAS_DIR, JQuantsStream\n\n\nclass PricesAmStream(JQuantsStream):\n    \"\"\"the prices_am stream.\"\"\"\n\n    name = \"prices_am\"\n    path = \"/prices/prices_am\"\n    primary_keys = [\"date\", \"code\"]\n    replication_key = None\n    schema_filepath = SCHEMAS_DIR / \"prices_am.json\"\n    records_jsonpath = \"$.prices_am[*]\"", "class PricesAmStream(JQuantsStream):\n    \"\"\"the prices_am stream.\"\"\"\n\n    name = \"prices_am\"\n    path = \"/prices/prices_am\"\n    primary_keys = [\"date\", \"code\"]\n    replication_key = None\n    schema_filepath = SCHEMAS_DIR / \"prices_am.json\"\n    records_jsonpath = \"$.prices_am[*]\"\n", ""]}
{"filename": "tap_jquants/streams/announcement.py", "chunked_list": ["\"\"\"\u6c7a\u7b97\u767a\u8868\u4e88\u5b9a\u65e5 (/fins/announcement).\n\nhttps://jpx.gitbook.io/j-quants-ja/api-reference/announcement\n\"\"\"\n\nfrom tap_jquants.client import SCHEMAS_DIR, JQuantsStream\n\n\nclass AnnouncementStream(JQuantsStream):\n    \"\"\"the announcement stream.\"\"\"\n\n    name = \"announcement\"\n    path = \"/fins/announcement\"\n    primary_keys = [\"date\", \"code\"]\n    replication_key = None\n    schema_filepath = SCHEMAS_DIR / \"announcement.json\"\n    records_jsonpath = \"$.announcement[*]\"", "class AnnouncementStream(JQuantsStream):\n    \"\"\"the announcement stream.\"\"\"\n\n    name = \"announcement\"\n    path = \"/fins/announcement\"\n    primary_keys = [\"date\", \"code\"]\n    replication_key = None\n    schema_filepath = SCHEMAS_DIR / \"announcement.json\"\n    records_jsonpath = \"$.announcement[*]\"\n", ""]}
{"filename": "tap_jquants/streams/statements.py", "chunked_list": ["\"\"\"\u8ca1\u52d9\u60c5\u5831 (/fins/statements).\n\nhttps://jpx.gitbook.io/j-quants-ja/api-reference/statements\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom tap_jquants.client import SCHEMAS_DIR, JQuantsDateStream\n\n\nclass StatementsStream(JQuantsDateStream):\n    \"\"\"the statements stream.\"\"\"\n\n    name = \"statements\"\n    path = \"/fins/statements\"\n    primary_keys = [\"disclosed_date\", \"local_code\"]\n    replication_key = \"disclosed_date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"statements.json\"\n    records_jsonpath = \"$.statements[*]\"", "\n\nclass StatementsStream(JQuantsDateStream):\n    \"\"\"the statements stream.\"\"\"\n\n    name = \"statements\"\n    path = \"/fins/statements\"\n    primary_keys = [\"disclosed_date\", \"local_code\"]\n    replication_key = \"disclosed_date\"\n    is_sorted = True\n    schema_filepath = SCHEMAS_DIR / \"statements.json\"\n    records_jsonpath = \"$.statements[*]\"", ""]}
{"filename": "tests/__init__.py", "chunked_list": ["\"\"\"Test suite for tap-jquants.\"\"\"\n"]}
{"filename": "tests/test_core.py", "chunked_list": ["\"\"\"Tests standard tap features using the built-in SDK tests library.\"\"\"\n\n# We cannot test the tap without valid accounts, so we skip the tests by default.\n"]}
{"filename": "tests/test_helpers.py", "chunked_list": ["from datetime import datetime, timedelta, timezone\n\nfrom tap_jquants.helpers import convert_json, convert_key, get_next_date\n\n\ndef test_convert_key():\n    assert convert_key(\"CamelCase\") == \"camel_case\"\n    assert convert_key(\"MoreCamelCases\") == \"more_camel_cases\"\n    assert convert_key(\"Sector17CodeName\") == \"sector17_code_name\"\n    assert (\n        convert_key(\"CityBKsRegionalBKsEtcSales\") == \"city_bks_regional_bks_etc_sales\"\n    )\n    # 'Share2nd' is not converted to 'share_2nd'.\n    # The only way to do that is to use a dictionary.\n    assert (\n        convert_key(\"ResultDividendPerShare2ndQuarter\")\n        == \"result_dividend_per_share2nd_quarter\"\n    )\n    assert convert_key(\"DistributionsPerUnit(REIT)\") == \"distributions_per_unit_reit\"\n    assert convert_key(\n        \"NumberOfIssuedAndOutstandingSharesAtTheEndOfFiscalYearIncludingTreasuryStock\",\n    ) == (\n        \"number_of_issued_and_outstanding_shares_at_the_end_of_fiscal_year\"\n        \"_including_treasury_stock\"\n    )\n    assert convert_key(\"Volume(OnlyAuction)\") == \"volume_only_auction\"", "\n\ndef test_convert_json():\n    assert convert_json(\n        {\n            \"info\": [\n                {\n                    \"Date\": \"2022-11-11\",\n                    \"Code\": \"86970\",\n                    \"CompanyName\": \"\u65e5\u672c\u53d6\u5f15\u6240\u30b0\u30eb\u30fc\u30d7\",\n                    \"CompanyNameEnglish\": \"Japan Exchange Group,Inc.\",\n                },\n            ],\n        },\n    ) == {\n        \"info\": [\n            {\n                \"date\": \"2022-11-11\",\n                \"code\": \"86970\",\n                \"company_name\": \"\u65e5\u672c\u53d6\u5f15\u6240\u30b0\u30eb\u30fc\u30d7\",\n                \"company_name_english\": \"Japan Exchange Group,Inc.\",\n            },\n        ],\n    }", "\n\ndef test_gen_next_date():\n    assert get_next_date(\"2021-01-01\") == \"2021-01-02\"\n    assert get_next_date(\"2021-01-31\") == \"2021-02-01\"\n    assert get_next_date(\"2021-02-28\") == \"2021-03-01\"\n    assert get_next_date(\"2021-12-31\") == \"2022-01-01\"\n    assert (\n        get_next_date(\n            datetime.now(tz=timezone(timedelta(hours=9))).strftime(\"%Y-%m-%d\"),\n        )\n        is None\n    )", ""]}
{"filename": "tests/conftest.py", "chunked_list": ["\"\"\"Test Configuration.\"\"\"\n\npytest_plugins = (\"singer_sdk.testing.pytest_plugin\",)\n"]}
