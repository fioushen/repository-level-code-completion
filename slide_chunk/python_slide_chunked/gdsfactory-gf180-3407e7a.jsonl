{"filename": "install_tech.py", "chunked_list": ["\"\"\"Symlink tech to klayout.\"\"\"\nimport os\nimport pathlib\nimport shutil\nimport sys\n\n\ndef remove_path_or_dir(dest: pathlib.Path):\n    if dest.is_dir():\n        os.unlink(dest)\n    else:\n        os.remove(dest)", "\n\ndef make_link(src, dest, overwrite: bool = True) -> None:\n    dest = pathlib.Path(dest)\n    if dest.exists() and not overwrite:\n        print(f\"{dest} already exists\")\n        return\n    if dest.exists() or dest.is_symlink():\n        print(f\"removing {dest} already installed\")\n        remove_path_or_dir(dest)\n    try:\n        os.symlink(src, dest, target_is_directory=True)\n    except OSError:\n        shutil.copy(src, dest)\n    print(\"link made:\")\n    print(f\"From: {src}\")\n    print(f\"To:   {dest}\")", "\n\nif __name__ == \"__main__\":\n    klayout_folder = \"KLayout\" if sys.platform == \"win32\" else \".klayout\"\n    cwd = pathlib.Path(__file__).resolve().parent\n    home = pathlib.Path.home()\n    src = cwd / \"gf180\" / \"klayout\"\n    dest_folder = home / klayout_folder / \"tech\"\n    dest_folder.mkdir(exist_ok=True, parents=True)\n    dest = dest_folder / \"gf180\"\n    make_link(src=src, dest=dest)", ""]}
{"filename": "tests/test_components.py", "chunked_list": ["import pathlib\n\nimport pytest\nfrom gdsfactory.component import Component\nfrom gdsfactory.difftest import difftest\nfrom pytest_regressions.data_regression import DataRegressionFixture\n\nfrom gf180 import cells\n\nskip_test = {\"res_dev\"}", "\nskip_test = {\"res_dev\"}\ncell_names = set(cells.keys()) - set(skip_test)\ndirpath = pathlib.Path(__file__).absolute().parent / \"gds_ref\"\n\n\n@pytest.fixture(params=cell_names, scope=\"function\")\ndef component(request) -> Component:\n    return cells[request.param]()\n", "\n\ndef test_pdk_gds(component: Component) -> None:\n    \"\"\"Avoid regressions in GDS geometry shapes and layers.\"\"\"\n    difftest(component, dirpath=dirpath)\n\n\ndef test_pdk_settings(\n    component: Component, data_regression: DataRegressionFixture\n) -> None:\n    \"\"\"Avoid regressions when exporting settings.\"\"\"\n    data_regression.check(component.to_dict())", "\n\ndef test_assert_ports_on_grid(component: Component):\n    component.assert_ports_on_grid()\n"]}
{"filename": "docs/write_cells.py", "chunked_list": ["import inspect\nimport pathlib\n\nfrom gf180 import cells\n\nfilepath = pathlib.Path(__file__).parent.absolute() / \"cells.rst\"\n\nskip = {\n    \"LIBRARY\",\n    \"circuit_names\",", "    \"LIBRARY\",\n    \"circuit_names\",\n    \"component_factory\",\n    \"component_names\",\n    \"container_names\",\n    \"component_names_test_ports\",\n    \"component_names_skip_test\",\n    \"component_names_skip_test_ports\",\n    \"dataclasses\",\n    \"library\",", "    \"dataclasses\",\n    \"library\",\n    \"waveguide_template\",\n}\n\nskip_plot: tuple[str, ...] = (\"add_fiber_array_siepic\",)\nskip_settings: tuple[str, ...] = (\"flatten\", \"safe_cell_names\")\n\n\nwith open(filepath, \"w+\") as f:\n    f.write(\n        \"\"\"\n\nHere are the parametric cells available in the PDK\n\n\nCells\n=============================\n\"\"\"\n    )\n\n    for name in sorted(cells.keys()):\n        if name in skip or name.startswith(\"_\"):\n            continue\n        print(name)\n        sig = inspect.signature(cells[name])\n        kwargs = \", \".join(\n            [\n                f\"{p}={repr(sig.parameters[p].default)}\"\n                for p in sig.parameters\n                if isinstance(sig.parameters[p].default, (int, float, str, tuple))\n                and p not in skip_settings\n            ]\n        )\n        if name in skip_plot:\n            f.write(\n                f\"\"\"\n\n{name}\n----------------------------------------------------\n\n.. autofunction:: gf180.{name}\n\n\"\"\"\n            )\n        else:\n            f.write(\n                f\"\"\"\n\n{name}\n----------------------------------------------------\n\n.. autofunction:: gf180.{name}\n\n.. plot::\n  :include-source:\n\n  import gf180\n\n  c = gf180.{name}({kwargs})\n  c.plot()\n\n\"\"\"\n            )", "\nwith open(filepath, \"w+\") as f:\n    f.write(\n        \"\"\"\n\nHere are the parametric cells available in the PDK\n\n\nCells\n=============================\n\"\"\"\n    )\n\n    for name in sorted(cells.keys()):\n        if name in skip or name.startswith(\"_\"):\n            continue\n        print(name)\n        sig = inspect.signature(cells[name])\n        kwargs = \", \".join(\n            [\n                f\"{p}={repr(sig.parameters[p].default)}\"\n                for p in sig.parameters\n                if isinstance(sig.parameters[p].default, (int, float, str, tuple))\n                and p not in skip_settings\n            ]\n        )\n        if name in skip_plot:\n            f.write(\n                f\"\"\"\n\n{name}\n----------------------------------------------------\n\n.. autofunction:: gf180.{name}\n\n\"\"\"\n            )\n        else:\n            f.write(\n                f\"\"\"\n\n{name}\n----------------------------------------------------\n\n.. autofunction:: gf180.{name}\n\n.. plot::\n  :include-source:\n\n  import gf180\n\n  c = gf180.{name}({kwargs})\n  c.plot()\n\n\"\"\"\n            )", ""]}
{"filename": "docs/notebooks/intro.py", "chunked_list": ["# ---\n# jupyter:\n#   jupytext:\n#     custom_cell_magics: kql\n#     text_representation:\n#       extension: .py\n#       format_name: percent\n#       format_version: '1.3'\n#       jupytext_version: 1.11.2\n#   kernelspec:", "#       jupytext_version: 1.11.2\n#   kernelspec:\n#     display_name: Python 3 (ipykernel)\n#     language: python\n#     name: python3\n# ---\n\n# %% [markdown]\n# # Layout\n#", "# # Layout\n#\n# ## Layout driven flow\n#\n# You can import the PDK and layout any of the standard cells\n\n# %%\nimport gf180\n\n# %%", "\n# %%\nc = gf180.diode_dw2ps()\nc\n"]}
{"filename": "gf180/res.py", "chunked_list": ["import gdsfactory as gf\nfrom gdsfactory.typings import Float2, LayerSpec\n\nfrom gf180.guardring import pcmpgr_gen\nfrom gf180.layers import layer\nfrom gf180.via_generator import via_stack\n\n\n@gf.cell\ndef res(\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"rm1\",\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw 2-terminal Metal resistor by specifying parameters\n\n    Args:\n         l      : Float of diff length\n         w      : Float of diff width\n    \"\"\"\n\n    c = gf.Component(\"res_dev\")\n\n    m_ext = 0.28\n\n    if res_type == \"rm1\":\n        m_layer = layer[\"metal1\"]\n        res_layer = layer[\"metal1_res\"]\n        m_lbl_layer = layer[\"metal1_label\"]\n    elif res_type == \"rm2\":\n        m_layer = layer[\"metal2\"]\n        res_layer = layer[\"metal2_res\"]\n        m_lbl_layer = layer[\"metal2_label\"]\n    elif res_type == \"rm3\":\n        m_layer = layer[\"metal3\"]\n        res_layer = layer[\"metal3_res\"]\n        m_lbl_layer = layer[\"metal3_label\"]\n    else:\n        m_layer = layer[\"metaltop\"]\n        res_layer = layer[\"metal6_res\"]\n        m_lbl_layer = layer[\"metaltop_label\"]\n\n    res_mk = c.add_ref(gf.components.rectangle(size=(l_res, w_res), layer=res_layer))\n\n    m_rect = c.add_ref(\n        gf.components.rectangle(size=(l_res + (2 * m_ext), w_res), layer=m_layer)\n    )\n    m_rect.xmin = res_mk.xmin - m_ext\n    m_rect.ymin = res_mk.ymin\n\n    # labels generation\n    if lbl == 1:\n        c.add_label(\n            r0_lbl,\n            position=(\n                res_mk.xmin + (res_mk.size[0] / 2),\n                res_mk.ymin + (res_mk.size[1] / 2),\n            ),\n            layer=m_lbl_layer,\n        )\n        c.add_label(\n            r1_lbl,\n            position=(\n                m_rect.xmin + (res_mk.xmin - m_rect.xmin) / 2,\n                m_rect.ymin + (m_rect.size[1] / 2),\n            ),\n            layer=m_lbl_layer,\n        )\n\n    return c", "@gf.cell\ndef res(\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"rm1\",\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw 2-terminal Metal resistor by specifying parameters\n\n    Args:\n         l      : Float of diff length\n         w      : Float of diff width\n    \"\"\"\n\n    c = gf.Component(\"res_dev\")\n\n    m_ext = 0.28\n\n    if res_type == \"rm1\":\n        m_layer = layer[\"metal1\"]\n        res_layer = layer[\"metal1_res\"]\n        m_lbl_layer = layer[\"metal1_label\"]\n    elif res_type == \"rm2\":\n        m_layer = layer[\"metal2\"]\n        res_layer = layer[\"metal2_res\"]\n        m_lbl_layer = layer[\"metal2_label\"]\n    elif res_type == \"rm3\":\n        m_layer = layer[\"metal3\"]\n        res_layer = layer[\"metal3_res\"]\n        m_lbl_layer = layer[\"metal3_label\"]\n    else:\n        m_layer = layer[\"metaltop\"]\n        res_layer = layer[\"metal6_res\"]\n        m_lbl_layer = layer[\"metaltop_label\"]\n\n    res_mk = c.add_ref(gf.components.rectangle(size=(l_res, w_res), layer=res_layer))\n\n    m_rect = c.add_ref(\n        gf.components.rectangle(size=(l_res + (2 * m_ext), w_res), layer=m_layer)\n    )\n    m_rect.xmin = res_mk.xmin - m_ext\n    m_rect.ymin = res_mk.ymin\n\n    # labels generation\n    if lbl == 1:\n        c.add_label(\n            r0_lbl,\n            position=(\n                res_mk.xmin + (res_mk.size[0] / 2),\n                res_mk.ymin + (res_mk.size[1] / 2),\n            ),\n            layer=m_lbl_layer,\n        )\n        c.add_label(\n            r1_lbl,\n            position=(\n                m_rect.xmin + (res_mk.xmin - m_rect.xmin) / 2,\n                m_rect.ymin + (m_rect.size[1] / 2),\n            ),\n            layer=m_lbl_layer,\n        )\n\n    return c", "\n\n@gf.cell\ndef plus_res_inst(\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"nplus_s\",\n    sub: bool = 0,\n    cmp_res_ext: float = 0.1,\n    con_enc: float = 0.1,\n    cmp_imp_layer: LayerSpec = layer[\"nplus\"],\n    sub_imp_layer: LayerSpec = layer[\"pplus\"],\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component()\n\n    sub_w: float = 0.36\n    np_enc_cmp: float = 0.16\n    pp_enc_cmp: float = 0.16\n    comp_spacing: float = 0.72\n    sab_res_ext = 0.22\n\n    res_mk = c.add_ref(\n        gf.components.rectangle(size=(l_res, w_res), layer=layer[\"res_mk\"])\n    )\n\n    if \"plus_u\" in res_type:\n        sab_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(res_mk.size[0], res_mk.size[1] + (2 * sab_res_ext)),\n                layer=layer[\"sab\"],\n            )\n        )\n        sab_rect.xmin = res_mk.xmin\n        sab_rect.ymin = res_mk.ymin - sab_res_ext\n\n    cmp = c.add_ref(\n        gf.components.rectangle(\n            size=(res_mk.size[0] + (2 * cmp_res_ext), res_mk.size[1]),\n            layer=layer[\"comp\"],\n        )\n    )\n    cmp.xmin = res_mk.xmin - cmp_res_ext\n    cmp.ymin = res_mk.ymin\n\n    cmp_con = via_stack(\n        x_range=(cmp.xmin, res_mk.xmin + con_enc),\n        y_range=(cmp.ymin, cmp.ymax),\n        base_layer=layer[\"comp\"],\n        metal_level=1,\n    )\n\n    cmp_con_arr = c.add_array(\n        component=cmp_con,\n        rows=1,\n        columns=2,\n        spacing=(cmp_res_ext - con_enc + res_mk.size[0], 0),\n    )  # comp contact array\n\n    # labels generation\n    if lbl == 1:\n        c.add_label(\n            r0_lbl,\n            position=(\n                cmp_con_arr.xmin + (cmp_con.size[0] / 2),\n                cmp_con_arr.ymin + (cmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n        c.add_label(\n            r1_lbl,\n            position=(\n                cmp_con_arr.xmax - (cmp_con.size[0] / 2),\n                cmp_con_arr.ymin + (cmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    cmp_imp = c.add_ref(\n        gf.components.rectangle(\n            size=(cmp.size[0] + (2 * np_enc_cmp), cmp.size[1] + (2 * np_enc_cmp)),\n            layer=cmp_imp_layer,\n        )\n    )\n    cmp_imp.xmin = cmp.xmin - np_enc_cmp\n    cmp_imp.ymin = cmp.ymin - np_enc_cmp\n\n    if sub == 1:\n        sub_rect = c.add_ref(\n            gf.components.rectangle(size=(sub_w, w_res), layer=layer[\"comp\"])\n        )\n        sub_rect.xmax = cmp.xmin - comp_spacing\n        sub_rect.ymin = cmp.ymin\n\n        # sub_rect contact\n        sub_con = c.add_ref(\n            via_stack(\n                x_range=(sub_rect.xmin, sub_rect.xmax),\n                y_range=(sub_rect.ymin, sub_rect.ymax),\n                base_layer=layer[\"comp\"],\n                metal_level=1,\n            )\n        )\n\n        sub_imp = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    sub_rect.size[0] + (2 * pp_enc_cmp),\n                    cmp.size[1] + (2 * pp_enc_cmp),\n                ),\n                layer=sub_imp_layer,\n            )\n        )\n        sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n        sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n\n        # label generation\n        if lbl == 1:\n            c.add_label(\n                sub_lbl,\n                position=(\n                    sub_con.xmin + (sub_con.size[0] / 2),\n                    sub_con.ymin + (sub_con.size[1] / 2),\n                ),\n                layer=layer[\"metal1_label\"],\n            )\n\n    return c", "\n\n@gf.cell\ndef nplus_res(\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"nplus_s\",\n    sub: bool = 0,\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component()\n\n    lvpwell_enc_cmp = 0.43\n    dn_enc_lvpwell = 2.5\n    sub_w = 0.36\n\n    if res_type == \"nplus_s\":\n        cmp_res_ext = 0.29\n        con_enc = 0.07\n    else:\n        cmp_res_ext = 0.44\n        con_enc = 0.0\n\n    # adding res inst\n    r_inst = c.add_ref(\n        plus_res_inst(\n            l_res=l_res,\n            w_res=w_res,\n            res_type=res_type,\n            sub=sub,\n            cmp_res_ext=cmp_res_ext,\n            con_enc=con_enc,\n            cmp_imp_layer=layer[\"nplus\"],\n            sub_imp_layer=layer[\"pplus\"],\n            lbl=lbl,\n            r0_lbl=r0_lbl,\n            r1_lbl=r1_lbl,\n            sub_lbl=sub_lbl,\n        )\n    )\n\n    if deepnwell == 1:\n        lvpwell = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    r_inst.size[0] + (2 * lvpwell_enc_cmp),\n                    r_inst.size[1] + (2 * lvpwell_enc_cmp),\n                ),\n                layer=layer[\"lvpwell\"],\n            )\n        )\n        lvpwell.xmin = r_inst.xmin - lvpwell_enc_cmp\n        lvpwell.ymin = r_inst.ymin - lvpwell_enc_cmp\n\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    lvpwell.size[0] + (2 * dn_enc_lvpwell),\n                    lvpwell.size[1] + (2 * dn_enc_lvpwell),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n        dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n        dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\n        if pcmpgr == 1:\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\n    return c", "\n\n@gf.cell\ndef pplus_res(\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"pplus_s\",\n    sub: bool = 0,\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component(\"res_dev\")\n\n    nw_enc_pcmp = 0.6\n    dn_enc_ncmp = 0.66\n    dn_enc_pcmp = 1.02\n    sub_w = 0.36\n\n    if res_type == \"pplus_s\":\n        cmp_res_ext = 0.29\n        con_enc = 0.07\n    else:\n        cmp_res_ext = 0.44\n        con_enc = 0.0\n\n    # adding res inst\n    r_inst = c.add_ref(\n        plus_res_inst(\n            l_res=l_res,\n            w_res=w_res,\n            res_type=res_type,\n            sub=1,\n            cmp_res_ext=cmp_res_ext,\n            con_enc=con_enc,\n            cmp_imp_layer=layer[\"pplus\"],\n            sub_imp_layer=layer[\"nplus\"],\n            lbl=lbl,\n            r0_lbl=r0_lbl,\n            r1_lbl=r1_lbl,\n            sub_lbl=sub_lbl,\n        )\n    )\n\n    if deepnwell == 1:\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    r_inst.size[0] + (dn_enc_pcmp + dn_enc_ncmp),\n                    r_inst.size[1] + (2 * dn_enc_pcmp),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n        dn_rect.xmax = r_inst.xmax + dn_enc_pcmp\n        dn_rect.ymin = r_inst.ymin - dn_enc_pcmp\n\n        if pcmpgr == 1:\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\n    else:\n        nw_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    r_inst.size[0] + (2 * nw_enc_pcmp),\n                    r_inst.size[1] + (2 * nw_enc_pcmp),\n                ),\n                layer=layer[\"nwell\"],\n            )\n        )\n        nw_rect.xmin = r_inst.xmin - nw_enc_pcmp\n        nw_rect.ymin = r_inst.ymin - nw_enc_pcmp\n\n    return c", "\n\n@gf.cell\ndef polyf_res_inst(\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"npolyf_s\",\n    pl_res_ext: float = 0.1,\n    con_enc: float = 0.1,\n    pl_imp_layer: LayerSpec = layer[\"nplus\"],\n    sub_imp_layer: LayerSpec = layer[\"pplus\"],\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component()\n\n    sub_w: float = 0.36\n    np_enc_poly2 = 0.3\n    pp_enc_cmp: float = 0.16\n    comp_spacing: float = 0.72\n    sab_res_ext = 0.28\n\n    res_mk = c.add_ref(\n        gf.components.rectangle(size=(l_res, w_res), layer=layer[\"res_mk\"])\n    )\n\n    if \"polyf_u\" in res_type:\n        sab_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(res_mk.size[0], res_mk.size[1] + (2 * sab_res_ext)),\n                layer=layer[\"sab\"],\n            )\n        )\n        sab_rect.xmin = res_mk.xmin\n        sab_rect.ymin = res_mk.ymin - sab_res_ext\n\n    pl = c.add_ref(\n        gf.components.rectangle(\n            size=(res_mk.size[0] + (2 * pl_res_ext), res_mk.size[1]),\n            layer=layer[\"poly2\"],\n        )\n    )\n    pl.xmin = res_mk.xmin - pl_res_ext\n    pl.ymin = res_mk.ymin\n\n    pl_con = via_stack(\n        x_range=(pl.xmin, res_mk.xmin + con_enc),\n        y_range=(pl.ymin, pl.ymax),\n        base_layer=layer[\"poly2\"],\n        metal_level=1,\n    )\n\n    pl_con_arr = c.add_array(\n        component=pl_con,\n        rows=1,\n        columns=2,\n        spacing=(pl_res_ext - con_enc + res_mk.size[0], 0),\n    )  # comp contact array\n\n    pl_imp = c.add_ref(\n        gf.components.rectangle(\n            size=(pl.size[0] + (2 * np_enc_poly2), pl.size[1] + (2 * np_enc_poly2)),\n            layer=pl_imp_layer,\n        )\n    )\n    pl_imp.xmin = pl.xmin - np_enc_poly2\n    pl_imp.ymin = pl.ymin - np_enc_poly2\n\n    sub_rect = c.add_ref(\n        gf.components.rectangle(size=(sub_w, w_res), layer=layer[\"comp\"])\n    )\n    sub_rect.xmax = pl.xmin - comp_spacing\n    sub_rect.ymin = pl.ymin\n\n    # sub_rect contact\n    sub_con = c.add_ref(\n        via_stack(\n            x_range=(sub_rect.xmin, sub_rect.xmax),\n            y_range=(sub_rect.ymin, sub_rect.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )\n\n    sub_imp = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                sub_rect.size[0] + (2 * pp_enc_cmp),\n                pl.size[1] + (2 * pp_enc_cmp),\n            ),\n            layer=sub_imp_layer,\n        )\n    )\n    sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n    sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n\n    # labels generation\n    if lbl == 1:\n        c.add_label(\n            r0_lbl,\n            position=(\n                pl_con_arr.xmin + (pl_con.size[0] / 2),\n                pl_con_arr.ymin + (pl_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n        c.add_label(\n            r1_lbl,\n            position=(\n                pl_con_arr.xmax - (pl_con.size[0] / 2),\n                pl_con_arr.ymin + (pl_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        c.add_label(\n            sub_lbl,\n            position=(\n                sub_con.xmin + (sub_con.size[0] / 2),\n                sub_con.ymin + (sub_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    return c", "\n\n@gf.cell\ndef npolyf_res(\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"npolyf_s\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component(\"res_dev\")\n\n    lvpwell_enc_cmp = 0.43\n    dn_enc_lvpwell = 2.5\n    sub_w = 0.36\n\n    if res_type == \"npolyf_s\":\n        pl_res_ext = 0.29\n        con_enc = 0.07\n    else:\n        pl_res_ext = 0.44\n        con_enc = 0.0\n\n    # adding res inst\n    r_inst = c.add_ref(\n        polyf_res_inst(\n            l_res=l_res,\n            w_res=w_res,\n            res_type=res_type,\n            pl_res_ext=pl_res_ext,\n            con_enc=con_enc,\n            pl_imp_layer=layer[\"nplus\"],\n            sub_imp_layer=layer[\"pplus\"],\n            lbl=lbl,\n            r0_lbl=r0_lbl,\n            r1_lbl=r1_lbl,\n            sub_lbl=sub_lbl,\n        )\n    )\n\n    if deepnwell == 1:\n        lvpwell = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    r_inst.size[0] + (2 * lvpwell_enc_cmp),\n                    r_inst.size[1] + (2 * lvpwell_enc_cmp),\n                ),\n                layer=layer[\"lvpwell\"],\n            )\n        )\n        lvpwell.xmin = r_inst.xmin - lvpwell_enc_cmp\n        lvpwell.ymin = r_inst.ymin - lvpwell_enc_cmp\n\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    lvpwell.size[0] + (2 * dn_enc_lvpwell),\n                    lvpwell.size[1] + (2 * dn_enc_lvpwell),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n        dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n        dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\n        if pcmpgr == 1:\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\n    return c", "\n\n@gf.cell\ndef ppolyf_res(\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"ppolyf_s\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component(\"res_dev\")\n\n    sub_w = 0.36\n    dn_enc_ncmp = 0.66\n    dn_enc_poly2 = 1.34\n\n    if res_type == \"ppolyf_s\":\n        pl_res_ext = 0.29\n        con_enc = 0.07\n    else:\n        pl_res_ext = 0.44\n        con_enc = 0.0\n\n    if deepnwell == 1:\n        sub_layer = layer[\"nplus\"]\n    else:\n        sub_layer = layer[\"pplus\"]\n\n    # adding res inst\n    r_inst = c.add_ref(\n        polyf_res_inst(\n            l_res=l_res,\n            w_res=w_res,\n            res_type=res_type,\n            pl_res_ext=pl_res_ext,\n            con_enc=con_enc,\n            pl_imp_layer=layer[\"pplus\"],\n            sub_imp_layer=sub_layer,\n            lbl=lbl,\n            r0_lbl=r0_lbl,\n            r1_lbl=r1_lbl,\n            sub_lbl=sub_lbl,\n        )\n    )\n\n    if deepnwell == 1:\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    r_inst.size[0] + (dn_enc_poly2 + dn_enc_ncmp),\n                    r_inst.size[1] + (2 * dn_enc_poly2),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n        dn_rect.xmax = r_inst.xmax + dn_enc_poly2\n        dn_rect.ymin = r_inst.ymin - dn_enc_poly2\n\n        if pcmpgr == 1:\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\n    return c", "\n\n@gf.cell\ndef ppolyf_u_high_Rs_res(\n    l_res: float = 0.42,\n    w_res: float = 0.42,\n    volt: str = \"3.3V\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component(\"res_dev\")\n\n    dn_enc_ncmp = 0.62\n    dn_enc_poly2 = 1.34\n\n    pl_res_ext = 0.64\n\n    sub_w: float = 0.42\n    pp_enc_poly2 = 0.18\n    pp_enc_cmp: float = 0.02\n    comp_spacing: float = 0.7\n    sab_res_ext = (0.1, 0.28)\n    con_size = 0.36\n    resis_enc = (1.04, 0.4)\n    dg_enc_dn = 0.5\n\n    res_mk = c.add_ref(\n        gf.components.rectangle(size=(l_res, w_res), layer=layer[\"res_mk\"])\n    )\n\n    resis_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                res_mk.size[0] + (2 * resis_enc[0]),\n                res_mk.size[1] + (2 * resis_enc[1]),\n            ),\n            layer=layer[\"resistor\"],\n        )\n    )\n\n    resis_mk.xmin = res_mk.xmin - resis_enc[0]\n    resis_mk.ymin = res_mk.ymin - resis_enc[1]\n\n    sab_rect = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                res_mk.size[0] + (2 * sab_res_ext[0]),\n                res_mk.size[1] + (2 * sab_res_ext[1]),\n            ),\n            layer=layer[\"sab\"],\n        )\n    )\n    sab_rect.xmin = res_mk.xmin - sab_res_ext[0]\n    sab_rect.ymin = res_mk.ymin - sab_res_ext[1]\n\n    pl = c.add_ref(\n        gf.components.rectangle(\n            size=(res_mk.size[0] + (2 * pl_res_ext), res_mk.size[1]),\n            layer=layer[\"poly2\"],\n        )\n    )\n    pl.xmin = res_mk.xmin - pl_res_ext\n    pl.ymin = res_mk.ymin\n\n    pl_con = via_stack(\n        x_range=(pl.xmin, pl.xmin + con_size),\n        y_range=(pl.ymin, pl.ymax),\n        base_layer=layer[\"poly2\"],\n        metal_level=1,\n    )\n\n    pl_con_arr = c.add_array(\n        component=pl_con,\n        rows=1,\n        columns=2,\n        spacing=(pl.size[0] - con_size, 0),\n    )  # comp contact array\n\n    pplus = gf.components.rectangle(\n        size=(pl_res_ext + pp_enc_poly2, pl.size[1] + (2 * pp_enc_poly2)),\n        layer=layer[\"pplus\"],\n    )\n\n    pplus_arr = c.add_array(\n        component=pplus, rows=1, columns=2, spacing=(pplus.size[0] + res_mk.size[0], 0)\n    )\n\n    pplus_arr.xmin = pl.xmin - pp_enc_poly2\n    pplus_arr.ymin = pl.ymin - pp_enc_poly2\n\n    sub_rect = c.add_ref(\n        gf.components.rectangle(size=(sub_w, w_res), layer=layer[\"comp\"])\n    )\n    sub_rect.xmax = pl.xmin - comp_spacing\n    sub_rect.ymin = pl.ymin\n\n    # sub_rect contact\n    sub_con = c.add_ref(\n        via_stack(\n            x_range=(sub_rect.xmin, sub_rect.xmax),\n            y_range=(sub_rect.ymin, sub_rect.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )\n\n    # labels generation\n    if lbl == 1:\n        c.add_label(\n            r0_lbl,\n            position=(\n                pl_con_arr.xmin + (pl_con.size[0] / 2),\n                pl_con_arr.ymin + (pl_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n        c.add_label(\n            r1_lbl,\n            position=(\n                pl_con_arr.xmax - (pl_con.size[0] / 2),\n                pl_con_arr.ymin + (pl_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        c.add_label(\n            sub_lbl,\n            position=(\n                sub_con.xmin + (sub_con.size[0] / 2),\n                sub_con.ymin + (sub_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    if deepnwell == 1:\n        sub_layer = layer[\"nplus\"]\n    else:\n        sub_layer = layer[\"pplus\"]\n\n    sub_imp = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                sub_rect.size[0] + (2 * pp_enc_cmp),\n                pl.size[1] + (2 * pp_enc_cmp),\n            ),\n            layer=sub_layer,\n        )\n    )\n    sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n    sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n\n    if deepnwell == 1:\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (pl.xmax - sub_rect.xmin) + (dn_enc_poly2 + dn_enc_ncmp),\n                    pl.size[1] + (2 * dn_enc_poly2),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n        dn_rect.xmax = pl.xmax + dn_enc_poly2\n        dn_rect.ymin = pl.ymin - dn_enc_poly2\n\n        if volt == \"5/6V\":\n            dg = c.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        dn_rect.size[0] + (2 * dg_enc_dn),\n                        dn_rect.size[1] + (2 * dg_enc_dn),\n                    ),\n                    layer=layer[\"dualgate\"],\n                )\n            )\n\n            dg.xmin = dn_rect.xmin - dg_enc_dn\n            dg.ymin = dn_rect.ymin - dg_enc_dn\n\n        if pcmpgr == 1:\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\n    else:\n        if volt == \"5/6V\":\n            dg = c.add_ref(\n                gf.components.rectangle(\n                    size=(resis_mk.size[0], resis_mk.size[1]), layer=layer[\"dualgate\"]\n                )\n            )\n\n            dg.xmin = resis_mk.xmin\n            dg.ymin = resis_mk.ymin\n\n    return c", "\n\n@gf.cell\ndef well_res(\n    l_res: float = 0.42,\n    w_res: float = 0.42,\n    res_type: str = \"nwell\",\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component(\"res_dev\")\n\n    nw_res_ext = 0.48\n    nw_res_enc = 0.5\n    nw_enc_cmp = 0.12\n\n    sub_w: float = 0.36\n    pp_enc_cmp: float = 0.16\n    nw_comp_spacing: float = 0.72\n    dn_enc_lvpwell = 2.5\n\n    if res_type == \"pwell\":\n        cmp_imp_layer = layer[\"pplus\"]\n        sub_imp_layer = layer[\"nplus\"]\n        well_layer = layer[\"lvpwell\"]\n    else:\n        cmp_imp_layer = layer[\"nplus\"]\n        sub_imp_layer = layer[\"pplus\"]\n        well_layer = layer[\"nwell\"]\n\n    res_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(l_res, w_res + (2 * nw_res_enc)), layer=layer[\"res_mk\"]\n        )\n    )\n\n    well_rect = c.add_ref(\n        gf.components.rectangle(\n            size=(res_mk.size[0] + (2 * nw_res_ext), w_res), layer=well_layer\n        )\n    )\n    well_rect.xmin = res_mk.xmin - nw_res_ext\n    well_rect.ymin = res_mk.ymin + nw_res_enc\n\n    @gf.cell\n    def comp_related_gen(size: Float2 = (0.42, 0.42)) -> gf.Component:\n        c = gf.Component()\n\n        cmp = c.add_ref(gf.components.rectangle(size=size, layer=layer[\"comp\"]))\n        cmp.xmin = well_rect.xmin + nw_enc_cmp\n        cmp.ymin = well_rect.ymin + nw_enc_cmp\n\n        c.add_ref(\n            via_stack(\n                x_range=(cmp.xmin, cmp.xmax),\n                y_range=(cmp.ymin, cmp.ymax),\n                base_layer=layer[\"comp\"],\n                metal_level=1,\n            )\n        )  # contact\n\n        return c\n\n    con_polys = comp_related_gen(\n        size=(\n            res_mk.xmin - well_rect.xmin - nw_enc_cmp,\n            well_rect.size[1] - (2 * nw_enc_cmp),\n        )\n    )\n\n    con_polys_arr = c.add_array(\n        component=con_polys,\n        rows=1,\n        columns=2,\n        spacing=(well_rect.size[0] - (2 * nw_enc_cmp) - con_polys.size[0], 0),\n    )  # comp and its related contact array\n\n    nplus_rect = gf.components.rectangle(\n        size=(\n            con_polys.size[0] + (2 * pp_enc_cmp),\n            con_polys.size[1] + (2 * pp_enc_cmp),\n        ),\n        layer=cmp_imp_layer,\n    )\n    nplus_arr = c.add_array(\n        component=nplus_rect,\n        rows=1,\n        columns=2,\n        spacing=(well_rect.size[0] - (2 * nw_enc_cmp) - con_polys.size[0], 0),\n    )\n    nplus_arr.xmin = con_polys.xmin - pp_enc_cmp\n    nplus_arr.ymin = con_polys.ymin - pp_enc_cmp\n\n    sub_rect = c.add_ref(\n        gf.components.rectangle(size=(sub_w, well_rect.size[1]), layer=layer[\"comp\"])\n    )\n    sub_rect.xmax = well_rect.xmin - nw_comp_spacing\n    sub_rect.ymin = well_rect.ymin\n\n    # sub_rect contact\n    sub_con = c.add_ref(\n        via_stack(\n            x_range=(sub_rect.xmin, sub_rect.xmax),\n            y_range=(sub_rect.ymin, sub_rect.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )\n\n    sub_imp = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                sub_rect.size[0] + (2 * pp_enc_cmp),\n                well_rect.size[1] + (2 * pp_enc_cmp),\n            ),\n            layer=sub_imp_layer,\n        )\n    )\n    sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n    sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n\n    if res_type == \"pwell\":\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    well_rect.size[0] + (2 * dn_enc_lvpwell),\n                    well_rect.size[1] + (2 * dn_enc_lvpwell),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n        dn_rect.xmin = well_rect.xmin - dn_enc_lvpwell\n        dn_rect.ymin = well_rect.ymin - dn_enc_lvpwell\n\n        if pcmpgr == 1:\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\n    # labels generation\n    if lbl == 1:\n        c.add_label(\n            r0_lbl,\n            position=(\n                con_polys_arr.xmin + (con_polys.size[0] / 2),\n                con_polys_arr.ymin + (con_polys.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n        c.add_label(\n            r1_lbl,\n            position=(\n                con_polys_arr.xmax - (con_polys.size[0] / 2),\n                con_polys_arr.ymin + (con_polys.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        c.add_label(\n            sub_lbl,\n            position=(\n                sub_con.xmin + (sub_con.size[0] / 2),\n                sub_con.ymin + (sub_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n    return c", "\n\nif __name__ == \"__main__\":\n    c = res()\n    c.show()\n"]}
{"filename": "gf180/layers.py", "chunked_list": ["import gdsfactory as gf\nfrom gdsfactory.typings import Layer\nfrom pydantic import BaseModel\n\nfrom gf180.config import PATH\n\n\nclass LayerMap(BaseModel):\n    comp: Layer = (22, 0)\n    dnwell: Layer = (12, 0)\n    nwell: Layer = (21, 0)\n    lvpwell: Layer = (204, 0)\n    dualgate: Layer = (55, 0)\n    poly2: Layer = (30, 0)\n    nplus: Layer = (32, 0)\n    pplus: Layer = (31, 0)\n    sab: Layer = (49, 0)\n    esd: Layer = (24, 0)\n    contact: Layer = (33, 0)\n    metal1: Layer = (34, 0)\n    via1: Layer = (35, 0)\n    metal2: Layer = (36, 0)\n    via2: Layer = (38, 0)\n    metal3: Layer = (42, 0)\n    via3: Layer = (40, 0)\n    metal4: Layer = (46, 0)\n    via4: Layer = (41, 0)\n    metal5: Layer = (81, 0)\n    via5: Layer = (82, 0)\n    metaltop: Layer = (53, 0)\n    pad: Layer = (37, 0)\n    resistor: Layer = (62, 0)\n    fhres: Layer = (227, 0)\n    fusetop: Layer = (75, 0)\n    fusewindow_d: Layer = (96, 1)\n    polyfuse: Layer = (220, 0)\n    mvsd: Layer = (210, 0)\n    mvpsd: Layer = (11, 39)\n    nat: Layer = (5, 0)\n    comp_dummy: Layer = (22, 4)\n    poly2_dummy: Layer = (30, 4)\n    metal1_dummy: Layer = (34, 4)\n    metal2_dummy: Layer = (36, 4)\n    metal3_dummy: Layer = (42, 4)\n    metal4_dummy: Layer = (46, 4)\n    metal5_dummy: Layer = (81, 4)\n    metaltop_dummy: Layer = (53, 4)\n    comp_label: Layer = (22, 10)\n    poly2_label: Layer = (30, 10)\n    metal1_label: Layer = (34, 10)\n    metal2_label: Layer = (36, 10)\n    metal3_label: Layer = (42, 10)\n    metal4_label: Layer = (46, 10)\n    metal5_label: Layer = (81, 10)\n    metaltop_label: Layer = (53, 10)\n    metal1_slot: Layer = (34, 3)\n    metal2_slot: Layer = (36, 3)\n    metal3_slot: Layer = (42, 3)\n    metal4_slot: Layer = (46, 3)\n    metal5_slot: Layer = (81, 3)\n    metaltop_slot: Layer = (53, 3)\n    ubmpperi: Layer = (183, 0)\n    ubmparray: Layer = (184, 0)\n    ubmeplate: Layer = (185, 0)\n    schottky_diode: Layer = (241, 0)\n    zener: Layer = (178, 0)\n    res_mk: Layer = (110, 5)\n    opc_drc: Layer = (124, 5)\n    ndmy: Layer = (111, 5)\n    pmndmy: Layer = (152, 5)\n    v5_xtor: Layer = (112, 1)\n    cap_mk: Layer = (117, 5)\n    mos_cap_mk: Layer = (166, 5)\n    ind_mk: Layer = (151, 5)\n    diode_mk: Layer = (115, 5)\n    drc_bjt: Layer = (127, 5)\n    lvs_bjt: Layer = (118, 5)\n    mim_l_mk: Layer = (117, 10)\n    latchup_mk: Layer = (137, 5)\n    guard_ring_mk: Layer = (167, 5)\n    otp_mk: Layer = (173, 5)\n    mtpmark: Layer = (122, 5)\n    neo_ee_mk: Layer = (88, 17)\n    sramcore: Layer = (108, 5)\n    lvs_rf: Layer = (100, 5)\n    lvs_drain: Layer = (100, 7)\n    ind_mk1: Layer = (151, 5)\n    hvpolyrs: Layer = (123, 5)\n    lvs_io: Layer = (119, 5)\n    probe_mk: Layer = (13, 17)\n    esd_mk: Layer = (24, 5)\n    lvs_source: Layer = (100, 8)\n    well_diode_mk: Layer = (153, 51)\n    ldmos_xtor: Layer = (226, 0)\n    plfuse: Layer = (125, 5)\n    efuse_mk: Layer = (80, 5)\n    mcell_feol_mk: Layer = (11, 17)\n    ymtp_mk: Layer = (86, 17)\n    dev_wf_mk: Layer = (128, 17)\n    metal1_blk: Layer = (34, 5)\n    metal2_blk: Layer = (36, 5)\n    metal3_blk: Layer = (42, 5)\n    metal4_blk: Layer = (46, 5)\n    metal5_blk: Layer = (81, 5)\n    metalt_blk: Layer = (53, 5)\n    pr_bndry: Layer = (0, 0)\n    mdiode: Layer = (116, 5)\n    metal1_res: Layer = (110, 11)\n    metal2_res: Layer = (110, 12)\n    metal3_res: Layer = (110, 13)\n    metal4_res: Layer = (110, 14)\n    metal5_res: Layer = (110, 15)\n    metal6_res: Layer = (110, 16)\n    border: Layer = (63, 0)", "\n\nLAYER = LayerMap()\nlayer = dict(LAYER)\nLAYER_VIEWS = gf.technology.LayerViews(PATH.lyp_yaml)\n\nif __name__ == \"__main__\":\n    LAYER_VIEWS.to_lyp(PATH.lyp)\n", ""]}
{"filename": "gf180/config.py", "chunked_list": ["\"\"\"Store configuration.\"\"\"\n\n__all__ = [\"PATH\"]\n\nimport pathlib\n\nhome = pathlib.Path.home()\ncwd = pathlib.Path.cwd()\ncwd_config = cwd / \"config.yml\"\n", "cwd_config = cwd / \"config.yml\"\n\nhome_config = home / \".config\" / \"gf180.yml\"\nconfig_dir = home / \".config\"\nconfig_dir.mkdir(exist_ok=True)\nmodule_path = pathlib.Path(__file__).parent.absolute()\nrepo_path = module_path.parent\n\n\nclass Path:\n    module = module_path\n    repo = repo_path\n    lyp = module_path / \"klayout\" / \"tech\" / \"gf180mcu.lyp\"\n    lyp_yaml = module_path / \"layers.yaml\"", "\nclass Path:\n    module = module_path\n    repo = repo_path\n    lyp = module_path / \"klayout\" / \"tech\" / \"gf180mcu.lyp\"\n    lyp_yaml = module_path / \"layers.yaml\"\n\n\nPATH = Path()\n\nif __name__ == \"__main__\":\n    print(PATH)", "PATH = Path()\n\nif __name__ == \"__main__\":\n    print(PATH)\n"]}
{"filename": "gf180/guardring.py", "chunked_list": ["import gdsfactory as gf\n\nfrom gf180.layers import LAYER, layer\nfrom gf180.via_generator import via_generator\n\ndn_rect = gf.partial(gf.components.rectangle, layer=LAYER.dnwell)\n\n\n@gf.cell\ndef pcmpgr_gen(dn_rect=dn_rect, grw: float = 0.36) -> gf.Component:\n    \"\"\"Return deepnwell guardring\n\n    Args:\n        dn_rect : deepnwell polygon.\n        grw : guardring width.\n    \"\"\"\n\n    c = gf.Component()\n\n    dn_rect = gf.get_component(dn_rect)\n\n    comp_pp_enc: float = 0.16\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n    pcmpgr_enc_dn = 2.5\n\n    c_temp_gr = gf.Component(\"temp_store guard ring\")\n    rect_pcmpgr_in = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n            ),\n            layer=layer[\"comp\"],\n        )\n    )\n    rect_pcmpgr_in.move((dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn))\n    rect_pcmpgr_out = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * grw,\n                (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * grw,\n            ),\n            layer=layer[\"comp\"],\n        )\n    )\n    rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n    c.add_ref(\n        gf.geometry.boolean(\n            A=rect_pcmpgr_out,\n            B=rect_pcmpgr_in,\n            operation=\"A-B\",\n            layer=layer[\"comp\"],\n        )\n    )  # guardring bulk\n\n    psdm_in = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * comp_pp_enc,\n                (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * comp_pp_enc,\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    psdm_in.move(\n        (\n            rect_pcmpgr_in.xmin + comp_pp_enc,\n            rect_pcmpgr_in.ymin + comp_pp_enc,\n        )\n    )\n    psdm_out = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * comp_pp_enc,\n                (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * comp_pp_enc,\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    psdm_out.move(\n        (\n            rect_pcmpgr_out.xmin - comp_pp_enc,\n            rect_pcmpgr_out.ymin - comp_pp_enc,\n        )\n    )\n    c.add_ref(\n        gf.geometry.boolean(\n            A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n        )\n    )  # pplus_draw\n\n    # generating contacts\n\n    c.add_ref(\n        via_generator(\n            x_range=(\n                rect_pcmpgr_in.xmin + con_size,\n                rect_pcmpgr_in.xmax - con_size,\n            ),\n            y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # bottom contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(\n                rect_pcmpgr_in.xmin + con_size,\n                rect_pcmpgr_in.xmax - con_size,\n            ),\n            y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # upper contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n            y_range=(\n                rect_pcmpgr_in.ymin + con_size,\n                rect_pcmpgr_in.ymax - con_size,\n            ),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # right contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n            y_range=(\n                rect_pcmpgr_in.ymin + con_size,\n                rect_pcmpgr_in.ymax - con_size,\n            ),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # left contact\n\n    comp_m1_in = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n            layer=layer[\"metal1\"],\n        )\n    )\n\n    comp_m1_out = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (comp_m1_in.size[0]) + 2 * grw,\n                (comp_m1_in.size[1]) + 2 * grw,\n            ),\n            layer=layer[\"metal1\"],\n        )\n    )\n    comp_m1_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n    c.add_ref(\n        gf.geometry.boolean(\n            A=rect_pcmpgr_out,\n            B=rect_pcmpgr_in,\n            operation=\"A-B\",\n            layer=layer[\"metal1\"],\n        )\n    )  # metal1 guardring\n\n    return c", "@gf.cell\ndef pcmpgr_gen(dn_rect=dn_rect, grw: float = 0.36) -> gf.Component:\n    \"\"\"Return deepnwell guardring\n\n    Args:\n        dn_rect : deepnwell polygon.\n        grw : guardring width.\n    \"\"\"\n\n    c = gf.Component()\n\n    dn_rect = gf.get_component(dn_rect)\n\n    comp_pp_enc: float = 0.16\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n    pcmpgr_enc_dn = 2.5\n\n    c_temp_gr = gf.Component(\"temp_store guard ring\")\n    rect_pcmpgr_in = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n            ),\n            layer=layer[\"comp\"],\n        )\n    )\n    rect_pcmpgr_in.move((dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn))\n    rect_pcmpgr_out = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * grw,\n                (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * grw,\n            ),\n            layer=layer[\"comp\"],\n        )\n    )\n    rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n    c.add_ref(\n        gf.geometry.boolean(\n            A=rect_pcmpgr_out,\n            B=rect_pcmpgr_in,\n            operation=\"A-B\",\n            layer=layer[\"comp\"],\n        )\n    )  # guardring bulk\n\n    psdm_in = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * comp_pp_enc,\n                (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * comp_pp_enc,\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    psdm_in.move(\n        (\n            rect_pcmpgr_in.xmin + comp_pp_enc,\n            rect_pcmpgr_in.ymin + comp_pp_enc,\n        )\n    )\n    psdm_out = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * comp_pp_enc,\n                (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * comp_pp_enc,\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    psdm_out.move(\n        (\n            rect_pcmpgr_out.xmin - comp_pp_enc,\n            rect_pcmpgr_out.ymin - comp_pp_enc,\n        )\n    )\n    c.add_ref(\n        gf.geometry.boolean(\n            A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n        )\n    )  # pplus_draw\n\n    # generating contacts\n\n    c.add_ref(\n        via_generator(\n            x_range=(\n                rect_pcmpgr_in.xmin + con_size,\n                rect_pcmpgr_in.xmax - con_size,\n            ),\n            y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # bottom contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(\n                rect_pcmpgr_in.xmin + con_size,\n                rect_pcmpgr_in.xmax - con_size,\n            ),\n            y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # upper contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n            y_range=(\n                rect_pcmpgr_in.ymin + con_size,\n                rect_pcmpgr_in.ymax - con_size,\n            ),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # right contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n            y_range=(\n                rect_pcmpgr_in.ymin + con_size,\n                rect_pcmpgr_in.ymax - con_size,\n            ),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # left contact\n\n    comp_m1_in = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n            layer=layer[\"metal1\"],\n        )\n    )\n\n    comp_m1_out = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (comp_m1_in.size[0]) + 2 * grw,\n                (comp_m1_in.size[1]) + 2 * grw,\n            ),\n            layer=layer[\"metal1\"],\n        )\n    )\n    comp_m1_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n    c.add_ref(\n        gf.geometry.boolean(\n            A=rect_pcmpgr_out,\n            B=rect_pcmpgr_in,\n            operation=\"A-B\",\n            layer=layer[\"metal1\"],\n        )\n    )  # metal1 guardring\n\n    return c", "\n\nif __name__ == \"__main__\":\n    c = pcmpgr_gen()\n    c.show()\n"]}
{"filename": "gf180/__init__.py", "chunked_list": ["import sys\n\nfrom gdsfactory.get_factories import get_cells\nfrom gdsfactory.pdk import Pdk\n\nfrom gf180 import config, diode, fet, layers\nfrom gf180.cap_mim import (\n    cap_mim,\n)\nfrom gf180.cap_mos import (", ")\nfrom gf180.cap_mos import (\n    cap_mos,\n    cap_mos_inst,\n)\nfrom gf180.config import PATH\nfrom gf180.diode import (\n    diode_dw2ps,\n    diode_nd2ps,\n    diode_nw2ps,", "    diode_nd2ps,\n    diode_nw2ps,\n    diode_pd2nw,\n    diode_pw2dw,\n    sc_diode,\n)\nfrom gf180.fet import (\n    add_gate_labels,\n    add_inter_sd_labels,\n    alter_interdig,", "    add_inter_sd_labels,\n    alter_interdig,\n    bulk_gr_gen,\n    get_patt_lbl,\n    hv_gen,\n    interdigit,\n    labels_gen,\n    nfet,\n    nfet_06v0_nvt,\n    nfet_deep_nwell,", "    nfet_06v0_nvt,\n    nfet_deep_nwell,\n    pfet,\n    pfet_deep_nwell,\n)\nfrom gf180.guardring import (\n    pcmpgr_gen,\n)\nfrom gf180.layers import LAYER, LAYER_VIEWS, LayerMap, layer\nfrom gf180.res import (", "from gf180.layers import LAYER, LAYER_VIEWS, LayerMap, layer\nfrom gf180.res import (\n    nplus_res,\n    npolyf_res,\n    plus_res_inst,\n    polyf_res_inst,\n    pplus_res,\n    ppolyf_res,\n    ppolyf_u_high_Rs_res,\n    res,", "    ppolyf_u_high_Rs_res,\n    res,\n    well_res,\n)\nfrom gf180.via_generator import (\n    via_generator,\n    via_stack,\n)\n\n__all__ = [", "\n__all__ = [\n    \"LAYER\",\n    \"LayerMap\",\n    \"PATH\",\n    \"add_gate_labels\",\n    \"add_inter_sd_labels\",\n    \"alter_interdig\",\n    \"bulk_gr_gen\",\n    \"cap_mim\",", "    \"bulk_gr_gen\",\n    \"cap_mim\",\n    \"cap_mos\",\n    \"cap_mos_inst\",\n    \"config\",\n    \"diode\",\n    \"diode_dw2ps\",\n    \"diode_nd2ps\",\n    \"diode_nw2ps\",\n    \"diode_pd2nw\",", "    \"diode_nw2ps\",\n    \"diode_pd2nw\",\n    \"diode_pw2dw\",\n    \"cap_mos\",\n    \"nplus_res\",\n    \"npolyf_res\",\n    \"pplus_res\",\n    \"ppolyf_res\",\n    \"ppolyf_u_high_Rs_res\",\n    \"well_res\",", "    \"ppolyf_u_high_Rs_res\",\n    \"well_res\",\n    \"fet\",\n    \"get_patt_lbl\",\n    \"hv_gen\",\n    \"interdigit\",\n    \"labels_gen\",\n    \"layer\",\n    \"layers\",\n    \"nfet\",", "    \"layers\",\n    \"nfet\",\n    \"nfet_06v0_nvt\",\n    \"nfet_deep_nwell\",\n    \"pcmpgr_gen\",\n    \"pfet\",\n    \"pfet_deep_nwell\",\n    \"plus_res_inst\",\n    \"polyf_res_inst\",\n    \"res\",", "    \"polyf_res_inst\",\n    \"res\",\n    \"sc_diode\",\n    \"via_generator\",\n    \"via_stack\",\n]\n__version__ = \"0.0.3\"\n\ncells = get_cells(sys.modules[__name__])\nPDK = Pdk(", "cells = get_cells(sys.modules[__name__])\nPDK = Pdk(\n    name=\"tj\",\n    cells=cells,\n    layers=LAYER.dict(),\n    layer_views=LAYER_VIEWS,\n    # layer_stack=LAYER_STACK,\n)\nPDK.activate()\n", "PDK.activate()\n"]}
{"filename": "gf180/via_generator.py", "chunked_list": ["from math import ceil, floor\n\nimport gdsfactory as gf\nfrom gdsfactory.typings import Float2, LayerSpec\n\nfrom gf180.layers import layer\n\n\n@gf.cell\ndef via_generator(\n    x_range: Float2 = (0, 1),\n    y_range: Float2 = (0, 1),\n    via_size: Float2 = (0.17, 0.17),\n    via_layer: LayerSpec = (66, 44),\n    via_enclosure: Float2 = (0.06, 0.06),\n    via_spacing: Float2 = (0.17, 0.17),\n) -> gf.Component:\n    \"\"\"\n    return only vias withen the range xrange and yrange while enclosing by via_enclosure\n    and set number of rows and number of coloumns according to ranges and via size and spacing\n    \"\"\"\n    c = gf.Component()\n\n    width = x_range[1] - x_range[0]\n    length = y_range[1] - y_range[0]\n    nr = floor(length / (via_size[1] + via_spacing[1]))\n    if (length - nr * via_size[1] - (nr - 1) * via_spacing[1]) / 2 < via_enclosure[1]:\n        nr -= 1\n\n    if nr < 1:\n        nr = 1\n\n    nc = ceil(width / (via_size[0] + via_spacing[0]))\n\n    if (\n        round(width - nc * via_size[0] - (nc - 1) * via_spacing[0], 2)\n    ) / 2 < via_enclosure[0]:\n        nc -= 1\n\n    if nc < 1:\n        nc = 1\n\n    via_sp = (via_size[0] + via_spacing[0], via_size[1] + via_spacing[1])\n\n    rect_via = gf.components.rectangle(size=via_size, layer=via_layer)\n\n    via_arr = c.add_array(rect_via, rows=nr, columns=nc, spacing=via_sp)\n\n    via_arr.move((x_range[0], y_range[0]))\n\n    via_arr.movex((width - nc * via_size[0] - (nc - 1) * via_spacing[0]) / 2)\n    via_arr.movey((length - nr * via_size[1] - (nr - 1) * via_spacing[1]) / 2)\n\n    return c", "@gf.cell\ndef via_generator(\n    x_range: Float2 = (0, 1),\n    y_range: Float2 = (0, 1),\n    via_size: Float2 = (0.17, 0.17),\n    via_layer: LayerSpec = (66, 44),\n    via_enclosure: Float2 = (0.06, 0.06),\n    via_spacing: Float2 = (0.17, 0.17),\n) -> gf.Component:\n    \"\"\"\n    return only vias withen the range xrange and yrange while enclosing by via_enclosure\n    and set number of rows and number of coloumns according to ranges and via size and spacing\n    \"\"\"\n    c = gf.Component()\n\n    width = x_range[1] - x_range[0]\n    length = y_range[1] - y_range[0]\n    nr = floor(length / (via_size[1] + via_spacing[1]))\n    if (length - nr * via_size[1] - (nr - 1) * via_spacing[1]) / 2 < via_enclosure[1]:\n        nr -= 1\n\n    if nr < 1:\n        nr = 1\n\n    nc = ceil(width / (via_size[0] + via_spacing[0]))\n\n    if (\n        round(width - nc * via_size[0] - (nc - 1) * via_spacing[0], 2)\n    ) / 2 < via_enclosure[0]:\n        nc -= 1\n\n    if nc < 1:\n        nc = 1\n\n    via_sp = (via_size[0] + via_spacing[0], via_size[1] + via_spacing[1])\n\n    rect_via = gf.components.rectangle(size=via_size, layer=via_layer)\n\n    via_arr = c.add_array(rect_via, rows=nr, columns=nc, spacing=via_sp)\n\n    via_arr.move((x_range[0], y_range[0]))\n\n    via_arr.movex((width - nc * via_size[0] - (nc - 1) * via_spacing[0]) / 2)\n    via_arr.movey((length - nr * via_size[1] - (nr - 1) * via_spacing[1]) / 2)\n\n    return c", "\n\n@gf.cell\ndef via_stack(\n    x_range: Float2 = (0, 1),\n    y_range: Float2 = (0, 1),\n    base_layer: LayerSpec = layer[\"comp\"],\n    slotted_licon: int = 0,\n    metal_level: int = 1,\n    li_enc_dir=\"V\",\n) -> gf.Component:\n    \"\"\"\n    return via stack till the metal level indicated where :\n    metal_level 1 : till m1\n    metal_level 2 : till m2\n    metal_level 3 : till m3\n    metal_level 4 : till m4\n    metal_level 5 : till m5\n    withen the range xrange and yrange and expecting the base_layer to be drawen\n\n    \"\"\"\n\n    c = gf.Component()\n\n    # vias dimensions\n\n    con_size = (0.22, 0.22)\n    con_enc = 0.07\n    m_enc = 0.06\n\n    con_spacing = (0.28, 0.28)\n\n    via_size = (0.22, 0.22)\n    via_spacing = (0.28, 0.28)\n    via_enc = (0.06, 0.06)\n\n    if metal_level >= 1:\n        con_gen = via_generator(\n            x_range=x_range,\n            y_range=y_range,\n            via_size=con_size,\n            via_enclosure=(con_enc, con_enc),\n            via_layer=layer[\"contact\"],\n            via_spacing=con_spacing,\n        )\n        con = c.add_ref(con_gen)\n\n        m1_x = con.size[0] + 2 * m_enc\n\n        m1_y = con.size[1] + 2 * m_enc\n\n        m1 = c.add_ref(\n            gf.components.rectangle(size=(m1_x, m1_y), layer=layer[\"metal1\"])\n        )\n        m1.xmin = con.xmin - m_enc\n        m1.ymin = con.ymin - m_enc\n\n    if metal_level >= 2:\n        via1_gen = via_generator(\n            x_range=(m1.xmin, m1.xmax),\n            y_range=(m1.ymin, m1.ymax),\n            via_size=via_size,\n            via_enclosure=via_enc,\n            via_layer=layer[\"via1\"],\n            via_spacing=via_spacing,\n        )\n        via1 = c.add_ref(via1_gen)\n\n        if (via1.xmax - via1.xmin + 2 * m_enc[0]) < (\n            via_size[0] + 2 * via_enc[0]\n        ) and metal_level >= 3:\n            m2_x = via_size[0] + 2 * via_enc[0]\n\n        else:\n            m2_x = via1.xmax - via1.xmin + 2 * m_enc[0]\n\n        if (via1.ymax - via1.ymin + 2 * m_enc[1]) < (\n            via_size[1] + 2 * via_enc[1]\n        ) and metal_level >= 3:\n            m2_y = via_size[1] + 2 * via_enc[1]\n\n        else:\n            m2_y = via1.ymax - via1.ymin + 2 * m_enc[1]\n\n        m2_mx = (m2_x - (via1.xmax - via1.xmin)) / 2\n        m2_my = (m2_y - (via1.ymax - via1.ymin)) / 2\n\n        m2 = c.add_ref(\n            gf.components.rectangle(size=(m2_x, m2_y), layer=layer[\"metal2\"])\n        )\n        m2.move((via1.xmin - m2_mx, via1.ymin - m2_my))\n\n    return c", "\n\nif __name__ == \"__main__\":\n    c = via_stack()\n    c.show()\n    # c = vias_gen_draw(start_layer=\"li\",end_layer=\"poly\")\n    # c.show()\n"]}
{"filename": "gf180/fet.py", "chunked_list": ["from math import ceil, floor\n\nimport gdsfactory as gf\nfrom gdsfactory.typings import Float2, LayerSpec, Optional, Strs\n\nfrom gf180.guardring import pcmpgr_gen\nfrom gf180.layers import layer\nfrom gf180.via_generator import via_generator, via_stack\n\n", "\n\n@gf.cell\ndef labels_gen(\n    lbl_str: str = \"\",\n    position: Float2 = (0.1, 0.1),\n    layer: LayerSpec = layer[\"metal1_label\"],\n    lbl: bool = 0,\n    labels: Optional[Strs] = None,\n    lbl_valid_len: int = 1,\n    index: int = 0,\n) -> gf.Component:\n    \"\"\"Returns labels at given position when lbl is enabled\n\n    Args :\n        lbl_str : string of the label.\n        position : position of the label.\n        layer : layer of the label.\n        lbl : boolean of having the label.\n        labels : list of given labels.\n        lbl_valid_len : valid length of labels.\n    \"\"\"\n\n    c = gf.Component()\n\n    if lbl == 1:\n        if len(labels) == lbl_valid_len:\n            if lbl_str == \"None\":\n                c.add_label(labels[index], position=position, layer=layer)\n            else:\n                c.add_label(lbl_str, position=position, layer=layer)\n\n    return c", "\n\ndef get_patt_lbl(nl_b, nl, nt, nt_e, g_lbl, nl_u, nt_o):\n    \"\"\"Returns list of odd,even gate label patterns for alternating gate connection\n\n    Args:\n        nl_b : number of bottom connected gates transistors.\n        nl : number of transistor.\n        nt : patterns of tansistor [with out redundency].\n        nt_e : number of transistor with even order.\n        g_lbl : list of transistors gate label.\n        nl_u :  number of upper connected gates transistors.\n        nt_o : number of transistor with odd order.\n    \"\"\"\n\n    g_lbl_e = []\n    g_lbl_o = []\n\n    if nt == len(g_lbl):\n        for i in range(nl_b):\n            for j in range(nl):\n                if nt[j] == nt_e[i]:\n                    g_lbl_e.append(g_lbl[j])\n\n        for i in range(nl_u):\n            for j in range(nl):\n                if nt[j] == nt_o[i]:\n                    g_lbl_o.append(g_lbl[j])\n\n    return [g_lbl_e, g_lbl_o]", "\n\n@gf.cell\ndef alter_interdig(\n    sd_diff,\n    pc1,\n    pc2,\n    poly_con,\n    sd_diff_intr,\n    l_gate=0.15,\n    inter_sd_l=0.15,\n    sd_l=0.36,\n    nf=1,\n    pat=\"\",\n    pc_x=0.1,\n    pc_spacing=0.1,\n    lbl: bool = 0,\n    g_lbl: list = [],\n    nl: int = 1,\n    patt_lbl: bool = 0,\n) -> gf.Component:\n    \"\"\"Returns interdigitation polygons of gate with alterating poly contacts\n\n    Args :\n        sd_diff : source/drain diffusion rectangle.\n        pc1 : first poly contact array.\n        pc2 : second poly contact array.\n        poly_con : componenet of poly contact.\n        sd_diff_inter : inter source/drain diffusion rectangle.\n        l_gate : gate length.\n        inter_sd_l : inter diffusion length.\n        nf : number of fingers.\n        pat : string of the required pattern.\n    \"\"\"\n\n    c_inst = gf.Component()\n\n    m2_spacing = 0.28\n    via_size = (0.26, 0.26)\n    via_enc = (0.06, 0.06)\n    via_spacing = (0.26, 0.26)\n\n    pat_o = []\n    pat_e = []\n\n    for i in range(int(nf)):\n        if i % 2 == 0:\n            pat_e.append(pat[i])\n        else:\n            pat_o.append(pat[i])\n\n    nt = []\n    [nt.append(x) for x in pat if x not in nt]\n\n    nt_o = []\n    [nt_o.append(x) for x in pat_o if x not in nt_o]\n\n    nt_e = []\n    [nt_e.append(x) for x in pat_e if x not in nt_e]\n\n    nl = len(nt)\n    nl_b = len(nt_e)\n    nl_u = len(nt_o)\n\n    g_lbl_e, g_lbl_o = get_patt_lbl(nl_b, nl, nt, nt_e, g_lbl, nl_u, nt_o)\n\n    m2_y = via_size[1] + 2 * via_enc[1]\n    m2 = gf.components.rectangle(\n        size=(sd_diff.xmax - sd_diff.xmin, m2_y),\n        layer=layer[\"metal2\"],\n    )\n\n    m2_arrb = c_inst.add_array(\n        component=m2,\n        columns=1,\n        rows=nl_b,\n        spacing=(0, -m2_y - m2_spacing),\n    )\n    m2_arrb.movey(pc1.ymin - m2_spacing - m2_y)\n\n    m2_arru = c_inst.add_array(\n        component=m2,\n        columns=1,\n        rows=nl_u,\n        spacing=(0, m2_y + m2_spacing),\n    )\n    m2_arru.movey(pc2.ymax + m2_spacing)\n\n    for i in range(nl_u):\n        for j in range(floor(nf / 2)):\n            if pat_o[j] == nt_o[i]:\n                m1 = c_inst.add_ref(\n                    gf.components.rectangle(\n                        size=(\n                            pc_x,\n                            ((pc2.ymax + (i + 1) * (m2_spacing + m2_y)) - pc2.ymin),\n                        ),\n                        layer=layer[\"metal1\"],\n                    )\n                )\n                m1.xmin = pc2.xmin + j * (pc_spacing)\n                m1.ymin = pc2.ymin\n\n                via1_dr = via_generator(\n                    x_range=(m1.xmin, m1.xmax),\n                    y_range=(\n                        m2_arru.ymin + i * (m2_y + m2_spacing),\n                        m2_arru.ymin + i * (m2_y + m2_spacing) + m2_y,\n                    ),\n                    via_enclosure=via_enc,\n                    via_layer=layer[\"via1\"],\n                    via_size=via_size,\n                    via_spacing=via_spacing,\n                )\n                via1 = c_inst.add_ref(via1_dr)\n\n                c_inst.add_ref(\n                    labels_gen(\n                        lbl_str=\"None\",\n                        position=(\n                            (via1.xmax + via1.xmin) / 2,\n                            (via1.ymax + via1.ymin) / 2,\n                        ),\n                        layer=layer[\"metal2_label\"],\n                        lbl=patt_lbl,\n                        labels=pat_o,\n                        lbl_valid_len=len(pat_o),\n                        index=j,\n                    )\n                )\n\n                # adding gate_label\n                c_inst.add_ref(\n                    labels_gen(\n                        lbl_str=\"None\",\n                        position=(\n                            m1.xmin + (m1.size[0] / 2),\n                            pc2.ymin + (pc2.size[1] / 2),\n                        ),\n                        layer=layer[\"metal1_label\"],\n                        lbl=lbl,\n                        labels=g_lbl_o,\n                        lbl_valid_len=nl_u,\n                        index=i,\n                    )\n                )\n\n    for i in range(nl_b):\n        for j in range(ceil(nf / 2)):\n            if pat_e[j] == nt_e[i]:\n                m1 = c_inst.add_ref(\n                    gf.components.rectangle(\n                        size=(\n                            # poly_con.xmax - poly_con.xmin,\n                            pc_x,\n                            ((pc1.ymax + (i + 1) * (m2_spacing + m2_y)) - pc1.ymin),\n                        ),\n                        layer=layer[\"metal1\"],\n                    )\n                )\n                m1.xmin = pc1.xmin + j * (pc_spacing)\n                m1.ymin = -(m1.ymax - m1.ymin) + (pc1.ymax)\n                via1_dr = via_generator(\n                    x_range=(m1.xmin, m1.xmax),\n                    y_range=(\n                        m2_arrb.ymax - i * (m2_spacing + m2_y) - m2_y,\n                        m2_arrb.ymax - i * (m2_spacing + m2_y),\n                    ),\n                    via_enclosure=via_enc,\n                    via_layer=layer[\"via1\"],\n                    via_size=via_size,\n                    via_spacing=via_spacing,\n                )\n                via1 = c_inst.add_ref(via1_dr)\n\n                c_inst.add_ref(\n                    labels_gen(\n                        lbl_str=\"None\",\n                        position=(\n                            (via1.xmax + via1.xmin) / 2,\n                            (via1.ymax + via1.ymin) / 2,\n                        ),\n                        layer=layer[\"metal2_label\"],\n                        lbl=patt_lbl,\n                        labels=pat_e,\n                        lbl_valid_len=len(pat_e),\n                        index=j,\n                    )\n                )\n\n                # adding gate_label\n                c_inst.add_ref(\n                    labels_gen(\n                        lbl_str=\"None\",\n                        position=(\n                            m1.xmin + (m1.size[0] / 2),\n                            pc1.ymin + (pc1.size[1] / 2),\n                        ),\n                        layer=layer[\"metal1_label\"],\n                        lbl=lbl,\n                        labels=g_lbl_e,\n                        lbl_valid_len=nl_b,\n                        index=i,\n                    )\n                )\n\n    m3_x = via_size[0] + 2 * via_enc[0]\n    m3_spacing = m2_spacing\n\n    for i in range(nl_b):\n        for j in range(nl_u):\n            if nt_e[i] == nt_o[j]:\n                m2_join_b = c_inst.add_ref(\n                    gf.components.rectangle(\n                        size=(\n                            m2_y + sd_l + (i + 1) * (m3_spacing + m3_x),\n                            m2_y,\n                        ),\n                        layer=layer[\"metal2\"],\n                    ).move(\n                        (\n                            m2_arrb.xmin\n                            - (m2_y + sd_l + (i + 1) * (m3_spacing + m3_x)),\n                            m2_arrb.ymax - i * (m2_spacing + m2_y) - m2_y,\n                        )\n                    )\n                )\n                m2_join_u = c_inst.add_ref(\n                    gf.components.rectangle(\n                        size=(\n                            m2_y + sd_l + (i + 1) * (m3_spacing + m3_x),\n                            m2_y,\n                        ),\n                        layer=layer[\"metal2\"],\n                    ).move(\n                        (\n                            m2_arru.xmin\n                            - (m2_y + sd_l + (i + 1) * (m3_spacing + m3_x)),\n                            m2_arru.ymin + j * (m2_spacing + m2_y),\n                        )\n                    )\n                )\n                m3 = c_inst.add_ref(\n                    gf.components.rectangle(\n                        size=(\n                            m3_x,\n                            m2_join_u.ymax - m2_join_b.ymin,\n                        ),\n                        layer=layer[\"metal1\"],\n                    )\n                )\n                m3.move((m2_join_b.xmin, m2_join_b.ymin))\n                via2_dr = via_generator(\n                    x_range=(m3.xmin, m3.xmax),\n                    y_range=(m2_join_b.ymin, m2_join_b.ymax),\n                    via_enclosure=via_enc,\n                    via_size=via_size,\n                    via_layer=layer[\"via1\"],\n                    via_spacing=via_spacing,\n                )\n                c_inst.add_array(\n                    component=via2_dr,\n                    columns=1,\n                    rows=2,\n                    spacing=(\n                        0,\n                        m2_join_u.ymin - m2_join_b.ymin,\n                    ),\n                )  # via2_draw\n    return c_inst", "\n\n@gf.cell\ndef interdigit(\n    sd_diff,\n    pc1,\n    pc2,\n    poly_con,\n    sd_diff_intr,\n    l_gate: float = 0.15,\n    inter_sd_l: float = 0.23,\n    sd_l: float = 0.15,\n    nf=1,\n    patt=[\"\"],\n    gate_con_pos=\"top\",\n    pc_x=0.1,\n    pc_spacing=0.1,\n    lbl: bool = 0,\n    g_lbl: Optional[Strs] = [],\n    patt_lbl: bool = 0,\n) -> gf.Component:\n    \"\"\"Returns interdigitation related polygons\n\n    Args :\n        sd_diff : source/drain diffusion rectangle.\n        pc1 : first poly contact array.\n        pc2 : second poly contact array.\n        poly_con : componenet of poly contact.\n        sd_diff_inter : inter source/drain diffusion rectangle.\n        l_gate : gate length.\n        inter_sd_l : inter diffusion length.\n        nf : number of fingers.\n        pat : string of the required pattern.\n        gate_con_pos : position of gate contact.\n    \"\"\"\n    c_inst = gf.Component()\n\n    if nf == len(patt):\n        pat = list(patt)\n        nt = (\n            []\n        )  # list to store the symbols of transistors and thier number nt(number of transistors)\n        [nt.append(x) for x in pat if x not in nt]\n        nl = int(len(nt))\n\n        m2_spacing = 0.28\n        via_size = (0.26, 0.26)\n        via_enc = (0.06, 0.06)\n        via_spacing = (0.26, 0.26)\n\n        m2_y = via_size[1] + 2 * via_enc[1]\n        m2 = gf.components.rectangle(\n            size=(sd_diff.xmax - sd_diff.xmin, m2_y), layer=layer[\"metal2\"]\n        )\n\n        if gate_con_pos == \"alternating\":\n            c_inst.add_ref(\n                alter_interdig(\n                    sd_diff=sd_diff,\n                    pc1=pc1,\n                    pc2=pc2,\n                    poly_con=poly_con,\n                    sd_diff_intr=sd_diff_intr,\n                    l_gate=l_gate,\n                    inter_sd_l=inter_sd_l,\n                    sd_l=sd_l,\n                    nf=nf,\n                    pat=pat,\n                    pc_x=pc_x,\n                    pc_spacing=pc_spacing,\n                    lbl=lbl,\n                    g_lbl=g_lbl,\n                    nl=nl,\n                    patt_lbl=patt_lbl,\n                )\n            )\n\n        elif gate_con_pos == \"top\":\n            m2_arr = c_inst.add_array(\n                component=m2,\n                columns=1,\n                rows=nl,\n                spacing=(0, m2.ymax - m2.ymin + m2_spacing),\n            )\n            m2_arr.movey(pc2.ymax + m2_spacing)\n\n            for i in range(nl):\n                for j in range(int(nf)):\n                    if pat[j] == nt[i]:\n                        m1 = c_inst.add_ref(\n                            gf.components.rectangle(\n                                size=(\n                                    pc_x,\n                                    # poly_con.xmax - poly_con.xmin,\n                                    (\n                                        (pc2.ymax + (i + 1) * (m2_spacing + m2_y))\n                                        - ((1 - j % 2) * pc1.ymin)\n                                        - (j % 2) * pc2.ymin\n                                    ),\n                                ),\n                                layer=layer[\"metal1\"],\n                            )\n                        )\n                        m1.xmin = pc1.xmin + j * (pc2.xmin - pc1.xmin)\n                        m1.ymin = pc1.ymin\n\n                        via1_dr = via_generator(\n                            x_range=(m1.xmin, m1.xmax),\n                            y_range=(\n                                m2_arr.ymin + i * (m2_spacing + m2_y),\n                                m2_arr.ymin + i * (m2_spacing + m2_y) + m2_y,\n                            ),\n                            via_enclosure=via_enc,\n                            via_layer=layer[\"via1\"],\n                            via_size=via_size,\n                            via_spacing=via_spacing,\n                        )\n                        via1 = c_inst.add_ref(via1_dr)\n\n                        c_inst.add_ref(\n                            labels_gen(\n                                lbl_str=\"None\",\n                                position=(\n                                    (via1.xmax + via1.xmin) / 2,\n                                    (via1.ymax + via1.ymin) / 2,\n                                ),\n                                layer=layer[\"metal2_label\"],\n                                lbl=patt_lbl,\n                                labels=pat,\n                                lbl_valid_len=nl,\n                                index=j,\n                            )\n                        )\n\n                        # adding gate_label\n                        c_inst.add_ref(\n                            labels_gen(\n                                lbl_str=\"None\",\n                                position=(\n                                    m1.xmin + (m1.size[0] / 2),\n                                    pc1.ymin + (pc1.size[1] / 2),\n                                ),\n                                layer=layer[\"metal1_label\"],\n                                lbl=lbl,\n                                labels=g_lbl,\n                                lbl_valid_len=nl,\n                                index=i,\n                            )\n                        )\n\n        elif gate_con_pos == \"bottom\":\n            m2_arr = c_inst.add_array(\n                component=m2,\n                columns=1,\n                rows=nl,\n                spacing=(0, -m2_y - m2_spacing),\n            )\n            m2_arr.movey(pc2.ymin - m2_spacing - m2_y)\n\n            for i in range(nl):\n                for j in range(int(nf)):\n                    if pat[j] == nt[i]:\n                        m1 = c_inst.add_ref(\n                            gf.components.rectangle(\n                                size=(\n                                    # poly_con.xmax - poly_con.xmin,\n                                    pc_x,\n                                    (\n                                        (pc1.ymax + (i + 1) * (m2_spacing + m2_y))\n                                        - (j % 2) * pc1.ymin\n                                        - (1 - j % 2) * pc2.ymin\n                                    ),\n                                ),\n                                layer=layer[\"metal1\"],\n                            )\n                        )\n                        m1.xmin = pc1.xmin + j * (pc2.xmin - pc1.xmin)\n                        m1.ymax = pc1.ymax\n\n                        via1_dr = via_generator(\n                            x_range=(m1.xmin, m1.xmax),\n                            y_range=(\n                                m2_arr.ymax - i * (m2_spacing + m2_y) - m2_y,\n                                m2_arr.ymax - i * (m2_spacing + m2_y),\n                            ),\n                            via_enclosure=via_enc,\n                            via_layer=layer[\"via1\"],\n                            via_size=via_size,\n                            via_spacing=via_spacing,\n                        )\n                        via1 = c_inst.add_ref(via1_dr)\n\n                        c_inst.add_ref(\n                            labels_gen(\n                                lbl_str=\"None\",\n                                position=(\n                                    (via1.xmax + via1.xmin) / 2,\n                                    (via1.ymax + via1.ymin) / 2,\n                                ),\n                                layer=layer[\"metal2_label\"],\n                                lbl=patt_lbl,\n                                labels=pat,\n                                lbl_valid_len=nl,\n                                index=j,\n                            )\n                        )\n\n                        # adding gate_label\n                        c_inst.add_ref(\n                            labels_gen(\n                                lbl_str=\"None\",\n                                position=(\n                                    m1.xmin + (m1.size[0] / 2),\n                                    pc1.ymin + (pc1.size[1] / 2),\n                                ),\n                                layer=layer[\"metal1_label\"],\n                                lbl=lbl,\n                                labels=g_lbl,\n                                lbl_valid_len=nl,\n                                index=i,\n                            )\n                        )\n\n    return c_inst", "\n\n# @gf.cell\ndef hv_gen(c, c_inst, volt, dg_encx: float = 0.1, dg_ency: float = 0.1):\n    \"\"\"Returns high volatge related polygons\n\n    Args :\n        c_inst : dualgate enclosed componenet\n        volt : operating voltage\n        dg_encx : dualgate enclosure in x_direction\n        dg_ency : dualgate enclosure in y_direction\n    \"\"\"\n    # c = gf.Component()\n\n    if volt == \"5V\" or volt == \"6V\":\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    c_inst.size[0] + (2 * dg_encx),\n                    c_inst.size[1] + (2 * dg_ency),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = c_inst.xmin - dg_encx\n        dg.ymin = c_inst.ymin - dg_ency\n\n        if volt == \"5V\":\n            v5x = c.add_ref(\n                gf.components.rectangle(\n                    size=(dg.size[0], dg.size[1]), layer=layer[\"v5_xtor\"]\n                )\n            )\n            v5x.xmin = dg.xmin\n            v5x.ymin = dg.ymin", "\n    # return c\n\n\ndef bulk_gr_gen(\n    c,\n    c_inst,\n    comp_spacing: float = 0.1,\n    poly2_comp_spacing: float = 0.1,\n    volt: str = \"3.3V\",\n    grw: float = 0.36,\n    l_d: float = 0.1,\n    implant_layer: LayerSpec = layer[\"pplus\"],\n    lbl: bool = 0,\n    sub_lbl: str = \"\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    nw_enc_pcmp: float = 0.1,\n):\n    \"\"\"Returns guardring\n\n    Args :\n        c_inst : componenet enclosed by guardring\n        comp_spacing : spacing between comp polygons\n        poly2_comp_spacing : spacing between comp and poly2 polygons\n        volt : operating voltage\n        grw : guardring width\n        l_d : total diffusion length\n        implant_layer : layer of comp implant (nplus,pplus)\n    \"\"\"\n\n    # c = gf.Component()\n\n    comp_pp_enc: float = 0.16\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n    dg_enc_cmp = 0.24\n\n    c_temp = gf.Component(\"temp_store\")\n    rect_bulk_in = c_temp.add_ref(\n        gf.components.rectangle(\n            size=(\n                (c_inst.xmax - c_inst.xmin) + 2 * comp_spacing,\n                (c_inst.ymax - c_inst.ymin) + 2 * poly2_comp_spacing,\n            ),\n            layer=layer[\"comp\"],\n        )\n    )\n    rect_bulk_in.move((c_inst.xmin - comp_spacing, c_inst.ymin - poly2_comp_spacing))\n    rect_bulk_out = c_temp.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n                (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n            ),\n            layer=layer[\"comp\"],\n        )\n    )\n    rect_bulk_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n    B = c.add_ref(\n        gf.geometry.boolean(\n            A=rect_bulk_out,\n            B=rect_bulk_in,\n            operation=\"A-B\",\n            layer=layer[\"comp\"],\n        )\n    )\n\n    psdm_in = c_temp.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_bulk_in.xmax - rect_bulk_in.xmin) - 2 * comp_pp_enc,\n                (rect_bulk_in.ymax - rect_bulk_in.ymin) - 2 * comp_pp_enc,\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    psdm_in.move((rect_bulk_in.xmin + comp_pp_enc, rect_bulk_in.ymin + comp_pp_enc))\n    psdm_out = c_temp.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_bulk_out.xmax - rect_bulk_out.xmin) + 2 * comp_pp_enc,\n                (rect_bulk_out.ymax - rect_bulk_out.ymin) + 2 * comp_pp_enc,\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    psdm_out.move(\n        (\n            rect_bulk_out.xmin - comp_pp_enc,\n            rect_bulk_out.ymin - comp_pp_enc,\n        )\n    )\n    c.add_ref(\n        gf.geometry.boolean(A=psdm_out, B=psdm_in, operation=\"A-B\", layer=implant_layer)\n    )  # implant_draw(pplus or nplus)\n\n    # generating contacts\n\n    c.add_ref(\n        via_generator(\n            x_range=(\n                rect_bulk_in.xmin + con_size,\n                rect_bulk_in.xmax - con_size,\n            ),\n            y_range=(rect_bulk_out.ymin, rect_bulk_in.ymin),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # bottom contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(\n                rect_bulk_in.xmin + con_size,\n                rect_bulk_in.xmax - con_size,\n            ),\n            y_range=(rect_bulk_in.ymax, rect_bulk_out.ymax),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # upper contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(rect_bulk_out.xmin, rect_bulk_in.xmin),\n            y_range=(\n                rect_bulk_in.ymin + con_size,\n                rect_bulk_in.ymax - con_size,\n            ),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # right contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(rect_bulk_in.xmax, rect_bulk_out.xmax),\n            y_range=(\n                rect_bulk_in.ymin + con_size,\n                rect_bulk_in.ymax - con_size,\n            ),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # left contact\n\n    comp_m1_in = c_temp.add_ref(\n        gf.components.rectangle(\n            size=(\n                (l_d) + 2 * comp_spacing,\n                (c_inst.ymax - c_inst.ymin) + 2 * poly2_comp_spacing,\n            ),\n            layer=layer[\"metal1\"],\n        )\n    )\n    comp_m1_in.move((-comp_spacing, c_inst.ymin - poly2_comp_spacing))\n    comp_m1_out = c_temp.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n                (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n            ),\n            layer=layer[\"metal1\"],\n        )\n    )\n    comp_m1_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n    c.add_ref(\n        gf.geometry.boolean(\n            A=rect_bulk_out,\n            B=rect_bulk_in,\n            operation=\"A-B\",\n            layer=layer[\"metal1\"],\n        )\n    )  # metal1_gaurdring\n\n    # c.add_ref(hv_gen(c_inst=B, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_cmp))\n    hv_gen(c, c_inst=B, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_cmp)\n\n    c.add_ref(\n        labels_gen(\n            lbl_str=sub_lbl,\n            position=(\n                B.xmin + (grw + 2 * (comp_pp_enc)) / 2,\n                B.ymin + (B.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n            lbl=lbl,\n            labels=[sub_lbl],\n            lbl_valid_len=1,\n        )\n    )\n\n    if implant_layer == layer[\"pplus\"]:\n        c.add_ref(\n            nfet_deep_nwell(\n                deepnwell=deepnwell,\n                pcmpgr=pcmpgr,\n                inst_size=(B.size[0], B.size[1]),\n                inst_xmin=B.xmin,\n                inst_ymin=B.ymin,\n                grw=grw,\n            )\n        )\n    else:\n        c.add_ref(\n            pfet_deep_nwell(\n                deepnwell=deepnwell,\n                pcmpgr=pcmpgr,\n                enc_size=(B.size[0], B.size[1]),\n                enc_xmin=B.xmin,\n                enc_ymin=B.ymin,\n                nw_enc_pcmp=nw_enc_pcmp,\n                grw=grw,\n            )\n        )", "\n    # return c\n\n\n@gf.cell\ndef nfet_deep_nwell(\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    inst_size: Float2 = (0.1, 0.1),\n    inst_xmin: float = 0.1,\n    inst_ymin: float = 0.1,\n    grw: float = 0.36,\n) -> gf.Component:\n    \"\"\"Return nfet deepnwell\n\n    Args :\n        deepnwell : boolean of having deepnwell\n        pcmpgr : boolean of having deepnwell guardring\n        inst_size : deepnwell enclosed size\n        inst_xmin : deepnwell enclosed xmin\n        inst_ymin : deepnwell enclosed ymin\n        grw : guardring width\n    \"\"\"\n\n    c = gf.Component()\n\n    dn_enc_lvpwell = 2.5\n    lvpwell_enc_ncmp = 0.43\n\n    if deepnwell == 1:\n        lvp_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    inst_size[0] + (2 * lvpwell_enc_ncmp),\n                    inst_size[1] + (2 * lvpwell_enc_ncmp),\n                ),\n                layer=layer[\"lvpwell\"],\n            )\n        )\n\n        lvp_rect.xmin = inst_xmin - lvpwell_enc_ncmp\n        lvp_rect.ymin = inst_ymin - lvpwell_enc_ncmp\n\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    lvp_rect.size[0] + (2 * dn_enc_lvpwell),\n                    lvp_rect.size[1] + (2 * dn_enc_lvpwell),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n\n        dn_rect.xmin = lvp_rect.xmin - dn_enc_lvpwell\n        dn_rect.ymin = lvp_rect.ymin - dn_enc_lvpwell\n\n        if pcmpgr == 1:\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=grw))\n\n    return c", "\n\ndef add_inter_sd_labels(\n    c, nf, sd_lbl, poly1, l_gate, inter_sd_l, sd_diff_intr, lbl, layer, con_bet_fin\n):\n    \"\"\"Adds label to intermediate source/drain diffusion\n\n    Args :\n        c : instance componenet of the device\n        nf : number of fingers\n        sd_lbl : required source and drain labels list\n        poly1 : componenet of poly array\n        l_gate : length of fet gate\n        inter_sd_l : length of intermediate source/drain diffusion\n        sd_diff_inter : componenet of intermediate source/drain polygon\n        lbl: boolean of having labels\n        layer : layer of label\n        con_bet_fin : boolean of having contact between fingers\n    \"\"\"\n\n    if con_bet_fin == 1:\n        lbl_layer = layer[\"metal1_label\"]\n    else:\n        lbl_layer = layer[\"comp_label\"]\n\n    for i in range(int(nf - 1)):\n        c.add_ref(\n            labels_gen(\n                lbl_str=\"None\",\n                position=(\n                    poly1.xmin + l_gate + (inter_sd_l / 2) + i * (l_gate + inter_sd_l),\n                    sd_diff_intr.ymin + (sd_diff_intr.size[1] / 2),\n                ),\n                layer=lbl_layer,\n                lbl=lbl,\n                labels=sd_lbl,\n                lbl_valid_len=nf + 1,\n                index=i + 1,\n            )\n        )", "\n\ndef add_gate_labels(c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf):\n    \"\"\"Adds gate label when lbl is enabled\n\n    Args :\n        c : instance componenet of the device\n        g_lbl : required gate labels list\n        pc1 : componenet of poly array1\n        c_pc : componenet of poly array element\n        pc_spacing : float of space between labels\n        nc1 : number of columns in poly array1\n        nc2 : number of columns in poly array2\n        pc2 : componenet of poly array2\n        lbl : boolean of having labels\n        layer : layer of labels\n        nf : number of fingers\n    \"\"\"\n\n    for i in range(nc1):\n        c.add_ref(\n            labels_gen(\n                lbl_str=\"None\",\n                position=(\n                    pc1.xmin + (c_pc.size[0] / 2) + i * (pc_spacing),\n                    pc1.ymin + (c_pc.size[1] / 2),\n                ),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                labels=g_lbl,\n                lbl_valid_len=nf,\n                index=2 * i,\n            )\n        )\n\n    for i in range(nc2):\n        c.add_ref(\n            labels_gen(\n                lbl_str=\"None\",\n                position=(\n                    pc2.xmin + (c_pc.size[0] / 2) + i * (pc_spacing),\n                    pc2.ymin + (c_pc.size[1] / 2),\n                ),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                labels=g_lbl,\n                lbl_valid_len=nf,\n                index=(2 * i) + 1,\n            )\n        )", "\n\n@gf.cell\ndef nfet(\n    l_gate: float = 0.28,\n    w_gate: float = 0.22,\n    sd_con_col: int = 1,\n    inter_sd_l: float = 0.24,\n    nf: int = 1,\n    grw: float = 0.22,\n    volt: str = \"3.3V\",\n    bulk=\"None\",\n    con_bet_fin: int = 1,\n    gate_con_pos=\"alternating\",\n    interdig: int = 0,\n    patt=\"\",\n    deepnwell: int = 0,\n    pcmpgr: int = 0,\n    lbl: bool = 0,\n    sd_lbl: Optional[Strs] = [],\n    g_lbl: str = [],\n    sub_lbl: str = \"\",\n    patt_lbl: bool = 0,\n) -> gf.Component:\n    \"\"\"\n    Return nfet\n\n    Args:\n        l : Float of gate length\n        w : Float of gate width\n        sd_l : Float of source and drain diffusion length\n        inter_sd_l : Float of source and drain diffusion length between fingers\n        nf : integer of number of fingers\n        M : integer of number of multipliers\n        grw : gaurd ring width when enabled\n        type : string of the device type\n        bulk : String of bulk connection type (None, Bulk Tie, Guard Ring)\n        con_bet_fin : boolean of having contacts for diffusion between fingers\n        gate_con_pos : string of choosing the gate contact position (bottom, top, alternating )\n\n    \"\"\"\n    # used layers and dimensions\n\n    end_cap: float = 0.22\n    if volt == \"3.3V\":\n        comp_spacing: float = 0.28\n    else:\n        comp_spacing: float = 0.36\n\n    gate_np_enc: float = 0.23\n    comp_np_enc: float = 0.16\n    comp_pp_enc: float = 0.16\n    poly2_spacing: float = 0.24\n    pc_ext: float = 0.04\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n    con_pl_enc = 0.07\n    dg_enc_cmp = 0.24\n    dg_enc_poly = 0.4\n\n    sd_l_con = (\n        ((sd_con_col) * con_size) + ((sd_con_col - 1) * con_sp) + 2 * con_comp_enc\n    )\n    sd_l = sd_l_con\n\n    # gds components to store a single instance and the generated device\n    c = gf.Component(\"sky_nfet_dev\")\n\n    c_inst = gf.Component(\"dev_temp\")\n\n    # generating sd diffusion\n\n    if interdig == 1 and nf > 1 and nf != len(patt) and patt != \"\":\n        nf = len(patt)\n\n    l_d = (\n        nf * l_gate + (nf - 1) * inter_sd_l + 2 * (con_comp_enc)\n    )  # diffution total length\n    rect_d_intr = gf.components.rectangle(size=(l_d, w_gate), layer=layer[\"comp\"])\n    sd_diff_intr = c_inst.add_ref(rect_d_intr)\n\n    #     # generatin sd contacts\n\n    if w_gate <= con_size + 2 * con_comp_enc:\n        cmpc_y = con_comp_enc + con_size + con_comp_enc\n\n    else:\n        cmpc_y = w_gate\n\n    cmpc_size = (sd_l_con, cmpc_y)\n\n    sd_diff = c_inst.add_array(\n        component=gf.components.rectangle(size=cmpc_size, layer=layer[\"comp\"]),\n        rows=1,\n        columns=2,\n        spacing=(cmpc_size[0] + sd_diff_intr.size[0], 0),\n    )\n\n    sd_diff.xmin = sd_diff_intr.xmin - cmpc_size[0]\n    sd_diff.ymin = sd_diff_intr.ymin - (sd_diff.size[1] - sd_diff_intr.size[1]) / 2\n\n    sd_con = via_stack(\n        x_range=(sd_diff.xmin, sd_diff_intr.xmin),\n        y_range=(sd_diff.ymin, sd_diff.ymax),\n        base_layer=layer[\"comp\"],\n        metal_level=1,\n    )\n    c_inst.add_array(\n        component=sd_con,\n        columns=2,\n        rows=1,\n        spacing=(\n            sd_l + nf * l_gate + (nf - 1) * inter_sd_l + 2 * (con_comp_enc),\n            0,\n        ),\n    )\n\n    if con_bet_fin == 1 and nf > 1:\n        inter_sd_con = via_stack(\n            x_range=(\n                sd_diff_intr.xmin + con_comp_enc + l_gate,\n                sd_diff_intr.xmin + con_comp_enc + l_gate + inter_sd_l,\n            ),\n            y_range=(0, w_gate),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n        c_inst.add_array(\n            component=inter_sd_con,\n            columns=nf - 1,\n            rows=1,\n            spacing=(l_gate + inter_sd_l, 0),\n        )\n\n    ### adding source/drain labels\n    c.add_ref(\n        labels_gen(\n            lbl_str=\"None\",\n            position=(sd_diff.xmin + (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n            layer=layer[\"metal1_label\"],\n            lbl=lbl,\n            labels=sd_lbl,\n            lbl_valid_len=nf + 1,\n            index=0,\n        )\n    )\n\n    c.add_ref(\n        labels_gen(\n            lbl_str=\"None\",\n            position=(sd_diff.xmax - (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n            layer=layer[\"metal1_label\"],\n            lbl=lbl,\n            labels=sd_lbl,\n            lbl_valid_len=nf + 1,\n            index=nf,\n        )\n    )\n\n    # generating poly\n\n    if l_gate <= con_size + 2 * con_pl_enc:\n        pc_x = con_pl_enc + con_size + con_pl_enc\n\n    else:\n        pc_x = l_gate\n\n    pc_size = (pc_x, con_pl_enc + con_size + con_pl_enc)\n\n    c_pc = gf.Component(\"poly con\")\n\n    rect_pc = c_pc.add_ref(gf.components.rectangle(size=pc_size, layer=layer[\"poly2\"]))\n\n    poly_con = via_stack(\n        x_range=(rect_pc.xmin, rect_pc.xmax),\n        y_range=(rect_pc.ymin, rect_pc.ymax),\n        base_layer=layer[\"poly2\"],\n        metal_level=1,\n        li_enc_dir=\"H\",\n    )\n    c_pc.add_ref(poly_con)\n\n    if nf == 1:\n        poly = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(l_gate, w_gate + 2 * end_cap), layer=layer[\"poly2\"]\n            )\n        )\n        poly.xmin = sd_diff_intr.xmin + con_comp_enc\n        poly.ymin = sd_diff_intr.ymin - end_cap\n\n        if gate_con_pos == \"bottom\":\n            mv = 0\n            nr = 1\n        elif gate_con_pos == \"top\":\n            mv = pc_size[1] + w_gate + 2 * end_cap\n            nr = 1\n        else:\n            mv = 0\n            nr = 2\n\n        pc = c_inst.add_array(\n            component=c_pc,\n            rows=nr,\n            columns=1,\n            spacing=(0, pc_size[1] + w_gate + 2 * end_cap),\n        )\n        pc.move((poly.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv))\n\n        # gate_lablel\n        c.add_ref(\n            labels_gen(\n                lbl_str=\"None\",\n                position=(pc.xmin + c_pc.size[0] / 2, pc.ymin + c_pc.size[1] / 2),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                labels=g_lbl,\n                lbl_valid_len=nf,\n                index=0,\n            )\n        )\n\n    else:\n        w_p1 = end_cap + w_gate + end_cap  # poly total width\n\n        if inter_sd_l < (poly2_spacing + 2 * pc_ext):\n            if gate_con_pos == \"alternating\":\n                w_p1 += 0.2\n                w_p2 = w_p1\n                e_c = 0.2\n            else:\n                w_p2 = w_p1 + con_pl_enc + con_size + con_pl_enc + poly2_spacing + 0.1\n                e_c = 0\n\n            if gate_con_pos == \"bottom\":\n                p_mv = -end_cap - (w_p2 - w_p1)\n            else:\n                p_mv = -end_cap\n\n        else:\n            w_p2 = w_p1\n            p_mv = -end_cap\n            e_c = 0\n\n        rect_p1 = gf.components.rectangle(size=(l_gate, w_p1), layer=layer[\"poly2\"])\n        rect_p2 = gf.components.rectangle(size=(l_gate, w_p2), layer=layer[\"poly2\"])\n        poly1 = c_inst.add_array(\n            rect_p1,\n            rows=1,\n            columns=ceil(nf / 2),\n            spacing=[2 * (inter_sd_l + l_gate), 0],\n        )\n        poly1.xmin = sd_diff_intr.xmin + con_comp_enc\n        poly1.ymin = sd_diff_intr.ymin - end_cap - e_c\n\n        poly2 = c_inst.add_array(\n            rect_p2,\n            rows=1,\n            columns=floor(nf / 2),\n            spacing=[2 * (inter_sd_l + l_gate), 0],\n        )\n        poly2.xmin = poly1.xmin + l_gate + inter_sd_l\n        poly2.ymin = p_mv\n\n        # generating poly contacts setups\n\n        if gate_con_pos == \"bottom\":\n            mv_1 = 0\n            mv_2 = -(w_p2 - w_p1)\n        elif gate_con_pos == \"top\":\n            mv_1 = pc_size[1] + w_p1\n            mv_2 = pc_size[1] + w_p2\n        else:\n            mv_1 = -e_c\n            mv_2 = pc_size[1] + w_p2\n\n        nc1 = ceil(nf / 2)\n        nc2 = floor(nf / 2)\n\n        pc_spacing = 2 * (inter_sd_l + l_gate)\n\n        # generating poly contacts\n\n        pc1 = c_inst.add_array(\n            component=c_pc, rows=1, columns=nc1, spacing=(pc_spacing, 0)\n        )\n        pc1.move((poly1.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv_1))\n\n        pc2 = c_inst.add_array(\n            component=c_pc, rows=1, columns=nc2, spacing=(pc_spacing, 0)\n        )\n        pc2.move(\n            (\n                poly1.xmin - ((pc_x - l_gate) / 2) + (inter_sd_l + l_gate),\n                -pc_size[1] - end_cap + mv_2,\n            )\n        )\n\n        add_inter_sd_labels(\n            c,\n            nf,\n            sd_lbl,\n            poly1,\n            l_gate,\n            inter_sd_l,\n            sd_diff_intr,\n            lbl,\n            layer,\n            con_bet_fin,\n        )\n\n        # add_gate_labels(c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf)\n\n        if interdig == 1:\n            c_inst.add_ref(\n                interdigit(\n                    sd_diff=sd_diff,\n                    pc1=pc1,\n                    pc2=pc2,\n                    poly_con=poly_con,\n                    sd_diff_intr=sd_diff_intr,\n                    l_gate=l_gate,\n                    inter_sd_l=inter_sd_l,\n                    sd_l=sd_l,\n                    nf=nf,\n                    patt=patt,\n                    gate_con_pos=gate_con_pos,\n                    pc_x=pc_x,\n                    pc_spacing=pc_spacing,\n                    lbl=lbl,\n                    g_lbl=g_lbl,\n                    patt_lbl=patt_lbl,\n                )\n            )\n        else:\n            add_gate_labels(\n                c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf\n            )\n\n    # generating bulk\n    if bulk == \"None\":\n        nplus = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_np_enc),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nplus.xmin = sd_diff.xmin - comp_np_enc\n        nplus.ymin = sd_diff_intr.ymin - gate_np_enc\n\n    elif bulk == \"Bulk Tie\":\n        rect_bulk = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_l + con_sp, sd_diff.size[1]), layer=layer[\"comp\"]\n            )\n        )\n        rect_bulk.xmin = sd_diff.xmax\n        rect_bulk.ymin = sd_diff.ymin\n        nsdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(\n                    sd_diff.xmax - sd_diff.xmin + comp_np_enc,\n                    w_gate + 2 * gate_np_enc,\n                ),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nsdm.xmin = sd_diff.xmin - comp_np_enc\n        nsdm.ymin = sd_diff_intr.ymin - gate_np_enc\n        psdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(\n                    rect_bulk.xmax - rect_bulk.xmin + comp_pp_enc,\n                    w_gate + 2 * comp_pp_enc,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm.connect(\"e1\", destination=nsdm.ports[\"e3\"])\n\n        bulk_con = via_stack(\n            x_range=(rect_bulk.xmin + 0.1, rect_bulk.xmax - 0.1),\n            y_range=(rect_bulk.ymin, rect_bulk.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n        c_inst.add_ref(bulk_con)\n\n        c.add_ref(\n            labels_gen(\n                lbl_str=sub_lbl,\n                position=(\n                    bulk_con.xmin + bulk_con.size[0] / 2,\n                    bulk_con.ymin + bulk_con.size[1] / 2,\n                ),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                labels=[sub_lbl],\n                lbl_valid_len=1,\n            )\n        )\n\n    if bulk == \"Guard Ring\":\n        nsdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_np_enc),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nsdm.xmin = sd_diff.xmin - comp_np_enc\n        nsdm.ymin = sd_diff_intr.ymin - gate_np_enc\n        c.add_ref(c_inst)\n\n        # b_gr = c.add_ref(\n        bulk_gr_gen(\n            c,\n            c_inst=c_inst,\n            comp_spacing=comp_spacing,\n            poly2_comp_spacing=comp_spacing,\n            volt=volt,\n            grw=grw,\n            l_d=l_d,\n            implant_layer=layer[\"pplus\"],\n            lbl=lbl,\n            sub_lbl=sub_lbl,\n            deepnwell=deepnwell,\n            pcmpgr=pcmpgr,\n        )\n\n    # if bulk != \"Guard Ring\":\n    else:\n        c.add_ref(c_inst)\n\n        inst_size = (c_inst.size[0], c_inst.size[1])\n        inst_xmin = c_inst.xmin\n        inst_ymin = c_inst.ymin\n\n        # c.add_ref(\n        #     hv_gen(c_inst=c_inst, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_poly)\n        # )\n        hv_gen(c, c_inst=c_inst, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_poly)\n\n        c.add_ref(\n            nfet_deep_nwell(\n                deepnwell=deepnwell,\n                pcmpgr=pcmpgr,\n                inst_size=inst_size,\n                inst_xmin=inst_xmin,\n                inst_ymin=inst_ymin,\n                grw=grw,\n            )\n        )\n\n    return c", "\n\n@gf.cell\ndef pfet_deep_nwell(\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    enc_size: Float2 = (0.1, 0.1),\n    enc_xmin: float = 0.1,\n    enc_ymin: float = 0.1,\n    nw_enc_pcmp: float = 0.1,\n    grw: float = 0.36,\n) -> gf.Component:\n    \"\"\"Returns pfet well related polygons\n\n    Args :\n        deepnwell : boolaen of having deepnwell\n        pcmpgr : boolean of having deepnwell guardring\n        enc_size : enclosed size\n        enc_xmin : enclosed xmin\n        enc_ymin : enclosed ymin\n        nw_enc_pcmp : nwell enclosure of pcomp\n        grw : guardring width\n    \"\"\"\n\n    c = gf.Component()\n\n    dnwell_enc_pcmp = 1.1\n\n    if deepnwell == 1:\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    enc_size[0] + (2 * dnwell_enc_pcmp),\n                    enc_size[1] + (2 * dnwell_enc_pcmp),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n\n        dn_rect.xmin = enc_xmin - dnwell_enc_pcmp\n        dn_rect.ymin = enc_ymin - dnwell_enc_pcmp\n\n        if pcmpgr == 1:\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=grw))\n\n    else:\n        # nwell generation\n        nw = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    enc_size[0] + (2 * nw_enc_pcmp),\n                    enc_size[1] + (2 * nw_enc_pcmp),\n                ),\n                layer=layer[\"nwell\"],\n            )\n        )\n        nw.xmin = enc_xmin - nw_enc_pcmp\n        nw.ymin = enc_ymin - nw_enc_pcmp\n\n    return c", "\n\n# @gf.cell\ndef pfet(\n    l_gate: float = 0.28,\n    w_gate: float = 0.22,\n    sd_con_col: int = 1,\n    inter_sd_l: float = 0.24,\n    nf: int = 1,\n    grw: float = 0.22,\n    volt: str = \"3.3V\",\n    bulk=\"None\",\n    con_bet_fin: int = 1,\n    gate_con_pos=\"alternating\",\n    interdig: int = 0,\n    patt=\"\",\n    deepnwell: int = 0,\n    pcmpgr: int = 0,\n    lbl: bool = 0,\n    sd_lbl: Optional[Strs] = [],\n    g_lbl: str = [],\n    sub_lbl: str = \"\",\n    patt_lbl: bool = 0,\n) -> gf.Component:\n    \"\"\"\n    Return pfet\n\n    Args:\n        l : Float of gate length\n        w : Float of gate width\n        sd_l : Float of source and drain diffusion length\n        inter_sd_l : Float of source and drain diffusion length between fingers\n        nf : integer of number of fingers\n        M : integer of number of multipliers\n        grw : gaurd ring width when enabled\n        type : string of the device type\n        bulk : String of bulk connection type (None, Bulk Tie, Guard Ring)\n        con_bet_fin : boolean of having contacts for diffusion between fingers\n        gate_con_pos : string of choosing the gate contact position (bottom, top, alternating )\n\n    \"\"\"\n    # used layers and dimensions\n\n    end_cap: float = 0.22\n    if volt == \"3.3V\":\n        comp_spacing: float = 0.28\n        nw_enc_pcmp = 0.43\n    else:\n        comp_spacing: float = 0.36\n        nw_enc_pcmp = 0.6\n\n    gate_pp_enc: float = 0.23\n    comp_np_enc: float = 0.16\n    comp_pp_enc: float = 0.16\n    poly2_spacing: float = 0.24\n    pc_ext: float = 0.04\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n    con_pl_enc = 0.07\n    dg_enc_cmp = 0.24\n    dg_enc_poly = 0.4\n\n    sd_l_con = (\n        ((sd_con_col) * con_size) + ((sd_con_col - 1) * con_sp) + 2 * con_comp_enc\n    )\n    sd_l = sd_l_con\n\n    # gds components to store a single instance and the generated device\n    c = gf.Component(\"sky_pfet_dev\")\n\n    c_inst = gf.Component(\"dev_temp\")\n\n    # generating sd diffusion\n\n    if interdig == 1 and nf > 1 and nf != len(patt) and patt != \"\":\n        nf = len(patt)\n\n    l_d = (\n        nf * l_gate + (nf - 1) * inter_sd_l + 2 * (con_comp_enc)\n    )  # diffution total length\n    rect_d_intr = gf.components.rectangle(size=(l_d, w_gate), layer=layer[\"comp\"])\n    sd_diff_intr = c_inst.add_ref(rect_d_intr)\n\n    # generatin sd contacts\n\n    if w_gate <= con_size + 2 * con_comp_enc:\n        cmpc_y = con_comp_enc + con_size + con_comp_enc\n\n    else:\n        cmpc_y = w_gate\n\n    cmpc_size = (sd_l_con, cmpc_y)\n\n    sd_diff = c_inst.add_array(\n        component=gf.components.rectangle(size=cmpc_size, layer=layer[\"comp\"]),\n        rows=1,\n        columns=2,\n        spacing=(cmpc_size[0] + sd_diff_intr.size[0], 0),\n    )\n\n    sd_diff.xmin = sd_diff_intr.xmin - cmpc_size[0]\n    sd_diff.ymin = sd_diff_intr.ymin - (sd_diff.size[1] - sd_diff_intr.size[1]) / 2\n\n    sd_con = via_stack(\n        x_range=(sd_diff.xmin, sd_diff_intr.xmin),\n        y_range=(sd_diff.ymin, sd_diff.ymax),\n        base_layer=layer[\"comp\"],\n        metal_level=1,\n    )\n    c_inst.add_array(\n        component=sd_con,\n        columns=2,\n        rows=1,\n        spacing=(\n            sd_l + nf * l_gate + (nf - 1) * inter_sd_l + 2 * (con_comp_enc),\n            0,\n        ),\n    )\n\n    if con_bet_fin == 1 and nf > 1:\n        inter_sd_con = via_stack(\n            x_range=(\n                sd_diff_intr.xmin + con_comp_enc + l_gate,\n                sd_diff_intr.xmin + con_comp_enc + l_gate + inter_sd_l,\n            ),\n            y_range=(0, w_gate),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n        c_inst.add_array(\n            component=inter_sd_con,\n            columns=nf - 1,\n            rows=1,\n            spacing=(l_gate + inter_sd_l, 0),\n        )\n\n    ### adding source/drain labels\n    c.add_ref(\n        labels_gen(\n            lbl_str=\"None\",\n            position=(sd_diff.xmin + (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n            layer=layer[\"metal1_label\"],\n            lbl=lbl,\n            labels=sd_lbl,\n            lbl_valid_len=nf + 1,\n            index=0,\n        )\n    )\n\n    c.add_ref(\n        labels_gen(\n            lbl_str=\"None\",\n            position=(sd_diff.xmax - (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n            layer=layer[\"metal1_label\"],\n            lbl=lbl,\n            labels=sd_lbl,\n            lbl_valid_len=nf + 1,\n            index=nf,\n        )\n    )\n\n    # generating poly\n\n    if l_gate <= con_size + 2 * con_pl_enc:\n        pc_x = con_pl_enc + con_size + con_pl_enc\n\n    else:\n        pc_x = l_gate\n\n    pc_size = (pc_x, con_pl_enc + con_size + con_pl_enc)\n\n    c_pc = gf.Component(\"poly con\")\n\n    rect_pc = c_pc.add_ref(gf.components.rectangle(size=pc_size, layer=layer[\"poly2\"]))\n\n    poly_con = via_stack(\n        x_range=(rect_pc.xmin, rect_pc.xmax),\n        y_range=(rect_pc.ymin, rect_pc.ymax),\n        base_layer=layer[\"poly2\"],\n        metal_level=1,\n        li_enc_dir=\"H\",\n    )\n    c_pc.add_ref(poly_con)\n\n    if nf == 1:\n        poly = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(l_gate, w_gate + 2 * end_cap), layer=layer[\"poly2\"]\n            )\n        )\n        poly.xmin = sd_diff_intr.xmin + con_comp_enc\n        poly.ymin = sd_diff_intr.ymin - end_cap\n\n        if gate_con_pos == \"bottom\":\n            mv = 0\n            nr = 1\n        elif gate_con_pos == \"top\":\n            mv = pc_size[1] + w_gate + 2 * end_cap\n            nr = 1\n        else:\n            mv = 0\n            nr = 2\n\n        pc = c_inst.add_array(\n            component=c_pc,\n            rows=nr,\n            columns=1,\n            spacing=(0, pc_size[1] + w_gate + 2 * end_cap),\n        )\n        pc.move((poly.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv))\n\n        # gate_lablel\n        c.add_ref(\n            labels_gen(\n                lbl_str=\"None\",\n                position=(pc.xmin + c_pc.size[0] / 2, pc.ymin + c_pc.size[1] / 2),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                labels=g_lbl,\n                lbl_valid_len=nf,\n                index=0,\n            )\n        )\n\n    else:\n        w_p1 = end_cap + w_gate + end_cap  # poly total width\n\n        if inter_sd_l < (poly2_spacing + 2 * pc_ext):\n            if gate_con_pos == \"alternating\":\n                w_p1 += 0.2\n                w_p2 = w_p1\n                e_c = 0.2\n            else:\n                w_p2 = w_p1 + con_pl_enc + con_size + con_pl_enc + poly2_spacing + 0.1\n                e_c = 0\n\n            if gate_con_pos == \"bottom\":\n                p_mv = -end_cap - (w_p2 - w_p1)\n            else:\n                p_mv = -end_cap\n\n        else:\n            w_p2 = w_p1\n            p_mv = -end_cap\n            e_c = 0\n\n        rect_p1 = gf.components.rectangle(size=(l_gate, w_p1), layer=layer[\"poly2\"])\n        rect_p2 = gf.components.rectangle(size=(l_gate, w_p2), layer=layer[\"poly2\"])\n        poly1 = c_inst.add_array(\n            rect_p1,\n            rows=1,\n            columns=ceil(nf / 2),\n            spacing=[2 * (inter_sd_l + l_gate), 0],\n        )\n        poly1.xmin = sd_diff_intr.xmin + con_comp_enc\n        poly1.ymin = sd_diff_intr.ymin - end_cap - e_c\n\n        poly2 = c_inst.add_array(\n            rect_p2,\n            rows=1,\n            columns=floor(nf / 2),\n            spacing=[2 * (inter_sd_l + l_gate), 0],\n        )\n        poly2.xmin = poly1.xmin + l_gate + inter_sd_l\n        poly2.ymin = p_mv\n\n        # generating poly contacts setups\n\n        if gate_con_pos == \"bottom\":\n            mv_1 = 0\n            mv_2 = -(w_p2 - w_p1)\n        elif gate_con_pos == \"top\":\n            mv_1 = pc_size[1] + w_p1\n            mv_2 = pc_size[1] + w_p2\n        else:\n            mv_1 = -e_c\n            mv_2 = pc_size[1] + w_p2\n\n        nc1 = ceil(nf / 2)\n        nc2 = floor(nf / 2)\n\n        pc_spacing = 2 * (inter_sd_l + l_gate)\n\n        # generating poly contacts\n\n        pc1 = c_inst.add_array(\n            component=c_pc, rows=1, columns=nc1, spacing=(pc_spacing, 0)\n        )\n        pc1.move((poly1.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv_1))\n\n        pc2 = c_inst.add_array(\n            component=c_pc, rows=1, columns=nc2, spacing=(pc_spacing, 0)\n        )\n        pc2.move(\n            (\n                poly1.xmin - ((pc_x - l_gate) / 2) + (inter_sd_l + l_gate),\n                -pc_size[1] - end_cap + mv_2,\n            )\n        )\n\n        add_inter_sd_labels(\n            c,\n            nf,\n            sd_lbl,\n            poly1,\n            l_gate,\n            inter_sd_l,\n            sd_diff_intr,\n            lbl,\n            layer,\n            con_bet_fin,\n        )\n\n        add_gate_labels(c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf)\n\n        if interdig == 1:\n            c_inst.add_ref(\n                interdigit(\n                    sd_diff=sd_diff,\n                    pc1=pc1,\n                    pc2=pc2,\n                    poly_con=poly_con,\n                    sd_diff_intr=sd_diff_intr,\n                    l_gate=l_gate,\n                    inter_sd_l=inter_sd_l,\n                    sd_l=sd_l,\n                    nf=nf,\n                    patt=patt,\n                    gate_con_pos=gate_con_pos,\n                    pc_x=pc_x,\n                    pc_spacing=pc_spacing,\n                    lbl=lbl,\n                    g_lbl=g_lbl,\n                    patt_lbl=patt_lbl,\n                )\n            )\n\n    # generating bulk\n    if bulk == \"None\":\n        pplus = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_diff.size[0] + 2 * comp_pp_enc, w_gate + 2 * gate_pp_enc),\n                layer=layer[\"pplus\"],\n            )\n        )\n        pplus.xmin = sd_diff.xmin - comp_pp_enc\n        pplus.ymin = sd_diff_intr.ymin - gate_pp_enc\n\n        c.add_ref(c_inst)\n\n        # deep nwell and nwell generation\n\n        c.add_ref(\n            pfet_deep_nwell(\n                deepnwell=deepnwell,\n                pcmpgr=pcmpgr,\n                enc_size=(sd_diff.size[0], sd_diff.size[1]),\n                enc_xmin=sd_diff.xmin,\n                enc_ymin=sd_diff.ymin,\n                nw_enc_pcmp=nw_enc_pcmp,\n                grw=grw,\n            )\n        )\n\n        # dualgate generation\n\n        # c.add_ref(\n        #     hv_gen(c_inst=c_inst, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_poly)\n        # )\n        hv_gen(c, c_inst=c_inst, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_poly)\n\n    elif bulk == \"Bulk Tie\":\n        rect_bulk = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_l + con_sp, sd_diff.size[1]), layer=layer[\"comp\"]\n            )\n        )\n        rect_bulk.xmin = sd_diff.xmax\n        rect_bulk.ymin = sd_diff.ymin\n        psdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(\n                    sd_diff.xmax - sd_diff.xmin + comp_pp_enc,\n                    w_gate + 2 * gate_pp_enc,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm.xmin = sd_diff.xmin - comp_pp_enc\n        psdm.ymin = sd_diff_intr.ymin - gate_pp_enc\n        nsdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(\n                    rect_bulk.xmax - rect_bulk.xmin + comp_np_enc,\n                    w_gate + 2 * comp_np_enc,\n                ),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nsdm.connect(\"e1\", destination=psdm.ports[\"e3\"])\n\n        bulk_con = via_stack(\n            x_range=(rect_bulk.xmin + 0.1, rect_bulk.xmax - 0.1),\n            y_range=(rect_bulk.ymin, rect_bulk.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n        c_inst.add_ref(bulk_con)\n\n        c.add_ref(c_inst)\n\n        c.add_ref(\n            labels_gen(\n                lbl_str=sub_lbl,\n                position=(\n                    bulk_con.xmin + bulk_con.size[0] / 2,\n                    bulk_con.ymin + bulk_con.size[1] / 2,\n                ),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                labels=[sub_lbl],\n                lbl_valid_len=1,\n            )\n        )\n\n        # deep nwell generation\n\n        c.add_ref(\n            pfet_deep_nwell(\n                deepnwell=deepnwell,\n                pcmpgr=pcmpgr,\n                enc_size=(sd_diff.size[0] + rect_bulk.size[0], sd_diff.size[1]),\n                enc_xmin=sd_diff.xmin,\n                enc_ymin=sd_diff.ymin,\n                nw_enc_pcmp=nw_enc_pcmp,\n                grw=grw,\n            )\n        )\n\n        # dualgate generation\n        # c.add_ref(\n        #     hv_gen(c_inst=c_inst, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_poly)\n        # )\n        hv_gen(c, c_inst=c_inst, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_poly)\n\n    elif bulk == \"Guard Ring\":\n        psdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_pp_enc),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm.xmin = sd_diff.xmin - comp_pp_enc\n        psdm.ymin = sd_diff_intr.ymin - gate_pp_enc\n        c.add_ref(c_inst)\n\n        bulk_gr_gen(\n            c,\n            c_inst=c_inst,\n            comp_spacing=comp_spacing,\n            poly2_comp_spacing=comp_spacing,\n            volt=volt,\n            grw=grw,\n            l_d=l_d,\n            implant_layer=layer[\"nplus\"],\n            lbl=lbl,\n            sub_lbl=sub_lbl,\n            deepnwell=deepnwell,\n            pcmpgr=pcmpgr,\n            nw_enc_pcmp=nw_enc_pcmp,\n        )\n        # bulk guardring\n\n    return c", "\n\n@gf.cell\ndef nfet_06v0_nvt(\n    l_gate: float = 1.8,\n    w_gate: float = 0.8,\n    sd_con_col: int = 1,\n    inter_sd_l: float = 0.24,\n    nf: int = 1,\n    grw: float = 0.22,\n    bulk=\"None\",\n    con_bet_fin: int = 1,\n    gate_con_pos=\"alternating\",\n    interdig: int = 0,\n    patt=\"\",\n    lbl: bool = 0,\n    sd_lbl: Optional[Strs] = [],\n    g_lbl: str = [],\n    sub_lbl: str = \"\",\n    patt_lbl: bool = 0,\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw Native NFET 6V transistor by specifying parameters\n\n    Arguments:-\n     l      : Float of gate length\n     w      : Float of gate width\n     ld     : Float of diffusion length\n     nf     : Integer of number of fingers\n     grw    : Float of guard ring width [If enabled]\n     bulk   : String of bulk connection type [None, Bulk Tie, Guard Ring]\n    \"\"\"\n\n    # used layers and dimensions\n\n    end_cap: float = 0.22\n\n    comp_spacing: float = 0.36\n    poly2_comp_spacing: float = 0.3\n\n    gate_np_enc: float = 0.23\n    comp_np_enc: float = 0.16\n    comp_pp_enc: float = 0.16\n    poly2_spacing: float = 0.24\n    pc_ext: float = 0.04\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n    con_pl_enc = 0.07\n    dg_enc_cmp = 0.24\n    dg_enc_poly = 0.4\n\n    sd_l_con = (\n        ((sd_con_col) * con_size) + ((sd_con_col - 1) * con_sp) + 2 * con_comp_enc\n    )\n    sd_l = sd_l_con\n\n    # gds components to store a single instance and the generated device\n    c = gf.Component(\"sky_nfet_nvt_dev\")\n\n    c_inst = gf.Component(\"dev_temp\")\n\n    # generating sd diffusion\n\n    if interdig == 1 and nf > 1 and nf != len(patt) and patt != \"\":\n        nf = len(patt)\n\n    l_d = (\n        nf * l_gate + (nf - 1) * inter_sd_l + 2 * (con_comp_enc)\n    )  # diffution total length\n    rect_d_intr = gf.components.rectangle(size=(l_d, w_gate), layer=layer[\"comp\"])\n    sd_diff_intr = c_inst.add_ref(rect_d_intr)\n\n    # generatin sd contacts\n\n    if w_gate <= con_size + 2 * con_comp_enc:\n        cmpc_y = con_comp_enc + con_size + con_comp_enc\n\n    else:\n        cmpc_y = w_gate\n\n    cmpc_size = (sd_l_con, cmpc_y)\n\n    sd_diff = c_inst.add_array(\n        component=gf.components.rectangle(size=cmpc_size, layer=layer[\"comp\"]),\n        rows=1,\n        columns=2,\n        spacing=(cmpc_size[0] + sd_diff_intr.size[0], 0),\n    )\n\n    sd_diff.xmin = sd_diff_intr.xmin - cmpc_size[0]\n    sd_diff.ymin = sd_diff_intr.ymin - (sd_diff.size[1] - sd_diff_intr.size[1]) / 2\n\n    sd_con = via_stack(\n        x_range=(sd_diff.xmin, sd_diff_intr.xmin),\n        y_range=(sd_diff.ymin, sd_diff.ymax),\n        base_layer=layer[\"comp\"],\n        metal_level=1,\n    )\n    c_inst.add_array(\n        component=sd_con,\n        columns=2,\n        rows=1,\n        spacing=(\n            sd_l + nf * l_gate + (nf - 1) * inter_sd_l + 2 * (con_comp_enc),\n            0,\n        ),\n    )\n\n    if con_bet_fin == 1 and nf > 1:\n        inter_sd_con = via_stack(\n            x_range=(\n                sd_diff_intr.xmin + con_comp_enc + l_gate,\n                sd_diff_intr.xmin + con_comp_enc + l_gate + inter_sd_l,\n            ),\n            y_range=(0, w_gate),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n        c_inst.add_array(\n            component=inter_sd_con,\n            columns=nf - 1,\n            rows=1,\n            spacing=(l_gate + inter_sd_l, 0),\n        )\n\n    ### adding source/drain labels\n    c.add_ref(\n        labels_gen(\n            lbl_str=\"None\",\n            position=(sd_diff.xmin + (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n            layer=layer[\"metal1_label\"],\n            lbl=lbl,\n            labels=sd_lbl,\n            lbl_valid_len=nf + 1,\n            index=0,\n        )\n    )\n\n    c.add_ref(\n        labels_gen(\n            lbl_str=\"None\",\n            position=(sd_diff.xmax - (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n            layer=layer[\"metal1_label\"],\n            lbl=lbl,\n            labels=sd_lbl,\n            lbl_valid_len=nf + 1,\n            index=nf,\n        )\n    )\n\n    # generating poly\n\n    if l_gate <= con_size + 2 * con_pl_enc:\n        pc_x = con_pl_enc + con_size + con_pl_enc\n\n    else:\n        pc_x = l_gate\n\n    pc_size = (pc_x, con_pl_enc + con_size + con_pl_enc)\n\n    c_pc = gf.Component(\"poly con\")\n\n    rect_pc = c_pc.add_ref(gf.components.rectangle(size=pc_size, layer=layer[\"poly2\"]))\n\n    poly_con = via_stack(\n        x_range=(rect_pc.xmin, rect_pc.xmax),\n        y_range=(rect_pc.ymin, rect_pc.ymax),\n        base_layer=layer[\"poly2\"],\n        metal_level=1,\n        li_enc_dir=\"H\",\n    )\n    c_pc.add_ref(poly_con)\n\n    if nf == 1:\n        poly = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(l_gate, w_gate + 2 * end_cap), layer=layer[\"poly2\"]\n            )\n        )\n        poly.xmin = sd_diff_intr.xmin + con_comp_enc\n        poly.ymin = sd_diff_intr.ymin - end_cap\n\n        if gate_con_pos == \"bottom\":\n            mv = 0\n            nr = 1\n        elif gate_con_pos == \"top\":\n            mv = pc_size[1] + w_gate + 2 * end_cap\n            nr = 1\n        else:\n            mv = 0\n            nr = 2\n\n        pc = c_inst.add_array(\n            component=c_pc,\n            rows=nr,\n            columns=1,\n            spacing=(0, pc_size[1] + w_gate + 2 * end_cap),\n        )\n        pc.move((poly.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv))\n\n        # gate_lablel\n        c.add_ref(\n            labels_gen(\n                lbl_str=\"None\",\n                position=(pc.xmin + c_pc.size[0] / 2, pc.ymin + c_pc.size[1] / 2),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                labels=g_lbl,\n                lbl_valid_len=nf,\n                index=0,\n            )\n        )\n\n    else:\n        w_p1 = end_cap + w_gate + end_cap  # poly total width\n\n        if inter_sd_l < (poly2_spacing + 2 * pc_ext):\n            if gate_con_pos == \"alternating\":\n                w_p1 += 0.2\n                w_p2 = w_p1\n                e_c = 0.2\n            else:\n                w_p2 = w_p1 + con_pl_enc + con_size + con_pl_enc + poly2_spacing + 0.1\n                e_c = 0\n\n            if gate_con_pos == \"bottom\":\n                p_mv = -end_cap - (w_p2 - w_p1)\n            else:\n                p_mv = -end_cap\n\n        else:\n            w_p2 = w_p1\n            p_mv = -end_cap\n            e_c = 0\n\n        rect_p1 = gf.components.rectangle(size=(l_gate, w_p1), layer=layer[\"poly2\"])\n        rect_p2 = gf.components.rectangle(size=(l_gate, w_p2), layer=layer[\"poly2\"])\n        poly1 = c_inst.add_array(\n            rect_p1,\n            rows=1,\n            columns=ceil(nf / 2),\n            spacing=[2 * (inter_sd_l + l_gate), 0],\n        )\n        poly1.xmin = sd_diff_intr.xmin + con_comp_enc\n        poly1.ymin = sd_diff_intr.ymin - end_cap - e_c\n\n        poly2 = c_inst.add_array(\n            rect_p2,\n            rows=1,\n            columns=floor(nf / 2),\n            spacing=[2 * (inter_sd_l + l_gate), 0],\n        )\n        poly2.xmin = poly1.xmin + l_gate + inter_sd_l\n        poly2.ymin = p_mv\n\n        # generating poly contacts setups\n\n        if gate_con_pos == \"bottom\":\n            mv_1 = 0\n            mv_2 = -(w_p2 - w_p1)\n        elif gate_con_pos == \"top\":\n            mv_1 = pc_size[1] + w_p1\n            mv_2 = pc_size[1] + w_p2\n        else:\n            mv_1 = -e_c\n            mv_2 = pc_size[1] + w_p2\n\n        nc1 = ceil(nf / 2)\n        nc2 = floor(nf / 2)\n\n        pc_spacing = 2 * (inter_sd_l + l_gate)\n\n        # generating poly contacts\n\n        pc1 = c_inst.add_array(\n            component=c_pc, rows=1, columns=nc1, spacing=(pc_spacing, 0)\n        )\n        pc1.move((poly1.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv_1))\n\n        pc2 = c_inst.add_array(\n            component=c_pc, rows=1, columns=nc2, spacing=(pc_spacing, 0)\n        )\n        pc2.move(\n            (\n                poly1.xmin - ((pc_x - l_gate) / 2) + (inter_sd_l + l_gate),\n                -pc_size[1] - end_cap + mv_2,\n            )\n        )\n\n        add_inter_sd_labels(\n            c,\n            nf,\n            sd_lbl,\n            poly1,\n            l_gate,\n            inter_sd_l,\n            sd_diff_intr,\n            lbl,\n            layer,\n            con_bet_fin,\n        )\n\n        add_gate_labels(c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf)\n\n        if interdig == 1:\n            c_inst.add_ref(\n                interdigit(\n                    sd_diff=sd_diff,\n                    pc1=pc1,\n                    pc2=pc2,\n                    poly_con=poly_con,\n                    sd_diff_intr=sd_diff_intr,\n                    l_gate=l_gate,\n                    inter_sd_l=inter_sd_l,\n                    sd_l=sd_l,\n                    nf=nf,\n                    patt=patt,\n                    gate_con_pos=gate_con_pos,\n                    pc_x=pc_x,\n                    pc_spacing=pc_spacing,\n                    lbl=lbl,\n                    g_lbl=g_lbl,\n                    patt_lbl=patt_lbl,\n                )\n            )\n\n    # generating bulk\n    if bulk == \"None\":\n        nplus = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_np_enc),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nplus.xmin = sd_diff.xmin - comp_np_enc\n        nplus.ymin = sd_diff_intr.ymin - gate_np_enc\n\n    elif bulk == \"Bulk Tie\":\n        rect_bulk = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_l + con_sp, sd_diff.size[1]), layer=layer[\"comp\"]\n            )\n        )\n        rect_bulk.xmin = sd_diff.xmax\n        rect_bulk.ymin = sd_diff.ymin\n        nsdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(\n                    sd_diff.xmax - sd_diff.xmin + comp_np_enc,\n                    w_gate + 2 * gate_np_enc,\n                ),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nsdm.xmin = sd_diff.xmin - comp_np_enc\n        nsdm.ymin = sd_diff_intr.ymin - gate_np_enc\n        psdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(\n                    rect_bulk.xmax - rect_bulk.xmin + comp_pp_enc,\n                    w_gate + 2 * comp_pp_enc,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm.connect(\"e1\", destination=nsdm.ports[\"e3\"])\n\n        bulk_con = via_stack(\n            x_range=(rect_bulk.xmin + 0.1, rect_bulk.xmax - 0.1),\n            y_range=(rect_bulk.ymin, rect_bulk.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n        c_inst.add_ref(bulk_con)\n\n        c.add_ref(\n            labels_gen(\n                lbl_str=sub_lbl,\n                position=(\n                    bulk_con.xmin + bulk_con.size[0] / 2,\n                    bulk_con.ymin + bulk_con.size[1] / 2,\n                ),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                labels=[sub_lbl],\n                lbl_valid_len=1,\n            )\n        )\n\n    elif bulk == \"Guard Ring\":\n        nsdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_np_enc),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nsdm.xmin = sd_diff.xmin - comp_np_enc\n        nsdm.ymin = sd_diff_intr.ymin - gate_np_enc\n        c.add_ref(c_inst)\n\n        c_temp = gf.Component(\"temp_store\")\n        rect_bulk_in = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (c_inst.xmax - c_inst.xmin) + 2 * comp_spacing,\n                    (c_inst.ymax - c_inst.ymin) + 2 * poly2_comp_spacing,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_bulk_in.move(\n            (c_inst.xmin - comp_spacing, c_inst.ymin - poly2_comp_spacing)\n        )\n        rect_bulk_out = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n                    (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_bulk_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n        B = c.add_ref(\n            gf.geometry.boolean(\n                A=rect_bulk_out,\n                B=rect_bulk_in,\n                operation=\"A-B\",\n                layer=layer[\"comp\"],\n            )\n        )\n\n        psdm_in = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_bulk_in.xmax - rect_bulk_in.xmin) - 2 * comp_pp_enc,\n                    (rect_bulk_in.ymax - rect_bulk_in.ymin) - 2 * comp_pp_enc,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_in.move((rect_bulk_in.xmin + comp_pp_enc, rect_bulk_in.ymin + comp_pp_enc))\n        psdm_out = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_bulk_out.xmax - rect_bulk_out.xmin) + 2 * comp_pp_enc,\n                    (rect_bulk_out.ymax - rect_bulk_out.ymin) + 2 * comp_pp_enc,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_out.move(\n            (\n                rect_bulk_out.xmin - comp_pp_enc,\n                rect_bulk_out.ymin - comp_pp_enc,\n            )\n        )\n        psdm = c.add_ref(\n            gf.geometry.boolean(\n                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n            )\n        )\n\n        # generating contacts\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_bulk_in.xmin + con_size,\n                    rect_bulk_in.xmax - con_size,\n                ),\n                y_range=(rect_bulk_out.ymin, rect_bulk_in.ymin),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # bottom contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_bulk_in.xmin + con_size,\n                    rect_bulk_in.xmax - con_size,\n                ),\n                y_range=(rect_bulk_in.ymax, rect_bulk_out.ymax),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # upper contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(rect_bulk_out.xmin, rect_bulk_in.xmin),\n                y_range=(\n                    rect_bulk_in.ymin + con_size,\n                    rect_bulk_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # right contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(rect_bulk_in.xmax, rect_bulk_out.xmax),\n                y_range=(\n                    rect_bulk_in.ymin + con_size,\n                    rect_bulk_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # left contact\n\n        comp_m1_in = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (l_d) + 2 * comp_spacing,\n                    (c_inst.ymax - c_inst.ymin) + 2 * poly2_comp_spacing,\n                ),\n                layer=layer[\"metal1\"],\n            )\n        )\n        comp_m1_in.move((-comp_spacing, c_inst.ymin - poly2_comp_spacing))\n        comp_m1_out = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n                    (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n                ),\n                layer=layer[\"metal1\"],\n            )\n        )\n        comp_m1_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n        b_gr = c.add_ref(\n            gf.geometry.boolean(\n                A=rect_bulk_out,\n                B=rect_bulk_in,\n                operation=\"A-B\",\n                layer=layer[\"metal1\"],\n            )\n        )  # guardring metal1\n\n        c.add_ref(\n            labels_gen(\n                lbl_str=sub_lbl,\n                position=(\n                    b_gr.xmin + (grw + 2 * (comp_pp_enc)) / 2,\n                    b_gr.ymin + (b_gr.size[1] / 2),\n                ),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                labels=[sub_lbl],\n                lbl_valid_len=1,\n            )\n        )\n\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    B.size[0] + (2 * dg_enc_cmp),\n                    B.size[1] + (2 * dg_enc_cmp),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = B.xmin - dg_enc_cmp\n        dg.ymin = B.ymin - dg_enc_cmp\n\n    if bulk != \"Guard Ring\":\n        c.add_ref(c_inst)\n\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    c_inst.size[0] + (2 * dg_enc_cmp),\n                    c_inst.size[1] + (2 * dg_enc_poly),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = c_inst.xmin - dg_enc_cmp\n        dg.ymin = c_inst.ymin - dg_enc_poly\n\n    # generating native layer\n    nat = c.add_ref(\n        gf.components.rectangle(size=(dg.size[0], dg.size[1]), layer=layer[\"nat\"])\n    )\n\n    nat.xmin = dg.xmin\n    nat.ymin = dg.ymin\n\n    return c", "\n\nif __name__ == \"__main__\":\n    # c = nfet()\n    c = nfet_06v0_nvt()\n    c.show()\n"]}
{"filename": "gf180/cap_mim.py", "chunked_list": ["import gdsfactory as gf\n\nfrom gf180.layers import layer\nfrom gf180.via_generator import via_generator\n\n\n@gf.cell\ndef cap_mim(\n    mim_option: str = \"A\",\n    metal_level: str = \"M4\",\n    lc: float = 2,\n    wc: float = 2,\n    lbl: bool = 0,\n    top_lbl: str = \"\",\n    bot_lbl: str = \"\",\n):\n    \"\"\"Return mim cap.\n\n    Args:\n        lc : float of cap length\n        wc : float of cap width\n\n    \"\"\"\n\n    c = gf.Component(\"mim_cap_dev\")\n\n    # used dimensions and layers\n\n    # MIM Option selection\n    if mim_option == \"MIM-A\":\n        upper_layer = layer[\"metal3\"]\n        bottom_layer = layer[\"metal2\"]\n        via_layer = layer[\"via2\"]\n        up_lbl_layer = layer[\"metal3_label\"]\n        bot_lbl_layer = layer[\"metal2_label\"]\n\n    elif mim_option == \"MIM-B\":\n        if metal_level == \"M4\":\n            upper_layer = layer[\"metal4\"]\n            bottom_layer = layer[\"metal3\"]\n            via_layer = layer[\"via3\"]\n            up_lbl_layer = layer[\"metal4_label\"]\n            bot_lbl_layer = layer[\"metal3_label\"]\n        elif metal_level == \"M5\":\n            upper_layer = layer[\"metal5\"]\n            bottom_layer = layer[\"metal4\"]\n            via_layer = layer[\"via4\"]\n            up_lbl_layer = layer[\"metal5_label\"]\n            bot_lbl_layer = layer[\"metal4_label\"]\n        elif metal_level == \"M6\":\n            upper_layer = layer[\"metaltop\"]\n            bottom_layer = layer[\"metal5\"]\n            via_layer = layer[\"via5\"]\n            up_lbl_layer = layer[\"metaltop_label\"]\n            bot_lbl_layer = layer[\"metal5_label\"]\n    else:\n        upper_layer = layer[\"metal3\"]\n        bottom_layer = layer[\"metal2\"]\n        via_layer = layer[\"via2\"]\n        up_lbl_layer = layer[\"metal3_label\"]\n        bot_lbl_layer = layer[\"metal2_label\"]\n\n    via_size = (0.22, 0.22)\n    via_spacing = (0.5, 0.5)\n    via_enc = (0.4, 0.4)\n\n    bot_enc_top = 0.6\n    l_mk_w = 0.1\n\n    # drawing cap identifier and bottom , upper layers\n\n    m_up = c.add_ref(\n        gf.components.rectangle(\n            size=(wc, lc),\n            layer=upper_layer,\n        )\n    )\n\n    fusetop = c.add_ref(\n        gf.components.rectangle(\n            size=(m_up.size[0], m_up.size[1]), layer=layer[\"fusetop\"]\n        )\n    )\n    fusetop.xmin = m_up.xmin\n    fusetop.ymin = m_up.ymin\n\n    mim_l_mk = c.add_ref(\n        gf.components.rectangle(size=(fusetop.size[0], l_mk_w), layer=layer[\"mim_l_mk\"])\n    )\n    mim_l_mk.xmin = fusetop.xmin\n    mim_l_mk.ymin = fusetop.ymin\n\n    m_dn = c.add_ref(\n        gf.components.rectangle(\n            size=(m_up.size[0] + (2 * bot_enc_top), m_up.size[1] + (2 * bot_enc_top)),\n            layer=bottom_layer,\n        )\n    )\n    m_dn.xmin = m_up.xmin - bot_enc_top\n    m_dn.ymin = m_up.ymin - bot_enc_top\n\n    cap_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(m_dn.size[0], m_dn.size[1]), layer=layer[\"cap_mk\"]\n        )\n    )\n    cap_mk.xmin = m_dn.xmin\n    cap_mk.ymin = m_dn.ymin\n\n    # generating labels\n    if lbl == 1:\n        c.add_label(\n            top_lbl,\n            position=(m_up.xmin + (m_up.size[0] / 2), m_dn.xmin + (m_dn.size[1] / 2)),\n            layer=up_lbl_layer,\n        )\n\n        c.add_label(\n            bot_lbl,\n            position=(\n                m_dn.xmin + (m_dn.size[0] / 2),\n                m_dn.ymin + (m_up.ymin - m_dn.ymin) / 2,\n            ),\n            layer=bot_lbl_layer,\n        )\n\n    # generating vias\n\n    via = via_generator(\n        x_range=(m_up.xmin, m_up.xmax),\n        y_range=(m_up.ymin, m_up.ymax),\n        via_enclosure=via_enc,\n        via_layer=via_layer,\n        via_size=via_size,\n        via_spacing=via_spacing,\n    )\n    c.add_ref(via)\n    return c", "\n\nif __name__ == \"__main__\":\n    c = cap_mim()\n    c.show()\n"]}
{"filename": "gf180/diode.py", "chunked_list": ["import gdsfactory as gf\nimport numpy as np\nfrom gdsfactory.typings import Float2\n\nfrom gf180.layers import layer\nfrom gf180.via_generator import via_generator, via_stack\n\n\n@gf.cell\ndef diode_nd2ps(\n    la: float = 0.1,\n    wa: float = 0.1,\n    cw: float = 0.1,\n    volt: str = \"3.3V\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    p_lbl: str = \"\",\n    n_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Draw N+/LVPWELL diode (Outside DNWELL) by specifying parameters\n\n    Arguments:\n        la         : Float of diff length (anode)\n        wa         : Float of diff width (anode)\n        cw         : Float of cathode width\n        volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n        deepnwell  : Boolean of using Deep NWELL device\n        pcmpgr     : Boolean of using P+ Guard Ring for Deep NWELL devices only\n    \"\"\"\n\n    c = gf.Component(\"diode_nd2ps_dev\")\n\n    comp_spacing: float = 0.48\n    np_enc_comp: float = 0.16\n    pp_enc_comp: float = 0.16\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n\n    dg_enc_cmp = 0.24\n    dn_enc_lvpwell = 2.5\n    lvpwell_enc_ncmp = 0.6\n    lvpwell_enc_pcmp = 0.16\n    pcmpgr_enc_dn = 2.5\n\n    # n generation\n    ncmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n    nplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                ncmp.size[0] + (2 * np_enc_comp),\n                ncmp.size[1] + (2 * np_enc_comp),\n            ),\n            layer=layer[\"nplus\"],\n        )\n    )\n    nplus.xmin = ncmp.xmin - np_enc_comp\n    nplus.ymin = ncmp.ymin - np_enc_comp\n    diode_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(ncmp.size[0], ncmp.size[1]), layer=layer[\"diode_mk\"]\n        )\n    )\n    diode_mk.xmin = ncmp.xmin\n    diode_mk.ymin = ncmp.ymin\n\n    ncmp_con = c.add_ref(\n        via_stack(\n            x_range=(ncmp.xmin, ncmp.xmax),\n            y_range=(ncmp.ymin, ncmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # ncomp_con\n\n    # p generation\n    pcmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n    pcmp.xmax = ncmp.xmin - comp_spacing\n    pplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                pcmp.size[0] + (2 * pp_enc_comp),\n                pcmp.size[1] + (2 * pp_enc_comp),\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    pplus.xmin = pcmp.xmin - pp_enc_comp\n    pplus.ymin = pcmp.ymin - pp_enc_comp\n\n    pcmp_con = c.add_ref(\n        via_stack(\n            x_range=(pcmp.xmin, pcmp.xmax),\n            y_range=(pcmp.ymin, pcmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # pcomp_con\n\n    # labels generation\n    if lbl == 1:\n        # n_label generation\n        c.add_label(\n            n_lbl,\n            position=(\n                ncmp_con.xmin + (ncmp_con.size[0] / 2),\n                ncmp_con.ymin + (ncmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        # p_label generation\n        c.add_label(\n            p_lbl,\n            position=(\n                pcmp_con.xmin + (pcmp_con.size[0] / 2),\n                pcmp_con.ymin + (pcmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    if volt == \"5/6V\":\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    ncmp.xmax - pcmp.xmin + (2 * dg_enc_cmp),\n                    ncmp.size[1] + (2 * dg_enc_cmp),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = pcmp.xmin - dg_enc_cmp\n        dg.ymin = pcmp.ymin - dg_enc_cmp\n\n    if deepnwell == 1:\n        lvpwell = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    ncmp.xmax - pcmp.xmin + (lvpwell_enc_ncmp + lvpwell_enc_pcmp),\n                    ncmp.size[1] + (2 * lvpwell_enc_ncmp),\n                ),\n                layer=layer[\"lvpwell\"],\n            )\n        )\n\n        lvpwell.xmin = pcmp.xmin - lvpwell_enc_pcmp\n        lvpwell.ymin = ncmp.ymin - lvpwell_enc_ncmp\n\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    lvpwell.size[0] + (2 * dn_enc_lvpwell),\n                    lvpwell.size[1] + (2 * dn_enc_lvpwell),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n\n        dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n        dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\n        if pcmpgr == 1:\n            c_temp_gr = gf.Component(\"temp_store guard ring\")\n            rect_pcmpgr_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                        (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_in.move(\n                (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n            )\n            rect_pcmpgr_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"comp\"],\n                )\n            )  # guardring Bulk draw\n\n            psdm_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_in.move(\n                (\n                    rect_pcmpgr_in.xmin + pp_enc_comp,\n                    rect_pcmpgr_in.ymin + pp_enc_comp,\n                )\n            )\n            psdm_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n                        (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_out.move(\n                (\n                    rect_pcmpgr_out.xmin - pp_enc_comp,\n                    rect_pcmpgr_out.ymin - pp_enc_comp,\n                )\n            )\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n                )\n            )  # psdm draw\n\n            # generating contacts\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # bottom contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # upper contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # right contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # left contact\n\n            comp_m1_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n                    layer=layer[\"metal1\"],\n                )\n            )\n\n            comp_m1_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (comp_m1_in.size[0]) + 2 * cw,\n                        (comp_m1_in.size[1]) + 2 * cw,\n                    ),\n                    layer=layer[\"metal1\"],\n                )\n            )\n            comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"metal1\"],\n                )\n            )  # guardring metal1\n\n    return c", "@gf.cell\ndef diode_nd2ps(\n    la: float = 0.1,\n    wa: float = 0.1,\n    cw: float = 0.1,\n    volt: str = \"3.3V\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    p_lbl: str = \"\",\n    n_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Draw N+/LVPWELL diode (Outside DNWELL) by specifying parameters\n\n    Arguments:\n        la         : Float of diff length (anode)\n        wa         : Float of diff width (anode)\n        cw         : Float of cathode width\n        volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n        deepnwell  : Boolean of using Deep NWELL device\n        pcmpgr     : Boolean of using P+ Guard Ring for Deep NWELL devices only\n    \"\"\"\n\n    c = gf.Component(\"diode_nd2ps_dev\")\n\n    comp_spacing: float = 0.48\n    np_enc_comp: float = 0.16\n    pp_enc_comp: float = 0.16\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n\n    dg_enc_cmp = 0.24\n    dn_enc_lvpwell = 2.5\n    lvpwell_enc_ncmp = 0.6\n    lvpwell_enc_pcmp = 0.16\n    pcmpgr_enc_dn = 2.5\n\n    # n generation\n    ncmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n    nplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                ncmp.size[0] + (2 * np_enc_comp),\n                ncmp.size[1] + (2 * np_enc_comp),\n            ),\n            layer=layer[\"nplus\"],\n        )\n    )\n    nplus.xmin = ncmp.xmin - np_enc_comp\n    nplus.ymin = ncmp.ymin - np_enc_comp\n    diode_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(ncmp.size[0], ncmp.size[1]), layer=layer[\"diode_mk\"]\n        )\n    )\n    diode_mk.xmin = ncmp.xmin\n    diode_mk.ymin = ncmp.ymin\n\n    ncmp_con = c.add_ref(\n        via_stack(\n            x_range=(ncmp.xmin, ncmp.xmax),\n            y_range=(ncmp.ymin, ncmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # ncomp_con\n\n    # p generation\n    pcmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n    pcmp.xmax = ncmp.xmin - comp_spacing\n    pplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                pcmp.size[0] + (2 * pp_enc_comp),\n                pcmp.size[1] + (2 * pp_enc_comp),\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    pplus.xmin = pcmp.xmin - pp_enc_comp\n    pplus.ymin = pcmp.ymin - pp_enc_comp\n\n    pcmp_con = c.add_ref(\n        via_stack(\n            x_range=(pcmp.xmin, pcmp.xmax),\n            y_range=(pcmp.ymin, pcmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # pcomp_con\n\n    # labels generation\n    if lbl == 1:\n        # n_label generation\n        c.add_label(\n            n_lbl,\n            position=(\n                ncmp_con.xmin + (ncmp_con.size[0] / 2),\n                ncmp_con.ymin + (ncmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        # p_label generation\n        c.add_label(\n            p_lbl,\n            position=(\n                pcmp_con.xmin + (pcmp_con.size[0] / 2),\n                pcmp_con.ymin + (pcmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    if volt == \"5/6V\":\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    ncmp.xmax - pcmp.xmin + (2 * dg_enc_cmp),\n                    ncmp.size[1] + (2 * dg_enc_cmp),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = pcmp.xmin - dg_enc_cmp\n        dg.ymin = pcmp.ymin - dg_enc_cmp\n\n    if deepnwell == 1:\n        lvpwell = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    ncmp.xmax - pcmp.xmin + (lvpwell_enc_ncmp + lvpwell_enc_pcmp),\n                    ncmp.size[1] + (2 * lvpwell_enc_ncmp),\n                ),\n                layer=layer[\"lvpwell\"],\n            )\n        )\n\n        lvpwell.xmin = pcmp.xmin - lvpwell_enc_pcmp\n        lvpwell.ymin = ncmp.ymin - lvpwell_enc_ncmp\n\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    lvpwell.size[0] + (2 * dn_enc_lvpwell),\n                    lvpwell.size[1] + (2 * dn_enc_lvpwell),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n\n        dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n        dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\n        if pcmpgr == 1:\n            c_temp_gr = gf.Component(\"temp_store guard ring\")\n            rect_pcmpgr_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                        (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_in.move(\n                (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n            )\n            rect_pcmpgr_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"comp\"],\n                )\n            )  # guardring Bulk draw\n\n            psdm_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_in.move(\n                (\n                    rect_pcmpgr_in.xmin + pp_enc_comp,\n                    rect_pcmpgr_in.ymin + pp_enc_comp,\n                )\n            )\n            psdm_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n                        (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_out.move(\n                (\n                    rect_pcmpgr_out.xmin - pp_enc_comp,\n                    rect_pcmpgr_out.ymin - pp_enc_comp,\n                )\n            )\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n                )\n            )  # psdm draw\n\n            # generating contacts\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # bottom contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # upper contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # right contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # left contact\n\n            comp_m1_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n                    layer=layer[\"metal1\"],\n                )\n            )\n\n            comp_m1_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (comp_m1_in.size[0]) + 2 * cw,\n                        (comp_m1_in.size[1]) + 2 * cw,\n                    ),\n                    layer=layer[\"metal1\"],\n                )\n            )\n            comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"metal1\"],\n                )\n            )  # guardring metal1\n\n    return c", "\n\n@gf.cell\ndef diode_pd2nw(\n    layout,\n    la: float = 0.1,\n    wa: float = 0.1,\n    cw: float = 0.1,\n    volt: str = \"3.3V\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    p_lbl: str = \"\",\n    n_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw 3.3V P+/Nwell diode (Outside DNWELL) by specifying parameters\n    Arguments:-\n     la         : Float of diffusion length (anode)\n     wa         : Float of diffusion width (anode)\n     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n     deepnwell  : Boolean of using Deep NWELL device\n     pcmpgr     : Boolean of using P+ Guard Ring for Deep NWELL devices only\n    \"\"\"\n\n    c = gf.Component(\"diode_pd2nw_dev\")\n\n    comp_spacing: float = 0.48\n    np_enc_comp: float = 0.16\n    pp_enc_comp: float = 0.16\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n\n    dg_enc_cmp = 0.24\n    dn_enc_nwell = 0.5\n    nwell_ncmp_enc = 0.12\n    nwell_pcmp_enc = 0.43\n    pcmpgr_enc_dn = 2.5\n\n    # p generation\n    pcmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n    pplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                pcmp.size[0] + (2 * pp_enc_comp),\n                pcmp.size[1] + (2 * pp_enc_comp),\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    pplus.xmin = pcmp.xmin - pp_enc_comp\n    pplus.ymin = pcmp.ymin - pp_enc_comp\n    diode_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(pcmp.size[0], pcmp.size[1]), layer=layer[\"diode_mk\"]\n        )\n    )\n    diode_mk.xmin = pcmp.xmin\n    diode_mk.ymin = pcmp.ymin\n\n    pcmp_con = c.add_ref(\n        via_stack(\n            x_range=(pcmp.xmin, pcmp.xmax),\n            y_range=(pcmp.ymin, pcmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # pcomp_contact\n\n    # n generation\n    ncmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n    ncmp.xmax = pcmp.xmin - comp_spacing\n    nplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                ncmp.size[0] + (2 * np_enc_comp),\n                ncmp.size[1] + (2 * np_enc_comp),\n            ),\n            layer=layer[\"nplus\"],\n        )\n    )\n    nplus.xmin = ncmp.xmin - np_enc_comp\n    nplus.ymin = ncmp.ymin - np_enc_comp\n\n    ncmp_con = c.add_ref(\n        via_stack(\n            x_range=(ncmp.xmin, ncmp.xmax),\n            y_range=(ncmp.ymin, ncmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # ncomp contact\n\n    # labels generation\n    if lbl == 1:\n        # n_label generation\n        c.add_label(\n            n_lbl,\n            position=(\n                ncmp_con.xmin + (ncmp_con.size[0] / 2),\n                ncmp_con.ymin + (ncmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        # p_label generation\n        c.add_label(\n            p_lbl,\n            position=(\n                pcmp_con.xmin + (pcmp_con.size[0] / 2),\n                pcmp_con.ymin + (pcmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    if volt == \"5/6V\":\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    pcmp.xmax - ncmp.xmin + (2 * dg_enc_cmp),\n                    ncmp.size[1] + (2 * dg_enc_cmp),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = ncmp.xmin - dg_enc_cmp\n        dg.ymin = ncmp.ymin - dg_enc_cmp\n\n    # nwell generation\n    nwell = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                pcmp.xmax - ncmp.xmin + (nwell_ncmp_enc + nwell_pcmp_enc),\n                pcmp.size[1] + (2 * nwell_pcmp_enc),\n            ),\n            layer=layer[\"nwell\"],\n        )\n    )\n\n    nwell.xmin = ncmp.xmin - nwell_ncmp_enc\n    nwell.ymin = pcmp.ymin - nwell_pcmp_enc\n\n    if deepnwell == 1:\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    nwell.size[0] + (2 * dn_enc_nwell),\n                    nwell.size[1] + (2 * dn_enc_nwell),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n\n        dn_rect.xmin = nwell.xmin - dn_enc_nwell\n        dn_rect.ymin = nwell.ymin - dn_enc_nwell\n\n        if pcmpgr == 1:\n            c_temp_gr = gf.Component(\"temp_store guard ring\")\n            rect_pcmpgr_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                        (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_in.move(\n                (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n            )\n            rect_pcmpgr_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"comp\"],\n                )\n            )  # Bulk guardring\n\n            psdm_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_in.move(\n                (\n                    rect_pcmpgr_in.xmin + pp_enc_comp,\n                    rect_pcmpgr_in.ymin + pp_enc_comp,\n                )\n            )\n            psdm_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n                        (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_out.move(\n                (\n                    rect_pcmpgr_out.xmin - pp_enc_comp,\n                    rect_pcmpgr_out.ymin - pp_enc_comp,\n                )\n            )\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n                )\n            )  # psdm guardring\n\n            # generating contacts\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # bottom contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # upper contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # right contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # left contact\n\n            comp_m1_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n                    layer=layer[\"metal1\"],\n                )\n            )\n\n            comp_m1_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (comp_m1_in.size[0]) + 2 * cw,\n                        (comp_m1_in.size[1]) + 2 * cw,\n                    ),\n                    layer=layer[\"metal1\"],\n                )\n            )\n            comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"metal1\"],\n                )\n            )  # guardring metal1\n\n    return c", "\n\n@gf.cell\ndef diode_nw2ps(\n    la: float = 0.1,\n    wa: float = 0.1,\n    cw: float = 0.1,\n    volt: str = \"3.3V\",\n    lbl: bool = 0,\n    p_lbl: str = \"\",\n    n_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw 3.3V Nwell/Psub diode by specifying parameters\n    Arguments:-\n     la         : Float of diff length (anode)\n     wa         : Float of diff width (anode)\n     cw         : Float of Cathode width\n     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n    \"\"\"\n\n    c = gf.Component(\"diode_nw2ps_dev\")\n\n    comp_spacing: float = 0.48\n    np_enc_comp: float = 0.16\n    pp_enc_comp: float = 0.16\n\n    dg_enc_cmp = 0.24\n\n    nwell_ncmp_enc = 0.16\n\n    # n generation\n    ncmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n    nplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                ncmp.size[0] + (2 * np_enc_comp),\n                ncmp.size[1] + (2 * np_enc_comp),\n            ),\n            layer=layer[\"nplus\"],\n        )\n    )\n    nplus.xmin = ncmp.xmin - np_enc_comp\n    nplus.ymin = ncmp.ymin - np_enc_comp\n    diode_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(ncmp.size[0], ncmp.size[1]), layer=layer[\"diode_mk\"]\n        )\n    )\n    diode_mk.xmin = ncmp.xmin\n    diode_mk.ymin = ncmp.ymin\n\n    nwell = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                ncmp.size[0] + (2 * nwell_ncmp_enc),\n                ncmp.size[1] + (2 * nwell_ncmp_enc),\n            ),\n            layer=layer[\"nwell\"],\n        )\n    )\n    nwell.xmin = ncmp.xmin - nwell_ncmp_enc\n    nwell.ymin = ncmp.ymin - nwell_ncmp_enc\n\n    n_con = c.add_ref(\n        via_stack(\n            x_range=(ncmp.xmin, ncmp.xmax),\n            y_range=(ncmp.ymin, ncmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # ncomp contact\n\n    # p generation\n    pcmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n    pcmp.xmax = ncmp.xmin - comp_spacing\n    pplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                pcmp.size[0] + (2 * pp_enc_comp),\n                pcmp.size[1] + (2 * pp_enc_comp),\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    pplus.xmin = pcmp.xmin - pp_enc_comp\n    pplus.ymin = pcmp.ymin - pp_enc_comp\n\n    p_con = c.add_ref(\n        via_stack(\n            x_range=(pcmp.xmin, pcmp.xmax),\n            y_range=(pcmp.ymin, pcmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # pcmop contact\n\n    # labels generation\n    if lbl == 1:\n        # n_label generation\n        c.add_label(\n            n_lbl,\n            position=(\n                n_con.xmin + (n_con.size[0] / 2),\n                n_con.ymin + (n_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        # p_label generation\n        c.add_label(\n            p_lbl,\n            position=(\n                p_con.xmin + (p_con.size[0] / 2),\n                p_con.ymin + (p_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    if volt == \"5/6V\":\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    ncmp.xmax - pcmp.xmin + (2 * dg_enc_cmp),\n                    ncmp.size[1] + (2 * dg_enc_cmp),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = pcmp.xmin - dg_enc_cmp\n        dg.ymin = pcmp.ymin - dg_enc_cmp\n\n    return c", "\n\n@gf.cell\ndef diode_pw2dw(\n    la: float = 0.1,\n    wa: float = 0.1,\n    cw: float = 0.1,\n    volt: str = \"3.3V\",\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    p_lbl: str = \"\",\n    n_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw LVPWELL/DNWELL diode by specifying parameters\n    Arguments:-\n     layout     : Object of layout\n     la         : Float of diff length (anode)\n     wa         : Float of diff width (anode)\n     cw         : Float of cathode width\n     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n    \"\"\"\n\n    c = gf.Component(\"diode_pw2dw_dev\")\n\n    comp_spacing: float = 0.48\n    np_enc_comp: float = 0.16\n    pp_enc_comp: float = 0.16\n\n    dg_enc_dn = 0.5\n\n    lvpwell_enc_pcmp = 0.16\n    dn_enc_lvpwell = 2.5\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n\n    pcmpgr_enc_dn = 2.5\n\n    # p generation\n    pcmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n    pplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                pcmp.size[0] + (2 * pp_enc_comp),\n                pcmp.size[1] + (2 * pp_enc_comp),\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    pplus.xmin = pcmp.xmin - pp_enc_comp\n    pplus.ymin = pcmp.ymin - pp_enc_comp\n    diode_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(pcmp.size[0], pcmp.size[1]), layer=layer[\"diode_mk\"]\n        )\n    )\n    diode_mk.xmin = pcmp.xmin\n    diode_mk.ymin = pcmp.ymin\n\n    lvpwell = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                pcmp.size[0] + (2 * lvpwell_enc_pcmp),\n                pcmp.size[1] + (2 * lvpwell_enc_pcmp),\n            ),\n            layer=layer[\"lvpwell\"],\n        )\n    )\n    lvpwell.xmin = pcmp.xmin - lvpwell_enc_pcmp\n    lvpwell.ymin = pcmp.ymin - lvpwell_enc_pcmp\n\n    p_con = c.add_ref(\n        via_stack(\n            x_range=(pcmp.xmin, pcmp.xmax),\n            y_range=(pcmp.ymin, pcmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # pcomp_contact\n\n    # n generation\n    ncmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n    ncmp.xmax = pcmp.xmin - comp_spacing\n    nplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                ncmp.size[0] + (2 * np_enc_comp),\n                ncmp.size[1] + (2 * np_enc_comp),\n            ),\n            layer=layer[\"nplus\"],\n        )\n    )\n    nplus.xmin = ncmp.xmin - np_enc_comp\n    nplus.ymin = ncmp.ymin - np_enc_comp\n\n    n_con = c.add_ref(\n        via_stack(\n            x_range=(ncmp.xmin, ncmp.xmax),\n            y_range=(ncmp.ymin, ncmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # ncomp contact\n\n    # labels generation\n    if lbl == 1:\n        # n_label generation\n        c.add_label(\n            n_lbl,\n            position=(\n                n_con.xmin + (n_con.size[0] / 2),\n                n_con.ymin + (n_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        # p_label generation\n        c.add_label(\n            p_lbl,\n            position=(\n                p_con.xmin + (p_con.size[0] / 2),\n                p_con.ymin + (p_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    dn_rect = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                lvpwell.size[0] + (2 * dn_enc_lvpwell),\n                lvpwell.size[1] + (2 * dn_enc_lvpwell),\n            ),\n            layer=layer[\"dnwell\"],\n        )\n    )\n\n    dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n    dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\n    if pcmpgr == 1:\n        c_temp_gr = gf.Component(\"temp_store guard ring\")\n        rect_pcmpgr_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                    (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_pcmpgr_in.move(\n            (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n        )\n        rect_pcmpgr_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n        c.add_ref(\n            gf.geometry.boolean(\n                A=rect_pcmpgr_out,\n                B=rect_pcmpgr_in,\n                operation=\"A-B\",\n                layer=layer[\"comp\"],\n            )\n        )  # guardring Bulk\n\n        psdm_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_in.move(\n            (\n                rect_pcmpgr_in.xmin + pp_enc_comp,\n                rect_pcmpgr_in.ymin + pp_enc_comp,\n            )\n        )\n        psdm_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n                    (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_out.move(\n            (\n                rect_pcmpgr_out.xmin - pp_enc_comp,\n                rect_pcmpgr_out.ymin - pp_enc_comp,\n            )\n        )\n        c.add_ref(\n            gf.geometry.boolean(\n                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n            )\n        )  # guardring psdm\n\n        # generating contacts\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_pcmpgr_in.xmin + con_size,\n                    rect_pcmpgr_in.xmax - con_size,\n                ),\n                y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # bottom contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_pcmpgr_in.xmin + con_size,\n                    rect_pcmpgr_in.xmax - con_size,\n                ),\n                y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # upper contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n                y_range=(\n                    rect_pcmpgr_in.ymin + con_size,\n                    rect_pcmpgr_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # right contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n                y_range=(\n                    rect_pcmpgr_in.ymin + con_size,\n                    rect_pcmpgr_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # left contact\n\n        comp_m1_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n                layer=layer[\"metal1\"],\n            )\n        )\n\n        comp_m1_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (comp_m1_in.size[0]) + 2 * cw,\n                    (comp_m1_in.size[1]) + 2 * cw,\n                ),\n                layer=layer[\"metal1\"],\n            )\n        )\n        comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n        c.add_ref(\n            gf.geometry.boolean(\n                A=rect_pcmpgr_out,\n                B=rect_pcmpgr_in,\n                operation=\"A-B\",\n                layer=layer[\"metal1\"],\n            )\n        )  # guardring metal1\n\n    if volt == \"5/6V\":\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    dn_rect.size[0] + (2 * dg_enc_dn),\n                    dn_rect.size[1] + (2 * dg_enc_dn),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = dn_rect.xmin - dg_enc_dn\n        dg.ymin = dn_rect.ymin - dg_enc_dn\n\n    return c", "\n\n@gf.cell\ndef diode_dw2ps(\n    la: float = 0.1,\n    wa: float = 0.1,\n    cw: float = 0.1,\n    volt: str = \"3.3V\",\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    p_lbl: str = \"\",\n    n_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw LVPWELL/DNWELL diode by specifying parameters\n    Arguments:-\n     la         : Float of diff length (anode)\n     wa         : Float of diff width (anode)\n     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n    \"\"\"\n\n    c = gf.Component(\"diode_dw2ps_dev\")\n\n    if volt == \"5/6V\":\n        dn_enc_ncmp = 0.66\n    else:\n        dn_enc_ncmp = 0.62\n\n    comp_spacing = 0.32\n    np_enc_comp: float = 0.16\n    pp_enc_comp: float = 0.16\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n\n    dg_enc_dn = 0.5\n\n    pcmpgr_enc_dn = 2.5\n\n    if (wa < ((2 * cw) + comp_spacing)) or (la < ((2 * cw) + comp_spacing)):\n        ncmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n\n        n_con = c.add_ref(\n            via_stack(\n                x_range=(ncmp.xmin, ncmp.xmax),\n                y_range=(ncmp.ymin, ncmp.ymax),\n                base_layer=layer[\"comp\"],\n                metal_level=1,\n            )\n        )  # ncomp_contact\n\n        nplus = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    ncmp.size[0] + (2 * np_enc_comp),\n                    ncmp.size[1] + (2 * np_enc_comp),\n                ),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nplus.xmin = ncmp.xmin - np_enc_comp\n        nplus.ymin = ncmp.ymin - np_enc_comp\n    else:\n        c_temp = gf.Component(\"temp_store guard ring\")\n        ncmp_in = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(wa - (2 * cw), la - (2 * cw)),\n                layer=layer[\"comp\"],\n            )\n        )\n        ncmp_out = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(wa, la),\n                layer=layer[\"comp\"],\n            )\n        )\n        ncmp_out.move((ncmp_in.xmin - cw, ncmp_in.ymin - cw))\n        ncmp = c.add_ref(\n            gf.geometry.boolean(\n                A=ncmp_out,\n                B=ncmp_in,\n                operation=\"A-B\",\n                layer=layer[\"comp\"],\n            )\n        )\n\n        pplus_in = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (ncmp_in.xmax - ncmp_in.xmin) - 2 * pp_enc_comp,\n                    (ncmp_in.ymax - ncmp_in.ymin) - 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        pplus_in.move(\n            (\n                ncmp_in.xmin + pp_enc_comp,\n                ncmp_in.ymin + pp_enc_comp,\n            )\n        )\n        pplus_out = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (ncmp_out.xmax - ncmp_out.xmin) + 2 * pp_enc_comp,\n                    (ncmp_out.ymax - ncmp_out.ymin) + 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        pplus_out.move(\n            (\n                ncmp_out.xmin - pp_enc_comp,\n                ncmp_out.ymin - pp_enc_comp,\n            )\n        )\n        c.add_ref(\n            gf.geometry.boolean(\n                A=pplus_out, B=pplus_in, operation=\"A-B\", layer=layer[\"nplus\"]\n            )\n        )  # nplus\n\n        # generating contacts\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    ncmp_in.xmin + con_size,\n                    ncmp_in.xmax - con_size,\n                ),\n                y_range=(ncmp_out.ymin, ncmp_in.ymin),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # bottom contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    ncmp_in.xmin + con_size,\n                    ncmp_in.xmax - con_size,\n                ),\n                y_range=(ncmp_in.ymax, ncmp_out.ymax),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # upper contact\n\n        n_con = c.add_ref(\n            via_generator(\n                x_range=(ncmp_out.xmin, ncmp_in.xmin),\n                y_range=(\n                    ncmp_in.ymin + con_size,\n                    ncmp_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # left contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(ncmp_in.xmax, ncmp_out.xmax),\n                y_range=(\n                    ncmp_in.ymin + con_size,\n                    ncmp_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # right contact\n\n        comp_m1_in = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(ncmp_in.size[0], ncmp_in.size[1]),\n                layer=layer[\"metal1\"],\n            )\n        )\n\n        comp_m1_out = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (comp_m1_in.size[0]) + 2 * cw,\n                    (comp_m1_in.size[0]) + 2 * cw,\n                ),\n                layer=layer[\"metal1\"],\n            )\n        )\n        comp_m1_out.move((ncmp_in.xmin - cw, ncmp_in.ymin - cw))\n        c.add_ref(\n            gf.geometry.boolean(\n                A=ncmp_out,\n                B=ncmp_in,\n                operation=\"A-B\",\n                layer=layer[\"metal1\"],\n            )\n        )  # guardring metal1\n\n    # labels generation\n    if lbl == 1:\n        # n_label generation\n        c.add_label(\n            n_lbl,\n            position=(\n                n_con.xmin + (n_con.size[0] / 2),\n                n_con.ymin + (n_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    # generate dnwell\n\n    dn_rect = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                ncmp.size[0] + (2 * dn_enc_ncmp),\n                ncmp.size[1] + (2 * dn_enc_ncmp),\n            ),\n            layer=layer[\"dnwell\"],\n        )\n    )\n    dn_rect.xmin = ncmp.xmin - dn_enc_ncmp\n    dn_rect.ymin = ncmp.ymin - dn_enc_ncmp\n\n    diode_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(dn_rect.size[0], dn_rect.size[1]), layer=layer[\"diode_mk\"]\n        )\n    )\n    diode_mk.xmin = dn_rect.xmin\n    diode_mk.ymin = dn_rect.ymin\n\n    if pcmpgr == 1:\n        c_temp_gr = gf.Component(\"temp_store guard ring\")\n        rect_pcmpgr_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                    (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_pcmpgr_in.move(\n            (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n        )\n        rect_pcmpgr_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n        c.add_ref(\n            gf.geometry.boolean(\n                A=rect_pcmpgr_out,\n                B=rect_pcmpgr_in,\n                operation=\"A-B\",\n                layer=layer[\"comp\"],\n            )\n        )  # guardring Bulk\n\n        psdm_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_in.move(\n            (\n                rect_pcmpgr_in.xmin + pp_enc_comp,\n                rect_pcmpgr_in.ymin + pp_enc_comp,\n            )\n        )\n        psdm_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n                    (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_out.move(\n            (\n                rect_pcmpgr_out.xmin - pp_enc_comp,\n                rect_pcmpgr_out.ymin - pp_enc_comp,\n            )\n        )\n        c.add_ref(\n            gf.geometry.boolean(\n                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n            )\n        )  # psdm\n\n        # generating contacts\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_pcmpgr_in.xmin + con_size,\n                    rect_pcmpgr_in.xmax - con_size,\n                ),\n                y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # bottom contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_pcmpgr_in.xmin + con_size,\n                    rect_pcmpgr_in.xmax - con_size,\n                ),\n                y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # upper contact\n\n        p_con = c.add_ref(\n            via_generator(\n                x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n                y_range=(\n                    rect_pcmpgr_in.ymin + con_size,\n                    rect_pcmpgr_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # left contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n                y_range=(\n                    rect_pcmpgr_in.ymin + con_size,\n                    rect_pcmpgr_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # right contact\n\n        # labels generation\n        if lbl == 1:\n            # n_label generation\n            c.add_label(\n                p_lbl,\n                position=(\n                    p_con.xmin + (p_con.size[0] / 2),\n                    p_con.ymin + (p_con.size[1] / 2),\n                ),\n                layer=layer[\"metal1_label\"],\n            )\n\n        comp_m1_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n                layer=layer[\"metal1\"],\n            )\n        )\n\n        comp_m1_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n                ),\n                layer=layer[\"metal1\"],\n            )\n        )\n        comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n        c.add_ref(\n            gf.geometry.boolean(\n                A=rect_pcmpgr_out,\n                B=rect_pcmpgr_in,\n                operation=\"A-B\",\n                layer=layer[\"metal1\"],\n            )\n        )  # guardring metal1\n\n    # generate dualgate\n\n    if volt == \"5/6V\":\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    dn_rect.size[0] + (2 * dg_enc_dn),\n                    dn_rect.size[1] + (2 * dg_enc_dn),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = dn_rect.xmin - dg_enc_dn\n        dg.ymin = dn_rect.ymin - dg_enc_dn\n\n    return c", "\n\n@gf.cell\ndef sc_diode(\n    la: float = 0.1,\n    wa: float = 0.1,\n    cw: float = 0.1,\n    m: int = 1,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    p_lbl: str = \"\",\n    n_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw N+/LVPWELL diode (Outside DNWELL) by specifying parameters\n    Arguments:-\n     la         : Float of diff length (anode)\n     wa         : Float of diff width (anode)\n     m          : Integer of number of fingers\n     pcmpgr     : Boolean of using P+ Guard Ring for Deep NWELL devices only\n    \"\"\"\n\n    c = gf.Component(\"sc_diode_dev\")\n\n    sc_enc_comp = 0.16\n    sc_comp_spacing = 0.28\n    dn_enc_sc_an = 1.4\n    np_enc_comp = 0.03\n    m1_w = 0.23\n    pcmpgr_enc_dn = 2.5\n    pp_enc_comp: float = 0.16\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n\n    # cathode draw\n\n    @gf.cell\n    def sc_cathode_strap(size: Float2 = (0.1, 0.1)) -> gf.Component:\n        \"\"\"Returns sc_diode cathode array element\n\n        Args :\n            size : size of cathode array element\n        \"\"\"\n\n        c = gf.Component()\n\n        ncmp = c.add_ref(gf.components.rectangle(size=size, layer=layer[\"comp\"]))\n\n        nplus = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    ncmp.size[0] + (2 * np_enc_comp),\n                    ncmp.size[1] + (2 * np_enc_comp),\n                ),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nplus.xmin = ncmp.xmin - np_enc_comp\n        nplus.ymin = ncmp.ymin - np_enc_comp\n\n        c.add_ref(\n            via_stack(\n                x_range=(ncmp.xmin, ncmp.xmax),\n                y_range=(ncmp.ymin, ncmp.ymax),\n                base_layer=layer[\"comp\"],\n                metal_level=1,\n            )\n        )  # ncomp contact\n\n        return c\n\n    @gf.cell\n    def sc_anode_strap(size: Float2 = (0.1, 0.1)) -> gf.Component:\n        \"\"\"Returns sc_diode anode array element\n\n        Args :\n            size : size of anode array element\n        \"\"\"\n\n        c = gf.Component()\n\n        cmp = c.add_ref(gf.components.rectangle(size=size, layer=layer[\"comp\"]))\n\n        c.add_ref(\n            via_stack(\n                x_range=(cmp.xmin, cmp.xmax),\n                y_range=(cmp.ymin, cmp.ymax),\n                base_layer=layer[\"comp\"],\n                metal_level=1,\n            )\n        )  # comp contact\n\n        return c\n\n    sc_an = sc_anode_strap(size=(wa, la))\n    sc_cath = sc_cathode_strap(size=(cw, la))\n\n    sc_cathode = c.add_array(\n        component=sc_cath,\n        rows=1,\n        columns=(m + 1),\n        spacing=((cw + wa + (2 * sc_comp_spacing)), 0),\n    )\n\n    cath_m1_polys = sc_cath.get_polygons(by_spec=layer[\"metal1\"])\n    cath_m1_xmin = np.min(cath_m1_polys[0][:, 0])\n    cath_m1_ymin = np.min(cath_m1_polys[0][:, 1])\n    cath_m1_xmax = np.max(cath_m1_polys[0][:, 0])\n\n    cath_m1_v = c.add_array(\n        component=gf.components.rectangle(\n            size=(\n                cath_m1_xmax - cath_m1_xmin,\n                cath_m1_ymin - sc_cathode.ymin + m1_w,\n            ),\n            layer=layer[\"metal1\"],\n        ),\n        rows=1,\n        columns=(m + 1),\n        spacing=((cw + wa + (2 * sc_comp_spacing)), 0),\n    )\n\n    cath_m1_v.xmin = cath_m1_xmin\n    cath_m1_v.ymax = cath_m1_ymin\n\n    cath_m1_h = c.add_ref(\n        gf.components.rectangle(size=(cath_m1_v.size[0], m1_w), layer=layer[\"metal1\"])\n    )\n    cath_m1_h.xmin = cath_m1_v.xmin\n    cath_m1_h.ymax = cath_m1_v.ymin\n\n    # cathode label generation\n    if lbl == 1:\n        c.add_label(\n            n_lbl,\n            position=(\n                cath_m1_h.xmin + (cath_m1_h.size[0] / 2),\n                cath_m1_h.ymin + (cath_m1_h.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    sc_anode = c.add_array(\n        component=sc_an,\n        rows=1,\n        columns=m,\n        spacing=(wa + cw + (2 * sc_comp_spacing), 0),\n    )\n\n    sc_anode.xmin = sc_cathode.xmin + (cw + sc_comp_spacing)\n\n    an_m1_polys = sc_anode.get_polygons(by_spec=layer[\"metal1\"])\n    an_m1_xmin = np.min(an_m1_polys[0][:, 0])\n    an_m1_ymin = np.min(an_m1_polys[0][:, 1])\n    an_m1_xmax = np.max(an_m1_polys[0][:, 0])\n    an_m1_ymax = np.max(an_m1_polys[0][:, 1])\n\n    if m > 1:\n        an_m1_v = c.add_array(\n            component=gf.components.rectangle(\n                size=(\n                    an_m1_xmax - an_m1_xmin,\n                    cath_m1_ymin - sc_an.ymin + m1_w,\n                ),\n                layer=layer[\"metal1\"],\n            ),\n            rows=1,\n            columns=m,\n            spacing=((cw + wa + (2 * sc_comp_spacing)), 0),\n        )\n\n        an_m1_v.xmin = an_m1_xmin\n        an_m1_v.ymin = an_m1_ymax\n\n        an_m1_h = c.add_ref(\n            gf.components.rectangle(size=(an_m1_v.size[0], m1_w), layer=layer[\"metal1\"])\n        )\n        an_m1_h.xmin = an_m1_v.xmin\n        an_m1_h.ymin = an_m1_v.ymax\n\n        # anode label generation\n        if lbl == 1:\n            c.add_label(\n                p_lbl,\n                position=(\n                    an_m1_h.xmin + (an_m1_h.size[0] / 2),\n                    an_m1_h.ymin + (an_m1_h.size[1] / 2),\n                ),\n                layer=layer[\"metal1_label\"],\n            )\n\n    else:\n        # anode label generation\n        if lbl == 1:\n            c.add_label(\n                p_lbl,\n                position=(\n                    an_m1_xmin + ((an_m1_xmax - an_m1_xmin) / 2),\n                    an_m1_ymin + ((an_m1_ymax - an_m1_ymin) / 2),\n                ),\n                layer=layer[\"metal1_label\"],\n            )\n\n    # diode_mk\n    diode_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                sc_cathode.size[0] + (2 * sc_enc_comp),\n                sc_cathode.size[1] + (2 * sc_enc_comp),\n            ),\n            layer=layer[\"schottky_diode\"],\n        )\n    )\n    diode_mk.xmin = sc_cathode.xmin - sc_enc_comp\n    diode_mk.ymin = sc_cathode.ymin - sc_enc_comp\n\n    # dnwell\n    dn_rect = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                sc_anode.size[0] + (2 * dn_enc_sc_an),\n                sc_anode.size[1] + (2 * dn_enc_sc_an),\n            ),\n            layer=layer[\"dnwell\"],\n        )\n    )\n    dn_rect.xmin = sc_anode.xmin - dn_enc_sc_an\n    dn_rect.ymin = sc_anode.ymin - dn_enc_sc_an\n\n    if pcmpgr == 1:\n        c_temp_gr = gf.Component(\"temp_store guard ring\")\n        rect_pcmpgr_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                    (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_pcmpgr_in.move(\n            (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n        )\n        rect_pcmpgr_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n        c.add_ref(\n            gf.geometry.boolean(\n                A=rect_pcmpgr_out,\n                B=rect_pcmpgr_in,\n                operation=\"A-B\",\n                layer=layer[\"comp\"],\n            )\n        )  # guardring Bulk\n\n        psdm_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_in.move(\n            (\n                rect_pcmpgr_in.xmin + pp_enc_comp,\n                rect_pcmpgr_in.ymin + pp_enc_comp,\n            )\n        )\n        psdm_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n                    (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_out.move(\n            (\n                rect_pcmpgr_out.xmin - pp_enc_comp,\n                rect_pcmpgr_out.ymin - pp_enc_comp,\n            )\n        )\n        c.add_ref(\n            gf.geometry.boolean(\n                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n            )\n        )  # psdm\n\n        # generating contacts\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_pcmpgr_in.xmin + con_size,\n                    rect_pcmpgr_in.xmax - con_size,\n                ),\n                y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # bottom contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_pcmpgr_in.xmin + con_size,\n                    rect_pcmpgr_in.xmax - con_size,\n                ),\n                y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # upper contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n                y_range=(\n                    rect_pcmpgr_in.ymin + con_size,\n                    rect_pcmpgr_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # right contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n                y_range=(\n                    rect_pcmpgr_in.ymin + con_size,\n                    rect_pcmpgr_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # left contact\n\n        comp_m1_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n                layer=layer[\"metal1\"],\n            )\n        )\n\n        comp_m1_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (comp_m1_in.size[0]) + 2 * cw,\n                    (comp_m1_in.size[1]) + 2 * cw,\n                ),\n                layer=layer[\"metal1\"],\n            )\n        )\n        comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n        c.add_ref(\n            gf.geometry.boolean(\n                A=rect_pcmpgr_out,\n                B=rect_pcmpgr_in,\n                operation=\"A-B\",\n                layer=layer[\"metal1\"],\n            )\n        )  # guardring metal1\n\n    # creating layout and cell in klayout\n    return c", "\n\nif __name__ == \"__main__\":\n    c = sc_diode()\n    c.show()\n"]}
{"filename": "gf180/cap_mos.py", "chunked_list": ["import gdsfactory as gf\nimport numpy as np\nfrom gdsfactory.typings import Float2, LayerSpec\n\nfrom gf180.layers import layer\nfrom gf180.via_generator import via_generator, via_stack\n\n\n@gf.cell\ndef cap_mos_inst(\n    lc: float = 0.1,\n    wc: float = 0.1,\n    cmp_w: float = 0.1,\n    con_w: float = 0.1,\n    pl_l: float = 0.1,\n    cmp_ext: float = 0.1,\n    pl_ext: float = 0.1,\n    implant_layer: LayerSpec = layer[\"nplus\"],\n    implant_enc: Float2 = (0.1, 0.1),\n    lbl: bool = 0,\n    g_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"Returns mos cap simple instance\n\n    Args :\n        lc : length of mos_cap\n        ws : width of mos_cap\n        cmp_w : width of layer[\"comp\"]\n        con_w : min width of comp contain contact\n        pl_l : length od layer[\"poly2\"]\n        cmp_ext : comp extension beyond poly2\n        pl_ext : poly2 extension beyond comp\n        implant_layer : Layer of implant [nplus,pplus]\n        implant_enc : enclosure of implant_layer to comp\n    \"\"\"\n\n    c_inst = gf.Component()\n\n    cmp = c_inst.add_ref(gf.components.rectangle(size=(cmp_w, wc), layer=layer[\"comp\"]))\n\n    cap_mk = c_inst.add_ref(\n        gf.components.rectangle(\n            size=(cmp.size[0], cmp.size[1]), layer=layer[\"mos_cap_mk\"]\n        )\n    )\n    cap_mk.xmin = cmp.xmin\n    cap_mk.ymin = cmp.ymin\n\n    c_inst.add_array(\n        component=via_stack(\n            x_range=(cmp.xmin, cmp.xmin + con_w),\n            y_range=(cmp.ymin, cmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        ),\n        rows=1,\n        columns=2,\n        spacing=(cmp_w - con_w, 0),\n    )  # comp contact\n\n    imp_rect = c_inst.add_ref(\n        gf.components.rectangle(\n            size=(\n                cmp.size[0] + (2 * implant_enc[0]),\n                cmp.size[1] + (2 * implant_enc[1]),\n            ),\n            layer=implant_layer,\n        )\n    )\n    imp_rect.xmin = cmp.xmin - implant_enc[0]\n    imp_rect.ymin = cmp.ymin - implant_enc[1]\n\n    poly = c_inst.add_ref(\n        gf.components.rectangle(size=(lc, pl_l), layer=layer[\"poly2\"])\n    )\n\n    poly.xmin = cmp.xmin + cmp_ext\n    poly.ymin = cmp.ymin - pl_ext\n\n    pl_con_el = via_stack(\n        x_range=(poly.xmin, poly.xmax),\n        y_range=(poly.ymin, poly.ymin + con_w),\n        base_layer=layer[\"poly2\"],\n        metal_level=1,\n    )\n\n    pl_con = c_inst.add_array(\n        component=pl_con_el,\n        rows=2,\n        columns=1,\n        spacing=(0, pl_l - con_w),\n    )\n\n    # Gate labels_generation\n\n    if lbl == 1:\n        c_inst.add_label(\n            g_lbl,\n            position=(\n                pl_con.xmin + (pl_con.size[0] / 2),\n                pl_con.ymin + (pl_con_el.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    pl_m1 = c_inst.add_ref(\n        gf.components.rectangle(\n            size=(pl_con.size[0], pl_con.size[1]), layer=layer[\"metal1\"]\n        )\n    )\n    pl_m1.xmin = pl_con.xmin\n    pl_m1.ymin = pl_con.ymin\n\n    return c_inst", "@gf.cell\ndef cap_mos_inst(\n    lc: float = 0.1,\n    wc: float = 0.1,\n    cmp_w: float = 0.1,\n    con_w: float = 0.1,\n    pl_l: float = 0.1,\n    cmp_ext: float = 0.1,\n    pl_ext: float = 0.1,\n    implant_layer: LayerSpec = layer[\"nplus\"],\n    implant_enc: Float2 = (0.1, 0.1),\n    lbl: bool = 0,\n    g_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"Returns mos cap simple instance\n\n    Args :\n        lc : length of mos_cap\n        ws : width of mos_cap\n        cmp_w : width of layer[\"comp\"]\n        con_w : min width of comp contain contact\n        pl_l : length od layer[\"poly2\"]\n        cmp_ext : comp extension beyond poly2\n        pl_ext : poly2 extension beyond comp\n        implant_layer : Layer of implant [nplus,pplus]\n        implant_enc : enclosure of implant_layer to comp\n    \"\"\"\n\n    c_inst = gf.Component()\n\n    cmp = c_inst.add_ref(gf.components.rectangle(size=(cmp_w, wc), layer=layer[\"comp\"]))\n\n    cap_mk = c_inst.add_ref(\n        gf.components.rectangle(\n            size=(cmp.size[0], cmp.size[1]), layer=layer[\"mos_cap_mk\"]\n        )\n    )\n    cap_mk.xmin = cmp.xmin\n    cap_mk.ymin = cmp.ymin\n\n    c_inst.add_array(\n        component=via_stack(\n            x_range=(cmp.xmin, cmp.xmin + con_w),\n            y_range=(cmp.ymin, cmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        ),\n        rows=1,\n        columns=2,\n        spacing=(cmp_w - con_w, 0),\n    )  # comp contact\n\n    imp_rect = c_inst.add_ref(\n        gf.components.rectangle(\n            size=(\n                cmp.size[0] + (2 * implant_enc[0]),\n                cmp.size[1] + (2 * implant_enc[1]),\n            ),\n            layer=implant_layer,\n        )\n    )\n    imp_rect.xmin = cmp.xmin - implant_enc[0]\n    imp_rect.ymin = cmp.ymin - implant_enc[1]\n\n    poly = c_inst.add_ref(\n        gf.components.rectangle(size=(lc, pl_l), layer=layer[\"poly2\"])\n    )\n\n    poly.xmin = cmp.xmin + cmp_ext\n    poly.ymin = cmp.ymin - pl_ext\n\n    pl_con_el = via_stack(\n        x_range=(poly.xmin, poly.xmax),\n        y_range=(poly.ymin, poly.ymin + con_w),\n        base_layer=layer[\"poly2\"],\n        metal_level=1,\n    )\n\n    pl_con = c_inst.add_array(\n        component=pl_con_el,\n        rows=2,\n        columns=1,\n        spacing=(0, pl_l - con_w),\n    )\n\n    # Gate labels_generation\n\n    if lbl == 1:\n        c_inst.add_label(\n            g_lbl,\n            position=(\n                pl_con.xmin + (pl_con.size[0] / 2),\n                pl_con.ymin + (pl_con_el.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    pl_m1 = c_inst.add_ref(\n        gf.components.rectangle(\n            size=(pl_con.size[0], pl_con.size[1]), layer=layer[\"metal1\"]\n        )\n    )\n    pl_m1.xmin = pl_con.xmin\n    pl_m1.ymin = pl_con.ymin\n\n    return c_inst", "\n\n@gf.cell\ndef cap_mos(\n    type: str = \"cap_nmos\",\n    lc: float = 0.1,\n    wc: float = 0.1,\n    volt: str = \"3.3V\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    g_lbl: str = \"\",\n    sd_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw NMOS capacitor (Outside DNWELL) by specifying parameters\n    Arguments:-\n     l      : Float of diff length\n     w      : Float of diff width\n    \"\"\"\n\n    c = gf.Component(\"cap_mos_dev\")\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n    con_pl_enc = 0.07\n    cmp_ext = 0.15 - con_comp_enc\n    pl_ext = 0.17 - con_pl_enc\n\n    np_enc_gate: float = 0.23\n    np_enc_cmp: float = 0.16\n\n    dg_enc_cmp = 0.24\n    dg_enc_poly = 0.4\n    lvpwell_enc_ncmp = 0.43\n    dn_enc_lvpwell = 2.5\n\n    grw = 0.36\n\n    m1_w = 1\n    pcmpgr_enc_dn = 2.5\n    m1_ext = 0.82\n    comp_pp_enc: float = 0.16\n    dnwell_enc_pcmp = 1.1\n\n    # end_cap: float = 0.22\n\n    cmp_ed_w = con_size + (2 * con_comp_enc)\n    cmp_w = (2 * (cmp_ed_w + cmp_ext)) + lc\n    end_cap = pl_ext + cmp_ed_w\n\n    pl_l = wc + (2 * end_cap)\n\n    if \"cap_nmos\" in type:\n        implant_layer = layer[\"nplus\"]\n    else:\n        implant_layer = layer[\"pplus\"]\n\n    c_inst = c.add_ref(\n        cap_mos_inst(\n            cmp_w=cmp_w,\n            lc=lc,\n            wc=wc,\n            pl_l=pl_l,\n            cmp_ext=cmp_ed_w + cmp_ext,\n            con_w=cmp_ed_w,\n            pl_ext=end_cap,\n            implant_layer=implant_layer,\n            implant_enc=(np_enc_cmp, np_enc_gate),\n            lbl=lbl,\n            g_lbl=g_lbl,\n        )\n    )\n\n    cmp_m1_polys = c_inst.get_polygons(by_spec=layer[\"metal1\"])\n    cmp_m1_xmin = np.min(cmp_m1_polys[0][:, 0])\n    cmp_m1_xmax = np.max(cmp_m1_polys[0][:, 0])\n    cmp_m1_ymax = np.max(cmp_m1_polys[0][:, 1])\n\n    # cmp_m1 = c.add_ref(gf.components.rectangle(size=(m1_w,w+m1_ext),layer=layer[\"metal1\"]))\n    cmp_m1_v = c.add_array(\n        component=gf.components.rectangle(\n            size=(m1_w, wc + m1_ext), layer=layer[\"metal1\"]\n        ),\n        rows=1,\n        columns=2,\n        spacing=(m1_w + cmp_w - 2 * cmp_ed_w, 0),\n    )\n    cmp_m1_v.xmin = cmp_m1_xmin - (m1_w - (cmp_m1_xmax - cmp_m1_xmin))\n    cmp_m1_v.ymax = cmp_m1_ymax\n\n    cmp_m1_h = c.add_ref(\n        gf.components.rectangle(size=(cmp_m1_v.size[0], m1_w), layer=layer[\"metal1\"])\n    )\n    cmp_m1_h.xmin = cmp_m1_v.xmin\n    cmp_m1_h.ymax = cmp_m1_v.ymin\n\n    # sd labels generation\n    if lbl == 1:\n        c.add_label(\n            sd_lbl,\n            position=(\n                cmp_m1_h.xmin + (cmp_m1_h.size[0] / 2),\n                cmp_m1_h.ymin + (cmp_m1_h.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    # dualgate\n\n    if volt == \"5/6V\":\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    c_inst.size[0] + (2 * dg_enc_cmp),\n                    c_inst.size[1] + (2 * dg_enc_poly),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = c_inst.xmin - dg_enc_cmp\n        dg.ymin = c_inst.ymin - dg_enc_poly\n\n    cmp_polys = c_inst.get_polygons(by_spec=layer[\"comp\"])\n    cmp_xmin = np.min(cmp_polys[0][:, 0])\n    cmp_ymin = np.min(cmp_polys[0][:, 1])\n    cmp_xmax = np.max(cmp_polys[0][:, 0])\n    cmp_ymax = np.max(cmp_polys[0][:, 1])\n\n    if \"_b\" in type:\n        if \"cap_nmos\" in type:\n            nwell = c.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        cmp_xmax - cmp_xmin + (2 * np_enc_cmp),\n                        cmp_ymax - cmp_ymin + (2 * np_enc_gate),\n                    ),\n                    layer=layer[\"nwell\"],\n                )\n            )\n            nwell.xmin = cmp_xmin - np_enc_cmp\n            nwell.ymin = cmp_ymin - np_enc_gate\n        else:\n            lvpwell = c.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        cmp_xmax - cmp_xmin + (2 * np_enc_cmp),\n                        cmp_ymax - cmp_ymin + (2 * np_enc_gate),\n                    ),\n                    layer=layer[\"lvpwell\"],\n                )\n            )\n\n            lvpwell.xmin = cmp_xmin - np_enc_cmp\n            lvpwell.ymin = cmp_ymin - np_enc_gate\n\n    if deepnwell == 1:\n        if type == \"cap_nmos\":\n            lvp_rect = c.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        c_inst.size[0] + (2 * lvpwell_enc_ncmp),\n                        c_inst.size[1] + (2 * lvpwell_enc_ncmp),\n                    ),\n                    layer=layer[\"lvpwell\"],\n                )\n            )\n\n            lvp_rect.xmin = c_inst.xmin - lvpwell_enc_ncmp\n            lvp_rect.ymin = c_inst.ymin - lvpwell_enc_ncmp\n\n            dn_rect = c.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        lvp_rect.size[0] + (2 * dn_enc_lvpwell),\n                        lvp_rect.size[1] + (2 * dn_enc_lvpwell),\n                    ),\n                    layer=layer[\"nwell\"],\n                )\n            )\n\n            dn_rect.xmin = lvp_rect.xmin - dn_enc_lvpwell\n            dn_rect.ymin = lvp_rect.ymin - dn_enc_lvpwell\n\n        else:\n            dn_rect = c.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        c_inst.size[0] + (2 * dnwell_enc_pcmp),\n                        c_inst.size[1] + (2 * dnwell_enc_pcmp),\n                    ),\n                    layer=layer[\"nwell\"],\n                )\n            )\n\n            dn_rect.xmin = c_inst.xmin - dnwell_enc_pcmp\n            dn_rect.ymin = c_inst.ymin - dnwell_enc_pcmp\n\n        if pcmpgr == 1:\n            c_temp_gr = gf.Component(\"temp_store guard ring\")\n            rect_pcmpgr_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                        (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_in.move(\n                (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n            )\n            rect_pcmpgr_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * grw,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * grw,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"comp\"],\n                )\n            )  # guardring Bullk\n\n            psdm_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * comp_pp_enc,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * comp_pp_enc,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_in.move(\n                (\n                    rect_pcmpgr_in.xmin + comp_pp_enc,\n                    rect_pcmpgr_in.ymin + comp_pp_enc,\n                )\n            )\n            psdm_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * comp_pp_enc,\n                        (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * comp_pp_enc,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_out.move(\n                (\n                    rect_pcmpgr_out.xmin - comp_pp_enc,\n                    rect_pcmpgr_out.ymin - comp_pp_enc,\n                )\n            )\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n                )\n            )  # psdm\n\n            # generating contacts\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # bottom contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # upper contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # right contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # left contact\n\n            comp_m1_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n                    layer=layer[\"metal1\"],\n                )\n            )\n\n            comp_m1_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (comp_m1_in.size[0]) + 2 * grw,\n                        (comp_m1_in.size[1]) + 2 * grw,\n                    ),\n                    layer=layer[\"metal1\"],\n                )\n            )\n            comp_m1_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"metal1\"],\n                )\n            )  # guardring metal1\n\n    return c", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/draw_diode.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n########################################################################################################################\n## Diode Pcells Generators for Klayout of GF180MCU\n########################################################################################################################\n", "########################################################################################################################\n\nimport gdsfactory as gf\nimport numpy as np\nfrom gdsfactory.typings import Float2\n\nfrom .layers_def import layer\nfrom .via_generator import via_generator, via_stack\n\n\ndef draw_diode_nd2ps(\n    layout,\n    la: float = 0.1,\n    wa: float = 0.1,\n    cw: float = 0.1,\n    volt: str = \"3.3V\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    p_lbl: str = \"\",\n    n_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw N+/LVPWELL diode (Outside DNWELL) by specifying parameters\n    Arguments:-\n     layout     : Object of layout\n     la         : Float of diff length (anode)\n     wa         : Float of diff width (anode)\n     cw         : Float of cathode width\n     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n     deepnwell  : Boolean of using Deep NWELL device\n     pcmpgr     : Boolean of using P+ Guard Ring for Deep NWELL devices only\n    \"\"\"\n\n    c = gf.Component(\"diode_nd2ps_dev\")\n\n    comp_spacing: float = 0.48\n    np_enc_comp: float = 0.16\n    pp_enc_comp: float = 0.16\n\n    # n generation\n    ncmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n    nplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                ncmp.size[0] + (2 * np_enc_comp),\n                ncmp.size[1] + (2 * np_enc_comp),\n            ),\n            layer=layer[\"nplus\"],\n        )\n    )\n    nplus.xmin = ncmp.xmin - np_enc_comp\n    nplus.ymin = ncmp.ymin - np_enc_comp\n    diode_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(ncmp.size[0], ncmp.size[1]), layer=layer[\"diode_mk\"]\n        )\n    )\n    diode_mk.xmin = ncmp.xmin\n    diode_mk.ymin = ncmp.ymin\n\n    ncmp_con = c.add_ref(\n        via_stack(\n            x_range=(ncmp.xmin, ncmp.xmax),\n            y_range=(ncmp.ymin, ncmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # ncomp_con\n\n    # p generation\n    pcmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n    pcmp.xmax = ncmp.xmin - comp_spacing\n    pplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                pcmp.size[0] + (2 * pp_enc_comp),\n                pcmp.size[1] + (2 * pp_enc_comp),\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    pplus.xmin = pcmp.xmin - pp_enc_comp\n    pplus.ymin = pcmp.ymin - pp_enc_comp\n\n    pcmp_con = c.add_ref(\n        via_stack(\n            x_range=(pcmp.xmin, pcmp.xmax),\n            y_range=(pcmp.ymin, pcmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # pcomp_con\n\n    # labels generation\n    if lbl == 1:\n        # n_label generation\n        c.add_label(\n            n_lbl,\n            position=(\n                ncmp_con.xmin + (ncmp_con.size[0] / 2),\n                ncmp_con.ymin + (ncmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        # p_label generation\n        c.add_label(\n            p_lbl,\n            position=(\n                pcmp_con.xmin + (pcmp_con.size[0] / 2),\n                pcmp_con.ymin + (pcmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    if volt == \"5/6V\":\n        dg_enc_cmp = 0.24\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    ncmp.xmax - pcmp.xmin + (2 * dg_enc_cmp),\n                    ncmp.size[1] + (2 * dg_enc_cmp),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = pcmp.xmin - dg_enc_cmp\n        dg.ymin = pcmp.ymin - dg_enc_cmp\n\n    if deepnwell == 1:\n        lvpwell_enc_ncmp = 0.6\n        lvpwell_enc_pcmp = 0.16\n        lvpwell = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    ncmp.xmax - pcmp.xmin + (lvpwell_enc_ncmp + lvpwell_enc_pcmp),\n                    ncmp.size[1] + (2 * lvpwell_enc_ncmp),\n                ),\n                layer=layer[\"lvpwell\"],\n            )\n        )\n\n        lvpwell.xmin = pcmp.xmin - lvpwell_enc_pcmp\n        lvpwell.ymin = ncmp.ymin - lvpwell_enc_ncmp\n\n        dn_enc_lvpwell = 2.5\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    lvpwell.size[0] + (2 * dn_enc_lvpwell),\n                    lvpwell.size[1] + (2 * dn_enc_lvpwell),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n\n        dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n        dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\n        if pcmpgr == 1:\n            c_temp_gr = gf.Component(\"temp_store guard ring\")\n            pcmpgr_enc_dn = 2.5\n\n            rect_pcmpgr_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                        (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_in.move(\n                (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n            )\n            rect_pcmpgr_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"comp\"],\n                )\n            )  # guardring Bulk draw\n\n            psdm_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_in.move(\n                (\n                    rect_pcmpgr_in.xmin + pp_enc_comp,\n                    rect_pcmpgr_in.ymin + pp_enc_comp,\n                )\n            )\n            psdm_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n                        (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_out.move(\n                (\n                    rect_pcmpgr_out.xmin - pp_enc_comp,\n                    rect_pcmpgr_out.ymin - pp_enc_comp,\n                )\n            )\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n                )\n            )  # psdm draw\n\n            con_size = 0.22\n            con_sp = 0.28\n            con_comp_enc = 0.07\n\n            # generating contacts\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # bottom contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # upper contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # right contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # left contact\n\n            comp_m1_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n                    layer=layer[\"metal1\"],\n                )\n            )\n\n            comp_m1_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (comp_m1_in.size[0]) + 2 * cw,\n                        (comp_m1_in.size[1]) + 2 * cw,\n                    ),\n                    layer=layer[\"metal1\"],\n                )\n            )\n            comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"metal1\"],\n                )\n            )  # guardring metal1\n\n    # creating layout and cell in klayout\n\n    c.write_gds(\"diode_nd2ps_temp.gds\")\n    layout.read(\"diode_nd2ps_temp.gds\")\n    cell_name = \"diode_nd2ps_dev\"\n\n    return layout.cell(cell_name)", "\n\ndef draw_diode_nd2ps(\n    layout,\n    la: float = 0.1,\n    wa: float = 0.1,\n    cw: float = 0.1,\n    volt: str = \"3.3V\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    p_lbl: str = \"\",\n    n_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw N+/LVPWELL diode (Outside DNWELL) by specifying parameters\n    Arguments:-\n     layout     : Object of layout\n     la         : Float of diff length (anode)\n     wa         : Float of diff width (anode)\n     cw         : Float of cathode width\n     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n     deepnwell  : Boolean of using Deep NWELL device\n     pcmpgr     : Boolean of using P+ Guard Ring for Deep NWELL devices only\n    \"\"\"\n\n    c = gf.Component(\"diode_nd2ps_dev\")\n\n    comp_spacing: float = 0.48\n    np_enc_comp: float = 0.16\n    pp_enc_comp: float = 0.16\n\n    # n generation\n    ncmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n    nplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                ncmp.size[0] + (2 * np_enc_comp),\n                ncmp.size[1] + (2 * np_enc_comp),\n            ),\n            layer=layer[\"nplus\"],\n        )\n    )\n    nplus.xmin = ncmp.xmin - np_enc_comp\n    nplus.ymin = ncmp.ymin - np_enc_comp\n    diode_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(ncmp.size[0], ncmp.size[1]), layer=layer[\"diode_mk\"]\n        )\n    )\n    diode_mk.xmin = ncmp.xmin\n    diode_mk.ymin = ncmp.ymin\n\n    ncmp_con = c.add_ref(\n        via_stack(\n            x_range=(ncmp.xmin, ncmp.xmax),\n            y_range=(ncmp.ymin, ncmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # ncomp_con\n\n    # p generation\n    pcmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n    pcmp.xmax = ncmp.xmin - comp_spacing\n    pplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                pcmp.size[0] + (2 * pp_enc_comp),\n                pcmp.size[1] + (2 * pp_enc_comp),\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    pplus.xmin = pcmp.xmin - pp_enc_comp\n    pplus.ymin = pcmp.ymin - pp_enc_comp\n\n    pcmp_con = c.add_ref(\n        via_stack(\n            x_range=(pcmp.xmin, pcmp.xmax),\n            y_range=(pcmp.ymin, pcmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # pcomp_con\n\n    # labels generation\n    if lbl == 1:\n        # n_label generation\n        c.add_label(\n            n_lbl,\n            position=(\n                ncmp_con.xmin + (ncmp_con.size[0] / 2),\n                ncmp_con.ymin + (ncmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        # p_label generation\n        c.add_label(\n            p_lbl,\n            position=(\n                pcmp_con.xmin + (pcmp_con.size[0] / 2),\n                pcmp_con.ymin + (pcmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    if volt == \"5/6V\":\n        dg_enc_cmp = 0.24\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    ncmp.xmax - pcmp.xmin + (2 * dg_enc_cmp),\n                    ncmp.size[1] + (2 * dg_enc_cmp),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = pcmp.xmin - dg_enc_cmp\n        dg.ymin = pcmp.ymin - dg_enc_cmp\n\n    if deepnwell == 1:\n        lvpwell_enc_ncmp = 0.6\n        lvpwell_enc_pcmp = 0.16\n        lvpwell = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    ncmp.xmax - pcmp.xmin + (lvpwell_enc_ncmp + lvpwell_enc_pcmp),\n                    ncmp.size[1] + (2 * lvpwell_enc_ncmp),\n                ),\n                layer=layer[\"lvpwell\"],\n            )\n        )\n\n        lvpwell.xmin = pcmp.xmin - lvpwell_enc_pcmp\n        lvpwell.ymin = ncmp.ymin - lvpwell_enc_ncmp\n\n        dn_enc_lvpwell = 2.5\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    lvpwell.size[0] + (2 * dn_enc_lvpwell),\n                    lvpwell.size[1] + (2 * dn_enc_lvpwell),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n\n        dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n        dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\n        if pcmpgr == 1:\n            c_temp_gr = gf.Component(\"temp_store guard ring\")\n            pcmpgr_enc_dn = 2.5\n\n            rect_pcmpgr_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                        (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_in.move(\n                (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n            )\n            rect_pcmpgr_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"comp\"],\n                )\n            )  # guardring Bulk draw\n\n            psdm_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_in.move(\n                (\n                    rect_pcmpgr_in.xmin + pp_enc_comp,\n                    rect_pcmpgr_in.ymin + pp_enc_comp,\n                )\n            )\n            psdm_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n                        (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_out.move(\n                (\n                    rect_pcmpgr_out.xmin - pp_enc_comp,\n                    rect_pcmpgr_out.ymin - pp_enc_comp,\n                )\n            )\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n                )\n            )  # psdm draw\n\n            con_size = 0.22\n            con_sp = 0.28\n            con_comp_enc = 0.07\n\n            # generating contacts\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # bottom contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # upper contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # right contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # left contact\n\n            comp_m1_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n                    layer=layer[\"metal1\"],\n                )\n            )\n\n            comp_m1_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (comp_m1_in.size[0]) + 2 * cw,\n                        (comp_m1_in.size[1]) + 2 * cw,\n                    ),\n                    layer=layer[\"metal1\"],\n                )\n            )\n            comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"metal1\"],\n                )\n            )  # guardring metal1\n\n    # creating layout and cell in klayout\n\n    c.write_gds(\"diode_nd2ps_temp.gds\")\n    layout.read(\"diode_nd2ps_temp.gds\")\n    cell_name = \"diode_nd2ps_dev\"\n\n    return layout.cell(cell_name)", "\n\ndef draw_diode_pd2nw(\n    layout,\n    la: float = 0.1,\n    wa: float = 0.1,\n    cw: float = 0.1,\n    volt: str = \"3.3V\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    p_lbl: str = \"\",\n    n_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw 3.3V P+/Nwell diode (Outside DNWELL) by specifying parameters\n    Arguments:-\n     layout     : Object of layout\n     la         : Float of diffusion length (anode)\n     wa         : Float of diffusion width (anode)\n     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n     deepnwell  : Boolean of using Deep NWELL device\n     pcmpgr     : Boolean of using P+ Guard Ring for Deep NWELL devices only\n    \"\"\"\n\n    c = gf.Component(\"diode_pd2nw_dev\")\n\n    comp_spacing: float = 0.48\n    np_enc_comp: float = 0.16\n    pp_enc_comp: float = 0.16\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n\n    dg_enc_cmp = 0.24\n    dn_enc_nwell = 0.5\n    nwell_ncmp_enc = 0.12\n    nwell_pcmp_enc = 0.43\n    pcmpgr_enc_dn = 2.5\n\n    # p generation\n    pcmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n    pplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                pcmp.size[0] + (2 * pp_enc_comp),\n                pcmp.size[1] + (2 * pp_enc_comp),\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    pplus.xmin = pcmp.xmin - pp_enc_comp\n    pplus.ymin = pcmp.ymin - pp_enc_comp\n    diode_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(pcmp.size[0], pcmp.size[1]), layer=layer[\"diode_mk\"]\n        )\n    )\n    diode_mk.xmin = pcmp.xmin\n    diode_mk.ymin = pcmp.ymin\n\n    pcmp_con = c.add_ref(\n        via_stack(\n            x_range=(pcmp.xmin, pcmp.xmax),\n            y_range=(pcmp.ymin, pcmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # pcomp_contact\n\n    # n generation\n    ncmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n    ncmp.xmax = pcmp.xmin - comp_spacing\n    nplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                ncmp.size[0] + (2 * np_enc_comp),\n                ncmp.size[1] + (2 * np_enc_comp),\n            ),\n            layer=layer[\"nplus\"],\n        )\n    )\n    nplus.xmin = ncmp.xmin - np_enc_comp\n    nplus.ymin = ncmp.ymin - np_enc_comp\n\n    ncmp_con = c.add_ref(\n        via_stack(\n            x_range=(ncmp.xmin, ncmp.xmax),\n            y_range=(ncmp.ymin, ncmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # ncomp contact\n\n    # labels generation\n    if lbl == 1:\n        # n_label generation\n        c.add_label(\n            n_lbl,\n            position=(\n                ncmp_con.xmin + (ncmp_con.size[0] / 2),\n                ncmp_con.ymin + (ncmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        # p_label generation\n        c.add_label(\n            p_lbl,\n            position=(\n                pcmp_con.xmin + (pcmp_con.size[0] / 2),\n                pcmp_con.ymin + (pcmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    if volt == \"5/6V\":\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    pcmp.xmax - ncmp.xmin + (2 * dg_enc_cmp),\n                    ncmp.size[1] + (2 * dg_enc_cmp),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = ncmp.xmin - dg_enc_cmp\n        dg.ymin = ncmp.ymin - dg_enc_cmp\n\n    # nwell generation\n    nwell = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                pcmp.xmax - ncmp.xmin + (nwell_ncmp_enc + nwell_pcmp_enc),\n                pcmp.size[1] + (2 * nwell_pcmp_enc),\n            ),\n            layer=layer[\"nwell\"],\n        )\n    )\n\n    nwell.xmin = ncmp.xmin - nwell_ncmp_enc\n    nwell.ymin = pcmp.ymin - nwell_pcmp_enc\n\n    if deepnwell == 1:\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    nwell.size[0] + (2 * dn_enc_nwell),\n                    nwell.size[1] + (2 * dn_enc_nwell),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n\n        dn_rect.xmin = nwell.xmin - dn_enc_nwell\n        dn_rect.ymin = nwell.ymin - dn_enc_nwell\n\n        if pcmpgr == 1:\n            c_temp_gr = gf.Component(\"temp_store guard ring\")\n            rect_pcmpgr_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                        (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_in.move(\n                (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n            )\n            rect_pcmpgr_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"comp\"],\n                )\n            )  # Bulk guardring\n\n            psdm_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_in.move(\n                (\n                    rect_pcmpgr_in.xmin + pp_enc_comp,\n                    rect_pcmpgr_in.ymin + pp_enc_comp,\n                )\n            )\n            psdm_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n                        (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_out.move(\n                (\n                    rect_pcmpgr_out.xmin - pp_enc_comp,\n                    rect_pcmpgr_out.ymin - pp_enc_comp,\n                )\n            )\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n                )\n            )  # psdm guardring\n\n            # generating contacts\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # bottom contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # upper contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # right contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # left contact\n\n            comp_m1_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n                    layer=layer[\"metal1\"],\n                )\n            )\n\n            comp_m1_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (comp_m1_in.size[0]) + 2 * cw,\n                        (comp_m1_in.size[1]) + 2 * cw,\n                    ),\n                    layer=layer[\"metal1\"],\n                )\n            )\n            comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"metal1\"],\n                )\n            )  # guardring metal1\n\n    # creating layout and cell in klayout\n\n    c.write_gds(\"diode_pd2nw_temp.gds\")\n    layout.read(\"diode_pd2nw_temp.gds\")\n    cell_name = \"diode_pd2nw_dev\"\n\n    return layout.cell(cell_name)", "\n\ndef draw_diode_nw2ps(\n    layout,\n    la: float = 0.1,\n    wa: float = 0.1,\n    cw: float = 0.1,\n    volt: str = \"3.3V\",\n    lbl: bool = 0,\n    p_lbl: str = \"\",\n    n_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw 3.3V Nwell/Psub diode by specifying parameters\n    Arguments:-\n     layout     : Object of layout\n     la         : Float of diff length (anode)\n     wa         : Float of diff width (anode)\n     cw         : Float of Cathode width\n     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n    \"\"\"\n\n    c = gf.Component(\"diode_nw2ps_dev\")\n\n    comp_spacing: float = 0.48\n    np_enc_comp: float = 0.16\n    pp_enc_comp: float = 0.16\n\n    dg_enc_cmp = 0.24\n\n    nwell_ncmp_enc = 0.16\n\n    # n generation\n    ncmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n    nplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                ncmp.size[0] + (2 * np_enc_comp),\n                ncmp.size[1] + (2 * np_enc_comp),\n            ),\n            layer=layer[\"nplus\"],\n        )\n    )\n    nplus.xmin = ncmp.xmin - np_enc_comp\n    nplus.ymin = ncmp.ymin - np_enc_comp\n    diode_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(ncmp.size[0], ncmp.size[1]), layer=layer[\"diode_mk\"]\n        )\n    )\n    diode_mk.xmin = ncmp.xmin\n    diode_mk.ymin = ncmp.ymin\n\n    nwell = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                ncmp.size[0] + (2 * nwell_ncmp_enc),\n                ncmp.size[1] + (2 * nwell_ncmp_enc),\n            ),\n            layer=layer[\"nwell\"],\n        )\n    )\n    nwell.xmin = ncmp.xmin - nwell_ncmp_enc\n    nwell.ymin = ncmp.ymin - nwell_ncmp_enc\n\n    n_con = c.add_ref(\n        via_stack(\n            x_range=(ncmp.xmin, ncmp.xmax),\n            y_range=(ncmp.ymin, ncmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # ncomp contact\n\n    # p generation\n    pcmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n    pcmp.xmax = ncmp.xmin - comp_spacing\n    pplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                pcmp.size[0] + (2 * pp_enc_comp),\n                pcmp.size[1] + (2 * pp_enc_comp),\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    pplus.xmin = pcmp.xmin - pp_enc_comp\n    pplus.ymin = pcmp.ymin - pp_enc_comp\n\n    p_con = c.add_ref(\n        via_stack(\n            x_range=(pcmp.xmin, pcmp.xmax),\n            y_range=(pcmp.ymin, pcmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # pcmop contact\n\n    # labels generation\n    if lbl == 1:\n        # n_label generation\n        c.add_label(\n            n_lbl,\n            position=(\n                n_con.xmin + (n_con.size[0] / 2),\n                n_con.ymin + (n_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        # p_label generation\n        c.add_label(\n            p_lbl,\n            position=(\n                p_con.xmin + (p_con.size[0] / 2),\n                p_con.ymin + (p_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    if volt == \"5/6V\":\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    ncmp.xmax - pcmp.xmin + (2 * dg_enc_cmp),\n                    ncmp.size[1] + (2 * dg_enc_cmp),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = pcmp.xmin - dg_enc_cmp\n        dg.ymin = pcmp.ymin - dg_enc_cmp\n\n    # creating layout and cell in klayout\n\n    c.write_gds(\"diode_nw2ps_temp.gds\")\n    layout.read(\"diode_nw2ps_temp.gds\")\n    cell_name = \"diode_nw2ps_dev\"\n\n    return layout.cell(cell_name)", "\n\ndef draw_diode_pw2dw(\n    layout,\n    la: float = 0.1,\n    wa: float = 0.1,\n    cw: float = 0.1,\n    volt: str = \"3.3V\",\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    p_lbl: str = \"\",\n    n_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw LVPWELL/DNWELL diode by specifying parameters\n    Arguments:-\n     layout     : Object of layout\n     la         : Float of diff length (anode)\n     wa         : Float of diff width (anode)\n     cw         : Float of cathode width\n     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n    \"\"\"\n\n    c = gf.Component(\"diode_pw2dw_dev\")\n\n    comp_spacing: float = 0.48\n    np_enc_comp: float = 0.16\n    pp_enc_comp: float = 0.16\n\n    dg_enc_dn = 0.5\n\n    lvpwell_enc_pcmp = 0.16\n    dn_enc_lvpwell = 2.5\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n\n    pcmpgr_enc_dn = 2.5\n\n    # p generation\n    pcmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n    pplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                pcmp.size[0] + (2 * pp_enc_comp),\n                pcmp.size[1] + (2 * pp_enc_comp),\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    pplus.xmin = pcmp.xmin - pp_enc_comp\n    pplus.ymin = pcmp.ymin - pp_enc_comp\n    diode_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(pcmp.size[0], pcmp.size[1]), layer=layer[\"diode_mk\"]\n        )\n    )\n    diode_mk.xmin = pcmp.xmin\n    diode_mk.ymin = pcmp.ymin\n\n    lvpwell = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                pcmp.size[0] + (2 * lvpwell_enc_pcmp),\n                pcmp.size[1] + (2 * lvpwell_enc_pcmp),\n            ),\n            layer=layer[\"lvpwell\"],\n        )\n    )\n    lvpwell.xmin = pcmp.xmin - lvpwell_enc_pcmp\n    lvpwell.ymin = pcmp.ymin - lvpwell_enc_pcmp\n\n    p_con = c.add_ref(\n        via_stack(\n            x_range=(pcmp.xmin, pcmp.xmax),\n            y_range=(pcmp.ymin, pcmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # pcomp_contact\n\n    # n generation\n    ncmp = c.add_ref(gf.components.rectangle(size=(cw, la), layer=layer[\"comp\"]))\n    ncmp.xmax = pcmp.xmin - comp_spacing\n    nplus = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                ncmp.size[0] + (2 * np_enc_comp),\n                ncmp.size[1] + (2 * np_enc_comp),\n            ),\n            layer=layer[\"nplus\"],\n        )\n    )\n    nplus.xmin = ncmp.xmin - np_enc_comp\n    nplus.ymin = ncmp.ymin - np_enc_comp\n\n    n_con = c.add_ref(\n        via_stack(\n            x_range=(ncmp.xmin, ncmp.xmax),\n            y_range=(ncmp.ymin, ncmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )  # ncomp contact\n\n    # labels generation\n    if lbl == 1:\n        # n_label generation\n        c.add_label(\n            n_lbl,\n            position=(\n                n_con.xmin + (n_con.size[0] / 2),\n                n_con.ymin + (n_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        # p_label generation\n        c.add_label(\n            p_lbl,\n            position=(\n                p_con.xmin + (p_con.size[0] / 2),\n                p_con.ymin + (p_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    dn_rect = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                lvpwell.size[0] + (2 * dn_enc_lvpwell),\n                lvpwell.size[1] + (2 * dn_enc_lvpwell),\n            ),\n            layer=layer[\"dnwell\"],\n        )\n    )\n\n    dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n    dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\n    if pcmpgr == 1:\n        c_temp_gr = gf.Component(\"temp_store guard ring\")\n        rect_pcmpgr_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                    (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_pcmpgr_in.move(\n            (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n        )\n        rect_pcmpgr_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n        c.add_ref(\n            gf.geometry.boolean(\n                A=rect_pcmpgr_out,\n                B=rect_pcmpgr_in,\n                operation=\"A-B\",\n                layer=layer[\"comp\"],\n            )\n        )  # guardring Bulk\n\n        psdm_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_in.move(\n            (\n                rect_pcmpgr_in.xmin + pp_enc_comp,\n                rect_pcmpgr_in.ymin + pp_enc_comp,\n            )\n        )\n        psdm_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n                    (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_out.move(\n            (\n                rect_pcmpgr_out.xmin - pp_enc_comp,\n                rect_pcmpgr_out.ymin - pp_enc_comp,\n            )\n        )\n        c.add_ref(\n            gf.geometry.boolean(\n                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n            )\n        )  # guardring psdm\n\n        # generating contacts\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_pcmpgr_in.xmin + con_size,\n                    rect_pcmpgr_in.xmax - con_size,\n                ),\n                y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # bottom contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_pcmpgr_in.xmin + con_size,\n                    rect_pcmpgr_in.xmax - con_size,\n                ),\n                y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # upper contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n                y_range=(\n                    rect_pcmpgr_in.ymin + con_size,\n                    rect_pcmpgr_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # right contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n                y_range=(\n                    rect_pcmpgr_in.ymin + con_size,\n                    rect_pcmpgr_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # left contact\n\n        comp_m1_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n                layer=layer[\"metal1\"],\n            )\n        )\n\n        comp_m1_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (comp_m1_in.size[0]) + 2 * cw,\n                    (comp_m1_in.size[1]) + 2 * cw,\n                ),\n                layer=layer[\"metal1\"],\n            )\n        )\n        comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n        c.add_ref(\n            gf.geometry.boolean(\n                A=rect_pcmpgr_out,\n                B=rect_pcmpgr_in,\n                operation=\"A-B\",\n                layer=layer[\"metal1\"],\n            )\n        )  # guardring metal1\n\n    if volt == \"5/6V\":\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    dn_rect.size[0] + (2 * dg_enc_dn),\n                    dn_rect.size[1] + (2 * dg_enc_dn),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = dn_rect.xmin - dg_enc_dn\n        dg.ymin = dn_rect.ymin - dg_enc_dn\n\n    # creating layout and cell in klayout\n\n    c.write_gds(\"diode_pw2dw_temp.gds\")\n    layout.read(\"diode_pw2dw_temp.gds\")\n    cell_name = \"diode_pw2dw_dev\"\n\n    return layout.cell(cell_name)", "\n\ndef draw_diode_dw2ps(\n    layout,\n    la: float = 0.1,\n    wa: float = 0.1,\n    cw: float = 0.1,\n    volt: str = \"3.3V\",\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    p_lbl: str = \"\",\n    n_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw LVPWELL/DNWELL diode by specifying parameters\n    Arguments:-\n     layout     : Object of layout\n     la         : Float of diff length (anode)\n     wa         : Float of diff width (anode)\n     volt       : String of operating voltage of the diode [3.3V, 5V/6V]\n    \"\"\"\n\n    c = gf.Component(\"diode_dw2ps_dev\")\n\n    if volt == \"5/6V\":\n        dn_enc_ncmp = 0.66\n    else:\n        dn_enc_ncmp = 0.62\n\n    comp_spacing = 0.32\n    np_enc_comp: float = 0.16\n    pp_enc_comp: float = 0.16\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n\n    dg_enc_dn = 0.5\n\n    pcmpgr_enc_dn = 2.5\n\n    if (wa < ((2 * cw) + comp_spacing)) or (la < ((2 * cw) + comp_spacing)):\n        ncmp = c.add_ref(gf.components.rectangle(size=(wa, la), layer=layer[\"comp\"]))\n\n        n_con = c.add_ref(\n            via_stack(\n                x_range=(ncmp.xmin, ncmp.xmax),\n                y_range=(ncmp.ymin, ncmp.ymax),\n                base_layer=layer[\"comp\"],\n                metal_level=1,\n            )\n        )  # ncomp_contact\n\n        nplus = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    ncmp.size[0] + (2 * np_enc_comp),\n                    ncmp.size[1] + (2 * np_enc_comp),\n                ),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nplus.xmin = ncmp.xmin - np_enc_comp\n        nplus.ymin = ncmp.ymin - np_enc_comp\n    else:\n        c_temp = gf.Component(\"temp_store guard ring\")\n        ncmp_in = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(wa - (2 * cw), la - (2 * cw)),\n                layer=layer[\"comp\"],\n            )\n        )\n        ncmp_out = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(wa, la),\n                layer=layer[\"comp\"],\n            )\n        )\n        ncmp_out.move((ncmp_in.xmin - cw, ncmp_in.ymin - cw))\n        ncmp = c.add_ref(\n            gf.geometry.boolean(\n                A=ncmp_out,\n                B=ncmp_in,\n                operation=\"A-B\",\n                layer=layer[\"comp\"],\n            )\n        )\n\n        pplus_in = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (ncmp_in.xmax - ncmp_in.xmin) - 2 * pp_enc_comp,\n                    (ncmp_in.ymax - ncmp_in.ymin) - 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        pplus_in.move(\n            (\n                ncmp_in.xmin + pp_enc_comp,\n                ncmp_in.ymin + pp_enc_comp,\n            )\n        )\n        pplus_out = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (ncmp_out.xmax - ncmp_out.xmin) + 2 * pp_enc_comp,\n                    (ncmp_out.ymax - ncmp_out.ymin) + 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        pplus_out.move(\n            (\n                ncmp_out.xmin - pp_enc_comp,\n                ncmp_out.ymin - pp_enc_comp,\n            )\n        )\n        c.add_ref(\n            gf.geometry.boolean(\n                A=pplus_out, B=pplus_in, operation=\"A-B\", layer=layer[\"nplus\"]\n            )\n        )  # nplus\n\n        # generating contacts\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    ncmp_in.xmin + con_size,\n                    ncmp_in.xmax - con_size,\n                ),\n                y_range=(ncmp_out.ymin, ncmp_in.ymin),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # bottom contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    ncmp_in.xmin + con_size,\n                    ncmp_in.xmax - con_size,\n                ),\n                y_range=(ncmp_in.ymax, ncmp_out.ymax),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # upper contact\n\n        n_con = c.add_ref(\n            via_generator(\n                x_range=(ncmp_out.xmin, ncmp_in.xmin),\n                y_range=(\n                    ncmp_in.ymin + con_size,\n                    ncmp_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # left contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(ncmp_in.xmax, ncmp_out.xmax),\n                y_range=(\n                    ncmp_in.ymin + con_size,\n                    ncmp_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # right contact\n\n        comp_m1_in = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(ncmp_in.size[0], ncmp_in.size[1]),\n                layer=layer[\"metal1\"],\n            )\n        )\n\n        comp_m1_out = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (comp_m1_in.size[0]) + 2 * cw,\n                    (comp_m1_in.size[0]) + 2 * cw,\n                ),\n                layer=layer[\"metal1\"],\n            )\n        )\n        comp_m1_out.move((ncmp_in.xmin - cw, ncmp_in.ymin - cw))\n        c.add_ref(\n            gf.geometry.boolean(\n                A=ncmp_out,\n                B=ncmp_in,\n                operation=\"A-B\",\n                layer=layer[\"metal1\"],\n            )\n        )  # guardring metal1\n\n    # labels generation\n    if lbl == 1:\n        # n_label generation\n        c.add_label(\n            n_lbl,\n            position=(\n                n_con.xmin + (n_con.size[0] / 2),\n                n_con.ymin + (n_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    # generate dnwell\n\n    dn_rect = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                ncmp.size[0] + (2 * dn_enc_ncmp),\n                ncmp.size[1] + (2 * dn_enc_ncmp),\n            ),\n            layer=layer[\"dnwell\"],\n        )\n    )\n    dn_rect.xmin = ncmp.xmin - dn_enc_ncmp\n    dn_rect.ymin = ncmp.ymin - dn_enc_ncmp\n\n    diode_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(dn_rect.size[0], dn_rect.size[1]), layer=layer[\"diode_mk\"]\n        )\n    )\n    diode_mk.xmin = dn_rect.xmin\n    diode_mk.ymin = dn_rect.ymin\n\n    if pcmpgr == 1:\n        c_temp_gr = gf.Component(\"temp_store guard ring\")\n        rect_pcmpgr_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                    (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_pcmpgr_in.move(\n            (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n        )\n        rect_pcmpgr_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n        c.add_ref(\n            gf.geometry.boolean(\n                A=rect_pcmpgr_out,\n                B=rect_pcmpgr_in,\n                operation=\"A-B\",\n                layer=layer[\"comp\"],\n            )\n        )  # guardring Bulk\n\n        psdm_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_in.move(\n            (\n                rect_pcmpgr_in.xmin + pp_enc_comp,\n                rect_pcmpgr_in.ymin + pp_enc_comp,\n            )\n        )\n        psdm_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n                    (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_out.move(\n            (\n                rect_pcmpgr_out.xmin - pp_enc_comp,\n                rect_pcmpgr_out.ymin - pp_enc_comp,\n            )\n        )\n        c.add_ref(\n            gf.geometry.boolean(\n                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n            )\n        )  # psdm\n\n        # generating contacts\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_pcmpgr_in.xmin + con_size,\n                    rect_pcmpgr_in.xmax - con_size,\n                ),\n                y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # bottom contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_pcmpgr_in.xmin + con_size,\n                    rect_pcmpgr_in.xmax - con_size,\n                ),\n                y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # upper contact\n\n        p_con = c.add_ref(\n            via_generator(\n                x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n                y_range=(\n                    rect_pcmpgr_in.ymin + con_size,\n                    rect_pcmpgr_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # left contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n                y_range=(\n                    rect_pcmpgr_in.ymin + con_size,\n                    rect_pcmpgr_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # right contact\n\n        # labels generation\n        if lbl == 1:\n            # n_label generation\n            c.add_label(\n                p_lbl,\n                position=(\n                    p_con.xmin + (p_con.size[0] / 2),\n                    p_con.ymin + (p_con.size[1] / 2),\n                ),\n                layer=layer[\"metal1_label\"],\n            )\n\n        comp_m1_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n                layer=layer[\"metal1\"],\n            )\n        )\n\n        comp_m1_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n                ),\n                layer=layer[\"metal1\"],\n            )\n        )\n        comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n        c.add_ref(\n            gf.geometry.boolean(\n                A=rect_pcmpgr_out,\n                B=rect_pcmpgr_in,\n                operation=\"A-B\",\n                layer=layer[\"metal1\"],\n            )\n        )  # guardring metal1\n\n    # generate dualgate\n\n    if volt == \"5/6V\":\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    dn_rect.size[0] + (2 * dg_enc_dn),\n                    dn_rect.size[1] + (2 * dg_enc_dn),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = dn_rect.xmin - dg_enc_dn\n        dg.ymin = dn_rect.ymin - dg_enc_dn\n\n    # creating layout and cell in klayout\n\n    c.write_gds(\"diode_dw2ps_temp.gds\")\n    layout.read(\"diode_dw2ps_temp.gds\")\n    cell_name = \"diode_dw2ps_dev\"\n\n    return layout.cell(cell_name)", "\n\ndef draw_sc_diode(\n    layout,\n    la: float = 0.1,\n    wa: float = 0.1,\n    cw: float = 0.1,\n    m: int = 1,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    p_lbl: str = \"\",\n    n_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw N+/LVPWELL diode (Outside DNWELL) by specifying parameters\n    Arguments:-\n     layout     : Object of layout\n     la         : Float of diff length (anode)\n     wa         : Float of diff width (anode)\n     m          : Integer of number of fingers\n     pcmpgr     : Boolean of using P+ Guard Ring for Deep NWELL devices only\n    \"\"\"\n\n    c = gf.Component(\"sc_diode_dev\")\n\n    sc_enc_comp = 0.16\n    sc_comp_spacing = 0.28\n    dn_enc_sc_an = 1.4\n    np_enc_comp = 0.03\n    m1_w = 0.23\n    pcmpgr_enc_dn = 2.5\n    pp_enc_comp: float = 0.16\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n\n    # cathode draw\n\n    @gf.cell\n    def sc_cathode_strap(size: Float2 = (0.1, 0.1)) -> gf.Component:\n        \"\"\"Returns sc_diode cathode array element\n\n        Args :\n            size : size of cathode array element\n        \"\"\"\n\n        c = gf.Component()\n\n        ncmp = c.add_ref(gf.components.rectangle(size=size, layer=layer[\"comp\"]))\n\n        nplus = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    ncmp.size[0] + (2 * np_enc_comp),\n                    ncmp.size[1] + (2 * np_enc_comp),\n                ),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nplus.xmin = ncmp.xmin - np_enc_comp\n        nplus.ymin = ncmp.ymin - np_enc_comp\n\n        c.add_ref(\n            via_stack(\n                x_range=(ncmp.xmin, ncmp.xmax),\n                y_range=(ncmp.ymin, ncmp.ymax),\n                base_layer=layer[\"comp\"],\n                metal_level=1,\n            )\n        )  # ncomp contact\n\n        return c\n\n    @gf.cell\n    def sc_anode_strap(size: Float2 = (0.1, 0.1)) -> gf.Component:\n        \"\"\"Returns sc_diode anode array element\n\n        Args :\n            size : size of anode array element\n        \"\"\"\n\n        c = gf.Component()\n\n        cmp = c.add_ref(gf.components.rectangle(size=size, layer=layer[\"comp\"]))\n\n        c.add_ref(\n            via_stack(\n                x_range=(cmp.xmin, cmp.xmax),\n                y_range=(cmp.ymin, cmp.ymax),\n                base_layer=layer[\"comp\"],\n                metal_level=1,\n            )\n        )  # comp contact\n\n        return c\n\n    sc_an = sc_anode_strap(size=(wa, la))\n    sc_cath = sc_cathode_strap(size=(cw, la))\n\n    sc_cathode = c.add_array(\n        component=sc_cath,\n        rows=1,\n        columns=(m + 1),\n        spacing=((cw + wa + (2 * sc_comp_spacing)), 0),\n    )\n\n    cath_m1_polys = sc_cath.get_polygons(by_spec=layer[\"metal1\"])\n    cath_m1_xmin = np.min(cath_m1_polys[0][:, 0])\n    cath_m1_ymin = np.min(cath_m1_polys[0][:, 1])\n    cath_m1_xmax = np.max(cath_m1_polys[0][:, 0])\n\n    cath_m1_v = c.add_array(\n        component=gf.components.rectangle(\n            size=(\n                cath_m1_xmax - cath_m1_xmin,\n                cath_m1_ymin - sc_cathode.ymin + m1_w,\n            ),\n            layer=layer[\"metal1\"],\n        ),\n        rows=1,\n        columns=(m + 1),\n        spacing=((cw + wa + (2 * sc_comp_spacing)), 0),\n    )\n\n    cath_m1_v.xmin = cath_m1_xmin\n    cath_m1_v.ymax = cath_m1_ymin\n\n    cath_m1_h = c.add_ref(\n        gf.components.rectangle(size=(cath_m1_v.size[0], m1_w), layer=layer[\"metal1\"])\n    )\n    cath_m1_h.xmin = cath_m1_v.xmin\n    cath_m1_h.ymax = cath_m1_v.ymin\n\n    # cathode label generation\n    if lbl == 1:\n        c.add_label(\n            n_lbl,\n            position=(\n                cath_m1_h.xmin + (cath_m1_h.size[0] / 2),\n                cath_m1_h.ymin + (cath_m1_h.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    sc_anode = c.add_array(\n        component=sc_an,\n        rows=1,\n        columns=m,\n        spacing=(wa + cw + (2 * sc_comp_spacing), 0),\n    )\n\n    sc_anode.xmin = sc_cathode.xmin + (cw + sc_comp_spacing)\n\n    an_m1_polys = sc_anode.get_polygons(by_spec=layer[\"metal1\"])\n    an_m1_xmin = np.min(an_m1_polys[0][:, 0])\n    an_m1_ymin = np.min(an_m1_polys[0][:, 1])\n    an_m1_xmax = np.max(an_m1_polys[0][:, 0])\n    an_m1_ymax = np.max(an_m1_polys[0][:, 1])\n\n    if m > 1:\n        an_m1_v = c.add_array(\n            component=gf.components.rectangle(\n                size=(\n                    an_m1_xmax - an_m1_xmin,\n                    cath_m1_ymin - sc_an.ymin + m1_w,\n                ),\n                layer=layer[\"metal1\"],\n            ),\n            rows=1,\n            columns=m,\n            spacing=((cw + wa + (2 * sc_comp_spacing)), 0),\n        )\n\n        an_m1_v.xmin = an_m1_xmin\n        an_m1_v.ymin = an_m1_ymax\n\n        an_m1_h = c.add_ref(\n            gf.components.rectangle(size=(an_m1_v.size[0], m1_w), layer=layer[\"metal1\"])\n        )\n        an_m1_h.xmin = an_m1_v.xmin\n        an_m1_h.ymin = an_m1_v.ymax\n\n        # anode label generation\n        if lbl == 1:\n            c.add_label(\n                p_lbl,\n                position=(\n                    an_m1_h.xmin + (an_m1_h.size[0] / 2),\n                    an_m1_h.ymin + (an_m1_h.size[1] / 2),\n                ),\n                layer=layer[\"metal1_label\"],\n            )\n\n    else:\n        # anode label generation\n        if lbl == 1:\n            c.add_label(\n                p_lbl,\n                position=(\n                    an_m1_xmin + ((an_m1_xmax - an_m1_xmin) / 2),\n                    an_m1_ymin + ((an_m1_ymax - an_m1_ymin) / 2),\n                ),\n                layer=layer[\"metal1_label\"],\n            )\n\n    # diode_mk\n    diode_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                sc_cathode.size[0] + (2 * sc_enc_comp),\n                sc_cathode.size[1] + (2 * sc_enc_comp),\n            ),\n            layer=layer[\"schottky_diode\"],\n        )\n    )\n    diode_mk.xmin = sc_cathode.xmin - sc_enc_comp\n    diode_mk.ymin = sc_cathode.ymin - sc_enc_comp\n\n    # dnwell\n    dn_rect = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                sc_anode.size[0] + (2 * dn_enc_sc_an),\n                sc_anode.size[1] + (2 * dn_enc_sc_an),\n            ),\n            layer=layer[\"dnwell\"],\n        )\n    )\n    dn_rect.xmin = sc_anode.xmin - dn_enc_sc_an\n    dn_rect.ymin = sc_anode.ymin - dn_enc_sc_an\n\n    if pcmpgr == 1:\n        c_temp_gr = gf.Component(\"temp_store guard ring\")\n        rect_pcmpgr_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                    (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_pcmpgr_in.move(\n            (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n        )\n        rect_pcmpgr_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * cw,\n                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * cw,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n        c.add_ref(\n            gf.geometry.boolean(\n                A=rect_pcmpgr_out,\n                B=rect_pcmpgr_in,\n                operation=\"A-B\",\n                layer=layer[\"comp\"],\n            )\n        )  # guardring Bulk\n\n        psdm_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * pp_enc_comp,\n                    (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_in.move(\n            (\n                rect_pcmpgr_in.xmin + pp_enc_comp,\n                rect_pcmpgr_in.ymin + pp_enc_comp,\n            )\n        )\n        psdm_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * pp_enc_comp,\n                    (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * pp_enc_comp,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_out.move(\n            (\n                rect_pcmpgr_out.xmin - pp_enc_comp,\n                rect_pcmpgr_out.ymin - pp_enc_comp,\n            )\n        )\n        c.add_ref(\n            gf.geometry.boolean(\n                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n            )\n        )  # psdm\n\n        # generating contacts\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_pcmpgr_in.xmin + con_size,\n                    rect_pcmpgr_in.xmax - con_size,\n                ),\n                y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # bottom contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_pcmpgr_in.xmin + con_size,\n                    rect_pcmpgr_in.xmax - con_size,\n                ),\n                y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # upper contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n                y_range=(\n                    rect_pcmpgr_in.ymin + con_size,\n                    rect_pcmpgr_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # right contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n                y_range=(\n                    rect_pcmpgr_in.ymin + con_size,\n                    rect_pcmpgr_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # left contact\n\n        comp_m1_in = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n                layer=layer[\"metal1\"],\n            )\n        )\n\n        comp_m1_out = c_temp_gr.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (comp_m1_in.size[0]) + 2 * cw,\n                    (comp_m1_in.size[1]) + 2 * cw,\n                ),\n                layer=layer[\"metal1\"],\n            )\n        )\n        comp_m1_out.move((rect_pcmpgr_in.xmin - cw, rect_pcmpgr_in.ymin - cw))\n        c.add_ref(\n            gf.geometry.boolean(\n                A=rect_pcmpgr_out,\n                B=rect_pcmpgr_in,\n                operation=\"A-B\",\n                layer=layer[\"metal1\"],\n            )\n        )  # guardring metal1\n\n    # creating layout and cell in klayout\n\n    c.write_gds(\"sc_diode_temp.gds\")\n    layout.read(\"sc_diode_temp.gds\")\n    cell_name = \"sc_diode_dev\"\n\n    return layout.cell(cell_name)", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/res.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n########################################################################################################################\n# Resistor Generator for GF180MCU\n########################################################################################################################\n", "########################################################################################################################\n\nimport os\n\nimport pya\n\nfrom .draw_res import (\n    draw_metal_res,\n    draw_nplus_res,\n    draw_npolyf_res,", "    draw_nplus_res,\n    draw_npolyf_res,\n    draw_pplus_res,\n    draw_ppolyf_res,\n    draw_ppolyf_u_high_Rs_res,\n    draw_well_res,\n)\n\nrm1_l = 0.23\nrm1_w = 0.23", "rm1_l = 0.23\nrm1_w = 0.23\n\nrm2_3_l = 0.28\nrm2_3_w = 0.28\n\ntm6k_l = 0.36\ntm6k_w = 0.36\n\ntm9_11k_l = 0.44", "\ntm9_11k_l = 0.44\ntm9_11k_w = 0.44\n\ntm30k_l = 1.8\ntm30k_w = 1.8\n\nnplus_s_l = 0.42\nnplus_s_w = 0.42\n", "nplus_s_w = 0.42\n\npplus_s_l = 0.42\npplus_s_w = 0.42\n\nnplus_u_l = 0.42\nnplus_u_w = 0.42\n\npplus_u_l = 0.42\npplus_u_w = 0.42", "pplus_u_l = 0.42\npplus_u_w = 0.42\n\nnwell_l = 0.42\nnwell_w = 0.42\n\npwell_l = 2.0\npwell_w = 2.0\n\nnpolyf_s_l = 0.42", "\nnpolyf_s_l = 0.42\nnpolyf_s_w = 0.42\n\nppolyf_s_l = 0.42\nppolyf_s_w = 0.42\n\nnpolyf_u_l = 0.42\nnpolyf_u_w = 0.42\n", "npolyf_u_w = 0.42\n\nppolyf_u_l = 0.42\nppolyf_u_w = 0.42\n\nppolyf_u_h_res_l = 0.42\nppolyf_u_h_res_w = 0.42\n\n\nclass metal_resistor(pya.PCellDeclarationHelper):\n    \"\"\"\n    2-terminal Metal resistor Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.Type_handle = self.param(\"res_type\", self.TypeList, \"Metal resistor type\")\n        self.Type_handle.add_choice(\"rm1\", \"rm1\")\n        self.Type_handle.add_choice(\"rm2\", \"rm2\")\n        self.Type_handle.add_choice(\"rm3\", \"rm3\")\n        self.Type_handle.add_choice(\"tm6k\", \"tm6k\")\n        self.Type_handle.add_choice(\"tm9k\", \"tm9k\")\n        self.Type_handle.add_choice(\"tm11k\", \"tm11k\")\n        self.Type_handle.add_choice(\"tm30k\", \"tm30k\")\n\n        self.param(\"l_res\", self.TypeDouble, \"Width\", default=rm1_l, unit=\"um\")\n        self.param(\"w_res\", self.TypeDouble, \"Length\", default=rm1_w, unit=\"um\")\n        self.param(\"l_res\", self.TypeDouble, \"Width\", default=rm1_l, unit=\"um\")\n        self.param(\"w_res\", self.TypeDouble, \"Length\", default=rm1_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n        self.param(\n            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n        )\n        self.param(\n            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n        )\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\n        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return (\n            \"metal_resistor(L=\"\n            + (\"%.3f\" % self.l_res)\n            + \",W=\"\n            + (\"%.3f\" % self.w_res)\n            + \")\"\n        )\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_res * self.l_res\n        self.perim = 2 * (self.w_res + self.l_res)\n        self.area = self.w_res * self.l_res\n        self.perim = 2 * (self.w_res + self.l_res)\n        # w,l must be larger or equal than min. values.\n        if (self.res_type) == \"rm1\":\n            self.l_res = max(self.l_res, rm1_l)\n            self.w_res = max(self.w_res, rm1_w)\n            self.l_res = max(self.l_res, rm1_l)\n            self.w_res = max(self.w_res, rm1_w)\n        if self.res_type in [\"rm2\", \"rm3\"]:\n            self.l_res = max(self.l_res, rm2_3_l)\n            self.w_res = max(self.w_res, rm2_3_w)\n        if (self.res_type) == \"tm6k\":\n            self.l_res = max(self.l_res, tm6k_l)\n            self.w_res = max(self.w_res, tm6k_w)\n        if self.res_type in [\"tm9k\", \"tm11k\"]:\n            self.l_res = max(self.l_res, tm9_11k_l)\n            self.w_res = max(self.w_res, tm9_11k_w)\n        if (self.res_type) == \"tm30k\":\n            self.l_res = max(self.l_res, tm30k_l)\n            self.w_res = max(self.w_res, tm30k_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.l_res = self.layout.get_info(self.layer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        dbu_PERCISION = 1 / self.layout.dbu\n        option = os.environ[\"GF_PDK_OPTION\"]\n        if option == \"A\":\n            if self.res_type in [\"rm3\", \"tm6k\", \"tm9k\", \"tm11k\"]:\n                raise TypeError(f\"Current stack ({option}) doesn't allow this option\")\n        elif option == \"B\":\n            if self.res_type in [\"tm6k\", \"tm9k\", \"tm30k\"]:\n                raise TypeError(f\"Current stack ({option}) doesn't allow this option\")\n        elif self.res_type in [\"tm6k\", \"tm11k\", \"tm30k\"]:\n            raise TypeError(f\"Current stack ({option}) doesn't allow this option\")\n        np_instance = draw_metal_res(\n            layout=self.layout,\n            l_res=self.l_res,\n            w_res=self.w_res,\n            res_type=self.res_type,\n            lbl=self.lbl,\n            r0_lbl=self.r0_lbl,\n            r1_lbl=self.r1_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n            self.array_x,\n            self.array_y,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\nclass metal_resistor(pya.PCellDeclarationHelper):\n    \"\"\"\n    2-terminal Metal resistor Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.Type_handle = self.param(\"res_type\", self.TypeList, \"Metal resistor type\")\n        self.Type_handle.add_choice(\"rm1\", \"rm1\")\n        self.Type_handle.add_choice(\"rm2\", \"rm2\")\n        self.Type_handle.add_choice(\"rm3\", \"rm3\")\n        self.Type_handle.add_choice(\"tm6k\", \"tm6k\")\n        self.Type_handle.add_choice(\"tm9k\", \"tm9k\")\n        self.Type_handle.add_choice(\"tm11k\", \"tm11k\")\n        self.Type_handle.add_choice(\"tm30k\", \"tm30k\")\n\n        self.param(\"l_res\", self.TypeDouble, \"Width\", default=rm1_l, unit=\"um\")\n        self.param(\"w_res\", self.TypeDouble, \"Length\", default=rm1_w, unit=\"um\")\n        self.param(\"l_res\", self.TypeDouble, \"Width\", default=rm1_l, unit=\"um\")\n        self.param(\"w_res\", self.TypeDouble, \"Length\", default=rm1_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n        self.param(\n            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n        )\n        self.param(\n            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n        )\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\n        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return (\n            \"metal_resistor(L=\"\n            + (\"%.3f\" % self.l_res)\n            + \",W=\"\n            + (\"%.3f\" % self.w_res)\n            + \")\"\n        )\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_res * self.l_res\n        self.perim = 2 * (self.w_res + self.l_res)\n        self.area = self.w_res * self.l_res\n        self.perim = 2 * (self.w_res + self.l_res)\n        # w,l must be larger or equal than min. values.\n        if (self.res_type) == \"rm1\":\n            self.l_res = max(self.l_res, rm1_l)\n            self.w_res = max(self.w_res, rm1_w)\n            self.l_res = max(self.l_res, rm1_l)\n            self.w_res = max(self.w_res, rm1_w)\n        if self.res_type in [\"rm2\", \"rm3\"]:\n            self.l_res = max(self.l_res, rm2_3_l)\n            self.w_res = max(self.w_res, rm2_3_w)\n        if (self.res_type) == \"tm6k\":\n            self.l_res = max(self.l_res, tm6k_l)\n            self.w_res = max(self.w_res, tm6k_w)\n        if self.res_type in [\"tm9k\", \"tm11k\"]:\n            self.l_res = max(self.l_res, tm9_11k_l)\n            self.w_res = max(self.w_res, tm9_11k_w)\n        if (self.res_type) == \"tm30k\":\n            self.l_res = max(self.l_res, tm30k_l)\n            self.w_res = max(self.w_res, tm30k_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.l_res = self.layout.get_info(self.layer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        dbu_PERCISION = 1 / self.layout.dbu\n        option = os.environ[\"GF_PDK_OPTION\"]\n        if option == \"A\":\n            if self.res_type in [\"rm3\", \"tm6k\", \"tm9k\", \"tm11k\"]:\n                raise TypeError(f\"Current stack ({option}) doesn't allow this option\")\n        elif option == \"B\":\n            if self.res_type in [\"tm6k\", \"tm9k\", \"tm30k\"]:\n                raise TypeError(f\"Current stack ({option}) doesn't allow this option\")\n        elif self.res_type in [\"tm6k\", \"tm11k\", \"tm30k\"]:\n            raise TypeError(f\"Current stack ({option}) doesn't allow this option\")\n        np_instance = draw_metal_res(\n            layout=self.layout,\n            l_res=self.l_res,\n            w_res=self.w_res,\n            res_type=self.res_type,\n            lbl=self.lbl,\n            r0_lbl=self.r0_lbl,\n            r1_lbl=self.r1_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n            self.array_x,\n            self.array_y,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass nplus_s_resistor(pya.PCellDeclarationHelper):\n    \"\"\"\n    3-terminal salicided n+ diffusion resistor (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.param(\"w_res\", self.TypeDouble, \"Width\", default=nplus_s_l, unit=\"um\")\n        self.param(\"l_res\", self.TypeDouble, \"Length\", default=nplus_s_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n        self.param(\n            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n        )\n        self.param(\n            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n        )\n        self.param(\"sub\", self.TypeBoolean, \"Substrate terminal\", default=1)\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\n        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\n        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return (\n            \"nplus_s_resistor(L=\"\n            + (\"%.3f\" % self.l_res)\n            + \",W=\"\n            + (\"%.3f\" % self.w_res)\n            + \")\"\n        )\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_res * self.l_res\n        self.perim = 2 * (self.w_res + self.l_res)\n        # w,l must be larger or equal than min. values.\n        self.l_res = max(self.l_res, nplus_s_l)\n        self.w_res = max(self.w_res, nplus_s_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.l_res = self.layout.get_info(self.layer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        dbu_PERCISION = 1 / self.layout.dbu\n        np_instance = draw_nplus_res(\n            layout=self.layout,\n            l_res=self.l_res,\n            w_res=self.w_res,\n            res_type=\"nplus_s\",\n            sub=self.sub,\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            r0_lbl=self.r0_lbl,\n            r1_lbl=self.r1_lbl,\n            sub_lbl=self.sub_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n            self.array_x,\n            self.array_y,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass pplus_s_resistor(pya.PCellDeclarationHelper):\n    \"\"\"\n    3-terminal salicided P+ diffusion resistor (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.param(\"w_res\", self.TypeDouble, \"Width\", default=pplus_s_l, unit=\"um\")\n        self.param(\"l_res\", self.TypeDouble, \"Length\", default=pplus_s_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n        self.param(\n            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n        )\n        self.param(\n            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n        )\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\n        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\n        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return (\n            \"pplus_s_resistor(L=\"\n            + (\"%.3f\" % self.l_res)\n            + \",W=\"\n            + (\"%.3f\" % self.w_res)\n            + \")\"\n        )\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_res * self.l_res\n        self.perim = 2 * (self.w_res + self.l_res)\n        # w,l must be larger or equal than min. values.\n        self.l_res = max(self.l_res, pplus_s_l)\n        self.w_res = max(self.w_res, pplus_s_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.l_res = self.layout.get_info(self.layer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        dbu_PERCISION = 1 / self.layout.dbu\n        np_instance = draw_pplus_res(\n            layout=self.layout,\n            l_res=self.l_res,\n            w_res=self.w_res,\n            res_type=\"pplus_s\",\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            r0_lbl=self.r0_lbl,\n            r1_lbl=self.r1_lbl,\n            sub_lbl=self.sub_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n            self.array_x,\n            self.array_y,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass nplus_u_resistor(pya.PCellDeclarationHelper):\n    \"\"\"\n    3-terminal unsalicided n+ diffusion resistor (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.param(\"w_res\", self.TypeDouble, \"Width\", default=nplus_u_l, unit=\"um\")\n        self.param(\"l_res\", self.TypeDouble, \"Length\", default=nplus_u_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n        self.param(\n            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n        )\n        self.param(\n            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n        )\n        self.param(\"sub\", self.TypeBoolean, \"Substrate terminal\", default=1)\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\n        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\n        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return (\n            \"nplus_u_resistor(L=\"\n            + (\"%.3f\" % self.l_res)\n            + \",W=\"\n            + (\"%.3f\" % self.w_res)\n            + \")\"\n        )\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_res * self.l_res\n        self.perim = 2 * (self.w_res + self.l_res)\n        # w,l must be larger or equal than min. values.\n        self.l_res = max(self.l_res, nplus_u_l)\n        self.w_res = max(self.w_res, nplus_u_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.l_res = self.layout.get_info(self.layer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        dbu_PERCISION = 1 / self.layout.dbu\n        np_instance = draw_nplus_res(\n            layout=self.layout,\n            l_res=self.l_res,\n            w_res=self.w_res,\n            res_type=\"nplus_u\",\n            sub=self.sub,\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            r0_lbl=self.r0_lbl,\n            r1_lbl=self.r1_lbl,\n            sub_lbl=self.sub_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n            self.array_x,\n            self.array_y,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass pplus_u_resistor(pya.PCellDeclarationHelper):\n    \"\"\"\n    3-terminal salicided P+ diffusion resistor (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.param(\"w_res\", self.TypeDouble, \"Width\", default=pplus_u_l, unit=\"um\")\n        self.param(\"l_res\", self.TypeDouble, \"Length\", default=pplus_u_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n        self.param(\n            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n        )\n        self.param(\n            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n        )\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\n        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\n        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return (\n            \"pplus_u_resistor(L=\"\n            + (\"%.3f\" % self.l_res)\n            + \",W=\"\n            + (\"%.3f\" % self.w_res)\n            + \")\"\n        )\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_res * self.l_res\n        self.perim = 2 * (self.w_res + self.l_res)\n        # w,l must be larger or equal than min. values.\n        self.l_res = max(self.l_res, pplus_u_l)\n        self.w_res = max(self.w_res, pplus_u_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.l_res = self.layout.get_info(self.layer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        dbu_PERCISION = 1 / self.layout.dbu\n        np_instance = draw_pplus_res(\n            layout=self.layout,\n            l_res=self.l_res,\n            w_res=self.w_res,\n            res_type=\"pplus_u\",\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            r0_lbl=self.r0_lbl,\n            r1_lbl=self.r1_lbl,\n            sub_lbl=self.sub_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n            self.array_x,\n            self.array_y,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass nwell_resistor(pya.PCellDeclarationHelper):\n    \"\"\"\n    3-terminal Nwell resistor under STI (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"w_res\", self.TypeDouble, \"Width\", default=nwell_l, unit=\"um\")\n        self.param(\"l_res\", self.TypeDouble, \"Length\", default=nwell_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n        self.param(\n            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n        )\n        self.param(\n            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n        )\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\n        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\n        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return (\n            \"nwell_resistor(L=\"\n            + (\"%.3f\" % self.l_res)\n            + \",W=\"\n            + (\"%.3f\" % self.w_res)\n            + \")\"\n        )\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_res * self.l_res\n        self.perim = 2 * (self.w_res + self.l_res)\n        # w,l must be larger or equal than min. values.\n        self.l_res = max(self.l_res, nwell_l)\n        self.w_res = max(self.w_res, nwell_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.l_res = self.layout.get_info(self.layer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        dbu_PERCISION = 1 / self.layout.dbu\n        np_instance = draw_well_res(\n            layout=self.layout,\n            l_res=self.l_res,\n            w_res=self.w_res,\n            res_type=\"nwell\",\n            pcmpgr=0,\n            lbl=self.lbl,\n            r0_lbl=self.r0_lbl,\n            r1_lbl=self.r1_lbl,\n            sub_lbl=self.sub_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n            self.array_x,\n            self.array_y,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass pwell_resistor(pya.PCellDeclarationHelper):\n    \"\"\"\n    3-terminal Pwell resistor under STI (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.param(\"w_res\", self.TypeDouble, \"Width\", default=pwell_l, unit=\"um\")\n        self.param(\"l_res\", self.TypeDouble, \"Length\", default=pwell_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n        self.param(\n            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n        )\n        self.param(\n            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n        )\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\n        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\n        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return (\n            \"pwell_resistor(L=\"\n            + (\"%.3f\" % self.l_res)\n            + \",W=\"\n            + (\"%.3f\" % self.w_res)\n            + \")\"\n        )\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_res * self.l_res\n        self.perim = 2 * (self.w_res + self.l_res)\n        # w,l must be larger or equal than min. values.\n        self.l_res = max(self.l_res, pwell_l)\n        self.w_res = max(self.w_res, pwell_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.l_res = self.layout.get_info(self.layer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        dbu_PERCISION = 1 / self.layout.dbu\n        np_instance = draw_well_res(\n            layout=self.layout,\n            l_res=self.l_res,\n            w_res=self.w_res,\n            res_type=\"pwell\",\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            r0_lbl=self.r0_lbl,\n            r1_lbl=self.r1_lbl,\n            sub_lbl=self.sub_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n            self.array_x,\n            self.array_y,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass npolyf_s_resistor(pya.PCellDeclarationHelper):\n    \"\"\"\n    3-terminal salicided n+ poly resistor (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.param(\"w_res\", self.TypeDouble, \"Width\", default=npolyf_s_l, unit=\"um\")\n        self.param(\"l_res\", self.TypeDouble, \"Length\", default=npolyf_s_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n        self.param(\n            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n        )\n        self.param(\n            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n        )\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\n        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\n        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return (\n            \"npolyf_s_resistor(L=\"\n            + (\"%.3f\" % self.l_res)\n            + \",W=\"\n            + (\"%.3f\" % self.w_res)\n            + \")\"\n        )\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_res * self.l_res\n        self.perim = 2 * (self.w_res + self.l_res)\n        # w,l must be larger or equal than min. values.\n        self.l_res = max(self.l_res, npolyf_s_l)\n        self.w_res = max(self.w_res, npolyf_s_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.l_res = self.layout.get_info(self.layer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        dbu_PERCISION = 1 / self.layout.dbu\n        np_instance = draw_npolyf_res(\n            layout=self.layout,\n            l_res=self.l_res,\n            w_res=self.w_res,\n            res_type=\"npolyf_s\",\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            r0_lbl=self.r0_lbl,\n            r1_lbl=self.r1_lbl,\n            sub_lbl=self.sub_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n            self.array_x,\n            self.array_y,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass ppolyf_s_resistor(pya.PCellDeclarationHelper):\n    \"\"\"\n    3-terminal salicided p+ poly resistor (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.param(\"w_res\", self.TypeDouble, \"Width\", default=ppolyf_s_l, unit=\"um\")\n        self.param(\"l_res\", self.TypeDouble, \"Length\", default=ppolyf_s_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n        self.param(\n            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n        )\n        self.param(\n            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n        )\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\n        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\n        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return (\n            \"ppolyf_s_resistor(L=\"\n            + (\"%.3f\" % self.l_res)\n            + \",W=\"\n            + (\"%.3f\" % self.w_res)\n            + \")\"\n        )\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_res * self.l_res\n        self.perim = 2 * (self.w_res + self.l_res)\n        # w,l must be larger or equal than min. values.\n        self.l_res = max(self.l_res, ppolyf_s_l)\n        self.w_res = max(self.w_res, ppolyf_s_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.l_res = self.layout.get_info(self.layer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        dbu_PERCISION = 1 / self.layout.dbu\n        np_instance = draw_ppolyf_res(\n            layout=self.layout,\n            l_res=self.l_res,\n            w_res=self.w_res,\n            res_type=\"ppolyf_s\",\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            r0_lbl=self.r0_lbl,\n            r1_lbl=self.r1_lbl,\n            sub_lbl=self.sub_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n            self.array_x,\n            self.array_y,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass npolyf_u_resistor(pya.PCellDeclarationHelper):\n    \"\"\"\n    3-terminal unsalicided n+ poly resistor (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.param(\"w_res\", self.TypeDouble, \"Width\", default=npolyf_u_l, unit=\"um\")\n        self.param(\"l_res\", self.TypeDouble, \"Length\", default=npolyf_u_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n        self.param(\n            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n        )\n        self.param(\n            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n        )\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\n        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\n        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return (\n            \"npolyf_u_resistor(L=\"\n            + (\"%.3f\" % self.l_res)\n            + \",W=\"\n            + (\"%.3f\" % self.w_res)\n            + \")\"\n        )\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_res * self.l_res\n        self.perim = 2 * (self.w_res + self.l_res)\n        # w,l must be larger or equal than min. values.\n        self.l_res = max(self.l_res, npolyf_u_l)\n        self.w_res = max(self.w_res, npolyf_u_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.l_res = self.layout.get_info(self.layer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        dbu_PERCISION = 1 / self.layout.dbu\n        np_instance = draw_npolyf_res(\n            layout=self.layout,\n            l_res=self.l_res,\n            w_res=self.w_res,\n            res_type=\"npolyf_u\",\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            r0_lbl=self.r0_lbl,\n            r1_lbl=self.r1_lbl,\n            sub_lbl=self.sub_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n            self.array_x,\n            self.array_y,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass ppolyf_u_resistor(pya.PCellDeclarationHelper):\n    \"\"\"\n    3-terminal unsalicided p+ poly resistor (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.param(\"w_res\", self.TypeDouble, \"Width\", default=ppolyf_u_l, unit=\"um\")\n        self.param(\"l_res\", self.TypeDouble, \"Length\", default=ppolyf_u_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n        self.param(\n            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n        )\n        self.param(\n            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n        )\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\n        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\n        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return (\n            \"ppolyf_u_resistor(L=\"\n            + (\"%.3f\" % self.l_res)\n            + \",W=\"\n            + (\"%.3f\" % self.w_res)\n            + \")\"\n        )\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_res * self.l_res\n        self.perim = 2 * (self.w_res + self.l_res)\n        # w,l must be larger or equal than min. values.\n        self.l_res = max(self.l_res, ppolyf_u_l)\n        self.w_res = max(self.w_res, ppolyf_u_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        #     # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        #     # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.l_res = self.layout.get_info(self.layer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        dbu_PERCISION = 1 / self.layout.dbu\n        np_instance = draw_ppolyf_res(\n            layout=self.layout,\n            l_res=self.l_res,\n            w_res=self.w_res,\n            res_type=\"ppolyf_u\",\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            r0_lbl=self.r0_lbl,\n            r1_lbl=self.r1_lbl,\n            sub_lbl=self.sub_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n            self.array_x,\n            self.array_y,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass ppolyf_u_high_Rs_resistor(pya.PCellDeclarationHelper):\n    \"\"\"\n    high-Rs p+ poly resistor (outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\n        self.param(\n            \"w_res\", self.TypeDouble, \"Width\", default=ppolyf_u_h_res_l, unit=\"um\"\n        )\n        self.param(\n            \"l_res\", self.TypeDouble, \"Length\", default=ppolyf_u_h_res_w, unit=\"um\"\n        )\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n        self.param(\"array_x\", self.TypeInt, \"Repeat X\", default=1)\n        self.param(\"array_y\", self.TypeInt, \"Repeat Y\", default=1)\n        self.param(\n            \"x_spacing\", self.TypeDouble, \"spacing in x_direction\", default=3, unit=\"um\"\n        )\n        self.param(\n            \"y_spacing\", self.TypeDouble, \"spacing in y_direction\", default=3, unit=\"um\"\n        )\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"r0_lbl\", self.TypeString, \"R0 label\", default=\"\")\n\n        self.param(\"r1_lbl\", self.TypeString, \"R1 label\", default=\"\")\n\n        self.param(\"sub_lbl\", self.TypeString, \"Substrate label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return (\n            \"ppolyf_u_high_Rs_resistor(L=\"\n            + (\"%.3f\" % self.l_res)\n            + \",W=\"\n            + (\"%.3f\" % self.w_res)\n            + \")\"\n        )\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_res * self.l_res\n        self.perim = 2 * (self.w_res + self.l_res)\n        # w,l must be larger or equal than min. values.\n        self.l_res = max(self.l_res, ppolyf_u_h_res_l)\n        self.w_res = max(self.w_res, ppolyf_u_h_res_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.l_res = self.layout.get_info(self.layer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        dbu_PERCISION = 1 / self.layout.dbu\n        np_instance = draw_ppolyf_u_high_Rs_res(\n            layout=self.layout,\n            l_res=self.l_res,\n            w_res=self.w_res,\n            volt=self.volt,\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            r0_lbl=self.r0_lbl,\n            r1_lbl=self.r1_lbl,\n            sub_lbl=self.sub_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(self.x_spacing * dbu_PERCISION, 0),\n            pya.Vector(0, self.y_spacing * dbu_PERCISION),\n            self.array_x,\n            self.array_y,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/efuse.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n########################################################################################################################\n# EFuse Generator for GF180MCU\n########################################################################################################################\n", "########################################################################################################################\n\nimport pya\n\nfrom .draw_efuse import draw_efuse\n\n\nclass efuse(pya.PCellDeclarationHelper):\n    \"\"\"\n    eFuse Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Important: initialize the super class\n        super().__init__()\n        self.param(\n            \"Model\",\n            self.TypeString,\n            \"Model\",\n            default=\"gf180mcu_fd_pr__efuse\",\n            readonly=True,\n        )\n        self.param(\"array_x\", self.TypeInt, \"Elements in x_direction\", default=1)\n        self.param(\"array_y\", self.TypeInt, \"Elements in y_direction\", default=1)\n        self.param(\n            \"x_spacing\", self.TypeDouble, \"Spacing in x_direction\", default=1, unit=\"um\"\n        )\n        self.param(\n            \"y_spacing\", self.TypeDouble, \"Spacing in y_direction\", default=1, unit=\"um\"\n        )\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return \"efuse\"\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the\n        # numeric parameter has changed (by comparing against the effective\n        # radius ru) and set ru to the effective radius. We also update the\n        # numerical value or the shape, depending on which on has not changed.\n        pass\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        # return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n        pass\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        # self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        # self.l = self.layout.get_info(self.layer)\n        pass\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        # return pya.Trans(self.shape.bbox().center())\n        pass\n\n    def produce_impl(self):\n        # This is the main part of the implementation: create the layout\n\n        self.percision = 1 / self.layout.dbu\n        efuse_instance = draw_efuse(layout=self.layout)\n        write_cells = pya.CellInstArray(\n            efuse_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(self.x_spacing * self.percision, 0),\n            pya.Vector(0, self.y_spacing * self.percision),\n            self.array_x,\n            self.array_y,\n        )\n\n        self.cell.flatten(1)\n        self.cell.insert(write_cells)\n        self.layout.cleanup()", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/draw_cap_mim.py", "chunked_list": ["import gdsfactory as gf\n\nfrom .layers_def import layer\nfrom .via_generator import via_generator\n\n\ndef draw_cap_mim(\n    layout,\n    mim_option: str = \"A\",\n    metal_level: str = \"M4\",\n    lc: float = 2,\n    wc: float = 2,\n    lbl: bool = 0,\n    top_lbl: str = \"\",\n    bot_lbl: str = \"\",\n):\n    \"\"\"\n    Retern mim cap\n\n    Args:\n        layout : layout object\n        lc : float of cap length\n        wc : float of cap width\n\n\n    \"\"\"\n\n    c = gf.Component(\"mim_cap_dev\")\n\n    # used dimensions and layers\n\n    # MIM Option selection\n    if mim_option == \"MIM-B\":\n        if metal_level == \"M4\":\n            upper_layer = layer[\"metal4\"]\n            bottom_layer = layer[\"metal3\"]\n            via_layer = layer[\"via3\"]\n            up_lbl_layer = layer[\"metal4_label\"]\n            bot_lbl_layer = layer[\"metal3_label\"]\n        elif metal_level == \"M5\":\n            upper_layer = layer[\"metal5\"]\n            bottom_layer = layer[\"metal4\"]\n            via_layer = layer[\"via4\"]\n            up_lbl_layer = layer[\"metal5_label\"]\n            bot_lbl_layer = layer[\"metal4_label\"]\n        elif metal_level == \"M6\":\n            upper_layer = layer[\"metaltop\"]\n            bottom_layer = layer[\"metal5\"]\n            via_layer = layer[\"via5\"]\n            up_lbl_layer = layer[\"metaltop_label\"]\n            bot_lbl_layer = layer[\"metal5_label\"]\n    else:\n        upper_layer = layer[\"metal3\"]\n        bottom_layer = layer[\"metal2\"]\n        via_layer = layer[\"via2\"]\n        up_lbl_layer = layer[\"metal3_label\"]\n        bot_lbl_layer = layer[\"metal2_label\"]\n\n    via_size = (0.22, 0.22)\n    via_spacing = (0.5, 0.5)\n    via_enc = (0.4, 0.4)\n\n    bot_enc_top = 0.6\n    l_mk_w = 0.1\n\n    # drawing cap identifier and bottom , upper layers\n\n    m_up = c.add_ref(\n        gf.components.rectangle(\n            size=(wc, lc),\n            layer=upper_layer,\n        )\n    )\n\n    fusetop = c.add_ref(\n        gf.components.rectangle(\n            size=(m_up.size[0], m_up.size[1]), layer=layer[\"fusetop\"]\n        )\n    )\n    fusetop.xmin = m_up.xmin\n    fusetop.ymin = m_up.ymin\n\n    mim_l_mk = c.add_ref(\n        gf.components.rectangle(size=(fusetop.size[0], l_mk_w), layer=layer[\"mim_l_mk\"])\n    )\n    mim_l_mk.xmin = fusetop.xmin\n    mim_l_mk.ymin = fusetop.ymin\n\n    m_dn = c.add_ref(\n        gf.components.rectangle(\n            size=(m_up.size[0] + (2 * bot_enc_top), m_up.size[1] + (2 * bot_enc_top)),\n            layer=bottom_layer,\n        )\n    )\n    m_dn.xmin = m_up.xmin - bot_enc_top\n    m_dn.ymin = m_up.ymin - bot_enc_top\n\n    cap_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(m_dn.size[0], m_dn.size[1]), layer=layer[\"cap_mk\"]\n        )\n    )\n    cap_mk.xmin = m_dn.xmin\n    cap_mk.ymin = m_dn.ymin\n\n    # generating labels\n    if lbl == 1:\n        c.add_label(\n            top_lbl,\n            position=(m_up.xmin + (m_up.size[0] / 2), m_dn.xmin + (m_dn.size[1] / 2)),\n            layer=up_lbl_layer,\n        )\n\n        c.add_label(\n            bot_lbl,\n            position=(\n                m_dn.xmin + (m_dn.size[0] / 2),\n                m_dn.ymin + (m_up.ymin - m_dn.ymin) / 2,\n            ),\n            layer=bot_lbl_layer,\n        )\n\n    # generating vias\n\n    via = via_generator(\n        x_range=(m_up.xmin, m_up.xmax),\n        y_range=(m_up.ymin, m_up.ymax),\n        via_enclosure=via_enc,\n        via_layer=via_layer,\n        via_size=via_size,\n        via_spacing=via_spacing,\n    )\n    c.add_ref(via)\n\n    c.write_gds(\"mim_cap_temp.gds\")\n    layout.read(\"mim_cap_temp.gds\")\n    cell_name = \"mim_cap_dev\"\n\n    return layout.cell(cell_name)", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/draw_fet.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n########################################################################################################################\n## FET Pcells Generators for Klayout of GF180MCU\n########################################################################################################################\n", "########################################################################################################################\n\nfrom math import ceil, floor\n\nimport gdsfactory as gf\nfrom gdsfactory.typings import Float2, LayerSpec\n\nfrom .layers_def import layer\nfrom .via_generator import via_generator, via_stack\n", "from .via_generator import via_generator, via_stack\n\n\n@gf.cell\ndef labels_gen(\n    lbl_str: str = \"\",\n    position: Float2 = (0.1, 0.1),\n    layer: LayerSpec = layer[\"metal1_label\"],\n    lbl: bool = 0,\n    lbl_lst: list = [],\n    lbl_valid_len: int = 1,\n    index: int = 0,\n) -> gf.Component:\n    \"\"\"Returns labels at given position when lbl is enabled\n\n    Args :\n        lbl_str : string of the label\n        position : position of the label\n        layer : layer of the label\n        lbl : boolean of having the label\n        lbl_lst : list of given labels\n        lbl_valid_len : valid length of labels\n    \"\"\"\n\n    c = gf.Component()\n\n    if lbl == 1 and len(lbl_lst) == lbl_valid_len:\n        if lbl_str == \"None\":\n            c.add_label(lbl_lst[index], position=position, layer=layer)\n        else:\n            c.add_label(lbl_str, position=position, layer=layer)\n\n    return c", "\n\ndef get_patt_lbl(nl_b, nl, nt, nt_e, g_lbl, nl_u, nt_o):\n    \"\"\"Returns list of odd,even gate label patterns for alternating gate connection\n\n    Args :\n        nl_b : number of bottom connected gates transistors\n        nl : number of transistor\n        nt : patterns of tansistor [with out redundency]\n        nt_e : number of transistor with even order\n        g_lbl : list of transistors gate label\n        nl_u :  number of upper connected gates transistors\n        nt_o : number of transistor with odd order\n    \"\"\"\n\n    g_lbl_e = []\n    g_lbl_o = []\n\n    if nt == len(g_lbl):\n        for i in range(nl_b):\n            g_lbl_e.extend(g_lbl[j] for j in range(nl) if nt[j] == nt_e[i])\n        for i in range(nl_u):\n            g_lbl_o.extend(g_lbl[j] for j in range(nl) if nt[j] == nt_o[i])\n    return [g_lbl_e, g_lbl_o]", "\n\ndef alter_interdig(\n    sd_diff,\n    pc1,\n    pc2,\n    poly_con,\n    sd_diff_intr,\n    l_gate=0.15,\n    inter_sd_l=0.15,\n    sd_l=0.36,\n    nf=1,\n    pat=\"\",\n    pc_x=0.1,\n    pc_spacing=0.1,\n    lbl: bool = 0,\n    g_lbl: list = [],\n    nl: int = 1,\n    patt_lbl: bool = 0,\n) -> gf.Component:\n    \"\"\"Returns interdigitation polygons of gate with alterating poly contacts\n\n    Args :\n        sd_diff : source/drain diffusion rectangle\n        pc1 : first poly contact array\n        pc2 : second poly contact array\n        poly_con : componenet of poly contact\n        sd_diff_inter : inter source/drain diffusion rectangle\n        l_gate : gate length\n        inter_sd_l : inter diffusion length\n        nf : number of fingers\n        pat : string of the required pattern\n    \"\"\"\n\n    c_inst = gf.Component()\n\n    m2_spacing = 0.28\n    via_size = (0.26, 0.26)\n    via_enc = (0.06, 0.06)\n    via_spacing = (0.26, 0.26)\n\n    pat_o = []\n    pat_e = []\n\n    for i in range(int(nf)):\n        if i % 2 == 0:\n            pat_e.append(pat[i])\n        else:\n            pat_o.append(pat[i])\n\n    nt = []\n    [nt.append(x) for x in pat if x not in nt]\n\n    nt_o = []\n    [nt_o.append(x) for x in pat_o if x not in nt_o]\n\n    nt_e = []\n    [nt_e.append(x) for x in pat_e if x not in nt_e]\n\n    nl = len(nt)\n    nl_b = len(nt_e)\n    nl_u = len(nt_o)\n\n    g_lbl_e, g_lbl_o = get_patt_lbl(nl_b, nl, nt, nt_e, g_lbl, nl_u, nt_o)\n\n    m2_y = via_size[1] + 2 * via_enc[1]\n    m2 = gf.components.rectangle(\n        size=(sd_diff.xmax - sd_diff.xmin, m2_y),\n        layer=layer[\"metal2\"],\n    )\n\n    m2_arrb = c_inst.add_array(\n        component=m2,\n        columns=1,\n        rows=nl_b,\n        spacing=(0, -m2_y - m2_spacing),\n    )\n    m2_arrb.movey(pc1.ymin - m2_spacing - m2_y)\n\n    m2_arru = c_inst.add_array(\n        component=m2,\n        columns=1,\n        rows=nl_u,\n        spacing=(0, m2_y + m2_spacing),\n    )\n    m2_arru.movey(pc2.ymax + m2_spacing)\n\n    for i in range(nl_u):\n        for j in range(floor(nf / 2)):\n            if pat_o[j] == nt_o[i]:\n                m1 = c_inst.add_ref(\n                    gf.components.rectangle(\n                        size=(\n                            pc_x,\n                            ((pc2.ymax + (i + 1) * (m2_spacing + m2_y)) - pc2.ymin),\n                        ),\n                        layer=layer[\"metal1\"],\n                    )\n                )\n                m1.xmin = pc2.xmin + j * (pc_spacing)\n                m1.ymin = pc2.ymin\n\n                via1_dr = via_generator(\n                    x_range=(m1.xmin, m1.xmax),\n                    y_range=(\n                        m2_arru.ymin + i * (m2_y + m2_spacing),\n                        m2_arru.ymin + i * (m2_y + m2_spacing) + m2_y,\n                    ),\n                    via_enclosure=via_enc,\n                    via_layer=layer[\"via1\"],\n                    via_size=via_size,\n                    via_spacing=via_spacing,\n                )\n                via1 = c_inst.add_ref(via1_dr)\n\n                c_inst.add_ref(\n                    labels_gen(\n                        lbl_str=\"None\",\n                        position=(\n                            (via1.xmax + via1.xmin) / 2,\n                            (via1.ymax + via1.ymin) / 2,\n                        ),\n                        layer=layer[\"metal2_label\"],\n                        lbl=patt_lbl,\n                        lbl_lst=pat_o,\n                        lbl_valid_len=len(pat_o),\n                        index=j,\n                    )\n                )\n\n                # adding gate_label\n                c_inst.add_ref(\n                    labels_gen(\n                        lbl_str=\"None\",\n                        position=(\n                            m1.xmin + (m1.size[0] / 2),\n                            pc2.ymin + (pc2.size[1] / 2),\n                        ),\n                        layer=layer[\"metal1_label\"],\n                        lbl=lbl,\n                        lbl_lst=g_lbl_o,\n                        lbl_valid_len=nl_u,\n                        index=i,\n                    )\n                )\n\n    for i in range(nl_b):\n        for j in range(ceil(nf / 2)):\n            if pat_e[j] == nt_e[i]:\n                m1 = c_inst.add_ref(\n                    gf.components.rectangle(\n                        size=(\n                            pc_x,\n                            ((pc1.ymax + (i + 1) * (m2_spacing + m2_y)) - pc1.ymin),\n                        ),\n                        layer=layer[\"metal1\"],\n                    )\n                )\n                m1.xmin = pc1.xmin + j * (pc_spacing)\n                m1.ymin = -(m1.ymax - m1.ymin) + (pc1.ymax)\n                via1_dr = via_generator(\n                    x_range=(m1.xmin, m1.xmax),\n                    y_range=(\n                        m2_arrb.ymax - i * (m2_spacing + m2_y) - m2_y,\n                        m2_arrb.ymax - i * (m2_spacing + m2_y),\n                    ),\n                    via_enclosure=via_enc,\n                    via_layer=layer[\"via1\"],\n                    via_size=via_size,\n                    via_spacing=via_spacing,\n                )\n                via1 = c_inst.add_ref(via1_dr)\n\n                c_inst.add_ref(\n                    labels_gen(\n                        lbl_str=\"None\",\n                        position=(\n                            (via1.xmax + via1.xmin) / 2,\n                            (via1.ymax + via1.ymin) / 2,\n                        ),\n                        layer=layer[\"metal2_label\"],\n                        lbl=patt_lbl,\n                        lbl_lst=pat_e,\n                        lbl_valid_len=len(pat_e),\n                        index=j,\n                    )\n                )\n\n                # adding gate_label\n                c_inst.add_ref(\n                    labels_gen(\n                        lbl_str=\"None\",\n                        position=(\n                            m1.xmin + (m1.size[0] / 2),\n                            pc1.ymin + (pc1.size[1] / 2),\n                        ),\n                        layer=layer[\"metal1_label\"],\n                        lbl=lbl,\n                        lbl_lst=g_lbl_e,\n                        lbl_valid_len=nl_b,\n                        index=i,\n                    )\n                )\n\n    m3_x = via_size[0] + 2 * via_enc[0]\n    m3_spacing = m2_spacing\n\n    for i in range(nl_b):\n        for j in range(nl_u):\n            if nt_e[i] == nt_o[j]:\n                m2_join_b = c_inst.add_ref(\n                    gf.components.rectangle(\n                        size=(\n                            m2_y + sd_l + (i + 1) * (m3_spacing + m3_x),\n                            m2_y,\n                        ),\n                        layer=layer[\"metal2\"],\n                    ).move(\n                        (\n                            m2_arrb.xmin\n                            - (m2_y + sd_l + (i + 1) * (m3_spacing + m3_x)),\n                            m2_arrb.ymax - i * (m2_spacing + m2_y) - m2_y,\n                        )\n                    )\n                )\n                m2_join_u = c_inst.add_ref(\n                    gf.components.rectangle(\n                        size=(\n                            m2_y + sd_l + (i + 1) * (m3_spacing + m3_x),\n                            m2_y,\n                        ),\n                        layer=layer[\"metal2\"],\n                    ).move(\n                        (\n                            m2_arru.xmin\n                            - (m2_y + sd_l + (i + 1) * (m3_spacing + m3_x)),\n                            m2_arru.ymin + j * (m2_spacing + m2_y),\n                        )\n                    )\n                )\n                m3 = c_inst.add_ref(\n                    gf.components.rectangle(\n                        size=(\n                            m3_x,\n                            m2_join_u.ymax - m2_join_b.ymin,\n                        ),\n                        layer=layer[\"metal1\"],\n                    )\n                )\n                m3.move((m2_join_b.xmin, m2_join_b.ymin))\n                via2_dr = via_generator(\n                    x_range=(m3.xmin, m3.xmax),\n                    y_range=(m2_join_b.ymin, m2_join_b.ymax),\n                    via_enclosure=via_enc,\n                    via_size=via_size,\n                    via_layer=layer[\"via1\"],\n                    via_spacing=via_spacing,\n                )\n                c_inst.add_array(\n                    component=via2_dr,\n                    columns=1,\n                    rows=2,\n                    spacing=(\n                        0,\n                        m2_join_u.ymin - m2_join_b.ymin,\n                    ),\n                )  # via2_draw\n    return c_inst", "\n\ndef interdigit(\n    sd_diff,\n    pc1,\n    pc2,\n    poly_con,\n    sd_diff_intr,\n    l_gate: float = 0.15,\n    inter_sd_l: float = 0.23,\n    sd_l: float = 0.15,\n    nf=1,\n    patt=[\"\"],\n    gate_con_pos=\"top\",\n    pc_x=0.1,\n    pc_spacing=0.1,\n    lbl: bool = 0,\n    g_lbl: list = [],\n    patt_lbl: bool = 0,\n) -> gf.Component:\n    \"\"\"Returns interdigitation related polygons\n\n    Args :\n        sd_diff : source/drain diffusion rectangle\n        pc1 : first poly contact array\n        pc2 : second poly contact array\n        poly_con : componenet of poly contact\n        sd_diff_inter : inter source/drain diffusion rectangle\n        l_gate : gate length\n        inter_sd_l : inter diffusion length\n        nf : number of fingers\n        pat : string of the required pattern\n        gate_con_pos : position of gate contact\n    \"\"\"\n    c_inst = gf.Component()\n\n    if nf == len(patt):\n        pat = list(patt)\n        nt = (\n            []\n        )  # list to store the symbols of transistors and thier number nt(number of transistors)\n        [nt.append(x) for x in pat if x not in nt]\n        nl = len(nt)\n\n        m2_spacing = 0.28\n        via_size = (0.26, 0.26)\n        via_enc = (0.06, 0.06)\n        via_spacing = (0.26, 0.26)\n\n        m2_y = via_size[1] + 2 * via_enc[1]\n        m2 = gf.components.rectangle(\n            size=(sd_diff.xmax - sd_diff.xmin, m2_y), layer=layer[\"metal2\"]\n        )\n\n        if gate_con_pos == \"alternating\":\n            c_inst.add_ref(\n                alter_interdig(\n                    sd_diff=sd_diff,\n                    pc1=pc1,\n                    pc2=pc2,\n                    poly_con=poly_con,\n                    sd_diff_intr=sd_diff_intr,\n                    l_gate=l_gate,\n                    inter_sd_l=inter_sd_l,\n                    sd_l=sd_l,\n                    nf=nf,\n                    pat=pat,\n                    pc_x=pc_x,\n                    pc_spacing=pc_spacing,\n                    lbl=lbl,\n                    g_lbl=g_lbl,\n                    nl=nl,\n                    patt_lbl=patt_lbl,\n                )\n            )\n\n        elif gate_con_pos == \"top\":\n            m2_arr = c_inst.add_array(\n                component=m2,\n                columns=1,\n                rows=nl,\n                spacing=(0, m2.ymax - m2.ymin + m2_spacing),\n            )\n            m2_arr.movey(pc2.ymax + m2_spacing)\n\n            for i in range(nl):\n                for j in range(int(nf)):\n                    if pat[j] == nt[i]:\n                        m1 = c_inst.add_ref(\n                            gf.components.rectangle(\n                                size=(\n                                    pc_x,\n                                    (\n                                        (pc2.ymax + (i + 1) * (m2_spacing + m2_y))\n                                        - ((1 - j % 2) * pc1.ymin)\n                                        - (j % 2) * pc2.ymin\n                                    ),\n                                ),\n                                layer=layer[\"metal1\"],\n                            )\n                        )\n                        m1.xmin = pc1.xmin + j * (pc2.xmin - pc1.xmin)\n                        m1.ymin = pc1.ymin\n\n                        via1_dr = via_generator(\n                            x_range=(m1.xmin, m1.xmax),\n                            y_range=(\n                                m2_arr.ymin + i * (m2_spacing + m2_y),\n                                m2_arr.ymin + i * (m2_spacing + m2_y) + m2_y,\n                            ),\n                            via_enclosure=via_enc,\n                            via_layer=layer[\"via1\"],\n                            via_size=via_size,\n                            via_spacing=via_spacing,\n                        )\n                        via1 = c_inst.add_ref(via1_dr)\n\n                        c_inst.add_ref(\n                            labels_gen(\n                                lbl_str=\"None\",\n                                position=(\n                                    (via1.xmax + via1.xmin) / 2,\n                                    (via1.ymax + via1.ymin) / 2,\n                                ),\n                                layer=layer[\"metal2_label\"],\n                                lbl=patt_lbl,\n                                lbl_lst=pat,\n                                lbl_valid_len=nl,\n                                index=j,\n                            )\n                        )\n\n                        # adding gate_label\n                        c_inst.add_ref(\n                            labels_gen(\n                                lbl_str=\"None\",\n                                position=(\n                                    m1.xmin + (m1.size[0] / 2),\n                                    pc1.ymin + (pc1.size[1] / 2),\n                                ),\n                                layer=layer[\"metal1_label\"],\n                                lbl=lbl,\n                                lbl_lst=g_lbl,\n                                lbl_valid_len=nl,\n                                index=i,\n                            )\n                        )\n\n        elif gate_con_pos == \"bottom\":\n            m2_arr = c_inst.add_array(\n                component=m2,\n                columns=1,\n                rows=nl,\n                spacing=(0, -m2_y - m2_spacing),\n            )\n            m2_arr.movey(pc2.ymin - m2_spacing - m2_y)\n\n            for i in range(nl):\n                for j in range(int(nf)):\n                    if pat[j] == nt[i]:\n                        m1 = c_inst.add_ref(\n                            gf.components.rectangle(\n                                size=(\n                                    pc_x,\n                                    (\n                                        (pc1.ymax + (i + 1) * (m2_spacing + m2_y))\n                                        - (j % 2) * pc1.ymin\n                                        - (1 - j % 2) * pc2.ymin\n                                    ),\n                                ),\n                                layer=layer[\"metal1\"],\n                            )\n                        )\n                        m1.xmin = pc1.xmin + j * (pc2.xmin - pc1.xmin)\n                        m1.ymax = pc1.ymax\n\n                        via1_dr = via_generator(\n                            x_range=(m1.xmin, m1.xmax),\n                            y_range=(\n                                m2_arr.ymax - i * (m2_spacing + m2_y) - m2_y,\n                                m2_arr.ymax - i * (m2_spacing + m2_y),\n                            ),\n                            via_enclosure=via_enc,\n                            via_layer=layer[\"via1\"],\n                            via_size=via_size,\n                            via_spacing=via_spacing,\n                        )\n                        via1 = c_inst.add_ref(via1_dr)\n\n                        c_inst.add_ref(\n                            labels_gen(\n                                lbl_str=\"None\",\n                                position=(\n                                    (via1.xmax + via1.xmin) / 2,\n                                    (via1.ymax + via1.ymin) / 2,\n                                ),\n                                layer=layer[\"metal2_label\"],\n                                lbl=patt_lbl,\n                                lbl_lst=pat,\n                                lbl_valid_len=nl,\n                                index=j,\n                            )\n                        )\n\n                        # adding gate_label\n                        c_inst.add_ref(\n                            labels_gen(\n                                lbl_str=\"None\",\n                                position=(\n                                    m1.xmin + (m1.size[0] / 2),\n                                    pc1.ymin + (pc1.size[1] / 2),\n                                ),\n                                layer=layer[\"metal1_label\"],\n                                lbl=lbl,\n                                lbl_lst=g_lbl,\n                                lbl_valid_len=nl,\n                                index=i,\n                            )\n                        )\n\n    return c_inst", "\n\n# @gf.cell\ndef hv_gen(c, c_inst, volt, dg_encx: float = 0.1, dg_ency: float = 0.1):\n    \"\"\"Returns high volatge related polygons\n\n    Args :\n        c_inst : dualgate enclosed componenet\n        volt : operating voltage\n        dg_encx : dualgate enclosure in x_direction\n        dg_ency : dualgate enclosure in y_direction\n    \"\"\"\n    # c = gf.Component()\n\n    if volt in [\"5V\", \"6V\"]:\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    c_inst.size[0] + (2 * dg_encx),\n                    c_inst.size[1] + (2 * dg_ency),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = c_inst.xmin - dg_encx\n        dg.ymin = c_inst.ymin - dg_ency\n\n    if volt == \"5V\":\n        v5x = c.add_ref(\n            gf.components.rectangle(\n                size=(dg.size[0], dg.size[1]), layer=layer[\"v5_xtor\"]\n            )\n        )\n        v5x.xmin = dg.xmin\n        v5x.ymin = dg.ymin", "\n    # return c\n\n\n# @gf.cell\ndef bulk_gr_gen(\n    c,\n    c_inst,\n    comp_spacing: float = 0.1,\n    poly2_comp_spacing: float = 0.1,\n    volt: str = \"3.3V\",\n    grw: float = 0.36,\n    l_d: float = 0.1,\n    implant_layer: LayerSpec = layer[\"pplus\"],\n    lbl: bool = 0,\n    sub_lbl: str = \"\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    nw_enc_pcmp: float = 0.1,\n    m1_sp: float = 0.1,\n):\n    \"\"\"Returns guardring\n\n    Args :\n        c_inst : componenet enclosed by guardring\n        comp_spacing : spacing between comp polygons\n        poly2_comp_spacing : spacing between comp and poly2 polygons\n        volt : operating voltage\n        grw : guardring width\n        l_d : total diffusion length\n        implant_layer : layer of comp implant (nplus,pplus)\n    \"\"\"\n\n    # c = gf.Component()\n\n    comp_pp_enc: float = 0.16\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n    dg_enc_cmp = 0.24\n\n    c_temp = gf.Component(\"temp_store\")\n    rect_bulk_in = c_temp.add_ref(\n        gf.components.rectangle(\n            size=(\n                (c_inst.xmax - c_inst.xmin) + 2 * m1_sp,\n                (c_inst.ymax - c_inst.ymin) + 2 * m1_sp,\n            ),\n            layer=layer[\"comp\"],\n        )\n    )\n    rect_bulk_in.move((c_inst.xmin - m1_sp, c_inst.ymin - m1_sp))\n    rect_bulk_out = c_temp.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n                (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n            ),\n            layer=layer[\"comp\"],\n        )\n    )\n    rect_bulk_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n    B = c.add_ref(\n        gf.geometry.boolean(\n            A=rect_bulk_out,\n            B=rect_bulk_in,\n            operation=\"A-B\",\n            layer=layer[\"comp\"],\n        )\n    )\n\n    psdm_in = c_temp.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_bulk_in.xmax - rect_bulk_in.xmin) - 2 * comp_pp_enc,\n                (rect_bulk_in.ymax - rect_bulk_in.ymin) - 2 * comp_pp_enc,\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    psdm_in.move((rect_bulk_in.xmin + comp_pp_enc, rect_bulk_in.ymin + comp_pp_enc))\n    psdm_out = c_temp.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_bulk_out.xmax - rect_bulk_out.xmin) + 2 * comp_pp_enc,\n                (rect_bulk_out.ymax - rect_bulk_out.ymin) + 2 * comp_pp_enc,\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    psdm_out.move(\n        (\n            rect_bulk_out.xmin - comp_pp_enc,\n            rect_bulk_out.ymin - comp_pp_enc,\n        )\n    )\n    c.add_ref(\n        gf.geometry.boolean(A=psdm_out, B=psdm_in, operation=\"A-B\", layer=implant_layer)\n    )  # implant_draw(pplus or nplus)\n\n    # generating contacts\n\n    c.add_ref(\n        via_generator(\n            x_range=(\n                rect_bulk_in.xmin + con_size,\n                rect_bulk_in.xmax - con_size,\n            ),\n            y_range=(rect_bulk_out.ymin, rect_bulk_in.ymin),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # bottom contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(\n                rect_bulk_in.xmin + con_size,\n                rect_bulk_in.xmax - con_size,\n            ),\n            y_range=(rect_bulk_in.ymax, rect_bulk_out.ymax),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # upper contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(rect_bulk_out.xmin, rect_bulk_in.xmin),\n            y_range=(\n                rect_bulk_in.ymin + con_size,\n                rect_bulk_in.ymax - con_size,\n            ),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # right contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(rect_bulk_in.xmax, rect_bulk_out.xmax),\n            y_range=(\n                rect_bulk_in.ymin + con_size,\n                rect_bulk_in.ymax - con_size,\n            ),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # left contact\n\n    comp_m1_in = c_temp.add_ref(\n        gf.components.rectangle(\n            size=(\n                (l_d) + 2 * comp_spacing,\n                (c_inst.ymax - c_inst.ymin) + 2 * poly2_comp_spacing,\n            ),\n            layer=layer[\"metal1\"],\n        )\n    )\n    comp_m1_in.move((-comp_spacing, c_inst.ymin - poly2_comp_spacing))\n    comp_m1_out = c_temp.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n                (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n            ),\n            layer=layer[\"metal1\"],\n        )\n    )\n    comp_m1_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n    c.add_ref(\n        gf.geometry.boolean(\n            A=rect_bulk_out,\n            B=rect_bulk_in,\n            operation=\"A-B\",\n            layer=layer[\"metal1\"],\n        )\n    )  # metal1_gaurdring\n\n    hv_gen(c, c_inst=B, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_cmp)\n\n    c.add_ref(\n        labels_gen(\n            lbl_str=sub_lbl,\n            position=(\n                B.xmin + (grw + 2 * (comp_pp_enc)) / 2,\n                B.ymin + (B.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n            lbl=lbl,\n            lbl_lst=[sub_lbl],\n            lbl_valid_len=1,\n        )\n    )\n\n    if implant_layer == layer[\"pplus\"]:\n        c.add_ref(\n            nfet_deep_nwell(\n                deepnwell=deepnwell,\n                pcmpgr=pcmpgr,\n                inst_size=(B.size[0], B.size[1]),\n                inst_xmin=B.xmin,\n                inst_ymin=B.ymin,\n                grw=grw,\n                volt=volt,\n            )\n        )\n    else:\n        c.add_ref(\n            pfet_deep_nwell(\n                deepnwell=deepnwell,\n                pcmpgr=pcmpgr,\n                enc_size=(B.size[0], B.size[1]),\n                enc_xmin=B.xmin,\n                enc_ymin=B.ymin,\n                nw_enc_pcmp=nw_enc_pcmp,\n                grw=grw,\n                volt=volt,\n            )\n        )", "\n    # return c\n\n\n@gf.cell\ndef pcmpgr_gen(dn_rect, grw: float = 0.36) -> gf.Component:\n    \"\"\"Return deepnwell guardring\n\n    Args :\n        dn_rect : deepnwell polygon\n        grw : guardring width\n    \"\"\"\n\n    c = gf.Component()\n\n    comp_pp_enc: float = 0.16\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n    pcmpgr_enc_dn = 2.5\n\n    c_temp_gr = gf.Component(\"temp_store guard ring\")\n    rect_pcmpgr_in = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n            ),\n            layer=layer[\"comp\"],\n        )\n    )\n    rect_pcmpgr_in.move((dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn))\n    rect_pcmpgr_out = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * grw,\n                (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * grw,\n            ),\n            layer=layer[\"comp\"],\n        )\n    )\n    rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n    c.add_ref(\n        gf.geometry.boolean(\n            A=rect_pcmpgr_out,\n            B=rect_pcmpgr_in,\n            operation=\"A-B\",\n            layer=layer[\"comp\"],\n        )\n    )  # guardring bulk\n\n    psdm_in = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * comp_pp_enc,\n                (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * comp_pp_enc,\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    psdm_in.move(\n        (\n            rect_pcmpgr_in.xmin + comp_pp_enc,\n            rect_pcmpgr_in.ymin + comp_pp_enc,\n        )\n    )\n    psdm_out = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * comp_pp_enc,\n                (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * comp_pp_enc,\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    psdm_out.move(\n        (\n            rect_pcmpgr_out.xmin - comp_pp_enc,\n            rect_pcmpgr_out.ymin - comp_pp_enc,\n        )\n    )\n    c.add_ref(\n        gf.geometry.boolean(\n            A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n        )\n    )  # pplus_draw\n\n    # generating contacts\n\n    c.add_ref(\n        via_generator(\n            x_range=(\n                rect_pcmpgr_in.xmin + con_size,\n                rect_pcmpgr_in.xmax - con_size,\n            ),\n            y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # bottom contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(\n                rect_pcmpgr_in.xmin + con_size,\n                rect_pcmpgr_in.xmax - con_size,\n            ),\n            y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # upper contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n            y_range=(\n                rect_pcmpgr_in.ymin + con_size,\n                rect_pcmpgr_in.ymax - con_size,\n            ),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # right contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n            y_range=(\n                rect_pcmpgr_in.ymin + con_size,\n                rect_pcmpgr_in.ymax - con_size,\n            ),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # left contact\n\n    comp_m1_in = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n            layer=layer[\"metal1\"],\n        )\n    )\n\n    comp_m1_out = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (comp_m1_in.size[0]) + 2 * grw,\n                (comp_m1_in.size[1]) + 2 * grw,\n            ),\n            layer=layer[\"metal1\"],\n        )\n    )\n    comp_m1_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n    c.add_ref(\n        gf.geometry.boolean(\n            A=rect_pcmpgr_out,\n            B=rect_pcmpgr_in,\n            operation=\"A-B\",\n            layer=layer[\"metal1\"],\n        )\n    )  # metal1 guardring\n\n    return c", "\n\n@gf.cell\ndef nfet_deep_nwell(\n    volt=\"3.3V\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    inst_size: Float2 = (0.1, 0.1),\n    inst_xmin: float = 0.1,\n    inst_ymin: float = 0.1,\n    grw: float = 0.36,\n) -> gf.Component:\n    \"\"\"Return nfet deepnwell\n\n    Args :\n        deepnwell : boolean of having deepnwell\n        pcmpgr : boolean of having deepnwell guardring\n        inst_size : deepnwell enclosed size\n        inst_xmin : deepnwell enclosed xmin\n        inst_ymin : deepnwell enclosed ymin\n        grw : guardring width\n    \"\"\"\n\n    c = gf.Component()\n\n    if deepnwell == 1:\n        lvpwell_enc_ncmp = 0.44\n        lvp_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    inst_size[0] + (2 * lvpwell_enc_ncmp),\n                    inst_size[1] + (2 * lvpwell_enc_ncmp),\n                ),\n                layer=layer[\"lvpwell\"],\n            )\n        )\n\n        lvp_rect.ymin = inst_ymin - lvpwell_enc_ncmp\n\n        dn_enc_lvpwell = 2.5\n        lvp_rect.xmin = inst_xmin - lvpwell_enc_ncmp\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    lvp_rect.size[0] + (2 * dn_enc_lvpwell),\n                    lvp_rect.size[1] + (2 * dn_enc_lvpwell),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n\n        dn_rect.xmin = lvp_rect.xmin - dn_enc_lvpwell\n        dn_rect.ymin = lvp_rect.ymin - dn_enc_lvpwell\n\n        if pcmpgr == 1:\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=grw))\n\n        if volt in [\"5V\", \"6V\"]:\n            dg_enc_dn = 0.5\n            dg = c.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        dn_rect.size[0] + (2 * dg_enc_dn),\n                        dn_rect.size[1] + (2 * dg_enc_dn),\n                    ),\n                    layer=layer[\"dualgate\"],\n                )\n            )\n            dg.xmin = dn_rect.xmin - dg_enc_dn\n            dg.ymin = dn_rect.ymin - dg_enc_dn\n\n    elif volt in [\"5V\", \"6V\"]:\n        dg_enc_cmp = 0.24\n        dg_enc_poly = 0.4\n\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    inst_size[0] + (2 * dg_enc_cmp),\n                    inst_size[1] + (2 * dg_enc_poly),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = inst_xmin - dg_enc_cmp\n        dg.ymin = inst_ymin - dg_enc_poly\n\n    if volt == \"5V\":\n        v5x = c.add_ref(\n            gf.components.rectangle(\n                size=(dg.size[0], dg.size[1]), layer=layer[\"v5_xtor\"]\n            )\n        )\n        v5x.xmin = dg.xmin\n        v5x.ymin = dg.ymin\n\n    return c", "\n\ndef add_inter_sd_labels(\n    c, nf, sd_lbl, poly1, l_gate, inter_sd_l, sd_diff_intr, lbl, layer, con_bet_fin\n):\n    \"\"\"Adds label to intermediate source/drain diffusion\n\n    Args :\n        c : instance componenet of the device\n        nf : number of fingers\n        sd_lbl : required source and drain labels list\n        poly1 : componenet of poly array\n        l_gate : length of fet gate\n        inter_sd_l : length of intermediate source/drain diffusion\n        sd_diff_inter : componenet of intermediate source/drain polygon\n        lbl: boolean of having labels\n        layer : layer of label\n        con_bet_fin : boolean of having contact between fingers\n    \"\"\"\n\n    lbl_layer = layer[\"metal1_label\"] if con_bet_fin == 1 else layer[\"comp_label\"]\n    for i in range(int(nf - 1)):\n        c.add_ref(\n            labels_gen(\n                lbl_str=\"None\",\n                position=(\n                    poly1.xmin + l_gate + (inter_sd_l / 2) + i * (l_gate + inter_sd_l),\n                    sd_diff_intr.ymin + (sd_diff_intr.size[1] / 2),\n                ),\n                layer=lbl_layer,\n                lbl=lbl,\n                lbl_lst=sd_lbl,\n                lbl_valid_len=nf + 1,\n                index=i + 1,\n            )\n        )", "\n\ndef add_gate_labels(c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf):\n    \"\"\"Adds gate label when lbl is enabled\n\n    Args :\n        c : instance componenet of the device\n        g_lbl : required gate labels list\n        pc1 : componenet of poly array1\n        c_pc : componenet of poly array element\n        pc_spacing : float of space between labels\n        nc1 : number of columns in poly array1\n        nc2 : number of columns in poly array2\n        pc2 : componenet of poly array2\n        lbl : boolean of having labels\n        layer : layer of labels\n        nf : number of fingers\n    \"\"\"\n\n    for i in range(nc1):\n        c.add_ref(\n            labels_gen(\n                lbl_str=\"None\",\n                position=(\n                    pc1.xmin + (c_pc.size[0] / 2) + i * (pc_spacing),\n                    pc1.ymin + (c_pc.size[1] / 2),\n                ),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                lbl_lst=g_lbl,\n                lbl_valid_len=nf,\n                index=2 * i,\n            )\n        )\n\n    for i in range(nc2):\n        c.add_ref(\n            labels_gen(\n                lbl_str=\"None\",\n                position=(\n                    pc2.xmin + (c_pc.size[0] / 2) + i * (pc_spacing),\n                    pc2.ymin + (c_pc.size[1] / 2),\n                ),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                lbl_lst=g_lbl,\n                lbl_valid_len=nf,\n                index=(2 * i) + 1,\n            )\n        )", "\n\ndef sd_m1_area_check(\n    sd_con_area, m1_area, sd_con, c_inst, sd_l, nf, l_gate, inter_sd_l, pl_cmp_spacing\n):\n    if sd_con_area < m1_area:\n        sd_con_m1 = gf.components.rectangle(\n            size=(sd_con.size[0], m1_area / sd_con.size[1]), layer=layer[\"metal1\"]\n        )\n        sd_m1_arr = c_inst.add_array(\n            component=sd_con_m1,\n            columns=2,\n            rows=1,\n            spacing=(\n                sd_l + nf * l_gate + (nf - 1) * inter_sd_l + 2 * (pl_cmp_spacing),\n                0,\n            ),\n        )\n        sd_m1_arr.xmin = sd_con.xmin\n        sd_m1_arr.ymin = sd_con.ymin - (sd_con_m1.size[1] - sd_con.size[1]) / 2", "\n\ndef poly_con_m1_check(poly_con_area, m1_area, c_pc, poly_con, c_pl_con):\n    if poly_con_area < m1_area:\n        m1_poly = c_pc.add_ref(\n            gf.components.rectangle(\n                size=(m1_area / poly_con.size[0], poly_con.size[1]),\n                layer=layer[\"metal1\"],\n            )\n        )\n        m1_poly.xmin = c_pl_con.xmin - (m1_poly.size[0] - poly_con.size[0]) / 2\n        m1_poly.ymin = c_pl_con.ymin", "\n\ndef inter_sd_m1_area_check(\n    inter_sd_con_area, m1_area, inter_sd_con, c_inst, l_gate, nf, inter_sd_l, sd_con\n):\n    if inter_sd_con_area < m1_area:\n        inter_sd_con_m1 = gf.components.rectangle(\n            size=(inter_sd_con.size[0], m1_area / inter_sd_con.size[1]),\n            layer=layer[\"metal1\"],\n        )\n        inter_sd_m1_arr = c_inst.add_array(\n            component=inter_sd_con_m1,\n            columns=nf - 1,\n            rows=1,\n            spacing=(l_gate + inter_sd_l, 0),\n        )\n        inter_sd_m1_arr.xmin = inter_sd_con.xmin\n        inter_sd_m1_arr.ymin = (\n            inter_sd_con.ymin - (inter_sd_con_m1.size[1] - sd_con.size[1]) / 2\n        )", "\n\ndef bulk_m1_check(bulk_con_area, m1_area, c_inst, bulk_con):\n    if bulk_con_area < m1_area:\n        bulk_m1 = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(bulk_con.size[0], m1_area / bulk_con.size[1]),\n                layer=layer[\"metal1\"],\n            )\n        )\n        bulk_m1.xmin = bulk_con.xmin\n        bulk_m1.ymin = bulk_con.ymin - (bulk_m1.size[1] - bulk_con.size[1]) / 2", "\n\n# @gf.cell\ndef draw_nfet(\n    layout,\n    l_gate: float = 0.28,\n    w_gate: float = 0.22,\n    sd_con_col: int = 1,\n    inter_sd_l: float = 0.24,\n    nf: int = 1,\n    grw: float = 0.22,\n    volt: str = \"3.3V\",\n    bulk=\"None\",\n    con_bet_fin: int = 1,\n    gate_con_pos=\"alternating\",\n    interdig: int = 0,\n    patt=\"\",\n    deepnwell: int = 0,\n    pcmpgr: int = 0,\n    lbl: bool = 0,\n    sd_lbl: list = [],\n    g_lbl: str = [],\n    sub_lbl: str = \"\",\n    patt_lbl: bool = 0,\n) -> gf.Component:\n    \"\"\"\n    Retern nfet\n\n    Args:\n        layout : layout object\n        l : Float of gate length\n        w : Float of gate width\n        sd_l : Float of source and drain diffusion length\n        inter_sd_l : Float of source and drain diffusion length between fingers\n        nf : integer of number of fingers\n        M : integer of number of multipliers\n        grw : gaurd ring width when enabled\n        type : string of the device type\n        bulk : String of bulk connection type (None, Bulk Tie, Guard Ring)\n        con_bet_fin : boolean of having contacts for diffusion between fingers\n        gate_con_pos : string of choosing the gate contact position (bottom, top, alternating )\n\n    \"\"\"\n    # used layers and dimensions\n\n    end_cap: float = 0.3\n    if volt == \"3.3V\":\n        comp_spacing: float = 0.28\n    else:\n        comp_spacing: float = 0.36\n\n    gate_np_enc: float = 0.23\n    comp_np_enc: float = 0.16\n    comp_pp_enc: float = 0.16\n    poly2_spacing: float = 0.24\n    pc_ext: float = 0.04\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n    con_pp_sp = 0.1 - con_comp_enc\n    con_pl_enc = 0.07\n    pl_cmp_spacing = 0.18\n    m1_area = 0.145\n    m1_sp = 0.3\n    pl_cmpcon_sp = 0.15\n\n    sd_l_con = (\n        ((sd_con_col) * con_size)\n        + ((sd_con_col - 1) * con_sp)\n        + 2 * con_comp_enc\n        + 2 * con_pp_sp\n    )\n    sd_l = sd_l_con\n\n    # gds components to store a single instance and the generated device\n    c = gf.Component(\"sky_nfet_dev\")\n\n    c_inst = gf.Component(\"dev_temp\")\n\n    # generating sd diffusion\n\n    if interdig == 1 and nf > 1 and nf != len(patt) and patt != \"\":\n        nf = len(patt)\n\n    l_d = (\n        nf * l_gate + (nf - 1) * inter_sd_l + 2 * (pl_cmp_spacing)\n    )  # diffution total length\n    rect_d_intr = gf.components.rectangle(size=(l_d, w_gate), layer=layer[\"comp\"])\n    sd_diff_intr = c_inst.add_ref(rect_d_intr)\n\n    #     # generatin sd contacts\n\n    if w_gate <= con_size + 2 * con_comp_enc:\n        cmpc_y = con_comp_enc + con_size + con_comp_enc\n        np_cmp_ency = comp_np_enc\n\n    else:\n        cmpc_y = w_gate\n        np_cmp_ency = gate_np_enc\n\n    cmpc_size = (sd_l_con, cmpc_y)\n\n    sd_diff = c_inst.add_array(\n        component=gf.components.rectangle(size=cmpc_size, layer=layer[\"comp\"]),\n        rows=1,\n        columns=2,\n        spacing=(cmpc_size[0] + sd_diff_intr.size[0], 0),\n    )\n\n    sd_diff.xmin = sd_diff_intr.xmin - cmpc_size[0]\n    sd_diff.ymin = sd_diff_intr.ymin - (sd_diff.size[1] - sd_diff_intr.size[1]) / 2\n\n    sd_con = via_stack(\n        x_range=(sd_diff.xmin + con_pp_sp, sd_diff_intr.xmin - con_pp_sp),\n        y_range=(sd_diff.ymin, sd_diff.ymax),\n        base_layer=layer[\"comp\"],\n        metal_level=1,\n    )\n    sd_con_arr = c_inst.add_array(\n        component=sd_con,\n        columns=2,\n        rows=1,\n        spacing=(\n            sd_l + nf * l_gate + (nf - 1) * inter_sd_l + 2 * (pl_cmp_spacing),\n            0,\n        ),\n    )\n\n    sd_con_area = sd_con.size[0] * sd_con.size[1]\n\n    sd_m1_area_check(\n        sd_con_area,\n        m1_area,\n        sd_con,\n        c_inst,\n        sd_l,\n        nf,\n        l_gate,\n        inter_sd_l,\n        pl_cmp_spacing,\n    )\n\n    if con_bet_fin == 1 and nf > 1:\n        inter_sd_con = via_stack(\n            x_range=(\n                sd_diff_intr.xmin + pl_cmp_spacing + l_gate + pl_cmpcon_sp,\n                sd_diff_intr.xmin + pl_cmp_spacing + l_gate + inter_sd_l - pl_cmpcon_sp,\n            ),\n            y_range=(0, w_gate),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n\n        c_inst.add_array(\n            component=inter_sd_con,\n            columns=nf - 1,\n            rows=1,\n            spacing=(l_gate + inter_sd_l, 0),\n        )\n\n        inter_sd_con_area = inter_sd_con.size[0] * inter_sd_con.size[1]\n        inter_sd_m1_area_check(\n            inter_sd_con_area,\n            m1_area,\n            inter_sd_con,\n            c_inst,\n            l_gate,\n            nf,\n            inter_sd_l,\n            sd_con,\n        )\n\n    ### adding source/drain labels\n    c.add_ref(\n        labels_gen(\n            lbl_str=\"None\",\n            position=(sd_diff.xmin + (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n            layer=layer[\"metal1_label\"],\n            lbl=lbl,\n            lbl_lst=sd_lbl,\n            lbl_valid_len=nf + 1,\n            index=0,\n        )\n    )\n\n    c.add_ref(\n        labels_gen(\n            lbl_str=\"None\",\n            position=(sd_diff.xmax - (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n            layer=layer[\"metal1_label\"],\n            lbl=lbl,\n            lbl_lst=sd_lbl,\n            lbl_valid_len=nf + 1,\n            index=nf,\n        )\n    )\n\n    # generating poly\n\n    if l_gate <= con_size + 2 * con_pl_enc:\n        pc_x = con_pl_enc + con_size + con_pl_enc\n\n    else:\n        pc_x = l_gate\n\n    pc_size = (pc_x, con_pl_enc + con_size + con_pl_enc)\n\n    c_pc = gf.Component(\"poly con\")\n\n    rect_pc = c_pc.add_ref(gf.components.rectangle(size=pc_size, layer=layer[\"poly2\"]))\n\n    poly_con = via_stack(\n        x_range=(rect_pc.xmin, rect_pc.xmax),\n        y_range=(rect_pc.ymin, rect_pc.ymax),\n        base_layer=layer[\"poly2\"],\n        metal_level=1,\n        li_enc_dir=\"H\",\n    )\n    c_pl_con = c_pc.add_ref(poly_con)\n\n    poly_con_area = poly_con.size[0] * poly_con.size[1]\n\n    poly_con_m1_check(poly_con_area, m1_area, c_pc, poly_con, c_pl_con)\n\n    if nf == 1:\n        poly = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(l_gate, w_gate + 2 * end_cap), layer=layer[\"poly2\"]\n            )\n        )\n        poly.xmin = sd_diff_intr.xmin + pl_cmp_spacing\n        poly.ymin = sd_diff_intr.ymin - end_cap\n\n        if gate_con_pos == \"bottom\":\n            mv = 0\n            nr = 1\n        elif gate_con_pos == \"top\":\n            mv = pc_size[1] + w_gate + 2 * end_cap\n            nr = 1\n        else:\n            mv = 0\n            nr = 2\n\n        pc = c_inst.add_array(\n            component=c_pc,\n            rows=nr,\n            columns=1,\n            spacing=(0, pc_size[1] + w_gate + 2 * end_cap),\n        )\n        pc.move((poly.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv))\n\n        # gate_lablel\n        c.add_ref(\n            labels_gen(\n                lbl_str=\"None\",\n                position=(pc.xmin + c_pc.size[0] / 2, pc.ymin + c_pc.size[1] / 2),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                lbl_lst=g_lbl,\n                lbl_valid_len=nf,\n                index=0,\n            )\n        )\n\n    else:\n        w_p1 = end_cap + w_gate + end_cap  # poly total width\n\n        if inter_sd_l < (poly2_spacing + 2 * pc_ext):\n            if gate_con_pos == \"alternating\":\n                w_p1 += 0.2\n                w_p2 = w_p1\n                e_c = 0.2\n            else:\n                w_p2 = w_p1 + con_pl_enc + con_size + con_pl_enc + poly2_spacing + 0.1\n                e_c = 0\n\n            if gate_con_pos == \"bottom\":\n                p_mv = -end_cap - (w_p2 - w_p1)\n            else:\n                p_mv = -end_cap\n\n        else:\n            w_p2 = w_p1\n            p_mv = -end_cap\n            e_c = 0\n\n        rect_p1 = gf.components.rectangle(size=(l_gate, w_p1), layer=layer[\"poly2\"])\n        rect_p2 = gf.components.rectangle(size=(l_gate, w_p2), layer=layer[\"poly2\"])\n        poly1 = c_inst.add_array(\n            rect_p1,\n            rows=1,\n            columns=ceil(nf / 2),\n            spacing=[2 * (inter_sd_l + l_gate), 0],\n        )\n        poly1.xmin = sd_diff_intr.xmin + pl_cmp_spacing\n        poly1.ymin = sd_diff_intr.ymin - end_cap - e_c\n\n        poly2 = c_inst.add_array(\n            rect_p2,\n            rows=1,\n            columns=floor(nf / 2),\n            spacing=[2 * (inter_sd_l + l_gate), 0],\n        )\n        poly2.xmin = poly1.xmin + l_gate + inter_sd_l\n        poly2.ymin = p_mv\n\n        # generating poly contacts setups\n\n        if gate_con_pos == \"bottom\":\n            mv_1 = 0\n            mv_2 = -(w_p2 - w_p1)\n        elif gate_con_pos == \"top\":\n            mv_1 = pc_size[1] + w_p1\n            mv_2 = pc_size[1] + w_p2\n        else:\n            mv_1 = -e_c\n            mv_2 = pc_size[1] + w_p2\n\n        nc1 = ceil(nf / 2)\n        nc2 = floor(nf / 2)\n\n        pc_spacing = 2 * (inter_sd_l + l_gate)\n\n        # generating poly contacts\n\n        pc1 = c_inst.add_array(\n            component=c_pc, rows=1, columns=nc1, spacing=(pc_spacing, 0)\n        )\n        pc1.move((poly1.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv_1))\n\n        pc2 = c_inst.add_array(\n            component=c_pc, rows=1, columns=nc2, spacing=(pc_spacing, 0)\n        )\n        pc2.move(\n            (\n                poly1.xmin - ((pc_x - l_gate) / 2) + (inter_sd_l + l_gate),\n                -pc_size[1] - end_cap + mv_2,\n            )\n        )\n\n        add_inter_sd_labels(\n            c,\n            nf,\n            sd_lbl,\n            poly1,\n            l_gate,\n            inter_sd_l,\n            sd_diff_intr,\n            lbl,\n            layer,\n            con_bet_fin,\n        )\n\n        if interdig == 1:\n            c_inst.add_ref(\n                interdigit(\n                    sd_diff=sd_diff,\n                    pc1=pc1,\n                    pc2=pc2,\n                    poly_con=poly_con,\n                    sd_diff_intr=sd_diff_intr,\n                    l_gate=l_gate,\n                    inter_sd_l=inter_sd_l,\n                    sd_l=sd_l,\n                    nf=nf,\n                    patt=patt,\n                    gate_con_pos=gate_con_pos,\n                    pc_x=pc_x,\n                    pc_spacing=pc_spacing,\n                    lbl=lbl,\n                    g_lbl=g_lbl,\n                    patt_lbl=patt_lbl,\n                )\n            )\n        else:\n            add_gate_labels(\n                c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf\n            )\n\n    # generating bulk\n    if bulk == \"None\":\n        nplus = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(\n                    sd_diff.size[0] + 2 * comp_np_enc,\n                    sd_diff.size[1] + 2 * np_cmp_ency,\n                ),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nplus.xmin = sd_diff.xmin - comp_np_enc\n        nplus.ymin = sd_diff.ymin - np_cmp_ency\n\n    elif bulk == \"Bulk Tie\":\n        rect_bulk = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_l + con_sp, sd_diff.size[1]), layer=layer[\"comp\"]\n            )\n        )\n        rect_bulk.xmin = sd_diff.xmax\n        rect_bulk.ymin = sd_diff.ymin\n        nsdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(\n                    sd_diff.xmax - sd_diff.xmin + comp_np_enc,\n                    sd_diff.size[1] + (2 * np_cmp_ency),\n                ),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nsdm.xmin = sd_diff.xmin - comp_np_enc\n        nsdm.ymin = sd_diff.ymin - np_cmp_ency\n        psdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(\n                    rect_bulk.xmax - rect_bulk.xmin + comp_pp_enc,\n                    w_gate + 2 * comp_pp_enc,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm.connect(\"e1\", destination=nsdm.ports[\"e3\"])\n\n        bulk_con = via_stack(\n            x_range=(sd_con_arr.xmax + m1_sp, rect_bulk.xmax),\n            y_range=(rect_bulk.ymin, rect_bulk.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n        c_inst.add_ref(bulk_con)\n\n        bulk_con_area = bulk_con.size[0] * bulk_con.size[1]\n\n        bulk_m1_check(bulk_con_area, m1_area, c_inst, bulk_con)\n\n        c.add_ref(\n            labels_gen(\n                lbl_str=sub_lbl,\n                position=(\n                    bulk_con.xmin + bulk_con.size[0] / 2,\n                    bulk_con.ymin + bulk_con.size[1] / 2,\n                ),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                lbl_lst=[sub_lbl],\n                lbl_valid_len=1,\n            )\n        )\n\n    if bulk == \"Guard Ring\":\n        nsdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_np_enc),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nsdm.xmin = sd_diff.xmin - comp_np_enc\n        nsdm.ymin = sd_diff_intr.ymin - gate_np_enc\n        c.add_ref(c_inst)\n\n        bulk_gr_gen(\n            c,\n            c_inst=c_inst,\n            comp_spacing=comp_spacing,\n            poly2_comp_spacing=comp_spacing,\n            volt=volt,\n            grw=grw,\n            l_d=l_d,\n            implant_layer=layer[\"pplus\"],\n            lbl=lbl,\n            sub_lbl=sub_lbl,\n            deepnwell=deepnwell,\n            pcmpgr=pcmpgr,\n            m1_sp=m1_sp,\n        )\n\n    else:\n        c.add_ref(c_inst)\n\n        inst_size = (c_inst.size[0], c_inst.size[1])\n        inst_xmin = c_inst.xmin\n        inst_ymin = c_inst.ymin\n\n        c.add_ref(\n            nfet_deep_nwell(\n                deepnwell=deepnwell,\n                pcmpgr=pcmpgr,\n                inst_size=inst_size,\n                inst_xmin=inst_xmin,\n                inst_ymin=inst_ymin,\n                grw=grw,\n                volt=volt,\n            )\n        )\n\n    # creating layout and cell in klayout\n    c.write_gds(\"nfet_temp.gds\")\n    layout.read(\"nfet_temp.gds\")\n    cell_name = \"sky_nfet_dev\"\n\n    return layout.cell(cell_name)", "    # return c\n\n\n@gf.cell\ndef pfet_deep_nwell(\n    volt=\"3.3V\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    enc_size: Float2 = (0.1, 0.1),\n    enc_xmin: float = 0.1,\n    enc_ymin: float = 0.1,\n    nw_enc_pcmp: float = 0.1,\n    grw: float = 0.36,\n) -> gf.Component:\n    \"\"\"Returns pfet well related polygons\n\n    Args :\n        deepnwell : boolaen of having deepnwell\n        pcmpgr : boolean of having deepnwell guardring\n        enc_size : enclosed size\n        enc_xmin : enclosed xmin\n        enc_ymin : enclosed ymin\n        nw_enc_pcmp : nwell enclosure of pcomp\n        grw : guardring width\n    \"\"\"\n\n    c = gf.Component()\n\n    dnwell_enc_pcmp = 1.1\n    dg_enc_dn = 0.5\n\n    if deepnwell == 1:\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    enc_size[0] + (2 * dnwell_enc_pcmp),\n                    enc_size[1] + (2 * dnwell_enc_pcmp),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n\n        dn_rect.xmin = enc_xmin - dnwell_enc_pcmp\n        dn_rect.ymin = enc_ymin - dnwell_enc_pcmp\n\n        if pcmpgr == 1:\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=grw))\n\n        if volt == \"5V\" or volt == \"6V\":\n            dg = c.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        dn_rect.size[0] + (2 * dg_enc_dn),\n                        dn_rect.size[1] + (2 * dg_enc_dn),\n                    ),\n                    layer=layer[\"dualgate\"],\n                )\n            )\n            dg.xmin = dn_rect.xmin - dg_enc_dn\n            dg.ymin = dn_rect.ymin - dg_enc_dn\n\n            if volt == \"5V\":\n                v5x = c.add_ref(\n                    gf.components.rectangle(\n                        size=(dg.size[0], dg.size[1]), layer=layer[\"v5_xtor\"]\n                    )\n                )\n                v5x.xmin = dg.xmin\n                v5x.ymin = dg.ymin\n\n    else:\n        # nwell generation\n        nw = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    enc_size[0] + (2 * nw_enc_pcmp),\n                    enc_size[1] + (2 * nw_enc_pcmp),\n                ),\n                layer=layer[\"nwell\"],\n            )\n        )\n        nw.xmin = enc_xmin - nw_enc_pcmp\n        nw.ymin = enc_ymin - nw_enc_pcmp\n\n        if volt == \"5V\" or volt == \"6V\":\n            dg = c.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        nw.size[0] + (2 * dg_enc_dn),\n                        nw.size[1] + (2 * dg_enc_dn),\n                    ),\n                    layer=layer[\"dualgate\"],\n                )\n            )\n            dg.xmin = nw.xmin - dg_enc_dn\n            dg.ymin = nw.ymin - dg_enc_dn\n\n            if volt == \"5V\":\n                v5x = c.add_ref(\n                    gf.components.rectangle(\n                        size=(dg.size[0], dg.size[1]), layer=layer[\"v5_xtor\"]\n                    )\n                )\n                v5x.xmin = dg.xmin\n                v5x.ymin = dg.ymin\n\n    return c", "\n\n# @gf.cell\ndef draw_pfet(\n    layout,\n    l_gate: float = 0.28,\n    w_gate: float = 0.22,\n    sd_con_col: int = 1,\n    inter_sd_l: float = 0.24,\n    nf: int = 1,\n    grw: float = 0.22,\n    volt: str = \"3.3V\",\n    bulk=\"None\",\n    con_bet_fin: int = 1,\n    gate_con_pos=\"alternating\",\n    interdig: int = 0,\n    patt=\"\",\n    deepnwell: int = 0,\n    pcmpgr: int = 0,\n    lbl: bool = 0,\n    sd_lbl: list = [],\n    g_lbl: str = [],\n    sub_lbl: str = \"\",\n    patt_lbl: bool = 0,\n) -> gf.Component:\n    \"\"\"\n    Retern pfet\n\n    Args:\n        layout : layout object\n        l : Float of gate length\n        w : Float of gate width\n        sd_l : Float of source and drain diffusion length\n        inter_sd_l : Float of source and drain diffusion length between fingers\n        nf : integer of number of fingers\n        M : integer of number of multipliers\n        grw : gaurd ring width when enabled\n        type : string of the device type\n        bulk : String of bulk connection type (None, Bulk Tie, Guard Ring)\n        con_bet_fin : boolean of having contacts for diffusion between fingers\n        gate_con_pos : string of choosing the gate contact position (bottom, top, alternating )\n\n    \"\"\"\n    # used layers and dimensions\n\n    end_cap: float = 0.22\n    if volt == \"3.3V\":\n        comp_spacing: float = 0.28\n        nw_enc_pcmp = 0.43\n    else:\n        comp_spacing: float = 0.36\n        nw_enc_pcmp = 0.6\n\n    gate_pp_enc: float = 0.23\n    comp_np_enc: float = 0.16\n    comp_pp_enc: float = 0.16\n    poly2_spacing: float = 0.24\n    pc_ext: float = 0.04\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n    con_pp_sp = 0.1 - con_comp_enc\n    pl_cmp_spacing = 0.1\n    con_pl_enc = 0.07\n    dg_enc_cmp = 0.24\n    dg_enc_poly = 0.4\n    m1_sp = 0.3\n    m1_area = 0.145\n    pl_cmpcon_sp = 0.15\n\n    # sd_l_con = (\n    #     ((sd_con_col) * con_size) + ((sd_con_col - 1) * con_sp) + 2 * con_comp_enc\n    # )\n    sd_l_con = (\n        ((sd_con_col) * con_size)\n        + ((sd_con_col - 1) * con_sp)\n        + 2 * con_comp_enc\n        + 2 * con_pp_sp\n    )\n    sd_l = sd_l_con\n\n    # gds components to store a single instance and the generated device\n    c = gf.Component(\"sky_pfet_dev\")\n\n    c_inst = gf.Component(\"dev_temp\")\n\n    # generating sd diffusion\n\n    if interdig == 1 and nf > 1 and nf != len(patt) and patt != \"\":\n        nf = len(patt)\n\n    l_d = (\n        nf * l_gate + (nf - 1) * inter_sd_l + 2 * (pl_cmp_spacing)\n    )  # diffution total length\n    rect_d_intr = gf.components.rectangle(size=(l_d, w_gate), layer=layer[\"comp\"])\n    sd_diff_intr = c_inst.add_ref(rect_d_intr)\n\n    # generatin sd contacts\n\n    if w_gate <= con_size + 2 * con_comp_enc:\n        cmpc_y = con_comp_enc + con_size + con_comp_enc\n        pp_cmp_ency = comp_pp_enc\n\n    else:\n        cmpc_y = w_gate\n        pp_cmp_ency = gate_pp_enc\n\n    cmpc_size = (sd_l_con, cmpc_y)\n\n    sd_diff = c_inst.add_array(\n        component=gf.components.rectangle(size=cmpc_size, layer=layer[\"comp\"]),\n        rows=1,\n        columns=2,\n        spacing=(cmpc_size[0] + sd_diff_intr.size[0], 0),\n    )\n\n    sd_diff.xmin = sd_diff_intr.xmin - cmpc_size[0]\n    sd_diff.ymin = sd_diff_intr.ymin - (sd_diff.size[1] - sd_diff_intr.size[1]) / 2\n\n    sd_con = via_stack(\n        x_range=(sd_diff.xmin + con_pp_sp, sd_diff_intr.xmin - con_pp_sp),\n        y_range=(sd_diff.ymin, sd_diff.ymax),\n        base_layer=layer[\"comp\"],\n        metal_level=1,\n    )\n    sd_con_arr = c_inst.add_array(\n        component=sd_con,\n        columns=2,\n        rows=1,\n        spacing=(\n            sd_l + nf * l_gate + (nf - 1) * inter_sd_l + 2 * (pl_cmp_spacing),\n            0,\n        ),\n    )\n\n    sd_con_area = sd_con.size[0] * sd_con.size[1]\n\n    sd_m1_area_check(\n        sd_con_area,\n        m1_area,\n        sd_con,\n        c_inst,\n        sd_l,\n        nf,\n        l_gate,\n        inter_sd_l,\n        pl_cmp_spacing,\n    )\n\n    if con_bet_fin == 1 and nf > 1:\n        inter_sd_con = via_stack(\n            x_range=(\n                sd_diff_intr.xmin + pl_cmp_spacing + l_gate + pl_cmpcon_sp,\n                sd_diff_intr.xmin + pl_cmp_spacing + l_gate + inter_sd_l - pl_cmpcon_sp,\n            ),\n            y_range=(0, w_gate),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n\n        c_inst.add_array(\n            component=inter_sd_con,\n            columns=nf - 1,\n            rows=1,\n            spacing=(l_gate + inter_sd_l, 0),\n        )\n\n        inter_sd_con_area = inter_sd_con.size[0] * inter_sd_con.size[1]\n        inter_sd_m1_area_check(\n            inter_sd_con_area,\n            m1_area,\n            inter_sd_con,\n            c_inst,\n            l_gate,\n            nf,\n            inter_sd_l,\n            sd_con,\n        )\n\n    ### adding source/drain labels\n    c.add_ref(\n        labels_gen(\n            lbl_str=\"None\",\n            position=(sd_diff.xmin + (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n            layer=layer[\"metal1_label\"],\n            lbl=lbl,\n            lbl_lst=sd_lbl,\n            lbl_valid_len=nf + 1,\n            index=0,\n        )\n    )\n\n    c.add_ref(\n        labels_gen(\n            lbl_str=\"None\",\n            position=(sd_diff.xmax - (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n            layer=layer[\"metal1_label\"],\n            lbl=lbl,\n            lbl_lst=sd_lbl,\n            lbl_valid_len=nf + 1,\n            index=nf,\n        )\n    )\n\n    # generating poly\n\n    if l_gate <= con_size + 2 * con_pl_enc:\n        pc_x = con_pl_enc + con_size + con_pl_enc\n\n    else:\n        pc_x = l_gate\n\n    pc_size = (pc_x, con_pl_enc + con_size + con_pl_enc)\n\n    c_pc = gf.Component(\"poly con\")\n\n    rect_pc = c_pc.add_ref(gf.components.rectangle(size=pc_size, layer=layer[\"poly2\"]))\n\n    poly_con = via_stack(\n        x_range=(rect_pc.xmin, rect_pc.xmax),\n        y_range=(rect_pc.ymin, rect_pc.ymax),\n        base_layer=layer[\"poly2\"],\n        metal_level=1,\n        li_enc_dir=\"H\",\n    )\n    c_pl_con = c_pc.add_ref(poly_con)\n\n    poly_con_area = poly_con.size[0] * poly_con.size[1]\n\n    poly_con_m1_check(poly_con_area, m1_area, c_pc, poly_con, c_pl_con)\n\n    if nf == 1:\n        poly = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(l_gate, w_gate + 2 * end_cap), layer=layer[\"poly2\"]\n            )\n        )\n        poly.xmin = sd_diff_intr.xmin + pl_cmp_spacing\n        poly.ymin = sd_diff_intr.ymin - end_cap\n\n        if gate_con_pos == \"bottom\":\n            mv = 0\n            nr = 1\n        elif gate_con_pos == \"top\":\n            mv = pc_size[1] + w_gate + 2 * end_cap\n            nr = 1\n        else:\n            mv = 0\n            nr = 2\n\n        pc = c_inst.add_array(\n            component=c_pc,\n            rows=nr,\n            columns=1,\n            spacing=(0, pc_size[1] + w_gate + 2 * end_cap),\n        )\n        pc.move((poly.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv))\n\n        # gate_lablel\n        c.add_ref(\n            labels_gen(\n                lbl_str=\"None\",\n                position=(pc.xmin + c_pc.size[0] / 2, pc.ymin + c_pc.size[1] / 2),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                lbl_lst=g_lbl,\n                lbl_valid_len=nf,\n                index=0,\n            )\n        )\n\n    else:\n        w_p1 = end_cap + w_gate + end_cap  # poly total width\n\n        if inter_sd_l < (poly2_spacing + 2 * pc_ext):\n            if gate_con_pos == \"alternating\":\n                w_p1 += 0.2\n                w_p2 = w_p1\n                e_c = 0.2\n            else:\n                w_p2 = w_p1 + con_pl_enc + con_size + con_pl_enc + poly2_spacing + 0.1\n                e_c = 0\n\n            if gate_con_pos == \"bottom\":\n                p_mv = -end_cap - (w_p2 - w_p1)\n            else:\n                p_mv = -end_cap\n\n        else:\n            w_p2 = w_p1\n            p_mv = -end_cap\n            e_c = 0\n\n        rect_p1 = gf.components.rectangle(size=(l_gate, w_p1), layer=layer[\"poly2\"])\n        rect_p2 = gf.components.rectangle(size=(l_gate, w_p2), layer=layer[\"poly2\"])\n        poly1 = c_inst.add_array(\n            rect_p1,\n            rows=1,\n            columns=ceil(nf / 2),\n            spacing=[2 * (inter_sd_l + l_gate), 0],\n        )\n        poly1.xmin = sd_diff_intr.xmin + pl_cmp_spacing\n        poly1.ymin = sd_diff_intr.ymin - end_cap - e_c\n\n        poly2 = c_inst.add_array(\n            rect_p2,\n            rows=1,\n            columns=floor(nf / 2),\n            spacing=[2 * (inter_sd_l + l_gate), 0],\n        )\n        poly2.xmin = poly1.xmin + l_gate + inter_sd_l\n        poly2.ymin = p_mv\n\n        # generating poly contacts setups\n\n        if gate_con_pos == \"bottom\":\n            mv_1 = 0\n            mv_2 = -(w_p2 - w_p1)\n        elif gate_con_pos == \"top\":\n            mv_1 = pc_size[1] + w_p1\n            mv_2 = pc_size[1] + w_p2\n        else:\n            mv_1 = -e_c\n            mv_2 = pc_size[1] + w_p2\n\n        nc1 = ceil(nf / 2)\n        nc2 = floor(nf / 2)\n\n        pc_spacing = 2 * (inter_sd_l + l_gate)\n\n        # generating poly contacts\n\n        pc1 = c_inst.add_array(\n            component=c_pc, rows=1, columns=nc1, spacing=(pc_spacing, 0)\n        )\n        pc1.move((poly1.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv_1))\n\n        pc2 = c_inst.add_array(\n            component=c_pc, rows=1, columns=nc2, spacing=(pc_spacing, 0)\n        )\n        pc2.move(\n            (\n                poly1.xmin - ((pc_x - l_gate) / 2) + (inter_sd_l + l_gate),\n                -pc_size[1] - end_cap + mv_2,\n            )\n        )\n\n        add_inter_sd_labels(\n            c,\n            nf,\n            sd_lbl,\n            poly1,\n            l_gate,\n            inter_sd_l,\n            sd_diff_intr,\n            lbl,\n            layer,\n            con_bet_fin,\n        )\n\n        add_gate_labels(c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf)\n\n        if interdig == 1:\n            c_inst.add_ref(\n                interdigit(\n                    sd_diff=sd_diff,\n                    pc1=pc1,\n                    pc2=pc2,\n                    poly_con=poly_con,\n                    sd_diff_intr=sd_diff_intr,\n                    l_gate=l_gate,\n                    inter_sd_l=inter_sd_l,\n                    sd_l=sd_l,\n                    nf=nf,\n                    patt=patt,\n                    gate_con_pos=gate_con_pos,\n                    pc_x=pc_x,\n                    pc_spacing=pc_spacing,\n                    lbl=lbl,\n                    g_lbl=g_lbl,\n                    patt_lbl=patt_lbl,\n                )\n            )\n\n    # generating bulk\n    if bulk == \"None\":\n        pplus = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_diff.size[0] + 2 * comp_pp_enc, w_gate + 2 * gate_pp_enc),\n                layer=layer[\"pplus\"],\n            )\n        )\n        pplus.xmin = sd_diff.xmin - comp_pp_enc\n        pplus.ymin = sd_diff_intr.ymin - gate_pp_enc\n\n        c.add_ref(c_inst)\n\n        # deep nwell and nwell generation\n\n        c.add_ref(\n            pfet_deep_nwell(\n                deepnwell=deepnwell,\n                pcmpgr=pcmpgr,\n                enc_size=(sd_diff.size[0], sd_diff.size[1]),\n                enc_xmin=sd_diff.xmin,\n                enc_ymin=sd_diff.ymin,\n                nw_enc_pcmp=nw_enc_pcmp,\n                grw=grw,\n                volt=volt,\n            )\n        )\n\n        hv_gen(c, c_inst=c_inst, volt=volt, dg_encx=dg_enc_cmp, dg_ency=dg_enc_poly)\n\n    elif bulk == \"Bulk Tie\":\n        rect_bulk = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_l + con_sp, sd_diff.size[1]), layer=layer[\"comp\"]\n            )\n        )\n        rect_bulk.xmin = sd_diff.xmax\n        rect_bulk.ymin = sd_diff.ymin\n        psdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(\n                    sd_diff.xmax - sd_diff.xmin + comp_pp_enc,\n                    sd_diff.size[1] + (2 * pp_cmp_ency),\n                    # w_gate + 2 * gate_pp_enc,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm.xmin = sd_diff.xmin - comp_pp_enc\n        psdm.ymin = sd_diff.ymin - gate_pp_enc\n        nsdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(\n                    rect_bulk.xmax - rect_bulk.xmin + comp_np_enc,\n                    w_gate + 2 * comp_np_enc,\n                ),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nsdm.connect(\"e1\", destination=psdm.ports[\"e3\"])\n\n        bulk_con = via_stack(\n            x_range=(sd_con_arr.xmax + m1_sp, rect_bulk.xmax),\n            y_range=(rect_bulk.ymin, rect_bulk.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n        c_inst.add_ref(bulk_con)\n\n        bulk_con_area = bulk_con.size[0] * bulk_con.size[1]\n\n        bulk_m1_check(bulk_con_area, m1_area, c_inst, bulk_con)\n\n        c.add_ref(c_inst)\n\n        c.add_ref(\n            labels_gen(\n                lbl_str=sub_lbl,\n                position=(\n                    bulk_con.xmin + bulk_con.size[0] / 2,\n                    bulk_con.ymin + bulk_con.size[1] / 2,\n                ),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                lbl_lst=[sub_lbl],\n                lbl_valid_len=1,\n            )\n        )\n\n        # deep nwell generation\n        nw_enc_pcmp = 0.45 + comp_np_enc + psdm.ymax - nsdm.ymax\n        c.add_ref(\n            pfet_deep_nwell(\n                deepnwell=deepnwell,\n                pcmpgr=pcmpgr,\n                enc_size=(sd_diff.size[0] + rect_bulk.size[0], sd_diff.size[1]),\n                enc_xmin=sd_diff.xmin,\n                enc_ymin=sd_diff.ymin,\n                nw_enc_pcmp=nw_enc_pcmp,\n                grw=grw,\n                volt=volt,\n            )\n        )\n\n    elif bulk == \"Guard Ring\":\n        psdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_pp_enc),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm.xmin = sd_diff.xmin - comp_pp_enc\n        psdm.ymin = sd_diff_intr.ymin - gate_pp_enc\n        c.add_ref(c_inst)\n\n        bulk_gr_gen(\n            c,\n            c_inst=c_inst,\n            comp_spacing=comp_spacing,\n            poly2_comp_spacing=comp_spacing,\n            volt=volt,\n            grw=grw,\n            l_d=l_d,\n            implant_layer=layer[\"nplus\"],\n            lbl=lbl,\n            sub_lbl=sub_lbl,\n            deepnwell=deepnwell,\n            pcmpgr=pcmpgr,\n            nw_enc_pcmp=nw_enc_pcmp,\n            m1_sp=m1_sp,\n        )\n        # bulk guardring\n\n    # creating layout and cell in klayout\n    c.write_gds(\"pfet_temp.gds\")\n    layout.read(\"pfet_temp.gds\")\n    cell_name = \"sky_pfet_dev\"\n\n    return layout.cell(cell_name)", "\n\ndef draw_nfet_06v0_nvt(\n    layout,\n    l_gate: float = 1.8,\n    w_gate: float = 0.8,\n    sd_con_col: int = 1,\n    inter_sd_l: float = 0.24,\n    nf: int = 1,\n    grw: float = 0.22,\n    bulk=\"None\",\n    con_bet_fin: int = 1,\n    gate_con_pos=\"alternating\",\n    interdig: int = 0,\n    patt=\"\",\n    lbl: bool = 0,\n    sd_lbl: list = [],\n    g_lbl: str = [],\n    sub_lbl: str = \"\",\n    patt_lbl: bool = 0,\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw Native NFET 6V transistor by specifying parameters\n    Arguments:-\n     layout : Object of layout\n     l      : Float of gate length\n     w      : Float of gate width\n     ld     : Float of diffusion length\n     nf     : Integer of number of fingers\n     grw    : Float of guard ring width [If enabled]\n     bulk   : String of bulk connection type [None, Bulk Tie, Guard Ring]\n    \"\"\"\n\n    # used layers and dimensions\n\n    end_cap: float = 0.22\n\n    comp_spacing: float = 0.36\n    poly2_comp_spacing: float = 0.3\n\n    gate_np_enc: float = 0.23\n    comp_np_enc: float = 0.16\n    comp_pp_enc: float = 0.16\n    poly2_spacing: float = 0.24\n    pc_ext: float = 0.04\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n    con_pp_sp = 0.1 - con_comp_enc\n    pl_cmp_spacing = 0.1\n    con_pl_enc = 0.07\n    pl_cmpcon_sp = 0.15\n    nvt_enc_cmp = 2\n    m1_sp = 0.3\n    m1_area = 0.145\n\n    sd_l_con = (\n        ((sd_con_col) * con_size)\n        + ((sd_con_col - 1) * con_sp)\n        + 2 * con_comp_enc\n        + 2 * con_pp_sp\n    )\n    sd_l = sd_l_con\n\n    # gds components to store a single instance and the generated device\n    c = gf.Component(\"sky_nfet_nvt_dev\")\n\n    c_inst = gf.Component(\"dev_temp\")\n\n    # generating sd diffusion\n\n    if interdig == 1 and nf > 1 and nf != len(patt) and patt != \"\":\n        nf = len(patt)\n\n    l_d = (\n        nf * l_gate + (nf - 1) * inter_sd_l + 2 * (pl_cmp_spacing)\n    )  # diffution total length\n    rect_d_intr = gf.components.rectangle(size=(l_d, w_gate), layer=layer[\"comp\"])\n    sd_diff_intr = c_inst.add_ref(rect_d_intr)\n\n    # generatin sd contacts\n\n    if w_gate <= con_size + 2 * con_comp_enc:\n        cmpc_y = con_comp_enc + con_size + con_comp_enc\n        np_cmp_ency = comp_np_enc\n\n    else:\n        cmpc_y = w_gate\n        np_cmp_ency = gate_np_enc\n\n    cmpc_size = (sd_l_con, cmpc_y)\n\n    sd_diff = c_inst.add_array(\n        component=gf.components.rectangle(size=cmpc_size, layer=layer[\"comp\"]),\n        rows=1,\n        columns=2,\n        spacing=(cmpc_size[0] + sd_diff_intr.size[0], 0),\n    )\n\n    sd_diff.xmin = sd_diff_intr.xmin - cmpc_size[0]\n    sd_diff.ymin = sd_diff_intr.ymin - (sd_diff.size[1] - sd_diff_intr.size[1]) / 2\n\n    sd_con = via_stack(\n        x_range=(sd_diff.xmin + con_pp_sp, sd_diff_intr.xmin - con_pp_sp),\n        y_range=(sd_diff.ymin, sd_diff.ymax),\n        base_layer=layer[\"comp\"],\n        metal_level=1,\n    )\n    sd_con_arr = c_inst.add_array(\n        component=sd_con,\n        columns=2,\n        rows=1,\n        spacing=(\n            sd_l + nf * l_gate + (nf - 1) * inter_sd_l + 2 * (pl_cmp_spacing),\n            0,\n        ),\n    )\n\n    sd_con_area = sd_con.size[0] * sd_con.size[1]\n\n    sd_m1_area_check(\n        sd_con_area,\n        m1_area,\n        sd_con,\n        c_inst,\n        sd_l,\n        nf,\n        l_gate,\n        inter_sd_l,\n        pl_cmp_spacing,\n    )\n\n    if con_bet_fin == 1 and nf > 1:\n        inter_sd_con = via_stack(\n            x_range=(\n                sd_diff_intr.xmin + pl_cmp_spacing + l_gate + pl_cmpcon_sp,\n                sd_diff_intr.xmin + pl_cmp_spacing + l_gate + inter_sd_l - pl_cmpcon_sp,\n            ),\n            y_range=(0, w_gate),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n\n        c_inst.add_array(\n            component=inter_sd_con,\n            columns=nf - 1,\n            rows=1,\n            spacing=(l_gate + inter_sd_l, 0),\n        )\n\n        inter_sd_con_area = inter_sd_con.size[0] * inter_sd_con.size[1]\n        inter_sd_m1_area_check(\n            inter_sd_con_area,\n            m1_area,\n            inter_sd_con,\n            c_inst,\n            l_gate,\n            nf,\n            inter_sd_l,\n            sd_con,\n        )\n\n    ### adding source/drain labels\n    c.add_ref(\n        labels_gen(\n            lbl_str=\"None\",\n            position=(sd_diff.xmin + (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n            layer=layer[\"metal1_label\"],\n            lbl=lbl,\n            lbl_lst=sd_lbl,\n            lbl_valid_len=nf + 1,\n            index=0,\n        )\n    )\n\n    c.add_ref(\n        labels_gen(\n            lbl_str=\"None\",\n            position=(sd_diff.xmax - (sd_l / 2), sd_diff.ymin + (sd_diff.size[1] / 2)),\n            layer=layer[\"metal1_label\"],\n            lbl=lbl,\n            lbl_lst=sd_lbl,\n            lbl_valid_len=nf + 1,\n            index=nf,\n        )\n    )\n\n    # generating poly\n\n    if l_gate <= con_size + 2 * con_pl_enc:\n        pc_x = con_pl_enc + con_size + con_pl_enc\n\n    else:\n        pc_x = l_gate\n\n    pc_size = (pc_x, con_pl_enc + con_size + con_pl_enc)\n\n    c_pc = gf.Component(\"poly con\")\n\n    rect_pc = c_pc.add_ref(gf.components.rectangle(size=pc_size, layer=layer[\"poly2\"]))\n\n    poly_con = via_stack(\n        x_range=(rect_pc.xmin, rect_pc.xmax),\n        y_range=(rect_pc.ymin, rect_pc.ymax),\n        base_layer=layer[\"poly2\"],\n        metal_level=1,\n        li_enc_dir=\"H\",\n    )\n    c_pc.add_ref(poly_con)\n\n    if nf == 1:\n        poly = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(l_gate, w_gate + 2 * end_cap), layer=layer[\"poly2\"]\n            )\n        )\n        poly.xmin = sd_diff_intr.xmin + pl_cmp_spacing\n        poly.ymin = sd_diff_intr.ymin - end_cap\n\n        if gate_con_pos == \"bottom\":\n            mv = 0\n            nr = 1\n        elif gate_con_pos == \"top\":\n            mv = pc_size[1] + w_gate + 2 * end_cap\n            nr = 1\n        else:\n            mv = 0\n            nr = 2\n\n        pc = c_inst.add_array(\n            component=c_pc,\n            rows=nr,\n            columns=1,\n            spacing=(0, pc_size[1] + w_gate + 2 * end_cap),\n        )\n        pc.move((poly.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv))\n\n        # gate_lablel\n        c.add_ref(\n            labels_gen(\n                lbl_str=\"None\",\n                position=(pc.xmin + c_pc.size[0] / 2, pc.ymin + c_pc.size[1] / 2),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                lbl_lst=g_lbl,\n                lbl_valid_len=nf,\n                index=0,\n            )\n        )\n\n    else:\n        w_p1 = end_cap + w_gate + end_cap  # poly total width\n\n        if inter_sd_l < (poly2_spacing + 2 * pc_ext):\n            if gate_con_pos == \"alternating\":\n                w_p1 += 0.2\n                w_p2 = w_p1\n                e_c = 0.2\n            else:\n                w_p2 = w_p1 + con_pl_enc + con_size + con_pl_enc + poly2_spacing + 0.1\n                e_c = 0\n\n            if gate_con_pos == \"bottom\":\n                p_mv = -end_cap - (w_p2 - w_p1)\n            else:\n                p_mv = -end_cap\n\n        else:\n            w_p2 = w_p1\n            p_mv = -end_cap\n            e_c = 0\n\n        rect_p1 = gf.components.rectangle(size=(l_gate, w_p1), layer=layer[\"poly2\"])\n        rect_p2 = gf.components.rectangle(size=(l_gate, w_p2), layer=layer[\"poly2\"])\n        poly1 = c_inst.add_array(\n            rect_p1,\n            rows=1,\n            columns=ceil(nf / 2),\n            spacing=[2 * (inter_sd_l + l_gate), 0],\n        )\n        poly1.xmin = sd_diff_intr.xmin + pl_cmp_spacing\n        poly1.ymin = sd_diff_intr.ymin - end_cap - e_c\n\n        poly2 = c_inst.add_array(\n            rect_p2,\n            rows=1,\n            columns=floor(nf / 2),\n            spacing=[2 * (inter_sd_l + l_gate), 0],\n        )\n        poly2.xmin = poly1.xmin + l_gate + inter_sd_l\n        poly2.ymin = p_mv\n\n        # generating poly contacts setups\n\n        if gate_con_pos == \"bottom\":\n            mv_1 = 0\n            mv_2 = -(w_p2 - w_p1)\n        elif gate_con_pos == \"top\":\n            mv_1 = pc_size[1] + w_p1\n            mv_2 = pc_size[1] + w_p2\n        else:\n            mv_1 = -e_c\n            mv_2 = pc_size[1] + w_p2\n\n        nc1 = ceil(nf / 2)\n        nc2 = floor(nf / 2)\n\n        pc_spacing = 2 * (inter_sd_l + l_gate)\n\n        # generating poly contacts\n\n        pc1 = c_inst.add_array(\n            component=c_pc, rows=1, columns=nc1, spacing=(pc_spacing, 0)\n        )\n        pc1.move((poly1.xmin - ((pc_x - l_gate) / 2), -pc_size[1] - end_cap + mv_1))\n\n        pc2 = c_inst.add_array(\n            component=c_pc, rows=1, columns=nc2, spacing=(pc_spacing, 0)\n        )\n        pc2.move(\n            (\n                poly1.xmin - ((pc_x - l_gate) / 2) + (inter_sd_l + l_gate),\n                -pc_size[1] - end_cap + mv_2,\n            )\n        )\n\n        add_inter_sd_labels(\n            c,\n            nf,\n            sd_lbl,\n            poly1,\n            l_gate,\n            inter_sd_l,\n            sd_diff_intr,\n            lbl,\n            layer,\n            con_bet_fin,\n        )\n\n        add_gate_labels(c, g_lbl, pc1, c_pc, pc_spacing, nc1, nc2, pc2, lbl, layer, nf)\n\n        if interdig == 1:\n            c_inst.add_ref(\n                interdigit(\n                    sd_diff=sd_diff,\n                    pc1=pc1,\n                    pc2=pc2,\n                    poly_con=poly_con,\n                    sd_diff_intr=sd_diff_intr,\n                    l_gate=l_gate,\n                    inter_sd_l=inter_sd_l,\n                    sd_l=sd_l,\n                    nf=nf,\n                    patt=patt,\n                    gate_con_pos=gate_con_pos,\n                    pc_x=pc_x,\n                    pc_spacing=pc_spacing,\n                    lbl=lbl,\n                    g_lbl=g_lbl,\n                    patt_lbl=patt_lbl,\n                )\n            )\n\n    # generating bulk\n    if bulk == \"None\":\n        nplus = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_np_enc),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nplus.xmin = sd_diff.xmin - comp_np_enc\n        nplus.ymin = sd_diff_intr.ymin - gate_np_enc\n\n    elif bulk == \"Bulk Tie\":\n        rect_bulk = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_l + con_sp, sd_diff.size[1]), layer=layer[\"comp\"]\n            )\n        )\n        rect_bulk.xmin = sd_diff.xmax\n        rect_bulk.ymin = sd_diff.ymin\n        nsdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(\n                    sd_diff.xmax - sd_diff.xmin + comp_np_enc,\n                    sd_diff.size[1] + (2 * np_cmp_ency),\n                ),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nsdm.xmin = sd_diff.xmin - comp_np_enc\n        nsdm.ymin = sd_diff.ymin - np_cmp_ency\n        psdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(\n                    rect_bulk.xmax - rect_bulk.xmin + comp_pp_enc,\n                    w_gate + 2 * comp_pp_enc,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm.connect(\"e1\", destination=nsdm.ports[\"e3\"])\n\n        bulk_con = via_stack(\n            x_range=(sd_con_arr.xmax + m1_sp, rect_bulk.xmax),\n            y_range=(rect_bulk.ymin, rect_bulk.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n        c_inst.add_ref(bulk_con)\n\n        bulk_con_area = bulk_con.size[0] * bulk_con.size[1]\n\n        bulk_m1_check(bulk_con_area, m1_area, c_inst, bulk_con)\n\n        c.add_ref(\n            labels_gen(\n                lbl_str=sub_lbl,\n                position=(\n                    bulk_con.xmin + bulk_con.size[0] / 2,\n                    bulk_con.ymin + bulk_con.size[1] / 2,\n                ),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                lbl_lst=[sub_lbl],\n                lbl_valid_len=1,\n            )\n        )\n\n    elif bulk == \"Guard Ring\":\n        nsdm = c_inst.add_ref(\n            gf.components.rectangle(\n                size=(sd_diff.size[0] + 2 * comp_np_enc, w_gate + 2 * gate_np_enc),\n                layer=layer[\"nplus\"],\n            )\n        )\n        nsdm.xmin = sd_diff.xmin - comp_np_enc\n        nsdm.ymin = sd_diff_intr.ymin - gate_np_enc\n        c.add_ref(c_inst)\n\n        c_temp = gf.Component(\"temp_store\")\n        rect_bulk_in = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (c_inst.xmax - c_inst.xmin) + 2 * comp_spacing,\n                    (c_inst.ymax - c_inst.ymin) + 2 * poly2_comp_spacing,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_bulk_in.move(\n            (c_inst.xmin - comp_spacing, c_inst.ymin - poly2_comp_spacing)\n        )\n        rect_bulk_out = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n                    (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n                ),\n                layer=layer[\"comp\"],\n            )\n        )\n        rect_bulk_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n        c.add_ref(\n            gf.geometry.boolean(\n                A=rect_bulk_out,\n                B=rect_bulk_in,\n                operation=\"A-B\",\n                layer=layer[\"comp\"],\n            )\n        )\n\n        psdm_in = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_bulk_in.xmax - rect_bulk_in.xmin) - 2 * comp_pp_enc,\n                    (rect_bulk_in.ymax - rect_bulk_in.ymin) - 2 * comp_pp_enc,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_in.move((rect_bulk_in.xmin + comp_pp_enc, rect_bulk_in.ymin + comp_pp_enc))\n        psdm_out = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_bulk_out.xmax - rect_bulk_out.xmin) + 2 * comp_pp_enc,\n                    (rect_bulk_out.ymax - rect_bulk_out.ymin) + 2 * comp_pp_enc,\n                ),\n                layer=layer[\"pplus\"],\n            )\n        )\n        psdm_out.move(\n            (\n                rect_bulk_out.xmin - comp_pp_enc,\n                rect_bulk_out.ymin - comp_pp_enc,\n            )\n        )\n        psdm = c.add_ref(\n            gf.geometry.boolean(\n                A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n            )\n        )\n\n        # generating contacts\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_bulk_in.xmin + con_size,\n                    rect_bulk_in.xmax - con_size,\n                ),\n                y_range=(rect_bulk_out.ymin, rect_bulk_in.ymin),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # bottom contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(\n                    rect_bulk_in.xmin + con_size,\n                    rect_bulk_in.xmax - con_size,\n                ),\n                y_range=(rect_bulk_in.ymax, rect_bulk_out.ymax),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # upper contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(rect_bulk_out.xmin, rect_bulk_in.xmin),\n                y_range=(\n                    rect_bulk_in.ymin + con_size,\n                    rect_bulk_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # right contact\n\n        c.add_ref(\n            via_generator(\n                x_range=(rect_bulk_in.xmax, rect_bulk_out.xmax),\n                y_range=(\n                    rect_bulk_in.ymin + con_size,\n                    rect_bulk_in.ymax - con_size,\n                ),\n                via_enclosure=(con_comp_enc, con_comp_enc),\n                via_layer=layer[\"contact\"],\n                via_size=(con_size, con_size),\n                via_spacing=(con_sp, con_sp),\n            )\n        )  # left contact\n\n        comp_m1_in = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (l_d) + 2 * comp_spacing,\n                    (c_inst.ymax - c_inst.ymin) + 2 * poly2_comp_spacing,\n                ),\n                layer=layer[\"metal1\"],\n            )\n        )\n        comp_m1_in.move((-comp_spacing, c_inst.ymin - poly2_comp_spacing))\n        comp_m1_out = c_temp.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (rect_bulk_in.xmax - rect_bulk_in.xmin) + 2 * grw,\n                    (rect_bulk_in.ymax - rect_bulk_in.ymin) + 2 * grw,\n                ),\n                layer=layer[\"metal1\"],\n            )\n        )\n        comp_m1_out.move((rect_bulk_in.xmin - grw, rect_bulk_in.ymin - grw))\n        b_gr = c.add_ref(\n            gf.geometry.boolean(\n                A=rect_bulk_out,\n                B=rect_bulk_in,\n                operation=\"A-B\",\n                layer=layer[\"metal1\"],\n            )\n        )  # guardring metal1\n\n        c.add_ref(\n            labels_gen(\n                lbl_str=sub_lbl,\n                position=(\n                    b_gr.xmin + (grw + 2 * (comp_pp_enc)) / 2,\n                    b_gr.ymin + (b_gr.size[1] / 2),\n                ),\n                layer=layer[\"metal1_label\"],\n                lbl=lbl,\n                lbl_lst=[sub_lbl],\n                lbl_valid_len=1,\n            )\n        )\n\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    sd_diff.size[0] + (2 * nvt_enc_cmp),\n                    sd_diff.size[1] + (2 * nvt_enc_cmp),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = sd_diff.xmin - nvt_enc_cmp\n        dg.ymin = sd_diff.ymin - nvt_enc_cmp\n\n    if bulk != \"Guard Ring\":\n        c.add_ref(c_inst)\n\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    c_inst.size[0] + (2 * nvt_enc_cmp),\n                    c_inst.size[1] + (2 * nvt_enc_cmp),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = c_inst.xmin - nvt_enc_cmp\n        dg.ymin = c_inst.ymin - nvt_enc_cmp\n\n    # generating native layer\n    nat = c.add_ref(\n        gf.components.rectangle(size=(dg.size[0], dg.size[1]), layer=layer[\"nat\"])\n    )\n\n    nat.xmin = dg.xmin\n    nat.ymin = dg.ymin\n\n    # creating layout and cell in klayout\n\n    c.write_gds(\"nfet_nvt_temp.gds\")\n    layout.read(\"nfet_nvt_temp.gds\")\n    cell_name = \"sky_nfet_nvt_dev\"\n\n    return layout.cell(cell_name)", "\n\nif __name__ == \"__main__\":\n    pass\n"]}
{"filename": "gf180/cells/klayout/pymacros/cells/bjt.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n########################################################################################################################\n# BJT Generator for GF180MCU\n########################################################################################################################\n", "########################################################################################################################\n\nimport pya\n\nfrom .draw_bjt import draw_bjt\n\n\nclass npn_bjt(pya.PCellDeclarationHelper):\n    \"\"\"\n    NPN BJT Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Important: initialize the super class\n        super().__init__()\n        self.Type_handle = self.param(\n            \"Type\", self.TypeList, \"Type\", default=\"npn_10p00x10p00\"\n        )\n        self.Type_handle.add_choice(\"npn_10p00x10p00\", \"npn_10p00x10p00\")\n        self.Type_handle.add_choice(\"npn_05p00x05p00\", \"npn_05p00x05p00\")\n        self.Type_handle.add_choice(\"npn_00p54x16p00\", \"npn_00p54x16p00\")\n        self.Type_handle.add_choice(\"npn_00p54x08p00\", \"npn_00p54x08p00\")\n        self.Type_handle.add_choice(\"npn_00p54x04p00\", \"npn_00p54x04p00\")\n        self.Type_handle.add_choice(\"npn_00p54x02p00\", \"npn_00p54x02p00\")\n        self.param(\n            \"Model\",\n            self.TypeString,\n            \"Model\",\n            default=\"gf180mcu_fd_pr__npn\",\n            readonly=True,\n        )\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return str(self.Type)\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the\n        # numeric parameter has changed. We also update the numerical value\n        # or the shape, depending on which on has not changed.\n        pass\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        pass\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        pass\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        pass\n\n    def produce_impl(self):\n        # This is the main part of the implementation: create the layout\n\n        self.percision = 1 / self.layout.dbu\n        npn_instance = draw_bjt(layout=self.layout, device_name=self.Type)\n        write_cells = pya.CellInstArray(\n            npn_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n\n        self.cell.flatten(1)\n        self.cell.insert(write_cells)\n        self.layout.cleanup()", "\n\nclass pnp_bjt(pya.PCellDeclarationHelper):\n    \"\"\"\n    PNP BJT Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Important: initialize the super class\n        super().__init__()\n        self.Type_handle = self.param(\n            \"Type\", self.TypeList, \"Type\", default=\"pnp_10p00x10p00\"\n        )\n        self.Type_handle.add_choice(\"pnp_10p00x10p00\", \"pnp_10p00x10p00\")\n        self.Type_handle.add_choice(\"pnp_05p00x05p00\", \"pnp_05p00x05p00\")\n        self.Type_handle.add_choice(\"pnp_10p00x00p42\", \"pnp_10p00x00p42\")\n        self.Type_handle.add_choice(\"pnp_05p00x00p42\", \"pnp_05p00x00p42\")\n        self.param(\n            \"Model\",\n            self.TypeString,\n            \"Model\",\n            default=\"gf180mcu_fd_pr__pnp\",\n            readonly=True,\n        )\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return str(self.Type)\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the\n        # numeric parameter has changed. We also update the numerical value\n        # or the shape, depending on which on has not changed.\n        pass\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        pass\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        pass\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        pass\n\n    def produce_impl(self):\n        # This is the main part of the implementation: create the layout\n\n        self.percision = 1 / self.layout.dbu\n        pnp_instance = draw_bjt(layout=self.layout, device_name=self.Type)\n        write_cells = pya.CellInstArray(\n            pnp_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n\n        self.cell.flatten(1)\n        self.cell.insert(write_cells)\n        self.layout.cleanup()", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/layers_def.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n########################################################################################################################\n## layers definition for Klayout of GF180MCU\n########################################################################################################################\n", "########################################################################################################################\n\nlayer = {\n    \"comp\": (22, 0),\n    \"dnwell\": (12, 0),\n    \"nwell\": (21, 0),\n    \"lvpwell\": (204, 0),\n    \"dualgate\": (55, 0),\n    \"poly2\": (30, 0),\n    \"nplus\": (32, 0),", "    \"poly2\": (30, 0),\n    \"nplus\": (32, 0),\n    \"pplus\": (31, 0),\n    \"sab\": (49, 0),\n    \"esd\": (24, 0),\n    \"contact\": (33, 0),\n    \"metal1\": (34, 0),\n    \"via1\": (35, 0),\n    \"metal2\": (36, 0),\n    \"via2\": (38, 0),", "    \"metal2\": (36, 0),\n    \"via2\": (38, 0),\n    \"metal3\": (42, 0),\n    \"via3\": (40, 0),\n    \"metal4\": (46, 0),\n    \"via4\": (41, 0),\n    \"metal5\": (81, 0),\n    \"via5\": (82, 0),\n    \"metaltop\": (53, 0),\n    \"pad\": (37, 0),", "    \"metaltop\": (53, 0),\n    \"pad\": (37, 0),\n    \"resistor\": (62, 0),\n    \"fhres\": (227, 0),\n    \"fusetop\": (75, 0),\n    \"fusewindow_d\": (96, 1),\n    \"polyfuse\": (220, 0),\n    \"mvsd\": (210, 0),\n    \"mvpsd\": (11, 39),\n    \"nat\": (5, 0),", "    \"mvpsd\": (11, 39),\n    \"nat\": (5, 0),\n    \"comp_dummy\": (22, 4),\n    \"poly2_dummy\": (30, 4),\n    \"metal1_dummy\": (34, 4),\n    \"metal2_dummy\": (36, 4),\n    \"metal3_dummy\": (42, 4),\n    \"metal4_dummy\": (46, 4),\n    \"metal5_dummy\": (81, 4),\n    \"metaltop_dummy\": (53, 4),", "    \"metal5_dummy\": (81, 4),\n    \"metaltop_dummy\": (53, 4),\n    \"comp_label\": (22, 10),\n    \"poly2_label\": (30, 10),\n    \"metal1_label\": (34, 10),\n    \"metal2_label\": (36, 10),\n    \"metal3_label\": (42, 10),\n    \"metal4_label\": (46, 10),\n    \"metal5_label\": (81, 10),\n    \"metaltop_label\": (53, 10),", "    \"metal5_label\": (81, 10),\n    \"metaltop_label\": (53, 10),\n    \"metal1_slot\": (34, 3),\n    \"metal2_slot\": (36, 3),\n    \"metal3_slot\": (42, 3),\n    \"metal4_slot\": (46, 3),\n    \"metal5_slot\": (81, 3),\n    \"metaltop_slot\": (53, 3),\n    \"ubmpperi\": (183, 0),\n    \"ubmparray\": (184, 0),", "    \"ubmpperi\": (183, 0),\n    \"ubmparray\": (184, 0),\n    \"ubmeplate\": (185, 0),\n    \"schottky_diode\": (241, 0),\n    \"zener\": (178, 0),\n    \"res_mk\": (110, 5),\n    \"opc_drc\": (124, 5),\n    \"ndmy\": (111, 5),\n    \"pmndmy\": (152, 5),\n    \"v5_xtor\": (112, 1),", "    \"pmndmy\": (152, 5),\n    \"v5_xtor\": (112, 1),\n    \"cap_mk\": (117, 5),\n    \"mos_cap_mk\": (166, 5),\n    \"ind_mk\": (151, 5),\n    \"diode_mk\": (115, 5),\n    \"drc_bjt\": (127, 5),\n    \"lvs_bjt\": (118, 5),\n    \"mim_l_mk\": (117, 10),\n    \"latchup_mk\": (137, 5),", "    \"mim_l_mk\": (117, 10),\n    \"latchup_mk\": (137, 5),\n    \"guard_ring_mk\": (167, 5),\n    \"otp_mk\": (173, 5),\n    \"mtpmark\": (122, 5),\n    \"neo_ee_mk\": (88, 17),\n    \"sramcore\": (108, 5),\n    \"lvs_rf\": (100, 5),\n    \"lvs_drain\": (100, 7),\n    \"ind_mk1\": (151, 5),", "    \"lvs_drain\": (100, 7),\n    \"ind_mk1\": (151, 5),\n    \"hvpolyrs\": (123, 5),\n    \"lvs_io\": (119, 5),\n    \"probe_mk\": (13, 17),\n    \"esd_mk\": (24, 5),\n    \"lvs_source\": (100, 8),\n    \"well_diode_mk\": (153, 51),\n    \"ldmos_xtor\": (226, 0),\n    \"plfuse\": (125, 5),", "    \"ldmos_xtor\": (226, 0),\n    \"plfuse\": (125, 5),\n    \"efuse_mk\": (80, 5),\n    \"mcell_feol_mk\": (11, 17),\n    \"ymtp_mk\": (86, 17),\n    \"dev_wf_mk\": (128, 17),\n    \"metal1_blk\": (34, 5),\n    \"metal2_blk\": (36, 5),\n    \"metal3_blk\": (42, 5),\n    \"metal4_blk\": (46, 5),", "    \"metal3_blk\": (42, 5),\n    \"metal4_blk\": (46, 5),\n    \"metal5_blk\": (81, 5),\n    \"metalt_blk\": (53, 5),\n    \"pr_bndry\": (0, 0),\n    \"mdiode\": (116, 5),\n    \"metal1_res\": (110, 11),\n    \"metal2_res\": (110, 12),\n    \"metal3_res\": (110, 13),\n    \"metal4_res\": (110, 14),", "    \"metal3_res\": (110, 13),\n    \"metal4_res\": (110, 14),\n    \"metal5_res\": (110, 15),\n    \"metal6_res\": (110, 16),\n    \"border\": (63, 0),\n}\n\nprint(layer[\"comp\"])\n", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/draw_efuse.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\n\nUSER = os.environ[\"USER\"]\ngds_path = f\"/home/{USER}/.klayout/pymacros/cells/efuse\"", "USER = os.environ[\"USER\"]\ngds_path = f\"/home/{USER}/.klayout/pymacros/cells/efuse\"\n\n\ndef draw_efuse(layout, device_name):\n    layout.read(f\"{gds_path}/efuse.gds\")\n    cell_name = \"efuse_cell\"\n\n    return layout.cell(cell_name)\n", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/draw_cap_mos.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n########################################################################################################################\n## MOS capacitor Pcells Generators for Klayout of GF180MCU\n########################################################################################################################\n", "########################################################################################################################\n\nimport gdsfactory as gf\nimport numpy as np\nfrom gdsfactory.typings import Float2, LayerSpec\n\nfrom .layers_def import layer\nfrom .via_generator import via_generator, via_stack\n\n", "\n\n@gf.cell\ndef cap_mos_inst(\n    lc: float = 0.1,\n    wc: float = 0.1,\n    cmp_w: float = 0.1,\n    con_w: float = 0.1,\n    pl_l: float = 0.1,\n    cmp_ext: float = 0.1,\n    pl_ext: float = 0.1,\n    implant_layer: LayerSpec = layer[\"nplus\"],\n    implant_enc: Float2 = (0.1, 0.1),\n    lbl: bool = 0,\n    g_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"Returns mos cap simple instance\n\n    Args :\n        lc : length of mos_cap\n        ws : width of mos_cap\n        cmp_w : width of layer[\"comp\"]\n        con_w : min width of comp contain contact\n        pl_l : length od layer[\"poly2\"]\n        cmp_ext : comp extension beyond poly2\n        pl_ext : poly2 extension beyond comp\n        implant_layer : Layer of implant [nplus,pplus]\n        implant_enc : enclosure of implant_layer to comp\n    \"\"\"\n\n    c_inst = gf.Component()\n\n    cmp = c_inst.add_ref(gf.components.rectangle(size=(cmp_w, wc), layer=layer[\"comp\"]))\n\n    cap_mk = c_inst.add_ref(\n        gf.components.rectangle(\n            size=(cmp.size[0], cmp.size[1]), layer=layer[\"mos_cap_mk\"]\n        )\n    )\n    cap_mk.xmin = cmp.xmin\n    cap_mk.ymin = cmp.ymin\n\n    c_inst.add_array(\n        component=via_stack(\n            x_range=(cmp.xmin, cmp.xmin + con_w),\n            y_range=(cmp.ymin, cmp.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        ),\n        rows=1,\n        columns=2,\n        spacing=(cmp_w - con_w, 0),\n    )  # comp contact\n\n    imp_rect = c_inst.add_ref(\n        gf.components.rectangle(\n            size=(\n                cmp.size[0] + (2 * implant_enc[0]),\n                cmp.size[1] + (2 * implant_enc[1]),\n            ),\n            layer=implant_layer,\n        )\n    )\n    imp_rect.xmin = cmp.xmin - implant_enc[0]\n    imp_rect.ymin = cmp.ymin - implant_enc[1]\n\n    poly = c_inst.add_ref(\n        gf.components.rectangle(size=(lc, pl_l), layer=layer[\"poly2\"])\n    )\n\n    poly.xmin = cmp.xmin + cmp_ext\n    poly.ymin = cmp.ymin - pl_ext\n\n    pl_con_el = via_stack(\n        x_range=(poly.xmin, poly.xmax),\n        y_range=(poly.ymin, poly.ymin + con_w),\n        base_layer=layer[\"poly2\"],\n        metal_level=1,\n    )\n\n    pl_con = c_inst.add_array(\n        component=pl_con_el,\n        rows=2,\n        columns=1,\n        spacing=(0, pl_l - con_w),\n    )\n\n    # Gate labels_generation\n\n    if lbl == 1:\n        c_inst.add_label(\n            g_lbl,\n            position=(\n                pl_con.xmin + (pl_con.size[0] / 2),\n                pl_con.ymin + (pl_con_el.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    pl_m1 = c_inst.add_ref(\n        gf.components.rectangle(\n            size=(pl_con.size[0], pl_con.size[1]), layer=layer[\"metal1\"]\n        )\n    )\n    pl_m1.xmin = pl_con.xmin\n    pl_m1.ymin = pl_con.ymin\n\n    return c_inst", "\n\ndef draw_cap_mos(\n    layout,\n    type: str = \"cap_nmos\",\n    lc: float = 0.1,\n    wc: float = 0.1,\n    volt: str = \"3.3V\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    g_lbl: str = \"\",\n    sd_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw NMOS capacitor (Outside DNWELL) by specifying parameters\n    Arguments:-\n     layout : Object of layout\n     l      : Float of diff length\n     w      : Float of diff width\n    \"\"\"\n\n    c = gf.Component(\"cap_mos_dev\")\n\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n    con_pl_enc = 0.07\n    cmp_ext = 0.15 - con_comp_enc\n    pl_ext = 0.17 - con_pl_enc\n\n    np_enc_gate: float = 0.23\n    np_enc_cmp: float = 0.16\n\n    dg_enc_cmp = 0.24\n    dg_enc_poly = 0.4\n    lvpwell_enc_ncmp = 0.43\n    dn_enc_lvpwell = 2.5\n\n    grw = 0.36\n\n    m1_w = 1\n    pcmpgr_enc_dn = 2.5\n    m1_ext = 0.82\n    comp_pp_enc: float = 0.16\n    dnwell_enc_pcmp = 1.1\n\n    # end_cap: float = 0.22\n\n    cmp_ed_w = con_size + (2 * con_comp_enc)\n    cmp_w = (2 * (cmp_ed_w + cmp_ext)) + lc\n    end_cap = pl_ext + cmp_ed_w\n\n    pl_l = wc + (2 * end_cap)\n\n    if \"cap_nmos\" in type:\n        implant_layer = layer[\"nplus\"]\n    else:\n        implant_layer = layer[\"pplus\"]\n\n    c_inst = c.add_ref(\n        cap_mos_inst(\n            cmp_w=cmp_w,\n            lc=lc,\n            wc=wc,\n            pl_l=pl_l,\n            cmp_ext=cmp_ed_w + cmp_ext,\n            con_w=cmp_ed_w,\n            pl_ext=end_cap,\n            implant_layer=implant_layer,\n            implant_enc=(np_enc_cmp, np_enc_gate),\n            lbl=lbl,\n            g_lbl=g_lbl,\n        )\n    )\n\n    cmp_m1_polys = c_inst.get_polygons(by_spec=layer[\"metal1\"])\n    cmp_m1_xmin = np.min(cmp_m1_polys[0][:, 0])\n    cmp_m1_xmax = np.max(cmp_m1_polys[0][:, 0])\n    cmp_m1_ymax = np.max(cmp_m1_polys[0][:, 1])\n\n    # cmp_m1 = c.add_ref(gf.components.rectangle(size=(m1_w,w+m1_ext),layer=layer[\"metal1\"]))\n    cmp_m1_v = c.add_array(\n        component=gf.components.rectangle(\n            size=(m1_w, wc + m1_ext), layer=layer[\"metal1\"]\n        ),\n        rows=1,\n        columns=2,\n        spacing=(m1_w + cmp_w - 2 * cmp_ed_w, 0),\n    )\n    cmp_m1_v.xmin = cmp_m1_xmin - (m1_w - (cmp_m1_xmax - cmp_m1_xmin))\n    cmp_m1_v.ymax = cmp_m1_ymax\n\n    cmp_m1_h = c.add_ref(\n        gf.components.rectangle(size=(cmp_m1_v.size[0], m1_w), layer=layer[\"metal1\"])\n    )\n    cmp_m1_h.xmin = cmp_m1_v.xmin\n    cmp_m1_h.ymax = cmp_m1_v.ymin\n\n    # sd labels generation\n    if lbl == 1:\n        c.add_label(\n            sd_lbl,\n            position=(\n                cmp_m1_h.xmin + (cmp_m1_h.size[0] / 2),\n                cmp_m1_h.ymin + (cmp_m1_h.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    # dualgate\n\n    if volt == \"5/6V\":\n        dg = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    c_inst.size[0] + (2 * dg_enc_cmp),\n                    c_inst.size[1] + (2 * dg_enc_poly),\n                ),\n                layer=layer[\"dualgate\"],\n            )\n        )\n        dg.xmin = c_inst.xmin - dg_enc_cmp\n        dg.ymin = c_inst.ymin - dg_enc_poly\n\n    cmp_polys = c_inst.get_polygons(by_spec=layer[\"comp\"])\n    cmp_xmin = np.min(cmp_polys[0][:, 0])\n    cmp_ymin = np.min(cmp_polys[0][:, 1])\n    cmp_xmax = np.max(cmp_polys[0][:, 0])\n    cmp_ymax = np.max(cmp_polys[0][:, 1])\n\n    if \"_b\" in type:\n        if \"cap_nmos\" in type:\n            nwell = c.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        cmp_xmax - cmp_xmin + (2 * np_enc_cmp),\n                        cmp_ymax - cmp_ymin + (2 * np_enc_gate),\n                    ),\n                    layer=layer[\"nwell\"],\n                )\n            )\n            nwell.xmin = cmp_xmin - np_enc_cmp\n            nwell.ymin = cmp_ymin - np_enc_gate\n        else:\n            lvpwell = c.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        cmp_xmax - cmp_xmin + (2 * np_enc_cmp),\n                        cmp_ymax - cmp_ymin + (2 * np_enc_gate),\n                    ),\n                    layer=layer[\"lvpwell\"],\n                )\n            )\n\n            lvpwell.xmin = cmp_xmin - np_enc_cmp\n            lvpwell.ymin = cmp_ymin - np_enc_gate\n\n    if deepnwell == 1:\n        if type == \"cap_nmos\":\n            lvp_rect = c.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        c_inst.size[0] + (2 * lvpwell_enc_ncmp),\n                        c_inst.size[1] + (2 * lvpwell_enc_ncmp),\n                    ),\n                    layer=layer[\"lvpwell\"],\n                )\n            )\n\n            lvp_rect.xmin = c_inst.xmin - lvpwell_enc_ncmp\n            lvp_rect.ymin = c_inst.ymin - lvpwell_enc_ncmp\n\n            dn_rect = c.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        lvp_rect.size[0] + (2 * dn_enc_lvpwell),\n                        lvp_rect.size[1] + (2 * dn_enc_lvpwell),\n                    ),\n                    layer=layer[\"nwell\"],\n                )\n            )\n\n            dn_rect.xmin = lvp_rect.xmin - dn_enc_lvpwell\n            dn_rect.ymin = lvp_rect.ymin - dn_enc_lvpwell\n\n        else:\n            dn_rect = c.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        c_inst.size[0] + (2 * dnwell_enc_pcmp),\n                        c_inst.size[1] + (2 * dnwell_enc_pcmp),\n                    ),\n                    layer=layer[\"nwell\"],\n                )\n            )\n\n            dn_rect.xmin = c_inst.xmin - dnwell_enc_pcmp\n            dn_rect.ymin = c_inst.ymin - dnwell_enc_pcmp\n\n        if pcmpgr == 1:\n            c_temp_gr = gf.Component(\"temp_store guard ring\")\n            rect_pcmpgr_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                        (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_in.move(\n                (dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn)\n            )\n            rect_pcmpgr_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * grw,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * grw,\n                    ),\n                    layer=layer[\"comp\"],\n                )\n            )\n            rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"comp\"],\n                )\n            )  # guardring Bullk\n\n            psdm_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * comp_pp_enc,\n                        (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * comp_pp_enc,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_in.move(\n                (\n                    rect_pcmpgr_in.xmin + comp_pp_enc,\n                    rect_pcmpgr_in.ymin + comp_pp_enc,\n                )\n            )\n            psdm_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * comp_pp_enc,\n                        (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * comp_pp_enc,\n                    ),\n                    layer=layer[\"pplus\"],\n                )\n            )\n            psdm_out.move(\n                (\n                    rect_pcmpgr_out.xmin - comp_pp_enc,\n                    rect_pcmpgr_out.ymin - comp_pp_enc,\n                )\n            )\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n                )\n            )  # psdm\n\n            # generating contacts\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # bottom contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(\n                        rect_pcmpgr_in.xmin + con_size,\n                        rect_pcmpgr_in.xmax - con_size,\n                    ),\n                    y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # upper contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # right contact\n\n            c.add_ref(\n                via_generator(\n                    x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n                    y_range=(\n                        rect_pcmpgr_in.ymin + con_size,\n                        rect_pcmpgr_in.ymax - con_size,\n                    ),\n                    via_enclosure=(con_comp_enc, con_comp_enc),\n                    via_layer=layer[\"contact\"],\n                    via_size=(con_size, con_size),\n                    via_spacing=(con_sp, con_sp),\n                )\n            )  # left contact\n\n            comp_m1_in = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n                    layer=layer[\"metal1\"],\n                )\n            )\n\n            comp_m1_out = c_temp_gr.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        (comp_m1_in.size[0]) + 2 * grw,\n                        (comp_m1_in.size[1]) + 2 * grw,\n                    ),\n                    layer=layer[\"metal1\"],\n                )\n            )\n            comp_m1_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n            c.add_ref(\n                gf.geometry.boolean(\n                    A=rect_pcmpgr_out,\n                    B=rect_pcmpgr_in,\n                    operation=\"A-B\",\n                    layer=layer[\"metal1\"],\n                )\n            )  # guardring metal1\n\n    c.write_gds(\"cap_mos_temp.gds\")\n    layout.read(\"cap_mos_temp.gds\")\n    cell_name = \"cap_mos_dev\"\n\n    return layout.cell(cell_name)", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/__init__.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# ============================================================================\n# ---------------- Pcells Generators for Klayout of GF180MCU ----------------\n# ============================================================================\n", "# ============================================================================\n\nimport pya\n\nfrom .bjt import npn_bjt, pnp_bjt\nfrom .cap_mim import cap_mim\nfrom .cap_mos import cap_nmos, cap_nmos_b, cap_pmos, cap_pmos_b\nfrom .diode import (\n    diode_dw2ps,\n    diode_nd2ps,", "    diode_dw2ps,\n    diode_nd2ps,\n    diode_nw2ps,\n    diode_pd2nw,\n    diode_pw2dw,\n    sc_diode,\n)\nfrom .fet import nfet, nfet_06v0_nvt, pfet\nfrom .res import (\n    metal_resistor,", "from .res import (\n    metal_resistor,\n    nplus_s_resistor,\n    nplus_u_resistor,\n    npolyf_s_resistor,\n    npolyf_u_resistor,\n    nwell_resistor,\n    pplus_s_resistor,\n    pplus_u_resistor,\n    ppolyf_s_resistor,", "    pplus_u_resistor,\n    ppolyf_s_resistor,\n    ppolyf_u_high_Rs_resistor,\n    ppolyf_u_resistor,\n    pwell_resistor,\n)\n\n\n# It's a Python class that inherits from the pya.Library class\nclass gf180mcu(pya.Library):\n    \"\"\"\n    The library where we will put the PCell into\n    \"\"\"\n\n    def __init__(self):\n        # Set the description\n        self.description = \"GF180MCU Pcells\"\n\n        # Create the PCell declarations\n        # MOS DEVICES\n        self.layout().register_pcell(\n            \"nfet\", nfet()\n        )  # nfet_03v3 , nfet_05v0 , nfet_06v0\n        self.layout().register_pcell(\n            \"pfet\", pfet()\n        )  # pfet_03v3 , pfet_05v0 , pfet_06v0\n        self.layout().register_pcell(\"nfet_06v0_nvt\", nfet_06v0_nvt())\n        # self.layout().register_pcell(\"nfet_10v0_asym\", nfet_10v0_asym())\n        # self.layout().register_pcell(\"pfet_10v0_asym\", pfet_10v0_asym())\n\n        # BJT\n        self.layout().register_pcell(\n            \"npn_bjt\", npn_bjt()\n        )  # npn_10p00x10p00 , npn_05p00x05p00 , npn_00p54x16p00 ,\n        # npn_00p54x08p00 , npn_00p54x04p00 , npn_00p54x02p00\n        self.layout().register_pcell(\n            \"pnp_bjt\", pnp_bjt()\n        )  # pnp_10p00x10p00 , pnp_05p00x05p00 , pnp_10p00x00p42 , pnp_05p00x00p42\n\n        # DIODE DEVICES\n        self.layout().register_pcell(\n            \"diode_nd2ps\", diode_nd2ps()\n        )  # diode_nd2ps_03v3    , diode_nd2ps_06v0\n        self.layout().register_pcell(\n            \"diode_pd2nw\", diode_pd2nw()\n        )  # diode_pd2nw_03v3    , diode_pd2nw_06v0\n        self.layout().register_pcell(\n            \"diode_nw2ps\", diode_nw2ps()\n        )  # diode_nw2ps_03v3   , diode_nw2ps_06v0\n        self.layout().register_pcell(\n            \"diode_pw2dw\", diode_pw2dw()\n        )  # diode_pw2dw_03v3 , diode_pw2dw_06v0\n        self.layout().register_pcell(\n            \"diode_dw2ps\", diode_dw2ps()\n        )  # diode_dw2ps_03v3 , diode_dw2ps_06v0\n        self.layout().register_pcell(\"sc_diode\", sc_diode())\n\n        # MIM_CAP DEVICES\n        self.layout().register_pcell(\"cap_mim\", cap_mim())\n\n        # cap_mos\n        self.layout().register_pcell(\n            \"cap_nmos\", cap_nmos()\n        )  # cap_nmos_03v3   , cap_nmos_06v0\n        self.layout().register_pcell(\n            \"cap_pmos\", cap_pmos()\n        )  # cap_pmos_03v3   , cap_pmos_06v0\n        self.layout().register_pcell(\n            \"cap_nmos_b\", cap_nmos_b()\n        )  # cap_nmos_03v3_b , cap_nmos_06v0_b\n        self.layout().register_pcell(\n            \"cap_pmos_b\", cap_pmos_b()\n        )  # cap_pmos_03v3_b , cap_pmos_06v0_b\n\n        # RES\n        self.layout().register_pcell(\"metal_resistor\", metal_resistor())\n        self.layout().register_pcell(\"nplus_s_resistor\", nplus_s_resistor())\n        self.layout().register_pcell(\"pplus_s_resistor\", pplus_s_resistor())\n        self.layout().register_pcell(\"nplus_u_resistor\", nplus_u_resistor())\n        self.layout().register_pcell(\"pplus_u_resistor\", pplus_u_resistor())\n        self.layout().register_pcell(\"nwell_resistor\", nwell_resistor())\n        self.layout().register_pcell(\"pwell_resistor\", pwell_resistor())\n        self.layout().register_pcell(\"npolyf_s_resistor\", npolyf_s_resistor())\n        self.layout().register_pcell(\"ppolyf_s_resistor\", ppolyf_s_resistor())\n        self.layout().register_pcell(\"npolyf_u_resistor\", npolyf_u_resistor())\n        self.layout().register_pcell(\"ppolyf_u_resistor\", ppolyf_u_resistor())\n        self.layout().register_pcell(\n            \"ppolyf_u_high_Rs_resistor\", ppolyf_u_high_Rs_resistor()\n        )\n\n        # Register us with the name \"gf180mcu\".\n        self.register(\"gf180mcu\")", "# It's a Python class that inherits from the pya.Library class\nclass gf180mcu(pya.Library):\n    \"\"\"\n    The library where we will put the PCell into\n    \"\"\"\n\n    def __init__(self):\n        # Set the description\n        self.description = \"GF180MCU Pcells\"\n\n        # Create the PCell declarations\n        # MOS DEVICES\n        self.layout().register_pcell(\n            \"nfet\", nfet()\n        )  # nfet_03v3 , nfet_05v0 , nfet_06v0\n        self.layout().register_pcell(\n            \"pfet\", pfet()\n        )  # pfet_03v3 , pfet_05v0 , pfet_06v0\n        self.layout().register_pcell(\"nfet_06v0_nvt\", nfet_06v0_nvt())\n        # self.layout().register_pcell(\"nfet_10v0_asym\", nfet_10v0_asym())\n        # self.layout().register_pcell(\"pfet_10v0_asym\", pfet_10v0_asym())\n\n        # BJT\n        self.layout().register_pcell(\n            \"npn_bjt\", npn_bjt()\n        )  # npn_10p00x10p00 , npn_05p00x05p00 , npn_00p54x16p00 ,\n        # npn_00p54x08p00 , npn_00p54x04p00 , npn_00p54x02p00\n        self.layout().register_pcell(\n            \"pnp_bjt\", pnp_bjt()\n        )  # pnp_10p00x10p00 , pnp_05p00x05p00 , pnp_10p00x00p42 , pnp_05p00x00p42\n\n        # DIODE DEVICES\n        self.layout().register_pcell(\n            \"diode_nd2ps\", diode_nd2ps()\n        )  # diode_nd2ps_03v3    , diode_nd2ps_06v0\n        self.layout().register_pcell(\n            \"diode_pd2nw\", diode_pd2nw()\n        )  # diode_pd2nw_03v3    , diode_pd2nw_06v0\n        self.layout().register_pcell(\n            \"diode_nw2ps\", diode_nw2ps()\n        )  # diode_nw2ps_03v3   , diode_nw2ps_06v0\n        self.layout().register_pcell(\n            \"diode_pw2dw\", diode_pw2dw()\n        )  # diode_pw2dw_03v3 , diode_pw2dw_06v0\n        self.layout().register_pcell(\n            \"diode_dw2ps\", diode_dw2ps()\n        )  # diode_dw2ps_03v3 , diode_dw2ps_06v0\n        self.layout().register_pcell(\"sc_diode\", sc_diode())\n\n        # MIM_CAP DEVICES\n        self.layout().register_pcell(\"cap_mim\", cap_mim())\n\n        # cap_mos\n        self.layout().register_pcell(\n            \"cap_nmos\", cap_nmos()\n        )  # cap_nmos_03v3   , cap_nmos_06v0\n        self.layout().register_pcell(\n            \"cap_pmos\", cap_pmos()\n        )  # cap_pmos_03v3   , cap_pmos_06v0\n        self.layout().register_pcell(\n            \"cap_nmos_b\", cap_nmos_b()\n        )  # cap_nmos_03v3_b , cap_nmos_06v0_b\n        self.layout().register_pcell(\n            \"cap_pmos_b\", cap_pmos_b()\n        )  # cap_pmos_03v3_b , cap_pmos_06v0_b\n\n        # RES\n        self.layout().register_pcell(\"metal_resistor\", metal_resistor())\n        self.layout().register_pcell(\"nplus_s_resistor\", nplus_s_resistor())\n        self.layout().register_pcell(\"pplus_s_resistor\", pplus_s_resistor())\n        self.layout().register_pcell(\"nplus_u_resistor\", nplus_u_resistor())\n        self.layout().register_pcell(\"pplus_u_resistor\", pplus_u_resistor())\n        self.layout().register_pcell(\"nwell_resistor\", nwell_resistor())\n        self.layout().register_pcell(\"pwell_resistor\", pwell_resistor())\n        self.layout().register_pcell(\"npolyf_s_resistor\", npolyf_s_resistor())\n        self.layout().register_pcell(\"ppolyf_s_resistor\", ppolyf_s_resistor())\n        self.layout().register_pcell(\"npolyf_u_resistor\", npolyf_u_resistor())\n        self.layout().register_pcell(\"ppolyf_u_resistor\", ppolyf_u_resistor())\n        self.layout().register_pcell(\n            \"ppolyf_u_high_Rs_resistor\", ppolyf_u_high_Rs_resistor()\n        )\n\n        # Register us with the name \"gf180mcu\".\n        self.register(\"gf180mcu\")", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/via_generator.py", "chunked_list": ["# Copyright 2022 Skywater 130nm pdk development\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published\n# by the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", "# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n########################################################################################################################\n# via Generator for skywater130\n########################################################################################################################", "# via Generator for skywater130\n########################################################################################################################\n\n\nfrom math import ceil, floor\n\nimport gdsfactory as gf\nfrom gdsfactory.typings import Float2, LayerSpec\n\nfrom .layers_def import layer", "\nfrom .layers_def import layer\n\n\n@gf.cell\ndef via_generator(\n    x_range: Float2 = (0, 1),\n    y_range: Float2 = (0, 1),\n    via_size: Float2 = (0.17, 0.17),\n    via_layer: LayerSpec = (66, 44),\n    via_enclosure: Float2 = (0.06, 0.06),\n    via_spacing: Float2 = (0.17, 0.17),\n) -> gf.Component:\n    \"\"\"\n    return only vias withen the range xrange and yrange while enclosing by via_enclosure\n    and set number of rows and number of coloumns according to ranges and via size and spacing\n\n    \"\"\"\n\n    c = gf.Component()\n\n    width = x_range[1] - x_range[0]\n    length = y_range[1] - y_range[0]\n    nr = floor(length / (via_size[1] + via_spacing[1]))\n    if (length - nr * via_size[1] - (nr - 1) * via_spacing[1]) / 2 < via_enclosure[1]:\n        nr -= 1\n\n    nr = max(nr, 1)\n    nc = ceil(width / (via_size[0] + via_spacing[0]))\n\n    if (\n        round(width - nc * via_size[0] - (nc - 1) * via_spacing[0], 2)\n    ) / 2 < via_enclosure[0]:\n        nc -= 1\n\n    nc = max(nc, 1)\n    via_sp = (via_size[0] + via_spacing[0], via_size[1] + via_spacing[1])\n\n    rect_via = gf.components.rectangle(size=via_size, layer=via_layer)\n\n    via_arr = c.add_array(rect_via, rows=nr, columns=nc, spacing=via_sp)\n\n    via_arr.move((x_range[0], y_range[0]))\n\n    via_arr.movex((width - nc * via_size[0] - (nc - 1) * via_spacing[0]) / 2)\n    via_arr.movey((length - nr * via_size[1] - (nr - 1) * via_spacing[1]) / 2)\n\n    return c", "\n\n@gf.cell\ndef via_stack(\n    x_range: Float2 = (0, 1),\n    y_range: Float2 = (0, 1),\n    base_layer: LayerSpec = layer[\"comp\"],\n    slotted_licon: int = 0,\n    metal_level: int = 1,\n    li_enc_dir=\"V\",\n) -> gf.Component:\n    \"\"\"\n    return via stack till the metal level indicated where :\n    metal_level 1 : till m1\n    metal_level 2 : till m2\n    metal_level 3 : till m3\n    metal_level 4 : till m4\n    metal_level 5 : till m5\n    withen the range xrange and yrange and expecting the base_layer to be drawen\n\n    \"\"\"\n\n    c = gf.Component()\n\n    # vias dimensions\n\n    con_size = (0.22, 0.22)\n    m_enc = 0.06\n\n    con_spacing = (0.28, 0.28)\n\n    via_size = (0.22, 0.22)\n    via_spacing = (0.28, 0.28)\n    via_enc = (0.06, 0.06)\n\n    if metal_level >= 1:\n        con_enc = 0.07\n        con_gen = via_generator(\n            x_range=x_range,\n            y_range=y_range,\n            via_size=con_size,\n            via_enclosure=(con_enc, con_enc),\n            via_layer=layer[\"contact\"],\n            via_spacing=con_spacing,\n        )\n        con = c.add_ref(con_gen)\n\n        m1_x = con.size[0] + 2 * m_enc\n\n        m1_y = con.size[1] + 2 * m_enc\n\n        m1 = c.add_ref(\n            gf.components.rectangle(size=(m1_x, m1_y), layer=layer[\"metal1\"])\n        )\n        m1.xmin = con.xmin - m_enc\n        m1.ymin = con.ymin - m_enc\n\n    if metal_level >= 2:\n        via1_gen = via_generator(\n            x_range=(m1.xmin, m1.xmax),\n            y_range=(m1.ymin, m1.ymax),\n            via_size=via_size,\n            via_enclosure=via_enc,\n            via_layer=layer[\"via1\"],\n            via_spacing=via_spacing,\n        )\n        via1 = c.add_ref(via1_gen)\n\n        if (via1.xmax - via1.xmin + 2 * m_enc[0]) < (\n            via_size[0] + 2 * via_enc[0]\n        ) and metal_level >= 3:\n            m2_x = via_size[0] + 2 * via_enc[0]\n\n        else:\n            m2_x = via1.xmax - via1.xmin + 2 * m_enc[0]\n\n        if (via1.ymax - via1.ymin + 2 * m_enc[1]) < (\n            via_size[1] + 2 * via_enc[1]\n        ) and metal_level >= 3:\n            m2_y = via_size[1] + 2 * via_enc[1]\n\n        else:\n            m2_y = via1.ymax - via1.ymin + 2 * m_enc[1]\n\n        m2_mx = (m2_x - (via1.xmax - via1.xmin)) / 2\n        m2_my = (m2_y - (via1.ymax - via1.ymin)) / 2\n\n        m2 = c.add_ref(\n            gf.components.rectangle(size=(m2_x, m2_y), layer=layer[\"metal2\"])\n        )\n        m2.move((via1.xmin - m2_mx, via1.ymin - m2_my))\n\n    return c", "\n\n# testing the generated methods\nif __name__ == \"__main__\":\n    c = via_stack()\n    c.show()\n    # c = vias_gen_draw(start_layer=\"li\",end_layer=\"poly\")\n    # c.show()\n", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/fet.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n########################################################################################################################\n# FET Generator for GF180MCU\n########################################################################################################################\nimport pya", "########################################################################################################################\nimport pya\n\nfrom .draw_fet import draw_nfet, draw_nfet_06v0_nvt, draw_pfet\n\nfet_3p3_l = 0.28\nfet_3p3_w = 0.22\nfet_3p3_w_con = 0.36\nfet_3p3_w_con_bulk = 0.42\nfet_5_6_w = 0.3", "fet_3p3_w_con_bulk = 0.42\nfet_5_6_w = 0.3\n\nnfet_05v0_l = 0.6\nnfet_06v0_l = 0.7\n\npfet_05v0_l = 0.5\npfet_06v0_l = 0.55\n\nnfet_nat_l = 1.8", "\nnfet_nat_l = 1.8\nnfet_nat_w = 0.8\nfet_grw = 0.36\nfet_ld = 0.52\n\nldfet_l_min = 0.6\nldfet_l_max = 20\nldfet_w_min = 4\nldfet_w_max = 50", "ldfet_w_min = 4\nldfet_w_max = 50\n\n\nclass nfet(pya.PCellDeclarationHelper):\n    \"\"\"\n    NFET Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initialize super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Deep NWELL Guard Ring\", default=0)\n        self.Type_handle = self.param(\"volt\", self.TypeList, \"Operating Voltage\")\n        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n        self.Type_handle.add_choice(\"5V\", \"5V\")\n        self.Type_handle.add_choice(\"6V\", \"6V\")\n        self.Type_handle = self.param(\"bulk\", self.TypeList, \"Bulk Type\")\n        self.Type_handle.add_choice(\"None\", \"None\")\n        self.Type_handle.add_choice(\"Bulk Tie\", \"Bulk Tie\")\n        self.Type_handle.add_choice(\"Guard Ring\", \"Guard Ring\")\n\n        self.param(\"w_gate\", self.TypeDouble, \"Width\", default=fet_3p3_w, unit=\"um\")\n        self.param(\"l_gate\", self.TypeDouble, \"Length\", default=fet_3p3_l, unit=\"um\")\n        self.param(\"ld\", self.TypeDouble, \"Diffusion Length\", default=fet_ld, unit=\"um\")\n        self.param(\"nf\", self.TypeInt, \"Number of Fingers\", default=1)\n        self.param(\n            \"grw\", self.TypeDouble, \"Guard Ring Width\", default=fet_grw, unit=\"um\"\n        )\n\n        self.Type_handle = self.param(\n            \"gate_con_pos\", self.TypeList, \"Gate Contact Position\"\n        )\n        self.Type_handle.add_choice(\"top\", \"top\")\n        self.Type_handle.add_choice(\"bottom\", \"bottom\")\n        self.Type_handle.add_choice(\"alternating\", \"alternating\")\n\n        self.param(\n            \"con_bet_fin\", self.TypeBoolean, \"Contact Between Fingers\", default=1\n        )\n        self.param(\"sd_con_col\", self.TypeInt, \"Diffusion Contacts Columns\", default=1)\n\n        self.param(\"interdig\", self.TypeBoolean, \"Interdigitation\", default=0)\n        self.param(\n            \"patt\", self.TypeString, \"Pattern in case of Interdigitation\", default=\"\"\n        )\n        self.param(\n            \"patt_lbl\", self.TypeBoolean, \"Interdigitation pattern label\", default=0\n        )\n\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\n            \"sd_lbl\", self.TypeList, \"Pattern of Source/Drain Labels\", default=[]\n        )\n\n        self.param(\"g_lbl\", self.TypeList, \"Pattern of Gate Labels\", default=[])\n\n        self.param(\"sub_lbl\", self.TypeString, \"Substrate Label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return \"nfet(L=\" + (\"%.3f\" % self.l_gate) + \",W=\" + (\"%.3f\" % self.w_gate) + \")\"\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the\n        # numeric parameter has changed (by comparing against the effective\n        # radius ru) and set ru to the effective radius. We also update the\n        # numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_gate * self.l_gate\n        self.perim = 2 * (self.w_gate + self.l_gate)\n        # w,l must be larger or equal than min. values.\n        if self.volt == \"3.3V\":\n            self.l_gate = max(self.l_gate, fet_3p3_l)\n            self.w_gate = max(self.w_gate, fet_3p3_w)\n            if self.con_bet_fin == 1 and (self.w_gate) < fet_3p3_w_con:\n                self.w_gate = fet_3p3_w_con\n        elif self.volt == \"5V\":\n            self.l_gate = max(self.l_gate, nfet_05v0_l)\n            self.w_gate = max(self.w_gate, fet_5_6_w)\n        elif self.volt == \"6V\":\n            self.l_gate = max(self.l_gate, nfet_06v0_l)\n            self.w_gate = max(self.w_gate, fet_5_6_w)\n        self.ld = max(self.ld, fet_ld)\n        self.grw = max(self.grw, fet_grw)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.l_gateayout.dbu / 2\n        self.l_gate = self.l_gateayout.get_info(self.l_gateayer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        instance = draw_nfet(\n            layout=self.layout,\n            l_gate=self.l_gate,\n            w_gate=self.w_gate,\n            sd_con_col=self.sd_con_col,\n            inter_sd_l=self.ld,\n            nf=self.nf,\n            grw=self.grw,\n            bulk=self.bulk,\n            volt=self.volt,\n            con_bet_fin=self.con_bet_fin,\n            gate_con_pos=self.gate_con_pos,\n            interdig=self.interdig,\n            patt=self.patt,\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            sd_lbl=self.sd_lbl,\n            g_lbl=self.g_lbl,\n            sub_lbl=self.sub_lbl,\n            patt_lbl=self.patt_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass pfet(pya.PCellDeclarationHelper):\n    \"\"\"\n    PFET Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initialize super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Deep NWELL Guard Ring\", default=0)\n        self.Type_handle = self.param(\"volt\", self.TypeList, \"Operating Voltage\")\n        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n        self.Type_handle.add_choice(\"5V\", \"5V\")\n        self.Type_handle.add_choice(\"6V\", \"6V\")\n        self.Type_handle = self.param(\"bulk\", self.TypeList, \"Bulk Type\")\n        self.Type_handle.add_choice(\"None\", \"None\")\n        self.Type_handle.add_choice(\"Bulk Tie\", \"Bulk Tie\")\n        self.Type_handle.add_choice(\"Guard Ring\", \"Guard Ring\")\n\n        self.param(\"w_gate\", self.TypeDouble, \"Width\", default=fet_3p3_w, unit=\"um\")\n        self.param(\"l_gate\", self.TypeDouble, \"Length\", default=fet_3p3_l, unit=\"um\")\n        self.param(\"ld\", self.TypeDouble, \"Diffusion Length\", default=fet_ld, unit=\"um\")\n        self.param(\"nf\", self.TypeInt, \"Number of Fingers\", default=1)\n        self.param(\n            \"grw\", self.TypeDouble, \"Guard Ring Width\", default=fet_grw, unit=\"um\"\n        )\n\n        self.Type_handle = self.param(\n            \"gate_con_pos\", self.TypeList, \"Gate Contact Position\"\n        )\n        self.Type_handle.add_choice(\"top\", \"top\")\n        self.Type_handle.add_choice(\"bottom\", \"bottom\")\n        self.Type_handle.add_choice(\"alternating\", \"alternating\")\n\n        self.param(\n            \"con_bet_fin\", self.TypeBoolean, \"Contact Between Fingers\", default=1\n        )\n        self.param(\"sd_con_col\", self.TypeInt, \"Diffusion Contacts Columns\", default=1)\n\n        self.param(\"interdig\", self.TypeBoolean, \"Interdigitation\", default=0)\n        self.param(\n            \"patt\", self.TypeString, \"Pattern in case of Interdigitation\", default=\"\"\n        )\n        self.param(\n            \"patt_lbl\", self.TypeBoolean, \"Interdigitation pattern label\", default=0\n        )\n\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\n            \"sd_lbl\", self.TypeList, \"Pattern of Source/Drain Labels\", default=[]\n        )\n\n        self.param(\"g_lbl\", self.TypeList, \"Pattern of Gate Labels\", default=[])\n\n        self.param(\"sub_lbl\", self.TypeString, \"Substrate Label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return \"pfet(L=\" + (\"%.3f\" % self.l_gate) + \",W=\" + (\"%.3f\" % self.w_gate) + \")\"\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the\n        # numeric parameter has changed (by comparing against the effective\n        # radius ru) and set ru to the effective radius. We also update the\n        # numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_gate * self.l_gate\n        self.perim = 2 * (self.w_gate + self.l_gate)\n        # w,l must be larger or equal than min. values.\n        if self.volt == \"3.3V\":\n            self.l_gate = max(self.l_gate, fet_3p3_l)\n            self.w_gate = max(self.w_gate, fet_3p3_w)\n            if self.con_bet_fin == 1 and (self.w_gate) < fet_3p3_w_con:\n                self.w_gate = fet_3p3_w_con\n        elif self.volt == \"5V\":\n            self.l_gate = max(self.l_gate, pfet_05v0_l)\n            self.w_gate = max(self.w_gate, fet_5_6_w)\n        elif self.volt == \"6V\":\n            self.l_gate = max(self.l_gate, pfet_06v0_l)\n            self.w_gate = max(self.w_gate, fet_5_6_w)\n        self.ld = max(self.ld, fet_ld)\n        self.grw = max(self.grw, fet_grw)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.l_gateayout.dbu / 2\n        self.l_gate = self.l_gateayout.get_info(self.l_gateayer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        instance = draw_pfet(\n            self.layout,\n            l_gate=self.l_gate,\n            w_gate=self.w_gate,\n            sd_con_col=self.sd_con_col,\n            inter_sd_l=self.ld,\n            nf=self.nf,\n            grw=self.grw,\n            bulk=self.bulk,\n            volt=self.volt,\n            con_bet_fin=self.con_bet_fin,\n            gate_con_pos=self.gate_con_pos,\n            interdig=self.interdig,\n            patt=self.patt,\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            sd_lbl=self.sd_lbl,\n            g_lbl=self.g_lbl,\n            sub_lbl=self.sub_lbl,\n            patt_lbl=self.patt_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass nfet_06v0_nvt(pya.PCellDeclarationHelper):\n    \"\"\"\n    6V Native NFET Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initialize super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.Type_handle = self.param(\"bulk\", self.TypeList, \"Bulk Type\")\n        self.Type_handle.add_choice(\"None\", \"None\")\n        self.Type_handle.add_choice(\"Bulk Tie\", \"Bulk Tie\")\n        self.Type_handle.add_choice(\"Guard Ring\", \"Guard Ring\")\n\n        self.param(\"w_gate\", self.TypeDouble, \"Width\", default=nfet_nat_w, unit=\"um\")\n        self.param(\"l_gate\", self.TypeDouble, \"Length\", default=nfet_nat_l, unit=\"um\")\n        self.param(\"ld\", self.TypeDouble, \"Diffusion Length\", default=fet_ld, unit=\"um\")\n        self.param(\"nf\", self.TypeInt, \"Number of Fingers\", default=1)\n        self.param(\n            \"grw\", self.TypeDouble, \"Guard Ring Width\", default=fet_grw, unit=\"um\"\n        )\n\n        self.Type_handle = self.param(\n            \"gate_con_pos\", self.TypeList, \"Gate Contact Position\"\n        )\n        self.Type_handle.add_choice(\"top\", \"top\")\n        self.Type_handle.add_choice(\"bottom\", \"bottom\")\n        self.Type_handle.add_choice(\"alternating\", \"alternating\")\n\n        self.param(\n            \"con_bet_fin\", self.TypeBoolean, \"Contact Between Fingers\", default=1\n        )\n        self.param(\"sd_con_col\", self.TypeInt, \"Diffusion Contacts Columns\", default=1)\n\n        self.param(\"interdig\", self.TypeBoolean, \"Interdigitation\", default=0)\n        self.param(\n            \"patt\", self.TypeString, \"Pattern in case of Interdigitation\", default=\"\"\n        )\n        self.param(\n            \"patt_lbl\", self.TypeBoolean, \"Interdigitation pattern label\", default=0\n        )\n\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\n            \"sd_lbl\", self.TypeList, \"Pattern of Source/Drain Labels\", default=[]\n        )\n\n        self.param(\"g_lbl\", self.TypeList, \"Pattern of Gate Labels\", default=[])\n\n        self.param(\"sub_lbl\", self.TypeString, \"Substrate Label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return (\n            \"nfet_06v0_nvt(L=\"\n            + (\"%.3f\" % self.l_gate)\n            + \",W=\"\n            + (\"%.3f\" % self.w_gate)\n            + \")\"\n        )\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the\n        # numeric parameter has changed (by comparing against the effective\n        # radius ru) and set ru to the effective radius. We also update the\n        # numerical value or the shape, depending on which on has not changed.\n        self.area = self.w_gate * self.l_gate\n        self.perim = 2 * (self.w_gate + self.l_gate)\n        # w,l must be larger or equal than min. values.\n        self.l_gate = max(self.l_gate, nfet_nat_l)\n        self.w_gate = max(self.w_gate, nfet_nat_w)\n        self.grw = max(self.grw, fet_grw)\n        self.ld = max(self.ld, fet_ld)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.l_gateayout.dbu / 2\n        self.l_gate = self.l_gateayout.get_info(self.l_gateayer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        instance = draw_nfet_06v0_nvt(\n            self.layout,\n            l_gate=self.l_gate,\n            w_gate=self.w_gate,\n            sd_con_col=self.sd_con_col,\n            inter_sd_l=self.ld,\n            nf=self.nf,\n            grw=self.grw,\n            bulk=self.bulk,\n            con_bet_fin=self.con_bet_fin,\n            gate_con_pos=self.gate_con_pos,\n            interdig=self.interdig,\n            patt=self.patt,\n            lbl=self.lbl,\n            sd_lbl=self.sd_lbl,\n            g_lbl=self.g_lbl,\n            sub_lbl=self.sub_lbl,\n            patt_lbl=self.patt_lbl,\n        )\n\n        write_cells = pya.CellInstArray(\n            instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/draw_bjt.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n########################################################################################################################\n## BJT Pcells Generators for Klayout of GF180MCU\n########################################################################################################################\n", "########################################################################################################################\n\nimport os\n\ngds_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"bjt\")\n\n\ndef draw_bjt(layout, device_name):\n    gds_file = f\"{gds_path}/{device_name}.gds\"\n\n    if os.path.exists(gds_file) and os.path.isfile(gds_file):\n        layout.read(gds_file)\n    else:\n        print(f\"{gds_file} is not exist, please recheck\")\n\n    return layout.cell(device_name)", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/draw_res.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n########################################################################################################################\n## Resistor Pcells Generators for Klayout of GF180MCU\n########################################################################################################################\n", "########################################################################################################################\n\nimport gdsfactory as gf\nfrom gdsfactory.typings import Float2, LayerSpec\n\nfrom .layers_def import layer\nfrom .via_generator import via_generator, via_stack\n\n\ndef draw_metal_res(\n    layout,\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"rm1\",\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw 2-terminal Metal resistor by specifying parameters\n    Arguments:-\n     layout : Object of layout\n     l      : Float of diff length\n     w      : Float of diff width\n    \"\"\"\n\n    c = gf.Component(\"res_dev\")\n\n    m_ext = 0.28\n\n    if res_type == \"rm1\":\n        m_layer = layer[\"metal1\"]\n        res_layer = layer[\"metal1_res\"]\n        m_lbl_layer = layer[\"metal1_label\"]\n    elif res_type == \"rm2\":\n        m_layer = layer[\"metal2\"]\n        res_layer = layer[\"metal2_res\"]\n        m_lbl_layer = layer[\"metal2_label\"]\n    elif res_type == \"rm3\":\n        m_layer = layer[\"metal3\"]\n        res_layer = layer[\"metal3_res\"]\n        m_lbl_layer = layer[\"metal3_label\"]\n    else:\n        m_layer = layer[\"metaltop\"]\n        res_layer = layer[\"metal6_res\"]\n        m_lbl_layer = layer[\"metaltop_label\"]\n\n    res_mk = c.add_ref(gf.components.rectangle(size=(l_res, w_res), layer=res_layer))\n\n    m_rect = c.add_ref(\n        gf.components.rectangle(size=(l_res + (2 * m_ext), w_res), layer=m_layer)\n    )\n    m_rect.xmin = res_mk.xmin - m_ext\n    m_rect.ymin = res_mk.ymin\n\n    # labels generation\n    if lbl == 1:\n        c.add_label(\n            r0_lbl,\n            position=(\n                res_mk.xmin + (res_mk.size[0] / 2),\n                res_mk.ymin + (res_mk.size[1] / 2),\n            ),\n            layer=m_lbl_layer,\n        )\n        c.add_label(\n            r1_lbl,\n            position=(\n                m_rect.xmin + (res_mk.xmin - m_rect.xmin) / 2,\n                m_rect.ymin + (m_rect.size[1] / 2),\n            ),\n            layer=m_lbl_layer,\n        )\n\n    # creating layout and cell in klayout\n    c.write_gds(\"res_temp.gds\")\n    layout.read(\"res_temp.gds\")\n    cell_name = \"res_dev\"\n\n    return layout.cell(cell_name)", "\ndef draw_metal_res(\n    layout,\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"rm1\",\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n) -> gf.Component:\n    \"\"\"\n    Usage:-\n     used to draw 2-terminal Metal resistor by specifying parameters\n    Arguments:-\n     layout : Object of layout\n     l      : Float of diff length\n     w      : Float of diff width\n    \"\"\"\n\n    c = gf.Component(\"res_dev\")\n\n    m_ext = 0.28\n\n    if res_type == \"rm1\":\n        m_layer = layer[\"metal1\"]\n        res_layer = layer[\"metal1_res\"]\n        m_lbl_layer = layer[\"metal1_label\"]\n    elif res_type == \"rm2\":\n        m_layer = layer[\"metal2\"]\n        res_layer = layer[\"metal2_res\"]\n        m_lbl_layer = layer[\"metal2_label\"]\n    elif res_type == \"rm3\":\n        m_layer = layer[\"metal3\"]\n        res_layer = layer[\"metal3_res\"]\n        m_lbl_layer = layer[\"metal3_label\"]\n    else:\n        m_layer = layer[\"metaltop\"]\n        res_layer = layer[\"metal6_res\"]\n        m_lbl_layer = layer[\"metaltop_label\"]\n\n    res_mk = c.add_ref(gf.components.rectangle(size=(l_res, w_res), layer=res_layer))\n\n    m_rect = c.add_ref(\n        gf.components.rectangle(size=(l_res + (2 * m_ext), w_res), layer=m_layer)\n    )\n    m_rect.xmin = res_mk.xmin - m_ext\n    m_rect.ymin = res_mk.ymin\n\n    # labels generation\n    if lbl == 1:\n        c.add_label(\n            r0_lbl,\n            position=(\n                res_mk.xmin + (res_mk.size[0] / 2),\n                res_mk.ymin + (res_mk.size[1] / 2),\n            ),\n            layer=m_lbl_layer,\n        )\n        c.add_label(\n            r1_lbl,\n            position=(\n                m_rect.xmin + (res_mk.xmin - m_rect.xmin) / 2,\n                m_rect.ymin + (m_rect.size[1] / 2),\n            ),\n            layer=m_lbl_layer,\n        )\n\n    # creating layout and cell in klayout\n    c.write_gds(\"res_temp.gds\")\n    layout.read(\"res_temp.gds\")\n    cell_name = \"res_dev\"\n\n    return layout.cell(cell_name)", "\n\n@gf.cell\ndef pcmpgr_gen(dn_rect, grw: float = 0.36) -> gf.Component:\n    \"\"\"Return deepnwell guardring\n\n    Args :\n        dn_rect : deepnwell polygon\n        grw : guardring width\n    \"\"\"\n\n    c = gf.Component()\n\n    comp_pp_enc: float = 0.16\n    con_size = 0.22\n    con_sp = 0.28\n    con_comp_enc = 0.07\n    pcmpgr_enc_dn = 2.5\n\n    c_temp_gr = gf.Component(\"temp_store guard ring\")\n    rect_pcmpgr_in = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (dn_rect.xmax - dn_rect.xmin) + 2 * pcmpgr_enc_dn,\n                (dn_rect.ymax - dn_rect.ymin) + 2 * pcmpgr_enc_dn,\n            ),\n            layer=layer[\"comp\"],\n        )\n    )\n    rect_pcmpgr_in.move((dn_rect.xmin - pcmpgr_enc_dn, dn_rect.ymin - pcmpgr_enc_dn))\n    rect_pcmpgr_out = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) + 2 * grw,\n                (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) + 2 * grw,\n            ),\n            layer=layer[\"comp\"],\n        )\n    )\n    rect_pcmpgr_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n    c.add_ref(\n        gf.geometry.boolean(\n            A=rect_pcmpgr_out,\n            B=rect_pcmpgr_in,\n            operation=\"A-B\",\n            layer=layer[\"comp\"],\n        )\n    )  # guardring bulk\n\n    psdm_in = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_pcmpgr_in.xmax - rect_pcmpgr_in.xmin) - 2 * comp_pp_enc,\n                (rect_pcmpgr_in.ymax - rect_pcmpgr_in.ymin) - 2 * comp_pp_enc,\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    psdm_in.move(\n        (\n            rect_pcmpgr_in.xmin + comp_pp_enc,\n            rect_pcmpgr_in.ymin + comp_pp_enc,\n        )\n    )\n    psdm_out = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (rect_pcmpgr_out.xmax - rect_pcmpgr_out.xmin) + 2 * comp_pp_enc,\n                (rect_pcmpgr_out.ymax - rect_pcmpgr_out.ymin) + 2 * comp_pp_enc,\n            ),\n            layer=layer[\"pplus\"],\n        )\n    )\n    psdm_out.move(\n        (\n            rect_pcmpgr_out.xmin - comp_pp_enc,\n            rect_pcmpgr_out.ymin - comp_pp_enc,\n        )\n    )\n    c.add_ref(\n        gf.geometry.boolean(\n            A=psdm_out, B=psdm_in, operation=\"A-B\", layer=layer[\"pplus\"]\n        )\n    )  # pplus_draw\n\n    # generating contacts\n\n    c.add_ref(\n        via_generator(\n            x_range=(\n                rect_pcmpgr_in.xmin + con_size,\n                rect_pcmpgr_in.xmax - con_size,\n            ),\n            y_range=(rect_pcmpgr_out.ymin, rect_pcmpgr_in.ymin),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # bottom contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(\n                rect_pcmpgr_in.xmin + con_size,\n                rect_pcmpgr_in.xmax - con_size,\n            ),\n            y_range=(rect_pcmpgr_in.ymax, rect_pcmpgr_out.ymax),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # upper contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(rect_pcmpgr_out.xmin, rect_pcmpgr_in.xmin),\n            y_range=(\n                rect_pcmpgr_in.ymin + con_size,\n                rect_pcmpgr_in.ymax - con_size,\n            ),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # right contact\n\n    c.add_ref(\n        via_generator(\n            x_range=(rect_pcmpgr_in.xmax, rect_pcmpgr_out.xmax),\n            y_range=(\n                rect_pcmpgr_in.ymin + con_size,\n                rect_pcmpgr_in.ymax - con_size,\n            ),\n            via_enclosure=(con_comp_enc, con_comp_enc),\n            via_layer=layer[\"contact\"],\n            via_size=(con_size, con_size),\n            via_spacing=(con_sp, con_sp),\n        )\n    )  # left contact\n\n    comp_m1_in = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(rect_pcmpgr_in.size[0], rect_pcmpgr_in.size[1]),\n            layer=layer[\"metal1\"],\n        )\n    )\n\n    comp_m1_out = c_temp_gr.add_ref(\n        gf.components.rectangle(\n            size=(\n                (comp_m1_in.size[0]) + 2 * grw,\n                (comp_m1_in.size[1]) + 2 * grw,\n            ),\n            layer=layer[\"metal1\"],\n        )\n    )\n    comp_m1_out.move((rect_pcmpgr_in.xmin - grw, rect_pcmpgr_in.ymin - grw))\n    c.add_ref(\n        gf.geometry.boolean(\n            A=rect_pcmpgr_out,\n            B=rect_pcmpgr_in,\n            operation=\"A-B\",\n            layer=layer[\"metal1\"],\n        )\n    )  # metal1 guardring\n\n    return c", "\n\n@gf.cell\ndef plus_res_inst(\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"nplus_s\",\n    sub: bool = 0,\n    cmp_res_ext: float = 0.1,\n    con_enc: float = 0.1,\n    cmp_imp_layer: LayerSpec = layer[\"nplus\"],\n    sub_imp_layer: LayerSpec = layer[\"pplus\"],\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component()\n\n    np_enc_cmp: float = 0.16\n    res_mk = c.add_ref(\n        gf.components.rectangle(size=(l_res, w_res), layer=layer[\"res_mk\"])\n    )\n\n    if \"plus_u\" in res_type:\n        sab_res_ext = 0.22\n\n        sab_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(res_mk.size[0], res_mk.size[1] + (2 * sab_res_ext)),\n                layer=layer[\"sab\"],\n            )\n        )\n        sab_rect.xmin = res_mk.xmin\n        sab_rect.ymin = res_mk.ymin - sab_res_ext\n\n    cmp = c.add_ref(\n        gf.components.rectangle(\n            size=(res_mk.size[0] + (2 * cmp_res_ext), res_mk.size[1]),\n            layer=layer[\"comp\"],\n        )\n    )\n    cmp.xmin = res_mk.xmin - cmp_res_ext\n    cmp.ymin = res_mk.ymin\n\n    cmp_con = via_stack(\n        x_range=(cmp.xmin, res_mk.xmin + con_enc),\n        y_range=(cmp.ymin, cmp.ymax),\n        base_layer=layer[\"comp\"],\n        metal_level=1,\n    )\n\n    cmp_con_arr = c.add_array(\n        component=cmp_con,\n        rows=1,\n        columns=2,\n        spacing=(cmp_res_ext - con_enc + res_mk.size[0], 0),\n    )  # comp contact array\n\n    # labels generation\n    if lbl == 1:\n        c.add_label(\n            r0_lbl,\n            position=(\n                cmp_con_arr.xmin + (cmp_con.size[0] / 2),\n                cmp_con_arr.ymin + (cmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n        c.add_label(\n            r1_lbl,\n            position=(\n                cmp_con_arr.xmax - (cmp_con.size[0] / 2),\n                cmp_con_arr.ymin + (cmp_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    cmp_imp = c.add_ref(\n        gf.components.rectangle(\n            size=(cmp.size[0] + (2 * np_enc_cmp), cmp.size[1] + (2 * np_enc_cmp)),\n            layer=cmp_imp_layer,\n        )\n    )\n    cmp_imp.xmin = cmp.xmin - np_enc_cmp\n    cmp_imp.ymin = cmp.ymin - np_enc_cmp\n\n    if sub == 1:\n        sub_w: float = 0.36\n        sub_rect = c.add_ref(\n            gf.components.rectangle(size=(sub_w, w_res), layer=layer[\"comp\"])\n        )\n        comp_spacing: float = 0.72\n        sub_rect.xmax = cmp.xmin - comp_spacing\n        sub_rect.ymin = cmp.ymin\n\n        # sub_rect contact\n        sub_con = c.add_ref(\n            via_stack(\n                x_range=(sub_rect.xmin, sub_rect.xmax),\n                y_range=(sub_rect.ymin, sub_rect.ymax),\n                base_layer=layer[\"comp\"],\n                metal_level=1,\n            )\n        )\n\n        pp_enc_cmp: float = 0.16\n        sub_imp = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    sub_rect.size[0] + (2 * pp_enc_cmp),\n                    cmp.size[1] + (2 * pp_enc_cmp),\n                ),\n                layer=sub_imp_layer,\n            )\n        )\n        sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n        sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n\n        # label generation\n        if lbl == 1:\n            c.add_label(\n                sub_lbl,\n                position=(\n                    sub_con.xmin + (sub_con.size[0] / 2),\n                    sub_con.ymin + (sub_con.size[1] / 2),\n                ),\n                layer=layer[\"metal1_label\"],\n            )\n\n    return c", "\n\ndef draw_nplus_res(\n    layout,\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"nplus_s\",\n    sub: bool = 0,\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component(\"res_dev\")\n\n    if res_type == \"nplus_s\":\n        cmp_res_ext = 0.29\n        con_enc = 0.07\n    else:\n        cmp_res_ext = 0.44\n        con_enc = 0.0\n\n    # adding res inst\n    r_inst = c.add_ref(\n        plus_res_inst(\n            l_res=l_res,\n            w_res=w_res,\n            res_type=res_type,\n            sub=sub,\n            cmp_res_ext=cmp_res_ext,\n            con_enc=con_enc,\n            cmp_imp_layer=layer[\"nplus\"],\n            sub_imp_layer=layer[\"pplus\"],\n            lbl=lbl,\n            r0_lbl=r0_lbl,\n            r1_lbl=r1_lbl,\n            sub_lbl=sub_lbl,\n        )\n    )\n\n    if deepnwell == 1:\n        lvpwell_enc_cmp = 0.43\n        lvpwell = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    r_inst.size[0] + (2 * lvpwell_enc_cmp),\n                    r_inst.size[1] + (2 * lvpwell_enc_cmp),\n                ),\n                layer=layer[\"lvpwell\"],\n            )\n        )\n        lvpwell.xmin = r_inst.xmin - lvpwell_enc_cmp\n        lvpwell.ymin = r_inst.ymin - lvpwell_enc_cmp\n\n        dn_enc_lvpwell = 2.5\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    lvpwell.size[0] + (2 * dn_enc_lvpwell),\n                    lvpwell.size[1] + (2 * dn_enc_lvpwell),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n        dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n        dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\n        if pcmpgr == 1:\n            sub_w = 0.36\n\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\n    c.write_gds(\"res_temp.gds\")\n    layout.read(\"res_temp.gds\")\n    cell_name = \"res_dev\"\n\n    return layout.cell(cell_name)", "\n\ndef draw_pplus_res(\n    layout,\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"pplus_s\",\n    sub: bool = 0,\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component(\"res_dev\")\n\n    if res_type == \"pplus_s\":\n        cmp_res_ext = 0.29\n        con_enc = 0.07\n    else:\n        cmp_res_ext = 0.44\n        con_enc = 0.0\n\n    # adding res inst\n    r_inst = c.add_ref(\n        plus_res_inst(\n            l_res=l_res,\n            w_res=w_res,\n            res_type=res_type,\n            sub=1,\n            cmp_res_ext=cmp_res_ext,\n            con_enc=con_enc,\n            cmp_imp_layer=layer[\"pplus\"],\n            sub_imp_layer=layer[\"nplus\"],\n            lbl=lbl,\n            r0_lbl=r0_lbl,\n            r1_lbl=r1_lbl,\n            sub_lbl=sub_lbl,\n        )\n    )\n\n    if deepnwell == 1:\n        dn_enc_ncmp = 0.66\n        dn_enc_pcmp = 1.02\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    r_inst.size[0] + (dn_enc_pcmp + dn_enc_ncmp),\n                    r_inst.size[1] + (2 * dn_enc_pcmp),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n        dn_rect.xmax = r_inst.xmax + dn_enc_pcmp\n        dn_rect.ymin = r_inst.ymin - dn_enc_pcmp\n\n        if pcmpgr == 1:\n            sub_w = 0.36\n\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\n    else:\n        nw_enc_pcmp = 0.6\n        nw_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    r_inst.size[0] + (2 * nw_enc_pcmp),\n                    r_inst.size[1] + (2 * nw_enc_pcmp),\n                ),\n                layer=layer[\"nwell\"],\n            )\n        )\n        nw_rect.xmin = r_inst.xmin - nw_enc_pcmp\n        nw_rect.ymin = r_inst.ymin - nw_enc_pcmp\n\n    c.write_gds(\"res_temp.gds\")\n    layout.read(\"res_temp.gds\")\n    cell_name = \"res_dev\"\n\n    return layout.cell(cell_name)", "\n\n@gf.cell\ndef polyf_res_inst(\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"npolyf_s\",\n    pl_res_ext: float = 0.1,\n    con_enc: float = 0.1,\n    pl_imp_layer: LayerSpec = layer[\"nplus\"],\n    sub_imp_layer: LayerSpec = layer[\"pplus\"],\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component()\n\n    sub_w: float = 0.36\n    np_enc_poly2 = 0.3\n    pp_enc_cmp: float = 0.16\n    comp_spacing: float = 0.72\n    res_mk = c.add_ref(\n        gf.components.rectangle(size=(l_res, w_res), layer=layer[\"res_mk\"])\n    )\n\n    if \"polyf_u\" in res_type:\n        sab_res_ext = 0.28\n\n        sab_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(res_mk.size[0], res_mk.size[1] + (2 * sab_res_ext)),\n                layer=layer[\"sab\"],\n            )\n        )\n        sab_rect.xmin = res_mk.xmin\n        sab_rect.ymin = res_mk.ymin - sab_res_ext\n\n    pl = c.add_ref(\n        gf.components.rectangle(\n            size=(res_mk.size[0] + (2 * pl_res_ext), res_mk.size[1]),\n            layer=layer[\"poly2\"],\n        )\n    )\n    pl.xmin = res_mk.xmin - pl_res_ext\n    pl.ymin = res_mk.ymin\n\n    pl_con = via_stack(\n        x_range=(pl.xmin, res_mk.xmin + con_enc),\n        y_range=(pl.ymin, pl.ymax),\n        base_layer=layer[\"poly2\"],\n        metal_level=1,\n    )\n\n    pl_con_arr = c.add_array(\n        component=pl_con,\n        rows=1,\n        columns=2,\n        spacing=(pl_res_ext - con_enc + res_mk.size[0], 0),\n    )  # comp contact array\n\n    pl_imp = c.add_ref(\n        gf.components.rectangle(\n            size=(pl.size[0] + (2 * np_enc_poly2), pl.size[1] + (2 * np_enc_poly2)),\n            layer=pl_imp_layer,\n        )\n    )\n    pl_imp.xmin = pl.xmin - np_enc_poly2\n    pl_imp.ymin = pl.ymin - np_enc_poly2\n\n    sub_rect = c.add_ref(\n        gf.components.rectangle(size=(sub_w, w_res), layer=layer[\"comp\"])\n    )\n    sub_rect.xmax = pl.xmin - comp_spacing\n    sub_rect.ymin = pl.ymin\n\n    # sub_rect contact\n    sub_con = c.add_ref(\n        via_stack(\n            x_range=(sub_rect.xmin, sub_rect.xmax),\n            y_range=(sub_rect.ymin, sub_rect.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )\n\n    sub_imp = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                sub_rect.size[0] + (2 * pp_enc_cmp),\n                pl.size[1] + (2 * pp_enc_cmp),\n            ),\n            layer=sub_imp_layer,\n        )\n    )\n    sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n    sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n\n    # labels generation\n    if lbl == 1:\n        c.add_label(\n            r0_lbl,\n            position=(\n                pl_con_arr.xmin + (pl_con.size[0] / 2),\n                pl_con_arr.ymin + (pl_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n        c.add_label(\n            r1_lbl,\n            position=(\n                pl_con_arr.xmax - (pl_con.size[0] / 2),\n                pl_con_arr.ymin + (pl_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        c.add_label(\n            sub_lbl,\n            position=(\n                sub_con.xmin + (sub_con.size[0] / 2),\n                sub_con.ymin + (sub_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    return c", "\n\ndef draw_npolyf_res(\n    layout,\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"npolyf_s\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component(\"res_dev\")\n\n    if res_type == \"npolyf_s\":\n        pl_res_ext = 0.29\n        con_enc = 0.07\n    else:\n        pl_res_ext = 0.44\n        con_enc = 0.0\n\n    # adding res inst\n    r_inst = c.add_ref(\n        polyf_res_inst(\n            l_res=l_res,\n            w_res=w_res,\n            res_type=res_type,\n            pl_res_ext=pl_res_ext,\n            con_enc=con_enc,\n            pl_imp_layer=layer[\"nplus\"],\n            sub_imp_layer=layer[\"pplus\"],\n            lbl=lbl,\n            r0_lbl=r0_lbl,\n            r1_lbl=r1_lbl,\n            sub_lbl=sub_lbl,\n        )\n    )\n\n    if deepnwell == 1:\n        lvpwell_enc_cmp = 0.43\n        lvpwell = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    r_inst.size[0] + (2 * lvpwell_enc_cmp),\n                    r_inst.size[1] + (2 * lvpwell_enc_cmp),\n                ),\n                layer=layer[\"lvpwell\"],\n            )\n        )\n        lvpwell.xmin = r_inst.xmin - lvpwell_enc_cmp\n        lvpwell.ymin = r_inst.ymin - lvpwell_enc_cmp\n\n        dn_enc_lvpwell = 2.5\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    lvpwell.size[0] + (2 * dn_enc_lvpwell),\n                    lvpwell.size[1] + (2 * dn_enc_lvpwell),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n        dn_rect.xmin = lvpwell.xmin - dn_enc_lvpwell\n        dn_rect.ymin = lvpwell.ymin - dn_enc_lvpwell\n\n        if pcmpgr == 1:\n            sub_w = 0.36\n\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\n    c.write_gds(\"res_temp.gds\")\n    layout.read(\"res_temp.gds\")\n    cell_name = \"res_dev\"\n\n    return layout.cell(cell_name)", "\n\ndef draw_ppolyf_res(\n    layout,\n    l_res: float = 0.1,\n    w_res: float = 0.1,\n    res_type: str = \"ppolyf_s\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component(\"res_dev\")\n\n    if res_type == \"ppolyf_s\":\n        pl_res_ext = 0.29\n        con_enc = 0.07\n    else:\n        pl_res_ext = 0.44\n        con_enc = 0.0\n\n    sub_layer = layer[\"nplus\"] if deepnwell == 1 else layer[\"pplus\"]\n    # adding res inst\n    r_inst = c.add_ref(\n        polyf_res_inst(\n            l_res=l_res,\n            w_res=w_res,\n            res_type=res_type,\n            pl_res_ext=pl_res_ext,\n            con_enc=con_enc,\n            pl_imp_layer=layer[\"pplus\"],\n            sub_imp_layer=sub_layer,\n            lbl=lbl,\n            r0_lbl=r0_lbl,\n            r1_lbl=r1_lbl,\n            sub_lbl=sub_lbl,\n        )\n    )\n\n    if deepnwell == 1:\n        dn_enc_ncmp = 0.66\n        dn_enc_poly2 = 1.34\n\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    r_inst.size[0] + (dn_enc_poly2 + dn_enc_ncmp),\n                    r_inst.size[1] + (2 * dn_enc_poly2),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n        dn_rect.xmax = r_inst.xmax + dn_enc_poly2\n        dn_rect.ymin = r_inst.ymin - dn_enc_poly2\n\n        if pcmpgr == 1:\n            sub_w = 0.36\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\n    c.write_gds(\"res_temp.gds\")\n    layout.read(\"res_temp.gds\")\n    cell_name = \"res_dev\"\n\n    return layout.cell(cell_name)", "\n\ndef draw_ppolyf_u_high_Rs_res(\n    layout,\n    l_res: float = 0.42,\n    w_res: float = 0.42,\n    volt: str = \"3.3V\",\n    deepnwell: bool = 0,\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component(\"res_dev\")\n\n    dn_enc_ncmp = 0.62\n    dn_enc_poly2 = 1.34\n\n    pl_res_ext = 0.64\n\n    sub_w: float = 0.42\n    pp_enc_poly2 = 0.18\n    pp_enc_cmp: float = 0.02\n    comp_spacing: float = 0.7\n    sab_res_ext = (0.1, 0.28)\n    con_size = 0.36\n    resis_enc = (1.04, 0.4)\n    dg_enc_dn = 0.5\n\n    res_mk = c.add_ref(\n        gf.components.rectangle(size=(l_res, w_res), layer=layer[\"res_mk\"])\n    )\n\n    resis_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                res_mk.size[0] + (2 * resis_enc[0]),\n                res_mk.size[1] + (2 * resis_enc[1]),\n            ),\n            layer=layer[\"resistor\"],\n        )\n    )\n\n    resis_mk.xmin = res_mk.xmin - resis_enc[0]\n    resis_mk.ymin = res_mk.ymin - resis_enc[1]\n\n    sab_rect = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                res_mk.size[0] + (2 * sab_res_ext[0]),\n                res_mk.size[1] + (2 * sab_res_ext[1]),\n            ),\n            layer=layer[\"sab\"],\n        )\n    )\n    sab_rect.xmin = res_mk.xmin - sab_res_ext[0]\n    sab_rect.ymin = res_mk.ymin - sab_res_ext[1]\n\n    pl = c.add_ref(\n        gf.components.rectangle(\n            size=(res_mk.size[0] + (2 * pl_res_ext), res_mk.size[1]),\n            layer=layer[\"poly2\"],\n        )\n    )\n    pl.xmin = res_mk.xmin - pl_res_ext\n    pl.ymin = res_mk.ymin\n\n    pl_con = via_stack(\n        x_range=(pl.xmin, pl.xmin + con_size),\n        y_range=(pl.ymin, pl.ymax),\n        base_layer=layer[\"poly2\"],\n        metal_level=1,\n    )\n\n    pl_con_arr = c.add_array(\n        component=pl_con,\n        rows=1,\n        columns=2,\n        spacing=(pl.size[0] - con_size, 0),\n    )  # comp contact array\n\n    pplus = gf.components.rectangle(\n        size=(pl_res_ext + pp_enc_poly2, pl.size[1] + (2 * pp_enc_poly2)),\n        layer=layer[\"pplus\"],\n    )\n\n    pplus_arr = c.add_array(\n        component=pplus, rows=1, columns=2, spacing=(pplus.size[0] + res_mk.size[0], 0)\n    )\n\n    pplus_arr.xmin = pl.xmin - pp_enc_poly2\n    pplus_arr.ymin = pl.ymin - pp_enc_poly2\n\n    sub_rect = c.add_ref(\n        gf.components.rectangle(size=(sub_w, w_res), layer=layer[\"comp\"])\n    )\n    sub_rect.xmax = pl.xmin - comp_spacing\n    sub_rect.ymin = pl.ymin\n\n    # sub_rect contact\n    sub_con = c.add_ref(\n        via_stack(\n            x_range=(sub_rect.xmin, sub_rect.xmax),\n            y_range=(sub_rect.ymin, sub_rect.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )\n\n    # labels generation\n    if lbl == 1:\n        c.add_label(\n            r0_lbl,\n            position=(\n                pl_con_arr.xmin + (pl_con.size[0] / 2),\n                pl_con_arr.ymin + (pl_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n        c.add_label(\n            r1_lbl,\n            position=(\n                pl_con_arr.xmax - (pl_con.size[0] / 2),\n                pl_con_arr.ymin + (pl_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        c.add_label(\n            sub_lbl,\n            position=(\n                sub_con.xmin + (sub_con.size[0] / 2),\n                sub_con.ymin + (sub_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    if deepnwell == 1:\n        sub_layer = layer[\"nplus\"]\n    else:\n        sub_layer = layer[\"pplus\"]\n\n    sub_imp = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                sub_rect.size[0] + (2 * pp_enc_cmp),\n                pl.size[1] + (2 * pp_enc_cmp),\n            ),\n            layer=sub_layer,\n        )\n    )\n    sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n    sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n\n    if deepnwell == 1:\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    (pl.xmax - sub_rect.xmin) + (dn_enc_poly2 + dn_enc_ncmp),\n                    pl.size[1] + (2 * dn_enc_poly2),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n        dn_rect.xmax = pl.xmax + dn_enc_poly2\n        dn_rect.ymin = pl.ymin - dn_enc_poly2\n\n        if volt == \"5/6V\":\n            dg = c.add_ref(\n                gf.components.rectangle(\n                    size=(\n                        dn_rect.size[0] + (2 * dg_enc_dn),\n                        dn_rect.size[1] + (2 * dg_enc_dn),\n                    ),\n                    layer=layer[\"dualgate\"],\n                )\n            )\n\n            dg.xmin = dn_rect.xmin - dg_enc_dn\n            dg.ymin = dn_rect.ymin - dg_enc_dn\n\n        if pcmpgr == 1:\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\n    else:\n        if volt == \"5/6V\":\n            dg = c.add_ref(\n                gf.components.rectangle(\n                    size=(resis_mk.size[0], resis_mk.size[1]), layer=layer[\"dualgate\"]\n                )\n            )\n\n            dg.xmin = resis_mk.xmin\n            dg.ymin = resis_mk.ymin\n\n    c.write_gds(\"res_temp.gds\")\n    layout.read(\"res_temp.gds\")\n    cell_name = \"res_dev\"\n\n    return layout.cell(cell_name)", "\n\ndef draw_well_res(\n    layout,\n    l_res: float = 0.42,\n    w_res: float = 0.42,\n    res_type: str = \"nwell\",\n    pcmpgr: bool = 0,\n    lbl: bool = 0,\n    r0_lbl: str = \"\",\n    r1_lbl: str = \"\",\n    sub_lbl: str = \"\",\n) -> gf.Component:\n    c = gf.Component(\"res_dev\")\n\n    nw_res_ext = 0.48\n    nw_res_enc = 0.5\n    nw_enc_cmp = 0.12\n\n    sub_w: float = 0.36\n    pp_enc_cmp: float = 0.16\n    nw_comp_spacing: float = 0.72\n    dn_enc_lvpwell = 2.5\n\n    if res_type == \"pwell\":\n        cmp_imp_layer = layer[\"pplus\"]\n        sub_imp_layer = layer[\"nplus\"]\n        well_layer = layer[\"lvpwell\"]\n    else:\n        cmp_imp_layer = layer[\"nplus\"]\n        sub_imp_layer = layer[\"pplus\"]\n        well_layer = layer[\"nwell\"]\n\n    res_mk = c.add_ref(\n        gf.components.rectangle(\n            size=(l_res, w_res + (2 * nw_res_enc)), layer=layer[\"res_mk\"]\n        )\n    )\n\n    well_rect = c.add_ref(\n        gf.components.rectangle(\n            size=(res_mk.size[0] + (2 * nw_res_ext), w_res), layer=well_layer\n        )\n    )\n    well_rect.xmin = res_mk.xmin - nw_res_ext\n    well_rect.ymin = res_mk.ymin + nw_res_enc\n\n    @gf.cell\n    def comp_related_gen(size: Float2 = (0.42, 0.42)) -> gf.Component:\n        c = gf.Component()\n\n        cmp = c.add_ref(gf.components.rectangle(size=size, layer=layer[\"comp\"]))\n        cmp.xmin = well_rect.xmin + nw_enc_cmp\n        cmp.ymin = well_rect.ymin + nw_enc_cmp\n\n        c.add_ref(\n            via_stack(\n                x_range=(cmp.xmin, cmp.xmax),\n                y_range=(cmp.ymin, cmp.ymax),\n                base_layer=layer[\"comp\"],\n                metal_level=1,\n            )\n        )  # contact\n\n        return c\n\n    con_polys = comp_related_gen(\n        size=(\n            res_mk.xmin - well_rect.xmin - nw_enc_cmp,\n            well_rect.size[1] - (2 * nw_enc_cmp),\n        )\n    )\n\n    con_polys_arr = c.add_array(\n        component=con_polys,\n        rows=1,\n        columns=2,\n        spacing=(well_rect.size[0] - (2 * nw_enc_cmp) - con_polys.size[0], 0),\n    )  # comp and its related contact array\n\n    nplus_rect = gf.components.rectangle(\n        size=(\n            con_polys.size[0] + (2 * pp_enc_cmp),\n            con_polys.size[1] + (2 * pp_enc_cmp),\n        ),\n        layer=cmp_imp_layer,\n    )\n    nplus_arr = c.add_array(\n        component=nplus_rect,\n        rows=1,\n        columns=2,\n        spacing=(well_rect.size[0] - (2 * nw_enc_cmp) - con_polys.size[0], 0),\n    )\n    nplus_arr.xmin = con_polys.xmin - pp_enc_cmp\n    nplus_arr.ymin = con_polys.ymin - pp_enc_cmp\n\n    sub_rect = c.add_ref(\n        gf.components.rectangle(size=(sub_w, well_rect.size[1]), layer=layer[\"comp\"])\n    )\n    sub_rect.xmax = well_rect.xmin - nw_comp_spacing\n    sub_rect.ymin = well_rect.ymin\n\n    # sub_rect contact\n    sub_con = c.add_ref(\n        via_stack(\n            x_range=(sub_rect.xmin, sub_rect.xmax),\n            y_range=(sub_rect.ymin, sub_rect.ymax),\n            base_layer=layer[\"comp\"],\n            metal_level=1,\n        )\n    )\n\n    sub_imp = c.add_ref(\n        gf.components.rectangle(\n            size=(\n                sub_rect.size[0] + (2 * pp_enc_cmp),\n                well_rect.size[1] + (2 * pp_enc_cmp),\n            ),\n            layer=sub_imp_layer,\n        )\n    )\n    sub_imp.xmin = sub_rect.xmin - pp_enc_cmp\n    sub_imp.ymin = sub_rect.ymin - pp_enc_cmp\n\n    if res_type == \"pwell\":\n        dn_rect = c.add_ref(\n            gf.components.rectangle(\n                size=(\n                    well_rect.size[0] + (2 * dn_enc_lvpwell),\n                    well_rect.size[1] + (2 * dn_enc_lvpwell),\n                ),\n                layer=layer[\"dnwell\"],\n            )\n        )\n        dn_rect.xmin = well_rect.xmin - dn_enc_lvpwell\n        dn_rect.ymin = well_rect.ymin - dn_enc_lvpwell\n\n        if pcmpgr == 1:\n            c.add_ref(pcmpgr_gen(dn_rect=dn_rect, grw=sub_w))\n\n    # labels generation\n    if lbl == 1:\n        c.add_label(\n            r0_lbl,\n            position=(\n                con_polys_arr.xmin + (con_polys.size[0] / 2),\n                con_polys_arr.ymin + (con_polys.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n        c.add_label(\n            r1_lbl,\n            position=(\n                con_polys_arr.xmax - (con_polys.size[0] / 2),\n                con_polys_arr.ymin + (con_polys.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n        c.add_label(\n            sub_lbl,\n            position=(\n                sub_con.xmin + (sub_con.size[0] / 2),\n                sub_con.ymin + (sub_con.size[1] / 2),\n            ),\n            layer=layer[\"metal1_label\"],\n        )\n\n    c.write_gds(\"res_temp.gds\")\n    layout.read(\"res_temp.gds\")\n    cell_name = \"res_dev\"\n\n    return layout.cell(cell_name)", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/cap_mim.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n########################################################################################################################\n# MIM Capacitor Generator for GF180MCU\n########################################################################################################################\n", "########################################################################################################################\n\nimport os\n\nimport pya\n\nfrom .draw_cap_mim import draw_cap_mim\n\nmim_l = 1.02\nmim_w = 1.02", "mim_l = 1.02\nmim_w = 1.02\n\n\nclass cap_mim(pya.PCellDeclarationHelper):\n    \"\"\"\n    MIM capacitor Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.Type_handle = self.param(\"mim_option\", self.TypeList, \"MIM-Option\")\n        self.Type_handle.add_choice(\"MIM-A\", \"MIM-A\")\n        self.Type_handle.add_choice(\"MIM-B\", \"MIM-B\")\n\n        self.Type_handle2 = self.param(\n            \"metal_level\", self.TypeList, \"Metal level (MIM-B)\"\n        )\n        self.Type_handle2.add_choice(\"M4\", \"M4\")\n        self.Type_handle2.add_choice(\"M5\", \"M5\")\n        self.Type_handle2.add_choice(\"M6\", \"M6\")\n\n        self.param(\"lc\", self.TypeDouble, \"Length\", default=mim_l, unit=\"um\")\n        self.param(\"wc\", self.TypeDouble, \"Width\", default=mim_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"top_lbl\", self.TypeString, \"Top plate label\", default=\"\")\n\n        self.param(\"bot_lbl\", self.TypeString, \"Bottom plate label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return \"cap_mim(L=\" + (\"%.3f\" % self.lc) + \",W=\" + (\"%.3f\" % self.wc) + \")\"\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.wc * self.lc\n        self.perim = 2 * (self.wc + self.lc)\n        # w,l must be larger or equal than min. values.\n        self.lc = max(self.lc, mim_l)\n        self.wc = max(self.wc, mim_w)\n        if (self.mim_option) == \"MIM-A\":\n            self.metal_level = \"M3\"\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.lc = self.layout.get_info(self.layer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        option = os.environ[\"GF_PDK_OPTION\"]\n        if (\n            option == \"A\"\n            and (self.mim_option) == \"MIM-B\"\n            or option != \"A\"\n            and (self.mim_option) == \"MIM-A\"\n        ):\n            raise TypeError(f\"Current stack ({option}) doesn't allow this option\")\n        np_instance = draw_cap_mim(\n            self.layout,\n            lc=self.lc,\n            wc=self.wc,\n            mim_option=self.mim_option,\n            metal_level=self.metal_level,\n            lbl=self.lbl,\n            top_lbl=self.top_lbl,\n            bot_lbl=self.bot_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/diode.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n########################################################################################################################\n# Diode Generator for GF180MCU\n########################################################################################################################\n", "########################################################################################################################\n\nimport pya\n\nfrom .draw_diode import (\n    draw_diode_dw2ps,\n    draw_diode_nd2ps,\n    draw_diode_nw2ps,\n    draw_diode_pd2nw,\n    draw_diode_pw2dw,", "    draw_diode_pd2nw,\n    draw_diode_pw2dw,\n    draw_sc_diode,\n)\n\nnp_l = 0.36\nnp_w = 0.36\n\npn_l = 0.36\npn_w = 0.36", "pn_l = 0.36\npn_w = 0.36\n\nnwp_l = 0.36\nnwp_w = 0.36\n\ndiode_pw2dw_l = 0.36\ndiode_pw2dw_w = 0.36\n\ndiode_dw2ps_l = 0.36", "\ndiode_dw2ps_l = 0.36\ndiode_dw2ps_w = 0.36\n\nsc_l = 1\nsc_w = 0.62\n\n\nclass diode_nd2ps(pya.PCellDeclarationHelper):\n    \"\"\"\n    N+/LVPWELL diode (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\n        self.param(\"la\", self.TypeDouble, \"Length\", default=np_l, unit=\"um\")\n        self.param(\"wa\", self.TypeDouble, \"Width\", default=np_w, unit=\"um\")\n        self.param(\"cw\", self.TypeDouble, \"Cathode Width\", default=np_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"p_lbl\", self.TypeString, \"plus label\", default=\"\")\n\n        self.param(\"n_lbl\", self.TypeString, \"minus label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return \"diode_nd2ps(L=\" + (\"%.3f\" % self.la) + \",W=\" + (\"%.3f\" % self.wa) + \")\"\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.wa * self.la\n        self.perim = 2 * (self.wa + self.la)\n        # w,l must be larger or equal than min. values.\n        self.la = max(self.la, np_l)\n        self.wa = max(self.wa, np_w)\n        self.cw = max(self.cw, np_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.la = self.layout.get_info(self.laayer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        np_instance = draw_diode_nd2ps(\n            self.layout,\n            la=self.la,\n            wa=self.wa,\n            cw=self.cw,\n            volt=self.volt,\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            p_lbl=self.p_lbl,\n            n_lbl=self.n_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "class diode_nd2ps(pya.PCellDeclarationHelper):\n    \"\"\"\n    N+/LVPWELL diode (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\n        self.param(\"la\", self.TypeDouble, \"Length\", default=np_l, unit=\"um\")\n        self.param(\"wa\", self.TypeDouble, \"Width\", default=np_w, unit=\"um\")\n        self.param(\"cw\", self.TypeDouble, \"Cathode Width\", default=np_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"p_lbl\", self.TypeString, \"plus label\", default=\"\")\n\n        self.param(\"n_lbl\", self.TypeString, \"minus label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return \"diode_nd2ps(L=\" + (\"%.3f\" % self.la) + \",W=\" + (\"%.3f\" % self.wa) + \")\"\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.wa * self.la\n        self.perim = 2 * (self.wa + self.la)\n        # w,l must be larger or equal than min. values.\n        self.la = max(self.la, np_l)\n        self.wa = max(self.wa, np_w)\n        self.cw = max(self.cw, np_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.la = self.layout.get_info(self.laayer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        np_instance = draw_diode_nd2ps(\n            self.layout,\n            la=self.la,\n            wa=self.wa,\n            cw=self.cw,\n            volt=self.volt,\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            p_lbl=self.p_lbl,\n            n_lbl=self.n_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass diode_pd2nw(pya.PCellDeclarationHelper):\n    \"\"\"\n    P+/Nwell diode (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\n        self.param(\"la\", self.TypeDouble, \"Length\", default=pn_l, unit=\"um\")\n        self.param(\"wa\", self.TypeDouble, \"Width\", default=pn_w, unit=\"um\")\n        self.param(\"cw\", self.TypeDouble, \"Cathode Width\", default=np_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"p_lbl\", self.TypeString, \"plus label\", default=\"\")\n\n        self.param(\"n_lbl\", self.TypeString, \"minus label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return \"diode_pd2nw(L=\" + (\"%.3f\" % self.la) + \",W=\" + (\"%.3f\" % self.wa) + \")\"\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.wa * self.la\n        self.perim = 2 * (self.wa + self.la)\n        # w,l must be larger or equal than min. values.\n        self.la = max(self.la, pn_l)\n        self.wa = max(self.wa, pn_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.la = self.layout.get_info(self.laayer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        np_instance = draw_diode_pd2nw(\n            self.layout,\n            la=self.la,\n            wa=self.wa,\n            cw=self.cw,\n            volt=self.volt,\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            p_lbl=self.p_lbl,\n            n_lbl=self.n_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass diode_nw2ps(pya.PCellDeclarationHelper):\n    \"\"\"\n    Nwell/Psub diode Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\n        self.param(\"la\", self.TypeDouble, \"Length\", default=nwp_l, unit=\"um\")\n        self.param(\"wa\", self.TypeDouble, \"Width\", default=nwp_w, unit=\"um\")\n        self.param(\"cw\", self.TypeDouble, \"Cathode Width\", default=np_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"p_lbl\", self.TypeString, \"plus label\", default=\"\")\n\n        self.param(\"n_lbl\", self.TypeString, \"minus label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return \"diode_nw2ps(L=\" + (\"%.3f\" % self.la) + \",W=\" + (\"%.3f\" % self.wa) + \")\"\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.wa * self.la\n        self.perim = 2 * (self.wa + self.la)\n        # w,l must be larger or equal than min. values.\n        self.la = max(self.la, nwp_l)\n        self.wa = max(self.wa, nwp_w)\n        self.cw = max(self.cw, nwp_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.la = self.layout.get_info(self.laayer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        nwp_instance = draw_diode_nw2ps(\n            self.layout,\n            la=self.la,\n            wa=self.wa,\n            cw=self.cw,\n            volt=self.volt,\n            lbl=self.lbl,\n            p_lbl=self.p_lbl,\n            n_lbl=self.n_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            nwp_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass diode_pw2dw(pya.PCellDeclarationHelper):\n    \"\"\"\n    LVPWELL/DNWELL diode Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\n        self.param(\"la\", self.TypeDouble, \"Length\", default=diode_pw2dw_l, unit=\"um\")\n        self.param(\"wa\", self.TypeDouble, \"Width\", default=diode_pw2dw_w, unit=\"um\")\n        self.param(\"cw\", self.TypeDouble, \"Cathode Width\", default=np_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"p_lbl\", self.TypeString, \"plus label\", default=\"\")\n\n        self.param(\"n_lbl\", self.TypeString, \"minus label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return \"diode_pw2dw(L=\" + (\"%.3f\" % self.la) + \",W=\" + (\"%.3f\" % self.wa) + \")\"\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.wa * self.la\n        self.perim = 2 * (self.wa + self.la)\n        # w,l must be larger or equal than min. values.\n        self.la = max(self.la, diode_pw2dw_l)\n        self.wa = max(self.wa, diode_pw2dw_w)\n        self.cw = max(self.cw, diode_pw2dw_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.la = self.layout.get_info(self.laayer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        diode_pw2dw_instance = draw_diode_pw2dw(\n            self.layout,\n            la=self.la,\n            wa=self.wa,\n            cw=self.cw,\n            volt=self.volt,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            p_lbl=self.p_lbl,\n            n_lbl=self.n_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            diode_pw2dw_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass diode_dw2ps(pya.PCellDeclarationHelper):\n    \"\"\"\n    LVPWELL/DNWELL diode Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\n        self.param(\"la\", self.TypeDouble, \"Length\", default=diode_dw2ps_l, unit=\"um\")\n        self.param(\"wa\", self.TypeDouble, \"Width\", default=diode_dw2ps_w, unit=\"um\")\n        self.param(\"cw\", self.TypeDouble, \"Cathode Width\", default=np_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"p_lbl\", self.TypeString, \"plus label\", default=\"\")\n\n        self.param(\"n_lbl\", self.TypeString, \"minus label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return \"diode_dw2ps(L=\" + (\"%.3f\" % self.la) + \",W=\" + (\"%.3f\" % self.wa) + \")\"\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.wa * self.la\n        self.perim = 2 * (self.wa + self.la)\n        # w,l must be larger or equal than min. values.\n        self.la = max(self.la, diode_dw2ps_l)\n        self.wa = max(self.wa, diode_dw2ps_w)\n        self.cw = max(self.cw, diode_dw2ps_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.la = self.layout.get_info(self.laayer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        diode_dw2ps_instance = draw_diode_dw2ps(\n            self.layout,\n            la=self.la,\n            wa=self.wa,\n            cw=self.cw,\n            volt=self.volt,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            p_lbl=self.p_lbl,\n            n_lbl=self.n_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            diode_dw2ps_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass sc_diode(pya.PCellDeclarationHelper):\n    \"\"\"\n    N+/LVPWELL diode (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.param(\"la\", self.TypeDouble, \"Length\", default=sc_l, unit=\"um\")\n        self.param(\n            \"wa\", self.TypeDouble, \"Width\", default=sc_w, unit=\"um\", readonly=True\n        )\n        self.param(\"cw\", self.TypeDouble, \"Cathode Width\", default=np_w, unit=\"um\")\n        self.param(\"m\", self.TypeDouble, \"no. of fingers\", default=4)\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"p_lbl\", self.TypeString, \"plus label\", default=\"\")\n\n        self.param(\"n_lbl\", self.TypeString, \"minus label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return \"sc_diode(L=\" + (\"%.3f\" % self.la) + \",W=\" + (\"%.3f\" % self.wa) + \")\"\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.wa * self.la\n        self.perim = 2 * (self.wa + self.la)\n        # w,l must be larger or equal than min. values.\n        self.la = max(self.la, sc_l)\n        if (self.wa) != sc_w:\n            self.wa = sc_w\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.la = self.layout.get_info(self.laayer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        sc_instance = draw_sc_diode(\n            self.layout,\n            la=self.la,\n            wa=self.wa,\n            cw=self.cw,\n            m=self.m,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            p_lbl=self.p_lbl,\n            n_lbl=self.n_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            sc_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", ""]}
{"filename": "gf180/cells/klayout/pymacros/cells/cap_mos.py", "chunked_list": ["# Copyright 2022 GlobalFoundries PDK Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n########################################################################################################################\n# MOS Capacitor Generator for GF180MCU\n########################################################################################################################\n", "########################################################################################################################\n\nimport pya\n\nfrom .draw_cap_mos import draw_cap_mos\n\ncap_nmos_w = 1.88\ncap_nmos_l = 1\n\ncap_pmos_w = 1.88", "\ncap_pmos_w = 1.88\ncap_pmos_l = 1\n\ncap_nmos_b_w = 1.88\ncap_nmos_b_l = 1\n\ncap_pmos_b_w = 1.88\ncap_pmos_b_l = 1\n", "cap_pmos_b_l = 1\n\npoly_spacing = 0.24\n\n\nclass cap_nmos(pya.PCellDeclarationHelper):\n    \"\"\"\n    NMOS capacitor (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\n        self.param(\"lc\", self.TypeDouble, \"Length\", default=cap_nmos_l, unit=\"um\")\n        self.param(\"wc\", self.TypeDouble, \"Width\", default=cap_nmos_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"g_lbl\", self.TypeString, \"Gate terminal label\", default=\"\")\n\n        self.param(\"sd_lbl\", self.TypeString, \"Source/Drain terminal label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return \"cap_nmos(LC=\" + (\"%.3f\" % self.lc) + \",WC=\" + (\"%.3f\" % self.wc) + \")\"\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.wc * self.lc\n        self.perim = 2 * (self.wc + self.lc)\n        # w,l must be larger or equal than min. values.\n        self.lc = max(self.lc, cap_nmos_l)\n        self.wc = max(self.wc, cap_nmos_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.lc = self.layout.get_info(self.lcayer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        np_instance = draw_cap_mos(\n            self.layout,\n            type=\"cap_nmos\",\n            lc=self.lc,\n            wc=self.wc,\n            volt=self.volt,\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            g_lbl=self.g_lbl,\n            sd_lbl=self.sd_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass cap_pmos(pya.PCellDeclarationHelper):\n    \"\"\"\n    3.3V PMOS capacitor (Outside DNWELL) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.param(\"deepnwell\", self.TypeBoolean, \"Deep NWELL\", default=0)\n        self.param(\"pcmpgr\", self.TypeBoolean, \"Guard Ring\", default=0)\n        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\n        self.param(\"lc\", self.TypeDouble, \"Length\", default=cap_pmos_l, unit=\"um\")\n        self.param(\"wc\", self.TypeDouble, \"Width\", default=cap_pmos_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"g_lbl\", self.TypeString, \"Gate terminal label\", default=\"\")\n\n        self.param(\"sd_lbl\", self.TypeString, \"Source/Drain terminal label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return \"cap_pmos(LC=\" + (\"%.3f\" % self.lc) + \",WC=\" + (\"%.3f\" % self.wc) + \")\"\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.wc * self.lc\n        self.perim = 2 * (self.wc + self.lc)\n        # w,l must be larger or equal than min. values.\n        self.lc = max(self.lc, cap_pmos_l)\n        self.wc = max(self.wc, cap_pmos_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.lc = self.layout.get_info(self.lcayer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        np_instance = draw_cap_mos(\n            self.layout,\n            type=\"cap_pmos\",\n            lc=self.lc,\n            wc=self.wc,\n            volt=self.volt,\n            deepnwell=self.deepnwell,\n            pcmpgr=self.pcmpgr,\n            lbl=self.lbl,\n            g_lbl=self.g_lbl,\n            sd_lbl=self.sd_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass cap_nmos_b(pya.PCellDeclarationHelper):\n    \"\"\"\n    3.3V NMOS capacitor (inside NWell) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\n        self.param(\"lc\", self.TypeDouble, \"Length\", default=cap_nmos_b_l, unit=\"um\")\n        self.param(\"wc\", self.TypeDouble, \"Width\", default=cap_nmos_b_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"g_lbl\", self.TypeString, \"Gate terminal label\", default=\"\")\n\n        self.param(\"sd_lbl\", self.TypeString, \"Source/Drain terminal label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return \"cap_nmos_b(LC=\" + (\"%.3f\" % self.lc) + \",WC=\" + (\"%.3f\" % self.wc) + \")\"\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.wc * self.lc\n        self.perim = 2 * (self.wc + self.lc)\n        # w,l must be larger or equal than min. values.\n        self.lc = max(self.lc, cap_nmos_b_l)\n        self.wc = max(self.wc, cap_nmos_b_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.lc = self.layout.get_info(self.lcayer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        np_instance = draw_cap_mos(\n            self.layout,\n            type=\"cap_nmos_b\",\n            lc=self.lc,\n            wc=self.wc,\n            volt=self.volt,\n            deepnwell=0,  # self.deepnwell,\n            pcmpgr=0,  # self.pcmpgr,\n            lbl=self.lbl,\n            g_lbl=self.g_lbl,\n            sd_lbl=self.sd_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", "\n\nclass cap_pmos_b(pya.PCellDeclarationHelper):\n    \"\"\"\n    3.3V PMOS capacitor (inside Psub) Generator for GF180MCU\n    \"\"\"\n\n    def __init__(self):\n        # Initializing super class.\n        super().__init__()\n\n        # ===================== PARAMETERS DECLARATIONS =====================\n        self.Type_handle = self.param(\"volt\", self.TypeList, \"Voltage area\")\n        self.Type_handle.add_choice(\"3.3V\", \"3.3V\")\n        self.Type_handle.add_choice(\"5/6V\", \"5/6V\")\n\n        self.param(\"lc\", self.TypeDouble, \"Length\", default=cap_pmos_b_l, unit=\"um\")\n        self.param(\"wc\", self.TypeDouble, \"Width\", default=cap_pmos_b_w, unit=\"um\")\n        self.param(\"area\", self.TypeDouble, \"Area\", readonly=True, unit=\"um^2\")\n        self.param(\"perim\", self.TypeDouble, \"Perimeter\", readonly=True, unit=\"um\")\n\n        self.param(\"lbl\", self.TypeBoolean, \"Labels\", default=0)\n\n        self.param(\"g_lbl\", self.TypeString, \"Gate terminal label\", default=\"\")\n\n        self.param(\"sd_lbl\", self.TypeString, \"Source/Drain terminal label\", default=\"\")\n\n    def display_text_impl(self):\n        # Provide a descriptive text for the cell\n        return \"cap_pmos_b(LC=\" + (\"%.3f\" % self.lc) + \",WC=\" + (\"%.3f\" % self.wc) + \")\"\n\n    def coerce_parameters_impl(self):\n        # We employ coerce_parameters_impl to decide whether the handle or the numeric parameter has changed.\n        #  We also update the numerical value or the shape, depending on which on has not changed.\n        self.area = self.wc * self.lc\n        self.perim = 2 * (self.wc + self.lc)\n        # w,l must be larger or equal than min. values.\n        self.lc = max(self.lc, cap_pmos_b_l)\n        self.wc = max(self.wc, cap_pmos_b_w)\n\n    def can_create_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we can use any shape which\n        # has a finite bounding box\n        return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()\n\n    def parameters_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we set r and l from the shape's\n        # bounding box width and layer\n        self.r = self.shape.bbox().width() * self.layout.dbu / 2\n        self.lc = self.layout.get_info(self.lcayer)\n\n    def transformation_from_shape_impl(self):\n        # Implement the \"Create PCell from shape\" protocol: we use the center of the shape's\n        # bounding box to determine the transformation\n        return pya.Trans(self.shape.bbox().center())\n\n    def produce_impl(self):\n        np_instance = draw_cap_mos(\n            self.layout,\n            type=\"cap_pmos_b\",\n            lc=self.lc,\n            wc=self.wc,\n            volt=self.volt,\n            deepnwell=0,  # self.deepnwell,\n            pcmpgr=0,  # self.pcmpgr,\n            lbl=self.lbl,\n            g_lbl=self.g_lbl,\n            sd_lbl=self.sd_lbl,\n        )\n        write_cells = pya.CellInstArray(\n            np_instance.cell_index(),\n            pya.Trans(pya.Point(0, 0)),\n            pya.Vector(0, 0),\n            pya.Vector(0, 0),\n            1,\n            1,\n        )\n\n        self.cell.insert(write_cells)\n        self.cell.flatten(1)", ""]}
