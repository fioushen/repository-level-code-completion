{"filename": "main.py", "chunked_list": ["from datetime import datetime\nimport traceback\n\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom fastapi_limiter.depends import FastAPILimiter\nfrom sqlalchemy import text\nfrom sqlalchemy.orm import Session\nimport uvicorn\n\nfrom src.conf import messages", "\nfrom src.conf import messages\nfrom src.database.db import get_db, get_redis\nfrom src.routes import auth, comments, images, users, ratings\nfrom src.services.asyncdevlogging import async_logging_to_file\n\n\napp = FastAPI()\napp.include_router(auth.router, prefix='/api')\napp.include_router(users.router, prefix='/api')", "app.include_router(auth.router, prefix='/api')\napp.include_router(users.router, prefix='/api')\napp.include_router(images.router, prefix='/api')\napp.include_router(comments.router, prefix='/api')\napp.include_router(ratings.router, prefix='/api')\n\n\n@app.on_event('startup')\nasync def startup() -> None:\n    await FastAPILimiter.init(get_redis())", "async def startup() -> None:\n    await FastAPILimiter.init(get_redis())\n\n\n@app.get('/api/healthchecker')\nasync def healthchecker(db: Session = Depends(get_db)) -> dict:\n    \"\"\"\n    The healthchecker function is a simple function that returns a JSON object with the message 'Welcome to FastAPI!'\n    This function is used by the healthchecker endpoint, which can be accessed at http://localhost:8000/healthchecker.\n    The purpose of this endpoint is to provide an easy way for users and developers to check if the API server has been", "    This function is used by the healthchecker endpoint, which can be accessed at http://localhost:8000/healthchecker.\n    The purpose of this endpoint is to provide an easy way for users and developers to check if the API server has been\n    successfully deployed and configured. This endpoint should return a 200 status code when everything works as\n    expected.\n\n    :param db: Session: Get the database session\n    :return: A dict with the message\n    :doc-author: Trelent\n    \"\"\"\n    try:\n        # Make request\n        result = db.execute(text('SELECT 1')).fetchone()\n        if result is None:\n            function_name = traceback.extract_stack(None, 2)[1][2]\n            add_log = f'\\n500:\\t{datetime.now()}\\t{messages.MSC500_DATABASE_CONNECT}\\t{function_name}'\n            await async_logging_to_file(add_log)\n            raise HTTPException(status_code=500, detail=messages.MSC500_DATABASE_CONFIG)\n\n        function_name = traceback.extract_stack(None, 2)[1][2]\n        add_log = f'\\n000:\\t{datetime.now()}\\t{messages.WELCOME_FASTAPI}\\t{function_name}'\n        await async_logging_to_file(add_log)\n\n        return {'message': messages.WELCOME_FASTAPI}\n\n    except Exception as e:\n        function_name = traceback.extract_stack(None, 2)[1][2]\n        add_log = f'\\n000:\\t{datetime.now()}\\t{messages.MSC500_DATABASE_CONNECT}: {e}\\t{function_name}'\n        await async_logging_to_file(add_log)\n        raise HTTPException(status_code=500, detail=messages.MSC500_DATABASE_CONNECT)", "    \"\"\"\n    try:\n        # Make request\n        result = db.execute(text('SELECT 1')).fetchone()\n        if result is None:\n            function_name = traceback.extract_stack(None, 2)[1][2]\n            add_log = f'\\n500:\\t{datetime.now()}\\t{messages.MSC500_DATABASE_CONNECT}\\t{function_name}'\n            await async_logging_to_file(add_log)\n            raise HTTPException(status_code=500, detail=messages.MSC500_DATABASE_CONFIG)\n\n        function_name = traceback.extract_stack(None, 2)[1][2]\n        add_log = f'\\n000:\\t{datetime.now()}\\t{messages.WELCOME_FASTAPI}\\t{function_name}'\n        await async_logging_to_file(add_log)\n\n        return {'message': messages.WELCOME_FASTAPI}\n\n    except Exception as e:\n        function_name = traceback.extract_stack(None, 2)[1][2]\n        add_log = f'\\n000:\\t{datetime.now()}\\t{messages.MSC500_DATABASE_CONNECT}: {e}\\t{function_name}'\n        await async_logging_to_file(add_log)\n        raise HTTPException(status_code=500, detail=messages.MSC500_DATABASE_CONNECT)", "\n\n@app.get('/')\ndef read_root() -> dict:\n    \"\"\"\n    The read_root function returns a dictionary with the key 'message' and value of `WELCOME`\n\n    :return: A dictionary with the key 'message' and the value of `welcome`\n    :doc-author: Trelent\n    \"\"\"\n    return {'message': messages.WELCOME}", "\n\nif __name__ == '__main__':\n    uvicorn.run(app, host='0.0.0.0', port=8000)\n"]}
{"filename": "tests/test_repository_images.py", "chunked_list": ["import unittest\nfrom unittest.mock import MagicMock\nfrom sqlalchemy.orm import Session\nfrom src.database.models import Image, Tag\nfrom src.schemas.images import ImageModel\n\nfrom src.repository.images import (\n    create_image,\n    get_image,\n    get_images,", "    get_image,\n    get_images,\n    transform_image,\n    remove_image,\n    update_image,\n    get_images_by_tag,\n    get_images_by_user\n)\n\n'''", "\n'''\nUnit tests for the application.\n'''\n\n'''\nTest src.repository.images \n1. create_image,\n2. get_image,\n3. get_images,", "2. get_image,\n3. get_images,\n4. transform_image,\n5. remove_image,\n6. update_image,\n7. get_images_by_tag,\n8. get_images_by_user\n'''\n\n\nclass TestImagesRepository(unittest.TestCase):\n    def setUp(self):\n        self.session = MagicMock(spec=Session)\n        self.user = {'id': 1, 'roles': 'user'}\n\n    async def test_create_image(self):\n        image = ImageModel(name='Test image', description='Test description', tags=['test', 'image'])\n        result = await create_image(body=image, user=self.user, db=self.session)\n        self.assertTrue(hasattr(result, 'id'))\n        self.assertEqual(result.description, image.description)\n        self.assertEqual(result.user_id, self.user['id'])\n        self.assertEqual(result.tags, image.tags)\n\n    async def test_get_image(self):\n        image = Image()\n        self.session.query().filter_by().first.return_value = image\n        result = await get_image(image_id=image.id, user=self.user, db=self.session)\n        self.assertEqual(image, result)\n\n    async def test_get_images(self):\n        images = [Image(), Image()]\n        self.session.query().filter_by().offset().limit().all.return_value = images\n        result = await get_images(user=self.user, db=self.session)\n        self.assertEqual(result, images)\n\n    async def test_transform_image(self):\n        image = Image()\n        self.session.query().filter_by().first.return_value = image\n        result = await transform_image(image_id=image.id, user=self.user, db=self.session)\n        self.assertEqual(image, result)\n\n    async def test_remove_image(self):\n        image = Image()\n        self.session.query().filter_by().first.return_value = image\n        result = await remove_image(image_id=image.id, user=self.user, db=self.session)\n        self.assertEqual(image, result)\n\n    async def test_update_image(self):\n        image = Image()\n        self.session.query().filter_by().first.return_value = image\n        result = await update_image(image_id=image.id, user=self.user, db=self.session)\n        self.assertEqual(image, result)\n\n    async def test_get_images_by_tag(self):\n        images = [Image(), Image()]\n        self.session.query().filter_by().offset().limit().all.return_value = images\n        result = await get_images_by_tag(tag='test', user=self.user, db=self.session)\n        self.assertEqual(result, images)\n\n    async def test_get_images_by_user(self):\n        images = [Image(), Image()]\n        self.session.query().filter_by().offset().limit().all.return_value = images\n        result = await get_images_by_user(user_id=self.user['id'], user=self.user, db=self.session)\n        self.assertEqual(result, images)", "\n\nclass TestImagesRepository(unittest.TestCase):\n    def setUp(self):\n        self.session = MagicMock(spec=Session)\n        self.user = {'id': 1, 'roles': 'user'}\n\n    async def test_create_image(self):\n        image = ImageModel(name='Test image', description='Test description', tags=['test', 'image'])\n        result = await create_image(body=image, user=self.user, db=self.session)\n        self.assertTrue(hasattr(result, 'id'))\n        self.assertEqual(result.description, image.description)\n        self.assertEqual(result.user_id, self.user['id'])\n        self.assertEqual(result.tags, image.tags)\n\n    async def test_get_image(self):\n        image = Image()\n        self.session.query().filter_by().first.return_value = image\n        result = await get_image(image_id=image.id, user=self.user, db=self.session)\n        self.assertEqual(image, result)\n\n    async def test_get_images(self):\n        images = [Image(), Image()]\n        self.session.query().filter_by().offset().limit().all.return_value = images\n        result = await get_images(user=self.user, db=self.session)\n        self.assertEqual(result, images)\n\n    async def test_transform_image(self):\n        image = Image()\n        self.session.query().filter_by().first.return_value = image\n        result = await transform_image(image_id=image.id, user=self.user, db=self.session)\n        self.assertEqual(image, result)\n\n    async def test_remove_image(self):\n        image = Image()\n        self.session.query().filter_by().first.return_value = image\n        result = await remove_image(image_id=image.id, user=self.user, db=self.session)\n        self.assertEqual(image, result)\n\n    async def test_update_image(self):\n        image = Image()\n        self.session.query().filter_by().first.return_value = image\n        result = await update_image(image_id=image.id, user=self.user, db=self.session)\n        self.assertEqual(image, result)\n\n    async def test_get_images_by_tag(self):\n        images = [Image(), Image()]\n        self.session.query().filter_by().offset().limit().all.return_value = images\n        result = await get_images_by_tag(tag='test', user=self.user, db=self.session)\n        self.assertEqual(result, images)\n\n    async def test_get_images_by_user(self):\n        images = [Image(), Image()]\n        self.session.query().filter_by().offset().limit().all.return_value = images\n        result = await get_images_by_user(user_id=self.user['id'], user=self.user, db=self.session)\n        self.assertEqual(result, images)", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "tests/test_routes_images.py", "chunked_list": ["from unittest.mock import patch, AsyncMock, MagicMock\n\nimport unittest.mock as um\n\nfrom src.conf import messages\nfrom src.services.auth import AuthUser\nfrom src.database.models import User, Image\n\n'''\nIntegration tests for the application.", "'''\nIntegration tests for the application.\n'''\n\n'''\nTest src.routes.comments\n1. test_create_image\n2. test_get_image\n3. test_get_images\n4. test_get_image_by_tag_name", "3. test_get_images\n4. test_get_image_by_tag_name\n5. test_get_image_by_user\n6. test_update_image\n7. test_remove_image\n8. test_transforme_image\n9. test_image_qrcode\n'''\n\n\ndef test_create_image(client, session, admin, admin_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n        mock_public_id = MagicMock()\n        monkeypatch.setattr('src.services.images.CloudImage.generate_name_image', mock_public_id)\n        mock_r = MagicMock()\n        monkeypatch.setattr('src.services.images.CloudImage.image_upload', mock_r)\n        mock_src_url = MagicMock()\n        mock_src_url.return_value = 'some url'\n        monkeypatch.setattr('src.services.images.CloudImage.get_url_for_image', mock_src_url)\n        current_user = session.query(User).filter_by(email=admin.get('email')).first()\n        session.expunge(current_user)\n\n        with um.patch('builtins.open', um.mock_open(read_data='test')) as mock_file:\n            response = client.post(\n                '/api/images/',\n                params={'description': image['description'], 'tags': image['tags']},\n\n                files={'file': ('filename', open(mock_file, 'rb'), 'image/jpeg')},\n                headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n            )\n        assert response.status_code == 200, response.text\n        data = response.json()\n        assert data['description'] == image['description']\n        assert data['tags'][0]['name'] == image['tags'].split()[0]\n        assert data['user_id'] == current_user.id\n        assert 'id' in data", "\n\ndef test_create_image(client, session, admin, admin_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n        mock_public_id = MagicMock()\n        monkeypatch.setattr('src.services.images.CloudImage.generate_name_image', mock_public_id)\n        mock_r = MagicMock()\n        monkeypatch.setattr('src.services.images.CloudImage.image_upload', mock_r)\n        mock_src_url = MagicMock()\n        mock_src_url.return_value = 'some url'\n        monkeypatch.setattr('src.services.images.CloudImage.get_url_for_image', mock_src_url)\n        current_user = session.query(User).filter_by(email=admin.get('email')).first()\n        session.expunge(current_user)\n\n        with um.patch('builtins.open', um.mock_open(read_data='test')) as mock_file:\n            response = client.post(\n                '/api/images/',\n                params={'description': image['description'], 'tags': image['tags']},\n\n                files={'file': ('filename', open(mock_file, 'rb'), 'image/jpeg')},\n                headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n            )\n        assert response.status_code == 200, response.text\n        data = response.json()\n        assert data['description'] == image['description']\n        assert data['tags'][0]['name'] == image['tags'].split()[0]\n        assert data['user_id'] == current_user.id\n        assert 'id' in data", "\n\ndef test_create_image_by_user(client, session, user, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n        mock_public_id = MagicMock()\n        monkeypatch.setattr('src.services.images.CloudImage.generate_name_image', mock_public_id)\n        mock_r = MagicMock()\n        monkeypatch.setattr('src.services.images.CloudImage.image_upload', mock_r)\n        mock_src_url = MagicMock()\n        mock_src_url.return_value = 'some url'\n        monkeypatch.setattr('src.services.images.CloudImage.get_url_for_image', mock_src_url)\n        current_user = session.query(User).filter_by(email=user.get('email')).first()\n        session.expunge(current_user)\n\n        with um.patch('builtins.open', um.mock_open(read_data='test')) as mock_file:\n            response = client.post(\n                '/api/images/',\n                params={'description': image['description'], 'tags': image['tags']},\n\n                files={'file': ('filename', open(mock_file, 'rb'), 'image/jpeg')},\n                headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n            )\n        assert response.status_code == 200, response.text\n        data = response.json()\n        assert data['description'] == image['description']\n        assert data['tags'][0]['name'] == image['tags'].split()[0]\n        assert data['user_id'] == current_user.id\n        assert 'id' in data", "\n\ndef test_create_image_toomanytags(client, session, user, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n        mock_public_id = MagicMock()\n        monkeypatch.setattr('src.services.images.CloudImage.generate_name_image', mock_public_id)\n        mock_r = MagicMock()\n        monkeypatch.setattr('src.services.images.CloudImage.image_upload', mock_r)\n        mock_src_url = MagicMock()\n        mock_src_url.return_value = 'some url'\n        monkeypatch.setattr('src.services.images.CloudImage.get_url_for_image', mock_src_url)\n        user = session.query(User).filter_by(email=user.get('email')).first()\n        session.expunge(user)\n        tags = ' '.join(['tag' for i in range(11)])\n        with um.patch('builtins.open', um.mock_open(read_data='test')) as mock_file:\n            response = client.post(\n                '/api/images/',\n                params={'description': image['description'], 'tags': tags},\n\n                files={'file': ('filename', open(mock_file, 'rb'), 'image/jpeg')},\n                headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n            )\n        assert response.status_code == 409, response.text\n        data = response.json()\n        assert data['detail'] == messages.MSC409_TAGS", "\n\ndef test_create_image_no_token(client, session, user, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n        mock_public_id = MagicMock()\n        monkeypatch.setattr('src.services.images.CloudImage.generate_name_image', mock_public_id)\n        mock_r = MagicMock()\n        monkeypatch.setattr('src.services.images.CloudImage.image_upload', mock_r)\n        mock_src_url = MagicMock()\n        mock_src_url.return_value = 'some url'\n        monkeypatch.setattr('src.services.images.CloudImage.get_url_for_image', mock_src_url)\n        user = session.query(User).filter_by(email=user.get('email')).first()\n        session.expunge(user)\n\n        with um.patch('builtins.open', um.mock_open(read_data='test')) as mock_file:\n            response = client.post(\n                '/api/images/',\n                params={'description': image['description'], 'tags': image['tags']},\n\n                files={'file': ('filename', open(mock_file, 'rb'), 'image/jpeg')},\n                # headers={'Authorization': f'Bearer some_token'}\n            )\n        assert response.status_code == 401, response.text\n        data = response.json()\n        assert data['detail'] == 'Not authenticated'", "\n\ndef test_get_image(client, session, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        response = client.get(\n            '/api/images/1',\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 200, response.text\n        assert type(data) == dict\n        assert data['description'] == image['description']\n        assert 'id' in data", "\n\ndef test_image_no_such_image(client, session, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        response = client.get(\n            '/api/images/999',\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 404, response.text\n        assert data['detail'] == messages.MSC404_IMAGE_NOT_FOUND", "\n\ndef test_get_images(client, session, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        response = client.get(\n            '/api/images/',\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 200, response.text\n        assert type(data) == dict\n        assert data['items'][0]['description'] == image['description']\n        assert 'id' in data['items'][0]", "\n\ndef test_get_images_not_authenticated(client, session, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        response = client.get(\n            '/api/images/',\n            # headers={'Authorization': f'Bearer {token['access_token']}'}\n        )\n        assert response.status_code == 401, response.text\n        data = response.json()\n        assert data['detail'] == 'Not authenticated'", "\n\ndef test_get_image_by_tag_name(client, session, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        response = client.get(\n                              f'''api//images/search_bytag/{image['tags'].split()[0]}''',\n                              params={'sort_direction': 'asc'},\n                              headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n                              )\n        data = response.json()\n        assert response.status_code == 200, response.text\n        assert type(data) == list\n        assert data[0]['description'] == image['description']\n        assert 'id' in data[0]", "\n\ndef test_get_image_by_tag_name_no_tags(client, session, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        response = client.get(\n            # f'api//images/search_bytag/{image['tags'].split()[0]}',\n            f'api//images/search_bytag/no_tag',\n            params={'sort_direction': 'asc'},\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 404, response.text\n        assert data['detail'] == messages.MSC404_TAG_NOT_FOUND", "\n\ndef test_get_image_by_user_userrole(client, session, user_token, user, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        user = session.query(User).filter_by(email=user.get('email')).first()\n\n        response = client.get(\n            f'/api/images/search_byuser/{user.id}',\n            params={'sort_direction': 'asc'},\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 403, response.text\n        assert data['detail'] == messages.MSC403_FORBIDDEN", "\n\ndef test_get_image_by_user_adminrole(client, session, admin_token, user, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        user = session.query(User).filter_by(email=user.get('email')).first()\n        session.expunge(user)\n\n        response = client.get(\n            f'/api/images/search_byuser/{user.id}',\n            params={'sort_direction': 'asc'},\n            headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 200, response.text\n        assert type(data) == list\n        assert data[0]['user_id'] == user.id", "\n\ndef test_get_image_by_user_no_user(client, session, admin_token, user, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        response = client.get(\n            f'/api/images/search_byuser/9999',\n            params={'sort_direction': 'asc'},\n            headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 404, response.text\n        assert data['detail'] == messages.MSC404_USER_NOT_FOUND", "\n\ndef test_transforme_image(client, session, user, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        user = session.query(User).filter_by(email=user.get('email')).first()\n        test_image = session.query(Image).filter_by(user_id=user.id).first()\n\n        response = client.post(\n            f'/api/images/transformation/{test_image.id}',\n            params={'type': 'black_white'},\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 200, response.text\n        assert type(data) == dict\n        assert 'e_grayscale' in data['link']", "\n\ndef test_transforme_foreign_image(client, session, admin, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        admin = session.query(User).filter_by(email=admin.get('email')).first()\n        test_image = session.query(Image).filter_by(user_id=admin.id).first()\n\n        response = client.post(\n            f'/api/images/transformation/{test_image.id}',\n            params={'type': 'black_white'},\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 400, response.text\n        assert data['detail'] == messages.MSC400_BAD_REQUEST", "\n\ndef test_transforme_image_not_found(client, session, user, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        # user = session.query(User).filter_by(email=user.get('email')).first()\n        # test_image = session.query(Image).filter_by(user_id=user.id).first()\n\n        response = client.post(\n            f'/api/images/transformation/9999',\n            params={'type': 'black_white'},\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 404, response.text\n        assert data['detail'] == messages.MSC404_IMAGE_NOT_FOUND", "\n\ndef test_image_qrcode(client, session, user, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        user = session.query(User).filter_by(email=user.get('email')).first()\n        test_image = session.query(Image).filter_by(user_id=user.id).first()\n\n        response = client.get(\n            f'/api/images/qrcode/{test_image.id}',\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n\n        assert response.status_code == 200\n        assert response.headers['Content-Type'] == 'image/png'\n        assert type(response._content) is bytes", "\n\ndef test_image_qrcode_not_found(client, session, user, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        # user = session.query(User).filter_by(email=user.get('email')).first()\n        # test_image = session.query(Image).filter_by(user_id=user.id).first()\n\n        response = client.get(\n            f'/api/images/qrcode/9999',\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n\n        data = response.json()\n        assert response.status_code == 404, response.text\n        assert data['detail'] == messages.MSC404_IMAGE_NOT_FOUND", "\n\ndef test_update_image(client, session, user, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        user = session.query(User).filter_by(email=user.get('email')).first()\n        test_image = session.query(Image).filter_by(user_id=user.id).first()\n\n        response = client.put(\n            f'/api/images/{test_image.id}',\n            json={'description': 'update description', 'tags': 'update_tag'},\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 200, response.text\n        assert type(data) == dict\n        assert data['description'] == 'update description'\n        assert data['tags'][0]['name'] == 'update_tag'\n        assert 'id' in data", "\n\ndef test_update_foreign_image_by_user(client, session, admin, user_token, image, monkeypatch):\n    # image.id = 1 user.id = 1 roles = admin\n    # image.id = 2 user.id = 2 roles = user\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        admin = session.query(User).filter_by(email=admin.get('email')).first()\n        test_image = session.query(Image).filter_by(user_id=admin.id).first()\n\n        response = client.put(\n            f'/api/images/{test_image.id}',\n            json={'description': 'update description', 'tags': 'update_tag'},\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 404, response.text\n        assert data['detail'] == messages.MSC404_IMAGE_NOT_FOUND", "\n\ndef test_update_foreign_image_by_admin(client, session, user, admin_token, image, monkeypatch):\n    # image.id = 1 user.id = 1 roles = admin\n    # image.id = 2 user.id = 2 roles = user\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        user = session.query(User).filter_by(email=user.get('email')).first()\n        test_image = session.query(Image).filter_by(user_id=user.id).first()\n\n        response = client.put(\n            f'/api/images/{test_image.id}',\n            json={'description': 'update description', 'tags': 'update_tag'},\n            headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 200, response.text\n        assert type(data) == dict\n        assert data['description'] == 'update description'\n        assert data['tags'][0]['name'] == 'update_tag'\n        assert 'id' in data", "\n\ndef test_remove_image(client, session, user, user_token, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        user = session.query(User).filter_by(email=user.get('email')).first()\n        test_image = session.query(Image).filter_by(user_id=user.id).first()\n\n        response = client.delete(\n            f'/api/images/{test_image.id}',\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 200, response.text\n        assert data['message'] == messages.IMAGE_DELETED\n        assert session.query(Image).filter_by(id=test_image.id).first() is None", "\n\ndef test_remove_foreign_image_by_user(client, session, admin, user_token, image, monkeypatch):\n    # image.id = 1 user.id = 1 roles = admin\n    # image.id = 2 user.id = 2 roles = user\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        admin = session.query(User).filter_by(email=admin.get('email')).first()\n        test_image = session.query(Image).filter_by(user_id=admin.id).first()\n\n        response = client.delete(\n            f'/api/images/{test_image.id}',\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 404, response.text\n        assert data['detail'] == messages.MSC404_IMAGE_NOT_FOUND", "\n\ndef test_remove_foreign_image_by_admin(client, session, user, admin_token, image, monkeypatch):\n    # image.id = 1 user.id = 1 roles = admin\n    # image.id = 2 user.id = 2 roles = user\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        user = session.query(User).filter_by(email=user.get('email')).first()\n        test_image = session.query(Image).filter_by(user_id=user.id).first()\n\n        response = client.delete(\n            f'/api/images/{test_image.id}',\n            headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 200, response.text\n        assert data['message'] == messages.IMAGE_DELETED\n        assert session.query(Image).filter_by(id=test_image.id).first() is None", "\n\ndef test_get_image_by_user_no_image(client, session, admin_token, user, image, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        user = session.query(User).filter_by(email=user.get('email')).first()\n        session.expunge(user)\n        images = session.query(Image).all()\n\n        response = client.get(\n            f'/api/images/search_byuser/{user.id}',\n            params={'sort_direction': 'asc'},\n            headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 404, response.text\n        assert data['detail'] == messages.MSC404_IMAGE_NOT_FOUND", ""]}
{"filename": "tests/test_repository_users.py", "chunked_list": ["from datetime import datetime\nfrom fastapi import HTTPException\nimport unittest\nfrom unittest.mock import MagicMock\n\nfrom pydantic import EmailStr\nfrom sqlalchemy.orm import Session\n\nfrom src.database.models import Role, User\nfrom src.repository.users import (", "from src.database.models import Role, User\nfrom src.repository.users import (\n                                  get_user_by_email,\n                                  get_user_by_id,\n                                  create_user,\n                                  change_password_for_user,\n                                  update_token,\n                                  confirmed_email,\n                                  update_avatar,\n                                  get_number_of_images_per_user,", "                                  update_avatar,\n                                  get_number_of_images_per_user,\n                                  update_user_profile,\n                                  update_your_profile,\n                                  ban_user,\n                                  )\nfrom src.schemas.users import UserBase, UserModel, UserType\n\nclass TestUsers(unittest.IsolatedAsyncioTestCase):\n    @classmethod\n    def setUpClass(cls):\n        \"\"\"Start before all test.\"\"\"\n        cls.password = 'new_passw0rd'\n        cls.email = 'Unknown2@mail.com'\n        cls.user_id = 3\n        cls.role = UserType(\n                            username='NewName',\n                            email=EmailStr('Unknown3@mail.com'),\n                            roles='moderator'\n                            )\n        cls.body_base = UserBase(\n                                 username='NewName', \n                                 email=EmailStr('NewEMail@mail.com')\n                                 )\n        cls.body_user_model = UserModel(\n                                        username='Unknown2', \n                                        email=EmailStr('Unknown2@mail.com'),\n                                        password='Qwerty@123',\n                                        )\n        cls.admin = User(\n                         id=1, \n                         username='Admin', \n                         email=EmailStr('Unknown1@mail.com'),\n                         password='Qwerty@123',\n                         created_at=datetime.now(),\n                         updated_at=datetime.now(),\n                         avatar='default',\n                         refresh_token='eyJhb...-iV1MI',\n                         roles=Role.admin,\n                         confirmed=True,\n                         status_active=True\n                         )\n        cls.user = User(\n                        id=2, \n                        username='User', \n                        email=EmailStr('Unknown2@mail.com'),\n                        password='Qwerty@123',\n                        created_at=datetime.now(),\n                        updated_at=datetime.now(),\n                        avatar='non-standard',\n                        refresh_token='ey.....37Ns5pX-iV1MI',\n                        roles=Role.user,\n                        confirmed=False,\n                        status_active=True\n                        )\n\n    # @classmethod\n    # def tearDownClass(cls):\n    #     \"\"\"Start after all test.\"\"\"\n    #     ...\n\n    def setUp(self):\n        \"\"\"Start before each test.\"\"\"\n        self.session = MagicMock(spec=Session)\n\n    # def tearDown(self):\n    #     \"\"\"Start after each test.\"\"\"\n    #     ...\n\n    async def test_get_user_by_email_found(self):\n        self.session.query().filter().first.return_value = TestUsers.user\n        result = await get_user_by_email(email=self.user.email, db=self.session)\n        self.assertIsInstance(result, User)\n        self.assertEqual(result, TestUsers.user)\n        [self.assertEqual(result.__dict__[el], TestUsers.user.__dict__[el])\n            for el in TestUsers.user.__dict__]\n\n    async def test_get_user_by_email_not_found(self):\n        self.session.query().filter().first.return_value = None\n        result = await get_user_by_email(email=self.email, db=self.session)  # self.email === TestUsers.email\n        self.assertIsNone(result)\n    \n    async def test_get_user_by_id_found(self):\n        self.session.query().filter().first.return_value = TestUsers.user\n        result = await get_user_by_id(user_id=self.user.id, db=self.session)\n        self.assertIsInstance(result, User)\n        self.assertEqual(result, TestUsers.user)\n        [self.assertEqual(result.__dict__[el], TestUsers.user.__dict__[el])\n            for el in TestUsers.user.__dict__]\n    \n    async def test_get_user_by_id_not_found(self):\n        self.session.query().filter().first.return_value = None\n        result = await get_user_by_id(user_id=self.user_id, db=self.session)\n        self.assertIsNone(result)\n\n    async def test_create_user_first_success(self):  # admin\n        self.session.query().first.return_value = None\n        result: User = await create_user(body=TestUsers.body_user_model, db=self.session)\n        [self.assertTrue(hasattr(result, el)) for el in TestUsers.admin.__dict__]\n        [self.assertEqual(result.__dict__[el], TestUsers.body_user_model.__dict__[el]) for el in TestUsers.body_user_model.__dict__]\n        self.assertEqual(result.roles, TestUsers.admin.roles)\n    \n    async def test_create_user_success(self):  # user\n        self.session.query().first.return_value = TestUsers.admin\n        result: User = await create_user(body=TestUsers.body_user_model, db=self.session)\n        [self.assertTrue(hasattr(result, el)) for el in TestUsers.admin.__dict__]\n        [self.assertEqual(result.__dict__[el], TestUsers.body_user_model.__dict__[el]) for el in TestUsers.body_user_model.__dict__]\n        self.assertEqual(result.roles, TestUsers.user.roles)\n    \n    async def test_create_user_fail(self):  # in auth-rout when signUp\n        return\n\n    async def test_change_password_for_user(self):\n        result: User = await change_password_for_user(user=TestUsers.user, password=self.password, db=self.session)\n        [self.assertTrue(hasattr(result, el)) for el in TestUsers.user.__dict__]\n        self.assertEqual(result.password, self.password)\n    \n    async def test_update_token(self):\n        result: User = await update_token(user=TestUsers.user, token=self.admin.refresh_token, db=self.session)\n        self.assertEqual(self.user.refresh_token, self.admin.refresh_token)\n        self.assertIsNone(result)\n        \n    async def test_confirmed_email(self):\n        self.assertEqual(self.user.confirmed, False)\n        result: User = await confirmed_email(user=TestUsers.user, db=self.session)\n        self.assertEqual(self.user.confirmed, True)\n        self.assertIsNone(result)\n\n    async def test_update_avatar_success(self):\n        self.session.query().filter().first.return_value = TestUsers.admin\n        result: User = await update_avatar(email=TestUsers.admin.email, url=TestUsers.user.avatar, db=self.session)\n        [self.assertTrue(hasattr(result, el)) for el in TestUsers.admin.__dict__]\n        self.assertEqual(TestUsers.admin.avatar, TestUsers.user.avatar)\n    \n    async def test_update_avatar_fail(self):\n        self.session.query().filter().first.return_value = None\n        result = await update_avatar(email=self.email, url=TestUsers.user.avatar, db=self.session)\n        self.assertIsNone(result)\n    \n    async def test_get_number_of_images_per_user(self):\n        self.session.query().filter().count.return_value = 0\n        result: User = await get_number_of_images_per_user(email=TestUsers.admin.email, db=self.session)\n        self.assertEqual(result, 0)\n        self.session.query().filter().count.return_value = 17\n        result: User = await get_number_of_images_per_user(email=TestUsers.admin.email, db=self.session)\n        self.assertEqual(result, 17)\n    \n    async def test_update_user_profile_success(self):\n        self.session.query().filter().first.return_value = TestUsers.user\n        result: User = await update_user_profile(\n                                                 user_id=TestUsers.user.id, \n                                                 current_user=TestUsers.admin.__dict__,\n                                                 body_data=self.role,\n                                                 db=self.session\n                                                 )\n        [self.assertTrue(hasattr(result, el)) for el in TestUsers.user.__dict__]\n        self.assertEqual(result.roles, TestUsers.user.roles)\n        self.assertEqual(self.role.roles, TestUsers.user.roles.value)\n    \n    async def test_update_user_profile_fails(self):\n        self.session.query().filter().first.return_value = None\n        result: None = await update_user_profile(\n                                                 user_id=TestUsers.user.id, \n                                                 current_user=TestUsers.admin.__dict__,\n                                                 body_data=self.role,\n                                                 db=self.session\n                                                 )\n        self.assertIsNone(result)\n\n        self.session.query().filter().first.return_value = TestUsers.user\n        result: User = await update_user_profile(\n                                                 user_id=TestUsers.user.id, \n                                                 current_user=TestUsers.admin.__dict__,\n                                                 body_data=None,\n                                                 db=self.session\n                                                 )\n        self.assertIsNone(result)\n\n        self.session.query().filter().first.return_value = TestUsers.user\n        result: User = await update_user_profile(\n                                                 user_id=TestUsers.user.id, \n                                                 current_user=TestUsers.user.__dict__,\n                                                 body_data=self.role,\n                                                 db=self.session\n                                                 )\n        self.assertIsNone(result)\n\n        self.session.query().filter().first.return_value = TestUsers.admin\n        result: User = await update_user_profile(\n                                                 user_id=TestUsers.admin.id, \n                                                 current_user=TestUsers.admin.__dict__,\n                                                 body_data=self.role,\n                                                 db=self.session\n                                                 )\n        self.assertIsNone(result)\n\n    async def test_update_your_profile_success(self):\n        self.session.query().filter().first.return_value = TestUsers.admin\n        result: User = await update_your_profile(\n                                                 email=TestUsers.admin.email, \n                                                 body_data=self.body_base, \n                                                 db=self.session\n                                                 )\n        [self.assertTrue(hasattr(result, el)) for el in TestUsers.admin.__dict__]\n        [self.assertEqual(result.__dict__[el], self.body_base.__dict__[el]) for el in self.body_base.__dict__]\n    \n    async def test_update_your_profile_fail(self):\n        self.session.query().filter().first.return_value = None\n        result = await update_your_profile(email=TestUsers.admin.email, body_data=self.body_base, db=self.session)\n        self.assertIsNone(result)\n        self.session.query().filter().first.return_value = TestUsers.admin\n        result = await update_your_profile(email=TestUsers.admin.email, body_data=None, db=self.session)\n        self.assertIsNone(result)\n    \n    async def test_ban_user_success(self):\n        self.assertEqual(self.user.status_active, True)\n        self.session.query().filter_by().first.return_value = TestUsers.user\n        result: User = await ban_user(user_id=TestUsers.user.id, active_status=False, db=self.session)\n        [self.assertTrue(hasattr(result, el)) for el in TestUsers.user.__dict__]\n        self.assertEqual(result.status_active, False)\n        self.assertEqual(self.user.status_active, False)\n\n    async def test_ban_user_fail(self):\n        self.session.query().filter_by().first.return_value = None\n        result = await ban_user(user_id=TestUsers.user_id, active_status=False, db=self.session)\n        self.assertIsNone(result)\n        self.session.query().filter_by().first.return_value = TestUsers.admin\n        with self.assertRaises(HTTPException) as context:\n            await ban_user(user_id=TestUsers.admin.id, active_status=False, db=self.session)\n        self.assertTrue(context.exception)", "class TestUsers(unittest.IsolatedAsyncioTestCase):\n    @classmethod\n    def setUpClass(cls):\n        \"\"\"Start before all test.\"\"\"\n        cls.password = 'new_passw0rd'\n        cls.email = 'Unknown2@mail.com'\n        cls.user_id = 3\n        cls.role = UserType(\n                            username='NewName',\n                            email=EmailStr('Unknown3@mail.com'),\n                            roles='moderator'\n                            )\n        cls.body_base = UserBase(\n                                 username='NewName', \n                                 email=EmailStr('NewEMail@mail.com')\n                                 )\n        cls.body_user_model = UserModel(\n                                        username='Unknown2', \n                                        email=EmailStr('Unknown2@mail.com'),\n                                        password='Qwerty@123',\n                                        )\n        cls.admin = User(\n                         id=1, \n                         username='Admin', \n                         email=EmailStr('Unknown1@mail.com'),\n                         password='Qwerty@123',\n                         created_at=datetime.now(),\n                         updated_at=datetime.now(),\n                         avatar='default',\n                         refresh_token='eyJhb...-iV1MI',\n                         roles=Role.admin,\n                         confirmed=True,\n                         status_active=True\n                         )\n        cls.user = User(\n                        id=2, \n                        username='User', \n                        email=EmailStr('Unknown2@mail.com'),\n                        password='Qwerty@123',\n                        created_at=datetime.now(),\n                        updated_at=datetime.now(),\n                        avatar='non-standard',\n                        refresh_token='ey.....37Ns5pX-iV1MI',\n                        roles=Role.user,\n                        confirmed=False,\n                        status_active=True\n                        )\n\n    # @classmethod\n    # def tearDownClass(cls):\n    #     \"\"\"Start after all test.\"\"\"\n    #     ...\n\n    def setUp(self):\n        \"\"\"Start before each test.\"\"\"\n        self.session = MagicMock(spec=Session)\n\n    # def tearDown(self):\n    #     \"\"\"Start after each test.\"\"\"\n    #     ...\n\n    async def test_get_user_by_email_found(self):\n        self.session.query().filter().first.return_value = TestUsers.user\n        result = await get_user_by_email(email=self.user.email, db=self.session)\n        self.assertIsInstance(result, User)\n        self.assertEqual(result, TestUsers.user)\n        [self.assertEqual(result.__dict__[el], TestUsers.user.__dict__[el])\n            for el in TestUsers.user.__dict__]\n\n    async def test_get_user_by_email_not_found(self):\n        self.session.query().filter().first.return_value = None\n        result = await get_user_by_email(email=self.email, db=self.session)  # self.email === TestUsers.email\n        self.assertIsNone(result)\n    \n    async def test_get_user_by_id_found(self):\n        self.session.query().filter().first.return_value = TestUsers.user\n        result = await get_user_by_id(user_id=self.user.id, db=self.session)\n        self.assertIsInstance(result, User)\n        self.assertEqual(result, TestUsers.user)\n        [self.assertEqual(result.__dict__[el], TestUsers.user.__dict__[el])\n            for el in TestUsers.user.__dict__]\n    \n    async def test_get_user_by_id_not_found(self):\n        self.session.query().filter().first.return_value = None\n        result = await get_user_by_id(user_id=self.user_id, db=self.session)\n        self.assertIsNone(result)\n\n    async def test_create_user_first_success(self):  # admin\n        self.session.query().first.return_value = None\n        result: User = await create_user(body=TestUsers.body_user_model, db=self.session)\n        [self.assertTrue(hasattr(result, el)) for el in TestUsers.admin.__dict__]\n        [self.assertEqual(result.__dict__[el], TestUsers.body_user_model.__dict__[el]) for el in TestUsers.body_user_model.__dict__]\n        self.assertEqual(result.roles, TestUsers.admin.roles)\n    \n    async def test_create_user_success(self):  # user\n        self.session.query().first.return_value = TestUsers.admin\n        result: User = await create_user(body=TestUsers.body_user_model, db=self.session)\n        [self.assertTrue(hasattr(result, el)) for el in TestUsers.admin.__dict__]\n        [self.assertEqual(result.__dict__[el], TestUsers.body_user_model.__dict__[el]) for el in TestUsers.body_user_model.__dict__]\n        self.assertEqual(result.roles, TestUsers.user.roles)\n    \n    async def test_create_user_fail(self):  # in auth-rout when signUp\n        return\n\n    async def test_change_password_for_user(self):\n        result: User = await change_password_for_user(user=TestUsers.user, password=self.password, db=self.session)\n        [self.assertTrue(hasattr(result, el)) for el in TestUsers.user.__dict__]\n        self.assertEqual(result.password, self.password)\n    \n    async def test_update_token(self):\n        result: User = await update_token(user=TestUsers.user, token=self.admin.refresh_token, db=self.session)\n        self.assertEqual(self.user.refresh_token, self.admin.refresh_token)\n        self.assertIsNone(result)\n        \n    async def test_confirmed_email(self):\n        self.assertEqual(self.user.confirmed, False)\n        result: User = await confirmed_email(user=TestUsers.user, db=self.session)\n        self.assertEqual(self.user.confirmed, True)\n        self.assertIsNone(result)\n\n    async def test_update_avatar_success(self):\n        self.session.query().filter().first.return_value = TestUsers.admin\n        result: User = await update_avatar(email=TestUsers.admin.email, url=TestUsers.user.avatar, db=self.session)\n        [self.assertTrue(hasattr(result, el)) for el in TestUsers.admin.__dict__]\n        self.assertEqual(TestUsers.admin.avatar, TestUsers.user.avatar)\n    \n    async def test_update_avatar_fail(self):\n        self.session.query().filter().first.return_value = None\n        result = await update_avatar(email=self.email, url=TestUsers.user.avatar, db=self.session)\n        self.assertIsNone(result)\n    \n    async def test_get_number_of_images_per_user(self):\n        self.session.query().filter().count.return_value = 0\n        result: User = await get_number_of_images_per_user(email=TestUsers.admin.email, db=self.session)\n        self.assertEqual(result, 0)\n        self.session.query().filter().count.return_value = 17\n        result: User = await get_number_of_images_per_user(email=TestUsers.admin.email, db=self.session)\n        self.assertEqual(result, 17)\n    \n    async def test_update_user_profile_success(self):\n        self.session.query().filter().first.return_value = TestUsers.user\n        result: User = await update_user_profile(\n                                                 user_id=TestUsers.user.id, \n                                                 current_user=TestUsers.admin.__dict__,\n                                                 body_data=self.role,\n                                                 db=self.session\n                                                 )\n        [self.assertTrue(hasattr(result, el)) for el in TestUsers.user.__dict__]\n        self.assertEqual(result.roles, TestUsers.user.roles)\n        self.assertEqual(self.role.roles, TestUsers.user.roles.value)\n    \n    async def test_update_user_profile_fails(self):\n        self.session.query().filter().first.return_value = None\n        result: None = await update_user_profile(\n                                                 user_id=TestUsers.user.id, \n                                                 current_user=TestUsers.admin.__dict__,\n                                                 body_data=self.role,\n                                                 db=self.session\n                                                 )\n        self.assertIsNone(result)\n\n        self.session.query().filter().first.return_value = TestUsers.user\n        result: User = await update_user_profile(\n                                                 user_id=TestUsers.user.id, \n                                                 current_user=TestUsers.admin.__dict__,\n                                                 body_data=None,\n                                                 db=self.session\n                                                 )\n        self.assertIsNone(result)\n\n        self.session.query().filter().first.return_value = TestUsers.user\n        result: User = await update_user_profile(\n                                                 user_id=TestUsers.user.id, \n                                                 current_user=TestUsers.user.__dict__,\n                                                 body_data=self.role,\n                                                 db=self.session\n                                                 )\n        self.assertIsNone(result)\n\n        self.session.query().filter().first.return_value = TestUsers.admin\n        result: User = await update_user_profile(\n                                                 user_id=TestUsers.admin.id, \n                                                 current_user=TestUsers.admin.__dict__,\n                                                 body_data=self.role,\n                                                 db=self.session\n                                                 )\n        self.assertIsNone(result)\n\n    async def test_update_your_profile_success(self):\n        self.session.query().filter().first.return_value = TestUsers.admin\n        result: User = await update_your_profile(\n                                                 email=TestUsers.admin.email, \n                                                 body_data=self.body_base, \n                                                 db=self.session\n                                                 )\n        [self.assertTrue(hasattr(result, el)) for el in TestUsers.admin.__dict__]\n        [self.assertEqual(result.__dict__[el], self.body_base.__dict__[el]) for el in self.body_base.__dict__]\n    \n    async def test_update_your_profile_fail(self):\n        self.session.query().filter().first.return_value = None\n        result = await update_your_profile(email=TestUsers.admin.email, body_data=self.body_base, db=self.session)\n        self.assertIsNone(result)\n        self.session.query().filter().first.return_value = TestUsers.admin\n        result = await update_your_profile(email=TestUsers.admin.email, body_data=None, db=self.session)\n        self.assertIsNone(result)\n    \n    async def test_ban_user_success(self):\n        self.assertEqual(self.user.status_active, True)\n        self.session.query().filter_by().first.return_value = TestUsers.user\n        result: User = await ban_user(user_id=TestUsers.user.id, active_status=False, db=self.session)\n        [self.assertTrue(hasattr(result, el)) for el in TestUsers.user.__dict__]\n        self.assertEqual(result.status_active, False)\n        self.assertEqual(self.user.status_active, False)\n\n    async def test_ban_user_fail(self):\n        self.session.query().filter_by().first.return_value = None\n        result = await ban_user(user_id=TestUsers.user_id, active_status=False, db=self.session)\n        self.assertIsNone(result)\n        self.session.query().filter_by().first.return_value = TestUsers.admin\n        with self.assertRaises(HTTPException) as context:\n            await ban_user(user_id=TestUsers.admin.id, active_status=False, db=self.session)\n        self.assertTrue(context.exception)", "\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "tests/test_route_users.py", "chunked_list": ["from fastapi import status\n\n# import pytest\n# from sqlalchemy import select\n\nfrom src.conf import messages\nfrom src.schemas.users import UserDb, UserResponseFull\n\n\ndef test_read_users_me(client, access_token):\n    response = client.get('api/users/me/')\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    headers = {'Authorization': f'Bearer {access_token}'}\n    response = client.get('api/users/me/', headers=headers)\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    expected_response: dict = UserDb.__fields__\n\n    for field in expected_response:\n        assert field in data", "\ndef test_read_users_me(client, access_token):\n    response = client.get('api/users/me/')\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    headers = {'Authorization': f'Bearer {access_token}'}\n    response = client.get('api/users/me/', headers=headers)\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    expected_response: dict = UserDb.__fields__\n\n    for field in expected_response:\n        assert field in data", "\n    \ndef test_read_user_by_id(client, access_token):\n    response = client.get('api/users/1/')\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    headers = {'Authorization': f'Bearer {access_token}'}\n    response = client.get('api/users/1000/', headers=headers)\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n    assert 'detail' in response.json()\n    assert response.json()['detail'] == messages.MSC404_USER_NOT_FOUND\n\n    response = client.get('api/users/1/', headers=headers)\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    expected_response: dict = UserResponseFull.__fields__\n\n    for field in expected_response:\n        assert field in data", "\n\ndef test_update_user_profile(client, admin, access_token, user, access_token_user):  # ! need\n    response = client.put('api/users/1/', json=admin)\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    headers = {'Authorization': f'Bearer {access_token}'}\n    response = client.put('api/users/9/', headers=headers, json=admin)\n    assert 'detail' in response.json()\n    assert response.json()['detail'] == messages.MSC404_USER_NOT_FOUND \n\n    response = client.put('api/users/1/', headers=headers, json=admin)\n    assert 'detail' in response.json()\n    assert response.json()['detail'] == messages.MSC404_USER_NOT_FOUND \n\n    response = client.put('api/users/2/', headers=headers, json=user)\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    expected_response: dict = UserDb.__fields__\n\n    for field in expected_response:\n        assert field in data", "\n\ndef test_update_your_profile(client, admin, access_token, user, access_token_user):  # ! need\n    response = client.put('api/users/me/1/', json=admin)\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    headers = {'Authorization': f'Bearer {access_token}'}\n    response = client.put('api/users/me/1/', headers=headers)\n    assert 'detail' in response.json()\n    assert response.json()['detail'] == messages.MSC404_USER_NOT_FOUND \n\n    response = client.put('api/users/me/1/', headers=headers, json=admin)\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    expected_response: dict = UserDb.__fields__\n\n    for field in expected_response:\n        assert field in data", " \n \ndef test_update_avatar_user(client, admin, access_token, mocker):\n    mock_avatar = 'https://pypi.org/static/images/logo-small.2a411bc6.svg'\n    mocker.patch('src.routes.users.CloudImage.avatar_upload', return_value=mock_avatar)\n    files = {'file': 'avatar_1.svg'}\n\n    response = client.patch('api/users/avatar', files=files)\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    headers = {'Authorization': f'Bearer {access_token}'}\n    response = client.patch('api/users/avatar', headers=headers, files=files)\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    expected_response: dict = UserDb.__fields__\n\n    for field in expected_response:\n        assert field in data\n\n    assert response.json()['email'] == admin['email']\n    assert response.json()['avatar'] == mock_avatar", "    \n\ndef test_ban_user(client, access_token, admin, access_token_user):\n    response = client.patch('api/users/ban_user/1/true')\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    headers = {'Authorization': f'Bearer {access_token}'}\n    response = client.patch('api/users/ban_user/999/true', headers=headers)\n    assert 'detail' in response.json()\n    assert response.json()['detail'] == messages.MSC404_USER_NOT_FOUND \n\n    response = client.patch('api/users/ban_user/1/true', headers=headers)\n    assert 'detail' in response.json()\n    assert response.json()['detail'] == messages.MSC403_USER_BANNED \n\n    response = client.patch('api/users/ban_user/2/false', headers=headers)\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    expected_response: dict = UserDb.__fields__\n\n    for field in expected_response:\n        assert field in data", ""]}
{"filename": "tests/test_route_auth.py", "chunked_list": ["\nimport asyncio\nfrom unittest.mock import MagicMock, AsyncMock\n\nfrom fastapi import status\n\nfrom src.conf import messages as m\nfrom src.database.models import User\nfrom src.schemas.users import UserResponse\nfrom src.services.auth import AuthToken", "from src.schemas.users import UserResponse\nfrom src.services.auth import AuthToken\n\n\nmock_send_email = MagicMock()\nmock_send_reset_password = AsyncMock()\n\n\ndef test_signup_ok(client, user, monkeypatch):\n    monkeypatch.setattr('src.routes.auth.send_email', mock_send_email)  \n    response = client.post('api/auth/signup', json=user)\n    assert response.status_code == 201, response.text\n    data = response.json()\n    expected_response: dict = UserResponse.__fields__\n\n    for field in expected_response:\n        assert field in data\n\n    assert data['email'] == user.get('email')\n    assert data['detail'] == m.MSC201_USER_CREATED", "def test_signup_ok(client, user, monkeypatch):\n    monkeypatch.setattr('src.routes.auth.send_email', mock_send_email)  \n    response = client.post('api/auth/signup', json=user)\n    assert response.status_code == 201, response.text\n    data = response.json()\n    expected_response: dict = UserResponse.__fields__\n\n    for field in expected_response:\n        assert field in data\n\n    assert data['email'] == user.get('email')\n    assert data['detail'] == m.MSC201_USER_CREATED", "\n\ndef test_signup_fail(client, user): \n    response = client.post('api/auth/signup', json=user)\n    assert response.status_code == status.HTTP_409_CONFLICT\n    assert response.json()['detail'] == m.MSC409_CONFLICT\n\n\ndef test_login_ok(client, session, user):\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.confirmed = True\n    session.commit()\n\n    response = client.post('api/auth/login', data={'username': user.get('email'), 'password': user.get('password')})\n    data = response.json()\n\n    assert response.status_code == status.HTTP_200_OK\n    assert data['token_type'] == m.TOKEN_TYPE", "def test_login_ok(client, session, user):\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.confirmed = True\n    session.commit()\n\n    response = client.post('api/auth/login', data={'username': user.get('email'), 'password': user.get('password')})\n    data = response.json()\n\n    assert response.status_code == status.HTTP_200_OK\n    assert data['token_type'] == m.TOKEN_TYPE", "\n\ndef test_logout(client, access_token):\n    headers = {'Authorization': f'Bearer {access_token}'}\n    response = client.get('api/auth/logout', headers=headers)\n    assert response.status_code == status.HTTP_205_RESET_CONTENT\n\n\ndef test_login_fail(client, session, user):  # split into several?\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.confirmed = False\n    session.commit()\n    \n    response1 = client.post('api/auth/login', data={'username': 'NonExistUser', 'password': user.get('password')})\n    assert response1.status_code == status.HTTP_401_UNAUTHORIZED\n    assert response1.json()['detail'] == m.MSC401_EMAIL\n\n    response2 = client.post('api/auth/login', data={'username': user.get('email'), 'password': user.get('password')})\n    assert response2.status_code == status.HTTP_401_UNAUTHORIZED\n    assert response2.json()['detail'] == m.MSC401_EMAIL_UNKNOWN\n\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.confirmed = True\n    session.commit()\n\n    response3 = client.post('api/auth/login', data={'username': user.get('email'), 'password': '54327'})\n    assert response3.status_code == status.HTTP_401_UNAUTHORIZED\n    assert response3.json()['detail'] == m.MSC401_PASSWORD", "def test_login_fail(client, session, user):  # split into several?\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.confirmed = False\n    session.commit()\n    \n    response1 = client.post('api/auth/login', data={'username': 'NonExistUser', 'password': user.get('password')})\n    assert response1.status_code == status.HTTP_401_UNAUTHORIZED\n    assert response1.json()['detail'] == m.MSC401_EMAIL\n\n    response2 = client.post('api/auth/login', data={'username': user.get('email'), 'password': user.get('password')})\n    assert response2.status_code == status.HTTP_401_UNAUTHORIZED\n    assert response2.json()['detail'] == m.MSC401_EMAIL_UNKNOWN\n\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.confirmed = True\n    session.commit()\n\n    response3 = client.post('api/auth/login', data={'username': user.get('email'), 'password': '54327'})\n    assert response3.status_code == status.HTTP_401_UNAUTHORIZED\n    assert response3.json()['detail'] == m.MSC401_PASSWORD", "\n\ndef test_refresh_token_ok(client, session, user):\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\n    headers = {'Authorization': f'Bearer {current_user.refresh_token}'}\n    response = client.get('api/auth/refresh_token', headers=headers)\n\n    assert response.status_code == status.HTTP_200_OK\n    assert response.json()['token_type'] == m.TOKEN_TYPE\n    assert response.json()['access_token'] is not None\n    assert response.json()['refresh_token'] is not None", "  \n\ndef test_refresh_token_fail(client, user, monkeypatch):\n    mock_async_logging_to_file = AsyncMock()\n    monkeypatch.setattr('src.services.asyncdevlogging.async_logging_to_file', mock_async_logging_to_file) \n    \n    headers = {'Authorization': f'Bearer NOTOKEN'}\n    response = client.get('api/auth/refresh_token', headers=headers)\n    \n    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n    assert response.json()['detail'] == m.MSC422_INVALID_TOKEN  \n\n    untrue_refresh_token = asyncio.run(\n                                       AuthToken.create_token(data={'sub': user['email']}, expires_delta=1, token_type='refresh_token')\n                                       )\n    headers = {'Authorization': f'Bearer {untrue_refresh_token}'}\n    response = client.get('api/auth/refresh_token', headers=headers)\n\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n    assert response.json()['detail'] == m.MSC401_TOKEN", "\n\ndef test_request_confirm_email_ok(client, session, user):\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.confirmed = True\n    session.commit()\n\n    response = client.post('api/auth/request_confirm_email', json={'email': user.get('email')})\n\n    assert response.status_code == status.HTTP_200_OK\n    assert response.json()['message'] == m.EMAIL_ERROR_CONFIRMED", "\n\ndef test_request_confirm_email_check(client, session, user, monkeypatch):  # , monkeypatch is redundant ?\n    monkeypatch.setattr('src.routes.auth.send_email', mock_send_email)\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.confirmed = False\n    session.commit()\n\n    response = client.post('api/auth/request_confirm_email', json={'email': user.get('email')})\n\n    assert response.status_code == status.HTTP_200_OK\n    assert response.json()['message'] == m.EMAIL_INFO_CONFIRMED\n\n    response2 = client.post('api/auth/request_confirm_email', json={'email': 'Email@notSignUp.user'})\n\n    assert response2.status_code == status.HTTP_200_OK\n    assert response2.json()['message'] == m.EMAIL_INFO_CONFIRMED", "\n\ndef test_confirmed_email_ok(client, session, user):\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.confirmed = False\n    session.commit()\n\n    email_token = asyncio.run(\n                              AuthToken.create_token(data={\n                                                          'sub': user['email'],\n                                                          'email': user['email'],\n                                                          'username': user['username'],\n                                                          }, \n                                                     expires_delta=10, \n                                                     token_type='email_token')\n                              )\n    \n    response = client.get(f'api/auth/confirmed_email/{email_token}')\n\n    assert response.status_code == status.HTTP_200_OK\n    assert response.json()['message'] == m.EMAIL_INFO_CONFIRM", "\n\ndef test_confirmed_email_fail(client, session, user):  # split into several?\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.confirmed = True\n    session.commit()\n\n    email_token = asyncio.run(\n                              AuthToken.create_token(data={\n                                                          'sub': user['email'],\n                                                          'email': user['email'],\n                                                          'username': user['username'],\n                                                          }, \n                                                     expires_delta=10, \n                                                     token_type='email_token')\n                              )\n    response = client.get(f'api/auth/confirmed_email/{email_token}')\n\n    assert response.status_code == status.HTTP_200_OK\n    assert response.json()['message'] == m.EMAIL_ERROR_CONFIRMED\n\n    email_token = asyncio.run(\n                              AuthToken.create_token(data={\n                                                          'sub': 'NonRegistered@unknown.email',\n                                                          'email': '-',\n                                                          'username': '-',\n                                                          }, \n                                                     expires_delta=10, \n                                                     token_type='email_token')\n                              )\n    response = client.get(f'api/auth/confirmed_email/{email_token}')\n\n    assert response.status_code == status.HTTP_400_BAD_REQUEST\n    assert response.json()['detail'] == m.MSC400_BAD_REQUEST", "\n\ndef test_reset_password_ok(client, session, user, monkeypatch):\n    monkeypatch.setattr('src.routes.auth.send_email', mock_send_email)\n    monkeypatch.setattr('src.routes.auth.send_reset_password', mock_send_reset_password)\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.confirmed = True\n    session.commit()\n\n    response = client.post('api/auth/reset-password', json={'email': user.get('email')})  \n\n    assert response.status_code == status.HTTP_200_OK\n    assert response.json()['message'] == m.MSG_SENT_PASSWORD", "\n\ndef test_reset_password_check(client, session, user):  # split into several?\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.confirmed = False\n    session.commit()\n\n    response = client.post('api/auth/reset-password', json={'email': user.get('email')})\n\n    assert response.status_code == status.HTTP_200_OK\n    assert response.json()['message'] == m.EMAIL_INFO_CONFIRMED\n\n    response2 = client.post('api/auth/reset-password', json={'email': 'Non_exist@email.com'})\n\n    assert response2.status_code == status.HTTP_200_OK\n    assert response2.json()['message'] == m.MSC401_EMAIL_UNKNOWN", "\n\ndef test_reset_password_done(client):\n    response = client.get('api/auth/reset-password/done_request')\n\n    assert response.status_code == status.HTTP_200_OK\n    assert response.template.name == 'password_reset_done.html'\n    assert 'request' in response.context\n    assert 'title' in response.context\n    assert response.context['title'] == m.MSG_SENT_PASSWORD", "\n\ndef test_reset_password_confirm_ok(client, session, user, monkeypatch):\n    monkeypatch.setattr('src.routes.auth.send_email', mock_send_email)\n    monkeypatch.setattr('src.routes.auth.send_new_password', mock_send_reset_password) \n\n\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.confirmed = True\n    session.commit()\n\n    user.update(password='new_secret')\n\n    password_reset_token = asyncio.run(\n                                        AuthToken.create_token(data={\n                                                                    'sub': user['email'],\n                                                                    # 'email': user['email'],\n                                                                    'username': user['username'],\n                                                                    }, \n                                                                expires_delta=30, \n                                                                token_type='password_reset_token')\n                                        )\n\n    response = client.post(f'api/auth/reset-password/confirm/{password_reset_token}', json={'password': user['password']})  # , json={'password': user['password']}\n \n    assert response.status_code == status.HTTP_200_OK\n    assert 'user' in response.json()  # response.content  # context\n    assert response.json()['detail'] == m.MSG_PASSWORD_CHENGED", "\n\ndef test_reset_password_confirm_fail(client, session, user, monkeypatch):\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.confirmed = False  # True\n    session.commit()\n\n    password_reset_token = asyncio.run(\n                                        AuthToken.create_token(data={\n                                                                    'sub': 'Non_exist@user.mail',\n                                                                    # 'email': user['email'],\n                                                                    'username': user['username'],\n                                                                    }, \n                                                                expires_delta=30, \n                                                                token_type='password_reset_token')\n                                        )\n    \n    response = client.post(f'api/auth/reset-password/confirm/{password_reset_token}')  # , json={'password': 'new_secret'}  data=   json=\n\n    assert response.status_code == status.HTTP_503_SERVICE_UNAVAILABLE\n    assert response.json()['detail'] == m.MSC503_UNKNOWN_USER", "\n\ndef test_reset_password_complete_ok(client):\n    response = client.get('api/auth/reset-password/complete')\n\n    assert response.status_code == status.HTTP_200_OK\n    assert response.template.name == 'password_reset_complete.html'\n    assert 'request' in response.context\n    assert 'title' in response.context\n    assert response.context['title'] == m.MSG_PASSWORD_RESET", ""]}
{"filename": "tests/test_root.py", "chunked_list": ["\nfrom fastapi.testclient import TestClient\n# import pytest\n\nimport main\n\n\nclient = TestClient(main.app)\n\n\ndef test_root():\n    response = client.get('/')\n    assert response.status_code == 200\n    assert response.json() == {'message': 'Welcome to Photo-Share by Fast Rabbit Team.'}", "\n\ndef test_root():\n    response = client.get('/')\n    assert response.status_code == 200\n    assert response.json() == {'message': 'Welcome to Photo-Share by Fast Rabbit Team.'}\n\n\ndef test_healthchecker():\n    response = client.get('/api/healthchecker')\n    assert response.status_code == 200\n    assert response.json() == {'message': 'Welcome to FastAPI!'}", "def test_healthchecker():\n    response = client.get('/api/healthchecker')\n    assert response.status_code == 200\n    assert response.json() == {'message': 'Welcome to FastAPI!'}\n"]}
{"filename": "tests/test_unit_repository_comments.py", "chunked_list": ["import unittest\nfrom unittest.mock import MagicMock\nfrom sqlalchemy.orm import Session\n\nfrom src.conf import messages\nfrom src.database.models import Comment, Image\nfrom src.schemas.images import CommentModel\n\nfrom src.repository.comments import (\n    add_comment,", "from src.repository.comments import (\n    add_comment,\n    update_comment,\n    remove_comment,\n    get_comments\n\n)\n\n\nclass TestComments(unittest.IsolatedAsyncioTestCase):\n\n    def setUp(self):\n        self.session = MagicMock(spec=Session)\n        self.image = Image(id=1)\n        self.user = {'id': 1, 'roles': 'user'}\n\n    async def test_get_comments(self):\n        comments = [Comment(), Comment()]\n        self.session.query.return_value.filter_by.return_value.all.return_value = comments\n        result = await get_comments(image_id=self.image.id, db=self.session)\n        self.assertEqual(result, comments)\n        self.session.query.assert_called_once_with(Comment)\n        self.session.query.return_value.filter_by.assert_called_once_with(image_id=self.image.id)\n        self.session.query.return_value.filter_by.return_value.all.assert_called_once()\n\n    async def test_add_comment(self):\n        comment = CommentModel(comment='Test comment')\n\n        result = await add_comment(body=comment, image_id=1, user=self.user, db=self.session)\n\n        self.assertTrue(hasattr(result, 'id'))\n        self.assertEqual(result.comment, comment.comment)\n        self.assertEqual(result.user_id, self.user['id'])\n\n    async def test_remove_contact(self):\n        comment = Comment()\n        self.session.query.return_value.filter_by.return_value.first.return_value = comment\n        result = await remove_comment(comment_id=comment.id, user=self.user, db=self.session)\n        self.assertEqual(result['message'], messages.COMMENT_DELETED)\n        self.session.query.assert_called_once_with(Comment)\n        self.session.query.return_value.filter_by.assert_called_once_with(id=comment.id)\n        self.session.delete.assert_called_once_with(comment)\n        self.session.commit.assert_called_once()\n\n\n\n    async def test_update_comment(self):\n        comment_id = 1\n        body = CommentModel(comment='Updated comment')\n        expected_comment = Comment(comment=body.comment, user_id=self.user['id'], image_id=None)\n\n        self.session.query.return_value.filter_by.return_value.first.return_value = expected_comment\n        self.session.commit.return_value = None\n        self.session.refresh.return_value = None\n\n        comment = await update_comment(comment_id, body, self.user, self.session)\n\n        self.assertEqual(comment, expected_comment)\n        self.session.query.assert_called_once_with(Comment)\n        self.session.query.return_value.filter_by.assert_called_once_with(id=comment_id, user_id=self.user['id'])\n        self.session.commit.assert_called_once()\n        self.session.refresh.assert_called_once_with(expected_comment)", "\nclass TestComments(unittest.IsolatedAsyncioTestCase):\n\n    def setUp(self):\n        self.session = MagicMock(spec=Session)\n        self.image = Image(id=1)\n        self.user = {'id': 1, 'roles': 'user'}\n\n    async def test_get_comments(self):\n        comments = [Comment(), Comment()]\n        self.session.query.return_value.filter_by.return_value.all.return_value = comments\n        result = await get_comments(image_id=self.image.id, db=self.session)\n        self.assertEqual(result, comments)\n        self.session.query.assert_called_once_with(Comment)\n        self.session.query.return_value.filter_by.assert_called_once_with(image_id=self.image.id)\n        self.session.query.return_value.filter_by.return_value.all.assert_called_once()\n\n    async def test_add_comment(self):\n        comment = CommentModel(comment='Test comment')\n\n        result = await add_comment(body=comment, image_id=1, user=self.user, db=self.session)\n\n        self.assertTrue(hasattr(result, 'id'))\n        self.assertEqual(result.comment, comment.comment)\n        self.assertEqual(result.user_id, self.user['id'])\n\n    async def test_remove_contact(self):\n        comment = Comment()\n        self.session.query.return_value.filter_by.return_value.first.return_value = comment\n        result = await remove_comment(comment_id=comment.id, user=self.user, db=self.session)\n        self.assertEqual(result['message'], messages.COMMENT_DELETED)\n        self.session.query.assert_called_once_with(Comment)\n        self.session.query.return_value.filter_by.assert_called_once_with(id=comment.id)\n        self.session.delete.assert_called_once_with(comment)\n        self.session.commit.assert_called_once()\n\n\n\n    async def test_update_comment(self):\n        comment_id = 1\n        body = CommentModel(comment='Updated comment')\n        expected_comment = Comment(comment=body.comment, user_id=self.user['id'], image_id=None)\n\n        self.session.query.return_value.filter_by.return_value.first.return_value = expected_comment\n        self.session.commit.return_value = None\n        self.session.refresh.return_value = None\n\n        comment = await update_comment(comment_id, body, self.user, self.session)\n\n        self.assertEqual(comment, expected_comment)\n        self.session.query.assert_called_once_with(Comment)\n        self.session.query.return_value.filter_by.assert_called_once_with(id=comment_id, user_id=self.user['id'])\n        self.session.commit.assert_called_once()\n        self.session.refresh.assert_called_once_with(expected_comment)", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["from unittest.mock import MagicMock\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy import create_engine, select\nfrom sqlalchemy.orm import sessionmaker\n\nfrom main import app\nfrom src.database.models import Base, Role, User\nfrom src.database.db import get_db", "from src.database.models import Base, Role, User\nfrom src.database.db import get_db\n\n\nSQLALCHEMY_DATABASE_URL = 'sqlite:///./test.db'\n\nengine = create_engine(\n                       SQLALCHEMY_DATABASE_URL, \n                       connect_args={'check_same_thread': False}\n                      )", "                       connect_args={'check_same_thread': False}\n                      )\n\nTestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n\n@pytest.fixture(scope='module')\ndef session():\n    # Create the database\n\n    Base.metadata.drop_all(bind=engine)\n    Base.metadata.create_all(bind=engine)\n\n    db = TestingSessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()", "\n\n@pytest.fixture(scope='module')\ndef client(session):\n    def override_get_db():\n        try:\n            yield session\n        finally:\n            session.close()\n\n    app.dependency_overrides[get_db] = override_get_db\n\n    yield TestClient(app)", "\n    \n@pytest.fixture(scope='module')\ndef admin():\n    return {\n            'id': 1,\n            'username': 'admin', \n            'email': 'example@example.com', \n            'password': 'Qwerty@1',\n            'roles': 'admin',\n            'status_active': 'true',\n            }", "\n\n@pytest.fixture(scope='module')\ndef user():\n    return {\n            'id': 2,\n            'username': 'user',\n            'email': 'example2@example.com',\n            'password': 'Qwerty@1',\n            'roles': 'user',\n            'status_active': 'true',\n            }", "\n\n@pytest.fixture(scope='module')\ndef comment():\n    return {'comment': 'Test comment', 'image_id': '1'}\n\n  \n@pytest.fixture(scope='module')\ndef image():\n    return {'description': 'Test image', 'tags': 'test tag'}", "def image():\n    return {'description': 'Test image', 'tags': 'test tag'}\n\n  \n@pytest.fixture\ndef admin_token(client, admin, session, monkeypatch):\n    mock_send_email = MagicMock()\n    monkeypatch.setattr('src.routes.auth.send_email', mock_send_email)\n    client.post('/api/auth/signup', json=admin)\n\n    current_user: User = session.query(User).filter_by(email=admin.get('email')).first()\n    current_user.id = 1\n    current_user.confirmed = True\n    current_user.roles = Role.admin\n    session.commit()\n\n    response = client.post(\n        '/api/auth/login',\n        data={'username': admin.get('email'), 'password': admin.get('password')},\n    )\n    data = response.json()\n    # return data['access_token']\n    return {'access_token': data['access_token'], 'refresh_token': data['refresh_token'], 'token_type': 'bearer'}", "\n\n@pytest.fixture\ndef user_token(client, user, session, monkeypatch):\n    mock_send_email = MagicMock()\n    monkeypatch.setattr('src.routes.auth.send_email', mock_send_email)\n    client.post('/api/auth/signup', json=user)\n\n    current_user: User = session.query(User).filter_by(email=user.get('email')).first()\n    current_user.id = 2\n    current_user.confirmed = True\n    current_user.roles = Role.user\n    session.commit()\n\n    response = client.post(\n        '/api/auth/login',\n        data={'username': user.get('email'), 'password': user.get('password')},\n    )\n    data = response.json()\n    # return data['access_token']\n    return {'access_token': data['access_token'], 'refresh_token': data['refresh_token'], 'token_type': 'bearer'}", "\n\n@pytest.fixture(scope='function')\ndef access_token(client, admin, session, mocker) -> str:\n    mocker.patch('src.routes.auth.send_email')  # mocker\n\n    client.post('/api/auth/signup', json=admin)\n\n    current_user: User = session.scalar(select(User).filter(User.email == admin['email']))\n    current_user.confirmed = True\n    session.commit()\n\n    response = client.post(\n                           '/api/auth/login',\n                           data={'username': admin.get('email'), 'password': admin.get('password')},\n                           )\n    return response.json()['access_token']", "\n\n@pytest.fixture(scope='function')\ndef access_token_user(client, user, session, mocker) -> str:\n    mocker.patch('src.routes.auth.send_email')  # mocker\n\n    client.post('/api/auth/signup', json=user)\n\n    current_user: User = session.scalar(select(User).filter(User.email == user['email']))\n    current_user.confirmed = True\n    session.commit()\n\n    response = client.post(\n                           '/api/auth/login',\n                           data={'username': user.get('email'), 'password': user.get('password')},\n                           )\n    return response.json()['access_token']"]}
{"filename": "tests/test_routes_comments.py", "chunked_list": ["from unittest.mock import patch, AsyncMock\n\nfrom src.conf import messages\nfrom src.services.auth import AuthUser\nfrom src.database.models import User, Comment\n\n'''\nIntegration tests for the application.\n'''\n", "'''\n\n'''\nTest src.routes.comments\n1. test_add_comment\n2. test_get_comments_by_image_id\n3. test_update_comment\n4. test_remove_comment\n'''\n", "'''\n\n\ndef test_add_comment(client, session, user_token, user, comment, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        mock_image = AsyncMock()\n        monkeypatch.setattr('src.repository.images.get_image', mock_image)\n\n        response = client.post(\n            f'''/api/comment/{comment['image_id']}''',\n            json={'comment': 'Test comment'},\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 200, response.text\n        assert type(data) == dict\n        assert data['comment'] == comment['comment']", "\n\ndef test_get_comments_by_image_id(client, session, user_token, user, comment, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        mock_image = AsyncMock()\n        monkeypatch.setattr('src.repository.images.get_image', mock_image)\n\n        response = client.get(\n            f'''/api/comment/{comment['image_id']}''',\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 200, response.text\n        assert type(data) == list\n        assert data[0]['comment'] == comment['comment']", "\n\ndef test_update_comment(client, session, user_token, user, comment, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        user = session.query(User).filter_by(email=user.get('email')).first()\n        test_comment = session.query(Comment).filter_by(user_id=user.id).first()\n        response = client.put(\n            '/api/comment/1',\n            json={'comment': 'New comment'},\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 200, response.text\n        assert type(data) == dict\n        assert data['comment'] == 'New comment'\n        assert test_comment.comment == 'New comment'", "\n\n#\n\ndef test_remove_comment_by_user(client, session, user_token, user, comment, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        user = session.query(User).filter_by(email=user.get('email')).first()\n        test_comment = session.query(Comment).filter_by(user_id=user.id).first()\n        response = client.delete(\n            f'/api/comment/{test_comment.id}',\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 403, response.text\n        assert data['detail'] == messages.MSC403_FORBIDDEN", "\n\ndef test_remove_comment_by_admin(client, session, admin_token, user, comment, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        user = session.query(User).filter_by(email=user.get('email')).first()\n        test_comment = session.query(Comment).filter_by(user_id=user.id).first()\n        response = client.delete(\n            f'/api/comment/{test_comment.id}',\n            headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 200, response.text\n        assert data['message'] == messages.COMMENT_DELETED\n        try_find = session.query(Comment).filter_by(id=test_comment.id).first()\n        assert try_find == None", "\n\ndef test_update_comment_not_found(client, session, user_token, user, comment, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        # user = session.query(User).fiomment).filter_by(user_id=comment['user_id']).first()\n        response = client.put(\n            '/api/comment/999',\n            json={'comment': 'New comment'},\n            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n        )\n        data = response.json()\n        assert response.status_code == 404, response.text", "#\n\ndef test_remove_comment_not_found(client, session, admin_token, user, comment, monkeypatch):\n    with patch.object(AuthUser, 'redis_client') as redis_mock:\n        redis_mock.get.return_value = None\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\n        response = client.delete(\n            '/api/comment/9999',\n            headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n        )\n        assert response.status_code == 404, response.text", ""]}
{"filename": "docs/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n#\n# For the full list of built-in configuration values, see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Project information -----------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information\nimport os\nimport sys\n", "import sys\n\n\nsys.path.append(os.path.abspath('..'))\nproject = 'frt-photo-share'\ncopyright = '2023, FRT'\nauthor = 'FRT'\nrelease = '0.0.0.1'\n\n# -- General configuration ---------------------------------------------------", "\n# -- General configuration ---------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n\nextensions = ['sphinx.ext.autodoc']\n\ntemplates_path = ['_templates']\nexclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n\n", "\n\n\n# -- Options for HTML output -------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n\nhtml_theme = 'nature'\nhtml_static_path = ['_static']\n", ""]}
{"filename": "src/repository/images.py", "chunked_list": ["from typing import Optional\n\nfrom fastapi import HTTPException, status\nfrom fastapi_pagination import Page, Params\nfrom fastapi_pagination.ext.sqlalchemy import paginate\nfrom sqlalchemy import asc, desc\nfrom sqlalchemy.orm import Session\n\nfrom src.database.models import Image, image_m2m_tag\nfrom src.schemas.images import ImageModel", "from src.database.models import Image, image_m2m_tag\nfrom src.schemas.images import ImageModel\nfrom src.conf import messages\nfrom src.repository import tags as repository_tags\n\n\nasync def get_images(\n                     user: dict,\n                     db: Session,\n                     pagination_params: Params", "                     db: Session,\n                     pagination_params: Params\n                     ) -> Page:\n    \"\"\"\n    The get_images function returns a list of images.\n\n    :param user: dict: Pass the user's information to the function\n    :param db: Session: Access the database\n    :param pagination_params: Params: Pass in the pagination parameters\n    :return: A page object that contains the results of a paginated query", "    :param pagination_params: Params: Pass in the pagination parameters\n    :return: A page object that contains the results of a paginated query\n    :doc-author: Trelent\n    \"\"\"\n    return paginate(\n                    query=db.query(Image).order_by(Image.user_id),\n                    params=pagination_params\n                    )\n\n", "\n\nasync def get_image(\n                    image_id: int, \n                    user: dict,\n                    db: Session\n                    ) -> Optional[Image]:\n    \"\"\"\n    The get_image function returns an image object from the database.\n    Args:", "    The get_image function returns an image object from the database.\n    Args:\n    image_id (int): The id of the desired image.\n    user (dict): A dictionary containing a user's credentials and permissions.\n    This is used to determine if a user has permission to view this particular\n    resource, as well as for logging purposes.\n\n    :param image_id: int: Specify the id of the image that we want to get\n    :param user: dict: Pass the user information to the function\n    :param db: Session: Pass the database session to the function", "    :param user: dict: Pass the user information to the function\n    :param db: Session: Pass the database session to the function\n    :return: An image object\n    :doc-author: Trelent\n    \"\"\"\n    return (\n            db.query(Image)\n            .filter_by(id=image_id)\n            .first()\n            )", "            .first()\n            )\n\n\nasync def create_image(\n                       body: dict,\n                       user_id: int,\n                       db: Session,\n                       tags_limit: int\n                       ) -> Image | Exception:", "                       tags_limit: int\n                       ) -> Image | Exception:\n    \"\"\"\n    The create_image function creates a new image in the database.\n    Args:\n    body (dict): The request body containing the image's description, link and tags.\n    user_id (int): The id of the user who created this image.\n\n    :param body: dict: Get the data from the request body\n    :param user_id: int: Get the user_id from the token", "    :param body: dict: Get the data from the request body\n    :param user_id: int: Get the user_id from the token\n    :param db: Session: Access the database\n    :param tags_limit: int: Limit the number of tags that can be added to an image\n    :return: The image created\n    :doc-author: Trelent\n    \"\"\"\n    tags_names = body['tags'].split()\n\n    if len(tags_names) > tags_limit:\n        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=messages.MSC409_TAGS)", "\n    if len(tags_names) > tags_limit:\n        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=messages.MSC409_TAGS)\n    \n    tags = []\n    for el in tags_names:\n        tag = await repository_tags.get_tag_by_name(el, db)\n\n        if tag is None:\n            tag = await repository_tags.create_tag(el, db)\n\n        tags.append(tag)", "    try:\n        image = Image(description=body['description'], link=body['link'], user_id=user_id, tags=tags)\n\n    except Exception as er:\n        return er\n\n    db.add(image)\n    db.commit()\n    db.refresh(image)\n", "    db.refresh(image)\n\n    return image\n\n\nasync def transform_image(\n                          body: dict,\n                          user_id: int,\n                          db: Session\n                          ) -> Image:", "                          db: Session\n                          ) -> Image:\n    \"\"\"\n    The transform_image function takes in a dictionary of image data, the user_id of the user who created it, and a database session.\n    It then creates an Image object from that data and adds it to the database. It returns either an error or the newly created Image.\n\n    :param body: dict: Pass the data from the request body\n    :param user_id: int: Get the user id from the token\n    :param db: Session: Access the database\n    :return: A new image object", "    :param db: Session: Access the database\n    :return: A new image object\n    :doc-author: Trelent\n    \"\"\"\n    try:\n        image = Image(\n                      description=body['description'],\n                      link=body['link'],\n                      user_id=user_id,\n                      type=body['type'],\n                      tags=body['tags']\n                      )\n\n    except Exception as er:\n        return er", "\n    db.add(image)\n    db.commit()\n    db.refresh(image)\n\n    return image\n\n\nasync def remove_image(\n                       image_id: int,", "async def remove_image(\n                       image_id: int,\n                       user: dict,\n                       db: Session\n                       ) -> dict:\n    \"\"\"\n    The remove_image function removes an image from the database.\n\n    :param image_id: int: Specify the image to be deleted\n    :param user: dict: Check if the user is an admin or moderator", "    :param image_id: int: Specify the image to be deleted\n    :param user: dict: Check if the user is an admin or moderator\n    :param db: Session: Access the database\n    :return: A message to the user\n    :doc-author: Trelent\n    \"\"\"\n    if user['roles'].value in ['admin', 'moderator']:\n        image: Image = db.query(Image).filter_by(id=image_id).first()\n\n    else:\n        image: Image = db.query(Image).filter_by(id=image_id, user_id=user['id']).first()", "\n    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n    else:\n        db.delete(image)\n        db.commit()\n\n    return {'message': messages.IMAGE_DELETED}\n\n", "\n\nasync def update_image(\n                       image_id: int,\n                       body: ImageModel,\n                       user: dict,\n                       db: Session,\n                       tags_limit: int\n                       ) -> Optional[Image]:\n    \"\"\"", "                       ) -> Optional[Image]:\n    \"\"\"\n    The update_image function updates an image in the database.\n\n    :param image_id: int: Get the image by id\n    :param body: ImageModel: Pass the image model to the function\n    :param user: dict: Check if the user is an admin or a moderator\n    :param db: Session: Pass the database session to the function\n    :param tags_limit: int: Limit the number of tags that can be added to an image\n    :return: The updated image", "    :param tags_limit: int: Limit the number of tags that can be added to an image\n    :return: The updated image\n    :doc-author: Trelent\n    \"\"\"\n    if user['roles'].value in ['admin', 'moderator']:\n        image: Image = db.query(Image).filter_by(id=image_id).first()\n\n    else:\n        image: Image = db.query(Image).filter_by(id=image_id, user_id=user['id']).first()\n\n    if not image or not body.description:\n        return None", "\n    if not image or not body.description:\n        return None\n\n    image.description = body.description\n\n    tags_names = body.tags.split()[:tags_limit]\n\n    tags = []\n    for el in tags_names:\n        tag = await repository_tags.get_tag_by_name(el, db)\n        if tag is None:\n            tag = await repository_tags.create_tag(el, db)\n\n        tags.append(tag)", "    tags = []\n    for el in tags_names:\n        tag = await repository_tags.get_tag_by_name(el, db)\n        if tag is None:\n            tag = await repository_tags.create_tag(el, db)\n\n        tags.append(tag)\n\n    image.tags = tags\n", "    image.tags = tags\n\n    db.add(image)\n    db.commit()\n    db.refresh(image)\n\n    return image\n\n\nasync def get_images_by_tag(tag, sort_direction, db):", "\nasync def get_images_by_tag(tag, sort_direction, db):\n    \"\"\"\n    The get_images_by_tag function takes in a tag and a sort direction, and returns all images associated with that tag.\n    The function first queries the image_m2m_tag table to find all rows where the tag id matches the inputted tags id.\n    It then creates an array of image ids from those rows, which it uses to query for images in the Image table. It then sorts these images by creation date based on whether or not they were sorted ascendingly or descendingly.\n\n    :param tag: Filter the images by tag\n    :param sort_direction: Determine whether the images should be sorted in ascending or descending order\n    :param db: Pass the database session to the function", "    :param sort_direction: Determine whether the images should be sorted in ascending or descending order\n    :param db: Pass the database session to the function\n    :return: A list of images that have a specific tag\n    :doc-author: Trelent\n    \"\"\"\n    image_tag = db.query(image_m2m_tag).filter_by(tag_id=tag.id).all()\n    images_id = [el[1] for el in image_tag]\n    if sort_direction.value == 'desc':\n        images = db.query(Image).filter(Image.id.in_((images_id))).order_by(desc(Image.created_at)).all()\n\n    else:\n        images = db.query(Image).filter(Image.id.in_((images_id))).order_by(asc(Image.created_at)).all()", "\n    return images\n\n\nasync def get_images_by_user(user_id, sort_direction, db):\n    \"\"\"\n    The get_images_by_user function returns a list of images that are associated with the user_id passed in.\n    The sort_direction parameter is an enum value that can be either 'asc' or 'desc'. The db parameter is a database session object.\n\n    :param user_id: Filter the images by user_id", "\n    :param user_id: Filter the images by user_id\n    :param sort_direction: Determine the order in which images are returned\n    :param db: Pass in the database session object\n    :return: A list of image objects\n    :doc-author: Trelent\n    \"\"\"\n    if sort_direction.value == 'desc':\n        images = db.query(Image).filter_by(user_id=user_id).order_by(desc(Image.created_at)).all()\n\n    else:\n        images = db.query(Image).filter_by(user_id=user_id).order_by(asc(Image.created_at)).all()", "\n    return images\n"]}
{"filename": "src/repository/ratings.py", "chunked_list": ["from typing import Optional, List\n\nfrom fastapi import HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import func\n\nfrom src.conf import messages\nfrom src.database.models import Rating, Image, User\nfrom src.schemas.images import RatingModel\n", "from src.schemas.images import RatingModel\n\n\nasync def add_rating(\n                     body: RatingModel,\n                     image_id: int,\n                     user: dict,\n                     db: Session\n                     ) -> Rating:\n    rating = Rating(", "                     ) -> Rating:\n    rating = Rating(\n                    rating=body.rating,\n                    user_id=user['id'],\n                    image_id=image_id\n                    )\n    db.add(rating)\n    db.commit()\n    db.refresh(rating)\n", "    db.refresh(rating)\n\n    image = db.query(Image).get(image_id)\n    average_rating = db.query(func.avg(Rating.rating)).filter(Rating.image_id == image_id).scalar()\n    image.rating = average_rating\n\n    db.commit()\n    db.refresh(image)\n\n    return rating", "\n    return rating\n\n\nasync def get_ratings(\n                image_id: int,\n                db: Session\n                ) -> List[Rating]:\n    ratings = db.query(Rating).filter(Rating.image_id == image_id).all()\n", "    ratings = db.query(Rating).filter(Rating.image_id == image_id).all()\n\n    return ratings\n\n\nasync def remove_rating(\n                         rating_id: int,\n                         user: User,\n                         db: Session\n                         ) -> dict:", "                         db: Session\n                         ) -> dict:\n    rating = db.query(Rating).filter_by(id=rating_id).first()\n\n    if rating is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_RATING_NOT_FOUND)\n\n    image_id = rating.image_id\n\n    db.delete(rating)", "\n    db.delete(rating)\n    db.commit()\n\n    image = db.query(Image).get(image_id)\n    average_rating = db.query(func.avg(Rating.rating)).filter(Rating.image_id == image_id).scalar()\n    image.rating = average_rating\n\n    db.commit()\n    db.refresh(image)", "    db.commit()\n    db.refresh(image)\n\n    return {'message': messages.RATING_DELETED}\n"]}
{"filename": "src/repository/users.py", "chunked_list": ["from typing import Optional, Type\n\nfrom fastapi import HTTPException, status\nfrom fastapi.encoders import jsonable_encoder\nfrom libgravatar import Gravatar\nfrom sqlalchemy.orm import Session\n\nfrom src.database.models import Image, Role, User\nfrom src.schemas.users import UserBase, UserModel, UserType\nfrom src.conf import messages", "from src.schemas.users import UserBase, UserModel, UserType\nfrom src.conf import messages\n\n\nasync def get_user_by_email(email: str, db: Session) -> Optional[User]:\n    return db.query(User).filter(User.email == email).first()\n\n\nasync def get_user_by_id(user_id: int, db: Session) -> Optional[User]:\n    return db.query(User).filter(User.id == user_id).first()", "async def get_user_by_id(user_id: int, db: Session) -> Optional[User]:\n    return db.query(User).filter(User.id == user_id).first()\n\n\nasync def create_user(body: UserModel, db: Session) -> User:\n    avatar = None\n    try:\n        g = Gravatar(body.email)\n        avatar = g.get_image()\n\n    except Exception as e:\n        print(e)", "\n    new_user: User = User(**body.dict(), avatar=avatar)\n    new_user.roles = Role.admin if not db.query(User).first() else Role.user\n\n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n\n    return new_user\n", "    return new_user\n\n\nasync def change_password_for_user(user: User, password: str, db: Session) -> User:\n    user.password = password\n    db.add(user)\n    db.commit()\n    db.refresh(user)\n\n    return user", "\n    return user\n\n\nasync def update_token(user: User, token: str | None, db: Session) -> None:\n    user.refresh_token = token\n    db.commit()\n\n\nasync def confirmed_email(user: User, db: Session) -> None:", "\nasync def confirmed_email(user: User, db: Session) -> None:\n    user.confirmed = True\n    db.commit()\n\n\nasync def update_avatar(email: str, url: str, db: Session) -> Optional[User]:\n    user: User = await get_user_by_email(email, db)\n    if user:\n        user.avatar = url\n        db.commit()\n        db.refresh(user)\n\n        return user", "    if user:\n        user.avatar = url\n        db.commit()\n        db.refresh(user)\n\n        return user\n\n\nasync def get_number_of_images_per_user(email: str, db: Session) -> int:\n    return db.query(Image).filter(User.email == email).count()", "async def get_number_of_images_per_user(email: str, db: Session) -> int:\n    return db.query(Image).filter(User.email == email).count()\n\n\nasync def update_user_profile(user_id: int, current_user: dict, body_data: UserType, db: Session) -> Optional[User]:\n    body_data: Optional[dict] = jsonable_encoder(body_data) if body_data else {}\n    user: User = await get_user_by_id(user_id, db)\n\n    if not user:\n        return None", "    if not user:\n        return None\n    \n    if not body_data.get('roles'):\n        return None\n    \n    if current_user['roles'] != Role.admin:\n        return None\n    \n    if (\n        current_user['roles'] == Role.admin and\n        user_id != current_user['id']\n        ):\n        role_mapping = {\n                        'admin': Role.admin,\n                        'moderator': Role.moderator,\n                        'user': Role.user\n                        }\n        body_data['roles'] = role_mapping.get(body_data['roles'].lower(), Role.user)\n        setattr(user, 'roles', body_data['roles'])\n        db.add(user)\n        db.commit()\n        db.refresh(user)\n\n        return user", "    \n    if (\n        current_user['roles'] == Role.admin and\n        user_id != current_user['id']\n        ):\n        role_mapping = {\n                        'admin': Role.admin,\n                        'moderator': Role.moderator,\n                        'user': Role.user\n                        }\n        body_data['roles'] = role_mapping.get(body_data['roles'].lower(), Role.user)\n        setattr(user, 'roles', body_data['roles'])\n        db.add(user)\n        db.commit()\n        db.refresh(user)\n\n        return user", "    \n    return None\n\n\nasync def update_your_profile(email: str, body_data: UserBase, db: Session) -> Optional[User]:\n    user: User = await get_user_by_email(email, db)\n    if not user:\n        return None  # raise 500?\n    \n    db_obj_data: Optional[dict] = user.__dict__", "    \n    db_obj_data: Optional[dict] = user.__dict__\n    body_data: Optional[dict] = jsonable_encoder(body_data) if body_data else None\n    if not db_obj_data or not body_data:\n        return None\n    \n    for field in db_obj_data:\n        if field in body_data:\n            setattr(user, field, body_data[field])\n", "\n    db.add(user)\n    db.commit()\n    db.refresh(user)\n\n    return user\n\n\nasync def ban_user(user_id: int, active_status: bool, db: Session) -> Type[User] | None:\n    user = db.query(User).filter_by(id=user_id).first()\n    if not user:\n        return None", "async def ban_user(user_id: int, active_status: bool, db: Session) -> Type[User] | None:\n    user = db.query(User).filter_by(id=user_id).first()\n    if not user:\n        return None\n   \n    if user.roles.value == 'admin':\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=messages.MSC403_USER_BANNED)\n    \n    user.status_active = active_status\n    db.commit()", "    user.status_active = active_status\n    db.commit()\n    db.refresh(user)\n\n    return user\n"]}
{"filename": "src/repository/tags.py", "chunked_list": ["from typing import List\n\nfrom sqlalchemy.orm import Session\n\nfrom src.database.models import Tag\n\n\nasync def create_tag(name, db: Session) -> Tag:\n    tag = Tag(name=name)\n", "    tag = Tag(name=name)\n\n    db.add(tag)\n    db.commit()\n    db.refresh(tag)\n    \n    return tag\n\n\nasync def get_tags(db: Session) -> List[Tag]:", "\nasync def get_tags(db: Session) -> List[Tag]:\n    return db.query(Tag).all()\n\n\nasync def get_tag(tag_id: int, db: Session) -> Tag:\n    return db.query(Tag).filter(Tag.id == tag_id).first()\n\n\nasync def get_tag_by_name(name: str, db: Session) -> Tag:", "\nasync def get_tag_by_name(name: str, db: Session) -> Tag:\n    return db.query(Tag).filter_by(name=name).first()\n"]}
{"filename": "src/repository/comments.py", "chunked_list": ["from typing import Optional, List\n\nfrom fastapi import HTTPException, status\n\nfrom sqlalchemy.orm import Session\n\nfrom src.database.models import Comment, User\nfrom src.schemas.images import CommentModel\nfrom src.conf import messages\n", "from src.conf import messages\n\n\nasync def add_comment(\n        body: CommentModel,\n        image_id: int,\n        user: dict,\n        db: Session\n        ) -> Optional[Comment]:\n    \"\"\"", "        ) -> Optional[Comment]:\n    \"\"\"\n    The add_comment function creates a new comment for an image.\n    Args:\n    body (CommentModel): The CommentModel object containing the comment to be added.\n    image_id (int): The id of the image that is being commented on.\n    user (dict): A dictionary containing information about the user who is adding a comment, including their id and username.\n\n    :param body: CommentModel: Get the comment from the request body\n    :param image_id: int: Get the image id from the url", "    :param body: CommentModel: Get the comment from the request body\n    :param image_id: int: Get the image id from the url\n    :param user: dict: Get the user id from the token\n    :param db: Session: Access the database\n    :return: A comment object\n    :doc-author: Trelent\n    \"\"\"\n    comment = Comment(\n        comment=body.comment,\n        user_id=user['id'],", "        comment=body.comment,\n        user_id=user['id'],\n        image_id=image_id\n    )\n    db.add(comment)\n    db.commit()\n    db.refresh(comment)\n\n    return comment\n", "    return comment\n\n\nasync def update_comment(\n        comment_id: int,\n        body: CommentModel,\n        user: dict,\n        db: Session,\n        ) -> Optional[Comment]:\n    \"\"\"", "        ) -> Optional[Comment]:\n    \"\"\"\n    The update_comment function updates a comment in the database.\n    Args:\n    comment_id (int): The id of the comment to update.\n    body (CommentModel): The updated Comment object with new values for its attributes.\n    This is passed as JSON from the client and converted into a CommentModel object by Pydantic's BaseModel class.\n    See models/comment_model for more information on how this works, or visit https://pydantic-docs.helpmanual.io/.\n\n    :param comment_id: int: Identify the comment to be deleted", "\n    :param comment_id: int: Identify the comment to be deleted\n    :param body: CommentModel: Get the comment from the request body\n    :param user: dict: Check if the user is authorized to delete a comment\n    :param db: Session: Access the database\n    :param : Get the comment id\n    :return: The updated comment\n    :doc-author: Trelent\n    \"\"\"\n    comment: Comment = db.query(Comment).filter_by(id=comment_id, user_id=user['id']).first()\n    if not comment or not body.comment:\n        return None", "    \"\"\"\n    comment: Comment = db.query(Comment).filter_by(id=comment_id, user_id=user['id']).first()\n    if not comment or not body.comment:\n        return None\n\n    comment.comment = body.comment\n    db.add(comment)\n    db.commit()\n    db.refresh(comment)\n", "    db.refresh(comment)\n\n    return comment\n\n\nasync def remove_comment(\n        comment_id: int,\n        user: User,\n        db: Session\n    ) -> dict:", "        db: Session\n    ) -> dict:\n    \"\"\"\n    The remove_comment function deletes a comment from the database.\n\n    :param comment_id: int: Specify the id of the comment that is to be deleted\n    :param user: User: Check if the user is authorized to delete a comment\n    :param db: Session: Access the database\n    :return: A dictionary with a message that the comment has been deleted\n    :doc-author: Trelent", "    :return: A dictionary with a message that the comment has been deleted\n    :doc-author: Trelent\n    \"\"\"\n    comment: Comment = db.query(Comment).filter_by(id=comment_id).first()\n\n    if comment is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_COMMENT_NOT_FOUND)\n\n    db.delete(comment)\n    db.commit()", "    db.delete(comment)\n    db.commit()\n\n    return {'message': messages.COMMENT_DELETED}\n\n\nasync def get_comments(image_id, db) -> List[Comment]:\n    \"\"\"\n    The get_comments function takes in an image_id and a database connection,\n    and returns all comments associated with the given image_id.", "    The get_comments function takes in an image_id and a database connection,\n    and returns all comments associated with the given image_id.\n\n    :param image_id: Filter the comments by image_id\n    :param db: Query the database for comments that are associated with a specific image\n    :return: All comments associated with a particular image\n    :doc-author: Trelent\n    \"\"\"\n    return db.query(Comment).filter_by(image_id=image_id).all()\n", "    return db.query(Comment).filter_by(image_id=image_id).all()\n"]}
{"filename": "src/schemas/images.py", "chunked_list": ["import enum\nfrom datetime import datetime\nfrom pydantic import BaseModel, Field\nfrom typing import List\n\nfrom src.database.models import TransformationsType\n\n\nclass TagModel(BaseModel):\n    name: str = Field(max_length=20)\n\n    class Config:\n        orm_mode = True", "class TagModel(BaseModel):\n    name: str = Field(max_length=20)\n\n    class Config:\n        orm_mode = True\n\n\nclass ImageModel(BaseModel):\n    description: str = Field(max_length=50)\n    tags: str\n    rating: float = None", "\n\nclass ImageResponse(ImageModel):\n    id: int\n    link: str\n    user_id: int\n    created_at: datetime\n    updated_at: datetime\n    tags: List[TagModel]\n    rating: float = None\n\n    class Config:\n        orm_mode = True", "\n\nclass TransformateModel(BaseModel):\n    Type: TransformationsType\n\n\nclass SortDirection(enum.Enum):\n    up: str = 'asc'\n    down: str = 'desc'\n", "\n\nclass CommentModel(BaseModel):\n    comment: str = Field(max_length=2000)\n\n\nclass CommentResponse(CommentModel):\n    id: int\n\n    class Config:\n        orm_mode = True", "\n\nclass RatingModel(BaseModel):\n    rating: float = Field(ge=1, le=5)\n\n\nclass RatingResponse(RatingModel):\n    id: int\n\n    class Config:\n        orm_mode = True", ""]}
{"filename": "src/schemas/users.py", "chunked_list": ["from datetime import datetime\nfrom pydantic import BaseModel, EmailStr, Field\n\nfrom src.conf import messages\nfrom src.database.models import Role\n\n\nclass UserBase(BaseModel):\n    username: str = Field(min_length=2, max_length=30)\n    email: EmailStr", "\n\nclass UserModel(UserBase):\n    password: str = Field(min_length=6, max_length=14)\n\n\nclass UserType(UserBase):\n    roles: str = 'user'\n\n\nclass UserDb(BaseModel):\n    id: int\n    username: str\n    email: str\n    created_at: datetime\n    avatar: str\n\n    class Config:\n        \"\"\"Indicates that the UserDb model is used to represent the ORM model.\"\"\"\n        orm_mode = True", "\n\nclass UserDb(BaseModel):\n    id: int\n    username: str\n    email: str\n    created_at: datetime\n    avatar: str\n\n    class Config:\n        \"\"\"Indicates that the UserDb model is used to represent the ORM model.\"\"\"\n        orm_mode = True", "\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    email: str\n    created_at: datetime\n    avatar: str\n    roles: Role\n    detail: str = messages.MSC201_USER_CREATED\n    status_active: bool\n\n    class Config:\n        orm_mode = True", "\n\nclass UserResponseFull(UserResponse):\n    number_images: int = 0\n\n\nclass Token(BaseModel):\n    access_token: str\n    refresh_token: str\n    token_type: str = messages.TOKEN_TYPE", "\n\nclass RequestEmail(BaseModel):\n    email: EmailStr\n\n\nclass PasswordRecovery(BaseModel):\n    \"\"\"To check the sufficiency of the password during the password recovery procedure.\"\"\"\n    password: str = Field(min_length=6, max_length=14)\n", "\n\nclass MessageResponse(BaseModel):\n    message: str = Field(max_length=2000)\n"]}
{"filename": "src/database/models.py", "chunked_list": ["import enum\n\nfrom sqlalchemy import Column, Boolean, Enum, func, Integer, String, Table\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql.schema import ForeignKey, UniqueConstraint, CheckConstraint\nfrom sqlalchemy.sql.sqltypes import DateTime, Float\n\nfrom src.database.db import Base\n\n\nclass Role(enum.Enum):\n    admin: str = 'admin'\n    moderator: str = 'moderator'\n    user: str = 'user'", "\n\nclass Role(enum.Enum):\n    admin: str = 'admin'\n    moderator: str = 'moderator'\n    user: str = 'user'\n\n\nclass User(Base):\n    \"\"\"Base User class.\"\"\"\n    __tablename__ = 'users'\n    id = Column(Integer, primary_key=True)\n    username = Column(String(50))\n    email = Column(String(30), nullable=False, unique=True)\n    password = Column(String(255), nullable=False)\n    created_at = Column('crated_at', DateTime, default=func.now())\n    updated_at = Column('updated_at', DateTime, default=func.now(), onupdate=func.now())\n    avatar = Column(String(255), nullable=True)\n    refresh_token = Column(String(255), nullable=True)\n    roles = Column('roles', Enum(Role), default=Role.user)\n    confirmed = Column(Boolean, default=False)\n    status_active = Column(Boolean, default=True)", "class User(Base):\n    \"\"\"Base User class.\"\"\"\n    __tablename__ = 'users'\n    id = Column(Integer, primary_key=True)\n    username = Column(String(50))\n    email = Column(String(30), nullable=False, unique=True)\n    password = Column(String(255), nullable=False)\n    created_at = Column('crated_at', DateTime, default=func.now())\n    updated_at = Column('updated_at', DateTime, default=func.now(), onupdate=func.now())\n    avatar = Column(String(255), nullable=True)\n    refresh_token = Column(String(255), nullable=True)\n    roles = Column('roles', Enum(Role), default=Role.user)\n    confirmed = Column(Boolean, default=False)\n    status_active = Column(Boolean, default=True)", "\n\nclass TransformationsType(enum.Enum):\n    basic: str = 'basic'\n    avatar: str = 'avatar'\n    black_white: str = 'black_white'\n    delete_bg: str = 'delete_bg'\n    cartoonify: str = 'cartoonify'\n    oil_paint: str = 'oil_paint'\n    sepia: str = 'sepia'\n    vector: str = 'vector'\n    outline: str = 'outline'", "\n\nimage_m2m_tag = Table('image_m2m_tag',\n                      Base.metadata,\n                      Column('id', Integer, primary_key=True),\n                      Column('image_id', Integer, ForeignKey('images.id', ondelete='CASCADE')),\n                      Column('tag_id', Integer, ForeignKey('tags.id', ondelete='CASCADE'))\n                      )\n\n\nclass Image(Base):\n    __tablename__ = 'images'\n    id = Column(Integer, primary_key=True)\n    description = Column(String, nullable=True)\n    type = Column('TransformationsType', Enum(TransformationsType), default=TransformationsType.basic)\n    link = Column(String, nullable=False)\n    user_id = Column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=True)\n    user = relationship('User', backref='images')\n    tags = relationship('Tag', secondary=image_m2m_tag, backref='images')\n    rating = Column(Float, nullable=True)\n    created_at = Column(DateTime, default=func.now())\n    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())", "\n\nclass Image(Base):\n    __tablename__ = 'images'\n    id = Column(Integer, primary_key=True)\n    description = Column(String, nullable=True)\n    type = Column('TransformationsType', Enum(TransformationsType), default=TransformationsType.basic)\n    link = Column(String, nullable=False)\n    user_id = Column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=True)\n    user = relationship('User', backref='images')\n    tags = relationship('Tag', secondary=image_m2m_tag, backref='images')\n    rating = Column(Float, nullable=True)\n    created_at = Column(DateTime, default=func.now())\n    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())", "\n\nclass Tag(Base):\n    __tablename__ = 'tags'\n    id = Column(Integer, primary_key=True)\n    name = Column(String(20), nullable=False, unique=True)\n\n\nclass Comment(Base):\n    __tablename__ = 'comments'\n    id = Column(Integer, primary_key=True)\n    comment = Column(String(2000))\n    user_id = Column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=True)\n    user = relationship('User', backref='comments')\n    image_id = Column(Integer, ForeignKey('images.id', ondelete='CASCADE'), nullable=True)\n    image = relationship('Image', backref='comments')\n    created_at = Column(DateTime, default=func.now())\n    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())", "class Comment(Base):\n    __tablename__ = 'comments'\n    id = Column(Integer, primary_key=True)\n    comment = Column(String(2000))\n    user_id = Column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=True)\n    user = relationship('User', backref='comments')\n    image_id = Column(Integer, ForeignKey('images.id', ondelete='CASCADE'), nullable=True)\n    image = relationship('Image', backref='comments')\n    created_at = Column(DateTime, default=func.now())\n    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())", "\n\nclass Rating(Base):\n    __tablename__ = 'ratings'\n\n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=True)\n    user = relationship(\"User\", backref='ratings')\n    image_id = Column(Integer, ForeignKey('images.id', ondelete='CASCADE'), nullable=True)\n    image = relationship(\"Image\", backref='ratings')\n    rating = Column(Float, CheckConstraint('rating >= 1 AND rating <= 5'))\n    created_at = Column(DateTime, default=func.now())\n\n    __table_args__ = (UniqueConstraint('user_id', 'image_id', name='_user_image_uc'),)", ""]}
{"filename": "src/database/db.py", "chunked_list": ["# from datetime import datetime\n# import traceback\n\nfrom fastapi import HTTPException, status\nimport redis\nimport redis.asyncio as aredis\nfrom redis.exceptions import AuthenticationError\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import declarative_base, sessionmaker\nfrom sqlalchemy.exc import SQLAlchemyError", "from sqlalchemy.orm import declarative_base, sessionmaker\nfrom sqlalchemy.exc import SQLAlchemyError\n\nfrom src.conf.config import settings\nfrom src.conf.messages import MSC500_DATABASE_CONFIG, MSC500_DATABASE_CONNECT\nfrom src.services.asyncdevlogging import async_logging_to_file\n\n\nURI = settings.sqlalchemy_database_url\n", "URI = settings.sqlalchemy_database_url\n\n\nengine = create_engine(URI, echo=True)\nDBSession = sessionmaker(bind=engine, autoflush=False, autocommit=False)\nBase = declarative_base()\n\n\ndef get_db():\n    db = DBSession()\n    try:\n        yield db\n\n    except SQLAlchemyError as err:\n        db.rollback()\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(err))\n\n    finally:\n        db.close()", "def get_db():\n    db = DBSession()\n    try:\n        yield db\n\n    except SQLAlchemyError as err:\n        db.rollback()\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(err))\n\n    finally:\n        db.close()", "\n\ndef get_redis(is_async: bool = True):\n    module = {\n        True: aredis,\n        False: redis\n    }\n    redis_module = module[is_async]\n    try:\n        if settings.redis_password and settings.redis_password != '0':\n            redis_client = redis_module.Redis(\n                                    host=settings.redis_host,\n                                    port=settings.redis_port,\n                                    db=0,\n                                    password=settings.redis_password\n                                    )\n\n        else:\n            redis_client = redis_module.Redis(\n                                    host=settings.redis_host,\n                                    port=settings.redis_port,\n                                    db=0\n                                    )\n\n    except AuthenticationError as error:\n        redis_client = None\n        print(f'Authentication failed to connect to redis\\n{error}')\n        # await async_logging_to_file(f'\\n500:\\t{datetime.now()}\\t{MSC500_DATABASE_CONFIG}: {err}\\t{traceback.extract_stack(None, 2)[1][2]}')\n\n    except Exception as error:\n        redis_client = None\n        print(f'Unable to connect to redis\\n{error}')\n        # await async_logging_to_file(f'\\n500:\\t{datetime.now()}\\t{MSC500_DATABASE_CONNECT}: {err}\\t{traceback.extract_stack(None, 2)[1][2]}')\n\n    return redis_client if redis_client else None", ""]}
{"filename": "src/services/images.py", "chunked_list": ["import hashlib\nimport io\nfrom typing import BinaryIO\n\nimport qrcode\nimport cloudinary\nfrom cloudinary.uploader import upload\n\nfrom src.conf.config import settings\nfrom src.database.models import Image", "from src.conf.config import settings\nfrom src.database.models import Image\n\n\nclass CloudImage:\n    cloudinary.config(\n        cloud_name=settings.cloudinary_name,\n        api_key=settings.cloudinary_api_key,\n        api_secret=settings.cloudinary_api_secret,\n        secure=True\n    )\n\n    filters = {\n        'avatar': [\n            {'aspect_ratio': '1.0', 'gravity': 'face', 'width': 500, 'zoom': '1', 'crop': 'thumb'},\n            {'radius': 'max'},\n            {'color': 'brown', 'effect': 'outline'}\n        ],\n        'black_white': [{'effect': 'grayscale'}],\n        'delete_bg': [{'effect': 'bgremoval'}],\n        'cartoonify': [{'effect': 'cartoonify'}],\n        'oil_paint': [{'effect': 'oil_paint:100'}],\n        'vector': [{'effect': 'vectorize:colors:5:corners:40:detail:1.0'}],\n        'sepia': [{'effect': 'sepia:100'}],\n        'outline': [\n            {'width': 200, 'crop': 'scale'},\n            {'color': 'blue', 'effect': 'outline:20:200'},\n            {'color': 'yellow', 'effect': 'outline:15:200'}\n        ]\n    }\n\n    @classmethod\n    def generate_name_avatar(cls, email: str):\n        user_name = hashlib.sha256(email.encode('utf-8')).hexdigest()[:14]\n\n        return f'FRT-PHOTO-SHARE-AVATARS/{user_name}'\n\n    @classmethod\n    def get_url_for_avatar(cls, public_id, res, clipping: tuple[int, int] = (120, 120)) -> str:\n        return (\n            cloudinary\n            .CloudinaryImage(public_id)\n            .build_url(width=clipping[0], height=clipping[1], crop='fill', version=res.get('version'))\n        )\n\n    @classmethod\n    def avatar_upload(cls, file: BinaryIO, email: str, clipping: tuple[int, int] = (120, 120)) -> str:\n        avatar_id = cls.generate_name_avatar(email)\n        upload_result = cloudinary.uploader.upload(file, public_id=avatar_id, overwrite=True)\n\n        return cls.get_url_for_avatar(avatar_id, upload_result, clipping)\n\n    @classmethod\n    def generate_name_image(cls, email: str, filename: str):\n        image_name = hashlib.sha256(email.encode('utf-8')).hexdigest()[:12]\n        image_sufix = hashlib.sha256(filename.encode('utf-8')).hexdigest()[:12]\n\n        return f'FRT-PHOTO-SHARE-IMAGES/{image_name}-{image_sufix}'\n\n    @classmethod\n    def image_upload(cls, file, public_id: str):\n        return cloudinary.uploader.upload(file, public_id=public_id, overwrite=True)\n\n    @classmethod\n    def get_url_for_image(cls, public_id, r):\n        src_url = cloudinary.CloudinaryImage(public_id).build_url(version=r.get('version'))\n\n        return src_url\n\n    @classmethod\n    def transformation(cls, image: Image, type):\n        old_link = image.link\n        break_point = old_link.find('/upload/') + settings.break_point\n        image_name = old_link[break_point:]\n        new_link = cloudinary.CloudinaryImage(image_name).build_url(transformation=CloudImage.filters[type.value])\n\n        return new_link\n\n    @classmethod\n    def get_qrcode(cls, image: Image):\n        qr_code = qrcode.QRCode(\n            error_correction=qrcode.constants.ERROR_CORRECT_M,\n            box_size=7,\n            border=4,\n        )\n        url = image.link\n        qr_code.add_data(url)\n        qr_code.make(fit=True)\n        img = qr_code.make_image(fill_color=\"black\", back_color=\"white\")\n        output = io.BytesIO()\n        img.save(output)\n        output.seek(0)\n\n        return output", ""]}
{"filename": "src/services/auth.py", "chunked_list": ["from datetime import datetime, timedelta\nimport traceback\nimport pickle\nfrom typing import Optional\nimport secrets\nimport string\n\nfrom fastapi import HTTPException, Depends, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt", "from fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom fastapi.security import HTTPBearer\nfrom sqlalchemy.orm import Session\n\nfrom src.conf.config import settings\nfrom src.conf import messages\nfrom src.database.db import get_db, get_redis\nfrom src.database.models import User", "from src.database.db import get_db, get_redis\nfrom src.database.models import User\nfrom src.repository import users as repository_users\nfrom src.services.asyncdevlogging import async_logging_to_file\n\n\nclass AuthPassword:\n    @staticmethod\n    def get_hash_password(password: str) -> str:\n        pwd_context = CryptContext(schemes=['bcrypt'], deprecated='auto')\n\n        return pwd_context.hash(password)\n\n    @staticmethod\n    def get_new_password(password_length: int = settings.password_length, meeting_limit: int = 3) -> str:\n        letters = string.ascii_letters\n        digits = string.digits\n        special_chars = string.punctuation\n\n        alphabet = letters + digits + special_chars\n\n        while True:\n            pwd = ''\n            for i in range(password_length):\n                pwd += ''.join(secrets.choice(alphabet))\n\n            if (any(char in special_chars for char in pwd) and\n                    sum(char in digits for char in pwd) >= meeting_limit):\n                break\n\n        return AuthPassword.get_hash_password(pwd)\n\n    @staticmethod\n    def verify_password(password: str, hashed_password: str) -> str:\n        pwd_context = CryptContext(schemes=['bcrypt'], deprecated='auto')\n\n        return pwd_context.verify(password, hashed_password)", "\n\nclass AuthToken:\n    oauth2_scheme: OAuth2PasswordBearer = OAuth2PasswordBearer(tokenUrl='/api/auth/login')\n    SECRET_KEY = settings.secret_key\n    ALGORITHM = settings.algorithm\n    credentials_exception = HTTPException(\n                                          status_code=status.HTTP_401_UNAUTHORIZED,\n                                          detail=messages.MSC401_CREDENTIALS,\n                                          headers={'WWW-Authenticate': messages.TOKEN_TYPE},\n                                          )\n\n    @classmethod\n    async def create_token(cls, data: dict, expires_delta: Optional[float] = None, token_type: str = None) -> str:\n        to_encode = data.copy()\n        token_type_mapping = {\n                              'access_token': settings.access_token_timer,\n                              'refresh_token': settings.refresh_token_timer,\n                              'password_reset_token': settings.password_reset_token_timer,\n                              'email_token': settings.email_token_timer,\n                              }\n        default_token_lifetime_limit = token_type_mapping.get(token_type, 0)\n\n        if expires_delta:\n            expire = datetime.utcnow() + timedelta(expires_delta)\n\n        else:\n            expire = datetime.utcnow() + timedelta(hours=default_token_lifetime_limit)\n\n        to_encode.update({'iat': datetime.utcnow(), 'exp': expire, 'scope': token_type})\n        token = jwt.encode(to_encode, AuthToken.SECRET_KEY, AuthToken.ALGORITHM)\n\n        return token\n\n    @classmethod\n    async def get_email_from_token(cls, token: str = Depends(oauth2_scheme), token_type: str = None) -> str:\n        try:\n            payload = jwt.decode(token, AuthToken.SECRET_KEY, algorithms=[AuthToken.ALGORITHM])\n            email = payload['sub']\n            if not token_type:\n                return email\n\n            elif payload['scope'] == token_type:\n                if email is None:\n                    raise AuthToken.credentials_exception  # MSC401_EMAIL ?\n\n            else:\n                raise AuthToken.credentials_exception  # MSC401_TOKEN_SCOPE ?\n\n        except JWTError as e:\n            await async_logging_to_file(f'\\n3XX:\\t{datetime.now()}\\tJWTError: {e}\\t{traceback.extract_stack(None, 2)[1][2]}')\n            raise HTTPException(\n                                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n                                detail=messages.MSC422_INVALID_TOKEN\n                                )\n        return email\n\n    @staticmethod\n    async def token_check(payload: dict, token_type: str = 'access_token') -> str:\n        if payload['scope'] == token_type:\n            email = payload['sub']\n            if email is None:\n                raise AuthToken.credentials_exception\n\n        else:\n            raise AuthToken.credentials_exception\n\n        return email", "\n\nclass AuthUser(AuthToken):\n    redis_client = get_redis(False)\n\n    @classmethod\n    async def clear_user_cash(cls, user_email) -> None:\n        AuthUser.redis_client.delete(user_email)\n\n    @classmethod\n    async def get_current_user(\n                               cls,\n                               token: str = Depends(AuthToken.oauth2_scheme),\n                               db: Session = Depends(get_db)\n                               ) -> dict:\n        email: str = await AuthToken.get_email_from_token(token, token_type='access_token')\n\n        bl_token = AuthUser.redis_client.get(token)\n        if bl_token:\n            raise AuthUser.credentials_exception\n\n        user: Optional[dict] = AuthUser.redis_client.get(email) if AuthUser.redis_client else None\n        if user is None:\n            user: User = await repository_users.get_user_by_email(email, db)\n\n            user = {\n                    'id': user.id,\n                    'username': user.username,\n                    'email': user.email,\n                    'roles': user.roles,\n                    'status_active': user.status_active,\n                   }\n\n            if user is None:\n                raise AuthUser.credentials_exception\n\n            AuthUser.redis_client.set(email, pickle.dumps(user)) if AuthUser.redis_client else None\n            AuthUser.redis_client.expire(email, settings.redis_user_timer) if AuthUser.redis_client else None\n\n        else:\n            user: User = pickle.loads(user)\n\n        if not user.get('status_active'):\n            await async_logging_to_file(f'\\n5XX:\\t{datetime.now()}\\tUser_status: {user[\"status_active\"]}\\t{traceback.extract_stack(None, 2)[1][2]}')\n            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=messages.MSC403_USER_BANNED)\n\n        return user\n\n    @classmethod\n    async def logout_user(cls,\n                          token: str = Depends(AuthToken.oauth2_scheme),\n                          db: Session = Depends(get_db)\n                          ) -> None:\n        try:\n            payload = jwt.decode(token, AuthUser.SECRET_KEY, AuthUser.ALGORITHM)\n            email = await AuthUser.token_check(payload, token_type='access_token')\n\n        except:\n            raise AuthUser.credentials_exception\n\n        now = datetime.timestamp(datetime.now())\n        time_delta = payload['exp'] - now + settings.redis_addition_lag\n        AuthUser.redis_client.set(token, 'True')\n        AuthUser.redis_client.expire(token, int(time_delta))\n        user = await repository_users.get_user_by_email(email, db)\n        user.refresh_token = None\n        db.commit()", "\n\nsecurity = HTTPBearer()\n"]}
{"filename": "src/services/asyncdevlogging.py", "chunked_list": ["from pathlib import Path\nimport logging\nimport sys\n\nfrom aiofile import async_open\nfrom aiopath import AsyncPath\n\n\nlogging.basicConfig(level=logging.DEBUG, format='%(threadName)s %(message)s')\nasync_log_file = 'frt_photo_share_asynclog.txt'", "logging.basicConfig(level=logging.DEBUG, format='%(threadName)s %(message)s')\nasync_log_file = 'frt_photo_share_asynclog.txt'\nasync_log_file = str(Path(sys.argv[0]).parent.absolute().joinpath('logs', async_log_file))\n\n\nasync def async_logging_to_file(message: str) -> None:\n    apath = AsyncPath(Path(async_log_file).parent)\n    await apath.mkdir(parents=True, exist_ok=True)\n    if apath.exists() and apath.is_file():\n        mode_file_open: str = 'a+'\n\n    elif not apath.exists():\n        mode_file_open: str = 'w+'\n\n    else:\n        logging.warning(f'Sorry, no log-file and can\\'t create \"{async_log_file}\".')\n        return None", "    if apath.exists() and apath.is_file():\n        mode_file_open: str = 'a+'\n\n    elif not apath.exists():\n        mode_file_open: str = 'w+'\n\n    else:\n        logging.warning(f'Sorry, no log-file and can\\'t create \"{async_log_file}\".')\n        return None\n", "\n    async with async_open(async_log_file, mode_file_open) as afp:\n        await afp.write(f'{message}\\n')\n"]}
{"filename": "src/services/email.py", "chunked_list": ["from datetime import datetime\nfrom pathlib import Path\nimport traceback\n\nfrom fastapi_mail import ConnectionConfig, FastMail, MessageSchema, MessageType\nfrom fastapi_mail.errors import ConnectionErrors\nfrom pydantic import EmailStr\n\nfrom src.conf.config import settings\nfrom src.conf import messages", "from src.conf.config import settings\nfrom src.conf import messages\nfrom src.services.asyncdevlogging import async_logging_to_file\nfrom src.services.auth import AuthToken\n\nconf = ConnectionConfig(\n    MAIL_USERNAME=settings.mail_username,\n    MAIL_PASSWORD=settings.mail_password,\n    MAIL_FROM=EmailStr(settings.mail_from),\n    MAIL_PORT=settings.mail_port,", "    MAIL_FROM=EmailStr(settings.mail_from),\n    MAIL_PORT=settings.mail_port,\n    MAIL_SERVER=settings.mail_server,\n    MAIL_FROM_NAME=settings.mail_from_name,\n    MAIL_STARTTLS=False,\n    MAIL_SSL_TLS=True,\n    USE_CREDENTIALS=True,\n    VALIDATE_CERTS=True,\n    TEMPLATE_FOLDER=Path(__file__).parent / 'templates',\n)", "    TEMPLATE_FOLDER=Path(__file__).parent / 'templates',\n)\n\n\nasync def send_email(email: EmailStr, username: str, host: str):\n    try:\n        token_verification = await AuthToken.create_token(data={'sub': email}, token_type='email_token')\n        mail_subject = messages.EMAIL_CONFIRMATION_REQUEST\n        message = MessageSchema(\n            subject=mail_subject,\n            recipients=[email],\n            template_body={\n                'subject': mail_subject,\n                'host': host,\n                'username': username,\n                'token': token_verification\n            },\n            subtype=MessageType.html\n        )\n\n        fm = FastMail(conf)\n        await fm.send_message(message, template_name='email_template.html')\n\n    except ConnectionErrors as err:\n        await async_logging_to_file(f'\\n500:\\t{datetime.now()}\\t{messages.MSC500_SENDING_EMAIL}: {err}\\t{traceback.extract_stack(None, 2)[1][2]}')", "\n\nasync def send_new_password(email: EmailStr, username: str, host: str, password: str):\n    subject = 'New password'\n    try:\n        message = MessageSchema(\n            subject=messages.PASSWORD_RESET_REQUEST,\n            recipients=[email],\n            template_body={\n                'subject': subject,\n                'host': host,\n                'username': username,\n                'new_password': password,\n            },\n            subtype=MessageType.html\n        )\n\n        fm = FastMail(conf)\n        await fm.send_message(message, template_name='new_password.html')\n\n    except ConnectionErrors as err:\n        await async_logging_to_file(f'\\n500:\\t{datetime.now()}\\t{messages.MSC500_SENDING_EMAIL}: {err}\\t{traceback.extract_stack(None, 2)[1][2]}')", "\n\nasync def send_reset_password(email: EmailStr, username: str, host: str):\n    subject = 'Reset password '\n    try:\n        token_verification = await AuthToken.create_token(data={'sub': email}, token_type='password_reset_token')\n        message = MessageSchema(\n            subject=messages.PASSWORD_RESET_REQUEST,\n            recipients=[email],\n            template_body={\n                'subject': subject,\n                'host': host,\n                'username': username,\n                'token': token_verification,\n            },\n            subtype=MessageType.html\n        )\n\n        fm = FastMail(conf)\n        await fm.send_message(message, template_name='password_reset.html')\n\n    except ConnectionErrors as err:\n        await async_logging_to_file(f'\\n500:\\t{datetime.now()}\\t{messages.MSC500_SENDING_EMAIL}: {err}\\t{traceback.extract_stack(None, 2)[1][2]}')", ""]}
{"filename": "src/services/roles.py", "chunked_list": ["from typing import List\n\nfrom fastapi import Depends, HTTPException, Request, status\n\nfrom src.database.models import Role\nfrom src.conf.messages import MSC403_FORBIDDEN\nfrom src.services.auth import AuthUser\n\n\nclass RoleAccess:\n    def __init__(self, allowed_roles: List[Role]):\n        self.allowed_roles = allowed_roles\n\n    async def __call__(self, request: Request, current_user: dict = Depends(AuthUser.get_current_user)):\n        if current_user.get('roles') not in self.allowed_roles:\n            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=MSC403_FORBIDDEN)", "\nclass RoleAccess:\n    def __init__(self, allowed_roles: List[Role]):\n        self.allowed_roles = allowed_roles\n\n    async def __call__(self, request: Request, current_user: dict = Depends(AuthUser.get_current_user)):\n        if current_user.get('roles') not in self.allowed_roles:\n            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=MSC403_FORBIDDEN)\n\n", "\n\nallowed_all_roles_access = RoleAccess([Role.admin, Role.moderator, Role.user])\nallowed_admin_moderator = RoleAccess([Role.admin, Role.moderator])\n"]}
{"filename": "src/conf/config.py", "chunked_list": ["from pydantic import BaseSettings\n\n\nclass Settings(BaseSettings):\n    sqlalchemy_database_url: str = 'postgresql+psycopg2://user:password@localhost:5432/postgres'\n    secret_key: str = 'secret_key'\n    algorithm: str = 'HS256'\n    mail_username: str = 'example@meta.ua'\n    mail_password: str = 'password'\n    mail_from: str = 'example@meta.ua'\n    mail_port: int = 465\n    mail_server: str = 'smtp.meta.ua'\n    mail_from_name: str = 'sender: app photo-share'\n    redis_host: str = 'localhost'\n    redis_password: str = ''\n    redis_port: int = 6379\n    cloudinary_name: str = 'name'\n    cloudinary_api_key: int = 1\n    cloudinary_api_secret: str = 'secret'\n    limit_crit: int = 12\n    limit_warn: int = 2\n    tags_limit: int = 5\n    limit_crit_timer: int = 60 # seconds\n    access_token_timer: int = 1 # hours\n    refresh_token_timer: int = 168 # hours\n    email_token_timer: int = 1 # hours\n    password_reset_token_timer: int = 1 # hours\n    redis_user_timer: int = 3600 # seconds\n    redis_addition_lag: int = 300\n    break_point: int = 8\n    password_length: int = 12\n\n    class Config:\n        env_file = '.env'\n        env_file_encoding = 'utf-8'", "\n\nsettings = Settings()\n"]}
{"filename": "src/conf/messages.py", "chunked_list": ["WELCOME = 'Welcome to Photo-Share by Fast Rabbit Team.'\nTOKEN_TYPE = 'Bearer'\nWELCOME_FASTAPI = 'Welcome to FastAPI!'\nMSC400_BAD_REQUEST = 'Verification error.'\nMSC400_ALREADY_RATED = 'User already rated this image.'\nMSC401_EMAIL = 'Invalid email.'\nMSC401_EMAIL_UNKNOWN = 'Unknown email.'\nMSC401_PASSWORD = 'Invalid password.'\nMSC401_TOKEN = 'Invalid token.'\nMSC401_TOKEN_SCOPE = 'Invalid scope for token.'", "MSC401_TOKEN = 'Invalid token.'\nMSC401_TOKEN_SCOPE = 'Invalid scope for token.'\nMSC401_CREDENTIALS = 'Could not validate credentials.'\nMSC404_IMAGE_NOT_FOUND = 'Image Not Found.'\nMSC404_USER_NOT_FOUND = 'User Not Found.'\nMSC404_COMMENT_NOT_FOUND = 'Comment Not Found.'\nMSC404_RATING_NOT_FOUND = 'Rating Not Found.'\nMSC404_TAG_NOT_FOUND = 'Tag Not Found.'\nMSC409_CONFLICT = 'This email is already in use.'\nMSC409_TAGS = 'To many tags. You can add 5 tags'", "MSC409_CONFLICT = 'This email is already in use.'\nMSC409_TAGS = 'To many tags. You can add 5 tags'\nMSC412_IMPOSSIBLE = 'Unable to complete the request.'\nMSC500_DATABASE_CONFIG = 'Database is not configured correctly.'\nMSC500_DATABASE_CONNECT = 'Error connecting to the database.'\nMSC503_UNKNOWN_USER = 'Can`t find user by email from token.'\nMSC201_USER_CREATED = 'User successfully created.'\nMSC403_FORBIDDEN = 'Operation forbidden.'\nMSC403_USER_BANNED = 'User is banned.'\nMSC422_EMAIL_VERIFICATION = 'Invalid token for email verification.'", "MSC403_USER_BANNED = 'User is banned.'\nMSC422_EMAIL_VERIFICATION = 'Invalid token for email verification.'\nMSC422_INVALID_TOKEN = 'Invalid token does not contain an email.'\nEMAIL_ERROR_CONFIRMED = 'Your email is already confirmed.'\nEMAIL_INFO_CONFIRMED = 'Check your email for confirmation.'\nEMAIL_INFO_CONFIRM = 'Email confirmed.'\nEMAIL_CONFIRMATION_REQUEST = 'Confirm your email.'\nPASSWORD_RESET_REQUEST = 'Reset password.'\nMSG_PASSWORD_CHENGED = 'User`s password successfully changed.'\nMSG_PASSWORD_RESET = 'Complete password reset.'", "MSG_PASSWORD_CHENGED = 'User`s password successfully changed.'\nMSG_PASSWORD_RESET = 'Complete password reset.'\nMSG_SENT_PASSWORD = 'Password-change email has been sent.'\nMSC500_SENDING_EMAIL = 'can`t send a letter.'\nRATING_DELETED = 'Rating deleted.'\nOWN_RATING = \"Can't rate own image.\"\nCOMMENT_DELETED = 'Comment deleted.'\nIMAGE_DELETED = 'Image deleted.'\n", ""]}
{"filename": "src/routes/images.py", "chunked_list": ["from typing import Optional, List\n\nfrom fastapi import APIRouter, Depends, File, HTTPException, Path, Security, status, UploadFile\nfrom fastapi_limiter.depends import RateLimiter\nfrom fastapi_pagination import add_pagination, Page, Params\nfrom fastapi.security import HTTPAuthorizationCredentials\nfrom starlette.responses import StreamingResponse\nfrom sqlalchemy.orm import Session\n\nfrom src.conf.config import settings", "\nfrom src.conf.config import settings\nfrom src.conf import messages\nfrom src.database.db import get_db\nfrom src.database.models import Image, TransformationsType\nfrom src.repository import images as repository_images\nfrom src.repository import tags as repository_tags\nfrom src.repository import users as repository_users\nfrom src.schemas.images import ImageModel, ImageResponse, SortDirection\nfrom src.schemas.users import MessageResponse", "from src.schemas.images import ImageModel, ImageResponse, SortDirection\nfrom src.schemas.users import MessageResponse\nfrom src.services.auth import AuthUser, security\nfrom src.services.images import CloudImage\nfrom src.services.roles import allowed_all_roles_access, allowed_admin_moderator\n\n\nrouter = APIRouter(prefix='/images', tags=['images'])\n\n", "\n\n@router.get(\n            '/',\n            description=f'Get images.\\nNo more than {settings.limit_crit} requests per minute.',\n            dependencies=[\n                          Depends(allowed_all_roles_access),\n                          Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n                          ],\n            response_model=Page", "                          ],\n            response_model=Page\n            )\nasync def get_images(\n                       db: Session = Depends(get_db),\n                       current_user: dict = Depends(AuthUser.get_current_user),\n                       credentials: HTTPAuthorizationCredentials = Security(security),\n                       pagination_params: Params = Depends()\n                       ) -> Page:\n    \"\"\"", "                       ) -> Page:\n    \"\"\"\n    The get_images function returns a list of images.\n\n    :param db: Session: Get the database session\n    :param current_user: dict: Get the current user from the database\n    :param credentials: HTTPAuthorizationCredentials: Authenticate the user\n    :param pagination_params: Params: Get the pagination parameters from the request\n    :return: A page object, which is a paginated list of image objects\n    :doc-author: Trelent", "    :return: A page object, which is a paginated list of image objects\n    :doc-author: Trelent\n    \"\"\"\n    images = await repository_images.get_images(current_user, db, pagination_params)\n\n    return images\n\n\n@router.post(\n             '/transformation/{image_id}',", "@router.post(\n             '/transformation/{image_id}',\n             description=f'Transform image.\\nNo more than {settings.limit_crit} requests per minute.',\n             dependencies=[\n                           Depends(allowed_all_roles_access),\n                           Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n                           ],\n             response_model=ImageResponse\n             )\nasync def transform_image(", "             )\nasync def transform_image(\n                          type: TransformationsType,\n                          image_id: int = Path(ge=1),\n                          db: Session = Depends(get_db),\n                          current_user: dict = Depends(AuthUser.get_current_user),\n                          credentials: HTTPAuthorizationCredentials = Security(security)\n                          ) -> Optional[Image]:\n    \"\"\"\n    The transform_image function is used to transform an image.", "    \"\"\"\n    The transform_image function is used to transform an image.\n    The function takes in the following parameters:\n    - type: TransformationsType, which is a transformation type from the enum TransformationsType.\n    - image_id: int = Path(ge=0), which is an integer representing the id of an existing image.\n    This parameter must be greater than or equal to 1 and it's required for this function to work properly.\n\n    :param type: TransformationsType: Define the type of transformation that will be applied to the image\n    :param image_id: int: Get the image from the database\n    :param db: Session: Get the database session", "    :param image_id: int: Get the image from the database\n    :param db: Session: Get the database session\n    :param current_user: dict: Get the user id of the current user\n    :param credentials: HTTPAuthorizationCredentials: Validate the token\n    :return: A new image with the transformation applied\n    :doc-author: Trelent\n    \"\"\"\n    image = await repository_images.get_image(image_id, current_user, db)\n    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n    if image.user_id != current_user['id']:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=messages.MSC400_BAD_REQUEST)", "    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n    if image.user_id != current_user['id']:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=messages.MSC400_BAD_REQUEST)\n\n    transform_image_link = CloudImage.transformation(image, type)\n\n    body = {\n            'description': image.description,\n            'link': transform_image_link,", "            'description': image.description,\n            'link': transform_image_link,\n            'tags': image.tags,\n            'type': type.value\n            }\n    new_image = await repository_images.transform_image(body, image.user_id, db)\n\n    return new_image\n\n", "\n\n@router.get(\n            '/qrcode/{image_id}',\n            description=f'No more than {settings.limit_crit} requests per minute',\n            dependencies=[\n                           Depends(allowed_all_roles_access),\n                           Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n                           ]\n            )", "                           ]\n            )\nasync def image_qrcode(\n                       image_id: int = Path(ge=1),\n                       db: Session = Depends(get_db),\n                       current_user: dict = Depends(AuthUser.get_current_user),\n                       credentials: HTTPAuthorizationCredentials = Security(security),\n                       ):\n    \"\"\"\n    The image_qrcode function returns a QR code for the image.", "    \"\"\"\n    The image_qrcode function returns a QR code for the image.\n\n    :param image_id: int: Identify the image that is to be deleted\n    :param db: Session: Access the database\n    :param current_user: dict: Get the current user's information\n    :param credentials: HTTPAuthorizationCredentials: Authenticate the user\n    :param : Get the image id from the url\n    :return: A qr code for the image that can be used to download it\n    :doc-author: Trelent", "    :return: A qr code for the image that can be used to download it\n    :doc-author: Trelent\n    \"\"\"\n    image = await repository_images.get_image(image_id, current_user, db)\n    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\n    qr_code = CloudImage.get_qrcode(image)\n\n    return StreamingResponse(qr_code, media_type=\"image/png\")", "\n    return StreamingResponse(qr_code, media_type=\"image/png\")\n\n\n@router.get(\n            '/{image_id}',\n            description=f'Get image.\\nNo more than {settings.limit_warn} requests per minute.',\n            dependencies=[\n                          Depends(allowed_all_roles_access),\n                          Depends(RateLimiter(times=settings.limit_warn, seconds=settings.limit_crit_timer))", "                          Depends(allowed_all_roles_access),\n                          Depends(RateLimiter(times=settings.limit_warn, seconds=settings.limit_crit_timer))\n                          ],\n            response_model=ImageResponse\n            )\nasync def get_image(\n                    image_id: int = Path(ge=1),\n                    db: Session = Depends(get_db),\n                    current_user: dict = Depends(AuthUser.get_current_user),\n                    credentials: HTTPAuthorizationCredentials = Security(security)", "                    current_user: dict = Depends(AuthUser.get_current_user),\n                    credentials: HTTPAuthorizationCredentials = Security(security)\n                    ) -> Optional[Image]:\n    \"\"\"\n    The get_image function is used to retrieve a single image from the database.\n    The function takes in an image_id, which is the id of the desired image. The function also takes in a db session,\n    which will be used to query for images within the database. The current_user and credentials are required by FastAPI's\n    security system.\n\n    :param image_id: int: Get the image id from the path", "\n    :param image_id: int: Get the image id from the path\n    :param db: Session: Get a database session\n    :param current_user: dict: Get the current user\n    :param credentials: HTTPAuthorizationCredentials: Validate the authentication token\n    :return: A single image object\n    :doc-author: Trelent\n    \"\"\"\n    image = await repository_images.get_image(image_id, current_user, db)\n    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)", "    image = await repository_images.get_image(image_id, current_user, db)\n    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\n    return image\n\n\n@router.post(\n            '/',\n            description=f'Create image.\\nNo more than {settings.limit_warn} requests per minute.',", "            '/',\n            description=f'Create image.\\nNo more than {settings.limit_warn} requests per minute.',\n            dependencies=[\n                          Depends(allowed_all_roles_access),\n                          Depends(RateLimiter(times=settings.limit_warn, seconds=settings.limit_crit_timer))\n                          ],\n            response_model=ImageResponse\n            )\nasync def create_image(\n                       description: str = '-',", "async def create_image(\n                       description: str = '-',\n                       tags: str = '',\n                       file: UploadFile = File(),\n                       db: Session = Depends(get_db),\n                       current_user: dict = Depends(AuthUser.get_current_user),\n                       credentials: HTTPAuthorizationCredentials = Security(security)\n                       ) -> Image:\n    \"\"\"\n    The create_image function creates a new image in the database.", "    \"\"\"\n    The create_image function creates a new image in the database.\n\n    :param description: str: Set the description of the image\n    :param tags: str: Pass the tags for the image\n    :param file: UploadFile: Upload the file to cloudinary\n    :param db: Session: Access the database\n    :param current_user: dict: Get the current user from the database\n    :param credentials: HTTPAuthorizationCredentials: Authenticate the user\n    :return: The created image object", "    :param credentials: HTTPAuthorizationCredentials: Authenticate the user\n    :return: The created image object\n    :doc-author: Trelent\n    \"\"\"\n    public_id = CloudImage.generate_name_image(current_user.get('email'), file.filename)\n    r = CloudImage.image_upload(file.file, public_id)\n    src_url = CloudImage.get_url_for_image(public_id, r)\n    body = {\n            'description': description,\n            'link': src_url,", "            'description': description,\n            'link': src_url,\n            'tags': tags\n            }\n    image = await repository_images.create_image(body, current_user.get('id'), db, settings.tags_limit)\n\n    return image\n\n\n@router.delete(", "\n@router.delete(\n               '/{image_id}',\n               description=f'Remove image.\\nNo more than {settings.limit_crit} requests per minute.',\n               dependencies=[\n                             Depends(RateLimiter(times=settings.limit_warn, seconds=settings.limit_crit_timer))\n                             ],\n               response_model=MessageResponse\n               )\nasync def remove_image(", "               )\nasync def remove_image(\n                       image_id: int = Path(ge=1),\n                       db: Session = Depends(get_db),\n                       current_user: dict = Depends(AuthUser.get_current_user),\n                       credentials: HTTPAuthorizationCredentials = Security(security)\n                       ) -> dict:\n\n    \"\"\"\n    The remove_image function is used to remove an image from the database.", "    \"\"\"\n    The remove_image function is used to remove an image from the database.\n    The function takes in a required image_id parameter, which is the id of the image that will be removed.\n    The function also takes in a db parameter, which is used to access and modify data within our database.\n    This db parameter uses Depends(get_db) as its default value, meaning it will use get_db() as its default value if no other value for this paramter is provided when calling this function.\n\n\n    :param image_id: int: Specify the id of the image to be removed\n    :param db: Session: Pass the database connection to the function\n    :param current_user: dict: Get the current user information", "    :param db: Session: Pass the database connection to the function\n    :param current_user: dict: Get the current user information\n    :param credentials: HTTPAuthorizationCredentials: Authenticate the user\n    :return: A dict with a key &quot;message&quot; and value of the message\n    :doc-author: Trelent\n    \"\"\"\n    message = await repository_images.remove_image(image_id, current_user, db)\n    return message\n\n", "\n\n@router.put(\n            '/{image_id}',\n            description=f'Update image.\\nNo more than {settings.limit_crit} requests per minute.',\n            dependencies=[Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n                          ],\n            response_model=ImageResponse\n            )\nasync def update_image(", "            )\nasync def update_image(\n                       body: ImageModel,\n                       image_id: int = Path(ge=1),\n                       db: Session = Depends(get_db),\n                       current_user: dict = Depends(AuthUser.get_current_user),\n                       credentials: HTTPAuthorizationCredentials = Security(security)\n                       ) -> Image:\n    \"\"\"\n    The update_image function updates an image in the database.", "    \"\"\"\n    The update_image function updates an image in the database.\n\n    :param body: ImageModel: Validate the data sent in the request body\n    :param image_id: int: Get the image id from the path\n    :param db: Session: Get the database session\n    :param current_user: dict: Get the current user information\n    :param credentials: HTTPAuthorizationCredentials: Check if the user is authenticated\n    :return: The updated image\n    :doc-author: Trelent", "    :return: The updated image\n    :doc-author: Trelent\n    \"\"\"\n    image = await repository_images.update_image(image_id, body, current_user, db, settings.tags_limit)\n    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\n    return image\n\n", "\n\n@router.get(\n            '/search_bytag/{tag_name}',\n            description=f'Get images by tag.\\nNo more than {settings.limit_warn} requests per minute.',\n            dependencies=[\n                          Depends(allowed_all_roles_access),\n                          Depends(RateLimiter(times=settings.limit_warn, seconds=settings.limit_crit_timer))\n                          ],\n            response_model=List[ImageResponse]", "                          ],\n            response_model=List[ImageResponse]\n            )\nasync def get_image_by_tag_name(\n                                tag_name: str,\n                                sort_direction: SortDirection,\n                                db: Session = Depends(get_db),\n                                current_user: dict = Depends(AuthUser.get_current_user),\n                                credentials: HTTPAuthorizationCredentials = Security(security)\n                                ) -> List[Image]:", "                                credentials: HTTPAuthorizationCredentials = Security(security)\n                                ) -> List[Image]:\n    \"\"\"\n    The get_image_by_tag_name function returns a list of images that have the tag name specified in the request.\n    The function takes three parameters:\n    - tag_name: The name of the tag to search for. This is a required parameter and must be passed as part of\n    the URL path (e.g., /images/tags/{tag_name}). It is also validated by FastAPI to ensure it meets\n    certain criteria, such as being non-empty and not exceeding 255 characters in length.\n\n    :param tag_name: str: Specify the tag name to search for", "\n    :param tag_name: str: Specify the tag name to search for\n    :param sort_direction: SortDirection: Sort the images by date\n    :param db: Session: Get the database session\n    :param current_user: dict: Get the current user from the database\n    :param credentials: HTTPAuthorizationCredentials: Validate the token\n    :return: A list of images\n    :doc-author: Trelent\n    \"\"\"\n    tag = await repository_tags.get_tag_by_name(tag_name, db)\n    if tag is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_TAG_NOT_FOUND)", "    \"\"\"\n    tag = await repository_tags.get_tag_by_name(tag_name, db)\n    if tag is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_TAG_NOT_FOUND)\n\n    images = await repository_images.get_images_by_tag(tag, sort_direction, db)\n    if images is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\n    return images", "\n    return images\n\n\n@router.get(\n            '/search_byuser/{user_id}',\n            description=f'Get images by user_id.\\nNo more than {settings.limit_warn} requests per minute.',\n            dependencies=[\n                          Depends(allowed_admin_moderator),\n                          Depends(RateLimiter(times=settings.limit_warn, seconds=settings.limit_crit_timer))", "                          Depends(allowed_admin_moderator),\n                          Depends(RateLimiter(times=settings.limit_warn, seconds=settings.limit_crit_timer))\n                          ],\n            response_model=List[ImageResponse]\n            )\nasync def get_image_by_user(\n                            user_id: int,\n                            sort_direction: SortDirection,\n                            db: Session = Depends(get_db),\n                            current_user: dict = Depends(AuthUser.get_current_user),", "                            db: Session = Depends(get_db),\n                            current_user: dict = Depends(AuthUser.get_current_user),\n                            credentials: HTTPAuthorizationCredentials = Security(security)\n                            ) -> List[Image]:\n    \"\"\"\n    The get_image_by_user function returns a list of images that are associated with the user_id provided.\n    The function will return an HTTP 404 error if no image is found or if the user_id does not exist.\n\n    :param user_id: int: Get the user id from the url\n    :param sort_direction: SortDirection: Sort the images by date in ascending or descending order", "    :param user_id: int: Get the user id from the url\n    :param sort_direction: SortDirection: Sort the images by date in ascending or descending order\n    :param db: Session: Get the database session\n    :param current_user: dict: Get the current user's id\n    :param credentials: HTTPAuthorizationCredentials: Authenticate the user\n    :return: A list of images\n    :doc-author: Trelent\n    \"\"\"\n    user = await repository_users.get_user_by_id(user_id, db)\n    if user is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)", "    user = await repository_users.get_user_by_id(user_id, db)\n    if user is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)\n\n    images = await repository_images.get_images_by_user(user_id, sort_direction, db)\n    if not any(images):\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\n    return images\n", "    return images\n\n\nadd_pagination(router)\n"]}
{"filename": "src/routes/ratings.py", "chunked_list": ["from typing import Optional, List\n\nfrom fastapi import APIRouter, Depends, Path, Security, HTTPException, status\nfrom fastapi.security import HTTPAuthorizationCredentials\nfrom fastapi_limiter.depends import RateLimiter\nfrom sqlalchemy.orm import Session\n\nfrom src.conf import messages\nfrom src.conf.config import settings\nfrom src.database.db import get_db", "from src.conf.config import settings\nfrom src.database.db import get_db\nfrom src.database.models import Rating\nfrom src.schemas.images import RatingResponse, RatingModel\nfrom src.schemas.users import MessageResponse\nfrom src.services.auth import AuthUser, security\nfrom src.services.roles import allowed_all_roles_access, allowed_admin_moderator\n\nfrom src.repository import images as repository_images\nfrom src.repository import ratings as repository_ratings", "from src.repository import images as repository_images\nfrom src.repository import ratings as repository_ratings\n\nrouter = APIRouter(prefix='/rating', tags=['ratings'])\n\n\n@router.post(\n             '/{image_id}',\n             description=f'Add rating.\\nCan rate for an image only once.',\n             dependencies=[", "             description=f'Add rating.\\nCan rate for an image only once.',\n             dependencies=[\n                           Depends(allowed_all_roles_access),\n                           Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n                           ],\n             response_model=RatingResponse\n             )\nasync def add_rating(\n                     body: RatingModel,\n                     image_id: int = Path(ge=1),", "                     body: RatingModel,\n                     image_id: int = Path(ge=1),\n                     db: Session = Depends(get_db),\n                     current_user: dict = Depends(AuthUser.get_current_user),\n                     credentials: HTTPAuthorizationCredentials = Security(security)\n                     ) -> RatingResponse:\n    image = await repository_images.get_image(image_id, current_user, db)\n    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n", "\n    existing_rating = db.query(Rating).filter_by(user_id=current_user['id'], image_id=image_id).first()\n    if existing_rating:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=messages.MSC400_ALREADY_RATED)\n\n    if image.user_id == current_user['id']:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=messages.OWN_RATING)\n\n    rating = await repository_ratings.add_rating(body, image_id, current_user, db)\n    return rating", "    rating = await repository_ratings.add_rating(body, image_id, current_user, db)\n    return rating\n\n\n@router.get(\n            '/{image_id}',\n            description=f'Get all ratings for image.\\nNo more than {settings.limit_crit} requests per minute.',\n            dependencies=[\n                          Depends(allowed_admin_moderator),\n                          Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))", "                          Depends(allowed_admin_moderator),\n                          Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n                          ],\n            response_model=List[RatingResponse]\n            )\nasync def get_ratings(\n                      image_id: int = Path(ge=1),\n                      db: Session = Depends(get_db),\n                      current_user: dict = Depends(AuthUser.get_current_user),\n                      credentials: HTTPAuthorizationCredentials = Security(security)", "                      current_user: dict = Depends(AuthUser.get_current_user),\n                      credentials: HTTPAuthorizationCredentials = Security(security)\n                      ) -> List[RatingResponse]:\n    image = await repository_images.get_image(image_id, current_user, db)\n    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\n    ratings = await repository_ratings.get_ratings(image_id, db)\n\n    return ratings", "\n    return ratings\n\n\n@router.delete(\n               '/{rating_id}',\n               description=f'Delete rating.\\nNo more than {settings.limit_crit} requests per minute.',\n               dependencies=[\n                             Depends(allowed_admin_moderator),\n                             Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))", "                             Depends(allowed_admin_moderator),\n                             Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n                             ],\n               response_model=MessageResponse\n               )\nasync def remove_rating(\n                        rating_id: int = Path(ge=1),\n                        db: Session = Depends(get_db),\n                        current_user: dict = Depends(AuthUser.get_current_user),\n                        credentials: HTTPAuthorizationCredentials = Security(security)", "                        current_user: dict = Depends(AuthUser.get_current_user),\n                        credentials: HTTPAuthorizationCredentials = Security(security)\n                        ) -> dict:\n    message = await repository_ratings.remove_rating(rating_id, current_user, db)\n\n    return message\n"]}
{"filename": "src/routes/auth.py", "chunked_list": ["from fastapi import (\n                     APIRouter,\n                     BackgroundTasks,\n                     Depends,\n                     HTTPException,\n                     Request,\n                     status,\n                     Security,\n                     )\nfrom fastapi.responses import HTMLResponse", "                     )\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.security import HTTPAuthorizationCredentials, OAuth2PasswordRequestForm\nfrom fastapi.templating import Jinja2Templates\nfrom starlette.responses import RedirectResponse\nfrom starlette.templating import _TemplateResponse\nfrom sqlalchemy.orm import Session\n\nfrom src.conf import messages\nfrom src.database.db import get_db", "from src.conf import messages\nfrom src.database.db import get_db\nfrom src.database.models import User\nfrom src.repository import users as repository_users\nfrom src.schemas.users import MessageResponse, RequestEmail, Token, UserModel, UserResponse\nfrom src.services.auth import AuthPassword, AuthToken, AuthUser, security\nfrom src.services.email import send_email, send_new_password, send_reset_password\n\n\nrouter = APIRouter(prefix='/auth', tags=['auth'])", "\nrouter = APIRouter(prefix='/auth', tags=['auth'])\ntemplates = Jinja2Templates(directory='src/services/templates')\n\n\n@router.post('/signup', response_model=UserResponse, status_code=status.HTTP_201_CREATED,\n             description='Create new user')\nasync def sign_up(\n                  body: UserModel,\n                  background_tasks: BackgroundTasks,", "                  body: UserModel,\n                  background_tasks: BackgroundTasks,\n                  request: Request,\n                  db: Session = Depends(get_db)\n                  ) -> User:\n    \"\"\"\n    The sign_up function creates a new user in the database.\n\n    :param body: UserModel: Get the data from the request body\n    :param background_tasks: BackgroundTasks: Add a task to the background queue", "    :param body: UserModel: Get the data from the request body\n    :param background_tasks: BackgroundTasks: Add a task to the background queue\n    :param request: Request: Get the base_url of the application\n    :param db: Session: Get the database session and pass it to the repository layer\n    :return: The new user created\n    :doc-author: Trelent\n    \"\"\"\n    check_user = await repository_users.get_user_by_email(body.email, db)\n    if check_user:\n        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=messages.MSC409_CONFLICT)", "    if check_user:\n        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=messages.MSC409_CONFLICT)\n\n    body.password = AuthPassword.get_hash_password(body.password)\n    new_user = await repository_users.create_user(body, db)\n    background_tasks.add_task(send_email, new_user.email, new_user.username, str(request.base_url))\n\n    return new_user\n\n", "\n\n@router.post('/login', response_model=Token)\nasync def login(body: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)) -> dict:\n    \"\"\"\n    The login function is used to authenticate a user.\n        It takes the username and password from the request body,\n        checks if they are correct, and returns an access token.\n\n    :param body: OAuth2PasswordRequestForm: Get the username and password from the request body", "\n    :param body: OAuth2PasswordRequestForm: Get the username and password from the request body\n    :param db: Session: Get a database session\n    :return: A new access token and a refresh token\n    :doc-author: Trelent\n    \"\"\"\n    user = await repository_users.get_user_by_email(body.username, db)\n    if user is None:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=messages.MSC401_EMAIL)\n\n    if not AuthPassword.verify_password(body.password, user.password):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=messages.MSC401_PASSWORD)", "\n    if not AuthPassword.verify_password(body.password, user.password):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=messages.MSC401_PASSWORD)\n\n    if not user.confirmed:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=messages.MSC401_EMAIL_UNKNOWN)\n\n    access_token = await AuthToken.create_token(data={'sub': user.email}, token_type='access_token')\n    refresh_token = await AuthToken.create_token(data={'sub': user.email}, token_type='refresh_token')\n    await repository_users.update_token(user, refresh_token, db)", "    refresh_token = await AuthToken.create_token(data={'sub': user.email}, token_type='refresh_token')\n    await repository_users.update_token(user, refresh_token, db)\n\n    return {'access_token': access_token, 'refresh_token': refresh_token, 'token_type': messages.TOKEN_TYPE}\n\n\n@router.get(\"/logout\", response_class=HTMLResponse)\nasync def logout(\n           credentials: HTTPAuthorizationCredentials = Security(security),\n           current_user: dict = Depends(AuthUser.logout_user)", "           credentials: HTTPAuthorizationCredentials = Security(security),\n           current_user: dict = Depends(AuthUser.logout_user)\n           ) -> RedirectResponse:\n    \"\"\"\n    The logout function is used to logout a user from the system.\n\n    :param credentials: HTTPAuthorizationCredentials: Get the credentials of the user\n    :param current_user: dict: Get the current user from the database\n    :return: A redirectresponse object with a status code of 205\n    :doc-author: Trelent", "    :return: A redirectresponse object with a status code of 205\n    :doc-author: Trelent\n    \"\"\"\n    resp = RedirectResponse(url=\"/login\", status_code=status.HTTP_205_RESET_CONTENT)\n\n    return resp\n\n\n@router.get('/refresh_token', response_model=Token)\nasync def refresh_token(", "@router.get('/refresh_token', response_model=Token)\nasync def refresh_token(\n                        credentials: HTTPAuthorizationCredentials = Security(security),\n                        db: Session = Depends(get_db)\n                        ) -> dict:\n    \"\"\"\n    The refresh_token function is used to refresh the access_token.\n        The function takes in a token and an email, then checks if the user exists.\n        If so, it creates new tokens for that user and returns them.\n", "        If so, it creates new tokens for that user and returns them.\n\n    :param credentials: HTTPAuthorizationCredentials: Get the token from the request header\n    :param db: Session: Access the database\n    :return: A new access_token and refresh_token\n    :doc-author: Trelent\n    \"\"\"\n    token = credentials.credentials\n    email = await AuthToken.get_email_from_token(token, 'refresh_token')\n    user = await repository_users.get_user_by_email(email, db)\n    if user.refresh_token != token:\n        await repository_users.update_token(user, None, db)\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=messages.MSC401_TOKEN)", "    email = await AuthToken.get_email_from_token(token, 'refresh_token')\n    user = await repository_users.get_user_by_email(email, db)\n    if user.refresh_token != token:\n        await repository_users.update_token(user, None, db)\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=messages.MSC401_TOKEN)\n\n    access_token = await AuthToken.create_token(data={'sub': user.email}, token_type='access_token')\n    refresh_token = await AuthToken.create_token(data={'sub': user.email}, token_type='refresh_token')\n    await repository_users.update_token(user, refresh_token, db)\n", "    await repository_users.update_token(user, refresh_token, db)\n\n    return {'access_token': access_token, 'refresh_token': refresh_token, 'token_type': messages.TOKEN_TYPE}\n\n\n@router.post('/request_confirm_email', response_model=MessageResponse)\nasync def request_confirm_email(\n                                body: RequestEmail,\n                                background_tasks: BackgroundTasks,\n                                request: Request,", "                                background_tasks: BackgroundTasks,\n                                request: Request,\n                                db: Session = Depends(get_db)\n                                ) -> dict:\n    \"\"\"\n    The request_confirm_email function is used to send a confirmation email to the user.\n        The function takes in an email address and sends a confirmation link to that address.\n        If the user already has an account, they will be sent another confirmation link.\n\n    :param body: RequestEmail: Get the email address from the request body", "\n    :param body: RequestEmail: Get the email address from the request body\n    :param background_tasks: BackgroundTasks: Add a task to the background\n    :param request: Request: Get the base_url of the application\n    :param db: Session: Get a database session from the dependency injection container\n    :return: A dictionary with a message\n    :doc-author: Trelent\n    \"\"\"\n    user = await repository_users.get_user_by_email(body.email, db)\n\n    if user and user.confirmed:\n        return {'message': messages.EMAIL_ERROR_CONFIRMED}", "    user = await repository_users.get_user_by_email(body.email, db)\n\n    if user and user.confirmed:\n        return {'message': messages.EMAIL_ERROR_CONFIRMED}\n\n    if user:\n        background_tasks.add_task(send_email, user.email, user.username, request.base_url)\n\n    return {'message': messages.EMAIL_INFO_CONFIRMED}\n", "    return {'message': messages.EMAIL_INFO_CONFIRMED}\n\n\n@router.get('/confirmed_email/{token}', response_model=MessageResponse)\nasync def confirmed_email(token: str, db: Session = Depends(get_db)) -> dict:\n    \"\"\"\n    The confirmed_email function is used to confirm the email of a user.\n        It takes in a token and returns an object with the message 'Email confirmed' if successful.\n\n    :param token: str: Get the email from the token", "\n    :param token: str: Get the email from the token\n    :param db: Session: Get a database session\n    :return: A dictionary with a message\n    :doc-author: Trelent\n    \"\"\"\n    email = await AuthToken.get_email_from_token(token)\n    user = await repository_users.get_user_by_email(email, db)\n    if user is None:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=messages.MSC400_BAD_REQUEST)", "    if user is None:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=messages.MSC400_BAD_REQUEST)\n\n    if user.confirmed:\n        return {'message': messages.EMAIL_ERROR_CONFIRMED}\n\n    await repository_users.confirmed_email(user, db)\n\n    return {'message': messages.EMAIL_INFO_CONFIRM}\n", "    return {'message': messages.EMAIL_INFO_CONFIRM}\n\n\n@router.post('/reset-password')\nasync def reset_password(\n                         body: RequestEmail,\n                         background_tasks: BackgroundTasks,\n                         request: Request,\n                         db: Session = Depends(get_db)\n                         ) -> dict:", "                         db: Session = Depends(get_db)\n                         ) -> dict:\n    \"\"\"\n    The reset_password function is used to send a password reset email to the user.\n        The function takes in an email address and sends a password reset link to that\n        address if it exists in the database. If not, then an error message is returned.\n\n    :param body: RequestEmail: Receive the email from the user\n    :param background_tasks: BackgroundTasks: Add a task to the background tasks queue\n    :param request: Request: Get the base_url of the application", "    :param background_tasks: BackgroundTasks: Add a task to the background tasks queue\n    :param request: Request: Get the base_url of the application\n    :param db: Session: Get the database session\n    :return: A message to the user\n    :doc-author: Trelent\n    \"\"\"\n    user = await repository_users.get_user_by_email(body.email, db)\n\n    if user:\n        if user.confirmed:\n            background_tasks.add_task(send_reset_password, user.email, user.username, request.base_url)\n\n            return {'message': messages.MSG_SENT_PASSWORD}\n\n        return {'message': messages.EMAIL_INFO_CONFIRMED}", "    if user:\n        if user.confirmed:\n            background_tasks.add_task(send_reset_password, user.email, user.username, request.base_url)\n\n            return {'message': messages.MSG_SENT_PASSWORD}\n\n        return {'message': messages.EMAIL_INFO_CONFIRMED}\n\n    return {'message': messages.MSC401_EMAIL_UNKNOWN}\n", "    return {'message': messages.MSC401_EMAIL_UNKNOWN}\n\n\n@router.get('/reset-password/done_request', response_class=HTMLResponse, description='Request password reset Page.')\nasync def reset_password_done(request: Request) -> _TemplateResponse:\n    \"\"\"\n    The reset_password_done function is called when the user clicks on the link in their email.\n    It displays a message that says `Your password has been reset.`\n\n    :param request: Request: Get the request object", "\n    :param request: Request: Get the request object\n    :return: A templateresponse object\n    :doc-author: Trelent\n    \"\"\"\n    return templates.TemplateResponse('password_reset_done.html', {'request': request,\n                                                                   'title': messages.MSG_SENT_PASSWORD})\n\n\n@router.post('/reset-password/confirm/{token}')", "\n@router.post('/reset-password/confirm/{token}')\nasync def reset_password_confirm(\n                                 background_tasks: BackgroundTasks,\n                                 request: Request,\n                                 token: str,\n                                 db: Session = Depends(get_db)\n                                 ) -> dict:\n    \"\"\"\n    The reset_password_confirm function is used to reset a user's password.", "    \"\"\"\n    The reset_password_confirm function is used to reset a user's password.\n        It takes the following parameters:\n            background_tasks: BackgroundTasks,\n            request: Request,\n            token: str,\n            db: Session = Depends(get_db)\n\n    :param background_tasks: BackgroundTasks: Add a background task to the queue\n    :param request: Request: Get the base_url of the application", "    :param background_tasks: BackgroundTasks: Add a background task to the queue\n    :param request: Request: Get the base_url of the application\n    :param token: str: Get the email from the token\n    :param db: Session: Get the database session\n    :return: A dict with the user and a message\n    :doc-author: Trelent\n    \"\"\"\n    email: str = await AuthToken.get_email_from_token(token)\n    exist_user = await repository_users.get_user_by_email(email, db)\n    if not exist_user:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n                            detail=messages.MSC503_UNKNOWN_USER)", "    exist_user = await repository_users.get_user_by_email(email, db)\n    if not exist_user:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n                            detail=messages.MSC503_UNKNOWN_USER)\n\n    new_password: str = AuthPassword.get_new_password()\n    password: str = AuthPassword.get_hash_password(new_password)\n\n    updated_user: User = await repository_users.change_password_for_user(exist_user, password, db)\n    if updated_user is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n                            detail=messages.MSC503_UNKNOWN_USER)", "    updated_user: User = await repository_users.change_password_for_user(exist_user, password, db)\n    if updated_user is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n                            detail=messages.MSC503_UNKNOWN_USER)\n\n    background_tasks.add_task(\n                              send_new_password,\n                              updated_user.email,\n                              updated_user.username,\n                              request.base_url,", "                              updated_user.username,\n                              request.base_url,\n                              new_password\n                              )\n\n    return {'user': updated_user, 'detail': messages.MSG_PASSWORD_CHENGED}\n\n\n@router.get('/reset-password/complete', response_class=HTMLResponse, description='Complete password reset Page.')\nasync def reset_password_complete(request: Request) -> _TemplateResponse:", "@router.get('/reset-password/complete', response_class=HTMLResponse, description='Complete password reset Page.')\nasync def reset_password_complete(request: Request) -> _TemplateResponse:\n    \"\"\"\n    The reset_password_complete function is called when the user has successfully reset their password.\n    It renders a template that informs the user of this fact.\n\n    :param request: Request: Get the request object\n    :return: The password_reset_complete\n    :doc-author: Trelent\n    \"\"\"", "    :doc-author: Trelent\n    \"\"\"\n    return templates.TemplateResponse('password_reset_complete.html', {'request': request,\n                                                                       'title': messages.MSG_PASSWORD_RESET})\n"]}
{"filename": "src/routes/users.py", "chunked_list": ["from typing import Optional\n\nfrom fastapi import APIRouter, Depends, HTTPException, Security, status, UploadFile, File\nfrom fastapi.security import HTTPAuthorizationCredentials\nfrom sqlalchemy.orm import Session\n\nfrom src.conf import messages\nfrom src.database.db import get_db\nfrom src.database.models import User\nfrom src.repository import users as repository_users", "from src.database.models import User\nfrom src.repository import users as repository_users\nfrom src.schemas.users import UserDb, UserResponseFull, UserType, UserBase\nfrom src.services.auth import AuthUser, security\n\nfrom src.services.images import CloudImage\nfrom src.services.roles import allowed_admin_moderator\n\n\nrouter = APIRouter(prefix='/users', tags=['users'])", "\nrouter = APIRouter(prefix='/users', tags=['users'])\n\n\n@router.get('/me', response_model=UserDb, name='Get user info')\nasync def read_users_me(\n                        current_user: dict = Depends(AuthUser.get_current_user),\n                        credentials: HTTPAuthorizationCredentials = Security(security),\n                        db: Session = Depends(get_db)\n                        ) -> User:", "                        db: Session = Depends(get_db)\n                        ) -> User:\n    \"\"\"\n    The read_users_me function is a GET request that returns the current user's information.\n    The function requires an authorization header with a valid JWT token to be passed in order for it to work.\n\n    :param current_user: dict: Get the current user from the database\n    :param credentials: HTTPAuthorizationCredentials: Validate the security scheme\n    :param db: Session: Pass the database session to the repository layer\n    :return: The user object of the currently logged in user", "    :param db: Session: Pass the database session to the repository layer\n    :return: The user object of the currently logged in user\n    :doc-author: Trelent\n    \"\"\"\n    return await repository_users.get_user_by_id(current_user.get('id'), db)\n\n\n@router.get('/{user_id}', response_model=UserResponseFull, name='Get user info by id')\nasync def read_user_by_id(\n                          user_id: int,", "async def read_user_by_id(\n                          user_id: int,\n                          current_user: dict = Depends(AuthUser.get_current_user),\n                          credentials: HTTPAuthorizationCredentials = Security(security),\n                          db: Session = Depends(get_db)\n                          ) -> dict:\n    \"\"\"\n    The read_user_by_id function reads a user by its id.\n\n    :param user_id: int: Get the user id from the url", "\n    :param user_id: int: Get the user id from the url\n    :param current_user: dict: Get the current user\n    :param credentials: HTTPAuthorizationCredentials: Validate the token in the header of the request\n    :param db: Session: Pass the database session to the repository layer\n    :return: A dictionary with the user information\n    :doc-author: Trelent\n    \"\"\"\n    user = await repository_users.get_user_by_id(user_id, db)\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)", "    user = await repository_users.get_user_by_id(user_id, db)\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)\n\n    user.number_images = await repository_users.get_number_of_images_per_user(user.email, db)\n    return user\n\n\n@router.put('/{user_id}', response_model=UserDb)\nasync def update_user_profile(", "@router.put('/{user_id}', response_model=UserDb)\nasync def update_user_profile(\n                              user_id: int,\n                              body: UserType,\n                              current_user: dict = Depends(AuthUser.get_current_user),\n                              credentials: HTTPAuthorizationCredentials = Security(security),\n                              db: Session = Depends(get_db)\n                              ) -> User:\n\n    \"\"\"", "\n    \"\"\"\n    The update_user_profile function updates the user profile.\n        Args:\n            user_id (int): The id of the user to update.\n            body (UserType): The updated information for the specified user.\n\n    :param user_id: int: Identify the user to be deleted\n    :param body: UserType: Validate the data sent by the user\n    :param current_user: dict: Get the current user", "    :param body: UserType: Validate the data sent by the user\n    :param current_user: dict: Get the current user\n    :param credentials: HTTPAuthorizationCredentials: Validate the token\n    :param db: Session: Access the database\n    :return: A user object\n    :doc-author: Trelent\n    \"\"\"\n    user = await repository_users.update_user_profile(user_id, current_user, body, db)\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)", "    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)\n\n    return user\n\n\n@router.put('/me/{user_id}', response_model=UserDb)\nasync def update_your_profile(\n                              user_id: int,\n                              body: Optional[UserBase] = None,", "                              user_id: int,\n                              body: Optional[UserBase] = None,\n                              current_user: dict = Depends(AuthUser.get_current_user),\n                              credentials: HTTPAuthorizationCredentials = Security(security),\n                              db: Session = Depends(get_db)\n                              ) -> User:\n    \"\"\"\n    The update_your_profile function updates the current user's profile.\n        Args:\n            user_id (int): The id of the user to update.", "        Args:\n            user_id (int): The id of the user to update.\n            body (UserBase): The updated information for the User object.\n\n    :param user_id: int: Identify the user\n    :param body: UserBase: Get the data from the request body\n    :param current_user: dict: Get the current user's email\n    :param credentials: HTTPAuthorizationCredentials: Check the token\n    :param db: Session: Access the database\n    :return: The user object", "    :param db: Session: Access the database\n    :return: The user object\n    :doc-author: Trelent\n    \"\"\"\n    user = await repository_users.update_your_profile(current_user.get('email'), body, db)\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)\n\n    return user\n", "    return user\n\n\n@router.patch('/avatar', response_model=UserDb)\nasync def update_avatar_user(\n                             file: UploadFile = File(),\n                             current_user: dict = Depends(AuthUser.get_current_user),\n                             credentials: HTTPAuthorizationCredentials = Security(security),\n                             db: Session = Depends(get_db)\n                             ) -> User:", "                             db: Session = Depends(get_db)\n                             ) -> User:\n    \"\"\"\n    The update_avatar_user function updates the avatar of a user.\n        The function takes in an UploadFile object (picture), which is a file that has been uploaded to the server.\n        It also takes in current_user and credentials as dependencies, which are used for authentication purposes.\n        Finally it takes in db as a dependency, which is used to access the database.\n\n    :param file: UploadFile: Upload the file to the cloud\n    :param current_user: dict: Get the current user's email", "    :param file: UploadFile: Upload the file to the cloud\n    :param current_user: dict: Get the current user's email\n    :param credentials: HTTPAuthorizationCredentials: Validate the token\n    :param db: Session: Access the database\n    :return: The user data\n    :doc-author: Trelent\n    \"\"\"\n    src_url = CloudImage.avatar_upload(file.file, current_user.get('email'))\n\n    user = await repository_users.update_avatar(current_user.get('email'), src_url, db)\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)", "\n    user = await repository_users.update_avatar(current_user.get('email'), src_url, db)\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)\n\n    return user\n\n\n@router.patch(\n              '/ban_user/{user_id}/{active_status}', response_model=UserDb,", "@router.patch(\n              '/ban_user/{user_id}/{active_status}', response_model=UserDb,\n              dependencies=[Depends(allowed_admin_moderator)],\n              description='Ban/unban user'\n              )\nasync def ban_user(\n                   user_id: int,\n                   active_status: bool,\n                   current_user: dict = Depends(AuthUser.get_current_user),\n                   credentials: HTTPAuthorizationCredentials = Security(security),", "                   current_user: dict = Depends(AuthUser.get_current_user),\n                   credentials: HTTPAuthorizationCredentials = Security(security),\n                   db: Session = Depends(get_db)\n                   ) -> User:\n    \"\"\"\n    The ban_user function is used to ban a user from the system.\n\n    :param user_id: int: Identify the user to be banned\n    :param active_status: bool: Set the user's status to active or inactive\n    :param current_user: dict: Get the current user from the authuser class", "    :param active_status: bool: Set the user's status to active or inactive\n    :param current_user: dict: Get the current user from the authuser class\n    :param db: Session: Access the database\n    :return: The banned user object\n    :doc-author: Trelent\n    \"\"\"\n    user: Optional[User] = await repository_users.ban_user(user_id, active_status, db)\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)\n", "\n    await AuthUser.clear_user_cash(user.email)\n\n    return user\n"]}
{"filename": "src/routes/comments.py", "chunked_list": ["from typing import Optional, List\n\nfrom fastapi import APIRouter, Depends, HTTPException, Path, Security, status\nfrom fastapi_limiter.depends import RateLimiter\nfrom fastapi.security import HTTPAuthorizationCredentials\nfrom sqlalchemy.orm import Session\nfrom src.schemas.users import MessageResponse\n\nfrom src.conf.config import settings\nfrom src.conf import messages", "from src.conf.config import settings\nfrom src.conf import messages\nfrom src.database.db import get_db\nfrom src.database.models import Comment\nfrom src.repository import images as repository_images\nfrom src.repository import comments as repository_comments\nfrom src.schemas.images import CommentModel, CommentResponse\nfrom src.services.auth import AuthUser, security\nfrom src.services.roles import allowed_all_roles_access, allowed_admin_moderator\n", "from src.services.roles import allowed_all_roles_access, allowed_admin_moderator\n\n\nrouter = APIRouter(prefix='/comment', tags=['comments'])\n\n\n@router.get(\n    '/{image_id}',\n    description=f'Get all comments on image.\\nNo more than {settings.limit_crit} requests per minute.',\n    dependencies=[", "    description=f'Get all comments on image.\\nNo more than {settings.limit_crit} requests per minute.',\n    dependencies=[\n        Depends(allowed_all_roles_access),\n        Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n    ],\n    response_model=List[CommentResponse],\n)\nasync def get_comments_by_image_id(\n        image_id: int = Path(ge=1),\n        db: Session = Depends(get_db),", "        image_id: int = Path(ge=1),\n        db: Session = Depends(get_db),\n        current_user: dict = Depends(AuthUser.get_current_user),\n        credentials: HTTPAuthorizationCredentials = Security(security)\n        ) -> List[Comment]:\n\n    \"\"\"\n    The get_comments_by_image_id function returns a list of comments for the image with the given id.\n\n    :param image_id: int: Get the comments of a specific image", "\n    :param image_id: int: Get the comments of a specific image\n    :param db: Session: Get the database session\n    :param current_user: dict: Get the current user's information\n    :param credentials: HTTPAuthorizationCredentials: Validate the token\n    :return: The comments associated with the image\n    :doc-author: Trelent\n    \"\"\"\n    image = await repository_images.get_image(image_id, current_user, db)\n    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)", "    image = await repository_images.get_image(image_id, current_user, db)\n    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\n    return await repository_comments.get_comments(image_id, db)\n\n@router.post(\n    '/{image_id}',\n    description=f'Add comment.\\nNo more than {settings.limit_crit} requests per minute.',\n    dependencies=[", "    description=f'Add comment.\\nNo more than {settings.limit_crit} requests per minute.',\n    dependencies=[\n        Depends(allowed_all_roles_access),\n        Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n    ],\n    response_model=CommentResponse,\n)\nasync def add_comment(\n        body: CommentModel,\n        image_id: int = Path(ge=1),", "        body: CommentModel,\n        image_id: int = Path(ge=1),\n        db: Session = Depends(get_db),\n        current_user: dict = Depends(AuthUser.get_current_user),\n        credentials: HTTPAuthorizationCredentials = Security(security)\n) -> Optional[Comment]:\n\n    \"\"\"\n    The add_comment function creates a new comment for an image.\n    The function takes in the following parameters:", "    The add_comment function creates a new comment for an image.\n    The function takes in the following parameters:\n    body: CommentModel - A model containing the information of the comment to be created.\n    image_id: int - The id of the image that will have a new comment added to it. This is passed as part of\n    path parameter and must be greater than or equal to 1 (Path(ge=0)).\n\n    :param body: CommentModel: Get the body of the comment\n    :param image_id: int: Get the image_id from the url\n    :param db: Session: Get the database session\n    :param current_user: dict: Get the current user from the database", "    :param db: Session: Get the database session\n    :param current_user: dict: Get the current user from the database\n    :param credentials: HTTPAuthorizationCredentials: Validate the token\n    :return: The created comment\n    :doc-author: Trelent\n    \"\"\"\n    image = await repository_images.get_image(image_id, current_user, db)\n    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n    comment = await repository_comments.add_comment(body, image_id, current_user, db)", "    comment = await repository_comments.add_comment(body, image_id, current_user, db)\n    return comment\n\n\n@router.put(\n            '/{comment_id}',\n            description=f'Update comment.\\nNo more than {settings.limit_crit} requests per minute.',\n            dependencies=[\n                Depends(allowed_all_roles_access),\n                Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))", "                Depends(allowed_all_roles_access),\n                Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n            ],\n            response_model=CommentResponse,\n             )\nasync def update_comment(\n                         body: CommentModel,\n                         comment_id: int = Path(ge=1),\n                         db: Session = Depends(get_db),\n                         current_user: dict = Depends(AuthUser.get_current_user),", "                         db: Session = Depends(get_db),\n                         current_user: dict = Depends(AuthUser.get_current_user),\n                         credentials: HTTPAuthorizationCredentials = Security(security)\n                         ) -> Comment:\n\n    \"\"\"\n    The update_comment function updates a comment in the database.\n    The function takes an id, body and current_user as parameters.\n    It returns a Comment object if successful.\n", "    It returns a Comment object if successful.\n\n    :param body: CommentModel: Get the data from the request body\n    :param comment_id: int: Get the comment id of the comment to be deleted\n    :param db: Session: Get the database session\n    :param current_user: dict: Get the user information from authuser\n    :param credentials: HTTPAuthorizationCredentials: Check the token\n    :return: A comment object\n    :doc-author: Trelent\n    \"\"\"", "    :doc-author: Trelent\n    \"\"\"\n    comment = await repository_comments.update_comment(comment_id, body, current_user, db)\n    if comment is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_COMMENT_NOT_FOUND)\n\n    return comment\n\n\n@router.delete(", "\n@router.delete(\n               '/{comment_id}',\n               description=f'Delete comment.\\nNo more than {settings.limit_crit} requests per minute.',\n               dependencies=[\n                             Depends(allowed_admin_moderator),\n                             Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n                             ],\n               response_model=MessageResponse\n               )", "               response_model=MessageResponse\n               )\nasync def remove_comment(\n                         comment_id: int = Path(ge=1),\n                         db: Session = Depends(get_db),\n                         current_user: dict = Depends(AuthUser.get_current_user),\n                         credentials: HTTPAuthorizationCredentials = Security(security)\n                         ) -> dict:\n\n    \"\"\"", "\n    \"\"\"\n    The remove_comment function removes a comment from the database.\n    The function takes in an integer representing the id of the comment to be removed,\n    and returns a dictionary containing information about whether or not it was successful.\n\n    :param comment_id: int: Get the comment id from the path\n    :param db: Session: Pass the database session to the function\n    :param current_user: dict: Get the current user information\n    :param credentials: HTTPAuthorizationCredentials: Authenticate the user", "    :param current_user: dict: Get the current user information\n    :param credentials: HTTPAuthorizationCredentials: Authenticate the user\n    :return: A dict with the message key and value\n    :doc-author: Trelent\n    \"\"\"\n    message = await repository_comments.remove_comment(comment_id, current_user, db)\n\n    return message\n", ""]}
