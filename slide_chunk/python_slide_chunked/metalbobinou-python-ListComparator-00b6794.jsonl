{"filename": "plugins/example_plugin.py", "chunked_list": ["from PluginLogic import PluginLogic\n\n# You can rename the class, but keep its name exactly like the file one\nclass example_logic(PluginLogic):\n    # Name for calling this plugin\n    name_str = \"TEST_PLUGIN\"\n\n    # Text printed when calling the script with wrong parameters\n    help_str = \"This is an example plugin that copy the 1st element of each \" \\\n        \"list (if the list isn't empty)\"\n\n    # Text of button in the GUI\n    button_str = \"Example Plugin\"\n\n    # The main function doing something with the lists and returning a list\n    def Logic(self, list1, list2):\n        out = []\n        if ((not (list1 is None)) and\n            (not (list2 is None))):\n            if (list1 != []):\n                out.append(list1[0])\n            if (list2 != []):\n                out.append(list2[0])\n        return (out)", ""]}
{"filename": "src/plugins_loader.py", "chunked_list": ["import os\n\n# Tools for loading modules and inspecting classes\nimport importlib\nimport inspect\n\n\n# The parent class of the plugins\nfrom PluginLogic import PluginLogic\n", "from PluginLogic import PluginLogic\n\n\n# The directory containing the plugins\ng_plugins_directory = \"plugins\"\n\n\nclass PluginsImporter:\n    # List of classes imported from the plugins\n    classes_list = []\n    nb_classes = 0\n\n    # State of the plugins\n    nb_files = 0\n    loaded = False\n\n    def __init__(self):\n        self.classes_list = []\n        self.nb_classes = 0\n        self.nb_files = 0\n        self.loaded = False\n\n    def LoadPlugins(self):\n        # Do not reload plugins if they are already loaded\n        if (self.loaded == True):\n            return (-1)\n\n        # Check if plugins directory exists\n        directory = g_plugins_directory\n        if (not (self.__dir_exists_and_not_empty(directory))):\n            return (None)\n\n        # List all the files in the \"plugins\" directory, and process them\n        for filename in os.listdir(directory):\n            filepath = os.path.join(directory, filename)\n            absfilepath = os.path.abspath(filepath)\n            if (not os.path.isfile(absfilepath)):\n                continue\n\n            # Avoid the non python files / Filenames that do not ends by \".py\"\n            if (not (filename.split(\".\")[-1] == \"py\")):\n                continue\n\n            # Avoid the Parent class that could be loaded by every plugin\n            if (filename == \"PluginLogic.py\"):\n                continue\n\n            # Count one more file loaded\n            self.nb_files += 1\n\n            # Build the name of module in python format : Dir.Class\n            submodulename = os.path.splitext(filename)[0]\n            modulename = directory + \".\" + submodulename\n\n            # Import the module (import from relative path)\n            #module = importlib.import_module(modulename)\n            # Import the module (import from absolute path)\n            module_spec = importlib.util.spec_from_file_location(modulename, absfilepath)\n            module = importlib.util.module_from_spec(module_spec)\n            module_spec.loader.exec_module(module)\n\n            # Import classes inside (avoid the \"PluginLogic\"/Parent Class)\n            for name, obj in inspect.getmembers(module, inspect.isclass):\n                #print(obj)\n                #print(obj.__name__)\n\n                # Avoid loading the PluginLogic class\n                if (obj.__name__ == \"PluginLogic\"):\n                    continue\n\n                # Add the class to the class container\n                self.classes_list.append(obj)\n\n        # Count how many classes were loaded\n        self.nb_classes = len(self.classes_list)\n\n        # Set the state as \"loaded\"\n        self.loaded = True\n\n        return (self.nb_classes)\n\n\n    # Test if a directory exists and is not empty\n    def __dir_exists_and_not_empty(self, directory):\n        res = False\n        if (os.path.exists(directory)):\n            if (os.listdir(directory)):\n                res = True\n        return (res)\n\n    # Return the list of loaded classes\n    def GetClasses(self):\n        return (self.classes_list)\n\n    # Return the number of loaded classes\n    def GetNbClasses(self):\n        return (len(self.classes_list))\n\n    # Return the number of files read\n    def GetNbFilesLoaded(self):\n        return (self.nb_files)\n\n    # Return the state of the loader\n    def IsAlreadyLoaded(self):\n        return (self.loaded)", "\n\n### Example of how to load classes in different manners\n#def importer1():\n#    BasicSet = importlib.import_module(\"basic_set_operators\")\n#    BasicOcc = importlib.import_module(\"basic_occurrencies_operators\")\n#\n#    l1 = [\"A\", \"B\", \"C\", \"D\"]\n#    l2 = [\"C\", \"D\", \"E\", \"F\"]\n#", "#    l2 = [\"C\", \"D\", \"E\", \"F\"]\n#\n#    out = occurrence(BasicSet.union(l1, l2))\n#    print(out)\n#\n#def importer2():\n#    MyImporter = PluginsImporter()\n#    nb_classes = MyImporter.LoadPlugins()\n#\n#    l1 = [\"A\", \"B\", \"C\", \"D\"]", "#\n#    l1 = [\"A\", \"B\", \"C\", \"D\"]\n#    l2 = [\"C\", \"D\", \"E\", \"F\"]\n#\n#    cls = MyImporter.GetClasses()[0]\n#\n#    name_str = cls.GetName(cls)\n#    help_str = cls.GetHelp(cls)\n#    button_str = cls.GetButton(cls)\n#", "#    button_str = cls.GetButton(cls)\n#\n#    print(\"Str found :\")\n#    print(\"NAME : \" + name_str)\n#    print(\"HELP : \" + help_str)\n#    print(\"BUTTON : \" + button_str)\n#\n#    tmp = cls.Logic(cls, l1, l2)\n#    out = occurrence(tmp)\n#    print(out)", "#    out = occurrence(tmp)\n#    print(out)\n"]}
{"filename": "src/basic_set_operators.py", "chunked_list": ["from PluginLogic import PluginLogic\n\n# Vector of classes containing the function and its descriptors/infos\ndef ListSetOperators():\n    SetOperations = []\n\n    SetOperations.append(Union)\n    SetOperations.append(Intersection)\n    #SetOperations.append(Inv_Intersection)\n    SetOperations.append(Unique_Both_Set)\n    SetOperations.append(Unique_1_Set)\n    SetOperations.append(Unique_2_Set)\n\n    return (SetOperations)", "\n# -- SETS OPERATIONS --\n# Each element is taken into account only one time (occurrencies are not used)\n\n# Union (set version)\nclass Union(PluginLogic):\n    name_str = \"UNION\"\n    help_str = \"Print all of the elements of the two CSV\"\n    button_str = \"Union\"\n\n    def Logic(self, list1, list2):\n        union_res = set(list1).union(set(list2))\n        return (union_res)", "\n# Intersection (set version)\nclass Intersection(PluginLogic):\n    name_str = \"INTERSECTION\"\n    help_str = \"Print only the common elements of the two CSV\"\n    button_str = \"Intersection\"\n\n    def Logic(self, list1, list2):\n        intersection_res = set(list1).intersection(set(list2))\n        ## intersection_res = [x for x in list1 if x in list2]\n        return (intersection_res)", "\n# Inverse of Intersection (set version) [SYMMETRIC DIFFERENCE]\n#class Inv_Intersection(PluginLogic):\n#    name_str = \"INV_INTERSECTION\"\n#    help_str = \"Print the inverse of the intersection (union - intersection)\"\n#    button_str = \"Inverse Intersection\"\n#\n#    def Logic(self, list1, list2):\n#        union = set(list1).union(set(list2))\n#        intersection = set(list1).intersection(set(list2))", "#        union = set(list1).union(set(list2))\n#        intersection = set(list1).intersection(set(list2))\n#        inv_intersection_res = set(union) - set(intersection)\n#        return (inv_intersection_res)\n\n# Unique elements to both CSV (delete commons elements)\nclass Unique_Both_Set(PluginLogic):\n    name_str = \"UNIQUE_SET_CSV_BOTH\"\n    help_str = \"Print elements unique to both CSV / Symmetric difference\"\n    button_str = \"Unique Both / Symmetric Diff\"\n\n    def Logic(self, list1, list2):\n        unique_both_res = set(list1).symmetric_difference(set(list2))\n        return (unique_both_res)", "\n# Unique elements to 1st CSV (delete elements from the other) (set version)\nclass Unique_1_Set(PluginLogic):\n    name_str = \"UNIQUE_SET_CSV_1\"\n    help_str = \"Print elements unique to 1st CSV / Difference CSV1 - CSV2\"\n    button_str = \"Unique CSV 1 / Difference\"\n\n    def Logic(self, list1, list2):\n        unique_1_res = set(list1).difference(set(list2))\n        return (unique_1_res)", "\n# Unique elements to 2nd CSV (delete elements from the other) (set version)\nclass Unique_2_Set(PluginLogic):\n    name_str = \"UNIQUE_SET_CSV_2\"\n    help_str = \"Print elements unique to 2nd CSV / Difference CSV2 - CSV1\"\n    button_str = \"Unique CSV 2 / Difference\"\n\n    def Logic(self, list1, list2):\n        unique_2_res = set(list2).difference(set(list1))\n        return (unique_2_res)", ""]}
{"filename": "src/GUI.py", "chunked_list": ["# Windows for each part\nfrom GuiClasses import WindowStart\nfrom GuiClasses import WindowActions\nfrom GuiClasses import WindowList\nfrom GuiClasses import WindowExit\n\n# Plugin loader\nfrom plugins_loader import PluginsImporter\n\n# CSV Loader", "\n# CSV Loader\nfrom csv_manipulate import load_csv\n\n# Tools\nfrom tools import occurrence\n\n# Globals required for the GUI\nfrom GuiClasses import Globals\n# gui_liste : Input List 1, Input List 2, Output List", "from GuiClasses import Globals\n# gui_liste : Input List 1, Input List 2, Output List\n# gui_liste = [None, None, None]\n\n\ndef main():\n    # Load the plugins\n    Globals.MyPluginsImporter = PluginsImporter()\n    nb_plugins_classes = Globals.MyPluginsImporter.LoadPlugins()\n\n    # Initialize 2 empty CSV (global var)\n    # (done by the initial files)\n\n    # Load exit button in hardcoded way\n    #ExitWindow = WindowExit.WindowExit()\n    #ExitWindow.SetGeometry(\"300x50+1200+50\")\n\n    StartWindow = None\n    # main loop of events :\n    while (True):\n\n        # if 2 empty CSV (global var) :\n        if ((Globals.gui_liste[0] is None) or\n            (Globals.gui_liste[1] is None)) :\n\n            # Open WindowStart if not already opened\n            if (StartWindow is None) :\n                StartWindow = WindowStart.WindowStart(\"500x300+550+250\")\n                StartWindow.SetTitle(\"Import CSV\")\n\n            #   Load inside 2 FrameCSVLoader\n            #   OnPress \"Process\"\n            #     Validate content\n            #     if correct :\n            #       fill 2 CSV (global var)\n            #       quit WindowStart\n            #     if incorrect :\n            #       pop for error\n\n            #   WindowStart.mainloop\n            StartWindow.CallMainloop()\n\n        # else :\n        else :\n            # Open WindowActions   (300x250+650+50)\n            ActionsWindow = WindowActions.WindowActions(\"450x450+650+50\")\n            ActionsWindow.SetTitle(\"CSV List Comparator\")\n\n            #   Open 2 WindowList with their CSV content (global var)\n            List1Window = WindowList.WindowList(0,\n                                                \"300x400+200+150\")\n            List1Window.SetTitle(\"CSV 1 List\")\n            List1Window.SpecializedAsInputList()\n\n            List2Window = WindowList.WindowList(1,\n                                                \"300x400+1100+150\")\n            List2Window.SetTitle(\"CSV 2 List\")\n            List2Window.SpecializedAsInputList()\n\n            #   WindowActions.mainloop\n            ActionsWindow.CallMainloop()\n\n    return 0", "\nmain()\n"]}
{"filename": "src/csv_manipulate-Pandas.py", "chunked_list": ["import os\n\n# Pandas module for CSV parsing\nimport pandas as pd\n\n# csv for Pandas options\nimport csv\n\n\ndef load_csv(file_path, separator, column):\n    csv_reader = pd.read_csv(file_path,\n                             sep=separator,\n                             header=None,\n                             usecols=[column])\n    csv_list = csv_reader[column].tolist()\n    return csv_list", "\ndef load_csv(file_path, separator, column):\n    csv_reader = pd.read_csv(file_path,\n                             sep=separator,\n                             header=None,\n                             usecols=[column])\n    csv_list = csv_reader[column].tolist()\n    return csv_list\n\n\ndef save_csv_to_file(dictio, file_path, separator):\n    # Convert the dictionnary into a DataFrame\n    df = pd.DataFrame.from_dict(dictio,\n                                orient='index')\n\n    # Delete the CSV file if it already exists\n    if os.path.exists(file_path):\n        os.remove(file_path)\n\n    # Save the DataFrame as a CSV file\n    df.to_csv(file_path,\n              sep=separator,\n              header=False,\n              index=True,\n              quoting=csv.QUOTE_NONNUMERIC)", "\n\ndef save_csv_to_file(dictio, file_path, separator):\n    # Convert the dictionnary into a DataFrame\n    df = pd.DataFrame.from_dict(dictio,\n                                orient='index')\n\n    # Delete the CSV file if it already exists\n    if os.path.exists(file_path):\n        os.remove(file_path)\n\n    # Save the DataFrame as a CSV file\n    df.to_csv(file_path,\n              sep=separator,\n              header=False,\n              index=True,\n              quoting=csv.QUOTE_NONNUMERIC)", "\n### Quoting :\n# csv.QUOTE_ALL         : quotes every field\n# csv.QUOTE_MINIMAL     : quotes only fields with special characters\n# csv.QUOTE_NONNUMERIC  : quotes only non-numeric fields\n# csv.QUOTE_NONE        : no quoting [requires an 'escapechar']\n\n\ndef print_out_csv(dictio, separator):\n    for key, value in dictio.items():\n        print(f\"{key}{separator}{value}\")", "def print_out_csv(dictio, separator):\n    for key, value in dictio.items():\n        print(f\"{key}{separator}{value}\")\n\n\ndef save_csv(dictio, separator, file_path):\n    if (file_path == \"-\"):\n        print_out_csv(dictio, separator)\n    else:\n        save_csv_to_file(dictio, file_path, separator)", ""]}
{"filename": "src/tools.py", "chunked_list": ["def occurrence(liste):\n    # Initialiser un dictionnaire pour stocker les occurrences\n    occu = {}\n\n    # Parcourir les lignes du fichier CSV\n    for row in liste:\n        valeur = row\n        if valeur in occu:\n            occu[valeur] += 1\n        else:\n            occu[valeur] = 1\n\n    return occu", ""]}
{"filename": "src/basic_occurrencies_operators.py", "chunked_list": ["from PluginLogic import PluginLogic\n\n# Vector of classes containing the function and its descriptors/infos\ndef ListOccurrenciesOperators():\n    OccOperations = []\n\n    OccOperations.append(DisjointUnion)\n    OccOperations.append(Unique_1_Occ)\n    OccOperations.append(Unique_2_Occ)\n\n    return (OccOperations)", "\n# -- CATEGORIES / OCCURRENCIES OPERATIONS --\n# The set of origin is taken into account (occurrencies are used)\n\n# Disjoint Union (categories) (counts only one time the common elements)\nclass DisjointUnion(PluginLogic):\n    name_str = \"DISJOINT_UNION\"\n    help_str = \"Print union of the two CSV (add occurrencies)\"\n    button_str = \"Disjoint Union\"\n\n    def Logic(self, list1, list2):\n        disjoint_union_res = list1 + list2\n        return (disjoint_union_res)", "\n# Unique elements to 1st CSV (deletes elements from the other) (occurrencies)\nclass Unique_1_Occ(PluginLogic):\n    name_str = \"UNIQUE_CSV_1\"\n    help_str = \"Print elements unique to 1st CSV (delete occurrencies from the 2nd CSV)\"\n    button_str = \"Unique CSV 1\"\n\n    def Logic(self, list1, list2):\n        unique_1 = list1.copy()\n        unique_2 = list2.copy()\n        for value in list1:\n            if (value in list2):\n                if (value in unique_2):\n                    unique_1.remove(value)\n                    unique_2.remove(value)\n        return (unique_1)", "\n# Unique elements to 2nd CSV (deletes elements from the other) (occurrencies)\nclass Unique_2_Occ(PluginLogic):\n    name_str = \"UNIQUE_CSV_2\"\n    help_str = \"Print elements unique to 2nd CSV (delete occurrencies from the 1st CSV)\"\n    button_str = \"Unique CSV 2\"\n\n    def Logic(self, list1, list2):\n        unique_1 = list1.copy()\n        unique_2 = list2.copy()\n        for value in list2:\n            if (value in list1):\n                if (value in unique_1):\n                    unique_1.remove(value)\n                    unique_2.remove(value)\n        return (unique_2)", ""]}
{"filename": "src/PluginLogic.py", "chunked_list": ["### USE example_plugin.py FOR WRITING NEW OPERATIONS ###\n\n###############################\n### DO NOT MODIFY THIS FILE ###\n###############################\n\n### USE example_plugin.py FOR WRITING NEW OPERATIONS ###\n\nclass PluginLogic:\n    # Name for calling this plugin\n    name_str = \"NAME_STR\"\n\n    # Text printed when calling the script with wrong parameters\n    help_str = \"HELP_STR\"\n\n    # Text of button in the GUI\n    button_str = \"BUTTON_STR\"\n\n    def __init__(self):\n        return (None)\n\n    # The main function doing something with the lists and returning a list\n    def Logic(self, list1, list2):\n        return (None)\n\n    # Getter for the attributes\n    def GetName(self):\n        return (self.name_str)\n\n    def GetHelp(self):\n        return (self.help_str)\n\n    def GetButton(self):\n        return (self.button_str)", "class PluginLogic:\n    # Name for calling this plugin\n    name_str = \"NAME_STR\"\n\n    # Text printed when calling the script with wrong parameters\n    help_str = \"HELP_STR\"\n\n    # Text of button in the GUI\n    button_str = \"BUTTON_STR\"\n\n    def __init__(self):\n        return (None)\n\n    # The main function doing something with the lists and returning a list\n    def Logic(self, list1, list2):\n        return (None)\n\n    # Getter for the attributes\n    def GetName(self):\n        return (self.name_str)\n\n    def GetHelp(self):\n        return (self.help_str)\n\n    def GetButton(self):\n        return (self.button_str)", ""]}
{"filename": "src/CLI.py", "chunked_list": ["import os\nimport sys\n\n# Plugin loader\nfrom plugins_loader import PluginsImporter\n\n# CSV loader (and saver)\nfrom csv_manipulate import load_csv\nfrom csv_manipulate import save_csv\nfrom csv_manipulate import print_out_csv", "from csv_manipulate import save_csv\nfrom csv_manipulate import print_out_csv\n\n# Actions\nfrom CliClasses.actions import execute_action\n\n# Usages & Helper\nfrom CliClasses.usages import print_usage\n\n", "\n\n### MAIN ###\n\ndef main():\n    # Load the plugins\n    MyPluginsImporter = PluginsImporter()\n    nb_plugins_classes = MyPluginsImporter.LoadPlugins()\n\n    # Test if enough parameters were given\n    if ((len(sys.argv) < 9) or ((len(sys.argv) > 10))) :\n        print_usage(MyPluginsImporter)\n        sys.exit(-1)\n\n    # Arguments assignation\n    file_path_1 = sys.argv[1]\n    sep1 = sys.argv[2]\n    id_col1 = int(sys.argv[3])\n\n    file_path_2 = sys.argv[4]\n    sep2 = sys.argv[5]\n    id_col2 = int(sys.argv[6])\n\n    action = sys.argv[7]\n    out_sep = sys.argv[8]\n\n    if (not (os.path.isfile(file_path_1))):\n        print(\"File 1 must exist\")\n        sys.exit(-2)\n\n    if (not (os.path.isfile(file_path_2))):\n        print(\"File 2 must exist\")\n        sys.exit(-2)\n\n    # Loading CSV in memory\n    list_csv_1 = load_csv(file_path_1, sep1, id_col1)\n    list_csv_2 = load_csv(file_path_2, sep2, id_col2)\n\n    # Executing the asked action\n    output_list = execute_action(list_csv_1,\n                                 list_csv_2,\n                                 action,\n                                 MyPluginsImporter)\n\n    # Write out the results\n    if (len(sys.argv) == 10):\n        out_file = sys.argv[9]\n        save_csv(output_list, out_sep, out_file)\n    else:\n        print_out_csv(output_list, out_sep)\n\n    return (0)", "\nmain()\n"]}
{"filename": "src/basic_various_operators.py", "chunked_list": ["from PluginLogic import PluginLogic\n\n# Vector of classes containing the function and its descriptors/infos\ndef ListVariousOperators():\n    VariousOperations = []\n\n    VariousOperations.append(IsDisjoint)\n    VariousOperations.append(IsSubset)\n    VariousOperations.append(IsSuperset)\n\n    return (VariousOperations)", "\n# -- VARIOUS OPERATIONS --\n# Various tests about the lists\n\n# Is Disjoint\nclass IsDisjoint(PluginLogic):\n    name_str = \"IS_DISJOINT\"\n    help_str = \"Test if the lists are disjoints (do not have any common element)\"\n    button_str = \"Is Disjoint ?\"\n\n    def Logic(self, list1, list2):\n        is_disjoint_res = set(list1).isdisjoint(set(list2))\n        return ([str(is_disjoint_res)])", "\n# Is Subset\nclass IsSubset(PluginLogic):\n    name_str = \"IS_SUBSET\"\n    help_str = \"Test if CSV 1 is a subset of CSV 2 (CSV 1 is completely included in CSV 2)\"\n    button_str = \"1 Is Subset of 2 ?\"\n\n    def Logic(self, list1, list2):\n        is_subset_res = set(list1).issubset(set(list2))\n        return ([str(is_subset_res)])", "\n# Is Superset\nclass IsSuperset(PluginLogic):\n    name_str = \"IS_SUPERSET\"\n    help_str = \"Test if CSV 1 is a superset of CSV 2 (CSV 1 contains the whole CSV 2)\"\n    button_str = \"1 Is Superset of 2 ?\"\n\n    def Logic(self, list1, list2):\n        is_superset_res = set(list1).issuperset(set(list2))\n        return ([str(is_superset_res)])", ""]}
{"filename": "src/csv_manipulate-Csv.py", "chunked_list": ["import os\n\n# csv module for CSV parsing\nimport csv as csv\n\n\ndef load_csv(file_path, separator, column):\n    # Open file\n    with open(file_path, newline='') as  csv_file:\n        # Prepare a reader on the opened file\n        csv_reader = csv.reader(csv_file,\n                                delimiter=separator)\n        # Read each line and get the desired column\n        csv_list = []\n        for line in csv_reader:\n            csv_list.append(str(line[column]))\n    return csv_list", "\n\ndef save_csv_to_file(dictio, file_path, separator):\n    # Delete the CSV file if it already exists\n    if os.path.exists(file_path):\n        os.remove(file_path)\n\n    with open(file_path, 'w') as csv_file:\n        writer = csv.writer(csv_file,\n                            delimiter=separator,\n                            quoting=csv.QUOTE_NONNUMERIC,\n                            escapechar='')\n        for key, value in dictio.items():\n            writer.writerow([key, value])", "\n### Quoting :\n# csv.QUOTE_ALL         : quotes every field\n# csv.QUOTE_MINIMAL     : quotes only fields with special characters\n# csv.QUOTE_NONNUMERIC  : quotes only non-numeric fields\n# csv.QUOTE_NONE        : no quoting [requires an 'escapechar']\n\n\ndef print_out_csv(dictio, separator):\n    for key, value in dictio.items():\n        print(f\"{key}{separator}{value}\")", "def print_out_csv(dictio, separator):\n    for key, value in dictio.items():\n        print(f\"{key}{separator}{value}\")\n\n\ndef save_csv(dictio, separator, file_path):\n    if (file_path == \"-\"):\n        print_out_csv(dictio, separator)\n    else:\n        save_csv_to_file(dictio, file_path, separator)", ""]}
{"filename": "src/csv_manipulate.py", "chunked_list": ["import os\n\n# csv module for CSV parsing\nimport csv as csv\n\n\ndef load_csv(file_path, separator, column):\n    # Open file\n    with open(file_path, newline='') as  csv_file:\n        # Prepare a reader on the opened file\n        csv_reader = csv.reader(csv_file,\n                                delimiter=separator)\n        # Read each line and get the desired column\n        csv_list = []\n        for line in csv_reader:\n            csv_list.append(str(line[column]))\n    return csv_list", "\n\ndef save_csv_to_file(dictio, file_path, separator):\n    # Delete the CSV file if it already exists\n    if os.path.exists(file_path):\n        os.remove(file_path)\n\n    with open(file_path, 'w') as csv_file:\n        writer = csv.writer(csv_file,\n                            delimiter=separator,\n                            quoting=csv.QUOTE_NONNUMERIC,\n                            escapechar='')\n        for key, value in dictio.items():\n            writer.writerow([key, value])", "\n### Quoting :\n# csv.QUOTE_ALL         : quotes every field\n# csv.QUOTE_MINIMAL     : quotes only fields with special characters\n# csv.QUOTE_NONNUMERIC  : quotes only non-numeric fields\n# csv.QUOTE_NONE        : no quoting [requires an 'escapechar']\n\n\ndef print_out_csv(dictio, separator):\n    for key, value in dictio.items():\n        print(f\"{key}{separator}{value}\")", "def print_out_csv(dictio, separator):\n    for key, value in dictio.items():\n        print(f\"{key}{separator}{value}\")\n\n\ndef save_csv(dictio, separator, file_path):\n    if (file_path == \"-\"):\n        print_out_csv(dictio, separator)\n    else:\n        save_csv_to_file(dictio, file_path, separator)", ""]}
{"filename": "src/GuiClasses/WindowList.py", "chunked_list": ["# Tkinter GUI\nimport tkinter as tk\nfrom tkinter import ttk\nfrom tkinter import filedialog\n\n# Windows & Frames for loading and saving CSV\nfrom GuiClasses import FrameCSVLoader\nfrom GuiClasses import FrameCSVSaver\n\n# Tools", "\n# Tools\nfrom tools import occurrence\nfrom enum import Enum\n\n# Globals required for the GUI\nfrom GuiClasses import Globals\n# gui_liste : Input List 1, Input List 2, Output List\n# gui_liste = [None, None, None]\n", "# gui_liste = [None, None, None]\n\n\n# If the list is printed with only names (list), or with occurrencies (dict)\nclass WindowListState(Enum):\n    TERMS = 1\n    OCCURRENCIES = 2\n\n# If the list is unsorted (0), or sorted alphabetically or by occurrencies\nclass WindowListSortState(Enum):\n    UNKNOWN = 0\n    SORTED_AtoZ = 1\n    SORTED_ZtoA = 2\n    SORTED_0to9 = 3\n    SORTED_9to0 = 4", "# If the list is unsorted (0), or sorted alphabetically or by occurrencies\nclass WindowListSortState(Enum):\n    UNKNOWN = 0\n    SORTED_AtoZ = 1\n    SORTED_ZtoA = 2\n    SORTED_0to9 = 3\n    SORTED_9to0 = 4\n\n# Class for printing lists (input and output) and asking for load/save\nclass WindowList:\n    GlobalListNumber = None\n\n    ### States / Context\n    # Context (Input list or Output list)\n    Context = None\n    # State (list in Name format only, or Name+Ocurrencies)\n    State = None\n    # SortState (list unsorted, sorted alphabetically, or by occurrencies)\n    SortState = None\n\n    ### GUI\n    # Main window getting everything\n    Root = None\n    # Specifications of the window\n    Geometry = \"0\"\n    Title = \"List Window\"\n\n    # Load/Save buttons in the window\n    FrameLoadSave = None\n    LoadButton = None\n    SaveButton = None\n    # Format list buttons\n    FrameFormatList = None\n    FormatTermButton = None\n    FormatOccButton = None\n    # Sorts buttons\n    FrameSorts = None\n    SortAlphaButton = None\n    SortNumButton = None\n    # List of terms\n    FrameListBox = None\n    ScrollbarListBox = None\n    ListBox = None\n\n    # def WindowListGenerator(self):\n    def __init__(self, globallistnum, geometry):\n        self.Root = tk.Tk()\n        self.SetGeometry(geometry)\n        self.GlobalListNumber = globallistnum\n        self.State = WindowListState.TERMS\n        self.SortState = WindowListSortState.UNKNOWN\n\n        ### Load / Save\n        # Frame for Load and Save\n        self.FrameLoadSave = ttk.Frame(self.Root)\n        self.FrameLoadSave.pack(side=tk.TOP,\n                                fill=tk.X,\n                                expand=tk.YES,\n                                anchor=tk.N)\n        # Load CSV button\n        self.LoadButton = tk.Button(self.FrameLoadSave,\n                                    text=\"Load\",\n                                    state=tk.DISABLED,\n                                    command=lambda: LoadFile(self.GlobalListNumber, self))\n        self.LoadButton.pack(side=tk.LEFT,\n                             fill=tk.X,\n                             expand=tk.YES,\n                             anchor=tk.NW)\n        # Save CSV button\n        self.SaveButton = tk.Button(self.FrameLoadSave,\n                                    text=\"Save\",\n                                    state=tk.DISABLED,\n                                    command=lambda: SaveFile(self.GlobalListNumber, self))\n        self.SaveButton.pack(side=tk.RIGHT,\n                             fill=tk.X,\n                             expand=tk.YES,\n                             anchor=tk.NE)\n\n        ### Format Terms/Occurrencies\n        # Frame for two modes\n        self.FrameFormatList = ttk.Frame(self.Root)\n        self.FrameFormatList.pack(side=tk.TOP,\n                                  fill=tk.X,\n                                  expand=tk.YES,\n                                  anchor=tk.N)\n        # Button format list as Terms list\n        self.FormatTermButton = tk.Button(self.FrameFormatList,\n                                          text=\"Mode:\\nTerms List\",\n                                          state=tk.NORMAL,\n                                          command=lambda: self.InsertListInListBox(Globals.gui_liste[self.GlobalListNumber]))\n        self.FormatTermButton.pack(side=tk.LEFT,\n                             fill=tk.X,\n                             expand=tk.YES,\n                             anchor=tk.NW)\n        # Button format list as Occurrencies list\n        self.FormatOccButton = tk.Button(self.FrameFormatList,\n                                         text=\"Mode:\\nOccurrences\",\n                                         state=tk.NORMAL,\n                                         command=lambda: self.InsertDictInListBox(occurrence(Globals.gui_liste[self.GlobalListNumber])))\n        self.FormatOccButton.pack(side=tk.RIGHT,\n                             fill=tk.X,\n                             expand=tk.YES,\n                             anchor=tk.NE)\n\n        ### Sorts buttons\n        # Frame for sorting by alphabetical and numerical orders\n        self.FrameSorts = ttk.Frame(self.Root)\n        self.FrameSorts.pack(side=tk.TOP,\n                             fill=tk.X,\n                             expand=tk.YES,\n                             anchor=tk.N)\n        # Sort A->Z CSV button\n        self.SortAlphaButton = tk.Button(self.FrameSorts,\n                                         text=\"Sort [Alphabetical]\",\n                                         state=tk.NORMAL,\n                                         command=lambda: self.SortListInListBoxAlphabetically())\n        self.SortAlphaButton.pack(side=tk.RIGHT,\n                                  fill=tk.X,\n                                  expand=tk.YES,\n                                  anchor=tk.NW)\n        self.UpdateSortAtoZButton()\n        # Sort 0->9 CSV button\n        self.SortNumButton = tk.Button(self.FrameSorts,\n                                       text=\"Sort [Numerical]\",\n                                       state=tk.DISABLED,\n                                       command=lambda: self.SortListInListBoxNumerically())\n        self.SortNumButton.pack(side=tk.RIGHT,\n                                fill=tk.X,\n                                expand=tk.YES,\n                                anchor=tk.NE)\n        self.UpdateSort0to9Button()\n\n        ### ListBox containing the list of terms\n        # Frame for containing the list\n        self.FrameListBox = ttk.Frame(self.Root)\n        self.FrameListBox.pack(fill=tk.BOTH,\n                               expand=True)\n        # Scrollbar for the list\n        self.ScrollbarListBox = ttk.Scrollbar(self.FrameListBox,\n                                              orient=tk.VERTICAL)\n        # ListBox containing the list\n        self.ListBox = tk.Listbox(self.FrameListBox,\n                                  yscrollcommand=self.ScrollbarListBox.set)\n        self.ListBox.pack(side=tk.LEFT,\n                          fill=tk.BOTH,\n                          expand=True)\n        # Configure the scrollbar for expanding with the list\n        self.ScrollbarListBox.config(command=self.ListBox.yview)\n        self.ScrollbarListBox.pack(side=tk.RIGHT,\n                                   fill=tk.Y)\n\n    # Specialize the Window List as an Input list (one of the 2 input CSV)\n    #  List each term in its exact position (print only the terms)\n    def SpecializedAsInputList(self):\n        self.LoadButton.config(state=tk.NORMAL)\n        self.SaveButton.config(state=tk.DISABLED)\n        self.ListBox.delete(0, tk.END)\n\n        self.InsertListInListBox(Globals.gui_liste[self.GlobalListNumber])\n\n    # Specialize the Window List as an Output list\n    #  List the occurrencies of terms\n    def SpecializedAsOutputList(self):\n        self.LoadButton.config(state=tk.DISABLED)\n        self.SaveButton.config(state=tk.NORMAL)\n        self.ListBox.delete(0, tk.END)\n\n        self.InsertDictInListBox(occurrence(Globals.gui_liste[self.GlobalListNumber]))\n\n\n    # Switch between the 2 states (TERMS <-> OCCURRENCIES)\n    def StateSwitch(self):\n        if (self.State == WindowListState.TERMS):\n            self.State = WindowListState.OCCURRENCES\n        else:\n            self.State = WindowListState.TERMS\n\n    # Switch the button from A->Z to Z->A (and vice versa)\n    def UpdateSortAtoZButton(self):\n        # If list is already in alphabetical, propose the reverse\n        if (self.SortState == WindowListSortState.SORTED_AtoZ):\n            self.SortAlphaButton.config(text=\"Sort (Z -> A)\")\n        else:\n            self.SortAlphaButton.config(text=\"Sort (A -> Z)\")\n\n    # Switch the button from 0->9 to 0->9 (and vice versa)\n    def UpdateSort0to9Button(self):\n        # If list is already in alphabetical, propose the reverse\n        if (self.SortState == WindowListSortState.SORTED_0to9):\n            self.SortNumButton.config(text=\"Sort (9 -> 0)\")\n        else:\n            self.SortNumButton.config(text=\"Sort (0 -> 9)\")\n\n    # Sort (A <-> Z) the list of terms\n    def SortListInListBoxAlphabetically(self):\n        liste = Globals.gui_liste[self.GlobalListNumber]\n        if (self.State == WindowListState.TERMS):\n            # List mode\n            if (self.SortState != WindowListSortState.SORTED_AtoZ):\n                # If the list is not sorted alphabetically...\n                #  let's sort it!\n                sorted_list = sorted(liste, reverse=False)\n                self.SortState = WindowListSortState.SORTED_AtoZ\n            else:\n                # Else, let's revert the sort\n                sorted_list = sorted(liste, reverse=True)\n                self.SortState = WindowListSortState.SORTED_ZtoA\n            self.InsertListInListBox(sorted_list)\n\n        else:\n            dico = occurrence(liste)\n            # Occurrencies mode\n            if (self.SortState != WindowListSortState.SORTED_AtoZ):\n                # If the list is not sorted alphabetically...\n                sorted_items = sorted(dico.items(), reverse=False)\n                self.SortState = WindowListSortState.SORTED_AtoZ\n            else:\n                # Else, let's revert the sort\n                sorted_items = sorted(dico.items(), reverse=True)\n                self.SortState = WindowListSortState.SORTED_ZtoA\n            self.InsertDictInListBox(dict(sorted_items))\n        self.UpdateSortAtoZButton()\n\n    # Sort (0 <-> 9) the list of terms\n    def SortListInListBoxNumerically(self):\n        liste = Globals.gui_liste[self.GlobalListNumber]\n        if (self.State == WindowListState.OCCURRENCIES):\n            dico = occurrence(liste)\n            # Occurrencies mode\n            if (self.SortState != WindowListSortState.SORTED_0to9):\n                # If the list is not sorted numerically...\n                sorted_items = sorted(dico.items(), key=lambda x : x[1], reverse=False)\n                self.SortState = WindowListSortState.SORTED_0to9\n            else:\n                # Else, let's revert the sort\n                sorted_items = sorted(dico.items(), key=lambda x : x[1], reverse=True)\n                self.SortState = WindowListSortState.SORTED_9to0\n            self.InsertDictInListBox(dict(sorted_items))\n        else:\n            # Terms mode\n            test = None\n        self.UpdateSort0to9Button()\n\n\n    # Insert a list of terms in the ListBox\n    def InsertListInListBox(self, liste):\n        self.ListBox.delete(0, tk.END)\n        for element in liste:\n            self.ListBox.insert(tk.END, element)\n        self.State = WindowListState.TERMS\n        self.SortNumButton.config(state=tk.DISABLED)\n\n    # Insert a dictionnary (term:occ) in the ListBox\n    def InsertDictInListBox(self, dico):\n        self.ListBox.delete(0, tk.END)\n        for valeur, compte in dico.items():\n            texte = f\"{valeur} : {compte} occurrence(s)\"\n            self.ListBox.insert(tk.END, texte)\n        self.State = WindowListState.OCCURRENCIES\n        self.SortNumButton.config(state=tk.NORMAL)\n\n\n    ### Regular Methods of the class (setters, getters, quit, geometry, ...)\n\n    def SetTitle(self, title):\n        self.Title = title\n        self.Root.title(title)\n\n    def SetGeometry(self, geometry):\n        self.Geometry = geometry\n        self.Root.geometry(geometry)\n\n    def GetGeometry(self):\n        return (self.Geometry)\n\n    def GetTitle(self):\n        return (self.Title)\n\n    # Hide the window\n    def CallWithdraw(self):\n        self.Root.withdraw()\n\n    # Destroy the window\n    def CallDestroy(self):\n        self.Root.destroy()", "# Class for printing lists (input and output) and asking for load/save\nclass WindowList:\n    GlobalListNumber = None\n\n    ### States / Context\n    # Context (Input list or Output list)\n    Context = None\n    # State (list in Name format only, or Name+Ocurrencies)\n    State = None\n    # SortState (list unsorted, sorted alphabetically, or by occurrencies)\n    SortState = None\n\n    ### GUI\n    # Main window getting everything\n    Root = None\n    # Specifications of the window\n    Geometry = \"0\"\n    Title = \"List Window\"\n\n    # Load/Save buttons in the window\n    FrameLoadSave = None\n    LoadButton = None\n    SaveButton = None\n    # Format list buttons\n    FrameFormatList = None\n    FormatTermButton = None\n    FormatOccButton = None\n    # Sorts buttons\n    FrameSorts = None\n    SortAlphaButton = None\n    SortNumButton = None\n    # List of terms\n    FrameListBox = None\n    ScrollbarListBox = None\n    ListBox = None\n\n    # def WindowListGenerator(self):\n    def __init__(self, globallistnum, geometry):\n        self.Root = tk.Tk()\n        self.SetGeometry(geometry)\n        self.GlobalListNumber = globallistnum\n        self.State = WindowListState.TERMS\n        self.SortState = WindowListSortState.UNKNOWN\n\n        ### Load / Save\n        # Frame for Load and Save\n        self.FrameLoadSave = ttk.Frame(self.Root)\n        self.FrameLoadSave.pack(side=tk.TOP,\n                                fill=tk.X,\n                                expand=tk.YES,\n                                anchor=tk.N)\n        # Load CSV button\n        self.LoadButton = tk.Button(self.FrameLoadSave,\n                                    text=\"Load\",\n                                    state=tk.DISABLED,\n                                    command=lambda: LoadFile(self.GlobalListNumber, self))\n        self.LoadButton.pack(side=tk.LEFT,\n                             fill=tk.X,\n                             expand=tk.YES,\n                             anchor=tk.NW)\n        # Save CSV button\n        self.SaveButton = tk.Button(self.FrameLoadSave,\n                                    text=\"Save\",\n                                    state=tk.DISABLED,\n                                    command=lambda: SaveFile(self.GlobalListNumber, self))\n        self.SaveButton.pack(side=tk.RIGHT,\n                             fill=tk.X,\n                             expand=tk.YES,\n                             anchor=tk.NE)\n\n        ### Format Terms/Occurrencies\n        # Frame for two modes\n        self.FrameFormatList = ttk.Frame(self.Root)\n        self.FrameFormatList.pack(side=tk.TOP,\n                                  fill=tk.X,\n                                  expand=tk.YES,\n                                  anchor=tk.N)\n        # Button format list as Terms list\n        self.FormatTermButton = tk.Button(self.FrameFormatList,\n                                          text=\"Mode:\\nTerms List\",\n                                          state=tk.NORMAL,\n                                          command=lambda: self.InsertListInListBox(Globals.gui_liste[self.GlobalListNumber]))\n        self.FormatTermButton.pack(side=tk.LEFT,\n                             fill=tk.X,\n                             expand=tk.YES,\n                             anchor=tk.NW)\n        # Button format list as Occurrencies list\n        self.FormatOccButton = tk.Button(self.FrameFormatList,\n                                         text=\"Mode:\\nOccurrences\",\n                                         state=tk.NORMAL,\n                                         command=lambda: self.InsertDictInListBox(occurrence(Globals.gui_liste[self.GlobalListNumber])))\n        self.FormatOccButton.pack(side=tk.RIGHT,\n                             fill=tk.X,\n                             expand=tk.YES,\n                             anchor=tk.NE)\n\n        ### Sorts buttons\n        # Frame for sorting by alphabetical and numerical orders\n        self.FrameSorts = ttk.Frame(self.Root)\n        self.FrameSorts.pack(side=tk.TOP,\n                             fill=tk.X,\n                             expand=tk.YES,\n                             anchor=tk.N)\n        # Sort A->Z CSV button\n        self.SortAlphaButton = tk.Button(self.FrameSorts,\n                                         text=\"Sort [Alphabetical]\",\n                                         state=tk.NORMAL,\n                                         command=lambda: self.SortListInListBoxAlphabetically())\n        self.SortAlphaButton.pack(side=tk.RIGHT,\n                                  fill=tk.X,\n                                  expand=tk.YES,\n                                  anchor=tk.NW)\n        self.UpdateSortAtoZButton()\n        # Sort 0->9 CSV button\n        self.SortNumButton = tk.Button(self.FrameSorts,\n                                       text=\"Sort [Numerical]\",\n                                       state=tk.DISABLED,\n                                       command=lambda: self.SortListInListBoxNumerically())\n        self.SortNumButton.pack(side=tk.RIGHT,\n                                fill=tk.X,\n                                expand=tk.YES,\n                                anchor=tk.NE)\n        self.UpdateSort0to9Button()\n\n        ### ListBox containing the list of terms\n        # Frame for containing the list\n        self.FrameListBox = ttk.Frame(self.Root)\n        self.FrameListBox.pack(fill=tk.BOTH,\n                               expand=True)\n        # Scrollbar for the list\n        self.ScrollbarListBox = ttk.Scrollbar(self.FrameListBox,\n                                              orient=tk.VERTICAL)\n        # ListBox containing the list\n        self.ListBox = tk.Listbox(self.FrameListBox,\n                                  yscrollcommand=self.ScrollbarListBox.set)\n        self.ListBox.pack(side=tk.LEFT,\n                          fill=tk.BOTH,\n                          expand=True)\n        # Configure the scrollbar for expanding with the list\n        self.ScrollbarListBox.config(command=self.ListBox.yview)\n        self.ScrollbarListBox.pack(side=tk.RIGHT,\n                                   fill=tk.Y)\n\n    # Specialize the Window List as an Input list (one of the 2 input CSV)\n    #  List each term in its exact position (print only the terms)\n    def SpecializedAsInputList(self):\n        self.LoadButton.config(state=tk.NORMAL)\n        self.SaveButton.config(state=tk.DISABLED)\n        self.ListBox.delete(0, tk.END)\n\n        self.InsertListInListBox(Globals.gui_liste[self.GlobalListNumber])\n\n    # Specialize the Window List as an Output list\n    #  List the occurrencies of terms\n    def SpecializedAsOutputList(self):\n        self.LoadButton.config(state=tk.DISABLED)\n        self.SaveButton.config(state=tk.NORMAL)\n        self.ListBox.delete(0, tk.END)\n\n        self.InsertDictInListBox(occurrence(Globals.gui_liste[self.GlobalListNumber]))\n\n\n    # Switch between the 2 states (TERMS <-> OCCURRENCIES)\n    def StateSwitch(self):\n        if (self.State == WindowListState.TERMS):\n            self.State = WindowListState.OCCURRENCES\n        else:\n            self.State = WindowListState.TERMS\n\n    # Switch the button from A->Z to Z->A (and vice versa)\n    def UpdateSortAtoZButton(self):\n        # If list is already in alphabetical, propose the reverse\n        if (self.SortState == WindowListSortState.SORTED_AtoZ):\n            self.SortAlphaButton.config(text=\"Sort (Z -> A)\")\n        else:\n            self.SortAlphaButton.config(text=\"Sort (A -> Z)\")\n\n    # Switch the button from 0->9 to 0->9 (and vice versa)\n    def UpdateSort0to9Button(self):\n        # If list is already in alphabetical, propose the reverse\n        if (self.SortState == WindowListSortState.SORTED_0to9):\n            self.SortNumButton.config(text=\"Sort (9 -> 0)\")\n        else:\n            self.SortNumButton.config(text=\"Sort (0 -> 9)\")\n\n    # Sort (A <-> Z) the list of terms\n    def SortListInListBoxAlphabetically(self):\n        liste = Globals.gui_liste[self.GlobalListNumber]\n        if (self.State == WindowListState.TERMS):\n            # List mode\n            if (self.SortState != WindowListSortState.SORTED_AtoZ):\n                # If the list is not sorted alphabetically...\n                #  let's sort it!\n                sorted_list = sorted(liste, reverse=False)\n                self.SortState = WindowListSortState.SORTED_AtoZ\n            else:\n                # Else, let's revert the sort\n                sorted_list = sorted(liste, reverse=True)\n                self.SortState = WindowListSortState.SORTED_ZtoA\n            self.InsertListInListBox(sorted_list)\n\n        else:\n            dico = occurrence(liste)\n            # Occurrencies mode\n            if (self.SortState != WindowListSortState.SORTED_AtoZ):\n                # If the list is not sorted alphabetically...\n                sorted_items = sorted(dico.items(), reverse=False)\n                self.SortState = WindowListSortState.SORTED_AtoZ\n            else:\n                # Else, let's revert the sort\n                sorted_items = sorted(dico.items(), reverse=True)\n                self.SortState = WindowListSortState.SORTED_ZtoA\n            self.InsertDictInListBox(dict(sorted_items))\n        self.UpdateSortAtoZButton()\n\n    # Sort (0 <-> 9) the list of terms\n    def SortListInListBoxNumerically(self):\n        liste = Globals.gui_liste[self.GlobalListNumber]\n        if (self.State == WindowListState.OCCURRENCIES):\n            dico = occurrence(liste)\n            # Occurrencies mode\n            if (self.SortState != WindowListSortState.SORTED_0to9):\n                # If the list is not sorted numerically...\n                sorted_items = sorted(dico.items(), key=lambda x : x[1], reverse=False)\n                self.SortState = WindowListSortState.SORTED_0to9\n            else:\n                # Else, let's revert the sort\n                sorted_items = sorted(dico.items(), key=lambda x : x[1], reverse=True)\n                self.SortState = WindowListSortState.SORTED_9to0\n            self.InsertDictInListBox(dict(sorted_items))\n        else:\n            # Terms mode\n            test = None\n        self.UpdateSort0to9Button()\n\n\n    # Insert a list of terms in the ListBox\n    def InsertListInListBox(self, liste):\n        self.ListBox.delete(0, tk.END)\n        for element in liste:\n            self.ListBox.insert(tk.END, element)\n        self.State = WindowListState.TERMS\n        self.SortNumButton.config(state=tk.DISABLED)\n\n    # Insert a dictionnary (term:occ) in the ListBox\n    def InsertDictInListBox(self, dico):\n        self.ListBox.delete(0, tk.END)\n        for valeur, compte in dico.items():\n            texte = f\"{valeur} : {compte} occurrence(s)\"\n            self.ListBox.insert(tk.END, texte)\n        self.State = WindowListState.OCCURRENCIES\n        self.SortNumButton.config(state=tk.NORMAL)\n\n\n    ### Regular Methods of the class (setters, getters, quit, geometry, ...)\n\n    def SetTitle(self, title):\n        self.Title = title\n        self.Root.title(title)\n\n    def SetGeometry(self, geometry):\n        self.Geometry = geometry\n        self.Root.geometry(geometry)\n\n    def GetGeometry(self):\n        return (self.Geometry)\n\n    def GetTitle(self):\n        return (self.Title)\n\n    # Hide the window\n    def CallWithdraw(self):\n        self.Root.withdraw()\n\n    # Destroy the window\n    def CallDestroy(self):\n        self.Root.destroy()", "\n\n\n# Callback for LoadButton\ndef LoadFile(NumList, TheWindowList):\n    WindowLoad = tk.Tk()\n    WindowLoad.title(\"Load CSV\")\n    WindowLoad.geometry(\"300x220+600+375\")\n\n    # Fill with the frame dedicated for loading CSV\n    FrameLoad = FrameCSVLoader.FrameCSVLoader(WindowLoad, NumList)\n    # Add the launch button & pack the frame\n    FrameLoad.Reload_PutLaunchButton(TheWindowList)\n\n    WindowLoad.mainloop()", "\n# Callback for SaveButton\ndef SaveFile(NumList, TheWindowList):\n    WindowSave = tk.Tk()\n    WindowSave.title(\"Save CSV\")\n    WindowSave.geometry(\"250x200+600+375\")\n\n    # Create a frame\n    FrameSave = FrameCSVSaver.FrameCSVSaver(WindowSave, NumList)\n    # Add the save button & pack the frame\n    FrameSave.Save_PutSaveButton(WindowSave)\n\n    WindowSave.mainloop()", ""]}
{"filename": "src/GuiClasses/WindowError.py", "chunked_list": ["# Tkinter GUI\nimport tkinter as tk\n\n\nclass WindowError:\n    Geometry = None\n    Title = None\n\n    # Main window getting the label and button\n    Root = None\n\n    # The label first with the error message\n    Label = None\n    # The button and its text to click on\n    Button = None\n    ButtonText = None\n\n    def __init__(self):\n        self.Root = tk.Tk()\n        self.SetTitle(\"Error\")\n        self.Label = tk.Label(self.Root, text=\"Error\")\n        self.Label.pack()\n        self.ButtonText = \"OK\"\n        self.Button = tk.Button(self.Root,\n                                text=\"OK\",\n                                command=lambda: self.Root.destroy())\n        self.Button.pack()\n\n    def SetGeometry(self, geometry):\n        self.Geometry = geometry\n        self.Root.geometry(geometry)\n\n    def GetGeometry(self):\n        return (self.Geometry)\n\n    def SetTitle(self, title):\n        self.Title = title\n        self.Root.title(title)\n\n    def GetTitle(self):\n        return (self.Title)\n\n    def SetButton(self, button_text):\n        self.Button.destroy()\n        self.ButtonText = button_text\n        self.Button = tk.Button(self.Root,\n                                text=button_text,\n                                command=lambda: self.Root.destroy())\n        self.Button.pack()\n\n    # For upating the label, we must remove the button and put it again\n    def SetLabel(self, new_text):\n        self.Label.destroy()\n        self.Label = tk.Label(self.Root, text=new_text)\n        self.Label.pack()\n        self.SetButton(self.ButtonText)", ""]}
{"filename": "src/GuiClasses/WindowStart.py", "chunked_list": ["# Tkinter GUI\nimport tkinter as tk\nfrom tkinter import messagebox\n\n# Windows & Frames for Errors and CSV Loading\nfrom GuiClasses import FrameCSVLoader\nfrom GuiClasses import WindowError\n\n# Tools\nfrom csv_manipulate import load_csv", "# Tools\nfrom csv_manipulate import load_csv\n\n# Globals required for the GUI\nfrom GuiClasses import Globals\n# gui_liste : Input List 1, Input List 2, Output List\n# gui_liste = [None, None, None]\n\n\n# Main first window asking to input 2 CSV\nclass WindowStart:\n    Geometry = \"0\"\n    Title = \"List Window\"\n    # Main window getting everything\n    Root = None\n    # 1st Frame for CSV 1\n    FrameCSV1 = None\n    # 2nd Frame for CSV 2\n    FrameCSV2 = None\n    # Launch button\n    FrameButton = None\n    LaunchButton = None\n\n    def __init__(self, geometry):\n        self.Root = tk.Tk()\n        self.SetGeometry(geometry)\n\n        # If user close the window, kill everything\n        self.Root.protocol(\"WM_DELETE_WINDOW\",\n                           lambda: on_closing(self))\n\n        # Add the CSV 1 frame\n        self.FrameCSV1 = FrameCSVLoader.FrameCSVLoader(self.Root)\n        self.FrameCSV1.PackLeft()\n\n        # Add the CSV 2 frame\n        self.FrameCSV2 = FrameCSVLoader.FrameCSVLoader(self.Root)\n        self.FrameCSV2.PackRight()\n\n        # Add the launch button\n        self.FrameButton = tk.Frame(self.Root)\n        self.PutLaunchButton()\n        self.FrameButton.pack(side=tk.BOTTOM,\n                              fill=tk.BOTH)\n\n    def PutLaunchButton(self):\n        self.LaunchButton = tk.Button(self.FrameButton,\n                                      text=\"Launch\",\n                                      command=lambda: Launch_WindowListActions(self))\n        self.LaunchButton.pack(fill=tk.BOTH,\n                               padx=10,\n                               pady=10)\n\n    def SetTitle(self, title):\n        self.Title = title\n        self.Root.title(title)\n\n    def SetGeometry(self, geometry):\n        self.Geometry = geometry\n        self.Root.geometry(geometry)\n\n    def GetTitle(self):\n        return (self.Title)\n\n    def GetGeometry(self):\n        return (self.Geometry)\n\n    def GetCSVInfos(self, num):\n        if (num == 1):\n            return (self.FrameCSV1.Validate())\n        elif (num == 2):\n            return (self.FrameCSV2.Validate())\n        else:\n            print(\"Bad CSV number (should be 1 or 2) : \" + num)\n            return (None)\n\n    def CallMainloop(self):\n        self.Root.mainloop()\n\n    def CallWithdraw(self):\n        self.Root.withdraw()\n\n    # Quit the \"mainloop\" and return\n    def CallQuit(self):\n        self.Root.withdraw()\n        self.Root.quit()\n\n    # Kill the \"mainloop\" completely/Exit program\n    def CallDestroy(self):\n        self.Root.destroy()", "\n# Main first window asking to input 2 CSV\nclass WindowStart:\n    Geometry = \"0\"\n    Title = \"List Window\"\n    # Main window getting everything\n    Root = None\n    # 1st Frame for CSV 1\n    FrameCSV1 = None\n    # 2nd Frame for CSV 2\n    FrameCSV2 = None\n    # Launch button\n    FrameButton = None\n    LaunchButton = None\n\n    def __init__(self, geometry):\n        self.Root = tk.Tk()\n        self.SetGeometry(geometry)\n\n        # If user close the window, kill everything\n        self.Root.protocol(\"WM_DELETE_WINDOW\",\n                           lambda: on_closing(self))\n\n        # Add the CSV 1 frame\n        self.FrameCSV1 = FrameCSVLoader.FrameCSVLoader(self.Root)\n        self.FrameCSV1.PackLeft()\n\n        # Add the CSV 2 frame\n        self.FrameCSV2 = FrameCSVLoader.FrameCSVLoader(self.Root)\n        self.FrameCSV2.PackRight()\n\n        # Add the launch button\n        self.FrameButton = tk.Frame(self.Root)\n        self.PutLaunchButton()\n        self.FrameButton.pack(side=tk.BOTTOM,\n                              fill=tk.BOTH)\n\n    def PutLaunchButton(self):\n        self.LaunchButton = tk.Button(self.FrameButton,\n                                      text=\"Launch\",\n                                      command=lambda: Launch_WindowListActions(self))\n        self.LaunchButton.pack(fill=tk.BOTH,\n                               padx=10,\n                               pady=10)\n\n    def SetTitle(self, title):\n        self.Title = title\n        self.Root.title(title)\n\n    def SetGeometry(self, geometry):\n        self.Geometry = geometry\n        self.Root.geometry(geometry)\n\n    def GetTitle(self):\n        return (self.Title)\n\n    def GetGeometry(self):\n        return (self.Geometry)\n\n    def GetCSVInfos(self, num):\n        if (num == 1):\n            return (self.FrameCSV1.Validate())\n        elif (num == 2):\n            return (self.FrameCSV2.Validate())\n        else:\n            print(\"Bad CSV number (should be 1 or 2) : \" + num)\n            return (None)\n\n    def CallMainloop(self):\n        self.Root.mainloop()\n\n    def CallWithdraw(self):\n        self.Root.withdraw()\n\n    # Quit the \"mainloop\" and return\n    def CallQuit(self):\n        self.Root.withdraw()\n        self.Root.quit()\n\n    # Kill the \"mainloop\" completely/Exit program\n    def CallDestroy(self):\n        self.Root.destroy()", "\n\ndef Launch_WindowListActions(TheStartWindow):\n    # Get CSV 1 & 2 informations\n    CSV1Infos = TheStartWindow.GetCSVInfos(1)\n    CSV2Infos = TheStartWindow.GetCSVInfos(2)\n\n    #print(\"[WindowStart] CSV 1 :\")\n    #print(type(CSV1Infos))\n    #print(CSV1Infos)\n    #print(\" \")\n    #print(\"[WindowStart] CSV 2 :\")\n    #print(type(CSV2Infos))\n    #print(CSV2Infos)\n\n    if ((not (CSV1Infos is None)) and (not (CSV2Infos is None))) :\n        # Correct the columns (technical) : [1 -> 9] to [0 -> 8]\n        Col1 = int(CSV1Infos[2]) - 1\n        Col2 = int(CSV2Infos[2]) - 1\n\n        Globals.gui_liste[0] = load_csv(CSV1Infos[0], CSV1Infos[1], Col1)\n        Globals.gui_liste[1] = load_csv(CSV2Infos[0], CSV2Infos[1], Col2)\n\n        # If the 2 CSV has been correctly loaded, exit\n        #if (! (Globals.gui_liste[0] is None) or\n        #    (Globals.gui_liste[1] is None)) :\n        # Close the main window and return back to the program\n        #TheStartWindow.CallDestroy()\n        TheStartWindow.CallQuit()\n\n    else :\n        #ErrWindow = tk.Tk()\n        #ErrWindow.title(\"Error\")\n        #ErrLabel = tk.Label(ErrWindow, text=\"Error : Fill correctly CSV\")\n        #ErrLabel.pack()\n        #ErrButton = tk.Button(ErrWindow,\n        #                      text=\"OK\",\n        #                      command=lambda: ErrWindow.destroy())\n        #ErrButton.pack()\n        ErrWindow = WindowError.WindowError()\n        ErrWindow.SetLabel(\"Error : Fill correctly CSV paths, separator, and column\")", "\ndef on_closing(TheStartWindow):\n    if (messagebox.askokcancel(\"Quit\", \"Do you want to quit?\")):\n        #TheStartWindow.CallDestroy()\n        exit(0)\n"]}
{"filename": "src/GuiClasses/__init__.py", "chunked_list": [""]}
{"filename": "src/GuiClasses/FrameCSVLoader.py", "chunked_list": ["import os.path\n\n# Tkinter GUI\nimport tkinter as tk\nfrom tkinter import filedialog\n\n# Windows for errors\nfrom GuiClasses import WindowError\n\n# CSV Loader", "\n# CSV Loader\nfrom csv_manipulate import load_csv\n\n# Globals required for the GUI\nfrom GuiClasses import Globals\n# gui_liste : Input List 1, Input List 2, Output List\n# gui_liste = [None, None, None]\n\n", "\n\n# Frame asking for informations about a CSV (path, sep, col)\nclass FrameCSVLoader:\n    GlobalListNumber = None\n\n    # Values we want to get from the user (tk.StringVar())\n    Filename = None\n    Separator = None\n    Column = None\n\n    ### GUI\n    # The current frame\n    Frame = None\n    # Canvas where to put the current frame\n    OutterCanvas = None\n    # Specifications of the current frame\n    Geometry = None\n    Padding = None\n    BorderWidth = None\n    Relief = None\n    # Widgets of the frame\n    FileLabel = None\n    FileButton = None\n    FileEntry = None\n    SeparatorLabel = None\n    SeparatorEntry = None\n    ColumnLabel = None\n    ColumnEntry = None\n    # Widgets for reloading a CSV\n    LaunchButton = None\n\n    def __init__(self, canvas, ListNum=None):\n        # Get the canvas where to put the frame\n        self.OutterCanvas = canvas\n        self.GlobalListNumber = ListNum\n\n        self.Frame = tk.Frame(self.OutterCanvas)\n\n        # Fill variables\n        self.Filename = tk.StringVar()\n        self.Separator = tk.StringVar()\n        self.Column = tk.StringVar()\n\n        # Describe the field and button\n        self.FileLabel = tk.Label(self.Frame,\n                                  text=\"CSV File Path:\")\n        self.FileLabel.pack()\n        # Put the button for the file and fill the file field when chosen\n        self.FileButton = tk.Button(self.Frame,\n                                    text=\"Choose file\",\n                                    command=self.ChooseFile)\n        self.FileButton.pack()\n        # Create a file field\n        self.FileEntry = tk.Entry(self.Frame, textvariable=self.Filename)\n        self.FileEntry.insert(0, \"C1.csv\")\n        self.FileEntry.pack()\n\n        # Separator Description and Field\n        self.SeparatorLabel = tk.Label(self.Frame,\n                                       text=\"Separator:\")\n        self.SeparatorLabel.pack()\n        self.SeparatorEntry = tk.Entry(self.Frame,\n                                       textvariable=self.Separator)\n        self.SeparatorEntry.insert(0, \";\")\n        self.SeparatorEntry.pack()\n\n        # Column Description and Field\n        self.ColumnLabel = tk.Label(self.Frame,\n                                    text=\"Column:\")\n        self.ColumnLabel.pack()\n        self.ColumnEntry = tk.Entry(self.Frame, textvariable=self.Column)\n        self.ColumnEntry.insert(0, \"6\")\n        self.ColumnEntry.pack()\n\n        #self.Frame.pack(side=\"left\", padx=50, pady=50)\n\n    def GetFilename(self):\n        return (self.Filename)\n\n    def GetSeparator(self):\n        return (self.Separator)\n\n    def GetColumn(self):\n        return (self.Column)\n\n    def SetPadding(self, padding):\n        self.Padding = padding\n        self.Frame['padding'] = padding\n\n    def SetBorder(self, borderwidth):\n        self.BorderWidth = borderwidth\n        self.Frame['borderwidth'] = borderwidth\n\n    def SetRelief(self, relief):\n        self.Relief = relief\n        self.Frame['relief'] = relief\n\n    def PackLeft(self):\n        self.Frame.pack(side=tk.LEFT,\n                        anchor=tk.NW,\n                        padx=10,\n                        pady=10)\n\n    def PackRight(self):\n        self.Frame.pack(side=tk.RIGHT,\n                        anchor=tk.NE,\n                        padx=10,\n                        pady=10)\n\n    # Called when reloading a CSV\n    #  Add the launch button and pack everything\n    def Reload_PutLaunchButton(self, TheWindowListToReload):\n        self.Frame.pack(side=tk.TOP, anchor=tk.N)\n        self.LaunchButton = tk.Button(self.OutterCanvas,\n                                      text=\"Launch\",\n                                      command=lambda: Reload_WindowList(self,\n                                                                        self.GlobalListNumber,\n                                                                        TheWindowListToReload))\n        self.LaunchButton.pack(side=tk.TOP,\n                               padx=10,\n                               pady=10)\n\n    # Quit the \"mainloop\" and return\n    def CallQuit(self):\n        self.OutterCanvas.quit()\n\n    # Kill the \"mainloop\" completely/Exit program\n    def CallDestroy(self):\n        self.OutterCanvas.destroy()\n\n    def ChooseFile(self):\n        # Open a dialog box in order to select the CSV file\n        file = filedialog.askopenfilename(title=\"Select a CSV file\",\n                                          filetypes=[(\"CSV Files\", \"*.csv\"),\n                                                     (\"Text Files\",\"*.txt\"),\n                                                     (\"All Files\",\"*.*\")])\n\n        # Check if a file has been selected\n        if (file):\n            # Store & Fill the file path in the entry box\n            self.Filename.set(file)\n            self.FileEntry.delete(0, tk.END) # remove previous content\n            self.FileEntry.insert(0, file)\n\n    def Validate(self):\n        self.Filename.set(self.FileEntry.get())\n        self.Separator.set(self.SeparatorEntry.get())\n        self.Column.set(self.ColumnEntry.get())\n\n        #print(\"Frame :\")\n        #print(\"  Path : --\" + self.Filename.get() + \"--\")\n        #print(\"  Sep  : --\" + self.Separator.get() + \"--\")\n        #print(\"  Col  : --\" + self.Column.get() + \"--\")\n\n        if ((os.path.isfile(self.Filename.get())) and\n            (len(self.Separator.get()) == 1) and\n            (int(self.Column.get()) > 0)) :\n\n            return (self.Filename.get(), self.Separator.get(), self.Column.get())\n        else :\n            return (None)\n\n    def GetCSVInfos(self):\n        return (self.Validate())", "\n\ndef Reload_WindowList(Frame, NumList, TheWindowListToReload):\n    # Get CSV informations\n    CSVInfos = Frame.GetCSVInfos()\n\n    #print(\"[ReloadWindowList] CSV :\")\n    #print(type(CSVInfos))\n    #print(CSVInfos)\n    #print(\" \")\n\n    if (not (CSVInfos is None)):\n        # Correct the columns (technical) : [1 -> 9] to [0 -> 8]\n        Col = int(CSVInfos[2]) - 1\n\n        Globals.gui_liste[NumList] = load_csv(CSVInfos[0], CSVInfos[1], Col)\n\n        # If the CSV has been correctly loaded, exit\n        if (not (Globals.gui_liste[NumList] is None)):\n            # Refresh the WindowList\n            TheWindowListToReload.InsertListInListBox(Globals.gui_liste[NumList])\n            # Close the main window and return back to the program\n            Frame.CallDestroy()\n            #Frame.CallQuit()\n\n    else :\n        #ErrWindow = tk.Tk()\n        #ErrWindow.title(\"Error\")\n        #ErrLabel = tk.Label(ErrWindow, text=\"Error : Fill correctly CSV\")\n        #ErrLabel.pack()\n        #ErrButton = tk.Button(ErrWindow,\n        #                      text=\"OK\",\n        #                      command=lambda: ErrWindow.destroy())\n        #ErrButton.pack()\n        ErrWindow = WindowError.WindowError()\n        ErrWindow.SetLabel(\"Error : Fill correctly CSV paths, separator, and column\")", ""]}
{"filename": "src/GuiClasses/WindowActions.py", "chunked_list": ["import sys\n\n# Tkinter GUI\nimport tkinter as tk\nfrom tkinter import ttk\nfrom tkinter import messagebox\n\n# Windows for input lists\nfrom GuiClasses import WindowList\n", "from GuiClasses import WindowList\n\n# Plugin loader\nfrom plugins_loader import PluginsImporter\n\n# Logic operators\nfrom basic_set_operators import ListSetOperators\nfrom basic_occurrencies_operators import ListOccurrenciesOperators\nfrom basic_various_operators import ListVariousOperators\n", "from basic_various_operators import ListVariousOperators\n\n# Globals required for the GUI\nfrom GuiClasses import Globals\n# gui_liste :  [0]:Input List 1  [1]:Input List 2  [2]:Output List\n# gui_liste = [None, None, None]\n\n\n# Class for proposing as much buttons as available operations on sets\nclass WindowActions:\n    Geometry = \"0\"\n    Title = \"CSV List Comparator\"\n    # Root Window\n    Root = None\n    # Canvas getting the Frame & Internal Canvas\n    Canvas = None\n    # Frame for putting scrollbars\n    FrameMain = None\n    FrameScrollbar = None\n    # Frame for buttons and others\n    Frame = None\n    # Scrollbars\n    Scrollbar_X = None\n    Scrollbar_Y = None\n    # Buttons for launching actions (set operations)\n    Buttons = []\n    # Labels\n    Labels = []\n    # Separators\n    Separators = []\n    # ListBox with the data\n    #ListBox = None\n\n    # Output WindowList that can be destroy as wished\n    OutWindow = None\n\n    def __init__(self, geometry):\n        self.Root = tk.Tk()\n\n        self.SetTitle(\"Actions\")\n        self.SetGeometry(geometry)\n\n        ## Frame Main [in root]\n        self.FrameMain = ttk.Frame(self.Root)\n        self.FrameMain.pack(fill=tk.BOTH,\n                            expand=True)\n        ## Frame for the scrollbar [in FrameMain]\n        self.FrameScrollbar = ttk.Frame(self.FrameMain)\n        self.FrameScrollbar.pack(side=tk.BOTTOM,\n                                 fill=tk.X)\n        ## Canvas [in FrameMain]\n        self.Canvas = tk.Canvas(self.FrameMain)\n        self.Canvas.pack(side=tk.LEFT,\n                         fill=tk.BOTH,\n                         expand=True)\n\n        ## Scrollbar in the Canvas [in FrameScrollbar and FrameMain]\n        #self.Scrollbar_X = ttk.Scrollbar(self.FrameScrollbar,\n        #                                 orient=tk.HORIZONTAL,\n        #                                 command=self.Canvas.xview)\n        #self.Scrollbar_X.pack(side=tk.BOTTOM,\n        #                      fill=tk.X)\n        self.Scrollbar_Y = ttk.Scrollbar(self.FrameMain,\n                                         orient=tk.VERTICAL,\n                                         command=self.Canvas.yview)\n        self.Scrollbar_Y.pack(side=tk.RIGHT,\n                              fill=tk.Y)\n\n        ## Configure the Canvas\n        #self.Canvas.configure(xscrollcommand=self.Scrollbar_X.set)\n        self.Canvas.configure(yscrollcommand=self.Scrollbar_Y.set)\n        self.Canvas.bind(\"<Configure>\",\n                         lambda e : self.Canvas.config(scrollregion=self.Canvas.bbox(tk.ALL)))\n\n        ## Frame internal (that will contain buttons) [in Canvas]\n        self.Frame = ttk.Frame(self.Canvas)\n        ## add a window to that frame in the canvas\n        self.Canvas.create_window((0,0),\n                                  window=self.Frame,\n                                  anchor=\"nw\")\n\n        ######################################\n        ### Put the separators and buttons ###\n        ######################################\n        self.__PutSeparatorsAndButtons()\n        ######################################\n\n        ## Separator\n        self.AddSeparator()\n\n        ## Exit button\n        self.Buttons.append(tk.Button(self.Frame,\n                                      text=\"Quit\",\n                                      command=lambda: on_closing(self)))\n        self.Buttons[-1].pack()\n        ## Catch the exit signal on the window ('X' in right corner)\n        self.Root.protocol(\"WM_DELETE_WINDOW\",\n                           lambda: on_closing(self))\n\n\n    ## Put the separators and buttons\n    def __PutSeparatorsAndButtons(self):\n        ## Loading buttons [in Frame]\n        ## [Currently hardcoded]\n        ## TODO : loading as much buttons as there are operations in the operations file\n\n        self.AddSeparator()\n        self.AddLabel(\"Occurrencies/Categories\")\n\n        for cls in ListOccurrenciesOperators():\n            button_str = str(cls.GetButton(cls))\n            name_str = str(cls.GetName(cls))\n            self.AddButton(button_str[0:32], lambda x=name_str[0:32] : CallBackAction(x))\n\n        self.AddSeparator()\n        self.AddLabel(\"Sets (no occurrencies)\")\n\n        for cls in ListSetOperators():\n            button_str = str(cls.GetButton(cls))\n            name_str = str(cls.GetName(cls))\n            self.AddButton(button_str[0:32], lambda x=name_str[0:32] : CallBackAction(x))\n\n        self.AddSeparator()\n        self.AddLabel(\"Various\")\n\n        for cls in ListVariousOperators():\n            button_str = str(cls.GetButton(cls))\n            name_str = str(cls.GetName(cls))\n            self.AddButton(button_str[0:32], lambda x=name_str[0:32] : CallBackAction(x))\n\n        self.AddSeparator()\n        self.AddLabel(\"Plugins\")\n\n        for cls in Globals.MyPluginsImporter.GetClasses():\n            button_str = str(cls.GetButton(cls))\n            name_str = str(cls.GetName(cls))\n            self.AddButton(button_str[0:32], lambda x=name_str[0:32] : CallBackAction(x))\n\n\n    ## Add a button in the frame\n    def AddButton(self, Text, Command):\n        self.Buttons.append(tk.Button(self.Frame,\n                                      text=Text,\n                                      command=Command))\n        self.Buttons[-1].pack(side=tk.TOP,\n                              fill=tk.X)\n\n    ## Add a label in the frame\n    def AddLabel(self, Text):\n        self.Labels.append(tk.ttk.Label(self.Frame,\n                                        text=Text))\n        self.Labels[-1].pack(expand=True,\n                             pady=5)\n\n    ## Add a separator in the frame\n    def AddSeparator(self):\n        self.Separators.append(tk.ttk.Separator(self.Frame,\n                                                orient=tk.HORIZONTAL))\n        self.Separators[-1].pack(side=tk.TOP,\n                                 fill=tk.X,\n                                 pady=5)\n\n    ## Regular Setters and Getters\n    def SetTitle(self, title):\n        self.Title = title\n        self.Root.title(title)\n\n    def SetGeometry(self, geometry):\n        self.Geometry = geometry\n        self.Root.geometry(geometry)\n\n    def GetGeometry(self):\n        return (self.Geometry)\n\n    def GetTitle(self):\n        return (self.Title)\n\n    ## Window loop and destroyers\n    def CallMainloop(self):\n        self.Root.mainloop()\n\n    def CallWithdraw(self):\n        self.Root.withdraw()\n\n    def CallDestroy(self):\n        self.Root.destroy()", "# Class for proposing as much buttons as available operations on sets\nclass WindowActions:\n    Geometry = \"0\"\n    Title = \"CSV List Comparator\"\n    # Root Window\n    Root = None\n    # Canvas getting the Frame & Internal Canvas\n    Canvas = None\n    # Frame for putting scrollbars\n    FrameMain = None\n    FrameScrollbar = None\n    # Frame for buttons and others\n    Frame = None\n    # Scrollbars\n    Scrollbar_X = None\n    Scrollbar_Y = None\n    # Buttons for launching actions (set operations)\n    Buttons = []\n    # Labels\n    Labels = []\n    # Separators\n    Separators = []\n    # ListBox with the data\n    #ListBox = None\n\n    # Output WindowList that can be destroy as wished\n    OutWindow = None\n\n    def __init__(self, geometry):\n        self.Root = tk.Tk()\n\n        self.SetTitle(\"Actions\")\n        self.SetGeometry(geometry)\n\n        ## Frame Main [in root]\n        self.FrameMain = ttk.Frame(self.Root)\n        self.FrameMain.pack(fill=tk.BOTH,\n                            expand=True)\n        ## Frame for the scrollbar [in FrameMain]\n        self.FrameScrollbar = ttk.Frame(self.FrameMain)\n        self.FrameScrollbar.pack(side=tk.BOTTOM,\n                                 fill=tk.X)\n        ## Canvas [in FrameMain]\n        self.Canvas = tk.Canvas(self.FrameMain)\n        self.Canvas.pack(side=tk.LEFT,\n                         fill=tk.BOTH,\n                         expand=True)\n\n        ## Scrollbar in the Canvas [in FrameScrollbar and FrameMain]\n        #self.Scrollbar_X = ttk.Scrollbar(self.FrameScrollbar,\n        #                                 orient=tk.HORIZONTAL,\n        #                                 command=self.Canvas.xview)\n        #self.Scrollbar_X.pack(side=tk.BOTTOM,\n        #                      fill=tk.X)\n        self.Scrollbar_Y = ttk.Scrollbar(self.FrameMain,\n                                         orient=tk.VERTICAL,\n                                         command=self.Canvas.yview)\n        self.Scrollbar_Y.pack(side=tk.RIGHT,\n                              fill=tk.Y)\n\n        ## Configure the Canvas\n        #self.Canvas.configure(xscrollcommand=self.Scrollbar_X.set)\n        self.Canvas.configure(yscrollcommand=self.Scrollbar_Y.set)\n        self.Canvas.bind(\"<Configure>\",\n                         lambda e : self.Canvas.config(scrollregion=self.Canvas.bbox(tk.ALL)))\n\n        ## Frame internal (that will contain buttons) [in Canvas]\n        self.Frame = ttk.Frame(self.Canvas)\n        ## add a window to that frame in the canvas\n        self.Canvas.create_window((0,0),\n                                  window=self.Frame,\n                                  anchor=\"nw\")\n\n        ######################################\n        ### Put the separators and buttons ###\n        ######################################\n        self.__PutSeparatorsAndButtons()\n        ######################################\n\n        ## Separator\n        self.AddSeparator()\n\n        ## Exit button\n        self.Buttons.append(tk.Button(self.Frame,\n                                      text=\"Quit\",\n                                      command=lambda: on_closing(self)))\n        self.Buttons[-1].pack()\n        ## Catch the exit signal on the window ('X' in right corner)\n        self.Root.protocol(\"WM_DELETE_WINDOW\",\n                           lambda: on_closing(self))\n\n\n    ## Put the separators and buttons\n    def __PutSeparatorsAndButtons(self):\n        ## Loading buttons [in Frame]\n        ## [Currently hardcoded]\n        ## TODO : loading as much buttons as there are operations in the operations file\n\n        self.AddSeparator()\n        self.AddLabel(\"Occurrencies/Categories\")\n\n        for cls in ListOccurrenciesOperators():\n            button_str = str(cls.GetButton(cls))\n            name_str = str(cls.GetName(cls))\n            self.AddButton(button_str[0:32], lambda x=name_str[0:32] : CallBackAction(x))\n\n        self.AddSeparator()\n        self.AddLabel(\"Sets (no occurrencies)\")\n\n        for cls in ListSetOperators():\n            button_str = str(cls.GetButton(cls))\n            name_str = str(cls.GetName(cls))\n            self.AddButton(button_str[0:32], lambda x=name_str[0:32] : CallBackAction(x))\n\n        self.AddSeparator()\n        self.AddLabel(\"Various\")\n\n        for cls in ListVariousOperators():\n            button_str = str(cls.GetButton(cls))\n            name_str = str(cls.GetName(cls))\n            self.AddButton(button_str[0:32], lambda x=name_str[0:32] : CallBackAction(x))\n\n        self.AddSeparator()\n        self.AddLabel(\"Plugins\")\n\n        for cls in Globals.MyPluginsImporter.GetClasses():\n            button_str = str(cls.GetButton(cls))\n            name_str = str(cls.GetName(cls))\n            self.AddButton(button_str[0:32], lambda x=name_str[0:32] : CallBackAction(x))\n\n\n    ## Add a button in the frame\n    def AddButton(self, Text, Command):\n        self.Buttons.append(tk.Button(self.Frame,\n                                      text=Text,\n                                      command=Command))\n        self.Buttons[-1].pack(side=tk.TOP,\n                              fill=tk.X)\n\n    ## Add a label in the frame\n    def AddLabel(self, Text):\n        self.Labels.append(tk.ttk.Label(self.Frame,\n                                        text=Text))\n        self.Labels[-1].pack(expand=True,\n                             pady=5)\n\n    ## Add a separator in the frame\n    def AddSeparator(self):\n        self.Separators.append(tk.ttk.Separator(self.Frame,\n                                                orient=tk.HORIZONTAL))\n        self.Separators[-1].pack(side=tk.TOP,\n                                 fill=tk.X,\n                                 pady=5)\n\n    ## Regular Setters and Getters\n    def SetTitle(self, title):\n        self.Title = title\n        self.Root.title(title)\n\n    def SetGeometry(self, geometry):\n        self.Geometry = geometry\n        self.Root.geometry(geometry)\n\n    def GetGeometry(self):\n        return (self.Geometry)\n\n    def GetTitle(self):\n        return (self.Title)\n\n    ## Window loop and destroyers\n    def CallMainloop(self):\n        self.Root.mainloop()\n\n    def CallWithdraw(self):\n        self.Root.withdraw()\n\n    def CallDestroy(self):\n        self.Root.destroy()", "\n\n## Callback for when an action button is clicked\ndef CallBackAction(action):\n    CloseOutWindow()\n\n    # Put Occurrencies and Set in the list of operators\n    operators = ListOccurrenciesOperators() + ListSetOperators() + ListVariousOperators()\n    # Add plugins in the list of operators\n    operators = operators + Globals.MyPluginsImporter.GetClasses()\n\n    for cls in operators:\n        verb = str(cls.GetName(cls))\n        if (action == verb[0:32]):\n            res = cls.Logic(cls, Globals.gui_liste[0], Globals.gui_liste[1])\n            break\n\n    Globals.gui_liste[2] = res\n\n    # Open a new Window List specialized as OutputList / FrameCSVSaver\n    Globals.gui_out_window = WindowList.WindowList(2,\n                                                   \"300x400+650+375\")\n    Globals.gui_out_window.SetTitle(action)\n    Globals.gui_out_window.SpecializedAsOutputList()", "\n\n# Procedure for closing the output window (before reopening it)\ndef CloseOutWindow():\n    if (not (Globals.gui_out_window is None)):\n        # Globals.gui_out_window.withdraw()\n        Globals.gui_out_window.CallWithdraw()\n        del Globals.gui_out_window\n        Globals.gui_out_window = None\n", "\n# Callback called when clicking on closing\ndef on_closing(TheWindow):\n    if (messagebox.askokcancel(\"Quit\", \"Do you want to quit?\")):\n        #TheWindow.CallDestroy()\n        sys.exit(0)\n\n# Insert data in a dictionnary\ndef insert_data(data, dictio):\n    for valeur, compte in dictio.items():\n        texte = f\"{valeur} : {compte} occurrence(s)\"\n        data.insert(0, texte)", "def insert_data(data, dictio):\n    for valeur, compte in dictio.items():\n        texte = f\"{valeur} : {compte} occurrence(s)\"\n        data.insert(0, texte)\n"]}
{"filename": "src/GuiClasses/FrameCSVSaver.py", "chunked_list": ["import os.path\n\n# Tkinter GUI\nimport tkinter as tk\nfrom tkinter import filedialog\n\n# Windows for errors\nfrom GuiClasses import WindowError\n\n# CSV Loader", "\n# CSV Loader\nfrom csv_manipulate import load_csv\n\n# Tools\nfrom tools import occurrence\nfrom enum import Enum\n\n# Globals required for the GUI\nfrom GuiClasses import Globals", "# Globals required for the GUI\nfrom GuiClasses import Globals\n# gui_liste : Input List 1, Input List 2, Output List\n# gui_liste = [None, None, None]\n\n\n# Choice of the output style : terms ? or terms;occ ?\nclass ChoiceModeType(Enum):\n    TERMS = 1\n    OCCURRENCIES = 2", "\n# Frame asking for informations about a CSV (path, sep, col)\nclass FrameCSVSaver:\n    GlobalListNumber = None\n\n    # Values we want to get from the user (tk.StringVar())\n    Separator = None\n    ModeType = None\n    Filename = None\n\n    ### GUI\n    # The current frame\n    Frame = None\n    # Canvas where to put the current frame\n    OutterCanvas = None\n    # Specifications of the current frame\n    Geometry = None\n    Padding = None\n    BorderWidth = None\n    Relief = None\n    # Widgets of the frame\n    SeparatorLabel = None\n    SeparatorEntry = None\n    ModeTypeLabel = None\n    ModeTypeRadioButton1 = None\n    ModeTypeRadioButton2 = None\n    # Widgets for saving into a CSV\n    SaveButton = None\n\n    def __init__(self, canvas, ListNum=None):\n        # Get the canvas where to put the frame\n        self.OutterCanvas = canvas\n        self.GlobalListNumber = ListNum\n\n        self.Frame = tk.Frame(self.OutterCanvas)\n\n        # Fill variables\n        self.Separator = tk.StringVar()\n        self.ModeType = tk.IntVar(self.Frame)\n        self.Filename = tk.StringVar()\n\n        # Separator Description and Field\n        self.SeparatorLabel = tk.Label(self.Frame,\n                                       text=\"Separator:\")\n        self.SeparatorLabel.pack()\n        self.SeparatorEntry = tk.Entry(self.Frame,\n                                       textvariable=self.Separator)\n        self.SeparatorEntry.insert(0, \";\")\n        self.SeparatorEntry.pack()\n\n        # Output choice list type : terms ? or terms;occ ?\n        self.ModeTypeLabel = tk.Label(self.Frame,\n                                      text=\"Type of output:\")\n        self.ModeTypeLabel.pack()\n        # Radio button : List\n        self.ModeTypeRadioButton1 = tk.Radiobutton(self.Frame,\n                                                   text=\"Terms only\",\n                                                   variable=self.ModeType,\n                                                   value=ChoiceModeType.TERMS.value)\n        self.ModeTypeRadioButton1.pack()\n        # Radio button : Occurrencies\n        self.ModeTypeRadioButton2 = tk.Radiobutton(self.Frame,\n                                                   text=\"Occurrencies\",\n                                                   variable=self.ModeType,\n                                                   value=ChoiceModeType.OCCURRENCIES.value)\n        self.ModeTypeRadioButton2.pack()\n\n        # Default : Terms list\n        #self.ModeType.set(ChoiceModeType.TERMS.value)\n        self.ModeTypeRadioButton1.select()\n        # Default : None\n        #self.ModeType.set(None)\n\n        #self.Frame.pack(side=\"left\", padx=50, pady=50)\n\n\n    def GetFilename(self):\n        return (self.Filename)\n\n    def GetSeparator(self):\n        return (self.Separator)\n\n    def GetModeType(self):\n        return (self.ModeType)\n\n\n    # Called when saving a CSV\n    #  Add the launch button and pack everything\n    def Save_PutSaveButton(self, TheWindowListToSave):\n        self.Frame.pack(side=tk.TOP, anchor=tk.N)\n        self.SaveButton = tk.Button(self.OutterCanvas,\n                                    text=\"Save to\",\n                                    command=lambda: Save_WindowList(self,\n                                                                    self.GlobalListNumber,\n                                                                    TheWindowListToSave))\n        self.SaveButton.pack(side=tk.TOP,\n                             padx=10,\n                             pady=10)\n\n\n    # Quit the \"mainloop\" and return\n    def CallQuit(self):\n        self.OutterCanvas.quit()\n\n    # Kill the \"mainloop\" completely/Exit program\n    def CallDestroy(self):\n        self.OutterCanvas.destroy()\n\n\n    def Validate(self):\n        self.Separator.set(self.SeparatorEntry.get())\n        #self.ModeType.set(self.ModeTypeEntry.get())\n\n        #print(\"Frame [Save] :\")\n        #print(\"  Sep  : --\" + self.Separator.get() + \"--\")\n        #print(\"  ModeType  : --\" + str(self.ModeType.get()) + \"--\")\n\n        if ((len(self.Separator.get()) == 1) and\n            ((self.ModeType.get() == ChoiceModeType.TERMS.value)\n             or (self.ModeType.get() == ChoiceModeType.OCCURRENCIES.value))) :\n\n            return (self.Separator.get(), self.ModeType.get())\n        else :\n            return (None)\n\n    def GetCSVInfos(self):\n        return (self.Validate())", "\n\ndef Save_WindowList(Frame, NumList, TheWindowListToSave):\n    # Get CSV informations\n    CSVInfos = Frame.GetCSVInfos()\n\n    #print(\"[SaveWindowList] CSV :\")\n    #print(type(CSVInfos))\n    #print(CSVInfos)\n    #print(\" \")\n\n    if (not (CSVInfos is None)):\n        ModeType = int(CSVInfos[1])\n        Sep = CSVInfos[0]\n        data = Globals.gui_liste[NumList]\n\n        filename = filedialog.asksaveasfilename(filetypes=[(\"CSV Files\", \"*.csv\")],\n                                                defaultextension=\".csv\")\n        fd = open(filename, 'w')\n        if (ModeType == ChoiceModeType.TERMS.value):\n            [fd.write(\"{0}\\n\".format(key)) for key in data]\n        elif (ModeType == ChoiceModeType.OCCURRENCIES.value):\n            occu = occurrence(data)\n            [fd.write(\"{0}{1}{2}\\n\".format(key, Sep, value)) for key, value in occu.items()]\n        fd.close()\n        Frame.CallDestroy()\n    else:\n        ErrWindow = WindowError.WindowError()\n        ErrWindow.SetLabel(\"Error : Fill correctly CSV separator and column\")", ""]}
{"filename": "src/GuiClasses/WindowExit.py", "chunked_list": ["# Tkinter GUI\nimport tkinter as tk\n\n\nclass WindowExit:\n    Geometry = None\n    Title = None\n\n    # Main window getting the label and button\n    Root = None\n\n    # The button and its text to click on\n    Button = None\n    ButtonText = None\n\n    def __init__(self):\n        self.Root = tk.Tk()\n        self.SetTitle(\"Close Application\")\n        self.ButtonText = \"Close All Windows\"\n        self.Button = tk.Button(self.Root,\n                                text=\"Close All Windows\",\n                                command=lambda: exit(0))\n        self.Button.pack()\n\n    def SetGeometry(self, geometry):\n        self.Geometry = geometry\n        self.Root.geometry(geometry)\n\n    def GetGeometry(self):\n        return (self.Geometry)\n\n    def SetTitle(self, title):\n        self.Title = title\n        self.Root.title(title)\n\n    def GetTitle(self):\n        return (self.Title)\n\n    def SetButton(self, button_text):\n        self.Button.destroy()\n        self.ButtonText = button_text\n        self.Button = tk.Button(self.Root,\n                                text=button_text,\n                                command=lambda: exit(0))\n        self.Button.pack()", ""]}
{"filename": "src/GuiClasses/Globals.py", "chunked_list": ["# gui_liste : [0]:Input List 1   [1]:Input List 2   [2]:Output List\ngui_liste = [None, None, None]\n\n# output window\ngui_out_window = None\n\n# MyPluginsImporter\nMyPluginsImporter = None\n", ""]}
{"filename": "src/CliClasses/actions.py", "chunked_list": ["import sys\n\n# Plugin loader\nfrom plugins_loader import PluginsImporter\n\n# Logic operators\nfrom basic_set_operators import ListSetOperators\nfrom basic_occurrencies_operators import ListOccurrenciesOperators\nfrom basic_various_operators import ListVariousOperators\n", "from basic_various_operators import ListVariousOperators\n\n# Tools for lists\nfrom tools import occurrence\n\n\n### LOADS ACTIONS FROM DIFFERENT FILES ###\n\ndef get_set_actions():\n    set_actions = []\n    for cls in ListSetOperators():\n        name_str = str(cls.GetName(cls))\n        #function = lambda l1, l2 : cls.Logic(cls, l1, l2)\n        set_actions.append([name_str[0:32], lambda l1, l2 : cls.Logic(cls, l1, l2)])\n    return (set_actions)", "def get_set_actions():\n    set_actions = []\n    for cls in ListSetOperators():\n        name_str = str(cls.GetName(cls))\n        #function = lambda l1, l2 : cls.Logic(cls, l1, l2)\n        set_actions.append([name_str[0:32], lambda l1, l2 : cls.Logic(cls, l1, l2)])\n    return (set_actions)\n\ndef get_occurrencies_actions():\n    occ_actions = []\n    for cls in ListOccurrenciesOperators():\n        name_str = str(cls.GetName(cls))\n        #function = lambda l1, l2 : cls.Logic(cls, l1, l2)\n        occ_actions.append([name_str[0:32], lambda l1, l2 : cls.Logic(cls, l1, l2)])\n    return (occ_actions)", "def get_occurrencies_actions():\n    occ_actions = []\n    for cls in ListOccurrenciesOperators():\n        name_str = str(cls.GetName(cls))\n        #function = lambda l1, l2 : cls.Logic(cls, l1, l2)\n        occ_actions.append([name_str[0:32], lambda l1, l2 : cls.Logic(cls, l1, l2)])\n    return (occ_actions)\n\ndef get_various_actions():\n    var_actions = []\n    for cls in ListVariousOperators():\n        name_str = str(cls.GetName(cls))\n        #function = lambda l1, l2 : cls.Logic(cls, l1, l2)\n        var_actions.append([name_str[0:32], lambda l1, l2 : cls.Logic(cls, l1, l2)])\n    return (var_actions)", "def get_various_actions():\n    var_actions = []\n    for cls in ListVariousOperators():\n        name_str = str(cls.GetName(cls))\n        #function = lambda l1, l2 : cls.Logic(cls, l1, l2)\n        var_actions.append([name_str[0:32], lambda l1, l2 : cls.Logic(cls, l1, l2)])\n    return (var_actions)\n\ndef get_plugins_actions(MyPluginsImporter):\n    plugins_actions = []\n    for cls in MyPluginsImporter.GetClasses():\n        name_str = str(cls.GetName(cls))\n        #function = lambda l1, l2 : cls.Logic(cls, l1, l2)\n        plugins_actions.append([name_str[0:32], lambda l1, l2 : cls.Logic(cls, l1, l2)])\n    return (plugins_actions)", "def get_plugins_actions(MyPluginsImporter):\n    plugins_actions = []\n    for cls in MyPluginsImporter.GetClasses():\n        name_str = str(cls.GetName(cls))\n        #function = lambda l1, l2 : cls.Logic(cls, l1, l2)\n        plugins_actions.append([name_str[0:32], lambda l1, l2 : cls.Logic(cls, l1, l2)])\n    return (plugins_actions)\n\n\n### SEARCH ONE ACTION TO DO FROM THE LISTS OF ACTIONS ###", "\n### SEARCH ONE ACTION TO DO FROM THE LISTS OF ACTIONS ###\n\ndef execute_action(list_1, list_2, action, MyPluginsImporter):\n    # Execution of the desired action\n    out_dict = []\n\n    # Fundamental actions\n    if (action == \"CSV_1\"):\n        # Print CSV 1\n        csv_1 = list_1\n        out_dict = occurrence(csv_1)\n        return (out_dict)\n\n    if (action == \"CSV_2\"):\n        # Print CSV 2\n        csv_2 = list_2\n        out_dict = occurrence(csv_2)\n        return (out_dict)\n\n    # Load internal functions first (set & occ & var) and search the verbs\n    operations = get_set_actions() + get_occurrencies_actions() + get_various_actions()\n    for operation in operations:\n        # operation == [ name/action, lambda l1, l2 : Logic(l1, l2) ]\n        verb = operation[0]\n        #function = operation[1] ### Contains a lambda\n        if (action == verb):\n            res = operation[1](list_1, list_2)\n            out_dict = occurrence(res)\n            return (out_dict)\n\n    # Load plugins functions if action is not found in the integrated ones\n    new_operations = get_plugins_actions(MyPluginsImporter)\n    for operation in new_operations:\n        verb = operation[0]\n        #function = operation[1] ### Contains a lambda\n        if (action == verb):\n            res = operation[1](list_1, list_2)\n            out_dict = occurrence(res)\n            return (out_dict)\n\n    print(\"!!! ERROR: ACTION NOT FOUND !!!\")\n\n    sys.exit(-3)", ""]}
{"filename": "src/CliClasses/__init__.py", "chunked_list": [""]}
{"filename": "src/CliClasses/usages.py", "chunked_list": ["import sys\n\n# Plugin loader\nfrom plugins_loader import PluginsImporter\n\n# Logic operators\nfrom basic_set_operators import ListSetOperators\nfrom basic_occurrencies_operators import ListOccurrenciesOperators\nfrom basic_various_operators import ListVariousOperators\n", "from basic_various_operators import ListVariousOperators\n\n\n### USAGE PRINTERS ###\n\ndef print_usage(MyPluginsImporter):\n    print_basic_usage()\n    print(\"\")\n    print_set_usage()\n    print(\"\")\n    print_various_usage()\n    print(\"\")\n    print_occurrencies_usage()\n    if (MyPluginsImporter.GetNbClasses() > 0):\n        print(\"\")\n        print_plugins_usage(MyPluginsImporter)", "\ndef print_basic_usage():\n    print(\"Usage: python CLI.py \" \\\n          \"<file_path_1> <separator1> <column_of_ID_1> \" \\\n          \"<file_path_2> <separator2> <column_of_ID_2> \" \\\n          \"<action> \" \\\n          \"<output_separator> [<output_file>]\")\n    print(\"\")\n    print(\"Write the output in the terminal if no <output_file> given or\" \\\n          \" if it is '-'\")\n    print(\"or write in the designated file (created if it does not exist)\")\n    print(\"\")\n    print(\"-- Actions --\")\n    print(\"CSV_1 : \")\n    print(\"   Print only 1st CSV\")\n    print(\"CSV_2 : \")\n    print(\"   Print only 2nd CSV\")", "\ndef print_set_usage():\n    print(\"-- Actions Set --\")\n    print(\" [set] : operation working on sets (occurrencies not used)\")\n    for cls in ListSetOperators():\n        name_str = str(cls.GetName(cls))\n        help_str = str(cls.GetHelp(cls))\n        print(name_str[0:32] + \" : [set]\")\n        print(\"   \" + help_str[0:256])\n\ndef print_occurrencies_usage():\n    print(\"-- Actions Occurrencies/Categories --\")\n    for cls in ListOccurrenciesOperators():\n        name_str = str(cls.GetName(cls))\n        help_str = str(cls.GetHelp(cls))\n        print(name_str[0:32] + \" :\")\n        print(\"   \" + help_str[0:256])", "\ndef print_occurrencies_usage():\n    print(\"-- Actions Occurrencies/Categories --\")\n    for cls in ListOccurrenciesOperators():\n        name_str = str(cls.GetName(cls))\n        help_str = str(cls.GetHelp(cls))\n        print(name_str[0:32] + \" :\")\n        print(\"   \" + help_str[0:256])\n\ndef print_various_usage():\n    print(\"-- Actions Various --\")\n    for cls in ListVariousOperators():\n        name_str = str(cls.GetName(cls))\n        help_str = str(cls.GetHelp(cls))\n        print(name_str[0:32] + \" :\")\n        print(\"   \" + help_str[0:256])", "\ndef print_various_usage():\n    print(\"-- Actions Various --\")\n    for cls in ListVariousOperators():\n        name_str = str(cls.GetName(cls))\n        help_str = str(cls.GetHelp(cls))\n        print(name_str[0:32] + \" :\")\n        print(\"   \" + help_str[0:256])\n\ndef print_plugins_usage(MyPluginsImporter):\n    print(\"-- Actions Plugins --\")\n    for cls in MyPluginsImporter.GetClasses():\n        name_str = str(cls.GetName(cls))\n        help_str = str(cls.GetHelp(cls))\n        print(name_str[0:32] + \" :\")\n        print(\"   \" + help_str[0:256])", "\ndef print_plugins_usage(MyPluginsImporter):\n    print(\"-- Actions Plugins --\")\n    for cls in MyPluginsImporter.GetClasses():\n        name_str = str(cls.GetName(cls))\n        help_str = str(cls.GetHelp(cls))\n        print(name_str[0:32] + \" :\")\n        print(\"   \" + help_str[0:256])\n", ""]}
