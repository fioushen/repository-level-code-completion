{"filename": "setup.py", "chunked_list": ["#!/usr/bin/env python\n\nimport setuptools\n\nif __name__ == \"__main__\":\n    setuptools.setup()\n"]}
{"filename": "tests/conftest.py", "chunked_list": [""]}
{"filename": "tests/showcase/test_showcasing.py", "chunked_list": ["from manim import *\n\nfrom powermanim.showcase.showcasescene import QUALITY, WOWCHEMY_FOLDER, ShowcaseMeta\n\n\ndef test_and_gen_showcases():\n    for scene in ShowcaseMeta.showcase_scenes:\n        with tempconfig(\n            {\n                \"quality\": QUALITY,\n                \"disable_caching\": True,\n                \"custom_folders\": True,\n                \"media_dir\": WOWCHEMY_FOLDER,\n            }\n        ):\n            scene = scene()\n            scene.render()", ""]}
{"filename": "src/powermanim/__init__.py", "chunked_list": ["try:\n    from ._version import __version__ as __version__\nexcept ImportError:\n    import sys\n\n    print(\n        \"Project not installed in the current env, activate the correct env or install it with:\\n\\tpip install -e .\",\n        file=sys.stderr,\n    )\n    __version__ = \"unknown\"", ""]}
{"filename": "src/powermanim/components/chartbars.py", "chunked_list": ["import itertools\nfrom typing import Iterable, Sequence\n\nfrom colour import Color\nfrom manim import *\n\n\nclass ChartBars(VGroup):\n    def __init__(\n        self,\n        axes,\n        values: Sequence[float | int],\n        xs: Sequence[float] | None = None,\n        width_ratio: float = 1.0,\n        offset: float = 0.5,\n        fill_color: Color = BLUE,\n        fill_opacity: float = 0.5,\n        stroke_color: Color = WHITE,\n        stroke_width: float = 1.0,\n    ):\n        \"\"\"Create a bar chart from values.\n\n        Args:\n            axes: The axes to plot the bars on.\n            values: The values to plot. There should be one value for each bar.\n            xs: The x-coordinates of the bars. If None, the bars will be centered on\n                each integer from 1 to the number of values.\n            width_ratio: The width of each bar as a fraction of the distance between x-coordinates.\n            offset: The distance of the bars from the x-coordinates as a fraction of the distance between x-coordinates.\n            fill_color: The fill color of the bars.\n            fill_opacity: The fill opacity of the bars.\n            stroke_color: The stroke color of the bars.\n            stroke_width: The stroke width of the bars.\n        \"\"\"\n        xs = xs if xs is not None else np.arange(*axes.x_range)\n\n        self.x_to_index = dict(zip(xs, itertools.count()))\n        x_step = xs[1] - xs[0]\n        x_unit = axes.x_axis.get_unit_size()\n        y_unit = axes.y_axis.get_unit_size()\n\n        width = width_ratio * x_unit * x_step\n\n        # Create a list of rectangles arranged side by side,\n        # one for each x value\n        rects = []\n        epsilon = 1e-8\n        for x, y in zip(xs, values):\n            rect = Rectangle(\n                width=width,\n                height=max(y * y_unit, epsilon),\n                fill_color=fill_color,\n                fill_opacity=fill_opacity,\n                stroke_color=stroke_color,\n                stroke_width=stroke_width,\n            )\n            rect.move_to(axes.c2p(x + offset * x_step, 0), DOWN)\n            rects.append(rect)\n        super().__init__(*rects)\n        self.axes = axes\n        self.xs = xs\n        self.set_values(values)\n\n    def set_values(self, values: Iterable[float | int]):\n        y_unit = self.axes.y_axis.get_unit_size()\n        for rect, value in zip(self, values):\n            new_height = value * y_unit\n            height = rect.get_top()[1] - rect.get_bottom()[1]\n            rescale = new_height / height\n            rect.stretch(\n                rescale,\n                dim=1,\n                about_edge=DOWN,\n            )", ""]}
{"filename": "src/powermanim/components/numberslider.py", "chunked_list": ["from manim import *\n\n\nclass NumberSlider(VGroup):\n    def __init__(\n        self,\n        x_range=[-2, 2, 0.5],\n        length=2,\n    ):\n        \"\"\"A class to represent a number together with an associated slider.\n\n        Args:\n            x_range (list): A list of 3 floats representing x_min, x_max and x_step.\n            length (float): Length of the line.\n        \"\"\"\n        self.tracker = ValueTracker(0)\n\n        decimal_number = DecimalNumber(self.tracker.get_value(), num_decimal_places=1)\n\n        number_line = NumberLine(\n            x_range=x_range,\n            length=length,\n            rotation=90 * DEGREES,\n        )\n\n        arrow = Arrow(RIGHT / 2, LEFT / 2, buff=0).next_to(number_line.n2p(self.tracker.get_value()), RIGHT)\n\n        arrow.add_updater(lambda obj: obj.become(obj.copy().next_to(number_line.n2p(self.tracker.get_value()), RIGHT)))\n        decimal_number.add_updater(\n            lambda obj: obj.set_value(\n                self.tracker.get_value(),\n            ).next_to(number_line, LEFT, buff=MED_LARGE_BUFF)\n        )\n\n        super().__init__(decimal_number, number_line, arrow)", ""]}
{"filename": "src/powermanim/components/__init__.py", "chunked_list": [""]}
{"filename": "src/powermanim/components/vgrouphighlight.py", "chunked_list": ["import typing as T\n\nfrom manim import *\n\n\nclass VGroupHighlight(VGroup):\n    def __init__(\n        self,\n        *args: VMobject,\n        anim_run_time: float = 1.0,\n        anim_lag_ratio: float = 0,\n        active_opacity: float = 1.0,\n        scale_active: float = 1.0,\n        scale_about_point=None,\n        scale_about_edge=None,\n        **kwargs: VMobject,\n    ) -> None:\n        \"\"\"Group component that can highlight a subset of its submobjects.\n\n        Args:\n            *args: Submobjects to be added to the VGroup.\n            anim_run_time (float): The run time of the animation.\n            anim_lag_ratio (float): The lag ratio of the animation.\n            active_opacity (float): The opacity of the highlighted submobjects.\n            scale_active (float): The scale of the highlighted submobjects.\n            scale_about_point (np.ndarray): The point to scale about.\n            scale_about_edge (np.ndarray): The edge to scale about.\n            **kwargs: Keyword arguments to be passed to the VGroup.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n        self.anim_run_time = anim_run_time\n        self.anim_lag_ratio = anim_lag_ratio\n        self.active_opacity = active_opacity\n        self.scale_active = scale_active\n        self.scale_about_point = scale_about_point\n        self.scale_about_edge = scale_about_edge\n\n        self.previously_active_idxs = []\n\n    def highlight(self, indices: T.Union[int, T.Sequence[int]]) -> AnimationGroup:\n        \"\"\"Highlights the submobjects in the given indices in the scene.\n\n        Args:\n            scene:\n                The scene in which the animation is played.\n\n            indices:\n                The indices to highlight. If a single integer is given, only that index is highlighted.\n                If a sequence of integers is given, all indices in the sequence are highlighted. The\n                previously highlighted indices are dehighlighted smoothly.\n        \"\"\"\n        anims = []\n\n        if not isinstance(indices, T.Sequence):\n            indices = [indices]\n\n        for to_highlight in indices:\n            item = self.submobjects[to_highlight]\n            if not hasattr(item, \"saved_state\") or item.saved_state is None:\n                item.save_state()\n            item.target = item.saved_state.copy()\n            item.target.scale(\n                self.scale_active,\n                about_point=self.scale_about_point,\n                about_edge=self.scale_about_edge,\n            )\n            item.target.set_opacity(self.active_opacity)\n            anims.append(MoveToTarget(item))\n\n        if self.previously_active_idxs:\n            for previously_active_idx in self.previously_active_idxs:\n                if previously_active_idx not in indices:\n                    anims.append(\n                        self.submobjects[previously_active_idx].animate.restore(),\n                    )\n\n        self.previously_active_idxs = indices\n\n        return AnimationGroup(*anims, lag_ratio=self.anim_lag_ratio)", ""]}
{"filename": "src/powermanim/components/powermanim.py", "chunked_list": ["from manim import *\nfrom manim.constants import DOWN, LEFT, ORIGIN, RIGHT, UP\nfrom manim.mobject.geometry.arc import Circle\nfrom manim.mobject.geometry.polygram import Square, Triangle\nfrom manim.mobject.text.tex_mobject import MathTex, Tex\nfrom manim.mobject.types.vectorized_mobject import VGroup\nfrom manim.utils.tex_templates import TexFontTemplates\n\n# config[\"pixel_height\"] = 500  #  1080 is default\n# config[\"pixel_width\"] = 1500  # 1920 is default", "# config[\"pixel_height\"] = 500  #  1080 is default\n# config[\"pixel_width\"] = 1500  # 1920 is default\n\n\nclass PowerManim(VGroup):\n    def build_shapes(self):\n        logo_green = \"#87c2a5\"\n        logo_blue = \"#525893\"\n        logo_red = \"#e07a5f\"\n\n        circle = Circle(color=logo_green, fill_opacity=1).shift(LEFT)\n\n        square = Square(color=logo_blue, fill_opacity=1).shift(UP)\n        triangle = Triangle(color=logo_red, fill_opacity=1).shift(RIGHT)\n\n        square = Difference(square, circle, color=logo_blue, fill_opacity=1)\n        triangle = Difference(triangle, square, color=logo_red, fill_opacity=1)\n\n        circle.shift(DL * self.gap)\n        triangle.shift(DR * self.gap)\n\n        return VGroup(circle, square, triangle)\n\n    def build_text(self):\n        ds_m = MathTex(r\"\\mathbb{PM}\", fill_color=self.logo_black).scale(5)\n        ds_m.shift(4.25 * LEFT + 1.5 * UP)\n        return ds_m\n\n    def build_banner(self):\n        shapes = self.build_shapes()\n\n        ds_p = MathTex(r\"\\mathbb{P}\", fill_color=self.logo_black).scale(2)\n        ower = Tex(\"ower\", tex_template=TexFontTemplates.gnu_freeserif_freesans).scale(2)\n        ower.next_to(ds_p, RIGHT, buff=SMALL_BUFF).align_to(ds_p, DOWN).set_color(self.font_color)\n        power = VGroup(ds_p, ower)\n\n        ds_m = MathTex(r\"\\mathbb{M}\", fill_color=self.logo_black).scale(2)\n        anim = Tex(\"anim\", tex_template=TexFontTemplates.gnu_freeserif_freesans).scale(2)\n        anim.next_to(ds_m, RIGHT, buff=SMALL_BUFF).align_to(ds_m, DOWN).set_color(self.font_color)\n        tmanim = VGroup(ds_m, anim)\n\n        banner = VGroup(power, tmanim).arrange(RIGHT, buff=MED_SMALL_BUFF).move_to(ORIGIN).scale(1.5)\n        banner.next_to(shapes[1], LEFT)\n        banner.align_to(shapes[0].get_critical_point(UP) + self.gap, DOWN)\n\n        return VGroup(shapes, banner).move_to(ORIGIN)\n\n    def __init__(self, font_color=\"#343434\", logo_black=\"#343434\", gap=0.4):\n        self.font_color = font_color\n        self.logo_black = logo_black\n        self.gap = gap\n\n        shapes = self.build_shapes()\n        ds_m = self.build_text()\n        super().__init__(*shapes, ds_m)\n        self.move_to(ORIGIN)", ""]}
{"filename": "src/powermanim/layouts/arrangedbullets.py", "chunked_list": ["import typing as T\nfrom collections import defaultdict\n\nfrom manim import *\n\n\nclass MathBullet(MathTex):\n    def __init__(\n        self,\n        *text: str,\n        level: int = 0,\n        group: T.Optional[int] = None,\n        adjustment: float = 0.0,\n        symbol: T.Optional[str] = r\"\\bullet\",\n        autoplace: bool = True,\n        **kwargs,\n    ):\n        \"\"\"A class to represent a bullet point.\n\n        Args:\n            text: The text to be displayed.\n            level: The indent level of the bullet point.\n            group: The group the bullet point belongs to, controls the animations.\n            adjustment: The adjustment of the bullet.\n            symbol: The symbol to be displayed as the bullet.\n            autoplace: Whether to automatically place the bullet point.\n        \"\"\"\n        self.level = level\n        self.adjustment = adjustment\n        self.group = group\n        self.symbol = symbol\n        self.autoplace = autoplace\n\n        first_text, *rest_text = text\n        if symbol is not None:\n            first_text = rf\"{symbol}~{first_text}\"\n\n        super().__init__(first_text, *rest_text, **kwargs)\n\n    def indent(self, indent_buff: float = MED_LARGE_BUFF * 1.5):\n        \"\"\"Indent the bullet point.\n\n        Args:\n            indent_buff: The spacing between the bullet and the text.\n        \"\"\"\n        self.shift(RIGHT * indent_buff * self.level)\n\n    def unindent(self, indent_buff: float = MED_LARGE_BUFF * 1.5):\n        \"\"\"Unindent the bullet point.\n\n        Args:\n            indent_buff: The spacing between the bullet and the text.\n        \"\"\"\n        self.shift(LEFT * indent_buff * self.intend_level)\n\n    def adjust(self, adjustment: T.Optional[float] = None):\n        \"\"\"Adjust the bullet point.\n\n        Args:\n            adjustment: The shift of the bullet.\n        \"\"\"\n        if adjustment is None:\n            adjustment = self.adjustment\n        self.shift(self.adjustment)", "\n\nclass Bullet(MathBullet):\n    def __init__(\n        self,\n        *text: str,\n        level: int = 0,\n        group: T.Optional[int] = None,\n        adjustment: float = 0.0,\n        symbol: T.Optional[str] = r\"$\\bullet$\",\n        force_inline: bool = False,\n        arg_separator=\"\",\n        tex_environment=\"center\",\n        **kwargs,\n    ):\n        first_text, *rest_text = text\n        if force_inline:\n            first_text = r\"\\mbox{\" + first_text\n            rest_text = *rest_text, r\"}\"\n\n        super().__init__(\n            first_text,\n            *rest_text,\n            level=level,\n            group=group,\n            adjustment=adjustment,\n            symbol=symbol,\n            arg_separator=arg_separator,\n            tex_environment=tex_environment,\n            **kwargs,\n        )", "\n\nclass ArrangedBullets(VGroup):\n    def arrage_rows(self, rows: T.Iterable[T.Union[MathBullet, Bullet, MathTex, Tex, Text]]):\n        bullet_rows: T.Iterable[MathBullet] = (\n            VGroup(*rows)\n            .arrange(DOWN, aligned_edge=LEFT, buff=self.line_spacing)\n            .to_edge(LEFT, buff=self.left_buff)\n            .shift(self.global_shift)\n        )\n\n        for row in bullet_rows:\n            row.indent(indent_buff=self.indent_buff)\n            row.adjust()\n\n    def __init__(\n        self,\n        *rows: T.Union[MathBullet, Bullet, MathTex, Tex, Text],\n        line_spacing: float = MED_LARGE_BUFF * 1.5,\n        indent_buff: float = MED_LARGE_BUFF * 1.5,\n        left_buff: float = MED_LARGE_BUFF * 1.5,\n        global_shift: float = 0.0,\n    ):\n        \"\"\"A VGroup that arranges the rows in a list of bullet points.\n\n        Args:\n            rows: A list of items to be displayed.\n            line_spacing: The spacing between the rows.\n            indent_buff: The spacing between the bullet and the text.\n            left_buff: The spacing between the left edge of the rows and the left edge of the screen.\n            global_shift: The global_shift of the rows.\n        \"\"\"\n        self.line_spacing = line_spacing\n        self.indent_buff = indent_buff\n        self.left_buff = left_buff\n        self.global_shift = global_shift\n\n        rows = [(row if isinstance(row, MathBullet) else Bullet(row)) for row in rows]\n\n        self.arrage_rows((row for row in rows if row.autoplace))\n\n        groups = [row.group for row in rows]\n\n        # If there is a None and aso something else\n        if (None in groups) and len(set(groups)) != 1:\n            raise ValueError(\"The groups must be specified for all or no bullets at all.\")\n\n        group2bullet = defaultdict(list)\n        for i, row in enumerate(rows):\n            group = row.group\n            if group is None:\n                group = i\n            group2bullet[group].append(row)\n\n        group_rows = []\n        for _, bullets in group2bullet.items():\n            group_rows.append(VGroup(*bullets))\n\n        super().__init__(*group_rows)\n        self.ngroups = len(self)", ""]}
{"filename": "src/powermanim/layouts/__init__.py", "chunked_list": [""]}
{"filename": "src/powermanim/templates/__init__.py", "chunked_list": [""]}
{"filename": "src/powermanim/templates/bulletlist.py", "chunked_list": ["import typing as T\n\nfrom manim import *\n\nfrom powermanim.components.vgrouphighlight import VGroupHighlight\nfrom powermanim.layouts.arrangedbullets import ArrangedBullets\n\n\nclass BulletList(VGroup):\n    def __init__(\n        self,\n        *rows: T.Union[Tex, Text],\n        line_spacing: float = MED_LARGE_BUFF * 1.5,\n        indent_buff: float = MED_LARGE_BUFF * 1.5,\n        left_buff: float = MED_LARGE_BUFF * 2,\n        global_shift: float = 0.0,\n        inactive_opacity: float = 0.5,\n        active_opacity: float = 1.0,\n        scale_active: float = 1.0,\n    ):\n        \"\"\"A class to represent an highlatable list of items.\n\n        Args:\n            rows: A list of items to be displayed.\n            line_spacing: The spacing between the rows.\n            indent_buff: The spacing between the bullet and the text.\n            left_buff: The spacing between the left edge of the rows and the left edge of the screen.\n            global_shift: The global_shift to apply to the rows.\n            inactive_opacity: The opacity of the inactive items.\n            active_opacity: The opacity of the active items.\n            scale_active: The scale of the active items.\n        \"\"\"\n        self.arranged_list = ArrangedBullets(\n            *rows,\n            line_spacing=line_spacing,\n            indent_buff=indent_buff,\n            left_buff=left_buff,\n            global_shift=global_shift,\n        ).set_opacity(inactive_opacity)\n\n        self.rows = VGroupHighlight(\n            *self.arranged_list,\n            active_opacity=active_opacity,\n            scale_active=scale_active,\n            scale_about_edge=LEFT,\n        )\n        super().__init__(self.rows)\n\n        self.highlighted = 0\n\n    def also_next(self) -> Animation:\n        \"\"\"Highlights also the next item in the list.\"\"\"\n        self.highlighted += 1\n\n        if self.highlighted > self.arranged_list.ngroups:\n            raise StopIteration(\"No more elements to highlight.\")\n\n        return self.rows.highlight(indices=list(range(self.highlighted)))\n\n    def only_next(self) -> Animation:\n        \"\"\"Highlights only the next item in the list.\"\"\"\n        if self.highlighted > self.arranged_list.ngroups:\n            raise StopIteration(\"No more elements to highlight.\")\n        anims = self.rows.highlight(indices=self.highlighted)\n        self.highlighted += 1\n        return anims\n\n    def clear(self) -> Animation:\n        \"\"\"Clears the list hightlighting.\"\"\"\n        anims = self.rows.highlight(indices=[])\n        self.highlighted = 0\n        return anims\n\n    def all(self) -> Animation:\n        \"\"\"Highlights all the list.\"\"\"\n        return self.rows.highlight(indices=list(range(len(self.rows))))", "class BulletList(VGroup):\n    def __init__(\n        self,\n        *rows: T.Union[Tex, Text],\n        line_spacing: float = MED_LARGE_BUFF * 1.5,\n        indent_buff: float = MED_LARGE_BUFF * 1.5,\n        left_buff: float = MED_LARGE_BUFF * 2,\n        global_shift: float = 0.0,\n        inactive_opacity: float = 0.5,\n        active_opacity: float = 1.0,\n        scale_active: float = 1.0,\n    ):\n        \"\"\"A class to represent an highlatable list of items.\n\n        Args:\n            rows: A list of items to be displayed.\n            line_spacing: The spacing between the rows.\n            indent_buff: The spacing between the bullet and the text.\n            left_buff: The spacing between the left edge of the rows and the left edge of the screen.\n            global_shift: The global_shift to apply to the rows.\n            inactive_opacity: The opacity of the inactive items.\n            active_opacity: The opacity of the active items.\n            scale_active: The scale of the active items.\n        \"\"\"\n        self.arranged_list = ArrangedBullets(\n            *rows,\n            line_spacing=line_spacing,\n            indent_buff=indent_buff,\n            left_buff=left_buff,\n            global_shift=global_shift,\n        ).set_opacity(inactive_opacity)\n\n        self.rows = VGroupHighlight(\n            *self.arranged_list,\n            active_opacity=active_opacity,\n            scale_active=scale_active,\n            scale_about_edge=LEFT,\n        )\n        super().__init__(self.rows)\n\n        self.highlighted = 0\n\n    def also_next(self) -> Animation:\n        \"\"\"Highlights also the next item in the list.\"\"\"\n        self.highlighted += 1\n\n        if self.highlighted > self.arranged_list.ngroups:\n            raise StopIteration(\"No more elements to highlight.\")\n\n        return self.rows.highlight(indices=list(range(self.highlighted)))\n\n    def only_next(self) -> Animation:\n        \"\"\"Highlights only the next item in the list.\"\"\"\n        if self.highlighted > self.arranged_list.ngroups:\n            raise StopIteration(\"No more elements to highlight.\")\n        anims = self.rows.highlight(indices=self.highlighted)\n        self.highlighted += 1\n        return anims\n\n    def clear(self) -> Animation:\n        \"\"\"Clears the list hightlighting.\"\"\"\n        anims = self.rows.highlight(indices=[])\n        self.highlighted = 0\n        return anims\n\n    def all(self) -> Animation:\n        \"\"\"Highlights all the list.\"\"\"\n        return self.rows.highlight(indices=list(range(len(self.rows))))", ""]}
{"filename": "src/powermanim/templates/sectiontitle.py", "chunked_list": ["from manim import *\nfrom manim.utils.color import Color\n\n\nclass SectionTitle(VGroup):\n    def __init__(\n        self,\n        section_title: str,\n        in_run_time: float = 0.75,\n        out_run_time: float = 0.25,\n        out_shift: float = UP,\n        border_color: Color = BLUE,\n        border_buff: float = MED_LARGE_BUFF,\n        border_lag_ratio: float = 0.5,\n    ):\n        \"\"\"Section title transition.\n\n        Args:\n            section_title (str): Title of the section\n            in_run_time (float, optional): Run time of the animation. Defaults to 0.75.\n            out_run_time (float, optional): Run time of the animation. Defaults to 0.25.\n            out_shift (float, optional): Shift of the animation. Defaults to UP.\n            border_color (Color, optional): Color of the border. Defaults to BLUE.\n            border_buff (float, optional): Buffer of the border. Defaults to MED_LARGE_BUFF.\n            border_lag_ratio (float, optional): Lag ratio of the border. Defaults to 0.5.\n        \"\"\"\n        self.slide_title = Tex(section_title, font_size=72)\n        self.border_color = border_color\n        self.border_buff = border_buff\n        self.border_lag_ratio = border_lag_ratio\n        self.in_run_time = in_run_time\n        self.out_run_time = out_run_time\n        self.out_shift = out_shift\n\n        super().__init__(self.slide_title)\n\n    def show(self, scene: Scene) -> None:\n        \"\"\"Show the section title.\n\n        Args:\n            scene (Scene): the scene.\n        \"\"\"\n        scene.play(\n            AnimationGroup(\n                DrawBorderThenFill(self.slide_title, run_time=self.in_run_time),\n                Circumscribe(\n                    self.slide_title,\n                    color=self.border_color,\n                    buff=self.border_buff,\n                ),\n                lag_ratio=self.border_lag_ratio,\n            )\n        )\n\n    def hide(self, scene: Scene) -> None:\n        \"\"\"Hide the section title.\n\n        Args:\n            scene (Scene): the scene.\n        \"\"\"\n        scene.play(\n            FadeOut(self.slide_title, shift=self.out_shift),\n            run_time=self.out_run_time,\n        )", ""]}
{"filename": "src/powermanim/showcase/showcasescene.py", "chunked_list": ["import abc\nfrom typing import Any, Sequence, Type\n\nfrom manim import *\n\nWOWCHEMY_FOLDER = \"docs/static/uploads/media\"\nQUALITY = \"medium_quality\"\nQUALITY2RES = {\n    \"high_quality\": \"1080p60\",\n    \"medium_quality\": \"720p30\",", "    \"high_quality\": \"1080p60\",\n    \"medium_quality\": \"720p30\",\n    \"low_quality\": \"480p15\",\n}\n\n\nclass ShowcaseMeta(abc.ABCMeta):\n    showcase_scenes: Sequence[Type[Scene]] = []\n\n    def __new__(cls, clsname, bases, attrs):\n        newclass = super().__new__(cls, clsname, bases, attrs)\n        if clsname != \"ShowcaseScene\":\n            cls.showcase_scenes.append(newclass)\n        return newclass", "\n\nclass ShowcaseScene(Scene, metaclass=ShowcaseMeta):\n    @staticmethod\n    @abc.abstractmethod\n    def showcasing(self) -> Type[Any]:\n        pass\n"]}
{"filename": "src/powermanim/showcase/__init__.py", "chunked_list": ["import importlib\nimport sys\nfrom pathlib import Path\n\n# Import all showcased scenes, in order for them to be registered in ShowcaseMeta\n\nall_python_files = [\n    f for f in Path(__file__).parent.rglob(\"*.py\") if f.is_file() and not f.name.endswith(\"__init__.py\")\n]\nfor m in all_python_files:\n    # TODO: fix this hack to get the module name\n    module_name = \".\".join(str(m.with_suffix(\"\").relative_to(Path(__file__).parent.parent)).split(\"/\"))\n\n    spec = importlib.util.spec_from_file_location(module_name, m)\n    foo = importlib.util.module_from_spec(spec)\n    sys.modules[\"module.name\"] = foo\n    spec.loader.exec_module(foo)", "]\nfor m in all_python_files:\n    # TODO: fix this hack to get the module name\n    module_name = \".\".join(str(m.with_suffix(\"\").relative_to(Path(__file__).parent.parent)).split(\"/\"))\n\n    spec = importlib.util.spec_from_file_location(module_name, m)\n    foo = importlib.util.module_from_spec(spec)\n    sys.modules[\"module.name\"] = foo\n    spec.loader.exec_module(foo)\n", ""]}
{"filename": "src/powermanim/showcase/components/chartbars.py", "chunked_list": ["from manim import *\nfrom scipy.special import softmax\n\nfrom powermanim.components.chartbars import ChartBars\nfrom powermanim.showcase.showcasescene import ShowcaseScene\n\n\nclass ChartBarsShowcase(ShowcaseScene):\n    def showcasing():\n        return ChartBars\n\n    def construct(self):\n        axes = Axes(x_range=[0, 6], y_range=[0, 1.5], x_length=7, y_length=4)\n        size = 5\n        changes = 3\n\n        dist1 = softmax(np.random.randn(size))\n\n        bars = ChartBars(axes, dist1, xs=list(range(size)), fill_color=RED, stroke_width=0.1)\n        self.add(axes, bars)\n        for i in range(changes):\n            dist2 = softmax(np.random.randn(size))\n            self.play(bars.animate.set_values(dist2), run_time=2)\n        self.play(bars.animate.set_values(dist1), run_time=2)", ""]}
{"filename": "src/powermanim/showcase/components/numberslider.py", "chunked_list": ["from manim import *\n\nfrom powermanim.components.numberslider import NumberSlider\nfrom powermanim.showcase.showcasescene import ShowcaseScene\n\n\nclass NumberSliderShowcase(ShowcaseScene):\n    def showcasing():\n        return NumberSlider\n\n    def construct(self):\n        slider = NumberSlider()\n        self.add(slider)\n        self.play(slider.tracker.animate.set_value(2), run_time=1)\n        self.play(slider.tracker.animate.set_value(-1), run_time=1)\n        self.play(slider.animate.shift(LEFT))\n        self.play(slider.tracker.animate.set_value(0.5), run_time=1)\n        self.play(slider.tracker.animate.set_value(-1.5), run_time=1)\n        self.play(slider.tracker.animate.set_value(0), run_time=1)", ""]}
{"filename": "src/powermanim/showcase/components/__init__.py", "chunked_list": [""]}
{"filename": "src/powermanim/showcase/components/vgroupghighlight.py", "chunked_list": ["from manim import *\n\nfrom powermanim.components.vgrouphighlight import VGroupHighlight\nfrom powermanim.showcase.showcasescene import ShowcaseScene\n\n\nclass VGroupHighlightShowcase(ShowcaseScene):\n    def showcasing():\n        return VGroupHighlight\n\n    def construct(self):\n        dots = [\n            Dot(radius=0.25, color=color, fill_opacity=0.25).shift(i * RIGHT)\n            for i, color in zip(\n                range(-2, 3),\n                [\n                    RED,\n                    GREEN,\n                    BLUE,\n                    YELLOW,\n                    PINK,\n                ],\n            )\n        ]\n\n        group = VGroupHighlight(*dots, anim_run_time=1, anim_lag_ratio=0.1)\n        self.add(group)\n        self.play(group.highlight(0))\n        self.play(group.highlight(1))\n        self.play(group.highlight([2, 3]))\n        self.play(group.highlight([1, 3]))\n        self.play(group.highlight([]))\n        self.play(group.highlight([2, 4]))\n        self.play(group.highlight([]))\n        self.wait(0.5)", ""]}
{"filename": "src/powermanim/showcase/layouts/arrangedbullets.py", "chunked_list": ["from manim import *\n\nfrom powermanim.layouts.arrangedbullets import ArrangedBullets, Bullet\nfrom powermanim.showcase.showcasescene import ShowcaseScene\n\n\nclass ArrangedBulletsShowcase(ShowcaseScene):\n    def showcasing():\n        return ArrangedBullets\n\n    def construct(self):\n        rows = [\n            Bullet(\"First row\"),\n            Bullet(\"Second row\"),\n            Bullet(\"Elements:\"),\n            Bullet(\"First element\", level=1, symbol=\"(1)\"),\n            Bullet(\"Second element\", level=1, symbol=\"(2)\"),\n            Bullet(\"Third element\", level=1, symbol=\"(3)\"),\n        ]\n        g_rows = VGroup(*rows).set_opacity(0.25).scale(0.9)\n        g_rows.target = ArrangedBullets(\n            *g_rows.copy(),\n            line_spacing=MED_LARGE_BUFF * 1.25,\n            left_buff=MED_LARGE_BUFF * 3,\n        ).set_opacity(1)\n\n        self.play(\n            MoveToTarget(g_rows),\n            rate_func=there_and_back_with_pause,\n            run_time=3,\n        )\n\n        self.wait()", ""]}
{"filename": "src/powermanim/showcase/layouts/__init__.py", "chunked_list": [""]}
{"filename": "src/powermanim/showcase/templates/__init__.py", "chunked_list": [""]}
{"filename": "src/powermanim/showcase/templates/bulletlist.py", "chunked_list": ["from manim import *\n\nfrom powermanim.layouts.arrangedbullets import Bullet\nfrom powermanim.showcase.showcasescene import ShowcaseScene\nfrom powermanim.templates.bulletlist import BulletList\n\n\nclass BulletListShowcase(ShowcaseScene):\n    def showcasing():\n        return BulletList\n\n    def construct(self):\n        rows = [\n            Bullet(\"First row\", group=0),\n            Bullet(\"Second row\", group=1),\n            Bullet(\"Elements:\", group=2),\n            Bullet(\"First element\", level=1, symbol=\"(1)\", group=3),\n            Bullet(\"Second element\", level=1, symbol=\"(2)\", group=4),\n            Bullet(\"Third element\", level=1, symbol=\"(3)\", group=5),\n        ]\n        VGroup(*rows).set_opacity(0.5).scale(0.8)\n\n        bullets = BulletList(\n            *rows,\n            scale_active=1.2,\n        )\n        self.add(bullets)\n\n        self.play(bullets.also_next())\n        self.play(bullets.also_next())\n        self.play(bullets.also_next())\n        self.play(bullets.also_next())\n        self.play(bullets.also_next())\n        self.play(bullets.also_next())\n        self.play(bullets.clear())\n        self.play(bullets.only_next())\n        self.play(bullets.only_next())\n        self.play(bullets.only_next())\n        self.play(bullets.only_next())\n        self.play(bullets.only_next())\n        self.play(bullets.only_next())\n        self.play(bullets.clear())\n        self.wait()", ""]}
{"filename": "src/powermanim/showcase/templates/sectiontitle.py", "chunked_list": ["from powermanim.showcase.showcasescene import ShowcaseScene\nfrom powermanim.templates.sectiontitle import SectionTitle\n\n\nclass SectionTitleShowcase(ShowcaseScene):\n    def showcasing():\n        return SectionTitle\n\n    def construct(self):\n        title = SectionTitle(\"Section Title\")\n        title.show(self)\n        self.wait(1)\n        title.hide(self)\n        self.wait(1)", ""]}
