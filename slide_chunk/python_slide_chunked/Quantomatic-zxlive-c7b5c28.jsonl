{"filename": "zxlive/graphview.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n#     Copyright (C) 2023 - Aleks Kissinger\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software", "\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import annotations\n\nfrom typing import Optional\n", "from typing import Optional\n\nimport math\nimport random\nfrom PySide6.QtCore import QRect, QSize, QPointF, Signal, Qt, QRectF, QLineF, QTimeLine\nfrom PySide6.QtWidgets import QGraphicsView, QGraphicsPathItem, QRubberBand, QGraphicsEllipseItem, QGraphicsItem\nfrom PySide6.QtGui import QPen, QColor, QPainter, QPainterPath, QTransform, QMouseEvent, QWheelEvent, QBrush, QShortcut, QKeySequence\n\nfrom .graphscene import GraphScene, VItem, EItem\n", "from .graphscene import GraphScene, VItem, EItem\n\nfrom dataclasses import dataclass\n\nfrom .common import  GraphT, SCALE, OFFSET_X, OFFSET_Y, MIN_ZOOM, MAX_ZOOM\nfrom .vitem import PHASE_ITEM_Z\nfrom . import animations as anims\n\n\nclass GraphTool:\n    Selection = 1\n    MagicWand = 2", "\nclass GraphTool:\n    Selection = 1\n    MagicWand = 2\n\n\n@dataclass\nclass WandTrace:\n    start: QPointF\n    end: QPointF\n    hit: dict[VItem | EItem, list[QPointF]]\n\n    def __init__(self, start: QPointF) -> None:\n        self.start = start\n        self.hit = {}\n        self.end = start", "\n\nWAND_COLOR = \"#500050\"\nWAND_WIDTH = 3.0\n\nZOOMFACTOR = 0.002 # Specifies how sensitive zooming with the mousewheel is\n\nGRID_SCALE = SCALE / 2\n\n\nclass GraphView(QGraphicsView):\n    \"\"\"QtWidget containing a graph\n\n    This widget is view associated with a graph. However, most of the\n    interesting stuff happens in `GraphScene`.\n    \"\"\"\n\n    wand_trace_finished = Signal(object)\n\n    def __init__(self, graph_scene: GraphScene) -> None:\n        self.graph_scene = graph_scene\n        self.tool = GraphTool.Selection\n        \n        super().__init__(self.graph_scene)\n        self.setMouseTracking(True)\n        self.setRenderHint(QPainter.RenderHint.Antialiasing)\n        # self.setResizeAnchor(QGraphicsView.ViewportAnchor.AnchorViewCenter)\n        self.setResizeAnchor(QGraphicsView.ViewportAnchor.AnchorUnderMouse)\n        #self.setDragMode(QGraphicsView.DragMode.ScrollHandDrag) # This has to be enabled based on keyboard shortcuts\n\n        # We implement the rubberband logic ourselves. Note that there is also\n        # the option to set `self.setDragMode(QGraphicsView.RubberBandDrag)`,\n        # but that doesn't seem to play nicely with selection in the GraphScene,\n        # presumably because it uses the coordinate system from this QGraphicsView\n        # and not the one from the GraphScene...\n        self.rubberband = QRubberBand(QRubberBand.Shape.Rectangle, self)\n\n        self.wand_trace: Optional[WandTrace] = None\n        self.wand_path: Optional[QGraphicsPathItem] = None\n\n        self.centerOn(OFFSET_X,OFFSET_Y)\n\n        self.sparkle_mode = False\n        QShortcut(QKeySequence(\"Ctrl+Shift+Alt+S\"), self).activated.connect(self._toggle_sparkles)\n\n    def _toggle_sparkles(self) -> None:\n        self.sparkle_mode = not self.sparkle_mode\n\n    def set_graph(self, g: GraphT) -> None:\n        self.graph_scene.set_graph(g)\n\n    def update_graph(self, g: GraphT, select_new: bool = False) -> None:\n        self.graph_scene.update_graph(g, select_new)\n\n    def mousePressEvent(self, e: QMouseEvent) -> None:\n        if self.tool == GraphTool.Selection and Qt.KeyboardModifier.ShiftModifier & e.modifiers():\n            e.setModifiers(e.modifiers() | Qt.KeyboardModifier.ControlModifier)\n        super().mousePressEvent(e)\n\n        if e.button() == Qt.MouseButton.LeftButton and not self.graph_scene.items(self.mapToScene(e.pos()), deviceTransform=QTransform()):\n            if self.tool == GraphTool.Selection:\n                self._rubberband_start = e.pos()\n                self.rubberband.setGeometry(QRect(self._rubberband_start, QSize()))\n                self.rubberband.show()\n            elif self.tool == GraphTool.MagicWand:\n                pos = self.mapToScene(e.pos())\n                self.wand_trace = WandTrace(pos)\n                self.wand_path = QGraphicsPathItem()\n                self.graph_scene.addItem(self.wand_path)\n                pen = QPen(QColor(WAND_COLOR), WAND_WIDTH)\n                self.wand_path.setPen(pen)\n                path = QPainterPath()\n                path.moveTo(pos)\n                self.wand_path.setPath(path)\n                self.wand_path.show()\n                if self.sparkle_mode:\n                    self._emit_sparkles(pos, 10)\n        else:\n            e.ignore()\n\n    def mouseMoveEvent(self, e: QMouseEvent) -> None:\n        super().mouseMoveEvent(e)\n        if self.tool == GraphTool.Selection:\n            if self.rubberband.isVisible():\n                self.rubberband.setGeometry(QRect(self._rubberband_start, e.pos()).normalized())\n        elif self.tool == GraphTool.MagicWand:\n            if self.wand_trace is not None:\n                assert self.wand_path is not None\n                pos = self.mapToScene(e.pos())\n                prev = self.wand_trace.end\n                self.wand_trace.end = pos\n                path = self.wand_path.path()\n                path.lineTo(pos)\n                self.wand_path.setPath(path)\n                for i in range(10):\n                    t = i / 9\n                    ipos = QPointF(pos * t + prev * (1.0 - t))\n                    if self.sparkle_mode:\n                        self._emit_sparkles(ipos, 1)\n                    items = self.graph_scene.items(ipos)\n                    for item in items:\n                        if isinstance(item, VItem) and item not in self.wand_trace.hit:\n                            anims.anticipate_fuse(item)\n                        if item is not self.wand_path and isinstance(item, (VItem, EItem)):\n                            if item not in self.wand_trace.hit:\n                                self.wand_trace.hit[item] = []\n                            self.wand_trace.hit[item].append(ipos)\n\n        else:\n            e.ignore()\n\n    def mouseReleaseEvent(self, e: QMouseEvent) -> None:\n        if self.tool == GraphTool.Selection and Qt.KeyboardModifier.ShiftModifier & e.modifiers():\n            e.setModifiers(e.modifiers() | Qt.KeyboardModifier.ControlModifier)\n        super().mouseReleaseEvent(e)\n        if e.button() == Qt.MouseButton.LeftButton:\n            if self.tool == GraphTool.Selection:\n                if self.rubberband.isVisible():\n                    self.rubberband.hide()\n                    key_modifiers = e.modifiers()\n                    if not(Qt.KeyboardModifier.ShiftModifier & key_modifiers or Qt.KeyboardModifier.ControlModifier & key_modifiers):\n                        self.graph_scene.clearSelection()\n                    rect = self.rubberband.geometry()\n                    items = [it for it in self.graph_scene.items(self.mapToScene(rect).boundingRect()) if isinstance(it, VItem)]\n                    for it in items:\n                        it.setSelected(not (len(items) == 1 or e.modifiers() & Qt.KeyboardModifier.ShiftModifier) or not it.isSelected())\n            elif self.tool == GraphTool.MagicWand:\n                if self.wand_trace is not None:\n                    assert self.wand_path is not None\n                    for item in self.wand_trace.hit:\n                        if isinstance(item, VItem):\n                            anims.back_to_default(item)\n                    self.wand_path.hide()\n                    self.graph_scene.removeItem(self.wand_path)\n                    self.wand_path = None\n                    self.wand_trace_finished.emit(self.wand_trace)\n                    self.wand_trace = None\n        else:\n            e.ignore()\n\n    def wheelEvent(self, event: QWheelEvent) -> None:\n        # This event captures mousewheel scrolls\n        # We do this to allow for zooming\n        \n        # If control is pressed, we want to zoom\n        if event.modifiers() == Qt.KeyboardModifier.ControlModifier:\n            ydelta = event.angleDelta().y()\n            self.zoom(ydelta)\n        else:\n            super().wheelEvent(event)\n        \n        \n    def zoom(self, ydelta: float) -> None:\n        # Set Anchors\n        self.setTransformationAnchor(QGraphicsView.ViewportAnchor.NoAnchor)\n        self.setResizeAnchor(QGraphicsView.ViewportAnchor.NoAnchor)\n\n        # Save the scene pos\n        old_pos = self.mapToScene(self.viewport().rect().center())\n\n        zoom_factor = 1.0\n        if ydelta > 0:\n            zoom_factor = 1 + ZOOMFACTOR * ydelta\n        elif ydelta < 0:\n            zoom_factor = 1/(1 - ZOOMFACTOR * ydelta)\n\n        current_zoom = self.transform().m11()\n        if current_zoom * zoom_factor < MIN_ZOOM:\n            return\n        elif current_zoom * zoom_factor > MAX_ZOOM:\n            return\n        self.scale(zoom_factor, zoom_factor)\n\n        # Get the new position\n        new_pos = self.mapToScene(self.viewport().rect().center())\n\n        # Move scene to old position\n        delta = new_pos - old_pos\n        self.translate(delta.x(), delta.y())\n\n    def zoom_out(self) -> None:\n        self.zoom(-100)\n\n    def zoom_in(self) -> None:\n        self.zoom(100)\n\n    def fit_view(self) -> None:\n        self.fitInView(self.graph_scene.itemsBoundingRect(), Qt.AspectRatioMode.KeepAspectRatio)\n        current_zoom = self.transform().m11()\n        print(current_zoom)\n        if current_zoom < MIN_ZOOM:\n            self.scale(MIN_ZOOM / current_zoom, MIN_ZOOM / current_zoom)\n        else:\n            if current_zoom > MAX_ZOOM:\n                self.scale(MAX_ZOOM / current_zoom, MAX_ZOOM / current_zoom)\n\n    def drawBackground(self, painter: QPainter, rect: QRectF | QRect) -> None:\n        # First draw blank white background\n        painter.setBrush(QColor(255, 255, 255, 255))\n        painter.setPen(QPen(Qt.PenStyle.NoPen))\n        painter.drawRect(rect)\n\n        # Calculate grid lines\n        lines, thick_lines = [], []\n        for x in range(int(rect.left() / GRID_SCALE), math.ceil(rect.right() / GRID_SCALE) + 1):\n            line = QLineF(x * GRID_SCALE, rect.top(), x * GRID_SCALE, rect.bottom())\n            if x % 4 == 0:\n                thick_lines.append(line)\n            else:\n                lines.append(line)\n        for y in range(int(rect.top() / GRID_SCALE), math.ceil(rect.bottom() / GRID_SCALE) + 1):\n            line = QLineF(rect.left(), y * GRID_SCALE, rect.right(), y * GRID_SCALE)\n            if y % 4 == 0:\n                thick_lines.append(line)\n            else:\n                lines.append(line)\n\n        # Draw grid lines\n        painter.setPen(QPen(QColor(240, 240, 240), 1, Qt.PenStyle.SolidLine))\n        painter.drawLines(lines)\n        painter.setPen(QPen(QColor(240, 240, 240), 2, Qt.PenStyle.SolidLine))\n        painter.drawLines(thick_lines)\n    \n    def _emit_sparkles(self, pos: QPointF, mult: int) -> None:\n        for _ in range(mult * SPARKLE_COUNT):\n            angle = random.random() * 2 * math.pi\n            speed = random.random() * (SPARKLE_MAX_SPEED - SPARKLE_MIN_SPEED) + SPARKLE_MIN_SPEED\n            x = speed * math.cos(angle)\n            y = speed * math.sin(angle)\n            Sparkle(pos.x(), pos.y(), x, y, SPARKLE_FADE, self.graph_scene)", "\n\nclass GraphView(QGraphicsView):\n    \"\"\"QtWidget containing a graph\n\n    This widget is view associated with a graph. However, most of the\n    interesting stuff happens in `GraphScene`.\n    \"\"\"\n\n    wand_trace_finished = Signal(object)\n\n    def __init__(self, graph_scene: GraphScene) -> None:\n        self.graph_scene = graph_scene\n        self.tool = GraphTool.Selection\n        \n        super().__init__(self.graph_scene)\n        self.setMouseTracking(True)\n        self.setRenderHint(QPainter.RenderHint.Antialiasing)\n        # self.setResizeAnchor(QGraphicsView.ViewportAnchor.AnchorViewCenter)\n        self.setResizeAnchor(QGraphicsView.ViewportAnchor.AnchorUnderMouse)\n        #self.setDragMode(QGraphicsView.DragMode.ScrollHandDrag) # This has to be enabled based on keyboard shortcuts\n\n        # We implement the rubberband logic ourselves. Note that there is also\n        # the option to set `self.setDragMode(QGraphicsView.RubberBandDrag)`,\n        # but that doesn't seem to play nicely with selection in the GraphScene,\n        # presumably because it uses the coordinate system from this QGraphicsView\n        # and not the one from the GraphScene...\n        self.rubberband = QRubberBand(QRubberBand.Shape.Rectangle, self)\n\n        self.wand_trace: Optional[WandTrace] = None\n        self.wand_path: Optional[QGraphicsPathItem] = None\n\n        self.centerOn(OFFSET_X,OFFSET_Y)\n\n        self.sparkle_mode = False\n        QShortcut(QKeySequence(\"Ctrl+Shift+Alt+S\"), self).activated.connect(self._toggle_sparkles)\n\n    def _toggle_sparkles(self) -> None:\n        self.sparkle_mode = not self.sparkle_mode\n\n    def set_graph(self, g: GraphT) -> None:\n        self.graph_scene.set_graph(g)\n\n    def update_graph(self, g: GraphT, select_new: bool = False) -> None:\n        self.graph_scene.update_graph(g, select_new)\n\n    def mousePressEvent(self, e: QMouseEvent) -> None:\n        if self.tool == GraphTool.Selection and Qt.KeyboardModifier.ShiftModifier & e.modifiers():\n            e.setModifiers(e.modifiers() | Qt.KeyboardModifier.ControlModifier)\n        super().mousePressEvent(e)\n\n        if e.button() == Qt.MouseButton.LeftButton and not self.graph_scene.items(self.mapToScene(e.pos()), deviceTransform=QTransform()):\n            if self.tool == GraphTool.Selection:\n                self._rubberband_start = e.pos()\n                self.rubberband.setGeometry(QRect(self._rubberband_start, QSize()))\n                self.rubberband.show()\n            elif self.tool == GraphTool.MagicWand:\n                pos = self.mapToScene(e.pos())\n                self.wand_trace = WandTrace(pos)\n                self.wand_path = QGraphicsPathItem()\n                self.graph_scene.addItem(self.wand_path)\n                pen = QPen(QColor(WAND_COLOR), WAND_WIDTH)\n                self.wand_path.setPen(pen)\n                path = QPainterPath()\n                path.moveTo(pos)\n                self.wand_path.setPath(path)\n                self.wand_path.show()\n                if self.sparkle_mode:\n                    self._emit_sparkles(pos, 10)\n        else:\n            e.ignore()\n\n    def mouseMoveEvent(self, e: QMouseEvent) -> None:\n        super().mouseMoveEvent(e)\n        if self.tool == GraphTool.Selection:\n            if self.rubberband.isVisible():\n                self.rubberband.setGeometry(QRect(self._rubberband_start, e.pos()).normalized())\n        elif self.tool == GraphTool.MagicWand:\n            if self.wand_trace is not None:\n                assert self.wand_path is not None\n                pos = self.mapToScene(e.pos())\n                prev = self.wand_trace.end\n                self.wand_trace.end = pos\n                path = self.wand_path.path()\n                path.lineTo(pos)\n                self.wand_path.setPath(path)\n                for i in range(10):\n                    t = i / 9\n                    ipos = QPointF(pos * t + prev * (1.0 - t))\n                    if self.sparkle_mode:\n                        self._emit_sparkles(ipos, 1)\n                    items = self.graph_scene.items(ipos)\n                    for item in items:\n                        if isinstance(item, VItem) and item not in self.wand_trace.hit:\n                            anims.anticipate_fuse(item)\n                        if item is not self.wand_path and isinstance(item, (VItem, EItem)):\n                            if item not in self.wand_trace.hit:\n                                self.wand_trace.hit[item] = []\n                            self.wand_trace.hit[item].append(ipos)\n\n        else:\n            e.ignore()\n\n    def mouseReleaseEvent(self, e: QMouseEvent) -> None:\n        if self.tool == GraphTool.Selection and Qt.KeyboardModifier.ShiftModifier & e.modifiers():\n            e.setModifiers(e.modifiers() | Qt.KeyboardModifier.ControlModifier)\n        super().mouseReleaseEvent(e)\n        if e.button() == Qt.MouseButton.LeftButton:\n            if self.tool == GraphTool.Selection:\n                if self.rubberband.isVisible():\n                    self.rubberband.hide()\n                    key_modifiers = e.modifiers()\n                    if not(Qt.KeyboardModifier.ShiftModifier & key_modifiers or Qt.KeyboardModifier.ControlModifier & key_modifiers):\n                        self.graph_scene.clearSelection()\n                    rect = self.rubberband.geometry()\n                    items = [it for it in self.graph_scene.items(self.mapToScene(rect).boundingRect()) if isinstance(it, VItem)]\n                    for it in items:\n                        it.setSelected(not (len(items) == 1 or e.modifiers() & Qt.KeyboardModifier.ShiftModifier) or not it.isSelected())\n            elif self.tool == GraphTool.MagicWand:\n                if self.wand_trace is not None:\n                    assert self.wand_path is not None\n                    for item in self.wand_trace.hit:\n                        if isinstance(item, VItem):\n                            anims.back_to_default(item)\n                    self.wand_path.hide()\n                    self.graph_scene.removeItem(self.wand_path)\n                    self.wand_path = None\n                    self.wand_trace_finished.emit(self.wand_trace)\n                    self.wand_trace = None\n        else:\n            e.ignore()\n\n    def wheelEvent(self, event: QWheelEvent) -> None:\n        # This event captures mousewheel scrolls\n        # We do this to allow for zooming\n        \n        # If control is pressed, we want to zoom\n        if event.modifiers() == Qt.KeyboardModifier.ControlModifier:\n            ydelta = event.angleDelta().y()\n            self.zoom(ydelta)\n        else:\n            super().wheelEvent(event)\n        \n        \n    def zoom(self, ydelta: float) -> None:\n        # Set Anchors\n        self.setTransformationAnchor(QGraphicsView.ViewportAnchor.NoAnchor)\n        self.setResizeAnchor(QGraphicsView.ViewportAnchor.NoAnchor)\n\n        # Save the scene pos\n        old_pos = self.mapToScene(self.viewport().rect().center())\n\n        zoom_factor = 1.0\n        if ydelta > 0:\n            zoom_factor = 1 + ZOOMFACTOR * ydelta\n        elif ydelta < 0:\n            zoom_factor = 1/(1 - ZOOMFACTOR * ydelta)\n\n        current_zoom = self.transform().m11()\n        if current_zoom * zoom_factor < MIN_ZOOM:\n            return\n        elif current_zoom * zoom_factor > MAX_ZOOM:\n            return\n        self.scale(zoom_factor, zoom_factor)\n\n        # Get the new position\n        new_pos = self.mapToScene(self.viewport().rect().center())\n\n        # Move scene to old position\n        delta = new_pos - old_pos\n        self.translate(delta.x(), delta.y())\n\n    def zoom_out(self) -> None:\n        self.zoom(-100)\n\n    def zoom_in(self) -> None:\n        self.zoom(100)\n\n    def fit_view(self) -> None:\n        self.fitInView(self.graph_scene.itemsBoundingRect(), Qt.AspectRatioMode.KeepAspectRatio)\n        current_zoom = self.transform().m11()\n        print(current_zoom)\n        if current_zoom < MIN_ZOOM:\n            self.scale(MIN_ZOOM / current_zoom, MIN_ZOOM / current_zoom)\n        else:\n            if current_zoom > MAX_ZOOM:\n                self.scale(MAX_ZOOM / current_zoom, MAX_ZOOM / current_zoom)\n\n    def drawBackground(self, painter: QPainter, rect: QRectF | QRect) -> None:\n        # First draw blank white background\n        painter.setBrush(QColor(255, 255, 255, 255))\n        painter.setPen(QPen(Qt.PenStyle.NoPen))\n        painter.drawRect(rect)\n\n        # Calculate grid lines\n        lines, thick_lines = [], []\n        for x in range(int(rect.left() / GRID_SCALE), math.ceil(rect.right() / GRID_SCALE) + 1):\n            line = QLineF(x * GRID_SCALE, rect.top(), x * GRID_SCALE, rect.bottom())\n            if x % 4 == 0:\n                thick_lines.append(line)\n            else:\n                lines.append(line)\n        for y in range(int(rect.top() / GRID_SCALE), math.ceil(rect.bottom() / GRID_SCALE) + 1):\n            line = QLineF(rect.left(), y * GRID_SCALE, rect.right(), y * GRID_SCALE)\n            if y % 4 == 0:\n                thick_lines.append(line)\n            else:\n                lines.append(line)\n\n        # Draw grid lines\n        painter.setPen(QPen(QColor(240, 240, 240), 1, Qt.PenStyle.SolidLine))\n        painter.drawLines(lines)\n        painter.setPen(QPen(QColor(240, 240, 240), 2, Qt.PenStyle.SolidLine))\n        painter.drawLines(thick_lines)\n    \n    def _emit_sparkles(self, pos: QPointF, mult: int) -> None:\n        for _ in range(mult * SPARKLE_COUNT):\n            angle = random.random() * 2 * math.pi\n            speed = random.random() * (SPARKLE_MAX_SPEED - SPARKLE_MIN_SPEED) + SPARKLE_MIN_SPEED\n            x = speed * math.cos(angle)\n            y = speed * math.sin(angle)\n            Sparkle(pos.x(), pos.y(), x, y, SPARKLE_FADE, self.graph_scene)", "\nSPARKLE_COLOR = \"#900090\"\nSPARKLE_COUNT = 1\nSPARKLE_MAX_SPEED = 200.0\nSPARKLE_MIN_SPEED = 100.0\nSPARKLE_FADE = 20.0\n\nclass Sparkle(QGraphicsEllipseItem):\n    def __init__(self, x: float, y: float, vx: float, vy: float, vo: float, scene: GraphScene) -> None:\n        super().__init__(\n            -0.05 * SCALE, -0.05 * SCALE, 0.1 * SCALE, 0.1 * SCALE\n        )\n\n        self.vx, self.vy, self.vo = vx, vy, vo\n        self.prev_value = 0.0\n\n        self.setPos(x, y)\n        self.setZValue(PHASE_ITEM_Z)\n        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, False)\n        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable, False)\n        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges, False)\n        self.setBrush(QBrush(QColor(SPARKLE_COLOR)))\n        self.setPen(QPen(Qt.PenStyle.NoPen))\n        \n        scene.addItem(self)\n\n        self.timer = QTimeLine(1000)\n        self.timer.valueChanged.connect(self._timer_step)\n        self.timer.start()\n        self.show()\n        \n    def _timer_step(self, value: float) -> None:\n        dt = value - self.prev_value\n        self.prev_value = value\n        self.setX(self.x() + dt * self.vx)\n        self.setY(self.y() + dt * self.vy)\n        self.setOpacity(max(self.opacity() - dt * self.vo, 0.0))\n\n        if value == 1.0:\n            self.scene().removeItem(self)", ""]}
{"filename": "zxlive/rules.py", "chunked_list": ["from statistics import fmean\nfrom typing import List\n\nfrom pyzx.utils import EdgeType, VertexType\n\nfrom .common import VT, ET, GraphT\n\n\ndef check_bialgebra(g:GraphT, v_list: List[VT]) -> bool:\n\n    phases = g.phases()\n    x_vertices = []\n    z_vertices = []\n\n    for v in v_list:\n        if phases[v] != 0:\n            return False\n        if g.type(v) == VertexType.X:\n            x_vertices.append(v)\n        elif g.type(v) == VertexType.Z:\n            z_vertices.append(v)\n        else:\n            return False\n\n    if z_vertices == [] or x_vertices == []:\n        return False\n\n    # all x vertices are connected to all z vertices\n    for x in x_vertices:\n        for z in z_vertices:\n            if x not in g.neighbors(z):\n                return False\n            if g.edge_type(g.edge(x, z)) != EdgeType.SIMPLE:\n                return False\n\n    # not connected among themselves\n    for vs in [x_vertices, z_vertices]:\n        for v1 in vs:\n            for v2 in vs:\n                if v1 != v2 and v1 in g.neighbors(v2):\n                    return False\n\n    return True", "def check_bialgebra(g:GraphT, v_list: List[VT]) -> bool:\n\n    phases = g.phases()\n    x_vertices = []\n    z_vertices = []\n\n    for v in v_list:\n        if phases[v] != 0:\n            return False\n        if g.type(v) == VertexType.X:\n            x_vertices.append(v)\n        elif g.type(v) == VertexType.Z:\n            z_vertices.append(v)\n        else:\n            return False\n\n    if z_vertices == [] or x_vertices == []:\n        return False\n\n    # all x vertices are connected to all z vertices\n    for x in x_vertices:\n        for z in z_vertices:\n            if x not in g.neighbors(z):\n                return False\n            if g.edge_type(g.edge(x, z)) != EdgeType.SIMPLE:\n                return False\n\n    # not connected among themselves\n    for vs in [x_vertices, z_vertices]:\n        for v1 in vs:\n            for v2 in vs:\n                if v1 != v2 and v1 in g.neighbors(v2):\n                    return False\n\n    return True", "\n\ndef bialgebra(g:GraphT, v_list:List[VT]) -> None:\n    '''\n    g: BaseGraph[[VT,ET]]\n    v_list: list of vertex where bialgebra needs to be applied\n    returns: The graph with bialgebra rule applied if the vertices\n    provided can be simplified by this rule\n    '''\n    if not check_bialgebra(g, v_list):\n        return\n\n    x_vertices = list(filter(lambda v: g.type(v) == VertexType.X, v_list))\n    z_vertices = list(filter(lambda v: g.type(v) == VertexType.Z, v_list))\n\n    nodes = []\n\n    nt: VertexType.Type\n    for nt, vs in [(VertexType.Z, x_vertices), (VertexType.X, z_vertices)]:  # type: ignore\n        q = fmean([g.qubit(x) for x in vs])\n        r = fmean([g.row(x) for x in vs])\n        node = g.add_vertex(nt, q, r)\n        nodes.append(node)\n\n        for v in vs:\n            for n in g.neighbors(v):\n                g.add_edge(g.edge(node, n), EdgeType.SIMPLE) # type: ignore\n            g.remove_vertex(v)\n\n    g.add_edge(g.edge(nodes[0], nodes[1]), EdgeType.SIMPLE)", ""]}
{"filename": "zxlive/construct.py", "chunked_list": ["from typing import List\n\nfrom pyzx.utils import EdgeType, VertexType\n\nfrom .common import GraphT, Graph\n\n\ndef construct_circuit() -> GraphT:\n    qubits = 4\n\n    vlist = [\n        (0, 0, 1), (1, 1, 2), (2, 2, 1), (3, 3, 1), (4, 0, 1), (5, 1, 1),\n        (6, 2, 2), (7, 3, 1), (8, 0, 1), (9, 1, 2), (10, 2, 1), (11, 3, 1),\n        (12, 0, 2), (13, 1, 2), (14, 2, 1), (15, 3, 2)]\n    elist = [\n        (0, 4, 0), (0, 1, 0), (1, 5, 0), (1, 6, 0), (2, 6, 0), (3, 7, 0),\n        (5, 9, 1), (4, 8, 0), (6, 10, 0), (7, 11, 0), (8, 12, 0), (8, 13, 0),\n        (9, 13, 1), (9, 14, 1), (10, 13, 0), (10, 14, 0), (11, 15, 0),\n        (11, 14, 0)]\n\n    nvertices = len(vlist) + (2 * qubits)\n\n    ty: List[VertexType.Type] = [VertexType.BOUNDARY] * nvertices\n\n    nvlist: list[tuple[int, int, VertexType.Type]] = []\n    # Adding inputs nodes to the nvlist.\n    for i in range(qubits):\n        nvlist.append((i, i, VertexType.BOUNDARY))\n        ty[i] = VertexType.BOUNDARY\n\n    # Adding the actual vertices to the nvlist.\n    for vert in vlist:\n        # print(vert[2])\n        if vert[2] == 1:\n            ty[vert[0]+qubits] = VertexType.Z\n            # print(ty)\n        elif vert[2] == 2:\n            ty[vert[0]+qubits] = VertexType.X\n        nvlist.append((vert[0]+qubits, vert[1], ty[i+qubits-1]))\n\n    # Adding the output nodes to the nvlist.\n    for i in range(qubits):\n        nvlist.append((nvertices - qubits + i, i, VertexType.BOUNDARY))\n        ty[nvertices - qubits + i] = VertexType.BOUNDARY\n\n    nelist = []\n\n    # Updating the user provided elist to include input indices\n    for edge in elist:\n        nelist.append((edge[0]+qubits, edge[1]+qubits, edge[2]))\n\n    # Adding the edges between inputs nodes and output nodes to internal nodes\n    for i in range(qubits):\n        nelist.append((i, i+qubits, 0))\n        nelist.append((nvertices - qubits + i, nvertices - (2*qubits) + i, 0))\n\n    cur_row = [1] * qubits\n\n    g = Graph()\n    assert isinstance(g, GraphT)\n\n    # Adding vertices to the graph\n    for (i, qu, tp) in nvlist:\n        rw = cur_row[qu]\n        g.add_vertex(ty[i], qu, rw)\n        cur_row[qu] += 1\n\n    es1 = [edge[:2] for edge in nelist if not edge[2]]\n    es2 = [edge[:2] for edge in nelist if edge[2]]\n\n    # TODO: add the phase part\n    # for w, phase in phases.items():\n    #     g.set_phase(w,phase)\n\n    g.add_edges(es1, EdgeType.SIMPLE)\n    g.add_edges(es2, EdgeType.HADAMARD)\n\n    inputs = []\n    outputs = []\n\n    for i in range(qubits):\n        inputs.append(i)\n        outputs.append(nvertices-qubits+i)\n\n    g.set_inputs(tuple(inputs))\n    g.set_outputs(tuple(outputs))\n\n    return g", ""]}
{"filename": "zxlive/__main__.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n#     Copyright (C) 2023 - Aleks Kissinger\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software", "\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom zxlive import app\n\nif __name__ == '__main__':\n    app.main()", "\nif __name__ == '__main__':\n    app.main()\n"]}
{"filename": "zxlive/app.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n#     Copyright (C) 2023 - Aleks Kissinger\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software", "\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import annotations\n\nfrom PySide6.QtWidgets import QApplication", "\nfrom PySide6.QtWidgets import QApplication\nimport sys\n\nsys.path.insert(0,'../pyzx') # So that it can find a local copy of pyzx\n\nfrom .mainwindow import MainWindow\n\nclass ZXLive(QApplication):\n    \"\"\"The main ZX Live application\n\n    ...\n    \"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(sys.argv)\n        self.setApplicationName('ZX Live')\n        self.setDesktopFileName('ZX Live')\n        self.main_window = MainWindow()\n\n        self.lastWindowClosed.connect(self.quit)", "class ZXLive(QApplication):\n    \"\"\"The main ZX Live application\n\n    ...\n    \"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(sys.argv)\n        self.setApplicationName('ZX Live')\n        self.setDesktopFileName('ZX Live')\n        self.main_window = MainWindow()\n\n        self.lastWindowClosed.connect(self.quit)", "\n\ndef main() -> None:\n    \"\"\"Main entry point for ZX Live\"\"\"\n\n    zxl = ZXLive()\n    zxl.exec_()\n"]}
{"filename": "zxlive/proof.py", "chunked_list": ["import json\nfrom typing import NamedTuple, Union, Any\n\nfrom PySide6.QtCore import QAbstractListModel, QModelIndex, QPersistentModelIndex, Qt\nfrom PySide6.QtGui import QFont\nfrom pyzx.graph import GraphDiff\n\nfrom zxlive.common import GraphT\n\n\nclass Rewrite(NamedTuple):\n    \"\"\"A rewrite turns a graph into another graph.\"\"\"\n\n    rule: str  # Name of the rule that was applied to get to this step\n    diff: GraphDiff  # Diff from the last step to this step\n\n    def to_json(self) -> str:\n        \"\"\"Serializes the rewrite to JSON.\"\"\"\n        return json.dumps({\n            \"rule\": self.rule,\n            \"diff\": self.diff.to_json()\n        })\n\n    @staticmethod\n    def from_json(json_str: str) -> \"Rewrite\":\n        \"\"\"Deserializes the rewrite from JSON.\"\"\"\n        d = json.loads(json_str)\n        return Rewrite(\n            rule=d[\"rule\"],\n            diff=GraphDiff.from_json(d[\"diff\"])\n        )", "\n\nclass Rewrite(NamedTuple):\n    \"\"\"A rewrite turns a graph into another graph.\"\"\"\n\n    rule: str  # Name of the rule that was applied to get to this step\n    diff: GraphDiff  # Diff from the last step to this step\n\n    def to_json(self) -> str:\n        \"\"\"Serializes the rewrite to JSON.\"\"\"\n        return json.dumps({\n            \"rule\": self.rule,\n            \"diff\": self.diff.to_json()\n        })\n\n    @staticmethod\n    def from_json(json_str: str) -> \"Rewrite\":\n        \"\"\"Deserializes the rewrite from JSON.\"\"\"\n        d = json.loads(json_str)\n        return Rewrite(\n            rule=d[\"rule\"],\n            diff=GraphDiff.from_json(d[\"diff\"])\n        )", "\nclass ProofModel(QAbstractListModel):\n    \"\"\"List model capturing the individual steps in a proof.\n\n    There is a row for each graph in the proof sequence. Furthermore, we store the\n    rewrite that was used to go from one graph to next.\n    \"\"\"\n\n    graphs: list[GraphT]  # n graphs\n    steps: list[Rewrite]  # n-1 rewrite steps\n\n    def __init__(self, start_graph: GraphT):\n        super().__init__()\n        self.graphs = [start_graph]\n        self.steps = []\n\n    def set_data(self, graphs: list[GraphT], steps: list[Rewrite]) -> None:\n        \"\"\"Sets the model data.\n\n        Can be used to load the model from a saved state.\n        \"\"\"\n        assert len(steps) == len(graphs) - 1\n        self.beginResetModel()\n        self.graphs = graphs\n        self.steps = steps\n        self.endResetModel()\n\n    def data(self, index: Union[QModelIndex, QPersistentModelIndex], role: int=Qt.ItemDataRole.DisplayRole) -> Any:\n        \"\"\"Overrides `QAbstractItemModel.data` to populate a view with rewrite steps\"\"\"\n\n        if index.row() >= len(self.graphs) or index.column() >= 1:\n            return None\n\n        if role == Qt.ItemDataRole.DisplayRole:\n            if index.row() == 0:\n                return \"START\"\n            else:\n                return self.steps[index.row()-1].rule\n        elif role == Qt.ItemDataRole.FontRole:\n            return QFont(\"monospace\", 12)\n\n    def headerData(self, section: int, orientation: Qt.Orientation,\n                   role: int = Qt.ItemDataRole.DisplayRole) -> Any:\n        \"\"\"Overrides `QAbstractItemModel.headerData`.\n\n        Indicates that this model doesn't have a header.\n        \"\"\"\n        return None\n\n    def columnCount(self, index: Union[QModelIndex, QPersistentModelIndex] = QModelIndex()) -> int:\n        \"\"\"The number of columns\"\"\"\n        return 1\n\n    def rowCount(self, index: Union[QModelIndex, QPersistentModelIndex] = QModelIndex()) -> int:\n        \"\"\"The number of rows\"\"\"\n        # This is a quirk of Qt list models: Since they are based on tree models, the\n        # user has to specify the index of the parent. In a list, we always expect the\n        # parent to be `None` or the empty `QModelIndex()`\n        if not index or not index.isValid():\n            return len(self.graphs)\n        else:\n            return 0\n\n    def add_rewrite(self, rewrite: Rewrite, new_graph: GraphT) -> None:\n        \"\"\"Adds a rewrite step to the model.\"\"\"\n        self.beginInsertRows(QModelIndex(), len(self.graphs), len(self.graphs))\n        self.graphs.append(new_graph)\n        self.steps.append(rewrite)\n        self.endInsertRows()\n\n    def pop_rewrite(self) -> tuple[Rewrite, GraphT]:\n        \"\"\"Removes the latest rewrite from the model.\n\n        Returns the rewrite and the graph that previously resulted from this rewrite.\n        \"\"\"\n        self.beginRemoveRows(QModelIndex(), len(self.graphs) - 1, len(self.graphs) - 1)\n        rewrite = self.steps.pop()\n        graph = self.graphs.pop()\n        self.endRemoveRows()\n        return rewrite, graph\n\n    def get_graph(self, index: int) -> GraphT:\n        \"\"\"Returns the grap at a given position in the proof.\"\"\"\n        copy = self.graphs[index].copy()\n        assert isinstance(copy, GraphT)\n        return copy\n\n    def to_json(self) -> str:\n        \"\"\"Serializes the model to JSON.\"\"\"\n        initial_graph_tikz = self.graphs[0].to_tikz()\n        proof_steps = []\n        for step in self.steps:\n            proof_steps.append(step.to_json())\n        return json.dumps({\n            \"initial_graph\": initial_graph_tikz,\n            \"proof_steps\": proof_steps\n        })\n    \n    @staticmethod\n    def from_json(json_str: str) -> \"ProofModel\":\n        \"\"\"Deserializes the model from JSON.\"\"\"\n        d = json.loads(json_str)\n        initial_graph = GraphT.from_tikz(d[\"initial_graph\"])\n        assert isinstance(initial_graph, GraphT)\n        model = ProofModel(initial_graph)\n        for step in d[\"proof_steps\"]:\n            rewrite = Rewrite.from_json(step)\n            rewritten_graph = rewrite.diff.apply_diff(model.graphs[-1])\n            assert isinstance(rewritten_graph, GraphT)\n            model.add_rewrite(rewrite, rewritten_graph)\n        return model", ""]}
{"filename": "zxlive/eitem.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n#     Copyright (C) 2023 - Aleks Kissinger\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software", "\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import annotations\nfrom typing import Optional, Any, TYPE_CHECKING\n", "from typing import Optional, Any, TYPE_CHECKING\n\nfrom PySide6.QtCore import QPointF\nfrom PySide6.QtWidgets import QGraphicsEllipseItem, QGraphicsPathItem, QGraphicsItem, \\\n    QGraphicsSceneMouseEvent, QStyleOptionGraphicsItem, QWidget, QStyle\nfrom PySide6.QtGui import QPen, QBrush,  QPainter, QColor, QPainterPath\n\nfrom pyzx import EdgeType\n\nfrom .common import SCALE, VT, ET, GraphT", "\nfrom .common import SCALE, VT, ET, GraphT\nfrom .vitem import VItem, EITEM_Z\n\nif TYPE_CHECKING:\n    from .graphscene import GraphScene\n\nHAD_EDGE_BLUE = \"#0077ff\"\n\nclass EItem(QGraphicsPathItem):\n    \"\"\"A QGraphicsItem representing an edge\"\"\"\n\n    def __init__(self, graph_scene: GraphScene, e: ET, s_item: VItem, t_item: VItem) -> None:\n        super().__init__()\n        self.setZValue(EITEM_Z)\n        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable, True)\n        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges, True)\n\n        self.graph_scene = graph_scene\n        self.e = e\n        self.s_item = s_item\n        self.t_item = t_item\n        s_item.adj_items.add(self)\n        t_item.adj_items.add(self)\n        self.selection_node = QGraphicsEllipseItem(-0.1 * SCALE, -0.1 * SCALE, 0.2 * SCALE, 0.2 * SCALE)\n        pen = QPen()\n        pen.setWidthF(4)\n        pen.setColor(QColor('#0022FF'))\n        self.selection_node.setPen(pen)\n        self.selection_node.setOpacity(0.5)\n        # self.selection_node.setVisible(False)\n\n        self.refresh()\n\n    @property\n    def g(self) -> GraphT:\n        return self.graph_scene.g\n\n    def refresh(self) -> None:\n        \"\"\"Call whenever source or target moves or edge data changes\"\"\"\n\n        # set color/style according to edge type\n        pen = QPen()\n        pen.setWidthF(3)\n        if self.g.edge_type(self.e) == EdgeType.HADAMARD:\n            pen.setColor(QColor(HAD_EDGE_BLUE))\n            pen.setDashPattern([4.0, 2.0])\n        else:\n            pen.setColor(QColor(\"#000000\"))\n        self.setPen(QPen(pen))\n\n        # set path as a straight line from source to target\n        path = QPainterPath()\n        path.moveTo(self.s_item.pos())\n        path.lineTo(self.t_item.pos())\n        self.setPath(path)\n\n        avg_x = 0.5*(self.s_item.pos().x() + self.t_item.pos().x())\n        avg_y = 0.5*(self.s_item.pos().y() + self.t_item.pos().y())\n        self.selection_node.setPos(avg_x,avg_y)\n        if self.isSelected():\n            self.selection_node.setVisible(True)\n        else:\n            self.selection_node.setVisible(False)\n\n    def paint(self, painter: QPainter, option: QStyleOptionGraphicsItem, widget: Optional[QWidget] = None) -> None:\n        # By default, Qt draws a dashed rectangle around selected items.\n        # We have our own implementation to draw selected vertices, so\n        # we intercept the selected option here.\n        option.state &= ~QStyle.StateFlag.State_Selected\n        super().paint(painter, option, widget)\n\n    def itemChange(self, change: QGraphicsItem.GraphicsItemChange, value: Any) -> Any:\n        # Intercept selection- and position-has-changed events to call `refresh`.\n        # Note that the position and selected values are already updated when\n        # this event fires.\n        if change in (QGraphicsItem.GraphicsItemChange.ItemSelectedHasChanged, QGraphicsItem.GraphicsItemChange.ItemPositionHasChanged):\n            self.refresh()\n\n        return super().itemChange(change, value)\n\n    def mousePressEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n        super().mousePressEvent(e)\n        self.refresh()", "\nclass EItem(QGraphicsPathItem):\n    \"\"\"A QGraphicsItem representing an edge\"\"\"\n\n    def __init__(self, graph_scene: GraphScene, e: ET, s_item: VItem, t_item: VItem) -> None:\n        super().__init__()\n        self.setZValue(EITEM_Z)\n        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable, True)\n        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges, True)\n\n        self.graph_scene = graph_scene\n        self.e = e\n        self.s_item = s_item\n        self.t_item = t_item\n        s_item.adj_items.add(self)\n        t_item.adj_items.add(self)\n        self.selection_node = QGraphicsEllipseItem(-0.1 * SCALE, -0.1 * SCALE, 0.2 * SCALE, 0.2 * SCALE)\n        pen = QPen()\n        pen.setWidthF(4)\n        pen.setColor(QColor('#0022FF'))\n        self.selection_node.setPen(pen)\n        self.selection_node.setOpacity(0.5)\n        # self.selection_node.setVisible(False)\n\n        self.refresh()\n\n    @property\n    def g(self) -> GraphT:\n        return self.graph_scene.g\n\n    def refresh(self) -> None:\n        \"\"\"Call whenever source or target moves or edge data changes\"\"\"\n\n        # set color/style according to edge type\n        pen = QPen()\n        pen.setWidthF(3)\n        if self.g.edge_type(self.e) == EdgeType.HADAMARD:\n            pen.setColor(QColor(HAD_EDGE_BLUE))\n            pen.setDashPattern([4.0, 2.0])\n        else:\n            pen.setColor(QColor(\"#000000\"))\n        self.setPen(QPen(pen))\n\n        # set path as a straight line from source to target\n        path = QPainterPath()\n        path.moveTo(self.s_item.pos())\n        path.lineTo(self.t_item.pos())\n        self.setPath(path)\n\n        avg_x = 0.5*(self.s_item.pos().x() + self.t_item.pos().x())\n        avg_y = 0.5*(self.s_item.pos().y() + self.t_item.pos().y())\n        self.selection_node.setPos(avg_x,avg_y)\n        if self.isSelected():\n            self.selection_node.setVisible(True)\n        else:\n            self.selection_node.setVisible(False)\n\n    def paint(self, painter: QPainter, option: QStyleOptionGraphicsItem, widget: Optional[QWidget] = None) -> None:\n        # By default, Qt draws a dashed rectangle around selected items.\n        # We have our own implementation to draw selected vertices, so\n        # we intercept the selected option here.\n        option.state &= ~QStyle.StateFlag.State_Selected\n        super().paint(painter, option, widget)\n\n    def itemChange(self, change: QGraphicsItem.GraphicsItemChange, value: Any) -> Any:\n        # Intercept selection- and position-has-changed events to call `refresh`.\n        # Note that the position and selected values are already updated when\n        # this event fires.\n        if change in (QGraphicsItem.GraphicsItemChange.ItemSelectedHasChanged, QGraphicsItem.GraphicsItemChange.ItemPositionHasChanged):\n            self.refresh()\n\n        return super().itemChange(change, value)\n\n    def mousePressEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n        super().mousePressEvent(e)\n        self.refresh()", "\n\n# TODO: This is essentially a clone of EItem. We should common it up!\nclass EDragItem(QGraphicsPathItem):\n    \"\"\"A QGraphicsItem representing an edge in construction during a drag\"\"\"\n\n    def __init__(self, g: GraphT, ety: EdgeType.Type, start: VItem, mouse_pos: QPointF) -> None:\n        super().__init__()\n        self.setZValue(EITEM_Z)\n        self.g = g\n        self.ety = ety\n        self.start = start\n        self.mouse_pos = mouse_pos\n        self.refresh()\n\n    def refresh(self) -> None:\n        \"\"\"Call whenever source or target moves or edge data changes\"\"\"\n\n        # set color/style according to edge type\n        pen = QPen()\n        pen.setWidthF(3)\n        if self.ety == EdgeType.HADAMARD:\n            pen.setColor(QColor(\"#0077ff\"))\n            pen.setDashPattern([4.0, 2.0])\n        else:\n            pen.setColor(QColor(\"#000000\"))\n        self.setPen(QPen(pen))\n\n        # set path as a straight line from source to target\n        path = QPainterPath()\n        path.moveTo(self.start.pos())\n        path.lineTo(self.mouse_pos)\n        self.setPath(path)", "\n"]}
{"filename": "zxlive/proof_panel.py", "chunked_list": ["from __future__ import annotations\n\nimport copy\nfrom typing import Iterator, Union, cast\n\nimport pyzx\nfrom PySide6.QtCore import QPointF, QPersistentModelIndex, Qt, \\\n    QModelIndex, QItemSelection, QRect, QSize\nfrom PySide6.QtGui import QVector2D, QFont, QColor, QPainter, QPen, QFontMetrics, QIcon\nfrom PySide6.QtWidgets import QWidget, QToolButton, QHBoxLayout, QListView, \\", "from PySide6.QtGui import QVector2D, QFont, QColor, QPainter, QPen, QFontMetrics, QIcon\nfrom PySide6.QtWidgets import QWidget, QToolButton, QHBoxLayout, QListView, \\\n    QStyledItemDelegate, QStyleOptionViewItem, QStyle, QAbstractItemView\nfrom pyzx import VertexType, basicrules\n\nfrom .common import ET, VT, GraphT, SCALE, pos_from_view, pos_to_view\nfrom .base_panel import BasePanel, ToolbarSection\nfrom .commands import AddRewriteStep, GoToRewriteStep, MoveNodeInStep\nfrom .graphscene import GraphScene\nfrom .graphview import WandTrace, GraphTool", "from .graphscene import GraphScene\nfrom .graphview import WandTrace, GraphTool\nfrom .eitem import EItem\nfrom .proof import ProofModel\nfrom .utils import get_data\nfrom .vitem import VItem, ZX_GREEN, DragState\nfrom . import proof_actions\nfrom . import animations as anims\n\n\nclass ProofPanel(BasePanel):\n    \"\"\"Panel for the proof mode of ZX live.\"\"\"\n\n    def __init__(self, graph: GraphT) -> None:\n        self.graph_scene = GraphScene()\n        self.graph_scene.vertices_moved.connect(self._vert_moved)\n        # TODO: Right now this calls for every single vertex selected, even if we select many at the same time\n        self.graph_scene.selectionChanged.connect(self.update_on_selection)\n        self.graph_scene.vertex_double_clicked.connect(self._vert_double_clicked)\n\n        super().__init__(graph, self.graph_scene)\n\n        self.init_action_groups()\n\n        self.graph_view.wand_trace_finished.connect(self._wand_trace_finished)\n        self.graph_scene.vertex_dragged.connect(self._vertex_dragged)\n        self.graph_scene.vertex_dropped_onto.connect(self._vertex_dropped_onto)\n\n        self.step_view = QListView(self)\n        self.proof_model = ProofModel(self.graph_view.graph_scene.g)\n        self.step_view.setModel(self.proof_model)\n        self.step_view.setPalette(QColor(255, 255, 255))\n        self.step_view.setSpacing(0)\n        self.step_view.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)\n        self.step_view.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)\n        self.step_view.setItemDelegate(ProofStepItemDelegate())\n        self.step_view.setCurrentIndex(self.proof_model.index(0, 0))\n        self.step_view.selectionModel().selectionChanged.connect(self._proof_step_selected)\n        self.step_view.viewport().setAttribute(Qt.WidgetAttribute.WA_Hover)\n\n        self.splitter.addWidget(self.step_view)\n\n    def _toolbar_sections(self) -> Iterator[ToolbarSection]:\n        icon_size = QSize(32, 32)\n        self.selection = QToolButton(self, checkable=True, checked=True)\n        self.magic_wand = QToolButton(self, checkable=True)\n        self.selection.setIcon(QIcon(get_data(\"icons/tikzit-tool-select.svg\")))\n        self.magic_wand.setIcon(QIcon(get_data(\"icons/magic-wand.svg\")))\n        self.selection.setIconSize(icon_size)\n        self.magic_wand.setIconSize(icon_size)\n        self.selection.setToolTip(\"Select (s)\")\n        self.magic_wand.setToolTip(\"Magic Wand (w)\")\n        self.selection.setShortcut(\"s\")\n        self.magic_wand.setShortcut(\"w\")\n        self.selection.clicked.connect(self._selection_clicked)\n        self.magic_wand.clicked.connect(self._magic_wand_clicked)\n        yield ToolbarSection(self.selection, self.magic_wand, exclusive=True)\n\n        self.identity_choice = (\n            QToolButton(self, text=\"Z\", checkable=True, checked=True),\n            QToolButton(self, text=\"X\", checkable=True)\n        )\n        yield ToolbarSection(*self.identity_choice, exclusive=True)\n\n    def init_action_groups(self) -> None:\n        self.action_groups = [proof_actions.ProofActionGroup(*proof_actions.rewrites).copy()]\n        for group in reversed(self.action_groups):\n            hlayout = QHBoxLayout()\n            group.init_buttons(self)\n            for action in group.actions:\n                assert action.button is not None\n                hlayout.addWidget(action.button)\n            hlayout.addStretch()\n\n            widget = QWidget()\n            widget.setLayout(hlayout)\n            self.layout().insertWidget(1, widget)\n\n    def parse_selection(self) -> tuple[list[VT], list[ET]]:\n        selection = list(self.graph_scene.selected_vertices)\n        g = self.graph_scene.g\n        edges = []\n        for e in g.edges():\n            s,t = g.edge_st(e)\n            if s in selection and t in selection:\n                edges.append(e)\n\n        return selection, edges\n\n    def update_on_selection(self) -> None:\n        selection, edges = self.parse_selection()\n        g = self.graph_scene.g\n\n        for group in self.action_groups:\n            group.update_active(g,selection,edges)\n\n    def _vert_moved(self, vs: list[tuple[VT, float, float]]) -> None:\n        cmd = MoveNodeInStep(self.graph_view, vs, self.step_view)\n        self.undo_stack.push(cmd)\n\n    def _selection_clicked(self) -> None:\n        self.graph_view.tool = GraphTool.Selection\n\n    def _magic_wand_clicked(self) -> None:\n        self.graph_view.tool = GraphTool.MagicWand\n\n    def _vertex_dragged(self, state: DragState, v: VT, w: VT) -> None:\n        if state == DragState.Onto:\n            if pyzx.basicrules.check_fuse(self.graph, v, w):\n                anims.anticipate_fuse(self.graph_scene.vertex_map[w])\n            elif pyzx.basicrules.check_strong_comp(self.graph, v, w):\n                anims.anticipate_strong_comp(self.graph_scene.vertex_map[w])\n        else:\n            anims.back_to_default(self.graph_scene.vertex_map[w])\n\n    def _vertex_dropped_onto(self, v: VT, w: VT) -> None:\n        if pyzx.basicrules.check_fuse(self.graph, v, w):\n            g = copy.deepcopy(self.graph)\n            pyzx.basicrules.fuse(g, w, v)\n            anim = anims.fuse(self.graph_scene.vertex_map[v], self.graph_scene.vertex_map[w])\n            cmd = AddRewriteStep(self.graph_view, g, self.step_view, \"fuse spiders\")\n            self.undo_stack.push(cmd, anim_before=anim)\n        elif pyzx.basicrules.check_strong_comp(self.graph, v, w):\n            g = copy.deepcopy(self.graph)\n            pyzx.basicrules.strong_comp(g, w, v)\n            anim = anims.strong_comp(self.graph, g, w, self.graph_scene)\n            cmd = AddRewriteStep(self.graph_view, g, self.step_view, \"bialgebra\")\n            self.undo_stack.push(cmd, anim_after=anim)\n\n    def _wand_trace_finished(self, trace: WandTrace) -> None:\n        if self._magic_slice(trace):\n            return\n        elif self._magic_identity(trace):\n            return\n\n    def _magic_identity(self, trace: WandTrace) -> bool:\n        if len(trace.hit) != 1 or not all(isinstance(item, EItem) for item in trace.hit):\n            return False\n        # We know that the type of `item` is `EItem` because of the check above\n        item = cast(EItem, next(iter(trace.hit)))\n        pos = trace.hit[item][-1]\n        pos = QPointF(*pos_from_view(pos.x(), pos.y())) * SCALE\n        s = self.graph.edge_s(item.e)\n        t = self.graph.edge_t(item.e)\n\n        if self.identity_choice[0].isChecked():\n            vty: VertexType.Type = VertexType.Z\n        elif self.identity_choice[1].isChecked():\n            vty = VertexType.X\n        else:\n            raise ValueError(\"Neither of the spider types are checked.\")\n\n        new_g = copy.deepcopy(self.graph)\n        v = new_g.add_vertex(vty, row=pos.x()/SCALE, qubit=pos.y()/SCALE)\n        new_g.add_edge(self.graph.edge(s, v), self.graph.edge_type(item.e))\n        new_g.add_edge(self.graph.edge(v, t))\n        new_g.remove_edge(item.e)\n\n        anim = anims.add_id(v, self.graph_scene)\n        cmd = AddRewriteStep(self.graph_view, new_g, self.step_view, \"remove identity\")\n        self.undo_stack.push(cmd, anim_after=anim)\n        return True\n\n    def _magic_slice(self, trace: WandTrace) -> bool:\n        def cross(a: QPointF, b: QPointF) -> float:\n            return a.y() * b.x() - a.x() * b.y()\n        filtered = [item for item in trace.hit if isinstance(item, VItem)]\n        if len(filtered) != 1:\n            return False\n        item = filtered[0]\n        vertex = item.v\n        if self.graph.type(vertex) not in (VertexType.Z, VertexType.X):\n            return False\n        \n        if basicrules.check_remove_id(self.graph, vertex):\n            self._remove_id(vertex)\n            return True\n\n        start = trace.hit[item][0]\n        end = trace.hit[item][-1]\n        if start.y() > end.y():\n            start, end = end, start\n        pos = QPointF(*pos_to_view(self.graph.row(vertex), self.graph.qubit(vertex)))\n        left, right = [], []\n        for neighbor in self.graph.neighbors(vertex):\n            npos = QPointF(*pos_to_view(self.graph.row(neighbor), self.graph.qubit(neighbor)))\n            # Compute whether each neighbor is inside the entry and exit points\n            i1 = cross(start - pos, npos - pos) * cross(start - pos, end - pos) >= 0\n            i2 = cross(end - pos, npos - pos) * cross(end - pos, start - pos) >= 0\n            inside = i1 and i2\n            if inside:\n                left.append(neighbor)\n            else:\n                right.append(neighbor)\n        mouse_dir = ((start + end) * (1/2)) - pos\n        self._unfuse(vertex, left, mouse_dir)\n        return True\n\n    def _remove_id(self, v: VT) -> None:\n        new_g = copy.deepcopy(self.graph)\n        basicrules.remove_id(new_g, v)\n        anim = anims.remove_id(self.graph_scene.vertex_map[v])\n        cmd = AddRewriteStep(self.graph_view, new_g, self.step_view, \"id\")\n        self.undo_stack.push(cmd, anim_before=anim)\n\n    def _unfuse(self, v: VT, left_neighbours: list[VT], mouse_dir: QPointF) -> None:\n        def snap_vector(v: QVector2D) -> None:\n            if abs(v.x()) > abs(v.y()):\n                v.setY(0.0)\n            else:\n                v.setX(0.0)\n            if not v.isNull():\n                v.normalize()\n\n        # Compute the average position of left vectors\n        pos = QPointF(self.graph.row(v), self.graph.qubit(v))\n        avg_left = QVector2D()\n        for n in left_neighbours:\n            npos = QPointF(self.graph.row(n), self.graph.qubit(n))\n            dir = QVector2D(npos - pos).normalized()\n            avg_left += dir\n        avg_left.normalize()\n        # And snap it to the grid\n        snap_vector(avg_left)\n        # Same for right vectors\n        avg_right = QVector2D()\n        for n in self.graph.neighbors(v):\n            if n in left_neighbours: continue\n            npos = QPointF(self.graph.row(n), self.graph.qubit(n))\n            dir = QVector2D(npos - pos).normalized()\n            avg_right += dir\n        avg_right.normalize()\n        snap_vector(avg_right)\n        if avg_right.isNull():\n            avg_right = -avg_left\n        elif avg_left.isNull():\n            avg_left = -avg_right\n\n        dist = 0.25 if QVector2D.dotProduct(avg_left, avg_right) != 0 else 0.35\n        # Put the phase on the left hand side if the mouse direction is further\n        # away from the average direction of the left neighbours than the right.\n        phase_left = QVector2D.dotProduct(QVector2D(mouse_dir), avg_left) \\\n            <= QVector2D.dotProduct(QVector2D(mouse_dir), avg_right)\n\n        new_g = copy.deepcopy(self.graph)\n        left_vert = new_g.add_vertex(self.graph.type(v),\n                                     qubit=self.graph.qubit(v) + dist*avg_left.y(),\n                                     row=self.graph.row(v) + dist*avg_left.x())\n        new_g.set_row(v, self.graph.row(v) + dist*avg_right.x())\n        new_g.set_qubit(v, self.graph.qubit(v) + dist*avg_right.y())\n        for neighbor in left_neighbours:\n            new_g.add_edge((neighbor, left_vert),\n                           self.graph.edge_type((v, neighbor)))\n            new_g.remove_edge((v, neighbor))\n        new_g.add_edge((v, left_vert))\n        if phase_left:\n            new_g.set_phase(left_vert, new_g.phase(v))\n            new_g.set_phase(v, 0)\n\n        anim = anims.unfuse(self.graph, new_g, v, self.graph_scene)\n        cmd = AddRewriteStep(self.graph_view, new_g, self.step_view, \"unfuse\")\n        self.undo_stack.push(cmd, anim_after=anim)\n\n    def _vert_double_clicked(self, v: VT) -> None:\n        if self.graph.type(v) == VertexType.BOUNDARY:\n            return\n\n        new_g = copy.deepcopy(self.graph)\n        basicrules.color_change(new_g, v)\n        cmd = AddRewriteStep(self.graph_view, new_g, self.step_view, \"color change\")\n        self.undo_stack.push(cmd)\n\n    def _proof_step_selected(self, selected: QItemSelection, deselected: QItemSelection) -> None:\n        if not selected or not deselected:\n            return\n        cmd = GoToRewriteStep(self.graph_view, self.step_view, deselected.first().topLeft().row(), selected.first().topLeft().row())\n        self.undo_stack.push(cmd)", "\n\nclass ProofPanel(BasePanel):\n    \"\"\"Panel for the proof mode of ZX live.\"\"\"\n\n    def __init__(self, graph: GraphT) -> None:\n        self.graph_scene = GraphScene()\n        self.graph_scene.vertices_moved.connect(self._vert_moved)\n        # TODO: Right now this calls for every single vertex selected, even if we select many at the same time\n        self.graph_scene.selectionChanged.connect(self.update_on_selection)\n        self.graph_scene.vertex_double_clicked.connect(self._vert_double_clicked)\n\n        super().__init__(graph, self.graph_scene)\n\n        self.init_action_groups()\n\n        self.graph_view.wand_trace_finished.connect(self._wand_trace_finished)\n        self.graph_scene.vertex_dragged.connect(self._vertex_dragged)\n        self.graph_scene.vertex_dropped_onto.connect(self._vertex_dropped_onto)\n\n        self.step_view = QListView(self)\n        self.proof_model = ProofModel(self.graph_view.graph_scene.g)\n        self.step_view.setModel(self.proof_model)\n        self.step_view.setPalette(QColor(255, 255, 255))\n        self.step_view.setSpacing(0)\n        self.step_view.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)\n        self.step_view.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)\n        self.step_view.setItemDelegate(ProofStepItemDelegate())\n        self.step_view.setCurrentIndex(self.proof_model.index(0, 0))\n        self.step_view.selectionModel().selectionChanged.connect(self._proof_step_selected)\n        self.step_view.viewport().setAttribute(Qt.WidgetAttribute.WA_Hover)\n\n        self.splitter.addWidget(self.step_view)\n\n    def _toolbar_sections(self) -> Iterator[ToolbarSection]:\n        icon_size = QSize(32, 32)\n        self.selection = QToolButton(self, checkable=True, checked=True)\n        self.magic_wand = QToolButton(self, checkable=True)\n        self.selection.setIcon(QIcon(get_data(\"icons/tikzit-tool-select.svg\")))\n        self.magic_wand.setIcon(QIcon(get_data(\"icons/magic-wand.svg\")))\n        self.selection.setIconSize(icon_size)\n        self.magic_wand.setIconSize(icon_size)\n        self.selection.setToolTip(\"Select (s)\")\n        self.magic_wand.setToolTip(\"Magic Wand (w)\")\n        self.selection.setShortcut(\"s\")\n        self.magic_wand.setShortcut(\"w\")\n        self.selection.clicked.connect(self._selection_clicked)\n        self.magic_wand.clicked.connect(self._magic_wand_clicked)\n        yield ToolbarSection(self.selection, self.magic_wand, exclusive=True)\n\n        self.identity_choice = (\n            QToolButton(self, text=\"Z\", checkable=True, checked=True),\n            QToolButton(self, text=\"X\", checkable=True)\n        )\n        yield ToolbarSection(*self.identity_choice, exclusive=True)\n\n    def init_action_groups(self) -> None:\n        self.action_groups = [proof_actions.ProofActionGroup(*proof_actions.rewrites).copy()]\n        for group in reversed(self.action_groups):\n            hlayout = QHBoxLayout()\n            group.init_buttons(self)\n            for action in group.actions:\n                assert action.button is not None\n                hlayout.addWidget(action.button)\n            hlayout.addStretch()\n\n            widget = QWidget()\n            widget.setLayout(hlayout)\n            self.layout().insertWidget(1, widget)\n\n    def parse_selection(self) -> tuple[list[VT], list[ET]]:\n        selection = list(self.graph_scene.selected_vertices)\n        g = self.graph_scene.g\n        edges = []\n        for e in g.edges():\n            s,t = g.edge_st(e)\n            if s in selection and t in selection:\n                edges.append(e)\n\n        return selection, edges\n\n    def update_on_selection(self) -> None:\n        selection, edges = self.parse_selection()\n        g = self.graph_scene.g\n\n        for group in self.action_groups:\n            group.update_active(g,selection,edges)\n\n    def _vert_moved(self, vs: list[tuple[VT, float, float]]) -> None:\n        cmd = MoveNodeInStep(self.graph_view, vs, self.step_view)\n        self.undo_stack.push(cmd)\n\n    def _selection_clicked(self) -> None:\n        self.graph_view.tool = GraphTool.Selection\n\n    def _magic_wand_clicked(self) -> None:\n        self.graph_view.tool = GraphTool.MagicWand\n\n    def _vertex_dragged(self, state: DragState, v: VT, w: VT) -> None:\n        if state == DragState.Onto:\n            if pyzx.basicrules.check_fuse(self.graph, v, w):\n                anims.anticipate_fuse(self.graph_scene.vertex_map[w])\n            elif pyzx.basicrules.check_strong_comp(self.graph, v, w):\n                anims.anticipate_strong_comp(self.graph_scene.vertex_map[w])\n        else:\n            anims.back_to_default(self.graph_scene.vertex_map[w])\n\n    def _vertex_dropped_onto(self, v: VT, w: VT) -> None:\n        if pyzx.basicrules.check_fuse(self.graph, v, w):\n            g = copy.deepcopy(self.graph)\n            pyzx.basicrules.fuse(g, w, v)\n            anim = anims.fuse(self.graph_scene.vertex_map[v], self.graph_scene.vertex_map[w])\n            cmd = AddRewriteStep(self.graph_view, g, self.step_view, \"fuse spiders\")\n            self.undo_stack.push(cmd, anim_before=anim)\n        elif pyzx.basicrules.check_strong_comp(self.graph, v, w):\n            g = copy.deepcopy(self.graph)\n            pyzx.basicrules.strong_comp(g, w, v)\n            anim = anims.strong_comp(self.graph, g, w, self.graph_scene)\n            cmd = AddRewriteStep(self.graph_view, g, self.step_view, \"bialgebra\")\n            self.undo_stack.push(cmd, anim_after=anim)\n\n    def _wand_trace_finished(self, trace: WandTrace) -> None:\n        if self._magic_slice(trace):\n            return\n        elif self._magic_identity(trace):\n            return\n\n    def _magic_identity(self, trace: WandTrace) -> bool:\n        if len(trace.hit) != 1 or not all(isinstance(item, EItem) for item in trace.hit):\n            return False\n        # We know that the type of `item` is `EItem` because of the check above\n        item = cast(EItem, next(iter(trace.hit)))\n        pos = trace.hit[item][-1]\n        pos = QPointF(*pos_from_view(pos.x(), pos.y())) * SCALE\n        s = self.graph.edge_s(item.e)\n        t = self.graph.edge_t(item.e)\n\n        if self.identity_choice[0].isChecked():\n            vty: VertexType.Type = VertexType.Z\n        elif self.identity_choice[1].isChecked():\n            vty = VertexType.X\n        else:\n            raise ValueError(\"Neither of the spider types are checked.\")\n\n        new_g = copy.deepcopy(self.graph)\n        v = new_g.add_vertex(vty, row=pos.x()/SCALE, qubit=pos.y()/SCALE)\n        new_g.add_edge(self.graph.edge(s, v), self.graph.edge_type(item.e))\n        new_g.add_edge(self.graph.edge(v, t))\n        new_g.remove_edge(item.e)\n\n        anim = anims.add_id(v, self.graph_scene)\n        cmd = AddRewriteStep(self.graph_view, new_g, self.step_view, \"remove identity\")\n        self.undo_stack.push(cmd, anim_after=anim)\n        return True\n\n    def _magic_slice(self, trace: WandTrace) -> bool:\n        def cross(a: QPointF, b: QPointF) -> float:\n            return a.y() * b.x() - a.x() * b.y()\n        filtered = [item for item in trace.hit if isinstance(item, VItem)]\n        if len(filtered) != 1:\n            return False\n        item = filtered[0]\n        vertex = item.v\n        if self.graph.type(vertex) not in (VertexType.Z, VertexType.X):\n            return False\n        \n        if basicrules.check_remove_id(self.graph, vertex):\n            self._remove_id(vertex)\n            return True\n\n        start = trace.hit[item][0]\n        end = trace.hit[item][-1]\n        if start.y() > end.y():\n            start, end = end, start\n        pos = QPointF(*pos_to_view(self.graph.row(vertex), self.graph.qubit(vertex)))\n        left, right = [], []\n        for neighbor in self.graph.neighbors(vertex):\n            npos = QPointF(*pos_to_view(self.graph.row(neighbor), self.graph.qubit(neighbor)))\n            # Compute whether each neighbor is inside the entry and exit points\n            i1 = cross(start - pos, npos - pos) * cross(start - pos, end - pos) >= 0\n            i2 = cross(end - pos, npos - pos) * cross(end - pos, start - pos) >= 0\n            inside = i1 and i2\n            if inside:\n                left.append(neighbor)\n            else:\n                right.append(neighbor)\n        mouse_dir = ((start + end) * (1/2)) - pos\n        self._unfuse(vertex, left, mouse_dir)\n        return True\n\n    def _remove_id(self, v: VT) -> None:\n        new_g = copy.deepcopy(self.graph)\n        basicrules.remove_id(new_g, v)\n        anim = anims.remove_id(self.graph_scene.vertex_map[v])\n        cmd = AddRewriteStep(self.graph_view, new_g, self.step_view, \"id\")\n        self.undo_stack.push(cmd, anim_before=anim)\n\n    def _unfuse(self, v: VT, left_neighbours: list[VT], mouse_dir: QPointF) -> None:\n        def snap_vector(v: QVector2D) -> None:\n            if abs(v.x()) > abs(v.y()):\n                v.setY(0.0)\n            else:\n                v.setX(0.0)\n            if not v.isNull():\n                v.normalize()\n\n        # Compute the average position of left vectors\n        pos = QPointF(self.graph.row(v), self.graph.qubit(v))\n        avg_left = QVector2D()\n        for n in left_neighbours:\n            npos = QPointF(self.graph.row(n), self.graph.qubit(n))\n            dir = QVector2D(npos - pos).normalized()\n            avg_left += dir\n        avg_left.normalize()\n        # And snap it to the grid\n        snap_vector(avg_left)\n        # Same for right vectors\n        avg_right = QVector2D()\n        for n in self.graph.neighbors(v):\n            if n in left_neighbours: continue\n            npos = QPointF(self.graph.row(n), self.graph.qubit(n))\n            dir = QVector2D(npos - pos).normalized()\n            avg_right += dir\n        avg_right.normalize()\n        snap_vector(avg_right)\n        if avg_right.isNull():\n            avg_right = -avg_left\n        elif avg_left.isNull():\n            avg_left = -avg_right\n\n        dist = 0.25 if QVector2D.dotProduct(avg_left, avg_right) != 0 else 0.35\n        # Put the phase on the left hand side if the mouse direction is further\n        # away from the average direction of the left neighbours than the right.\n        phase_left = QVector2D.dotProduct(QVector2D(mouse_dir), avg_left) \\\n            <= QVector2D.dotProduct(QVector2D(mouse_dir), avg_right)\n\n        new_g = copy.deepcopy(self.graph)\n        left_vert = new_g.add_vertex(self.graph.type(v),\n                                     qubit=self.graph.qubit(v) + dist*avg_left.y(),\n                                     row=self.graph.row(v) + dist*avg_left.x())\n        new_g.set_row(v, self.graph.row(v) + dist*avg_right.x())\n        new_g.set_qubit(v, self.graph.qubit(v) + dist*avg_right.y())\n        for neighbor in left_neighbours:\n            new_g.add_edge((neighbor, left_vert),\n                           self.graph.edge_type((v, neighbor)))\n            new_g.remove_edge((v, neighbor))\n        new_g.add_edge((v, left_vert))\n        if phase_left:\n            new_g.set_phase(left_vert, new_g.phase(v))\n            new_g.set_phase(v, 0)\n\n        anim = anims.unfuse(self.graph, new_g, v, self.graph_scene)\n        cmd = AddRewriteStep(self.graph_view, new_g, self.step_view, \"unfuse\")\n        self.undo_stack.push(cmd, anim_after=anim)\n\n    def _vert_double_clicked(self, v: VT) -> None:\n        if self.graph.type(v) == VertexType.BOUNDARY:\n            return\n\n        new_g = copy.deepcopy(self.graph)\n        basicrules.color_change(new_g, v)\n        cmd = AddRewriteStep(self.graph_view, new_g, self.step_view, \"color change\")\n        self.undo_stack.push(cmd)\n\n    def _proof_step_selected(self, selected: QItemSelection, deselected: QItemSelection) -> None:\n        if not selected or not deselected:\n            return\n        cmd = GoToRewriteStep(self.graph_view, self.step_view, deselected.first().topLeft().row(), selected.first().topLeft().row())\n        self.undo_stack.push(cmd)", "\n\nclass ProofStepItemDelegate(QStyledItemDelegate):\n    \"\"\"This class controls the painting of items in the proof steps list view.\n\n    We paint a \"git-style\" line with circles to denote individual steps in a proof.\n    \"\"\"\n\n    line_width = 3\n    line_padding = 13\n    vert_padding = 10\n\n    circle_radius = 4\n    circle_radius_selected = 6\n    circle_outline_width = 3\n\n    def paint(self, painter: QPainter, option: QStyleOptionViewItem, index: Union[QModelIndex, QPersistentModelIndex]) -> None:\n        painter.save()\n\n        # Draw background\n        painter.setPen(Qt.GlobalColor.transparent)\n        if option.state & QStyle.StateFlag.State_Selected:\n            painter.setBrush(QColor(204, 232, 255))\n        elif option.state & QStyle.StateFlag.State_MouseOver:\n            painter.setBrush(QColor(229, 243, 255))\n        else:\n            painter.setBrush(Qt.GlobalColor.white)\n        painter.drawRect(option.rect)\n\n        # Draw line\n        is_last = index.row() == index.model().rowCount() - 1\n        line_rect = QRect(\n            self.line_padding,\n            option.rect.y(),\n            self.line_width,\n            option.rect.height() if not is_last else option.rect.height() / 2\n        )\n        painter.setBrush(Qt.GlobalColor.black)\n        painter.drawRect(line_rect)\n\n        # Draw circle\n        painter.setPen(QPen(Qt.GlobalColor.black, self.circle_outline_width))\n        painter.setBrush(QColor(ZX_GREEN))\n        circle_radius = self.circle_radius_selected if option.state & QStyle.StateFlag.State_Selected else self.circle_radius\n        painter.drawEllipse(\n            QPointF(self.line_padding + self.line_width / 2, option.rect.y() + option.rect.height() / 2),\n            circle_radius,\n            circle_radius\n        )\n\n        # Draw text\n        text = index.data(Qt.ItemDataRole.DisplayRole)\n        text_height = QFontMetrics(option.font).height()\n        text_rect = QRect(\n            option.rect.x() + self.line_width + 2 * self.line_padding,\n            option.rect.y() + option.rect.height() / 2 - text_height / 2,\n            option.rect.width(),\n            text_height\n        )\n        if option.state & QStyle.State_Selected:\n            option.font.setWeight(QFont.Weight.Bold)\n        painter.setFont(option.font)\n        painter.setPen(Qt.GlobalColor.black)\n        painter.setBrush(Qt.GlobalColor.black)\n        painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft, text)\n\n        painter.restore()\n\n    def sizeHint(self, option: QStyleOptionViewItem, index: QModelIndex | QPersistentModelIndex) -> QSize:\n        size = super().sizeHint(option, index)\n        return QSize(size.width(), size.height() + 2 * self.vert_padding)", "\n    # def createEditor(self, parent: QWidget, option: QStyleOptionViewItem, index: QModelIndex | QPersistentModelIndex) -> QWidget:\n    #     return False\n\n"]}
{"filename": "zxlive/animations.py", "chunked_list": ["import itertools\nimport random\nfrom typing import Optional, Callable\n\nfrom PySide6.QtCore import QEasingCurve, QPointF, QAbstractAnimation, \\\n    QParallelAnimationGroup\nfrom PySide6.QtGui import QUndoStack, QUndoCommand\n\nfrom .common import VT, GraphT, pos_to_view\nfrom .graphscene import GraphScene", "from .common import VT, GraphT, pos_to_view\nfrom .graphscene import GraphScene\nfrom .vitem import VItem, VItemAnimation, VITEM_UNSELECTED_Z, VITEM_SELECTED_Z\n\n\nclass AnimatedUndoStack(QUndoStack):\n    \"\"\"An undo stack that can play animations between actions.\"\"\"\n\n    # Command that has not yet been pushed to the base stack because an\n    # animation is still playing\n    queued_cmd: Optional[QUndoCommand] = None\n\n    # Animation that is currently playing\n    running_anim: Optional[QAbstractAnimation] = None\n\n    def push(self, cmd: QUndoCommand, anim_before: Optional[QAbstractAnimation] = None,\n             anim_after: Optional[QAbstractAnimation] = None) -> None:\n        # Stop previously running animation\n        if self.running_anim:\n            self.running_anim.stop()\n            self.running_anim = None\n\n        # If there is still a queued command, perform it first immediately\n        if self.queued_cmd:\n            self._push_now(self.queued_cmd)\n\n        if anim_before:\n            self.queued_cmd = cmd\n            anim_before.finished.connect(lambda: self._push_now(cmd, anim_after))\n            anim_before.start()\n            self.running_anim = anim_before\n        else:\n            self._push_now(cmd, anim_after)\n\n    def undo(self) -> None:\n        # Stop previously running animation\n        if self.running_anim:\n            self.running_anim.stop()\n            self.running_anim = None\n\n        # If there is still a queued command, perform it first immediately\n        if self.queued_cmd:\n            self._push_now(self.queued_cmd)\n\n        super().undo()\n\n    def _push_now(self, cmd: QUndoCommand, anim_after: Optional[QAbstractAnimation] = None) -> None:\n        self.queued_cmd = None\n        super().push(cmd)\n\n        if anim_after:\n            anim_after.start()\n            self.running_anim = anim_after", "\n\ndef scale(it: VItem, target: float, duration: int, ease: QEasingCurve, start: Optional[float] = None) -> VItemAnimation:\n    anim = VItemAnimation(it, VItem.Properties.Scale)\n    anim.setDuration(duration)\n    anim.setStartValue(start or it.scale())\n    # Important: end value must be a float, otherwise the animation doesn't work because\n    # start and end have different types\n    anim.setEndValue(float(target))\n    anim.setEasingCurve(ease)\n    return anim", "\n\ndef move(it: VItem, target: QPointF, duration: int, ease: QEasingCurve, start: Optional[QPointF] = None) -> VItemAnimation:\n    anim = VItemAnimation(it, VItem.Properties.Position, refresh=True)\n    anim.setDuration(duration)\n    anim.setStartValue(start or it.pos())\n    anim.setEndValue(target)\n    anim.setEasingCurve(ease)\n    return anim\n", "\n\ndef morph_graph(start: GraphT, end: GraphT, scene: GraphScene, to_start: Callable[[VT], Optional[VT]],\n                to_end: Callable[[VT], Optional[VT]], duration: int, ease: QEasingCurve) -> QAbstractAnimation:\n    \"\"\"Morphs a graph into another graph by moving the vertices.\"\"\"\n    moves = set()\n    for v in itertools.chain(iter(start.vertices()), iter(end.vertices())):\n        if v not in start.graph:\n            if u := to_start(v):\n                moves.add((v, u, v))\n        elif v not in end.graph:\n            if u := to_end(v):\n                moves.add((v, v, u))\n        elif start.row(v) != end.row(v) or start.qubit(v) != end.qubit(v):\n            moves.add((v, v, v))\n    group = QParallelAnimationGroup()\n    for v, start_pos, end_pos in moves:\n        anim = VItemAnimation(v, VItem.Properties.Position, scene, refresh=True)\n        anim.setDuration(duration)\n        anim.setStartValue(QPointF(*pos_to_view(start.row(start_pos), start.qubit(start_pos))))\n        anim.setEndValue(QPointF(*pos_to_view(end.row(end_pos), end.qubit(end_pos))))\n        anim.setEasingCurve(ease)\n        group.addAnimation(anim)\n    return group", "\n\ndef shake(it: VItem, amount: float, duration: int) -> None:\n    center = it.pos()\n    anim = VItemAnimation(it, VItem.Properties.Position, refresh=False)\n    anim.setLoopCount(-1)  # Infinite looping\n    anim.setEasingCurve(QEasingCurve.Type.InOutExpo)\n    anim.setDuration(duration)\n\n    def set_random_params() -> None:\n        dx = (2 * random.random() - 1) * amount\n        dy = (2 * random.random() - 1) * amount\n        anim.setStartValue(it.pos())\n        anim.setEndValue(QPointF(center.x() + dx, center.y() + dy))\n\n    def state_changed(state: QAbstractAnimation.State) -> None:\n        if state == QAbstractAnimation.State.Stopped:\n            it.setPos(center)\n\n    set_random_params()\n    anim.currentLoopChanged.connect(set_random_params)\n    anim.stateChanged.connect(state_changed)\n    anim.start()", "\n\ndef anticipate_fuse(it: VItem) -> None:\n    \"\"\"Animation that is played when a fuseable spider is dragged onto a vertex.\"\"\"\n    scale(it, target=1.25, duration=100, ease=QEasingCurve(QEasingCurve.Type.OutInQuad)).start()\n\n\ndef fuse(dragged: VItem, target: VItem) -> QAbstractAnimation:\n    \"\"\"Animation that is played when a fuseable spider is dropped onto a vertex.\"\"\"\n    group = QParallelAnimationGroup()\n    group.addAnimation(move(dragged, target=target.pos(), duration=100, ease=QEasingCurve(QEasingCurve.Type.OutQuad)))\n    group.addAnimation(scale(target, target=1, duration=100, ease=QEasingCurve(QEasingCurve.Type.InBack)))\n\n    def set_z(state: QAbstractAnimation.State) -> None:\n        if state == QAbstractAnimation.State.Running:\n            target.setZValue(VITEM_SELECTED_Z+1)\n        elif state == QAbstractAnimation.State.Stopped:\n            target.setZValue(VITEM_UNSELECTED_Z)\n\n    group.stateChanged.connect(set_z)\n    return group", "\n\ndef anticipate_strong_comp(it: VItem) -> None:\n    \"\"\"Animation that is played when a bialgebra-capable spider is dragged onto a\n    vertex.\"\"\"\n    scale(it, target=1.25, duration=100, ease=QEasingCurve(QEasingCurve.Type.OutInQuad)).start()\n    # shake(it, amount=1.0, duration=70)  # TODO: This could be improved...\n\n\ndef strong_comp(before: GraphT, after: GraphT, target: VT, scene: GraphScene) -> QAbstractAnimation:\n    \"\"\"Animation that is played when a bialgebra-capable spider is dropped onto a\n    vertex.\"\"\"\n    return morph_graph(before, after, scene, to_start=lambda _: target,\n                       to_end=lambda _: None, duration=150, ease=QEasingCurve(QEasingCurve.Type.OutQuad))", "\ndef strong_comp(before: GraphT, after: GraphT, target: VT, scene: GraphScene) -> QAbstractAnimation:\n    \"\"\"Animation that is played when a bialgebra-capable spider is dropped onto a\n    vertex.\"\"\"\n    return morph_graph(before, after, scene, to_start=lambda _: target,\n                       to_end=lambda _: None, duration=150, ease=QEasingCurve(QEasingCurve.Type.OutQuad))\n\n\ndef back_to_default(it: VItem) -> None:\n    \"\"\"Stops all running animations on an VItem and animates all properties back to\n    their default values.\"\"\"\n    for anim in it.active_animations.copy():\n        anim.stop()\n    scale(it, target=1, duration=250, ease=QEasingCurve(QEasingCurve.Type.InOutQuad)).start()", "def back_to_default(it: VItem) -> None:\n    \"\"\"Stops all running animations on an VItem and animates all properties back to\n    their default values.\"\"\"\n    for anim in it.active_animations.copy():\n        anim.stop()\n    scale(it, target=1, duration=250, ease=QEasingCurve(QEasingCurve.Type.InOutQuad)).start()\n\n\ndef remove_id(it: VItem) -> VItemAnimation:\n    \"\"\"Animation that is played when an identity spider is removed using\n    the magic wand.\"\"\"\n    anim = VItemAnimation(it, VItem.Properties.Scale)\n    anim.setDuration(200)\n    anim.setStartValue(it.scale())\n    anim.setEndValue(0.0)\n    anim.setEasingCurve(QEasingCurve.Type.InBack)\n    return anim", "def remove_id(it: VItem) -> VItemAnimation:\n    \"\"\"Animation that is played when an identity spider is removed using\n    the magic wand.\"\"\"\n    anim = VItemAnimation(it, VItem.Properties.Scale)\n    anim.setDuration(200)\n    anim.setStartValue(it.scale())\n    anim.setEndValue(0.0)\n    anim.setEasingCurve(QEasingCurve.Type.InBack)\n    return anim\n\ndef add_id(v: VT, scene: GraphScene) -> VItemAnimation:\n    \"\"\"Animation that is played when an identity spider is added using\n    the magic wand.\"\"\"\n    anim = VItemAnimation(v, VItem.Properties.Scale, scene)\n    anim.setDuration(500)\n    anim.setStartValue(0.0)\n    anim.setEndValue(1.0)\n    anim.setEasingCurve(QEasingCurve.Type.OutElastic)\n    return anim", "\ndef add_id(v: VT, scene: GraphScene) -> VItemAnimation:\n    \"\"\"Animation that is played when an identity spider is added using\n    the magic wand.\"\"\"\n    anim = VItemAnimation(v, VItem.Properties.Scale, scene)\n    anim.setDuration(500)\n    anim.setStartValue(0.0)\n    anim.setEndValue(1.0)\n    anim.setEasingCurve(QEasingCurve.Type.OutElastic)\n    return anim", "\ndef unfuse(before: GraphT, after: GraphT, src: VT, scene: GraphScene) -> QAbstractAnimation:\n    \"\"\"Animation that is played when a spider is unfused using the magic wand.\"\"\"\n    return morph_graph(before, after, scene, to_start=lambda _: src, to_end=lambda _: None,\n                       duration=700, ease=QEasingCurve(QEasingCurve.Type.OutElastic))\n\n"]}
{"filename": "zxlive/graphscene.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n#     Copyright (C) 2023 - Aleks Kissinger\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software", "\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import annotations\n\nfrom typing import Optional, Iterator, Iterable, Dict", "\nfrom typing import Optional, Iterator, Iterable, Dict\n\nfrom PySide6.QtCore import Qt, Signal\nfrom PySide6.QtGui import QBrush, QColor, QTransform\nfrom PySide6.QtWidgets import QGraphicsScene, QGraphicsSceneMouseEvent, QGraphicsItem\n\nfrom pyzx.graph.base import EdgeType\nfrom pyzx.graph import GraphDiff\nfrom pyzx.graph.graph_s import GraphS", "from pyzx.graph import GraphDiff\nfrom pyzx.graph.graph_s import GraphS\n\nfrom .common import VT, ET, GraphT, ToolType, pos_from_view, OFFSET_X, OFFSET_Y\nfrom .vitem import VItem\nfrom .eitem import EItem, EDragItem\n\n\nclass GraphScene(QGraphicsScene):\n    \"\"\"The main class responsible for drawing/editing graphs\"\"\"\n\n    g: GraphT\n\n    # Signals to handle double-clicking and moving of vertices.\n    # Note that we have to set the argument types to `object`,\n    # otherwise it doesn't work for some reason...\n    vertex_double_clicked = Signal(object)  # Actual type: VT\n    vertices_moved = Signal(object)  # Actual type: list[tuple[VT, float, float]]\n\n    # Triggers when a vertex is dragged onto or off of another vertex\n    # Actual types: DragState, VT, VT\n    vertex_dragged = Signal(object, object, object)\n\n    # Triggers when a vertex is dropped onto another vertex. Actual types: VT, VT\n    vertex_dropped_onto = Signal(object, object)\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.setSceneRect(0, 0, 2*OFFSET_X, 2*OFFSET_Y)\n        self.setBackgroundBrush(QBrush(QColor(255, 255, 255)))\n        self.vertex_map: Dict[VT, VItem] = {}\n        self.edge_map: Dict[ET, EItem] = {}\n\n    @property\n    def selected_vertices(self) -> Iterator[VT]:\n        \"\"\"An iterator over all currently selected vertices.\"\"\"\n        return (it.v for it in self.selectedItems() if isinstance(it, VItem))\n\n    @property\n    def selected_edges(self) -> Iterator[ET]:\n        return (it.e for it in self.selectedItems() if isinstance(it, EItem))\n\n    def select_vertices(self, vs: Iterable[VT]) -> None:\n        \"\"\"Selects the given collection of vertices.\"\"\"\n        self.clearSelection()\n        vs = set(vs)\n        for it in self.items():\n            if isinstance(it, VItem) and it.v in vs:\n                it.setSelected(True)\n                vs.remove(it.v)\n\n    def set_graph(self, g: GraphT) -> None:\n        \"\"\"Set the PyZX graph for the scene.\n        If the scene already contains a graph, it will be replaced.\"\"\"\n\n        self.g = g\n        # Stop all animations\n        for it in self.items():\n            if isinstance(it, VItem):\n                for anim in it.active_animations.copy():\n                    anim.stop()\n        self.clear()\n        self.add_items()\n        self.invalidate()\n\n    def update_graph(self, new: GraphT, select_new: bool = False) -> None:\n        \"\"\"Update the PyZX graph for the scene.\n        This will update the scene to match the given graph. It will\n        try to reuse existing QGraphicsItem's as much as possible.\n        \n        The selection is carried over to the updated graph.\n        \n        :param new: The new graph to update to.\n        :param select_new: If True, add all new vertices to the selection set.\"\"\"\n\n        selected_vertices = set(self.selected_vertices)\n\n        diff = GraphDiff(self.g, new)\n\n        removed_edges = set(diff.removed_edges)\n\n        for v in diff.removed_verts:\n            v_item = self.vertex_map[v]\n            if v_item.phase_item:\n                self.removeItem(v_item.phase_item)\n            for anim in v_item.active_animations.copy():\n                anim.stop()\n            for e in self.g.incident_edges(v):\n                removed_edges.add(e)\n\n            selected_vertices.discard(v)\n            self.removeItem(v_item)\n\n        for e in removed_edges:\n            e_item = self.edge_map[e]\n            if e_item.selection_node:\n                self.removeItem(e_item.selection_node)\n            self.removeItem(e_item)\n\n        new_g = diff.apply_diff(self.g)\n        assert isinstance(new_g, GraphS)\n        self.g = new_g\n        # g now contains the new graph,\n        # but we still need to update the scene\n        # However, the new vertices and edges automatically follow the new graph structure\n        \n        for v in diff.new_verts:\n            v_item = VItem(self, v)\n            self.vertex_map[v] = v_item\n            self.addItem(v_item)\n            self.addItem(v_item.phase_item)\n            if select_new:\n                selected_vertices.add(v)\n\n        for e in diff.new_edges:\n            s, t = self.g.edge_st(e)\n            e_item = EItem(self, e, self.vertex_map[s], self.vertex_map[t])\n            self.edge_map[e] = e_item\n            self.addItem(e_item)\n            self.addItem(e_item.selection_node)\n\n        # So we only have to make sure that the existing vertices and edges\n        # are updated to match the new graph structure\n        for v in diff.changed_vertex_types:\n            self.vertex_map[v].refresh()\n\n        for v in diff.changed_phases:\n            self.vertex_map[v].refresh()\n\n        for v in diff.changed_pos:\n            v_item = self.vertex_map[v]\n            for anim in v_item.active_animations.copy():\n                anim.stop()\n            v_item.set_pos_from_graph()\n\n        for e in diff.changed_edge_types:\n            self.edge_map[e].refresh()\n\n        self.select_vertices(selected_vertices)\n\n    def add_items(self) -> None:\n        \"\"\"Add QGraphicsItem's for all vertices and edges in the graph\"\"\"\n        self.vertex_map = {}\n        for v in self.g.vertices():\n            vi = VItem(self, v)\n            self.vertex_map[v] = vi\n            self.addItem(vi)  # add the vertex to the scene\n            self.addItem(vi.phase_item)  # add the phase label to the scene\n        \n        self.edge_map = {}\n        for e in self.g.edges():\n            s, t = self.g.edge_st(e)\n            ei = EItem(self, e, self.vertex_map[s], self.vertex_map[t])\n            self.addItem(ei)\n            self.addItem(ei.selection_node)\n            self.edge_map[e] = ei\n\n    def select_all(self) -> None:\n        \"\"\"Selects all vertices and edges in the scene.\"\"\"\n        for it in self.items():\n            it.setSelected(True)", "class GraphScene(QGraphicsScene):\n    \"\"\"The main class responsible for drawing/editing graphs\"\"\"\n\n    g: GraphT\n\n    # Signals to handle double-clicking and moving of vertices.\n    # Note that we have to set the argument types to `object`,\n    # otherwise it doesn't work for some reason...\n    vertex_double_clicked = Signal(object)  # Actual type: VT\n    vertices_moved = Signal(object)  # Actual type: list[tuple[VT, float, float]]\n\n    # Triggers when a vertex is dragged onto or off of another vertex\n    # Actual types: DragState, VT, VT\n    vertex_dragged = Signal(object, object, object)\n\n    # Triggers when a vertex is dropped onto another vertex. Actual types: VT, VT\n    vertex_dropped_onto = Signal(object, object)\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.setSceneRect(0, 0, 2*OFFSET_X, 2*OFFSET_Y)\n        self.setBackgroundBrush(QBrush(QColor(255, 255, 255)))\n        self.vertex_map: Dict[VT, VItem] = {}\n        self.edge_map: Dict[ET, EItem] = {}\n\n    @property\n    def selected_vertices(self) -> Iterator[VT]:\n        \"\"\"An iterator over all currently selected vertices.\"\"\"\n        return (it.v for it in self.selectedItems() if isinstance(it, VItem))\n\n    @property\n    def selected_edges(self) -> Iterator[ET]:\n        return (it.e for it in self.selectedItems() if isinstance(it, EItem))\n\n    def select_vertices(self, vs: Iterable[VT]) -> None:\n        \"\"\"Selects the given collection of vertices.\"\"\"\n        self.clearSelection()\n        vs = set(vs)\n        for it in self.items():\n            if isinstance(it, VItem) and it.v in vs:\n                it.setSelected(True)\n                vs.remove(it.v)\n\n    def set_graph(self, g: GraphT) -> None:\n        \"\"\"Set the PyZX graph for the scene.\n        If the scene already contains a graph, it will be replaced.\"\"\"\n\n        self.g = g\n        # Stop all animations\n        for it in self.items():\n            if isinstance(it, VItem):\n                for anim in it.active_animations.copy():\n                    anim.stop()\n        self.clear()\n        self.add_items()\n        self.invalidate()\n\n    def update_graph(self, new: GraphT, select_new: bool = False) -> None:\n        \"\"\"Update the PyZX graph for the scene.\n        This will update the scene to match the given graph. It will\n        try to reuse existing QGraphicsItem's as much as possible.\n        \n        The selection is carried over to the updated graph.\n        \n        :param new: The new graph to update to.\n        :param select_new: If True, add all new vertices to the selection set.\"\"\"\n\n        selected_vertices = set(self.selected_vertices)\n\n        diff = GraphDiff(self.g, new)\n\n        removed_edges = set(diff.removed_edges)\n\n        for v in diff.removed_verts:\n            v_item = self.vertex_map[v]\n            if v_item.phase_item:\n                self.removeItem(v_item.phase_item)\n            for anim in v_item.active_animations.copy():\n                anim.stop()\n            for e in self.g.incident_edges(v):\n                removed_edges.add(e)\n\n            selected_vertices.discard(v)\n            self.removeItem(v_item)\n\n        for e in removed_edges:\n            e_item = self.edge_map[e]\n            if e_item.selection_node:\n                self.removeItem(e_item.selection_node)\n            self.removeItem(e_item)\n\n        new_g = diff.apply_diff(self.g)\n        assert isinstance(new_g, GraphS)\n        self.g = new_g\n        # g now contains the new graph,\n        # but we still need to update the scene\n        # However, the new vertices and edges automatically follow the new graph structure\n        \n        for v in diff.new_verts:\n            v_item = VItem(self, v)\n            self.vertex_map[v] = v_item\n            self.addItem(v_item)\n            self.addItem(v_item.phase_item)\n            if select_new:\n                selected_vertices.add(v)\n\n        for e in diff.new_edges:\n            s, t = self.g.edge_st(e)\n            e_item = EItem(self, e, self.vertex_map[s], self.vertex_map[t])\n            self.edge_map[e] = e_item\n            self.addItem(e_item)\n            self.addItem(e_item.selection_node)\n\n        # So we only have to make sure that the existing vertices and edges\n        # are updated to match the new graph structure\n        for v in diff.changed_vertex_types:\n            self.vertex_map[v].refresh()\n\n        for v in diff.changed_phases:\n            self.vertex_map[v].refresh()\n\n        for v in diff.changed_pos:\n            v_item = self.vertex_map[v]\n            for anim in v_item.active_animations.copy():\n                anim.stop()\n            v_item.set_pos_from_graph()\n\n        for e in diff.changed_edge_types:\n            self.edge_map[e].refresh()\n\n        self.select_vertices(selected_vertices)\n\n    def add_items(self) -> None:\n        \"\"\"Add QGraphicsItem's for all vertices and edges in the graph\"\"\"\n        self.vertex_map = {}\n        for v in self.g.vertices():\n            vi = VItem(self, v)\n            self.vertex_map[v] = vi\n            self.addItem(vi)  # add the vertex to the scene\n            self.addItem(vi.phase_item)  # add the phase label to the scene\n        \n        self.edge_map = {}\n        for e in self.g.edges():\n            s, t = self.g.edge_st(e)\n            ei = EItem(self, e, self.vertex_map[s], self.vertex_map[t])\n            self.addItem(ei)\n            self.addItem(ei.selection_node)\n            self.edge_map[e] = ei\n\n    def select_all(self) -> None:\n        \"\"\"Selects all vertices and edges in the scene.\"\"\"\n        for it in self.items():\n            it.setSelected(True)", "\n\nclass EditGraphScene(GraphScene):\n    \"\"\"A graph scene tracking additional mouse events for graph editing.\"\"\"\n\n    # Signals to handle addition of vertices and edges.\n    # Note that we have to set the argument types to `object`,\n    # otherwise it doesn't work for some reason...\n    vertex_added = Signal(object, object)  # Actual types: float, float\n    edge_added = Signal(object, object)  # Actual types: VT, VT\n\n    # Currently selected edge type for preview when dragging\n    # to add a new edge\n    curr_ety: EdgeType.Type\n    curr_tool: ToolType\n\n    # The vertex a right mouse button drag was initiated on\n    _drag: Optional[EDragItem]\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.curr_ety = EdgeType.SIMPLE\n        self.curr_tool = ToolType.SELECT\n        self._drag = None\n        self._is_dragging = False\n        self._is_mouse_pressed = False\n\n    def mousePressEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n        # Right-press on a vertex means the start of a drag for edge adding\n        super().mousePressEvent(e)\n        if (self.curr_tool == ToolType.EDGE) or \\\n            (self.curr_tool == ToolType.SELECT and e.button() == Qt.MouseButton.RightButton):\n            if self.items(e.scenePos(), deviceTransform=QTransform()):\n                for it in self.items(e.scenePos(), deviceTransform=QTransform()):\n                    if isinstance(it, VItem):\n                        self._drag = EDragItem(self.g, self.curr_ety, it, e.scenePos())\n                        self._drag.start.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, False)\n                        self.addItem(self._drag)\n        else:\n            e.ignore()\n        self._is_mouse_pressed = True\n\n    def mouseMoveEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n        super().mouseMoveEvent(e)\n        if self._drag:\n            self._drag.mouse_pos = e.scenePos()\n            self._drag.refresh()\n        else:\n            e.ignore()\n        if self._is_mouse_pressed:\n            self._is_dragging = True\n\n    def mouseReleaseEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n        super().mouseReleaseEvent(e)\n        isRightClickOnSelectTool = (self.curr_tool == ToolType.SELECT and \\\n                                    e.button() == Qt.MouseButton.RightButton)\n        if self._drag and (self.curr_tool == ToolType.EDGE or isRightClickOnSelectTool):\n            self._drag.start.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, True)\n            self.add_edge(e)\n        elif not self._is_dragging and (self.curr_tool == ToolType.VERTEX or isRightClickOnSelectTool):\n            self.add_vertex(e)\n        else:\n            e.ignore()\n        self._is_mouse_pressed = False\n        self._is_dragging = False\n\n    def add_vertex(self, e: QGraphicsSceneMouseEvent) -> None:\n        p = e.scenePos()\n        self.vertex_added.emit(*pos_from_view(p.x(), p.y()))\n\n    def add_edge(self, e: QGraphicsSceneMouseEvent) -> None:\n        assert self._drag is not None\n        self.removeItem(self._drag)\n        for it in self.items(e.scenePos(), deviceTransform=QTransform()):\n            # TODO: Think about if we want to allow self loops here?\n            #  For example, if had edge is selected this would mean that\n            #  right clicking adds pi to the phase...\n            if isinstance(it, VItem) and it != self._drag.start:\n                self.edge_added.emit(self._drag.start.v, it.v)\n        self._drag = None", ""]}
{"filename": "zxlive/__init__.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n#     Copyright (C) 2023 - Aleks Kissinger\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software", "\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom . import app\nfrom .graphview import GraphView", "from . import app\nfrom .graphview import GraphView\n"]}
{"filename": "zxlive/utils.py", "chunked_list": ["import os\n\n_ROOT = os.path.abspath(os.path.dirname(__file__))\n\n\ndef get_data(path: str) -> str:\n    return os.path.join(_ROOT, path)\n"]}
{"filename": "zxlive/vitem.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n#     Copyright (C) 2023 - Aleks Kissinger\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software", "\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import annotations\nfrom enum import Enum\n", "from enum import Enum\n\nfrom typing import Optional, Set, Any, TYPE_CHECKING, Union\n\nfrom PySide6.QtCore import Qt, QPointF, QVariantAnimation, QAbstractAnimation\nfrom PySide6.QtGui import QPen, QBrush,  QPainter, QColor, QFont, QPainterPath\nfrom PySide6.QtWidgets import QWidget, QGraphicsPathItem, QGraphicsTextItem, QGraphicsItem, \\\n     QStyle, QStyleOptionGraphicsItem, QGraphicsSceneMouseEvent\n\n", "\n\n\nfrom pyzx.graph.base import VertexType\nfrom pyzx.utils import phase_to_s\n\nfrom .common import VT, ET, GraphT, SCALE, pos_to_view, pos_from_view\n\nif TYPE_CHECKING:\n    from .eitem import EItem\n    from .graphscene import GraphScene", "if TYPE_CHECKING:\n    from .eitem import EItem\n    from .graphscene import GraphScene\n\n\nZX_GREEN = \"#ccffcc\"\nZX_GREEN_PRESSED = \"#64BC90\"\nZX_RED = \"#ff8888\"\nZX_RED_PRESSED = \"#bb0f0f\"\nH_YELLOW = \"#ffff00\"", "ZX_RED_PRESSED = \"#bb0f0f\"\nH_YELLOW = \"#ffff00\"\nH_YELLOW_PRESSED = \"#f1c232\"\n\n# Z values for different items. We use those to make sure that edges\n# are drawn below vertices and selected vertices above unselected\n# vertices during movement. Phase items are drawn on the very top.\nEITEM_Z = -1\nVITEM_UNSELECTED_Z = 0\nVITEM_SELECTED_Z = 1", "VITEM_UNSELECTED_Z = 0\nVITEM_SELECTED_Z = 1\nPHASE_ITEM_Z = 2\n\nclass DragState(Enum):\n        \"\"\"A vertex can be dragged onto another vertex, or if it was dragged onto\n         before, it can be dragged off of it again.\"\"\"\n        Onto = 0\n        OffOf = 1\n", "\n\nclass VItem(QGraphicsPathItem):\n    \"\"\"A QGraphicsItem representing a single vertex\"\"\"\n\n    v: VT\n    phase_item: PhaseItem\n    adj_items: Set[EItem]  # Connected edges\n    graph_scene: GraphScene\n\n    halftone = \"1000100010001000\" #QPixmap(\"images/halftone.png\")\n\n    # Set of animations that are currently running on this vertex\n    active_animations: set[VItemAnimation]\n\n    # Position before starting a drag-move\n    _old_pos: Optional[QPointF]\n\n    # Vertex we are currently dragged on top of\n    _dragged_on: Optional[VItem]\n\n    class Properties(Enum):\n        \"\"\"Properties of a VItem that can be animated.\"\"\"\n        Position = 0\n        Scale = 1\n        Rect = 2\n\n    def __init__(self, graph_scene: GraphScene, v: VT) -> None:\n        super().__init__()\n        self.setZValue(VITEM_UNSELECTED_Z)\n\n        self.graph_scene = graph_scene\n        self.v = v\n        self.setPos(*pos_to_view(self.g.row(v), self.g.qubit(v)))\n        self.adj_items: Set[EItem] = set()\n        self.phase_item = PhaseItem(self)\n        self.active_animations = set()\n\n        self._old_pos = None\n        self._dragged_on = None\n\n        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, True)\n        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable, True)\n        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges, True)\n\n        pen = QPen()\n        pen.setWidthF(3)\n        pen.setColor(QColor(\"black\"))\n        self.setPen(pen)\n\n        path = QPainterPath()\n        if self.g.type(self.v) == VertexType.H_BOX:\n            path.addRect(-0.2 * SCALE, -0.2 * SCALE, 0.4 * SCALE, 0.4 * SCALE)\n        else:\n            path.addEllipse(-0.2 * SCALE, -0.2 * SCALE, 0.4 * SCALE, 0.4 * SCALE)\n        self.setPath(path)\n        self.refresh()\n\n    @property\n    def g(self) -> GraphT:\n        return self.graph_scene.g\n\n    @property\n    def is_dragging(self) -> bool:\n        return self._old_pos is not None\n\n    @property\n    def is_animated(self) -> bool:\n        return len(self.active_animations) > 0\n\n    def refresh(self) -> None:\n        \"\"\"Call this method whenever a vertex moves or its data changes\"\"\"\n        if not self.isSelected():\n            t = self.g.type(self.v)\n            if t == VertexType.Z:\n                self.setBrush(QBrush(QColor(ZX_GREEN)))\n            elif t == VertexType.X:\n                self.setBrush(QBrush(QColor(ZX_RED)))\n            elif t == VertexType.H_BOX:\n                self.setBrush(QBrush(QColor(H_YELLOW)))\n            else:\n                self.setBrush(QBrush(QColor(\"#000000\")))\n            pen = QPen()\n            pen.setWidthF(3)\n            pen.setColor(QColor(\"black\"))\n            self.setPen(pen)\n\n        if self.isSelected():\n            pen = QPen()\n            pen.setWidthF(5)\n            t = self.g.type(self.v)\n            if t == VertexType.Z:\n                brush = QBrush(QColor(ZX_GREEN_PRESSED))\n                brush.setStyle(Qt.BrushStyle.Dense1Pattern)\n                self.setBrush(brush)\n            elif t == VertexType.X:\n                brush = QBrush(QColor(ZX_RED_PRESSED))\n                brush.setStyle(Qt.BrushStyle.Dense1Pattern)\n                self.setBrush(brush)\n            elif t == VertexType.H_BOX:\n                brush = QBrush(QColor(H_YELLOW_PRESSED))\n                brush.setStyle(Qt.BrushStyle.Dense1Pattern)\n                self.setBrush(brush)\n            else:\n                brush = QBrush(QColor(\"#444444\"))\n                brush.setStyle(Qt.BrushStyle.Dense1Pattern)\n                self.setBrush(brush)\n                pen.setColor(QColor(\"#444444\"))\n            self.setPen(pen)\n\n        if self.phase_item:\n            self.phase_item.refresh()\n\n        for e_item in self.adj_items:\n            e_item.refresh()\n\n    def set_pos_from_graph(self) -> None:\n        self.setPos(*pos_to_view(self.g.row(self.v), self.g.qubit(self.v)))\n\n    def paint(self, painter: QPainter, option: QStyleOptionGraphicsItem, widget: Optional[QWidget] = None) -> None:\n        # By default, Qt draws a dashed rectangle around selected items.\n        # We have our own implementation to draw selected vertices, so\n        # we intercept the selected option here.\n        option.state &= ~QStyle.StateFlag.State_Selected\n        super().paint(painter, option, widget)\n\n    def itemChange(self, change: QGraphicsItem.GraphicsItemChange, value: Any) -> Any:\n        # Snap items to grid on movement by intercepting the position-change\n        # event and returning a new position\n        if change == QGraphicsItem.GraphicsItemChange.ItemPositionChange and not self.is_animated:\n            assert isinstance(value, QPointF)\n            grid_size = SCALE / 8\n            x = round(value.x() / grid_size) * grid_size\n            y = round(value.y() / grid_size) * grid_size\n            return QPointF(x, y)\n\n        # When selecting/deselecting items, we move them to the front/back\n        if change == QGraphicsItem.GraphicsItemChange.ItemSelectedChange:\n            assert isinstance(value, int)  # 0 or 1\n            self.setZValue(VITEM_SELECTED_Z if value else VITEM_UNSELECTED_Z)\n            return value\n\n        # Intercept selection- and position-has-changed events to call `refresh`.\n        # Note that the position and selected values are already updated when\n        # this event fires.\n        if change in (QGraphicsItem.GraphicsItemChange.ItemSelectedHasChanged, QGraphicsItem.GraphicsItemChange.ItemPositionHasChanged):\n            # If we're being animated, the animation will decide for itself whether we\n            # should be refreshed or not\n            if not self.is_animated:\n                self.refresh()\n\n        return super().itemChange(change, value)\n\n    def mouseDoubleClickEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n        super().mouseDoubleClickEvent(e)\n        if self.is_animated:\n            return\n        scene = self.scene()\n        if TYPE_CHECKING: assert isinstance(scene, GraphScene)\n        scene.vertex_double_clicked.emit(self.v)\n\n    def mousePressEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n        super().mousePressEvent(e)\n        if self.is_animated:\n            return\n        self._old_pos = self.pos()\n\n    def mouseMoveEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n        super().mouseMoveEvent(e)\n        if self.is_animated:\n            return\n        scene = self.scene()\n        if TYPE_CHECKING: assert isinstance(scene, GraphScene)\n        if self.is_dragging and len(scene.selectedItems()) == 1:\n            reset = True\n            for it in scene.items():\n                if not it.sceneBoundingRect().intersects(self.sceneBoundingRect()):\n                    continue\n                if it == self._dragged_on:\n                    reset = False\n                elif isinstance(it, VItem) and it != self:\n                    scene.vertex_dragged.emit(DragState.Onto, self.v, it.v)\n                    # If we previously hovered over a vertex, notify the scene that we\n                    # are no longer\n                    if self._dragged_on is not None:\n                        scene.vertex_dragged.emit(DragState.OffOf, self.v, self._dragged_on.v)\n                    self._dragged_on = it\n                    return\n            if reset and self._dragged_on is not None:\n                scene.vertex_dragged.emit(DragState.OffOf, self.v, self._dragged_on.v)\n                self._dragged_on = None\n        e.ignore()\n\n    def mouseReleaseEvent(self, e: QGraphicsSceneMouseEvent) -> None:\n        # Unfortunately, Qt does not provide a \"MoveFinished\" event, so we have to\n        # manually detect mouse releases.\n        super().mouseReleaseEvent(e)\n        if self.is_animated:\n            return\n        if e.button() == Qt.MouseButton.LeftButton:\n            if self._old_pos != self.pos():\n                scene = self.scene()\n                if TYPE_CHECKING: assert isinstance(scene, GraphScene)\n                if self._dragged_on is not None and len(scene.selectedItems()) == 1:\n                    scene.vertex_dropped_onto.emit(self.v, self._dragged_on.v)\n                else:\n                    scene.vertices_moved.emit([\n                        (it.v, *pos_from_view(it.pos().x(),it.pos().y()))\n                        for it in scene.selectedItems() if isinstance(it, VItem)\n                    ])\n                self._dragged_on = None\n                self._old_pos = None\n        else:\n            e.ignore()", "\n\nclass VItemAnimation(QVariantAnimation):\n    \"\"\"Animator for vertex graphics items.\n\n    This animator lets the vertex know that its being animated which stops any\n    interaction with the user and disables grid snapping. Furthermore, this animator\n    ensures that it's not garbage collected until the animation is finished, so there is\n    no need to hold onto a reference of this class.\"\"\"\n\n    _it: Optional[VItem]\n    prop: VItem.Properties\n    refresh: bool  # Whether the item is refreshed at each frame\n\n    v: Optional[VT]\n\n    def __init__(self, item: Union[VItem, VT], property: VItem.Properties,\n                 scene: Optional[GraphScene] = None, refresh: bool = False) -> None:\n        super().__init__()\n        self.v = None\n        self._it = None\n        self.scene: Optional[GraphScene] = None\n        if refresh and property != VItem.Properties.Position:\n            raise ValueError(\"Only position animations require refresh\")\n        if isinstance(item, VItem):\n            self._it = item\n        elif scene is None:\n            raise ValueError(\"Scene is required to obtain VItem from vertex id\")\n        else:\n            self.v = item\n            self.scene = scene\n        self.prop = property\n        self.refresh = refresh\n        self.stateChanged.connect(self._on_state_changed)\n\n    @property\n    def it(self) -> VItem:\n        if self._it is None and self.scene is not None and self.v is not None:\n            self._it = self.scene.vertex_map[self.v]\n        assert self._it is not None\n        return self._it\n\n    def _on_state_changed(self, state: QAbstractAnimation.State) -> None:\n        if state == QAbstractAnimation.State.Running and self not in self.it.active_animations:\n            # Stop all animations that target the same property\n            for anim in self.it.active_animations.copy():\n                if anim.prop == self.prop:\n                    anim.stop()\n            self.it.active_animations.add(self)\n        elif state == QAbstractAnimation.State.Stopped:\n            self.it.active_animations.remove(self)\n        elif state == QAbstractAnimation.State.Paused:\n            # TODO: Once we use pausing, we should decide what to do here.\n            #   Note that we cannot just remove ourselves from the set since the garbage\n            #   collector will eat us in that case. We'll probably need something like\n            #   `it.paused_animations`\n            pass\n\n    def updateCurrentValue(self, value: Any) -> None:\n        if self.state() != QAbstractAnimation.State.Running:\n            return\n\n        if self.prop == VItem.Properties.Position:\n            self.it.setPos(value)\n        elif self.prop == VItem.Properties.Scale:\n            self.it.setScale(value)\n        elif self.prop == VItem.Properties.Rect:\n            self.it.setPath(value)\n\n        if self.refresh:\n            self.it.refresh()", "\n\nclass PhaseItem(QGraphicsTextItem):\n    \"\"\"A QGraphicsItem representing a phase label\"\"\"\n\n    def __init__(self, v_item: VItem) -> None:\n        super().__init__()\n        self.setZValue(PHASE_ITEM_Z)\n\n        self.setDefaultTextColor(QColor(\"#006bb3\"))\n        self.setFont(QFont(\"monospace\"))\n        self.v_item = v_item\n        self.refresh()\n\n    def refresh(self) -> None:\n        \"\"\"Call this when a vertex moves or its phase changes\"\"\"\n\n        phase = self.v_item.g.phase(self.v_item.v)\n        # phase = self.v_item.v\n        self.setPlainText(phase_to_s(phase, self.v_item.g.type(self.v_item.v)))\n        if self.v_item.g.type(self.v_item.v) == VertexType.BOUNDARY:\n            self.setPlainText(str(int(self.v_item.g.qubit(self.v_item.v))))\n        p = self.v_item.pos()\n        self.setPos(p.x(), p.y() - 0.6 * SCALE)", ""]}
{"filename": "zxlive/proof_actions.py", "chunked_list": ["import copy\nfrom dataclasses import dataclass, field, replace\nfrom typing import Callable, Literal, List, Optional, TYPE_CHECKING\n\nimport networkx as nx\nfrom networkx.algorithms.isomorphism import GraphMatcher, categorical_node_match\nimport numpy as np\nimport pyzx\nfrom pyzx.utils import VertexType, EdgeType\nfrom shapely import Polygon", "from pyzx.utils import VertexType, EdgeType\nfrom shapely import Polygon\n\nfrom PySide6.QtWidgets import QPushButton, QButtonGroup\n\nfrom . import animations as anims\nfrom .commands import AddRewriteStep\nfrom .common import ET, Graph, GraphT, VT\n\nif TYPE_CHECKING:\n    from .proof_panel import ProofPanel", "\nif TYPE_CHECKING:\n    from .proof_panel import ProofPanel\n\noperations = pyzx.editor.operations\n\nMatchType = Literal[1, 2]\n\n# Copied from pyzx.editor_actions\nMATCHES_VERTICES: MatchType = 1", "# Copied from pyzx.editor_actions\nMATCHES_VERTICES: MatchType = 1\nMATCHES_EDGES: MatchType = 2\n\n\n@dataclass\nclass ProofAction(object):\n    name: str\n    matcher: Callable[[GraphT, Callable], List]\n    rule: Callable[[GraphT, List], pyzx.rules.RewriteOutputType[ET,VT]]\n    match_type: MatchType\n    tooltip: str\n    button: Optional[QPushButton] = field(default=None, init=False)\n\n    @classmethod\n    def from_dict(cls, d: dict) -> \"ProofAction\":\n          return cls(d['text'], d['matcher'], d['rule'], d['type'], d['tooltip'])\n\n    def do_rewrite(self, panel: \"ProofPanel\") -> None:\n        verts, edges = panel.parse_selection()\n        g = copy.deepcopy(panel.graph_scene.g)\n\n        if self.match_type == MATCHES_VERTICES:\n            matches = self.matcher(g, lambda v: v in verts)\n        else:\n            matches = self.matcher(g, lambda e: e in edges)\n\n        etab, rem_verts, rem_edges, check_isolated_vertices = self.rule(g, matches)\n        g.remove_edges(rem_edges)\n        g.remove_vertices(rem_verts)\n        g.add_edge_table(etab)\n\n        cmd = AddRewriteStep(panel.graph_view, g, panel.step_view, self.name)\n\n        if self.name == operations['spider']['text']:\n            anim = anims.fuse(panel.graph_scene.vertex_map[verts[0]], panel.graph_scene.vertex_map[verts[1]])\n            panel.undo_stack.push(cmd, anim_before=anim)\n        elif self.name == operations['to_z']['text']:\n            print('To do: animate ' + self.name)\n            panel.undo_stack.push(cmd)\n        elif self.name == operations['to_x']['text']:\n            print('To do: animate ' + self.name)\n            panel.undo_stack.push(cmd)\n        elif self.name == operations['rem_id']['text']:\n            anim = anims.remove_id(panel.graph_scene.vertex_map[verts[0]])\n            panel.undo_stack.push(cmd, anim_before=anim)\n        elif self.name == operations['copy']['text']:\n            anim = anims.strong_comp(panel.graph, g, verts[0], panel.graph_scene)\n            panel.undo_stack.push(cmd, anim_after=anim)\n            # print('To do: animate ' + self.name)\n            # panel.undo_stack.push(cmd)\n        elif self.name == operations['pauli']['text']:\n            print('To do: animate ' + self.name)\n            panel.undo_stack.push(cmd)\n        elif self.name == operations['bialgebra']['text']:\n            anim = anims.strong_comp(panel.graph, g, verts[0], panel.graph_scene)\n            panel.undo_stack.push(cmd, anim_after=anim)\n        else:\n            panel.undo_stack.push(cmd)\n\n    def update_active(self, g: GraphT, verts: List[VT], edges: List[ET]) -> None:\n        if self.match_type == MATCHES_VERTICES:\n            matches = self.matcher(g, lambda v: v in verts)\n        else:\n            matches = self.matcher(g, lambda e: e in edges)\n\n        if self.button is None: return\n        if matches:\n            self.button.setEnabled(True)\n        else:\n            self.button.setEnabled(False)", "\n\nclass ProofActionGroup(object):\n    def __init__(self, *actions: ProofAction) -> None:\n        self.actions = actions\n        self.btn_group: Optional[QButtonGroup] = None\n        self.parent_panel = None\n\n    def copy(self) -> \"ProofActionGroup\":\n        copied_actions = []\n        for action in self.actions:\n            action_copy = replace(action)\n            action_copy.button = None\n            copied_actions.append(action_copy)\n        return ProofActionGroup(*copied_actions)\n\n    def init_buttons(self, parent: \"ProofPanel\") -> None:\n        self.btn_group = QButtonGroup(parent, exclusive=False)\n        def create_rewrite(action: ProofAction, parent: \"ProofPanel\") -> Callable[[], None]: # Needed to prevent weird bug with closures in signals\n            def rewriter() -> None:\n                action.do_rewrite(parent)\n            return rewriter\n        for action in self.actions:\n            if action.button is not None: continue\n            btn = QPushButton(action.name, parent)\n            btn.setMaximumWidth(150)\n            btn.setStatusTip(action.tooltip)\n            btn.setEnabled(False)\n            btn.clicked.connect(create_rewrite(action, parent))\n            self.btn_group.addButton(btn)\n            action.button = btn\n\n    def update_active(self, g: GraphT, verts: List[VT], edges: List[ET]) -> None:\n        for action in self.actions:\n            action.update_active(g, verts, edges)", "\n\ndef to_networkx(graph: Graph) -> nx.Graph:\n    G = nx.Graph()\n    v_data = {v: {\"type\": graph.type(v),\n                  \"phase\": graph.phase(v),}\n              for v in graph.vertices()}\n    for i, input_vertex in enumerate(graph.inputs()):\n        v_data[input_vertex][\"boundary_index\"] = f'input_{i}'\n    for i, output_vertex in enumerate(graph.outputs()):\n        v_data[output_vertex][\"boundary_index\"] = f'output_{i}'\n    G.add_nodes_from([(v, v_data[v]) for v in graph.vertices()])\n    G.add_edges_from([(*v, {\"type\": graph.edge_type(v)}) for v in  graph.edges()])\n    return G", "\ndef create_subgraph(graph: Graph, verts: List[VT]) -> nx.Graph:\n    graph_nx = to_networkx(graph)\n    subgraph_nx = nx.Graph(graph_nx.subgraph(verts))\n    boundary_mapping = {}\n    i = 0\n    for v in verts:\n        for vn in graph.neighbors(v):\n            if vn not in verts:\n                boundary_node = 'b' + str(i)\n                boundary_mapping[boundary_node] = vn\n                subgraph_nx.add_node(boundary_node, type=VertexType.BOUNDARY)\n                subgraph_nx.add_edge(v, boundary_node, type=EdgeType.SIMPLE)\n                i += 1\n    return subgraph_nx, boundary_mapping", "\ndef custom_matcher(graph: Graph, in_selection: Callable[[VT], bool], lhs_graph: nx.Graph) -> List[VT]:\n    verts = [v for v in graph.vertices() if in_selection(v)]\n    subgraph_nx, _ = create_subgraph(graph, verts)\n    graph_matcher = GraphMatcher(lhs_graph, subgraph_nx,\\\n        node_match=categorical_node_match(['type', 'phase'], default=[1, 0]))\n    if graph_matcher.is_isomorphic():\n        return verts\n    return []\n\ndef custom_rule(graph: Graph, vertices: List[VT], lhs_graph: nx.Graph, rhs_graph: nx.Graph) -> pyzx.rules.RewriteOutputType[ET,VT]:\n    subgraph_nx, boundary_mapping = create_subgraph(graph, vertices)\n    graph_matcher = GraphMatcher(lhs_graph, subgraph_nx,\\\n        node_match=categorical_node_match(['type', 'phase'], default=[1, 0]))\n    matching = list(graph_matcher.match())[0]\n\n    vertices_to_remove = []\n    for v in matching:\n        if subgraph_nx.nodes()[matching[v]]['type'] != VertexType.BOUNDARY:\n            vertices_to_remove.append(matching[v])\n\n    boundary_vertex_map = {}\n    for v in rhs_graph.nodes():\n        if rhs_graph.nodes()[v]['type'] == VertexType.BOUNDARY:\n            for x, data in lhs_graph.nodes(data=True):\n                if data['type'] == VertexType.BOUNDARY and \\\n                    data['boundary_index'] == rhs_graph.nodes()[v]['boundary_index']:\n                    boundary_vertex_map[v] = boundary_mapping[matching[x]]\n                    break\n\n    vertex_positions = get_vertex_positions(graph, rhs_graph, boundary_vertex_map)\n    vertex_map = boundary_vertex_map\n    for v in rhs_graph.nodes():\n        if rhs_graph.nodes()[v]['type'] != VertexType.BOUNDARY:\n            vertex_map[v] = graph.add_vertex(ty = rhs_graph.nodes()[v]['type'],\n                                             row = vertex_positions[v][0],\n                                             qubit = vertex_positions[v][1],\n                                             phase = rhs_graph.nodes()[v]['phase'],)\n\n    # create etab to add edges\n    etab = {}\n    for v1, v2, data in rhs_graph.edges(data=True):\n        v1 = vertex_map[v1]\n        v2 = vertex_map[v2]\n        if (v1, v2) not in etab: etab[(v1, v2)] = [0, 0]\n        etab[(v1, v2)][data['type']-1] += 1\n\n    return etab, vertices_to_remove, [], True", "\ndef custom_rule(graph: Graph, vertices: List[VT], lhs_graph: nx.Graph, rhs_graph: nx.Graph) -> pyzx.rules.RewriteOutputType[ET,VT]:\n    subgraph_nx, boundary_mapping = create_subgraph(graph, vertices)\n    graph_matcher = GraphMatcher(lhs_graph, subgraph_nx,\\\n        node_match=categorical_node_match(['type', 'phase'], default=[1, 0]))\n    matching = list(graph_matcher.match())[0]\n\n    vertices_to_remove = []\n    for v in matching:\n        if subgraph_nx.nodes()[matching[v]]['type'] != VertexType.BOUNDARY:\n            vertices_to_remove.append(matching[v])\n\n    boundary_vertex_map = {}\n    for v in rhs_graph.nodes():\n        if rhs_graph.nodes()[v]['type'] == VertexType.BOUNDARY:\n            for x, data in lhs_graph.nodes(data=True):\n                if data['type'] == VertexType.BOUNDARY and \\\n                    data['boundary_index'] == rhs_graph.nodes()[v]['boundary_index']:\n                    boundary_vertex_map[v] = boundary_mapping[matching[x]]\n                    break\n\n    vertex_positions = get_vertex_positions(graph, rhs_graph, boundary_vertex_map)\n    vertex_map = boundary_vertex_map\n    for v in rhs_graph.nodes():\n        if rhs_graph.nodes()[v]['type'] != VertexType.BOUNDARY:\n            vertex_map[v] = graph.add_vertex(ty = rhs_graph.nodes()[v]['type'],\n                                             row = vertex_positions[v][0],\n                                             qubit = vertex_positions[v][1],\n                                             phase = rhs_graph.nodes()[v]['phase'],)\n\n    # create etab to add edges\n    etab = {}\n    for v1, v2, data in rhs_graph.edges(data=True):\n        v1 = vertex_map[v1]\n        v2 = vertex_map[v2]\n        if (v1, v2) not in etab: etab[(v1, v2)] = [0, 0]\n        etab[(v1, v2)][data['type']-1] += 1\n\n    return etab, vertices_to_remove, [], True", "\ndef get_vertex_positions(graph, rhs_graph, boundary_vertex_map):\n    pos_dict = {v: (graph.row(m), graph.qubit(m)) for v, m in boundary_vertex_map.items()}\n    coords = np.array(list(pos_dict.values()))\n    center = np.mean(coords, axis=0)\n    angles = np.arctan2(coords[:,1]-center[1], coords[:,0]-center[0])\n    coords = coords[np.argsort(-angles)]\n    try:\n        area = Polygon(coords).area\n    except:\n        area = 1\n    k = (area ** 0.5) / len(rhs_graph)\n    return nx.spring_layout(rhs_graph, k=k, pos=pos_dict, fixed=boundary_vertex_map.keys())", "\ndef create_custom_matcher(lhs_graph: Graph) -> Callable[[Graph, Callable[[VT], bool]], List[VT]]:\n    lhs_graph.auto_detect_io()\n    return lambda g, selection: custom_matcher(g, selection, to_networkx(lhs_graph))\n\ndef create_custom_rule(lhs_graph: Graph, rhs_graph: Graph) -> Callable[[Graph, List[VT]], pyzx.rules.RewriteOutputType[ET,VT]]:\n    lhs_graph.auto_detect_io()\n    rhs_graph.auto_detect_io()\n    return lambda g, verts: custom_rule(g, verts, to_networkx(lhs_graph), to_networkx(rhs_graph))\n", "\n\nspider_fuse = ProofAction.from_dict(operations['spider'])\nto_z = ProofAction.from_dict(operations['to_z'])\nto_x = ProofAction.from_dict(operations['to_x'])\nrem_id = ProofAction.from_dict(operations['rem_id'])\ncopy_action = ProofAction.from_dict(operations['copy'])\npauli = ProofAction.from_dict(operations['pauli'])\nbialgebra = ProofAction.from_dict(operations['bialgebra'])\n", "bialgebra = ProofAction.from_dict(operations['bialgebra'])\n\nrewrites = [spider_fuse, to_z, to_x, rem_id, copy_action, pauli, bialgebra]\n"]}
{"filename": "zxlive/dialogs.py", "chunked_list": ["from __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional, Tuple\nfrom dataclasses import dataclass\n\nfrom PySide6.QtCore import QFile, QIODevice, QTextStream\nfrom PySide6.QtWidgets import QWidget, QFileDialog, QMessageBox, QDialog, QFormLayout, QLineEdit, QTextEdit, QPushButton, QDialogButtonBox\nimport numpy as np\nfrom pyzx import Circuit, extract_circuit", "import numpy as np\nfrom pyzx import Circuit, extract_circuit\nfrom pyzx.graph.base import BaseGraph\nfrom zxlive import proof_actions\n\nfrom zxlive.proof import ProofModel\n\nfrom .common import VT,ET, GraphT, Graph\n\n\nclass FileFormat(Enum):\n    \"\"\"Supported formats for importing/exporting diagrams.\"\"\"\n\n    All = \"zxg *.json *.qasm *.tikz *.zxp\", \"All Supported Formats\"\n    QGraph = \"zxg\", \"QGraph\"  # \"file extension\", \"format name\"\n    QASM = \"qasm\", \"QASM\"\n    TikZ = \"tikz\", \"TikZ\"\n    Json = \"json\", \"JSON\"\n    ZXProof = \"zxp\", \"ZXProof\"\n    _value_: str\n\n    def __new__(cls, *args, **kwds):  # type: ignore\n        obj = object.__new__(cls)\n        obj._value_ = args[0]  # Use extension as `_value_`\n        return obj\n\n    def __init__(self, _extension: str, name: str) -> None:\n        # Ignore extension param since it's already set by `__new__`\n        self._name = name\n\n    @property\n    def extension(self) -> str:\n        \"\"\"The file extension for this format.\n\n        The extension is returned *without* a leading dot.\"\"\"\n        return self._value_\n\n    @property\n    def name(self) -> str:\n        \"\"\"The text used to display this file format.\"\"\"\n        return self._name_\n\n    @property\n    def filter(self) -> str:\n        \"\"\"The filter string for this file type.\n\n        Used by `QFileDialog` to filter the shown file extensions.\"\"\"\n        return f\"{self.name} (*.{self.extension})\"", "\n\nclass FileFormat(Enum):\n    \"\"\"Supported formats for importing/exporting diagrams.\"\"\"\n\n    All = \"zxg *.json *.qasm *.tikz *.zxp\", \"All Supported Formats\"\n    QGraph = \"zxg\", \"QGraph\"  # \"file extension\", \"format name\"\n    QASM = \"qasm\", \"QASM\"\n    TikZ = \"tikz\", \"TikZ\"\n    Json = \"json\", \"JSON\"\n    ZXProof = \"zxp\", \"ZXProof\"\n    _value_: str\n\n    def __new__(cls, *args, **kwds):  # type: ignore\n        obj = object.__new__(cls)\n        obj._value_ = args[0]  # Use extension as `_value_`\n        return obj\n\n    def __init__(self, _extension: str, name: str) -> None:\n        # Ignore extension param since it's already set by `__new__`\n        self._name = name\n\n    @property\n    def extension(self) -> str:\n        \"\"\"The file extension for this format.\n\n        The extension is returned *without* a leading dot.\"\"\"\n        return self._value_\n\n    @property\n    def name(self) -> str:\n        \"\"\"The text used to display this file format.\"\"\"\n        return self._name_\n\n    @property\n    def filter(self) -> str:\n        \"\"\"The filter string for this file type.\n\n        Used by `QFileDialog` to filter the shown file extensions.\"\"\"\n        return f\"{self.name} (*.{self.extension})\"", "\n@dataclass\nclass ImportGraphOutput:\n    file_type: FileFormat\n    file_path: str\n    g: GraphT\n\n@dataclass\nclass ImportProofOutput:\n    file_type: FileFormat\n    file_path: str\n    p: ProofModel", "class ImportProofOutput:\n    file_type: FileFormat\n    file_path: str\n    p: ProofModel\n\ndef show_error_msg(title: str, description: Optional[str] = None) -> None:\n    \"\"\"Displays an error message box.\"\"\"\n    msg = QMessageBox()\n    msg.setText(title)\n    msg.setIcon(QMessageBox.Icon.Critical)\n    if description is not None:\n        msg.setInformativeText(description)\n    msg.exec()", "\ndef import_diagram_dialog(parent: QWidget) -> Optional[ImportGraphOutput | ImportProofOutput]:\n    \"\"\"Shows a dialog to import a diagram from disk.\n\n    Returns the imported graph or `None` if the import failed.\"\"\"\n    file_path, selected_filter = QFileDialog.getOpenFileName(\n        parent=parent,\n        caption=\"Open File\",\n        filter=\";;\".join([f.filter for f in FileFormat]),\n    )\n    if selected_filter == \"\":\n        # This happens if the user clicks on cancel\n        return None\n    selected_format = next(f for f in FileFormat if f.filter == selected_filter)\n\n    file = QFile(file_path)\n    if not file.open(QIODevice.OpenModeFlag.ReadOnly | QIODevice.OpenModeFlag.Text):\n        show_error_msg(\"Could not open file\")\n        return None\n    stream = QTextStream(file)\n    data = stream.readAll()\n    file.close()\n\n    ext = file_path.split(\".\")[-1]\n    selected_format = next(f for f in FileFormat if f.filter == selected_filter)\n    if selected_format == FileFormat.All:\n        selected_format = next(f for f in FileFormat if f.extension == ext)\n\n    # TODO: This would be nicer with match statements...\n    try:\n        if selected_format == FileFormat.ZXProof:\n            return ImportProofOutput(selected_format, file_path, ProofModel.from_json(data))\n        elif selected_format in (FileFormat.QGraph, FileFormat.Json):\n            return ImportGraphOutput(selected_format, file_path, Graph.from_json(data))  # type: ignore # This is something that needs to be better annotated in PyZX\n        elif selected_format == FileFormat.QASM:\n            return ImportGraphOutput(selected_format, file_path, Circuit.from_qasm(data).to_graph()) # type: ignore\n        elif selected_format == FileFormat.TikZ:\n            return ImportGraphOutput(selected_format, file_path, Graph.from_tikz(data))  # type: ignore\n        else:\n            assert selected_format == FileFormat.All\n            try:\n                circ = Circuit.load(file_path)\n                return ImportGraphOutput(FileFormat.QASM, file_path, circ.to_graph())  # type: ignore\n            except TypeError:\n                try:\n                    return ImportGraphOutput(FileFormat.QGraph, file_path, Graph.from_json(data))  # type: ignore\n                except Exception:\n                    try:\n                        return ImportGraphOutput(FileFormat.TikZ, file_path, Graph.from_tikz(data))  # type: ignore\n                    except:\n                        show_error_msg(f\"Failed to import {selected_format.name} file\", \"Couldn't determine filetype.\")\n                        return None\n\n    except Exception as e:\n        show_error_msg(f\"Failed to import {selected_format.name} file\", str(e))\n        return None", "\ndef write_to_file(file_path: str, data: str) -> bool:\n    file = QFile(file_path)\n    if not file.open(QIODevice.OpenModeFlag.WriteOnly | QIODevice.OpenModeFlag.Text):\n        show_error_msg(\"Could not write to file\")\n        return False\n    out = QTextStream(file)\n    out << data\n    file.close()\n    return True", "\n\ndef get_file_path_and_format(parent: QWidget, filter: str) -> Optional[Tuple[str, FileFormat]]:\n    file_path, selected_filter = QFileDialog.getSaveFileName(\n        parent=parent,\n        caption=\"Save File\",\n        filter=filter,\n    )\n    if selected_filter == \"\":\n        # This happens if the user clicks on cancel\n        return None\n\n    ext = file_path.split(\".\")[-1]\n    selected_format = next(f for f in FileFormat if f.filter == selected_filter)\n    if selected_format == FileFormat.All:\n        selected_format = next(f for f in FileFormat if f.extension == ext)\n\n    # Add file extension if it's not already there\n    if file_path.split(\".\")[-1].lower() != selected_format.extension:\n        file_path += \".\" + selected_format.extension\n\n    return file_path, selected_format", "\ndef export_diagram_dialog(graph: GraphT, parent: QWidget) -> Optional[Tuple[str, FileFormat]]:\n    file_path_and_format = get_file_path_and_format(parent, \";;\".join([f.filter for f in FileFormat if f != FileFormat.ZXProof]))\n    if file_path_and_format is None or not file_path_and_format[0]:\n        return None\n    file_path, selected_format = file_path_and_format\n\n    if selected_format in (FileFormat.QGraph, FileFormat.Json):\n        data = graph.to_json()\n    elif selected_format == FileFormat.QASM:\n        try:\n            circuit = extract_circuit(graph)\n        except Exception as e:\n            show_error_msg(\"Failed to convert the diagram to a circuit\", str(e))\n            return None\n        data = circuit.to_qasm()\n    else:\n        assert selected_format == FileFormat.TikZ\n        data = graph.to_tikz()\n\n    if not write_to_file(file_path, data):\n        return None\n\n    return file_path, selected_format", "\ndef export_proof_dialog(proof_model: ProofModel, parent: QWidget) -> Optional[Tuple[str, FileFormat]]:\n    file_path_and_format = get_file_path_and_format(parent, FileFormat.ZXProof.filter)\n    if file_path_and_format is None or not file_path_and_format[0]:\n        return None\n    file_path, selected_format = file_path_and_format\n    data = proof_model.to_json()\n    if not write_to_file(file_path, data):\n        return None\n    return file_path, selected_format", "\ndef create_new_rewrite(parent) -> None:\n    dialog = QDialog()\n    parent.rewrite_form = QFormLayout(dialog)\n    name = QLineEdit()\n    parent.rewrite_form.addRow(\"Name\", name)\n    description = QTextEdit()\n    parent.rewrite_form.addRow(\"Description\", description)\n    left_button = QPushButton(\"Left-hand side of the rule\")\n    right_button = QPushButton(\"Right-hand side of the rule\")\n    parent.left_graph = None\n    parent.right_graph = None\n    def get_file(self, button, side) -> None:\n        out = import_diagram_dialog(self)\n        if out is not None:\n            button.setText(out.file_path)\n            if side == \"left\":\n                self.left_graph = out.g\n            else:\n                self.right_graph = out.g\n    left_button.clicked.connect(lambda: get_file(parent, left_button, \"left\"))\n    right_button.clicked.connect(lambda: get_file(parent, right_button, \"right\"))\n    parent.rewrite_form.addRow(left_button)\n    parent.rewrite_form.addRow(right_button)\n    button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)\n    parent.rewrite_form.addRow(button_box)\n    def add_rewrite() -> None:\n        if parent.left_graph is None or parent.right_graph is None:\n            return\n        parent.left_graph.auto_detect_io()\n        parent.right_graph.auto_detect_io()\n        left_matrix, right_matrix = parent.left_graph.to_matrix(), parent.right_graph.to_matrix()\n        if not np.allclose(left_matrix, right_matrix):\n            if np.allclose(left_matrix / np.linalg.norm(left_matrix), right_matrix / np.linalg.norm(right_matrix)):\n                show_error_msg(\"Warning!\", \"The left-hand side and right-hand side of the rule differ by a scalar.\")\n            else:\n                show_error_msg(\"Warning!\", \"The left-hand side and right-hand side of the rule have different semantics.\")\n        rewrite = proof_actions.ProofAction.from_dict({\n            \"text\":name.text(),\n            \"tooltip\":description.toPlainText(),\n            \"matcher\": proof_actions.create_custom_matcher(parent.left_graph),\n            \"rule\": proof_actions.create_custom_rule(parent.left_graph, parent.right_graph),\n            \"type\": proof_actions.MATCHES_VERTICES,\n        })\n        proof_actions.rewrites.append(rewrite)\n        dialog.accept()\n    button_box.accepted.connect(add_rewrite)\n    button_box.rejected.connect(dialog.reject)\n    if not dialog.exec(): return", ""]}
{"filename": "zxlive/commands.py", "chunked_list": ["from dataclasses import dataclass, field\nfrom fractions import Fraction\nfrom typing import Optional, Iterable, Set, Union, List, Any\nimport copy\n\nfrom PySide6.QtCore import QItemSelection, QModelIndex, QItemSelectionModel, \\\n    QSignalBlocker\nfrom PySide6.QtGui import QUndoCommand\nfrom PySide6.QtWidgets import QListView\n", "from PySide6.QtWidgets import QListView\n\nfrom pyzx import basicrules\nfrom pyzx.graph import GraphDiff\nfrom pyzx.utils import EdgeType, VertexType\n\nfrom .common import VT, ET, GraphT\nfrom .graphview import GraphView\nfrom .proof import ProofModel, Rewrite\n", "from .proof import ProofModel, Rewrite\n\n\n@dataclass\nclass BaseCommand(QUndoCommand):\n    \"\"\"Abstract base class for all commands.\n\n    Each command has a reference to the graph view whose graph it\n    modifies. This allows the command to notify the view that the\n    graph has changed and requires redrawing.\"\"\"\n    graph_view: GraphView\n\n    def __post_init__(self) -> None:\n        # We need to make sure that `__init__` of the super `QUndoCommand`\n        # is being called, but a normal dataclass doesn't do that.\n        # Overriding `__init__` also doesn't work since the command sub-\n        # dataclasses don't call modified super constructors. Thus, we\n        # hook it into `__post_init__`.\n        super().__init__()\n        self.g = copy.deepcopy(self.graph_view.graph_scene.g)\n        \n    def update_graph_view(self, select_new: bool = False) -> None:\n        \"\"\"Notifies the graph view that graph needs to be redrawn.\n\n        :param select_new: If True, add all new vertices to the selection set.\n        \"\"\"\n        # TODO: For performance reasons, we should track which parts\n        #  of the graph have changed and only update those. For example\n        #  we could store \"dirty flags\" for each node/edge.\n        self.graph_view.update_graph(self.g, select_new)", "\n\n@dataclass\nclass SetGraph(BaseCommand):\n    \"\"\"Replaces the current graph with an entirely new graph.\"\"\"\n    new_g: GraphT\n    old_g: Optional[GraphT] = field(default=None, init=False)\n\n    def undo(self) -> None:\n        assert self.old_g is not None\n        self.graph_view.set_graph(self.old_g)\n\n    def redo(self) -> None:\n        self.old_g = self.graph_view.graph_scene.g\n        self.graph_view.set_graph(self.new_g)", "\n\n@dataclass\nclass UpdateGraph(BaseCommand):\n    \"\"\"Updates the current graph with a modified one.\n    It will try to reuse existing QGraphicsItem's as much as possible.\"\"\"\n    new_g: GraphT\n    old_g: Optional[GraphT] = field(default=None, init=False)\n    old_selected: Optional[Set[VT]] = field(default=None, init=False)\n\n    def undo(self) -> None:\n        assert self.old_g is not None and self.old_selected is not None\n        self.g = self.old_g\n        self.update_graph_view()\n        self.graph_view.graph_scene.select_vertices(self.old_selected)\n\n    def redo(self) -> None:\n        self.old_g = self.graph_view.graph_scene.g\n        self.old_selected = set(self.graph_view.graph_scene.selected_vertices)\n        self.g = self.new_g\n        self.update_graph_view(True)", "\n\n@dataclass\nclass ChangeNodeColor(BaseCommand):\n    \"\"\"Changes the color of a set of spiders.\"\"\"\n    vs: Iterable[VT]\n    vty: VertexType.Type\n\n    _old_vtys: Optional[list[VertexType]] = field(default=None, init=False)\n\n    def undo(self) -> None:\n        assert self._old_vtys is not None\n        for v, old_vty in zip(self.vs, self._old_vtys):  # TODO: strict=True in Python 3.10\n            self.g.set_type(v, old_vty)\n        self.update_graph_view()\n\n    def redo(self) -> None:\n        self._old_vtys = [self.g.type(v) for v in self.vs]\n        for v in self.vs:\n            self.g.set_type(v, self.vty)\n        self.update_graph_view()", "\n\n@dataclass\nclass ChangeEdgeColor(BaseCommand):\n    \"\"\"Changes the color of a set of edges\"\"\"\n    es: Iterable[ET]\n    ety: EdgeType.Type\n\n    _old_etys: Optional[list[EdgeType]] = field(default=None, init=False)\n\n    def undo(self) -> None:\n        assert self._old_etys is not None\n        for e, old_ety in zip(self.es, self._old_etys):  # TODO: strict=True in Python 3.10\n            self.g.set_edge_type(e, old_ety)\n        self.update_graph_view()\n\n    def redo(self) -> None:\n        self._old_etys = [self.g.edge_type(e) for e in self.es]\n        for e in self.es:\n            self.g.set_edge_type(e, self.ety)\n        self.update_graph_view()", "\n\n@dataclass\nclass AddNode(BaseCommand):\n    \"\"\"Adds a new spider at a given position.\"\"\"\n    x: float\n    y: float\n    vty: VertexType.Type\n\n    _added_vert: Optional[VT] = field(default=None, init=False)\n\n    def undo(self) -> None:\n        assert self._added_vert is not None\n        self.g.remove_vertex(self._added_vert)\n        self.update_graph_view()\n\n    def redo(self) -> None:\n        self._added_vert = self.g.add_vertex(self.vty, self.y, self.x)\n        self.update_graph_view()", "\n\n@dataclass\nclass AddEdge(BaseCommand):\n    \"\"\"Adds an edge between two spiders.\"\"\"\n    u: VT\n    v: VT\n    ety: EdgeType.Type\n\n    _old_ety: Optional[EdgeType.Type] = field(default=None, init=False)\n\n    def undo(self) -> None:\n        u, v = self.u, self.v\n        e = self.g.edge(u, v)\n        if self._old_ety:\n            self.g.add_edge(e, self._old_ety)\n        else:\n            self.g.remove_edge(e)\n        self.update_graph_view()\n\n    def redo(self) -> None:\n        u, v = self.u, self.v\n        e = self.g.edge(u, v)\n        if self.g.connected(u, v):\n            self._old_ety = self.g.edge_type(e)\n            self.g.set_edge_type(e, self.ety)\n        else:\n            self._old_ety = None\n            self.g.add_edge(e, self.ety)\n        self.update_graph_view()", "\n\n@dataclass\nclass MoveNode(BaseCommand):\n    \"\"\"Updates the location of a collection of nodes.\"\"\"\n    vs: list[tuple[VT, float, float]]\n\n    _old_positions: Optional[list[tuple[float, float]]] = field(default=None, init=False)\n\n    def undo(self) -> None:\n        assert self._old_positions is not None\n        for (v, _, _), (x, y) in zip(self.vs, self._old_positions):\n            self.g.set_row(v, x)\n            self.g.set_qubit(v, y)\n        self.update_graph_view()\n\n    def redo(self) -> None:\n        self._old_positions = []\n        for v, x, y in self.vs:\n            self._old_positions.append((self.g.row(v), self.g.qubit(v)))\n            self.g.set_row(v, x)\n            self.g.set_qubit(v, y)\n        self.update_graph_view()", "\n\n@dataclass\nclass AddIdentity(BaseCommand):\n    \"\"\"Adds an X or Z identity spider on an edge between two vertices.\"\"\"\n    u: VT\n    v: VT\n    vty: VertexType.Type\n\n    _new_vert: Optional[VT] = field(default=None, init=False)\n\n    def undo(self) -> None:\n        u, v, w = self.u, self.v, self._new_vert\n        assert w is not None\n        g = self.g\n        et = g.edge_type(g.edge(v, w))\n        g.remove_edge(g.edge(u, w))\n        g.remove_edge(g.edge(v, w))\n        g.remove_vertex(w)\n        g.add_edge(g.edge(u, v), et)\n        self.update_graph_view()\n\n    def redo(self) -> None:\n        u, v = self.u, self.v\n        g = self.g\n        uv = g.edge(u, v)\n        r = 0.5 * (g.row(u) + g.row(v))\n        q = 0.5 * (g.qubit(u) + g.qubit(v))\n        self._new_vert = g.add_vertex(self.vty, q, r, 0)\n\n        g.add_edge(g.edge(u, self._new_vert))\n        g.add_edge(g.edge(v, self._new_vert), g.edge_type(uv))\n        g.remove_edge(uv)\n        self.update_graph_view()", "\n\n@dataclass\nclass ChangePhase(BaseCommand):\n    \"\"\"Updates the phase of a spider.\"\"\"\n    v: VT\n    new_phase: Union[Fraction, int]\n\n    _old_phase: Optional[Union[Fraction, int]] = field(default=None, init=False)\n\n    def undo(self) -> None:\n        assert self._old_phase is not None\n        self.g.set_phase(self.v, self._old_phase)\n        self.update_graph_view()\n\n    def redo(self) -> None:\n        self._old_phase = self.g.phase(self.v)\n        self.g.set_phase(self.v, self.new_phase)\n        self.update_graph_view()", "\n\n@dataclass\nclass ChangeColor(BaseCommand):\n    \"\"\"Applies the color-change rule on a set of vertices.\n\n    Changes the spider type using Hadamard conjugation.\"\"\"\n    vs: Iterable[VT]\n\n    def toggle(self) -> None:\n        for v in self.vs:\n            basicrules.color_change(self.g, v)\n        self.update_graph_view()\n\n    undo = redo = toggle", "\n\n@dataclass\nclass AddRewriteStep(SetGraph):\n    \"\"\"Adds a new rewrite to the proof.\n\n    The rewrite is inserted after the currently selected step. In particular, it\n    replaces all rewrites that were previously after the current selection.\n    \"\"\"\n    step_view: QListView\n    name: str\n    diff: Optional[GraphDiff] = None\n\n    _old_selected: Optional[int] = field(default=None, init=False)\n    _old_steps: list[tuple[Rewrite, GraphT]] = field(default_factory=list, init=False)\n\n    @property\n    def proof_model(self) -> ProofModel:\n        model = self.step_view.model()\n        assert isinstance(model, ProofModel)\n        return model\n\n    def redo(self) -> None:\n        # Remove steps from the proof model until we're at the currently selected step\n        self._old_selected = self.step_view.currentIndex().row()\n        self._old_steps = []\n        for _ in range(self.proof_model.rowCount() - self._old_selected - 1):\n            self._old_steps.append(self.proof_model.pop_rewrite())\n\n        diff = self.diff or GraphDiff(self.g, self.new_g)\n        self.proof_model.add_rewrite(Rewrite(self.name, diff), self.new_g)\n\n        # Select the added step\n        idx = self.step_view.model().index(self.proof_model.rowCount() - 1, 0, QModelIndex())\n        self.step_view.selectionModel().blockSignals(True)\n        self.step_view.setCurrentIndex(idx)\n        self.step_view.selectionModel().blockSignals(False)\n        super().redo()\n\n    def undo(self) -> None:\n        # Undo the rewrite\n        self.step_view.selectionModel().blockSignals(True)\n        self.proof_model.pop_rewrite()\n        self.step_view.selectionModel().blockSignals(False)\n\n        # Add back steps that were previously removed\n        for rewrite, graph in reversed(self._old_steps):\n            self.proof_model.add_rewrite(rewrite, graph)\n\n        # Select the previously selected step\n        assert self._old_selected is not None\n        idx = self.step_view.model().index(self._old_selected, 0, QModelIndex())\n        self.step_view.selectionModel().blockSignals(True)\n        self.step_view.setCurrentIndex(idx)\n        self.step_view.selectionModel().blockSignals(False)\n        super().undo()", "\n\n@dataclass\nclass GoToRewriteStep(SetGraph):\n    \"\"\"Shows the graph at some step in the proof.\n\n    Undoing returns to the previously selected proof step.\n    \"\"\"\n\n    def __init__(self, graph_view: GraphView, step_view: QListView, old_step: int, step: int) -> None:\n        proof_model = step_view.model()\n        assert isinstance(proof_model, ProofModel)\n        SetGraph.__init__(self, graph_view, proof_model.get_graph(step))\n        self.step_view = step_view\n        self.step = step\n        self.old_step = old_step\n\n    def redo(self) -> None:\n        idx = self.step_view.model().index(self.step, 0, QModelIndex())\n        self.step_view.clearSelection()\n        self.step_view.selectionModel().blockSignals(True)\n        self.step_view.setCurrentIndex(idx)\n        self.step_view.selectionModel().blockSignals(False)\n        self.step_view.update(idx)\n        super().redo()\n\n    def undo(self) -> None:\n        idx = self.step_view.model().index(self.old_step, 0, QModelIndex())\n        self.step_view.clearSelection()\n        self.step_view.selectionModel().blockSignals(True)\n        self.step_view.setCurrentIndex(idx)\n        self.step_view.selectionModel().blockSignals(False)\n        self.step_view.update(idx)\n        super().undo()", "\n\n@dataclass\nclass MoveNodeInStep(MoveNode):\n    step_view: QListView\n\n    def redo(self) -> None:\n        super().redo()\n        model = self.step_view.model()\n        assert isinstance(model, ProofModel)\n        model.graphs[self.step_view.currentIndex().row()] = self.g\n\n    def undo(self) -> None:\n        super().undo()\n        model = self.step_view.model()\n        assert isinstance(model, ProofModel)\n        model.graphs[self.step_view.currentIndex().row()] = self.g", ""]}
{"filename": "zxlive/common.py", "chunked_list": ["from enum import IntEnum\nfrom typing import Final\nfrom typing_extensions import TypeAlias\nimport pyzx\n\nVT: TypeAlias = int\nET: TypeAlias = tuple[int,int]\nGraphT: TypeAlias = pyzx.graph.graph_s.GraphS\n\nclass ToolType(IntEnum):\n    SELECT = 0\n    VERTEX = 1\n    EDGE = 2", "\nclass ToolType(IntEnum):\n    SELECT = 0\n    VERTEX = 1\n    EDGE = 2\n\nfrom pyzx.graph.graph_s import GraphS as Graph\n\nSCALE: Final = 60.0\n", "SCALE: Final = 60.0\n\n# Offsets should be a multiple of SCALE for grid snapping to work properly\nOFFSET_X: Final = 300 * SCALE\nOFFSET_Y: Final = 300 * SCALE\n\nMIN_ZOOM = 0.05\nMAX_ZOOM = 10.0\n\ndef pos_to_view(x:float,y: float) -> tuple[float, float]:\n    return (x * SCALE + OFFSET_X, y * SCALE + OFFSET_Y)", "\ndef pos_to_view(x:float,y: float) -> tuple[float, float]:\n    return (x * SCALE + OFFSET_X, y * SCALE + OFFSET_Y)\n\ndef pos_from_view(x:float,y: float) -> tuple[float, float]:\n    return ((x-OFFSET_X) / SCALE, (y-OFFSET_Y) / SCALE)\n\ndef pos_to_view_int(x:float,y: float) -> tuple[int, int]:\n    return (int(x * SCALE + OFFSET_X), int(y * SCALE + OFFSET_Y))\n\ndef pos_from_view_int(x:float,y: float) -> tuple[int, int]:\n    return (int((x - OFFSET_X) / SCALE), int((y - OFFSET_Y) / SCALE))", "\ndef pos_from_view_int(x:float,y: float) -> tuple[int, int]:\n    return (int((x - OFFSET_X) / SCALE), int((y - OFFSET_Y) / SCALE))\n\ndef view_to_length(width:float,height:float)-> tuple[float, float]:\n    return (width / SCALE, height / SCALE)\n"]}
{"filename": "zxlive/base_panel.py", "chunked_list": ["from dataclasses import dataclass\nfrom typing import Iterator, Sequence, Optional\n\nfrom PySide6.QtWidgets import QWidget, QVBoxLayout, QToolBar, QToolButton, QButtonGroup, \\\n    QHBoxLayout, QSplitter\nfrom pyzx.graph import Graph\nfrom pyzx.graph.graph_s import GraphS\n\nfrom .common import GraphT\nfrom .graphscene import GraphScene", "from .common import GraphT\nfrom .graphscene import GraphScene\nfrom .graphview import GraphView\nfrom .commands import SetGraph\nfrom .dialogs import FileFormat\nfrom .animations import AnimatedUndoStack\n\n\n@dataclass\nclass ToolbarSection:\n    \"\"\"The data needed to construct a section in the panel toolbar.\n\n    Contains a sequence of buttons that should be added in the section.\n    If the buttons are checkable, we can optionally allow only one of them\n    to be selected at any given time by setting `exclusive=True`.\"\"\"\n    buttons: Sequence[QToolButton]\n    exclusive: bool = False\n\n    def __init__(self, *args: QToolButton, exclusive: bool = False) -> None:\n        self.buttons = args\n        self.exclusive = exclusive", "@dataclass\nclass ToolbarSection:\n    \"\"\"The data needed to construct a section in the panel toolbar.\n\n    Contains a sequence of buttons that should be added in the section.\n    If the buttons are checkable, we can optionally allow only one of them\n    to be selected at any given time by setting `exclusive=True`.\"\"\"\n    buttons: Sequence[QToolButton]\n    exclusive: bool = False\n\n    def __init__(self, *args: QToolButton, exclusive: bool = False) -> None:\n        self.buttons = args\n        self.exclusive = exclusive", "\n\nclass BasePanel(QWidget):\n    \"\"\"Base class implementing functionality shared between the edit and\n    proof panels.\"\"\"\n\n    graph_scene: GraphScene\n    graph_view: GraphView\n\n    toolbar: QToolBar\n    undo_stack: AnimatedUndoStack\n    file_path: Optional[str]\n    file_type: Optional[FileFormat]\n\n    def __init__(self, graph: GraphT, graph_scene: GraphScene) -> None:\n        super().__init__()\n        self.graph_scene = graph_scene\n        self.graph_view = GraphView(self.graph_scene)\n        self.undo_stack = AnimatedUndoStack(self)\n\n        # Use box layout that fills the entire tab\n        self.setLayout(QVBoxLayout())\n        self.layout().setSpacing(0)\n        self.toolbar = QToolBar()\n        self.layout().addWidget(self.toolbar)\n\n        self.splitter = QSplitter(self)\n        self.layout().addWidget(self.splitter)\n        self.splitter.addWidget(self.graph_view)\n\n        self.graph_view.set_graph(graph)\n        self.file_path = None\n        self.file_type = None\n\n        self._populate_toolbar()\n\n    @property\n    def graph(self) -> GraphT:\n        return self.graph_scene.g\n\n    def _populate_toolbar(self) -> None:\n        for section in self._toolbar_sections():\n            group = QButtonGroup(self, exclusive=section.exclusive)\n            for btn in section.buttons:\n                self.toolbar.addWidget(btn)\n                group.addButton(btn)\n            self.toolbar.addSeparator()\n\n    def _toolbar_sections(self) -> Iterator[ToolbarSection]:\n        raise NotImplementedError\n\n    def clear_graph(self) -> None:\n        empty_graph = Graph()\n        assert isinstance(empty_graph, GraphS)\n        cmd = SetGraph(self.graph_view, empty_graph)\n        self.undo_stack.push(cmd)\n\n    def select_all(self) -> None:\n        self.graph_scene.select_all()\n\n    def deselect_all(self) -> None:\n        self.graph_scene.clearSelection()\n\n    def copy_selection(self) -> GraphT:\n        selection = list(self.graph_scene.selected_vertices)\n        copied_graph = self.graph.subgraph_from_vertices(selection)\n        assert isinstance(copied_graph, GraphS)\n        return copied_graph", ""]}
{"filename": "zxlive/edit_panel.py", "chunked_list": ["import copy\nfrom fractions import Fraction\nfrom typing import Iterator, TypedDict, Callable\nfrom PySide6.QtCore import Signal, QSize, Qt\n\nfrom PySide6.QtWidgets import QToolButton, QInputDialog, QSplitter, QListView, QListWidget, QListWidgetItem\nfrom PySide6.QtGui import QShortcut, QIcon, QPen, QPainter, QColor, QPixmap\nfrom pyzx import EdgeType, VertexType\nfrom sympy import sympify\n", "from sympy import sympify\n\nfrom .vitem import ZX_GREEN, ZX_RED, H_YELLOW\nfrom .eitem import HAD_EDGE_BLUE\n\nfrom .utils import get_data\nfrom .common import VT, GraphT, ToolType\nfrom .base_panel import BasePanel, ToolbarSection\nfrom .commands import (\n    AddEdge, AddNode, MoveNode, SetGraph, UpdateGraph, ChangePhase, ChangeNodeColor,", "from .commands import (\n    AddEdge, AddNode, MoveNode, SetGraph, UpdateGraph, ChangePhase, ChangeNodeColor,\n    ChangeEdgeColor)\nfrom .dialogs import show_error_msg\nfrom .graphscene import EditGraphScene\n\n\nclass DrawPanelNodeType(TypedDict):\n    text: str\n    type: VertexType.Type\n    icon: tuple[str, str]", "\n\nVERTICES: dict[str, DrawPanelNodeType] = {\n    \"Z\": {\"text\": \"Z spider\", \"type\": VertexType.Z, \"icon\": (\"circle\", ZX_GREEN)},\n    \"X\": {\"text\": \"X spider\", \"type\": VertexType.X, \"icon\": (\"circle\", ZX_RED)},\n    \"H\": {\"text\": \"H box\", \"type\": VertexType.H_BOX, \"icon\": (\"square\", H_YELLOW)},\n    \"T\": {\"text\": \"boundary\", \"type\": VertexType.BOUNDARY, \"icon\": (\"circle\", \"black\")},\n}\n\nEDGES: dict[str, DrawPanelNodeType] = {", "\nEDGES: dict[str, DrawPanelNodeType] = {\n    \"SIMPLE\": {\"text\": \"Simple\", \"type\": EdgeType.SIMPLE, \"icon\": (\"line\", \"black\")},\n    \"HADAMARD\": {\"text\": \"Hadamard\", \"type\": EdgeType.HADAMARD, \"icon\": (\"dashed_line\", HAD_EDGE_BLUE)},\n}\n\n\nclass GraphEditPanel(BasePanel):\n    \"\"\"Panel for the edit mode of ZX live.\"\"\"\n\n    graph_scene: EditGraphScene\n    start_derivation_signal = Signal(object)\n\n    _curr_ety: EdgeType.Type\n    _curr_vty: VertexType.Type\n\n    def __init__(self, graph: GraphT) -> None:\n        self.graph_scene = EditGraphScene()\n        self.graph_scene.vertices_moved.connect(self._vert_moved)\n        self.graph_scene.vertex_double_clicked.connect(self._vert_double_clicked)\n        self.graph_scene.vertex_added.connect(self._add_vert)\n        self.graph_scene.edge_added.connect(self._add_edge)\n\n        self._curr_vty = VertexType.Z\n        self._curr_ety = EdgeType.SIMPLE\n        super().__init__(graph, self.graph_scene)\n\n        self.sidebar = QSplitter(self)\n        self.sidebar.setOrientation(Qt.Vertical)\n        self.splitter.addWidget(self.sidebar)\n        self.vertex_list = self.create_list_widget(VERTICES, self._vty_clicked)\n        self.edge_list = self.create_list_widget(EDGES, self._ety_clicked)\n        self.sidebar.addWidget(self.vertex_list)\n        self.sidebar.addWidget(self.edge_list)\n\n    def create_list_widget(self, data: dict[str, DrawPanelNodeType], onclick: Callable[[EdgeType.Type], None]) -> QListWidget:\n        list_widget = QListWidget(self)\n        list_widget.setResizeMode(QListView.ResizeMode.Adjust)\n        list_widget.setViewMode(QListView.ViewMode.IconMode)\n        list_widget.setMovement(QListView.Movement.Static)\n        list_widget.setUniformItemSizes(True)\n        list_widget.setGridSize(QSize(60, 64))\n        list_widget.setWordWrap(True)\n        list_widget.setIconSize(QSize(24, 24))\n        for value in data.values():\n            icon = self.create_icon(*value[\"icon\"])\n            item = QListWidgetItem(icon, value[\"text\"])\n            item.setData(Qt.UserRole, value[\"type\"])\n            list_widget.addItem(item)\n        list_widget.itemClicked.connect(lambda x: onclick(x.data(Qt.UserRole)))\n        list_widget.setCurrentItem(list_widget.item(0))\n        return list_widget\n\n    def create_icon(self, shape: str, color: str) -> QIcon:\n        icon = QIcon()\n        pixmap = QPixmap(64, 64)\n        pixmap.fill(Qt.transparent)\n        painter = QPainter(pixmap)\n        painter.setRenderHint(QPainter.Antialiasing)\n        painter.setPen(QPen(QColor(\"black\"), 6))\n        painter.setBrush(QColor(color))\n        if shape == \"circle\":\n            painter.drawEllipse(4, 4, 56, 56)\n        elif shape == \"square\":\n            painter.drawRect(4, 4, 56, 56)\n        elif shape == \"line\":\n            painter.drawLine(0, 32, 64, 32)\n        elif shape == \"dashed_line\":\n            painter.setPen(QPen(QColor(color), 6, Qt.DashLine))\n            painter.drawLine(0, 32, 64, 32)\n        painter.end()\n        icon.addPixmap(pixmap)\n        return icon\n\n    def _toolbar_sections(self) -> Iterator[ToolbarSection]:\n        # Toolbar section for select, node, edge\n        icon_size = QSize(32, 32)\n        self.select = QToolButton(self, checkable=True, checked=True)  # Selected by default\n        self.vertex = QToolButton(self, checkable=True)\n        self.edge = QToolButton(self, checkable=True)\n        self.select.setToolTip(\"Select (s)\")\n        self.vertex.setToolTip(\"Add Vertex (v)\")\n        self.edge.setToolTip(\"Add Edge (e)\")\n        self.select.setIcon(QIcon(get_data(\"icons/tikzit-tool-select.svg\")))\n        self.vertex.setIcon(QIcon(get_data(\"icons/tikzit-tool-node.svg\")))\n        self.edge.setIcon(QIcon(get_data(\"icons/tikzit-tool-edge.svg\")))\n        self.select.setShortcut(\"s\")\n        self.vertex.setShortcut(\"v\")\n        self.edge.setShortcut(\"e\")\n        self.select.setIconSize(icon_size)\n        self.vertex.setIconSize(icon_size)\n        self.edge.setIconSize(icon_size)\n        self.select.clicked.connect(lambda: self._tool_clicked(ToolType.SELECT))\n        self.vertex.clicked.connect(lambda: self._tool_clicked(ToolType.VERTEX))\n        self.edge.clicked.connect(lambda: self._tool_clicked(ToolType.EDGE))\n        yield ToolbarSection(self.select, self.vertex, self.edge, exclusive=True)\n\n        self.start_derivation = QToolButton(self, text=\"Start Derivation\")\n        self.start_derivation.clicked.connect(self._start_derivation)\n        yield ToolbarSection(self.start_derivation)\n\n    def _tool_clicked(self, tool: ToolType) -> None:\n        self.graph_scene.curr_tool = tool\n\n    def _vty_clicked(self, vty: VertexType.Type) -> None:\n        self._curr_vty = vty\n        selected = list(self.graph_scene.selected_vertices)\n        if len(selected) > 0:\n            cmd = ChangeNodeColor(self.graph_view, selected, vty)\n            self.undo_stack.push(cmd)\n\n    def _ety_clicked(self, ety: EdgeType.Type) -> None:\n        self._curr_ety = ety\n        self.graph_scene.curr_ety = ety\n        selected = list(self.graph_scene.selected_edges)\n        if len(selected) > 0:\n            cmd = ChangeEdgeColor(self.graph_view, selected, ety)\n            self.undo_stack.push(cmd)\n\n    def _add_vert(self, x: float, y: float) -> None:\n        cmd = AddNode(self.graph_view, x, y, self._curr_vty)\n        self.undo_stack.push(cmd)\n\n    def _add_edge(self, u: VT, v: VT) -> None:\n        cmd = AddEdge(self.graph_view, u, v, self._curr_ety)\n        self.undo_stack.push(cmd)\n\n    def _vert_moved(self, vs: list[tuple[VT, float, float]]) -> None:\n        cmd = MoveNode(self.graph_view, vs)\n        self.undo_stack.push(cmd)\n\n    def _vert_double_clicked(self, v: VT) -> None:\n        if self.graph.type(v) == VertexType.BOUNDARY:\n            input_, ok = QInputDialog.getText(\n                self, \"Input Dialog\", \"Enter Qubit Index:\"\n            )\n            try:\n                input_ = int(input_.strip())\n                self.graph.set_qubit(v, input_)\n            except ValueError:\n                show_error_msg(\"Wrong Input Type\", \"Please enter a valid input (e.g. 1, 2)\")\n            return\n\n        input_, ok = QInputDialog.getText(\n            self, \"Input Dialog\", \"Enter Desired Phase Value:\"\n        )\n        if not ok:\n            return\n        try:\n            new_phase = string_to_phase(input_)\n        except ValueError:\n            show_error_msg(\"Wrong Input Type\", \"Please enter a valid input (e.g. 1/2, 2)\")\n            return\n        cmd = ChangePhase(self.graph_view, v, new_phase)\n        self.undo_stack.push(cmd)\n\n    def paste_graph(self, graph: GraphT) -> None:\n        if graph is None: return\n        new_g = copy.deepcopy(self.graph_scene.g)\n        new_verts, new_edges = new_g.merge(graph.translate(0.5,0.5))\n        cmd = UpdateGraph(self.graph_view,new_g)\n        self.undo_stack.push(cmd)\n        self.graph_scene.select_vertices(new_verts)\n\n    def delete_selection(self) -> None:\n        selection = list(self.graph_scene.selected_vertices)\n        selected_edges = list(self.graph_scene.selected_edges)\n        if not selection and not selected_edges: return\n        new_g = copy.deepcopy(self.graph_scene.g)\n        self.graph_scene.clearSelection()\n        new_g.remove_edges(selected_edges)\n        new_g.remove_vertices(selection)\n        cmd = SetGraph(self.graph_view,new_g) if len(selection) > 128 \\\n            else UpdateGraph(self.graph_view,new_g)\n        self.undo_stack.push(cmd)\n\n    def _start_derivation(self) -> None:\n        self.start_derivation_signal.emit(copy.deepcopy(self.graph_scene.g))", "\ndef string_to_phase(string: str) -> Fraction:\n    if not string: \n        return Fraction(0)\n    try:\n        s = string.lower().replace(' ', '')\n        s = s.replace('\\u03c0', '').replace('pi', '')\n        if '.' in s or 'e' in s:\n            return Fraction(float(s))\n        elif '/' in s:\n            a, b = s.split(\"/\", 2)\n            if not a:\n                return Fraction(1, int(b))\n            if a == '-':\n                a = '-1'\n            return Fraction(int(a), int(b))\n        else:\n            return Fraction(int(s))\n    except ValueError:\n        return sympify(string)", ""]}
{"filename": "zxlive/mainwindow.py", "chunked_list": ["#     zxlive - An interactive tool for the ZX calculus\n#     Copyright (C) 2023 - Aleks Kissinger\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software", "\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import annotations\nfrom typing import Callable, Optional, TypedDict\n", "from typing import Callable, Optional, TypedDict\n\nimport copy\n\nfrom PySide6.QtCore import QFile, QFileInfo, QTextStream, QIODevice, QSettings, QByteArray, QEvent\nfrom PySide6.QtGui import QAction, QKeySequence, QCloseEvent\nfrom PySide6.QtWidgets import QMessageBox, QMainWindow, QWidget, QVBoxLayout, QTabWidget\nfrom pyzx.graph.base import BaseGraph\n\nfrom .commands import AddRewriteStep", "\nfrom .commands import AddRewriteStep\nfrom .base_panel import BasePanel\nfrom .edit_panel import GraphEditPanel\nfrom .proof_panel import ProofPanel\nfrom .construct import *\nfrom .dialogs import ImportGraphOutput, create_new_rewrite, export_proof_dialog, import_diagram_dialog, export_diagram_dialog, show_error_msg, FileFormat\nfrom .common import GraphT\n\nfrom pyzx import Graph, simplify, Circuit", "\nfrom pyzx import Graph, simplify, Circuit\n\n\nclass MainWindow(QMainWindow):\n    \"\"\"A simple window containing a single `GraphView`\n    This is just an example, and should be replaced with\n    something more sophisticated.\n    \"\"\"\n\n    edit_panel: GraphEditPanel\n    proof_panel: ProofPanel\n\n    def __init__(self) -> None:\n        super().__init__()\n        conf = QSettings(\"zxlive\", \"zxlive\")\n\n        self.setWindowTitle(\"zxlive\")\n\n        w = QWidget(self)\n        w.setLayout(QVBoxLayout())\n        self.setCentralWidget(w)\n        w.layout().setContentsMargins(0, 0, 0, 0)\n        w.layout().setSpacing(0)\n        self.resize(1200, 800)\n\n        # restore the window from the last time it was opened\n        geom = conf.value(\"main_window_geometry\")\n        if geom and isinstance(geom, QByteArray):\n            self.restoreGeometry(geom)\n        self.show()\n\n        tab_widget = QTabWidget()\n        w.layout().addWidget(tab_widget)\n        tab_widget.setTabsClosable(True)\n        tab_widget.currentChanged.connect(self.tab_changed)\n        tab_widget.tabCloseRequested.connect(lambda i: tab_widget.removeTab(i))\n        self.tab_widget = tab_widget\n\n        # Currently the copied part is stored internally, and is not made available to the clipboard.\n        # We could do this by using pyperclip.\n        self.copied_graph: Optional[GraphT] = None\n\n        menu = self.menuBar()\n\n        new_graph = self._new_action(\"&New\", self.new_graph, QKeySequence.StandardKey.New,\n            \"Reinitialize with an empty graph\")\n        open_file = self._new_action(\"&Open...\", self.open_file, QKeySequence.StandardKey.Open,\n            \"Open a file-picker dialog to choose a new diagram\")\n        close_action = self._new_action(\"Close\", self.close_action, QKeySequence.StandardKey.Close,\n            \"Closes the window\")\n        close_action.setShortcuts([QKeySequence(QKeySequence.StandardKey.Close), QKeySequence(\"Ctrl+W\")])\n        # TODO: We should remember if we have saved the diagram before,\n        # and give an open to overwrite this file with a Save action\n        save_file = self._new_action(\"&Save\", self.save_file, QKeySequence.StandardKey.Save,\n            \"Save the diagram by overwriting the previous loaded file.\")\n        save_as = self._new_action(\"Save &as...\", self.save_as, QKeySequence.StandardKey.SaveAs,\n            \"Opens a file-picker dialog to save the diagram in a chosen file format\")\n\n        file_menu = menu.addMenu(\"&File\")\n        file_menu.addAction(new_graph)\n        file_menu.addAction(open_file)\n        file_menu.addSeparator()\n        file_menu.addAction(close_action)\n        file_menu.addAction(save_file)\n        file_menu.addAction(save_as)\n\n        undo = self._new_action(\"Undo\", self.undo, QKeySequence.StandardKey.Undo,\n            \"Undoes the last action\")\n        redo = self._new_action(\"Redo\", self.redo, QKeySequence.StandardKey.Redo,\n            \"Redoes the last action\")\n        cut_action = self._new_action(\"Cut\", self.cut_graph,QKeySequence.StandardKey.Cut,\n            \"Cut the selected part of the diagram\")\n        copy_action = self._new_action(\"&Copy\", self.copy_graph,QKeySequence.StandardKey.Copy,\n            \"Copy the selected part of the diagram\")\n        paste_action = self._new_action(\"Paste\", self.paste_graph,QKeySequence.StandardKey.Paste,\n            \"Paste the copied part of the diagram\")\n        delete_action = self._new_action(\"Delete\", self.delete_graph,QKeySequence.StandardKey.Delete,\n            \"Delete the selected part of the diagram\")\n        delete_action.setShortcuts([QKeySequence(QKeySequence.StandardKey.Delete),QKeySequence(\"Backspace\")])\n        new_tab = self._new_action(\"new_tab\", self.new_graph, QKeySequence.StandardKey.AddTab,\n            \"Create a new tab\")\n        self.addAction(new_tab)\n        select_all = self._new_action(\"Select &All\", self.select_all, QKeySequence.StandardKey.SelectAll, \"Select all\")\n        deselect_all = self._new_action(\"&Deselect All\", self.deselect_all, QKeySequence.StandardKey.Deselect, \"Deselect all\")\n        deselect_all.setShortcuts([QKeySequence(QKeySequence.StandardKey.Deselect), QKeySequence(\"Ctrl+D\")])\n\n        edit_menu = menu.addMenu(\"&Edit\")\n        edit_menu.addAction(undo)\n        edit_menu.addAction(redo)\n        edit_menu.addSeparator()\n        edit_menu.addAction(cut_action)\n        edit_menu.addAction(copy_action)\n        edit_menu.addAction(paste_action)\n        edit_menu.addAction(delete_action)\n        edit_menu.addSeparator()\n        edit_menu.addAction(select_all)\n        edit_menu.addAction(deselect_all)\n\n        zoom_in  = self._new_action(\"Zoom in\", self.zoom_in,   QKeySequence.StandardKey.ZoomIn,\"Zooms in by a fixed amount\")\n        zoom_out = self._new_action(\"Zoom out\", self.zoom_out, QKeySequence.StandardKey.ZoomOut, \"Zooms out by a fixed amount\")\n        zoom_in.setShortcuts([QKeySequence(QKeySequence.StandardKey.ZoomIn), QKeySequence(\"Ctrl+=\")])\n        fit_view = self._new_action(\"Fit view\", self.fit_view, QKeySequence(\"C\"), \"Fits the view to the diagram\")\n        self.addAction(zoom_in)\n        self.addAction(zoom_out)\n        self.addAction(fit_view)\n\n        view_menu = menu.addMenu(\"&View\")\n        view_menu.addAction(zoom_in)\n        view_menu.addAction(zoom_out)\n        view_menu.addAction(fit_view)\n\n        new_rewrite = self._new_action(\"Create new rewrite\", lambda: create_new_rewrite(self), None, \"Create a new rewrite\")\n        rewrite_menu = menu.addMenu(\"&Rewrite\")\n        rewrite_menu.addAction(new_rewrite)\n\n        simplify_actions = []\n        for simp in simplifications.values():\n            simplify_actions.append(self._new_action(simp[\"text\"], self.apply_pyzx_reduction(simp), None, simp[\"tool_tip\"]))\n        self.simplify_menu = menu.addMenu(\"&Simplify\")\n        for action in simplify_actions:\n            self.simplify_menu.addAction(action)\n        self.simplify_menu.menuAction().setVisible(False)\n\n        graph = construct_circuit()\n        self.new_graph(graph)\n\n    def _new_action(self,name:str,trigger:Callable,shortcut:QKeySequence | QKeySequence.StandardKey | None,tooltip:str) -> QAction:\n        action = QAction(name, self)\n        action.setStatusTip(tooltip)\n        action.triggered.connect(trigger)\n        if shortcut:\n            action.setShortcut(shortcut)\n        return action\n\n    @property\n    def active_panel(self) -> Optional[BasePanel]:\n        current_widget = self.tab_widget.currentWidget()\n        if current_widget is not None:\n            assert isinstance(current_widget, BasePanel)\n            return current_widget\n        return None\n\n\n    def closeEvent(self, e: QCloseEvent) -> None:\n        while self.active_panel is not None:  # We close all the tabs and ask the user if they want to save progress\n            success = self.close_action()\n            if not success:\n                e.ignore()  # Abort the closing\n                return\n\n        # save the shape/size of this window on close\n        conf = QSettings(\"zxlive\", \"zxlive\")\n        conf.setValue(\"main_window_geometry\", self.saveGeometry())\n        e.accept()\n\n    def undo(self,e: QEvent) -> None:\n        if self.active_panel is None: return\n        self.active_panel.undo_stack.undo()\n\n    def redo(self,e: QEvent) -> None:\n        if self.active_panel is None: return\n        self.active_panel.undo_stack.redo()\n\n    def update_tab_name(self, clean:bool) -> None:\n        i = self.tab_widget.currentIndex()\n        name = self.tab_widget.tabText(i)\n        if name.endswith(\"*\"): name = name[:-1]\n        if not clean: name += \"*\"\n        self.tab_widget.setTabText(i,name)\n\n    def tab_changed(self, i: int) -> None:\n        if isinstance(self.active_panel, ProofPanel):\n            self.simplify_menu.menuAction().setVisible(True)\n        else:\n            self.simplify_menu.menuAction().setVisible(False)\n\n    def open_file(self) -> None:\n        out = import_diagram_dialog(self)\n        if out is not None:\n            assert self.active_panel is not None\n            name = QFileInfo(out.file_path).baseName()\n            if isinstance(out, ImportGraphOutput):\n                self.new_graph(out.g, name)\n            else:\n                graph = out.p.graphs[-1]\n                self.new_deriv(graph, name)\n                proof_panel: BasePanel = self.active_panel\n                proof_panel.proof_model = out.p\n                proof_panel.step_view.setModel(proof_panel.proof_model)\n                proof_panel.step_view.setCurrentIndex(proof_panel.proof_model.index(len(proof_panel.proof_model.steps), 0))\n                proof_panel.step_view.selectionModel().selectionChanged.connect(proof_panel._proof_step_selected)\n            self.active_panel.file_path = out.file_path\n            self.active_panel.file_type = out.file_type\n\n    def close_action(self) -> bool:\n        assert self.active_panel is not None\n        i = self.tab_widget.currentIndex()\n        if i == -1: # no tabs open\n            self.close()\n        if not self.active_panel.undo_stack.isClean():\n            name = self.tab_widget.tabText(i).replace(\"*\",\"\")\n            answer = QMessageBox.question(self, \"Save Changes\",\n                            f\"Do you wish to save your changes to {name} before closing?\",\n                            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No | QMessageBox.StandardButton.Cancel)\n            if answer == QMessageBox.StandardButton.Cancel: return False\n            if answer == QMessageBox.StandardButton.Yes:\n                val = self.save_file()\n                if not val: return False\n        self.tab_widget.tabCloseRequested.emit(i)\n        return True\n\n    def save_file(self) -> bool:\n        assert self.active_panel is not None\n        if self.active_panel.file_path is None:\n            return self.save_as()\n        if self.active_panel.file_type == FileFormat.QASM:\n            show_error_msg(\"Can't save to circuit file\",\n                \"You imported this file from a circuit description. You can currently only save it in a graph format.\")\n            return self.save_as()\n\n        if isinstance(self.active_panel, ProofPanel):\n            data = self.active_panel.proof_model.to_json()\n        elif self.active_panel.file_type in (FileFormat.QGraph, FileFormat.Json):\n            data = self.active_panel.graph.to_json()\n        elif self.active_panel.file_type == FileFormat.TikZ:\n            data = self.active_panel.graph.to_tikz()\n        else:\n            raise TypeError(\"Unknown file format\", self.active_panel.file_type)\n\n        file = QFile(self.active_panel.file_path)\n        if not file.open(QIODevice.OpenModeFlag.WriteOnly | QIODevice.OpenModeFlag.Text):\n            show_error_msg(\"Could not write to file\")\n            return False\n        out = QTextStream(file)\n        out << data\n        file.close()\n        self.active_panel.undo_stack.setClean()\n        return True\n\n\n    def save_as(self) -> bool:\n        assert self.active_panel is not None\n        if isinstance(self.active_panel, ProofPanel):\n            out = export_proof_dialog(self.active_panel.proof_model, self)\n        else:\n            out = export_diagram_dialog(self.active_panel.graph_scene.g, self)\n        if out is None: return False\n        file_path, file_type = out\n        self.active_panel.file_path = file_path\n        self.active_panel.file_type = file_type\n        self.active_panel.undo_stack.setClean()\n        name = QFileInfo(file_path).baseName()\n        i = self.tab_widget.currentIndex()\n        self.tab_widget.setTabText(i,name)\n        return True\n\n\n    def cut_graph(self) -> None:\n        assert self.active_panel is not None\n        if isinstance(self.active_panel, GraphEditPanel):\n            self.copied_graph = self.active_panel.copy_selection()\n            self.active_panel.delete_selection()\n\n    def copy_graph(self) -> None:\n        assert self.active_panel is not None\n        self.copied_graph = self.active_panel.copy_selection()\n\n    def paste_graph(self) -> None:\n        assert self.active_panel is not None\n        if isinstance(self.active_panel, GraphEditPanel) and self.copied_graph is not None:\n            self.active_panel.paste_graph(self.copied_graph)\n\n    def delete_graph(self) -> None:\n        assert self.active_panel is not None\n        if isinstance(self.active_panel, GraphEditPanel):\n            self.active_panel.delete_selection()\n\n    def new_graph(self, graph:Optional[GraphT] = None, name:Optional[str]=None) -> None:\n        graph = graph or Graph()\n        panel = GraphEditPanel(graph)\n        panel.start_derivation_signal.connect(self.new_deriv)\n        if name is None: name = \"New Graph\"\n        self.tab_widget.addTab(panel, name)\n        self.tab_widget.setCurrentWidget(panel)\n        panel.undo_stack.cleanChanged.connect(self.update_tab_name)\n\n    def new_deriv(self, graph:GraphT, name:Optional[str]=None) -> None:\n        panel = ProofPanel(graph)\n        if name is None: name = \"New Proof\"\n        self.tab_widget.addTab(panel, name)\n        self.tab_widget.setCurrentWidget(panel)\n        panel.undo_stack.cleanChanged.connect(self.update_tab_name)\n\n    def select_all(self) -> None:\n        assert self.active_panel is not None\n        self.active_panel.select_all()\n\n    def deselect_all(self) -> None:\n        assert self.active_panel is not None\n        self.active_panel.deselect_all()\n\n    def zoom_in(self) -> None:\n        assert self.active_panel is not None\n        self.active_panel.graph_view.zoom_in()\n\n    def zoom_out(self) -> None:\n        assert self.active_panel is not None\n        self.active_panel.graph_view.zoom_out()\n\n    def fit_view(self) -> None:\n        assert self.active_panel is not None\n        self.active_panel.graph_view.fit_view()\n\n    def apply_pyzx_reduction(self, reduction: SimpEntry) -> Callable[[],None]:\n        def reduce() -> None:\n            assert self.active_panel is not None\n            old_graph = self.active_panel.graph\n            new_graph = copy.deepcopy(old_graph)\n            reduction[\"function\"](new_graph)\n            cmd = AddRewriteStep(self.active_panel.graph_view, new_graph, self.active_panel.step_view, reduction[\"text\"])\n            self.active_panel.undo_stack.push(cmd)\n        return reduce", "\n\nclass SimpEntry(TypedDict):\n    text: str\n    tool_tip: str\n    function: Callable[[BaseGraph], int | None | BaseGraph] | Callable[[BaseGraph | Circuit], int]\n\nsimplifications: dict[str, SimpEntry] = {\n    'bialg_simp': {\"text\": \"bialg_simp\", \"tool_tip\":\"bialg_simp\", \"function\": simplify.bialg_simp,},\n    'spider_simp': {\"text\": \"spider_simp\", \"tool_tip\":\"spider_simp\", \"function\": simplify.spider_simp},", "    'bialg_simp': {\"text\": \"bialg_simp\", \"tool_tip\":\"bialg_simp\", \"function\": simplify.bialg_simp,},\n    'spider_simp': {\"text\": \"spider_simp\", \"tool_tip\":\"spider_simp\", \"function\": simplify.spider_simp},\n    'id_simp': {\"text\": \"id_simp\", \"tool_tip\":\"id_simp\", \"function\": simplify.id_simp},\n    'phase_free_simp': {\"text\": \"phase_free_simp\", \"tool_tip\":\"phase_free_simp\", \"function\": simplify.phase_free_simp},\n    'pivot_simp': {\"text\": \"pivot_simp\", \"tool_tip\":\"pivot_simp\", \"function\": simplify.pivot_simp},\n    'pivot_gadget_simp': {\"text\": \"pivot_gadget_simp\", \"tool_tip\":\"pivot_gadget_simp\", \"function\": simplify.pivot_gadget_simp},\n    'pivot_boundary_simp': {\"text\": \"pivot_boundary_simp\", \"tool_tip\":\"pivot_boundary_simp\", \"function\": simplify.pivot_boundary_simp},\n    'gadget_simp': {\"text\": \"gadget_simp\", \"tool_tip\":\"gadget_simp\", \"function\": simplify.gadget_simp},\n    'lcomp_simp': {\"text\": \"lcomp_simp\", \"tool_tip\":\"lcomp_simp\", \"function\": simplify.lcomp_simp},\n    'clifford_simp': {\"text\": \"clifford_simp\", \"tool_tip\":\"clifford_simp\", \"function\": simplify.clifford_simp},", "    'lcomp_simp': {\"text\": \"lcomp_simp\", \"tool_tip\":\"lcomp_simp\", \"function\": simplify.lcomp_simp},\n    'clifford_simp': {\"text\": \"clifford_simp\", \"tool_tip\":\"clifford_simp\", \"function\": simplify.clifford_simp},\n    'tcount': {\"text\": \"tcount\", \"tool_tip\":\"tcount\", \"function\": simplify.tcount},\n    'to_gh': {\"text\": \"to_gh\", \"tool_tip\":\"to_gh\", \"function\": simplify.to_gh},\n    'to_rg': {\"text\": \"to_rg\", \"tool_tip\":\"to_rg\", \"function\": simplify.to_rg},\n    'full_reduce': {\"text\": \"full_reduce\", \"tool_tip\":\"full_reduce\", \"function\": simplify.full_reduce},\n    'teleport_reduce': {\"text\": \"teleport_reduce\", \"tool_tip\":\"teleport_reduce\", \"function\": simplify.teleport_reduce},\n    'reduce_scalar': {\"text\": \"reduce_scalar\", \"tool_tip\":\"reduce_scalar\", \"function\": simplify.reduce_scalar},\n    'supplementarity_simp': {\"text\": \"supplementarity_simp\", \"tool_tip\":\"supplementarity_simp\", \"function\": simplify.supplementarity_simp},\n    'to_clifford_normal_form_graph': {\"text\": \"to_clifford_normal_form_graph\", \"tool_tip\":\"to_clifford_normal_form_graph\", \"function\": simplify.to_clifford_normal_form_graph},", "    'supplementarity_simp': {\"text\": \"supplementarity_simp\", \"tool_tip\":\"supplementarity_simp\", \"function\": simplify.supplementarity_simp},\n    'to_clifford_normal_form_graph': {\"text\": \"to_clifford_normal_form_graph\", \"tool_tip\":\"to_clifford_normal_form_graph\", \"function\": simplify.to_clifford_normal_form_graph},\n}"]}
