{"filename": "Stage1/continuous_uct_3d.py", "chunked_list": ["import numpy as np\nimport logging\nimport math, time\nimport os, sys, contextlib, platform\n\nbase_path = os.getcwd()\nsys.path.append(base_path)\n\nfrom configs.config import get_base_config, make_config\nfrom utils.utils import readFile, readAlist, save_file_from_list, util_init", "from configs.config import get_base_config, make_config\nfrom utils.utils import readFile, readAlist, save_file_from_list, util_init\nfrom apps.draw import *\nfrom algo.UCTs import *\nfrom truss_envs.reward import *\n\nparser = get_base_config()\nargs = parser.parse_known_args(sys.argv[1:])[0]\nconfig = make_config(args.config)\nfor k, v in config.get(\"base\", {}).items():\n    if f\"--{k}\" not in args:\n        setattr(args, k, v)", "config = make_config(args.config)\nfor k, v in config.get(\"base\", {}).items():\n    if f\"--{k}\" not in args:\n        setattr(args, k, v)\n\nprint(config)\n\ndef main():\n    p, e = readFile(args.input_path)\n    if not os.path.exists('results_3d/' + args.config):\n        os.mkdir('results_3d/' + args.config)\n        \n    # save and load path\n    LOGFOLDER = args.save_path\n    if not os.path.exists(LOGFOLDER): os.mkdir(LOGFOLDER)\n\n    if (args.useAlist == True): Alist = readAlist(args.Alist_path)\n    else: Alist = None\n\n    Envs_init(args)\n    UCTs_init(args, arealist__ = Alist)\n    util_init(args)\n    \n    bestreward, pbest, ebest = UCTSearch(p, e)\n\n    print(\"bestreward =\",bestreward)\n    print(reward_fun(pbest, ebest))", "\nif __name__ == '__main__':\n    if not os.path.exists('results_3d/'):\n        os.mkdir('results_3d/')\n    main()"]}
{"filename": "Stage1/noise_input_permutation_format_transfer.py", "chunked_list": ["import time\nimport json\nimport numpy as np\nimport math\nimport random\nimport copy\n\nimport matplotlib.pyplot as plt\nimport warnings\nimport os, sys, contextlib", "import warnings\nimport os, sys, contextlib\nimport openseespy.opensees as op\n\nimport heapq\n\nbase_path = os.getcwd()\nsys.path.append(base_path)\nfrom configs.config import get_base_config, make_config\n", "from configs.config import get_base_config, make_config\n\nparser = get_base_config()\nargs = parser.parse_known_args(sys.argv[1:])[0]\nconfig = make_config(args.config)\nfor k, v in config.get(\"base\", {}).items():\n    if f\"--{k}\" not in args:\n        setattr(args, k, v)\n\nif not os.path.exists('PostResults'):\n    os.mkdir('PostResults')", "\nif not os.path.exists('PostResults'):\n    os.mkdir('PostResults')\nif not os.path.exists('PostResults/' + args.config):\n    os.mkdir('PostResults/' + args.config)\n\nOrgF = os.path.join(args.save_path, args.run_id)\nTarFolder = os.path.join(args.input_path_2, args.run_id)\nif not os.path.exists(TarFolder):\n    os.mkdir(TarFolder)", "if not os.path.exists(TarFolder):\n    os.mkdir(TarFolder)\nOrgFolder = os.path.join(OrgF, args.transfer_filefold)\nprint(OrgFolder)\n\npermutation = [0, 1, 2, 3]\n\n    #if not os.path.exists(TarFolder):\n    #    os.mkdir(TarFolder)\n", "    #    os.mkdir(TarFolder)\n\nfiles = os.listdir(OrgFolder)\nfiles.sort(key = lambda x: int(x[:-4]))\nselected_files = []\nmax_idx = len(files)\n#print('max_idx', max_idx)\n\nif (args.finetune == False):\n    for _ in range(min(args.max_num_topo_truss, max_idx)):\n        _idx = _\n        selected_files.append(files[_idx])\nelse: \n    assert(max_idx > args.max_num_topo_truss)\n    right = min(args.max_num_topo_truss * 2, max_idx)\n    for _ in range(args.max_num_topo_truss, right):\n        _idx = _\n        selected_files.append(files[_idx])", "if (args.finetune == False):\n    for _ in range(min(args.max_num_topo_truss, max_idx)):\n        _idx = _\n        selected_files.append(files[_idx])\nelse: \n    assert(max_idx > args.max_num_topo_truss)\n    right = min(args.max_num_topo_truss * 2, max_idx)\n    for _ in range(args.max_num_topo_truss, right):\n        _idx = _\n        selected_files.append(files[_idx])", "\nprint(selected_files)\nfor idfile, file in enumerate(selected_files):\n        FILENAME = os.path.join(OrgFolder, file)\n        #SAVENAME = TarFolder + file\n        #SAVENAME = SAVENAME[:-4]\n        #SAVENAME += folder_name\n        #SAVENAME += '.txt'\n        if file[-4:] != '.txt': continue\n        with open(FILENAME, \"r\") as fle:\n            lines = fle.readlines()\n            for i in range(len(lines)):\n                line = lines[i]\n                vec = line.strip().split(' ')\n\n                if (i == 0):\n                    vn = int(vec[0])\n                    en = int(vec[1])\n                    Edges = [[- 1.0 for _ in range(vn)] for _ in range(vn)]\n                    d = [[- 1.0 for _ in range(vn)] for _ in range(vn)]\n                    t = [[- 1.0 for _ in range(vn)] for _ in range(vn)]\n                    Nodes = []\n                    nodes_position = []\n                    continue\n\n                if (1 <= i and i <= vn):\n                    Nodes.append(line)\n                    nodes_position.append([vec[0], vec[1], vec[2]])\n                    continue\n\n                if (vn + 1 <= i and i <= vn + en):\n                    node1 = int(vec[0])\n                    node2 = int(vec[1])\n                    Edges[node1][node2] = vec[2]\n                    Edges[node2][node1] = vec[2]\n                    d[node1][node2] = vec[3]\n                    d[node2][node1] = vec[3]\n                    t[node1][node2] = vec[4]\n                    t[node2][node1] = vec[4]\n\n        mass = 0\n        pho = args.pho\n        for v_i in range(vn):\n            for v_j in range(vn):\n                if v_i < v_j:\n                    i_x = float(nodes_position[v_i][0])\n                    i_y = float(nodes_position[v_i][1])\n                    i_z = float(nodes_position[v_i][2])\n                    j_x = float(nodes_position[v_j][0])\n                    j_y = float(nodes_position[v_j][1])\n                    j_z = float(nodes_position[v_j][2])\n                    area = float(Edges[v_i][v_j])\n                    if area == -1:\n                        continue\n                    mass += math.sqrt((i_x - j_x) ** 2 + (i_y - j_y) ** 2 + (i_z - j_z) ** 2) * area * args.pho\n\n\n        SAVENAME = os.path.join(TarFolder, str(round(mass * 1000)) + '_' + str(idfile).zfill(2) + '.txt')\n        #print(mass, SAVENAME)\n\n        PermutationEdges = [[- 1.0 for _ in range(vn)] for _ in range(vn)]\n        Permutationd = [[- 1.0 for _ in range(vn)] for _ in range(vn)]\n        Permutationt = [[- 1.0 for _ in range(vn)] for _ in range(vn)]\n        for i in range(vn):\n            for j in range(vn):\n                new_i = i\n                new_j = j\n                if i < len(permutation):\n                    new_i = permutation[i]\n                if j < len(permutation):\n                    new_j = permutation[j]\n                PermutationEdges[i][j] = Edges[new_i][new_j]\n                PermutationEdges[j][i] = Edges[new_j][new_i]\n                Permutationd[i][j] = d[new_i][new_j]\n                Permutationd[j][i] = d[new_j][new_i]\n                Permutationt[i][j] = t[new_i][new_j]\n                Permutationt[j][i] = t[new_j][new_i]\n\n        with open(SAVENAME, \"w\") as f:\n            print(int(vn), int(vn * (vn - 1) / 2), file=f)\n            for i in range(len(Nodes)):\n                new_i = i\n                if i < len(permutation):\n                    new_i = permutation[i]\n                print(Nodes[new_i], file=f, end='')\n            for j in range(vn):\n                for i in range(vn):\n                    if i < j:\n                        print(int(i), int(j), PermutationEdges[i][j], Permutationd[i][j], Permutationt[i][j], file=f)"]}
{"filename": "configs/config.py", "chunked_list": ["from typing import Dict\nimport argparse\nimport yaml\n\ndef get_base_config():\n    parser = argparse.ArgumentParser(\n        description='RL_truss_layout',\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n\n    parser.add_argument('--config', type = str)\n# args for UCTs:\n    parser.add_argument(\"--c\", default = [30.0, 30.0, 30.0])\n    parser.add_argument(\"--rate2\", default = 0.9)\n    parser.add_argument(\"--prob\", default = 1.0)\n    parser.add_argument(\"--alpha\", default = 0.3)\n    parser.add_argument(\"--rate\", default = 0)\n    parser.add_argument(\"--pickalpha\", default = 0)\n    parser.add_argument(\"--sgm1\", default = 0.0005)\n    parser.add_argument(\"--sgm2\", default = 0.5)\n    parser.add_argument(\"--maxnum\", default = 25)\n    parser.add_argument(\"--maxson\", default = 200)\n    parser.add_argument(\"--UCT-maxiter\", type = int, default = 300000)\n    parser.add_argument(\"--UCT_extra_iter_for_point_pos\", type = int, default = 250000)\n    parser.add_argument(\"--initson\", default = 25)\n    parser.add_argument(\"--USE-VALUE-NETWORK\", type = bool, default = 0)\n\n# args for Env:\n    parser.add_argument(\"--bad-attempt-limit\", default = 5)\n    parser.add_argument(\"--maxp\", default = 10)\n    parser.add_argument(\"--env-dims\", default = 3, type = int)\n    parser.add_argument(\"--env-mode\", default='DT', choices=['Area', 'DT'])\n    parser.add_argument(\"--useIntersect\", default = True)\n    parser.add_argument('--coordinate_range', type=list, default=[(0.0, 4.634), (-0.483, 0.7725), (-0.5, 1.0)], help='points\\' range')\n    parser.add_argument('--area_range', type=list, default=(0.0001, 0.003028), help='edges\\' area range')\n    parser.add_argument(\"--len_range\", type=list, default = (0.03, 5.0), help='edges\\' length range')    \n    parser.add_argument('--area_delta_range', type=list, default=(-0.0005, 0.0005), help='edges\\' area delta range')\n    parser.add_argument('--coordinate_delta_range', type=list, default=[(-0.5715, 0.5715), (-0.5715, 0.5715), (-0.5715, 0.5715)], help='nodes\\' coordinate delta range')\n    parser.add_argument('--d-range', type=list, default=(0.025, 0.12))\n    parser.add_argument('--t-range', type=list, default=(0.0015, 0.005))\n    parser.add_argument('--d-delta-range', type=list, default=(-0.05, 0.05))\n    parser.add_argument('--t-delta-range', type=list, default=(-0.005, 0.005))\n    parser.add_argument(\"--usePlist\", default = False)\n    parser.add_argument(\"--Plist-path\", type = str, default = None)\n    parser.add_argument(\"--useAlist\", default = True)\n    parser.add_argument(\"--Alist-path\", type = str, default = 'input/sectionList3.txt')\n    parser.add_argument(\"--input-path\", type = str, default = 'input/kr-sundial-newinput.txt')\n    parser.add_argument(\"--ratio_ring\", default = 0.0)\n    parser.add_argument('--fixed_points', type=int, default=4, help='number of fixed nodes')\n    parser.add_argument('--variable_edges', type=int, default=-1, help='number of variable edges, -1 if all is variable')\n    parser.add_argument('--symmetry-build', type=int, default=0)\n\n# args for dynamics:\n    parser.add_argument('--E', type = float, default = 1.93*10**11)\n    parser.add_argument('--pho', type = float, default = 8.0*10**3)\n    parser.add_argument('--sigma-T', type = float, default = 123.0*10**6)\n    parser.add_argument('--sigma-C', type = float, default = 123.0*10**6)\n    parser.add_argument('--slenderness_ratio_c', type = float, default = 180.0)\n    parser.add_argument('--slenderness_ratio_t', type = float, default = 220.0)\n    parser.add_argument('--dislimit', type = float, default = 0.002)\n\n    parser.add_argument('--CONSTRAINT-CROSS-EDGE', type = int, default = 1)\n    parser.add_argument('--CONSTRAINT-STRESS', type = int, default = 1)\n    parser.add_argument('--CONSTRAINT-DIS', type = int, default = 1)\n    parser.add_argument('--CONSTRAINT-BUCKLE', type = int, default = 1)\n    parser.add_argument('--CONSTRAINT-SLENDERNESS', type = int, default = 1)\n    parser.add_argument(\"--CONSTRAINT-MAX-LENGTH\", type = int, default = 1)\n    parser.add_argument(\"--CONSTRAINT-MIN-LENGTH\", type = int, default = 1)\n    parser.add_argument(\"--CONSTRAINT-SELF-WEIGHT\", type = int, default = 1)\n    parser.add_argument(\"--NEW_CONST....\", type = int, default = 1)\n\n# args for save and load:\n    parser.add_argument(\"--save-KR\", default = False)\n    parser.add_argument(\"--save-diversity\", type = bool, default = True)\n    parser.add_argument(\"--save-path\", type = str, default = './results_3d/')\n    parser.add_argument(\"--input-path-2\", type = str, default = './PostResults/')\n    parser.add_argument(\"--save-model-path\", type = str, default = './saved_models/')\n    parser.add_argument(\"--finetune-model-path\", type = str, default = './saved_models/')\n    parser.add_argument(\"--OUTPUT_ALL_THRESHOLD\", type = float, default = 4000)\n    parser.add_argument(\"--MASS_OUTPUT_ALL_THRESHOLD\", type = float, default = 4000)\n    parser.add_argument(\"--save-invalid-factor\", type = int, default = 0)\n    parser.add_argument(\"--run-id\", type = str, default = '.')\n    parser.add_argument(\"--logfile-stage1\", type = str, default = 'log_stage1.log')\n    parser.add_argument(\"--logfile-stage2\", type = str, default = 'log_stage2.log')\n    parser.add_argument(\"--transfer-filefold\", type = str, default = 'DIVERSITY_TOPO_result')\n\n# args for Reward:\n    parser.add_argument(\"--reward_lambda\", default = 10 * 50 * 50)\n\n# args for RL:    \n    parser.add_argument('--initial_state_files', type=str, default='PostResults/', help='input file for refine')\n    parser.add_argument('--num_trains_per_train_loop', type=int, default=5, help='for sac training')\n    parser.add_argument('--num_train_loops_per_epoch', type=int, default=5, help='for sac training')\n    parser.add_argument('--hidden-dims', type=list, default=[256, 512], help='hidden layer dimensions')\n    parser.add_argument('--buffer-size', type=int, default=1000000, help='buffer size')\n    parser.add_argument('--epoch', type=int, default=40, help='epoch')\n    parser.add_argument('--batch-size', type=int, default=128, help='batch size')\n    parser.add_argument('--eval', action='store_true', default=False)\n    parser.add_argument('--finetune', action='store_true', default=False)\n    parser.add_argument('--only-position', type=bool, default = True)\n    parser.add_argument('--greedy-upd', type=bool, default = True)\n    parser.add_argument('--prev-dims', type=list, default=[128, 256], help='input dims for TransformerEmbed')\n    parser.add_argument('--post-dims', type=list, default=[256, 128], help='hidden dims for TransformerEmbed')\n    parser.add_argument('--max-refine-steps', type=int, default=20, help='maximum timesteps of an episode')\n    parser.add_argument('--EmbeddingBackbone', type = str, default = 'Transformer', help = 'Transformer or GNN')\n    parser.add_argument('--max_num_topo_truss', type = int, default = 5)\n\n# args for check:\n    parser.add_argument('--check-file', type=str, default=None)\n\n# args for draw:\n    parser.add_argument('--draw-file', type=str, default=None)\n\n# args for transfer\n    parser.add_argument('--trans-folder-name', type=str, default=\"\")\n    return parser", "\nALL_CONFIGS = {\n    # 3D\n    'kr_sundial': \"configs/input_kr_sundial.yaml\",\n    # 2D\n    'without_buckle_case1': \"configs/input_without_buckle_case1.yaml\",\n    'without_buckle_case2': \"configs/input_without_buckle_case2.yaml\",\n    '17_bar_case': \"configs/input_17_bar_case.yaml\"\n}\n\ndef make_config(type_) -> Dict:\n    with open(ALL_CONFIGS[type_]) as f:\n        config = yaml.load(f, Loader=yaml.FullLoader)\n    return config", "}\n\ndef make_config(type_) -> Dict:\n    with open(ALL_CONFIGS[type_]) as f:\n        config = yaml.load(f, Loader=yaml.FullLoader)\n    return config"]}
{"filename": "configs/__init__.py", "chunked_list": ["from configs.config import *"]}
{"filename": "utils/utils.py", "chunked_list": ["import math\nimport random\nimport os\nimport matplotlib.pyplot as plt\nimport shutil\nimport numpy as np\ndef util_init(args__):\n    global args\n    args = args__\n    \nclass Vector3:\n    def __init__(self, x=0.0, y=0.0, z=0.0):\n        self.x = float(x)\n        self.y = float(y)\n        self.z = float(z)\n\n    def __add__(self, obj):\n        return Vector3(self.x + obj.x, self.y + obj.y, self.z + obj.z)\n\n    def __sub__(self, obj):\n        return Vector3(self.x - obj.x, self.y - obj.y, self.z - obj.z)\n\n    def __mul__(self, obj):\n        if (type(obj) == Vector3):\n            return Vector3(self.y * obj.z - self.z * obj.y, self.z * obj.x - self.x * obj.z,\n                           self.x * obj.y - self.y * obj.x)\n        if (type(obj) == float or type(obj) == int):\n            return Vector3(self.x * obj, self.y * obj, self.z * obj)\n        assert (False)\n\n    def __str__(self):\n        return str('(' + str(self.x) + ', ' + str(self.y) + ', ' + str(self.z) + ')')\n\n    def length2(self):\n        return float(self.x * self.x + self.y * self.y + self.z * self.z)\n\n    def length(self):\n        return (self.x * self.x + self.y * self.y + self.z * self.z) ** .5\n\n    def norm(self):\n        l = self.length()\n        return Vector3(self.x / l, self.y / l, self.z / l)\n\n    def __eq__(self, other):\n        assert (type(other) == Vector3)\n        if (abs(self.x - other.x) < 1e-8 and abs(self.y - other.y) < 1e-8 and abs(self.z - other.z) < 1e-8):\n            return True\n        else:\n            return False", "    \nclass Vector3:\n    def __init__(self, x=0.0, y=0.0, z=0.0):\n        self.x = float(x)\n        self.y = float(y)\n        self.z = float(z)\n\n    def __add__(self, obj):\n        return Vector3(self.x + obj.x, self.y + obj.y, self.z + obj.z)\n\n    def __sub__(self, obj):\n        return Vector3(self.x - obj.x, self.y - obj.y, self.z - obj.z)\n\n    def __mul__(self, obj):\n        if (type(obj) == Vector3):\n            return Vector3(self.y * obj.z - self.z * obj.y, self.z * obj.x - self.x * obj.z,\n                           self.x * obj.y - self.y * obj.x)\n        if (type(obj) == float or type(obj) == int):\n            return Vector3(self.x * obj, self.y * obj, self.z * obj)\n        assert (False)\n\n    def __str__(self):\n        return str('(' + str(self.x) + ', ' + str(self.y) + ', ' + str(self.z) + ')')\n\n    def length2(self):\n        return float(self.x * self.x + self.y * self.y + self.z * self.z)\n\n    def length(self):\n        return (self.x * self.x + self.y * self.y + self.z * self.z) ** .5\n\n    def norm(self):\n        l = self.length()\n        return Vector3(self.x / l, self.y / l, self.z / l)\n\n    def __eq__(self, other):\n        assert (type(other) == Vector3)\n        if (abs(self.x - other.x) < 1e-8 and abs(self.y - other.y) < 1e-8 and abs(self.z - other.z) < 1e-8):\n            return True\n        else:\n            return False", "        \n\nclass Point:\n\n    def __init__(self, vec=Vector3(), supportX = 0, supportY = 0, supportZ = 0, loadX = 0.0, loadY = 0.0, loadZ = 0.0):\n        \n        self.vec = vec\n        self.supportX = supportX\n        self.supportY = supportY\n        self.supportZ = supportZ\n        self.isSupport = False\n        if (supportX == 1 and supportY == 1 and supportZ == 1):\n            self.isSupport = True\n        self.loadX = loadX\n        self.loadY = loadY\n        self.loadZ = loadZ\n        self.isLoad = False\n        if (abs(loadX) > 1e-7 or abs(loadY) > 1e-7 or abs(loadZ) > 1e-7):\n            self.isLoad = True\n    \n    def Point2np(self):\n        return np.array([self.vec.x, self.vec.y, self.vec.z])", "\nclass Bar:\n    def __init__(self, u=-1, v=-1, area=1.0, leng=0.0, inertia=1.0, name_s = 'dt', d = None, t = None):\n        self.u = int(u)\n        self.v = int(v)\n        self.d = d\n        self.t = t\n        self._area = float(area)\n        self._inertia = inertia\n        self.force = 0.0\n        self.len = leng\n        self.stress = 0.0 # calculate in dynamic\n        self.name_s = name_s\n            \n    @property\n    def area(self):\n        if (self.d == None): return self._area\n        else: return math.pi * self.d ** 2 / 4.0 - math.pi * (self.d - 2 * self.t) ** 2 / 4.0\n\n    @property\n    #TODO Ratio-ring\n    def inertia(self):\n        if (self.d == None): return self.area ** 2 * (1 + 0 ** 2) / (4 * math.pi * (1 - 0 ** 2))\n        else: return math.pi * self.d ** 4 / 64.0 - math.pi * (self.d - 2 * self.t) ** 4 / 64.0", "\ndef randpoint():\n    x = random.random() * 2.0 - 1.0\n    y = random.random() * 2.0 - 1.0\n    z = random.random() * 2.0 - 1.0\n    while(x * x + y * y + z * z > 1.0):\n        x = random.random() * 2.0 - 1.0\n        y = random.random() * 2.0 - 1.0\n        z = random.random() * 2.0 - 1.0\n    return Vector3(x, y, z)", "\ndef getrand(x, y):\n    if (x > y): return x\n    return random.uniform(x, y)\n\ndef Kernel1(x1, x2, sgm):\n    assert(type(x1) == float and type(x2) == float)\n    return math.exp(-(x1 - x2) * (x1 - x2) / (2 * sgm * sgm))\n\ndef Kernel2(x1, x2, sgm):\n    assert(type(x1) == Vector3 and type(x2) == Vector3)\n    vec = x1 - x2\n    len2 = vec.x * vec.x + vec.y * vec.y + vec.z * vec.z\n    return math.exp(-(len2 / (2 * sgm * sgm)))", "\ndef Kernel2(x1, x2, sgm):\n    assert(type(x1) == Vector3 and type(x2) == Vector3)\n    vec = x1 - x2\n    len2 = vec.x * vec.x + vec.y * vec.y + vec.z * vec.z\n    return math.exp(-(len2 / (2 * sgm * sgm)))\n\ndef getlen(vec):\n    return math.sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z)\n\ndef getlen2(u, v):\n    return getlen(u.vec - v.vec)", "\ndef getlen2(u, v):\n    return getlen(u.vec - v.vec)\n\ndef getang(vec1, vec2):\n    return (vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z) / (getlen(vec1) * getlen(vec2))\n\ndef intersect(N1, N2, N3, N4):\n    game_stop = False\n    X1=N1.x\n    Y1=N1.y\n    X2=N2.x\n    Y2=N2.y\n    X3=N3.x\n    Y3=N3.y\n    X4=N4.x\n    Y4=N4.y\n\n    if N1 != N3 and N1 != N4 and N2 != N3 and N2 != N4:\n        SIN13_14=(X3-X1)*(Y4-Y1)-(X4-X1)*(Y3-Y1)\n        SIN23_24=(X3-X2)*(Y4-Y2)-(X4-X2)*(Y3-Y2)\n        SIN31_32=(X1-X3)*(Y2-Y3)-(X2-X3)*(Y1-Y3)\n        SIN41_42=(X1-X4)*(Y2-Y4)-(X2-X4)*(Y1-Y4)\n\n        if SIN13_14*SIN23_24<=0 and SIN31_32*SIN41_42<=0:\n            SIN12_23=(X2-X1)*(Y3-Y2)-(X3-X2)*(Y2-Y1)\n            SIN12_24=(X2-X1)*(Y4-Y2)-(X4-X2)*(Y2-Y1)\n            SIN23_34=(X3-X2)*(Y4-Y3)-(X4-X3)*(Y3-Y2)\n            SIN13_34=(X3-X1)*(Y4-Y3)-(X4-X3)*(Y3-Y1)\n\n            if SIN12_23!=0 and SIN12_24!=0 and SIN23_34!=0 and SIN13_34!=0:\n                game_stop=True\n\n\n    SIN13_14=(X3-X1)*(Y4-Y1)-(X4-X1)*(Y3-Y1)\n    SIN23_24=(X3-X2)*(Y4-Y2)-(X4-X2)*(Y3-Y2)\n    if (abs(SIN13_14) < 1e-7 and abs(SIN23_24) < 1e-7):\n        D13 = math.sqrt((X3 - X1) * (X3 - X1) + (Y3 - Y1) * (Y3 - Y1))\n        D14 = math.sqrt((X4 - X1) * (X4 - X1) + (Y4 - Y1) * (Y4 - Y1))\n        D23 = math.sqrt((X3 - X2) * (X3 - X2) + (Y3 - Y2) * (Y3 - Y2))\n        D24 = math.sqrt((X4 - X2) * (X4 - X2) + (Y4 - Y2) * (Y4 - Y2))\n        D1 = D13 + D24\n        D2 = D23 + D14\n        if (abs(D1 - D2) > 1e-7):\n            game_stop = True\n    return game_stop", "\ndef getang(vec1, vec2):\n    return (vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z) / (getlen(vec1) * getlen(vec2))\n\ndef transintersect(u1, v1, u2, v2, p):\n    if (intersect(p[u1].vec, p[v1].vec, p[u2].vec, p[v2].vec)):\n        return True\n    return False\n\ndef readFile(input_file):\n    r'''\n\n    :param input_file: File name\n    :return: point list, edge list\n    '''\n\n    p = []\n    e = []\n\n    with open(input_file, \"r\") as fle:\n        lines = fle.readlines()\n        for i in range(len(lines)):\n            if len(lines[i]) < 2:\n                continue\n            line = lines[i]\n            vec = line.strip().split(' ')\n            if (i == 0):\n                vn = int(vec[0])\n                en = int(vec[1])\n                continue\n\n            if (1 <= i and i <= vn):\n                p.append(Point(Vector3(float(vec[0]), float(vec[1]), float(vec[2])), int(vec[3]), int(vec[4]), int(vec[5]), float(vec[6]), float(vec[7]), float(vec[8])))\n                continue\n\n            if (vn + 1 <= i and i <= vn + en):\n                if (len(vec) > 3 and vec[3] != 'None'):\n                    d = float(vec[3])\n                    t = float(vec[4])\n                else:\n                    d = None\n                    t = None\n                if (float(vec[2]) < 0): continue\n                e.append(Bar(vec[0], vec[1], float(vec[2]), getlen2(p[int(vec[0])], p[int(vec[1])]), d = d, t = t))\n    return p, e", "\ndef readFile(input_file):\n    r'''\n\n    :param input_file: File name\n    :return: point list, edge list\n    '''\n\n    p = []\n    e = []\n\n    with open(input_file, \"r\") as fle:\n        lines = fle.readlines()\n        for i in range(len(lines)):\n            if len(lines[i]) < 2:\n                continue\n            line = lines[i]\n            vec = line.strip().split(' ')\n            if (i == 0):\n                vn = int(vec[0])\n                en = int(vec[1])\n                continue\n\n            if (1 <= i and i <= vn):\n                p.append(Point(Vector3(float(vec[0]), float(vec[1]), float(vec[2])), int(vec[3]), int(vec[4]), int(vec[5]), float(vec[6]), float(vec[7]), float(vec[8])))\n                continue\n\n            if (vn + 1 <= i and i <= vn + en):\n                if (len(vec) > 3 and vec[3] != 'None'):\n                    d = float(vec[3])\n                    t = float(vec[4])\n                else:\n                    d = None\n                    t = None\n                if (float(vec[2]) < 0): continue\n                e.append(Bar(vec[0], vec[1], float(vec[2]), getlen2(p[int(vec[0])], p[int(vec[1])]), d = d, t = t))\n    return p, e", "\ndef readFilewithload(input_file):\n    r'''\n\n    :param input_file: File name\n    :return: point list, edge list\n    '''\n\n    p = []\n    e = []\n    load = []\n\n    with open(input_file, \"r\") as fle:\n        lines = fle.readlines()\n        for i in range(len(lines)):\n            if len(lines[i]) < 2:\n                continue\n            line = lines[i]\n            vec = line.strip().split(' ')\n            if (i == 0):\n                vn = int(vec[0])\n                en = int(vec[1])\n                continue\n\n            if (1 <= i and i <= vn):\n                p.append(Point(Vector3(float(vec[0]), float(vec[1]), float(vec[2])), int(vec[3]), int(vec[4]), int(vec[5]), float(vec[6]), float(vec[7]), float(vec[8])))\n                load.append(float(vec[7]))\n                continue\n\n            if (vn + 1 <= i and i <= vn + en):\n                if (len(vec) > 3 and vec[3] != 'None'):\n                    d = float(vec[3])\n                    t = float(vec[4])\n                else:\n                    d = None\n                    t = None\n                if (float(vec[2]) < 0): continue\n                e.append(Bar(vec[0], vec[1], float(vec[2]), getlen2(p[int(vec[0])], p[int(vec[1])]), d = d, t = t))\n    return p, e, load", "\ndef readAlist(Alist_path):\n    AREAFILE = Alist_path\n    alist = []\n    with open(AREAFILE,'r') as ar:\n        section_lines = ar.readlines()\n        for i in range(len(section_lines)):\n            section_line = section_lines[i]\n            section_r = section_line.strip().split(' ')\n            if (i==0):\n                section_num = int(section_r[0])\n            if (i > 0 and i <= section_num):\n                name_s = 'd' + str(section_r[0]) + 't' + str(int(float(section_r[1]) * 10))\n                d = float(section_r[0]) / 1000.0\n                t = float(section_r[1]) / 1000.0\n                area_s = math.pi * d ** 2 / 4.0 - math.pi * (d - 2 * t) ** 2 / 4.0\n                I_s = math.pi * d ** 4 / 64.0 - math.pi * ( d - 2 * t) ** 4 / 64.0\n                i_s = math.sqrt(I_s/area_s)\n                alist.append((float(area_s), float(I_s), float(i_s), str(name_s), float(d), float(t)))\n    return alist", "\ndef save_file_stage1(OUTFILE, p, e):\n    with open(OUTFILE, \"w\") as f:\n        print(len(p), len(e), file=f)\n        for i in range(len(p)):\n            print(p[i].vec.x, p[i].vec.y, p[i].vec.z, p[i].supportX, p[i].supportY,\n                p[i].supportZ, p[i].loadX, p[i].loadY, p[i].loadZ, file=f)\n        for i in range(len(e)): print(e[i].u, e[i].v, e[i].area, e[i].d, e[i].t, file = f)\n\ndef save_file(initial_points, state, mass, path, mode = 'Area', best = False, diverse_id = None):\n    r'''\n    save state into txt\n    :param initial_points: initial points, for support and load information\n    :param state: truss state\n    :param mass: mass of truss\n    :param path: path to store\n    :return: None\n    '''\n    if (best == False):\n        if (diverse_id == None):\n            fo = open(os.path.join(path, str(int(mass * 1000)) + \".txt\"), \"w\")\n        else: \n            fo = open(os.path.join(path, str(int(mass * 1000)) + \"_\" + str(diverse_id).zfill(2) + \".txt\"), \"w\")\n    else: fo = open(os.path.join(path, '_best.txt'), \"w\")\n    n = state.num_points\n    fo.write(\"{} {}\\n\".format(n, n * (n - 1) // 2))\n    for i in range(n):\n        x = state.nodes[i][0]\n        y = state.nodes[i][1]\n        if state.dimension == 2:\n            z = 0.0\n        else:\n            z = state.nodes[i][2]\n        fo.write(\"{} {} {} {} {} {} {} {} {}\\n\".format(x, y, z,\n                                                       initial_points[i].supportX, initial_points[i].supportY, initial_points[i].supportZ,\n                                                       initial_points[i].loadX, initial_points[i].loadY, initial_points[i].loadZ))\n    if (mode == 'Area'):\n        for i in range(n):\n            for j in range(i):\n                fo.write(\"{} {} {}\\n\".format(j, i, state.edges[i][j]))\n    if (mode == 'DT'):\n        for i in range(n):\n            for j in range(i):\n                if (state.edges[i][j][0] <= 0):\n                    fo.write(\"{} {} {} {} {}\\n\".format(j, i, -1, -1, -1))\n                else:\n                    d = state.edges[i][j][0]\n                    t = state.edges[i][j][1]\n                    if (t == 0): \n                        fo.write(\"{} {} {} {} {}\\n\".format(j, i, -1, -1, -1))\n                    else:\n                        area = math.pi*state.edges[i][j][0]**2/4.0 - math.pi*(state.edges[i][j][0]-2*state.edges[i][j][1])**2/4.0\n                        fo.write(\"{} {} {} {} {}\\n\".format(j, i, area, state.edges[i][j][0], state.edges[i][j][1]))\n    fo.close()", "\ndef save_file(initial_points, state, mass, path, mode = 'Area', best = False, diverse_id = None):\n    r'''\n    save state into txt\n    :param initial_points: initial points, for support and load information\n    :param state: truss state\n    :param mass: mass of truss\n    :param path: path to store\n    :return: None\n    '''\n    if (best == False):\n        if (diverse_id == None):\n            fo = open(os.path.join(path, str(int(mass * 1000)) + \".txt\"), \"w\")\n        else: \n            fo = open(os.path.join(path, str(int(mass * 1000)) + \"_\" + str(diverse_id).zfill(2) + \".txt\"), \"w\")\n    else: fo = open(os.path.join(path, '_best.txt'), \"w\")\n    n = state.num_points\n    fo.write(\"{} {}\\n\".format(n, n * (n - 1) // 2))\n    for i in range(n):\n        x = state.nodes[i][0]\n        y = state.nodes[i][1]\n        if state.dimension == 2:\n            z = 0.0\n        else:\n            z = state.nodes[i][2]\n        fo.write(\"{} {} {} {} {} {} {} {} {}\\n\".format(x, y, z,\n                                                       initial_points[i].supportX, initial_points[i].supportY, initial_points[i].supportZ,\n                                                       initial_points[i].loadX, initial_points[i].loadY, initial_points[i].loadZ))\n    if (mode == 'Area'):\n        for i in range(n):\n            for j in range(i):\n                fo.write(\"{} {} {}\\n\".format(j, i, state.edges[i][j]))\n    if (mode == 'DT'):\n        for i in range(n):\n            for j in range(i):\n                if (state.edges[i][j][0] <= 0):\n                    fo.write(\"{} {} {} {} {}\\n\".format(j, i, -1, -1, -1))\n                else:\n                    d = state.edges[i][j][0]\n                    t = state.edges[i][j][1]\n                    if (t == 0): \n                        fo.write(\"{} {} {} {} {}\\n\".format(j, i, -1, -1, -1))\n                    else:\n                        area = math.pi*state.edges[i][j][0]**2/4.0 - math.pi*(state.edges[i][j][0]-2*state.edges[i][j][1])**2/4.0\n                        fo.write(\"{} {} {} {} {}\\n\".format(j, i, area, state.edges[i][j][0], state.edges[i][j][1]))\n    fo.close()", "\ndef save_file_from_list(p, e, output_file):\n    with open(output_file, \"w\") as f:\n        print(len(p), len(e), file = f)\n        for i in range(len(p)):\n            print(p[i].vec.x, p[i].vec.y, p[i].vec.z, p[i].supportX, p[i].supportY, p[i].supportZ, p[i].loadX, p[i].loadY, p[i].loadZ, file = f)\n        for i in range(len(e)):\n            print(e[i].u, e[i].v, e[i].area, e[i].d, e[i].t, file = f)\n\ndef save_trajectory(initial_points, trajectory, mass, path):\n    r'''\n    save state into txt\n    :param initial_points: initial points, for support and load information\n    :param trajectory: history of truss states\n    :param mass: mass of truss\n    :param path: path to store\n    :return: None\n    '''\n    current_dir = os.getcwd()\n    dir = path + str(int(mass))\n    if os.path.exists(dir):\n        shutil.rmtree(dir)\n    os.mkdir(dir)\n    os.chdir(dir)\n    for i in range(len(trajectory)):\n        state = trajectory[i]\n\n        def _save_file(initial_points, state, file_name):\n            r'''\n            save state into txt\n            :param initial_points: initial points, for support and load information\n            :param state: truss state\n            :param mass: mass of truss\n            :param path: path to store\n            :return: None\n            '''\n            fo = open(file_name, \"w\")\n            n = state.num_points\n            fo.write(\"{} {}\\n\".format(n, n * (n - 1) // 2))\n            for i in range(n):\n                x = state.nodes[i][0]\n                y = state.nodes[i][1]\n                if state.dimension == 2:\n                    z = 0.0\n                else:\n                    z = state.nodes[i][2]\n                fo.write(\"{} {} {} {} {} {} {} {} {}\\n\".format(x, y, z,\n                                                               initial_points[i].supportX, initial_points[i].supportY, initial_points[i].supportZ,\n                                                               initial_points[i].loadX, initial_points[i].loadY, initial_points[i].loadZ))\n            for i in range(n):\n                for j in range(i):\n                    fo.write(\"{} {} {}\\n\".format(j, i, state.edges[i][j]))\n            fo.close()\n\n        def _saveGraph(p, e, file):\n            for i in range(len(p)):\n                plt.scatter([p[i].vec.x], [p[i].vec.y], color='b')\n\n            for i in range(len(e)):\n                x0 = [p[e[i].u].vec.x, p[e[i].v].vec.x]\n                y0 = [p[e[i].u].vec.y, p[e[i].v].vec.y]\n\n                if e[i].area != -1:\n                    plt.plot(x0, y0, color='b', linewidth=e[i].area / 0.01)\n\n            plt.axis(\"equal\")\n            plt.savefig(file)\n            plt.cla()\n\n        _save_file(initial_points, state, str(i) + \".txt\")\n\n    os.chdir(current_dir)", "\ndef save_trajectory(initial_points, trajectory, mass, path):\n    r'''\n    save state into txt\n    :param initial_points: initial points, for support and load information\n    :param trajectory: history of truss states\n    :param mass: mass of truss\n    :param path: path to store\n    :return: None\n    '''\n    current_dir = os.getcwd()\n    dir = path + str(int(mass))\n    if os.path.exists(dir):\n        shutil.rmtree(dir)\n    os.mkdir(dir)\n    os.chdir(dir)\n    for i in range(len(trajectory)):\n        state = trajectory[i]\n\n        def _save_file(initial_points, state, file_name):\n            r'''\n            save state into txt\n            :param initial_points: initial points, for support and load information\n            :param state: truss state\n            :param mass: mass of truss\n            :param path: path to store\n            :return: None\n            '''\n            fo = open(file_name, \"w\")\n            n = state.num_points\n            fo.write(\"{} {}\\n\".format(n, n * (n - 1) // 2))\n            for i in range(n):\n                x = state.nodes[i][0]\n                y = state.nodes[i][1]\n                if state.dimension == 2:\n                    z = 0.0\n                else:\n                    z = state.nodes[i][2]\n                fo.write(\"{} {} {} {} {} {} {} {} {}\\n\".format(x, y, z,\n                                                               initial_points[i].supportX, initial_points[i].supportY, initial_points[i].supportZ,\n                                                               initial_points[i].loadX, initial_points[i].loadY, initial_points[i].loadZ))\n            for i in range(n):\n                for j in range(i):\n                    fo.write(\"{} {} {}\\n\".format(j, i, state.edges[i][j]))\n            fo.close()\n\n        def _saveGraph(p, e, file):\n            for i in range(len(p)):\n                plt.scatter([p[i].vec.x], [p[i].vec.y], color='b')\n\n            for i in range(len(e)):\n                x0 = [p[e[i].u].vec.x, p[e[i].v].vec.x]\n                y0 = [p[e[i].u].vec.y, p[e[i].v].vec.y]\n\n                if e[i].area != -1:\n                    plt.plot(x0, y0, color='b', linewidth=e[i].area / 0.01)\n\n            plt.axis(\"equal\")\n            plt.savefig(file)\n            plt.cla()\n\n        _save_file(initial_points, state, str(i) + \".txt\")\n\n    os.chdir(current_dir)", "\ndef is_edge_addable(u, v, points, edges, enabled=False):\n    r'''\n    Check if adding a bar between u and v is valid, only applied to 2-d case\n\n    :param u: index of one end of the edge\n    :param v: index of the other end of the edge\n    :param points: nodes\n    :param edges: edges\n    :param enabled: Whether use this function to check edge constraint, if False, always return True\n    :return: bool\n    '''\n\n    max_length = 18\n    minang = 10\n    cosminang = np.cos(minang / 180.0 * np.pi)\n    max_edges = 10\n\n    #\u5224\u65ad\u6746\u4ef6\u662f\u5426\u4ea4\u53c9\n    def _intersect(point_u1,point_v1,point_u2,point_v2): #\u56db\u4e2a\u70b9\u5bf9\u8c61\uff0c\u5176\u4e2du1v1\u4e3a\u4e00\u6839\u6746\uff0cu2v2\u4e3a\u4e00\u6839\u6746\n        intersected = False\n\n        u1=np.array([point_u1.vec.x,point_u1.vec.y])\n        v1=np.array([point_v1.vec.x,point_v1.vec.y])\n        u2=np.array([point_u2.vec.x,point_u2.vec.y])\n        v2=np.array([point_v2.vec.x,point_v2.vec.y])      #\u53d6\u5f97\u56db\u4e2a\u70b9\u5750\u6807\u5411\u91cf\n\n        u1v1=v1-u1\n        u2v2=v2-u2     #\u6746\u4ef6\u5411\u91cf\n\n        u1u2=u2-u1\n        u1v2=v2-u1\n\n        u2u1=u1-u2\n        u2v1=v1-u2\n\n        def compare(a,b):\n            if((a[0] < b[0]) or (a[0] == b[0] and a[1] < b[1])):\n                return -1\n            elif(a[0] == b[0] and a[1] == b[1]):\n                return 0\n            else:\n                return 1\n        #\u5bf9\u4e00\u6761\u7ebf\u6bb5\u7684\u4e24\u7aef\u70b9\u8fdb\u884c\u6392\u5e8f\uff0c\u6a2a\u5750\u6807\u5927\u7684\u70b9\u66f4\u5927\uff0c\u6a2a\u5750\u6807\u76f8\u540c\uff0c\u7eb5\u5750\u6807\u5927\u7684\u70b9\u66f4\u5927\uff0c\u5347\u5e8f\u6392\u5e8f\n        po=[u1,v1,u2,v2]\n        if compare(po[0],po[1])>0:\n            temp=po[0]\n            po[0]=po[1]\n            po[1]=temp\n        if compare(po[2],po[3])>0:\n            temp=po[2]\n            po[2]=po[3]\n            po[3]=temp\n\n        #\u8003\u8651\u4e00\u822c\u60c5\u51b5\n        if  ((np.cross(u1v1,u1u2)*np.cross(u1v1,u1v2)<0 and np.cross(u2v2,u2u1)*np.cross(u2v2,u2v1)<0) or    #\u53c9\u79ef\u5747\u5c0f\u4e8e0\uff0c\u8de8\u8d8a\u4ea4\u53c9\n            (np.cross(u1v1,u1u2)*np.cross(u1v1,u1v2)==0 and np.cross(u2v2,u2u1)*np.cross(u2v2,u2v1)<0) or    #\u4efb\u610f\u4e00\u65b9=0\uff0c \u53e6\u4e00\u65b9<0\uff0c\u4e3a\u4e00\u8282\u70b9\u4f4d\u4e8e\u53e6\u4e00\u6746\u4ef6\u4e0a\n            (np.cross(u1v1,u1u2)*np.cross(u1v1,u1v2)<0 and np.cross(u2v2,u2u1)*np.cross(u2v2,u2v1)==0)):     #\u987a\u4fbf\u6392\u9664\u4e86\u6709\u516c\u5171\u70b9\u7684\u60c5\u51b5\uff0c\u6709\u516c\u5171\u70b9\u4e24\u65b9\u5747\u4e3a0\n            intersected = True\n\n        #\u8003\u8651\u5982\u679c\u4e24\u7ebf\u6bb5\u5171\u7ebf\u91cd\u53e0\n        if np.cross(u1v1,u2v2)==0 and np.cross(u1v1,u1v2)==0: #\u4e24\u7ebf\u6bb5\u5171\u7ebf\n            if(compare(po[0],po[2]) <= 0 and compare(po[1],po[2]) > 0):     #\u7b2c\u4e00\u6761\u8d77\u70b9\u5c0f\u4e8e\u7b2c\u4e8c\u6761\u8d77\u70b9\uff0c\u7b2c\u4e00\u6761\u7ec8\u70b9\u5927\u4e8e\u7b2c\u4e8c\u6761\u8d77\u70b9\n                intersected = True\n            elif(compare(po[2],po[0]) <= 0 and compare(po[3],po[0]) > 0):   #\u7b2c\u4e8c\u6761\u8d77\u70b9\u5c0f\u4e8e\u7b2c\u4e00\u6761\u8d77\u70b9\uff0c\u7b2c\u4e8c\u6761\u7ec8\u70b9\u5927\u4e8e\u7b2c\u4e00\u6761\u8d77\u70b9\n                intersected = True\n\n        return intersected\n\n    def _transintersect(\n        u1,v1,u2,v2,\n        points,\n    ): # ?\n        if (\n            _intersect(\n                points[u1], points[v1], points[u2], points[v2]\n            )\n        ):\n            return True\n\n        if (u1 == u2):\n            if (\n                getang(\n                    points[v1].vec - points[u1].vec,\n                    points[v2].vec - points[u2].vec,\n                ) > cosminang\n            ):\n                return True\n        if (u1 == v2):\n            if (\n                getang(\n                    points[v1].vec - points[u1].vec,\n                    points[u2].vec - points[v2].vec,\n                ) > cosminang\n            ):\n                return True\n        if (v1 == u2):\n            if (\n                getang(\n                    points[u1].vec - points[v1].vec,\n                    points[v2].vec - points[u2].vec,\n                ) > cosminang\n            ):\n                return True\n        if (v1 == v2):\n            if (\n                getang(\n                    points[u1].vec - points[v1].vec,\n                    points[u2].vec - points[v2].vec,\n                ) > cosminang\n            ):\n                return True\n\n        return False\n\n    def _is_too_long(point_u, point_v):\n        return getlen2(point_u, point_v) > max_length\n\n    # MODIFICATION: not considering EDGE_CONFIG\n\n    if not enabled:\n        return True\n\n    if _is_too_long(points[u], points[v]):\n        return False\n\n    if points[u].isSupport and points[v].isSupport:\n        return False\n\n    for edge in edges.values():\n        if (\n            _transintersect(\n                u, v, edge.u, edge.v, points\n            )\n        ):\n            return False\n\n    return True", "\ndef getuv(x):\n    x += 1\n    v = math.ceil(\n        (math.sqrt(1 + 8 * x) - 1) / 2.0\n    )\n    u = x - v * (v - 1) // 2 - 1\n    return u, v\n\ndef similar_position(p1, e1, p2, e2):\n    pts1 = []\n    pts2 = []\n    for p in p1:\n        pts1.append([p.vec.x, p.vec.y, p.vec.z])\n    for p in p2:\n        pts2.append([p.vec.x, p.vec.y, p.vec.z])\n    es1 = []\n    es2 = []\n    for e in e1:\n        es1.append([pts1[e.u], pts1[e.v]])\n        es1.append([pts1[e.v], pts1[e.u]])\n    for e in e2:\n        es2.append([pts2[e.u], pts2[e.v]])\n        es2.append([pts2[e.v], pts2[e.u]])\n    if sorted(pts1) != sorted(pts2): return False\n    if sorted(es1) != sorted(es2): return False\n    return True", "\ndef similar_position(p1, e1, p2, e2):\n    pts1 = []\n    pts2 = []\n    for p in p1:\n        pts1.append([p.vec.x, p.vec.y, p.vec.z])\n    for p in p2:\n        pts2.append([p.vec.x, p.vec.y, p.vec.z])\n    es1 = []\n    es2 = []\n    for e in e1:\n        es1.append([pts1[e.u], pts1[e.v]])\n        es1.append([pts1[e.v], pts1[e.u]])\n    for e in e2:\n        es2.append([pts2[e.u], pts2[e.v]])\n        es2.append([pts2[e.v], pts2[e.u]])\n    if sorted(pts1) != sorted(pts2): return False\n    if sorted(es1) != sorted(es2): return False\n    return True", "\ndef similar_topo(p1, e1, p2, e2):\n    pts1 = []\n    pts2 = []\n    for i in range(len(p1)): pts1.append(i)\n    for i in range(len(p2)): pts2.append(i)\n    es1 = []\n    es2 = []\n    for e in e1:\n        es1.append([pts1[e.u], pts1[e.v]])\n        es1.append([pts1[e.v], pts1[e.u]])\n    for e in e2:\n        es2.append([pts2[e.u], pts2[e.v]])\n        es2.append([pts2[e.v], pts2[e.u]])\n    if sorted(pts1) != sorted(pts2): return False\n    if sorted(es1) != sorted(es2): return False\n    return True", "\ndef closestDistanceBetweenLines(a0, a1, b0, b1, \n        clampAll = False, clampA0 = False,clampA1 = False,clampB0 = False,clampB1 = False):\n        r''' \n        Given two lines defined by numpy.array pairs (a0,a1,b0,b1)\n        Return the closest points on each segment and their distance\n        '''\n        # If clampAll=True, set all clamps to True\n        if clampAll:\n            clampA0=True\n            clampA1=True\n            clampB0=True\n            clampB1=True\n        # Calculate denomitator\n        A = a1 - a0\n        B = b1 - b0\n        magA = np.linalg.norm(A)\n        magB = np.linalg.norm(B)\n    \n        _A = A / magA\n        _B = B / magB\n    \n        cross = np.cross(_A, _B)\n        denom = np.linalg.norm(cross) ** 2\n    \n        # If lines are parallel (denom=0) test if lines overlap.\n        # If they don't overlap then there is a closest point solution.\n        # If they do overlap, there are infinite closest positions, but there is a closest distance\n        if not denom:\n            d0 = np.dot(_A, (b0 - a0))\n        \n            # Overlap only possible with clamping\n            if clampA0 or clampA1 or clampB0 or clampB1:\n                d1 = np.dot(_A, (b1 - a0))\n            \n                # Is segment B before A?\n                if d0 <= 0 >= d1:\n                    if clampA0 and clampB1:\n                        if np.absolute(d0) < np.absolute(d1):\n                            return a0,b0,np.linalg.norm(a0-b0)\n                        return a0,b1,np.linalg.norm(a0-b1)\n                \n                # Is segment B after A?\n                elif d0 >= magA <= d1:\n                    if clampA1 and clampB0:\n                        if np.absolute(d0) < np.absolute(d1):\n                            return a1,b0,np.linalg.norm(a1-b0)\n                        return a1,b1,np.linalg.norm(a1-b1)\n                \n            # Segments overlap, return distance between parallel segments\n            return None,None,np.linalg.norm(((d0*_A)+a0)-b0)\n    \n        # Lines criss-cross: Calculate the projected closest points\n        t = (b0 - a0)\n        detA = np.linalg.det([t, _B, cross])\n        detB = np.linalg.det([t, _A, cross])\n\n        t0 = detA/denom\n        t1 = detB/denom\n\n        pA = a0 + (_A * t0) # Projected closest point on segment A\n        pB = b0 + (_B * t1) # Projected closest point on segment B\n\n\n        # Clamp projections\n        if clampA0 or clampA1 or clampB0 or clampB1:\n            if clampA0 and t0 < 0:\n                pA = a0\n            elif clampA1 and t0 > magA:\n                pA = a1\n        \n            if clampB0 and t1 < 0:\n                pB = b0\n            elif clampB1 and t1 > magB:\n                pB = b1\n            \n            # Clamp projection A\n            if (clampA0 and t0 < 0) or (clampA1 and t0 > magA):\n                dot = np.dot(_B,(pA-b0))\n                if clampB0 and dot < 0:\n                    dot = 0\n                elif clampB1 and dot > magB:\n                    dot = magB\n                pB = b0 + (_B * dot)\n    \n            # Clamp projection B\n            if (clampB0 and t1 < 0) or (clampB1 and t1 > magB):\n                dot = np.dot(_A,(pB-a0))\n                if clampA0 and dot < 0:\n                    dot = 0\n                elif clampA1 and dot > magA:\n                    dot = magA\n                pA = a0 + (_A * dot)\n\n        return pA, pB, np.linalg.norm(pA - pB)"]}
{"filename": "algo/UCT_deprecate.py", "chunked_list": ["from glob import glob\nfrom utils.utils import Vector3, Point, Bar\nfrom utils.utils import getrand, randpoint, Kernel1, Kernel2, getlen, getlen2\nfrom truss_envs.reward import *\nimport math\nimport copy\nimport random\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time", "import matplotlib.pyplot as plt\nimport time\nimport heapq\n\ndef intersect(N1, N2, N3, N4):\n    game_stop = False\n    X1=N1.x\n    Y1=N1.y\n    X2=N2.x\n    Y2=N2.y\n    X3=N3.x\n    Y3=N3.y\n    X4=N4.x\n    Y4=N4.y\n\n    if N1 != N3 and N1 != N4 and N2 != N3 and N2 != N4:\n        SIN13_14=(X3-X1)*(Y4-Y1)-(X4-X1)*(Y3-Y1)\n        SIN23_24=(X3-X2)*(Y4-Y2)-(X4-X2)*(Y3-Y2)\n        SIN31_32=(X1-X3)*(Y2-Y3)-(X2-X3)*(Y1-Y3)\n        SIN41_42=(X1-X4)*(Y2-Y4)-(X2-X4)*(Y1-Y4)\n\n        if SIN13_14*SIN23_24<=0 and SIN31_32*SIN41_42<=0:\n            SIN12_23=(X2-X1)*(Y3-Y2)-(X3-X2)*(Y2-Y1)\n            SIN12_24=(X2-X1)*(Y4-Y2)-(X4-X2)*(Y2-Y1)\n            SIN23_34=(X3-X2)*(Y4-Y3)-(X4-X3)*(Y3-Y2)\n            SIN13_34=(X3-X1)*(Y4-Y3)-(X4-X3)*(Y3-Y1)\n\n            if SIN12_23!=0 and SIN12_24!=0 and SIN23_34!=0 and SIN13_34!=0:\n                game_stop=True\n\n\n    SIN13_14=(X3-X1)*(Y4-Y1)-(X4-X1)*(Y3-Y1)\n    SIN23_24=(X3-X2)*(Y4-Y2)-(X4-X2)*(Y3-Y2)\n    if (abs(SIN13_14) < 1e-7 and abs(SIN23_24) < 1e-7):\n        D13 = math.sqrt((X3 - X1) * (X3 - X1) + (Y3 - Y1) * (Y3 - Y1))\n        D14 = math.sqrt((X4 - X1) * (X4 - X1) + (Y4 - Y1) * (Y4 - Y1))\n        D23 = math.sqrt((X3 - X2) * (X3 - X2) + (Y3 - Y2) * (Y3 - Y2))\n        D24 = math.sqrt((X4 - X2) * (X4 - X2) + (Y4 - Y2) * (Y4 - Y2))\n        D1 = D13 + D24\n        D2 = D23 + D14\n        if (abs(D1 - D2) > 1e-7):\n            game_stop = True\n    return game_stop", "\n\ndef transintersect(u1, v1, u2, v2, p):\n    if (intersect(p[u1].vec, p[v1].vec, p[u2].vec, p[v2].vec)):\n        return True\n    return False\n\nclass Action():\n    def __init__(self, args, opt, u = -1, v = -1, area = -1, vec = Vector3(), eid = 0, d = None, t = None):\n        self.opt = opt\n        self.stateid = -1\n        self.d = None\n        self.t = None\n        if (opt == 0): self.vec = vec   # add node\n        if (opt == 1):                  # add edge\n            self.opt = opt\n            self.u = u\n            self.v = v\n            if (area != -1): self.area = area\n            else: self.area = args.maxarea\n            if (args.env_mode == 'DT'):\n                self.d = arealist[-1][4]\n                self.t = arealist[-1][5]\n        if (opt == 2):                  # change area\n            if (args.env_mode == 'DT'): assert(d > 0 and t > 0)\n            self.eid = eid\n            if (area != -1): self.area = area\n            else: self.area = maxarea\n            self.d = d\n            self.t = t\n    def __str__(self):\n        if (self.opt == 0): return \"add node at\" + self.vec.__str__()\n        if (self.opt == 1):\n            if (self.area < 1e-8): return \"do nothing\"\n            else: return \"add edge between\" + str(self.u) + \"and\" + str(self.v)\n        if (self.opt == 2): return \"modify area of \" + str(self.eid) + \"to \" + str(self.area)", "\nclass State():\n    def __init__(self, p, e, opt, fa = 0, elist = set(), eid = 0):\n        self.opt = opt\n        self.sons = []\n        self.isEnd = False\n        self.n = 0\n        self.q = 0\n        self.fa = fa\n        self.allvisited = False\n        self.w = 0.0\n        self.sumq = 0.0\n        self.sumw = 0.0\n        self.mq = -1000\n        if (opt == 0):\n            for i in range(len(plist)):\n                flag = False\n                tmpp = plist[i]\n                for j in range(len(p)):\n                    if (inlen(Point(tmpp), p[j])):\n                        flag = True\n                        break\n                if (flag == True): self.sons.append(Action(0, vec = tmpp))\n\n            for i in range(len(self.sons), args.initson):\n                flag = False\n                tmpp = Vector3(getrand(minx, maxx), getrand(miny, maxy), getrand(minz, maxz))\n                for j in range(len(p)):\n                    if (inlen(Point(tmpp), p[j])):\n                        flag = True\n                        break\n                if (flag == True): self.sons.append(Action(0, vec = tmpp))\n                \n        if (opt == 1):\n            self.reward = soft_reward(reward_fun(p, e), p, e)\n            if (self.reward > 1e-7): self.sons.append(Action(1)) # \u5f53\u524d\u7ed3\u6784\u7a33\u5b9a\n            for i in elist: \n                self.sons.append(Action(1, u = i[0], v = i[1]))\n            if (len(self.sons) == 0):\n                self.isEnd = True\n                self.reward = soft_reward(reward_fun(p, e), p, e)\n\n        if (opt == 2):\n            self.eid = eid\n            if (eid >= len(e)):\n                self.isEnd = True\n                self.reward = soft_reward(reward_fun(p, e), p, e)\n            else:\n                if (args.env_mode == 'DT'):\n                    for i in range(len(arealist)):\n                        self.sons.append(Action(2, d = arealist[i][4], t = arealist[i][5], eid = eid))\n                else:\n                    for i in range(args.initson + 1):\n                        self.sons.append(Action(2, area = minarea + (maxarea - minarea) / args.initson * i))\n\n    def findunvis(self): # find unvisited node\n        ret = -1\n        for i in range(len(self.sons)):\n            if (self.sons[i].stateid == -1):\n                ret = i\n                break\n        if (ret == -1): self.allvisited = True\n        return ret", "\nclass UCTs():\n    def UCTs_init(self, args, plist__ = [], arealist__ = []):\n        self.args = args\n        self.pbest = []\n        self.ebest = []\n        self.time_str = time.strftime(\"%Y-%m-%d-%H_%M_%S\",time.localtime())\n        self.bestreward = 1e9\n        self.tempbestreward = 1e9\n        self.minx = args.coordinate_range[0][0]\n        self.maxx = args.coordinate_range[0][1]\n        self.miny = args.coordinate_range[1][0]\n        self.maxy = args.coordinate_range[1][1]\n        self.statelist = []\n        if (args.env_dims == 3):\n            self.minz = args.coordinate_range[2][0]\n            self.maxz = args.coordinate_range[2][1]\n        else: self.minz = self.maxz = 0\n        self.minlen = args.len_range[0]\n        self.maxlen = args.len_range[1]\n        self.minarea = args.area_range[0]\n        self.maxarea = args.area_range[1]\n        self.arealist = arealist__\n        self.plist = plist__\n        self.save_valid_count = 0\n        self.save_invalid_count = 0\n        self.output_dir_init()\n    \n    def output_dir_init(self):\n        self.OUTPUT_ALL_THRESHOLD = self.args.OUTPUT_ALL_THRESHOLD\n        self.MASS_OUTPUT_ALL_THRESHOLD = self.args.MASS_OUTPUT_ALL_THRESHOLD\n        self.LOGFOLDER = self.args.save_path\n\n        if not os.path.exists(self.LOGFOLDER): os.mkdir(self.LOGFOLDER)\n\n        self.ALLFOLDER = self.LOGFOLDER + 'Reward_ALL_Result/'\n        if not os.path.exists(self.ALLFOLDER): os.mkdir(self.ALLFOLDER)\n        self.OUTPUT_ALL_MAX = 10000\n        print('OUTPUT_ALL_THRESHOLD:', self.OUTPUT_ALL_THRESHOLD)\n\n        self.MASS_ALLFOLDER = self.LOGFOLDER + 'MASS_ALL_Result/'\n        if not os.path.exists(self.MASS_ALLFOLDER): os.mkdir(self.MASS_ALLFOLDER)\n        self.MASS_OUTPUT_ALL_MAX = 10000\n        print('MASS_OUTPUT_ALL_THRESHOLD:', self.MASS_OUTPUT_ALL_THRESHOLD)\n\n    def similar(self, tup1, tup2):\n        p1 = tup1[2]\n        e1 = tup1[3]\n        p2 = tup2[2]\n        e2 = tup2[3]\n        pts1 = []\n        pts2 = []\n        for p in p1: pts1.append([p.vec.x, p.vec.y, p.vec.z])\n        for p in p2: pts2.append([p.vec.x, p.vec.y, p.vec.z])\n        es1 = []\n        es2 = []\n        for e in e1:\n            es1.append([pts1[e.u], pts1[e.v]])\n            es1.append([pts1[e.v], pts1[e.u]])\n        for e in e2:\n            es2.append([pts2[e.u], pts2[e.v]])\n            es2.append([pts2[e.v], pts2[e.u]])\n        if sorted(pts1) != sorted(pts2): return False\n        if sorted(es1) != sorted(es2): return False\n        return True\n\n    def save_file(self, OUTFILE, p, e, valid = True):\n        if (valid): self.save_valid_count += 1\n        else: self.save_invalid_count += 1\n        with open(OUTFILE, \"w\") as f:\n            print(len(p), len(e), file=f)\n            for i in range(len(p)):\n                print(p[i].vec.x, p[i].vec.y, p[i].vec.z, p[i].supportX, p[i].supportY,\n                    p[i].supportZ, p[i].loadX, p[i].loadY, p[i].loadZ, file=f)\n            for i in range(len(e)): print(e[i].u, e[i].v, e[i].area, e[i].d, e[i].t, file = f)\n\n    def diversity_save(self, reward, reward_count, Mass, Dis_value, Stress_value, Buckle_value, p, e):\n        FILES = os.listdir(self.ALLFOLDER)\n        if len(FILES) < self.OUTPUT_ALL_MAX and reward <= self.OUTPUT_ALL_THRESHOLD:\n            OUTFILE = self.ALLFOLDER + str(reward_count).zfill(len(str(self.OUTPUT_ALL_MAX))) + '_' + str(\n                round(Mass)) + '_' + str(round(reward)) + '.txt'\n            self.save_file(OUTFILE, p, e)\n\n        MASS_FILES = os.listdir(self.MASS_ALLFOLDER)\n        if len(MASS_FILES) < self.MASS_OUTPUT_ALL_MAX and Mass <= self.MASS_OUTPUT_ALL_THRESHOLD:\n            if not (Dis_value > 1e-7 or Stress_value > 1e-7 or Buckle_value > 1e-7):\n                OUTFILE = self.MASS_ALLFOLDER + str(round(Mass)) + '.txt'\n                self.save_file(OUTFILE, p, e)\n            \n    def soft_reward(self, env_output, p, e):\n        reward, reward_cnt, Mass, Dis_value, Stress_value, Buckle_value = env_output\n        if (reward <= 0):\n            if (self.save_invalid_count * self.args.save_invalid_factor < self.save_valid_count and reward == 0):\n                folder = os.path.join(self.LOGFOLDER, \"invalid\")\n                if (not os.path.exists(folder)): os.mkdir(folder)\n                self.save_file(os.path.join(folder, str(self.save_invalid_count) + '.txt'), p, e)\n            return reward\n        if (self.bestreward > reward):\n            self.bestreward = reward\n            self.pbest = copy.deepcopy(p)\n            self.ebest = copy.deepcopy(e)\n        if (self.tempbestreward > reward):\n            self.tempbestreward = reward\n        if (args.save_diversity):\n            self.diversity_save(reward, reward_cnt, Mass, Dis_value, Stress_value, Buckle_value, p, e)\n        reward= self.args.reward_lambda / (reward * reward)\n        return reward\n\n    def inlen(self, u, v):\n        if (getlen2(u, v) > self.maxlen and self.args.CONSTRAINT_MAX_LENGTH): return False\n        if (getlen2(u, v) < self.minlen and self.args.CONSTRAINT_MIN_LENGTH): return False\n        return True\n\n    def canadd(self, N1, N2, p, e):\n        if (not self.inlen(p[N1], p[N2])): return False\n        if (args.env_dims == 2 and args.CONSTRAINT_CROSS_EDGE == 1):\n            for i in range(len(e)):\n                N3 = e[i].u\n                N4 = e[i].v\n                if (transintersect(N1, N2, N3, N4, p)): return False\n        return True\n\n    def bestchild(self, now, c, alpha):\n        ret = -1\n        actid = -1\n        mx = 0\n        if (abs(c) < 1e-7): # final find, no explore \n            for i in range(len(self.statelist[now].sons)):\n                v = self.statelist[now].sons[i].stateid\n                if (self.statelist[now].opt == 1):\n                    tmp = alpha * self.statelist[v].q / self.statelist[v].n + (1 - alpha) * self.statelist[v].mq\n                    print(self.statelist[v].q, self.statelist[v].n, self.statelist[v].mq, self.statelist[v].q / self.statelist[v].n, 'a')\n                else:\n                    tmp = alpha * self.statelist[v].sumq / self.statelist[v].n + (1 - alpha) * self.statelist[v].mq\n                    print(self.statelist[v].q, self.statelist[v].sumq, self.statelist[v].mq, self.statelist[v].w, self.statelist[v].sumq / statelist[v].n, statelist[v].n)\n                if (ret == -1 or tmp > mx):\n                    ret = v\n                    mx = tmp\n                    actid = i\n\n            print(\"**************\")\n            print(round(self.statelist[ret].n,2), round(self.statelist[ret].mq,2))\n            print(\"**************\")\n        \n            return ret, self.statelist[now].sons[actid]\n    \n        if (self.statelist[now].opt == 1 or self.statelist[now].opt == 2):\n            for i in range(len(self.statelist[now].sons)):\n                v = self.statelist[now].sons[i].stateid\n                tmp = alpha * self.statelist[v].q / self.statelist[v].n + (1 - alpha) * self.statelist[v].mq + c * math.sqrt(2 * math.log(self.statelist[now].n) / self.statelist[v].n)\n                if (ret == -1 or tmp > mx):\n                    ret = v\n                    mx = tmp\n                    actid = i\n        else: # use kernel\n            for i in range(len(self.statelist[now].sons)):\n                v = self.statelist[now].sons[i].stateid\n                if (self.statelist[v].w < 1e-7):\n                    ret = v\n                    actid = i\n                    break\n                tmp = alpha * self.statelist[v].q / self.statelist[v].w + (1 - alpha) * self.statelist[v].mq\n                tmp = tmp + c * (math.sqrt(2 * math.log(self.statelist[now].sumw) / self.statelist[v].w) * 0.8 + math.sqrt(2 * math.log(self.statelist[now].n) / self.statelist[v].n) * 0.2)\n                if (ret == -1 or tmp > mx):\n                    ret = v\n                    mx = tmp\n                    actid = i\n        return ret, self.statelist[now].sons[actid]\n\n    def take_action(self, p, e, elist, act):\n        if (act.opt == 0):\n            p.append(Point(act.vec))\n            if (len(p) == args.maxp):\n                for i in range(len(p)):\n                    for j in range(i + 1, len(p)):\n                        if (not (p[i].isSupport and p[j].isSupport)) and self.inlen(p[i], p[j]):\n                            elist.add((i, j))\n\n        if (act.opt == 1):\n            if (act.u != -1 and act.v != -1):\n                e.append(Bar(act.u, act.v, act.area, getlen2(p[act.u], p[act.v]), d = act.d, t = act.t))\n                elist.remove((act.u, act.v))\n                if (args.env_dims == 2 and args.CONSTRAINT_CROSS_EDGE == 1):\n                    dellist = []\n                    for i in elist:\n                        if (transintersect(act.u, act.v, i[0], i[1], p)):\n                            dellist.append(i)\n                    for i in dellist: elist.remove(i)\n            else:\n                elist.clear()\n\n        if (act.opt == 2):\n            if args.env_mode == 'DT':\n                e[act.eid].d = act.d\n                e[act.eid].t = act.t\n            else:\n                e[act.eid]._area = act.area", "\ndef isok(vec):\n    if (minx <= vec.x and vec.x <= maxx and miny <= vec.y and vec.y <= maxy and minz <= vec.z and vec.z <= maxz):\n        return True\n    return False\n\ndef getnewchild0(stateid, vec):\n    assert(statelist[stateid].opt == 0)\n    finvec = Vector3()\n    bestw = 0.0\n\n    for iter in range(args.maxnum):\n        newvec = vec + randpoint() * args.sgm2 * 0.5\n        newvec.x = max(min(newvec.x, maxx), minx)\n        newvec.x = max(min(newvec.y, maxy), miny)\n        newvec.x = max(min(newvec.z, maxz), minz)\n        w = 0.0\n        for i in range(len(statelist[stateid].sons)):\n            w = w + Kernel2(newvec, statelist[stateid].sons[i].vec, args.sgm2) * statelist[statelist[stateid].sons[i].stateid].n\n        if (iter == 0 or w < bestw):\n            bestw = w\n            finvec = newvec\n\n    statelist[stateid].sons.append(Action(0, vec = finvec))\n    return len(statelist[stateid].sons) - 1", "    \n## gai\ndef getnewchild2(stateid, area):\n    assert(statelist[stateid].opt == 2)\n    finarea = maxarea\n    bestw = 0.0\n\n    for iter in range(args.maxnum):\n        newarea = getrand(max(minarea, area - args.sgm1 * 3), min(maxarea, area + args.sgm1 * 3))\n        w = 0.0\n        for i in range(len(statelist[stateid].sons)):\n            w = w + Kernel1(newarea, statelist[stateid].sons[i].area, args.sgm1)\n        if (iter == 0 or w < bestw):\n            bestw = w\n            finarea = newarea\n\n    statelist[stateid].sons.append(Action(2, area = finarea, eid = statelist[stateid].eid))\n    return len(statelist[stateid].sons) - 1", "\n\ndef treepolicy(stateid, p_, e_, elist_):\n    p = copy.deepcopy(p_)\n    e = copy.deepcopy(e_)\n    elist = copy.deepcopy(elist_)\n    global statelist\n    now = stateid\n    sonid = -1\n    while ((not statelist[now].isEnd) and (sonid == -1)):\n        opt = statelist[now].opt\n        ret = statelist[now].findunvis()\n        if (ret != -1):\n            sonid = ret\n            break\n        \n        nxt, act = bestchild(now, args.c[opt], args.alpha)\n        if (opt == 1):\n            now = nxt\n            take_action(p, e, elist, act)\n        \n        elif (opt == 0):\n            sizeA = len(statelist[now].sons)\n            if (sizeA * sizeA * 3 > statelist[now].n and (not statelist[nxt].isEnd or len(statelist[now].sons) > args.maxson)): \n                now = nxt\n                take_action(p, e, elist, act)\n            else: \n                sonid = getnewchild0(now, act.vec) #add new child\n        \n        elif (opt == 2):\n            sizeA = len(statelist[now].sons)\n            if (sizeA * sizeA * 3 > statelist[now].n and (not statelist[nxt].isEnd or len(statelist[now].sons) > args.maxson)): \n                now = nxt\n                take_action(p, e, elist, act)\n            else: \n                sonid = getnewchild2(now, act.area) #add new child\n\n\n    if (sonid >= 0): # add new child\n        act = statelist[now].sons[sonid]\n        take_action(p, e, elist, act)\n        opt = statelist[now].opt\n        if (opt == 0):\n            if (len(p) == args.maxp): newstate = State(p, e, 1, fa = now, elist = elist)\n            else: newstate = State(p, e, 0, fa = now)\n            for i in range(len(statelist[now].sons)):\n                if (i == sonid): continue\n                if (opt == 0):\n                    KAB = Kernel2(act.vec, statelist[now].sons[i].vec, args.sgm2)\n                else:\n                    KAB = Kernel1(act.area, statelist[now].sons[i].area, args.sgm1)\n                sid = statelist[now].sons[i].stateid\n                newstate.w = newstate.w + statelist[sid].n * KAB\n                newstate.q = newstate.q + statelist[sid].sumq * KAB\n        if (opt == 1):\n            if (act.u < 0): newstate = State(p, e, 2, fa = now, eid = 0)\n            else: newstate = State(p, e, 1, fa = now, elist = elist)\n        if (opt == 2): \n            newstate = State(p, e, 2, fa = now, eid = act.eid + 1)\n        statelist.append(newstate)\n        statelist[now].sons[sonid].stateid = len(statelist) - 1\n        now = len(statelist) - 1\n    return now, p, e, elist", "\ndef defaultpolicy(stateid, p, e, elist):\n    opt = statelist[stateid].opt\n    if (opt == 0):\n        while (len(p) < args.maxp):\n            p.append(Point(Vector3(getrand(minx, maxx), getrand(miny, maxy), getrand(minz, maxz))))\n        opt = 1\n\n    if (opt == 1):\n        for i in range(len(e)):\n            if (args.env_mode == 'DT'):\n                area_random = arealist[random.randint(0, len(arealist) - 1)]\n                e[i].d = area_random[4]\n                e[i].t = area_random[5]\n            else: e[i]._area = getrand(minarea, maxarea)\n        el = []\n        for i in elist: el.append(i)\n        if (len(el) == 0 and len(e) == 0):\n            for i in range(len(p)):\n                for j in range(i + 1, len(p)):\n                    if (p[i].isSupport and p[j].isSupport): continue\n                    if (not inlen(p[i], p[j])): continue\n                    el.append((i, j))\n\n        random.shuffle(el)\n        ret = -1\n        for i in range(len(el)):\n            probnow = random.random()\n            if (probnow > args.prob): continue\n            u = el[i][0]\n            v = el[i][1]\n            if (canadd(u, v, p, e)):\n                if (args.env_mode == 'DT'):\n                    area_random = arealist[random.randint(0, len(arealist) - 1)]\n                    e.append(Bar(u, v, leng = getlen2(p[u], p[v]), d=area_random[4], t=area_random[5]))\n                else: e.append(Bar(u, v, leng = getlen2(p[u], p[v]), area = getrand(minarea, maxarea)))\n                ret = soft_reward(reward_fun(p, e), p, e)\n                if (ret > 1e-7): return ret\n        return ret\n\n    if (opt == 2):\n        for i in range(statelist[stateid].eid, len(e)):\n            if (args.env_mode == 'DT'):\n                area_random = arealist[random.randint(0, len(arealist) - 1)]\n                e[i].d = area_random[4]\n                e[i].t = area_random[5]\n            else: e[i]._area = getrand(minarea, maxarea)\n        ret = soft_reward(reward_fun(p, e), p, e)\n        return ret\n\n    assert(False)", "\ndef backup(now, delta, root):\n    fa = statelist[now].fa\n    while (True):\n        statelist[now].n = statelist[now].n + 1\n        statelist[now].sumq = statelist[now].sumq + delta\n        if (statelist[now].mq < delta):\n            statelist[now].mq = delta\n        if (now == root): break\n        if (statelist[fa].opt == 1 or statelist[fa].opt == 2):\n            statelist[now].q = statelist[now].q + delta\n        elif (statelist[fa].opt == 0):  \n            sonid = -1\n            for i in range(len(statelist[fa].sons)):\n                if (statelist[fa].sons[i].stateid == now):\n                    sonid = i\n                    break\n            assert(sonid != -1)\n            vec0 = statelist[fa].sons[sonid].vec\n            for i in range(len(statelist[fa].sons)):\n                KAB = Kernel2(vec0, statelist[fa].sons[i].vec, args.sgm2)\n                sid = statelist[fa].sons[i].stateid\n                statelist[sid].w = statelist[sid].w + KAB\n                statelist[sid].q = statelist[sid].q + KAB * delta\n                statelist[fa].sumw = statelist[fa].sumw + KAB\n        now = fa\n        fa = statelist[now].fa", "\ndef UCTSearch(p, e):\n    global bestreward\n    global tmpbestreward\n    global elist\n    elist = set()\n    step_node = 1\n    opt = 0\n    eidnow = 0\n    maxiter = args.UCT_maxiter\n    root = 0\n    while (not (opt == 2 and eidnow >= len(e))):\n        statelist.clear()\n        tmpbestreward = 1e9\n        tmpbestreward2 = 1e9\n        root = 0\n        if (opt == 0):\n            statelist.append(State(p, e, 0, -1))\n            if (len(pbest) > len(p)):\n                statelist[root].sons.append(Action(0, vec = pbest[len(p)].vec))\n        if (opt == 1):\n            statelist.append(State(p, e, 1, -1, elist = elist))\n        if (opt == 2):\n            statelist.append(State(p, e, 2, -1, eid = eidnow))\n        extra_iter = 0\n        if (opt == 0): extra_iter = args.UCT_extra_iter_for_point_pos\n        for iter in range(maxiter + extra_iter):\n            tmp, ptmp, etmp, elisttmp = treepolicy(root, p, e, elist)\n            delta = defaultpolicy(tmp, ptmp, etmp, elisttmp)\n            backup(tmp, delta, root)\n            if (iter % 100 == 0):\n                tmpbestreward2 = min(tmpbestreward2, tmpbestreward)\n                print(iter, bestreward, tmpbestreward2, tmpbestreward, len(statelist[root].sons))\n                tmpbestreward = 1e9\n    \n        root2, tmpact = bestchild(root, 0.0, args.pickalpha)\n        if (opt == 0):\n            act = Action(0, vec = pbest[len(p)].vec)\n            # for SaveKR:\n            if args.save_KR == True:\n                KR_plist_x = []\n                KR_plist_y = []\n                KR_plist_z = []\n                print(len(p)+1,\"*****************************************\")\n#                print(len(p)+1,\"*****************************************\", file = LOG_result)\n                for ii in range(len(statelist[root].sons)):\n                    KR_plist_x.append(statelist[root].sons[ii].vec.x)\n                    KR_plist_y.append(statelist[root].sons[ii].vec.y)\n                    KR_plist_z.append(statelist[root].sons[ii].vec.z)\n                    print(ii,statelist[root].sons[ii].vec.x, statelist[root].sons[ii].vec.y, statelist[root].sons[ii].vec.z)\n#                    print(ii,statelist[root].sons[ii].vec.x, statelist[root].sons[ii].vec.y, statelist[root].sons[ii].vec.z, file = LOG_result)\n\n                print(len(p)+1,\"*****************************************\")\n#                print(len(p)+1,\"*****************************************\", file = LOG_result)\n                \n                X1=np.ones(len(KR_plist_x))\n                Y1=np.ones(len(KR_plist_x))\n                Z1=np.ones(len(KR_plist_x))\n                \n                fig1 = plt.figure()\n                ax1 = plt.axes(projection='3d')\n                for i in range(len(KR_plist_x)):\n                    ax1.scatter3D([KR_plist_x[i]], [KR_plist_y[i]], [KR_plist_z[i]], color='b')\n                    X1[i] = KR_plist_x[i]\n                    Y1[i] = KR_plist_y[i]\n                    Z1[i] = KR_plist_z[i]\n                # Create cubic bounding box to simulate equal aspect ratio\n                max_range = np.array([X1.max()-X1.min(), Y1.max()-Y1.min(), Z1.max()-Z1.min()]).max()\n                Xb1 = 0.5*max_range*np.mgrid[-1:2:2,-1:2:2,-1:2:2][0].flatten() + 0.5*(X1.max()+X1.min())\n                Yb1 = 0.5*max_range*np.mgrid[-1:2:2,-1:2:2,-1:2:2][1].flatten() + 0.5*(Y1.max()+Y1.min())\n                Zb1 = 0.5*max_range*np.mgrid[-1:2:2,-1:2:2,-1:2:2][2].flatten() + 0.5*(Z1.max()+Z1.min())\n                \n                # Comment or uncomment following both lines to test the fake bounding box:\n                for xb1, yb1, zb1 in zip(Xb1, Yb1, Zb1):\n                    ax1.plot([xb1], [yb1], [zb1], 'w')\n                \n                # plt.scatter(KR_plist_x, KR_plist_y, color='b')\n                # plt.axis(\"equal\")\n                inputname = FILENAME.replace(\".txt\",\"_\")\n                FILENAME_add_node_jpg = \"./results/\" + time_str + \"_\" + str(args.maxp) + \"p_\" + inputname + \"add-node-\"+str(step_node) + \".jpg\"\n                plt.savefig(FILENAME_add_node_jpg, dpi = 1000)\n                plt.close()\n                step_node = step_node + 1\n                print(len(KR_plist_x))\n\n        if (opt == 1):\n            if (len(e) == len(ebest)): act = Action(1)\n            else: act = Action(1, u = ebest[len(e)].u, v = ebest[len(e)].v)\n\n        if (opt == 2):\n            act = Action(2, area = ebest[eidnow].area, \n                eid = eidnow,\n                d = ebest[eidnow].d, \n                t = ebest[eidnow].t\n            )\n\n        take_action(p, e, elist, act)\n        \n        print(act)\n        print(bestreward, tmpbestreward)\n        \n        if (opt == 0):\n            if (len(p) == args.maxp): opt = 1\n        elif (opt == 1):\n            if (act.u == -1): opt = 2\n        elif (opt == 2):\n            eidnow = eidnow + 1\n    return bestreward, pbest, ebest"]}
{"filename": "algo/UCTs.py", "chunked_list": ["from utils.utils import Vector3, Point, Bar\nfrom utils.utils import getrand, randpoint, Kernel1, Kernel2, getlen, getlen2, save_file_stage1, readFile, transintersect, similar_position, similar_topo, closestDistanceBetweenLines\nfrom truss_envs.reward import *\nfrom algo.value_network import Value_Network\nimport math\nimport copy\nimport random\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time", "import matplotlib.pyplot as plt\nimport time\nimport heapq\n\npbest = []\nebest = []\nbestreward = 1e9\ntmpbestreward = 1e9\nFILENAME = \"kr-sundial-newinput.txt\"\ntime_str = time.strftime(\"%Y-%m-%d-%H_%M_%S\",time.localtime()) ", "FILENAME = \"kr-sundial-newinput.txt\"\ntime_str = time.strftime(\"%Y-%m-%d-%H_%M_%S\",time.localtime()) \n\ndef UCTs_init(args__, plist__ = [], arealist__ = []):\n    global args\n    global arealist\n    global plist\n    global minx\n    global maxx\n    global miny\n    global maxy\n    global minz\n    global maxz\n    global minlen\n    global maxlen\n    global minarea\n    global maxarea\n    global OUTPUT_ALL_THRESHOLD\n    global MASS_ALLFOLDER\n    global MASS_OUTPUT_ALL_MAX\n    global OUTPUT_ALL_MAX\n    global MASS_OUTPUT_ALL_THRESHOLD\n    global ALLFOLDER\n    global LOGFOLDER\n    global logfile\n    global DIVERSITY_FOLDER\n    global DIVERSITY_TOPO_FOLDER\n    global save_valid_count\n    global save_invalid_count\n    global v_network\n    global global_iteration\n    args = args__\n    minx = args.coordinate_range[0][0]\n    maxx = args.coordinate_range[0][1]\n    miny = args.coordinate_range[1][0]\n    maxy = args.coordinate_range[1][1]\n    if (args.env_dims == 3):\n        minz = args.coordinate_range[2][0]\n        maxz = args.coordinate_range[2][1]\n    else:\n        minz = maxz = 0\n    minlen = args.len_range[0]\n    maxlen = args.len_range[1]\n    minarea = args.area_range[0]\n    maxarea = args.area_range[1]\n    arealist = arealist__\n    plist = plist__\n    save_valid_count = 0\n    save_invalid_count = 0\n    global_iteration = 0\n    MASS_OUTPUT_ALL_THRESHOLD = args.MASS_OUTPUT_ALL_THRESHOLD\n    LOGFOLDER = os.path.join(args.save_path, args.run_id)\n\n    if not os.path.exists(LOGFOLDER): os.mkdir(LOGFOLDER)\n\n    ALLFOLDER = os.path.join(LOGFOLDER, 'Reward_ALL_Result/')\n    print(ALLFOLDER)\n    if not os.path.exists(ALLFOLDER): os.mkdir(ALLFOLDER)\n    OUTPUT_ALL_MAX = 10000\n\n    MASS_ALLFOLDER = os.path.join(LOGFOLDER, 'MASS_ALL_Result/')\n    if not os.path.exists(MASS_ALLFOLDER): os.mkdir(MASS_ALLFOLDER)\n    MASS_OUTPUT_ALL_MAX = 10000\n\n    DIVERSITY_FOLDER = os.path.join(LOGFOLDER, 'DIVERSITY_result/')\n    if not os.path.exists(DIVERSITY_FOLDER): os.mkdir(DIVERSITY_FOLDER)\n\n    DIVERSITY_TOPO_FOLDER = os.path.join(LOGFOLDER, 'DIVERSITY_TOPO_result/')\n    if not os.path.exists(DIVERSITY_TOPO_FOLDER): os.mkdir(DIVERSITY_TOPO_FOLDER)\n    logfile = open(os.path.join(LOGFOLDER, args.logfile_stage1), 'w')", "\ndef diversity_save(reward, reward_count, Mass, Dis_value, Stress_value, Buckle_value, p, e):\n    global save_valid_count\n    FILES = os.listdir(ALLFOLDER)\n    if (Mass > MASS_OUTPUT_ALL_THRESHOLD): return\n\n    MASS_FILES = os.listdir(MASS_ALLFOLDER)\n    if len(MASS_FILES) < MASS_OUTPUT_ALL_MAX:\n        OUTFILE = MASS_ALLFOLDER + str(round(Mass)) + '.txt'\n        if (not os.path.exists(OUTFILE)):\n            save_file_stage1(OUTFILE, p, e)\n            save_valid_count += 1\n\n    DIVERSITY_FILES = os.listdir(DIVERSITY_FOLDER)\n    d_flag = True\n    for d_file in DIVERSITY_FILES:\n        p_tmp, e_tmp = readFile(os.path.join(DIVERSITY_FOLDER, d_file))\n        mass_tmp = int(d_file[:-4])\n        if (similar_position(p, e, p_tmp, e_tmp)):\n            d_flag = False\n            if (mass_tmp <= Mass): continue\n            os.remove(os.path.join(DIVERSITY_FOLDER, d_file))\n            OUTFILE = DIVERSITY_FOLDER + str(round(Mass)) + '.txt'\n            if (not os.path.exists(OUTFILE)):\n                save_file_stage1(OUTFILE, p, e)\n\n    if (d_flag):\n        OUTFILE = DIVERSITY_FOLDER + str(round(Mass)) + '.txt'\n        if (not os.path.exists(OUTFILE)):\n            save_file_stage1(OUTFILE, p, e)\n\n    DIVERSITY_TOPO_FILES = os.listdir(DIVERSITY_TOPO_FOLDER)\n    d_flag = True\n    for d_file in DIVERSITY_TOPO_FILES:\n        p_tmp, e_tmp = readFile(os.path.join(DIVERSITY_TOPO_FOLDER, d_file))\n        mass_tmp = int(d_file[:-4])\n        if (similar_topo(p, e, p_tmp, e_tmp)):\n            d_flag = False\n            if (mass_tmp > Mass):\n                os.remove(os.path.join(DIVERSITY_TOPO_FOLDER, d_file))\n                OUTFILE = DIVERSITY_TOPO_FOLDER + str(round(Mass)) + '.txt'\n                if (not os.path.exists(OUTFILE)): save_file_stage1(OUTFILE, p, e)\n            break\n\n    if (d_flag):\n        OUTFILE = DIVERSITY_TOPO_FOLDER + str(round(Mass)) + '.txt'\n        if (not os.path.exists(OUTFILE)):\n            save_file_stage1(OUTFILE, p, e)", "\n            \ndef soft_reward(env_output, p, e):\n    reward, reward_cnt, Mass, Dis_value, Stress_value, Buckle_value = env_output\n    global pbest\n    global ebest\n    global bestreward\n    global tmpbestreward\n    global save_invalid_count\n    if (reward <= 0):\n        if (save_invalid_count < save_valid_count * args.save_invalid_factor and reward == 0):\n            folder = os.path.join(LOGFOLDER, \"invalid\")\n            if (not os.path.exists(folder)): os.mkdir(folder)\n            save_file_stage1(os.path.join(folder, str(save_invalid_count) + '.txt'), p, e)\n            save_invalid_count += 1\n        return reward\n        \n    if (bestreward > reward):\n        bestreward = reward\n        pbest = copy.deepcopy(p)\n        ebest = copy.deepcopy(e)\n    if (tmpbestreward > reward):\n        tmpbestreward = reward\n    if (args.save_diversity):\n        diversity_save(reward, reward_cnt, Mass, Dis_value, Stress_value, Buckle_value, p, e)\n    reward= args.reward_lambda / (reward * reward)\n    return reward", "\ndef inlen(u, v):\n    if (getlen2(u, v) > maxlen and args.CONSTRAINT_MAX_LENGTH):\n        return False\n    if (getlen2(u, v) < minlen and args.CONSTRAINT_MIN_LENGTH):\n        return False\n    return True\n\ndef canadd(N1, N2, p, e, area = None, d = None, t = None):\n    if (not inlen(p[N1], p[N2])): return False\n    if (args.CONSTRAINT_CROSS_EDGE == 1):\n        if (area == None and d == None and t == None):\n            if (args.env_dims == 2):\n                for i in range(len(e)):\n                    N3 = e[i].u\n                    N4 = e[i].v\n                    if (transintersect(N1, N2, N3, N4, p)): return False\n            return True\n        for i in range(len(e)):\n            if (N1 == e[i].v or N1 == e[i].u or N2 == e[i].v or N2 == e[i].u): continue\n            _, _, dis = closestDistanceBetweenLines(p[N1].Point2np(), p[N2].Point2np(), p[e[i].u].Point2np(), p[e[i].v].Point2np(), clampAll = True)\n            if (d != None):\n                r1, r2 = d / 2, e[i].d / 2\n            else:\n                if (args.env_dims == 2):\n                    r1, r2 = area / 2, e[i].area / 2\n                elif (args.env_dims == 3):\n                    r1, r2 = np.sqrt(area / np.pi), np.sqrt(e[i].area / np.pi)\n            if (dis <= r1 + r2): return False\n    return True", "def canadd(N1, N2, p, e, area = None, d = None, t = None):\n    if (not inlen(p[N1], p[N2])): return False\n    if (args.CONSTRAINT_CROSS_EDGE == 1):\n        if (area == None and d == None and t == None):\n            if (args.env_dims == 2):\n                for i in range(len(e)):\n                    N3 = e[i].u\n                    N4 = e[i].v\n                    if (transintersect(N1, N2, N3, N4, p)): return False\n            return True\n        for i in range(len(e)):\n            if (N1 == e[i].v or N1 == e[i].u or N2 == e[i].v or N2 == e[i].u): continue\n            _, _, dis = closestDistanceBetweenLines(p[N1].Point2np(), p[N2].Point2np(), p[e[i].u].Point2np(), p[e[i].v].Point2np(), clampAll = True)\n            if (d != None):\n                r1, r2 = d / 2, e[i].d / 2\n            else:\n                if (args.env_dims == 2):\n                    r1, r2 = area / 2, e[i].area / 2\n                elif (args.env_dims == 3):\n                    r1, r2 = np.sqrt(area / np.pi), np.sqrt(e[i].area / np.pi)\n            if (dis <= r1 + r2): return False\n    return True", "\ndef max_can_add_area(new_e, p, e):\n    if (args.CONSTRAINT_CROSS_EDGE == 0): \n        if (args.env_mode == 'DT'):\n            return None, arealist[-1][4]\n        elif (args.env_mode == 'Area'):\n            return maxarea, None\n    if (args.env_mode == 'DT'):\n        mind = arealist[-1][4]\n        for i in range(len(e)):\n            if (new_e.u == e[i].v or new_e.u == e[i].u or new_e.v == e[i].v or new_e.v == e[i].u): continue\n            _, _, dis = closestDistanceBetweenLines(p[new_e.u].Point2np(), p[new_e.v].Point2np(), p[e[i].u].Point2np(), p[e[i].v].Point2np(), clampAll = True)\n            mind = min(mind, (dis - e[i].d / 2) * 2)\n        return None, mind\n    elif (args.env_mode == 'Area'):\n        mina = maxarea\n        for i in range(len(e)):\n            if (new_e.u == e[i].v or new_e.u == e[i].u or new_e.v == e[i].v or new_e.v == e[i].u): continue\n            _, _, dis = closestDistanceBetweenLines(p[new_e.u].Point2np(), p[new_e.v].Point2np(), p[e[i].u].Point2np(), p[e[i].v].Point2np(), clampAll = True)\n            if (args.env_dims == 2):\n                mina = min(mina, (dis - e[i].area / 2) * 2)\n            elif (args.env_dims == 3):\n                mina = min(mina, np.pi * ((dis - np.sqrt(e[i].area / np.pi)) ** 2))\n        return mina, None", "\nclass Action():\n    def __init__(self, opt, u = -1, v = -1, area = -1, vec = Vector3(), eid = 0, d = None, t = None):\n        self.opt = opt\n        self.stateid = -1\n        self.d = None\n        self.t = None\n        \n        if (opt == 0): self.vec = vec           #add node\n            \n        if (opt == 1):                          #add edge\n            self.opt = opt\n            self.u = u\n            self.v = v\n            if (area != -1): self.area = area\n            else: self.area = maxarea\n            if (args.env_mode == 'DT'):\n                self.d = arealist[-1][4]\n                self.t = arealist[-1][5]\n\n        if (opt == 2):                          #change area\n            if (args.env_mode == 'DT'): assert(d > 0 and t > 0)\n            self.eid = eid\n            if (area != -1): self.area = area\n            else: self.area = maxarea\n            self.d = d\n            self.t = t\n\n    def __str__(self):\n        if (self.opt == 0): return \"add node at\" + self.vec.__str__()\n        if (self.opt == 1):\n            if (self.area < 1e-8): return \"do nothing\"\n            else: return \"add edge between\" + str(self.u) + \"and\" + str(self.v)\n        if (self.opt == 2): return \"modify area of \" + str(self.eid) + \"to \" + str(self.area)", "\nclass State():\n    def __init__(self, p, e, opt, fa = 0, elist = set(), eid = 0):\n        self.opt = opt\n        self.sons = []\n        self.isEnd = False\n        self.n = 0\n        self.q = 0\n        self.fa = fa\n        self.allvisited = False\n        self.w = 0.0\n        self.sumq = 0.0\n        self.sumw = 0.0\n        self.mq = -1000\n        if (opt == 0):\n            for i in range(len(plist)):\n                flag = False\n                tmpp = plist[i]\n                for j in range(len(p)):\n                    if (inlen(Point(tmpp), p[j])):\n                        flag = True\n                        break\n                if (flag == True): self.sons.append(Action(0, vec = tmpp))\n\n            for i in range(len(self.sons), args.initson):\n                flag = False\n                tmpp = Vector3(getrand(minx, maxx), getrand(miny, maxy), getrand(minz, maxz))\n                for j in range(len(p)):\n                    if (inlen(Point(tmpp), p[j])):\n                        flag = True\n                        break\n                if (flag == True): self.sons.append(Action(0, vec = tmpp))\n                \n        if (opt == 1):\n            self.reward = soft_reward(reward_fun(p, e), p, e)\n            if (self.reward > 1e-7): self.sons.append(Action(1)) # \u5f53\u524d\u7ed3\u6784\u7a33\u5b9a\n            for i in elist: \n                self.sons.append(Action(1, u = i[0], v = i[1]))\n            if (len(self.sons) == 0):\n                self.isEnd = True\n                self.reward = soft_reward(reward_fun(p, e), p, e)\n\n        if (opt == 2):\n            self.eid = eid\n            if (eid >= len(e)):\n                self.isEnd = True\n                self.reward = soft_reward(reward_fun(p, e), p, e)\n            else:\n                if (args.env_mode == 'DT'):\n                    for i in range(len(arealist)):\n                        self.sons.append(Action(2, d = arealist[i][4], t = arealist[i][5], eid = eid))\n                else:\n                    for i in range(args.initson + 1):\n                        self.sons.append(Action(2, area = minarea + (maxarea - minarea) / args.initson * i))\n\n    def findunvis(self): # find unvisited node\n        ret = -1\n        for i in range(len(self.sons)):\n            if (self.sons[i].stateid == -1):\n                ret = i\n                break\n        if (ret == -1): self.allvisited = True\n        return ret", "\ndef bestchild(now, c, alpha):\n    global statelist\n    ret = -1\n    actid = -1\n    mx = 0\n    if (abs(c) < 1e-7): # final find, no explore \n        for i in range(len(statelist[now].sons)):\n            v = statelist[now].sons[i].stateid\n            if (statelist[now].opt == 1):\n                tmp = alpha * statelist[v].q / statelist[v].n + (1 - alpha) * statelist[v].mq\n                print(statelist[v].q, statelist[v].n, statelist[v].mq, statelist[v].q / statelist[v].n, 'a')\n            else:\n                tmp = alpha * statelist[v].sumq / statelist[v].n + (1 - alpha) * statelist[v].mq\n                print(statelist[v].q, statelist[v].sumq, statelist[v].mq, statelist[v].w, statelist[v].sumq / statelist[v].n, statelist[v].n)\n            if (ret == -1 or tmp > mx):\n                ret = v\n                mx = tmp\n                actid = i\n        print(\"**************\")\n        print(round(statelist[ret].n,2), round(statelist[ret].mq,2))\n        print(\"**************\")\n        \n        return ret, statelist[now].sons[actid]\n    \n    if (statelist[now].opt == 1 or statelist[now].opt == 2):\n        for i in range(len(statelist[now].sons)):\n            v = statelist[now].sons[i].stateid\n            tmp = alpha * statelist[v].q / statelist[v].n + (1 - alpha) * statelist[v].mq + c * math.sqrt(2 * math.log(statelist[now].n) / statelist[v].n)\n            if (ret == -1 or tmp > mx):\n                ret = v\n                mx = tmp\n                actid = i\n    else: # use kernel\n        for i in range(len(statelist[now].sons)):\n            v = statelist[now].sons[i].stateid\n            if (statelist[v].w < 1e-7):\n                ret = v\n                actid = i\n                break\n            tmp = alpha * statelist[v].q / statelist[v].w + (1 - alpha) * statelist[v].mq\n            tmp = tmp + c * (math.sqrt(2 * math.log(statelist[now].sumw) / statelist[v].w) * 0.8 + math.sqrt(2 * math.log(statelist[now].n) / statelist[v].n) * 0.2)\n            if (ret == -1 or tmp > mx):\n                ret = v\n                mx = tmp\n                actid = i\n    return ret, statelist[now].sons[actid]", "\ndef take_action(p, e, elist, act):\n    if (act.opt == 0):\n        p.append(Point(act.vec))\n        if (len(p) == args.maxp):\n            for i in range(len(p)):\n                for j in range(i + 1, len(p)):\n                    if (not (p[i].isSupport and p[j].isSupport)) and inlen(p[i], p[j]):\n                        elist.add((i, j))\n\n    if (act.opt == 1):\n        if (act.u != -1 and act.v != -1):\n            e.append(Bar(act.u, act.v, act.area, getlen2(p[act.u], p[act.v]), d = act.d, t = act.t))\n            elist.remove((act.u, act.v))\n            dellist = []\n            if (args.env_dims == 2 and args.CONSTRAINT_CROSS_EDGE == 1):\n                for i in elist:\n                    if (transintersect(act.u, act.v, i[0], i[1], p)):\n                        dellist.append(i)\n                for i in dellist:\n                    elist.remove(i)\n        else: elist.clear()\n\n    if (act.opt == 2):\n        if args.env_mode == 'DT':\n            e[act.eid].d = act.d\n            e[act.eid].t = act.t\n        else: e[act.eid]._area = act.area", "\ndef isok(vec):\n    if (minx <= vec.x and vec.x <= maxx and miny <= vec.y and vec.y <= maxy and minz <= vec.z and vec.z <= maxz):\n        return True\n    return False\n\ndef getnewchild0(stateid, vec):\n    assert(statelist[stateid].opt == 0)\n    finvec = Vector3()\n    bestw = 0.0\n\n    for iter in range(args.maxnum):\n        newvec = vec + randpoint() * args.sgm2 * 0.5\n        newvec.x = max(min(newvec.x, maxx), minx)\n        newvec.y = max(min(newvec.y, maxy), miny)\n        newvec.z = max(min(newvec.z, maxz), minz)\n        w = 0.0\n        for i in range(len(statelist[stateid].sons)):\n            w = w + Kernel2(newvec, statelist[stateid].sons[i].vec, args.sgm2) * statelist[statelist[stateid].sons[i].stateid].n\n        if (iter == 0 or w < bestw):\n            bestw = w\n            finvec = newvec\n\n    statelist[stateid].sons.append(Action(0, vec = finvec))\n    return len(statelist[stateid].sons) - 1", "    \ndef getnewchild2(stateid, area):\n    assert(statelist[stateid].opt == 2)\n    finarea = maxarea\n    bestw = 0.0\n\n    for iter in range(args.maxnum):\n        newarea = getrand(max(minarea, area - args.sgm1 * 3), min(maxarea, area + args.sgm1 * 3))\n        w = 0.0\n        for i in range(len(statelist[stateid].sons)):\n            w = w + Kernel1(newarea, statelist[stateid].sons[i].area, args.sgm1)\n        if (iter == 0 or w < bestw):\n            bestw = w\n            finarea = newarea\n\n    statelist[stateid].sons.append(Action(2, area = finarea, eid = statelist[stateid].eid))\n    return len(statelist[stateid].sons) - 1", "\n\ndef treepolicy(stateid, p_, e_, elist_):\n    p = copy.deepcopy(p_)\n    e = copy.deepcopy(e_)\n    elist = copy.deepcopy(elist_)\n    global statelist\n    now = stateid\n    sonid = -1\n    while ((not statelist[now].isEnd) and (sonid == -1)):\n        opt = statelist[now].opt\n        ret = statelist[now].findunvis()\n        if (ret != -1):\n            sonid = ret\n            break\n        \n        nxt, act = bestchild(now, args.c[opt], args.alpha)\n        if (opt == 1):\n            now = nxt\n            take_action(p, e, elist, act)\n        \n        elif (opt == 0):\n            sizeA = len(statelist[now].sons)\n            if (sizeA * sizeA * 3 > statelist[now].n and (not statelist[nxt].isEnd or len(statelist[now].sons) > args.maxson)): \n                now = nxt\n                take_action(p, e, elist, act)\n            else: \n                sonid = getnewchild0(now, act.vec) #add new child\n        \n        elif (opt == 2):\n            sizeA = len(statelist[now].sons)\n            if (sizeA * sizeA * 3 > statelist[now].n and (not statelist[nxt].isEnd or len(statelist[now].sons) > args.maxson)) or (args.env_mode == 'DT'): \n                now = nxt\n                take_action(p, e, elist, act)\n            else: \n                sonid = getnewchild2(now, act.area) #add new child\n\n\n    if (sonid >= 0): # add new child\n        act = statelist[now].sons[sonid]\n        take_action(p, e, elist, act)\n        opt = statelist[now].opt\n        if (opt == 0):\n            if (len(p) == args.maxp): newstate = State(p, e, 1, fa = now, elist = elist)\n            else: newstate = State(p, e, 0, fa = now)\n            for i in range(len(statelist[now].sons)):\n                if (i == sonid): continue\n                if (opt == 0):\n                    KAB = Kernel2(act.vec, statelist[now].sons[i].vec, args.sgm2)\n                else:\n                    KAB = Kernel1(act.area, statelist[now].sons[i].area, args.sgm1)\n                sid = statelist[now].sons[i].stateid\n                newstate.w = newstate.w + statelist[sid].n * KAB\n                newstate.q = newstate.q + statelist[sid].sumq * KAB\n        if (opt == 1):\n            if (act.u < 0): newstate = State(p, e, 2, fa = now, eid = 0)\n            else: newstate = State(p, e, 1, fa = now, elist = elist)\n        if (opt == 2): \n            newstate = State(p, e, 2, fa = now, eid = act.eid + 1)\n        statelist.append(newstate)\n        statelist[now].sons[sonid].stateid = len(statelist) - 1\n        now = len(statelist) - 1\n    return now, p, e, elist", "\ndef defaultpolicy(stateid, p, e, elist):\n    opt = statelist[stateid].opt\n    if (opt == 0):\n        while (len(p) < args.maxp):\n            p.append(Point(Vector3(getrand(minx, maxx), getrand(miny, maxy), getrand(minz, maxz))))\n        opt = 1\n\n    if (opt == 1):\n        for i in range(len(e)):\n            area, d = max_can_add_area(e[i], p, e[0 : i])\n            if (args.env_mode == 'DT'):\n                can_id = 0\n                while (can_id < len(arealist) - 1 and arealist[can_id + 1][4] <= d): can_id += 1\n                area_random = arealist[random.randint(0, can_id)]\n                e[i].d = area_random[4]\n                e[i].t = area_random[5]\n            else: e[i]._area = getrand(minarea, area)\n\n        el = []\n        for i in elist: el.append(i)\n        if (len(el) == 0 and len(e) == 0):\n            for i in range(len(p)):\n                for j in range(i + 1, len(p)):\n                    if (p[i].isSupport and p[j].isSupport): continue\n                    if (not inlen(p[i], p[j])): continue\n                    el.append((i, j))\n        random.shuffle(el)\n        ret = -1\n        for i in range(len(el)):\n            probnow = random.random()\n            if (probnow > args.prob): continue\n            u = el[i][0]\n            v = el[i][1]\n            if (args.env_mode == 'DT'): \n                area = 1.0\n                area_random = arealist[random.randint(0, len(arealist) - 1)]\n                d, t = area_random[4], area_random[5]\n            elif (args.env_mode == 'Area'):\n                area = getrand(minarea, maxarea)\n                d, t = None, None\n            if (canadd(u, v, p, e, area, d, t)):\n                e.append(Bar(u, v, leng = getlen2(p[u], p[v]), area = area, d = d, t = t))\n                ret = soft_reward(reward_fun(p, e), p, e)\n                if (ret > 1e-7): return ret\n        return ret\n\n    if (opt == 2):\n        for i in range(statelist[stateid].eid, len(e)):\n            area, d = max_can_add_area(e[i], p, e[0 : i])\n            if (args.env_mode == 'DT'):\n                can_id = 0\n                while (can_id < len(arealist) - 1 and arealist[can_id + 1][4] <= d): can_id += 1\n                area_random = arealist[random.randint(0, can_id)]\n                e[i].d = area_random[4]\n                e[i].t = area_random[5]\n            else: e[i]._area = getrand(minarea, area)\n        ret = soft_reward(reward_fun(p, e), p, e)\n        return ret\n\n    assert(False)", "\ndef backup(now, delta, root):\n    fa = statelist[now].fa\n    while (True):\n        statelist[now].n = statelist[now].n + 1\n        statelist[now].sumq = statelist[now].sumq + delta\n        if (statelist[now].mq < delta):\n            statelist[now].mq = delta\n        if (now == root): break\n        if (statelist[fa].opt == 1 or statelist[fa].opt == 2):\n            statelist[now].q = statelist[now].q + delta\n        elif (statelist[fa].opt == 0):  \n            sonid = -1\n            for i in range(len(statelist[fa].sons)):\n                if (statelist[fa].sons[i].stateid == now):\n                    sonid = i\n                    break\n            assert(sonid != -1)\n            vec0 = statelist[fa].sons[sonid].vec\n            for i in range(len(statelist[fa].sons)):\n                KAB = Kernel2(vec0, statelist[fa].sons[i].vec, args.sgm2)\n                sid = statelist[fa].sons[i].stateid\n                statelist[sid].w = statelist[sid].w + KAB\n                statelist[sid].q = statelist[sid].q + KAB * delta\n                statelist[fa].sumw = statelist[fa].sumw + KAB\n        now = fa\n        fa = statelist[now].fa", "\ndef UCTSearch(p, e):\n    global statelist\n    global bestreward\n    global tmpbestreward\n    global elist\n    global global_iteration\n    elist = set()\n    statelist = []\n    step_node = 1\n    opt = 0\n    eidnow = 0\n    maxiter = args.UCT_maxiter\n    root = 0\n    while (not (opt == 2 and eidnow >= len(e))):\n        statelist.clear()\n        tmpbestreward = 1e9\n        tmpbestreward2 = 1e9\n        root = 0\n        if (opt == 0):\n            statelist.append(State(p, e, 0, -1))\n            if (len(pbest) > len(p)):\n                statelist[root].sons.append(Action(0, vec = pbest[len(p)].vec))\n        if (opt == 1):\n            statelist.append(State(p, e, 1, -1, elist = elist))\n        if (opt == 2):\n            statelist.append(State(p, e, 2, -1, eid = eidnow))\n        extra_iter = 0\n        if (opt == 0): extra_iter = args.UCT_extra_iter_for_point_pos\n        for iter in range(maxiter + extra_iter):\n            tmp, ptmp, etmp, elisttmp = treepolicy(root, p, e, elist)\n            delta = defaultpolicy(tmp, ptmp, etmp, elisttmp)\n            backup(tmp, delta, root)\n            if (iter % 200 == 0):\n                tmpbestreward2 = min(tmpbestreward2, tmpbestreward)\n                print(global_iteration + iter, iter, bestreward, tmpbestreward2, tmpbestreward, len(statelist[root].sons))\n                print(global_iteration + iter, iter, bestreward, tmpbestreward2, tmpbestreward, len(statelist[root].sons), file = logfile)\n                tmpbestreward = 1e9\n        global_iteration += maxiter + extra_iter\n        \n        if (opt == 0):\n            act = Action(0, vec = pbest[len(p)].vec)\n            # for SaveKR:\n            if args.save_KR == True:\n                KR_plist_x = []\n                KR_plist_y = []\n                KR_plist_z = []\n                print(len(p)+1,\"*****************************************\")\n#                print(len(p)+1,\"*****************************************\", file = LOG_result)\n                for ii in range(len(statelist[root].sons)):\n                    KR_plist_x.append(statelist[root].sons[ii].vec.x)\n                    KR_plist_y.append(statelist[root].sons[ii].vec.y)\n                    KR_plist_z.append(statelist[root].sons[ii].vec.z)\n                    print(ii,statelist[root].sons[ii].vec.x, statelist[root].sons[ii].vec.y, statelist[root].sons[ii].vec.z)\n#                    print(ii,statelist[root].sons[ii].vec.x, statelist[root].sons[ii].vec.y, statelist[root].sons[ii].vec.z, file = LOG_result)\n\n                print(len(p)+1,\"*****************************************\")\n#                print(len(p)+1,\"*****************************************\", file = LOG_result)\n                \n                X1=np.ones(len(KR_plist_x))\n                Y1=np.ones(len(KR_plist_x))\n                Z1=np.ones(len(KR_plist_x))\n                \n                fig1 = plt.figure()\n                ax1 = plt.axes(projection='3d')\n                for i in range(len(KR_plist_x)):\n                    ax1.scatter3D([KR_plist_x[i]], [KR_plist_y[i]], [KR_plist_z[i]], color='b')\n                    X1[i] = KR_plist_x[i]\n                    Y1[i] = KR_plist_y[i]\n                    Z1[i] = KR_plist_z[i]\n                # Create cubic bounding box to simulate equal aspect ratio\n                max_range = np.array([X1.max()-X1.min(), Y1.max()-Y1.min(), Z1.max()-Z1.min()]).max()\n                Xb1 = 0.5*max_range*np.mgrid[-1:2:2,-1:2:2,-1:2:2][0].flatten() + 0.5*(X1.max()+X1.min())\n                Yb1 = 0.5*max_range*np.mgrid[-1:2:2,-1:2:2,-1:2:2][1].flatten() + 0.5*(Y1.max()+Y1.min())\n                Zb1 = 0.5*max_range*np.mgrid[-1:2:2,-1:2:2,-1:2:2][2].flatten() + 0.5*(Z1.max()+Z1.min())\n                \n                # Comment or uncomment following both lines to test the fake bounding box:\n                for xb1, yb1, zb1 in zip(Xb1, Yb1, Zb1):\n                    ax1.plot([xb1], [yb1], [zb1], 'w')\n                \n                # plt.scatter(KR_plist_x, KR_plist_y, color='b')\n                # plt.axis(\"equal\")\n                inputname = FILENAME.replace(\".txt\",\"_\")\n                FILENAME_add_node_jpg = \"./results/\" + time_str + \"_\" + str(args.maxp) + \"p_\" + inputname + \"add-node-\"+str(step_node) + \".jpg\"\n                plt.savefig(FILENAME_add_node_jpg, dpi = 1000)\n                plt.close()\n                step_node = step_node + 1\n                print(len(KR_plist_x))\n\n        if (opt == 1):\n            if (len(e) == len(ebest)): act = Action(1)\n            else: act = Action(1, u = ebest[len(e)].u, v = ebest[len(e)].v)\n\n        if (opt == 2):\n            act = Action(2, area = ebest[eidnow].area, \n                eid = eidnow,\n                d = ebest[eidnow].d, \n                t = ebest[eidnow].t\n            )\n\n        take_action(p, e, elist, act)\n        \n        print(act)\n        print(bestreward, tmpbestreward)\n        \n        if (opt == 0):\n            if (len(p) == args.maxp): opt = 1\n        elif (opt == 1):\n            if (act.u == -1): opt = 2\n        elif (opt == 2):\n            eidnow = eidnow + 1\n    return bestreward, pbest, ebest"]}
{"filename": "algo/__init__.py", "chunked_list": ["from algo.value_network import Value_Network, Truss_Dataset\nfrom algo.UCTs import UCTSearch, UCTs_init"]}
{"filename": "algo/value_network.py", "chunked_list": ["import os, sys, torch\nimport torch.nn as nn\nimport numpy as np\nfrom tqdm import tqdm\nfrom torch.utils.data import Dataset, DataLoader\nfrom collections import deque\nbase_path = os.getcwd()\nsys.path.append(base_path)\nfrom Stage2.models import Transformer_Value_Network, Toy_Value_Network\nfrom Stage2.envs.state import State", "from Stage2.models import Transformer_Value_Network, Toy_Value_Network\nfrom Stage2.envs.state import State\nfrom utils.utils import readFile, readFilewithload\nfrom configs.config import get_base_config, make_config\n\nclass Truss_Dataset(Dataset):\n    def __init__(self, storage, scale_value_max = None, max_value = None, \n                start_index = None, end_index = None):\n        self.storage = storage\n        self.scale_value_max = scale_value_max\n        self.max_value = max_value     \n        self.start_index = start_index\n        if (self.start_index == None): self.start_index = 0\n        self.end_index = end_index\n        if (self.end_index == None): self.end_index = len(self.storage)\n    \n    def __getitem__(self, index):\n        return self.storage[index + self.start_index]\n\n    def __len__(self):\n        return self.end_index - self.start_index\n\n    def collate_fn(self, samples):\n        bz = len(samples)\n        truss_input = torch.zeros(bz, len(samples[0]['truss_input']))\n        truss_valid = torch.zeros(bz, dtype=int)\n        truss_value = torch.zeros(bz, len(samples[0]['truss_value']))\n        for i in range(len(samples)):\n            truss_input[i] = torch.from_numpy(samples[i]['truss_input'])\n            truss_valid[i] = torch.from_numpy(samples[i]['truss_valid'])[0]\n            if (self.scale_value_max != None):\n                truss_value[i] = torch.from_numpy(samples[i]['truss_value'] / self.max_value * self.scale_value_max)\n            else:\n                truss_value[i] = torch.from_numpy(samples[i]['truss_value'])\n        truss_input = truss_input.to('cuda:0')\n        truss_valid = truss_valid.to('cuda:0')\n        truss_value = truss_value.to('cuda:0')\n        return {\n            'truss_input' : truss_input,\n            'truss_valid' : truss_valid,\n            'truss_value' : truss_value\n        }", "\nclass Value_Network:\n    def __init__(self, args, storage_size = 1000000, batch_size = 32, lr = 1e-3):\n        self.value_network = Transformer_Value_Network(args.prev_dims, args.hidden_dims, args.env_dims, args.env_mode, num_node = args.maxp).to('cuda:0')\n        #self.value_network = Toy_Value_Network(args.maxp * 3 + args.maxp * (args.maxp - 1) // 2, 2048)\n        self.storage_size = storage_size\n        self.batch_size = batch_size\n        self.storage = deque(maxlen = self.storage_size)\n        self.valid_loss_fc = nn.CrossEntropyLoss()\n        self.value_loss_fc = nn.MSELoss()\n        self.value_loss_alpha = 1\n        self.lr = lr\n        self.max_value = -1\n        self.valid_count = 0\n        self.invalid_count = 0\n        self.save_model_path = os.path.join(args.save_model_path, args.run_id)\n\n    def pred(self, input):\n        self.value_network.eval()\n        return self.value_network(input)\n\n    def one_dim_presentation(self, points, edges, block_rate = 0):\n        r'''\n        block_rate: how much of the Edges will be remove.\n        '''\n        state = State(args.maxp, args.env_dims, args.env_mode)\n        for i in range(args.maxp):\n            state.nodes[i][0] = points[i].vec.x\n            state.nodes[i][1] = points[i].vec.y\n            if args.env_dims == 3:\n                state.nodes[i][2] = points[i].vec.z\n\n        for e in edges:\n            if (np.random.random() > block_rate):\n                i, j = e.u, e.v\n                if (args.env_mode == 'Area'):\n                    state.edges[i][j] = e.area\n                    state.edges[j][i] = e.area\n\n                if (args.env_mode == 'DT'):\n                    state.edges[i][j][0] = e.d\n                    state.edges[j][i][0] = e.d\n                    state.edges[i][j][1] = e.t\n                    state.edges[j][i][1] = e.t\n\n        return state\n\n    def upd_from_storage(self, steps = 50000, scale_value_max = 10, train_ratio = 0.8):\n        num_train_data = int(train_ratio * len(self.storage) + 0.5)\n        choose = np.arange(len(self.storage))\n        np.random.shuffle(choose)\n        training_storage = [self.storage[choose[i]] for i in range(num_train_data)]\n        valid_storage = [self.storage[choose[i]] for i in range(num_train_data, len(self.storage))]\n        train_dataset = Truss_Dataset(training_storage, scale_value_max = scale_value_max, max_value = self.max_value)\n        \n        train_dataloader = DataLoader(train_dataset, collate_fn=train_dataset.collate_fn, batch_size = self.batch_size, shuffle = True)\n        \n        optimizer = torch.optim.Adam(self.value_network.parameters(), lr = self.lr)\n        \n        current_step = 0\n        current_epoch = 0\n        min_valid_loss = 1e9\n        while (current_step < steps):\n            train_losses_valid = []\n            train_losses_value = []   \n            with tqdm(train_dataloader, desc = \"training\") as pbar:\n              self.value_network.train()\n              for samples in pbar:\n                ### Training ###\n                optimizer.zero_grad()\n                valid_pred, value_pred = self.value_network(samples['truss_input'])\n                value_pred[samples['truss_valid'] == 0] = 0\n                loss_valid = self.valid_loss_fc(valid_pred, samples['truss_valid'])\n                loss_value = self.value_loss_fc(value_pred, samples['truss_value'])\n                #print(loss_valid, loss_value)\n                loss = loss_valid + self.value_loss_alpha * loss_value\n                loss.backward()\n                optimizer.step()\n\n                ### Logging ###\n                train_losses_valid.append(loss_valid.item())\n                train_losses_value.append(loss_value.item())\n\n                current_step += 1\n                if (current_step >= steps): break\n                \n                pbar.set_description(\"Epoch: %d, losses_valid: %0.8f, losses_value: %0.8f, lr: %0.6f\" %\n                                     (current_epoch + 1, np.mean(train_losses_valid), np.mean(train_losses_value),\n                                      optimizer.param_groups[0]['lr']))\n            current_epoch += 1\n\n            print('##### epoch.{} #####'.format(current_epoch))\n            print('train_loss_valid:', np.mean(train_losses_valid))\n            print('train_loss_value:', np.mean(train_losses_value))\n\n            now_valid_loss = self.eval_storage(valid_storage, descending = 'valid')\n            if (now_valid_loss < min_valid_loss):\n                self.save_model(\"value_network_best.pt\")\n                min_valid_loss = now_valid_loss\n            self.save_model(\"value_network_{}.pt\".format(current_epoch))\n\n            print('min_valid_loss:', min_valid_loss)\n            print('now_valid_loss:', now_valid_loss)\n            print(\"#\" * 19)\n\n    def eval_storage(self, eval_storage = None, scale_value_max = 10, descending = 'eval'):\n        r'''\n        evaluate the value network in a given storage\n        '''\n        if (eval_storage == None): eval_storage = self.storage\n        eval_dataset = Truss_Dataset(eval_storage, scale_value_max = scale_value_max, max_value = self.max_value)\n        eval_dataloader = DataLoader(eval_dataset, collate_fn=eval_dataset.collate_fn, batch_size = self.batch_size, shuffle = True)\n        eval_losses_valid = []\n        eval_losses_value = []\n        correct_pred_num = 0\n        total_pred_num = 0\n        with tqdm(eval_dataloader, desc = descending) as pbar:\n              self.value_network.eval()  \n              for samples in pbar:\n                ### validing ###\n                with torch.no_grad():\n                    valid_pred, value_pred = self.value_network(samples['truss_input'])\n                    value_pred[samples['truss_valid'] == 0] = 0\n                    loss_valid = self.valid_loss_fc(valid_pred, samples['truss_valid'])\n                    loss_value = self.value_loss_fc(value_pred, samples['truss_value'])\n\n                    valid_pred_label = torch.argmax(valid_pred, dim = -1, keepdim = False)\n                    correct_pred_num += torch.sum(valid_pred_label == samples['truss_valid']).item()\n                    total_pred_num += valid_pred_label.shape[0]\n\n                ### Logging ###\n                eval_losses_valid.append(loss_valid.item())\n                eval_losses_value.append(loss_value.item())\n                \n                pbar.set_description(\"losses_eval: %0.8f, losses_eval: %0.8f\" %\n                                     (np.mean(eval_losses_valid), np.mean(eval_losses_value)))\n\n        now_eval_loss = np.mean(eval_losses_valid) + self.value_loss_alpha * np.mean(eval_losses_value)\n        \n        print('{}_loss_valid:'.format(descending), np.mean(eval_losses_valid))\n        print('{}_loss_value:'.format(descending), np.mean(eval_losses_value))\n        print(\"predict ratio:\", correct_pred_num / total_pred_num, correct_pred_num, '/', total_pred_num)\n\n        return now_eval_loss\n\n    def upd_storage(self, data):\n        self.storage.append(data)\n        \n    def init_storage(self, data_path, invalid_data_path = None, threshold = None, copy_num = 1, invalid_copy_num = 1, clear = False):\n        r'''\n        threshold: only use the data with value smaller than the threshold\n        copy_num: remove some Edges in the Truss; \n                  set to 1 means no remove\n        '''\n        if (clear): \n            self.storage.clear()\n            self.valid_count = self.invalid_count = 0\n\n        files = os.listdir(data_path)\n        if (files[0][:-4] == '.txt'):\n            files.sort(key = lambda x: int(x[:-4]))\n        else: files.sort()\n\n        for file in files:\n            if (not(threshold == None or int(file[:-4]) <= threshold)): continue\n            points, edges, load = readFilewithload(data_path + file)\n            load = np.array(load)\n            for i in range(copy_num):\n                if (i == 0): state = self.one_dim_presentation(points, edges)\n                else: state = self.one_dim_presentation(points, edges, block_rate = np.random.random())\n                data = {\n                    'truss_input' : np.concatenate([state.obs(nonexistent_edge = 0), load]),\n                    'truss_valid' : np.array([1]),\n                    'truss_value' : np.array([int(file[:-4])])\n                }\n                self.max_value = max(self.max_value, int(file[:-4]))\n                self.valid_count += 1\n                self.storage.append(data)\n        \n        if (invalid_data_path != None):\n            files = os.listdir(invalid_data_path)\n            for file in files:\n                points, edges, load = readFilewithload(invalid_data_path + file)\n                load = np.array(load)\n                for i in range(invalid_copy_num):\n                    if (i == 0): state = self.one_dim_presentation(points, edges)\n                    else: state = self.one_dim_presentation(points, edges, block_rate = np.random.random())\n                    data = {\n                        'truss_input' : np.concatenate([state.obs(nonexistent_edge = 0), load]),\n                        'truss_valid' : np.array([0]),\n                        'truss_value' : np.array([0])\n                    }\n                    self.invalid_count += 1\n                    self.storage.append(data)\n        print(self.valid_count, self.invalid_count)\n\n    def save_model(self, network_name = 'value_network.pt'):\n        if (not os.path.exists(self.save_model_path)):\n            os.mkdir(self.save_model_path)\n        torch.save(self.value_network, os.path.join(self.save_model_path, network_name))\n    \n    def load_model(self, model_load_path = None):\n        if (model_load_path == None): model_load_path = os.path.join(self.save_model_path, \"value_network_best.pt\")\n        self.value_network = torch.load(model_load_path)\n        print(\"load from\", model_load_path)", "\nif __name__ == '__main__':\n    parser = get_base_config()\n    args = parser.parse_known_args(sys.argv[1:])[0]\n    config = make_config(args.config)\n    for k, v in config.get(\"base\", {}).items():\n        if f\"--{k}\" not in args:\n            setattr(args, k, v)\n\n    Value_Net = Value_Network(args, batch_size = 32)\n    Value_Net.init_storage(data_path = './results_3d/without_buckle_case1/buckle_fixed0/MASS_ALL_Result/', invalid_data_path = './results_3d/without_buckle_case1/buckle_fixed0/invalid/', copy_num = 10, invalid_copy_num = 1)\n    Value_Net.upd_from_storage()\n    Value_Net.eval_storage()", "    #print(len(Value_Net.storage))"]}
{"filename": "algo/rl_algo.py", "chunked_list": ["\nimport numpy as np\nimport warnings\n\nimport abc\n\nimport gtimer as gt\n\nfrom rlkit.data_management.env_replay_buffer import EnvReplayBuffer\nfrom rlkit.data_management.replay_buffer import ReplayBuffer", "from rlkit.data_management.env_replay_buffer import EnvReplayBuffer\nfrom rlkit.data_management.replay_buffer import ReplayBuffer\nfrom rlkit.samplers.data_collector import PathCollector\n\nfrom rlkit.core import logger, eval_util\nfrom rlkit.samplers.data_collector import DataCollector\n\n\n\nclass NewBaseRLAlgorithm(object, metaclass=abc.ABCMeta):\n    def __init__(\n            self,\n            trainer,\n            exploration_env,\n            evaluation_env,\n            exploration_data_collector: DataCollector,\n            evaluation_data_collector: DataCollector,\n            replay_buffer: ReplayBuffer,\n    ):\n        self.trainer = trainer\n        self.expl_env = exploration_env\n        self.eval_env = evaluation_env\n        self.expl_data_collector = exploration_data_collector\n        self.eval_data_collector = evaluation_data_collector\n        self.replay_buffer = replay_buffer\n        self._start_epoch = 0\n\n        self.post_epoch_funcs = []\n\n    def train(self, start_epoch=0):\n        self._start_epoch = start_epoch\n        self._train()\n\n    def _train(self):\n        \"\"\"\n        Train model.\n        \"\"\"\n        raise NotImplementedError('_train must implemented by inherited class')\n\n    def _begin_epoch(self, epoch):\n        pass\n\n    def _end_epoch(self, epoch):\n        snapshot = self._get_snapshot()\n        logger.save_itr_params(epoch, snapshot)\n        gt.stamp('saving')\n        self._log_stats(epoch)\n\n        self.expl_data_collector.end_epoch(epoch)\n        self.eval_data_collector.end_epoch(epoch)\n        self.replay_buffer.end_epoch(epoch)\n        self.trainer.end_epoch(epoch)\n\n        for post_epoch_func in self.post_epoch_funcs:\n            post_epoch_func(self, epoch)\n\n    def _get_snapshot(self):\n        snapshot = {}\n        for k, v in self.trainer.get_snapshot().items():\n            snapshot['trainer/' + k] = v\n        for k, v in self.expl_data_collector.get_snapshot().items():\n            snapshot['exploration/' + k] = v\n        for k, v in self.eval_data_collector.get_snapshot().items():\n            snapshot['evaluation/' + k] = v\n        for k, v in self.replay_buffer.get_snapshot().items():\n            snapshot['replay_buffer/' + k] = v\n        return snapshot\n\n    def _log_stats(self, epoch):\n        logger.log(\"Epoch {} finished\".format(epoch), with_timestamp=True)\n        logger.record_dict({\"epoch\": epoch})\n\n        \"\"\"\n        Replay Buffer\n        \"\"\"\n        logger.record_dict(\n            self.replay_buffer.get_diagnostics(),\n            prefix='replay_buffer/'\n        )\n\n        \"\"\"\n        Trainer\n        \"\"\"\n        logger.record_dict(self.trainer.get_diagnostics(), prefix='trainer/')\n\n        \"\"\"\n        Exploration\n        \"\"\"\n        logger.record_dict(\n            self.expl_data_collector.get_diagnostics(),\n            prefix='expl/'\n        )\n        expl_paths = self.expl_data_collector.get_epoch_paths()\n        if hasattr(self.expl_env, 'get_diagnostics'):\n            logger.record_dict(\n                self.expl_env.get_diagnostics(expl_paths),\n                prefix='expl/',\n            )\n        logger.record_dict(\n            eval_util.get_generic_path_information(expl_paths),\n            prefix=\"expl/\",\n        )\n        \"\"\"\n        Evaluation\n        \"\"\"\n        logger.record_dict(\n            self.eval_data_collector.get_diagnostics(),\n            prefix='eval/',\n        )\n        eval_paths = self.eval_data_collector.get_epoch_paths()\n        if hasattr(self.eval_env, 'get_diagnostics'):\n            logger.record_dict(\n                self.eval_env.get_diagnostics(eval_paths),\n                prefix='eval/',\n            )\n        logger.record_dict(\n            eval_util.get_generic_path_information(eval_paths),\n            prefix=\"eval/\",\n        )\n\n        \"\"\"\n        Misc\n        \"\"\"\n        gt.stamp('logging')\n        logger.record_dict(_get_epoch_timings())\n        logger.record_tabular('Epoch', epoch)\n        logger.dump_tabular(with_prefix=False, with_timestamp=False)\n\n    @abc.abstractmethod\n    def training_mode(self, mode):\n        \"\"\"\n        Set training mode to `mode`.\n        :param mode: If True, training will happen (e.g. set the dropout\n        probabilities to not all ones).\n        \"\"\"\n        pass", "\nclass NewBaseRLAlgorithm(object, metaclass=abc.ABCMeta):\n    def __init__(\n            self,\n            trainer,\n            exploration_env,\n            evaluation_env,\n            exploration_data_collector: DataCollector,\n            evaluation_data_collector: DataCollector,\n            replay_buffer: ReplayBuffer,\n    ):\n        self.trainer = trainer\n        self.expl_env = exploration_env\n        self.eval_env = evaluation_env\n        self.expl_data_collector = exploration_data_collector\n        self.eval_data_collector = evaluation_data_collector\n        self.replay_buffer = replay_buffer\n        self._start_epoch = 0\n\n        self.post_epoch_funcs = []\n\n    def train(self, start_epoch=0):\n        self._start_epoch = start_epoch\n        self._train()\n\n    def _train(self):\n        \"\"\"\n        Train model.\n        \"\"\"\n        raise NotImplementedError('_train must implemented by inherited class')\n\n    def _begin_epoch(self, epoch):\n        pass\n\n    def _end_epoch(self, epoch):\n        snapshot = self._get_snapshot()\n        logger.save_itr_params(epoch, snapshot)\n        gt.stamp('saving')\n        self._log_stats(epoch)\n\n        self.expl_data_collector.end_epoch(epoch)\n        self.eval_data_collector.end_epoch(epoch)\n        self.replay_buffer.end_epoch(epoch)\n        self.trainer.end_epoch(epoch)\n\n        for post_epoch_func in self.post_epoch_funcs:\n            post_epoch_func(self, epoch)\n\n    def _get_snapshot(self):\n        snapshot = {}\n        for k, v in self.trainer.get_snapshot().items():\n            snapshot['trainer/' + k] = v\n        for k, v in self.expl_data_collector.get_snapshot().items():\n            snapshot['exploration/' + k] = v\n        for k, v in self.eval_data_collector.get_snapshot().items():\n            snapshot['evaluation/' + k] = v\n        for k, v in self.replay_buffer.get_snapshot().items():\n            snapshot['replay_buffer/' + k] = v\n        return snapshot\n\n    def _log_stats(self, epoch):\n        logger.log(\"Epoch {} finished\".format(epoch), with_timestamp=True)\n        logger.record_dict({\"epoch\": epoch})\n\n        \"\"\"\n        Replay Buffer\n        \"\"\"\n        logger.record_dict(\n            self.replay_buffer.get_diagnostics(),\n            prefix='replay_buffer/'\n        )\n\n        \"\"\"\n        Trainer\n        \"\"\"\n        logger.record_dict(self.trainer.get_diagnostics(), prefix='trainer/')\n\n        \"\"\"\n        Exploration\n        \"\"\"\n        logger.record_dict(\n            self.expl_data_collector.get_diagnostics(),\n            prefix='expl/'\n        )\n        expl_paths = self.expl_data_collector.get_epoch_paths()\n        if hasattr(self.expl_env, 'get_diagnostics'):\n            logger.record_dict(\n                self.expl_env.get_diagnostics(expl_paths),\n                prefix='expl/',\n            )\n        logger.record_dict(\n            eval_util.get_generic_path_information(expl_paths),\n            prefix=\"expl/\",\n        )\n        \"\"\"\n        Evaluation\n        \"\"\"\n        logger.record_dict(\n            self.eval_data_collector.get_diagnostics(),\n            prefix='eval/',\n        )\n        eval_paths = self.eval_data_collector.get_epoch_paths()\n        if hasattr(self.eval_env, 'get_diagnostics'):\n            logger.record_dict(\n                self.eval_env.get_diagnostics(eval_paths),\n                prefix='eval/',\n            )\n        logger.record_dict(\n            eval_util.get_generic_path_information(eval_paths),\n            prefix=\"eval/\",\n        )\n\n        \"\"\"\n        Misc\n        \"\"\"\n        gt.stamp('logging')\n        logger.record_dict(_get_epoch_timings())\n        logger.record_tabular('Epoch', epoch)\n        logger.dump_tabular(with_prefix=False, with_timestamp=False)\n\n    @abc.abstractmethod\n    def training_mode(self, mode):\n        \"\"\"\n        Set training mode to `mode`.\n        :param mode: If True, training will happen (e.g. set the dropout\n        probabilities to not all ones).\n        \"\"\"\n        pass", "\nclass NewBatchRLAlgorithm(NewBaseRLAlgorithm, metaclass=abc.ABCMeta):\n    def __init__(\n            self,\n            trainer,\n            exploration_env,\n            evaluation_env,\n            exploration_data_collector: PathCollector,\n            evaluation_data_collector: PathCollector,\n            replay_buffer: ReplayBuffer,\n            batch_size,\n            max_path_length,\n            num_epochs,\n            num_eval_steps_per_epoch,\n            num_expl_steps_per_train_loop,\n            num_trains_per_train_loop,\n            num_train_loops_per_epoch=1,\n            min_num_steps_before_training=0,\n            start_epoch=0, # negative epochs are offline, positive epochs are online\n    ):\n        super().__init__(\n            trainer,\n            exploration_env,\n            evaluation_env,\n            exploration_data_collector,\n            evaluation_data_collector,\n            replay_buffer,\n        )\n        self.batch_size = batch_size\n        self.max_path_length = max_path_length\n        self.num_epochs = num_epochs\n        self.num_eval_steps_per_epoch = num_eval_steps_per_epoch\n        self.num_trains_per_train_loop = num_trains_per_train_loop\n        self.num_train_loops_per_epoch = num_train_loops_per_epoch\n        self.num_expl_steps_per_train_loop = num_expl_steps_per_train_loop\n        self.min_num_steps_before_training = min_num_steps_before_training\n        self._start_epoch = start_epoch\n        gt.reset_root()\n\n    def train(self):\n        \"\"\"Negative epochs are offline, positive epochs are online\"\"\"\n        for self.epoch in gt.timed_for(\n                range(self._start_epoch, self.num_epochs),\n                save_itrs=True,\n        ):\n            self.offline_rl = self.epoch < 0\n            self._begin_epoch(self.epoch)\n            self._train()\n            self._end_epoch(self.epoch)\n\n    def _train(self):\n        if self.epoch == 0 and self.min_num_steps_before_training > 0:\n            init_expl_paths = self.expl_data_collector.collect_new_paths(\n                self.max_path_length,\n                self.min_num_steps_before_training,\n                discard_incomplete_paths=False,\n            )\n            if not self.offline_rl:\n                self.replay_buffer.add_paths(init_expl_paths)\n            self.expl_data_collector.end_epoch(-1)\n\n        self.eval_data_collector.collect_new_paths(\n            self.max_path_length,\n            self.num_eval_steps_per_epoch,\n            discard_incomplete_paths=True,\n        )\n        gt.stamp('evaluation sampling')\n\n        for _ in range(self.num_train_loops_per_epoch):\n            new_expl_paths = self.expl_data_collector.collect_new_paths(\n                self.max_path_length,\n                self.num_expl_steps_per_train_loop,\n                discard_incomplete_paths=False,\n            )\n            gt.stamp('exploration sampling', unique=False)\n\n            if not self.offline_rl:\n                self.replay_buffer.add_paths(new_expl_paths)\n            gt.stamp('data storing', unique=False)\n\n            self.training_mode(True)\n            for _ in range(self.num_trains_per_train_loop):\n                train_data = self.replay_buffer.random_batch(self.batch_size)\n                self.trainer.train(train_data)\n            gt.stamp('training', unique=False)\n            self.training_mode(False)", "\nclass NewTorchBatchRLAlgorithm(NewBatchRLAlgorithm):\n    def to(self, device):\n        for net in self.trainer.networks:\n            net.to(device)\n\n    def training_mode(self, mode):\n        for net in self.trainer.networks:\n            net.train(mode)\n", "\n\nclass SizeEnvReplayBuffer(EnvReplayBuffer):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n    def random_batch(self, batch_size):\n        indices = np.random.choice(self._size, size=batch_size, replace=self._replace or self._size < batch_size)\n        if not self._replace and self._size < batch_size:\n            warnings.warn('Replace was set to false, but is temporarily set to true because batch size is larger than current size of replay.')\n        batch = dict(\n            observations=self._observations[indices],\n            actions=self._actions[indices],\n            rewards=self._rewards[indices],\n            terminals=self._terminals[indices],\n            next_observations=self._next_obs[indices],\n        )\n        for key in self._env_info_keys:\n            assert key not in batch.keys()\n            batch[key] = self._env_infos[key][indices]\n        return batch"]}
{"filename": "apps/wandb_record.py", "chunked_list": ["import matplotlib.pyplot as plt\nimport wandb\nimport numpy as np\nimport sys, os\nbase_path = os.getcwd()\nsys.path.append(base_path)\nfrom configs.config import get_base_config, make_config\nfrom utils.utils import *\nif __name__ == '__main__':\n    parser = get_base_config()\n    args = parser.parse_known_args(sys.argv[1:])[0]\n    from truss_envs.reward import Envs_init, reward_fun\n    config = make_config(args.config)\n    for k, v in config.get(\"base\", {}).items():\n        if f\"--{k}\" not in args:\n            setattr(args, k, v)\n    Envs_init(args)\n    run_dir = os.path.join(args.save_path, args.run_id)\n    wandb.init(\n        config = args,\n        project = 'Truss_plot_fixed',\n        group = args.config,\n        dir = run_dir,\n        job_type = 'check',\n        name = args.config + args.run_id\n    )\n    Envs_init(args)\n    log_file1 = np.loadtxt(os.path.join(args.save_path, args.run_id, args.logfile_stage1))\n    print(log_file1.shape)\n    log_file2 = np.loadtxt(os.path.join(args.input_path_2, args.run_id, args.logfile_stage2))\n    begin_index = 0\n    while (log_file1[begin_index][2] > 1000000): begin_index += 1\n    for i in range(0, begin_index):\n        wandb.log({'mass_stage1': log_file1[begin_index][2], \n            'mass_stage2': log_file2[i][1]}, \n        step = int(log_file2[i][0]))\n    for i in range(begin_index, len(log_file1)):\n        if (i < len(log_file2)):\n            wandb.log({'mass_stage1': log_file1[i][2], \n                'mass_stage2': log_file2[i][1]}, step = int(log_file1[i][0]))\n        else:\n            wandb.log({'mass_stage1': log_file1[i][2]}, step = int(log_file1[i][0]))", "if __name__ == '__main__':\n    parser = get_base_config()\n    args = parser.parse_known_args(sys.argv[1:])[0]\n    from truss_envs.reward import Envs_init, reward_fun\n    config = make_config(args.config)\n    for k, v in config.get(\"base\", {}).items():\n        if f\"--{k}\" not in args:\n            setattr(args, k, v)\n    Envs_init(args)\n    run_dir = os.path.join(args.save_path, args.run_id)\n    wandb.init(\n        config = args,\n        project = 'Truss_plot_fixed',\n        group = args.config,\n        dir = run_dir,\n        job_type = 'check',\n        name = args.config + args.run_id\n    )\n    Envs_init(args)\n    log_file1 = np.loadtxt(os.path.join(args.save_path, args.run_id, args.logfile_stage1))\n    print(log_file1.shape)\n    log_file2 = np.loadtxt(os.path.join(args.input_path_2, args.run_id, args.logfile_stage2))\n    begin_index = 0\n    while (log_file1[begin_index][2] > 1000000): begin_index += 1\n    for i in range(0, begin_index):\n        wandb.log({'mass_stage1': log_file1[begin_index][2], \n            'mass_stage2': log_file2[i][1]}, \n        step = int(log_file2[i][0]))\n    for i in range(begin_index, len(log_file1)):\n        if (i < len(log_file2)):\n            wandb.log({'mass_stage1': log_file1[i][2], \n                'mass_stage2': log_file2[i][1]}, step = int(log_file1[i][0]))\n        else:\n            wandb.log({'mass_stage1': log_file1[i][2]}, step = int(log_file1[i][0]))"]}
{"filename": "apps/discretize.py", "chunked_list": ["import os\nimport sys\nimport math\nbase_path = os.getcwd()\nsys.path.append(base_path)\nfrom utils.utils import *\nfrom configs.config import *\nparser = get_base_config()\nargs = parser.parse_known_args(sys.argv[1:])[0]\nfrom truss_envs.reward import *", "args = parser.parse_known_args(sys.argv[1:])[0]\nfrom truss_envs.reward import *\nEnvs_init(args)\nif __name__ == '__main__':\n    p = []\n    e = []\n    alist = []\n    AREAFILE = args.Alist_path\n    FILENAME = args.check_file\n    \n    with open(FILENAME, \"r\") as fle:\n        lines = fle.readlines()\n        for i in range(len(lines)):\n            line = lines[i]\n            vec = line.strip().split(' ')\n            if (i == 0):\n                vn = int(vec[0])\n                en = int(vec[1])\n            if (1 <= i and i <= vn):\n                p.append(Point(Vector3(float(vec[0]), float(vec[1]), float(vec[2])), int(vec[3]), int(vec[4]), int(vec[5]), float(vec[6]), float(vec[7]), float(vec[8])))            \n            if (vn + 1 <= i and i <= vn + en):\n                if (len(vec) > 3):\n                    d = float(vec[3])\n                    t = float(vec[4])\n                else:\n                    d = None\n                    t = None\n                if (float(vec[2]) < 0): continue\n                e.append(Bar(vec[0], vec[1], float(vec[2]), getlen2(p[int(vec[0])], p[int(vec[1])]), d = d, t = t))\n\n    with open(AREAFILE,'r') as ar:\n        section_lines = ar.readlines()\n        for i in range(len(section_lines)):\n            section_line = section_lines[i]\n            section_r = section_line.strip().split(' ')\n            if (i==0):\n                section_num = int(section_r[0])\n                continue\n            if (i > 0 and i <= section_num):\n                name_s = 'd'+str(section_r[0])+'t'+str(int(float(section_r[1])*10))\n                d = float(section_r[0])/1000.0\n                t = float(section_r[1])/1000.0\n                area_s =  math.pi*d**2/4.0 - math.pi*(d-2*t)**2/4.0\n                I_s = math.pi*d**4/64.0 - math.pi*(d-2*t)**4/64.0\n                i_s = math.sqrt(I_s/area_s)\n                alist.append((float(area_s), float(I_s), float(i_s), str(name_s), float(d), float(t)))\n    \n    print(reward_fun(p, e))\n\n    for j in range(5):\n      for i in range(len(e)):\n        minaera = 1e9\n        for d_edge in alist:\n            e[i] = Bar(e[i].u, e[i].v, leng = getlen2(p[e[i].u], p[e[i].v]), area=d_edge[0], I_s = d_edge[1], i_s = d_edge[2], name_s = d_edge[3], d = d_edge[4], t = d_edge[5])\n            if (reward_fun(p, e)[0] > 0 and d_edge[0] < minaera):\n                final_edge = d_edge\n                minaera = d_edge[0]\n        if (minaera == 1e9):\n            print('no valid truss')\n        e[i] = Bar(e[i].u, e[i].v, leng = getlen2(p[e[i].u], p[e[i].v]), area=final_edge[0], I_s = final_edge[1], i_s = final_edge[2], name_s = final_edge[3], d = final_edge[4], t = final_edge[5])\n\n    print(reward_fun(p, e))\n\n    OUTFILE = 'D' + str(reward_fun(p, e)[0]) + '.txt'\n    with open(OUTFILE, \"w\") as f:\n        print(len(p), len(e), file=f)\n        for i in range(len(p)):\n            print(p[i].vec.x, p[i].vec.y, p[i].vec.z, p[i].supportX, p[i].supportY,\n                p[i].supportZ, p[i].loadX, p[i].loadY, p[i].loadZ, file=f)\n\n        for i in range(len(e)):\n            print(e[i].u, e[i].v, e[i].area, e[i].d, e[i].t, file=f)", ""]}
{"filename": "apps/plot_truss_layout.py", "chunked_list": ["import matplotlib.pyplot as plt\nimport math, os\n\n\nclass Vector3:\n\tdef __init__(self, x=0.0, y=0.0, z=0.0):\n\t\tself.x = float(x)\n\t\tself.y = float(y)\n\t\tself.z = float(z)\n\n\tdef __add__(self, obj):\n\t\treturn Vector3(self.x + obj.x, self.y + obj.y, self.z + obj.z)\n\n\tdef __sub__(self, obj):\n\t\treturn Vector3(self.x - obj.x, self.y - obj.y, self.z - obj.z)\n\n\tdef __mul__(self, obj):\n\t\tif (type(obj) == Vector3):\n\t\t\treturn Vector3(self.y * obj.z - self.z * obj.y, self.z * obj.x - self.x * obj.z,\n\t\t\t\t\t\t   self.x * obj.y - self.y * obj.x)\n\t\tif (type(obj) == float or type(obj) == int):\n\t\t\treturn Vector3(self.x * obj, self.y * obj, self.z * obj)\n\t\tassert (False)\n\n\tdef __str__(self):\n\t\treturn str('(' + str(self.x) + ', ' + str(self.y) + ', ' + str(self.z) + ')')\n\n\tdef length2(self):\n\t\treturn float(self.x * self.x + self.y * self.y + self.z * self.z)\n\n\tdef length(self):\n\t\treturn math.sqrt(self.x * self.x + self.y * self.y + self.z * self.z)\n\n\tdef norm(self):\n\t\tl = self.length()\n\t\treturn Vector3(self.x / l, self.y / l, self.z / l)\n\n\tdef __eq__(self, other):\n\t\tassert (type(other) == Vector3)\n\t\tif (abs(self.x - other.x) < 1e-8 and abs(self.y - other.y) < 1e-8 and abs(self.z - other.z) < 1e-8):\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False", "\n\nclass Point:\n\n\tdef __init__(self, vec=Vector3(), supportX=0, supportY=0, supportZ=1, loadX=0.0, loadY=0.0, loadZ=0.0):\n\t\tself.vec = vec\n\n\t\tself.supportX = supportX\n\t\tself.supportY = supportY\n\t\tself.supportZ = supportZ\n\t\tself.isSupport = False\n\t\t# 2D\n\t\tif (supportX == 1 or supportY == 1):\n\t\t\tself.isSupport = True\n\t\t# #3D\n\t\t# if (supportX == 1 or supportY == 1 or supportZ == 1):\n\t\t# \tself.isSupport = True\n\t\tself.loadX = loadX\n\t\tself.loadY = loadY\n\t\tself.loadZ = loadZ\n\t\tself.isLoad = False\n\t\tif (abs(loadX) > 1e-7 or abs(loadY) > 1e-7 or abs(loadZ) > 1e-7):\n\t\t\tself.isLoad = True", "\n\nclass Bar:\n\n\tdef __init__(self, u=-1, v=-1, area=1.0, leng=0.0, inertia=1.0):\n\t\tself.u = int(u)\n\t\tself.v = int(v)\n\t\tself.area = float(area)\n\t\tself.force = float(0.0)\n\t\tself.len = leng\n\t\tself.stress = 0.0\n\t\tself.inertia = float(inertia)", "\n\nclass Load:\n\n\tdef __init__(self, u=-1, fx=0.0, fy=0.0, fz=0.0):\n\t\tself.u = int(u)\n\t\tself.fx = float(fx)\n\t\tself.fy = float(fy)\n\t\tself.fz = float(fz)\n", "\n\ndef getlen2(u, v):\n\treturn math.sqrt((u.vec.x-v.vec.x)**2+(u.vec.y-v.vec.y)**2+(u.vec.z-v.vec.z)**2)\n\n\ndef readFile(FILENAME):\n\tp = []\n\te = []\n\tpload = []\n\n\twith open(FILENAME, \"r\") as fle:\n\t\tlines = fle.readlines()\n\t\tfor i in range(len(lines)):\n\t\t\tline = lines[i]\n\t\t\tvec = line.strip().split(' ')\n\t\t\tif (i == 0):\n\t\t\t\tvn = int(vec[0])\n\t\t\t\ten = int(vec[1])\n\t\t\t\tcontinue\n\n\t\t\tif (1 <= i and i <= vn):\n\t\t\t\tp.append(Point(Vector3(float(vec[0]), float(vec[1]), float(vec[2])), int(vec[3]), int(vec[4]), int(vec[5]), float(vec[6]), float(vec[7]), float(vec[8])))\n\t\t\t\tpload.append(Load(i-1, float(vec[6]), float(vec[7]), float(vec[8])))\n\t\t\t\tcontinue\n\n\t\t\tif (vn + 1 <= i and i <= vn + en):\n\t\t\t\te.append(Bar(vec[0], vec[1], float(vec[2]), getlen2(p[int(vec[0])], p[int(vec[1])])))\n\t\t\t\tcontinue\n\n\treturn p, e, pload", "\n\ndef saveGraph(p, e):\n\tfor i in range(len(p)):\n\t\tplt.scatter([p[i].vec.x], [p[i].vec.y], color='b')\n\n\tfor i in range(len(e)):\n\t\tx0 = [p[e[i].u].vec.x, p[e[i].v].vec.x]\n\t\ty0 = [p[e[i].u].vec.y, p[e[i].v].vec.y]\n\n\t\t# plt.scatter(x0, y0, color='b')\n\t\t# plt.text((x0[0] + x0[1]) / 2, (y0[0] + y0[1]) / 2, '%.3f'%e[i]['len'], ha = 'center',va = 'bottom',fontsize=7)\n\t\t# plt.plot(x0, y0, color='g')\n\t\t#if (e[i].stress < 0):\n\t\t#\tplt.plot(x0, y0, color='g', linewidth=e[i].area / 0.01)\n\t\t#else:\n\t\t#\tplt.plot(x0, y0, color='r', linewidth=e[i].area / 0.01)\n\t\tif e[i].area != -1:\n\t\t\tplt.plot(x0, y0, color='b', linewidth=e[i].area / 0.01)\n\n\t#plt.figure()\n\tplt.axis(\"equal\")\n\t# FILENAME = \".\\\\\" + str(len(p)) + \"p_case1_\" + str(reward) + \".jpg\"\n\tinputname = FILENAME.replace(\".txt\", \"\")\n\tFILENAME_jpg = inputname + \".jpg\"\n\t# FILENAME = \".\\\\\" + str(len(p)) + \"p_case1_\" + str(round(reward, 2)) + \".jpg\"\n\n\tplt.savefig(FILENAME_jpg, dpi=1000)\n\tplt.clf()", "\n\nif __name__ == '__main__':\n\t#FILENAME = '../results/20211107/generate-tg-reward_v2-keep_policy-brute_force-nn-s1ts100-s2ts100-area0.0001x0.02-cdl37x17-1107_mp_7_cdl_37_17/stage_1_best_2822_obs.txt'\n\t#FILENAME = '../thu_wsy/truss_refine-master_v2/best_results/2139/2139.txt'\n\t#FILENAME = './MasterTransformerEmbedding_v1/ExperiementResult/Max9p_2/2523997.txt'\n\t#FILENAME = './AllExperiment/AlphaTrussStage1/6p_2305.txt'\n\t#FILENAME = './Stage1/PostResults/Eval_noise/9p_1/'\n\n\t#p, e, pload = readFile(FILENAME)\n\t#saveGraph(p, e)\n\n\n\tFILEfolder = './AllExperiment/Noise/'\n\tfilelist = os.listdir(FILEfolder)\n\tfor file in filelist:\n\t\tif file[-4:] == '.txt':\n\t\t\tprint(file)\n\t\t\tFILENAME = FILEfolder + file\n\t\t\tp, e, pload = readFile(FILENAME)\n\t\t\tsaveGraph(p, e)", ""]}
{"filename": "apps/draw_log.py", "chunked_list": ["import matplotlib.pyplot as plt\nimport numpy as np\nimport sys, os\nbase_path = os.getcwd()\nsys.path.append(base_path)\nfrom configs.config import get_base_config, make_config\nfrom utils.utils import *\nif __name__ == '__main__':\n    parser = get_base_config()\n    args = parser.parse_known_args(sys.argv[1:])[0]\n    from truss_envs.reward import Envs_init, reward_fun\n    config = make_config(args.config)\n    for k, v in config.get(\"base\", {}).items():\n        if f\"--{k}\" not in args:\n            setattr(args, k, v)\n    Envs_init(args)\n    log_file1 = np.loadtxt(os.path.join(args.save_path, args.run_id, args.logfile_stage1))\n    print(log_file1.shape)\n    begin_index = 0\n    while (log_file1[begin_index][2] > 1000000): begin_index += 1\n    plt.plot(log_file1[begin_index:, 0], log_file1[begin_index:, 2])\n    plt.savefig(os.path.join(args.save_path, args.run_id, 'graph_stage1.jpg'), dpi = 1000)\n    plt.clf()\n    log_file2 = np.loadtxt(os.path.join(args.input_path_2, args.run_id, args.logfile_stage2))\n    print(log_file2.shape)\n    begin_index = 0\n    while (log_file2[begin_index][1] > 1000000): begin_index += 1\n    plt.plot(log_file2[begin_index:, 0], log_file2[begin_index:, 1])\n    plt.savefig(os.path.join(args.save_path, args.run_id, 'graph_stage2.jpg'), dpi = 1000)"]}
{"filename": "apps/diversity_check.py", "chunked_list": ["import matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.animation as animation\nimport sys, os\nimport time\nbase_path = os.getcwd()\nsys.path.append(base_path)\nfrom configs.config import get_base_config, make_config\nfrom utils.utils import *\nfrom truss_envs.reward import reward_fun", "from utils.utils import *\nfrom truss_envs.reward import reward_fun\n#change 3D\u4f5c\u56fe\ntime_str = time.strftime(\"%Y-%m-%d-%H_%M_%S\",time.localtime()) \n\nif __name__ == '__main__':\n    parser = get_base_config()\n    args = parser.parse_known_args(sys.argv[1:])[0]\n    from truss_envs.reward import Envs_init, reward_fun\n    config = make_config(args.config)\n    for k, v in config.get(\"base\", {}).items():\n        if f\"--{k}\" not in args:\n            setattr(args, k, v)\n    Envs_init(args)", "\ndef check_diversity_map(truss_list):\n    distinct = []\n    distinct_count = []\n    for truss in truss_list:\n        unique = True\n        for i in range(len(distinct)):\n            ref_truss = distinct[i]\n            if (similar_topo(truss[0], truss[1], ref_truss[0], ref_truss[1])):\n                unique = False\n                distinct_count[i] += 1\n                break\n        if (unique):\n            distinct.append(truss)\n            distinct_count.append(1)\n    for i in range(len(distinct)):\n        distinct[i] = (distinct[i], distinct_count[i])\n    distinct.sort(key = lambda x1: x1[1], reverse = True)\n    distinct_count.sort(reverse = True)\n    return len(distinct), distinct_count, distinct", "\nif __name__ == '__main__':\n    check_path = os.path.join(args.save_path, args.run_id, 'DIVERSITY_TOPO_result')\n    files = os.listdir(check_path)\n    truss_list = []\n    for file in files:\n        if (file[-4:] == '.txt'):\n            p, e = readFile(os.path.join(check_path, file))\n            truss_list.append((p, e))\n    print(check_diversity_map(truss_list)[0 : 2])\n    check_path = os.path.join(args.input_path_2, args.run_id)\n    files = os.listdir(check_path)\n    truss_list = []\n    for file in files:\n        if (file[-4:] == '.txt'):\n            p, e = readFile(os.path.join(check_path, file))\n            truss_list.append((p, e))\n    print(check_diversity_map(truss_list)[0 : 2])", ""]}
{"filename": "apps/check.py", "chunked_list": ["import os, sys\nbase_path = os.getcwd()\nsys.path.append(base_path)\n\nfrom configs.config import *\nparser = get_base_config()\nargs = parser.parse_known_args(sys.argv[1:])[0]\nfrom collections import OrderedDict\nfrom truss_envs.reward import *\nfrom utils.utils import *", "from truss_envs.reward import *\nfrom utils.utils import *\nfrom Stage2.envs.dynamic2 import DynamicModel\n\nEnvs_init(args)\n\nFILENAME = args.check_file\n    \np = OrderedDict()\ne = OrderedDict()\nwith open(FILENAME, \"r\") as fle:\n    lines = fle.readlines()\n    edge_cnt = 0\n    for i in range(len(lines)):\n        line = lines[i]\n        vec = line.strip().split(' ')\n        if (i == 0):\n            vn = int(vec[0])\n            en = int(vec[1])\n            continue\n\n        if (1 <= i and i <= vn):\n            p[i - 1] = Point(Vector3(float(vec[0]), float(vec[1]), float(vec[2])), int(vec[3]), int(vec[4]), int(vec[5]), float(vec[6]), float(vec[7]), float(vec[8]))\n        \n        if (vn + 1 <= i and i <= vn + en and float(vec[2]) != -1):\n            e[edge_cnt] = Bar(vec[0], vec[1], float(vec[2]), getlen2(p[int(vec[0])], p[int(vec[1])]), d = float(vec[3]), t = float(vec[4]))\n            edge_cnt += 1", "p = OrderedDict()\ne = OrderedDict()\nwith open(FILENAME, \"r\") as fle:\n    lines = fle.readlines()\n    edge_cnt = 0\n    for i in range(len(lines)):\n        line = lines[i]\n        vec = line.strip().split(' ')\n        if (i == 0):\n            vn = int(vec[0])\n            en = int(vec[1])\n            continue\n\n        if (1 <= i and i <= vn):\n            p[i - 1] = Point(Vector3(float(vec[0]), float(vec[1]), float(vec[2])), int(vec[3]), int(vec[4]), int(vec[5]), float(vec[6]), float(vec[7]), float(vec[8]))\n        \n        if (vn + 1 <= i and i <= vn + en and float(vec[2]) != -1):\n            e[edge_cnt] = Bar(vec[0], vec[1], float(vec[2]), getlen2(p[int(vec[0])], p[int(vec[1])]), d = float(vec[3]), t = float(vec[4]))\n            edge_cnt += 1", "\n#print(len(p), len(e))\nmodel = DynamicModel(dimension = 3)\nprint(model.run(p, e, mode = 'check'))\nprint(reward_fun(p, e,sanity_check = False))"]}
{"filename": "apps/eval.py", "chunked_list": ["import matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.animation as animation\nimport sys, os\nimport time\nbase_path = os.getcwd()\nsys.path.append(base_path)\nfrom configs.config import get_base_config, make_config\nfrom utils.utils import *\nfrom truss_envs.reward import reward_fun", "from utils.utils import *\nfrom truss_envs.reward import reward_fun\n#change 3D\u4f5c\u56fe\ntime_str = time.strftime(\"%Y-%m-%d-%H_%M_%S\",time.localtime()) \n\nif __name__ == '__main__':\n    parser = get_base_config()\n    args = parser.parse_known_args(sys.argv[1:])[0]\n    from truss_envs.reward import Envs_init, reward_fun\n    config = make_config(args.config)\n    for k, v in config.get(\"base\", {}).items():\n        if f\"--{k}\" not in args:\n            setattr(args, k, v)\n    Envs_init(args)", "\ndef drawGraph(p, e, args, canshow = 1, reward = 0.0, FILENAME = \"output\"):\n\n    print(reward_fun(p, e, mode = 'check'))\n    if (reward == 0.0): reward, _, _, _, _, _ = reward_fun(p, e)\n\n    if (args.env_dims == 3):\n        fig = plt.figure()\n        ax = plt.axes(projection='3d')\n\n        X=np.ones(len(p))\n        Y=np.ones(len(p))\n        Z=np.ones(len(p))\n\n        def rotate(angle): ax.view_init(azim=angle)\n\n        for i in range(len(p)):\n            ax.scatter3D([p[i].vec.x], [p[i].vec.y], [p[i].vec.z], color='b')\n            X[i]=p[i].vec.x\n            Y[i]=p[i].vec.y\n            Z[i]=p[i].vec.z\n\n        for i in range(len(e)):\n            x0 = [p[e[i].u].vec.x, p[e[i].v].vec.x]\n            y0 = [p[e[i].u].vec.y, p[e[i].v].vec.y]\n            z0 = [p[e[i].u].vec.z, p[e[i].v].vec.z]\n            if (e[i].area < 0): continue\n\n            if (e[i].stress < 0):\n                # ax.plot3D(x0, y0, z0, color='g', linewidth = e[i].area / 0.001)\n                ax.plot3D(x0, y0, z0, color='g', linewidth = 1)\n            elif (e[i].stress > 0):\n                # ax.plot3D(x0, y0, z0, color='r', linewidth = e[i].area / 0.001)\n                ax.plot3D(x0, y0, z0, color='r', linewidth = 1)\n            else:\n                ax.plot3D(x0, y0, z0, color='k', linewidth = 1)\n        \n            # scat = ax.scatter(X, Y, Z)\n            # Create cubic bounding box to simulate equal aspect ratio\n            max_range = np.array([X.max()-X.min(), Y.max()-Y.min(), Z.max()-Z.min()]).max()\n            Xb = 0.5*max_range*np.mgrid[-1:2:2,-1:2:2,-1:2:2][0].flatten() + 0.5*(X.max()+X.min())\n            Yb = 0.5*max_range*np.mgrid[-1:2:2,-1:2:2,-1:2:2][1].flatten() + 0.5*(Y.max()+Y.min())\n            Zb = 0.5*max_range*np.mgrid[-1:2:2,-1:2:2,-1:2:2][2].flatten() + 0.5*(Z.max()+Z.min())\n\n            # Comment or uncomment following both lines to test the fake bounding box:\n            for xb, yb, zb in zip(Xb, Yb, Zb): ax.plot([xb], [yb], [zb], 'w')\n        \n        # plt.axis(\"auto\")\n        # NotImplementedError: Axes3D currently only supports the aspect argument 'auto'. You passed in 'equal'.\n        plt.title(str(reward))\n        #plot animation gif\n        rot_animation = animation.FuncAnimation(fig, rotate, frames=np.arange(0,362,2),interval=100)\n        FILENAME = os.path.join(args.config + \"_\" + str(len(p)) + \"p\" + str(round(reward, 2)) + '_3d' + \".gif\")\n        print('Save img to', FILENAME)\n        rot_animation.save(FILENAME, dpi=100)\n        if (canshow == 1): plt.show()\n\n    elif args.env_dims == 2:\n        for i in range(len(e)):\n            x0 = [p[e[i].u].vec.x, p[e[i].v].vec.x]\n            y0 = [p[e[i].u].vec.y, p[e[i].v].vec.y]\n            if (e[i].stress < 0): plt.plot(x0, y0, color='g', linewidth = min(max(e[i].area / 0.005, 2), 6))\n            else: plt.plot(x0, y0, color='b', linewidth = min(max(e[i].area / 0.005, 2), 6))\n        for i in range(len(p)):\n            plt.scatter([p[i].vec.x], [p[i].vec.y], color='b', linewidths = 5)\n        plt.axis(\"equal\")\n        plt.title(str(reward))\n        FILENAME = os.path.join(args.config + \"_\" + str(len(p)) + \"p\" + str(round(reward, 2)) + '_2d' + \".jpg\")\n        print('Save img to', FILENAME)\n        plt.savefig(FILENAME, dpi = 1000)", "        \n\ndef saveGraph(p, e, reward = 0.0):\n\n    print(reward_fun(p, e))\n    if (reward == 0.0): reward, _, _, _, _, _ = reward_fun(p, e, mode = 'check')\n    for i in range(len(p)):\n        plt.scatter([p[i].vec.x], [p[i].vec.y], color='b')\n\n    for i in range(len(e)):\n        x0 = [p[e[i].u].vec.x, p[e[i].v].vec.x]\n        y0 = [p[e[i].u].vec.y, p[e[i].v].vec.y]\n        if (e[i].stress < 0):\n            plt.plot(x0, y0, color='g', linewidth = e[i].area / 0.01)\n        else:\n            plt.plot(x0, y0, color='r', linewidth = e[i].area / 0.01)\n        \n    plt.axis(\"equal\")\n    plt.title(str(reward))\n    FILENAME = str(args.config) + \"_\" + str(len(p)) + \"p\" + str(round(reward, 2)) + '_2d' + \".jpg\"\n    plt.savefig(FILENAME, dpi = 1000)", "\ndef draw2Graph(p1, e1, p2, e2, canshow = 1):\n    sub1 = plt.subplot(1, 2, 1)\n    sub2 = plt.subplot(1, 2, 2)\n    plt.sca(sub1)\n    drawGraph(p1, e1, 0)\n    plt.sca(sub2)\n    drawGraph(p2, e2, 0)\n    if (canshow == 1):\n        plt.show()", "\nif __name__ == '__main__':\n    FILENAME = args.draw_file\n    p, e = readFile(FILENAME)\n    drawGraph(p, e, args = args)"]}
{"filename": "apps/draw.py", "chunked_list": ["import matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.animation as animation\nimport sys, os\nimport time\nbase_path = os.getcwd()\nsys.path.append(base_path)\nfrom configs.config import get_base_config, make_config\nfrom utils.utils import *\nfrom truss_envs.reward import reward_fun", "from utils.utils import *\nfrom truss_envs.reward import reward_fun\n#change 3D\u4f5c\u56fe\ntime_str = time.strftime(\"%Y-%m-%d-%H_%M_%S\",time.localtime()) \n\nif __name__ == '__main__':\n    parser = get_base_config()\n    args = parser.parse_known_args(sys.argv[1:])[0]\n    from truss_envs.reward import Envs_init, reward_fun\n    config = make_config(args.config)\n    for k, v in config.get(\"base\", {}).items():\n        if f\"--{k}\" not in args:\n            setattr(args, k, v)\n    Envs_init(args)", "\ndef drawGraph(p, e, args, canshow = 1, reward = 0.0, FILENAME = \"output\"):\n\n    print(reward_fun(p, e, mode = 'check'))\n    if (reward == 0.0): reward, _, _, _, _, _ = reward_fun(p, e)\n\n    if (args.env_dims == 3):\n        fig = plt.figure()\n        ax = plt.axes(projection='3d')\n\n        X=np.ones(len(p))\n        Y=np.ones(len(p))\n        Z=np.ones(len(p))\n\n        def rotate(angle): ax.view_init(azim=angle)\n\n        for i in range(len(p)):\n            ax.scatter3D([p[i].vec.x], [p[i].vec.y], [p[i].vec.z], color='b')\n            X[i]=p[i].vec.x\n            Y[i]=p[i].vec.y\n            Z[i]=p[i].vec.z\n\n        for i in range(len(e)):\n            x0 = [p[e[i].u].vec.x, p[e[i].v].vec.x]\n            y0 = [p[e[i].u].vec.y, p[e[i].v].vec.y]\n            z0 = [p[e[i].u].vec.z, p[e[i].v].vec.z]\n            if (e[i].area < 0): continue\n\n            if (e[i].stress < 0):\n                # ax.plot3D(x0, y0, z0, color='g', linewidth = e[i].area / 0.001)\n                ax.plot3D(x0, y0, z0, color='g', linewidth = 1)\n            elif (e[i].stress > 0):\n                # ax.plot3D(x0, y0, z0, color='r', linewidth = e[i].area / 0.001)\n                ax.plot3D(x0, y0, z0, color='r', linewidth = 1)\n            else:\n                ax.plot3D(x0, y0, z0, color='k', linewidth = 1)\n        \n            # scat = ax.scatter(X, Y, Z)\n            # Create cubic bounding box to simulate equal aspect ratio\n            max_range = np.array([X.max()-X.min(), Y.max()-Y.min(), Z.max()-Z.min()]).max()\n            Xb = 0.5*max_range*np.mgrid[-1:2:2,-1:2:2,-1:2:2][0].flatten() + 0.5*(X.max()+X.min())\n            Yb = 0.5*max_range*np.mgrid[-1:2:2,-1:2:2,-1:2:2][1].flatten() + 0.5*(Y.max()+Y.min())\n            Zb = 0.5*max_range*np.mgrid[-1:2:2,-1:2:2,-1:2:2][2].flatten() + 0.5*(Z.max()+Z.min())\n\n            # Comment or uncomment following both lines to test the fake bounding box:\n            for xb, yb, zb in zip(Xb, Yb, Zb): ax.plot([xb], [yb], [zb], 'w')\n        \n        # plt.axis(\"auto\")\n        # NotImplementedError: Axes3D currently only supports the aspect argument 'auto'. You passed in 'equal'.\n        plt.title(str(reward))\n        #plot animation gif\n        rot_animation = animation.FuncAnimation(fig, rotate, frames=np.arange(0,362,2),interval=100)\n        FILENAME = os.path.join(args.save_path, args.run_id, args.config + \"_\" + str(len(p)) + \"p\" + str(round(reward, 2)) + '_3d' + \".gif\")\n        print(FILENAME)\n        rot_animation.save(FILENAME, dpi=100)\n        if (canshow == 1): plt.show()\n\n    elif args.env_dims == 2:\n        for i in range(len(e)):\n            x0 = [p[e[i].u].vec.x, p[e[i].v].vec.x]\n            y0 = [p[e[i].u].vec.y, p[e[i].v].vec.y]\n            if (e[i].stress < 0): plt.plot(x0, y0, color='g', linewidth = min(max(e[i].area / 0.005, 2), 6))\n            else: plt.plot(x0, y0, color='b', linewidth = min(max(e[i].area / 0.005, 2), 6))\n        for i in range(len(p)):\n            plt.scatter([p[i].vec.x], [p[i].vec.y], color='b', linewidths = 5)\n        plt.axis(\"equal\")\n        plt.title(str(reward))\n        FILENAME = os.path.join(args.save_path, args.run_id, args.config + \"_\" + str(len(p)) + \"p\" + str(round(reward, 2)) + '_2d' + \".jpg\")\n        print(FILENAME)\n        plt.savefig(FILENAME, dpi = 1000)", "        \n\ndef saveGraph(p, e, reward = 0.0):\n\n    print(reward_fun(p, e))\n    if (reward == 0.0): reward, _, _, _, _, _ = reward_fun(p, e, mode = 'check')\n    for i in range(len(p)):\n        plt.scatter([p[i].vec.x], [p[i].vec.y], color='b')\n\n    for i in range(len(e)):\n        x0 = [p[e[i].u].vec.x, p[e[i].v].vec.x]\n        y0 = [p[e[i].u].vec.y, p[e[i].v].vec.y]\n        if (e[i].stress < 0):\n            plt.plot(x0, y0, color='g', linewidth = e[i].area / 0.01)\n        else:\n            plt.plot(x0, y0, color='r', linewidth = e[i].area / 0.01)\n        \n    plt.axis(\"equal\")\n    plt.title(str(reward))\n    FILENAME = \"./results_3d/\" + str(args.config) + \"_\" + str(len(p)) + \"p\" + str(round(reward, 2)) + '_2d' + \".jpg\"\n    plt.savefig(FILENAME, dpi = 1000)", "\ndef draw2Graph(p1, e1, p2, e2, canshow = 1):\n    sub1 = plt.subplot(1, 2, 1)\n    sub2 = plt.subplot(1, 2, 2)\n    plt.sca(sub1)\n    drawGraph(p1, e1, 0)\n    plt.sca(sub2)\n    drawGraph(p2, e2, 0)\n    if (canshow == 1):\n        plt.show()", "\nif __name__ == '__main__':\n    FILENAME = args.draw_file\n    p, e = readFile(FILENAME)\n    drawGraph(p, e, args = args)"]}
{"filename": "apps/checker.py", "chunked_list": ["import numpy as np\nimport math\nimport os, sys\nbase_path = os.getcwd()\nsys.path.append(base_path)\nimport openseespy.opensees as op\nimport matplotlib.pyplot as plt\nfrom utils.utils import readFile\n\nclass DynamicModel:\n    #\u6784\u9020\u51fd\u6570\n    def __init__(self,\n                dimension,\n                E=193*10**9,          #N/m2\n                pho=8.0*10**3,        #kg/m3\n                sigma_T=123*10**6,    #N/m2\n                sigma_C=213*10**6,    #N/m2\n                dislimit=0.002,       #m\n                slenderness_ratio_T=220,\n                slenderness_ratio_C=180,\n                max_len=5,            #m\n                min_len=0.03,         #m\n                use_self_weight=True,\n                use_dis_constraint=True,\n                use_stress_constraint=True,\n                use_buckle_constraint=True,\n                use_slenderness_constraint=True,\n                use_longer_constraint=True,\n                use_shorter_constraint=True\n                ): \n        self._dimension = dimension    #\u7ed3\u6784\u7ef4\u5ea6\n        self._E = E                    #\u5f39\u6027\u6a21\u91cf\n        self._pho = pho                #\u6750\u6599\u5bc6\u5ea6\n        self._sigma_T = sigma_T        #\u5bb9\u8bb8\u62c9\u5e94\u529b\n        self._sigma_C = sigma_C        #\u5bb9\u8bb8\u538b\u5e94\u529b\n        self._limit_dis = dislimit     #\u5bb9\u8bb8\u4f4d\u79fb\n        self.slenderness_ratio_T=slenderness_ratio_T #\u5bb9\u8bb8\u53d7\u62c9\u957f\u7ec6\u6bd4\n        self.slenderness_ratio_C=slenderness_ratio_C #\u5bb9\u8bb8\u53d7\u538b\u957f\u7ec6\u6bd4\n        self.max_len=max_len                         #\u6700\u5927\u957f\u5ea6\n        self.min_len=min_len                         #\u6700\u5c0f\u957f\u5ea6\n        self._use_self_weight = use_self_weight              #\u662f\u5426\u8ba1\u7b97\u81ea\u91cd\n        self._use_dis_constraint = use_dis_constraint        #\u662f\u5426\u542f\u7528\u4f4d\u79fb\u7ea6\u675f\n        self._use_stress_constraint = use_stress_constraint         #\u662f\u5426\u542f\u7528\u5e94\u529b\u7ea6\u675f\n        self._use_buckle_constraint = use_buckle_constraint         #\u662f\u5426\u542f\u7528\u5c48\u66f2\u7ea6\u675f\n        self._use_slenderness_constraint=use_slenderness_constraint #\u662f\u5426\u542f\u7528\u957f\u7ec6\u6bd4\u7ea6\u675f\n        self._use_longer_constraint=use_longer_constraint           #\u662f\u5426\u542f\u7528\u8d85\u957f\u7ea6\u675f\n        self._use_shorter_constraint=use_shorter_constraint         #\u662f\u5426\u542f\u7528\u8fc7\u77ed\u7ea6\u675f\n\n    #\u5224\u5b9a\u7ed3\u6784\u7684\u51e0\u4f55\u4e0d\u53d8\u6027+\u5206\u6790\u8ba1\u7b97\n    def _is_struct(self, points, edges):\n        ########\u8ba1\u7b97\u81ea\u7531\u5ea6\u521d\u5224\u7ed3\u6784\u51e0\u4f55\u4e0d\u53d8\u6027##########\n        total_support = 0             #\u4fdd\u5b58\u652f\u5ea7\u7ea6\u675f\u6570\n        for p in points.values():\n            if self._dimension == 2:  #\u5e73\u9762\u6841\u67b6\n                total_support += (\n                    p.supportX\n                    + p.supportY\n                )\n            else:                     #\u7a7a\u95f4\u6841\u67b6\n                total_support += (\n                    p.supportX\n                    + p.supportY\n                    + p.supportZ\n                )\n\n        if len(points) * self._dimension - len(edges) - total_support > 0:\n            return (False)   #\u8ba1\u7b97\u81ea\u7531\u5ea6>0\uff0c\u7ed3\u6784\u4e0d\u7a33\u5b9a\u76f4\u63a5\u8fd4\u56deFalse\n        \n        #######\u4ee5\u4e0b\u57fa\u4e8e\u70b9\u548c\u8fb9\u96c6\u5efa\u7acb\u6709\u9650\u5143\u6a21\u5f62\u5206\u6790########\n        op.wipe()   # \u6e05\u9664\u6240\u6709\u5df2\u6709\u7ed3\u6784\n        op.model('basic', '-ndm', self._dimension, '-ndf', self._dimension)  #\u8bbe\u7f6e\u5efa\u6a21\u5668\n\n        for i, point in points.items():   #\u5efa\u7acb\u8282\u70b9\n            if self._dimension == 2:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                )\n            else:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                    point.vec.z,\n                )\n\n        for i, point in points.items():  #\u65bd\u52a0\u8282\u70b9\u652f\u5ea7\u7ea6\u675f\n            if point.isSupport:\n                if self._dimension == 2:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                    )\n                else:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                        point.supportZ,\n                    )\n\n        op.timeSeries(\"Linear\", 1)\n        op.pattern(\"Plain\", 1, 1)\n        \n        for i, point in points.items():  #\u6dfb\u52a0\u8282\u70b9\u8377\u8f7d\n            if point.isLoad:\n                if self._dimension == 2:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                    )\n                else:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                        point.loadZ,\n                    )\n\n        op.uniaxialMaterial(\"Elastic\", 1, self._E)   #\u5b9a\u4e49\u6750\u6599\n\n        for i, edge in enumerate(edges.values()):\n            op.element(\"Truss\", i, edge.u, edge.v, edge.area, 1)  #\u8d4b\u4e88\u6746\u4ef6\u622a\u9762\u5c5e\u6027\n        \n        \n        \n        if self._use_self_weight:  #\u5982\u679c\u8ba1\u7b97\u81ea\u91cd\u65f6\n            gravity = 9.8   #\u91cd\u529b\u52a0\u901f\u5ea6\n            load_gravity = [0 for _ in range(len(points))]  #\u521d\u59cb\u5316\u4e86\u4e00\u4e2aload_gravity\u5217\u8868\uff0c\u8868\u5f81\u6746\u4ef6\u81ea\u91cd\u7684\u7b49\u6548\u7ed3\u70b9\u529b\uff0clen(points)\u4e2a\u5143\u7d20\u5747\u4e3a0\n\n            for i, edge in edges.items():\n                edge_mass = edge.len * edge.area * self._pho       #\u6bcf\u6839\u6746\u4ef6\u8d28\u91cf\n                load_gravity[edge.u] += edge_mass * gravity * 0.5\n                load_gravity[edge.v] += edge_mass * gravity * 0.5  #\u6bcf\u6839\u6746\u4ef6\u7684\u91cd\u529b\u5411\u4e24\u7aef\u5206\u4e00\u534a\u5230\u8282\u70b9\u4e0a\n            \n            for i in range(len(points)):        #\u5c06\u91cd\u529b\u8377\u8f7d\u7b49\u6548\u65bd\u52a0\u4e8e\u8282\u70b9\u4e0a\n                if self._dimension == 2:        #\u5982\u679c\u662f\u5e73\u9762\u7ed3\u6784\n                    op.load(i, 0.0, -1 * load_gravity[i])\n                else:                           #\u5982\u679c\u662f\u7a7a\u95f4\u7ed3\u6784\n                    op.load(i, 0.0, 0.0, -1 * load_gravity[i])\t\n        \n        \n        op.system(\"BandSPD\")\n        op.numberer(\"RCM\")\n        op.constraints(\"Plain\")\n        op.integrator(\"LoadControl\", 1.0)\n        op.algorithm(\"Newton\")\n        op.analysis(\"Static\")\n        ok = op.analyze(1)  #\u8fd0\u884c\u5206\u6790\uff0cok\u8868\u5f81\u662f\u5426\u6210\u529f\u8fd0\u884c\uff0c\u8fd4\u56de0\u4ee3\u8868\u6210\u529f\uff0c\u8fd4\u56de<0\u5931\u8d25\u3002\uff08\u6ce8:\u8fd9\u91cc\u5bf9\u7ed3\u6784\u7684\u51e0\u4f55\u4e0d\u53d8\u6027\u8fdb\u884c\u4e86\u5145\u5206\u5224\u65ad\uff09\n        if ok < 0:\n            ok = False\n        else:\n            ok = True\n        return ok\n    \n    #\u8bc4\u4f30\u8282\u70b9\u4f4d\u79fb\n    def _get_dis_value(self, points):\n        displacement_weight = np.zeros((len(points), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u4f4d\u79fb\u6570\u636e\n        for i in range(len(points)):\n            if self._dimension == 2:\n                weight = max(   \n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                )                                  #\u53ea\u8003\u8651x,y,(z)\u65b9\u5411\u4e0a\u7684\u6700\u5927\u7684\u4e00\u4e2a\u7ebf\u4f4d\u79fb\n            else:\n                weight = max(\n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                    abs(op.nodeDisp(i, 3)),\n                )\n            print(\"\u7b2c{:}\u7ed3\u70b9\u4f4d\u79fb\u4e3a{:}mm\".format(i,weight*10**3))\n            displacement_weight[i] = max(weight / self._limit_dis - 1, 0)  #\u5224\u5b9a\u8282\u70b9\u4f4d\u79fb\u662f\u5426\u8d85\u9650\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\uff0c\u6700\u540e\u7d2f\u52a0\u6570\u7ec4\u4e2d\u7684\u6570\u503c\u4f5c\u4e3a\u4f4d\u79fb\u8bc4\u4f30\u53c2\u7167\n        return displacement_weight\n    \n    #\u8bc4\u4f30\u6746\u4ef6\u5e94\u529b\n    def _get_stress_value(self, edges):\n        stress_weight = np.zeros((len(edges), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u5e94\u529b\u6570\u636e\n\n        for tag, i in enumerate(edges.keys()):\n\n            edges[i].force = op.basicForce(tag)   #\u4ece\u6709\u9650\u5143\u5f97\u5230\u6746\u4ef6\u8f74\u529b\n            edges[i].stress = edges[i].force[0] / edges[i].area  #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            print(\"\u7b2c{:}\u6746\u4ef6\u5e94\u529b\u4e3a{:}MPa\".format(i,edges[i].stress*10**(-6)))\n            if edges[i].stress < 0:                                  #\u538b\u6746\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_C - 1.0,\n                    0.0\n                )\n            else:                                                    #\u62c9\u6746\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_T - 1.0,\n                    0.0\n                )\n        return stress_weight  #\u5224\u5b9a\u8282\u70b9\u5e94\u529b\u662f\u5426\u8d85\u9650\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\uff0c\u6700\u540e\u7d2f\u52a0\u6570\u7ec4\u4e2d\u7684\u6570\u503c\u4f5c\u4e3a\u5e94\u529b\u8bc4\u4f30\u53c2\u7167\n\n    #\u8bc4\u4f30\u6746\u4ef6\u5c48\u66f2\n    def _get_buckle_value(self, edges):\n        buckle_weight = np.zeros((len(edges), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u5c48\u66f2\u6570\u636e\n        miu_buckle = 1.0                           #\u6746\u4ef6\u8ba1\u7b97\u957f\u5ea6\u7cfb\u6570\uff0c\u6841\u67b6\u4e24\u7aef\u94f0\u63a5\u53d61\n        \n        for tag, i in enumerate(edges.keys()):\n            edges[i].force = op.basicForce(tag)    #\u5b58\u653e\u8f74\u529b\u6570\u636e\n            edges[i].stress = edges[i].force[0] / edges[i].area #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            \n            if edges[i].stress < 0:    #\u4ec5\u538b\u6746\u624d\u8003\u8651\u5c48\u66f2\n                #\u8ba1\u7b97\u6b27\u62c9\u4e34\u754c\u529b\n                force_cr = (\n                    math.pi ** 2 \n                    * self._E * edges[i].inertia\n                ) / (miu_buckle * edges[i].len) ** 2\n\n                #\u8ba1\u7b97\u6b27\u62c9\u4e34\u754c\u5e94\u529b\n                buckle_stress_max = force_cr / edges[i].area\n\n                buckle_weight[tag] = max(\n                    abs(edges[i].stress) / abs(buckle_stress_max) - 1.0,\n                    0.0\n                )#\u5224\u5b9a\u6746\u4ef6\u538b\u5e94\u529b\u662f\u5426\u8d85\u8fc7\u5c48\u66f2\u4e34\u754c\u5e94\u529b\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return buckle_weight\n    \n    #\u8bc4\u4f30\u6746\u4ef6\u957f\u7ec6\u6bd4\n    def _get_slenderness_ratio(self, edges):\n        lambda_weight = np.zeros((len(edges), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for tag, i in enumerate(edges.keys()):\n            edges[i].force = op.basicForce(tag)    #\u5b58\u653e\u8f74\u529b\u6570\u636e\n            edges[i].stress = edges[i].force[0] / edges[i].area #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            print(edges[i].len, edges[i].inertia, edges[i].area)\n            lambda_weight[tag] = max(\n                # self.len/(self.inertia/self.area)**0.5\n                abs(edges[i].len / (edges[i].inertia / edges[i].area) ** 0.5) / abs(self.slenderness_ratio_C if edges[i].stress < 0 else self.slenderness_ratio_T) - 1.0,\n                0.0\n            )#\u5224\u5b9a\u6746\u4ef6\u957f\u7ec6\u6bd4\u662f\u5426\u8d85\u8fc7\u9650\u5236\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return lambda_weight\n\n    #\u8bc4\u4f30\u6746\u4ef6\u8d85\u957f\n    def _get_length_longer(self, edges):\n        longer_weight = np.zeros((len(edges), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for tag, i in enumerate(edges.keys()):   \n            longer_weight[tag] = max(\n                abs(edges[i].len) / abs(self.max_len) - 1.0,\n                0.0\n            )#\u5224\u5b9a\u6746\u4ef6\u957f\u5ea6\u662f\u5426\u8d85\u8fc7\u9650\u5236\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return longer_weight\n\n    #\u8bc4\u4f30\u6746\u4ef6\u8d85\u957f\n    def _get_length_shorter(self, edges):\n        shorter_weight = np.zeros((len(edges), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for tag, i in enumerate(edges.keys()):   \n            if edges[i].len<self.min_len:\n                shorter_weight[tag] = 1.0-edges[i].len / self.min_len\n                #\u5224\u5b9a\u6746\u4ef6\u957f\u5ea6\u662f\u5426\u8fc7\u77ed\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return shorter_weight\n\n    #\u8c03\u7528\u4ee5\u4e0a\u51fd\u6570\u8fd0\u884c\u7ed3\u6784\u5206\u6790\n    def run(self, points, edges):\n        \n        is_struct = self._is_struct(points, edges) #\u8fd0\u884c\u7ed3\u6784\u5efa\u6a21\u4e0e\u5206\u6790\uff0cis_struct\u8fd4\u56de\u7ed3\u6784\u662f\u5426\u6b63\u5e38\u5b8c\u6210\u5206\u6790\n        mass, dis_value, stress_value, buckle_value, slenderness_vlaue, longer_value, shorter_value= 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0\n\n        if is_struct: #\u5982\u679c\u7ed3\u6784\u6210\u529f\u5b8c\u6210\u5206\u6790\uff0c\u5373\u7ed3\u6784\u662f\u51e0\u4f55\u4e0d\u53d8\u7684\n            for i, edge in edges.items():\n                mass += edge.len * edge.area * self._pho      #\u8ba1\u7b97\u7ed3\u6784\u603b\u8d28\u91cf\n            \n            if self._use_dis_constraint:\n                dis_value = self._get_dis_value(points)       #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u4f4d\u79fb\u8bc4\u4f30\u7ed3\u679c\n            if self._use_stress_constraint:\n                stress_value = self._get_stress_value(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u5e94\u529b\u8bc4\u4f30\u7ed3\u679c\n            if self._use_buckle_constraint:\n                buckle_value = self._get_buckle_value(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u5c48\u66f2\u8bc4\u4f30\u7ed3\u679c\n            if self._use_slenderness_constraint:\n                slenderness_vlaue = self._get_slenderness_ratio(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c    \n            if self._use_longer_constraint:\n                longer_value = self._get_length_longer(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c\n            if self._use_shorter_constraint:\n                shorter_value = self._get_length_shorter(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c \n\n        return (\n            is_struct, mass, dis_value, stress_value, buckle_value, slenderness_vlaue, longer_value, shorter_value\n        )\n\n    #\u7ed8\u5236\u5e73\u9762\u6841\u67b6\n    def render(self, points, edges):\n        _ax = plt.axes(projection='3d')\n        for point in points.values():   #\u7ed8\u5236\u8282\u70b9\uff0cscatter()\u7ed8\u5236\u6563\u70b9\n            if point.isSupport:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='g') #\u652f\u5ea7\u70b9\u4e3a\u7eff\u8272\n            elif point.isLoad:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='r') #\u8377\u8f7d\u4f5c\u7528\u7684\u8282\u70b9\u4e3a\u7ea2\u8272\n            else:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='b') #\u5176\u4f59\u8282\u70b9\u84dd\u8272\n\n        for edge in edges.values():    #\u7ed8\u5236\u6746\u4ef6\n            x0 = [points[edge.u].vec.x, points[edge.v].vec.x]   #\u6746\u4ef6\u8d77\u70b9\n            y0 = [points[edge.u].vec.y, points[edge.v].vec.y]   #\u6746\u4ef6\u7ec8\u70b9\n            z0 = [points[edge.u].vec.z, points[edge.v].vec.z]   #\u6746\u4ef6\u8d77\u70b9\n            \n            if edge.stress < -1e-7:\n                _ax.plot(x0, y0, z0, color='g', linewidth=(edge.area / math.pi)**0.5*500)    #\u538b\u6746\u7eff\u8272\n            elif edge.stress > 1e-7:\n                _ax.plot(x0, y0, z0, color='r', linewidth=(edge.area / math.pi)**0.5*500)    #\u62c9\u6746\u7ea2\u8272\n            else:\n                _ax.plot(x0, y0, z0, color='k', linewidth=(edge.area / math.pi)**0.5*500)    #\u96f6\u6746\u9ed1\u8272\n        plt.show() #\u663e\u793a\u56fe\u50cf", "\nclass DynamicModel:\n    #\u6784\u9020\u51fd\u6570\n    def __init__(self,\n                dimension,\n                E=193*10**9,          #N/m2\n                pho=8.0*10**3,        #kg/m3\n                sigma_T=123*10**6,    #N/m2\n                sigma_C=213*10**6,    #N/m2\n                dislimit=0.002,       #m\n                slenderness_ratio_T=220,\n                slenderness_ratio_C=180,\n                max_len=5,            #m\n                min_len=0.03,         #m\n                use_self_weight=True,\n                use_dis_constraint=True,\n                use_stress_constraint=True,\n                use_buckle_constraint=True,\n                use_slenderness_constraint=True,\n                use_longer_constraint=True,\n                use_shorter_constraint=True\n                ): \n        self._dimension = dimension    #\u7ed3\u6784\u7ef4\u5ea6\n        self._E = E                    #\u5f39\u6027\u6a21\u91cf\n        self._pho = pho                #\u6750\u6599\u5bc6\u5ea6\n        self._sigma_T = sigma_T        #\u5bb9\u8bb8\u62c9\u5e94\u529b\n        self._sigma_C = sigma_C        #\u5bb9\u8bb8\u538b\u5e94\u529b\n        self._limit_dis = dislimit     #\u5bb9\u8bb8\u4f4d\u79fb\n        self.slenderness_ratio_T=slenderness_ratio_T #\u5bb9\u8bb8\u53d7\u62c9\u957f\u7ec6\u6bd4\n        self.slenderness_ratio_C=slenderness_ratio_C #\u5bb9\u8bb8\u53d7\u538b\u957f\u7ec6\u6bd4\n        self.max_len=max_len                         #\u6700\u5927\u957f\u5ea6\n        self.min_len=min_len                         #\u6700\u5c0f\u957f\u5ea6\n        self._use_self_weight = use_self_weight              #\u662f\u5426\u8ba1\u7b97\u81ea\u91cd\n        self._use_dis_constraint = use_dis_constraint        #\u662f\u5426\u542f\u7528\u4f4d\u79fb\u7ea6\u675f\n        self._use_stress_constraint = use_stress_constraint         #\u662f\u5426\u542f\u7528\u5e94\u529b\u7ea6\u675f\n        self._use_buckle_constraint = use_buckle_constraint         #\u662f\u5426\u542f\u7528\u5c48\u66f2\u7ea6\u675f\n        self._use_slenderness_constraint=use_slenderness_constraint #\u662f\u5426\u542f\u7528\u957f\u7ec6\u6bd4\u7ea6\u675f\n        self._use_longer_constraint=use_longer_constraint           #\u662f\u5426\u542f\u7528\u8d85\u957f\u7ea6\u675f\n        self._use_shorter_constraint=use_shorter_constraint         #\u662f\u5426\u542f\u7528\u8fc7\u77ed\u7ea6\u675f\n\n    #\u5224\u5b9a\u7ed3\u6784\u7684\u51e0\u4f55\u4e0d\u53d8\u6027+\u5206\u6790\u8ba1\u7b97\n    def _is_struct(self, points, edges):\n        ########\u8ba1\u7b97\u81ea\u7531\u5ea6\u521d\u5224\u7ed3\u6784\u51e0\u4f55\u4e0d\u53d8\u6027##########\n        total_support = 0             #\u4fdd\u5b58\u652f\u5ea7\u7ea6\u675f\u6570\n        for p in points.values():\n            if self._dimension == 2:  #\u5e73\u9762\u6841\u67b6\n                total_support += (\n                    p.supportX\n                    + p.supportY\n                )\n            else:                     #\u7a7a\u95f4\u6841\u67b6\n                total_support += (\n                    p.supportX\n                    + p.supportY\n                    + p.supportZ\n                )\n\n        if len(points) * self._dimension - len(edges) - total_support > 0:\n            return (False)   #\u8ba1\u7b97\u81ea\u7531\u5ea6>0\uff0c\u7ed3\u6784\u4e0d\u7a33\u5b9a\u76f4\u63a5\u8fd4\u56deFalse\n        \n        #######\u4ee5\u4e0b\u57fa\u4e8e\u70b9\u548c\u8fb9\u96c6\u5efa\u7acb\u6709\u9650\u5143\u6a21\u5f62\u5206\u6790########\n        op.wipe()   # \u6e05\u9664\u6240\u6709\u5df2\u6709\u7ed3\u6784\n        op.model('basic', '-ndm', self._dimension, '-ndf', self._dimension)  #\u8bbe\u7f6e\u5efa\u6a21\u5668\n\n        for i, point in points.items():   #\u5efa\u7acb\u8282\u70b9\n            if self._dimension == 2:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                )\n            else:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                    point.vec.z,\n                )\n\n        for i, point in points.items():  #\u65bd\u52a0\u8282\u70b9\u652f\u5ea7\u7ea6\u675f\n            if point.isSupport:\n                if self._dimension == 2:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                    )\n                else:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                        point.supportZ,\n                    )\n\n        op.timeSeries(\"Linear\", 1)\n        op.pattern(\"Plain\", 1, 1)\n        \n        for i, point in points.items():  #\u6dfb\u52a0\u8282\u70b9\u8377\u8f7d\n            if point.isLoad:\n                if self._dimension == 2:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                    )\n                else:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                        point.loadZ,\n                    )\n\n        op.uniaxialMaterial(\"Elastic\", 1, self._E)   #\u5b9a\u4e49\u6750\u6599\n\n        for i, edge in enumerate(edges.values()):\n            op.element(\"Truss\", i, edge.u, edge.v, edge.area, 1)  #\u8d4b\u4e88\u6746\u4ef6\u622a\u9762\u5c5e\u6027\n        \n        \n        \n        if self._use_self_weight:  #\u5982\u679c\u8ba1\u7b97\u81ea\u91cd\u65f6\n            gravity = 9.8   #\u91cd\u529b\u52a0\u901f\u5ea6\n            load_gravity = [0 for _ in range(len(points))]  #\u521d\u59cb\u5316\u4e86\u4e00\u4e2aload_gravity\u5217\u8868\uff0c\u8868\u5f81\u6746\u4ef6\u81ea\u91cd\u7684\u7b49\u6548\u7ed3\u70b9\u529b\uff0clen(points)\u4e2a\u5143\u7d20\u5747\u4e3a0\n\n            for i, edge in edges.items():\n                edge_mass = edge.len * edge.area * self._pho       #\u6bcf\u6839\u6746\u4ef6\u8d28\u91cf\n                load_gravity[edge.u] += edge_mass * gravity * 0.5\n                load_gravity[edge.v] += edge_mass * gravity * 0.5  #\u6bcf\u6839\u6746\u4ef6\u7684\u91cd\u529b\u5411\u4e24\u7aef\u5206\u4e00\u534a\u5230\u8282\u70b9\u4e0a\n            \n            for i in range(len(points)):        #\u5c06\u91cd\u529b\u8377\u8f7d\u7b49\u6548\u65bd\u52a0\u4e8e\u8282\u70b9\u4e0a\n                if self._dimension == 2:        #\u5982\u679c\u662f\u5e73\u9762\u7ed3\u6784\n                    op.load(i, 0.0, -1 * load_gravity[i])\n                else:                           #\u5982\u679c\u662f\u7a7a\u95f4\u7ed3\u6784\n                    op.load(i, 0.0, 0.0, -1 * load_gravity[i])\t\n        \n        \n        op.system(\"BandSPD\")\n        op.numberer(\"RCM\")\n        op.constraints(\"Plain\")\n        op.integrator(\"LoadControl\", 1.0)\n        op.algorithm(\"Newton\")\n        op.analysis(\"Static\")\n        ok = op.analyze(1)  #\u8fd0\u884c\u5206\u6790\uff0cok\u8868\u5f81\u662f\u5426\u6210\u529f\u8fd0\u884c\uff0c\u8fd4\u56de0\u4ee3\u8868\u6210\u529f\uff0c\u8fd4\u56de<0\u5931\u8d25\u3002\uff08\u6ce8:\u8fd9\u91cc\u5bf9\u7ed3\u6784\u7684\u51e0\u4f55\u4e0d\u53d8\u6027\u8fdb\u884c\u4e86\u5145\u5206\u5224\u65ad\uff09\n        if ok < 0:\n            ok = False\n        else:\n            ok = True\n        return ok\n    \n    #\u8bc4\u4f30\u8282\u70b9\u4f4d\u79fb\n    def _get_dis_value(self, points):\n        displacement_weight = np.zeros((len(points), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u4f4d\u79fb\u6570\u636e\n        for i in range(len(points)):\n            if self._dimension == 2:\n                weight = max(   \n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                )                                  #\u53ea\u8003\u8651x,y,(z)\u65b9\u5411\u4e0a\u7684\u6700\u5927\u7684\u4e00\u4e2a\u7ebf\u4f4d\u79fb\n            else:\n                weight = max(\n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                    abs(op.nodeDisp(i, 3)),\n                )\n            print(\"\u7b2c{:}\u7ed3\u70b9\u4f4d\u79fb\u4e3a{:}mm\".format(i,weight*10**3))\n            displacement_weight[i] = max(weight / self._limit_dis - 1, 0)  #\u5224\u5b9a\u8282\u70b9\u4f4d\u79fb\u662f\u5426\u8d85\u9650\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\uff0c\u6700\u540e\u7d2f\u52a0\u6570\u7ec4\u4e2d\u7684\u6570\u503c\u4f5c\u4e3a\u4f4d\u79fb\u8bc4\u4f30\u53c2\u7167\n        return displacement_weight\n    \n    #\u8bc4\u4f30\u6746\u4ef6\u5e94\u529b\n    def _get_stress_value(self, edges):\n        stress_weight = np.zeros((len(edges), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u5e94\u529b\u6570\u636e\n\n        for tag, i in enumerate(edges.keys()):\n\n            edges[i].force = op.basicForce(tag)   #\u4ece\u6709\u9650\u5143\u5f97\u5230\u6746\u4ef6\u8f74\u529b\n            edges[i].stress = edges[i].force[0] / edges[i].area  #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            print(\"\u7b2c{:}\u6746\u4ef6\u5e94\u529b\u4e3a{:}MPa\".format(i,edges[i].stress*10**(-6)))\n            if edges[i].stress < 0:                                  #\u538b\u6746\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_C - 1.0,\n                    0.0\n                )\n            else:                                                    #\u62c9\u6746\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_T - 1.0,\n                    0.0\n                )\n        return stress_weight  #\u5224\u5b9a\u8282\u70b9\u5e94\u529b\u662f\u5426\u8d85\u9650\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\uff0c\u6700\u540e\u7d2f\u52a0\u6570\u7ec4\u4e2d\u7684\u6570\u503c\u4f5c\u4e3a\u5e94\u529b\u8bc4\u4f30\u53c2\u7167\n\n    #\u8bc4\u4f30\u6746\u4ef6\u5c48\u66f2\n    def _get_buckle_value(self, edges):\n        buckle_weight = np.zeros((len(edges), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u5c48\u66f2\u6570\u636e\n        miu_buckle = 1.0                           #\u6746\u4ef6\u8ba1\u7b97\u957f\u5ea6\u7cfb\u6570\uff0c\u6841\u67b6\u4e24\u7aef\u94f0\u63a5\u53d61\n        \n        for tag, i in enumerate(edges.keys()):\n            edges[i].force = op.basicForce(tag)    #\u5b58\u653e\u8f74\u529b\u6570\u636e\n            edges[i].stress = edges[i].force[0] / edges[i].area #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            \n            if edges[i].stress < 0:    #\u4ec5\u538b\u6746\u624d\u8003\u8651\u5c48\u66f2\n                #\u8ba1\u7b97\u6b27\u62c9\u4e34\u754c\u529b\n                force_cr = (\n                    math.pi ** 2 \n                    * self._E * edges[i].inertia\n                ) / (miu_buckle * edges[i].len) ** 2\n\n                #\u8ba1\u7b97\u6b27\u62c9\u4e34\u754c\u5e94\u529b\n                buckle_stress_max = force_cr / edges[i].area\n\n                buckle_weight[tag] = max(\n                    abs(edges[i].stress) / abs(buckle_stress_max) - 1.0,\n                    0.0\n                )#\u5224\u5b9a\u6746\u4ef6\u538b\u5e94\u529b\u662f\u5426\u8d85\u8fc7\u5c48\u66f2\u4e34\u754c\u5e94\u529b\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return buckle_weight\n    \n    #\u8bc4\u4f30\u6746\u4ef6\u957f\u7ec6\u6bd4\n    def _get_slenderness_ratio(self, edges):\n        lambda_weight = np.zeros((len(edges), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for tag, i in enumerate(edges.keys()):\n            edges[i].force = op.basicForce(tag)    #\u5b58\u653e\u8f74\u529b\u6570\u636e\n            edges[i].stress = edges[i].force[0] / edges[i].area #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            print(edges[i].len, edges[i].inertia, edges[i].area)\n            lambda_weight[tag] = max(\n                # self.len/(self.inertia/self.area)**0.5\n                abs(edges[i].len / (edges[i].inertia / edges[i].area) ** 0.5) / abs(self.slenderness_ratio_C if edges[i].stress < 0 else self.slenderness_ratio_T) - 1.0,\n                0.0\n            )#\u5224\u5b9a\u6746\u4ef6\u957f\u7ec6\u6bd4\u662f\u5426\u8d85\u8fc7\u9650\u5236\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return lambda_weight\n\n    #\u8bc4\u4f30\u6746\u4ef6\u8d85\u957f\n    def _get_length_longer(self, edges):\n        longer_weight = np.zeros((len(edges), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for tag, i in enumerate(edges.keys()):   \n            longer_weight[tag] = max(\n                abs(edges[i].len) / abs(self.max_len) - 1.0,\n                0.0\n            )#\u5224\u5b9a\u6746\u4ef6\u957f\u5ea6\u662f\u5426\u8d85\u8fc7\u9650\u5236\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return longer_weight\n\n    #\u8bc4\u4f30\u6746\u4ef6\u8d85\u957f\n    def _get_length_shorter(self, edges):\n        shorter_weight = np.zeros((len(edges), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for tag, i in enumerate(edges.keys()):   \n            if edges[i].len<self.min_len:\n                shorter_weight[tag] = 1.0-edges[i].len / self.min_len\n                #\u5224\u5b9a\u6746\u4ef6\u957f\u5ea6\u662f\u5426\u8fc7\u77ed\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return shorter_weight\n\n    #\u8c03\u7528\u4ee5\u4e0a\u51fd\u6570\u8fd0\u884c\u7ed3\u6784\u5206\u6790\n    def run(self, points, edges):\n        \n        is_struct = self._is_struct(points, edges) #\u8fd0\u884c\u7ed3\u6784\u5efa\u6a21\u4e0e\u5206\u6790\uff0cis_struct\u8fd4\u56de\u7ed3\u6784\u662f\u5426\u6b63\u5e38\u5b8c\u6210\u5206\u6790\n        mass, dis_value, stress_value, buckle_value, slenderness_vlaue, longer_value, shorter_value= 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0\n\n        if is_struct: #\u5982\u679c\u7ed3\u6784\u6210\u529f\u5b8c\u6210\u5206\u6790\uff0c\u5373\u7ed3\u6784\u662f\u51e0\u4f55\u4e0d\u53d8\u7684\n            for i, edge in edges.items():\n                mass += edge.len * edge.area * self._pho      #\u8ba1\u7b97\u7ed3\u6784\u603b\u8d28\u91cf\n            \n            if self._use_dis_constraint:\n                dis_value = self._get_dis_value(points)       #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u4f4d\u79fb\u8bc4\u4f30\u7ed3\u679c\n            if self._use_stress_constraint:\n                stress_value = self._get_stress_value(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u5e94\u529b\u8bc4\u4f30\u7ed3\u679c\n            if self._use_buckle_constraint:\n                buckle_value = self._get_buckle_value(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u5c48\u66f2\u8bc4\u4f30\u7ed3\u679c\n            if self._use_slenderness_constraint:\n                slenderness_vlaue = self._get_slenderness_ratio(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c    \n            if self._use_longer_constraint:\n                longer_value = self._get_length_longer(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c\n            if self._use_shorter_constraint:\n                shorter_value = self._get_length_shorter(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c \n\n        return (\n            is_struct, mass, dis_value, stress_value, buckle_value, slenderness_vlaue, longer_value, shorter_value\n        )\n\n    #\u7ed8\u5236\u5e73\u9762\u6841\u67b6\n    def render(self, points, edges):\n        _ax = plt.axes(projection='3d')\n        for point in points.values():   #\u7ed8\u5236\u8282\u70b9\uff0cscatter()\u7ed8\u5236\u6563\u70b9\n            if point.isSupport:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='g') #\u652f\u5ea7\u70b9\u4e3a\u7eff\u8272\n            elif point.isLoad:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='r') #\u8377\u8f7d\u4f5c\u7528\u7684\u8282\u70b9\u4e3a\u7ea2\u8272\n            else:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='b') #\u5176\u4f59\u8282\u70b9\u84dd\u8272\n\n        for edge in edges.values():    #\u7ed8\u5236\u6746\u4ef6\n            x0 = [points[edge.u].vec.x, points[edge.v].vec.x]   #\u6746\u4ef6\u8d77\u70b9\n            y0 = [points[edge.u].vec.y, points[edge.v].vec.y]   #\u6746\u4ef6\u7ec8\u70b9\n            z0 = [points[edge.u].vec.z, points[edge.v].vec.z]   #\u6746\u4ef6\u8d77\u70b9\n            \n            if edge.stress < -1e-7:\n                _ax.plot(x0, y0, z0, color='g', linewidth=(edge.area / math.pi)**0.5*500)    #\u538b\u6746\u7eff\u8272\n            elif edge.stress > 1e-7:\n                _ax.plot(x0, y0, z0, color='r', linewidth=(edge.area / math.pi)**0.5*500)    #\u62c9\u6746\u7ea2\u8272\n            else:\n                _ax.plot(x0, y0, z0, color='k', linewidth=(edge.area / math.pi)**0.5*500)    #\u96f6\u6746\u9ed1\u8272\n        plt.show() #\u663e\u793a\u56fe\u50cf", "\n\nif __name__=='__main__':\n    truss=DynamicModel(3)    #\u521b\u5efa\u7ed3\u6784\u5bf9\u8c61\n    point_list, edge_list = readFile(\"input_file_3d.txt\") #\u8bfb\u53d6\u6570\u636e\u8f93\u5165\u6587\u4ef6\u4e2d\u7684\u9884\u8bbe\u70b9\u548c\u8fb9\n\n    #\u5c06point_list, edge_list\u8f6c\u6362\u6210truss.run\u7684\u6570\u636e\u7ed3\u6784\n    points = {}\n    edges = {}\n    for i, point in enumerate(point_list):  #\u5c06\u9884\u8bbe\u70b9\u5bf9\u8c61\u52a0\u5165\u70b9\u96c6\n        points[i] = point\n\n    for i, edge in enumerate(edge_list):    #\u5c06\u9884\u8bbe\u8fb9\u5bf9\u8c61\u52a0\u5165\u8fb9\u96c6\n        if edge.u > edge.v:                 #\u8fb9\u7aef\u70b9\u91cd\u65b0\u7f16\u53f7\n            tmp = edge.u\n            edge.u = edge.v\n            edge.v = tmp\n        edges[(edge.u, edge.v)] = edge        \n\n    #\u8fd0\u884c\u6a21\u578b\u5206\u6790                                 \n    is_struct, mass, dis_value, stress_value, buckle_value, slenderness_vlaue, longer_value, shorter_value  = truss.run(points, edges) \n    \n    #\u540e\u5904\u7406\uff0c\u8f93\u51fa\u7ed3\u6784\u8bbe\u8ba1\u7ed3\u679c\u7684\u63d0\u793a\u4fe1\u606f\n    print(np.sum(dis_value), np.sum(stress_value), np.sum(buckle_value), np.sum(slenderness_vlaue), np.sum(longer_value), np.sum(shorter_value))\n    if not is_struct:\n        print(\"\u7ed3\u6784\u51e0\u4f55\u4e0d\u7a33\u5b9a\")\n    elif np.sum(dis_value) > 0.0 or np.sum(stress_value) > 0.0 or np.sum(buckle_value) > 0.0 or np.sum(slenderness_vlaue) or np.sum(longer_value) or np.sum(shorter_value):\n        for i in range(len(dis_value)):\n            if dis_value[i]>0.0:\n                print(\"\u7b2c{:}\u7ed3\u70b9\u4f4d\u79fb\u8d85\u51fa\u9650\u503c{:}%\".format(i,dis_value[i]*100))\n\n        for i in range(len(stress_value)):\n            if stress_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u5e94\u529b\u8d85\u51fa\u9650\u503c{:}%\".format(i,stress_value[i]*100))\n\n        for i in range(len(buckle_value)):\n            if buckle_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u5c48\u66f2\u5e94\u529b\u8d85\u51fa\u9650\u503c{:}%\".format(i,buckle_value[i]*100))\n\n        for i in range(len(slenderness_vlaue)):\n            if slenderness_vlaue[i][0]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u957f\u7ec6\u6bd4\u8d85\u51fa\u9650\u503c{:}%\".format(i,slenderness_vlaue[i]*100))\n\n        for i in range(len(longer_value)):\n            if longer_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u957f\u5ea6\u8d85\u51fa\u9650\u503c{:}%\".format(i,longer_value[i]*100))\n\n        for i in range(len(shorter_value)):\n            if shorter_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u957f\u5ea6\u77ed\u8fc7\u9650\u503c{:}%\".format(i,shorter_value[i]*100))                 \n\n    else:\n        print(\"\u7ed3\u6784\u51e0\u4f55\u7a33\u5b9a\uff0c\u4e14\u6240\u6709\u7ea6\u675f\u6ee1\u8db3\u3002\u5f53\u524d\u7ed3\u6784\u603b\u8d28\u91cf\u4e3a\uff1a{:.3f}kg\".format(mass))\n\n    truss.render(points, edges) #\u663e\u793a\u6841\u67b6\u56fe\u50cf", "\n\n   \n"]}
{"filename": "apps/checker/\u7ed3\u6784\u9a8c\u7b97/dynamic.py", "chunked_list": ["import numpy as np\nimport math\nimport openseespy.opensees as op\nimport matplotlib.pyplot as plt\nfrom utils import *\n\nclass DynamicModel:\n    #\u6784\u9020\u51fd\u6570\n    def __init__(self,\n                dimension,\n                E=193*10**9,          #N/m2\n                pho=8.0*10**3,        #kg/m3\n                sigma_T=123*10**6,    #N/m2\n                sigma_C=213*10**6,    #N/m2\n                dislimit=0.002,       #m\n                slenderness_ratio_T=220,\n                slenderness_ratio_C=180,\n                max_len=5.0,            #m\n                min_len=0.03,         #m\n                use_self_weight=True,\n                use_dis_constraint=True,\n                use_stress_constraint=True,\n                use_buckle_constraint=True,\n                use_slenderness_constraint=True,\n                use_longer_constraint=True,\n                use_shorter_constraint=True\n                ): \n        self._dimension = dimension    #\u7ed3\u6784\u7ef4\u5ea6\n        self._E = E                    #\u5f39\u6027\u6a21\u91cf\n        self._pho = pho                #\u6750\u6599\u5bc6\u5ea6\n        self._sigma_T = sigma_T        #\u5bb9\u8bb8\u62c9\u5e94\u529b\n        self._sigma_C = sigma_C        #\u5bb9\u8bb8\u538b\u5e94\u529b\n        self._limit_dis = dislimit     #\u5bb9\u8bb8\u4f4d\u79fb\n        self.slenderness_ratio_T=slenderness_ratio_T #\u5bb9\u8bb8\u53d7\u62c9\u957f\u7ec6\u6bd4\n        self.slenderness_ratio_C=slenderness_ratio_C #\u5bb9\u8bb8\u53d7\u538b\u957f\u7ec6\u6bd4\n        self.max_len=max_len                         #\u6700\u5927\u957f\u5ea6\n        self.min_len=min_len                         #\u6700\u5c0f\u957f\u5ea6\n        self._use_self_weight = use_self_weight              #\u662f\u5426\u8ba1\u7b97\u81ea\u91cd\n        self._use_dis_constraint = use_dis_constraint        #\u662f\u5426\u542f\u7528\u4f4d\u79fb\u7ea6\u675f\n        self._use_stress_constraint = use_stress_constraint         #\u662f\u5426\u542f\u7528\u5e94\u529b\u7ea6\u675f\n        self._use_buckle_constraint = use_buckle_constraint         #\u662f\u5426\u542f\u7528\u5c48\u66f2\u7ea6\u675f\n        self._use_slenderness_constraint=use_slenderness_constraint #\u662f\u5426\u542f\u7528\u957f\u7ec6\u6bd4\u7ea6\u675f\n        self._use_longer_constraint=use_longer_constraint           #\u662f\u5426\u542f\u7528\u8d85\u957f\u7ea6\u675f\n        self._use_shorter_constraint=use_shorter_constraint         #\u662f\u5426\u542f\u7528\u8fc7\u77ed\u7ea6\u675f\n\n    #\u5224\u5b9a\u7ed3\u6784\u7684\u51e0\u4f55\u4e0d\u53d8\u6027+\u5206\u6790\u8ba1\u7b97\n    def _is_struct(self, points, edges):\n        ########\u8ba1\u7b97\u81ea\u7531\u5ea6\u521d\u5224\u7ed3\u6784\u51e0\u4f55\u4e0d\u53d8\u6027##########\n        total_support = 0             #\u4fdd\u5b58\u652f\u5ea7\u7ea6\u675f\u6570\n        for p in points.values():\n            if self._dimension == 2:  #\u5e73\u9762\u6841\u67b6\n                total_support += (\n                    p.supportX\n                    + p.supportY\n                )\n            else:                     #\u7a7a\u95f4\u6841\u67b6\n                total_support += (\n                    p.supportX\n                    + p.supportY\n                    + p.supportZ\n                )\n\n        if len(points) * self._dimension - len(edges) - total_support > 0:\n            return (False)   #\u8ba1\u7b97\u81ea\u7531\u5ea6>0\uff0c\u7ed3\u6784\u4e0d\u7a33\u5b9a\u76f4\u63a5\u8fd4\u56deFalse\n        \n        #######\u4ee5\u4e0b\u57fa\u4e8e\u70b9\u548c\u8fb9\u96c6\u5efa\u7acb\u6709\u9650\u5143\u6a21\u5f62\u5206\u6790########\n        op.wipe()   # \u6e05\u9664\u6240\u6709\u5df2\u6709\u7ed3\u6784\n        op.model('basic', '-ndm', self._dimension, '-ndf', self._dimension)  #\u8bbe\u7f6e\u5efa\u6a21\u5668\n\n        for i, point in points.items():   #\u5efa\u7acb\u8282\u70b9\n            if self._dimension == 2:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                )\n            else:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                    point.vec.z,\n                )\n\n        for i, point in points.items():  #\u65bd\u52a0\u8282\u70b9\u652f\u5ea7\u7ea6\u675f\n            if point.isSupport:\n                if self._dimension == 2:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                    )\n                else:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                        point.supportZ,\n                    )\n\n        op.timeSeries(\"Linear\", 1)\n        op.pattern(\"Plain\", 1, 1)\n        \n        for i, point in points.items():  #\u6dfb\u52a0\u8282\u70b9\u8377\u8f7d\n            if point.isLoad:\n                if self._dimension == 2:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                    )\n                else:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                        point.loadZ,\n                    )\n\n        op.uniaxialMaterial(\"Elastic\", 1, self._E)   #\u5b9a\u4e49\u6750\u6599\n\n        for i, edge in enumerate(edges.values()):\n            op.element(\"Truss\", i, edge.u, edge.v, edge.area, 1)  #\u8d4b\u4e88\u6746\u4ef6\u622a\u9762\u5c5e\u6027\n        \n        \n        \n        if self._use_self_weight:  #\u5982\u679c\u8ba1\u7b97\u81ea\u91cd\u65f6\n            gravity = 9.8   #\u91cd\u529b\u52a0\u901f\u5ea6\n            load_gravity = [0 for _ in range(len(points))]  #\u521d\u59cb\u5316\u4e86\u4e00\u4e2aload_gravity\u5217\u8868\uff0c\u8868\u5f81\u6746\u4ef6\u81ea\u91cd\u7684\u7b49\u6548\u7ed3\u70b9\u529b\uff0clen(points)\u4e2a\u5143\u7d20\u5747\u4e3a0\n\n            for i, edge in edges.items():\n                edge_mass = edge.len * edge.area * self._pho       #\u6bcf\u6839\u6746\u4ef6\u8d28\u91cf\n                load_gravity[edge.u] += edge_mass * gravity * 0.5\n                load_gravity[edge.v] += edge_mass * gravity * 0.5  #\u6bcf\u6839\u6746\u4ef6\u7684\u91cd\u529b\u5411\u4e24\u7aef\u5206\u4e00\u534a\u5230\u8282\u70b9\u4e0a\n            \n            for i in range(len(points)):        #\u5c06\u91cd\u529b\u8377\u8f7d\u7b49\u6548\u65bd\u52a0\u4e8e\u8282\u70b9\u4e0a\n                if self._dimension == 2:        #\u5982\u679c\u662f\u5e73\u9762\u7ed3\u6784\n                    op.load(i, 0.0, -1 * load_gravity[i])\n                else:                           #\u5982\u679c\u662f\u7a7a\u95f4\u7ed3\u6784\n                    op.load(i, 0.0, 0.0, -1 * load_gravity[i])\t\n        \n        \n        op.system(\"BandSPD\")\n        op.numberer(\"RCM\")\n        op.constraints(\"Plain\")\n        op.integrator(\"LoadControl\", 1.0)\n        op.algorithm(\"Newton\")\n        op.analysis(\"Static\")\n        ok = op.analyze(1)  #\u8fd0\u884c\u5206\u6790\uff0cok\u8868\u5f81\u662f\u5426\u6210\u529f\u8fd0\u884c\uff0c\u8fd4\u56de0\u4ee3\u8868\u6210\u529f\uff0c\u8fd4\u56de<0\u5931\u8d25\u3002\uff08\u6ce8:\u8fd9\u91cc\u5bf9\u7ed3\u6784\u7684\u51e0\u4f55\u4e0d\u53d8\u6027\u8fdb\u884c\u4e86\u5145\u5206\u5224\u65ad\uff09\n        if ok < 0:\n            ok = False\n        else:\n            ok = True\n        return ok\n    \n    #\u8bc4\u4f30\u8282\u70b9\u4f4d\u79fb\n    def _get_dis_value(self, points):\n        displacement_weight = np.zeros((len(points), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u4f4d\u79fb\u6570\u636e\n        for i in range(len(points)):\n            if self._dimension == 2:\n                weight = max(   \n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                )                                  #\u53ea\u8003\u8651x,y,(z)\u65b9\u5411\u4e0a\u7684\u6700\u5927\u7684\u4e00\u4e2a\u7ebf\u4f4d\u79fb\n            else:\n                weight = max(\n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                    abs(op.nodeDisp(i, 3)),\n                )\n            print(\"\u7b2c{:}\u7ed3\u70b9\u4f4d\u79fb\u4e3a{:}mm\".format(i,weight*10**3))\n            displacement_weight[i] = max(weight / self._limit_dis - 1, 0)  #\u5224\u5b9a\u8282\u70b9\u4f4d\u79fb\u662f\u5426\u8d85\u9650\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\uff0c\u6700\u540e\u7d2f\u52a0\u6570\u7ec4\u4e2d\u7684\u6570\u503c\u4f5c\u4e3a\u4f4d\u79fb\u8bc4\u4f30\u53c2\u7167\n        return displacement_weight\n    \n    #\u8bc4\u4f30\u6746\u4ef6\u5e94\u529b\n    def _get_stress_value(self, edges):\n        stress_weight = np.zeros((len(edges), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u5e94\u529b\u6570\u636e\n\n        for tag, i in enumerate(edges.keys()):\n\n            edges[i].force = op.basicForce(tag)   #\u4ece\u6709\u9650\u5143\u5f97\u5230\u6746\u4ef6\u8f74\u529b\n            edges[i].stress = edges[i].force[0] / edges[i].area  #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            print(\"\u7b2c{:}\u6746\u4ef6\u5e94\u529b\u4e3a{:}MPa\".format(i,edges[i].stress*10**(-6)))\n            if edges[i].stress < 0:                                  #\u538b\u6746\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_C - 1.0,\n                    0.0\n                )\n            else:                                                    #\u62c9\u6746\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_T - 1.0,\n                    0.0\n                )\n        return stress_weight  #\u5224\u5b9a\u8282\u70b9\u5e94\u529b\u662f\u5426\u8d85\u9650\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\uff0c\u6700\u540e\u7d2f\u52a0\u6570\u7ec4\u4e2d\u7684\u6570\u503c\u4f5c\u4e3a\u5e94\u529b\u8bc4\u4f30\u53c2\u7167\n\n    #\u8bc4\u4f30\u6746\u4ef6\u5c48\u66f2\n    def _get_buckle_value(self, edges):\n        buckle_weight = np.zeros((len(edges), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u5c48\u66f2\u6570\u636e\n        miu_buckle = 1.0                           #\u6746\u4ef6\u8ba1\u7b97\u957f\u5ea6\u7cfb\u6570\uff0c\u6841\u67b6\u4e24\u7aef\u94f0\u63a5\u53d61\n        \n        for tag, i in enumerate(edges.keys()):\n            edges[i].force = op.basicForce(tag)    #\u5b58\u653e\u8f74\u529b\u6570\u636e\n            edges[i].stress = edges[i].force[0] / edges[i].area #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            \n            if edges[i].stress < 0:    #\u4ec5\u538b\u6746\u624d\u8003\u8651\u5c48\u66f2\n                #\u8ba1\u7b97\u6b27\u62c9\u4e34\u754c\u529b\n                force_cr = (\n                    math.pi ** 2 \n                    * self._E * edges[i].inertia\n                ) / (miu_buckle * edges[i].len) ** 2\n\n                #\u8ba1\u7b97\u6b27\u62c9\u4e34\u754c\u5e94\u529b\n                buckle_stress_max = force_cr / edges[i].area\n\n                buckle_weight[tag] = max(\n                    abs(edges[i].stress) / abs(buckle_stress_max) - 1.0,\n                    0.0\n                )#\u5224\u5b9a\u6746\u4ef6\u538b\u5e94\u529b\u662f\u5426\u8d85\u8fc7\u5c48\u66f2\u4e34\u754c\u5e94\u529b\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return buckle_weight\n    \n    #\u8bc4\u4f30\u6746\u4ef6\u957f\u7ec6\u6bd4\n    def _get_slenderness_ratio(self, edges):\n        lambda_weight = np.zeros((len(edges), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for tag, i in enumerate(edges.keys()):\n            edges[i].force = op.basicForce(tag)    #\u5b58\u653e\u8f74\u529b\u6570\u636e\n            edges[i].stress = edges[i].force[0] / edges[i].area #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            lambda_weight[tag] = max(\n                abs(edges[i].slenderness_ratio) / abs(self.slenderness_ratio_C if edges[i].stress < 0 else self.slenderness_ratio_T) - 1.0,\n                0.0\n            )#\u5224\u5b9a\u6746\u4ef6\u957f\u7ec6\u6bd4\u662f\u5426\u8d85\u8fc7\u9650\u5236\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return lambda_weight\n\n    #\u8bc4\u4f30\u6746\u4ef6\u8d85\u957f\n    def _get_length_longer(self, edges):\n        longer_weight = np.zeros((len(edges), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for tag, i in enumerate(edges.keys()):   \n            longer_weight[tag] = max(\n                abs(edges[i].len) / abs(self.max_len) - 1.0,\n                0.0\n            )#\u5224\u5b9a\u6746\u4ef6\u957f\u5ea6\u662f\u5426\u8d85\u8fc7\u9650\u5236\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return longer_weight\n\n    #\u8bc4\u4f30\u6746\u4ef6\u8fc7\u77ed\n    def _get_length_shorter(self, edges):\n        shorter_weight = np.zeros((len(edges), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for tag, i in enumerate(edges.keys()): \n            if edges[i].len < self.min_len:\n                shorter_weight[tag] = 1.0-edges[i].len / self.min_len\n                #\u5224\u5b9a\u6746\u4ef6\u957f\u5ea6\u662f\u5426\u8fc7\u77ed\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return shorter_weight\n\n    #\u8c03\u7528\u4ee5\u4e0a\u51fd\u6570\u8fd0\u884c\u7ed3\u6784\u5206\u6790\n    def run(self, points, edges):\n        \n        is_struct = self._is_struct(points, edges) #\u8fd0\u884c\u7ed3\u6784\u5efa\u6a21\u4e0e\u5206\u6790\uff0cis_struct\u8fd4\u56de\u7ed3\u6784\u662f\u5426\u6b63\u5e38\u5b8c\u6210\u5206\u6790\n        mass, dis_value, stress_value, buckle_value, slenderness_vlaue, longer_value, shorter_value= 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0\n\n        if is_struct: #\u5982\u679c\u7ed3\u6784\u6210\u529f\u5b8c\u6210\u5206\u6790\uff0c\u5373\u7ed3\u6784\u662f\u51e0\u4f55\u4e0d\u53d8\u7684\n            for i, edge in edges.items():\n                mass += edge.len * edge.area * self._pho      #\u8ba1\u7b97\u7ed3\u6784\u603b\u8d28\u91cf\n            \n            if self._use_dis_constraint:\n                dis_value = self._get_dis_value(points)       #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u4f4d\u79fb\u8bc4\u4f30\u7ed3\u679c\n            if self._use_stress_constraint:\n                stress_value = self._get_stress_value(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u5e94\u529b\u8bc4\u4f30\u7ed3\u679c\n            if self._use_buckle_constraint:\n                buckle_value = self._get_buckle_value(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u5c48\u66f2\u8bc4\u4f30\u7ed3\u679c\n            if self._use_slenderness_constraint:\n                slenderness_vlaue = self._get_slenderness_ratio(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c    \n            if self._use_longer_constraint:\n                longer_value = self._get_length_longer(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c\n            if self._use_shorter_constraint:\n                shorter_value = self._get_length_shorter(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c \n        return (\n            is_struct, mass, dis_value, stress_value, buckle_value, slenderness_vlaue, longer_value, shorter_value\n        )\n\n    #\u7ed8\u5236\u5e73\u9762\u6841\u67b6\n    def render(self, points, edges):\n        _ax = plt.axes(projection='3d')\n        for point in points.values():   #\u7ed8\u5236\u8282\u70b9\uff0cscatter()\u7ed8\u5236\u6563\u70b9\n            if point.isSupport:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='g') #\u652f\u5ea7\u70b9\u4e3a\u7eff\u8272\n            elif point.isLoad:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='r') #\u8377\u8f7d\u4f5c\u7528\u7684\u8282\u70b9\u4e3a\u7ea2\u8272\n            else:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='b') #\u5176\u4f59\u8282\u70b9\u84dd\u8272\n\n        for edge in edges.values():    #\u7ed8\u5236\u6746\u4ef6\n            x0 = [points[edge.u].vec.x, points[edge.v].vec.x]   #\u6746\u4ef6\u8d77\u70b9\n            y0 = [points[edge.u].vec.y, points[edge.v].vec.y]   #\u6746\u4ef6\u7ec8\u70b9\n            z0 = [points[edge.u].vec.z, points[edge.v].vec.z]   #\u6746\u4ef6\u8d77\u70b9\n            \n            if edge.stress < -1e-7:\n                _ax.plot(x0, y0, z0, color='g', linewidth=(edge.area / math.pi)**0.5*500)    #\u538b\u6746\u7eff\u8272\n            elif edge.stress > 1e-7:\n                _ax.plot(x0, y0, z0, color='r', linewidth=(edge.area / math.pi)**0.5*500)    #\u62c9\u6746\u7ea2\u8272\n            else:\n                _ax.plot(x0, y0, z0, color='k', linewidth=(edge.area / math.pi)**0.5*500)    #\u96f6\u6746\u9ed1\u8272\n        plt.show() #\u663e\u793a\u56fe\u50cf", "\n\nif __name__=='__main__':\n    truss=DynamicModel(3)    #\u521b\u5efa\u7ed3\u6784\u5bf9\u8c61\n    point_list, edge_list = readFile(\"input_file_3d.txt\") #\u8bfb\u53d6\u6570\u636e\u8f93\u5165\u6587\u4ef6\u4e2d\u7684\u9884\u8bbe\u70b9\u548c\u8fb9\n\n    #\u5c06point_list, edge_list\u8f6c\u6362\u6210truss.run\u7684\u6570\u636e\u7ed3\u6784\n    points = {}\n    edges = {}\n    for i, point in enumerate(point_list):  #\u5c06\u9884\u8bbe\u70b9\u5bf9\u8c61\u52a0\u5165\u70b9\u96c6\n        points[i] = point\n\n    for i, edge in enumerate(edge_list):    #\u5c06\u9884\u8bbe\u8fb9\u5bf9\u8c61\u52a0\u5165\u8fb9\u96c6\n        if edge.u > edge.v:                 #\u8fb9\u7aef\u70b9\u91cd\u65b0\u7f16\u53f7\n            tmp = edge.u\n            edge.u = edge.v\n            edge.v = tmp\n        edges[(edge.u, edge.v)] = edge        \n\n    #\u8fd0\u884c\u6a21\u578b\u5206\u6790                                 \n    is_struct, mass, dis_value, stress_value, buckle_value, slenderness_vlaue, longer_value, shorter_value  = truss.run(points, edges) \n    \n    #\u540e\u5904\u7406\uff0c\u8f93\u51fa\u7ed3\u6784\u8bbe\u8ba1\u7ed3\u679c\u7684\u63d0\u793a\u4fe1\u606f\n    if not is_struct:\n        print(\"\u7ed3\u6784\u51e0\u4f55\u4e0d\u7a33\u5b9a\")\n    elif np.sum(dis_value) > 0.0 or np.sum(stress_value) > 0.0 or np.sum(buckle_value) > 0.0 or np.sum(slenderness_vlaue) or np.sum(longer_value) or np.sum(shorter_value):\n        for i in range(len(dis_value)):\n            if dis_value[i]>0.0:\n                print(\"\u7b2c{:}\u7ed3\u70b9\u4f4d\u79fb\u8d85\u51fa\u9650\u503c{:}%\".format(i,dis_value[i]*100))\n\n        for i in range(len(stress_value)):\n            if stress_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u5e94\u529b\u8d85\u51fa\u9650\u503c{:}%\".format(i,stress_value[i]*100))\n\n        for i in range(len(buckle_value)):\n            if buckle_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u5c48\u66f2\u5e94\u529b\u8d85\u51fa\u9650\u503c{:}%\".format(i,buckle_value[i]*100))\n\n        for i in range(len(slenderness_vlaue)):\n            if slenderness_vlaue[i][0]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u957f\u7ec6\u6bd4\u8d85\u51fa\u9650\u503c{:}%\".format(i,slenderness_vlaue[i]*100))\n\n        for i in range(len(longer_value)):\n            if longer_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u957f\u5ea6\u8d85\u51fa\u9650\u503c{:}%\".format(i,longer_value[i]*100))\n        for i in range(len(shorter_value)):\n            if shorter_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u957f\u5ea6\u77ed\u8fc7\u9650\u503c{:}%\".format(i,shorter_value[i]*100))                 \n\n    else:\n        print(\"\u7ed3\u6784\u51e0\u4f55\u7a33\u5b9a\uff0c\u4e14\u6240\u6709\u7ea6\u675f\u6ee1\u8db3\u3002\u5f53\u524d\u7ed3\u6784\u603b\u8d28\u91cf\u4e3a\uff1a{:.3f}kg\".format(mass))\n\n    truss.render(points, edges) #\u663e\u793a\u6841\u67b6\u56fe\u50cf", "\n\n   \n"]}
{"filename": "apps/checker/\u7ed3\u6784\u9a8c\u7b97/utils.py", "chunked_list": ["import math\n\n#\u5b9a\u4e49\u7a7a\u95f4\u5411\u91cf\u7c7b\u53ca\u5176\u8fd0\u7b97\nclass Vector3:\n\t#\u6784\u9020\u51fd\u6570\n\tdef __init__(self, x = 0.0, y = 0.0, z = 0.0):\n\t\tself.x = float(x)\n\t\tself.y = float(y)\n\t\tself.z = float(z)   #\u7a7a\u95f4\u5750\u6807\n\n\t#\u5411\u91cf\u52a0\u8fd0\u7b97\n\tdef __add__(self, obj):\n\t\treturn Vector3(self.x + obj.x, self.y + obj.y, self.z + obj.z)\n\n\t#\u5411\u91cf\u51cf\u8fd0\u7b97\n\tdef __sub__(self, obj):\n\t\treturn Vector3(self.x - obj.x, self.y - obj.y, self.z - obj.z)\n\n\t#\u5411\u91cf\u6570\u4e58\u53ca\u53c9\u4e58\n\tdef __mul__(self, obj):\n\t\tif (type(obj) == Vector3):\n\t\t\treturn Vector3(self.y*obj.z-self.z*obj.y, self.z*obj.x-self.x*obj.z, self.x*obj.y-self.y*obj.x)#\u5411\u91cf\u53c9\u4e58\n\t\tif (type(obj) == float or type(obj) == int):\n\t\t\treturn Vector3(self.x * obj, self.y * obj, self.z * obj)#\u6570\u4e58\u5411\u91cf\n\t\tassert(False)\n\t\n\t#\u5411\u91cf\u6587\u672c\u5316\u8868\u793a(x,y,z)\n\tdef __str__(self):\n\t\treturn str('(' + str(self.x) + ', ' + str(self.y) + ', ' + str(self.z) + ')')\n\n\t#\u5411\u91cf\u6a21\u957f\u7684\u5e73\u65b9\n\tdef length2(self):\n\t\treturn float(self.x * self.x + self.y * self.y + self.z * self.z)\n\n\t#\u5411\u91cf\u6a21\u957f\n\tdef length(self):\n\t\treturn math.sqrt(self.x * self.x + self.y * self.y + self.z * self.z)\n\n\t#\u5411\u91cf\u5355\u4f4d\u5316\n\tdef norm(self):\n\t\tl = self.length()\n\t\treturn Vector3(self.x / l, self.y / l, self.z / l)\n\n\t#\u5224\u65ad\u5411\u91cf\u662f\u5426\u76f8\u7b49\n\tdef __eq__(self, other):\n\t\tassert(type(other) == Vector3)\n\t\tif (abs(self.x - other.x) < 1e-8 and abs(self.y - other.y) < 1e-8 and abs(self.z - other.z) < 1e-8):\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False", "\n#\u8282\u70b9\u7c7b\nclass Point:\n\t#\u6784\u9020\u51fd\u6570\n\tdef __init__(self, vec = Vector3(), supportX = 0, supportY = 0, supportZ = 0, loadX = 0.0, loadY = 0.0, loadZ = 0.0):\n\t\tself.vec = vec  #\u7528\u7a7a\u95f4\u5411\u91cf\u7c7b\u521b\u5efa\u4f4d\u7f6e\n\t\t\n\t\tself.supportX = supportX       #\u8868\u5f81\u8282\u70b9\u67d0\u65b9\u5411\u652f\u5ea7\u7ea6\u675f\uff0c1\u662f0\u5426\n\t\tself.supportY = supportY\n\t\tself.supportZ = supportZ\n\t\tself.isSupport = False\n\t\tif (supportX == 1 or supportY == 1 or supportZ == 1):\n\t\t\tself.isSupport = True\n\t\t\n\t\tself.loadX = loadX            #\u8868\u5f81\u8282\u70b9\u67d0\u65b9\u5411\u7684\u70b9\u8377\u8f7d\u7684\u5927\u5c0f\n\t\tself.loadY = loadY\n\t\tself.loadZ = loadZ\n\t\tself.isLoad = False\n\t\tif (abs(loadX) > 1e-7 or abs(loadY) > 1e-7 or abs(loadZ) > 1e-7):\n\t\t\tself.isLoad = True", "\n#\u6746\u4ef6\u7c7b\nclass Bar:\n\t#\u6784\u9020\u51fd\u6570\n\tdef __init__(self, u = -1, v = -1, area = 1.0, leng = 0.0, inertia=1.0):\n\n\t\tself.u = int(u)\n\t\tself.v = int(v)             #\u6746\u4ef6\u4e24\u7aef\u7684\u8282\u70b9\u7f16\u53f7\n\t\tself.area = float(area)     #\u6746\u4ef6\u622a\u9762\u79ef\n\t\tself.force = float(0.0)     #\u6746\u4ef6\u8f74\u529b\n\t\tself.len = leng             #\u6746\u4ef6\u957f\u5ea6\n\t\tself.stress = 0.0           #\u6746\u4ef6\u5e94\u529b\n\t\tself.inertia=float(inertia) #\u6746\u4ef6\u60ef\u6027\u77e9\n\t\tself.slenderness_ratio=self.len/(self.inertia/self.area)**0.5", "\t\t\n#\u6c42\u7a7a\u95f4\u5411\u91cf\u7684\u6a21\u957f\ndef getlen(vec):\n\treturn math.sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z)\n\n#\u6c42\u4e24\u70b9\u95f4\u6746\u4ef6\u957f\u5ea6\ndef getlen2(u, v):\n\treturn getlen(u.vec - v.vec)\n\n#\u4e24\u5411\u91cf\u5939\u89d2\u7684\u4f59\u5f26\ndef getang(vec1, vec2):\n\treturn (vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z) / (getlen(vec1) * getlen(vec2))", "\n#\u4e24\u5411\u91cf\u5939\u89d2\u7684\u4f59\u5f26\ndef getang(vec1, vec2):\n\treturn (vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z) / (getlen(vec1) * getlen(vec2))\n\n#\u4ece\u6587\u4ef6\u8bfb\u53d6\u8bbe\u8ba1\u6570\u636e\ndef readFile(input_file):\n\n\tp = []  #\u70b9\u96c6\n\te = []  #\u8fb9\u96c6\n\n\twith open(input_file, \"r\") as fle:\n\t\tlines = fle.readlines()        #\u8bfb\u53d6\u6587\u4ef6\u5168\u90e8\u884c\uff0c\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\u5217\u8868\uff0c\u6bcf\u4e2a\u5143\u7d20\u4e3a\u6587\u4ef6\u7684\u4e00\u884c\u5185\u5bb9\n\t\tfor i in range(len(lines)):\n\t\t\tline = lines[i]            #\u7b2ci\u884c\u5185\u5bb9\n\t\t\tvec = line.strip().split(' ')  #strip()\u7528\u4e8e\u79fb\u9664\u5b57\u7b26\u4e32\u5934\u5c3e\u6307\u5b9a\u7684\u5b57\u7b26\uff08\u9ed8\u8ba4\u4e3a\u7a7a\u683c\uff09\u6216\u5b57\u7b26\u5e8f\u5217\uff0csplit(' ')\u901a\u8fc7\u6307\u5b9a\u5206\u9694\u7b26\u5bf9\u5b57\u7b26\u4e32\u8fdb\u884c\u5207\u7247\uff0csep\u9ed8\u8ba4\u4e3a\u6240\u6709\u7684\u7a7a\u5b57\u7b26\uff0c\u5305\u62ec\u7a7a\u683c\u3001\u6362\u884c(\\n)\u3001\u5236\u8868\u7b26(\\t)\n\t\t\t\n\t\t\tif (i == 0):               #\u7b2c\u4e00\u884c\n\t\t\t\tvn = int(vec[0])       #\u9884\u8bbe\u8282\u70b9\u6570\u91cf\n\t\t\t\ten = int(vec[1])       #\u9884\u8bbe\u8fb9\u6570\u91cf\n\t\t\t\tcontinue\n\n\t\t\tif (1 <= i and i <= vn):   #\u9884\u8bbe\u8282\u70b9\u4fe1\u606f\n\t\t\t\tp.append(Point(Vector3(float(vec[0]), float(vec[1]), float(vec[2])), int(vec[3]), int(vec[4]), int(vec[5]), float(vec[6]), float(vec[7]), float(vec[8])))\n\t\t\t\tcontinue               #\u70b9\u96c6p\u91cc\u6bcf\u4e2a\u5143\u7d20\u4e3aPoint\u7c7b\u5bf9\u8c61\uff1a{\u70b9\u5750\u68073+\u652f\u5ea7\u7ea6\u675f+\u8377\u8f7d}\n\n\t\t\tif (vn + 1 <= i and i <= vn + en):\n\t\t\t\te.append(Bar(vec[0], vec[1], float(vec[2]), getlen2(p[int(vec[0])], p[int(vec[1])]),math.pi*(float(vec[3])**4-(float(vec[3])-2*float(vec[4]))**4)/64))\n\t\t\t\tcontinue               #\u8fb9\u96c6\u91cc\u6bcf\u4e2a\u5143\u7d20\u4e3abar\u7c7b\u5bf9\u8c61\uff1a{\u4e24\u7aef\u8282\u70b9\u7f16\u53f72+\u622a\u9762\u79ef+\u957f\u5ea6+(\u60ef\u6027\u77e9\u7f3a\u7701)}\n\treturn p, e", "\t"]}
{"filename": "Stage2/__init__.py", "chunked_list": ["from Stage2.models import *"]}
{"filename": "Stage2/main_3d.py", "chunked_list": ["import argparse\nimport os\nimport sys\nbase_path = os.getcwd()\nsys.path.append(base_path)\nfrom configs.config import *\nimport copy\nimport torch as th\nimport rlkit.torch.pytorch_util as ptu\nimport numpy as np", "import rlkit.torch.pytorch_util as ptu\nimport numpy as np\nimport warnings\nfrom rlkit.envs.wrappers import NormalizedBoxEnv\nfrom rlkit.samplers.data_collector import MdpPathCollector\nfrom rlkit.data_management.env_replay_buffer import EnvReplayBuffer\nfrom rlkit.torch.sac.sac import SACTrainer\nfrom rlkit.torch.torch_rl_algorithm import TorchBatchRLAlgorithm\n\nfrom Stage2.envs import Truss", "\nfrom Stage2.envs import Truss\nfrom models import MLP, TanhGaussianPolicy, MakeDeterministic, TRANSFORMEREMBED, GNNEMBED, TRANSFORMEREMBED_policy, GNNEMBED_policy\n\nclass SizeEnvReplayBuffer(EnvReplayBuffer):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n    def random_batch(self, batch_size):\n        indices = np.random.choice(self._size, size=batch_size, replace=self._replace or self._size < batch_size)\n        if not self._replace and self._size < batch_size:\n            warnings.warn('Replace was set to false, but is temporarily set to true because batch size is larger than current size of replay.')\n        batch = dict(\n            observations=self._observations[indices],\n            actions=self._actions[indices],\n            rewards=self._rewards[indices],\n            terminals=self._terminals[indices],\n            next_observations=self._next_obs[indices],\n        )\n        for key in self._env_info_keys:\n            assert key not in batch.keys()\n            batch[key] = self._env_infos[key][indices]\n        return batch", "\nif __name__ == '__main__':\n    parser = get_base_config()\n    args = parser.parse_known_args(sys.argv[1:])[0]\n    config = make_config(args.config)\n    for k, v in config.get(\"base\", {}).items():\n        if f\"--{k}\" not in args:\n            setattr(args, k, v)\n    print(args)\n    print(args.save_model_path)\n    if not os.path.exists('saved_models'):\n        os.mkdir('saved_models')\n    if not os.path.exists(args.save_model_path):\n        os.mkdir(args.save_model_path)\n    args.save_model_path = os.path.join(args.save_model_path, args.run_id)\n    if not os.path.exists(args.save_model_path):\n        os.mkdir(args.save_model_path)\n    if th.cuda.is_available():\n        ptu.set_gpu_mode(True)\n    env = NormalizedBoxEnv(Truss(args, args.maxp, os.path.join(args.input_path_2, args.run_id),\n                                 args.coordinate_range, args.area_range,\n                                 args.coordinate_delta_range, args.area_delta_range,\n                                 args.fixed_points, args.variable_edges,\n                                 args.max_refine_steps, dimension=args.env_dims, reward_lambda=args.reward_lambda))\n\n    obs_dim = env.observation_space.low.size\n    action_dim = env.action_space.low.size\n\n    #qf1 = MLP(obs_dim + action_dim, args.hidden_dims)\n    #qf2 = MLP(obs_dim + action_dim, args.hidden_dims)\n    if (args.EmbeddingBackbone == 'Transformer'):\n        qf1 = TRANSFORMEREMBED(args.prev_dims, args.hidden_dims, args.env_dims, args.env_mode, src_mask=True)\n        qf2 = TRANSFORMEREMBED(args.prev_dims, args.hidden_dims, args.env_dims, args.env_mode, src_mask=True)\n    elif (args.EmbeddingBackbone == 'GNN'):\n        qf1 = GNNEMBED(args.prev_dims, args.hidden_dims, args.env_dims, args.env_mode, args.maxp)\n        qf2 = GNNEMBED(args.prev_dims, args.hidden_dims, args.env_dims, args.env_mode, args.maxp)\n\n    target_qf1 = copy.deepcopy(qf1)\n    target_qf2 = copy.deepcopy(qf2)\n    \n    if (args.EmbeddingBackbone == 'Transformer'):\n        expl_policy = TRANSFORMEREMBED_policy(args.prev_dims, action_dim, args.hidden_dims, args.env_dims, args.env_mode, num_point=args.maxp, src_mask=True)\n    elif (args.EmbeddingBackbone == 'GNN'):\n        expl_policy = GNNEMBED_policy(args.prev_dims, action_dim, args.hidden_dims, args.env_dims, args.env_mode, num_point=args.maxp)\n\n    #expl_policy = TanhGaussianPolicy(obs_dim=obs_dim, action_dim=action_dim, hidden_sizes=args.hidden_dims)\n    \n    if args.finetune:\n        print(\"load pretrain\")\n        expl_policy.load_state_dict(th.load(\"{}/policy.th\".format(args.finetune_model_path)))\n        qf1.load_state_dict(th.load(\"{}/qf1.th\".format(args.finetune_model_path)))\n        qf2.load_state_dict(th.load(\"{}/qf2.th\".format(args.finetune_model_path)))\n        target_qf1.load_state_dict(th.load(\"{}/target_qf1.th\".format(args.finetune_model_path)))\n        target_qf2.load_state_dict(th.load(\"{}/target_qf2.th\".format(args.finetune_model_path)))\n\n    eval_policy = MakeDeterministic(expl_policy)\n\n    if args.eval:\n        expl_policy = MakeDeterministic(expl_policy)\n        trainer = SACTrainer(env=env, policy=expl_policy, qf1=qf1, qf2=qf2, target_qf1=target_qf1, target_qf2=target_qf2,\n                         soft_target_tau=0.005, reward_scale=1, policy_lr=0.0000, qf_lr=0.0000)\n    else: trainer = SACTrainer(env=env, policy=expl_policy, qf1=qf1, qf2=qf2, target_qf1=target_qf1, target_qf2=target_qf2,\n                         soft_target_tau=0.005, reward_scale=1, policy_lr=0.0003, qf_lr=0.0003)\n\n    expl_path_collector = MdpPathCollector(env, expl_policy)\n    eval_path_collector = MdpPathCollector(env, eval_policy)\n    replay_buffer = EnvReplayBuffer(args.buffer_size, env)\n    algorithm = TorchBatchRLAlgorithm(trainer=trainer, exploration_env=env, evaluation_env=env,\n                                      exploration_data_collector=expl_path_collector,\n                                      evaluation_data_collector=eval_path_collector,\n                                      replay_buffer=replay_buffer,\n                                      num_epochs=args.epoch,\n                                      num_eval_steps_per_epoch=2000,\n                                      num_trains_per_train_loop=args.num_trains_per_train_loop,\n                                      num_train_loops_per_epoch=args.num_train_loops_per_epoch,\n                                      num_expl_steps_per_train_loop=1000,\n                                      min_num_steps_before_training=1000,\n                                      max_path_length=500,\n                                      batch_size=args.batch_size, eval = args.eval)\n    algorithm.to(ptu.device)\n    algorithm.train()\n\n    trained_network = algorithm.trainer.networks\n    th.save(trained_network[0].state_dict(), \"{}/policy.th\".format(args.save_model_path))\n    th.save(trained_network[1].state_dict(), \"{}/qf1.th\".format(args.save_model_path))\n    th.save(trained_network[2].state_dict(), \"{}/qf2.th\".format(args.save_model_path))\n    th.save(trained_network[3].state_dict(), \"{}/target_qf1.th\".format(args.save_model_path))\n    th.save(trained_network[4].state_dict(), \"{}/target_qf2.th\".format(args.save_model_path))", ""]}
{"filename": "Stage2/models/__init__.py", "chunked_list": ["from .policy import TanhGaussianPolicy, MakeDeterministic, EmbedTanhGaussianPolicy\nfrom .value_function import MLP, TRANSFORMEREMBED, Transformer_Value_Network, Toy_Value_Network, GNNEMBED, TRANSFORMEREMBED_policy, GNNEMBED_policy\n"]}
{"filename": "Stage2/models/policy/__init__.py", "chunked_list": ["from .TanhGaussian import TanhGaussianPolicy, MakeDeterministic, EmbedTanhGaussianPolicy"]}
{"filename": "Stage2/models/policy/TanhGaussian_autoregression.py", "chunked_list": ["from rlkit.torch.sac.policies import TanhGaussianPolicy, MakeDeterministic\n"]}
{"filename": "Stage2/models/policy/TanhGaussian.py", "chunked_list": ["from rlkit.torch.sac.policies import TanhGaussianPolicy, MakeDeterministic\n\nimport abc\nimport logging\nimport os\nimport math\n\nimport numpy as np\nimport torch\nimport torch.nn.functional as F", "import torch\nimport torch.nn.functional as F\nfrom torch import nn as nn\n\nimport rlkit.torch.pytorch_util as ptu\nfrom rlkit.policies.base import ExplorationPolicy\nfrom rlkit.torch.core import torch_ify, elem_or_tuple_to_numpy\nfrom rlkit.torch.distributions import (\n    Delta, TanhNormal, MultivariateDiagonalNormal, GaussianMixture, GaussianMixtureFull,\n)", "    Delta, TanhNormal, MultivariateDiagonalNormal, GaussianMixture, GaussianMixtureFull,\n)\nfrom rlkit.torch.networks import Mlp, CNN\nfrom rlkit.torch.networks.basic import MultiInputSequential\nfrom rlkit.torch.networks.stochastic.distribution_generator import (\n    DistributionGenerator\n)\nfrom rlkit.torch.sac.policies.base import (\n    TorchStochasticPolicy,\n    PolicyFromDistributionGenerator,", "    TorchStochasticPolicy,\n    PolicyFromDistributionGenerator,\n    MakeDeterministic,\n)\n\nLOG_SIG_MAX = 2\nLOG_SIG_MIN = -20\n\nclass EmbedTanhGaussianPolicy(Mlp, TorchStochasticPolicy):\n    \"\"\"\n    Usage:\n    ```\n    policy = TanhGaussianPolicy(...)\n    \"\"\"\n\n    def __init__(\n            self,\n            hidden_sizes,\n            obs_dim,\n            action_dim,\n            input_dims,\n            std=None,\n            init_w=1e-3,\n            **kwargs\n    ):\n        super().__init__(\n            hidden_sizes,\n            input_size=obs_dim,\n            output_size=action_dim,\n            init_w=init_w,\n            **kwargs\n        )\n        self.log_std = None\n        self.std = std\n        if std is None:\n            last_hidden_size = obs_dim\n            if len(hidden_sizes) > 0:\n                last_hidden_size = hidden_sizes[-1]\n            self.last_fc_log_std = nn.Linear(last_hidden_size, action_dim)\n            self.last_fc_log_std.weight.data.uniform_(-init_w, init_w)\n            self.last_fc_log_std.bias.data.uniform_(-init_w, init_w)\n        else:\n            self.log_std = np.log(std)\n            assert LOG_SIG_MIN <= self.log_std <= LOG_SIG_MAX\n\n        self.embed_dim = input_dims[-1]\n        # print(input_dims[-1])\n        # print(input_dims[:-1])\n        self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3)\n        self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=5)\n        self.embed_id = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=2)\n        self.embed_act = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3)\n        self.transformer = nn.Transformer(d_model=self.embed_dim, nhead=4, num_encoder_layers=2)\n\n    def forward(self, obs):\n        inputs = [obs, torch.ones(obs.shape[0], 3).cuda()]\n        flat_inputs = torch.cat(inputs, dim=-1).cuda()\n        # print(flat_inputs.shape)\n        flat_dim = flat_inputs.shape[1]\n        act_inputs = flat_inputs[..., -3:]\n        id_inputs = flat_inputs[..., -5: -3]\n        num_points = int((math.sqrt(25 + 8 * (flat_dim - 5)) - 5) / 2)\n        # print(num_points)\n        pos_inputs = flat_inputs[..., :2 * num_points]\n        force_inputs = flat_inputs[..., -5 - num_points: -5]\n        edge_inputs = flat_inputs[..., 2 * num_points: -5 - num_points]\n        node_outputs = NodeEmbedding(pos_inputs, force_inputs, num_points).cuda()\n        embed_node_outputs = self.embed_node(node_outputs)\n        # print(node_outputs.shape, embed_node_outputs.shape)\n        edge_outputs = EdgeEmbedding(pos_inputs, edge_inputs, num_points).cuda()\n        embed_edge_outputs = self.embed_edge(edge_outputs)\n        # print(edge_outputs.shape, embed_edge_outputs.shape)\n        embed_id_outputs = self.embed_id(id_inputs).unsqueeze(1)\n        embed_act_outputs = self.embed_act(act_inputs).unsqueeze(1)\n        # print(embed_id_outputs.shape, embed_act_outputs.shape)\n\n        src = torch.cat([embed_node_outputs, embed_edge_outputs, embed_id_outputs], dim=1).transpose(0, 1)\n        # print(src.shape)\n        tgt = embed_act_outputs.transpose(0, 1)\n        # print(tgt.shape)\n        outs = self.transformer(src, tgt).transpose(0, 1).squeeze(dim=1)\n        #print(outs.shape)\n\n        h = outs\n        for i, fc in enumerate(self.fcs):\n            h = self.hidden_activation(fc(h))\n        mean = self.last_fc(h)\n        if self.std is None:\n            log_std = self.last_fc_log_std(h)\n            log_std = torch.clamp(log_std, LOG_SIG_MIN, LOG_SIG_MAX)\n            std = torch.exp(log_std)\n        else:\n            std = torch.from_numpy(np.array([self.std, ])).float().to(\n                ptu.device)\n\n        return TanhNormal(mean, std)\n\n    def logprob(self, action, mean, std):\n        tanh_normal = TanhNormal(mean, std)\n        log_prob = tanh_normal.log_prob(\n            action,\n        )\n        log_prob = log_prob.sum(dim=1, keepdim=True)\n        return log_prob", "class EmbedTanhGaussianPolicy(Mlp, TorchStochasticPolicy):\n    \"\"\"\n    Usage:\n    ```\n    policy = TanhGaussianPolicy(...)\n    \"\"\"\n\n    def __init__(\n            self,\n            hidden_sizes,\n            obs_dim,\n            action_dim,\n            input_dims,\n            std=None,\n            init_w=1e-3,\n            **kwargs\n    ):\n        super().__init__(\n            hidden_sizes,\n            input_size=obs_dim,\n            output_size=action_dim,\n            init_w=init_w,\n            **kwargs\n        )\n        self.log_std = None\n        self.std = std\n        if std is None:\n            last_hidden_size = obs_dim\n            if len(hidden_sizes) > 0:\n                last_hidden_size = hidden_sizes[-1]\n            self.last_fc_log_std = nn.Linear(last_hidden_size, action_dim)\n            self.last_fc_log_std.weight.data.uniform_(-init_w, init_w)\n            self.last_fc_log_std.bias.data.uniform_(-init_w, init_w)\n        else:\n            self.log_std = np.log(std)\n            assert LOG_SIG_MIN <= self.log_std <= LOG_SIG_MAX\n\n        self.embed_dim = input_dims[-1]\n        # print(input_dims[-1])\n        # print(input_dims[:-1])\n        self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3)\n        self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=5)\n        self.embed_id = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=2)\n        self.embed_act = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3)\n        self.transformer = nn.Transformer(d_model=self.embed_dim, nhead=4, num_encoder_layers=2)\n\n    def forward(self, obs):\n        inputs = [obs, torch.ones(obs.shape[0], 3).cuda()]\n        flat_inputs = torch.cat(inputs, dim=-1).cuda()\n        # print(flat_inputs.shape)\n        flat_dim = flat_inputs.shape[1]\n        act_inputs = flat_inputs[..., -3:]\n        id_inputs = flat_inputs[..., -5: -3]\n        num_points = int((math.sqrt(25 + 8 * (flat_dim - 5)) - 5) / 2)\n        # print(num_points)\n        pos_inputs = flat_inputs[..., :2 * num_points]\n        force_inputs = flat_inputs[..., -5 - num_points: -5]\n        edge_inputs = flat_inputs[..., 2 * num_points: -5 - num_points]\n        node_outputs = NodeEmbedding(pos_inputs, force_inputs, num_points).cuda()\n        embed_node_outputs = self.embed_node(node_outputs)\n        # print(node_outputs.shape, embed_node_outputs.shape)\n        edge_outputs = EdgeEmbedding(pos_inputs, edge_inputs, num_points).cuda()\n        embed_edge_outputs = self.embed_edge(edge_outputs)\n        # print(edge_outputs.shape, embed_edge_outputs.shape)\n        embed_id_outputs = self.embed_id(id_inputs).unsqueeze(1)\n        embed_act_outputs = self.embed_act(act_inputs).unsqueeze(1)\n        # print(embed_id_outputs.shape, embed_act_outputs.shape)\n\n        src = torch.cat([embed_node_outputs, embed_edge_outputs, embed_id_outputs], dim=1).transpose(0, 1)\n        # print(src.shape)\n        tgt = embed_act_outputs.transpose(0, 1)\n        # print(tgt.shape)\n        outs = self.transformer(src, tgt).transpose(0, 1).squeeze(dim=1)\n        #print(outs.shape)\n\n        h = outs\n        for i, fc in enumerate(self.fcs):\n            h = self.hidden_activation(fc(h))\n        mean = self.last_fc(h)\n        if self.std is None:\n            log_std = self.last_fc_log_std(h)\n            log_std = torch.clamp(log_std, LOG_SIG_MIN, LOG_SIG_MAX)\n            std = torch.exp(log_std)\n        else:\n            std = torch.from_numpy(np.array([self.std, ])).float().to(\n                ptu.device)\n\n        return TanhNormal(mean, std)\n\n    def logprob(self, action, mean, std):\n        tanh_normal = TanhNormal(mean, std)\n        log_prob = tanh_normal.log_prob(\n            action,\n        )\n        log_prob = log_prob.sum(dim=1, keepdim=True)\n        return log_prob", "\n\ndef EdgeEmbedding(pos_inputs, edge_inputs, num_points):\n    _pos_inputs = pos_inputs.reshape(pos_inputs.shape[0], num_points, 2)\n    outputs = []\n    for k in range(_pos_inputs.shape[0]):\n        one_output = []\n        idx = 0\n        i = 0\n        j = 1\n        while idx < num_points * (num_points - 1) / 2:\n            one_edge = []\n            v_i = [_pos_inputs[k][i][0], _pos_inputs[k][i][1]]\n            v_j = [_pos_inputs[k][j][0], _pos_inputs[k][j][1]]\n            area_ij = edge_inputs[k][idx]\n            one_edge += v_i\n            one_edge += v_j\n            one_edge.append(area_ij)\n            idx += 1\n            i += 1\n            if i == j:\n                i = 0\n                j += 1\n            one_output.append(one_edge)\n        outputs.append(one_output)\n    return torch.Tensor(outputs)", "\ndef NodeEmbedding(pos_inputs, force_inputs, num_points):\n    _pos_inputs = pos_inputs.reshape(pos_inputs.shape[0], num_points, 2)\n    _force_inputs = force_inputs.reshape(force_inputs.shape[0], num_points, 1)\n    return torch.cat([_pos_inputs, _force_inputs], dim=-1)"]}
{"filename": "Stage2/models/value_function/mlp.py", "chunked_list": ["import torch, os, math\nimport numpy as np\nfrom torch import nn\nfrom torch.nn import functional as F\nfrom rlkit.policies.base import Policy\nfrom rlkit.pythonplusplus import identity\nfrom rlkit.torch import pytorch_util as ptu\nfrom rlkit.torch.core import PyTorchModule, eval_np\nfrom rlkit.torch.data_management.normalizer import TorchFixedNormalizer\nfrom rlkit.torch.networks import LayerNorm, ConcatMlp, Mlp", "from rlkit.torch.data_management.normalizer import TorchFixedNormalizer\nfrom rlkit.torch.networks import LayerNorm, ConcatMlp, Mlp\nfrom rlkit.torch.pytorch_util import activation_from_string\nfrom rlkit.torch.sac.policies import TanhGaussianPolicy\n\nclass MLP(ConcatMlp):\n    def __init__(self, input_dim, hidden_dims):\n        super().__init__(input_size=input_dim, output_size=1, hidden_sizes=hidden_dims)\n\nclass _Mlp(Mlp):\n    def __init__(self, *args, dim=1, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.dim = dim", "\nclass _Mlp(Mlp):\n    def __init__(self, *args, dim=1, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.dim = dim\n\nclass Transformer_Value_Network(nn.Module):\n    \"\"\"\n        value network for UCTs\n        hidden dims: hidden_dims for Mlp\n        input dims: [... -1]: ... for Mlp for input size, -1 for enbedding size \n    \"\"\"\n    def __init__(self, input_dims, hidden_dims, env_dims, env_mode, num_node):\n        super(Transformer_Value_Network, self).__init__()\n        self.embed_dim = input_dims[-1]\n        self.env_dims = env_dims\n        self.env_mode = env_mode\n        self.num_node = num_node\n        self.num_edge = self.num_node * (self.num_node - 1) // 2\n        # print(self.num_node * (self.env_dims + 1) + self.num_edge * (1 + 2 * self.env_dims))\n        self.query_valid_embed = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size = 1)\n        self.query_value_embed = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size = 1)\n        if (env_dims == 2):\n            self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size = 3) #2 pos + 1 force = 3\n            self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size = 5) #2 * 2 pos + 1 Area = 5\n        if (env_dims == 3 and env_mode == 'Area'):\n            self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size = 4) #3 pos + 1 force = 4\n            self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size = 7) #2 * 3 pos + 1 Area = 7\n        if (env_dims == 3 and env_mode == 'DT'):\n            self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size = 4) #3 pos + 1 force = 4\n            self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size = 8) #2 * 3 pos + 2 dt = 8\n        self.transformer = nn.Transformer(d_model=self.embed_dim, nhead = 1, num_encoder_layers = 6)\n        self.valid_head = Mlp(input_size = input_dims[-1], output_size = 2, hidden_sizes = hidden_dims)\n        self.value_head = Mlp(input_size = input_dims[-1], output_size = 1, hidden_sizes = hidden_dims)\n\n    def forward(self, *inputs, **kwargs): \n        flat_inputs = torch.cat(inputs, dim = -1).cuda()\n        flat_dim = flat_inputs.shape[1]\n        #print(flat_dim)\n        #print(self.env_dims)\n        #print(flat_inputs.shape)\n        if (self.env_dims == 2):\n            num_points = int((math.sqrt(25 + 8 * (flat_dim)) - 5) / 2) # check!!!\n            pos_inputs = flat_inputs[..., :2 * num_points]\n            force_inputs = flat_inputs[..., -num_points: ]\n            edge_inputs = flat_inputs[..., 2 * num_points: -num_points]\n        if (self.env_dims == 3 and self.env_mode == 'Area'):\n            num_points = int((math.sqrt(49 + 8 * (flat_dim)) - 7) / 2) # check!!!\n            #1/2 * (-7 + sqrt(49 + 8n))\n            pos_inputs = flat_inputs[..., :3 * num_points]\n            force_inputs = flat_inputs[..., num_points: ]\n            edge_inputs = flat_inputs[..., 3 * num_points: -num_points]\n\n        if (self.env_dims == 3 and self.env_mode == 'DT'):\n            num_points = int((math.sqrt(9 + 4 * (flat_dim)) - 3) / 2) # check!!!\n            #1 / 2 * (-3 + sqrt(9 + 4n))\n            pos_inputs = flat_inputs[..., :3 * num_points]\n            force_inputs = flat_inputs[..., -num_points: ]\n            edge_inputs = flat_inputs[..., 3 * num_points: -num_points]\n\n        #print(pos_inputs[0])\n        #print(force_inputs[0])\n        #print(edge_inputs[0])\n        node_outputs = NodeEmbedding(pos_inputs, force_inputs, num_points).cuda()\n        #print(node_outputs[0])\n        embed_node_outputs = self.embed_node(node_outputs)\n        #print(node_outputs.shape, embed_node_outputs.shape)\n        edge_outputs, src_mask = EdgeEmbedding_with_Mask(pos_inputs, edge_inputs, num_points, self.env_dims, self.env_mode)\n        #print(edge_outputs[0])\n        embed_edge_outputs = self.embed_edge(edge_outputs)\n        #print(edge_outputs.shape, embed_edge_outputs.shape)\n        #print(embed_id_outputs.shape, embed_act_outputs.shape)\n        src = torch.cat([embed_node_outputs, embed_edge_outputs], dim=1).transpose(0, 1)\n        #print(src.shape)\n        query_input = torch.ones(flat_inputs.shape[0]).unsqueeze(-1).unsqueeze(0).to(src.device)\n        tgt = torch.cat((self.query_valid_embed(query_input), self.query_value_embed(query_input)), dim = 0)\n        #print(src.shape, tgt.shape)\n        #print(src_mask.shape)\n        #print(src_mask)\n        #print(src_mask[1])\n        src_mask = ~src_mask\n        outs = self.transformer(src, tgt, src_mask = src_mask)\n        #print(outs.shape)\n        valid = self.valid_head(outs[0])\n        value = self.value_head(outs[1])\n        return valid, value", "\nclass TRANSFORMEREMBED(_Mlp):\n    \"\"\"\n        represented by edge sequences --> MLP embed to high dim --> transformer --> MLP to dim 1\n    \"\"\"\n    def __init__(self, input_dims, hidden_dims, env_dims, env_mode, num_point = None, src_mask = False):\n        super().__init__(input_size=input_dims[-1], output_size=1, hidden_sizes=hidden_dims)\n        self.embed_dim = input_dims[-1]\n        self.env_dims = env_dims\n        self.env_mode = env_mode\n        self.src_mask = src_mask\n        if (env_dims == 2):\n            self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3) #2 pos + 1 force = 3\n            self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=5) #2 * 2 pos + 1 Area = 5\n            self.embed_id = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3)\n            self.embed_act = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3) # 2 pos + 1 Area = 3\n        if (env_dims == 3 and env_mode == 'Area'):\n            self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=4) #3 pos + 1 force = 4\n            self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=7) #2 * 3 pos + 1 Area = 7\n            self.embed_id = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3) \n            self.embed_act = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=4) # 3 pos + 1 Area = 4  \n        if (env_dims == 3 and env_mode == 'DT'):\n            self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=4) #3 pos + 1 force = 4\n            self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=8) #2 * 3 pos + 2 dt = 8\n            self.embed_id = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3) \n            self.embed_act = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=5) # 3 pos + 2 dt = 5  \n        if (src_mask):\n            self.transformer = nn.Transformer(d_model=self.embed_dim, nhead=1, num_encoder_layers=6)\n        else: \n            self.transformer = nn.Transformer(d_model=self.embed_dim, nhead=4, num_encoder_layers=2)\n\n    def forward(self, *inputs, **kwargs):\n        flat_inputs = torch.cat(inputs, dim=self.dim).cuda()\n        flat_dim = flat_inputs.shape[1]\n        #print(flat_dim)\n        #print(self.env_dims)\n        #print(flat_inputs.shape)\n        if (self.env_dims == 2):\n            act_inputs = flat_inputs[..., -3:]\n            id_inputs = flat_inputs[..., -6: -3]\n            num_points = int((math.sqrt(25 + 8 * (flat_dim - 6)) - 5) / 2)\n            pos_inputs = flat_inputs[..., :2 * num_points]\n            force_inputs = flat_inputs[..., -6 - num_points: -6]\n            edge_inputs = flat_inputs[..., 2 * num_points: -6 - num_points]\n        if (self.env_dims == 3 and self.env_mode == 'Area'):\n            act_inputs = flat_inputs[..., -4:]\n            id_inputs = flat_inputs[..., -7: -4]\n            num_points = int((math.sqrt(49 + 8 * (flat_dim - 7)) - 7) / 2)\n            #1/2 * (-7 + sqrt(49 + 8n))\n            pos_inputs = flat_inputs[..., :3 * num_points]\n            force_inputs = flat_inputs[..., -7 - num_points: -7]\n            edge_inputs = flat_inputs[..., 3 * num_points: -7 - num_points]\n        if (self.env_dims == 3 and self.env_mode == 'DT'):\n            act_inputs = flat_inputs[..., -5:]\n            id_inputs = flat_inputs[..., -8: -5]\n            num_points = int((math.sqrt(9 + 4 * (flat_dim - 8)) - 3) / 2)\n            #1 / 2 * (-3 + sqrt(9 + 4n))\n            pos_inputs = flat_inputs[..., :3 * num_points]\n            force_inputs = flat_inputs[..., -8 - num_points: -8]\n            edge_inputs = flat_inputs[..., 3 * num_points: -8 - num_points]\n\n        node_outputs = NodeEmbedding(pos_inputs, force_inputs, num_points).cuda()\n        embed_node_outputs = self.embed_node(node_outputs)\n        #print(node_outputs.shape, embed_node_outputs.shape)\n        edge_outputs, src_mask = EdgeEmbedding_with_Mask(pos_inputs, edge_inputs, num_points, self.env_dims, self.env_mode, with_act_id = True)\n        edge_outputs.cuda() \n        src_mask.cuda()\n        embed_edge_outputs = self.embed_edge(edge_outputs)\n        #print(edge_outputs.shape, embed_edge_outputs.shape)\n        embed_id_outputs = self.embed_id(id_inputs).unsqueeze(1)\n        embed_act_outputs = self.embed_act(act_inputs).unsqueeze(1)\n        #print(embed_id_outputs.shape, embed_act_outputs.shape)\n        src = torch.cat([embed_node_outputs, embed_edge_outputs, embed_id_outputs], dim=1).transpose(0, 1)\n        #print(src.shape)\n        tgt = embed_act_outputs.transpose(0, 1)\n        #print(tgt.shape)\n        #print(src_mask.shape)\n        #print(src_mask[0])\n        if (not self.src_mask): src_mask = None\n        if (src_mask != None): src_mask = ~src_mask\n        outs = self.transformer(src, tgt, src_mask = src_mask).transpose(0, 1).squeeze(dim=1)\n        #print(outs[0])\n        return super().forward(outs, **kwargs)", "\ndef EdgeEmbedding(pos_inputs, edge_inputs, num_points, env_dims = 2, env_mode = 'Area'):# TODO:check it\n    _pos_inputs = pos_inputs.reshape(pos_inputs.shape[0], num_points, -1)\n    outputs = []\n    for k in range(_pos_inputs.shape[0]):\n        one_output = []\n        idx = 0\n        i = 0\n        j = 1\n        while idx < num_points * (num_points - 1) / 2:\n            one_edge = []\n            v_i = [_pos_inputs[k][i][0], _pos_inputs[k][i][1]]\n            v_j = [_pos_inputs[k][j][0], _pos_inputs[k][j][1]]\n            if (env_dims == 3):\n                v_i = [_pos_inputs[k][i][0], _pos_inputs[k][i][1], _pos_inputs[k][i][2]]\n                v_j = [_pos_inputs[k][j][0], _pos_inputs[k][j][1], _pos_inputs[k][j][2]]\n            one_edge += v_i\n            one_edge += v_j\n            if (env_mode == 'Area'):\n                area_ij = edge_inputs[k][idx]\n                one_edge.append(area_ij)\n            if (env_mode == 'DT'):\n                d_ij = edge_inputs[k][idx * 2]\n                t_ij = edge_inputs[k][idx * 2 + 1]\n                one_edge.append(d_ij)\n                one_edge.append(t_ij)\n            idx += 1\n            i += 1\n            if i == j:\n                i = 0\n                j += 1\n            one_output.append(one_edge)\n        outputs.append(one_output)\n    return torch.Tensor(outputs) # k * (num * (num - 1) / 2) * 8", "\ndef EdgeEmbedding_with_Mask(pos_inputs, edge_inputs, num_points, env_dims = 2, env_mode = 'Area', with_act_id = False):\n    _pos_inputs = pos_inputs.reshape(pos_inputs.shape[0], num_points, -1)\n    outputs = []\n    src_len = num_points + num_points * (num_points - 1) // 2\n    if (not with_act_id):\n        masks = torch.zeros((pos_inputs.shape[0], src_len, src_len), dtype = bool)\n    else:\n        masks = torch.zeros((pos_inputs.shape[0], src_len + 1, src_len + 1), dtype = bool)\n    for k in range(_pos_inputs.shape[0]):\n        if (not with_act_id):\n            mask = torch.zeros((src_len, src_len), dtype = bool)\n        else:\n            mask = torch.zeros((src_len + 1, src_len + 1), dtype = bool)\n        one_output = []\n        idx = 0\n        i, j = 0, 1\n        while idx < num_points * (num_points - 1) // 2:\n            one_edge = []\n            v_i = [_pos_inputs[k][i][0], _pos_inputs[k][i][1]]\n            v_j = [_pos_inputs[k][j][0], _pos_inputs[k][j][1]]\n            if (env_dims == 3):\n                v_i = [_pos_inputs[k][i][0], _pos_inputs[k][i][1], _pos_inputs[k][i][2]]\n                v_j = [_pos_inputs[k][j][0], _pos_inputs[k][j][1], _pos_inputs[k][j][2]]\n            one_edge += v_i\n            one_edge += v_j\n            if (env_mode == 'Area'):\n                area_ij = edge_inputs[k][idx]\n                one_edge.append(area_ij)\n                if (area_ij > 0): \n                    mask[i, idx + num_points], mask[j, idx + num_points] = True, True\n                    mask[idx + num_points, i], mask[idx + num_points, j] = True, True\n            if (env_mode == 'DT'):\n                d_ij = edge_inputs[k][idx * 2]\n                t_ij = edge_inputs[k][idx * 2 + 1]\n                one_edge.append(d_ij)\n                one_edge.append(t_ij)\n                if (d_ij > 0): \n                    mask[i, idx + num_points], mask[j, idx + num_points] = True, True\n                    mask[idx + num_points, i], mask[idx + num_points, j] = True, True\n            idx += 1\n            i += 1\n            if i == j:\n                i = 0\n                j += 1\n            one_output.append(one_edge)\n        outputs.append(one_output)\n        masks[k] = mask\n    if (with_act_id):\n        for i in range(masks.shape[1]): masks[..., i, src_len], masks[..., src_len, i] = True, True\n    for i in range(mask.shape[1]): masks[..., i, i] = True\n    return torch.Tensor(outputs).cuda(), masks.cuda()", "\ndef NodeEmbedding(pos_inputs, force_inputs, num_points):\n    _pos_inputs = pos_inputs.reshape(pos_inputs.shape[0], num_points, -1) \n    _force_inputs = force_inputs.reshape(force_inputs.shape[0], num_points, -1)\n    return torch.cat([_pos_inputs, _force_inputs], dim=-1)\n\n# for flat_input, output is a sequence of tuple with size 5, each one is (P1.x, P1.y, P2.x, P2.y, area)\ndef Dim2EdgeEmbedding(flat_input, num_points): #UNUSED\n    UseNormalizationEdge = False\n    if UseNormalizationEdge:\n        NormalizationEdge = 1000\n    else:\n        NormalizationEdge = 1\n    output = []\n    obs_action_dim = flat_input.size()[1]\n    num_edges = int(num_points * (num_points - 1) / 2)\n    obs_dim = num_points * 2 + num_edges\n    act_dim = obs_action_dim - obs_dim\n    fixed_points = int((obs_dim - act_dim) / 2)\n    for one_input in flat_input:\n        points = []\n        changed_points = []\n        for i in range(num_points):\n            points.append([one_input[2 * i], one_input[2 * i + 1]])\n        for i in range(num_points):\n            if i < fixed_points:\n                changed_points.append(points[i])\n            else:\n                changed_points.append([points[i][0] + one_input[(i - fixed_points) * 2 + obs_dim], points[i][1] + one_input[(i - fixed_points) * 2 + obs_dim + 1]])\n\n        together_edges = []\n        edges = []\n        changed_edges = []\n        idx = 2 * num_points\n        changed_idx = obs_dim + 2 * (num_points - fixed_points)\n        i = 0\n        j = 1\n        while idx < obs_dim:\n            one_edge = []\n            one_edge += points[i]\n            one_edge += points[j]\n            one_edge.append(one_input[idx] * NormalizationEdge)\n            edges.append(one_edge)\n            one_changed_edge = []\n            one_changed_edge += changed_points[i]\n            one_changed_edge += changed_points[j]\n            one_changed_edge.append(one_input[changed_idx] * NormalizationEdge + one_input[idx] * NormalizationEdge)\n            changed_edges.append(one_changed_edge)\n            together_edges.append(one_edge)\n            together_edges.append(one_changed_edge)\n            idx += 1\n            changed_idx += 1\n            i += 1\n            if i >= j:\n                j += 1\n                i = 0\n        output.append(edges + [[-1, -1, -1, -1, -1],] + changed_edges)\n    return torch.Tensor(output)", "\nclass Toy_Value_Network(nn.Module):\n    def __init__(self, input_dims, hidden_dims):\n        super(Toy_Value_Network, self).__init__()\n        self.linear1 = nn.Linear(input_dims, hidden_dims)\n        self.ReLU = nn.ReLU()\n        self.linear2 = nn.Linear(hidden_dims, hidden_dims)\n        self.dropout = nn.Dropout(0.2)\n        self.valid_head = nn.Linear(hidden_dims, 2)\n        self.value_head = nn.Linear(hidden_dims, 1)\n\n    def forward(self, *inputs, **kwargs): \n        flat_inputs = torch.cat(inputs, dim = -1).cuda()\n        hidden = self.linear1(flat_inputs)\n        hidden = self.ReLU(self.dropout(hidden))\n        hidden = self.linear2(hidden)\n        hidden = self.ReLU(self.dropout(hidden))\n        valid = self.valid_head(hidden)\n        value = self.value_head(hidden)\n        return valid, value", "\n\nclass TRANSFORMEREMBED_policy(TanhGaussianPolicy):\n    def __init__(self, input_dims, action_dim, hidden_dims, env_dims, env_mode, num_point = None, src_mask = False):\n        super().__init__(obs_dim=input_dims[-1], action_dim = action_dim, hidden_sizes=hidden_dims)\n        self.embed_dim = input_dims[-1]\n        self.env_dims = env_dims\n        self.env_mode = env_mode\n        self.src_mask = src_mask\n        self.num_point = num_point\n        if (env_dims == 2):\n            self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3) #2 pos + 1 force = 3\n            self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=5) #2 * 2 pos + 1 Area = 5\n            self.embed_id = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3)\n            #self.embed_act = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3) # 2 pos + 1 Area = 3\n        if (env_dims == 3 and env_mode == 'Area'):\n            self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=4) #3 pos + 1 force = 4\n            self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=7) #2 * 3 pos + 1 Area = 7\n            self.embed_id = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3) \n            #self.embed_act = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=4) # 3 pos + 1 Area = 4  \n        if (env_dims == 3 and env_mode == 'DT'):\n            self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=4) #3 pos + 1 force = 4\n            self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=8) #2 * 3 pos + 2 dt = 8\n            self.embed_id = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3) \n            #self.embed_act = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=5) # 3 pos + 2 dt = 5  \n        if (src_mask):\n            self.transformer = nn.Transformer(d_model=self.embed_dim, nhead=1, num_encoder_layers=4)\n        else: \n            self.transformer = nn.Transformer(d_model=self.embed_dim, nhead=4, num_encoder_layers=2)\n\n    def forward(self, obs):\n        flat_inputs = obs\n        #print(flat_dim)\n        #print(self.env_dims)\n        #print(flat_inputs.shape)\n        assert(self.num_point != None)\n        if (self.num_point != None): num_points = self.num_point\n        if (self.env_dims == 2):\n            id_inputs = flat_inputs[..., -3:]\n            pos_inputs = flat_inputs[..., :2 * num_points]\n            force_inputs = flat_inputs[..., -3 - num_points: -3]\n            edge_inputs = flat_inputs[..., 2 * num_points: -3 - num_points]\n        if (self.env_dims == 3 and self.env_mode == 'Area'):\n            id_inputs = flat_inputs[..., -3:]\n            pos_inputs = flat_inputs[..., :3 * num_points]\n            force_inputs = flat_inputs[..., -3 - num_points: -3]\n            edge_inputs = flat_inputs[..., 3 * num_points: -3 - num_points]\n        if (self.env_dims == 3 and self.env_mode == 'DT'):\n            id_inputs = flat_inputs[..., -3:]\n            pos_inputs = flat_inputs[..., :3 * num_points]\n            force_inputs = flat_inputs[..., -3 - num_points: -3]\n            edge_inputs = flat_inputs[..., 3 * num_points: -3 - num_points]\n\n        node_outputs = NodeEmbedding(pos_inputs, force_inputs, num_points).cuda()\n        embed_node_outputs = self.embed_node(node_outputs)\n        #print(node_outputs.shape, embed_node_outputs.shape)\n        edge_outputs, src_mask = EdgeEmbedding_with_Mask(pos_inputs, edge_inputs, num_points, self.env_dims, self.env_mode, with_act_id = True)\n        edge_outputs.cuda() \n        src_mask.cuda()\n        embed_edge_outputs = self.embed_edge(edge_outputs)\n        #print(edge_outputs.shape, embed_edge_outputs.shape)\n        embed_id_outputs = self.embed_id(id_inputs).unsqueeze(1)\n        #embed_act_outputs = self.embed_act(act_inputs).unsqueeze(1)\n        #print(embed_id_outputs.shape, embed_act_outputs.shape)\n        src = torch.cat([embed_node_outputs, embed_edge_outputs, embed_id_outputs], dim=1).transpose(0, 1)\n        #print(src.shape)\n        tgt = embed_id_outputs.transpose(0, 1)\n        #print(tgt.shape)\n        #print(src_mask.shape)\n        #print(src_mask[0])\n        if (not self.src_mask): src_mask = None\n        if (src_mask != None): src_mask = ~src_mask\n        outs = self.transformer(src, tgt, src_mask = src_mask).transpose(0, 1).squeeze(dim=1)\n        #print(outs[0])\n        return super().forward(outs)", "    \n\nif __name__ == '__main__':\n    qf = TRANSFORMEREMBED([128, 256], [256, 512], 3, 'Area', 7).cuda()\n    qf(torch.ones(1, 39).cuda())\n"]}
{"filename": "Stage2/models/value_function/__init__.py", "chunked_list": ["from .mlp import MLP, TRANSFORMEREMBED, Transformer_Value_Network, Toy_Value_Network, TRANSFORMEREMBED_policy\nfrom .mlp_GNN import GNNEMBED, GNNEMBED_policy"]}
{"filename": "Stage2/models/value_function/mlp_GNN.py", "chunked_list": ["import torch, os, math\nimport numpy as np\nfrom torch_geometric.nn import GCNConv\nfrom torch import nn\nfrom torch.nn import functional as F\nfrom rlkit.policies.base import Policy\nfrom rlkit.pythonplusplus import identity\nfrom rlkit.torch import pytorch_util as ptu\nfrom rlkit.torch.core import PyTorchModule, eval_np\nfrom rlkit.torch.data_management.normalizer import TorchFixedNormalizer", "from rlkit.torch.core import PyTorchModule, eval_np\nfrom rlkit.torch.data_management.normalizer import TorchFixedNormalizer\nfrom rlkit.torch.networks import LayerNorm, ConcatMlp, Mlp\nfrom rlkit.torch.pytorch_util import activation_from_string\nfrom torch_geometric.nn import CGConv\nfrom rlkit.torch.sac.policies import TanhGaussianPolicy\nfrom torch_geometric.data import Data\n\nclass MLP(ConcatMlp):\n    def __init__(self, input_dim, hidden_dims):\n        super().__init__(input_size=input_dim, output_size=1, hidden_sizes=hidden_dims)", "class MLP(ConcatMlp):\n    def __init__(self, input_dim, hidden_dims):\n        super().__init__(input_size=input_dim, output_size=1, hidden_sizes=hidden_dims)\n\nclass _Mlp(Mlp):\n    def __init__(self, *args, dim=1, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.dim = dim\n\nclass id_to_point:\n    def __init__(self, num_point):\n        self.trans = []\n        u, v = 0, 1\n        while (v < num_point):\n            self.trans.append([u, v])\n            v += 1\n            if (v == num_point): u, v = u + 1, u + 2\n    def convert(self, id):\n        return self.trans[id]", "\nclass id_to_point:\n    def __init__(self, num_point):\n        self.trans = []\n        u, v = 0, 1\n        while (v < num_point):\n            self.trans.append([u, v])\n            v += 1\n            if (v == num_point): u, v = u + 1, u + 2\n    def convert(self, id):\n        return self.trans[id]", "    \nclass GNNEMBED(_Mlp):\n    r\"\"\"\n        represented by graph --> GCN --> MLP to dim 1\n    \"\"\"\n    def __init__(self, input_dims, hidden_dims, env_dims, env_mode, num_point):\n        super().__init__(input_size=input_dims[-1], output_size=1, hidden_sizes=hidden_dims)\n        self.trans = id_to_point(num_point)\n        self.embed_dim = input_dims[-1]\n        self.env_dims = env_dims\n        self.env_mode = env_mode\n        #print(input_dims[-1])\n        #print(input_dims[:-1])\n        if (env_dims == 2):\n            self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3) #2 pos + 1 force = 3\n            self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=5) #2 * 2 pos + 1 Area = 5\n            self.embed_id = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3)\n            self.embed_act = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3) # 2 pos + 1 Area = 3\n        if (env_dims == 3 and env_mode == 'Area'):\n            self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=4) #3 pos + 1 force = 4\n            self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=7) #2 * 3 pos + 1 Area = 7\n            self.embed_id = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3) # No change!!!\n            self.embed_act = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=4) # 3 pos + 1 Area = 4     \n        if (env_dims == 3 and env_mode == 'DT'):\n            self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=4) #3 pos + 1 force = 4\n            self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=8) #2 * 3 pos + 2 dt = 8\n            self.embed_id = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3) # No change!!!\n            self.embed_act = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=5) # 3 pos + 2 dt = 5     \n        if (env_mode == 'DT'):\n            dim = 2\n        else: dim = 1\n        self.gcn1 = CGConv(channels=self.embed_dim, dim = dim)\n        self.gcn2 = CGConv(channels=self.embed_dim, dim = dim)\n        self.gcn3 = CGConv(channels=self.embed_dim, dim = dim)\n        self.point_query = nn.Linear(self.embed_dim, self.embed_dim)\n        self.edge_query = nn.Linear(2 * self.embed_dim, self.embed_dim)\n        self.greedy_query = nn.Linear(self.embed_dim, self.embed_dim)\n        self.mix_graph_action = nn.Linear(2 * self.embed_dim, self.embed_dim)\n\n    def forward(self, *inputs, **kwargs):\n        flat_inputs = torch.cat(inputs, dim=self.dim).cuda()\n        flat_dim = flat_inputs.shape[1]\n\n        if (self.env_dims == 2):\n            act_inputs = flat_inputs[..., -3:]\n            id_inputs = flat_inputs[..., -6: -3]\n            num_points = int((math.sqrt(25 + 8 * (flat_dim - 6)) - 5) / 2)\n            pos_inputs = flat_inputs[..., :2 * num_points]\n            force_inputs = flat_inputs[..., -6 - num_points: -6]\n            edge_inputs = flat_inputs[..., 2 * num_points: -6 - num_points]\n            \n        if (self.env_dims == 3 and self.env_mode == 'Area'):\n            act_inputs = flat_inputs[..., -4:]\n            id_inputs = flat_inputs[..., -7: -4]\n            num_points = int((math.sqrt(49 + 8 * (flat_dim - 7)) - 7) / 2)\n            #1/2 * (-7 + sqrt(49 + 8n))\n            pos_inputs = flat_inputs[..., :3 * num_points]\n            force_inputs = flat_inputs[..., -7 - num_points: -7]\n            edge_inputs = flat_inputs[..., 3 * num_points: -7 - num_points]\n\n        if (self.env_dims == 3 and self.env_mode == 'DT'):\n            act_inputs = flat_inputs[..., -5:]\n            id_inputs = flat_inputs[..., -8: -5]\n            num_points = int((math.sqrt(9 + 4 * (flat_dim - 8)) - 3) / 2)\n            #1 / 2 * (-3 + sqrt(9 + 4n))\n            pos_inputs = flat_inputs[..., :3 * num_points]\n            force_inputs = flat_inputs[..., -8 - num_points: -8]\n            edge_inputs = flat_inputs[..., 3 * num_points: -8 - num_points]\n\n        node_outputs = NodeEmbedding(pos_inputs, force_inputs, num_points).cuda()\n        embed_node_outputs = self.embed_node(node_outputs)\n        edge_id, edge_feature = Edge_IndexEmbedding(pos_inputs, edge_inputs, num_points, self.env_dims, self.env_mode)\n        embed_graph_outs = torch.zeros(flat_inputs.shape[0], self.embed_dim).cuda()\n        for i in range(flat_inputs.shape[0]):\n            graph_data = Data(x = embed_node_outputs[i], edge_index = edge_id[i].transpose(0, 1), edge_attr = edge_feature[i])\n            graph_out = self.gcn1(x=graph_data.x, edge_index=graph_data.edge_index, edge_attr=graph_data.edge_attr)\n            graph_data = Data(x = graph_out, edge_index = edge_id[i].transpose(0, 1), edge_attr = edge_feature[i])\n            graph_out = self.gcn2(x=graph_data.x, edge_index=graph_data.edge_index, edge_attr=graph_data.edge_attr)\n            graph_data = Data(x = graph_out, edge_index = edge_id[i].transpose(0, 1), edge_attr = edge_feature[i])\n            graph_out = self.gcn3(x=graph_data.x, edge_index=graph_data.edge_index, edge_attr=graph_data.edge_attr)\n            #print(edge_outputs.shape, embed_edge_outputs.shape)\n            if (id_inputs[i, 0] != -1):\n                embed_graph_out = self.point_query(graph_out[int(id_inputs[i, 0])])\n            if (id_inputs[i, 1] != -1):\n                u, v = self.trans.convert(int(id_inputs[i, 1]))\n                embed_graph_out = self.edge_query(torch.cat((graph_out[u], graph_out[v])))\n            if (id_inputs[i, 2] != -1):\n                embed_graph_out = self.greedy_query(torch.max(graph_out, dim = -2)[0])\n            embed_graph_outs[i] = embed_graph_out\n        embed_act_outputs = self.embed_act(act_inputs)\n        feature = self.mix_graph_action(torch.cat((embed_graph_outs, embed_act_outputs), dim = -1))\n        x = super().forward(feature, **kwargs)\n        return x", "            \nclass GNNEMBED_policy(TanhGaussianPolicy):\n    r\"\"\"\n        represented by graph --> GCN --> MLP to dim 1\n    \"\"\"\n    def __init__(self, input_dims, action_dim, hidden_dims, env_dims, env_mode, num_point):\n        super().__init__(obs_dim=input_dims[-1], action_dim = action_dim, hidden_sizes=hidden_dims)\n        self.trans = id_to_point(num_point)\n        self.embed_dim = input_dims[-1]\n        self.env_dims = env_dims\n        self.env_mode = env_mode\n        self.num_point = num_point\n        if (env_dims == 2):\n            self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3) #2 pos + 1 force = 3\n            self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=5) #2 * 2 pos + 1 Area = 5\n            self.embed_id = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3)\n            self.embed_act = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3) # 2 pos + 1 Area = 3\n        if (env_dims == 3 and env_mode == 'Area'):\n            self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=4) #3 pos + 1 force = 4\n            self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=7) #2 * 3 pos + 1 Area = 7\n            self.embed_id = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3)\n            self.embed_act = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=4) # 3 pos + 1 Area = 4     \n        if (env_dims == 3 and env_mode == 'DT'):\n            self.embed_node = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=4) #3 pos + 1 force = 4\n            self.embed_edge = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=8) #2 * 3 pos + 2 dt = 8\n            self.embed_id = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=3)\n            self.embed_act = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=5) # 3 pos + 2 dt = 5\n        if (env_mode == 'DT'):\n            dim = 2\n        else: dim = 1\n        self.gcn1 = CGConv(channels=self.embed_dim, dim = dim)\n        self.gcn2 = CGConv(channels=self.embed_dim, dim = dim)\n        self.gcn3 = CGConv(channels=self.embed_dim, dim = dim)\n        self.point_query = nn.Linear(self.embed_dim, self.embed_dim)\n        self.edge_query = nn.Linear(2 * self.embed_dim, self.embed_dim)\n        self.greedy_query = nn.Linear(self.embed_dim, self.embed_dim)\n        self.mix_graph_action = nn.Linear(self.embed_dim, self.embed_dim)\n\n    def forward(self, obs):\n        flat_inputs = obs\n        num_points  = self.num_point\n        if (self.env_dims == 2):\n            id_inputs = flat_inputs[..., -3:]\n            pos_inputs = flat_inputs[..., :2 * num_points]\n            force_inputs = flat_inputs[..., -3 - num_points: -3]\n            edge_inputs = flat_inputs[..., 2 * num_points: -3 - num_points]\n            \n        if (self.env_dims == 3 and self.env_mode == 'Area'):\n            id_inputs = flat_inputs[..., -3:]\n            pos_inputs = flat_inputs[..., :3 * num_points]\n            force_inputs = flat_inputs[..., -3 - num_points: -3]\n            edge_inputs = flat_inputs[..., 3 * num_points: -3 - num_points]\n\n        if (self.env_dims == 3 and self.env_mode == 'DT'):\n            id_inputs = flat_inputs[..., -3:]\n            pos_inputs = flat_inputs[..., :3 * num_points]\n            force_inputs = flat_inputs[..., -3 - num_points: -3]\n            edge_inputs = flat_inputs[..., 3 * num_points: -3 - num_points]\n\n        node_outputs = NodeEmbedding(pos_inputs, force_inputs, num_points).cuda()\n        embed_node_outputs = self.embed_node(node_outputs)\n        edge_id, edge_feature = Edge_IndexEmbedding(pos_inputs, edge_inputs, num_points, self.env_dims, self.env_mode)\n        embed_graph_outs = torch.zeros(flat_inputs.shape[0], self.embed_dim).cuda()\n        for i in range(flat_inputs.shape[0]):\n            graph_data = Data(x = embed_node_outputs[i], edge_index = edge_id[i].transpose(0, 1), edge_attr = edge_feature[i])\n            graph_out = self.gcn1(x=graph_data.x, edge_index=graph_data.edge_index, edge_attr=graph_data.edge_attr)\n            graph_data = Data(x = graph_out, edge_index = edge_id[i].transpose(0, 1), edge_attr = edge_feature[i])\n            graph_out = self.gcn2(x=graph_data.x, edge_index=graph_data.edge_index, edge_attr=graph_data.edge_attr)\n            graph_data = Data(x = graph_out, edge_index = edge_id[i].transpose(0, 1), edge_attr = edge_feature[i])\n            graph_out = self.gcn3(x=graph_data.x, edge_index=graph_data.edge_index, edge_attr=graph_data.edge_attr)\n            #print(edge_outputs.shape, embed_edge_outputs.shape)\n            if (id_inputs[i, 0] != -1):\n                embed_graph_out = self.point_query(graph_out[int(id_inputs[i, 0])])\n            if (id_inputs[i, 1] != -1):\n                u, v = self.trans.convert(int(id_inputs[i, 1]))\n                embed_graph_out = self.edge_query(torch.cat((graph_out[u], graph_out[v])))\n            if (id_inputs[i, 2] != -1):\n                embed_graph_out = self.greedy_query(torch.max(graph_out, dim = -2)[0])\n            embed_graph_outs[i] = embed_graph_out\n        feature = self.mix_graph_action(embed_graph_outs)\n        x = super().forward(feature)\n        return x", "\ndef EdgeEmbedding(pos_inputs, edge_inputs, num_points, env_dims = 2, env_mode = 'Area'):# TODO:check it\n    _pos_inputs = pos_inputs.reshape(pos_inputs.shape[0], num_points, -1)\n    outputs = []\n    for k in range(_pos_inputs.shape[0]):\n        one_output = []\n        idx = 0\n        i = 0\n        j = 1\n        while idx < num_points * (num_points - 1) / 2:\n            one_edge = []\n            v_i = [_pos_inputs[k][i][0], _pos_inputs[k][i][1]]\n            v_j = [_pos_inputs[k][j][0], _pos_inputs[k][j][1]]\n            if (env_dims == 3):\n                v_i = [_pos_inputs[k][i][0], _pos_inputs[k][i][1], _pos_inputs[k][i][2]]\n                v_j = [_pos_inputs[k][j][0], _pos_inputs[k][j][1], _pos_inputs[k][j][2]]\n            one_edge += v_i\n            one_edge += v_j\n            if (env_mode == 'Area'):\n                area_ij = edge_inputs[k][idx]\n                one_edge.append(area_ij)\n            if (env_mode == 'DT'):\n                d_ij = edge_inputs[k][idx * 2]\n                t_ij = edge_inputs[k][idx * 2 + 1]\n                one_edge.append(d_ij)\n                one_edge.append(t_ij)\n            idx += 1\n            j += 1\n            if j == num_points:\n                i += 1\n                j = i + 1\n            one_output.append(one_edge)\n        outputs.append(one_output)\n    return torch.Tensor(outputs) # k * (num * (num - 1) / 2) * 8", "\ndef Edge_IndexEmbedding(pos_inputs, edge_inputs, num_points, env_dims = 2, env_mode = 'Area'):# TODO:check it\n    _pos_inputs = pos_inputs.reshape(pos_inputs.shape[0], num_points, -1)\n    outputs = []\n    feature_outputs = []\n    for k in range(_pos_inputs.shape[0]):\n        one_output = []\n        one_feature_output = []\n        idx = 0\n        i = 0\n        j = 1\n        while idx < num_points * (num_points - 1) / 2:\n            if (env_mode == 'Area' and edge_inputs[k][idx] > 0): \n                one_output.append([i, j])\n                one_feature_output.append([edge_inputs[k][idx]])\n            if (env_mode == 'DT' and edge_inputs[k][idx * 2] > 0): \n                one_output.append([i, j])\n                one_feature_output.append([edge_inputs[k][idx * 2], edge_inputs[k][idx * 2 + 1]])\n            idx += 1\n            j += 1\n            if j == num_points:\n                i += 1\n                j = i + 1\n        outputs.append(torch.tensor(one_output).cuda())\n        feature_outputs.append(torch.tensor(one_feature_output).cuda())\n    return outputs, feature_outputs", "\ndef EdgeEmbedding_with_Mask(pos_inputs, edge_inputs, num_points, env_dims = 2, env_mode = 'Area'):\n    _pos_inputs = pos_inputs.reshape(pos_inputs.shape[0], num_points, -1)\n    outputs = []\n    src_len = num_points + num_points * (num_points - 1) // 2\n    masks = torch.zeros((pos_inputs.shape[0], src_len, src_len), dtype = bool)\n    for k in range(_pos_inputs.shape[0]):\n        mask = torch.zeros((src_len, src_len), dtype = bool)\n        one_output = []\n        idx = 0\n        i, j = 0, 1\n        while idx < num_points * (num_points - 1) // 2:\n            one_edge = []\n            v_i = [_pos_inputs[k][i][0], _pos_inputs[k][i][1]]\n            v_j = [_pos_inputs[k][j][0], _pos_inputs[k][j][1]]\n            if (env_dims == 3):\n                v_i = [_pos_inputs[k][i][0], _pos_inputs[k][i][1], _pos_inputs[k][i][2]]\n                v_j = [_pos_inputs[k][j][0], _pos_inputs[k][j][1], _pos_inputs[k][j][2]]\n            one_edge += v_i\n            one_edge += v_j\n            if (env_mode == 'Area'):\n                area_ij = edge_inputs[k][idx]\n                one_edge.append(area_ij)\n                if (area_ij > 0): \n                    mask[i, idx + num_points], mask[j, idx + num_points] = True, True\n                    mask[idx + num_points, i], mask[idx + num_points, j] = True, True\n            if (env_mode == 'DT'):\n                d_ij = edge_inputs[k][idx * 2]\n                t_ij = edge_inputs[k][idx * 2 + 1]\n                one_edge.append(d_ij)\n                one_edge.append(t_ij)\n                if (d_ij > 0): \n                    mask[i, idx + num_points], mask[j, idx + num_points] = True, True\n                    mask[idx + num_points, i], mask[idx + num_points, j] = True, True\n            idx += 1\n            i += 1\n            if i == j:\n                i = 0\n                j += 1\n            one_output.append(one_edge)\n        outputs.append(one_output)\n        masks[k] = mask\n    return torch.Tensor(outputs).cuda(), masks.cuda()", "\ndef NodeEmbedding(pos_inputs, force_inputs, num_points): #TODO: check it \n    _pos_inputs = pos_inputs.reshape(pos_inputs.shape[0], num_points, -1) \n    _force_inputs = force_inputs.reshape(force_inputs.shape[0], num_points, -1)\n    return torch.cat([_pos_inputs, _force_inputs], dim=-1)\n\n# for flat_input, output is a sequence of tuple with size 5, each one is (P1.x, P1.y, P2.x, P2.y, area)\ndef Dim2EdgeEmbedding(flat_input, num_points): #UNUSED\n    UseNormalizationEdge = False\n    if UseNormalizationEdge:\n        NormalizationEdge = 1000\n    else:\n        NormalizationEdge = 1\n    output = []\n    obs_action_dim = flat_input.size()[1]\n    num_edges = int(num_points * (num_points - 1) / 2)\n    obs_dim = num_points * 2 + num_edges\n    act_dim = obs_action_dim - obs_dim\n    fixed_points = int((obs_dim - act_dim) / 2)\n    for one_input in flat_input:\n        points = []\n        changed_points = []\n        for i in range(num_points):\n            points.append([one_input[2 * i], one_input[2 * i + 1]])\n        for i in range(num_points):\n            if i < fixed_points:\n                changed_points.append(points[i])\n            else:\n                changed_points.append([points[i][0] + one_input[(i - fixed_points) * 2 + obs_dim], points[i][1] + one_input[(i - fixed_points) * 2 + obs_dim + 1]])\n\n        together_edges = []\n        edges = []\n        changed_edges = []\n        idx = 2 * num_points\n        changed_idx = obs_dim + 2 * (num_points - fixed_points)\n        i = 0\n        j = 1\n        while idx < obs_dim:\n            one_edge = []\n            one_edge += points[i]\n            one_edge += points[j]\n            one_edge.append(one_input[idx] * NormalizationEdge)\n            edges.append(one_edge)\n            one_changed_edge = []\n            one_changed_edge += changed_points[i]\n            one_changed_edge += changed_points[j]\n            one_changed_edge.append(one_input[changed_idx] * NormalizationEdge + one_input[idx] * NormalizationEdge)\n            changed_edges.append(one_changed_edge)\n            together_edges.append(one_edge)\n            together_edges.append(one_changed_edge)\n            idx += 1\n            changed_idx += 1\n            i += 1\n            if i >= j:\n                j += 1\n                i = 0\n        output.append(edges + [[-1, -1, -1, -1, -1],] + changed_edges)\n        #output.append(together_edges)\n    return torch.Tensor(output)", "\nclass Toy_Value_Network(nn.Module):\n    def __init__(self, input_dims, hidden_dims):\n        super(Toy_Value_Network, self).__init__()\n        self.linear1 = nn.Linear(input_dims, hidden_dims)\n        self.ReLU = nn.ReLU()\n        self.linear2 = nn.Linear(hidden_dims, hidden_dims)\n        self.dropout = nn.Dropout(0.2)\n        self.valid_head = nn.Linear(hidden_dims, 2)\n        self.value_head = nn.Linear(hidden_dims, 1)\n\n    def forward(self, *inputs, **kwargs): \n        flat_inputs = torch.cat(inputs, dim = -1).cuda()\n        hidden = self.linear1(flat_inputs)\n        hidden = self.ReLU(self.dropout(hidden))\n        hidden = self.linear2(hidden)\n        hidden = self.ReLU(self.dropout(hidden))\n        valid = self.valid_head(hidden)\n        value = self.value_head(hidden)\n        return valid, value", "\nif __name__ == '__main__':\n    qf = GNNEMBED([128, 256], [256, 512], 3, 'Area', 7).cuda()\n    qf(torch.ones(1, 39).cuda())\n"]}
{"filename": "Stage2/models/value_function/mlp_autoregression.py", "chunked_list": ["import torch, os, math\nimport numpy as np\nfrom torch import nn\nfrom torch.nn import functional as F\nfrom rlkit.policies.base import Policy\nfrom rlkit.pythonplusplus import identity\nfrom rlkit.torch import pytorch_util as ptu\nfrom rlkit.torch.core import PyTorchModule, eval_np\nfrom rlkit.torch.data_management.normalizer import TorchFixedNormalizer\nfrom rlkit.torch.networks import LayerNorm, ConcatMlp, Mlp", "from rlkit.torch.data_management.normalizer import TorchFixedNormalizer\nfrom rlkit.torch.networks import LayerNorm, ConcatMlp, Mlp\nfrom rlkit.torch.pytorch_util import activation_from_string\n\nclass MLP(ConcatMlp):\n    def __init__(self, input_dim, hidden_dims):\n        super().__init__(input_size=input_dim, output_size=1, hidden_sizes=hidden_dims)\n\nclass _Mlp(Mlp):\n    def __init__(self, *args, dim=1, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.dim = dim", "class _Mlp(Mlp):\n    def __init__(self, *args, dim=1, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.dim = dim\n\nclass TRANSFORMEREMBED(_Mlp):\n    \"\"\"\n        represented by edge sequences --> MLP embed to high dim --> transformer --> MLP to dim 1\n    \"\"\"\n    def __init__(self, input_dims, hidden_dims):\n        super().__init__(input_size=input_dims[-1], output_size=1, hidden_sizes=hidden_dims)\n        self.embed_dim = input_dims[-1]\n        #print(input_dims[-1])\n        #print(input_dims[:-1])\n        self.embed = Mlp(hidden_sizes=input_dims[:-1], output_size=self.embed_dim, input_size=5)\n        self.transformer = nn.Transformer(d_model=self.embed_dim, nhead=4, num_encoder_layers=2)\n\n    def forward(self, *inputs, **kwargs):\n        flat_inputs = torch.cat(inputs, dim=self.dim)\n        obs_dim = inputs[0].shape[1]\n        num_points = int((math.sqrt(9 + 8 * (obs_dim - 2)) -  3) / 2)\n        outputs = Dim2EdgeEmbedding(flat_inputs, num_points).transpose(0, 1).cuda()\n        #print('1', outputs.shape)\n        outputs = self.embed(outputs)\n        #print('2', outputs.shape)\n        tgt = (torch.ones((outputs.shape[1], 1, self.embed_dim)).transpose(0, 1) / math.sqrt(self.embed_dim)).cuda()\n        #print('3', tgt)\n        outs = self.transformer(outputs, tgt).transpose(0, 1).squeeze(dim=1)\n        #print('4', outs)\n        #print('outs shape', outs.shape)\n        return super().forward(outs, **kwargs)", "\n\n# for flat_input, output is a sequence of tuple with size 5, each one is (P1.x, P1.y, P2.x, P2.y, area)\ndef Dim2EdgeEmbedding(flat_input, num_points):\n    output = []\n    obs_action_dim = flat_input.size()[1]\n    num_edges = int(num_points * (num_points - 1) / 2)\n    obs_dim = num_points * 2 + num_edges\n    act_dim = obs_action_dim - obs_dim\n    fixed_points = int((obs_dim - act_dim) / 2)\n    for one_input in flat_input:\n        for i in one_input:\n            print(i)\n        os._exit(0)\n        points = []\n        changed_points = []\n        for i in range(num_points):\n            points.append([one_input[2 * i], one_input[2 * i + 1]])\n        for i in range(num_points):\n            if i < fixed_points:\n                changed_points.append(points[i])\n            else:\n                changed_points.append([points[i][0] + one_input[(i - fixed_points) * 2 + obs_dim], points[i][1] + one_input[(i - fixed_points) * 2 + obs_dim + 1]])\n\n        together_edges = []\n        edges = []\n        changed_edges = []\n        idx = 2 * num_points\n        changed_idx = obs_dim + 2 * (num_points - fixed_points)\n        i = 0\n        j = 1\n        while idx < obs_dim:\n            one_edge = []\n            one_edge += points[i]\n            one_edge += points[j]\n            one_edge.append(one_input[idx])\n            edges.append(one_edge)\n            one_changed_edge = []\n            one_changed_edge += changed_points[i]\n            one_changed_edge += changed_points[j]\n            one_changed_edge.append(one_input[changed_idx] + one_input[idx])\n            changed_edges.append(one_changed_edge)\n            together_edges.append(one_edge)\n            together_edges.append(one_changed_edge)\n            idx += 1\n            changed_idx += 1\n            i += 1\n            if i >= j:\n                j += 1\n                i = 0\n        output.append(edges + [[-1, -1, -1, -1, -1],] + changed_edges)\n        #output.append(together_edges)\n    return torch.Tensor(output)", ""]}
{"filename": "Stage2/envs/env_test.py", "chunked_list": ["from .env import Truss\n\n\nif __name__ == '__main__':\n    num_points = 6\n    initial_state_files = 'best_results'\n    coordinate_range = [(0.0, 18.288), (0.0, 9.144)]\n    area_range = (6.452e-05, 0.02)\n    coordinate_delta_range = [(-0.5715, 0.5715), (-0.5715, 0.5715)]\n    area_delta_range = (-0.0005, 0.0005)\n    fixed_points = 4\n    variable_edges = -1\n    max_refine_steps = 1000\n    env = Truss(num_points, initial_state_files, coordinate_range, area_range, coordinate_delta_range, area_delta_range, fixed_points, variable_edges, max_refine_steps)\n    while True:\n        env.reset()", ""]}
{"filename": "Stage2/envs/space.py", "chunked_list": ["import numpy as np\nimport gym\n\n\nclass ActionSpace(gym.spaces.Box):\n    def __init__(\n        self,\n        num_points,\n        coordinate_delta_range,\n        area_delta_range,\n        fixed_points,\n        variable_edges,\n    ):\n        r'''\n        :param num_points: Total number of points\n        :param coordinate_delta_range: Actions' coordinate delta range, a list of length D, where D is the dimension of the environment, each element is a tuple of (low, high)\n        :param area_delta_range: Actions' area delta range (low, high)\n        :param fixed_points: Number of points whose coordinate cannot be modified (first #fixed_points nodes)\n        :param variable_edges: Number of edges whose area can be modified, -1 if all can be modified (first #variable_edges edges)\n        '''\n        single_low = [cr[0] for cr in coordinate_delta_range]\n        single_high = [cr[1] for cr in coordinate_delta_range]\n        low = []\n        high = []\n        edge_num = num_points * (num_points - 1) // 2\n        if variable_edges != -1:\n            edge_num = variable_edges\n        for _ in range(num_points - fixed_points):\n            low += single_low\n            high += single_high\n        for _ in range(edge_num):\n            low.append(area_delta_range[0])\n            high.append(area_delta_range[1])\n        super().__init__(low=np.array(low), high=np.array(high), dtype=np.float64)", "\n\nclass AutoregressiveEnvActionSpace(gym.spaces.Box): #TODO: change area into d, t \n    def __init__(\n        self,\n        coordinate_delta_range,\n        range1,\n        range2 = None,\n    ):\n        r'''\n        :param coordinate_delta_range: Actions' coordinate delta range, a list of length D, where D is the dimension of the environment, each element is a tuple of (low, high)\n        :param area_delta_range: Actions' area delta range (low, high)\n        '''\n        low = [cr[0] for cr in coordinate_delta_range]\n        high = [cr[1] for cr in coordinate_delta_range]\n        low.append(range1[0])\n        high.append(range1[1])\n        if (range2 != None):\n            low.append(range2[0])\n            high.append(range2[1])\n        super().__init__(low=np.array(low), high=np.array(high), dtype=np.float64)", "\n\nclass StateObservationSpace(gym.spaces.Box):\n    def __init__(\n        self,\n        num_points,\n        coordinate_range,\n        range1,\n        range2 = None,\n    ):\n        r'''\n        :param num_points: Total number of points\n        :param coordinate_range: nodes' coordinate range, a list of length D, where D is the dimension of the environment, each element is a tuple of (low, high)\n        :param area_range: edges' area range (low, high)\n        '''\n        single_low = [cr[0] for cr in coordinate_range]\n        single_high = [cr[1] for cr in coordinate_range]\n        low = []\n        high = []\n        edge_num = num_points * (num_points - 1) // 2\n        for _ in range(num_points):\n            low += single_low\n            high += single_high\n        for _ in range(edge_num):\n            low.append(range1[0])\n            high.append(range1[1])\n            if (range2 != None):\n                low.append(range2[0])\n                high.append(range2[1])\n        super().__init__(low=np.array(low), high=np.array(high), dtype=np.float64)", "\n\nclass AutoregressiveEnvObservationSpace(gym.spaces.Box):\n    def __init__(\n        self,\n        num_points,\n        coordinate_range,\n        range1,\n        range2 = None,\n    ):\n        r'''\n        :param num_points: Total number of points\n        :param coordinate_range: nodes' coordinate range, a list of length D, where D is the dimension of the environment, each element is a tuple of (low, high)\n        :param area_range: edges' area range (low, high)\n        '''\n        single_low = [cr[0] for cr in coordinate_range]\n        single_high = [cr[1] for cr in coordinate_range]\n        low = []\n        high = []\n        edge_num = num_points * (num_points - 1) // 2\n        for _ in range(num_points):\n            low += single_low\n            high += single_high\n        for _ in range(edge_num):\n            low.append(range1[0])\n            high.append(range1[1])\n            if (range2 != None):\n                low.append(range2[0])\n                high.append(range2[1])\n        for _ in range(num_points):\n            low.append(-1000000)\n            high.append(1000000)\n        low.append(-1)\n        high.append(num_points)\n        low.append(-1)\n        high.append(num_points * (num_points - 1) // 2)\n        low.append(-1)\n        high.append(1)\n        super().__init__(low=np.array(low), high=np.array(high), dtype=np.float64)"]}
{"filename": "Stage2/envs/state.py", "chunked_list": ["import numpy as np\n\n\nclass State:\n    def __init__(self, num_points, dimension, env_mode):\n        self.num_points = num_points\n        self.dimension = dimension\n        self.env_mode = env_mode\n        self.nodes = -np.ones((num_points, dimension), dtype=np.float64)\n        if (env_mode == 'Area'):\n            self.edges = -np.ones((num_points, num_points), dtype=np.float64)\n        if (env_mode == 'DT'):\n            self.edges = -np.ones((num_points, num_points, 2), dtype=np.float64)\n\n    def obs(self, nonexistent_edge = -1):\n        r'''\n        transfer self.state to observation\n        :param nonexistent_edge: area value of nonexistent edge\n        :return: list, a tuple containing nodes coordinates and edges area\n        '''\n        if (self.env_mode == 'Area'):\n            obs = np.zeros(self.num_points * self.dimension + self.num_points * (self.num_points - 1) // 2, dtype=np.float64)\n            for i in range(self.num_points):\n                obs[i * self.dimension: (i + 1) * self.dimension] = self.nodes[i]\n            loc = self.num_points * self.dimension\n            for i in range(self.num_points):\n                for j in range(i + 1, self.num_points):\n                    obs[loc] = nonexistent_edge if self.edges[i][j] < 0 else self.edges[i][j]\n                    loc += 1\n        elif (self.env_mode == 'DT'):\n            obs = np.zeros(self.num_points * self.dimension + self.num_points * (self.num_points - 1), dtype=np.float64)\n            for i in range(self.num_points):\n                obs[i * self.dimension: (i + 1) * self.dimension] = self.nodes[i]\n            loc = self.num_points * self.dimension\n            for i in range(self.num_points):\n                for j in range(i + 1, self.num_points):\n                    obs[loc: loc + 2] = nonexistent_edge if self.edges[i][j][0] < 0 else self.edges[i][j][0 : 2]\n                    loc += 2\n        return obs\n\n    def set(self, obs):\n        r'''\n        set self.state according to obs, do not set nonexistent edges. Warning: obs must set 1 for nonexistent edges\n        :param obs: observation\n        :return: None\n        '''\n        for i in range(self.num_points):\n            self.nodes[i] = obs[i * self.dimension: (i + 1) * self.dimension]\n\n        loc = self.num_points * self.dimension\n        if (self.env_mode == 'Area'):\n            for i in range(self.num_points):\n                for j in range(i + 1, self.num_points):\n                    self.edges[i][j] = obs[loc]\n                    self.edges[j][i] = obs[loc]\n                    loc += 1\n        elif (self.env_mode == 'DT'):\n            for i in range(self.num_points):\n                for j in range(i + 1, self.num_points):\n                    self.edges[i][j][0] = obs[loc]\n                    self.edges[j][i][0] = obs[loc]\n                    self.edges[i][j][1] = obs[loc + 1]\n                    self.edges[j][i][1] = obs[loc + 1]\n                    loc += 2\n\n    def print(self):\n        for i in range(self.num_points):\n            print(self.nodes[i])\n\n        if (self.env_mode == 'Area'):\n            for i in range(self.num_points):\n                for j in range(i + 1, self.num_points):\n                    print(i, j, self.edges[i][j])\n        if (self.env_mode == 'DT'):\n            for i in range(self.num_points):\n                for j in range(i + 1, self.num_points):\n                    print(i, j, self.edges[i][j][0], self.edges[i][j][1])", ""]}
{"filename": "Stage2/envs/__init__.py", "chunked_list": ["from .env import Truss\n"]}
{"filename": "Stage2/envs/env.py", "chunked_list": ["import gym\nimport copy\nimport os\nimport numpy as np\nimport random\n\nfrom collections import OrderedDict\nfrom .space import StateObservationSpace, AutoregressiveEnvObservationSpace, AutoregressiveEnvActionSpace, ActionSpace\nfrom utils.utils import is_edge_addable, readFile, getlen2, save_file, save_trajectory\nfrom truss_envs.dynamic import DynamicModel", "from utils.utils import is_edge_addable, readFile, getlen2, save_file, save_trajectory\nfrom truss_envs.dynamic import DynamicModel\nfrom .state import State\n\nclass Truss(gym.Env):\n    def __init__(self, args, num_points, initial_state_files,\n                 coordinate_range, area_range, coordinate_delta_range, area_delta_range, fixed_points, variable_edges,\n                 max_refine_steps,\n                 min_refine_steps=10,\n                 dimension=2, constraint_threshold=1e-7, best_n_results=5,\n                 structure_fail_reward=-50., constraint_fail_reward=-10., reward_lambda=169000000,\n                 best=10000, save_good_threshold=0, normalize_magnitude=False):\n        r'''\n        Create a Truss Refine environment instance.\n        :param num_points: number of nodes\n        :param initial_state_files: locations where initial states are stored\n        :param coordinate_range: nodes' coordinate range\n        :param area_range: edges' area range\n        :param coordinate_delta_range: nodes' modification range\n        :param area_delta_range: edges' modification range\n        :param max_refine_steps: max refine steps\n        :param min_refine_steps: another refine steps threshold\n        :param edge_constraint: intersection of edges\n        :param dis_constraint: nodes' displacement weight\n        :param stress_constraint: edges' stress\n        :param buckle_constraint: buckle constraint\n        :param self_weight: edge's weight\n        :param dimension: dimension\n        :param constraint_threshold: eps to check constraint\n        :param best_n_results: choose best_n_results from initial_state_files\n        :param structure_fail_reward: structure fail reward\n        :param constraint_fail_reward: constraint fail reward\n        :param reward_lambda: reward lambda\n        :param best: initial best weight\n        :param save_good_threshold: threshold over best weight to best\n        :param normalize_magnitude: normalize observation's magnitude\n        '''\n        if dimension != 2 and dimension != 3:\n            raise NotImplementedError(\"only support 2D / 3D dimension for now\")\n\n        # Env Config\n        self.num_points = num_points\n        self.dimension = dimension\n        self.fixed_points = fixed_points\n        self.normalize_magnitude = normalize_magnitude\n        self.only_position = args.only_position # if True, do not change edges' area unless greedy upd step.\n        self.greedy_upd = args.greedy_upd\n        self.global_env_step = 0\n        if (args.useAlist): # only 3d case\n            self.alist = []\n            AREAFILE = args.Alist_path\n            with open(AREAFILE,'r') as ar:\n                section_lines = ar.readlines()\n                for i in range(len(section_lines)):\n                    section_line = section_lines[i]\n                    section_r = section_line.strip().split(' ')\n                    if (i==0):\n                        section_num = int(section_r[0])\n                        continue\n                    if (i > 0 and i <= section_num):\n                        d = float(section_r[0]) / 1000.0\n                        t = float(section_r[1]) / 1000.0\n                        self.alist.append((d, t))\n        else: # only 2d case\n            area_range = args.area_range\n            delta = (area_range[1] - area_range[0]) / 50\n            self.alist = [area_range[0] + delta * i for i in range(51)]\n\n        if args.env_mode == 'Area':\n            self.state_observation_space = StateObservationSpace(num_points, coordinate_range, area_range)\n            self.env_observation_space = AutoregressiveEnvObservationSpace(num_points, coordinate_range, area_range)\n            self.action_space = AutoregressiveEnvActionSpace(coordinate_delta_range, area_delta_range)\n        \n        elif args.env_mode == 'DT':\n            self.state_observation_space = StateObservationSpace(num_points, coordinate_range, args.d_range, args.t_range)\n            self.env_observation_space = AutoregressiveEnvObservationSpace(num_points, coordinate_range, args.d_range, args.t_range)\n            self.action_space = AutoregressiveEnvActionSpace(coordinate_delta_range, args.d_delta_range, args.t_delta_range)\n        \n        else: raise NotImplementedError\n\n        # Initial State\n        self.initial_state_files = initial_state_files\n        self.logfile = open(os.path.join(self.initial_state_files, args.logfile_stage2), 'w')\n        self.best_n_results = best_n_results\n\n        # Done\n        self.refine_step = None\n        self.max_refine_steps = max_refine_steps\n        self.min_refine_steps = min_refine_steps\n\n        # Dynamics\n        self.args = args\n        self.env_mode = args.env_mode\n        self.bad_attempt_limit = args.bad_attempt_limit\n        self.use_edge_constraint = args.CONSTRAINT_CROSS_EDGE\n        self.use_dis_constraint = args.CONSTRAINT_DIS\n        self.use_stress_constraint = args.CONSTRAINT_STRESS\n        self.use_buckle_constraint = args.CONSTRAINT_BUCKLE\n        self.use_slenderness_constraint = args.CONSTRAINT_SLENDERNESS\n        self.use_max_length_constraint = args.CONSTRAINT_MAX_LENGTH\n        self.use_min_length_constraint = args.CONSTRAINT_MIN_LENGTH\n        self.use_self_weight = args.CONSTRAINT_SELF_WEIGHT\n        self.constraint_threshold = constraint_threshold\n        self.dynamic_model = DynamicModel(\n            dimension = self.dimension, \n            use_cross_constraint = self.use_edge_constraint,\n            use_self_weight = self.use_self_weight, \n            use_dis_constraint = self.use_dis_constraint, \n            use_buckle_constraint = self.use_buckle_constraint, \n            use_stress_constraint = self.use_stress_constraint,\n            use_slenderness_constraint = self.use_slenderness_constraint,\n            use_longer_constraint = self.use_max_length_constraint,\n            use_shorter_constraint = self.use_min_length_constraint,\n            E = args.E,\n            pho = args.pho,\n            sigma_T = args.sigma_T,\n            sigma_C = args.sigma_C,\n            dislimit = args.dislimit,\n            slenderness_ratio_T = args.slenderness_ratio_t,\n            slenderness_ratio_C = args.slenderness_ratio_c,\n            max_len = args.len_range[1],\n            min_len = args.len_range[0],\n        )\n\n        # State\n        self.initial_state_file = None\n        self.initial_state_point = None\n        self.initial_state_bar = None\n        self.initial_state_mass = None\n        self.state = State(num_points, dimension, args.env_mode)\n        self.state_dynamics = None\n        self.prev_mass = None\n        self.prev_reward = None\n        self.action_id = None\n        self.trajectory = None\n        self.loads = None\n        self.normalize_factor = None\n        self.last_id = 0\n\n        # Reward\n        self.structure_fail_reward = structure_fail_reward\n        self.constraint_fail_reward = constraint_fail_reward\n        self.reward_lambda = reward_lambda\n\n        # Result\n        self.best = best\n        self.save_good_threshold = save_good_threshold\n\n    @property\n    def observation_space(self):\n        return self.env_observation_space\n\n    def _reward_fn(self):\n        is_struct, mass, dis_value, stress_value, buckle_value = self.state_dynamics\n        extra_reward = 0\n        if not is_struct:\n            extra_reward += self.structure_fail_reward\n        if max(dis_value, stress_value, buckle_value) > self.constraint_threshold:\n            extra_reward += self.constraint_fail_reward\n        reward = self.reward_lambda / ((mass * (1 + dis_value + stress_value + buckle_value)) ** 2)\n        return reward, extra_reward\n\n    def _stop_fn(self, reward_step):\n        if (self.refine_step >= self.max_refine_steps): return True\n        if (reward_step <= self.constraint_fail_reward):\n            self.bad_attempt += 1\n        return self.bad_attempt >= self.bad_attempt_limit #and self.refine_step >= self.min_refine_steps\n\n    def valid_truss(self):\n        r'''\n        check whether self.state is valid\n        :return: a list of four bools, a tuple of dynamics\n        '''\n        ret = [True for _ in range(4)]\n        if (self.env_mode == 'Area'):\n            if not self.state_observation_space.contains(self.state.obs(nonexistent_edge=self.state_observation_space.low[-1])):\n                ret[0] = False  # Not in valid observation\n        \n        if (self.env_mode == 'DT'):\n            if not self.state_observation_space.contains(self.state.obs(nonexistent_edge=self.state_observation_space.low[-2:])):\n                ret[0] = False  # Not in valid observation\n\n        for i in range(self.num_points):\n            for j in range(i):\n                if (self.state.nodes[i] == self.state.nodes[j]).all():\n                    ret[1] = False  # Duplicate nodes location\n\n        points = copy.deepcopy(self.initial_state_point)\n        for i in range(self.num_points):\n            points[i].vec.x = self.state.nodes[i][0]\n            points[i].vec.y = self.state.nodes[i][1]\n            if self.dimension == 3:\n                points[i].vec.z = self.state.nodes[i][2]\n        edges = copy.deepcopy(self.initial_state_bar)\n        edges_list = []\n        for i in range(self.num_points):\n            for j in range(i):\n                if (self.env_mode == 'Area'):\n                    if self.state.edges[i][j] > 0:\n                        edges[(j, i)]._area = self.state.edges[i][j]\n                        edges[(j, i)].len = getlen2(points[j], points[i])\n                        edges_list.append((j, i))\n                if (self.env_mode == 'DT'):\n                    if self.state.edges[i][j][0] > 0:\n                        d = self.state.edges[i][j][0]\n                        t = self.state.edges[i][j][1]\n                        assert (d - 2 * t >= 0)\n                        if (d - 2 * t == 0 or t == 0): continue\n                        edges[(j, i)].d = d\n                        edges[(j, i)].t = t\n                        edges[(j, i)].len = getlen2(points[j], points[i])\n                        edges_list.append((j, i))\n\n        if self.use_edge_constraint and self.dimension == 2:\n            for _ in edges_list:\n                i, j = _\n                left_edges = copy.deepcopy(edges)\n                left_edges.pop((i, j))\n                if not is_edge_addable(i, j, points, left_edges):\n                    ret[2] = False  # Edges intersect\n\n        is_struct, mass, dis_value, stress_value, buckle_value, slenderness_value, longer_value, shorter_value, cross_value = self.dynamic_model.run(points, edges, mode = 'train')\n        ret[3] = is_struct and max(dis_value, stress_value, buckle_value) < self.constraint_threshold and max(slenderness_value, longer_value, shorter_value, cross_value) <= 0 # Dynamic constraints\n        return ret, (is_struct, mass, dis_value, stress_value, buckle_value)\n\n    def reset(self, file_name=None):\n        _ = random.random()\n        if _ > 0.5:\n            best_n_results = self.best_n_results\n        else:\n            best_n_results = -1\n        if file_name is None:\n            _input_file_list = os.listdir(self.initial_state_files)\n            input_file_list = []\n            self.total_diverse_count = dict()\n            for s in _input_file_list:\n                if s[-3:] == 'txt' and s[0] != '_':\n                    input_file_list.append(s)\n                    if (self.total_diverse_count.get(int(s[-6: -4])) == None):\n                        self.total_diverse_count[int(s[-6: -4])] = 0\n                    self.total_diverse_count[int(s[-6: -4])] += 1\n            input_file_list.sort(key = lambda x: int(x[:-7]))\n            if best_n_results != -1: # maybe a bug, fixed #\n                if len(input_file_list) > self.best_n_results:\n                    input_file_list = input_file_list[:self.best_n_results]\n            choise_id = np.random.randint(len(input_file_list))\n            file_name = os.path.join(self.initial_state_files, input_file_list[choise_id])\n            self.diverse_id = int(input_file_list[choise_id][-6 : -4])\n        #    print(file_name, self.diverse_id)\n\n        #print(\"file_name =\", file_name)\n\n        self.initial_state_file = file_name\n        points, edges = readFile(file_name)\n        self.initial_state_point = OrderedDict()\n        self.initial_state_bar = OrderedDict()\n        for i in range(self.num_points):\n            self.initial_state_point[i] = points[i]\n        for e in edges:\n            if e.area < 0:\n                continue\n            u = e.u\n            v = e.v\n            if u > v:\n                tmp = u\n                u = v\n                v = tmp\n            self.initial_state_bar[(u, v)] = e\n\n        self.state = State(self.num_points, self.dimension, self.env_mode)\n        for i in range(self.num_points):\n            self.state.nodes[i][0] = points[i].vec.x\n            self.state.nodes[i][1] = points[i].vec.y\n            if self.dimension == 3:\n                self.state.nodes[i][2] = points[i].vec.z\n\n        if (self.env_mode == 'Area'):\n            for e in edges:\n                i = e.u\n                j = e.v\n                self.state.edges[i][j] = e.area\n                self.state.edges[j][i] = e.area\n        \n        if (self.env_mode == 'DT'):\n            for e in edges:\n                i = e.u\n                j = e.v\n                self.state.edges[i][j][0] = e.d\n                self.state.edges[j][i][0] = e.d\n                self.state.edges[i][j][1] = e.t\n                self.state.edges[j][i][1] = e.t\n        \n        _ = self.valid_truss()\n        assert _[0][0] and _[0][1] and _[0][2] and _[0][3], \"Initial state {} not valid\".format(file_name)\n        self.state_dynamics = _[1]\n        self.prev_mass = _[1][1]\n        self.initial_state_mass = _[1][1]\n        self.prev_reward, __ = self._reward_fn()\n        self.refine_step = 0\n        self.total_reward = 0\n        self.bad_attempt = 0\n\n        self.trajectory = [copy.deepcopy(self.state)]\n\n        self.loads = []\n        for i in range(self.num_points):\n            self.loads.append(self.initial_state_point[i].loadY)\n\n        self.normalize_factor = np.array([1. for _ in range(self.num_points * self.dimension)] +\n                                         [100. for _ in range(self.num_points * (self.num_points - 1) // 2)] +\n                                         [1. for _ in range(2)] +\n                                         [1e-5 for _ in range(self.num_points)])\n\n        return self._observation()\n\n    def _observation(self):\n        state_obs = self.state.obs()\n        self.action_id, self.action_id_one_hot = self._generate_action_id()\n        ret = np.concatenate((state_obs, np.array(self.loads), self.action_id))\n        if self.normalize_magnitude:\n            print(\"ret:\", ret)\n            print(\"normalize_factor:\", self.normalize_factor)\n            ret = ret * self.normalize_factor\n            print(\"new_ret:\", ret)\n        return ret\n\n    def _generate_action_id(self):\n        point_action = np.zeros(self.num_points, dtype = np.float64)\n        edge_action = np.zeros(self.num_points * (self.num_points - 1) // 2, dtype = np.float64)\n        greedy_action = np.zeros(1, dtype = np.float64)\n        choose = np.random.randint(0, 20)\n        if (choose == 0): # now use greedy update\n            greedy_action[0] = 1\n            return np.array([-1, -1, 1]), np.concatenate([point_action, edge_action, greedy_action])\n        if (not self.args.eval):\n            id = np.random.randint(self.num_points - self.fixed_points + len(self.initial_state_bar))\n        else: \n            id = (self.last_id + 1) % self.num_points - self.fixed_points + len(self.initial_state_bar)\n            self.last_id += 1\n        if id < self.num_points - self.fixed_points or self.only_position == True:\n            i = id % (self.num_points - self.fixed_points) + self.fixed_points\n            j = -1\n            point_action[i] = 1\n        else:\n            i = -1\n            u, v = list(self.initial_state_bar)[id - (self.num_points - self.fixed_points)]\n            j = (u * ((self.num_points - 1) + (self.num_points - u)) // 2) + (v - u - 1)\n            edge_action[j] = 1\n        return np.array([i, j, -1]), np.concatenate([point_action, edge_action, greedy_action])\n    \n    def greedy_update(self, obs):\n        n_obs = copy.deepcopy(obs)\n        for i in range(len(self.initial_state_bar)):\n                u, v = list(self.initial_state_bar)[i]\n                j = (u * ((self.num_points - 1) + (self.num_points - u)) // 2) + (v - u - 1)\n                if (self.env_mode == 'DT'):\n                    pos = j * 2 + self.num_points * self.dimension\n                else: pos = j + self.num_points * self.dimension\n                if (self.env_mode == 'DT'): ori = n_obs[pos: pos + 2].copy()\n                if (self.env_mode == 'Area'): ori = n_obs[pos: pos + 1].copy()\n                minaera = 1e9\n                if (self.alist != None):\n                    for j in range(len(self.alist)):\n                        if (self.env_mode == 'DT'): n_obs[pos: pos + 2] = self.alist[j]\n                        if (self.env_mode == 'Aera'): n_obs[pos: pos + 1] = self.alist[j]\n                        self.state.set(n_obs)\n                        valid, temp_state_dynamics = self.valid_truss()\n                        if (valid[0] and valid[1] and valid[2] and valid[3] and temp_state_dynamics[1] < minaera):\n                            minaera = temp_state_dynamics[1]\n                            if (self.env_mode == 'DT'): \n                                ori[0] = n_obs[pos: pos + 2][0]\n                                ori[1] = n_obs[pos: pos + 2][1]\n                            else: ori = n_obs[pos: pos + 1].copy()\n                    if (self.env_mode == 'DT'): n_obs[pos: pos + 2] = ori.copy()\n                    if (self.env_mode == 'Area'): n_obs[pos: pos + 1] = ori.copy()\n                else:\n                    raise NotImplementedError()\n        return n_obs\n\n    def fit_diverse(self, area):\n        assert self.env_mode == 'DT'\n        min_area = 1e9\n        chosed_area = self.alist[-1]\n        for d_area in self.alist:\n            if (area[0] <= d_area[0] and area[1] <= d_area[1]):\n                if (min_area > d_area[0] ** 2 - (d_area[0] - 2 * d_area[1]) ** 2):\n                    chosed_area = d_area\n                    min_area = d_area[0] ** 2 - (d_area[0] - 2 * d_area[1]) ** 2\n        return chosed_area\n\n    def step(self, action):\n        self.global_env_step += 1\n        if (self.global_env_step % 4000 == 0):\n            print(self.global_env_step, self.best, file = self.logfile)\n            print(self.global_env_step, self.best)\n#            best_path = os.path.join(self.initial_state_files, '_best.txt')\n#            save_log_path = os.path.join(self.initial_state_files, '_best_{}.txt'.format(str(self.global_env_step)))\n#            os.system('cp {} {}'.format(best_path, save_log_path))\n        assert self.action_space.contains(action), \"actions({}) not in action space({})\".format(action, self.action_space)\n        obs = self.state.obs(nonexistent_edge=-1)\n        n_obs = copy.deepcopy(obs)\n        if (self.action_id[2] == 1): # Greedy update\n            n_obs = self.greedy_update(n_obs)\n\n        if (self.env_mode == 'Area'):\n            if self.action_id[1] != -1:\n                _i = int(self.action_id[1]) + self.num_points * self.dimension\n                n_obs[_i] += action[-1]\n                n_obs[_i] = max(min(n_obs[_i], self.state_observation_space.high[_i]), self.state_observation_space.low[_i])\n            if self.action_id[0] != -1:\n                n_obs[int(self.action_id[0]) * self.dimension: int(self.action_id[0] + 1) * self.dimension] += action[:-1] # act = [(a, b, c), d]\n                for _i in range(int(self.action_id[0]) * self.dimension, int(self.action_id[0] + 1) * self.dimension):\n                    n_obs[_i] = max(min(n_obs[_i], self.state_observation_space.high[_i]), self.state_observation_space.low[_i])\n\n        if (self.env_mode == 'DT'):\n            if self.action_id[1] != -1:\n                _i = int(self.action_id[1]) * 2 + self.num_points * self.dimension\n                n_obs[_i: _i + 2] += action[-2:]\n                n_obs[_i] = max(min(n_obs[_i], self.state_observation_space.high[_i]), self.state_observation_space.low[_i])\n                n_obs[_i + 1] = max(min(n_obs[_i + 1], self.state_observation_space.high[_i + 1]), self.state_observation_space.low[_i + 1])\n                n_obs[_i: _i + 2] = self.fit_diverse(n_obs[_i: _i + 2])\n                n_obs[_i + 1] = min(n_obs[_i + 1], n_obs[_i] / 2)\n            if self.action_id[0] != -1:\n                n_obs[int(self.action_id[0]) * self.dimension: int(self.action_id[0] + 1) * self.dimension] += action[:-2] # act = [(a, b, c), (d, e)]\n                for _i in range(int(self.action_id[0]) * self.dimension, int(self.action_id[0] + 1) * self.dimension):\n                    n_obs[_i] = max(min(n_obs[_i], self.state_observation_space.high[_i]), self.state_observation_space.low[_i])                \n\n        self.state.set(n_obs)\n        self.trajectory.append(copy.deepcopy(self.state))\n\n        info = {}\n        info['illegal action'] = 0\n        valid, self.state_dynamics = self.valid_truss()\n\n        reward, extra_reward = self._reward_fn()\n        if not (valid[0] and valid[1] and valid[2]):\n            info['illegal action'] = 1\n            extra_reward += self.structure_fail_reward # check whether go out the boundary\n\n        if (extra_reward != 0):\n            reward_step = extra_reward # not satisfy the constraint\n        else: \n            reward_step = reward - self.prev_reward\n            self.prev_reward = reward # delta reward\n\n        mass = self.state_dynamics[1]\n        self.prev_mass = mass\n\n        if not (valid[0] and valid[1] and valid[2] and valid[3]): mass = 10000\n        done = self._stop_fn(reward_step)\n        \n        info['is struct'] = self.state_dynamics[0]\n        info['mass'] = mass # if illegal, set to 10000\n        info['displacement'] = self.state_dynamics[2]\n        info['stress'] = self.state_dynamics[3]\n        info['buckle'] = self.state_dynamics[4]\n        info['initial_state_file'] = self.initial_state_file\n        self.refine_step += 1\n        self.total_reward += reward_step\n\n        if (valid[0] and valid[1] and valid[2] and valid[3]):\n            if mass < self.best + self.save_good_threshold:\n                self.total_diverse_count[self.diverse_id] += 1\n                if mass < self.best:\n                    # if mass < self.best - 1:\n                    #     save_trajectory(self.initial_state_point, self.trajectory, mass, self.initial_state_files)\n                    print(\"best:\", mass)\n                    self.best = mass\n                    save_file(self.initial_state_point, self.state, mass, self.initial_state_files, self.env_mode, best = True)\n\n                max_count = self.best_n_results\n                if (self.args.eval): max_count = 1\n                if (self.total_diverse_count[self.diverse_id] > max_count):\n                    self.total_diverse_count[self.diverse_id] -= 1\n                    os.remove(self.initial_state_file)\n                    save_file(self.initial_state_point, self.state, mass, self.initial_state_files, self.env_mode, diverse_id = self.diverse_id)\n                    self.initial_state_file = os.path.join(self.initial_state_files, str(int(mass * 1000)) + \"_\" + str(self.diverse_id).zfill(2) + \".txt\")\n                    self.initial_state_mass = mass\n                    points, edges = readFile(self.initial_state_file)\n                    self.initial_state_point = OrderedDict()\n                    self.initial_state_bar = OrderedDict()\n                    for i in range(self.num_points): self.initial_state_point[i] = points[i]\n                    for e in edges:\n                        if e.area < 0: continue\n                        u = e.u\n                        v = e.v\n                        if u > v:\n                            tmp = u\n                            u = v\n                            v = tmp\n                        self.initial_state_bar[(u, v)] = e\n                else:\n                    save_file(self.initial_state_point, self.state, mass, self.initial_state_files, self.env_mode, diverse_id = self.diverse_id)\n\n            elif mass + 0.01 < self.initial_state_mass: \n                os.remove(self.initial_state_file)\n                save_file(self.initial_state_point, self.state, mass, self.initial_state_files, self.env_mode, diverse_id = self.diverse_id)\n                self.initial_state_file = os.path.join(self.initial_state_files, str(int(mass * 1000)) + \"_\" + str(self.diverse_id).zfill(2) + \".txt\")\n                self.initial_state_mass = mass\n                points, edges = readFile(self.initial_state_file)\n                self.initial_state_point = OrderedDict()\n                self.initial_state_bar = OrderedDict()\n                for i in range(self.num_points):\n                    self.initial_state_point[i] = points[i]\n                for e in edges:\n                    if e.area < 0: continue\n                    u = e.u\n                    v = e.v\n                    if u > v:\n                        tmp = u\n                        u = v\n                        v = tmp\n                    self.initial_state_bar[(u, v)] = e\n        return self._observation(), reward_step, done, info", ""]}
{"filename": "Stage2/envs/dynamic2.py", "chunked_list": ["import numpy as np\nfrom collections import OrderedDict\nimport math\nimport sys, os, time\nimport openseespy.opensees as op\nimport matplotlib.pyplot as plt\nfrom utils.utils import readFile\ndef blockPrint():\n    sys.stdout = open(os.devnull, 'w')\n    sys.stderr = open(os.devnull, 'w')", "\ndef enablePrint():\n    sys.stdout = sys.__stdout__\n    sys.stderr = sys.__stderr__\n\nclass DynamicModel:\n    #\u6784\u9020\u51fd\u6570\n    def __init__(self,\n                dimension,\n                E=193*10**9,          #N/m2\n                pho=8.0*10**3,        #kg/m3\n                sigma_T=123*10**6,    #N/m2\n                sigma_C=213*10**6,    #N/m2\n                dislimit=0.002,       #m\n                slenderness_ratio_T=220,\n                slenderness_ratio_C=180,\n                max_len=5.0,            #m\n                min_len=0.03,         #m\n                use_self_weight=True,\n                use_dis_constraint=True,\n                use_stress_constraint=True,\n                use_buckle_constraint=True,\n                use_slenderness_constraint=True,\n                use_longer_constraint=True,\n                use_shorter_constraint=True,\n                use_cross_constraint=True,\n                ): \n        self._dimension = dimension    #\u7ed3\u6784\u7ef4\u5ea6\n        self._E = E                    #\u5f39\u6027\u6a21\u91cf\n        self._pho = pho                #\u6750\u6599\u5bc6\u5ea6\n        self._sigma_T = sigma_T        #\u5bb9\u8bb8\u62c9\u5e94\u529b\n        self._sigma_C = sigma_C        #\u5bb9\u8bb8\u538b\u5e94\u529b\n        self._limit_dis = dislimit     #\u5bb9\u8bb8\u4f4d\u79fb\n        self.slenderness_ratio_T=slenderness_ratio_T #\u5bb9\u8bb8\u53d7\u62c9\u957f\u7ec6\u6bd4\n        self.slenderness_ratio_C=slenderness_ratio_C #\u5bb9\u8bb8\u53d7\u538b\u957f\u7ec6\u6bd4\n        self.max_len=max_len                         #\u6700\u5927\u957f\u5ea6\n        self.min_len=min_len                         #\u6700\u5c0f\u957f\u5ea6\n        self._use_self_weight = use_self_weight              #\u662f\u5426\u8ba1\u7b97\u81ea\u91cd\n        self._use_dis_constraint = use_dis_constraint        #\u662f\u5426\u542f\u7528\u4f4d\u79fb\u7ea6\u675f\n        self._use_stress_constraint = use_stress_constraint         #\u662f\u5426\u542f\u7528\u5e94\u529b\u7ea6\u675f\n        self._use_buckle_constraint = use_buckle_constraint         #\u662f\u5426\u542f\u7528\u5c48\u66f2\u7ea6\u675f\n        self._use_slenderness_constraint=use_slenderness_constraint #\u662f\u5426\u542f\u7528\u957f\u7ec6\u6bd4\u7ea6\u675f\n        self._use_longer_constraint=use_longer_constraint           #\u662f\u5426\u542f\u7528\u8d85\u957f\u7ea6\u675f\n        self._use_shorter_constraint=use_shorter_constraint         #\u662f\u5426\u542f\u7528\u8fc7\u77ed\u7ea6\u675f\n        self._use_cross_constraint=use_cross_constraint             #\u662f\u5426\u542f\u7528\u6746\u4ef6\u4ea4\u53c9\u7ea6\u675f\n\n    #\u5224\u5b9a\u7ed3\u6784\u7684\u51e0\u4f55\u4e0d\u53d8\u6027+\u5206\u6790\u8ba1\u7b97\n    def _is_struct(self, points, edges):\n        ########\u8ba1\u7b97\u81ea\u7531\u5ea6\u521d\u5224\u7ed3\u6784\u51e0\u4f55\u4e0d\u53d8\u6027##########\n        total_support = 0             #\u4fdd\u5b58\u652f\u5ea7\u7ea6\u675f\u6570\n        for p in points:\n            if self._dimension == 2:  #\u5e73\u9762\u6841\u67b6\n                total_support += (\n                    p.supportX\n                    + p.supportY\n                )\n            else:                     #\u7a7a\u95f4\u6841\u67b6\n                total_support += (\n                    p.supportX\n                    + p.supportY\n                    + p.supportZ\n                )\n\n        if len(points) * self._dimension - len(edges) - total_support > 0:\n            return (False)   #\u8ba1\u7b97\u81ea\u7531\u5ea6>0\uff0c\u7ed3\u6784\u4e0d\u7a33\u5b9a\u76f4\u63a5\u8fd4\u56deFalse\n        \n        blockPrint()\n        #######\u4ee5\u4e0b\u57fa\u4e8e\u70b9\u548c\u8fb9\u96c6\u5efa\u7acb\u6709\u9650\u5143\u6a21\u5f62\u5206\u6790########\n        op.wipe()   # \u6e05\u9664\u6240\u6709\u5df2\u6709\u7ed3\u6784\n        op.model('basic', '-ndm', self._dimension, '-ndf', self._dimension)  #\u8bbe\u7f6e\u5efa\u6a21\u5668\n\n        for i, point in enumerate(points):   #\u5efa\u7acb\u8282\u70b9\n            if self._dimension == 2:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                )\n            else:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                    point.vec.z,\n                )\n\n        for i, point in enumerate(points):  #\u65bd\u52a0\u8282\u70b9\u652f\u5ea7\u7ea6\u675f\n            if point.isSupport:\n                if self._dimension == 2:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                    )\n                else:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                        point.supportZ,\n                    )\n\n        op.timeSeries(\"Linear\", 1)\n        op.pattern(\"Plain\", 1, 1)\n        \n        for i, point in enumerate(points):  #\u6dfb\u52a0\u8282\u70b9\u8377\u8f7d\n            if point.isLoad:\n                if self._dimension == 2:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                    )\n                else:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                        point.loadZ,\n                    )\n\n        op.uniaxialMaterial(\"Elastic\", 1, self._E)   #\u5b9a\u4e49\u6750\u6599\n\n        for i, edge in enumerate(edges):\n            op.element(\"Truss\", i, edge.u, edge.v, edge.area, 1)  #\u8d4b\u4e88\u6746\u4ef6\u622a\u9762\u5c5e\u6027\n        \n        \n        \n        if self._use_self_weight:  #\u5982\u679c\u8ba1\u7b97\u81ea\u91cd\u65f6\n            gravity = 9.8   #\u91cd\u529b\u52a0\u901f\u5ea6\n            load_gravity = [0 for _ in range(len(points))]  #\u521d\u59cb\u5316\u4e86\u4e00\u4e2aload_gravity\u5217\u8868\uff0c\u8868\u5f81\u6746\u4ef6\u81ea\u91cd\u7684\u7b49\u6548\u7ed3\u70b9\u529b\uff0clen(points)\u4e2a\u5143\u7d20\u5747\u4e3a0\n\n            for i, edge in enumerate(edges):\n                edge_mass = edge.len * edge.area * self._pho       #\u6bcf\u6839\u6746\u4ef6\u8d28\u91cf\n                load_gravity[edge.u] += edge_mass * gravity * 0.5\n                load_gravity[edge.v] += edge_mass * gravity * 0.5  #\u6bcf\u6839\u6746\u4ef6\u7684\u91cd\u529b\u5411\u4e24\u7aef\u5206\u4e00\u534a\u5230\u8282\u70b9\u4e0a\n            \n            for i in range(len(points)):        #\u5c06\u91cd\u529b\u8377\u8f7d\u7b49\u6548\u65bd\u52a0\u4e8e\u8282\u70b9\u4e0a\n                if self._dimension == 2:        #\u5982\u679c\u662f\u5e73\u9762\u7ed3\u6784\n                    op.load(i, 0.0, -1 * load_gravity[i])\n                else:                           #\u5982\u679c\u662f\u7a7a\u95f4\u7ed3\u6784\n                    op.load(i, 0.0, 0.0, -1 * load_gravity[i])\n        \n        op.system(\"BandSPD\")\n        op.numberer(\"RCM\")\n        op.constraints(\"Plain\")\n        op.integrator(\"LoadControl\", 1.0)\n        op.algorithm(\"Newton\")\n        op.analysis(\"Static\")\n        ok = op.analyze(1)  #\u8fd0\u884c\u5206\u6790\uff0cok\u8868\u5f81\u662f\u5426\u6210\u529f\u8fd0\u884c\uff0c\u8fd4\u56de0\u4ee3\u8868\u6210\u529f\uff0c\u8fd4\u56de<0\u5931\u8d25\u3002\uff08\u6ce8:\u8fd9\u91cc\u5bf9\u7ed3\u6784\u7684\u51e0\u4f55\u4e0d\u53d8\u6027\u8fdb\u884c\u4e86\u5145\u5206\u5224\u65ad\uff09\n        if ok < 0:\n            ok = False\n        else:\n            ok = True\n        enablePrint()\n        return ok\n    \n    #\u8bc4\u4f30\u8282\u70b9\u4f4d\u79fb\n    def _get_dis_value(self, points, mode = 'check'):\n        displacement_weight = np.zeros((len(points), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u4f4d\u79fb\u6570\u636e\n        for i in range(len(points)):\n            if self._dimension == 2:\n                weight = max(   \n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                )                                  #\u53ea\u8003\u8651x,y,(z)\u65b9\u5411\u4e0a\u7684\u6700\u5927\u7684\u4e00\u4e2a\u7ebf\u4f4d\u79fb\n            else:\n                weight = max(\n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                    abs(op.nodeDisp(i, 3)),\n                )\n            if (mode == 'check'): print(\"\u7b2c{:}\u7ed3\u70b9\u4f4d\u79fb\u4e3a{:}mm\".format(i,weight*10**3))\n            displacement_weight[i] = max(weight / self._limit_dis - 1, 0)  #\u5224\u5b9a\u8282\u70b9\u4f4d\u79fb\u662f\u5426\u8d85\u9650\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\uff0c\u6700\u540e\u7d2f\u52a0\u6570\u7ec4\u4e2d\u7684\u6570\u503c\u4f5c\u4e3a\u4f4d\u79fb\u8bc4\u4f30\u53c2\u7167\n        return displacement_weight\n    \n    #\u8bc4\u4f30\u6746\u4ef6\u5e94\u529b\n    def _get_stress_value(self, edges, mode = 'check'):\n        stress_weight = np.zeros(len(edges))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u5e94\u529b\u6570\u636e\n\n        for tag, i in enumerate(range(len(edges))):\n\n            edges[i].force = op.basicForce(tag)   #\u4ece\u6709\u9650\u5143\u5f97\u5230\u6746\u4ef6\u8f74\u529b\n            edges[i].stress = edges[i].force[0] / edges[i].area  #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            if (mode == 'check'): print(\"\u7b2c{:}\u6746\u4ef6\u5e94\u529b\u4e3a{:}MPa\".format(i,edges[i].stress*10**(-6)))\n            if edges[i].stress < 0:                                  #\u538b\u6746\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_C - 1.0,\n                    0.0\n                )\n            else:                                                    #\u62c9\u6746\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_T - 1.0,\n                    0.0\n                )\n        return stress_weight  #\u5224\u5b9a\u8282\u70b9\u5e94\u529b\u662f\u5426\u8d85\u9650\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\uff0c\u6700\u540e\u7d2f\u52a0\u6570\u7ec4\u4e2d\u7684\u6570\u503c\u4f5c\u4e3a\u5e94\u529b\u8bc4\u4f30\u53c2\u7167\n\n    #\u8bc4\u4f30\u6746\u4ef6\u5c48\u66f2\n    def _get_buckle_value(self, edges):\n        buckle_weight = np.zeros(len(edges))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u5c48\u66f2\u6570\u636e\n        miu_buckle = 1.0                           #\u6746\u4ef6\u8ba1\u7b97\u957f\u5ea6\u7cfb\u6570\uff0c\u6841\u67b6\u4e24\u7aef\u94f0\u63a5\u53d61\n        \n        for i in range(len(edges)):\n            edges[i].force = op.basicForce(i)    #\u5b58\u653e\u8f74\u529b\u6570\u636e\n            edges[i].stress = edges[i].force[0] / edges[i].area #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            \n            if edges[i].stress < 0:    #\u4ec5\u538b\u6746\u624d\u8003\u8651\u5c48\u66f2\n                #\u8ba1\u7b97\u6b27\u62c9\u4e34\u754c\u529b\n                force_cr = (\n                    math.pi ** 2 \n                    * self._E * edges[i].inertia\n                ) / (miu_buckle * edges[i].len) ** 2\n\n                #\u8ba1\u7b97\u6b27\u62c9\u4e34\u754c\u5e94\u529b\n                buckle_stress_max = force_cr / edges[i].area\n\n                buckle_weight[i] = max(\n                    abs(edges[i].stress) / abs(buckle_stress_max) - 1.0,\n                    0.0\n                )#\u5224\u5b9a\u6746\u4ef6\u538b\u5e94\u529b\u662f\u5426\u8d85\u8fc7\u5c48\u66f2\u4e34\u754c\u5e94\u529b\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return buckle_weight\n    \n    #\u8bc4\u4f30\u6746\u4ef6\u957f\u7ec6\u6bd4\n    def _get_slenderness_ratio(self, edges):\n        lambda_weight = np.zeros(len(edges))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for i in range(len(edges)):\n            edges[i].force = op.basicForce(i)    #\u5b58\u653e\u8f74\u529b\u6570\u636e\n            edges[i].stress = edges[i].force[0] / edges[i].area #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            lambda_weight[i] = max(\n                # self.len/(self.inertia/self.area)**0.5\n                abs(edges[i].len / (edges[i].inertia / edges[i].area) ** 0.5) / abs(self.slenderness_ratio_C if edges[i].stress < 0 else self.slenderness_ratio_T) - 1.0,\n                0.0\n            )#\u5224\u5b9a\u6746\u4ef6\u957f\u7ec6\u6bd4\u662f\u5426\u8d85\u8fc7\u9650\u5236\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return lambda_weight\n\n    #\u8bc4\u4f30\u6746\u4ef6\u8d85\u957f\n    def _get_length_longer(self, edges):\n        longer_weight = np.zeros(len(edges))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for i in range(len(edges)):   \n            longer_weight[i] = max(\n                abs(edges[i].len) / abs(self.max_len) - 1.0,\n                0.0\n            )#\u5224\u5b9a\u6746\u4ef6\u957f\u5ea6\u662f\u5426\u8d85\u8fc7\u9650\u5236\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return longer_weight\n\n    #\u8bc4\u4f30\u6746\u4ef6\u8fc7\u77ed\n    def _get_length_shorter(self, edges):\n        shorter_weight = np.zeros(len(edges))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for i in range(len(edges)): \n            if edges[i].len < self.min_len:\n                shorter_weight[i] = 1.0-edges[i].len / self.min_len\n                #\u5224\u5b9a\u6746\u4ef6\u957f\u5ea6\u662f\u5426\u8fc7\u77ed\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return shorter_weight\n\n    def _get_cross_value(self, points, edges):\n        cross_value = 0\n        for i in range(len(edges)):\n            for j in range(len(edges)):\n                if (edges[i].u == edges[j].v or edges[i].u == edges[j].u or edges[i].v == edges[j].v or edges[i].v == edges[j].u):\n                    continue\n                _, _, dis = self.closestDistanceBetweenLines(points[edges[i].u].Point2np(), points[edges[i].v].Point2np(), points[edges[j].u].Point2np(), points[edges[j].v].Point2np(), clampAll = True)\n                if (edges[i].d != None):\n                    r1, r2 = edges[i].d, edges[j].d\n                else:\n                    if (self._dimension == 2):\n                        r1, r2 = edges[i].area, edges[j].area\n                    elif (self._dimension == 3):\n                        r1, r2 = np.sqrt(edges[i].area / np.pi), np.sqrt(edges[j].area / np.pi)\n                if (dis <= r1 + r2): cross_value += 1\n        return cross_value\n\n    def closestDistanceBetweenLines(self, a0, a1, b0, b1, \n        clampAll = False, clampA0 = False,clampA1 = False,clampB0 = False,clampB1 = False):\n        ''' \n        Given two lines defined by numpy.array pairs (a0,a1,b0,b1)\n        Return the closest points on each segment and their distance\n        '''\n        # If clampAll=True, set all clamps to True\n        if clampAll:\n            clampA0=True\n            clampA1=True\n            clampB0=True\n            clampB1=True\n        # Calculate denomitator\n        A = a1 - a0\n        B = b1 - b0\n        magA = np.linalg.norm(A)\n        magB = np.linalg.norm(B)\n    \n        _A = A / magA\n        _B = B / magB\n    \n        cross = np.cross(_A, _B)\n        denom = np.linalg.norm(cross) ** 2\n    \n        # If lines are parallel (denom=0) test if lines overlap.\n        # If they don't overlap then there is a closest point solution.\n        # If they do overlap, there are infinite closest positions, but there is a closest distance\n        if not denom:\n            d0 = np.dot(_A, (b0 - a0))\n        \n            # Overlap only possible with clamping\n            if clampA0 or clampA1 or clampB0 or clampB1:\n                d1 = np.dot(_A, (b1 - a0))\n            \n                # Is segment B before A?\n                if d0 <= 0 >= d1:\n                    if clampA0 and clampB1:\n                        if np.absolute(d0) < np.absolute(d1):\n                            return a0,b0,np.linalg.norm(a0-b0)\n                        return a0,b1,np.linalg.norm(a0-b1)\n                \n                # Is segment B after A?\n                elif d0 >= magA <= d1:\n                    if clampA1 and clampB0:\n                        if np.absolute(d0) < np.absolute(d1):\n                            return a1,b0,np.linalg.norm(a1-b0)\n                        return a1,b1,np.linalg.norm(a1-b1)\n                \n            # Segments overlap, return distance between parallel segments\n            return None,None,np.linalg.norm(((d0*_A)+a0)-b0)\n    \n        # Lines criss-cross: Calculate the projected closest points\n        t = (b0 - a0)\n        detA = np.linalg.det([t, _B, cross])\n        detB = np.linalg.det([t, _A, cross])\n\n        t0 = detA/denom\n        t1 = detB/denom\n\n        pA = a0 + (_A * t0) # Projected closest point on segment A\n        pB = b0 + (_B * t1) # Projected closest point on segment B\n\n\n        # Clamp projections\n        if clampA0 or clampA1 or clampB0 or clampB1:\n            if clampA0 and t0 < 0:\n                pA = a0\n            elif clampA1 and t0 > magA:\n                pA = a1\n        \n            if clampB0 and t1 < 0:\n                pB = b0\n            elif clampB1 and t1 > magB:\n                pB = b1\n            \n            # Clamp projection A\n            if (clampA0 and t0 < 0) or (clampA1 and t0 > magA):\n                dot = np.dot(_B,(pA-b0))\n                if clampB0 and dot < 0:\n                    dot = 0\n                elif clampB1 and dot > magB:\n                    dot = magB\n                pB = b0 + (_B * dot)\n    \n            # Clamp projection B\n            if (clampB0 and t1 < 0) or (clampB1 and t1 > magB):\n                dot = np.dot(_A,(pB-a0))\n                if clampA0 and dot < 0:\n                    dot = 0\n                elif clampA1 and dot > magA:\n                    dot = magA\n                pA = a0 + (_A * dot)\n\n        return pA, pB, np.linalg.norm(pA - pB)\n\n    #\u8c03\u7528\u4ee5\u4e0a\u51fd\u6570\u8fd0\u884c\u7ed3\u6784\u5206\u6790\n    def run(self, points, edges, mode = 'check'):\n        # if mode = check, return a list\n        # else, return value\n        if 'IS_RUNNING_DYNAMIC' not in os.environ:\n            os.environ['IS_RUNNING_DYNAMIC'] = 'no'\n        while os.environ['IS_RUNNING_DYNAMIC'] == 'yes':\n            print('waiting for dynamics to be enabled')\n            time.sleep(0.1)\n        os.environ['IS_RUNNING_DYNAMIC'] = 'yes'\n        if (type(points) == dict or type(points) == OrderedDict):\n            _points = []\n            for i, point in points.items():\n                _points.append(point)\n            points = _points\n        \n        if (type(edges) == dict or type(edges) == OrderedDict):\n            _edges = []\n            for i, edge in edges.items():\n                _edges.append(edge)\n            edges = _edges\n\n\n        is_struct = self._is_struct(points, edges) #\u8fd0\u884c\u7ed3\u6784\u5efa\u6a21\u4e0e\u5206\u6790\uff0cis_struct\u8fd4\u56de\u7ed3\u6784\u662f\u5426\u6b63\u5e38\u5b8c\u6210\u5206\u6790\n        mass, dis_value, stress_value, buckle_value, slenderness_value, longer_value, shorter_value, cross_value = 0, 0, 0, 0, 0, 0, 0, 0\n        for edge in edges: mass += edge.len * edge.area * self._pho      #\u8ba1\u7b97\u7ed3\u6784\u603b\u8d28\u91cf\n        if is_struct: #\u5982\u679c\u7ed3\u6784\u6210\u529f\u5b8c\u6210\u5206\u6790\uff0c\u5373\u7ed3\u6784\u662f\u51e0\u4f55\u4e0d\u53d8\u7684\n            if self._use_dis_constraint:\n                dis_value = self._get_dis_value(points, mode)       #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u4f4d\u79fb\u8bc4\u4f30\u7ed3\u679c\n            if self._use_stress_constraint:\n                stress_value = self._get_stress_value(edges, mode)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u5e94\u529b\u8bc4\u4f30\u7ed3\u679c\n            if self._use_buckle_constraint:\n                buckle_value = self._get_buckle_value(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u5c48\u66f2\u8bc4\u4f30\u7ed3\u679c\n            if self._use_slenderness_constraint:\n                slenderness_value = self._get_slenderness_ratio(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c    \n            if self._use_longer_constraint:\n                longer_value = self._get_length_longer(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c\n            if self._use_shorter_constraint:\n                shorter_value = self._get_length_shorter(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c\n        if self._use_cross_constraint:\n            cross_value = self._get_cross_value(points, edges)\n\n        if (mode != 'check'):\n            if (is_struct and self._use_dis_constraint): dis_value = dis_value.sum()\n            if (is_struct and self._use_buckle_constraint): buckle_value = buckle_value.sum()\n            if (is_struct and self._use_slenderness_constraint): slenderness_value = slenderness_value.sum()\n            if (is_struct and self._use_stress_constraint): stress_value = stress_value.sum()\n            if (is_struct and self._use_longer_constraint): longer_value = longer_value.sum()\n            if (is_struct and self._use_shorter_constraint): shorter_value = shorter_value.sum()\n\n        os.environ['IS_RUNNING_DYNAMIC'] = 'no'\n        return (\n            is_struct, mass, dis_value, stress_value, buckle_value, slenderness_value, longer_value, shorter_value, cross_value\n        )\n\n    #\u7ed8\u5236\u5e73\u9762\u6841\u67b6\n    def render(self, points, edges):\n        _ax = plt.axes(projection='3d')\n        for point in points.values():   #\u7ed8\u5236\u8282\u70b9\uff0cscatter()\u7ed8\u5236\u6563\u70b9\n            if point.isSupport:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='g') #\u652f\u5ea7\u70b9\u4e3a\u7eff\u8272\n            elif point.isLoad:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='r') #\u8377\u8f7d\u4f5c\u7528\u7684\u8282\u70b9\u4e3a\u7ea2\u8272\n            else:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='b') #\u5176\u4f59\u8282\u70b9\u84dd\u8272\n\n        for edge in edges.values():    #\u7ed8\u5236\u6746\u4ef6\n            x0 = [points[edge.u].vec.x, points[edge.v].vec.x]   #\u6746\u4ef6\u8d77\u70b9\n            y0 = [points[edge.u].vec.y, points[edge.v].vec.y]   #\u6746\u4ef6\u7ec8\u70b9\n            z0 = [points[edge.u].vec.z, points[edge.v].vec.z]   #\u6746\u4ef6\u8d77\u70b9\n            \n            if edge.stress < -1e-7:\n                _ax.plot(x0, y0, z0, color='g', linewidth=(edge.area / math.pi)**0.5*500)    #\u538b\u6746\u7eff\u8272\n            elif edge.stress > 1e-7:\n                _ax.plot(x0, y0, z0, color='r', linewidth=(edge.area / math.pi)**0.5*500)    #\u62c9\u6746\u7ea2\u8272\n            else:\n                _ax.plot(x0, y0, z0, color='k', linewidth=(edge.area / math.pi)**0.5*500)    #\u96f6\u6746\u9ed1\u8272\n        plt.show() #\u663e\u793a\u56fe\u50cf", "\n\nif __name__=='__main__':\n    truss=DynamicModel(3)    #\u521b\u5efa\u7ed3\u6784\u5bf9\u8c61\n    point_list, edge_list = readFile(\"25.txt\") #\u8bfb\u53d6\u6570\u636e\u8f93\u5165\u6587\u4ef6\u4e2d\u7684\u9884\u8bbe\u70b9\u548c\u8fb9\n\n    #\u5c06point_list, edge_list\u8f6c\u6362\u6210truss.run\u7684\u6570\u636e\u7ed3\u6784\n    points = {}\n    edges = {}\n    for i, point in enumerate(point_list):  #\u5c06\u9884\u8bbe\u70b9\u5bf9\u8c61\u52a0\u5165\u70b9\u96c6\n        points[i] = point\n\n    for i, edge in enumerate(edge_list):    #\u5c06\u9884\u8bbe\u8fb9\u5bf9\u8c61\u52a0\u5165\u8fb9\u96c6\n        if edge.u > edge.v:                 #\u8fb9\u7aef\u70b9\u91cd\u65b0\u7f16\u53f7\n            tmp = edge.u\n            edge.u = edge.v\n            edge.v = tmp\n        edges[(edge.u, edge.v)] = edge        \n\n    #\u8fd0\u884c\u6a21\u578b\u5206\u6790                                 \n    is_struct, mass, dis_value, stress_value, buckle_value, slenderness_value, longer_value, shorter_value  = truss.run(points, edges) \n    \n    #\u540e\u5904\u7406\uff0c\u8f93\u51fa\u7ed3\u6784\u8bbe\u8ba1\u7ed3\u679c\u7684\u63d0\u793a\u4fe1\u606f\n    if not is_struct:\n        print(\"\u7ed3\u6784\u51e0\u4f55\u4e0d\u7a33\u5b9a\")\n    elif np.sum(dis_value) > 0.0 or np.sum(stress_value) > 0.0 or np.sum(buckle_value) > 0.0 or np.sum(slenderness_value) or np.sum(longer_value) or np.sum(shorter_value):\n        for i in range(len(dis_value)):\n            if dis_value[i]>0.0:\n                print(\"\u7b2c{:}\u7ed3\u70b9\u4f4d\u79fb\u8d85\u51fa\u9650\u503c{:}%\".format(i,dis_value[i]*100))\n\n        for i in range(len(stress_value)):\n            if stress_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u5e94\u529b\u8d85\u51fa\u9650\u503c{:}%\".format(i,stress_value[i]*100))\n\n        for i in range(len(buckle_value)):\n            if buckle_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u5c48\u66f2\u5e94\u529b\u8d85\u51fa\u9650\u503c{:}%\".format(i,buckle_value[i]*100))\n\n        for i in range(len(slenderness_value)):\n            if slenderness_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u957f\u7ec6\u6bd4\u8d85\u51fa\u9650\u503c{:}%\".format(i,slenderness_value[i]*100))\n\n        for i in range(len(longer_value)):\n            if longer_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u957f\u5ea6\u8d85\u51fa\u9650\u503c{:}%\".format(i,longer_value[i]*100))\n        for i in range(len(shorter_value)):\n            if shorter_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u957f\u5ea6\u77ed\u8fc7\u9650\u503c{:}%\".format(i,shorter_value[i]*100))                 \n\n    else:\n        print(\"\u7ed3\u6784\u51e0\u4f55\u7a33\u5b9a\uff0c\u4e14\u6240\u6709\u7ea6\u675f\u6ee1\u8db3\u3002\u5f53\u524d\u7ed3\u6784\u603b\u8d28\u91cf\u4e3a\uff1a{:.3f}kg\".format(mass))\n\n    truss.render(points, edges) #\u663e\u793a\u6841\u67b6\u56fe\u50cf"]}
{"filename": "Stage2/envs/dynamic_.py", "chunked_list": ["import gym\nimport time\nimport json\nimport numpy as np\nimport math\nimport random\nimport copy\n\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation", "import matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport warnings\nimport os, sys, contextlib, platform\n\nsysstr = platform.system()\nif sysstr == \"Windows\" or sysstr == \"Linux\":\n    isMac = False\nelse:\n    isMac = True", "\nif isMac:\n    import openseespymac.opensees as op\nelse:\n    import openseespy.opensees as op\n\nfrom utils.utils import readFile, Point, Bar, getlen2, Vector3, getang\n\n\ndef blockPrint():\n    sys.stdout = open(os.devnull, 'w')\n    sys.stderr = open(os.devnull, 'w')", "\ndef blockPrint():\n    sys.stdout = open(os.devnull, 'w')\n    sys.stderr = open(os.devnull, 'w')\n\ndef enablePrint():\n    sys.stdout = sys.__stdout__\n    sys.stderr = sys.__stderr__\n\nclass DynamicModel:\n\n    def __init__(self,\n                 dimension,\n                 E=6.895 * 10 ** 10,\n                 pho=2.76799 * 10 ** 3,\n                 sigma_T=172.3 * 10 ** 6,\n                 sigma_C=172.3 * 10 ** 6,\n                 dislimit=0.0508,\n                 ratio_ring=0.0,\n                 use_self_weight=True,\n                 use_dis_constraint=True,\n                 use_stress_constraint=True,\n                 use_buckle_constraint=True,\n                 ):\n        self._dimension = dimension\n        self._E = E\n        self._pho = pho\n        self._sigma_T = sigma_T\n        self._sigma_C = sigma_C\n        self._limit_dis = dislimit\n        self._ratio_ring = ratio_ring\n        self._use_self_weight = use_self_weight\n        self._use_dis_constraint = use_dis_constraint\n        self._use_stress_constraint = use_stress_constraint\n        self._use_buckle_constraint = use_buckle_constraint\n\n    def _is_struct(self, points, edges):\n        total_support = 0\n        for p in points.values():\n            if self._dimension == 2:\n                total_support += (\n                        p.supportX\n                        + p.supportY\n                )\n            else:\n                total_support += (\n                        p.supportX\n                        + p.supportY\n                        + p.supportZ\n                )\n\n        if len(points) * self._dimension - len(edges) - total_support > 0:\n            return (False)  # \u8ba1\u7b97\u81ea\u7531\u5ea6>0\uff0c\u7ed3\u6784\u4e0d\u7a33\u5b9a\u76f4\u63a5\u8fd4\u56deFalse\n        blockPrint()\n        op.wipe()\n        op.model('basic', '-ndm', self._dimension, '-ndf', self._dimension)\n\n        for i, point in points.items():\n            if self._dimension == 2:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                )\n            else:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                    point.vec.z,\n                )\n        for i, point in points.items():\n            if point.isSupport:\n                if self._dimension == 2:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                    )\n                else:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                        point.supportZ,\n                    )\n        op.uniaxialMaterial(\"Elastic\", 1, self._E)\n        for i, edge in enumerate(edges.values()):\n            op.element(\"Truss\", i, edge.u, edge.v, edge.area, 1)\n        op.timeSeries(\"Linear\", 1)\n        op.pattern(\"Plain\", 1, 1)\n        for i, point in points.items():\n            if point.isLoad:\n                if self._dimension == 2:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                    )\n                else:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                        point.loadZ,\n                    )\n        if self._use_self_weight:\n            gravity = 9.8\n            load_gravity = [0 for _ in range(len(points))]\n\n            for i, edge in edges.items():\n                edge_mass = edge.len * edge.area * self._pho\n                load_gravity[edge.u] += edge_mass * gravity * 0.5\n                load_gravity[edge.v] += edge_mass * gravity * 0.5\n\n            for i in range(len(points)):\n                if self._dimension == 2:  # \u5982\u679c\u662f\u5e73\u9762\u7ed3\u6784\n                    op.load(i, 0.0, -1 * load_gravity[i])\n                else:  # \u5982\u679c\u662f\u7a7a\u95f4\u7ed3\u6784\n                    op.load(i, 0.0, 0.0, -1 * load_gravity[i])\n\n        op.system(\"BandSPD\")\n        op.numberer(\"RCM\")\n        op.constraints(\"Plain\")\n        op.integrator(\"LoadControl\", 1.0)\n        op.algorithm(\"Newton\")\n        op.analysis(\"Static\")\n        ok = op.analyze(1)\n        enablePrint()\n        if ok < 0:\n            ok = False\n        else:\n            ok = True\n        return ok\n\n    def _get_dis_value(self, points):\n        displacement_weight = np.zeros((len(points), 1))\n        for i in range(len(points)):\n            if self._dimension == 2:\n                weight = max(\n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                )\n            else:\n                weight = max(\n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                    abs(op.nodeDisp(i, 3)),\n                )\n\n            displacement_weight[i] = max(weight / self._limit_dis - 1.0, 0)\n        return np.sum(displacement_weight)\n\n    def _get_stress_value(self, edges):\n        stress_weight = np.zeros((len(edges), 1))\n        for tag, i in enumerate(edges.keys()):\n            edges[i].force = op.basicForce(tag)\n            if isMac:\n                edges[i].stress = edges[i].force / edges[i].area\n            else:\n                edges[i].stress = edges[i].force[0] / edges[i].area\n\n            if edges[i].stress < 0:\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_C - 1.0,\n                    0.0\n                )\n            else:\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_T - 1.0,\n                    0.0\n                )\n        return np.sum(stress_weight)\n\n    def _get_buckle_value(self, edges):\n        buckle_weight = np.zeros((len(edges), 1))\n        miu_buckle = 1.0\n        for tag, i in enumerate(edges.keys()):\n            edges[i].force = op.basicForce(tag)\n            if isMac:\n                edges[i].stress = edges[i].force / edges[i].area\n            else:\n                edges[i].stress = edges[i].force[0] / edges[i].area\n\n            if edges[i].stress < 0:\n                edges[i].inertia = (\n                        edges[i].area ** 2\n                        * (1 + self._ratio_ring ** 2)\n                        / (\n                                4 * math.pi\n                                * (1 - self._ratio_ring ** 2)\n                        )\n                )\n                force_cr = (\n                                   math.pi ** 2\n                                   * self._E * edges[i].inertia\n                           ) / (miu_buckle * edges[i].len) ** 2\n                buckle_stress_max = force_cr / edges[i].area\n                buckle_weight[tag] = max(\n                    abs(edges[i].stress) / abs(buckle_stress_max) - 1.0,\n                    0.0\n                )\n        return np.sum(buckle_weight)\n\n    def run(self, points, edges):\n        if 'IS_RUNNING_DYNAMIC' not in os.environ:\n            os.environ['IS_RUNNING_DYNAMIC'] = 'no'\n        while os.environ['IS_RUNNING_DYNAMIC'] == 'yes':\n            print('waiting for dynamics to be enabled')\n            time.sleep(0.1)\n        os.environ['IS_RUNNING_DYNAMIC'] = 'yes'\n        is_struct = self._is_struct(points, edges)\n        mass, dis_value, stress_value, buckle_value = 0.0, 0.0, 0.0, 0.0\n        if is_struct:\n            for i, edge in edges.items():\n                mass += edge.len * edge.area * self._pho\n            if self._use_dis_constraint:\n                dis_value = self._get_dis_value(points)\n            if self._use_stress_constraint:\n                stress_value = self._get_stress_value(edges)\n            if self._use_buckle_constraint:\n                buckle_value = self._get_buckle_value(edges)\n        os.environ['IS_RUNNING_DYNAMIC'] = 'no'\n        return (\n            is_struct,\n            mass, dis_value, stress_value, buckle_value\n        )", "\nclass DynamicModel:\n\n    def __init__(self,\n                 dimension,\n                 E=6.895 * 10 ** 10,\n                 pho=2.76799 * 10 ** 3,\n                 sigma_T=172.3 * 10 ** 6,\n                 sigma_C=172.3 * 10 ** 6,\n                 dislimit=0.0508,\n                 ratio_ring=0.0,\n                 use_self_weight=True,\n                 use_dis_constraint=True,\n                 use_stress_constraint=True,\n                 use_buckle_constraint=True,\n                 ):\n        self._dimension = dimension\n        self._E = E\n        self._pho = pho\n        self._sigma_T = sigma_T\n        self._sigma_C = sigma_C\n        self._limit_dis = dislimit\n        self._ratio_ring = ratio_ring\n        self._use_self_weight = use_self_weight\n        self._use_dis_constraint = use_dis_constraint\n        self._use_stress_constraint = use_stress_constraint\n        self._use_buckle_constraint = use_buckle_constraint\n\n    def _is_struct(self, points, edges):\n        total_support = 0\n        for p in points.values():\n            if self._dimension == 2:\n                total_support += (\n                        p.supportX\n                        + p.supportY\n                )\n            else:\n                total_support += (\n                        p.supportX\n                        + p.supportY\n                        + p.supportZ\n                )\n\n        if len(points) * self._dimension - len(edges) - total_support > 0:\n            return (False)  # \u8ba1\u7b97\u81ea\u7531\u5ea6>0\uff0c\u7ed3\u6784\u4e0d\u7a33\u5b9a\u76f4\u63a5\u8fd4\u56deFalse\n        blockPrint()\n        op.wipe()\n        op.model('basic', '-ndm', self._dimension, '-ndf', self._dimension)\n\n        for i, point in points.items():\n            if self._dimension == 2:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                )\n            else:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                    point.vec.z,\n                )\n        for i, point in points.items():\n            if point.isSupport:\n                if self._dimension == 2:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                    )\n                else:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                        point.supportZ,\n                    )\n        op.uniaxialMaterial(\"Elastic\", 1, self._E)\n        for i, edge in enumerate(edges.values()):\n            op.element(\"Truss\", i, edge.u, edge.v, edge.area, 1)\n        op.timeSeries(\"Linear\", 1)\n        op.pattern(\"Plain\", 1, 1)\n        for i, point in points.items():\n            if point.isLoad:\n                if self._dimension == 2:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                    )\n                else:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                        point.loadZ,\n                    )\n        if self._use_self_weight:\n            gravity = 9.8\n            load_gravity = [0 for _ in range(len(points))]\n\n            for i, edge in edges.items():\n                edge_mass = edge.len * edge.area * self._pho\n                load_gravity[edge.u] += edge_mass * gravity * 0.5\n                load_gravity[edge.v] += edge_mass * gravity * 0.5\n\n            for i in range(len(points)):\n                if self._dimension == 2:  # \u5982\u679c\u662f\u5e73\u9762\u7ed3\u6784\n                    op.load(i, 0.0, -1 * load_gravity[i])\n                else:  # \u5982\u679c\u662f\u7a7a\u95f4\u7ed3\u6784\n                    op.load(i, 0.0, 0.0, -1 * load_gravity[i])\n\n        op.system(\"BandSPD\")\n        op.numberer(\"RCM\")\n        op.constraints(\"Plain\")\n        op.integrator(\"LoadControl\", 1.0)\n        op.algorithm(\"Newton\")\n        op.analysis(\"Static\")\n        ok = op.analyze(1)\n        enablePrint()\n        if ok < 0:\n            ok = False\n        else:\n            ok = True\n        return ok\n\n    def _get_dis_value(self, points):\n        displacement_weight = np.zeros((len(points), 1))\n        for i in range(len(points)):\n            if self._dimension == 2:\n                weight = max(\n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                )\n            else:\n                weight = max(\n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                    abs(op.nodeDisp(i, 3)),\n                )\n\n            displacement_weight[i] = max(weight / self._limit_dis - 1.0, 0)\n        return np.sum(displacement_weight)\n\n    def _get_stress_value(self, edges):\n        stress_weight = np.zeros((len(edges), 1))\n        for tag, i in enumerate(edges.keys()):\n            edges[i].force = op.basicForce(tag)\n            if isMac:\n                edges[i].stress = edges[i].force / edges[i].area\n            else:\n                edges[i].stress = edges[i].force[0] / edges[i].area\n\n            if edges[i].stress < 0:\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_C - 1.0,\n                    0.0\n                )\n            else:\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_T - 1.0,\n                    0.0\n                )\n        return np.sum(stress_weight)\n\n    def _get_buckle_value(self, edges):\n        buckle_weight = np.zeros((len(edges), 1))\n        miu_buckle = 1.0\n        for tag, i in enumerate(edges.keys()):\n            edges[i].force = op.basicForce(tag)\n            if isMac:\n                edges[i].stress = edges[i].force / edges[i].area\n            else:\n                edges[i].stress = edges[i].force[0] / edges[i].area\n\n            if edges[i].stress < 0:\n                edges[i].inertia = (\n                        edges[i].area ** 2\n                        * (1 + self._ratio_ring ** 2)\n                        / (\n                                4 * math.pi\n                                * (1 - self._ratio_ring ** 2)\n                        )\n                )\n                force_cr = (\n                                   math.pi ** 2\n                                   * self._E * edges[i].inertia\n                           ) / (miu_buckle * edges[i].len) ** 2\n                buckle_stress_max = force_cr / edges[i].area\n                buckle_weight[tag] = max(\n                    abs(edges[i].stress) / abs(buckle_stress_max) - 1.0,\n                    0.0\n                )\n        return np.sum(buckle_weight)\n\n    def run(self, points, edges):\n        if 'IS_RUNNING_DYNAMIC' not in os.environ:\n            os.environ['IS_RUNNING_DYNAMIC'] = 'no'\n        while os.environ['IS_RUNNING_DYNAMIC'] == 'yes':\n            print('waiting for dynamics to be enabled')\n            time.sleep(0.1)\n        os.environ['IS_RUNNING_DYNAMIC'] = 'yes'\n        is_struct = self._is_struct(points, edges)\n        mass, dis_value, stress_value, buckle_value = 0.0, 0.0, 0.0, 0.0\n        if is_struct:\n            for i, edge in edges.items():\n                mass += edge.len * edge.area * self._pho\n            if self._use_dis_constraint:\n                dis_value = self._get_dis_value(points)\n            if self._use_stress_constraint:\n                stress_value = self._get_stress_value(edges)\n            if self._use_buckle_constraint:\n                buckle_value = self._get_buckle_value(edges)\n        os.environ['IS_RUNNING_DYNAMIC'] = 'no'\n        return (\n            is_struct,\n            mass, dis_value, stress_value, buckle_value\n        )", ""]}
{"filename": "Stage2/noise/noise_main.py", "chunked_list": ["import argparse\nimport copy\nimport os\nimport random\nimport torch as th\nimport rlkit.torch.pytorch_util as ptu\nfrom rlkit.envs.wrappers import NormalizedBoxEnv\nfrom rlkit.samplers.data_collector import MdpPathCollector\nfrom rlkit.data_management.env_replay_buffer import EnvReplayBuffer\nfrom rlkit.torch.sac.sac import SACTrainer", "from rlkit.data_management.env_replay_buffer import EnvReplayBuffer\nfrom rlkit.torch.sac.sac import SACTrainer\nfrom rlkit.torch.torch_rl_algorithm import TorchBatchRLAlgorithm\n\nfrom envs import Truss\nfrom models import MLP, TanhGaussianPolicy, MakeDeterministic, TRANSFORMEREMBED, EmbedTanhGaussianPolicy\n\nimport gtimer as gt\n\ndef get_args():\n    parser = argparse.ArgumentParser(description='Alpha Truss')\n    # Training args\n    parser.add_argument('--num_trains_per_train_loop', type=int, default=5, help='for sac training')\n    parser.add_argument('--num_train_loops_per_epoch', type=int, default=5, help='for sac training')\n    parser.add_argument('--hidden_dims', type=list, default=[256, 1024], help='hidden layer dimensions')\n    parser.add_argument('--buffer_size', type=int, default=1000000, help='buffer size')\n    parser.add_argument('--epoch', type=int, default=1, help='epoch')\n    parser.add_argument('--batch_size', type=int, default=256, help='batch size')\n    parser.add_argument('--evaluation', action='store_true', default=False)\n    parser.add_argument('--save_model_path', type=str, default='.')\n    parser.add_argument('--prev_dims', type=list, default=[8, 32], help='input dims for TransformerEmbed')\n    parser.add_argument('--post_dims', type=list, default=[256, 128], help='hidden dims for TransformerEmbed')\n    # Env args\n    parser.add_argument('--num_points', type=int, default=6, help='number of nodes')\n    parser.add_argument('--initial_state_files', type=str, default='best_results/Noise6789p_2/', help='input file for refine')\n    parser.add_argument('--coordinate_range', type=list, default=[(0.0, 18.288), (0.0, 9.144)], help='nodes\\' coordinate range')\n    parser.add_argument('--area_range', type=list, default=(6.452e-05, 0.04), help='edges\\' area range')\n    parser.add_argument('--coordinate_delta_range', type=list, default=[(-0.5715, 0.5715), (-0.5715, 0.5715)], help='nodes\\' coordinate delta range')\n    parser.add_argument('--area_delta_range', type=list, default=(-0.0005, 0.0005), help='edges\\' area delta range')\n    parser.add_argument('--fixed_points', type=int, default=4, help='number of fixed nodes')\n    parser.add_argument('--variable_edges', type=int, default=-1, help='number of variable edges, -1 if all is variable')\n    parser.add_argument('--max_refine_steps', type=int, default=200, help='maximum timesteps of an episode')\n\n    args = parser.parse_args()\n    return args", "\ndef get_args():\n    parser = argparse.ArgumentParser(description='Alpha Truss')\n    # Training args\n    parser.add_argument('--num_trains_per_train_loop', type=int, default=5, help='for sac training')\n    parser.add_argument('--num_train_loops_per_epoch', type=int, default=5, help='for sac training')\n    parser.add_argument('--hidden_dims', type=list, default=[256, 1024], help='hidden layer dimensions')\n    parser.add_argument('--buffer_size', type=int, default=1000000, help='buffer size')\n    parser.add_argument('--epoch', type=int, default=1, help='epoch')\n    parser.add_argument('--batch_size', type=int, default=256, help='batch size')\n    parser.add_argument('--evaluation', action='store_true', default=False)\n    parser.add_argument('--save_model_path', type=str, default='.')\n    parser.add_argument('--prev_dims', type=list, default=[8, 32], help='input dims for TransformerEmbed')\n    parser.add_argument('--post_dims', type=list, default=[256, 128], help='hidden dims for TransformerEmbed')\n    # Env args\n    parser.add_argument('--num_points', type=int, default=6, help='number of nodes')\n    parser.add_argument('--initial_state_files', type=str, default='best_results/Noise6789p_2/', help='input file for refine')\n    parser.add_argument('--coordinate_range', type=list, default=[(0.0, 18.288), (0.0, 9.144)], help='nodes\\' coordinate range')\n    parser.add_argument('--area_range', type=list, default=(6.452e-05, 0.04), help='edges\\' area range')\n    parser.add_argument('--coordinate_delta_range', type=list, default=[(-0.5715, 0.5715), (-0.5715, 0.5715)], help='nodes\\' coordinate delta range')\n    parser.add_argument('--area_delta_range', type=list, default=(-0.0005, 0.0005), help='edges\\' area delta range')\n    parser.add_argument('--fixed_points', type=int, default=4, help='number of fixed nodes')\n    parser.add_argument('--variable_edges', type=int, default=-1, help='number of variable edges, -1 if all is variable')\n    parser.add_argument('--max_refine_steps', type=int, default=200, help='maximum timesteps of an episode')\n\n    args = parser.parse_args()\n    return args", "\n\nif __name__ == '__main__':\n    for loop in range(50):\n        for point_num in range(6, 10):\n            print('loop:', loop, 'point_num:', point_num)\n            args = get_args()\n            #args.save_model_path = args.initial_state_files.replace('best_results', 'saved_models')\n            #args.save_model_path = args.save_model_path[:-1]\n            args.save_model_path = 'saved_models/Noise6789p_2'\n            args.num_points = int(point_num)\n            args.initial_state_files = 'best_results/Noise6789p_2/New' + str(point_num) + 'pointsNoise/'\n            if not os.path.exists(args.save_model_path):\n                os.mkdir(args.save_model_path)\n            UseEvalModel = False\n            if UseEvalModel:\n                args.save_model_path = 'saved_models/test6points'\n            if th.cuda.is_available():\n                ptu.set_gpu_mode(True)\n            _ = random.random()\n            if _ > 0.5:\n                best_n_results = 200\n            else:\n                best_n_results = -1\n            print('best_n_results:', best_n_results)\n            env = NormalizedBoxEnv(Truss(args.num_points, args.initial_state_files,\n                                         args.coordinate_range, args.area_range,\n                                         args.coordinate_delta_range, args.area_delta_range,\n                                         args.fixed_points, args.variable_edges,\n                                         args.max_refine_steps, best_n_results=best_n_results))\n\n            obs_dim = env.observation_space.low.size\n            action_dim = env.action_space.low.size\n            print(obs_dim, action_dim)\n            #qf1 = MLP(obs_dim + action_dim, args.hidden_dims)\n            #qf2 = MLP(obs_dim + action_dim, args.hidden_dims)\n            qf1 = TRANSFORMEREMBED(args.prev_dims, args.hidden_dims)\n            qf2 = TRANSFORMEREMBED(args.prev_dims, args.hidden_dims)\n            target_qf1 = copy.deepcopy(qf1)\n            target_qf2 = copy.deepcopy(qf2)\n            expl_policy = EmbedTanhGaussianPolicy(obs_dim=args.prev_dims[-1], action_dim=action_dim, hidden_sizes=args.hidden_dims, input_dims=args.prev_dims)\n            eval_policy = MakeDeterministic(expl_policy)\n            if os.path.exists(\"{}/qf1.th\".format(args.save_model_path)):\n                args.evaluation = True\n            if args.evaluation:\n                print(\"load pretrain\")\n                expl_policy.load_state_dict(th.load(\"{}/policy.th\".format(args.save_model_path)))\n                qf1.load_state_dict(th.load(\"{}/qf1.th\".format(args.save_model_path)))\n                qf2.load_state_dict(th.load(\"{}/qf2.th\".format(args.save_model_path)))\n                target_qf1.load_state_dict(th.load(\"{}/target_qf1.th\".format(args.save_model_path)))\n                target_qf2.load_state_dict(th.load(\"{}/target_qf2.th\".format(args.save_model_path)))\n\n\n            expl_path_collector = MdpPathCollector(env, expl_policy)\n            eval_path_collector = MdpPathCollector(env, eval_policy)\n            replay_buffer = EnvReplayBuffer(args.buffer_size, env)\n            trainer = SACTrainer(env=env, policy=expl_policy, qf1=qf1, qf2=qf2, target_qf1=target_qf1, target_qf2=target_qf2,\n                                 soft_target_tau=0.005, reward_scale=10., policy_lr=0.0003, qf_lr=0.0003)\n            algorithm = TorchBatchRLAlgorithm(trainer=trainer, exploration_env=env, evaluation_env=env,\n                                              exploration_data_collector=expl_path_collector,\n                                              evaluation_data_collector=eval_path_collector,\n                                              replay_buffer=replay_buffer,\n                                              num_epochs=args.epoch,\n                                              num_eval_steps_per_epoch=2000,\n                                              num_trains_per_train_loop=args.num_trains_per_train_loop,\n                                              num_train_loops_per_epoch=args.num_train_loops_per_epoch,\n                                              num_expl_steps_per_train_loop=1000,\n                                              min_num_steps_before_training=1000,\n                                              max_path_length=500,\n                                              batch_size=args.batch_size)\n            if not UseEvalModel:\n                gt.reset_root()\n            algorithm.to(ptu.device)\n            algorithm.train()\n\n            if not UseEvalModel:\n                trained_network = algorithm.trainer.networks\n                th.save(trained_network[0].state_dict(), \"{}/policy.th\".format(args.save_model_path))\n                th.save(trained_network[1].state_dict(), \"{}/qf1.th\".format(args.save_model_path))\n                th.save(trained_network[2].state_dict(), \"{}/qf2.th\".format(args.save_model_path))\n                th.save(trained_network[3].state_dict(), \"{}/target_qf1.th\".format(args.save_model_path))\n                th.save(trained_network[4].state_dict(), \"{}/target_qf2.th\".format(args.save_model_path))", ""]}
{"filename": "Stage2/noise/eval_noise.py", "chunked_list": ["import argparse\nimport copy\nimport os\nimport torch as th\nimport rlkit.torch.pytorch_util as ptu\nfrom rlkit.envs.wrappers import NormalizedBoxEnv\nfrom rlkit.samplers.data_collector import MdpPathCollector\nfrom rlkit.data_management.env_replay_buffer import EnvReplayBuffer\nfrom rlkit.torch.sac.sac import SACTrainer\nfrom rlkit.torch.torch_rl_algorithm import TorchBatchRLAlgorithm", "from rlkit.torch.sac.sac import SACTrainer\nfrom rlkit.torch.torch_rl_algorithm import TorchBatchRLAlgorithm\n\nfrom envs import Truss\nfrom models import MLP, TanhGaussianPolicy, MakeDeterministic, TRANSFORMEREMBED, EmbedTanhGaussianPolicy\n\nimport gtimer as gt\n\ndef get_args():\n    parser = argparse.ArgumentParser(description='Alpha Truss')\n    # Training args\n    parser.add_argument('--num_trains_per_train_loop', type=int, default=5, help='for sac training')\n    parser.add_argument('--num_train_loops_per_epoch', type=int, default=5, help='for sac training')\n    parser.add_argument('--hidden_dims', type=list, default=[256, 1024], help='hidden layer dimensions')\n    parser.add_argument('--buffer_size', type=int, default=1000000, help='buffer size')\n    parser.add_argument('--epoch', type=int, default=50, help='epoch')\n    parser.add_argument('--batch_size', type=int, default=256, help='batch size')\n    parser.add_argument('--evaluation', action='store_true', default=False)\n    parser.add_argument('--save_model_path', type=str, default='.')\n    parser.add_argument('--prev_dims', type=list, default=[8, 32], help='input dims for TransformerEmbed')\n    parser.add_argument('--post_dims', type=list, default=[256, 128], help='hidden dims for TransformerEmbed')\n    # Env args\n    parser.add_argument('--num_points', type=int, default=9, help='number of nodes')\n    parser.add_argument('--initial_state_files', type=str, default='best_results/NoSoft/NoSoft9p/', help='input file for refine')\n    parser.add_argument('--coordinate_range', type=list, default=[(0.0, 18.288), (0.0, 9.144)], help='nodes\\' coordinate range')\n    parser.add_argument('--area_range', type=list, default=(6.452e-05, 0.04), help='edges\\' area range')\n    parser.add_argument('--coordinate_delta_range', type=list, default=[(-0.5715, 0.5715), (-0.5715, 0.5715)], help='nodes\\' coordinate delta range')\n    parser.add_argument('--area_delta_range', type=list, default=(-0.0005, 0.0005), help='edges\\' area delta range')\n    parser.add_argument('--fixed_points', type=int, default=4, help='number of fixed nodes')\n    parser.add_argument('--variable_edges', type=int, default=-1, help='number of variable edges, -1 if all is variable')\n    parser.add_argument('--max_refine_steps', type=int, default=200, help='maximum timesteps of an episode')\n\n    args = parser.parse_args()\n    return args", "def get_args():\n    parser = argparse.ArgumentParser(description='Alpha Truss')\n    # Training args\n    parser.add_argument('--num_trains_per_train_loop', type=int, default=5, help='for sac training')\n    parser.add_argument('--num_train_loops_per_epoch', type=int, default=5, help='for sac training')\n    parser.add_argument('--hidden_dims', type=list, default=[256, 1024], help='hidden layer dimensions')\n    parser.add_argument('--buffer_size', type=int, default=1000000, help='buffer size')\n    parser.add_argument('--epoch', type=int, default=50, help='epoch')\n    parser.add_argument('--batch_size', type=int, default=256, help='batch size')\n    parser.add_argument('--evaluation', action='store_true', default=False)\n    parser.add_argument('--save_model_path', type=str, default='.')\n    parser.add_argument('--prev_dims', type=list, default=[8, 32], help='input dims for TransformerEmbed')\n    parser.add_argument('--post_dims', type=list, default=[256, 128], help='hidden dims for TransformerEmbed')\n    # Env args\n    parser.add_argument('--num_points', type=int, default=9, help='number of nodes')\n    parser.add_argument('--initial_state_files', type=str, default='best_results/NoSoft/NoSoft9p/', help='input file for refine')\n    parser.add_argument('--coordinate_range', type=list, default=[(0.0, 18.288), (0.0, 9.144)], help='nodes\\' coordinate range')\n    parser.add_argument('--area_range', type=list, default=(6.452e-05, 0.04), help='edges\\' area range')\n    parser.add_argument('--coordinate_delta_range', type=list, default=[(-0.5715, 0.5715), (-0.5715, 0.5715)], help='nodes\\' coordinate delta range')\n    parser.add_argument('--area_delta_range', type=list, default=(-0.0005, 0.0005), help='edges\\' area delta range')\n    parser.add_argument('--fixed_points', type=int, default=4, help='number of fixed nodes')\n    parser.add_argument('--variable_edges', type=int, default=-1, help='number of variable edges, -1 if all is variable')\n    parser.add_argument('--max_refine_steps', type=int, default=200, help='maximum timesteps of an episode')\n\n    args = parser.parse_args()\n    return args", "\n\nif __name__ == '__main__':\n    args = get_args()\n    point_num = args.num_points\n    #args.save_model_path = args.initial_state_files.replace('best_results', 'saved_models')\n    #args.save_model_path = args.save_model_path[:-1]\n    #args.save_model_path = 'saved_models/NewMixedNoise'\n    #args.num_points = int(point_num)\n    #if not os.path.exists(args.save_model_path):\n    #    os.mkdir(args.save_model_path)\n    UseEvalModel = True\n    if UseEvalModel:\n        args.save_model_path = 'saved_models/Noise6789p_2'\n    if th.cuda.is_available():\n        ptu.set_gpu_mode(True)\n    env = NormalizedBoxEnv(Truss(args.num_points, args.initial_state_files,\n                                 args.coordinate_range, args.area_range,\n                                 args.coordinate_delta_range, args.area_delta_range,\n                                 args.fixed_points, args.variable_edges,\n                                 args.max_refine_steps))\n\n    obs_dim = env.observation_space.low.size\n    action_dim = env.action_space.low.size\n    print(obs_dim, action_dim)\n    #qf1 = MLP(obs_dim + action_dim, args.hidden_dims)\n    #qf2 = MLP(obs_dim + action_dim, args.hidden_dims)\n    qf1 = TRANSFORMEREMBED(args.prev_dims, args.hidden_dims)\n    qf2 = TRANSFORMEREMBED(args.prev_dims, args.hidden_dims)\n    target_qf1 = copy.deepcopy(qf1)\n    target_qf2 = copy.deepcopy(qf2)\n    expl_policy = EmbedTanhGaussianPolicy(obs_dim=args.prev_dims[-1], action_dim=action_dim, hidden_sizes=args.hidden_dims, input_dims=args.prev_dims)\n    eval_policy = MakeDeterministic(expl_policy)\n    if os.path.exists(\"{}/qf1.th\".format(args.save_model_path)):\n        args.evaluation = True\n    if args.evaluation:\n        print(\"load pretrain\")\n        expl_policy.load_state_dict(th.load(\"{}/policy.th\".format(args.save_model_path)))\n        qf1.load_state_dict(th.load(\"{}/qf1.th\".format(args.save_model_path)))\n        qf2.load_state_dict(th.load(\"{}/qf2.th\".format(args.save_model_path)))\n        target_qf1.load_state_dict(th.load(\"{}/target_qf1.th\".format(args.save_model_path)))\n        target_qf2.load_state_dict(th.load(\"{}/target_qf2.th\".format(args.save_model_path)))\n\n\n    expl_path_collector = MdpPathCollector(env, expl_policy)\n    eval_path_collector = MdpPathCollector(env, eval_policy)\n    replay_buffer = EnvReplayBuffer(args.buffer_size, env)\n    trainer = SACTrainer(env=env, policy=expl_policy, qf1=qf1, qf2=qf2, target_qf1=target_qf1, target_qf2=target_qf2,\n                         soft_target_tau=0.005, reward_scale=10., policy_lr=0.0003, qf_lr=0.0003)\n    algorithm = TorchBatchRLAlgorithm(trainer=trainer, exploration_env=env, evaluation_env=env,\n                                      exploration_data_collector=expl_path_collector,\n                                      evaluation_data_collector=eval_path_collector,\n                                      replay_buffer=replay_buffer,\n                                      num_epochs=args.epoch,\n                                      num_eval_steps_per_epoch=2000,\n                                      num_trains_per_train_loop=args.num_trains_per_train_loop,\n                                      num_train_loops_per_epoch=args.num_train_loops_per_epoch,\n                                      num_expl_steps_per_train_loop=1000,\n                                      min_num_steps_before_training=1000,\n                                      max_path_length=500,\n                                      batch_size=args.batch_size)\n    if not UseEvalModel:\n        gt.reset_root()\n    algorithm.to(ptu.device)\n    algorithm.train()\n\n    if not UseEvalModel:\n        trained_network = algorithm.trainer.networks\n        th.save(trained_network[0].state_dict(), \"{}/policy.th\".format(args.save_model_path))\n        th.save(trained_network[1].state_dict(), \"{}/qf1.th\".format(args.save_model_path))\n        th.save(trained_network[2].state_dict(), \"{}/qf2.th\".format(args.save_model_path))\n        th.save(trained_network[3].state_dict(), \"{}/target_qf1.th\".format(args.save_model_path))\n        th.save(trained_network[4].state_dict(), \"{}/target_qf2.th\".format(args.save_model_path))", ""]}
{"filename": "Stage2/noise/train_noise.py", "chunked_list": ["import argparse\nimport copy\nimport os\nimport torch as th\nimport rlkit.torch.pytorch_util as ptu\nfrom rlkit.envs.wrappers import NormalizedBoxEnv\nfrom rlkit.samplers.data_collector import MdpPathCollector\nfrom rlkit.data_management.env_replay_buffer import EnvReplayBuffer\nfrom rlkit.torch.sac.sac import SACTrainer\nfrom rlkit.torch.torch_rl_algorithm import TorchBatchRLAlgorithm", "from rlkit.torch.sac.sac import SACTrainer\nfrom rlkit.torch.torch_rl_algorithm import TorchBatchRLAlgorithm\n\nfrom envs import Truss\nfrom models import MLP, TanhGaussianPolicy, MakeDeterministic, TRANSFORMEREMBED, EmbedTanhGaussianPolicy\n\nimport gtimer as gt\n\ndef get_args():\n    parser = argparse.ArgumentParser(description='Alpha Truss')\n    # Training args\n    parser.add_argument('--num_trains_per_train_loop', type=int, default=5, help='for sac training')\n    parser.add_argument('--num_train_loops_per_epoch', type=int, default=5, help='for sac training')\n    parser.add_argument('--hidden_dims', type=list, default=[256, 1024], help='hidden layer dimensions')\n    parser.add_argument('--buffer_size', type=int, default=1000000, help='buffer size')\n    parser.add_argument('--epoch', type=int, default=50, help='epoch')\n    parser.add_argument('--batch_size', type=int, default=256, help='batch size')\n    parser.add_argument('--evaluation', action='store_true', default=False)\n    parser.add_argument('--save_model_path', type=str, default='.')\n    parser.add_argument('--prev_dims', type=list, default=[8, 32], help='input dims for TransformerEmbed')\n    parser.add_argument('--post_dims', type=list, default=[256, 128], help='hidden dims for TransformerEmbed')\n    # Env args\n    parser.add_argument('--num_points', type=int, default=9, help='number of nodes')\n    parser.add_argument('--initial_state_files', type=str, default='best_results/TrainMax9p_1/', help='input file for refine')\n    parser.add_argument('--coordinate_range', type=list, default=[(0.0, 18.288), (0.0, 9.144)], help='nodes\\' coordinate range')\n    parser.add_argument('--area_range', type=list, default=(6.452e-05, 0.04), help='edges\\' area range')\n    parser.add_argument('--coordinate_delta_range', type=list, default=[(-0.5715, 0.5715), (-0.5715, 0.5715)], help='nodes\\' coordinate delta range')\n    parser.add_argument('--area_delta_range', type=list, default=(-0.0005, 0.0005), help='edges\\' area delta range')\n    parser.add_argument('--fixed_points', type=int, default=4, help='number of fixed nodes')\n    parser.add_argument('--variable_edges', type=int, default=-1, help='number of variable edges, -1 if all is variable')\n    parser.add_argument('--max_refine_steps', type=int, default=200, help='maximum timesteps of an episode')\n\n    args = parser.parse_args()\n    return args", "def get_args():\n    parser = argparse.ArgumentParser(description='Alpha Truss')\n    # Training args\n    parser.add_argument('--num_trains_per_train_loop', type=int, default=5, help='for sac training')\n    parser.add_argument('--num_train_loops_per_epoch', type=int, default=5, help='for sac training')\n    parser.add_argument('--hidden_dims', type=list, default=[256, 1024], help='hidden layer dimensions')\n    parser.add_argument('--buffer_size', type=int, default=1000000, help='buffer size')\n    parser.add_argument('--epoch', type=int, default=50, help='epoch')\n    parser.add_argument('--batch_size', type=int, default=256, help='batch size')\n    parser.add_argument('--evaluation', action='store_true', default=False)\n    parser.add_argument('--save_model_path', type=str, default='.')\n    parser.add_argument('--prev_dims', type=list, default=[8, 32], help='input dims for TransformerEmbed')\n    parser.add_argument('--post_dims', type=list, default=[256, 128], help='hidden dims for TransformerEmbed')\n    # Env args\n    parser.add_argument('--num_points', type=int, default=9, help='number of nodes')\n    parser.add_argument('--initial_state_files', type=str, default='best_results/TrainMax9p_1/', help='input file for refine')\n    parser.add_argument('--coordinate_range', type=list, default=[(0.0, 18.288), (0.0, 9.144)], help='nodes\\' coordinate range')\n    parser.add_argument('--area_range', type=list, default=(6.452e-05, 0.04), help='edges\\' area range')\n    parser.add_argument('--coordinate_delta_range', type=list, default=[(-0.5715, 0.5715), (-0.5715, 0.5715)], help='nodes\\' coordinate delta range')\n    parser.add_argument('--area_delta_range', type=list, default=(-0.0005, 0.0005), help='edges\\' area delta range')\n    parser.add_argument('--fixed_points', type=int, default=4, help='number of fixed nodes')\n    parser.add_argument('--variable_edges', type=int, default=-1, help='number of variable edges, -1 if all is variable')\n    parser.add_argument('--max_refine_steps', type=int, default=200, help='maximum timesteps of an episode')\n\n    args = parser.parse_args()\n    return args", "\n\nif __name__ == '__main__':\n    args = get_args()\n    point_num = args.num_points\n    #args.save_model_path = args.initial_state_files.replace('best_results', 'saved_models')\n    #args.save_model_path = args.save_model_path[:-1]\n    args.save_model_path = 'saved_models/TrainMax9p_1'\n    #args.num_points = int(point_num)\n    if not os.path.exists(args.save_model_path):\n        os.mkdir(args.save_model_path)\n    UseEvalModel = False\n    if UseEvalModel:\n        args.save_model_path = 'saved_models/Noise6789p_2'\n    if th.cuda.is_available():\n        ptu.set_gpu_mode(True)\n    env = NormalizedBoxEnv(Truss(args.num_points, args.initial_state_files,\n                                 args.coordinate_range, args.area_range,\n                                 args.coordinate_delta_range, args.area_delta_range,\n                                 args.fixed_points, args.variable_edges,\n                                 args.max_refine_steps))\n\n    obs_dim = env.observation_space.low.size\n    action_dim = env.action_space.low.size\n    print(obs_dim, action_dim)\n    #qf1 = MLP(obs_dim + action_dim, args.hidden_dims)\n    #qf2 = MLP(obs_dim + action_dim, args.hidden_dims)\n    qf1 = TRANSFORMEREMBED(args.prev_dims, args.hidden_dims)\n    qf2 = TRANSFORMEREMBED(args.prev_dims, args.hidden_dims)\n    target_qf1 = copy.deepcopy(qf1)\n    target_qf2 = copy.deepcopy(qf2)\n    expl_policy = EmbedTanhGaussianPolicy(obs_dim=args.prev_dims[-1], action_dim=action_dim, hidden_sizes=args.hidden_dims, input_dims=args.prev_dims)\n    eval_policy = MakeDeterministic(expl_policy)\n    if os.path.exists(\"{}/qf1.th\".format(args.save_model_path)):\n        args.evaluation = True\n    if args.evaluation:\n        print(\"load pretrain\")\n        expl_policy.load_state_dict(th.load(\"{}/policy.th\".format(args.save_model_path)))\n        qf1.load_state_dict(th.load(\"{}/qf1.th\".format(args.save_model_path)))\n        qf2.load_state_dict(th.load(\"{}/qf2.th\".format(args.save_model_path)))\n        target_qf1.load_state_dict(th.load(\"{}/target_qf1.th\".format(args.save_model_path)))\n        target_qf2.load_state_dict(th.load(\"{}/target_qf2.th\".format(args.save_model_path)))\n\n\n    expl_path_collector = MdpPathCollector(env, expl_policy)\n    eval_path_collector = MdpPathCollector(env, eval_policy)\n    replay_buffer = EnvReplayBuffer(args.buffer_size, env)\n    trainer = SACTrainer(env=env, policy=expl_policy, qf1=qf1, qf2=qf2, target_qf1=target_qf1, target_qf2=target_qf2,\n                         soft_target_tau=0.005, reward_scale=10., policy_lr=0.0003, qf_lr=0.0003)\n    algorithm = TorchBatchRLAlgorithm(trainer=trainer, exploration_env=env, evaluation_env=env,\n                                      exploration_data_collector=expl_path_collector,\n                                      evaluation_data_collector=eval_path_collector,\n                                      replay_buffer=replay_buffer,\n                                      num_epochs=args.epoch,\n                                      num_eval_steps_per_epoch=2000,\n                                      num_trains_per_train_loop=args.num_trains_per_train_loop,\n                                      num_train_loops_per_epoch=args.num_train_loops_per_epoch,\n                                      num_expl_steps_per_train_loop=1000,\n                                      min_num_steps_before_training=1000,\n                                      max_path_length=500,\n                                      batch_size=args.batch_size)\n    if not UseEvalModel:\n        gt.reset_root()\n    algorithm.to(ptu.device)\n    algorithm.train()\n\n    if not UseEvalModel:\n        trained_network = algorithm.trainer.networks\n        th.save(trained_network[0].state_dict(), \"{}/policy.th\".format(args.save_model_path))\n        th.save(trained_network[1].state_dict(), \"{}/qf1.th\".format(args.save_model_path))\n        th.save(trained_network[2].state_dict(), \"{}/qf2.th\".format(args.save_model_path))\n        th.save(trained_network[3].state_dict(), \"{}/target_qf1.th\".format(args.save_model_path))\n        th.save(trained_network[4].state_dict(), \"{}/target_qf2.th\".format(args.save_model_path))", ""]}
{"filename": "truss_envs/dynamic.py", "chunked_list": ["import numpy as np\nimport math, time\nimport sys, os\nimport openseespy.opensees as op\nimport matplotlib.pyplot as plt\nfrom collections import OrderedDict\nbase_path = os.getcwd()\nsys.path.append(base_path)\nfrom utils.utils import readFile, closestDistanceBetweenLines\ndef blockPrint():\n    sys.stdout = open(os.devnull, 'w')\n    sys.stderr = open(os.devnull, 'w')", "from utils.utils import readFile, closestDistanceBetweenLines\ndef blockPrint():\n    sys.stdout = open(os.devnull, 'w')\n    sys.stderr = open(os.devnull, 'w')\n\ndef enablePrint():\n    sys.stdout = sys.__stdout__\n    sys.stderr = sys.__stderr__\n\nclass DynamicModel:\n    #\u6784\u9020\u51fd\u6570\n    def __init__(self,\n                dimension,\n                E=193*10**9,          #N/m2\n                pho=8.0*10**3,        #kg/m3\n                sigma_T=123*10**6,    #N/m2\n                sigma_C=213*10**6,    #N/m2\n                dislimit=0.002,       #m\n                slenderness_ratio_T=220,\n                slenderness_ratio_C=180,\n                max_len=5.0,            #m\n                min_len=0.03,         #m\n                use_self_weight=True,\n                use_dis_constraint=True,\n                use_stress_constraint=True,\n                use_buckle_constraint=True,\n                use_slenderness_constraint=True,\n                use_longer_constraint=True,\n                use_shorter_constraint=True,\n                use_cross_constraint=True,\n                ): \n        self._dimension = dimension    #\u7ed3\u6784\u7ef4\u5ea6\n        self._E = E                    #\u5f39\u6027\u6a21\u91cf\n        self._pho = pho                #\u6750\u6599\u5bc6\u5ea6\n        self._sigma_T = sigma_T        #\u5bb9\u8bb8\u62c9\u5e94\u529b\n        self._sigma_C = sigma_C        #\u5bb9\u8bb8\u538b\u5e94\u529b\n        self._limit_dis = dislimit     #\u5bb9\u8bb8\u4f4d\u79fb\n        self.slenderness_ratio_T=slenderness_ratio_T #\u5bb9\u8bb8\u53d7\u62c9\u957f\u7ec6\u6bd4\n        self.slenderness_ratio_C=slenderness_ratio_C #\u5bb9\u8bb8\u53d7\u538b\u957f\u7ec6\u6bd4\n        self.max_len=max_len                         #\u6700\u5927\u957f\u5ea6\n        self.min_len=min_len                         #\u6700\u5c0f\u957f\u5ea6\n        self._use_self_weight = use_self_weight              #\u662f\u5426\u8ba1\u7b97\u81ea\u91cd\n        self._use_dis_constraint = use_dis_constraint        #\u662f\u5426\u542f\u7528\u4f4d\u79fb\u7ea6\u675f\n        self._use_stress_constraint = use_stress_constraint         #\u662f\u5426\u542f\u7528\u5e94\u529b\u7ea6\u675f\n        self._use_buckle_constraint = use_buckle_constraint         #\u662f\u5426\u542f\u7528\u5c48\u66f2\u7ea6\u675f\n        self._use_slenderness_constraint=use_slenderness_constraint #\u662f\u5426\u542f\u7528\u957f\u7ec6\u6bd4\u7ea6\u675f\n        self._use_longer_constraint=use_longer_constraint           #\u662f\u5426\u542f\u7528\u8d85\u957f\u7ea6\u675f\n        self._use_shorter_constraint=use_shorter_constraint         #\u662f\u5426\u542f\u7528\u8fc7\u77ed\u7ea6\u675f\n        self._use_cross_constraint=use_cross_constraint             #\u662f\u5426\u542f\u7528\u6746\u4ef6\u4ea4\u53c9\u7ea6\u675f\n        print(self._use_self_weight)\n        print(self._use_buckle_constraint)\n\n    #\u5224\u5b9a\u7ed3\u6784\u7684\u51e0\u4f55\u4e0d\u53d8\u6027+\u5206\u6790\u8ba1\u7b97\n    def _is_struct(self, points, edges):\n        ########\u8ba1\u7b97\u81ea\u7531\u5ea6\u521d\u5224\u7ed3\u6784\u51e0\u4f55\u4e0d\u53d8\u6027##########\n        total_support = 0             #\u4fdd\u5b58\u652f\u5ea7\u7ea6\u675f\u6570\n        for p in points:\n            if self._dimension == 2:  #\u5e73\u9762\u6841\u67b6\n                total_support += (\n                    p.supportX\n                    + p.supportY\n                )\n            else:                     #\u7a7a\u95f4\u6841\u67b6\n                total_support += (\n                    p.supportX\n                    + p.supportY\n                    + p.supportZ\n                )\n\n        if len(points) * self._dimension - len(edges) - total_support > 0:\n            return (False)   #\u8ba1\u7b97\u81ea\u7531\u5ea6>0\uff0c\u7ed3\u6784\u4e0d\u7a33\u5b9a\u76f4\u63a5\u8fd4\u56deFalse\n        \n        blockPrint()\n        #######\u4ee5\u4e0b\u57fa\u4e8e\u70b9\u548c\u8fb9\u96c6\u5efa\u7acb\u6709\u9650\u5143\u6a21\u5f62\u5206\u6790########\n        op.wipe()   # \u6e05\u9664\u6240\u6709\u5df2\u6709\u7ed3\u6784\n        op.model('basic', '-ndm', self._dimension, '-ndf', self._dimension)  #\u8bbe\u7f6e\u5efa\u6a21\u5668\n\n        for i, point in enumerate(points):   #\u5efa\u7acb\u8282\u70b9\n            if self._dimension == 2:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                )\n            else:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                    point.vec.z,\n                )\n\n        for i, point in enumerate(points):  #\u65bd\u52a0\u8282\u70b9\u652f\u5ea7\u7ea6\u675f\n                if self._dimension == 2:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                    )\n                else:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                        point.supportZ,\n                    )\n\n        op.timeSeries(\"Linear\", 1)\n        op.pattern(\"Plain\", 1, 1)\n        \n        for i, point in enumerate(points):  #\u6dfb\u52a0\u8282\u70b9\u8377\u8f7d\n            if point.isLoad:\n                if self._dimension == 2:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                    )\n                else:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                        point.loadZ,\n                    )\n\n        op.uniaxialMaterial(\"Elastic\", 1, self._E)   #\u5b9a\u4e49\u6750\u6599\n\n        for i, edge in enumerate(edges):\n            op.element(\"Truss\", i, edge.u, edge.v, edge.area, 1)  #\u8d4b\u4e88\u6746\u4ef6\u622a\u9762\u5c5e\u6027\n        \n        \n        \n        if self._use_self_weight:  #\u5982\u679c\u8ba1\u7b97\u81ea\u91cd\u65f6\n            gravity = 9.8   #\u91cd\u529b\u52a0\u901f\u5ea6\n            load_gravity = [0 for _ in range(len(points))]  #\u521d\u59cb\u5316\u4e86\u4e00\u4e2aload_gravity\u5217\u8868\uff0c\u8868\u5f81\u6746\u4ef6\u81ea\u91cd\u7684\u7b49\u6548\u7ed3\u70b9\u529b\uff0clen(points)\u4e2a\u5143\u7d20\u5747\u4e3a0\n\n            for i, edge in enumerate(edges):\n                edge_mass = edge.len * edge.area * self._pho       #\u6bcf\u6839\u6746\u4ef6\u8d28\u91cf\n                load_gravity[edge.u] += edge_mass * gravity * 0.5\n                load_gravity[edge.v] += edge_mass * gravity * 0.5  #\u6bcf\u6839\u6746\u4ef6\u7684\u91cd\u529b\u5411\u4e24\u7aef\u5206\u4e00\u534a\u5230\u8282\u70b9\u4e0a\n            \n            for i in range(len(points)):        #\u5c06\u91cd\u529b\u8377\u8f7d\u7b49\u6548\u65bd\u52a0\u4e8e\u8282\u70b9\u4e0a\n                if self._dimension == 2:        #\u5982\u679c\u662f\u5e73\u9762\u7ed3\u6784\n                    op.load(i, 0.0, -1 * load_gravity[i])\n                else:                           #\u5982\u679c\u662f\u7a7a\u95f4\u7ed3\u6784\n                    op.load(i, 0.0, 0.0, -1 * load_gravity[i])\n        \n        op.system(\"BandSPD\")\n        op.numberer(\"RCM\")\n        op.constraints(\"Plain\")\n        op.integrator(\"LoadControl\", 1.0)\n        op.algorithm(\"Newton\")\n        op.analysis(\"Static\")\n        ok = op.analyze(1)  #\u8fd0\u884c\u5206\u6790\uff0cok\u8868\u5f81\u662f\u5426\u6210\u529f\u8fd0\u884c\uff0c\u8fd4\u56de0\u4ee3\u8868\u6210\u529f\uff0c\u8fd4\u56de<0\u5931\u8d25\u3002\uff08\u6ce8:\u8fd9\u91cc\u5bf9\u7ed3\u6784\u7684\u51e0\u4f55\u4e0d\u53d8\u6027\u8fdb\u884c\u4e86\u5145\u5206\u5224\u65ad\uff09\n        if ok < 0:\n            ok = False\n        else:\n            ok = True\n        enablePrint()\n        return ok\n    \n    #\u8bc4\u4f30\u8282\u70b9\u4f4d\u79fb\n    def _get_dis_value(self, points, mode = 'check'):\n        displacement_weight = np.zeros((len(points), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u4f4d\u79fb\u6570\u636e\n        for i in range(len(points)):\n            if self._dimension == 2:\n                weight = max(   \n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                )                                  #\u53ea\u8003\u8651x,y,(z)\u65b9\u5411\u4e0a\u7684\u6700\u5927\u7684\u4e00\u4e2a\u7ebf\u4f4d\u79fb\n            else:\n                weight = max(\n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                    abs(op.nodeDisp(i, 3)),\n                )\n            if (mode == 'check'): print(\"\u7b2c{:}\u7ed3\u70b9\u4f4d\u79fb\u4e3a{:}mm\".format(i,weight*10**3))\n            displacement_weight[i] = max(weight / self._limit_dis - 1, 0)  #\u5224\u5b9a\u8282\u70b9\u4f4d\u79fb\u662f\u5426\u8d85\u9650\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\uff0c\u6700\u540e\u7d2f\u52a0\u6570\u7ec4\u4e2d\u7684\u6570\u503c\u4f5c\u4e3a\u4f4d\u79fb\u8bc4\u4f30\u53c2\u7167\n        return displacement_weight\n    \n    #\u8bc4\u4f30\u6746\u4ef6\u5e94\u529b\n    def _get_stress_value(self, edges, mode = 'check'):\n        stress_weight = np.zeros(len(edges))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u5e94\u529b\u6570\u636e\n\n        for tag, i in enumerate(range(len(edges))):\n            edges[i].force = op.basicForce(tag)   #\u4ece\u6709\u9650\u5143\u5f97\u5230\u6746\u4ef6\u8f74\u529b\n            edges[i].stress = edges[i].force[0] / edges[i].area  #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            if (mode == 'check'): print(\"\u7b2c{:}\u6746\u4ef6\u5e94\u529b\u4e3a{:}MPa\".format(i,edges[i].stress*10**(-6)))\n            if edges[i].stress < 0:                                  #\u538b\u6746\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_C - 1.0,\n                    0.0\n                )\n            else:                                                    #\u62c9\u6746\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_T - 1.0,\n                    0.0\n                )\n        return stress_weight  #\u5224\u5b9a\u8282\u70b9\u5e94\u529b\u662f\u5426\u8d85\u9650\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\uff0c\u6700\u540e\u7d2f\u52a0\u6570\u7ec4\u4e2d\u7684\u6570\u503c\u4f5c\u4e3a\u5e94\u529b\u8bc4\u4f30\u53c2\u7167\n\n    #\u8bc4\u4f30\u6746\u4ef6\u5c48\u66f2\n    def _get_buckle_value(self, edges):\n        buckle_weight = np.zeros(len(edges))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u5c48\u66f2\u6570\u636e\n        miu_buckle = 1.0                           #\u6746\u4ef6\u8ba1\u7b97\u957f\u5ea6\u7cfb\u6570\uff0c\u6841\u67b6\u4e24\u7aef\u94f0\u63a5\u53d61\n        \n        for i in range(len(edges)):\n            edges[i].force = op.basicForce(i)    #\u5b58\u653e\u8f74\u529b\u6570\u636e\n            edges[i].stress = edges[i].force[0] / edges[i].area #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            if edges[i].stress < 0:    #\u4ec5\u538b\u6746\u624d\u8003\u8651\u5c48\u66f2\n                #\u8ba1\u7b97\u6b27\u62c9\u4e34\u754c\u529b\n                force_cr = (\n                    math.pi ** 2 \n                    * self._E * edges[i].inertia\n                ) / (miu_buckle * edges[i].len) ** 2\n\n                #\u8ba1\u7b97\u6b27\u62c9\u4e34\u754c\u5e94\u529b\n                buckle_stress_max = force_cr / edges[i].area\n\n                buckle_weight[i] = max(\n                    abs(edges[i].stress) / abs(buckle_stress_max) - 1.0,\n                    0.0\n                )#\u5224\u5b9a\u6746\u4ef6\u538b\u5e94\u529b\u662f\u5426\u8d85\u8fc7\u5c48\u66f2\u4e34\u754c\u5e94\u529b\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return buckle_weight\n    \n    #\u8bc4\u4f30\u6746\u4ef6\u957f\u7ec6\u6bd4\n    def _get_slenderness_ratio(self, edges):\n        lambda_weight = np.zeros(len(edges))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for i in range(len(edges)):\n            edges[i].force = op.basicForce(i)    #\u5b58\u653e\u8f74\u529b\u6570\u636e\n            edges[i].stress = edges[i].force[0] / edges[i].area #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            lambda_weight[i] = max(\n                # self.len/(self.inertia/self.area)**0.5\n                abs(edges[i].len / (edges[i].inertia / edges[i].area) ** 0.5) / abs(self.slenderness_ratio_C if edges[i].stress < 0 else self.slenderness_ratio_T) - 1.0,\n                0.0\n            )#\u5224\u5b9a\u6746\u4ef6\u957f\u7ec6\u6bd4\u662f\u5426\u8d85\u8fc7\u9650\u5236\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return lambda_weight\n\n    #\u8bc4\u4f30\u6746\u4ef6\u8d85\u957f\n    def _get_length_longer(self, edges):\n        longer_weight = np.zeros(len(edges))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for i in range(len(edges)):   \n            longer_weight[i] = max(\n                abs(edges[i].len) / abs(self.max_len) - 1.0,\n                0.0\n            )#\u5224\u5b9a\u6746\u4ef6\u957f\u5ea6\u662f\u5426\u8d85\u8fc7\u9650\u5236\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return longer_weight\n\n    #\u8bc4\u4f30\u6746\u4ef6\u8fc7\u77ed\n    def _get_length_shorter(self, edges):\n        shorter_weight = np.zeros(len(edges))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for i in range(len(edges)): \n            if edges[i].len < self.min_len:\n                shorter_weight[i] = 1.0-edges[i].len / self.min_len\n                #\u5224\u5b9a\u6746\u4ef6\u957f\u5ea6\u662f\u5426\u8fc7\u77ed\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return shorter_weight\n\n    def _get_cross_value(self, points, edges):\n        cross_value = 0\n        for i in range(len(edges)):\n            for j in range(len(edges)):\n                if (edges[i].u == edges[j].v or edges[i].u == edges[j].u or edges[i].v == edges[j].v or edges[i].v == edges[j].u): continue\n                _, _, dis = closestDistanceBetweenLines(points[edges[i].u].Point2np(), points[edges[i].v].Point2np(), points[edges[j].u].Point2np(), points[edges[j].v].Point2np(), clampAll = True)\n                if (edges[i].d != None):\n                    r1, r2 = edges[i].d / 2, edges[j].d / 2\n                else:\n                    if (self._dimension == 2):\n                        r1, r2 = edges[i].area / 2, edges[j].area / 2\n                    elif (self._dimension == 3):\n                        r1, r2 = np.sqrt(edges[i].area / np.pi), np.sqrt(edges[j].area / np.pi)\n                if (dis <= r1 + r2): cross_value += 1\n        return cross_value\n\n    #\u8c03\u7528\u4ee5\u4e0a\u51fd\u6570\u8fd0\u884c\u7ed3\u6784\u5206\u6790\n    def run(self, points, edges, mode = 'check'):\n        # if mode = check, return a list\n        # else, return value\n        if 'IS_RUNNING_DYNAMIC' not in os.environ:\n            os.environ['IS_RUNNING_DYNAMIC'] = 'no'\n        while os.environ['IS_RUNNING_DYNAMIC'] == 'yes':\n            print('waiting for dynamics to be enabled')\n            time.sleep(0.1)\n        os.environ['IS_RUNNING_DYNAMIC'] = 'yes'\n        if (type(points) == dict or type(points) == OrderedDict):\n            _points = []\n            for i, point in points.items():\n                _points.append(point)\n            points = _points\n        \n        if (type(edges) == dict or type(edges) == OrderedDict):\n            _edges = []\n            for i, edge in edges.items():\n                _edges.append(edge)\n            edges = _edges\n\n\n        is_struct = self._is_struct(points, edges) #\u8fd0\u884c\u7ed3\u6784\u5efa\u6a21\u4e0e\u5206\u6790\uff0cis_struct\u8fd4\u56de\u7ed3\u6784\u662f\u5426\u6b63\u5e38\u5b8c\u6210\u5206\u6790\n        mass, dis_value, stress_value, buckle_value, slenderness_value, longer_value, shorter_value, cross_value = 0, 0, 0, 0, 0, 0, 0, 0\n        for edge in edges: mass += edge.len * edge.area * self._pho      #\u8ba1\u7b97\u7ed3\u6784\u603b\u8d28\u91cf\n        if is_struct: #\u5982\u679c\u7ed3\u6784\u6210\u529f\u5b8c\u6210\u5206\u6790\uff0c\u5373\u7ed3\u6784\u662f\u51e0\u4f55\u4e0d\u53d8\u7684\n            if self._use_dis_constraint:\n                dis_value = self._get_dis_value(points, mode)       #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u4f4d\u79fb\u8bc4\u4f30\u7ed3\u679c\n            if self._use_stress_constraint:\n                stress_value = self._get_stress_value(edges, mode)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u5e94\u529b\u8bc4\u4f30\u7ed3\u679c\n            if self._use_buckle_constraint:\n                buckle_value = self._get_buckle_value(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u5c48\u66f2\u8bc4\u4f30\u7ed3\u679c\n            if self._use_slenderness_constraint:\n                slenderness_value = self._get_slenderness_ratio(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c    \n            if self._use_longer_constraint:\n                longer_value = self._get_length_longer(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c\n            if self._use_shorter_constraint:\n                shorter_value = self._get_length_shorter(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c\n        if self._use_cross_constraint:\n            cross_value = self._get_cross_value(points, edges)\n\n        if (mode != 'check'):\n            if (is_struct and self._use_dis_constraint): dis_value = dis_value.sum()\n            if (is_struct and self._use_buckle_constraint): buckle_value = buckle_value.sum()\n            if (is_struct and self._use_slenderness_constraint): slenderness_value = slenderness_value.sum()\n            if (is_struct and self._use_stress_constraint): stress_value = stress_value.sum()\n            if (is_struct and self._use_longer_constraint): longer_value = longer_value.sum()\n            if (is_struct and self._use_shorter_constraint): shorter_value = shorter_value.sum()\n        os.environ['IS_RUNNING_DYNAMIC'] = 'no'\n        return (\n            is_struct, mass, dis_value, stress_value, buckle_value, slenderness_value, longer_value, shorter_value, cross_value\n        )\n\n    #\u7ed8\u5236\u5e73\u9762\u6841\u67b6\n    def render(self, points, edges):\n        _ax = plt.axes(projection='3d')\n        for point in points.values():   #\u7ed8\u5236\u8282\u70b9\uff0cscatter()\u7ed8\u5236\u6563\u70b9\n            if point.isSupport:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='g') #\u652f\u5ea7\u70b9\u4e3a\u7eff\u8272\n            elif point.isLoad:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='r') #\u8377\u8f7d\u4f5c\u7528\u7684\u8282\u70b9\u4e3a\u7ea2\u8272\n            else:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='b') #\u5176\u4f59\u8282\u70b9\u84dd\u8272\n\n        for edge in edges.values():    #\u7ed8\u5236\u6746\u4ef6\n            x0 = [points[edge.u].vec.x, points[edge.v].vec.x]   #\u6746\u4ef6\u8d77\u70b9\n            y0 = [points[edge.u].vec.y, points[edge.v].vec.y]   #\u6746\u4ef6\u7ec8\u70b9\n            z0 = [points[edge.u].vec.z, points[edge.v].vec.z]   #\u6746\u4ef6\u8d77\u70b9\n            \n            if edge.stress < -1e-7:\n                _ax.plot(x0, y0, z0, color='g', linewidth=(edge.area / math.pi)**0.5*500)    #\u538b\u6746\u7eff\u8272\n            elif edge.stress > 1e-7:\n                _ax.plot(x0, y0, z0, color='r', linewidth=(edge.area / math.pi)**0.5*500)    #\u62c9\u6746\u7ea2\u8272\n            else:\n                _ax.plot(x0, y0, z0, color='k', linewidth=(edge.area / math.pi)**0.5*500)    #\u96f6\u6746\u9ed1\u8272\n        plt.show() #\u663e\u793a\u56fe\u50cf", "\nclass DynamicModel:\n    #\u6784\u9020\u51fd\u6570\n    def __init__(self,\n                dimension,\n                E=193*10**9,          #N/m2\n                pho=8.0*10**3,        #kg/m3\n                sigma_T=123*10**6,    #N/m2\n                sigma_C=213*10**6,    #N/m2\n                dislimit=0.002,       #m\n                slenderness_ratio_T=220,\n                slenderness_ratio_C=180,\n                max_len=5.0,            #m\n                min_len=0.03,         #m\n                use_self_weight=True,\n                use_dis_constraint=True,\n                use_stress_constraint=True,\n                use_buckle_constraint=True,\n                use_slenderness_constraint=True,\n                use_longer_constraint=True,\n                use_shorter_constraint=True,\n                use_cross_constraint=True,\n                ): \n        self._dimension = dimension    #\u7ed3\u6784\u7ef4\u5ea6\n        self._E = E                    #\u5f39\u6027\u6a21\u91cf\n        self._pho = pho                #\u6750\u6599\u5bc6\u5ea6\n        self._sigma_T = sigma_T        #\u5bb9\u8bb8\u62c9\u5e94\u529b\n        self._sigma_C = sigma_C        #\u5bb9\u8bb8\u538b\u5e94\u529b\n        self._limit_dis = dislimit     #\u5bb9\u8bb8\u4f4d\u79fb\n        self.slenderness_ratio_T=slenderness_ratio_T #\u5bb9\u8bb8\u53d7\u62c9\u957f\u7ec6\u6bd4\n        self.slenderness_ratio_C=slenderness_ratio_C #\u5bb9\u8bb8\u53d7\u538b\u957f\u7ec6\u6bd4\n        self.max_len=max_len                         #\u6700\u5927\u957f\u5ea6\n        self.min_len=min_len                         #\u6700\u5c0f\u957f\u5ea6\n        self._use_self_weight = use_self_weight              #\u662f\u5426\u8ba1\u7b97\u81ea\u91cd\n        self._use_dis_constraint = use_dis_constraint        #\u662f\u5426\u542f\u7528\u4f4d\u79fb\u7ea6\u675f\n        self._use_stress_constraint = use_stress_constraint         #\u662f\u5426\u542f\u7528\u5e94\u529b\u7ea6\u675f\n        self._use_buckle_constraint = use_buckle_constraint         #\u662f\u5426\u542f\u7528\u5c48\u66f2\u7ea6\u675f\n        self._use_slenderness_constraint=use_slenderness_constraint #\u662f\u5426\u542f\u7528\u957f\u7ec6\u6bd4\u7ea6\u675f\n        self._use_longer_constraint=use_longer_constraint           #\u662f\u5426\u542f\u7528\u8d85\u957f\u7ea6\u675f\n        self._use_shorter_constraint=use_shorter_constraint         #\u662f\u5426\u542f\u7528\u8fc7\u77ed\u7ea6\u675f\n        self._use_cross_constraint=use_cross_constraint             #\u662f\u5426\u542f\u7528\u6746\u4ef6\u4ea4\u53c9\u7ea6\u675f\n        print(self._use_self_weight)\n        print(self._use_buckle_constraint)\n\n    #\u5224\u5b9a\u7ed3\u6784\u7684\u51e0\u4f55\u4e0d\u53d8\u6027+\u5206\u6790\u8ba1\u7b97\n    def _is_struct(self, points, edges):\n        ########\u8ba1\u7b97\u81ea\u7531\u5ea6\u521d\u5224\u7ed3\u6784\u51e0\u4f55\u4e0d\u53d8\u6027##########\n        total_support = 0             #\u4fdd\u5b58\u652f\u5ea7\u7ea6\u675f\u6570\n        for p in points:\n            if self._dimension == 2:  #\u5e73\u9762\u6841\u67b6\n                total_support += (\n                    p.supportX\n                    + p.supportY\n                )\n            else:                     #\u7a7a\u95f4\u6841\u67b6\n                total_support += (\n                    p.supportX\n                    + p.supportY\n                    + p.supportZ\n                )\n\n        if len(points) * self._dimension - len(edges) - total_support > 0:\n            return (False)   #\u8ba1\u7b97\u81ea\u7531\u5ea6>0\uff0c\u7ed3\u6784\u4e0d\u7a33\u5b9a\u76f4\u63a5\u8fd4\u56deFalse\n        \n        blockPrint()\n        #######\u4ee5\u4e0b\u57fa\u4e8e\u70b9\u548c\u8fb9\u96c6\u5efa\u7acb\u6709\u9650\u5143\u6a21\u5f62\u5206\u6790########\n        op.wipe()   # \u6e05\u9664\u6240\u6709\u5df2\u6709\u7ed3\u6784\n        op.model('basic', '-ndm', self._dimension, '-ndf', self._dimension)  #\u8bbe\u7f6e\u5efa\u6a21\u5668\n\n        for i, point in enumerate(points):   #\u5efa\u7acb\u8282\u70b9\n            if self._dimension == 2:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                )\n            else:\n                op.node(\n                    i,\n                    point.vec.x,\n                    point.vec.y,\n                    point.vec.z,\n                )\n\n        for i, point in enumerate(points):  #\u65bd\u52a0\u8282\u70b9\u652f\u5ea7\u7ea6\u675f\n                if self._dimension == 2:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                    )\n                else:\n                    op.fix(\n                        i,\n                        point.supportX,\n                        point.supportY,\n                        point.supportZ,\n                    )\n\n        op.timeSeries(\"Linear\", 1)\n        op.pattern(\"Plain\", 1, 1)\n        \n        for i, point in enumerate(points):  #\u6dfb\u52a0\u8282\u70b9\u8377\u8f7d\n            if point.isLoad:\n                if self._dimension == 2:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                    )\n                else:\n                    op.load(\n                        i,\n                        point.loadX,\n                        point.loadY,\n                        point.loadZ,\n                    )\n\n        op.uniaxialMaterial(\"Elastic\", 1, self._E)   #\u5b9a\u4e49\u6750\u6599\n\n        for i, edge in enumerate(edges):\n            op.element(\"Truss\", i, edge.u, edge.v, edge.area, 1)  #\u8d4b\u4e88\u6746\u4ef6\u622a\u9762\u5c5e\u6027\n        \n        \n        \n        if self._use_self_weight:  #\u5982\u679c\u8ba1\u7b97\u81ea\u91cd\u65f6\n            gravity = 9.8   #\u91cd\u529b\u52a0\u901f\u5ea6\n            load_gravity = [0 for _ in range(len(points))]  #\u521d\u59cb\u5316\u4e86\u4e00\u4e2aload_gravity\u5217\u8868\uff0c\u8868\u5f81\u6746\u4ef6\u81ea\u91cd\u7684\u7b49\u6548\u7ed3\u70b9\u529b\uff0clen(points)\u4e2a\u5143\u7d20\u5747\u4e3a0\n\n            for i, edge in enumerate(edges):\n                edge_mass = edge.len * edge.area * self._pho       #\u6bcf\u6839\u6746\u4ef6\u8d28\u91cf\n                load_gravity[edge.u] += edge_mass * gravity * 0.5\n                load_gravity[edge.v] += edge_mass * gravity * 0.5  #\u6bcf\u6839\u6746\u4ef6\u7684\u91cd\u529b\u5411\u4e24\u7aef\u5206\u4e00\u534a\u5230\u8282\u70b9\u4e0a\n            \n            for i in range(len(points)):        #\u5c06\u91cd\u529b\u8377\u8f7d\u7b49\u6548\u65bd\u52a0\u4e8e\u8282\u70b9\u4e0a\n                if self._dimension == 2:        #\u5982\u679c\u662f\u5e73\u9762\u7ed3\u6784\n                    op.load(i, 0.0, -1 * load_gravity[i])\n                else:                           #\u5982\u679c\u662f\u7a7a\u95f4\u7ed3\u6784\n                    op.load(i, 0.0, 0.0, -1 * load_gravity[i])\n        \n        op.system(\"BandSPD\")\n        op.numberer(\"RCM\")\n        op.constraints(\"Plain\")\n        op.integrator(\"LoadControl\", 1.0)\n        op.algorithm(\"Newton\")\n        op.analysis(\"Static\")\n        ok = op.analyze(1)  #\u8fd0\u884c\u5206\u6790\uff0cok\u8868\u5f81\u662f\u5426\u6210\u529f\u8fd0\u884c\uff0c\u8fd4\u56de0\u4ee3\u8868\u6210\u529f\uff0c\u8fd4\u56de<0\u5931\u8d25\u3002\uff08\u6ce8:\u8fd9\u91cc\u5bf9\u7ed3\u6784\u7684\u51e0\u4f55\u4e0d\u53d8\u6027\u8fdb\u884c\u4e86\u5145\u5206\u5224\u65ad\uff09\n        if ok < 0:\n            ok = False\n        else:\n            ok = True\n        enablePrint()\n        return ok\n    \n    #\u8bc4\u4f30\u8282\u70b9\u4f4d\u79fb\n    def _get_dis_value(self, points, mode = 'check'):\n        displacement_weight = np.zeros((len(points), 1))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u4f4d\u79fb\u6570\u636e\n        for i in range(len(points)):\n            if self._dimension == 2:\n                weight = max(   \n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                )                                  #\u53ea\u8003\u8651x,y,(z)\u65b9\u5411\u4e0a\u7684\u6700\u5927\u7684\u4e00\u4e2a\u7ebf\u4f4d\u79fb\n            else:\n                weight = max(\n                    abs(op.nodeDisp(i, 1)),\n                    abs(op.nodeDisp(i, 2)),\n                    abs(op.nodeDisp(i, 3)),\n                )\n            if (mode == 'check'): print(\"\u7b2c{:}\u7ed3\u70b9\u4f4d\u79fb\u4e3a{:}mm\".format(i,weight*10**3))\n            displacement_weight[i] = max(weight / self._limit_dis - 1, 0)  #\u5224\u5b9a\u8282\u70b9\u4f4d\u79fb\u662f\u5426\u8d85\u9650\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\uff0c\u6700\u540e\u7d2f\u52a0\u6570\u7ec4\u4e2d\u7684\u6570\u503c\u4f5c\u4e3a\u4f4d\u79fb\u8bc4\u4f30\u53c2\u7167\n        return displacement_weight\n    \n    #\u8bc4\u4f30\u6746\u4ef6\u5e94\u529b\n    def _get_stress_value(self, edges, mode = 'check'):\n        stress_weight = np.zeros(len(edges))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u5e94\u529b\u6570\u636e\n\n        for tag, i in enumerate(range(len(edges))):\n            edges[i].force = op.basicForce(tag)   #\u4ece\u6709\u9650\u5143\u5f97\u5230\u6746\u4ef6\u8f74\u529b\n            edges[i].stress = edges[i].force[0] / edges[i].area  #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            if (mode == 'check'): print(\"\u7b2c{:}\u6746\u4ef6\u5e94\u529b\u4e3a{:}MPa\".format(i,edges[i].stress*10**(-6)))\n            if edges[i].stress < 0:                                  #\u538b\u6746\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_C - 1.0,\n                    0.0\n                )\n            else:                                                    #\u62c9\u6746\n                stress_weight[tag] = max(\n                    abs(edges[i].stress) / self._sigma_T - 1.0,\n                    0.0\n                )\n        return stress_weight  #\u5224\u5b9a\u8282\u70b9\u5e94\u529b\u662f\u5426\u8d85\u9650\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\uff0c\u6700\u540e\u7d2f\u52a0\u6570\u7ec4\u4e2d\u7684\u6570\u503c\u4f5c\u4e3a\u5e94\u529b\u8bc4\u4f30\u53c2\u7167\n\n    #\u8bc4\u4f30\u6746\u4ef6\u5c48\u66f2\n    def _get_buckle_value(self, edges):\n        buckle_weight = np.zeros(len(edges))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u5c48\u66f2\u6570\u636e\n        miu_buckle = 1.0                           #\u6746\u4ef6\u8ba1\u7b97\u957f\u5ea6\u7cfb\u6570\uff0c\u6841\u67b6\u4e24\u7aef\u94f0\u63a5\u53d61\n        \n        for i in range(len(edges)):\n            edges[i].force = op.basicForce(i)    #\u5b58\u653e\u8f74\u529b\u6570\u636e\n            edges[i].stress = edges[i].force[0] / edges[i].area #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            if edges[i].stress < 0:    #\u4ec5\u538b\u6746\u624d\u8003\u8651\u5c48\u66f2\n                #\u8ba1\u7b97\u6b27\u62c9\u4e34\u754c\u529b\n                force_cr = (\n                    math.pi ** 2 \n                    * self._E * edges[i].inertia\n                ) / (miu_buckle * edges[i].len) ** 2\n\n                #\u8ba1\u7b97\u6b27\u62c9\u4e34\u754c\u5e94\u529b\n                buckle_stress_max = force_cr / edges[i].area\n\n                buckle_weight[i] = max(\n                    abs(edges[i].stress) / abs(buckle_stress_max) - 1.0,\n                    0.0\n                )#\u5224\u5b9a\u6746\u4ef6\u538b\u5e94\u529b\u662f\u5426\u8d85\u8fc7\u5c48\u66f2\u4e34\u754c\u5e94\u529b\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return buckle_weight\n    \n    #\u8bc4\u4f30\u6746\u4ef6\u957f\u7ec6\u6bd4\n    def _get_slenderness_ratio(self, edges):\n        lambda_weight = np.zeros(len(edges))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for i in range(len(edges)):\n            edges[i].force = op.basicForce(i)    #\u5b58\u653e\u8f74\u529b\u6570\u636e\n            edges[i].stress = edges[i].force[0] / edges[i].area #\u6839\u636e\u8f74\u529b\u3001\u622a\u9762\u79ef\u6c42\u6b63\u5e94\u529b\n            lambda_weight[i] = max(\n                # self.len/(self.inertia/self.area)**0.5\n                abs(edges[i].len / (edges[i].inertia / edges[i].area) ** 0.5) / abs(self.slenderness_ratio_C if edges[i].stress < 0 else self.slenderness_ratio_T) - 1.0,\n                0.0\n            )#\u5224\u5b9a\u6746\u4ef6\u957f\u7ec6\u6bd4\u662f\u5426\u8d85\u8fc7\u9650\u5236\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return lambda_weight\n\n    #\u8bc4\u4f30\u6746\u4ef6\u8d85\u957f\n    def _get_length_longer(self, edges):\n        longer_weight = np.zeros(len(edges))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for i in range(len(edges)):   \n            longer_weight[i] = max(\n                abs(edges[i].len) / abs(self.max_len) - 1.0,\n                0.0\n            )#\u5224\u5b9a\u6746\u4ef6\u957f\u5ea6\u662f\u5426\u8d85\u8fc7\u9650\u5236\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return longer_weight\n\n    #\u8bc4\u4f30\u6746\u4ef6\u8fc7\u77ed\n    def _get_length_shorter(self, edges):\n        shorter_weight = np.zeros(len(edges))  #\u521d\u59cb\u5316\u4e00\u4e2a0\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u653e\u957f\u7ec6\u6bd4\u6570\u636e\n        \n        for i in range(len(edges)): \n            if edges[i].len < self.min_len:\n                shorter_weight[i] = 1.0-edges[i].len / self.min_len\n                #\u5224\u5b9a\u6746\u4ef6\u957f\u5ea6\u662f\u5426\u8fc7\u77ed\uff1a\u8d85\u51fa\u5219\u6bd4\u4f8b\u5b58\u5165\u6570\u7ec4\uff0c\u5426\u5219\u8bb0\u4e3a0\n        return shorter_weight\n\n    def _get_cross_value(self, points, edges):\n        cross_value = 0\n        for i in range(len(edges)):\n            for j in range(len(edges)):\n                if (edges[i].u == edges[j].v or edges[i].u == edges[j].u or edges[i].v == edges[j].v or edges[i].v == edges[j].u): continue\n                _, _, dis = closestDistanceBetweenLines(points[edges[i].u].Point2np(), points[edges[i].v].Point2np(), points[edges[j].u].Point2np(), points[edges[j].v].Point2np(), clampAll = True)\n                if (edges[i].d != None):\n                    r1, r2 = edges[i].d / 2, edges[j].d / 2\n                else:\n                    if (self._dimension == 2):\n                        r1, r2 = edges[i].area / 2, edges[j].area / 2\n                    elif (self._dimension == 3):\n                        r1, r2 = np.sqrt(edges[i].area / np.pi), np.sqrt(edges[j].area / np.pi)\n                if (dis <= r1 + r2): cross_value += 1\n        return cross_value\n\n    #\u8c03\u7528\u4ee5\u4e0a\u51fd\u6570\u8fd0\u884c\u7ed3\u6784\u5206\u6790\n    def run(self, points, edges, mode = 'check'):\n        # if mode = check, return a list\n        # else, return value\n        if 'IS_RUNNING_DYNAMIC' not in os.environ:\n            os.environ['IS_RUNNING_DYNAMIC'] = 'no'\n        while os.environ['IS_RUNNING_DYNAMIC'] == 'yes':\n            print('waiting for dynamics to be enabled')\n            time.sleep(0.1)\n        os.environ['IS_RUNNING_DYNAMIC'] = 'yes'\n        if (type(points) == dict or type(points) == OrderedDict):\n            _points = []\n            for i, point in points.items():\n                _points.append(point)\n            points = _points\n        \n        if (type(edges) == dict or type(edges) == OrderedDict):\n            _edges = []\n            for i, edge in edges.items():\n                _edges.append(edge)\n            edges = _edges\n\n\n        is_struct = self._is_struct(points, edges) #\u8fd0\u884c\u7ed3\u6784\u5efa\u6a21\u4e0e\u5206\u6790\uff0cis_struct\u8fd4\u56de\u7ed3\u6784\u662f\u5426\u6b63\u5e38\u5b8c\u6210\u5206\u6790\n        mass, dis_value, stress_value, buckle_value, slenderness_value, longer_value, shorter_value, cross_value = 0, 0, 0, 0, 0, 0, 0, 0\n        for edge in edges: mass += edge.len * edge.area * self._pho      #\u8ba1\u7b97\u7ed3\u6784\u603b\u8d28\u91cf\n        if is_struct: #\u5982\u679c\u7ed3\u6784\u6210\u529f\u5b8c\u6210\u5206\u6790\uff0c\u5373\u7ed3\u6784\u662f\u51e0\u4f55\u4e0d\u53d8\u7684\n            if self._use_dis_constraint:\n                dis_value = self._get_dis_value(points, mode)       #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u4f4d\u79fb\u8bc4\u4f30\u7ed3\u679c\n            if self._use_stress_constraint:\n                stress_value = self._get_stress_value(edges, mode)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u5e94\u529b\u8bc4\u4f30\u7ed3\u679c\n            if self._use_buckle_constraint:\n                buckle_value = self._get_buckle_value(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u5c48\u66f2\u8bc4\u4f30\u7ed3\u679c\n            if self._use_slenderness_constraint:\n                slenderness_value = self._get_slenderness_ratio(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c    \n            if self._use_longer_constraint:\n                longer_value = self._get_length_longer(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c\n            if self._use_shorter_constraint:\n                shorter_value = self._get_length_shorter(edges)  #\u82e5\u542f\u7528\uff0c\u83b7\u53d6\u7ed3\u6784\u957f\u7ec6\u6bd4\u8bc4\u4f30\u7ed3\u679c\n        if self._use_cross_constraint:\n            cross_value = self._get_cross_value(points, edges)\n\n        if (mode != 'check'):\n            if (is_struct and self._use_dis_constraint): dis_value = dis_value.sum()\n            if (is_struct and self._use_buckle_constraint): buckle_value = buckle_value.sum()\n            if (is_struct and self._use_slenderness_constraint): slenderness_value = slenderness_value.sum()\n            if (is_struct and self._use_stress_constraint): stress_value = stress_value.sum()\n            if (is_struct and self._use_longer_constraint): longer_value = longer_value.sum()\n            if (is_struct and self._use_shorter_constraint): shorter_value = shorter_value.sum()\n        os.environ['IS_RUNNING_DYNAMIC'] = 'no'\n        return (\n            is_struct, mass, dis_value, stress_value, buckle_value, slenderness_value, longer_value, shorter_value, cross_value\n        )\n\n    #\u7ed8\u5236\u5e73\u9762\u6841\u67b6\n    def render(self, points, edges):\n        _ax = plt.axes(projection='3d')\n        for point in points.values():   #\u7ed8\u5236\u8282\u70b9\uff0cscatter()\u7ed8\u5236\u6563\u70b9\n            if point.isSupport:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='g') #\u652f\u5ea7\u70b9\u4e3a\u7eff\u8272\n            elif point.isLoad:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='r') #\u8377\u8f7d\u4f5c\u7528\u7684\u8282\u70b9\u4e3a\u7ea2\u8272\n            else:\n                _ax.scatter([point.vec.x], [point.vec.y],[point.vec.z], color='b') #\u5176\u4f59\u8282\u70b9\u84dd\u8272\n\n        for edge in edges.values():    #\u7ed8\u5236\u6746\u4ef6\n            x0 = [points[edge.u].vec.x, points[edge.v].vec.x]   #\u6746\u4ef6\u8d77\u70b9\n            y0 = [points[edge.u].vec.y, points[edge.v].vec.y]   #\u6746\u4ef6\u7ec8\u70b9\n            z0 = [points[edge.u].vec.z, points[edge.v].vec.z]   #\u6746\u4ef6\u8d77\u70b9\n            \n            if edge.stress < -1e-7:\n                _ax.plot(x0, y0, z0, color='g', linewidth=(edge.area / math.pi)**0.5*500)    #\u538b\u6746\u7eff\u8272\n            elif edge.stress > 1e-7:\n                _ax.plot(x0, y0, z0, color='r', linewidth=(edge.area / math.pi)**0.5*500)    #\u62c9\u6746\u7ea2\u8272\n            else:\n                _ax.plot(x0, y0, z0, color='k', linewidth=(edge.area / math.pi)**0.5*500)    #\u96f6\u6746\u9ed1\u8272\n        plt.show() #\u663e\u793a\u56fe\u50cf", "\n\nif __name__=='__main__':\n    truss=DynamicModel(3)    #\u521b\u5efa\u7ed3\u6784\u5bf9\u8c61\n    point_list, edge_list = readFile(\"PostResults/with_buckle_case1/1918656.txt\") #\u8bfb\u53d6\u6570\u636e\u8f93\u5165\u6587\u4ef6\u4e2d\u7684\u9884\u8bbe\u70b9\u548c\u8fb9\n\n    #\u5c06point_list, edge_list\u8f6c\u6362\u6210truss.run\u7684\u6570\u636e\u7ed3\u6784\n    points = {}\n    edges = {}\n    for i, point in enumerate(point_list):  #\u5c06\u9884\u8bbe\u70b9\u5bf9\u8c61\u52a0\u5165\u70b9\u96c6\n        points[i] = point\n\n    for i, edge in enumerate(edge_list):    #\u5c06\u9884\u8bbe\u8fb9\u5bf9\u8c61\u52a0\u5165\u8fb9\u96c6\n        if edge.u > edge.v:                 #\u8fb9\u7aef\u70b9\u91cd\u65b0\u7f16\u53f7\n            tmp = edge.u\n            edge.u = edge.v\n            edge.v = tmp\n        edges[(edge.u, edge.v)] = edge        \n\n    print(points)\n    print(edges)\n\n    #\u8fd0\u884c\u6a21\u578b\u5206\u6790                                 \n    is_struct, mass, dis_value, stress_value, buckle_value, slenderness_value, longer_value, shorter_value, cross_value = truss.run(points, edges) \n    \n    #\u540e\u5904\u7406\uff0c\u8f93\u51fa\u7ed3\u6784\u8bbe\u8ba1\u7ed3\u679c\u7684\u63d0\u793a\u4fe1\u606f\n    if not is_struct:\n        print(\"\u7ed3\u6784\u51e0\u4f55\u4e0d\u7a33\u5b9a\")\n    elif np.sum(dis_value) > 0.0 or np.sum(stress_value) > 0.0 or np.sum(buckle_value) > 0.0 or np.sum(slenderness_value) or np.sum(longer_value) or np.sum(shorter_value):\n        for i in range(len(dis_value)):\n            if dis_value[i]>0.0:\n                print(\"\u7b2c{:}\u7ed3\u70b9\u4f4d\u79fb\u8d85\u51fa\u9650\u503c{:}%\".format(i,dis_value[i]*100))\n\n        for i in range(len(stress_value)):\n            if stress_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u5e94\u529b\u8d85\u51fa\u9650\u503c{:}%\".format(i,stress_value[i]*100))\n\n        for i in range(len(buckle_value)):\n            if buckle_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u5c48\u66f2\u5e94\u529b\u8d85\u51fa\u9650\u503c{:}%\".format(i,buckle_value[i]*100))\n\n        for i in range(len(slenderness_value)):\n            if slenderness_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u957f\u7ec6\u6bd4\u8d85\u51fa\u9650\u503c{:}%\".format(i,slenderness_value[i]*100))\n\n        for i in range(len(longer_value)):\n            if longer_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u957f\u5ea6\u8d85\u51fa\u9650\u503c{:}%\".format(i,longer_value[i]*100))\n        for i in range(len(shorter_value)):\n            if shorter_value[i]>0.0:\n                print(\"\u7b2c{:}\u6746\u4ef6\u957f\u5ea6\u77ed\u8fc7\u9650\u503c{:}%\".format(i,shorter_value[i]*100))                 \n\n    else:\n        print(\"\u7ed3\u6784\u51e0\u4f55\u7a33\u5b9a\uff0c\u4e14\u6240\u6709\u7ea6\u675f\u6ee1\u8db3\u3002\u5f53\u524d\u7ed3\u6784\u603b\u8d28\u91cf\u4e3a\uff1a{:.3f}kg\".format(mass))\n\n    truss.render(points, edges) #\u663e\u793a\u6841\u67b6\u56fe\u50cf", "\n\n   \n"]}
{"filename": "truss_envs/reward.py", "chunked_list": ["import sys, os\nimport openseespy.opensees as op\nimport numpy as np\nimport math\nfrom truss_envs.dynamic import DynamicModel\nfrom utils.utils import Bar, getlen2\n\ndef Envs_init(args__):\n    global args\n    global truss_env\n    args = args__\n    '''\n    global E\n    global pho\n    global Sigma_T\n    global Sigma_C\n    global slenderness_ratio_c\n    global slenderness_ratio_t\n    global dislimit\n    global maxlen\n    global minlen\n    global CONSTRAINT_STRESS\n    global CONSTRAINT_DIS\n    global CONSTRAINT_BUCKLE\n    global CONSTRAINT_SLENDERNESS\n    \n    #Elasticity modulus\n    E = args.E #1.93*10**11\n    pho = args.pho #8.0*10**3\n    Sigma_T = args.sigma_T #123.0*10**6\n    Sigma_C = args.sigma_C #123.0*10**6\n    slenderness_ratio_c = args.slenderness_ratio_c #180.0\n    slenderness_ratio_t = args.slenderness_ratio_t #220.0\n    dislimit = args.dislimit #0.002\n    maxlen = args.len_range[1]\n    minlen = args.len_range[0]\n\n    #constraints\n    CONSTRAINT_STRESS = args.CONSTRAINT_STRESS\n    CONSTRAINT_DIS = args.CONSTRAINT_DIS\n    CONSTRAINT_BUCKLE = args.CONSTRAINT_BUCKLEd\n    CONSTRAINT_SLENDERNESS = args.CONSTRAINT_SLENDERNESS\n    '''\n\n    truss_env = DynamicModel(\n            dimension = args.env_dims,\n            E = args.E,\n            pho = args.pho,\n            sigma_T = args.sigma_T,\n            sigma_C = args.sigma_C,\n            dislimit = args.dislimit,\n            slenderness_ratio_C = args.slenderness_ratio_c,\n            slenderness_ratio_T = args.slenderness_ratio_t,\n            max_len = args.len_range[1],\n            min_len = args.len_range[0],\n            use_self_weight = args.CONSTRAINT_SELF_WEIGHT,\n            use_dis_constraint = args.CONSTRAINT_DIS,\n            use_stress_constraint = args.CONSTRAINT_STRESS,\n            use_buckle_constraint = args.CONSTRAINT_BUCKLE,\n            use_slenderness_constraint = args.CONSTRAINT_SLENDERNESS,\n            use_longer_constraint = args.CONSTRAINT_MAX_LENGTH,\n            use_shorter_constraint = args.CONSTRAINT_MIN_LENGTH,\n            use_cross_constraint = args.CONSTRAINT_CROSS_EDGE,\n        )", "\nReward_cnt = 0\n\ndef reward_fun(p, e, sanity_check = True, mode = 'train'):\n    global Reward_cnt\n    Reward_cnt += 1\n    if (sanity_check):\n        for se in e:\n            new_e = Bar(se.u, se.v, se._area, leng = getlen2(p[se.u], p[se.v]), d = se.d, t = se.t)\n            assert(new_e.area == se.area)\n            assert(new_e.len == se.len)\n            assert(new_e.v == se.v)\n            assert(new_e.t == se.t)\n\n    is_struct, mass, dis_value, stress_value, buckle_value, slenderness_value, longer_value, shorter_value, cross_value = truss_env.run(p, e, mode = mode) \n\n    dis_value = np.sum(dis_value)\n    stress_value = np.sum(stress_value)\n    buckle_value = np.sum(buckle_value)\n    slenderness_value = np.sum(slenderness_value)\n    longer_value = np.sum(longer_value)\n    shorter_value = np.sum(shorter_value)\n    cross_value = np.sum(cross_value)\n\n    if (mode == 'check'):\n        print(is_struct, mass, dis_value, stress_value, buckle_value, slenderness_value, longer_value, shorter_value, cross_value)\n\n    #check_geometruc_stability\n    if ((not is_struct) or cross_value > 0):\n        return -1.0, Reward_cnt, mass, 0, 0, 0\n    \n    # check slenderness ratio / longer_value / shorter_value\n    if (slenderness_value > 0 or longer_value > 0 or shorter_value > 0):\n        return 0, Reward_cnt, mass, 0, 0, 0\n\n    # check displacement / Stress_value / Buckle_value\n    if (dis_value > 1e-7 or stress_value > 1e-7 or buckle_value > 1e-7):\n        return 0, Reward_cnt, mass, dis_value, stress_value, buckle_value\n    \n    # pass check\n    reward = mass * (1 + dis_value + stress_value + buckle_value)\n    return reward, Reward_cnt, mass, dis_value, stress_value, buckle_value"]}
