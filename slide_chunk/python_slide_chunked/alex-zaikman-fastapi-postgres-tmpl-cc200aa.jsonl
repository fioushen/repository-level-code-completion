{"filename": "tests/mock_db.py", "chunked_list": ["import os\n\nimport psycopg\nimport testing.postgresql\n\nfrom singleton_meta import SingletonMeta\n\n\nclass _Postgresql(metaclass=SingletonMeta):\n    def __init__(self):\n        self.__postgresql = self._postgres_factory()\n\n    @staticmethod\n    def _init_db(db):\n        os.environ.setdefault('DB_NULL_POOL', 'true')\n        os.environ.setdefault('DB_ECHO', 'true')\n        conn = psycopg.connect(db.url())\n        cur = conn.cursor()\n\n        with open(os.path.join(os.path.dirname(__file__), '../db/init.sql'), 'r', encoding=\"UTF-8\") as fp:\n            _ = [(cur.execute(statement.strip())) for statement in fp.read().split(';') if statement.strip()]\n\n        conn.commit()\n        cur.close()\n        conn.close()\n\n    def _postgres_factory(self):\n        \"\"\"\n        Creates an initial fake database for use in unit tests.\n        \"\"\"\n        postgres_factory = testing.postgresql.PostgresqlFactory(cache_initialized_db=True,\n                                                                on_initialized=self._init_db)\n        return postgres_factory\n\n    def __call__(self, *args, **kwargs):\n        return self.__postgresql()\n\n    def clear_cache(self):\n        self.__postgresql.clear_cache()", "class _Postgresql(metaclass=SingletonMeta):\n    def __init__(self):\n        self.__postgresql = self._postgres_factory()\n\n    @staticmethod\n    def _init_db(db):\n        os.environ.setdefault('DB_NULL_POOL', 'true')\n        os.environ.setdefault('DB_ECHO', 'true')\n        conn = psycopg.connect(db.url())\n        cur = conn.cursor()\n\n        with open(os.path.join(os.path.dirname(__file__), '../db/init.sql'), 'r', encoding=\"UTF-8\") as fp:\n            _ = [(cur.execute(statement.strip())) for statement in fp.read().split(';') if statement.strip()]\n\n        conn.commit()\n        cur.close()\n        conn.close()\n\n    def _postgres_factory(self):\n        \"\"\"\n        Creates an initial fake database for use in unit tests.\n        \"\"\"\n        postgres_factory = testing.postgresql.PostgresqlFactory(cache_initialized_db=True,\n                                                                on_initialized=self._init_db)\n        return postgres_factory\n\n    def __call__(self, *args, **kwargs):\n        return self.__postgresql()\n\n    def clear_cache(self):\n        self.__postgresql.clear_cache()", "\n\nPostgresql = _Postgresql()\n"]}
{"filename": "tests/base.py", "chunked_list": ["import unittest\n\nfrom database import DataBase\nfrom tests.mock_db import Postgresql\n\n\nclass TestBase(unittest.IsolatedAsyncioTestCase):\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        cls.postgresql = Postgresql()\n\n    async def asyncSetUp(self):\n        self.db = DataBase(self.postgresql.url().replace('postgresql', 'postgresql+asyncpg'))  # pylint: disable=attribute-defined-outside-init\n\n    @classmethod\n    def tearDownClass(cls) -> None:\n        Postgresql.clear_cache()", ""]}
{"filename": "tests/__init__.py", "chunked_list": ["import sys\nsys.path.append(\"src\")\n"]}
{"filename": "tests/test_schema.py", "chunked_list": ["from schema.users import users\nfrom tests.base import TestBase\n\n\nclass TestSchema(TestBase):\n\n    async def test_select_users(self):\n        async with self.db.async_session.begin() as session:\n            res = await session.execute(users.select())\n            self.assertEqual(len(res.all()), 2)", ""]}
{"filename": "tests/api_base.py", "chunked_list": ["from fastapi.openapi.models import Response\nfrom fastapi.testclient import TestClient\n\nfrom tests.base import TestBase\n\n\nclass AuthHeader:\n    def __init__(self, response: Response):\n        self._tokens = response.json()\n        self.status_code = response.status_code\n\n    @property\n    def auth(self):\n        return {\"Authorization\": f\"Bearer {self._tokens.get('access_token')}\"}\n\n    @property\n    def refresh(self):\n        return {\"Authorization\": f\"Bearer {self._tokens.get('refresh_token')}\"}", "\n\nclass TestAPIBase(TestBase):\n    async def asyncSetUp(self):\n        await super().asyncSetUp()\n        from api import app  # pylint: disable=import-outside-toplevel\n        self.client = TestClient(app)  # pylint: disable=attribute-defined-outside-init\n\n    async def asyncTearDown(self) -> None:\n        self.client.close()\n        await super().asyncTearDown()\n\n    def login(self, email, password) -> AuthHeader:\n        response = self.client.post(\"/token\", data={\"username\": email, \"password\": password})\n        return AuthHeader(response)", ""]}
{"filename": "tests/test_user_ep.py", "chunked_list": ["from fastapi import status\nfrom tests.api_base import TestAPIBase\n\n\nclass TestUserEP(TestAPIBase):\n\n    async def test_crud_users(self):\n        headers = self.login('admin@gmail.com', 'admin123')\n        response = self.client.post(\n            url='/user',\n            headers=headers.auth,\n            json={\n                \"email\": \"test@test.com\",\n                \"scopes\": [\n                    \"ADMIN\"\n                ],\n                \"password\": \"test123\"\n            }\n        )\n        self.assertEqual(response.status_code, status.HTTP_201_CREATED)\n        res = self.login('test@test.com', 'test123')\n        self.assertEqual(res.status_code, status.HTTP_200_OK)", ""]}
{"filename": "tests/test_auth.py", "chunked_list": ["# import datetime\n# import datetime as dt\n# import os\n# import time\n# import time_machine\n\nfrom fastapi import status\n\nfrom tests.api_base import TestAPIBase, AuthHeader\n", "from tests.api_base import TestAPIBase, AuthHeader\n\n\nclass TestAuth(TestAPIBase):\n\n    async def asyncSetUp(self):\n        await super().asyncSetUp()\n        self.headers = self.login('admin@gmail.com', 'admin123')  # pylint: disable=attribute-defined-outside-init\n\n    async def test_auth(self):\n        response = self.client.get(url='/user', headers=self.headers.auth)\n        self.assertEqual(response.status_code, status.HTTP_200_OK, 'sunny path')\n\n        response = self.client.get(url='/user')\n        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED, 'no auth headers')\n\n        response = self.client.get(url='/user', headers={\"Authorization\": \"Bearer blasdfdfwerwewfer44r44fr44f4f4c4f4ff4f4\"})\n        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED, \"bad auth headers\")\n\n    async def test_refresh(self):\n        response = self.client.get(url='/user', headers=self.headers.refresh)\n        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED, 'ep with refresh')\n\n        response = self.client.post(url='/refresh', headers=self.headers.auth)\n        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED, 'refresh with auth')\n\n        response = self.client.post(url='/refresh', headers=self.headers.refresh)\n        self.assertEqual(response.status_code, status.HTTP_200_OK, 'sunny path')\n\n        new_headers = AuthHeader(response)\n\n        response = self.client.get(url='/user', headers=new_headers.auth)\n        self.assertEqual(response.status_code, status.HTTP_200_OK, 'sunny path')", "\n    # async def test_expiration(self):\n    #\n    #     with time_machine.travel(0, tick=False) as traveller:\n    #         response = self.client.get(url='/user', headers=self.headers.auth)\n    #         self.assertEqual(response.status_code, status.HTTP_200_OK, 'sunny path')\n    #\n    #         traveller.shift(datetime.timedelta(minutes=555))\n    #         response = self.client.get(url='/user', headers=self.headers.auth)\n    #         self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED, 'expired token')", "    #         response = self.client.get(url='/user', headers=self.headers.auth)\n    #         self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED, 'expired token')\n"]}
{"filename": "src/database.py", "chunked_list": ["import os\n\nfrom sqlalchemy import NullPool\nfrom sqlalchemy.ext.asyncio import AsyncAttrs, AsyncSession\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\n\nfrom singleton_meta import SingletonMeta\n\n\nclass DataBase(metaclass=SingletonMeta):\n\n    def __init__(self, url=None):\n        self.engine = self._create_async_engine(url)\n        self.async_session = sessionmaker(self.engine, class_=AsyncSession, expire_on_commit=False)\n\n    @staticmethod\n    def _create_async_engine(url):\n        if url is None:\n            db_host = os.environ.get('DB_HOST', default='localhost')\n            db_port = os.environ.get('DB_PORT', default='5432')\n            db_user = os.environ.get('DB_USER', default='postgres')\n            db_password = os.environ.get('DB_PASSWORD', default='postgres')\n            db_name = os.environ.get('DB_NAME', default='postgres')\n            url = f\"postgresql+asyncpg://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}\"\n\n        kwargs = {'url': url}\n        if os.environ.get('DB_NULL_POOL', default=None) is not None:\n            kwargs.update(poolclass=NullPool)\n        if os.environ.get('DB_ECHO', default=None) is not None:\n            kwargs.update(echo=True)\n        return create_async_engine(\n            **kwargs\n        )\n\n    async def get_session(self) -> AsyncSession:\n        async with self.async_session() as session:\n            async with session.begin():\n                try:\n                    yield session\n                except Exception as exc:  # pylint: disable=bare-except\n                    await session.rollback()\n                    raise exc\n\n                await session.commit()\n\n    class Base(AsyncAttrs, DeclarativeBase):\n        pass", "\n\nclass DataBase(metaclass=SingletonMeta):\n\n    def __init__(self, url=None):\n        self.engine = self._create_async_engine(url)\n        self.async_session = sessionmaker(self.engine, class_=AsyncSession, expire_on_commit=False)\n\n    @staticmethod\n    def _create_async_engine(url):\n        if url is None:\n            db_host = os.environ.get('DB_HOST', default='localhost')\n            db_port = os.environ.get('DB_PORT', default='5432')\n            db_user = os.environ.get('DB_USER', default='postgres')\n            db_password = os.environ.get('DB_PASSWORD', default='postgres')\n            db_name = os.environ.get('DB_NAME', default='postgres')\n            url = f\"postgresql+asyncpg://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}\"\n\n        kwargs = {'url': url}\n        if os.environ.get('DB_NULL_POOL', default=None) is not None:\n            kwargs.update(poolclass=NullPool)\n        if os.environ.get('DB_ECHO', default=None) is not None:\n            kwargs.update(echo=True)\n        return create_async_engine(\n            **kwargs\n        )\n\n    async def get_session(self) -> AsyncSession:\n        async with self.async_session() as session:\n            async with session.begin():\n                try:\n                    yield session\n                except Exception as exc:  # pylint: disable=bare-except\n                    await session.rollback()\n                    raise exc\n\n                await session.commit()\n\n    class Base(AsyncAttrs, DeclarativeBase):\n        pass", ""]}
{"filename": "src/auth.py", "chunked_list": ["import hashlib\nimport logging\nimport os\nimport string\nfrom datetime import datetime, timedelta\nfrom random import choice\n\nfrom fastapi import HTTPException, Depends, status\nfrom fastapi.security import OAuth2PasswordBearer, SecurityScopes\nfrom jose import JWTError, jwt", "from fastapi.security import OAuth2PasswordBearer, SecurityScopes\nfrom jose import JWTError, jwt\nfrom jose.constants import ALGORITHMS\nfrom passlib.context import CryptContext\n\nfrom database import DataBase\nfrom models.token import TokenData, TokenType\nfrom models.users import User\nfrom schema.users import get_db_user\n", "from schema.users import get_db_user\n\n\ndef _gen_secret_key():\n    return hashlib.sha512(''.join(choice(string.ascii_letters)\n                                  for _ in range(29)).encode()).hexdigest()\n\n\n# Auth conf\nAPI_ALGORITHM = os.environ.get(\"API_ALGORITHM\", ALGORITHMS.HS256)", "# Auth conf\nAPI_ALGORITHM = os.environ.get(\"API_ALGORITHM\", ALGORITHMS.HS256)\nAPI_ACCESS_TOKEN_EXPIRE_MINUTES = os.environ.get(\"API_ACCESS_TOKEN_EXPIRE_MINUTES\", 15)\nAPI_REFRESH_TOKEN_EXPIRE_DAYS = os.environ.get(\"API_REFRESH_TOKEN_EXPIRE_DAYS\", 30)\nAPI_SECRET_KEY = os.environ.get(\"API_SECRET_KEY\", _gen_secret_key())\nAPI_REFRESH_SECRET_KEY = os.environ.get(\"API_REFRESH_SECRET_KEY\", _gen_secret_key())\n\n_pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")", "\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\nlogger = logging.getLogger(\"api\")\n\n\ndef verify_hashed(plain: str, hashed: str) -> bool:\n    return _pwd_context.verify(plain, hashed)\n\n\ndef get_hash(str_to_hash: str) -> str:\n    \"\"\"\n\n    :rtype: object\n    \"\"\"\n    return _pwd_context.hash(str_to_hash)", "\n\ndef get_hash(str_to_hash: str) -> str:\n    \"\"\"\n\n    :rtype: object\n    \"\"\"\n    return _pwd_context.hash(str_to_hash)\n\n", "\n\nasync def validate_token_data(security_scopes: SecurityScopes,\n                              session=Depends(DataBase().get_session),\n                              token__: str = Depends(oauth2_scheme)\n                              ) -> TokenData:\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": f'Bearer scope=\"{security_scopes.scope_str}\"'},", "        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": f'Bearer scope=\"{security_scopes.scope_str}\"'},\n    )\n\n    # parse token payload\n    try:\n        payload = jwt.decode(token__, API_SECRET_KEY, algorithms=[API_ALGORITHM])\n    except JWTError as exc:\n        raise credentials_exception from exc\n", "\n    return await validate_token(token__, session, payload, credentials_exception, security_scopes)\n\n\nasync def validate_refresh_token_data(token__: str = Depends(oauth2_scheme),\n                                      session=Depends(DataBase().get_session)) -> TokenData:\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": f'Bearer token=\"{token__}\"'},", "        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": f'Bearer token=\"{token__}\"'},\n    )\n    # parse token payload\n    try:\n        payload = jwt.decode(token__, API_REFRESH_SECRET_KEY, algorithms=[API_ALGORITHM])\n    except JWTError as exc:\n        raise credentials_exception from exc\n\n    return await validate_token(token__, session, payload, credentials_exception)", "\n    return await validate_token(token__, session, payload, credentials_exception)\n\n\nasync def validate_token(token__,\n                         session,\n                         payload,\n                         credentials_exception,\n                         security_scopes=None):\n    if security_scopes:\n        # validate Scopes\n        if not set(payload['scopes']).intersection(security_scopes.scopes):\n            raise credentials_exception", "                         security_scopes=None):\n    if security_scopes:\n        # validate Scopes\n        if not set(payload['scopes']).intersection(security_scopes.scopes):\n            raise credentials_exception\n\n    _user = await get_db_user(session=session, email=payload['email'])\n\n    if security_scopes:\n        if set(_user.scopes) != set(payload['scopes']):\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"insufficient privileges\",\n                headers={\"WWW-Authenticate\": f'Bearer token=\"{token__}\"'},\n            )", "    if security_scopes:\n        if set(_user.scopes) != set(payload['scopes']):\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"insufficient privileges\",\n                headers={\"WWW-Authenticate\": f'Bearer token=\"{token__}\"'},\n            )\n\n    return TokenData(user=User(**payload), exp=payload['exp'])\n", "    return TokenData(user=User(**payload), exp=payload['exp'])\n\n\ndef create_access_token(data: dict):\n    expire = datetime.utcnow() + timedelta(minutes=int(API_ACCESS_TOKEN_EXPIRE_MINUTES))\n    data['token_title'] = TokenType.ACCESS\n    encoded_jwt = jwt.encode({\"exp\": expire, **data}, API_SECRET_KEY, algorithm=API_ALGORITHM)\n    return encoded_jwt\n\n\ndef create_refresh_token(data: dict):\n    expire = datetime.utcnow() + timedelta(days=int(API_REFRESH_TOKEN_EXPIRE_DAYS))\n    data['token_title'] = TokenType.REFRESH\n    encoded_jwt = jwt.encode({\"exp\": expire, **data}, API_REFRESH_SECRET_KEY, algorithm=API_ALGORITHM)\n    return encoded_jwt", "\n\ndef create_refresh_token(data: dict):\n    expire = datetime.utcnow() + timedelta(days=int(API_REFRESH_TOKEN_EXPIRE_DAYS))\n    data['token_title'] = TokenType.REFRESH\n    encoded_jwt = jwt.encode({\"exp\": expire, **data}, API_REFRESH_SECRET_KEY, algorithm=API_ALGORITHM)\n    return encoded_jwt\n\n\n# def get_logger(bt: BackgroundTasks,", "\n# def get_logger(bt: BackgroundTasks,\n#                context_id: str = Depends(get_context)):\n#     return lambda msg, func=logger.info: bt.add_task(func, msg, extra={\"context_id\": context_id})\n\n\nif __name__ == '__main__':\n    print(get_hash('admin123'))\n", ""]}
{"filename": "src/api.py", "chunked_list": ["import logging\n\nimport uvicorn\nfrom fastapi import FastAPI, Depends, status, Response, Security, BackgroundTasks, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom starlette.responses import RedirectResponse\n\nfrom auth import create_refresh_token, create_access_token, validate_refresh_token_data\nfrom auth import verify_hashed", "from auth import create_refresh_token, create_access_token, validate_refresh_token_data\nfrom auth import verify_hashed\nfrom database import DataBase\nfrom endpoints import user_api\nfrom middleware import ContextIdMiddleware, TimeMiddleware\nfrom models.token import TokenData, Token\nfrom models.users import User\nfrom schema.users import get_db_user\n\nlogger = logging.getLogger(\"api\")", "\nlogger = logging.getLogger(\"api\")\napp = FastAPI(title=\"Demo app.\", version='1.0.0', description=\"FastAPI and postgres demo.\")\n\napp.include_router(user_api.router)\n\napp.add_middleware(TimeMiddleware)\napp.add_middleware(ContextIdMiddleware)\napp.add_middleware(\n    CORSMiddleware,", "app.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n    expose_headers=[TimeMiddleware.HEADER_NAME, ContextIdMiddleware.HEADER_NAME]\n)\n\n", "\n\n@app.on_event(\"startup\")\nasync def startup():\n    db = DataBase()  # warmup db connection\n    async with db.engine.begin() as conn:\n        await conn.run_sync(db.Base.metadata.create_all)\n\n\n# @app.on_event(\"shutdown\")", "\n# @app.on_event(\"shutdown\")\n# def shutdown_db_client():\n#     db = DataBase()\n#     db.async_session.close_all()\n#     db.engine.dispose()\n\n\n@app.get(\"/ping\")\nasync def ping(bt: BackgroundTasks,", "@app.get(\"/ping\")\nasync def ping(bt: BackgroundTasks,\n               context_id: str = Depends(ContextIdMiddleware.get_context)):\n    bt.add_task(logger.debug, \"ping\", extra={\"context_id\": context_id})\n    return Response(status_code=status.HTTP_200_OK)\n\n\n@app.get(\"/\")\nasync def redirect_root():  # pragma: no cover\n    \"\"\"Reroutes the default path to docs\"\"\"", "async def redirect_root():  # pragma: no cover\n    \"\"\"Reroutes the default path to docs\"\"\"\n    return RedirectResponse(\"/docs\")\n\n\n@app.post('/refresh', tags=['Auth'], response_model=Token)\nasync def refresh(bt: BackgroundTasks, session=Depends(DataBase().get_session),\n                  context_id: str = Depends(ContextIdMiddleware.get_context),\n                  token: TokenData = Security(validate_refresh_token_data),\n                  ):", "                  token: TokenData = Security(validate_refresh_token_data),\n                  ):\n    bt.add_task(logger.info, f'Getting token and refresh for {token.user.email}',\n                extra={\"context_id\": context_id})\n\n    _user = await get_db_user(session=session, email=token.user.email)\n\n    refresh_token = create_refresh_token(data=User.from_orm(_user).dict())\n    access_token = create_access_token(data=User.from_orm(_user).dict())\n", "    access_token = create_access_token(data=User.from_orm(_user).dict())\n\n    bt.add_task(logger.info, f'Login succeeded for {token.user.email}',\n                extra={\"context_id\": context_id})\n\n    return {\"access_token\": access_token,\n            \"refresh_token\": refresh_token,\n            \"token_type\": \"bearer\"}\n\n", "\n\n@app.post('/token', tags=['Auth'], response_model=Token)\nasync def get_token(bt: BackgroundTasks,\n                    context_id: str = Depends(ContextIdMiddleware.get_context),\n                    session=Depends(DataBase().get_session),\n                    form_data: OAuth2PasswordRequestForm = Depends()):\n    bt.add_task(logger.info, f'Getting token for {form_data.username}',\n                extra={\"context_id\": context_id})\n", "                extra={\"context_id\": context_id})\n\n    exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Incorrect email or password\",\n        headers={\"WWW-Authenticate\": \"Bearer\"})\n\n    _user = await get_db_user(session=session, email=form_data.username)\n    # test\n    if not _user or not verify_hashed(plain=form_data.password, hashed=_user.password):\n        bt.add_task(logger.warning,\n                    f'Illegal password for {form_data.username}',\n                    extra={\"context_id\": context_id})\n        raise exception", "    # test\n    if not _user or not verify_hashed(plain=form_data.password, hashed=_user.password):\n        bt.add_task(logger.warning,\n                    f'Illegal password for {form_data.username}',\n                    extra={\"context_id\": context_id})\n        raise exception\n\n    refresh_token = create_refresh_token(data=User.from_orm(_user).dict())\n    access_token = create_access_token(data=User.from_orm(_user).dict())\n", "    access_token = create_access_token(data=User.from_orm(_user).dict())\n\n    bt.add_task(logger.info, f'Login succeeded for {form_data.username}',\n                extra={\"context_id\": context_id})\n\n    return {\"access_token\": access_token,\n            \"refresh_token\": refresh_token,\n            \"token_type\": \"bearer\"}\n\n\nif __name__ == '__main__':\n    uvicorn.run(\"api:app\",\n                host=\"0.0.0.0\",\n                port=8001,\n                log_config=\"logger.json\",\n                log_level=logging.DEBUG)", "\n\nif __name__ == '__main__':\n    uvicorn.run(\"api:app\",\n                host=\"0.0.0.0\",\n                port=8001,\n                log_config=\"logger.json\",\n                log_level=logging.DEBUG)\n", ""]}
{"filename": "src/__init__.py", "chunked_list": [""]}
{"filename": "src/singleton_meta.py", "chunked_list": ["from weakref import WeakValueDictionary\n\n\nclass SingletonMeta(type):\n    _instances = WeakValueDictionary()\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            instance = super().__call__(*args, **kwargs)\n            cls._instances[cls] = instance\n        return cls._instances[cls]", ""]}
{"filename": "src/middleware.py", "chunked_list": ["import time\nfrom uuid import uuid4\n\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.requests import Request\n\n\nclass ContextIdMiddleware(BaseHTTPMiddleware):\n    HEADER_NAME = \"X-Context-Id\"\n\n    async def dispatch(self, request: Request, call_next):\n        context_id = request.headers.get('context-id', str(uuid4()))\n        request.state.context_id = context_id\n        response = await call_next(request)\n        response.headers[self.HEADER_NAME] = context_id\n        return response\n\n    @staticmethod\n    def get_context(request: Request) -> str:\n        return request.state.context_id", "\n\nclass TimeMiddleware(BaseHTTPMiddleware):\n    \"\"\"This middleware adds \"X-Process-Time\" header with server code execution time.\"\"\"\n    HEADER_NAME = \"X-Process-Time\"\n\n    async def dispatch(self, request: Request, call_next):\n        start_time = time.time()\n        response = await call_next(request)\n        process_time = time.time() - start_time\n        response.headers[self.HEADER_NAME] = str(f'{process_time:0.4f} sec')\n        return response", ""]}
{"filename": "src/endpoints/__init__.py", "chunked_list": [""]}
{"filename": "src/endpoints/user_api.py", "chunked_list": ["from typing import List\n\nfrom fastapi import APIRouter, Depends, Security, Body, status\n\nfrom auth import validate_token_data, get_hash\nfrom database import DataBase\nfrom models.scopes import Scope\nfrom models.token import TokenData\nfrom models.users import NewUser, DisplayUser\nfrom schema.users import users", "from models.users import NewUser, DisplayUser\nfrom schema.users import users\n\nrouter = APIRouter(tags=[\"User\"], prefix=\"/user\")\n\n\n@router.get(\"/\", response_model=List[DisplayUser], description='List users.')\nasync def list_users(session=Depends(DataBase().get_session),\n                     token: TokenData = Security(validate_token_data,  # pylint: disable=unused-argument\n                                                 scopes=[Scope.ADMIN, Scope.USER])", "                     token: TokenData = Security(validate_token_data,  # pylint: disable=unused-argument\n                                                 scopes=[Scope.ADMIN, Scope.USER])\n                     ):\n    query = users.select()\n    result = await session.execute(query)\n    return result.all()\n\n\n@router.post(\"/\", status_code=status.HTTP_201_CREATED, description='Add new user')\nasync def create_new_user(session=Depends(DataBase().get_session),", "@router.post(\"/\", status_code=status.HTTP_201_CREATED, description='Add new user')\nasync def create_new_user(session=Depends(DataBase().get_session),\n                          new_user: NewUser = Body(...),\n                          token: TokenData = Security(validate_token_data, scopes=[Scope.ADMIN])  # pylint: disable=unused-argument\n                          ):\n    query_params = new_user.dict()\n    query_params.pop('id', None)  # ensure id is not passed.\n    query_params['password'] = get_hash(query_params['password'])  # hash password\n    query = users.insert().values(**query_params)\n    await session.execute(query)", "    query = users.insert().values(**query_params)\n    await session.execute(query)\n"]}
{"filename": "src/models/scopes.py", "chunked_list": ["from enum import Enum\n\n\nclass Scope(str, Enum):\n    ADMIN = 'ADMIN'\n    USER = 'USER'\n"]}
{"filename": "src/models/users.py", "chunked_list": ["from typing import List\n\nfrom pydantic import BaseModel, Field\n\nfrom models.scopes import Scope\n\n\nclass _UserBase(BaseModel):\n    email: str = Field(...)\n    scopes: List[Scope] = Field(...)\n\n    class Config:\n        orm_mode = True", "\n\nclass NewUser(_UserBase):\n    password: str = Field(...)\n\n    class Config:\n        orm_mode = True\n\n\nclass DisplayUser(_UserBase):\n    id: int = Field(...)\n\n    class Config:\n        orm_mode = True", "\nclass DisplayUser(_UserBase):\n    id: int = Field(...)\n\n    class Config:\n        orm_mode = True\n\n\nclass User(NewUser, DisplayUser):\n    id: int = Field(...)\n\n    class Config:\n        orm_mode = True", "class User(NewUser, DisplayUser):\n    id: int = Field(...)\n\n    class Config:\n        orm_mode = True\n"]}
{"filename": "src/models/__init__.py", "chunked_list": [""]}
{"filename": "src/models/token.py", "chunked_list": ["from enum import Enum\n\nfrom pydantic import BaseModel, Field\n\nfrom models.users import User\n\n\nclass TokenType(str, Enum):\n    ACCESS = 'ACCESS'\n    REFRESH = 'REFRESH'", "\n\nclass Token(BaseModel):\n    \"\"\"jwt token\"\"\"\n    access_token: str = Field(...)\n    refresh_token: str = Field(...)\n    token_type: str = Field(...)\n\n\nclass TokenData(BaseModel):\n    \"\"\"jwt token\"\"\"\n    exp: int = Field(...)\n    user: User = Field(...)", "\nclass TokenData(BaseModel):\n    \"\"\"jwt token\"\"\"\n    exp: int = Field(...)\n    user: User = Field(...)\n"]}
{"filename": "src/schema/users.py", "chunked_list": ["import sqlalchemy\n\nfrom database import DataBase\n\nUSER_ID_SEQ = sqlalchemy.Sequence('user_id_seq', start=1, increment=1)\n\nusers = sqlalchemy.Table(\n    \"users\",\n    DataBase.Base.metadata,\n    sqlalchemy.Column(\"id\",", "    DataBase.Base.metadata,\n    sqlalchemy.Column(\"id\",\n                      sqlalchemy.Integer, USER_ID_SEQ,\n                      primary_key=True\n                      ),\n    sqlalchemy.Column(\"email\", sqlalchemy.String),\n    sqlalchemy.Column(\"password\", sqlalchemy.String),\n    sqlalchemy.Column(\"scopes\", sqlalchemy.ARRAY(sqlalchemy.String)),\n    schema='public'\n)", "    schema='public'\n)\n\n\nasync def get_db_user(session, email):\n    query = users.select().where(users.c.email == email.lower())\n    _user = await session.execute(query)\n    _user = _user.first()\n    return _user\n", "    return _user\n"]}
{"filename": "src/schema/__init__.py", "chunked_list": [""]}
