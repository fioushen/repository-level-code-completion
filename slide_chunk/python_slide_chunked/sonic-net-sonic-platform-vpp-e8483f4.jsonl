{"filename": "platform/mkrules/files/scripts/vppcfg_load.py", "chunked_list": ["#!/usr/bin/python3\n# -*- coding: utf-8 -*-\n# Copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport sys\nimport os", "import sys\nimport os\nimport tempfile\n\ndef load_config():\n    cfg = {}\n    vpp = {}\n    conf_db_set = os.getenv('VPP_CONF_DB', '')\n    if not conf_db_set or conf_db_set != 'y':\n        sys.exit(0)\n\n    portlist = os.getenv('VPP_DPDK_PORTS', '')\n    vports = {}\n    dpdk_ports = {}\n    index=0\n    for port in portlist.split(','):\n        rc = os.system('ip link show type veth dev {}'.format(port))\n        if rc == 0:\n            vports[port] = ''\n        else:\n            dpdk_ports[port] = {'name': 'bobm{}'.format(index)}\n            index += 1\n\n    if len(vports):\n        vpp['vports'] = vports\n\n    if len(dpdk_ports):\n        dpdk = { 'dev': dpdk_ports }\n        vpp['dpdk'] = dpdk\n\n    cfg['PLATFORM'] = { 'vpp': vpp }\n    print(cfg)\n    fd, tmpfile = tempfile.mkstemp(prefix='vppcfg')\n\n    with open(tmpfile, 'w') as fp:\n        json.dump(cfg, fp, indent=4)\n\n    rc = os.system('cat {}'.format(tmpfile))\n    rc += os.system('config load -y {}'.format(tmpfile))\n    os.close(fd)\n    os.unlink(tmpfile)\n\n    return rc", "\nif __name__ == '__main__':\n   sys.exit(load_config())\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/setup.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport setuptools\n\nsetuptools.setup(\n    name = 'sonic-vppcfgd',\n    version = '1.0',", "    name = 'sonic-vppcfgd',\n    version = '1.0',\n    description = 'Utility to configure vpp startup config based on vpp cfg in config_db',\n    author = 'Shashidhar Patil',\n    author_email = 'shaship@cisco.com',\n    url = 'https://github.com/sonic-net/sonic-platform-vpp',\n    packages = setuptools.find_packages(),\n    entry_points = {\n        'console_scripts': [\n            'vppcfgd = vppcfgd.main:main',", "        'console_scripts': [\n            'vppcfgd = vppcfgd.main:main',\n        ]\n    },\n    install_requires = [\n        'jinja2>=2.10',\n        'pyyaml==5.4.1',\n    ],\n    setup_requires = [\n        'pytest-runner',", "    setup_requires = [\n        'pytest-runner',\n        'wheel'\n    ],\n    tests_require = [\n        'pytest',\n        'pytest-cov',\n        'sonic-config-engine'\n    ]\n)", "    ]\n)\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/vars.py", "chunked_list": ["# Copyright 2016 Microsoft, Inc.\n# Modifications copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\ng_debug = True  # FIXME: read from env variable, or from constants\ng_dev_debug = True\n\nINDENT='    '", "\nINDENT='    '\nVPP_CONFIG_JSON_PATH='/etc/sonic/vpp/startup.json'\nVPP_CFG_STARTUP_PATH='/etc/sonic/vpp/startup.conf'\nVPP_BOOTUP_CFG_PATH='/etc/sonic/vpp/bootup.conf'\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/manager.py", "chunked_list": ["# Copyright 2016 Microsoft, Inc.\n# Modifications copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom swsscommon import swsscommon\n\nfrom .log import log_debug, log_err\n", "from .log import log_debug, log_err\n\n\nclass Manager(object):\n    \"\"\" This class represents a SONiC DB table \"\"\"\n    def __init__(self, common_objs, deps, database, table_name):\n        \"\"\"\n        Initialize class\n        :param common_objs: common object dictionary\n        :param deps: dependencies list\n        :param database: database name\n        :param table_name: table name\n        \"\"\"\n        self.directory = common_objs['directory']\n        self.cfg_mgr = common_objs['cfg_mgr']\n        self.constants = common_objs['constants']\n        self.deps = deps\n        self.db_name = database\n        self.table_name = table_name\n        self.set_queue = []\n        self.directory.subscribe(deps, self.on_deps_change)  # subscribe this class method on directory changes\n\n    def get_database(self):\n        \"\"\" Return associated database \"\"\"\n        return self.db_name\n\n    def get_table_name(self):\n        \"\"\" Return associated table name\"\"\"\n        return self.table_name\n\n    def handler(self, key, op, data):\n        \"\"\"\n        This method is executed on each add/remove event on the table.\n        :param key: key of the table entry\n        :param op: operation on the table entry. Could be either 'SET' or 'DEL'\n        :param data: associated data of the event. Empty for 'DEL' operation.\n        \"\"\"\n        if op == swsscommon.SET_COMMAND:\n            if self.directory.available_deps(self.deps):  # all required dependencies are set in the Directory?\n                res = self.set_handler(key, data)\n                if not res:  # set handler returned False, which means it is not ready to process is. Save it for later.\n                    log_debug(\"'SET' handler returned NOT_READY for the Manager: %s\" % self.__class__)\n                    self.set_queue.append((key, data))\n            else:\n                log_debug(\"Not all dependencies are met for the Manager: %s\" % self.__class__)\n                self.set_queue.append((key, data))\n        elif op == swsscommon.DEL_COMMAND:\n            self.del_handler(key)\n        else:\n            log_err(\"Invalid operation '%s' for key '%s'\" % (op, key))\n\n    def on_deps_change(self):\n        \"\"\" This method is being executed on every dependency change \"\"\"\n        if not self.directory.available_deps(self.deps):\n            return\n        new_queue = []\n        for key, data in self.set_queue:\n            res = self.set_handler(key, data)\n            if not res:\n                new_queue.append((key, data))\n        self.set_queue = new_queue\n\n    def set_handler(self, key, data):\n        \"\"\" Placeholder for 'SET' command \"\"\"\n        log_err(\"set_handler() wasn't implemented for %s\" % self.__class__.__name__)\n\n    def del_handler(self, key):\n        \"\"\" Placeholder for 'DEL' command \"\"\"\n        log_err(\"del_handler wasn't implemented for %s\" % self.__class__.__name__)", ""]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/main.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport signal\nimport sys\nimport syslog\nimport threading", "import syslog\nimport threading\nimport traceback\n\nfrom swsscommon import swsscommon\n\nfrom .config import ConfigMgr\nfrom .directory import Directory\nfrom .log import log_notice, log_crit\nfrom .vpp import VppMgr", "from .log import log_notice, log_crit\nfrom .vpp import VppMgr\nfrom .managers_vppcfg import VppCfgMgr\nfrom .runner import Runner, signal_handler\nfrom .template import TemplateFabric\nfrom .utils import read_constants\nfrom .vars import g_debug\n\nVPP_TEMPLATE=\"/etc/sonic/vpp/vpp_template.json\"\n\ndef do_work():\n    \"\"\" Main function \"\"\"\n    vpp = VppMgr(VPP_TEMPLATE)\n\n    common_objs = {\n        'directory': Directory(),\n        'cfg_mgr':   ConfigMgr(vpp),\n        'tf':        TemplateFabric(),\n        'constants': read_constants(),\n    }\n    managers = [\n        VppCfgMgr(common_objs, \"CONFIG_DB\", \"PLATFORM\"),\n        VppCfgMgr(common_objs, \"STATE_DB\", \"PLATFORM\"),\n    ]\n    runner = Runner(common_objs['cfg_mgr'])\n    for mgr in managers:\n        runner.add_manager(mgr)\n    runner.run()", "VPP_TEMPLATE=\"/etc/sonic/vpp/vpp_template.json\"\n\ndef do_work():\n    \"\"\" Main function \"\"\"\n    vpp = VppMgr(VPP_TEMPLATE)\n\n    common_objs = {\n        'directory': Directory(),\n        'cfg_mgr':   ConfigMgr(vpp),\n        'tf':        TemplateFabric(),\n        'constants': read_constants(),\n    }\n    managers = [\n        VppCfgMgr(common_objs, \"CONFIG_DB\", \"PLATFORM\"),\n        VppCfgMgr(common_objs, \"STATE_DB\", \"PLATFORM\"),\n    ]\n    runner = Runner(common_objs['cfg_mgr'])\n    for mgr in managers:\n        runner.add_manager(mgr)\n    runner.run()", "\n\ndef main():\n    rc = 0\n    try:\n        syslog.openlog('vppcfgd')\n        signal.signal(signal.SIGTERM, signal_handler)\n        signal.signal(signal.SIGINT, signal_handler)\n        do_work()\n    except KeyboardInterrupt:\n        log_notice(\"Keyboard interrupt\")\n    except RuntimeError as exc:\n        log_crit(str(exc))\n        rc = -2\n        if g_debug:\n            raise\n    except Exception as exc:\n        log_crit(\"Got an exception %s: Traceback: %s\" % (str(exc), traceback.format_exc()))\n        rc = -1\n        if g_debug:\n            raise\n    finally:\n        syslog.closelog()\n    try:\n        sys.exit(rc)\n    except SystemExit:\n        os._exit(rc)", "\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/__main__.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom .main import main\n\nif __name__ == '__main__':\n    main()\n", ""]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/managers_vppcfg.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport traceback\nfrom .log import log_crit, log_err, log_debug, log_notice, dev_debug, g_dev_debug\nfrom .manager import Manager\nfrom .template import TemplateFabric\nimport socket", "from .template import TemplateFabric\nimport socket\nimport json\nfrom .utils import print_dict\n\nclass VppCfgMgr(Manager):\n    \"\"\" This class updates vpp startup.conf when PLATFORM|vpp table entry is updated \"\"\"\n    def __init__(self, common_objs, db, table):\n        \"\"\"\n        Initialize the object\n        :param common_objs: common object dictionary\n        :param db: name of the db\n        :param table: name of the table in the db\n        \"\"\"\n        super(VppCfgMgr, self).__init__(\n            common_objs,\n            [],\n            db,\n            table,\n        )\n\n    def set_handler(self, key, data):\n        if key != \"vpp\":\n            return True\n        dev_debug(\"Key %s data %s\" % (key, data))\n        self.handle_config_data(data)\n        return True\n\n\n    def del_handler(self, key):\n        pass\n\n    @staticmethod\n    def split_key(key):\n        \"\"\"\n        :param key: key to split\n        :return:  table, key\n        \"\"\"\n\n        if '|' in key:\n            return tuple(key.split('|', 1))\n        else:\n            return None, key\n\n    def handle_config_data(self, data):\n        print_dict(data)\n        self.vpp_cfg = {}\n        for key, val in data.items():\n            val = val.replace(\"'\", \"\\\"\")\n            self.vpp_cfg[key] = json.loads(val)\n\n        self.cfg_mgr.update(self.vpp_cfg)", "\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/log.py", "chunked_list": ["# Copyright 2016 Microsoft, Inc.\n# Modifications copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport syslog\n\nfrom .vars import g_debug, g_dev_debug\n\ndef log_debug(msg):\n    \"\"\" Send a message msg to the syslog as DEBUG \"\"\"\n    dev_debug(msg)\n    if g_debug:\n        syslog.syslog(syslog.LOG_DEBUG, msg)", "from .vars import g_debug, g_dev_debug\n\ndef log_debug(msg):\n    \"\"\" Send a message msg to the syslog as DEBUG \"\"\"\n    dev_debug(msg)\n    if g_debug:\n        syslog.syslog(syslog.LOG_DEBUG, msg)\n\n\ndef log_notice(msg):\n    \"\"\" Send a message msg to the syslog as NOTICE \"\"\"\n    dev_debug(msg)\n    syslog.syslog(syslog.LOG_NOTICE, msg)", "\ndef log_notice(msg):\n    \"\"\" Send a message msg to the syslog as NOTICE \"\"\"\n    dev_debug(msg)\n    syslog.syslog(syslog.LOG_NOTICE, msg)\n\n\ndef log_info(msg):\n    \"\"\" Send a message msg to the syslog as INFO \"\"\"\n    dev_debug(msg)\n    syslog.syslog(syslog.LOG_INFO, msg)", "\n\ndef log_warn(msg):\n    \"\"\" Send a message msg to the syslog as WARNING \"\"\"\n    dev_debug(msg)\n    syslog.syslog(syslog.LOG_WARNING, msg)\n\n\ndef log_err(msg):\n    \"\"\" Send a message msg to the syslog as ERR \"\"\"\n    dev_debug(msg)\n    syslog.syslog(syslog.LOG_ERR, msg)", "def log_err(msg):\n    \"\"\" Send a message msg to the syslog as ERR \"\"\"\n    dev_debug(msg)\n    syslog.syslog(syslog.LOG_ERR, msg)\n\n\ndef log_crit(msg):\n    \"\"\" Send a message msg to the syslog as CRIT \"\"\"\n    dev_debug(msg)\n    syslog.syslog(syslog.LOG_CRIT, msg)", "\ndef dev_debug(msg):\n    if g_dev_debug:\n        print(msg)\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/runner.py", "chunked_list": ["# Copyright 2016 Microsoft, Inc.\n# Modifications copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom collections import defaultdict\nfrom swsscommon import swsscommon\n\nfrom .log import log_debug, log_crit", "\nfrom .log import log_debug, log_crit\n\n\ng_run = True\n\n\ndef signal_handler(_, __):  # signal_handler(signum, frame)\n    \"\"\" signal handler \"\"\"\n    global g_run\n    g_run = False", "\n\nclass Runner(object):\n    \"\"\" Implements main io-loop of the application\n        It will run event handlers inside of Manager objects\n        when corresponding db/table is updated\n    \"\"\"\n    SELECT_TIMEOUT = 1000\n\n    def __init__(self, cfg_manager):\n        \"\"\" Constructor \"\"\"\n        self.cfg_manager = cfg_manager\n        self.db_connectors = {}\n        self.selector = swsscommon.Select()\n        self.callbacks = defaultdict(lambda: defaultdict(list))  # db -> table -> handlers[]\n        self.subscribers = set()\n\n    def add_manager(self, manager):\n        \"\"\"\n        Add a manager to the Runner.\n        As soon as new events will be receiving by Runner,\n        handlers of corresponding objects will be executed\n        :param manager: an object implementing Manager\n        \"\"\"\n        db_name = manager.get_database()\n        table_name = manager.get_table_name()\n        db = swsscommon.SonicDBConfig.getDbId(db_name)\n        if db not in self.db_connectors:\n            self.db_connectors[db] = swsscommon.DBConnector(db_name, 0)\n\n        if table_name not in self.callbacks[db]:\n            conn = self.db_connectors[db]\n            subscriber = swsscommon.SubscriberStateTable(conn, table_name)\n            self.subscribers.add(subscriber)\n            self.selector.addSelectable(subscriber)\n        self.callbacks[db][table_name].append(manager.handler)\n\n    def run(self):\n        \"\"\" Main loop \"\"\"\n        while g_run:\n            state, _ = self.selector.select(Runner.SELECT_TIMEOUT)\n            if state == self.selector.TIMEOUT:\n                continue\n            elif state == self.selector.ERROR:\n                raise Exception(\"Received error from select\")\n\n            for subscriber in self.subscribers:\n                while True:\n                    key, op, fvs = subscriber.pop()\n                    if not key:\n                        break\n                    log_debug(\"Received message : '%s'\" % str((key, op, fvs)))\n                    for callback in self.callbacks[subscriber.getDbConnector().getDbId()][subscriber.getTableName()]:\n                        callback(key, op, dict(fvs))\n\n            rc = self.cfg_manager.commit()\n            if not rc:\n                log_crit(\"Runner::commit was unsuccessful\")", ""]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/config.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nfrom .vars import g_dev_debug, VPP_CONFIG_JSON_PATH, VPP_CFG_STARTUP_PATH, VPP_BOOTUP_CFG_PATH, INDENT\nfrom .log import dev_debug, log_notice\nfrom .utils import print_dict\nimport os", "from .utils import print_dict\nimport os\n\nclass ConfigMgr(object):\n    \"\"\" The class represents vpp configuration \"\"\"\n    def __init__(self, vpp):\n        self.vpp = vpp\n        self.vpp_json_cfg = None\n        self.vpp_startup_conf = ''\n        self.vpp_vports_conf = ''\n\n    def reset(self):\n        \"\"\" Reset stored config \"\"\"\n        self.vpp_json_cfg = None\n        self.vpp_startup_conf = ''\n        self.vpp_vports_conf = ''\n\n    def deep_update(self, input, output):\n        for key, val in input.items():\n            dev_debug(\"key {} : val {}\".format(key, val))\n            if key in output:\n                out_val = output[key]\n                if type(val) == dict:\n                    self.deep_update(val, out_val)\n                else:\n                    output[key] = val\n            else:\n                output[key] = val\n\n    def update(self, sonic_vpp_cfg):\n        \"\"\" Read current config from VPP \"\"\"\n        self.vpp_json_cfg = self.vpp.get_config()\n        self.deep_update(sonic_vpp_cfg, self.vpp_json_cfg)\n        print_dict(self.vpp_json_cfg)\n\n    def render_vpp_config(self):\n        indoff=''\n        self.vpp_startup_conf=''\n        self.gen_vpp_conf(self.vpp_json_cfg, indoff)\n\n    def gen_vpp_conf(self, cfg, indoff):\n        for key, val in cfg.items():\n            if type(val) == dict:\n                if key == 'vports':\n                    continue\n                if key == 'dev':\n                    self.gen_dpdk_dev_cfg(val, indoff)\n                elif key == 'plugin':\n                    self.gen_plugins_cfg(val, indoff)\n                else:\n                    self.vpp_startup_conf = self.vpp_startup_conf+indoff+key+' '+'{'+'\\n'\n                    self.gen_vpp_conf(val, indoff+INDENT)\n                    self.vpp_startup_conf = self.vpp_startup_conf+indoff+'}'+'\\n'\n            else:\n                if val:\n                    self.vpp_startup_conf = self.vpp_startup_conf+indoff+key+' '+val+'\\n'\n                else:\n                    self.vpp_startup_conf = self.vpp_startup_conf+indoff+key+'\\n'\n\n    def gen_dpdk_dev_cfg(self, cfg, indoff):\n        for key, val in cfg.items():\n            if type(val) == dict:\n                self.vpp_startup_conf = self.vpp_startup_conf+indoff+'dev '+key+' '+'{'+'\\n'\n                self.gen_dpdk_dev_cfg(val, indoff+INDENT)\n                self.vpp_startup_conf = self.vpp_startup_conf+indoff+'}'+'\\n'\n            else:\n                if val:\n                    self.vpp_startup_conf = self.vpp_startup_conf+indoff+key+' '+val+'\\n'\n                else:\n                    self.vpp_startup_conf = self.vpp_startup_conf+indoff+key+'\\n'\n\n    def gen_plugins_cfg(self, cfg, indoff):\n        for key, val in cfg.items():\n            self.vpp_startup_conf = self.vpp_startup_conf+indoff+'plugin '+key+' '+'{ '+val+' }'+'\\n'\n\n    def commit(self):\n        \"\"\"\n        Write configuration change to VPP.\n        :return: True if change was applied successfully, False otherwise\n        \"\"\"\n\n        self.vpp_vports_config()\n        self.vpp_dpdk_config()\n        self.vpp_env_config()\n        self.render_vpp_config()\n\n        with open(VPP_CONFIG_JSON_PATH, \"w\") as fp:\n            json.dump(self.vpp_json_cfg, fp, indent=4)\n\n        dev_debug(\"bootup ports config {}\".format(self.vpp_vports_conf))\n        with open(VPP_BOOTUP_CFG_PATH, \"w\") as fp:\n            fp.write(self.vpp_vports_conf)\n\n        dev_debug(\"startup {}\".format(self.vpp_startup_conf))\n        with open(VPP_CFG_STARTUP_PATH, \"w\") as fp:\n            fp.write(self.vpp_startup_conf)\n\n        self.reset()\n\n        log_notice(\"Config changes committed.\");\n        return True\n\n    def vpp_vports_config(self):\n        if 'vports' in self.vpp_json_cfg:\n            for key, val in self.vpp_json_cfg['vports'].items():\n                self.vpp_vports_conf = self.vpp_vports_conf + 'create host-interface name {}\\n'.format(key)\n\n    def vpp_dpdk_config(self):\n        disable_dpdk = True\n\n        if 'dpdk' in self.vpp_json_cfg and 'dev' in self.vpp_json_cfg['dpdk']:\n            for key, val in self.vpp_json_cfg['dpdk']['dev'].items():\n                if key != 'default':\n                    disable_dpdk = False\n\n        if disable_dpdk:\n            self.disable_dpdk_cfg()\n\n    def vpp_env_config(self):\n        disable_dpdk = os.getenv('DPDK_DISABLE', 'n')\n        if disable_dpdk == 'y':\n            self.disable_dpdk_cfg()\n\n        no_linux_nl = os.getenv('NO_LINUX_NL', 'n')\n        if no_linux_nl == 'y':\n            self.vpp_json_cfg['plugins']['plugin']['linux_nl_plugin.so'] = 'disable'\n\n    def disable_dpdk_cfg(self):\n        self.vpp_json_cfg['plugins']['plugin']['dpdk_plugin.so'] = 'disable'\n        self.vpp_json_cfg.pop('dpdk', None)", ""]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/vpp.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\n\nclass VppMgr(object):\n    \"\"\" The class represents vpp  configuration template in json\"\"\"\n    def __init__(self, template):\n        self.vpp_config = {}\n        with open(template, \"r\") as flp:\n            self.vpp_config = json.load(flp)\n            print(\"Template {}\".format(self.vpp_config))\n\n    def get_config(self):\n        return self.vpp_config", ""]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/template.py", "chunked_list": ["# Copyright 2016 Microsoft, Inc.\n# Modifications copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom collections import OrderedDict\nfrom functools import partial\n\nimport jinja2", "\nimport jinja2\nimport netaddr\n\nfrom .log import log_err\n\nclass TemplateFabric(object):\n    \"\"\" Fabric for rendering jinja2 templates \"\"\"\n    def __init__(self, template_path = '/usr/share/sonic/templates'):\n        j2_template_paths = [template_path]\n        j2_loader = jinja2.FileSystemLoader(j2_template_paths)\n        j2_env = jinja2.Environment(loader=j2_loader, trim_blocks=False)\n        j2_env.filters['ipv4'] = self.is_ipv4\n        j2_env.filters['ipv6'] = self.is_ipv6\n        j2_env.filters['pfx_filter'] = self.pfx_filter\n        for attr in ['ip', 'network', 'prefixlen', 'netmask']:\n            j2_env.filters[attr] = partial(self.prefix_attr, attr)\n        self.env = j2_env\n\n    def from_file(self, filename):\n        \"\"\"\n        Read a template from a file\n        :param filename: filename of the file. Type String\n        :return: Jinja2 template object\n        \"\"\"\n        return self.env.get_template(filename)\n\n    def from_string(self, tmpl):\n        \"\"\"\n        Read a template from a string\n        :param tmpl: Text representation of Jinja2 template\n        :return: Jinja2 template object\n        \"\"\"\n        return self.env.from_string(tmpl)\n\n    @staticmethod\n    def is_ipv4(value):\n        \"\"\" Return True if the value is an ipv4 address \"\"\"\n        if not value:\n            return False\n        if isinstance(value, netaddr.IPNetwork):\n            addr = value\n        else:\n            try:\n                addr = netaddr.IPNetwork(str(value))\n            except (netaddr.NotRegisteredError, netaddr.AddrFormatError, netaddr.AddrConversionError):\n                return False\n        return addr.version == 4\n\n    @staticmethod\n    def is_ipv6(value):\n        \"\"\" Return True if the value is an ipv6 address \"\"\"\n        if not value:\n            return False\n        if isinstance(value, netaddr.IPNetwork):\n            addr = value\n        else:\n            try:\n                addr = netaddr.IPNetwork(str(value))\n            except (netaddr.NotRegisteredError, netaddr.AddrFormatError, netaddr.AddrConversionError):\n                return False\n        return addr.version == 6\n\n    @staticmethod\n    def prefix_attr(attr, value):\n        \"\"\"\n        Extract attribute from IPNetwork object\n        :param attr: attribute to extract\n        :param value: the string representation of ip prefix which will be converted to IPNetwork.\n        :return: the value of the extracted attribute\n        \"\"\"\n        if not value:\n            return None\n        else:\n            try:\n                prefix = netaddr.IPNetwork(str(value).strip())\n            except (netaddr.NotRegisteredError, netaddr.AddrFormatError, netaddr.AddrConversionError):\n                return None\n        return str(getattr(prefix, attr))\n\n    @staticmethod\n    def pfx_filter(value):\n        \"\"\"INTERFACE Table can have keys in one of the two formats:\n           string or tuple - This filter skips the string keys and only\n           take into account the tuple.\n           For eg - VLAN_INTERFACE|Vlan1000 vs VLAN_INTERFACE|Vlan1000|192.168.0.1/21\n        \"\"\"\n        table = OrderedDict()\n\n        if not value:\n            return table\n\n        for key, val in value.items():\n            if not isinstance(key, tuple):\n                continue\n            intf, ip_address = key\n            if '/' not in ip_address:\n                if TemplateFabric.is_ipv4(ip_address):\n                    table[(intf, \"%s/32\" % ip_address)] = val\n                elif TemplateFabric.is_ipv6(ip_address):\n                    table[(intf, \"%s/128\" % ip_address)] = val\n                else:\n                    log_err(\"'%s' is invalid ip address\" % ip_address)\n            else:\n                table[key] = val\n        return table", ""]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/__init__.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/utils.py", "chunked_list": ["# Copyright 2016 Microsoft, Inc.\n# Modifications copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport subprocess\nimport yaml\n\nfrom .log import log_crit, log_debug, log_err", "\nfrom .log import log_crit, log_debug, log_err\nfrom .vars import g_dev_debug\n\ndef run_command(command, shell=False, hide_errors=False):\n    \"\"\"\n    Run a linux command. The command is defined as a list. See subprocess.Popen documentation on format\n    :param command: command to execute. Type: List of strings\n    :param shell: execute the command through shell when True. Type: Boolean\n    :param hide_errors: don't report errors to syslog when True. Type: Boolean\n    :return: Tuple: integer exit code from the command, stdout as a string, stderr as a string\n    \"\"\"\n    log_debug(\"execute command '%s'.\" % str(command))\n    p = subprocess.Popen(command, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding='utf-8')\n    stdout, stderr = p.communicate()\n    if p.returncode != 0:\n        if not hide_errors:\n            print_tuple = p.returncode, str(command), stdout, stderr\n            log_err(\"command execution returned %d. Command: '%s', stdout: '%s', stderr: '%s'\" % print_tuple)\n\n    return p.returncode, stdout, stderr", "\n\ndef read_constants():\n    \"\"\" Read file with constants values from /etc/sonic/constants.yml \"\"\"\n    with open('/etc/sonic/constants.yml') as fp:\n        content = yaml.load(fp) # FIXME: , Loader=yaml.FullLoader)\n        if \"constants\" not in content:\n            log_crit(\"/etc/sonic/constants.yml doesn't have 'constants' key\")\n            raise Exception(\"/etc/sonic/constants.yml doesn't have 'constants' key\")\n        return content[\"constants\"]", "\ndef print_dict(data):\n    if not g_dev_debug:\n        return\n    print(\"Printing dictionary {}\".format(data))\n    for key, val in data.items():\n        print(\"key {} : val {}\".format(key, val))\n        if type(val) == dict:\n            print_dict(val)\n", ""]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/directory.py", "chunked_list": ["# Copyright 2016 Microsoft, Inc.\n# Modifications copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,", "# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom collections import defaultdict\n\nfrom .log import log_err\n", "from .log import log_err\n\n\nclass Directory(object):\n    \"\"\" This class stores values and notifies callbacks which were registered to be executed as soon\n        as some value is changed. This class works as DB cache mostly \"\"\"\n    def __init__(self):\n        self.data = defaultdict(dict)  # storage. A key is a slot name, a value is a dictionary with data\n        self.notify = defaultdict(lambda: defaultdict(list))  # registered callbacks: slot -> path -> handlers[]\n\n    @staticmethod\n    def get_slot_name(db, table):\n        \"\"\" Convert db, table pair into a slot name \"\"\"\n        return db + \"__\" + table\n\n    def path_traverse(self, slot, path):\n        \"\"\"\n        Traverse a path in the storage.\n        If the path is an empty string, it returns a value as it is.\n        If the path is not an empty string, the method will traverse through the dictionary value.\n        Example:\n            self.data[\"key_1\"] = { \"abc\": { \"cde\": { \"fgh\": \"val_1\", \"ijk\": \"val_2\" } } }\n            self.path_traverse(\"key_1\", \"abc/cde\") will return True, { \"fgh\": \"val_1\", \"ijk\": \"val_2\" }\n        :param slot: storage key\n        :param path: storage path as a string where each internal key is separated by '/'\n        :return: a pair: True if the path was found, object if it was found\n        \"\"\"\n        if slot not in self.data:\n            return False, None\n        elif path == '':\n            return True, self.data[slot]\n        d = self.data[slot]\n        for p in path.split(\"/\"):\n            if p not in d:\n                return False, None\n            d = d[p]\n        return True, d\n\n    def path_exist(self, db, table, path):\n        \"\"\"\n        Check if the path exists in the storage\n        :param db: db name\n        :param table: table name\n        :param path: requested path\n        :return: True if the path is available, False otherwise\n        \"\"\"\n        slot = self.get_slot_name(db, table)\n        return self.path_traverse(slot, path)[0]\n\n    def get_path(self, db, table, path):\n        \"\"\"\n        Return the requested path from the storage\n        :param db: db name\n        :param table: table name\n        :param path: requested path\n        :return: object if the path was found, None otherwise\n        \"\"\"\n        slot = self.get_slot_name(db, table)\n        return self.path_traverse(slot, path)[1]\n\n    def put(self, db, table, key, value):\n        \"\"\"\n        Put information into the storage. Notify handlers which are dependant to the information\n        :param db: db name\n        :param table: table name\n        :param key: key to change\n        :param value: value to put\n        :return:\n        \"\"\"\n        slot = self.get_slot_name(db, table)\n        self.data[slot][key] = value\n        if slot in self.notify:\n            for path in self.notify[slot].keys():\n                if self.path_exist(db, table, path):\n                    for handler in self.notify[slot][path]:\n                        handler()\n\n    def get(self, db, table, key):\n        \"\"\"\n        Get a value from the storage\n        :param db: db name\n        :param table: table name\n        :param key: ket to get\n        :return: value for the key\n        \"\"\"\n        slot = self.get_slot_name(db, table)\n        return self.data[slot][key]\n\n    def get_slot(self, db, table):\n        \"\"\"\n        Get an object from the storage\n        :param db: db name\n        :param table: table name\n        :return: object for the slot\n        \"\"\"\n        slot = self.get_slot_name(db, table)\n        return self.data[slot]\n\n    def remove(self, db, table, key):\n        \"\"\"\n        Remove a value from the storage\n        :param db: db name\n        :param table: table name\n        :param key: key to remove\n        \"\"\"\n        slot = self.get_slot_name(db, table)\n        if slot in self.data:\n            if key in self.data[slot]:\n                del self.data[slot][key]\n            else:\n                log_err(\"Directory: Can't remove key '%s' from slot '%s'. The key doesn't exist\" % (key, slot))\n        else:\n            log_err(\"Directory: Can't remove key '%s' from slot '%s'. The slot doesn't exist\" % (key, slot))\n\n    def remove_slot(self, db, table):\n        \"\"\"\n        Remove an object from the storage\n        :param db: db name\n        :param table: table name\n        \"\"\"\n        slot = self.get_slot_name(db, table)\n        if slot in self.data:\n            del self.data[slot]\n        else:\n            log_err(\"Directory: Can't remove slot '%s'. The slot doesn't exist\" % slot)\n\n    def available(self, db, table):\n        \"\"\"\n        Check if the table is available\n        :param db: db name\n        :param table: table name\n        :return: True if the slot is available, False if not\n        \"\"\"\n        slot = self.get_slot_name(db, table)\n        return slot in self.data\n\n    def available_deps(self, deps):\n        \"\"\"\n        Check if all items from the deps list is available in the storage\n        :param deps: list of dependencies\n        :return: True if all dependencies are presented, False otherwise\n        \"\"\"\n        res = True\n        for db, table, path in deps:\n            res = res and self.path_exist(db, table, path)\n        return res\n\n    def subscribe(self, deps, handler):\n        \"\"\"\n        Subscribe the handler to be run as soon as all dependencies are presented\n        :param deps:\n        :param handler:\n        :return:\n        \"\"\"\n        for db, table, path in deps:\n            slot = self.get_slot_name(db, table)\n            self.notify[slot][path].append(handler)", ""]}
{"filename": "platform/vpp/docker-sonic-vpp/scripts/vppcfg_load.py", "chunked_list": ["#!/usr/bin/python3\n# -*- coding: utf-8 -*-\n# Copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport sys\nimport os", "import sys\nimport os\nimport tempfile\n\ndef load_config():\n    cfg = {}\n    vpp = {}\n    conf_db_set = os.getenv('VPP_CONF_DB', '')\n    if not conf_db_set or conf_db_set != 'y':\n        sys.exit(0)\n\n    portlist = os.getenv('VPP_DPDK_PORTS', '')\n    vports = {}\n    dpdk_ports = {}\n    index=0\n    for port in portlist.split(','):\n        rc = os.system('ip link show type veth dev {}'.format(port))\n        if rc == 0:\n            vports[port] = ''\n        else:\n            dpdk_ports[port] = {'name': 'bobm{}'.format(index)}\n            index += 1\n\n    if len(vports):\n        vpp['vports'] = vports\n\n    if len(dpdk_ports):\n        dpdk = { 'dev': dpdk_ports }\n        vpp['dpdk'] = dpdk\n\n    cfg['PLATFORM'] = { 'vpp': vpp }\n    print(cfg)\n    fd, tmpfile = tempfile.mkstemp(prefix='vppcfg')\n\n    with open(tmpfile, 'w') as fp:\n        json.dump(cfg, fp, indent=4)\n\n    rc = os.system('cat {}'.format(tmpfile))\n    rc += os.system('config load -y {}'.format(tmpfile))\n    os.close(fd)\n    os.unlink(tmpfile)\n\n    return rc", "\nif __name__ == '__main__':\n   sys.exit(load_config())\n"]}
{"filename": "platform/vpp/tests/breakout/test_breakout_cli.py", "chunked_list": ["from swsscommon import swsscommon\nimport time\nimport os\nimport json\nimport ast\nimport pytest\nimport collections\n\n@pytest.mark.usefixtures('dpb_setup_fixture')\nclass TestBreakoutCli(object):\n    def setup_db(self, dvs):\n        self.cdb = swsscommon.DBConnector(4, dvs.redis_sock, 0)\n\n    def read_Json(self, dvs):\n        test_dir = os.path.dirname(os.path.realpath(__file__))\n        sample_output_file = os.path.join(test_dir, 'sample_output', 'sample_new_port_config.json')\n        with open(sample_output_file, 'rb') as fh:\n            fh_data = json.load(fh)\n\n        if not fh_data:\n            return False\n        expected = ast.literal_eval(json.dumps(fh_data))\n        return expected\n\n    def breakout(self, dvs, interface, brkout_mode):\n        (exitcode, result) = dvs.runcmd(\"config interface breakout {} {} -y\".format(interface, brkout_mode))\n\n        if result.strip(\"\\n\")[0] == \"[ERROR] Breakout feature is not available without platform.json file\" :\n            pytest.skip(\"**** This test is not needed ****\")\n        root_dir = os.path.dirname('/')\n        (exitcode, output_dict) = dvs.runcmd(\"jq '.' new_port_config.json\")\n        if output_dict is None:\n            raise Exception(\"Breakout output cant be None\")\n\n        output_dict = ast.literal_eval(output_dict.strip())\n        return output_dict\n\n    # Check Initial Brakout Mode\n    def test_InitialBreakoutMode(self, dvs, testlog):\n        self.setup_db(dvs)\n\n        output_dict = {}\n        brkoutTbl = swsscommon.Table(self.cdb, \"BREAKOUT_CFG\")\n        brkout_entries = brkoutTbl.getKeys()\n        assert len(brkout_entries) == 32\n\n        for key in brkout_entries:\n            (status, fvs) = brkoutTbl.get(key)\n            assert status\n\n            brkout_mode = fvs[0][1]\n            output_dict[key] = brkout_mode\n        output = collections.OrderedDict(sorted(output_dict.items(), key=lambda t: t[0]))\n        expected_dict = \\\n                {'Ethernet8': '1x100G[40G]', 'Ethernet0': '1x100G[40G]', 'Ethernet4': '1x100G[40G]', \\\n                'Ethernet108': '1x100G[40G]', 'Ethernet100': '1x100G[40G]', 'Ethernet104': '1x100G[40G]', \\\n                'Ethernet68': '1x100G[40G]', 'Ethernet96': '1x100G[40G]', 'Ethernet124': '1x100G[40G]', \\\n                'Ethernet92': '1x100G[40G]', 'Ethernet120': '1x100G[40G]', 'Ethernet52': '1x100G[40G]', \\\n                'Ethernet56': '1x100G[40G]', 'Ethernet76': '1x100G[40G]', 'Ethernet72': '1x100G[40G]', \\\n                'Ethernet32': '1x100G[40G]', 'Ethernet16': '1x100G[40G]', 'Ethernet36': '1x100G[40G]', \\\n                'Ethernet12': '1x100G[40G]', 'Ethernet28': '1x100G[40G]', 'Ethernet88': '1x100G[40G]', \\\n                'Ethernet116': '1x100G[40G]', 'Ethernet80': '1x100G[40G]', 'Ethernet112': '1x100G[40G]', \\\n                'Ethernet84': '1x100G[40G]', 'Ethernet48': '1x100G[40G]', 'Ethernet44': '1x100G[40G]', \\\n                'Ethernet40': '1x100G[40G]', 'Ethernet64': '1x100G[40G]', 'Ethernet60': '1x100G[40G]', \\\n                'Ethernet20': '1x100G[40G]', 'Ethernet24': '1x100G[40G]'}\n        expected = collections.OrderedDict(sorted(expected_dict.items(), key=lambda t: t[0]))\n        assert output == expected\n\n    # Breakout Cli Test Mode\n    def test_breakout_modes(self, dvs):\n        expected = self.read_Json(dvs)\n        assert expected\n\n        print(\"**** Breakout Cli test Starts ****\")\n        output_dict = self.breakout(dvs, 'Ethernet0', '2x50G')\n        expected_dict = expected[\"Ethernet0_2x50G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1X100G --> 2x50G passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet4', '4x25G[10G]')\n        expected_dict = expected[\"Ethernet4_4x25G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1X100G --> 4x25G[10G] passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet8', '2x25G(2)+1x50G(2)')\n        expected_dict = expected[\"Ethernet8_2x25G_1x50G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1X100G --> 2x25G(2)+1x50G(2) passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet12', '1x50G(2)+2x25G(2)')\n        expected_dict = expected[\"Ethernet12_1x50G_2x25G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1X100G --> 1x50G(2)+2x25G(2) passed ****\")\n\n        # TODOFIX: remove comments once #4442 PR got merged and\n        # yang model for DEVICE_METADATA becomes available.\n        # As below test cases are dependent on DEVICE_METADATA to go\n        # from a non-default breakout mode to a different breakout mode.\n        \"\"\"\n        output_dict = self.breakout(dvs, 'Ethernet0', '1x100G[40G]')\n        expected_dict = expected[\"Ethernet0_1x100G\"]\n        assert output_dict == expected_dict\n        print(\"**** 2x50G --> 1x100G[40G] passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet0', '4x25G[10G]')\n        expected_dict = expected[\"Ethernet0_4x25G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1X100G --> 4x25G[10G] passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet0', '1x100G[40G]')\n        expected_dict = expected[\"Ethernet0_1x100G\"]\n        assert output_dict == expected_dict\n        print(\"**** 4x25G[10G] --> 1x100G[40G] passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet4', '2x50G')\n        print(\"**** 1X100G --> 2x50G mode change ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet4', '4x25G[10G]')\n        expected_dict = expected[\"Ethernet4_4x25G\"]\n        assert output_dict == expected_dict\n        print(\"**** 2X50G --> 4x25G[10G] passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet4', '2x50G')\n        expected_dict = expected[\"Ethernet4_2x50G\"]\n        assert output_dict == expected_dict\n        print(\"**** 4x25G[10G] --> 2X50G passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet4', '1x100G[40G]')\n        print(\"**** 2x50G  -- > 1X100G mode change ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet0', '2x25G(2)+1x50G(2)')\n        expected_dict = expected[\"Ethernet0_2x25G_1x50G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1x100G[40G] --> 2x25G(2)+1x50G(2) passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet0', '1x100G[40G]')\n        expected_dict = expected[\"Ethernet0_1x100G\"]\n        assert output_dict == expected_dict\n        print(\"**** 2x25G(2)+1x50G(2) --> 1x100G[40G] passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet0', '1x50G(2)+2x25G(2)')\n        expected_dict = expected[\"Ethernet0_1x50G_2x25G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1x100G[40G] --> 1x50G(2)+2x25G(2)  passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet0', '1x100G[40G]')\n        expected_dict = expected[\"Ethernet0_1x100G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1x50G(2)+2x25G(2) --> 1x100G[40G] passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet8', '2x50G')\n        print(\"**** 1x100G[40G] --> 2x50G  mode change ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet8', '1x50G(2)+2x25G(2)')\n        expected_dict = expected[\"Ethernet8_1x50G_2x25G\"]\n        assert output_dict == expected_dict\n        print(\"**** 2x50G --> 2x25G(2)+1x50G(2)  passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet8', '2x25G(2)+1x50G(2)')\n        expected_dict = expected[\"Ethernet8_2x25G_1x50G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1x50G(2)+2x25G(2) --> 2x25G(2)+1x50G(2)  passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet8', '1x100G[40G]')\n        expected_dict = expected[\"Ethernet8_1x100G\"]\n        assert output_dict == expected_dict\n        print(\"**** 2x25G(2)+1x50G(2)  --> 1x100G[40G]  passed ****\")\n        \"\"\"", "@pytest.mark.usefixtures('dpb_setup_fixture')\nclass TestBreakoutCli(object):\n    def setup_db(self, dvs):\n        self.cdb = swsscommon.DBConnector(4, dvs.redis_sock, 0)\n\n    def read_Json(self, dvs):\n        test_dir = os.path.dirname(os.path.realpath(__file__))\n        sample_output_file = os.path.join(test_dir, 'sample_output', 'sample_new_port_config.json')\n        with open(sample_output_file, 'rb') as fh:\n            fh_data = json.load(fh)\n\n        if not fh_data:\n            return False\n        expected = ast.literal_eval(json.dumps(fh_data))\n        return expected\n\n    def breakout(self, dvs, interface, brkout_mode):\n        (exitcode, result) = dvs.runcmd(\"config interface breakout {} {} -y\".format(interface, brkout_mode))\n\n        if result.strip(\"\\n\")[0] == \"[ERROR] Breakout feature is not available without platform.json file\" :\n            pytest.skip(\"**** This test is not needed ****\")\n        root_dir = os.path.dirname('/')\n        (exitcode, output_dict) = dvs.runcmd(\"jq '.' new_port_config.json\")\n        if output_dict is None:\n            raise Exception(\"Breakout output cant be None\")\n\n        output_dict = ast.literal_eval(output_dict.strip())\n        return output_dict\n\n    # Check Initial Brakout Mode\n    def test_InitialBreakoutMode(self, dvs, testlog):\n        self.setup_db(dvs)\n\n        output_dict = {}\n        brkoutTbl = swsscommon.Table(self.cdb, \"BREAKOUT_CFG\")\n        brkout_entries = brkoutTbl.getKeys()\n        assert len(brkout_entries) == 32\n\n        for key in brkout_entries:\n            (status, fvs) = brkoutTbl.get(key)\n            assert status\n\n            brkout_mode = fvs[0][1]\n            output_dict[key] = brkout_mode\n        output = collections.OrderedDict(sorted(output_dict.items(), key=lambda t: t[0]))\n        expected_dict = \\\n                {'Ethernet8': '1x100G[40G]', 'Ethernet0': '1x100G[40G]', 'Ethernet4': '1x100G[40G]', \\\n                'Ethernet108': '1x100G[40G]', 'Ethernet100': '1x100G[40G]', 'Ethernet104': '1x100G[40G]', \\\n                'Ethernet68': '1x100G[40G]', 'Ethernet96': '1x100G[40G]', 'Ethernet124': '1x100G[40G]', \\\n                'Ethernet92': '1x100G[40G]', 'Ethernet120': '1x100G[40G]', 'Ethernet52': '1x100G[40G]', \\\n                'Ethernet56': '1x100G[40G]', 'Ethernet76': '1x100G[40G]', 'Ethernet72': '1x100G[40G]', \\\n                'Ethernet32': '1x100G[40G]', 'Ethernet16': '1x100G[40G]', 'Ethernet36': '1x100G[40G]', \\\n                'Ethernet12': '1x100G[40G]', 'Ethernet28': '1x100G[40G]', 'Ethernet88': '1x100G[40G]', \\\n                'Ethernet116': '1x100G[40G]', 'Ethernet80': '1x100G[40G]', 'Ethernet112': '1x100G[40G]', \\\n                'Ethernet84': '1x100G[40G]', 'Ethernet48': '1x100G[40G]', 'Ethernet44': '1x100G[40G]', \\\n                'Ethernet40': '1x100G[40G]', 'Ethernet64': '1x100G[40G]', 'Ethernet60': '1x100G[40G]', \\\n                'Ethernet20': '1x100G[40G]', 'Ethernet24': '1x100G[40G]'}\n        expected = collections.OrderedDict(sorted(expected_dict.items(), key=lambda t: t[0]))\n        assert output == expected\n\n    # Breakout Cli Test Mode\n    def test_breakout_modes(self, dvs):\n        expected = self.read_Json(dvs)\n        assert expected\n\n        print(\"**** Breakout Cli test Starts ****\")\n        output_dict = self.breakout(dvs, 'Ethernet0', '2x50G')\n        expected_dict = expected[\"Ethernet0_2x50G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1X100G --> 2x50G passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet4', '4x25G[10G]')\n        expected_dict = expected[\"Ethernet4_4x25G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1X100G --> 4x25G[10G] passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet8', '2x25G(2)+1x50G(2)')\n        expected_dict = expected[\"Ethernet8_2x25G_1x50G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1X100G --> 2x25G(2)+1x50G(2) passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet12', '1x50G(2)+2x25G(2)')\n        expected_dict = expected[\"Ethernet12_1x50G_2x25G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1X100G --> 1x50G(2)+2x25G(2) passed ****\")\n\n        # TODOFIX: remove comments once #4442 PR got merged and\n        # yang model for DEVICE_METADATA becomes available.\n        # As below test cases are dependent on DEVICE_METADATA to go\n        # from a non-default breakout mode to a different breakout mode.\n        \"\"\"\n        output_dict = self.breakout(dvs, 'Ethernet0', '1x100G[40G]')\n        expected_dict = expected[\"Ethernet0_1x100G\"]\n        assert output_dict == expected_dict\n        print(\"**** 2x50G --> 1x100G[40G] passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet0', '4x25G[10G]')\n        expected_dict = expected[\"Ethernet0_4x25G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1X100G --> 4x25G[10G] passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet0', '1x100G[40G]')\n        expected_dict = expected[\"Ethernet0_1x100G\"]\n        assert output_dict == expected_dict\n        print(\"**** 4x25G[10G] --> 1x100G[40G] passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet4', '2x50G')\n        print(\"**** 1X100G --> 2x50G mode change ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet4', '4x25G[10G]')\n        expected_dict = expected[\"Ethernet4_4x25G\"]\n        assert output_dict == expected_dict\n        print(\"**** 2X50G --> 4x25G[10G] passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet4', '2x50G')\n        expected_dict = expected[\"Ethernet4_2x50G\"]\n        assert output_dict == expected_dict\n        print(\"**** 4x25G[10G] --> 2X50G passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet4', '1x100G[40G]')\n        print(\"**** 2x50G  -- > 1X100G mode change ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet0', '2x25G(2)+1x50G(2)')\n        expected_dict = expected[\"Ethernet0_2x25G_1x50G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1x100G[40G] --> 2x25G(2)+1x50G(2) passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet0', '1x100G[40G]')\n        expected_dict = expected[\"Ethernet0_1x100G\"]\n        assert output_dict == expected_dict\n        print(\"**** 2x25G(2)+1x50G(2) --> 1x100G[40G] passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet0', '1x50G(2)+2x25G(2)')\n        expected_dict = expected[\"Ethernet0_1x50G_2x25G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1x100G[40G] --> 1x50G(2)+2x25G(2)  passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet0', '1x100G[40G]')\n        expected_dict = expected[\"Ethernet0_1x100G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1x50G(2)+2x25G(2) --> 1x100G[40G] passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet8', '2x50G')\n        print(\"**** 1x100G[40G] --> 2x50G  mode change ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet8', '1x50G(2)+2x25G(2)')\n        expected_dict = expected[\"Ethernet8_1x50G_2x25G\"]\n        assert output_dict == expected_dict\n        print(\"**** 2x50G --> 2x25G(2)+1x50G(2)  passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet8', '2x25G(2)+1x50G(2)')\n        expected_dict = expected[\"Ethernet8_2x25G_1x50G\"]\n        assert output_dict == expected_dict\n        print(\"**** 1x50G(2)+2x25G(2) --> 2x25G(2)+1x50G(2)  passed ****\")\n\n        output_dict = self.breakout(dvs, 'Ethernet8', '1x100G[40G]')\n        expected_dict = expected[\"Ethernet8_1x100G\"]\n        assert output_dict == expected_dict\n        print(\"**** 2x25G(2)+1x50G(2)  --> 1x100G[40G]  passed ****\")\n        \"\"\"", ""]}
{"filename": "platform/vpp/tests/teamd/test_portchannel.py", "chunked_list": ["from swsscommon import swsscommon\nimport time\nimport re\nimport json\n\ndef test_PortChannel(dvs, testlog):\n    appldb = swsscommon.DBConnector(0, dvs.redis_sock, 0)\n    statdb = swsscommon.DBConnector(6, dvs.redis_sock, 0)\n\n    # create the lag\n    dvs.runcmd(\"config portchannel add PortChannel0001\")\n    time.sleep(1)\n\n    # test lag table in appl db\n    tbl = swsscommon.Table(appldb, \"LAG_TABLE\")\n    (status, fvs) = tbl.get(\"PortChannel0001\")\n    assert status == True\n\n    # test lag table in state db\n    tbl = swsscommon.Table(statdb, \"LAG_TABLE\")\n    (status, fvs) = tbl.get(\"PortChannel0001\")\n    assert status == True\n\n    # create the lag member\n    dvs.runcmd(\"config portchannel member add PortChannel0001 Ethernet112\")\n    time.sleep(1)\n\n    # test lag member table in appl db\n    tbl = swsscommon.Table(appldb, \"LAG_MEMBER_TABLE\")\n    (status, fvs) = tbl.get(\"PortChannel0001:Ethernet112\")\n    assert status == True\n\n    # remove the lag member\n    dvs.runcmd(\"config portchannel member del PortChannel0001 Ethernet112\")\n\n    # remove the lag\n    dvs.runcmd(\"config portchannel del PortChannel0001\")", ""]}
{"filename": "platform/vpp/tests/bgp/test_invalid_nexthop.py", "chunked_list": ["from swsscommon import swsscommon\nimport os\nimport re\nimport time\nimport json\nimport pytest\n\ndef test_InvalidNexthop(dvs, testlog):\n\n    dvs.copy_file(\"/etc/frr/\", \"bgp/files/invalid_nexthop/bgpd.conf\")\n    dvs.runcmd(\"supervisorctl start bgpd\")\n    dvs.runcmd(\"ip addr add fc00::1/126 dev Ethernet0\")\n    dvs.runcmd(\"config interface startup Ethernet0\")\n\n    dvs.servers[0].runcmd(\"ip addr add fc00::2/126 dev eth0\")\n    dvs.servers[0].runcmd(\"ifconfig eth0 up\")\n\n    time.sleep(5)\n\n    print(dvs.runcmd(\"supervisorctl status\"))\n\n    p = dvs.servers[0].runcmd_async(\"exabgp -d bgp/files/invalid_nexthop/invalid_nexthop.conf\")\n\n    time.sleep(10)\n\n    (exit_code, output) = dvs.runcmd([\"vtysh\", \"-c\", \"show bgp ipv6\"])\n\n    p.terminate()\n    p = p.wait()\n\n    print(exit_code, output)\n\n    assert \"3333::/64\" in output", ""]}
{"filename": "platform/vpp/tests/bgp/test_no_export.py", "chunked_list": ["from swsscommon import swsscommon\nimport os\nimport re\nimport time\nimport json\n\ndef test_bounce(dvs, testlog):\n    dvs.copy_file(\"/etc/frr/\", \"bgp/files/no_export/bgpd.conf\")\n    dvs.runcmd(\"supervisorctl start bgpd\")\n    dvs.runcmd(\"ip addr add 10.0.0.0/31 dev Ethernet0\")\n    dvs.runcmd(\"config interface startup Ethernet0\")\n\n    dvs.runcmd(\"ip addr add 10.0.0.2/31 dev Ethernet4\")\n    dvs.runcmd(\"config interface startup Ethernet4\")\n\n    dvs.servers[0].runcmd(\"ip addr add 10.0.0.1/31 dev eth0\")\n    dvs.servers[0].runcmd(\"ifconfig eth0 up\")\n\n    dvs.servers[1].runcmd(\"ip addr add 10.0.0.3/31 dev eth0\")\n    dvs.servers[1].runcmd(\"ifconfig eth0 up\")\n\n    time.sleep(5)\n\n    p1 = dvs.servers[0].runcmd_async(\"exabgp -d bgp/files/no_export/exabgp1.conf\")\n    p2 = dvs.servers[1].runcmd_async(\"exabgp -d bgp/files/no_export/exabgp2.conf\")\n\n    time.sleep(60)\n\n    (exit_code, sum_res) =  dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp sum\"])\n    (exit_code, all_route) = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp\"])\n    (exit_code, announce_route) = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.3 advertised-routes\"])\n\n    p1.terminate()\n    p1 = p1.wait()\n\n    p2.terminate()\n    p2 = p2.wait()\n\n    print(sum_res)\n    print(announce_route)\n    assert \"1.1.1.1/32\" in all_route\n    assert \"1.1.1.1/32\" not in announce_route\n    assert \"2.2.2.2/32\" in all_route\n    assert \"2.2.2.2/32\" in announce_route", ""]}
{"filename": "platform/vpp/tests/bgp/test_gr_livelock.py", "chunked_list": ["from swsscommon import swsscommon\nimport os\nimport re\nimport time\nimport json\nimport random\n\ndef output(dvs, title):\n    print(\"=========================== %s ===========================\" % title)\n    exit_cod,  sum_res =  dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp sum\"])\n    exit_code, all_route = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp\"])\n    exit_code, neig_1           = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.1\"])\n    exit_code, announce_route_1 = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.1 advertised-routes\"])\n    exit_code, received_route_1 = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.1 routes\"])\n    exit_code, announce_route_3 = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.3 advertised-routes\"])\n    exit_code, received_route_3 = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.3 routes\"])\n    print(\"Summary:\")\n    print(sum_res)\n    print(\"Received routes:\")\n    print(\"10.0.0.1\")\n    print(received_route_1)\n    print(\"10.0.0.3\")\n    print(received_route_3)\n    print(\"Announces routes:\")\n    print(\"10.0.0.1\")\n    print(announce_route_1)\n    print(\"10.0.0.3\")\n    print(announce_route_3)\n    print(\"Neighbors\")\n    print(\"10.0.0.1\")\n    print(neig_1)\n    print(\"======================================================\")", "\ndef mkdir(path):\n    if not os.path.exists(path):\n        os.makedirs(path)\n\ndef remove(path):\n    if os.path.exists(path):\n        os.unlink(path)\n\ndef get_target_env(idx):\n    return '/usr/local/etc/exabgp/exabgp_%d.env' % idx", "\ndef get_target_env(idx):\n    return '/usr/local/etc/exabgp/exabgp_%d.env' % idx\n\ndef prepare_exa_env(dvs, idx):\n    mkdir('/usr/local/etc')\n    mkdir('/usr/local/etc/exabgp')\n    tmp_name = '/tmp/env.%d.%d' % (random.randint(0, 10000000), os.getpid())\n    dvs.servers[idx].runcmd(\"exabgp --fi > %s\" % tmp_name)\n    with open(tmp_name) as r_fp:\n        with open(get_target_env(idx), 'w') as w_fp:\n            for line in r_fp:\n                if line.startswith('pipename'):\n                    line = \"pipename = 'exabgp.%d'\\n\" % idx\n                w_fp.write(line)\n    os.unlink(tmp_name)", "\n\ndef run_exa(dvs, idx, cfg):\n    prepare_exa_env(dvs, idx)\n    run_dir = \"/var/run/exabgp\"\n    mkdir(run_dir)\n    fifo_in_path  = \"%s/exabgp.%d.in\"  % (run_dir, idx)\n    fifo_out_path = \"%s/exabgp.%d.out\" % (run_dir, idx)\n    remove(fifo_in_path)\n    remove(fifo_out_path)\n    os.mkfifo(fifo_in_path)\n    os.mkfifo(fifo_out_path)\n    os.chmod(fifo_in_path,  0o666)\n    os.chmod(fifo_out_path, 0o666)\n    print(\"!!! Start exabgp instance %d\" % idx)\n    cmd = \"exabgp -d --env %s %s\" % (get_target_env(idx), cfg)\n    print(\"Cmd is ___ %s ___\" % cmd)\n    return dvs.servers[idx].runcmd_async(cmd)", "\ndef run_exacli(dvs, idx, cmd):\n    return dvs.servers[idx].runcmd('exabgpcli --env %s %s' % (get_target_env(idx), cmd))\n\ndef test_gr_livelock(dvs, testlog):\n    # update exabgp to version 4.0.10\n    dvs.servers[0].runcmd(\"pip install 'exabgp==4.0.10' --force-reinstall \")\n    #\n    dvs.copy_file(\"/etc/frr/\", \"bgp/files/gr_livelock/bgpd.conf\")\n    dvs.runcmd(\"supervisorctl stop bgpd\")\n    time.sleep(5)\n    dvs.runcmd(\"supervisorctl start bgpd\")\n    dvs.runcmd(\"ip addr add 10.0.0.0/31 dev Ethernet0\")\n    dvs.runcmd(\"config interface startup Ethernet0\")\n\n    dvs.runcmd(\"ip addr add 10.0.0.2/31 dev Ethernet4\")\n    dvs.runcmd(\"config interface startup Ethernet4\")\n\n    dvs.servers[0].runcmd(\"ip addr add 10.0.0.1/31 dev eth0\")\n    dvs.servers[0].runcmd(\"ifconfig eth0 up\")\n\n    dvs.servers[1].runcmd(\"ip addr add 10.0.0.3/31 dev eth0\")\n    dvs.servers[1].runcmd(\"ifconfig eth0 up\")\n\n    time.sleep(5)\n\n    # Run two bgp neighbors\n    p1 = run_exa(dvs, 0, \"bgp/files/gr_livelock/exabgp1.conf\")\n    p2 = run_exa(dvs, 1, \"bgp/files/gr_livelock/exabgp2.conf\")\n\n    time.sleep(30)\n\n    output(dvs, \"First neighbor doesn't have GR enabled\")\n\n    # Check that we announce routes from the 1st neigbbor to 2nd, if 1st neighbor doesn't support graceful restart\n    _, announced_routes = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.3 advertised-routes\"])\n    assert '2.2.2.2/32' in announced_routes\n\n    # Stop 1st neighbor\n    run_exacli(dvs, 0, 'shutdown')\n    p1 = p1.wait()\n\n    # Wait until frr thinks that 1st neighbor was shut down\n    time.sleep(300)\n\n    # Start the 1st neighbor again with graceful restart enabled\n    p1 = run_exa(dvs, 0, \"bgp/files/gr_livelock/exabgp1.graceful.conf\")\n\n    time.sleep(60)\n\n    output(dvs, \"First neighbor has GR enalbed\")\n\n    run_exacli(dvs, 0, 'announce route 1.10.0.0/24 next-hop self')\n\n    time.sleep(60)\n\n    output(dvs, \"Announced a new route from the first neighbor\")\n\n    # Check that we announce all routes from the 1st neighbor\n    _, announced_routes = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.3 advertised-routes\"])\n    assert '2.2.2.2/32'  in announced_routes\n    assert '1.10.0.0/24' in announced_routes\n\n    run_exacli(dvs, 0, 'shutdown')\n    p1 = p1.wait()\n\n    run_exacli(dvs, 1, 'shutdown')\n    p2 = p2.wait()", ""]}
{"filename": "platform/vpp/tests/bgp/test_default_route.py", "chunked_list": ["from swsscommon import swsscommon\nimport os\nimport re\nimport time\nimport json\nimport pytest\n\ndef test_DefaultRoute(dvs, testlog):\n\n    dvs.copy_file(\"/etc/frr/\", \"bgp/files/default_route/bgpd.conf\")\n    dvs.runcmd(\"supervisorctl start bgpd\")\n    dvs.runcmd(\"ip addr add 10.10.10.0/31 dev Ethernet0\")\n    dvs.runcmd(\"config interface startup Ethernet0\")\n    dvs.runcmd(\"ip route del 0.0.0.0/0\")\n    dvs.runcmd(\"vtysh -c \\\"confgure terminal\\\" -c \\\"ip route 0.0.0.0/0 via 172.17.0.1 200\\\"\")\n\n    dvs.servers[0].runcmd(\"ip addr add 10.10.10.1/31 dev eth0\")\n    dvs.servers[0].runcmd(\"ifconfig eth0 up\")\n\n    time.sleep(5)\n\n    print(dvs.runcmd(\"supervisorctl status\"))\n\n    p = dvs.servers[0].runcmd_async(\"exabgp -d bgp/files/default_route/default_route.conf\")\n\n    time.sleep(10)\n\n    (exit_code, output) = dvs.runcmd([\"redis-cli\", \"hgetall\", \"ROUTE_TABLE:0.0.0.0/0\"])\n    print(exit_code, output)\n\n    # make sure 10.10.10.1 is the correct next hop for default route\n    assert \"10.10.10.1\" in output\n\n    # insert default route for table default\n    dvs.runcmd(\"ip route add default via 172.17.0.1 table default\")\n\n    (exit_code, output) = dvs.runcmd([\"redis-cli\", \"hgetall\", \"ROUTE_TABLE:0.0.0.0/0\"])\n    print(exit_code, output)\n\n    time.sleep(10)\n    # make sure 10.10.10.1 is still the correct next hop for default route\n    assert \"10.10.10.1\" in output\n\n    p.terminate()\n    p = p.wait()", "\n\n\n"]}
{"filename": "tests/validate-sonic-vpp-vm-routing.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport sys\nimport subprocess\nimport yaml\nimport ipaddress\nimport pprint", "import ipaddress\nimport pprint\nimport re\nimport argparse\nfrom jinja2 import Environment, FileSystemLoader\n\ndef getIppoolAndCidrMask(ipPoolCidr):\n    separator = \"/\"\n    ippool = ipPoolCidr.split(separator)\n    return ippool[0], ippool[1]", "\ndef checkPosInteger(num):\n    if not num.isdigit():\n        print(f'Invalid IPPool has been provided')\n        sys.exit(1)\n\ndef checkIp(ip):\n    try:\n        ipaddress.ip_address(ip)\n    except ValueError:\n        print(f'Invalid IP address specified - {ip}')\n        sys.exit(1)", "\ndef checkAction(action):\n    \n    if  action != \"build\" and action != \"tear\" and action != \"build,tear\":\n        print(\"Invalid action specified\")\n        sys.exit(1)\n  \ndef getSubnet(ippool):\n\n    separator = \".\"\n\n    subnetArr = ippool.split(separator)\n\n    subnetReqdArr = subnetArr[:2]\n\n    subnet =  separator.join(subnetReqdArr)\n\n    return subnet", "\n\ndef checkVerboselog(verboselog):\n    for i in verboselog:\n        if i != 'v' and verboselog.count(i) != len(verboselog):\n            print(\"Invalid verbose argument passed. Please pass like - 'v' or 'vv' or 'vvv' or 'vvvv' or 'vvvvvv\")\n            sys.exit(1)\n\n\ndef createInventoryFromTemplate(username, password, host):\n\n    environment = Environment(loader=FileSystemLoader(\".\"))\n\n    #inventory.j2\n    template = environment.get_template(\"inventory-vm.j2\")\n\n    #new inventory file with values filled at templatized variables\n    filename = \"inventory-vm.yaml\"\n    content = template.render(\n        username = username,\n        password = password,\n        host = host\n    )\n    with open(filename, mode=\"w\", encoding=\"utf-8\") as message:\n        message.write(content)\n        print(f\"... wrote {filename}\")", "\ndef createInventoryFromTemplate(username, password, host):\n\n    environment = Environment(loader=FileSystemLoader(\".\"))\n\n    #inventory.j2\n    template = environment.get_template(\"inventory-vm.j2\")\n\n    #new inventory file with values filled at templatized variables\n    filename = \"inventory-vm.yaml\"\n    content = template.render(\n        username = username,\n        password = password,\n        host = host\n    )\n    with open(filename, mode=\"w\", encoding=\"utf-8\") as message:\n        message.write(content)\n        print(f\"... wrote {filename}\")", "      \n\ndef runSonic(action, verboselogArg):\n\n    ansiblePlaybook = \"sonic-vpp-vm-bring-up.yaml\"\n\n    print(\"ansible-playbook : \", ansiblePlaybook, \"\\n\")\n\n    cmd = ['ansible-playbook', '-i', 'inventory-vm.yaml',  ansiblePlaybook, '--extra-vars', '@inventory-vm.yaml', '--tags', action, verboselogArg]\n\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n\n    for l in p.stdout.readlines():\n        loglineDecoded = l.decode()\n        print(loglineDecoded)\n\n        if  re.search('failed=', loglineDecoded) != None and re.search('unreachable=', loglineDecoded) != None:\n            if None == re.search('failed=0', loglineDecoded):\n                print(f'failed to execute {loglineDecoded.split().pop(0)} ansible {action} task')\n                sys.exit(1)\n            if None == re.search('unreachable=0', loglineDecoded):\n                print(f'failed to execute {loglineDecoded.split().pop(0)} ansible {action} task, VM is unreachable')\n                sys.exit(1)\n\n        if None != re.search('ok=0', loglineDecoded):\n            print(f'unable to execute {loglineDecoded.split().pop(0)} ansible {action} task')\n            sys.exit(1)\n\n    if action == \"build\" or action == \"build,tear\":\n        print(\"SUCCESSFUL in validating SONiC VM routing...\\n\")\n    else:\n        print(\"SUCCESSFUL in tearing down SONiC VM routing...\\n\")    \n\n    print(\"OPERATION COMPLETE...\\n\") ", "\n#Main\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--action\", type=str, help=\"enter action -  {'build' | 'tear'}\", nargs='?', default=\"build,tear\")\nparser.add_argument(\"--IPPool\", type=str, help=\"enter IPPool - example : '172.16.0.0/16'\", nargs='?', default=\"172.16.0.0/16\") \nparser.add_argument(\"--host\", type=str, help=\"enter host - example : '10.64.98.181'\", nargs='?',required=True )   \nparser.add_argument(\"--username\", type=str, help=\"enter SSH username for host\", nargs='?',required=True ) \nparser.add_argument(\"--password\", type=str, help=\"enter SSH user password for host\", nargs='?',required=True )                       \nparser.add_argument(\"--verboselog\", type=str, help=\"enter verbose logging - example : 'v or vv or vvv etc'\", nargs='?', default=\"v\")", "parser.add_argument(\"--password\", type=str, help=\"enter SSH user password for host\", nargs='?',required=True )                       \nparser.add_argument(\"--verboselog\", type=str, help=\"enter verbose logging - example : 'v or vv or vvv etc'\", nargs='?', default=\"v\")\n\n\nargs = parser.parse_args()\n\naction = args.action\nippoolCidr = args.IPPool\nhost = args.host\nusername = args.username", "host = args.host\nusername = args.username\npassword = args.password\nverboselog = args.verboselog\n\n#check action\ncheckAction(action)\n\n#get ippool\nipPool, cidrMask = getIppoolAndCidrMask(ippoolCidr)", "#get ippool\nipPool, cidrMask = getIppoolAndCidrMask(ippoolCidr)\n\n#validate ippool\ncheckIp(ipPool)\n\n#validate cidrMask\ncheckPosInteger(cidrMask)\n\n#extract subnet", "\n#extract subnet\nsubnet =  getSubnet(ipPool)\n\n#validate host\ncheckIp(host)\n\n#validate verbose argument\ncheckVerboselog(verboselog)\n", "checkVerboselog(verboselog)\n\nprint('Arguments passed:\\n')\nprint('_________________________\\n')\nprint(f'action - {action}\\nusername - {username}\\npassword - {password}\\nhost - {host}\\nverbose - {verboselog}')\nprint('_________________________\\n')\n\n#create inventory yaml file\ncreateInventoryFromTemplate(username, password, host)\n", "createInventoryFromTemplate(username, password, host)\n\n#run python script\nrunSonic(action, \"-\"+verboselog)\n\nsys.exit(0)\n"]}
{"filename": "tests/validate-sonic-vpp-docker-routing.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport sys\nimport subprocess\nimport yaml\nimport ipaddress\nimport pprint", "import ipaddress\nimport pprint\nimport re\nimport argparse\nfrom jinja2 import Environment, FileSystemLoader\n\ndef getIppoolAndCidrMask(ipPoolCidr):\n    separator = \"/\"\n    ippool = ipPoolCidr.split(separator)\n\n    if len(ippool) != 2:\n        print(f'Invalid IP Pool - \"{ipPoolCidr}\" is specified')\n        sys.exit(1)\n\n    return ippool[0], ippool[1]", "\ndef checkPosInteger(num):\n    if not num.isdigit():\n        print(f'Invalid IPPool has been provided')\n        sys.exit(1)\n\ndef checkIp(ip):\n    try:\n        ipaddress.ip_address(ip)\n    except ValueError:\n        print(f'Invalid IP address specified - {ip}')\n        sys.exit(1)", "\ndef checkAction(action):\n\n    if  action != \"build\" and action != \"tear\" and action != \"build,tear\":\n        print(\"Invalid action specified\")\n        sys.exit(1)\n  \n\ndef checkTopology(topology):\n    if not (topology == \"singleHop\" or topology == \"multiHop\"):\n        print(\"Invalid topology specified\")\n        sys.exit(1)", "def checkTopology(topology):\n    if not (topology == \"singleHop\" or topology == \"multiHop\"):\n        print(\"Invalid topology specified\")\n        sys.exit(1)\n\ndef checkRouting(routing):\n    if not (routing == \"static\" or routing == \"bgp\"):\n        print(\"Invalid routing protocol specified\")\n        sys.exit(1)\n\ndef checkIpType(ip, iptype):\n\n    if iptype == \"ipv4\":\n\n        if not type(ipaddress.ip_address(ip)) is ipaddress.IPv4Address:\n            print(f'Invalid IPV4 address - \"{ip}\" is specified')\n            sys.exit(1)\n\n    elif iptype == \"ipv6\":\n         if not type(ipaddress.ip_address(ip)) is ipaddress.IPv6Address:\n            print(f'Invalid IPV6 address - \"{ip}\" is specified')\n            sys.exit(1)        ", "\ndef checkIpType(ip, iptype):\n\n    if iptype == \"ipv4\":\n\n        if not type(ipaddress.ip_address(ip)) is ipaddress.IPv4Address:\n            print(f'Invalid IPV4 address - \"{ip}\" is specified')\n            sys.exit(1)\n\n    elif iptype == \"ipv6\":\n         if not type(ipaddress.ip_address(ip)) is ipaddress.IPv6Address:\n            print(f'Invalid IPV6 address - \"{ip}\" is specified')\n            sys.exit(1)        ", "\n\ndef getSubnet(ippool, separator):\n\n    subnetArr = ippool.split(separator)\n\n    subnetReqdArr = subnetArr[:2]\n\n    subnet =  separator.join(subnetReqdArr)\n\n    return subnet", "\ndef checkVerboselog(verboselog):\n    for i in verboselog:\n        if i != 'v' and verboselog.count(i) != len(verboselog):\n            print(\"Invalid verbose argument passed. Please pass like - 'v' or 'vv' or 'vvv' or 'vvvv' or 'vvvvvv\")\n            sys.exit(1)\n\n\ndef checkNoLinuxNl(noLinuxNl):\n\n    if noLinuxNl != \"yes\" and noLinuxNl != \"no\":\n        print(\"Invalid 'noLinuxNl' argument specified. Enter 'yes' or 'no'\")\n        sys.exit(1)", "def checkNoLinuxNl(noLinuxNl):\n\n    if noLinuxNl != \"yes\" and noLinuxNl != \"no\":\n        print(\"Invalid 'noLinuxNl' argument specified. Enter 'yes' or 'no'\")\n        sys.exit(1)\n\ndef createInventoryFromTemplate(subnet, username, password, host, subnetV6, noLinuxNl):\n    environment = Environment(loader=FileSystemLoader(\".\"))\n\n    #inventory.j2\n    template = environment.get_template(\"inventory.j2\")\n\n    #new inventory file with values filled at templatized variables\n    filename = \"inventory.yaml\"\n\n    noLinuxNlArg = \"\"\n\n    if noLinuxNl == \"yes\":\n        noLinuxNlArg = \"y\"\n    elif noLinuxNl == \"no\":\n        noLinuxNlArg = \"n\"\n\n    content = template.render(\n        subnet = subnet,\n        username = username,\n        password = password,\n        host = host,\n        ipv6_subnet = subnetV6,\n        no_linux_nl = noLinuxNlArg\n    )\n    with open(filename, mode=\"w\", encoding=\"utf-8\") as message:\n        message.write(content)\n        print(f\"... wrote {filename}\")", "\ndef execute(ansiblePlaybook, topology, verboselogArg):\n\n    cmd = ['ansible-playbook', '-i', 'inventory.yaml',  ansiblePlaybook, '--extra-vars', '@inventory.yaml', '--tags', topology,  verboselogArg]\n    print(cmd)\n\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n\n    for l in p.stdout.readlines():\n        loglineDecoded = l.decode()\n        print(loglineDecoded)\n\n        if  re.search('failed=', loglineDecoded) != None and re.search('unreachable=', loglineDecoded) != None:\n            if None == re.search('failed=0', loglineDecoded):\n                print(f'failed to execute {loglineDecoded.split().pop(0)} ansible {topology} task')\n                sys.exit(1)\n            if None == re.search('unreachable=0', loglineDecoded):\n                print(f'failed to execute {loglineDecoded.split().pop(0)} ansible {topology} task, VM is unreachable')\n                sys.exit(1)\n\n        if None != re.search('ok=0', loglineDecoded):\n            print(f'unable to execute {loglineDecoded.split().pop(0)} ansible {topology} task')\n            sys.exit(1)", "\n   \n\ndef runSonic(action, topology, routing, verboselogArg):\n\n    #playbook file is first argument taken\n    if action == \"build\":\n        ansiblePlaybook = \"sonic-sw-dp-bring-up.yaml\"\n        print(\"ansiblePlaybook : \", ansiblePlaybook, \"\\n\")\n        if topology == \"multiHop\":\n           topology = topology + ',' + routing\n        execute(ansiblePlaybook, topology, verboselogArg)\n        print(\"SUCCESSFUL in validating SONiC routing...\\n\")\n\n    elif action == \"tear\":\n        ansiblePlaybook = \"sonic-sw-dp-bring-down.yaml\"\n        print(\"ansiblePlaybook : \", ansiblePlaybook, \"\\n\")\n        execute(ansiblePlaybook, topology, verboselogArg)\n        print(\"SUCCESSFUL in tearing down...\\n\")    ", "\n\n\n#Main\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--action\", type=str, help=\"enter action -  {'build' | 'tear'}\", nargs='?', default=\"build,tear\")\nparser.add_argument(\"--topology\", type=str, help=\"enter topology - {'singleHop' | 'multiHop'}\", nargs='?', default=\"multiHop\")\nparser.add_argument(\"--routing\", type=str, help=\"enter routing protocol - {'static' | 'bgp'}\", nargs='?', default=\"bgp\")\nparser.add_argument(\"--IPPool\", type=str, help=\"enter IPPool - example : '172.16.0.0/16'\", nargs='?', default=\"172.16.0.0/16\") ", "parser.add_argument(\"--routing\", type=str, help=\"enter routing protocol - {'static' | 'bgp'}\", nargs='?', default=\"bgp\")\nparser.add_argument(\"--IPPool\", type=str, help=\"enter IPPool - example : '172.16.0.0/16'\", nargs='?', default=\"172.16.0.0/16\") \nparser.add_argument(\"--IPV6Pool\", type=str, help=\"enter IPV6Pool - example : '2001:0db8::/64'\", nargs='?', default=\"2001:0db8::/64\") \nparser.add_argument(\"--host\", type=str, help=\"enter host - example : '10.64.98.181'\", nargs='?',required=True )   \nparser.add_argument(\"--username\", type=str, help=\"enter SSH username for host\", nargs='?',required=True ) \nparser.add_argument(\"--password\", type=str, help=\"enter SSH user password for host\", nargs='?',required=True )                       \nparser.add_argument(\"--verboselog\", type=str, help=\"enter verbose logging - example : 'v or vv or vvv etc'\", nargs='?', default=\"v\")\nparser.add_argument(\"--noLinuxNl\", type=str, help=\"enter noLinuxNl - example : 'yes' or 'no'\", nargs='?', default=\"no\")\n\n", "\n\nargs = parser.parse_args()\n\n\naction = args.action\ntopology = args.topology\nrouting = args.routing\nippoolCidr = args.IPPool\nipv6poolCidr = args.IPV6Pool", "ippoolCidr = args.IPPool\nipv6poolCidr = args.IPV6Pool\nhost = args.host\nusername = args.username\npassword = args.password\nverboselog = args.verboselog\nnoLinuxNl = args.noLinuxNl\n\n\n#check action", "\n#check action\ncheckAction(action)\n\n#check topology\ncheckTopology(topology)\n\n#check routing protocol\ncheckRouting(routing)\n", "checkRouting(routing)\n\n#get ippool\nipPool, cidrMask = getIppoolAndCidrMask(ippoolCidr)\n\n#validate ippool\ncheckIp(ipPool)\n\n#check if ipv4\ncheckIpType(ipPool, \"ipv4\")", "#check if ipv4\ncheckIpType(ipPool, \"ipv4\")\n\n#validate cidrMask\ncheckPosInteger(cidrMask)\n\n#extract subnet\nsubnet =  getSubnet(ipPool, \".\")\n\n#get ipv6pool", "\n#get ipv6pool\nipV6Pool, cidrV6Mask = getIppoolAndCidrMask(ipv6poolCidr)\n\n#validate ipv6pool\ncheckIp(ipV6Pool)\n\n#validate ipv6\ncheckIpType(ipV6Pool, \"ipv6\")\n", "checkIpType(ipV6Pool, \"ipv6\")\n\n#validate cidrMask\ncheckPosInteger(cidrV6Mask)\n\n#extract subnet\nsubnetV6 =  getSubnet(ipV6Pool, \":\")\n\n#validate host\ncheckIp(host)", "#validate host\ncheckIp(host)\n\n#validate verbose argument\ncheckVerboselog(verboselog)\n\n#validate noLinuxNl\ncheckNoLinuxNl(noLinuxNl)\n\nprint('Arguments passed:\\n')", "\nprint('Arguments passed:\\n')\nprint('_________________________\\n')\nprint(f'action - {action}\\ntopology - {topology}\\nrouting - {routing}\\nippool - {ippoolCidr}\\nipv6pool - {ipv6poolCidr}\\nusername - {username}\\npassword - {password}\\nhost - {host}\\nverbose - {verboselog}\\nnoLinuxNl - {noLinuxNl}')\nprint('_________________________\\n')\n\n#create inventory yaml file\ncreateInventoryFromTemplate(subnet, username, password, host, subnetV6, noLinuxNl)\n\n#run python script\nif action == \"build,tear\":\n    runSonic(\"build\", topology, routing, \"-\"+verboselog)\n    print(\"Now tearing down...\\n\")\n    runSonic(\"tear\", topology, routing, \"-\"+verboselog)\nelse:\n    runSonic(action, topology, routing, \"-\"+verboselog)", "\n#run python script\nif action == \"build,tear\":\n    runSonic(\"build\", topology, routing, \"-\"+verboselog)\n    print(\"Now tearing down...\\n\")\n    runSonic(\"tear\", topology, routing, \"-\"+verboselog)\nelse:\n    runSonic(action, topology, routing, \"-\"+verboselog)\n\nprint(\"OPERATION COMPLETE...\\n\")    ", "\nprint(\"OPERATION COMPLETE...\\n\")    \n\nsys.exit(0)\n"]}
