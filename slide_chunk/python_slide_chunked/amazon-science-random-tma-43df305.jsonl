{"filename": "src/__init__.py", "chunked_list": ["import json\nimport os\nfrom pathlib import Path\nimport sys\n\n# Get root path of the package, regardless of whether `dvc exp run --temp` is used or not.\npackageRoot = Path(os.getcwd().split(\"/.dvc\", maxsplit=1)[0]) / \"src\"\n\n# Load environs that is tracked by git\nif (packageRoot / \"dist_environ.json\").exists():\n    print(\"Loading distributed environs...\", file=sys.stderr)\n    with open(str(packageRoot / \"dist_environ.json\"), \"r\") as f:\n        environDict = json.load(f)\n    for key, val in environDict.items():\n        if key not in os.environ:\n            os.environ[key] = str(val)\n        else:\n            print(f\"Use existing environ {key}: {os.environ[key]}\")", "# Load environs that is tracked by git\nif (packageRoot / \"dist_environ.json\").exists():\n    print(\"Loading distributed environs...\", file=sys.stderr)\n    with open(str(packageRoot / \"dist_environ.json\"), \"r\") as f:\n        environDict = json.load(f)\n    for key, val in environDict.items():\n        if key not in os.environ:\n            os.environ[key] = str(val)\n        else:\n            print(f\"Use existing environ {key}: {os.environ[key]}\")", "\n# Load local environs that is not tracked by git\nif (packageRoot / \"__environ__.json\").exists():\n    print(\"Loading local environs...\", file=sys.stderr)\n    with open(str(packageRoot / \"__environ__.json\"), \"r\") as f:\n        environDict = json.load(f)\n    for key, val in environDict.items():\n        os.environ[key] = str(val)\n\n", "\n"]}
{"filename": "src/train_links.py", "chunked_list": ["import faulthandler\nimport gc\nimport os\nimport signal\nimport sys\nimport time\nimport traceback\nfrom pathlib import Path\nfrom typing import Final\n", "from typing import Final\n\nimport pandas\nimport torch\nimport torch.multiprocessing as mp\nimport tqdm\n\nfrom .distributed.AvgCluster import AvgCluster, AvgClusterServer\nfrom .dataloading.DataMgr import DataMgr\nfrom .pipelines.SessionMgr import EvalMetrics, EvalMetricsCalc, SessionMgr, write_stats", "from .dataloading.DataMgr import DataMgr\nfrom .pipelines.SessionMgr import EvalMetrics, EvalMetricsCalc, SessionMgr, write_stats\nfrom .distributed.MultiGPU import MultiGPUServer, MultiGPUTrainer\nfrom .pipelines.Initialization import parse_args\nfrom .pipelines.utils import get_peak_mem, vscode_debug\n\n\ndef prepare_trainer_data(create_formats=False):\n    '''\n    Prepare data for training on the trainer process.\n\n    Arguments\n    ---------\n    create_formats: bool\n        Whether to create all DGL data formats for the graph dataset.\n    \n    Returns\n    -------\n    datamgr: DataMgr or AvgCluster\n        Data manager or distributed manager that manages the training graph.\n    distmgr: None or AvgCluster\n        Distributed manager for the graph dataset, if model aggregation training is used.\n    '''\n    if args.distributed is not None:\n        args.dataset_str = None\n        dist_params = {\n            (key[5:] if key.startswith(\"eval_\") else key): (eval(value) if key.startswith(\"eval_\") else value)\n            for key, value in args.distributed_params.items()\n        }\n        distmgr = AvgCluster(args.world_size, args.dist_is_master, \n            args.dataset, dataset_kwargs=args.dataset_params, **dist_params)\n        distmgr.sync_train_data()\n        datamgr = distmgr\n        \n    else:\n        datamgr = DataMgr(args.dataset, args.to_undirected, args.use_self_loops, \n            **args.dataset_params)\n        datamgr.prepare_dataset()\n        distmgr = None\n        args.dataset_str = datamgr.dataset_str\n\n    if create_formats:\n        datamgr.create_formats_()\n\n    return datamgr, distmgr", "\ndef start_trainer(proc_id, args, datamgr, distmgr=None, device=None):\n    '''\n    Main function for the trainer process.\n    Also run validation and test in single GPU training\n    (i.e., if no distributed or MultiGPU training is used).\n\n    Arguments\n    ---------\n    proc_id: int\n        Process ID of for the trainer process in Multi-GPU training.\n    args: argparse.Namespace\n        Parsed arguments.\n    datamgr: DataMgr or AvgCluster\n        Data manager or distributed manager that manages the training graph.\n    distmgr: None or AvgCluster\n        Distributed manager for the graph dataset, if model aggregation training is used.\n    device: torch.device\n        Device to use for training.\n    '''\n    if device is None:\n        # check device\n        if args.use_gpu and torch.cuda.is_available():\n            if type(args.gpu) == list: # Multi-GPU training\n                dev_id = args.gpu[proc_id]\n                distmgr = MultiGPUTrainer(args, proc_id, dev_id)\n                device = distmgr.device\n                args.is_mgpu = True\n            else:\n                device = torch.device(\"cuda:{}\".format(args.gpu))\n                torch.cuda.set_device(args.gpu)\n                args.is_mgpu = False\n                args.mgpu_is_master = None\n        \n        else:\n            args.use_gpu = False\n            device = torch.device(\"cpu\")\n        print(f\"Using device: {device}\")\n\n    valid_edge = datamgr.valid_edge\n    test_edge = datamgr.test_edge\n    in_dim = datamgr.in_dim\n    \n    session = SessionMgr(args, datamgr, device, distmgr=distmgr)\n    session.create_train_data_loader(use_ddp=args.is_mgpu)\n    \n    if valid_edge is not None and session.enable_eval:\n        session.create_evaluator(\"valid\")\n        session.is_eval_point()\n    \n    if not args.is_mgpu:\n        model, optimizer = session.create_model()\n    else:\n        model, optimizer = session.create_model(\n            use_ddp=True, ddp_device=device)\n\n    # Load node features for MAG240M before timing begins\n    if datamgr.use_feat_loader:\n        _ = datamgr.node_features\n    \n    # create training epoch\n    stats_dict: Final[dict] = session.create_stats_dict()\n    session.reset_timer()\n\n    postfix_dict_epoch = {\n        \"Model\": f\"{args.model} ({model.num_model_params})\",\n        \"PID\": os.getpid(),\n        \"SIGNAC\": args.signac_job.id if args.signac_job else None,\n        **args.tqdm_msg\n    }\n    postfix_dict_step: Final[dict] = dict()\n    session.postfix_dict_step = postfix_dict_step\n    \n    # Training loop\n    session.epoch_progress = tqdm.tqdm(\n        range(1, args.n_epochs + 1), desc=\"Train Progress\",\n        postfix=postfix_dict_epoch, dynamic_ncols=True)\n    for epoch in session.epoch_progress:\n        step_progress = session.create_step_progress()\n        session.t_step = time.time() # Include time for data loader\n        for step, (_, pos_graph, neg_graph, blocks) in enumerate(session.dataloader, start=1):            \n            session.run_pre_train_hooks(epoch, step)\n            \n            # Training - forward pass\n            pos_logits, neg_logits, loss = session.train_step(pos_graph, neg_graph, blocks)\n            \n            # Step evaluation\n            train_loss = loss.item()\n            result_dict = {\n                EvalMetrics.EPOCH: epoch, \n                EvalMetrics.STEP: step, \n                EvalMetrics.LOSS: train_loss\n            }\n            result_dict.update(\n                EvalMetricsCalc.roc_auc_ap_score(pos_logits, neg_logits,\n                    metrics=[EvalMetrics.ROC_AUC]))\n            \n            # Training - backward pass\n            optimizer.zero_grad()\n            loss.backward()\n            ## Gradient clipping\n            if ((epoch + step / session.step_per_epoch) >= args.grad_clip_since \n                and args.grad_clip_norm > 0):\n                grad_norm = torch.nn.utils.clip_grad.clip_grad_norm_(\n                    model.parameters(), args.grad_clip_norm\n                )\n                result_dict[EvalMetrics.GRAD_NORM] = grad_norm.item()\n            optimizer.step()\n\n            # Metrics recording\n            if args.use_gpu:\n                result_dict[EvalMetrics.GPU_VRAM] = session.max_gpu_vram\n            postfix_dict_step.update(\n                EvalMetricsCalc.format_str({\n                    EvalMetrics.GPU_VRAM: result_dict[EvalMetrics.GPU_VRAM]\n                }, as_dict=True)\n            )\n            session.t_train += time.time() - session.t_step\n            result_dict[EvalMetrics.TRAINING_TIME] = session.t_train\n            result_dict[EvalMetrics.TOTAL_TIME] = time.time() - session.t_start\n            result_str = EvalMetricsCalc.format_str(result_dict, rank=session.rank)\n\n            step_progress.write(\" | \".join(result_str).strip())\n            result_dict[EvalMetrics.ITER] = session.iter_count\n            result_dict[EvalMetrics.RAM] = get_peak_mem()\n            result_dict = {key.value: value for key, value in result_dict.items()}\n            stats_dict[\"train_stats\"].append(\n                pandas.Series(result_dict))\n\n            step_progress.set_postfix(postfix_dict_step)\n            if session.unit_step_progress:\n                step_progress.update(1)\n            else:\n                step_progress.update(pos_graph.num_edges())\n            stats_dict[\"metrics\"][\"train_stats\"] = result_dict\n            \n            # Memory cleanup\n            model.cleanup_step()\n            del pos_graph, neg_graph, blocks, pos_logits, neg_logits, loss\n            gc.collect()\n\n            # Evaluation\n            if (valid_edge is not None) and session.is_eval_point():\n                model_at_best = session.run_evaluation(\"valid\")\n                if model_at_best:\n                    session.save_checkpoints(\"best\")\n                session.save_checkpoints(\"latest\")\n            else:\n                if step % args.save_every == 0:\n                    write_stats(args, stats_dict, train_stats=True, metrics=True)\n                if (args.use_gpu and args.clear_cache_every > 0 \n                    and step % args.clear_cache_every == 0):\n                    torch.cuda.empty_cache()\n            \n            session.run_post_step_hooks()\n            session.t_step = time.time()\n            if session.is_stopping:\n                session.write(\"[Training] Stopping training...\")\n                break\n        \n        session.close_step_progress()\n        if session.is_stopping:\n            break\n    \n    write_stats(args, stats_dict, train_stats=True, valid_stats=True, metrics=True)\n    session.signac_mark_success()\n    \n    if distmgr is not None:\n        distmgr.wait_cluster(session)\n\n    # Test on test set\n    if test_edge is not None and session.enable_eval:\n        session.clean_memory()\n        session.run_evaluation(\"test\")\n        session.clean_memory()\n        session.run_evaluation(\"best\")\n\n    # Keep this at the last of the code\n    if args.use_signac and distmgr is None:\n        args.result_path = args.result_path_final\n        write_stats(args, stats_dict, train_stats=True, valid_stats=True, metrics=True)", "    \n\ndef start_server():\n    '''\n    Start the server for distributed training.\n    '''\n    # check device\n    if args.use_gpu and torch.cuda.is_available():\n        device = torch.device(\"cuda:{}\".format(args.gpu))\n        torch.cuda.set_device(args.gpu)\n    else:\n        args.use_gpu = False\n        device = torch.device(\"cpu\")\n    print(f\"Using device: {device}\")\n\n    datamgr = DataMgr(args.dataset, args.to_undirected, args.use_self_loops, **args.dataset_params)\n    datamgr.prepare_dataset()\n    args.dataset_str = datamgr.dataset_str\n\n    dist_params = {\n        (key[5:] if key.startswith(\"eval_\") else key): (eval(value) if key.startswith(\"eval_\") else value)\n        for key, value in args.distributed_params.items()\n    }\n    distmgr = AvgClusterServer(args.world_size, args.dist_is_master, datamgr, **dist_params)\n    distmgr.sync_train_data()\n\n    session = SessionMgr(args, datamgr, device, distmgr=distmgr)\n    if datamgr.valid_edge is not None:\n        session.create_evaluator(\"valid\")\n    \n    session.create_model()\n    # create training epoch\n    stats_dict: Final[dict] = session.create_stats_dict()\n\n    distmgr.server_main(session)", "\n\ndef multigpu_start(proc_id, args, datamgr, distmgr=None):\n    '''\n    Start processes for Multi-GPU DDP training.\n    When `proc_id` is 0, it will start the server process;\n    otherwise, it will start the trainer process.\n    \n    Arguments\n    ---------\n    proc_id: int\n        Process ID in Multi-GPU DDP training.\n    args: argparse.Namespace\n        Parsed arguments.\n    datamgr: DataMgr\n        Data manager.\n    distmgr: MultiGPUTrainer\n        MultiGPUTrainer for the trainer processes.\n    '''\n    if proc_id == 0:\n        faulthandler.enable()\n        # vscode_debug()\n    torch.cuda.manual_seed_all(args.random_seed)\n    datamgr.multigpu_postprocess()\n    if proc_id == 0:\n        dev_id = args.gpu[proc_id]\n        distmgr = MultiGPUServer(args, dev_id)\n        session = SessionMgr(args, datamgr, distmgr.device, distmgr=distmgr)\n        if datamgr.valid_edge is not None:\n            session.create_evaluator(\"valid\")\n\n        session.create_model(create_optimizer=False)\n        session.create_stats_dict()\n        \n        distmgr.server_main(session)\n    \n    else:\n        start_trainer(proc_id, args, datamgr, distmgr)", "\n\nif __name__ == '__main__':\n    faulthandler.enable()\n    \n    # Parse arguments\n    args = parse_args()\n    if args.debug:\n        # Disable workers for dataloader in debug mode\n        args.num_workers = 0\n    \n    if (args.distributed is None) or not args.dist_is_master:\n        if type(args.gpu) is list:\n            # Start Multi-GPU DDP training\n            print(\"[Session] Preparing training data...\")\n            datamgr, distmgr = prepare_trainer_data(create_formats=False)\n            shared_graph = datamgr.multigpu_preprocess()\n            print(\"[Session] Starting MultiGPU processes...\")\n            mp.start_processes(multigpu_start, args=(args, datamgr, distmgr), \n                nprocs=len(args.gpu), start_method=\"forkserver\")\n        else:\n            # Start single-GPU training and evaluation\n            torch.cuda.manual_seed_all(args.random_seed)\n            print(\"[Session] Starting trainer...\")\n            datamgr, distmgr = prepare_trainer_data()\n            start_trainer(None, args, datamgr, distmgr)\n    else:\n        # Start server side for distributed training\n        torch.cuda.manual_seed_all(args.random_seed)\n        print(\"[Session] Starting distributed server...\")\n        start_server()", ""]}
{"filename": "src/distributed/AvgCluster.py", "chunked_list": ["'''\nImplementation of distributed training with Time-based Model Aggregation (TMA)\nand randomized partitioning of the graph (SuperTMA / RandomTMA).\n\nSee paper \"Simplifying Distributed Neural Network Training on Massive Graphs: \nRandomized Partitions Improve Model Aggregation\" for details.\n'''\nimport gc\nimport os\nimport pickle", "import os\nimport pickle\nimport time\nfrom collections import deque\nfrom datetime import timedelta\nfrom enum import IntEnum\nfrom functools import partial\nfrom pathlib import Path\nfrom typing import Final, List, Union\n", "from typing import Final, List, Union\n\nimport dgl\nimport numpy as np\nimport scipy.sparse as sp\nimport torch\nimport torch.distributed as dist\nimport tqdm\n\nfrom ..dataloading.DataMgr import DataMgr, MAG240MDatasetRAM", "\nfrom ..dataloading.DataMgr import DataMgr, MAG240MDatasetRAM\nfrom ..pipelines.utils import dist_isend_obj, dist_recv_obj, parse_timedelta\nfrom ..samplers import ClusterGCN\nfrom ..samplers.ClusterGCN import ClusterGCNClusterSampler\n\n\nclass DistStatus(IntEnum):\n    '''\n    Status of the distributed training process.\n    '''\n    INITIALIZED = 0\n    RUNNING = 1\n    COMPLETED = 2\n    CLOSE_OK = 3\n    CLOSED = 4", "\n\nclass AvgOperator:\n    @classmethod\n    def initialize(cls, cluster, session):\n        '''\n        Initialize model parameters on trainers by broadcasting \n        the initialized parameters from server process (rank 0).\n        '''\n        avg_progress = tqdm.tqdm(\n            session.model.parameters(),\n            desc=\"Model Averaging:\",\n            postfix=dict(rank=cluster.rank, status=cluster.status,\n                         op=\"initialize\"),\n            dynamic_ncols=True\n        )\n        weights : torch.nn.parameter.Parameter\n        for weights in avg_progress:\n            dist.broadcast(weights.data, src=0)\n\n\n    @classmethod\n    def average(cls, cluster, session):\n        '''\n        Sync model parameters on trainers by averaging their parameters\n        and replace the parameters on the server process (rank 0).\n        '''\n        avg_progress = tqdm.tqdm(\n            session.model.parameters(),\n            desc=\"Model Averaging:\",\n            postfix=dict(rank=cluster.rank, status=cluster.status,\n                         op=\"average\"),\n            dynamic_ncols=True\n        )\n        weights : torch.nn.parameter.Parameter\n        for weights in avg_progress:\n            if cluster.is_master:\n                # Set weights from rank 0 to be zeros\n                weights.data.zero_()\n            dist.all_reduce(weights.data, dist.ReduceOp.SUM)\n            weights.data /= float(cluster.num_workers)\n\n    @classmethod\n    def soft_medoid(cls, cluster, session, metrics=\"-Loss\", \n                    medoid_T : int=1):\n        perf_dict_list = cluster.gather_object(cluster.perf_dict)\n        if cluster.is_master:\n            perf_list = np.array([\n                perf_dict_list[i][metrics[1:]]\n                for i in range(1, cluster.world_size)])\n            \n            diff = np.abs(perf_list - perf_list[:, None])\n            coeff = np.exp(-diff.sum(0) / medoid_T)\n            coeff /= coeff.sum()\n            coeff = torch.tensor(coeff, dtype=torch.float32)\n        else:\n            coeff = torch.zeros(cluster.num_workers, dtype=torch.float32)\n        dist.broadcast(coeff, src=0)\n        avg_progress = tqdm.tqdm(\n            session.model.parameters(),\n            desc=\"Model Averaging:\",\n            postfix=dict(rank=cluster.rank, status=cluster.status, \n                         op=\"soft_medoid\", coeff=coeff),\n            dynamic_ncols=True\n        )\n        weights : torch.nn.parameter.Parameter\n        for weights in avg_progress:\n            if cluster.is_master:\n                # Set weights from rank 0 to be zeros\n                weights.data.zero_()\n            else:\n                weights.data = weights.data * coeff[cluster.rank - 1]\n            dist.all_reduce(weights.data, dist.ReduceOp.SUM)\n        \n    @classmethod\n    def find_best_perf_id(cls, cluster, session, metrics=\"-Loss\"):\n        perf_dict_list = cluster.gather_object(cluster.perf_dict)\n        if cluster.is_master:\n            perf_list = np.array([\n                perf_dict_list[i][metrics[1:]]\n                for i in range(1, cluster.world_size)])\n            if metrics[0].startswith(\"-\"):\n                perf_list = - perf_list\n            best_perf_id = perf_list.argmax() + 1\n            best_perf_id = torch.tensor([best_perf_id], dtype=torch.int32)\n        else:\n            best_perf_id = torch.zeros([1], dtype=torch.int32)\n\n        dist.broadcast(best_perf_id, src=0)\n        return best_perf_id.item()\n    \n    @classmethod\n    def select_best_perf(cls, cluster, session, metrics=\"-Loss\"):\n        best_perf_id = cls.find_best_perf_id(cluster, session, metrics)\n\n        avg_progress = tqdm.tqdm(\n            session.model.parameters(),\n            desc=\"Model Averaging:\",\n            postfix=dict(rank=cluster.rank, status=cluster.status,\n                         op=\"select_best_perf\", best_id=best_perf_id),\n            dynamic_ncols=True\n        )\n        weights : torch.nn.parameter.Parameter\n        for weights in avg_progress:\n            dist.broadcast(weights.data, src=best_perf_id)\n\n    @classmethod\n    def llcg(cls, cluster, session, corr_steps=2):\n        '''\n        Implementation of the global server correction step of LLCG.\n        See paper: Learn Locally, Correct Globally: A Scalable Framework for Training Graph Neural Networks\n        https://openreview.net/pdf?id=FndDxSz3LxQ\n        '''\n        cls.average(cluster, session)\n\n        # Server correction\n        if cluster.is_master:\n            with torch.enable_grad():\n                for step in tqdm.tqdm(range(corr_steps), desc=\"Server correction\"):\n                    try:\n                        _, pos_graph, neg_graph, blocks = next(session.dataloader_iter)\n                    except StopIteration:\n                        session.dataloader_iter = iter(session.dataloader)\n                        _, pos_graph, neg_graph, blocks = next(session.dataloader_iter)\n                    _, _, loss = session.train_step(pos_graph, neg_graph, blocks)\n                    session.optimizer.zero_grad()\n                    loss.backward()\n                    session.optimizer.step()\n                    \n            del _, pos_graph, neg_graph, blocks, loss\n            gc.collect()\n            torch.cuda.empty_cache()\n        \n        weights : torch.nn.parameter.Parameter\n        avg_progress = tqdm.tqdm(\n            session.model.parameters(),\n            desc=\"Model Averaging:\",\n            postfix=dict(rank=cluster.rank, status=cluster.status,\n                         op=\"llcg\"),\n            dynamic_ncols=True\n        )\n        for weights in avg_progress:\n            dist.broadcast(weights.data, src=0)", "\n\nclass AvgCluster:\n    '''\n    Distributed manager on trainer side for TMA training.\n    This class also acts as a DataMgr on trainer side, since the training data\n    is distributed by the server, and there is no separate DataMgr on trainer side. \n    '''\n    def __init__(self, world_size: int, is_master: bool,\n                 dataset_name: str, dataset_kwargs=None,\n                 avg_operator=\"average\", **kwargs) -> None:\n        '''\n        Arguments:\n        ----------\n        world_size: int\n            Number of processes (server + trainer) in the cluster.\n        is_master: bool\n            Whether this process is the server process.\n        dataset_name: str\n            Name of the dataset to be used.\n        dataset_kwargs: dict\n            Keyword arguments for the dataset.\n        avg_operator: str\n            Name of the averaging operator to be used.\n            Must be a name of a method defined in `AvgOperator.{avg_operator}`.\n        kwargs: dict\n            Additional keyword arguments for the averaging operator.\n            See `AvgOperator.{avg_operator}` to check the required arguments.\n        '''\n        self.is_master = is_master\n        self.world_size = world_size\n        self.rank = dist.get_rank()\n        print(\"[Dist] Establishing distributed store...\")\n        self.dist_store = dist.TCPStore(\n            os.environ[\"MASTER_ADDR\"],\n            int(os.environ[\"TCPSTORE_PORT\"]),\n            world_size=world_size,\n            is_master=is_master,\n            timeout=timedelta(minutes=30)\n        )\n        \n        print(\"[Dist] Distributed store established.\")\n        self.dist_store.set_timeout(timedelta(seconds=10))\n        self.status = DistStatus.INITIALIZED\n        self.running = False\n        self.dataset_name = dataset_name\n        if dataset_kwargs is None:\n            self.dataset_kwargs = dict()\n        else:\n            self.dataset_kwargs = dataset_kwargs\n        self.pgs_dict = dict()\n        self.perf_dict = dict()\n        self.enable_eval = False\n        # self.dist_store_rank = dist.PrefixStore(f\"{self.rank}_\", self.dist_store)\n\n        self.avg_operator = getattr(AvgOperator, avg_operator)\n        # Parse additional arguments for some aggregation operators\n        if self.avg_operator in [\n            AvgOperator.select_best_perf, AvgOperator.soft_medoid]:\n            if \"metrics\" in kwargs:\n                self.avg_operator = partial(\n                    self.avg_operator, metrics=kwargs[\"metrics\"])\n        \n        if self.avg_operator in [AvgOperator.soft_medoid]:\n            if \"medoid_T\" in kwargs:\n                self.avg_operator = partial(\n                    self.avg_operator, medoid_T=kwargs[\"medoid_T\"])\n        \n        if self.avg_operator in [AvgOperator.llcg]:\n            if \"corr_steps\" in kwargs:\n                self.avg_operator = partial(\n                    self.avg_operator, corr_steps=kwargs[\"corr_steps\"]\n                )\n\n        self.train_frac = self.dataset_kwargs.get(\"train_frac\", 1.0)\n        self.random_seed = self.dataset_kwargs.get(\"rnd_seed\", None)\n\n    @property\n    def status(self):\n        '''\n        Get the status of this process.\n        '''\n        return DistStatus(int(self.dist_store.get(f\"{self.rank}-status\")))\n\n    @status.setter\n    def status(self, status: DistStatus):\n        '''\n        Set the status of this process.\n        '''\n        self.dist_store.set(f\"{self.rank}-status\", str(status.value))\n\n    def gather_object(self, obj):\n        '''\n        Gather an object from all processes in the cluster.\n\n        Arguments:\n        ----------\n        obj: object\n            The object to be gathered.\n        \n        Returns:\n        --------\n        obj_list: list\n            A list of objects gathered from all processes in the cluster.\n        '''\n\n        if self.is_master:\n            obj = None\n            obj_list = [None] * self.world_size\n        else:\n            obj_list = None\n        dist.gather_object(obj, obj_list)\n        return obj_list\n\n    @property\n    def is_averaging(self) -> bool:\n        '''\n        Indicate if this process should now enter model averaging.\n        '''\n        return bool(int(self.dist_store.get(\"is_averaging\")))\n\n    @is_averaging.setter\n    def is_averaging(self, value: bool):\n        '''\n        Set the flag indicating if this process should now enter model averaging.\n        '''\n        self.dist_store.set(\"is_averaging\", str(int(value)))\n\n    def model_averaging(self, session):\n        '''\n        Conduct model averaging.\n        '''\n        with torch.no_grad():\n            session.save_checkpoints(\"local\")\n            session.write(\n                f\"[Model Averaging] Entering model averaging as rank {self.rank}...\")\n\n            if self.status < DistStatus.RUNNING:\n                # Initialization phase: push server model weights to trainers\n                AvgOperator.initialize(self, session)\n\n                # Sync signac IDs\n                if session.args.use_signac:\n                    dist_signac_ids = [None] * self.world_size\n                    dist.all_gather_object(dist_signac_ids, session.args.signac_job.id)\n                    session.signac_job.doc.dist_signac_ids = dist_signac_ids\n\n                # Sync preprocessing time\n                if self.is_master:\n                    t_preprocess = [session.t_preprocess]\n                else:\n                    t_preprocess = [None]\n                dist.broadcast_object_list(t_preprocess)\n                session.reset_timer()\n                session.t_preprocess += t_preprocess[0]\n                # if not self.is_master:\n                #     session.add_timer(t_preprocess[0])\n            else: # Running phase\n                # Aggregate model weights through selected model operator\n                self.avg_operator(self, session)\n\n                # Update progress from each worker\n                pgs_dict_list = self.gather_object(self.pgs_dict)\n                if self.is_master:\n                    for worker_id in range(1, self.world_size):\n                        self.update_worker_progress(\n                            session, worker_id, pgs_dict_list[worker_id])\n            session.save_checkpoints(\"latest\")\n\n    def sync_train_data(self):\n        '''\n        Get the training data partition from the server process,\n        and side-load feature if necessary.\n        '''\n        sg, node_ids, partition_offset, clusters, train_adj_sg_obj, metaDict = dist_recv_obj(0)\n\n        self.train_graph = sg\n        self.train_edge_idx = sg.edges(\"eid\")\n\n        self.node_ids = node_ids # Node ID in the *original* graph\n        self.partition_offset = partition_offset\n        self.clusters = clusters\n        self.cluster_mapping_dict = {\n            cid: i for i, cid in enumerate(clusters)\n        }\n\n        if len(train_adj_sg_obj) == 4:\n            self.train_adj_sg = sp.csr_matrix(\n                train_adj_sg_obj[:3], shape=train_adj_sg_obj[-1]\n            )\n        else:\n            self.train_adj_sg = sp.csr_matrix(\n                (np.ones_like(train_adj_sg_obj[0]), *train_adj_sg_obj[:2]), \n                shape=train_adj_sg_obj[-1]\n            )\n\n        # Check if the new node ID are assigned following the order of the clusters\n        assert (self.train_graph.ndata[dgl.NID] == self.node_ids).all()\n        # New node ID should be torch.arange(self.train_graph.num_nodes())\n\n        if self.partition_offset is not None:\n            self.cluster_sampler = ClusterGCN.ClusterGCNEdgeSampler.create_from_mem(\n                self.partition_offset, torch.arange(self.train_graph.num_nodes())\n            )\n\n        self.n_relations = metaDict[\"n_relations\"]\n        self.n_nodetypes = metaDict[\"n_nodetypes\"]\n        self.valid_edge = None\n        self.test_edge = None\n        \n        # Side-loading additional feature information that is not sent by the server\n        # for some large datasets (e.g. mag240m)\n        if \"feat\" in self.train_graph.ndata:\n            print('Using features in train_graph.ndata[\"feat\"]')\n            self.use_feat_loader = False\n            self.in_dim = self.train_graph.ndata[\"feat\"].shape[-1]\n            self.feat_dtype = self.train_graph.ndata[\"feat\"].dtype\n        elif self.dataset_name == \"mag240m\":\n            print('Using feature loader')\n            self.dataset = MAG240MDatasetRAM(\n                tmpfs_dir=self.dataset_kwargs.get(\"tmpfs_dir\", None))\n            self.use_feat_loader = True\n            self.node_features = self.dataset.paper_feat\n            self.in_dim = self.dataset.paper_feat.shape[-1]\n            if self.dataset.paper_feat.dtype == np.float16:\n                self.feat_dtype = torch.float16\n            else:\n                self.feat_dtype = torch.float32\n        else:\n            raise ValueError(\"Feature or feature loader is missing for trainer!\")\n\n    def feature_loader(self, first_block, device=None):\n        '''\n        Implement a feature loader as in `dataloading.DataMgr`.\n        '''\n        if device is None:\n            device = first_block.device\n        if self.dataset_name in ['mag240m']:\n            sg_nids = first_block.srcdata[dgl.NID].cpu()\n            nids = self.train_graph.ndata[dgl.NID][sg_nids]\n            feat = self.node_features[nids]\n            return torch.as_tensor(feat, device=device)\n        else:\n            return None\n\n    @property\n    def num_workers(self) -> int:\n        '''\n        Return the number of trainers (excluding server) in the distributed cluster.\n        '''\n        return self.world_size - 1\n\n    def run_pre_train_hooks(self, session):\n        '''\n        Run hooks before each training step to register current training progress.\n        '''\n        for name in [\"epoch\", \"step\", \"iter_count\", \"step_per_epoch\"]:\n            value = getattr(session, name)\n            self.pgs_dict[name] = int(value)\n            self.dist_store.set(f\"{self.rank}-{name}\", str(int(value)))\n\n        if not self.running: \n            # Initialize model parameters if training has not started\n            if session.args.use_signac:\n                self.dist_store.set(\n                    f\"{self.rank}-signac_id\", str(session.args.signac_job.id))\n            self.model_averaging(session)\n            self.status = DistStatus.RUNNING\n            self.running = True\n        else:\n            for name in [\"Loss\", \"AUC\"]:\n                self.perf_dict[name] = session.metrics[\"train_stats\"][name]\n\n            server_status = DistStatus(int(self.dist_store.get(f\"0-status\")))\n            if server_status == DistStatus.CLOSE_OK:\n                session.is_stopping = True\n\n    def run_post_step_hooks(self, session):\n        '''\n        Run hooks after each training step to enter model aggregation if needed.\n        '''\n        if self.is_averaging:\n            self.model_averaging(session)\n\n    def wait_cluster(self, session):\n        '''\n        Wait for other processes in the cluster to finish training.\n        '''\n        self.status = DistStatus.COMPLETED\n\n        while self.status != DistStatus.CLOSE_OK:\n            if self.is_averaging:\n                self.model_averaging(session)\n            time.sleep(0.1)\n\n        self.status = DistStatus.CLOSED", "\nclass AvgClusterServer(AvgCluster):\n    '''\n    Distributed manager on server side for TMA training.\n    '''\n    def __init__(self, world_size: int, is_master: bool,\n                 datamgr: DataMgr, num_parts: int, cache_path,\n                 sync_every: str, group_strategy=\"uniform-cluster\",\n                 avg_operator=\"average\", balance_ntypes=None, balance_edges=False,\n                 mode='k-way', drop_parts: List[int] = None, **kwargs) -> None:\n        '''\n        Initialize server side for TMA training and generate super-nodes (mini-clusters).\n\n        Arguments\n        ---------\n        world_size: int\n            Number of processes (server + trainer) in the cluster.\n        is_master: bool\n            Whether this process is the server process.\n        datamgr: DataMgr\n            Data manager for dataset. \n        num_parts: int\n            Number of supernodes (mini-clusters) to generate by METIS. \n            This has no effect if `group_strategy` is \"random-cluster\".\n        cache_path: str\n            Path to store the generated supernodes.\n        sync_every: str, format x minutes as \"{x}min\" or x hours \"{x}h\".\n            The frequency to aggregate model parameters.\n        group_strategy: str, choices=[\"uniform-cluster\", \"random-cluster\"]\n            The scheme to generate graph partition for each trainer.\n            - If \"uniform-cluster\", super-nodes (mini-clusters) will be first generated by METIS, and\n              then each trainer will be assigned a random subset of super-nodes (SuperTMA).\n              * When `num_parts` equal to the number of trainers, this is equivalent to PSGD-PA partition scheme.\n            - If \"random-cluster\", each trainer will be assigned a random subset of nodes (RandomTMA).\n        avg_operator: str\n            Name of the averaging operator to be used.\n            Must be a name of a method defined in `AvgOperator.{avg_operator}`.\n        drop_parts: List[int]\n            List of partition ID (not super-node ID) that will be dropped and not assigned to any trainer.\n            Used to mimic the case where some trainers are down.\n        kwargs: dict\n            Additional keyword arguments for the averaging operator.\n            See `AvgOperator.{avg_operator}` to check the required arguments.\n\n        For usages of `balance_ntypes`, `balance_edges` and `mode`, see \n        `samplers.ClusterGCN.ClusterGCNClusterSampler`.\n        '''\n        super().__init__(world_size, is_master,\n            datamgr.dataset_name,\n            dataset_kwargs=datamgr.dataset_kwargs,\n            avg_operator=avg_operator,\n            **kwargs\n        )\n        if avg_operator == \"llcg\": # not self.avg_operator here since it is a function\n            self.need_train_dataloader = True\n        else:\n            self.need_train_dataloader = False\n        self.datamgr = datamgr\n        self.train_graph = self.datamgr.train_graph\n        self.num_parts = num_parts\n        self.group_strategy = group_strategy.split(\":\")[0]\n        if len(group_strategy.split(\":\")) > 1:\n            self.group_random_seed = int(group_strategy.split(\":\", maxsplit=1)[-1])\n        else:\n            self.group_random_seed = None\n        self.sampler = ClusterGCNClusterSampler(\n            self.datamgr.train_graph,\n            self.num_parts, cache_path,\n            balance_ntypes=balance_ntypes,\n            balance_edges=balance_edges,\n            mode=mode,\n            random_seed=self.group_random_seed\n        )\n        if type(sync_every) is str:\n            self.sync_every = parse_timedelta(sync_every)\n        else:\n            self.sync_every = sync_every\n\n        self.is_averaging = False\n        self.is_saved_partitions = False\n        self.eval_thread = None\n        self.eval_model = None\n        self.enable_eval = True\n        self.drop_parts = (set(drop_parts) if drop_parts else [])\n\n    @property\n    def full_world_size(self):\n        return self.world_size + len(self.drop_parts)\n\n    @property\n    def partition_str(self):\n        '''\n        Get a string representation of the current partitioning strategy.\n        '''\n        part_str = f\"{self.full_world_size - 1}-{self.group_strategy}\"\n        if self.group_random_seed is not None:\n            part_str += f\":{self.group_random_seed}\"\n        return part_str\n\n    @property\n    def saved_partitions(self) -> List:\n        '''\n        Get the list of saved graph partition strings that indicate the partitions\n        that can be reused.\n        '''\n        if self.sampler.signac_job is None:\n            return []\n        else:\n            return self.sampler.signac_job.doc.get(\"saved_partitions\", [])\n\n    @saved_partitions.setter\n    def saved_partitions(self, value):\n        self.sampler.signac_job.doc.saved_partitions = value\n\n    def partition_iter(self):\n        '''\n        Get an iterator of graph partitions.\n        If partitions matching the current partition strategy have been saved,\n        then load them from disk to save time. Otherwise, generate new partitions.\n\n        Yield\n        -----\n        sg: DGLGraph\n            A partition of the training graph to be sent to a trainer.\n        node_ids: Tensor\n            Node IDs of the partition.\n        cluster_offset: Tensor\n            Indicate the start indices of each super-node (mini-cluster) in the `node_ids` tensor.\n        clusters_ids: Tensor\n            IDs of the super-nodes (mini-clusters) contained in the partition. When interpreted together with\n            `cluster_offset`, this can be used to map a node ID to its corresponding super-node ID.\n        '''\n        if self.partition_str in self.saved_partitions:\n            print(\"[Dist] Using saved partitions\")\n            self.is_saved_partitions = True\n            with self.sampler.signac_job:\n                for ind in range(1, self.full_world_size):\n                    if ind not in self.drop_parts:\n                        with open(f\"saved_partitions/{self.partition_str}-{ind}.pkl\", \"rb\") as f:\n                            yield pickle.load(f)\n        \n        elif self.group_strategy == \"uniform-cluster\":\n            self.is_saved_partitions = False\n            group_list = self.sampler.group_clusters(self.full_world_size - 1, self.group_strategy)\n            for ind, clusters in enumerate(group_list, start=1):\n                if ind not in self.drop_parts:\n                    yield *self.sampler.sample(self.train_graph, clusters), clusters\n        \n        elif self.group_strategy == \"random-nodes\":\n            self.is_saved_partitions = False\n            node_idx = self.train_graph.nodes()\n            if self.group_random_seed is not None:\n                rnd_state = torch.get_rng_state()\n            rand_exps = torch.rand(len(node_idx), dtype=torch.float16)\n            if self.group_random_seed is not None:\n                torch.set_rng_state(rnd_state)\n            step = 1.0 / (self.full_world_size - 1)\n            for i in range(self.full_world_size - 1):\n                if (i + 1) not in self.drop_parts:\n                    if i != self.full_world_size - 2:\n                        s_idx = node_idx[(rand_exps >= i * step) & (rand_exps < (i + 1) * step)]\n                    else:\n                        s_idx = node_idx[(rand_exps >= i * step)]\n                    sg = self.sampler.get_subgraph(self.train_graph, s_idx)\n                    yield sg, s_idx, [], []\n        \n        else:\n            raise ValueError(f\"Unknown group strategy {self.group_strategy}\")\n\n    def sync_train_data(self):\n        '''\n        Partition and distribute training data to trainers.\n        '''\n        print(\"[Dist] Syncing training data...\")\n        print(\"Full graph:\", self.train_graph)\n        part_iter = self.partition_iter()\n        req_queue = deque()\n        for t_rank, (sg, node_ids, cluster_offset, clusters_ids) in enumerate(part_iter, start=1):\n            print(f\"Sending subgraph with {len(clusters_ids)} clusters to worker {t_rank}:\")\n            print(sg)\n\n            # Construct sparse matrix with src nodes as nodes in the subgraph and target nodes as \n            # nodes in the full graph in their original node IDs. \n            train_adj = self.train_graph.adj(scipy_fmt=\"csr\")\n            train_adj_sg : sp.csr_matrix = train_adj[node_ids, :]\n            if (train_adj_sg.data == 1).all():\n                train_adj_sg_obj = (\n                    train_adj_sg.indices, train_adj_sg.indptr, train_adj_sg.shape)\n            else:\n                train_adj_sg_obj = (\n                    train_adj_sg.data, train_adj_sg.indices, train_adj_sg.indptr, train_adj_sg.shape)\n            \n            metaDict = dict(\n                n_relations = getattr(self.datamgr, \"n_relations\", 1),\n                n_nodetypes = getattr(self.datamgr, \"n_nodetypes\", 1)\n            )\n            \n            size_req, byte_req = dist_isend_obj(\n                (sg, node_ids, cluster_offset, clusters_ids, train_adj_sg_obj, metaDict), t_rank)\n            req_queue.append((size_req, byte_req))\n\n            if (self.num_parts > 1 and (self.sampler.signac_job is not None) \n                and not self.is_saved_partitions and (len(self.drop_parts) == 0)):\n                with self.sampler.signac_job:\n                    Path(\"saved_partitions\").mkdir(parents=True, exist_ok=True)\n                with self.sampler.signac_job:\n                    with open(f\"saved_partitions/{self.partition_str}-{t_rank}.pkl\", \"wb\") as f:\n                        pickle.dump((sg, node_ids, cluster_offset, clusters_ids), f)\n\n            del sg, node_ids, cluster_offset, clusters_ids\n            gc.collect()\n\n        if (self.num_parts > 1 and (self.sampler.signac_job is not None) \n            and not self.is_saved_partitions and (len(self.drop_parts) == 0)):\n            print(f\"[Dist] Partitions saved to {self.sampler.signac_job.ws}/saved_partitions\")\n            self.saved_partitions = list(self.saved_partitions) + [self.partition_str]\n\n        while len(req_queue) > 0:\n            job = req_queue.popleft()\n            for req in job:\n                req.wait()\n\n    def get_worker_status(self, worker_id: int) -> int:\n        return int(self.dist_store.get(f\"{worker_id}-status\"))\n\n    def model_averaging(self, session, run_eval=True):\n        '''\n        Server side function to perform model averaging.\n\n        Arguments\n        ---------\n        session : SessionMgr\n            Session manager object.\n        run_eval : bool\n            Whether to run evaluation on validation set on aggregated model after model averaging.\n        '''\n        self.is_averaging = True\n        super().model_averaging(session)\n        self.is_averaging = False\n        self.t_averaging = time.time()\n\n        # Run evaluation\n        if run_eval:\n            if self.eval_model is None:\n                self.eval_model = session.create_model(\n                    create_optimizer=False, inplace=False)\n            elif session.model_at_best:\n                # Check if previous evaluation yields best performance\n                session.save_checkpoints(\"best\", model=self.eval_model)\n\n            if type(self.sync_every) is timedelta:\n                # Update current epoch count\n                self.next_sync_point = self.min_epoch_count\n\n            self.eval_model.load_state_dict(session.model.state_dict())\n            session.run_evaluation(\n                \"valid\",\n                alt_epoch=self.next_sync_point,\n                model=self.eval_model,\n                callback=lambda: self.poll_workers(session, run_eval=False)\n            )\n    \n    @property\n    def min_epoch_count(self):\n        '''\n        Calculate the minimum epoch count among all trainers (i.e., progress of the slowest trainer) \n        based on information in `self.worker_dict`.\n        '''\n        epoch_count_list = [\n            self.worker_dict[worker_id][\"epoch\"] - 1\n            + self.worker_dict[worker_id][\"step\"]\n            / self.worker_dict[worker_id][\"step_per_epoch\"]\n            for worker_id in range(1, self.world_size)]\n        min_epoch_count = min(epoch_count_list)\n        return min_epoch_count\n\n    def poll_workers(self, session, run_eval=True):\n        '''\n        Poll progress of workers and trigger model averaging if necessary.\n\n        Arguments:\n        ----------\n        session : SessionMgr\n            Session manager object.\n        run_eval : bool\n            Whether to run evaluation on validation set on aggregated model after model averaging.\n        '''\n        worker_queue : Final[deque] = self.worker_queue\n        worker_dict : Final[dict] = self.worker_dict\n\n        while len(worker_queue) > 1:\n            worker_id = worker_queue.popleft()\n            if worker_id is None: # broadcast operations\n                min_epoch_count = self.min_epoch_count\n\n                if self.update_sync_point:\n                    # Calculate next sync point\n                    factor = min_epoch_count // self.sync_every\n                    base_next_sync_point = self.next_sync_point + self.sync_every\n                    if factor >= base_next_sync_point // self.sync_every:\n                        self.next_sync_point = factor * self.sync_every\n                    else:\n                        self.next_sync_point = base_next_sync_point\n                    session.write(\n                        f\"[Model Averaging] Next sync point at {self.next_sync_point}; \"\n                        f\"current min epoch at {min_epoch_count}\")\n                    self.update_sync_point = False\n\n                worker_status = [\n                    self.get_worker_status(worker_id) for worker_id in worker_queue]\n                if all((status == DistStatus.COMPLETED for status in worker_status)):\n                    if not run_eval:\n                        worker_queue.append(None)\n                        return\n\n                    worker_queue.append(None)\n                    self.model_averaging(session)\n                    worker_queue.pop()\n                    session.write(\"All workers have completed. Closing...\")\n\n                    for worker_id in worker_queue:\n                        # Inform each worker to close\n                        self.dist_store.set(f\"{worker_id}-status\", str(DistStatus.CLOSE_OK.value))\n\n                    while len(worker_queue) > 0:\n                        # Wait until each worker confirmed closing\n                        worker_id = worker_queue.popleft()\n                        status = self.get_worker_status(worker_id)\n                        while status != DistStatus.CLOSED:\n                            time.sleep(0.1)\n                            status = self.get_worker_status(worker_id)\n                        worker_dict[worker_id][\"bar\"].close()\n                        del worker_dict[worker_id][\"bar\"]\n                    # Exiting loop\n\n                elif all((status >= DistStatus.RUNNING for status in worker_status)):\n                    if time.time() - session.t_start > session.time_limit.total_seconds():\n                        ready_to_sync = True\n                        session.is_stopping = True\n                        self.status = DistStatus.CLOSE_OK\n                        self.next_sync_point = min_epoch_count\n\n                    elif type(self.sync_every) is not timedelta:\n                        ready_to_sync = np.zeros(len(worker_queue), dtype=bool)\n                        for i, worker_id in enumerate(worker_queue):\n                            if worker_status[i] == DistStatus.COMPLETED:\n                                ready_to_sync[i] = True\n                                continue\n                            sdict = worker_dict[worker_id]\n                            epoch_count = sdict[\"epoch\"] - 1\n                            epoch_count += sdict[\"step\"] / sdict[\"step_per_epoch\"]\n\n                            worker_dict[worker_id][\"bar\"].set_postfix(\n                                step=f'{sdict[\"step\"]}/{sdict[\"step_per_epoch\"]}',\n                                next_sync=self.next_sync_point,\n                                **session.postfix_dict_step\n                            )\n\n                            # iter_count = worker_dict[worker_id][\"iter_count\"]\n                            if epoch_count >= self.next_sync_point:\n                                ready_to_sync[i] = True\n                        ready_to_sync = ready_to_sync.all()\n                    else:\n                        ready_to_sync = ((time.time() - self.t_averaging)\n                                         > self.sync_every.total_seconds())\n                        self.next_sync_point = min_epoch_count\n\n                    if ready_to_sync:\n                        # Run model averaging\n                        worker_queue.append(None)\n                        self.model_averaging(session, run_eval=run_eval)\n                        if (type(self.sync_every) is not timedelta\n                            and self.next_sync_point < min_epoch_count):\n                            self.update_sync_point = True\n                        worker_queue.pop()\n\n                worker_queue.append(None)\n                return\n\n            else: # Update status from each worker\n                if type(self.sync_every) is not timedelta:\n                    # For deprecated step-based aggregation interval. \n                    # This has no effect when using time-based aggregation interval.\n                    worker_status = self.get_worker_status(worker_id)\n                    if worker_status >= DistStatus.RUNNING.value:\n                        # The following line of code may cause segmentation fault randomly\n                        pgs_dict = {\n                            name: int(self.dist_store.get(f\"{worker_id}-{name}\"))\n                            for name in [\"epoch\", \"step\", \"iter_count\", \"step_per_epoch\"]\n                        }\n                        self.update_worker_progress(session, worker_id, pgs_dict)\n\n                worker_queue.append(worker_id)\n\n    def update_worker_progress(self, session, worker_id: int, pgs_dict: dict):\n        '''\n        Update progress bar of each worker in the server process.\n\n        Arguments:\n        ----------\n        session: SessionMgr\n            Session manager object\n        worker_id: int\n            Rank of the distributed trainer\n        pgs_dict: dict\n            Dictionary containing progress information of the trainer\n        '''\n        epoch_delta = pgs_dict[\"epoch\"] - self.worker_dict[worker_id][\"epoch\"]\n        # worker_dict[worker_id][\"bar\"].write(str(epoch_delta))\n        self.worker_dict[worker_id][\"bar\"].update(\n            epoch_delta\n        )\n        self.worker_dict[worker_id][\"bar\"].set_postfix(\n            step=f'{pgs_dict[\"step\"]}/{pgs_dict[\"step_per_epoch\"]}',\n            next_sync=self.next_sync_point,\n            **session.postfix_dict_step\n        )\n        self.worker_dict[worker_id].update(pgs_dict)\n\n    def server_main(self, session):\n        '''\n        Main function for server process. \n\n        Arguments:\n        ----------\n        session: SessionMgr\n            Session manager object\n        '''\n        # session.t_preprocess = self.sampler.preprocess_time\n        session.reset_timer()\n        if self.need_train_dataloader:\n            print(\"[Dist] Creating train dataloader...\")\n            session.create_train_data_loader()\n            session.dataloader_iter = iter(session.dataloader)\n        # Calculate validation MFG\n        session.valid_evaluator.create_data_loader(session.model)\n        # Initial parameter sync\n        self.model_averaging(session, run_eval=False)\n\n        self.status = DistStatus.RUNNING\n        worker_queue = deque(range(1, self.world_size))\n        worker_dict = {\n            worker_id: dict(\n                bar=tqdm.tqdm(\n                    desc=f\"Worker {worker_id}\",\n                    total=session.args.n_epochs,\n                    position=i,\n                    dynamic_ncols=True\n                ),\n                epoch=0,\n                step=0,\n                iter_count=0,\n                step_per_epoch=float(\"inf\")\n            )\n            for i, worker_id in enumerate(worker_queue)\n        }\n        self.worker_queue = worker_queue\n        self.worker_dict = worker_dict\n\n        session.step_progress = worker_dict[1][\"bar\"]\n        session.postfix_dict_step = {\n            \"model\": f\"{session.args.model} ({session.model.num_model_params})\",\n            \"PID\": os.getpid(),\n            \"SIGNAC\": session.args.signac_job.id if session.args.signac_job else None,\n            **session.args.tqdm_msg\n        }\n\n        worker_queue.append(None)\n        if type(self.sync_every) is not timedelta:\n            self.next_sync_point = self.sync_every\n        else:\n            self.next_sync_point = None\n        self.update_sync_point = False\n        while len(worker_queue) > 1:\n            self.poll_workers(session)\n            time.sleep(0.1)\n\n        # Wait for current evaluation to complete\n        if self.eval_thread is not None:\n            self.eval_thread.join()\n        if session.model_at_best:\n            session.save_checkpoints(\"best\", model=self.eval_model)\n\n        # Evaluate on test set\n        if session.datamgr.test_edge is not None:\n            session.clean_memory()\n            session.run_evaluation(\"test\")\n            session.clean_memory()\n            session.run_evaluation(\"best\")\n        \n        if session.args.signac_job:\n            session.args.signac_job.doc.worker_pgs = self.worker_dict\n        \n        session.signac_mark_success()", ""]}
{"filename": "src/distributed/MultiGPU.py", "chunked_list": ["'''\nImplementation of MultiGPU training with synchronized SGD using DGL DDP functionality.\n'''\nimport time\nfrom pathlib import Path\n\nimport numpy as np\nimport torch\nimport torch.distributed as dist\n", "import torch.distributed as dist\n\nfrom ..pipelines.utils import parse_timedelta\n\n\nclass MultiGPUTrainer:\n    def __init__(self, args, proc_id:int, dev_id: int):\n        '''\n        Distributed manager on trainer side for MultiGPU training.\n        The trainer processes communicates with the server process through file system\n        (specifically, the signac job document of the server job),\n        since the server process only conducts evaluation and does not participate in the torch distributed \n        process group. As a result, signac must be used for MultiGPU training to work.\n\n        Arguments\n        ---------\n        args: argparse.Namespace\n            The parsed program arguments.\n        proc_id: int\n            Process ID of the trainer.\n        dev_id: int\n            The GPU device ID to use.\n        '''\n        dist_init_method = 'tcp://{master_ip}:{master_port}'.format(master_ip='127.0.0.1', master_port='12555')\n\n        torch.cuda.set_device(dev_id)\n        self.device = torch.device(\"cuda:{}\".format(dev_id))\n        self.gpu_list = args.gpu\n        self.proc_id = proc_id\n\n        self.pgs_dict = dict()\n\n        # Cannot be used together with distributed training\n        # Only the trainers are communicating through the process group\n        torch.distributed.init_process_group(\n            backend='nccl', init_method=dist_init_method, \n            world_size=self.trainer_size, rank=self.rank)\n        \n        self.enable_eval = False\n        \n        # Reopen signac job\n        spDict = args.signac_job.sp()\n\n        args.signac_job_server = args.project.open_job(spDict)\n        spDict[\"dist_params\"][\"rank\"] = proc_id\n        args.signac_job = args.project.open_job(spDict).init()\n        args.signac_job.reset()\n        args.result_path = Path(args.signac_job.ws)\n\n        self.signac_job_server = args.signac_job_server\n        self.signac_job = args.signac_job\n\n        while True:\n            if len(self.signac_job_server.doc.get(\"dist_signac_ids\", [])) == proc_id:\n                self.signac_job_server.doc.dist_signac_ids.append(self.signac_job.id)\n                break\n            else:\n                time.sleep(0.01)\n        \n        self.signac_job.doc.dist_signac_ids = self.signac_job_server.doc.dist_signac_ids\n\n        # reset all random seeds\n        torch.manual_seed(args.random_seed)\n        torch.cuda.manual_seed_all(args.random_seed)\n        np.random.seed(args.random_seed)\n\n    @property\n    def used_gpu_list(self):\n        '''\n        Get the list of GPUs used by all trainer processes.\n        '''\n        return self.gpu_list[1:]\n\n    @property\n    def rank(self):\n        '''\n        Get the rank of the trainer process in the torch distributed process group.\n        '''\n        return self.proc_id - 1\n\n    @property\n    def is_eval(self):\n        '''\n        Get the evaluation signal from the server process.\n        '''\n        return self.signac_job_server.doc.get(\"is_eval\", False)\n    \n    @is_eval.setter\n    def is_eval(self, value):\n        self.signac_job_server.doc.is_eval = value\n\n    @property\n    def train_started(self):\n        return self.signac_job_server.doc.get(\"train_started\", False)\n    \n    @train_started.setter\n    def train_started(self, value):\n        '''\n        Inform the server process if training has started.\n        '''\n        self.signac_job_server.doc.train_started = value\n\n    def run_pre_train_hooks(self, session):\n        '''\n        Run hooks before each training step to check if the training should be stopped.\n        '''\n        if not self.train_started:\n            self.train_started = True\n        elif self.is_stopping:\n            print(f\"[Trainer {self.rank}] Stop signal detected.\")\n            session.is_stopping = True\n\n    def run_post_step_hooks(self, session):\n        '''\n        Run hooks after each training step to check if server is asking for model to be evaluated.\n        '''\n        if self.rank == 0:\n            if self.is_eval:\n                for name in [\"epoch\", \"step\", \"iter_count\", \"step_per_epoch\"]:\n                    value = getattr(session, name)\n                    self.pgs_dict[name] = int(value)\n                self.pgs_dict[\"epoch_count\"] = (self.pgs_dict[\"epoch\"] - 1\n                    + self.pgs_dict[\"step\"] / self.pgs_dict[\"step_per_epoch\"])\n                self.signac_job_server.doc.eval_pgs_dict = self.pgs_dict\n                with self.signac_job_server:\n                    session._save_checkpoints(\n                        None, session.model, None, checkpoint_path=\"eval.pth\")\n                session.write(f\"[Trainer] saved evaluation checkpoint.\")\n                self.is_eval = False\n        \n    @property\n    def trainer_size(self):\n        '''\n        Get the size of the torch distributed process group.\n        '''\n        return len(self.gpu_list) - 1\n\n    @property\n    def world_size(self):\n        '''\n        Get the world size of the torch distributed process group.\n        '''\n        return len(self.gpu_list)\n\n    @property\n    def is_stopping(self):\n        '''\n        Get the stop signal from the server process.\n        '''\n        return self.signac_job_server.doc.get(\"is_stopping\", False)\n    \n    @property\n    def ok_to_stop(self):\n        '''\n        Get the program exit signal from the server process.\n        '''\n        return self.signac_job_server.doc.get(\"ok_to_stop\", False)\n\n    def wait_cluster(self, session):\n        '''\n        Wait for all processes to complete and destroy the process group.\n        '''\n        while not self.ok_to_stop:\n            time.sleep(0.5)\n        print(f\"[Trainer {self.rank}] Destroying process group...\")\n        dist.destroy_process_group()", "    \n\nclass MultiGPUServer:\n    def __init__(self, args, dev_id: int):\n        '''\n        Distributed manager on server side for MultiGPU training.\n        The trainer processes communicates with the server process through file system\n        (specifically, the signac job document of the server job),\n        since the server process only conducts evaluation and does not participate in the torch distributed \n        process group. As a result, signac must be used for MultiGPU training to work.\n\n        Arguments\n        ---------\n        args: argparse.Namespace\n            The parsed program arguments.\n        dev_id: int\n            The GPU device ID to use.\n        '''\n        torch.cuda.set_device(dev_id)\n        self.device = torch.device(\"cuda:{}\".format(dev_id))\n        \n        self.signac_project = args.project\n\n        # Reopen signac job\n        spDict = args.signac_job.sp()\n        args.signac_job = args.project.open_job(spDict)\n        args.signac_job_server = args.signac_job\n        \n        self.signac_job_server = args.signac_job_server\n        self.signac_job = args.signac_job\n\n        self.signac_job.doc.dist_signac_ids = [args.signac_job.id]\n        self.is_eval = False\n        self.sync_every = parse_timedelta(args.eval_every)\n        self.time_limit = parse_timedelta(args.time_limit)\n        self.enable_eval = True\n\n        # reset all random seeds\n        torch.manual_seed(args.random_seed)\n        torch.cuda.manual_seed_all(args.random_seed)\n        np.random.seed(args.random_seed)\n    \n\n    @property\n    def train_started(self):\n        '''\n        Check if training has started by the trainer processes.\n        '''\n        return self.signac_job_server.doc.get(\"train_started\", False)\n\n    @property\n    def is_eval(self):\n        '''\n        Get the evaluation signal.\n        '''\n        return self.signac_job.doc.get(\"is_eval\", False)\n\n    @is_eval.setter\n    def is_eval(self, value):\n        '''\n        Set the evaluation signal from the server process.\n        '''\n        self.signac_job.doc.is_eval = value\n\n    @property\n    def is_stopping(self):\n        '''\n        Get the stop signal.\n        '''\n        return self.signac_job_server.doc.get(\"is_stopping\", False)\n    \n    @is_stopping.setter\n    def is_stopping(self, value):\n        '''\n        Set the stop signal.\n        '''\n        self.signac_job.doc.is_stopping = value\n\n    @property\n    def ok_to_stop(self):\n        '''\n        Get the program exit signal from the server process.\n        '''\n        return self.signac_job_server.doc.get(\"ok_to_stop\", False)\n    \n    @ok_to_stop.setter\n    def ok_to_stop(self, value):\n        '''\n        Set the program exit signal from the server process.\n        '''\n        self.signac_job.doc.ok_to_stop = value\n\n    @property\n    def used_gpu_list(self):\n        '''\n        Get the list of GPUs used by the server.\n        '''\n        return self.gpu_list[:1]\n\n\n    @property\n    def eval_pgs_dict(self):\n        return self.signac_job.doc.eval_pgs_dict\n\n    def time_training(self, session):\n        '''\n        Check if the time limit for training has been reached.\n        If so, set the stop signal.\n        '''\n        if not self.is_stopping and ((time.time() - session.t_start) > self.time_limit.total_seconds()):\n            self.is_stopping = True\n            self.is_eval = True\n\n    def trainer_signac_mark_success(self):\n        '''\n        Mark the signac job of the trainers as successful.\n        '''\n        for pid in self.signac_job.doc.dist_signac_ids[1:]:\n            tjob = self.signac_project.open_job(id=pid)\n            tjob.doc.success = True\n\n    def run_eval(self, session):\n        '''\n        Load the evaluation checkpoint stored by trainer and run evaluation.\n        '''\n        while self.is_eval:\n            time.sleep(0.1)\n        with self.signac_job:\n            checkpoint = torch.load(\"eval.pth\")\n            Path(\"eval.pth\").unlink()\n        self.t_eval = time.time()\n        filtered_state_dict = {\n            key.replace(\"module.\", \"\", 1): value \n            for key, value in checkpoint[\"model_state_dict\"].items()}\n        session.model.load_state_dict(filtered_state_dict)\n        session.save_checkpoints(\"latest\")\n        session.run_evaluation(\n            \"valid\", \n            alt_epoch=self.eval_pgs_dict[\"epoch_count\"],\n            callback=lambda: self.time_training(session)\n        )\n        if session.model_at_best:\n            session.save_checkpoints(\"best\")\n\n    def server_main(self, session):\n        '''\n        Main function of the server process.\n\n        Arugments:\n        ----------\n        session: SessionMgr\n            Session manager object\n        '''\n        session.valid_evaluator.create_data_loader(session.model)\n        self.is_stopping = False\n        while not self.train_started:\n            time.sleep(0.1)\n        session.reset_timer()\n        self.t_eval = time.time()\n        print(\"Server standby...\")\n        \n        while not self.is_stopping:\n            self.time_training(session)\n            \n            if (time.time() - self.t_eval) > self.sync_every.total_seconds():\n                self.is_eval = True\n                self.run_eval(session)\n            else:\n                time.sleep(0.1)\n\n        with self.signac_job:\n            if Path(\"eval.pth\").exists():\n                self.run_eval(session)\n        \n        # Evaluate on test set\n        session.clean_memory()\n        session.run_evaluation(\"test\")\n        session.clean_memory()\n        session.run_evaluation(\"best\")\n\n        session.signac_mark_success()\n        self.trainer_signac_mark_success()\n        \n        self.ok_to_stop = True", ""]}
{"filename": "src/distributed/__init__.py", "chunked_list": [""]}
{"filename": "src/samplers/ClusterGCN.py", "chunked_list": ["'''\nAdaption of the ClusterGCN sampler from DGL for link prediction.\n'''\nimport torch\nimport dgl\nimport itertools\nimport time\nfrom pathlib import Path\nimport json\nfrom ..pipelines.utils import get_peak_mem", "import json\nfrom ..pipelines.utils import get_peak_mem\nimport signac\nimport numpy as np\nfrom dgl.dataloading.cluster_gcn import set_edge_lazy_features, set_node_lazy_features\nfrom dgl.dataloading.cluster_gcn import F\n\n\nclass ClusterGCNEdgeSampler(dgl.dataloading.ClusterGCNSampler):\n    '''\n    ClusterGCN sampler for link prediction.\n    '''\n    @classmethod\n    def create_sampler_from_mem(\n            cls, partition_offset, partition_node_ids,\n            prefetch_ndata=None, prefetch_edata=None, output_device=None\n        ) -> dgl.dataloading.ClusterGCNSampler:\n        '''\n        An alternative constructor for the *parent* class (ClusterGCNSampler) \n        that recreates a sampler using existing partition information, \n        instead of rerunning the partitioning algorithm from start.\n\n        For the usage of all arguments, see the constructor of `dgl.dataloading.ClusterGCNSampler`.\n        '''\n        super_self = dgl.dataloading.ClusterGCNSampler.__new__(\n            dgl.dataloading.ClusterGCNSampler)\n        super(dgl.dataloading.ClusterGCNSampler, super_self).__init__()\n\n        super_self.partition_offset = partition_offset\n        super_self.partition_node_ids = partition_node_ids\n        \n        super_self.prefetch_ndata = prefetch_ndata or []\n        super_self.prefetch_edata = prefetch_edata or []\n        super_self.output_device = output_device\n\n        return super_self\n        \n    @classmethod\n    def create_from_mem(\n            cls, partition_offset, partition_node_ids, negative_sampler=None,\n            prefetch_ndata=None, prefetch_edata=None, output_device=None\n        ):\n        '''\n        An alternative constructor that recreates an edge sampler using existing partition information, \n        instead of rerunning the partitioning algorithm from start.\n\n        Arguments\n        ---------\n        negative_sampler: `dgl.dataloading.negative_sampler._BaseNegativeSampler`\n            Negative sampler for link prediction.\n        \n        For the usage of all other arguments, see the constructor of `dgl.dataloading.ClusterGCNSampler`.\n        '''\n        self = cls.create_sampler_from_mem(\n            partition_offset, partition_node_ids, \n            prefetch_ndata, prefetch_edata, output_device)\n        \n        self.perf_dict = dict()\n        self.signac_job = None\n        self.cache_path = None\n        self.negative_sampler = negative_sampler\n        self.__class__ = cls\n\n        return self\n\n    def __init__(self, g, k, cache_path='ClusterGCN', negative_sampler=None,\n                 balance_ntypes=None, balance_edges=False, mode='k-way',\n                 prefetch_ndata=None, prefetch_edata=None, output_device=None):\n        '''\n        Arguments\n        ---------\n        negative_sampler: `dgl.dataloading.negative_sampler._BaseNegativeSampler`\n            Negative sampler for link prediction.\n        cache_path: `str`\n            Path to cache the graph partitions.\n        For the usage of all other arguments, see the constructor of `dgl.dataloading.ClusterGCNSampler`.\n        '''\n        metis_params_dict = dict(\n            k=k, balance_ntypes=balance_ntypes,\n            balance_edges=balance_edges,\n            mode=mode\n        )\n        if type(cache_path) is tuple and type(cache_path[0]) is signac.Project:\n            self.signac_job = self.get_signac_job(\n                cache_path[0], metis_params_dict, cache_path[1])\n            self.cache_path = Path(self.signac_job.ws)\n        else:\n            self.signac_job = None\n            self.cache_path = Path(cache_path)\n            self.cache_path.mkdir(parents=True, exist_ok=True)\n        print(f\"ClusterGCN: using cache path {self.cache_path}\")\n        self.cluster_file_path = self.cache_path / 'ClusterGCN.pkl'\n        self.perf_file_path = self.cache_path / 'ClusterGCN_perf.json'\n        if self.cluster_file_path.exists() and self.perf_file_path.exists():\n            self.loaded_from_cache = True\n        else:\n            self.loaded_from_cache = False\n        start_t = time.time()\n        super().__init__(g, cache_path=str(self.cluster_file_path),\n                         prefetch_ndata=prefetch_ndata,\n                         prefetch_edata=prefetch_edata,\n                         output_device=output_device, **metis_params_dict)\n        end_t = time.time()\n        self.perf_dict = dict()\n        if not self.loaded_from_cache:\n            self.perf_dict[\"Time\"] = end_t - start_t\n            self.perf_dict[\"RAM\"] = get_peak_mem()\n            with open(self.perf_file_path, \"w\") as f:\n                json.dump(self.perf_dict, f)\n            if self.signac_job:\n                self.signac_job.doc.success = True\n                self.signac_job.doc.metrics = self.perf_dict\n        else:\n            with open(self.perf_file_path, \"r\") as f:\n                self.perf_dict = json.load(f)\n        self.negative_sampler = negative_sampler\n\n    _build_neg_graph = dgl.dataloading.EdgePredictionSampler._build_neg_graph\n\n    def get_signac_job(self, project: signac.Project, params_dict: dict, \n                       dataset_str: str):\n        '''\n        Get the signac job for storing the graph partitioning results.\n\n        Arguments\n        ---------\n        project: `signac.Project`\n            The signac project.\n        params_dict: `dict`\n            The parameters for METIS.\n        dataset_str: `str`\n            The name of the dataset.\n        '''\n        sp_dict = dict(\n            type=\"preprocess\",\n            model=\"preprocess-ClusterGCN\",\n            model_params=params_dict,\n            dataset=dataset_str\n        )\n        return project.open_job(sp_dict).init()\n\n    def sample(self, g, partition_ids):\n        '''\n        Sample positive edges and negative edges for link prediction \n        given the partition IDs.\n\n        Arguments\n        ----------\n        g: `dgl.DGLGraph`\n            Graph to sample from.\n        partition_ids: `torch.Tensor`\n            IDs of the partitions for sampling.\n\n        Returns\n        -------\n        node_ids: `torch.Tensor`\n            Node IDs of the sampled subgraph.\n        subg: `dgl.DGLGraph`\n            The sampled positive subgraph.\n        neg_graph: `dgl.DGLGraph`\n            The sampled negative graph.\n        '''\n        subg = super().sample(g, partition_ids)  # type: dgl.DGLGraph\n        if self.negative_sampler is not None:\n            neg_graph = self._build_neg_graph(subg, subg.edges(form=\"eid\"))\n            # subg, neg_graph = dgl.transforms.compact_graphs(subg, neg_graph)\n            return subg.ndata[dgl.NID], subg, neg_graph\n        else:\n            return subg.ndata[dgl.NID], subg\n\n    @property\n    def preprocess_time(self):\n        '''\n        Get the time spent on graph partitioning.\n        '''\n        return self.perf_dict.get(\"Time\", 0.0)\n\n    @property\n    def preprocess_stats(self):\n        '''\n        Get the performance statistics of graph partitioning.\n        '''\n        return self.perf_dict.copy()", "class ClusterGCNEdgeSampler(dgl.dataloading.ClusterGCNSampler):\n    '''\n    ClusterGCN sampler for link prediction.\n    '''\n    @classmethod\n    def create_sampler_from_mem(\n            cls, partition_offset, partition_node_ids,\n            prefetch_ndata=None, prefetch_edata=None, output_device=None\n        ) -> dgl.dataloading.ClusterGCNSampler:\n        '''\n        An alternative constructor for the *parent* class (ClusterGCNSampler) \n        that recreates a sampler using existing partition information, \n        instead of rerunning the partitioning algorithm from start.\n\n        For the usage of all arguments, see the constructor of `dgl.dataloading.ClusterGCNSampler`.\n        '''\n        super_self = dgl.dataloading.ClusterGCNSampler.__new__(\n            dgl.dataloading.ClusterGCNSampler)\n        super(dgl.dataloading.ClusterGCNSampler, super_self).__init__()\n\n        super_self.partition_offset = partition_offset\n        super_self.partition_node_ids = partition_node_ids\n        \n        super_self.prefetch_ndata = prefetch_ndata or []\n        super_self.prefetch_edata = prefetch_edata or []\n        super_self.output_device = output_device\n\n        return super_self\n        \n    @classmethod\n    def create_from_mem(\n            cls, partition_offset, partition_node_ids, negative_sampler=None,\n            prefetch_ndata=None, prefetch_edata=None, output_device=None\n        ):\n        '''\n        An alternative constructor that recreates an edge sampler using existing partition information, \n        instead of rerunning the partitioning algorithm from start.\n\n        Arguments\n        ---------\n        negative_sampler: `dgl.dataloading.negative_sampler._BaseNegativeSampler`\n            Negative sampler for link prediction.\n        \n        For the usage of all other arguments, see the constructor of `dgl.dataloading.ClusterGCNSampler`.\n        '''\n        self = cls.create_sampler_from_mem(\n            partition_offset, partition_node_ids, \n            prefetch_ndata, prefetch_edata, output_device)\n        \n        self.perf_dict = dict()\n        self.signac_job = None\n        self.cache_path = None\n        self.negative_sampler = negative_sampler\n        self.__class__ = cls\n\n        return self\n\n    def __init__(self, g, k, cache_path='ClusterGCN', negative_sampler=None,\n                 balance_ntypes=None, balance_edges=False, mode='k-way',\n                 prefetch_ndata=None, prefetch_edata=None, output_device=None):\n        '''\n        Arguments\n        ---------\n        negative_sampler: `dgl.dataloading.negative_sampler._BaseNegativeSampler`\n            Negative sampler for link prediction.\n        cache_path: `str`\n            Path to cache the graph partitions.\n        For the usage of all other arguments, see the constructor of `dgl.dataloading.ClusterGCNSampler`.\n        '''\n        metis_params_dict = dict(\n            k=k, balance_ntypes=balance_ntypes,\n            balance_edges=balance_edges,\n            mode=mode\n        )\n        if type(cache_path) is tuple and type(cache_path[0]) is signac.Project:\n            self.signac_job = self.get_signac_job(\n                cache_path[0], metis_params_dict, cache_path[1])\n            self.cache_path = Path(self.signac_job.ws)\n        else:\n            self.signac_job = None\n            self.cache_path = Path(cache_path)\n            self.cache_path.mkdir(parents=True, exist_ok=True)\n        print(f\"ClusterGCN: using cache path {self.cache_path}\")\n        self.cluster_file_path = self.cache_path / 'ClusterGCN.pkl'\n        self.perf_file_path = self.cache_path / 'ClusterGCN_perf.json'\n        if self.cluster_file_path.exists() and self.perf_file_path.exists():\n            self.loaded_from_cache = True\n        else:\n            self.loaded_from_cache = False\n        start_t = time.time()\n        super().__init__(g, cache_path=str(self.cluster_file_path),\n                         prefetch_ndata=prefetch_ndata,\n                         prefetch_edata=prefetch_edata,\n                         output_device=output_device, **metis_params_dict)\n        end_t = time.time()\n        self.perf_dict = dict()\n        if not self.loaded_from_cache:\n            self.perf_dict[\"Time\"] = end_t - start_t\n            self.perf_dict[\"RAM\"] = get_peak_mem()\n            with open(self.perf_file_path, \"w\") as f:\n                json.dump(self.perf_dict, f)\n            if self.signac_job:\n                self.signac_job.doc.success = True\n                self.signac_job.doc.metrics = self.perf_dict\n        else:\n            with open(self.perf_file_path, \"r\") as f:\n                self.perf_dict = json.load(f)\n        self.negative_sampler = negative_sampler\n\n    _build_neg_graph = dgl.dataloading.EdgePredictionSampler._build_neg_graph\n\n    def get_signac_job(self, project: signac.Project, params_dict: dict, \n                       dataset_str: str):\n        '''\n        Get the signac job for storing the graph partitioning results.\n\n        Arguments\n        ---------\n        project: `signac.Project`\n            The signac project.\n        params_dict: `dict`\n            The parameters for METIS.\n        dataset_str: `str`\n            The name of the dataset.\n        '''\n        sp_dict = dict(\n            type=\"preprocess\",\n            model=\"preprocess-ClusterGCN\",\n            model_params=params_dict,\n            dataset=dataset_str\n        )\n        return project.open_job(sp_dict).init()\n\n    def sample(self, g, partition_ids):\n        '''\n        Sample positive edges and negative edges for link prediction \n        given the partition IDs.\n\n        Arguments\n        ----------\n        g: `dgl.DGLGraph`\n            Graph to sample from.\n        partition_ids: `torch.Tensor`\n            IDs of the partitions for sampling.\n\n        Returns\n        -------\n        node_ids: `torch.Tensor`\n            Node IDs of the sampled subgraph.\n        subg: `dgl.DGLGraph`\n            The sampled positive subgraph.\n        neg_graph: `dgl.DGLGraph`\n            The sampled negative graph.\n        '''\n        subg = super().sample(g, partition_ids)  # type: dgl.DGLGraph\n        if self.negative_sampler is not None:\n            neg_graph = self._build_neg_graph(subg, subg.edges(form=\"eid\"))\n            # subg, neg_graph = dgl.transforms.compact_graphs(subg, neg_graph)\n            return subg.ndata[dgl.NID], subg, neg_graph\n        else:\n            return subg.ndata[dgl.NID], subg\n\n    @property\n    def preprocess_time(self):\n        '''\n        Get the time spent on graph partitioning.\n        '''\n        return self.perf_dict.get(\"Time\", 0.0)\n\n    @property\n    def preprocess_stats(self):\n        '''\n        Get the performance statistics of graph partitioning.\n        '''\n        return self.perf_dict.copy()", "\n\nclass ClusterGCNEdgeDataLoader:\n    def __init__(self, graph, num_parts, batch_size,\n                 cache_path='cluster_gcn.pkl',\n                 negative_sampler=None, \n                 train_frac_sample=(1.0, None), \n                 device=\"cpu\",\n                 _graph_sampler=None,\n                 sampler_kwargs=dict(),\n                 **loader_kwargs) -> None:\n        '''\n        Implementation for ClusterGCN sampler: \n        wrap ClusterGCNEdgeSampler to act as a dataloader for subgraphs in \n        link prediction training.\n\n        Arguments\n        ---------\n        graph: `dgl.DGLGraph`\n            The graph to sample from.\n        num_parts: int\n            number of total clusters to generate;\n        batch_size: int\n            number of clusters to include in each subgraph.\n        train_frac_sample: `tuple`\n            The fraction of training graph to sample, and the random seed.\n        device: `str`\n            The device to store the sampled graphs.\n        sampler_kwargs: `dict`\n            The keyword arguments for ClusterGCNEdgeSampler.\n        loader_kwargs:\n            Additional keyword arguments for DGL dataloader.\n        '''\n        self.graph = graph\n        self.num_parts = num_parts\n        self.batch_size = batch_size\n        self.negative_sampler = negative_sampler\n        if _graph_sampler is None:\n            self.graphsampler = ClusterGCNEdgeSampler(\n                self.graph, self.num_parts, cache_path,\n                negative_sampler=self.negative_sampler,\n                **sampler_kwargs\n            )\n        else:\n            self.graphsampler : ClusterGCNEdgeSampler = _graph_sampler\n            self.graphsampler.negative_sampler = negative_sampler\n            self.num_parts = len(self.graphsampler.partition_offset) - 1\n        \n        # Downsample training set if needed\n        self.train_frac = train_frac_sample[0]\n        self.random_seed = train_frac_sample[1]\n        if self.train_frac < 1.0:\n            torch_rnd_state = torch.random.get_rng_state()\n            if self.random_seed is not None:\n                torch.random.manual_seed(self.random_seed)\n            num_clusters = np.round(self.train_frac * self.num_parts)\n            self.train_cluster_idx = torch.randperm(self.num_parts)[:num_clusters]\n            torch.random.set_rng_state(torch_rnd_state)\n            print(f\"Selected {len(self.train_cluster_idx)} out of {self.num_parts} clusters for training.\")\n        else:\n            self.train_cluster_idx = torch.arange(self.num_parts)\n        \n\n        self.dataloader = dgl.dataloading.DataLoader(\n            self.graph, self.train_cluster_idx,\n            self.graphsampler, batch_size=self.batch_size,\n            device=device, **loader_kwargs\n        )\n\n    def __iter__(self):\n        if self.negative_sampler is not None:\n            for input_nodes, subg, neg_graph in self.dataloader:\n                # input_nodes, pos_graph, neg_graph, blocks\n                yield input_nodes, subg, neg_graph, itertools.repeat(subg)\n        else:\n            for input_nodes, subg in self.dataloader:\n                # input_nodes, pos_graph, neg_graph, blocks\n                yield input_nodes, subg, itertools.repeat(subg)\n\n    @property\n    def step_per_epoch(self):\n        '''\n        Get the number of training steps per epoch.\n        '''\n        return np.ceil(self.num_parts / self.batch_size)\n\n    @property\n    def preprocess_time(self):\n        '''\n        Get the time spent on graph partitioning.\n        '''\n        return self.graphsampler.preprocess_time\n\n    @property\n    def preprocess_stats(self):\n        '''\n        Get the performance statistics of graph partitioning.\n        '''\n        return self.graphsampler.preprocess_stats\n\n    @property\n    def cache_path(self):\n        '''\n        Get the cache path of the sampler.\n        '''\n        return self.graphsampler.cache_path\n    \n    @property\n    def collate_fn(self):\n        return self.dataloader.collate_fn\n    \n    @collate_fn.setter\n    def collate_fn(self, value):\n        self.dataloader.collate_fn = value", "\n\nclass ClusterGCNClusterSampler(ClusterGCNEdgeSampler):\n    def __init__(self, g, k, cache_path='ClusterGCN', negative_sampler=None, \n                 balance_ntypes=None, balance_edges=False, mode='k-way', \n                 prefetch_ndata=None, prefetch_edata=None, output_device=None, \n                 random_seed=None):\n        '''\n        Wrapper of ClusterGCNEdgeSampler to sample clusters instead of edges:\n        sample a group of mini-clusters to generate a subgraph.\n\n        Arguments\n        ---------\n        random_seed: `int`\n            Random seed for generating groups of clusters.\n        \n        For all other arguments, see ClusterGCNEdgeSampler.\n        '''\n        super().__init__(g, k, cache_path, negative_sampler, balance_ntypes, \n                         balance_edges, mode, prefetch_ndata, prefetch_edata, output_device)\n        self.random_seed = random_seed\n\n    def sample(self, g, partition_ids):\n        '''\n        Generate a subgraph from a group of clusters.\n\n        Arguments\n        ---------\n        g: DGLGraph\n            The input graph.\n        partition_ids: torch.Tensor\n            The cluster IDs from which the subgraph is generated.\n\n        Returns\n        -------\n        sg: DGLGraph\n            The generated subgraph.\n        node_ids: torch.Tensor\n            The node IDs in the subgraph.\n        partition_offset: torch.Tensor\n            The offset of the start of each cluster in `node_ids`.\n        '''\n        node_ids = F.cat([\n            self.partition_node_ids[self.partition_offset[i]:self.partition_offset[i+1]]\n            for i in partition_ids], 0)\n        partition_size = np.array(\n            [self.partition_offset[i+1] - self.partition_offset[i]\n             for i in partition_ids]\n        )\n        partition_offset = np.insert(np.cumsum(partition_size), 0, 0)\n        sg = self.get_subgraph(g, node_ids)\n\n        return sg, node_ids, partition_offset\n\n    def get_subgraph(self, g, node_ids):\n        sg = g.subgraph(node_ids, relabel_nodes=True,\n                        output_device=self.output_device)\n        set_node_lazy_features(sg, self.prefetch_ndata)\n        set_edge_lazy_features(sg, self.prefetch_edata)\n\n        return sg\n\n    def group_clusters(self, num_groups, strategy=\"uniform-cluster\"):\n        '''\n        Group clusters into groups for generating subgraphs.\n\n        Arguments\n        ---------\n        num_groups: `int`\n            The number of groups to generate.\n        strategy: `str`\n            The grouping strategy. Currently only \"uniform-cluster\" is supported.\n        \n        Returns\n        -------\n        group_list: `list`\n            A list of groups of clusters.\n        '''\n        rng = np.random.default_rng(seed=self.random_seed)\n        group_list = []\n        if strategy == \"uniform-cluster\":\n            cluster_per_group = float(self.num_clusters) / num_groups\n            cluster_list = np.arange(self.num_clusters)\n            rng.shuffle(cluster_list)\n            p = 0\n            for i in range(num_groups):\n                group_size = int(np.floor(cluster_per_group))\n                if rng.random() < cluster_per_group % 1:\n                    group_size += 1\n                if i != num_groups - 1:\n                    p_end = p + group_size\n                else:\n                    p_end = self.num_clusters\n                group_list.append(cluster_list[p:p_end])\n                p = p_end\n        else:\n            raise ValueError(f\"Unknown grouping strategy {strategy}\")\n        return group_list\n\n    @property\n    def num_clusters(self):\n        return len(self.partition_offset) - 1", ""]}
{"filename": "src/samplers/__init__.py", "chunked_list": [""]}
{"filename": "src/pipelines/Initialization.py", "chunked_list": ["'''\nInitialization of the pipeline:\n- Load parameters from params.yaml\n- Argument parsing\n- Signac initialization\n- Initialization of distributed training\n'''\nimport argparse\nimport datetime\nimport json", "import datetime\nimport json\nimport os\nimport pprint\nimport shutil\nimport sys\nimport time\nimport warnings\nfrom pathlib import Path\n", "from pathlib import Path\n\nimport dgl\nimport numpy as np\nimport signac\nimport torch\nimport torch.distributed as dist\nimport yaml\n\nfrom .utils import vscode_debug", "\nfrom .utils import vscode_debug\nfrom .SessionMgr import EvalMetrics, ResultFiles\n\n\ndef parse_args():\n    '''\n    - Load arguments from params.yaml and parse arguments.\n    - Initialize of signac job and distributed training.\n\n    Returns:\n        args: Namespace object containing all arguments.\n    '''\n    parser = argparse.ArgumentParser(description='Variant Graph Auto Encoder')\n    # The arguments defined below are NOT comprehensive, \n    # The full list of arguments are defined in params.yaml\n    parser.add_argument(\"model\", type=str)\n    parser.add_argument('--dataset', type=str,\n                        default='ogbl-citation2', help='Dataset string.')\n    parser.add_argument('--lr', '--learning_rate', type=float,\n                        default=0.01, help='Initial learning rate.')\n    parser.add_argument('--grad_clip_norm', type=float, default=0.0)\n    parser.add_argument('--grad_clip_since', type=float, default=1.0)\n    parser.add_argument('--n_epochs', type=int, default=10,\n                        help='Number of epochs to train.')\n    parser.add_argument('--gpu', type=int, default=0, help='GPU id to use.')\n    parser.add_argument('--num_workers', type=int, default=2)\n    parser.add_argument('--use_self_loops', action=\"store_true\")\n    parser.add_argument('--no_training_neg', action=\"store_true\")\n    parser.add_argument('--batch_size', type=int,\n                        nargs=\"+\", default=[8192, 512])\n    parser.add_argument('--eval_every', type=float,\n                        nargs=\"+\", default=[0.5, 1])\n    parser.add_argument('--save_every', type=int, default=20)\n    parser.add_argument('--clear_cache_every', type=int, default=10)\n    parser.add_argument('--eval_metrics', type=str, nargs=\"+\", default=[\"MRR\"])\n    parser.add_argument('--result_path', type=str, default=\"results/{model}/\")\n    parser.add_argument('--random_seed', type=int, default=45342)\n    parser.add_argument('--use_gpu', type=bool, default=True)\n    parser.add_argument('--use_signac', type=bool, default=True)\n    parser.add_argument('--signac_override', action=\"store_true\")\n    parser.add_argument('--signac_gather_id', type=str, default=None)\n    parser.add_argument('--debug', action=\"store_true\")\n    args = parser.parse_args()\n\n    # Load parameters from params.yaml\n    with open(\"params.yaml\", \"r\") as fd:\n        params = yaml.safe_load(fd)\n\n    args.debug = params[\"debug\"]\n    args.signac_override = params[\"signac_override\"]\n    args.signac_gather_id = params.get(\"signac_gather_id\", None)\n\n    if args.debug:\n        vscode_debug()\n        breakpoint()\n        args.num_workers = 0\n\n    args.distributed = params[\"distributed\"][\"mode\"]\n    args.world_size = params[\"distributed\"][\"world_size\"]\n    args.dist_backend = params[\"distributed\"][\"backend\"]\n    if params[\"distributed\"][\"rank\"] is None:\n        args.dist_rank = int(os.environ[\"RANK\"])\n    else:\n        args.dist_rank = params[\"distributed\"][\"rank\"]\n    args.dist_gpu_list = params[\"distributed\"][\"gpu\"]\n    if args.distributed is not None:\n        dist_initialize_(args, params)\n    \n    for key, val in params[\"train\"].items():\n        setattr(args, key, val)\n    for key, val in params[\"models\"][args.model].items():\n        setattr(args, key, val)\n    args.dataset_params = params[\"datasets\"][args.dataset]\n    for i in range(2):\n        if args.batch_size[i] is None:\n            args.batch_size[i] = args.dataset_params[\"batch_size\"][i]\n    common_args = set(params[\"models\"][args.model].keys()) & set(\n        params[\"train\"].keys())\n    if len(common_args) > 0:\n        warnings.warn(\n            f\"These training arguments are overwritten by {args.model} arguments: {common_args}\")\n    args.eval_clear_cache_every = params[\"models\"][args.model].get(\n        \"eval_clear_cache_every\", 0)\n    if args.model_params.get(\"n_layers\", None) is None:\n        args.model_params[\"n_layers\"] = len(args.model_params[\"hidden_dims\"])\n\n    args.tqdm_msg = params.get(\"tqdm_msg\", None)\n    if args.tqdm_msg is None:\n        args.tqdm_msg = dict()\n\n    if args.use_signac:\n        args.result_path_final = Path(\n            args.result_path.format(model=args.model))\n        args.result_path_final.mkdir(parents=True, exist_ok=True)\n\n        # Get project not sandboxed by DVC\n        args.rootpath = os.getcwd().split(\"/.dvc\", maxsplit=1)[0]\n        args.project = signac.get_project(args.rootpath)\n        spDict = dict(\n            model=args.model,\n            model_params=params[\"models\"][args.model],\n            train_params=params[\"train\"],\n            dataset_params=params[\"datasets\"][params[\"train\"][\"dataset\"]],\n            debug=args.debug,\n            pkg_version=dict(\n                torch=torch.__version__,\n                dgl=dgl.__version__\n            )\n        )\n        if args.distributed is not None: # Distributed training\n            spDict[\"dist_params\"] = {\n                \"mode\": args.distributed,\n                \"world_size\": params[\"distributed\"][\"world_size\"],\n                \"backend\": args.dist_backend,\n                \"rank\": args.dist_rank,\n                **args.distributed_params\n            }\n        elif type(args.gpu) == list: # Multi-GPU training\n            spDict[\"dist_params\"] = {\n                \"mode\": \"MultiGPU\",\n                \"world_size\": len(args.gpu),\n                \"rank\": 0\n            }\n        args.signac_job = args.project.open_job(spDict)\n        if args.signac_gather_id:\n            with open(args.signac_gather_id, \"a\") as f:\n                f.write(f\"{args.signac_job.id}\\n\")\n       \n        # Check if a job with the same signac statepoint has succeeded before\n        # If so, skip or override the job based on the signac_override flag\n        dvc_pointer_file = (Path(args.project.workspace()) / f\".{args.signac_job.id}.dvc\")\n        has_success = None\n\n        if dvc_pointer_file.exists():\n            print(f\"Loading job information from {dvc_pointer_file}\")\n            with open(dvc_pointer_file, \"r\") as fd:\n                dvc_content = yaml.safe_load(fd)[\"outs\"]\n            if len(dvc_content) == 1:\n                for item in dvc_content:\n                    job_info = json.loads(item[\"desc\"])\n                    has_success = job_info[\"doc\"].get(\"success\", None)\n        \n        if has_success is None:\n            args.signac_job.init()\n            has_success = args.signac_job.doc.get(\"success\", None)\n        \n        if has_success:\n            if args.signac_override is True:\n                warnings.warn(\n                    f\"Job {args.signac_job.id} is already succeeded and will be overwritten in 10s!\")\n                time.sleep(10)\n                warnings.warn(\n                    f\"Reset job {args.signac_job.id}...\")\n                args.signac_job.reset()\n                if dvc_pointer_file.exists():\n                    dvc_pointer_file.unlink()\n            else:\n                print(\n                    f\"***{args.signac_job.id} has already succeeded. Using existing results.\")\n                file_list = list(ResultFiles)\n                for item in file_list:\n                    src_path = str(Path(args.signac_job.ws) / item.value)\n                    dst_path = str(args.result_path_final / item.value)\n                    shutil.copy2(src_path, dst_path)\n                sys.exit(0)\n        elif has_success == False:\n            if args.signac_override is None or args.signac_override == \"status_only\":\n                print(\n                    f\"***Job {args.signac_job.id} has failed!\")\n                sys.exit(1)\n            args.signac_job.reset()\n        elif args.signac_override == \"status_only\":\n            print(\n                f\"***Job {args.signac_job.id} does not exist!\")\n            sys.exit(1)\n        args.signac_job.init() \n        args.signac_job.doc.success = False\n\n        args.result_path = Path(args.signac_job.ws)\n        print(f\"Using signac workspace: {args.signac_job.id}\")\n    else:\n        args.result_path_final = None\n        args.result_path = Path(args.result_path.format(model=args.model))\n        args.result_path.mkdir(parents=True, exist_ok=True)\n\n    for i in range(len(args.eval_metrics)):\n        args.eval_metrics[i] = getattr(EvalMetrics, args.eval_metrics[i])\n\n    # Set all random seeds\n    torch.manual_seed(args.random_seed)\n    np.random.seed(args.random_seed)\n\n    print(\"Parameters:\")\n    pprint.pprint(vars(args))\n    return args", "\n\ndef dist_initialize_(args_, params_):\n    '''\n    Initialize distributed training and synchronize arguments\n\n    Args:\n        args_ (argparse.Namespace): \n            Namespace of arguments, will be modified in place.\n        params_ (dict): \n            Dictionary of parameters loaded from `params.yaml`,\n            will be modified in place.\n    '''\n    if args_.dist_rank >= args_.world_size:\n        raise ValueError(f\"Rank {args_.dist_rank} is too much for world size {args_.world_size}\")\n    print(f\"[Dist] Initializing distributed process group as rank {args_.dist_rank}...\")\n    dist.init_process_group(\n        args_.dist_backend, world_size=args_.world_size, rank=args_.dist_rank,\n        timeout=datetime.timedelta(minutes=45)\n    )\n    args_.dist_is_master = (dist.get_rank() == 0)\n    params_[\"train\"][\"gpu\"] = args_.dist_gpu_list\n\n    # Synchronize parameters\n    sync_list = [params_[\"train\"], params_[\"models\"], \n        params_[\"distributed\"][args_.distributed], params_[\"datasets\"]]\n    if args_.dist_is_master:\n        print(\"[Dist] Synchronizing parameters to clients...\")\n        dist.broadcast_object_list(sync_list)\n        args_.distributed_params = sync_list[2]\n        params_[\"train\"][\"gpu\"] = params_[\"train\"][\"gpu\"][dist.get_rank()]\n    else:\n        params_list = [None] * len(sync_list)\n        print(\"[Dist] Synchronizing parameters with server...\")\n        dist.broadcast_object_list(params_list)\n        \n        for key, value in params_list[0].items():\n            params_[\"train\"][key] = value\n        params_[\"train\"][\"gpu\"] = params_[\"train\"][\"gpu\"][dist.get_rank()]\n        params_[\"models\"] = params_list[1]\n        args_.distributed_params = params_list[2]\n        params_[\"datasets\"] = sync_list[3]", "\n\n"]}
{"filename": "src/pipelines/SessionMgr.py", "chunked_list": ["'''\nCode for managing training and evaluation session.\n'''\n\nimport gc\nimport pprint\nimport time\nimport datetime\nfrom collections import deque\nfrom enum import Enum", "from collections import deque\nfrom enum import Enum\nfrom multiprocessing import Process, Value\nfrom string import capwords\nfrom typing import Literal\n\nimport dgl\nimport numpy as np\nimport pandas\nimport torch", "import pandas\nimport torch\nimport tqdm\nimport yaml\n\nfrom .Evaluation import NodeBatchEvaluator, EvalMetrics, EvalMetricsCalc\nfrom ..dataloading.DataMgr import DataMgr\nfrom ..distributed.AvgCluster import AvgCluster\nfrom ..distributed.MultiGPU import MultiGPUTrainer\nfrom ..samplers import ClusterGCN", "from ..distributed.MultiGPU import MultiGPUTrainer\nfrom ..samplers import ClusterGCN\nfrom .utils import (CustomDistributedDataParallel, SharedMemCollateWrapper,\n                    get_gpu_usage, get_peak_mem, parse_timedelta, write_csv)\n\n# Correspond `nhood_sampler.name` in `params.yaml` to underlying sampler class\nnhoodSamplerDict = {\n    \"MultiLayerFullNeighborSampler\": dgl.dataloading.MultiLayerFullNeighborSampler,\n    \"MultiLayerNeighborSampler\": dgl.dataloading.MultiLayerNeighborSampler\n}", "    \"MultiLayerNeighborSampler\": dgl.dataloading.MultiLayerNeighborSampler\n}\n# Correspond `nhood_sampler.name` in `params.yaml` to underlying dataloader class\ndataLoaderDict = {\n    \"ClusterGCNEdgeDataLoader\": ClusterGCN.ClusterGCNEdgeDataLoader\n}\n# Correspond `neg_sampler.name` in `params.yaml` to underlying negative sampler class\nnegSamplerDict = {\n    \"Uniform\": dgl.dataloading.negative_sampler.Uniform\n}", "    \"Uniform\": dgl.dataloading.negative_sampler.Uniform\n}\n\n\nclass SessionMgr:\n    '''\n    Manage training and evaluation session.\n    '''\n    def __init__(self, args, datamgr, device,\n                 stats_dict=dict(), distmgr=None) -> None:\n        '''\n        Parameters:\n        -----------\n        args: argparse.Namespace\n            Parsed arguments. \n        datamgr: DataMgr\n            Data manager.\n        device: torch.device\n            Device to use.\n        stats_dict: dict\n            Dictionary to store statistics.\n        distmgr: DistMgr\n            Distributed manager.\n        '''\n        self.args = args\n        self.stats_dict = stats_dict\n        self.datamgr = datamgr\n        self.distmgr = distmgr\n        self.device = device\n\n        self.dataloader = None\n        self.valid_evaluator = None\n        self.test_evaluator = None\n\n        self.epoch_progress : tqdm.tqdm = None\n        self.step_progress : tqdm.tqdm = None\n        self.postfix_dict_step = dict()\n        self.eval_every = None  # (step_list, iter_mod_list, iter_list)\n\n        self.iter_count = 0\n        self.epoch = None\n        self.step = None\n        self.t_start = time.time()\n        self.t_train = 0\n        self.t_step = time.time()\n        self.t_preprocess = 0\n        self.stats_dict = stats_dict\n        self.checkpoint_dict = dict()\n        self.model_at_best = None\n        self.start_gpu_daemon()\n        self._max_gpu_vram = 0.0\n\n        self.time_limit = parse_timedelta(args.time_limit)\n        print(f\"Training time is limited to {self.time_limit}\")\n        self.is_stopping = False\n\n    def __del__(self):\n        self.stop_gpu_daemon()\n\n    def start_gpu_daemon(self):\n        '''\n        Start GPU daemon to monitor GPU VRAM usage.\n        '''\n        self.__gpu_daemon_flag = Value(\"b\", 1)\n        self.__gpu_vram = Value(\"d\", 0.0)\n\n        if hasattr(self.distmgr, \"used_gpu_list\"):\n            glist = self.distmgr.used_gpu_list\n        else:\n            glist = self.args.gpu\n        \n        if type(glist) is not list:\n            gpu_list = [glist]\n        else:\n            gpu_list = glist\n        \n        self.gpu_daemon = Process(\n            target=get_gpu_usage, \n            args=(self.__gpu_daemon_flag, self.__gpu_vram, gpu_list),\n            daemon=True, name=\"GPU-monitor\")\n        self.gpu_daemon.start()\n    \n    def stop_gpu_daemon(self):\n        '''\n        Stop GPU daemon.\n        '''\n        if self.gpu_daemon.is_alive():\n            self.__gpu_daemon_flag.value = 0\n            self.gpu_daemon.join()\n\n    def create_train_data_loader(self, use_ddp=False):\n        '''\n        Create train data loader.\n        \n        Arguments:\n        ----------\n        use_ddp: bool, default False\n            Set to True if using MultiGPU training.\n        '''\n        args = self.args\n        train_sampler_args = args.nhood_sampler[0]\n\n        for s_args in (train_sampler_args, ):\n            if s_args[\"params\"].get(\"n_layers\", False) is None:\n                s_args[\"params\"][\"n_layers\"] = args.model_params[\"n_layers\"]\n\n        # Construct train data loader\n        negative_sampler = negSamplerDict[args.neg_sampler[\"name\"]](\n            **args.neg_sampler[\"params\"])\n        scope = locals()\n        train_sampler_args[\"params\"] = {\n            (key[5:] if key.startswith(\"eval_\") else key):\n            (eval(value, globals(), scope) if key.startswith(\"eval_\") else value)\n            for key, value in train_sampler_args[\"params\"].items()\n        }\n        if train_sampler_args[\"name\"] in nhoodSamplerDict:\n            train_nhood_sampler = nhoodSamplerDict[train_sampler_args[\"name\"]](\n                **train_sampler_args[\"params\"])\n            if isinstance(train_nhood_sampler, dgl.dataloading.BlockSampler):\n                train_nhood_sampler = dgl.dataloading.as_edge_prediction_sampler(\n                    train_nhood_sampler, negative_sampler=negative_sampler\n                )\n            \n            # Downsample training set if needed\n            if self.datamgr.train_frac < 1.0 and type(self.distmgr) != MultiGPUTrainer:\n                print(f\"Sampling training edges using fraction {self.train_frac}...\")\n                self.datamgr.train_edge_idx = DataMgr.sample_idx(\n                    self.datamgr.train_edge_idx, self.datamgr.train_frac, \n                    self.datamgr.random_seed)\n\n            dataloader = dgl.dataloading.EdgeDataLoader(\n                self.datamgr.train_graph, self.datamgr.train_edge_idx,\n                train_nhood_sampler,\n                device=self.device, batch_size=args.batch_size[0],\n                shuffle=True, drop_last=False,\n                num_workers=args.num_workers,\n                use_uva=False, use_ddp=use_ddp,\n                ddp_seed=self.datamgr.random_seed\n            )\n\n        elif train_sampler_args[\"name\"] in dataLoaderDict:\n            dataLoaderCls = dataLoaderDict[train_sampler_args[\"name\"]]\n            dataloader_kwargs = dict(\n                negative_sampler=negative_sampler,\n                device=self.device, shuffle=True, drop_last=False,\n                num_workers=args.num_workers, use_uva=False,\n                use_ddp=use_ddp, **train_sampler_args[\"params\"]\n            )\n            if (dataLoaderCls == dataLoaderDict[\"ClusterGCNEdgeDataLoader\"]\n                and type(self.datamgr) is AvgCluster):\n                dataloader_kwargs[\"_graph_sampler\"] = self.datamgr.cluster_sampler\n                dataloader_kwargs[\"train_frac_sample\"] = (self.datamgr.train_frac, \n                    self.datamgr.random_seed)\n                \n            dataloader = dataLoaderCls(\n                self.datamgr.train_graph,\n                **dataloader_kwargs\n            )\n        else:\n            raise ValueError(\n                f\"Unknown train sampler {train_sampler_args['name']}.\")\n        \n        # Allow DDP dataloader to load graph from shared memory\n        if type(self.distmgr) == MultiGPUTrainer:\n            if self.datamgr.multigpu_train_graph_name is not None:\n                dataloader.collate_fn = SharedMemCollateWrapper(\n                    dataloader.collate_fn.sample_func,\n                    self.datamgr.multigpu_train_graph_name,\n                    self.datamgr.multigpu_shared_ndata,\n                    self.datamgr.multigpu_shared_edata\n                )\n        self.dataloader = dataloader\n        if hasattr(dataloader, \"step_per_epoch\"):\n            self.step_per_epoch = dataloader.step_per_epoch\n            self.unit_step_progress = True\n            if type(self.distmgr) == MultiGPUTrainer:\n                self.step_per_epoch = np.ceil(\n                    self.step_per_epoch / self.distmgr.trainer_size)\n        else:\n            if type(self.distmgr) == MultiGPUTrainer:\n                self.step_per_epoch = np.ceil(\n                    self.datamgr.train_edge_idx.shape[0] / args.batch_size[0] / self.distmgr.trainer_size)\n                self.unit_step_progress = True\n            else:\n                self.step_per_epoch = np.ceil(\n                    self.datamgr.train_edge_idx.shape[0] / args.batch_size[0])\n                self.unit_step_progress = False\n        \n        self.t_preprocess += getattr(self.dataloader, \"preprocess_time\", 0.0)\n\n    def create_evaluator(self, target: Literal[\"valid\", \"test\"] = \"valid\"):\n        '''\n        Create evaluator for validation or test set.\n        '''\n        args = self.args\n        if len(args.nhood_sampler) > 1:\n            eval_sampler_args = args.nhood_sampler[1]\n        else:\n            eval_sampler_args = None\n        if eval_sampler_args is not None:\n            eval_nhood_sampler = nhoodSamplerDict[eval_sampler_args[\"name\"]](\n                **eval_sampler_args[\"params\"])\n        else:\n            eval_nhood_sampler = dgl.dataloading.MultiLayerFullNeighborSampler(1)\n\n        if target == \"valid\":\n            eval_edges = self.datamgr.valid_edge\n            save_embed = False\n            graph = self.datamgr.train_graph\n        \n        elif target == \"test\":\n            eval_edges = self.datamgr.test_edge\n            save_embed = self.datamgr.save_embed\n            if self.datamgr.val_use_val_edges:\n                graph = self.datamgr.graph\n            else:\n                graph = self.datamgr.train_graph\n        \n        evaluator = NodeBatchEvaluator(\n            self, graph, eval_edges,\n            batch_size=args.batch_size[1],\n            nhood_sampler=eval_nhood_sampler,\n            batch_device=self.device,\n            graph_device=None, shuffle=True, drop_last=False,\n            num_workers=0, save_embed=save_embed,\n            clear_cache_every=args.eval_clear_cache_every\n        )\n        if getattr(self.datamgr, \"use_feat_loader\", False):\n            evaluator.feature_loader = self.datamgr.feature_loader\n\n        if target == \"valid\":\n            self.valid_evaluator = evaluator\n        elif target == \"test\":\n            self.test_evaluator = evaluator\n        else:\n            raise ValueError(f\"Unknow target {target} for evaluator\")\n\n        return evaluator\n\n    def create_model(self, create_optimizer=True, inplace=True, use_ddp=False, \n                     ddp_device=None, ddp_proc_group=None):\n        '''\n        Create model and optimizer.\n\n        Arguments\n        ----------\n        create_optimizer : bool\n            Whether to create optimizer.\n        inplace : bool\n            Whether to modify the self.model and self.optimizer in place.\n        use_ddp : bool\n            Must be True if using MultiGPU training.\n        ddp_device : int\n            Device ID for DDP. Must be set if using MultiGPU training.\n        ddp_proc_group : torch.distributed.ProcessGroup\n            Process group for DDP. Must be set if using MultiGPU training.\n        '''\n        from ..models import modelDict\n\n        # create model\n        args = self.args\n        ModelClass = modelDict[args.model] # type: torch.nn.Module\n        model = ModelClass(\n            self.datamgr.in_dim, \n            device=self.device, \n            dtype=self.datamgr.feat_dtype,\n            n_relations=getattr(self.datamgr, \"n_relations\", 1),\n            n_nodetypes=getattr(self.datamgr, \"n_nodetypes\", 1),\n            **args.model_params) # type: BaseLinkEncoderDecoder\n        model = model.to(self.device)\n        print(\"Model created:\")\n        print(model)\n        if use_ddp:\n            model = CustomDistributedDataParallel(\n                model, device_ids=[ddp_device], output_device=ddp_device, \n                process_group=ddp_proc_group)\n        if inplace:\n            print('Total Parameters:', model.num_model_params)\n            self.model = model\n\n        if create_optimizer:\n            # create training component\n            optimizer = torch.optim.Adam(self.model.parameters(), lr=args.lr)\n            if inplace:\n                self.optimizer = optimizer\n            return model, optimizer\n        else:\n            if inplace:\n                self.optimizer = None\n            return model\n\n    def create_stats_dict(self):\n        '''\n        Create dictionary for storing training and evaluation statistics.\n        '''\n        self.stats_dict = dict(\n            metrics=dict(\n                train_stats=dict(), valid_stats=dict(), \n                test_stats=dict(), \n                preprocess_stats=getattr(self.dataloader, \"preprocess_stats\", dict()),\n                best_stats={self.args.eval_metrics[0].value: None},\n                model_stats={\"Total Params\": self.model.num_model_params}),\n            train_stats=deque(),\n            valid_stats=deque()\n        )\n        return self.stats_dict\n\n    @property\n    def enable_eval(self):\n        '''\n        Check if evaluation should be enabled in this process.\n        '''\n        if hasattr(self.distmgr, \"enable_eval\"):\n            return self.distmgr.enable_eval\n        else:\n            return True\n\n    def is_eval_point(self, reset_eval_point=False):\n        '''\n        Check if evaluation should be performed at this time.\n        '''\n        if (self.distmgr is not None) and not self.enable_eval:\n            return False\n        \n        if (self.eval_every is None) or reset_eval_point:\n            args = self.args\n\n            if type(args.eval_every) is str:\n                self.eval_every = parse_timedelta(args.eval_every)\n                self.t_eval = time.time()\n            else:\n                step_list = []\n                iter_mod_list = []\n                iter_list = []\n                for _, value in enumerate(args.eval_every):\n                    if type(value) is str:\n                        new_value_list = np.array(eval(value))\n                        new_value_list = np.ceil(\n                            self.step_per_epoch * new_value_list).astype(int)\n                        iter_list.extend(new_value_list)\n                    else:\n                        new_value = int(np.ceil(value * self.step_per_epoch))\n                        if value <= 1:\n                            step_list.append(new_value)\n                        else:\n                            iter_mod_list.append(new_value)\n                self.eval_every = [np.array(step_list), np.array(\n                    iter_mod_list), np.array(iter_list)]\n                print(\"Evaluation config:\")\n                pprint.pprint(self.eval_every)\n\n        if self.is_stopping:\n            return True\n        \n        if type(self.eval_every) is datetime.timedelta:\n            if time.time() - self.t_eval > self.eval_every.total_seconds():\n                self.t_eval = time.time()\n                return True\n            else:\n                return False\n        \n        if self.step is not None:\n            return (self.step in self.eval_every[0]\n                    or (np.mod(self.iter_count, self.eval_every[1]) == 0).any()\n                    or self.iter_count in self.eval_every[2])\n\n    def reset_timer(self):\n        '''\n        Reset timer for training.\n        '''\n        self.t_start = time.time()\n        self.t_train = 0\n        self.t_step = time.time()\n\n    def add_timer(self, delta:float):\n        '''\n        Add time to timer for training.\n        \n        Arguments\n        ---------\n        delta : float\n            Time to add in seconds.\n        '''\n        self.t_start -= delta\n        self.t_train += delta\n\n    def run_pre_train_hooks(self, epoch, step, iter_count=None):\n        '''\n        Run pre-train hooks:\n        - Update epoch, step and iteration count.\n        - Run registered pre-train hooks in distributed manager.\n        - Check if training should be stopped.\n\n        Arguments\n        ---------\n        epoch : int\n            Current epoch count.\n        step : int\n            Current step count in the current epoch.\n        iter_count : int\n            Current iteration (step) count since the beginning of training.\n        '''\n        self.epoch = epoch\n        self.step = step\n        if iter_count is None:\n            self.iter_count += 1\n        else:\n            self.iter_count = iter_count\n        \n        if self.distmgr:\n            self.distmgr.run_pre_train_hooks(self)\n        elif time.time() - self.t_start > self.time_limit.total_seconds():\n            self.is_stopping = True\n\n    def train_step(self, pos_graph, neg_graph, blocks):\n        '''\n        Run a training step on provided graph data.\n\n        Arguments\n        ---------\n        pos_graph : dgl.DGLGraph\n            Graph with edges as positive link prediction targets\n        neg_graph : dgl.DGLGraph\n            Graph with edges as negative link prediction targets\n        blocks : list of dgl.DGLGraph\n            List of graphs (or blocks) for message passing on each GNN layer.\n            The length of the list should be equal to the number of GNN layers.\n        '''\n        args = self.args\n\n        # Add edge types to negative graph for heterogeneous decoder\n        if self.model.hg_decoder and dgl.ETYPE not in neg_graph.edata:\n            if args.neg_sampler[\"name\"] in [\"PerSourceUniform\", \"Uniform\"]:\n                neg_graph.edata[dgl.ETYPE] = pos_graph.edata[dgl.ETYPE].repeat_interleave(\n                        args.neg_sampler[\"params\"][\"k\"]\n                    )\n            else:\n                etypes = pos_graph.edata[dgl.ETYPE]\n                rnd_ind = torch.randint(\n                    etypes.shape[0], (neg_graph.num_edges(),), \n                    device=neg_graph.device)\n                neg_graph.edata[dgl.ETYPE] = etypes[rnd_ind]\n        \n        if args.no_training_neg:\n            remove_neg_edges_in_training_(self.train_graph, neg_graph, pos_graph)\n        \n        if getattr(self.datamgr, \"use_feat_loader\", False):\n            x = self.datamgr.feature_loader(next(iter(blocks)))\n        else:\n            x = next(iter(blocks)).srcdata[\"feat\"]\n\n        neg_graph = dgl.remove_self_loop(neg_graph)\n\n        # Training - forward\n        self.model.train()\n\n        pos_logits, neg_logits = self.model.forward(blocks, x, pos_graph, neg_graph)\n        loss = self.model.loss_fn(pos_graph, neg_graph, pos_logits, neg_logits)\n\n        return pos_logits, neg_logits, loss\n\n    def get_save_embed_callback(self, target, model):\n        '''\n        Obtain a callback function for saving node embeddings.\n        The actual callback function to save embeddings should be defined in Data Manager.\n\n        Arguments:\n        ----------\n        target : str, \"test\", \"best\"\n            Name of the model parameter set to save embeddings from.\n            Used to name the saved embedding file.\n        model : nn.Module\n            Model to save embeddings from.\n        '''\n        def callback():\n            if self.test_evaluator.node_embedding is not None:\n                embedding = self.test_evaluator.node_embedding\n                graph = self.test_evaluator.graph\n                save_folder = self.args.result_path / \"embed\"\n                if self.datamgr.save_embed_callback is not None:\n                    self.datamgr.save_embed_callback(\n                        self, embedding, graph, model, target, save_folder)\n                    self.test_evaluator.node_embedding = None\n            return False\n        return callback\n\n    def run_evaluation(self, target: Literal[\"valid\", \"test\", \"best\"] = \"valid\", \n                       alt_epoch=None, model=None, callback=None):\n        '''\n        Run evaluation on validation or test set. \n\n        Arguments\n        ---------\n        target : str, \"valid\", \"test\", \"best\"\n            Set of data to evaluate on.\n            When \"best\", the model with the best validation MRR will be restored\n            and used to evaluate on test set.\n        alt_epoch : int\n            Epoch count to record in evaluation.\n            If None, the current epoch count recorded in the session will be used.\n        model : nn.Module\n            Model to evaluate.\n            If None, the model in the session will be used.\n        callback : function\n            Callback function to run during evaluation.\n        '''\n        args = self.args\n        if model is None:\n            model = self.model\n        \n        self.stats_dict[\"metrics\"][\"preprocess_stats\"][\"Time\"] = self.t_preprocess\n        write_stats(args, self.stats_dict, train_stats=True, metrics=True)\n\n        if target == \"valid\":\n            self.write(\"[Evaluation] Running evaluation on validation set...\")\n            self.reset_peak_memory_stats()\n\n            result_dict = dict()\n            if self.epoch is not None and self.step is not None:\n                result_dict[EvalMetrics.EPOCH] = self.epoch\n                result_dict[EvalMetrics.STEP] = self.step\n                self.postfix_dict_step[\"Last Eval\"] = f\"{self.epoch}-{self.step}\"\n            result_dict[EvalMetrics.TRAINING_TIME] = self.t_train\n            result_dict[EvalMetrics.TOTAL_TIME] = time.time() - self.t_start\n            evaluator = self.valid_evaluator\n            eval_dict = evaluator(model, args.eval_metrics, callback=callback)\n            result_dict.update(eval_dict)\n            if args.use_gpu:\n                result_dict[EvalMetrics.GPU_VRAM] = self.max_gpu_vram\n            result_str = EvalMetricsCalc.format_str(result_dict)\n            result_str = \" | \".join(result_str).strip()\n            if alt_epoch:\n                result_dict[EvalMetrics.EPOCH] = alt_epoch\n                result_str = f\"{EvalMetrics.EPOCH.value} {alt_epoch:.2f} | {result_str}\"\n                self.postfix_dict_step[\"Last Eval\"] = alt_epoch\n            self.write(f\"[Validation results] {result_str}\")\n            if EvalMetrics.LOSS in self.metrics[\"train_stats\"]:\n                result_dict.update({\n                    EvalMetrics.LOSS: self.metrics[\"train_stats\"][EvalMetrics.LOSS.value]\n                })\n            result_dict[EvalMetrics.ITER] = self.iter_count\n            result_dict[EvalMetrics.RAM] = get_peak_mem()\n            self.postfix_dict_step.update(\n                EvalMetricsCalc.format_str(eval_dict, as_dict=True)\n            )\n            result_dict = {key.value: value for key, value in result_dict.items()}\n            self.stats_dict[\"valid_stats\"].append(\n                pandas.Series(result_dict))\n            self.stats_dict[\"metrics\"][\"valid_stats\"] = result_dict\n\n            # Update best stats\n            prev_best = self.stats_dict[\"metrics\"][\"best_stats\"][args.eval_metrics[0].value]\n            if prev_best is None or result_dict[args.eval_metrics[0].value] > prev_best:\n                self.stats_dict[\"metrics\"][\"best_stats\"] = result_dict\n                new_best = result_dict[args.eval_metrics[0].value]\n                self.postfix_dict_step[f\"Best {args.eval_metrics[0].value}\"] = new_best\n                self.model_at_best = True\n            else:\n                self.model_at_best = False\n\n            write_stats(args, self.stats_dict, valid_stats=True, metrics=True)\n\n        elif target == \"test\":\n            self.reset_peak_memory_stats()\n\n            self.write(\"[Test] Running evaluation on test set using latest model...\")\n            if self.test_evaluator is None:\n                self.create_evaluator(\"test\")\n            \n            prev_stats = self.stats_dict[\"metrics\"][\"valid_stats\"].copy()\n            result_dict = self.test_evaluator(\n                model, args.eval_metrics, \n                callback=self.get_save_embed_callback(target, model)\n            )\n            if args.use_gpu:\n                result_dict[EvalMetrics.GPU_VRAM] = self.max_gpu_vram\n            result_dict[EvalMetrics.RAM] = get_peak_mem()\n            result_str = EvalMetricsCalc.format_str(result_dict)\n            result_str = \" | \".join(result_str).strip()\n            self.write(f\"[Test Results - Latest] {result_str}\")\n            result_dict = {key.value: value for key, value in result_dict.items()}\n            prev_stats.update(result_dict)\n            result_dict = prev_stats\n            self.stats_dict[\"metrics\"][\"test_stats\"][\"latest\"] = result_dict\n            pprint.pprint(result_dict)\n            write_stats(args, self.stats_dict, train_stats=False, valid_stats=False, metrics=True)\n\n        elif target == \"best\":\n            if self.model_at_best:\n                self.stats_dict[\"metrics\"][\"test_stats\"][\"best\"] = self.stats_dict[\"metrics\"][\"test_stats\"][\"latest\"]\n            else:\n                self.reset_peak_memory_stats()\n                self.write(\"[Test] Running evaluation on test set using the best model...\")\n                self.write(\"[Test] Loading checkpoint for the best model...\")\n                checkpoint = torch.load(self.checkpoint_dict[\"best\"])\n                model.load_state_dict(checkpoint[\"model_state_dict\"])\n                model.eval()\n\n                if self.test_evaluator is None:\n                    self.create_evaluator(\"test\")\n                prev_stats = self.stats_dict[\"metrics\"][\"best_stats\"].copy()\n                result_dict = self.test_evaluator(\n                    model, args.eval_metrics, \n                    callback=self.get_save_embed_callback(target, model)\n                )\n                if args.use_gpu:\n                    result_dict[EvalMetrics.GPU_VRAM] = self.max_gpu_vram\n                result_dict[EvalMetrics.RAM] = get_peak_mem()\n                result_str = EvalMetricsCalc.format_str(result_dict)\n                result_str = \" | \".join(result_str).strip()\n                print(f\"[Test Results - Best] {result_str}\")\n                \n                result_dict = {key.value: value for key, value in result_dict.items()}\n                prev_stats.update(result_dict)\n                result_dict = prev_stats\n                self.stats_dict[\"metrics\"][\"test_stats\"][\"best\"] = result_dict\n                pprint.pprint(result_dict)\n\n            write_stats(args, self.stats_dict, train_stats=False, valid_stats=False, metrics=True)\n        \n        self.reset_peak_memory_stats()\n        return self.model_at_best\n\n    def run_post_step_hooks(self):\n        '''\n        Run post step hooks registered by the distributed manager.\n        '''\n        if self.distmgr:\n            self.distmgr.run_post_step_hooks(self)\n\n    @staticmethod\n    def _save_checkpoints(args, model, optimizer, postfix=\"\", checkpoint_path=None, **kwargs):\n        '''\n        Utility function to save checkpoints to disk.\n        '''\n        if checkpoint_path is None:\n            if postfix != \"\":\n                postfix = \"-\" + postfix\n            checkpoint_file = \"checkpoint{}.pth\".format(postfix)\n            checkpoint_path = str(args.result_path / checkpoint_file)\n        filtered_kwargs = dict()\n        for key, value in kwargs.items():\n            if value is not None:\n                filtered_kwargs[key] = value\n        if optimizer is not None:\n            torch.save({\n                \"model_state_dict\": model.state_dict(),\n                \"optimizer_state_dict\": optimizer.state_dict(),\n                **filtered_kwargs\n            }, checkpoint_path)\n        else:\n            torch.save({\n                \"model_state_dict\": model.state_dict(),\n                **filtered_kwargs\n            }, checkpoint_path)\n        return checkpoint_path\n\n    def save_checkpoints(self, target: Literal[\"latest\", \"best\", \"local\"] = \"latest\", model=None):\n        '''\n        Save checkpoints to disk and store the its name and path in the checkpoint dictionary.\n\n        Arguments:\n        ----------\n        target: Literal[\"latest\", \"best\", \"local\"]\n            Name of the checkpoint to save.\n        model: torch.nn.Module\n            Model to save. If None, the model for current session will be saved.\n        '''\n        if model is None:\n            model = self.model\n        checkpoint_path = self._save_checkpoints(\n            self.args, model, self.optimizer, postfix=target, \n            epoch=self.epoch, step=self.step, iter=self.iter_count)\n        self.write(\n            f\"[Checkpoint] {capwords(target)} checkpoint saved to {checkpoint_path}\")\n        self.checkpoint_dict[target] = checkpoint_path\n        return checkpoint_path\n\n    def create_step_progress(self):\n        '''\n        Create a progress bar for the steps in the current epoch.\n        '''\n        if self.unit_step_progress:\n            self.step_progress = tqdm.tqdm(\n                total=self.step_per_epoch, \n                desc=\"Epoch Progress\", dynamic_ncols=True)\n        else:\n            self.step_progress = tqdm.tqdm(\n                total=len(self.datamgr.train_edge_idx), \n                desc=\"Epoch Progress\", dynamic_ncols=True)\n        return self.step_progress\n\n    def close_step_progress(self):\n        '''\n        Close the progress bar for the steps in the current epoch.\n        '''\n        self.step_progress.close()\n        self.step_progress = None\n\n    def clean_memory(self):\n        '''\n        Run garbage collection and empty GPU memory cache.\n        '''\n        gc.collect()\n        if self.args.use_gpu:\n            torch.cuda.empty_cache()\n\n    def write(self, string):\n        '''\n        Print a string to the console in a way that is compatible with the progress bars.\n        '''\n        if self.step_progress is not None:\n            self.step_progress.write(string)\n        elif self.epoch_progress is not None:\n            self.epoch_progress.write(string)\n        else:\n            print(string)\n\n    def signac_mark_success(self):\n        '''\n        Mark the current signac job as successful.\n        '''\n        if self.args.use_signac:\n            self.args.signac_job.doc.success = True\n\n    @property\n    def metrics(self):\n        return self.stats_dict[\"metrics\"]\n    \n    @property\n    def signac_job(self):\n        return self.args.signac_job\n\n    @property\n    def gpu_vram(self):\n        '''\n        Get the latest recorded GPU VRAM usage.\n        '''\n        if self.gpu_daemon.is_alive():\n            return self.__gpu_vram.value\n        elif self.gpu_daemon is not None:\n            return float('nan')\n    \n    @property\n    def max_gpu_vram(self):\n        '''\n        Update and get the maximum GPU VRAM usage ever recorded.\n        '''\n        current_gpu_varm = self.gpu_vram\n        if np.isnan(current_gpu_varm):\n            return current_gpu_varm\n        if self.gpu_vram > self._max_gpu_vram:\n            self._max_gpu_vram = current_gpu_varm\n        return self._max_gpu_vram\n    \n    @max_gpu_vram.setter\n    def max_gpu_vram(self, value):\n        self._max_gpu_vram = value\n    \n    def reset_peak_memory_stats(self):\n        '''\n        Reset the maximum GPU VRAM usage ever recorded.\n        '''\n        self.max_gpu_vram = 0.0\n        torch.cuda.reset_peak_memory_stats()\n    \n    @property\n    def rank(self):\n        '''\n        Get the rank of the current process in distributed cluster from the distributed manager.\n        '''\n        if self.distmgr is None:\n            return None\n        else:\n            return self.distmgr.rank", "\nclass ResultFiles(Enum):\n    '''\n    Name of files that will be created to save the results.\n    '''\n    METRICS = \"metrics.yaml\"\n    TRAIN_STATS = \"train_stats.csv\"\n    VALID_STATS = \"valid_stats.csv\"\n\n\ndef write_stats(args, stats_dict,\n                train_stats=False, valid_stats=False, metrics=False):\n    '''\n    Write the statistics to disk.\n\n    Arguments:\n    ----------\n    args: argparse.Namespace\n        Parsed arguments.\n    stats_dict: dict\n        Statistics dictionary of the session.\n    train_stats: bool\n        Whether to write the training statistics to disk.\n    valid_stats: bool\n        Whether to write the validation statistics to disk.\n    metrics: bool\n        Whether to write the metrics to disk.\n    '''\n    if metrics:\n        with open(args.result_path / ResultFiles.METRICS.value) as f:\n            yaml.dump(stats_dict[\"metrics\"], f)\n        if args.use_signac:\n            args.signac_job.doc.metrics = stats_dict[\"metrics\"]\n\n    if train_stats:\n        train_stats_df = pandas.DataFrame(\n            stats_dict[\"train_stats\"])\n        if EvalMetrics.ITER.value in train_stats_df.columns:\n            train_stats_df.set_index(EvalMetrics.ITER.value, inplace=True)\n        write_csv(train_stats_df, args.result_path /\n                  ResultFiles.TRAIN_STATS.value)\n\n    if valid_stats:\n        valid_stats_df = pandas.DataFrame(\n            stats_dict[\"valid_stats\"])\n        if EvalMetrics.ITER.value in valid_stats_df.columns:\n            valid_stats_df.set_index(EvalMetrics.ITER.value, inplace=True)\n        write_csv(valid_stats_df, args.result_path /\n                  ResultFiles.VALID_STATS.value)", "\n\ndef write_stats(args, stats_dict,\n                train_stats=False, valid_stats=False, metrics=False):\n    '''\n    Write the statistics to disk.\n\n    Arguments:\n    ----------\n    args: argparse.Namespace\n        Parsed arguments.\n    stats_dict: dict\n        Statistics dictionary of the session.\n    train_stats: bool\n        Whether to write the training statistics to disk.\n    valid_stats: bool\n        Whether to write the validation statistics to disk.\n    metrics: bool\n        Whether to write the metrics to disk.\n    '''\n    if metrics:\n        with open(args.result_path / ResultFiles.METRICS.value) as f:\n            yaml.dump(stats_dict[\"metrics\"], f)\n        if args.use_signac:\n            args.signac_job.doc.metrics = stats_dict[\"metrics\"]\n\n    if train_stats:\n        train_stats_df = pandas.DataFrame(\n            stats_dict[\"train_stats\"])\n        if EvalMetrics.ITER.value in train_stats_df.columns:\n            train_stats_df.set_index(EvalMetrics.ITER.value, inplace=True)\n        write_csv(train_stats_df, args.result_path /\n                  ResultFiles.TRAIN_STATS.value)\n\n    if valid_stats:\n        valid_stats_df = pandas.DataFrame(\n            stats_dict[\"valid_stats\"])\n        if EvalMetrics.ITER.value in valid_stats_df.columns:\n            valid_stats_df.set_index(EvalMetrics.ITER.value, inplace=True)\n        write_csv(valid_stats_df, args.result_path /\n                  ResultFiles.VALID_STATS.value)", "\n\ndef remove_neg_edges_in_training_(train_graph, neg_graph_, pos_graph=None):\n    '''\n    Remove negative edges that are also present in the training graph.\n    This is done in place to `neg_graph_`.\n    '''\n    nu = neg_graph_.edges()[0]\n    nv = neg_graph_.edges()[1]\n    try:\n        u = neg_graph_.ndata[dgl.NID][nu].to(\"cpu\")\n        v = neg_graph_.ndata[dgl.NID][nv].to(\"cpu\")\n    except KeyError:\n        u = pos_graph.ndata[dgl.NID][nu].to(\"cpu\")\n        v = pos_graph.ndata[dgl.NID][nv].to(\"cpu\")\n    neg_train_overlap_bool = train_graph.has_edges_between(u, v)\n    neg_train_overlap = neg_train_overlap_bool.sum().item()\n    if neg_train_overlap > 0:\n        uu = nu[neg_train_overlap_bool]\n        vv = nv[neg_train_overlap_bool]\n        eids = neg_graph_.edge_ids(uu, vv)\n        neg_graph_.remove_edges(eids)\n        del uu, vv, eids\n    del nu, nv, u, v, neg_train_overlap_bool, neg_train_overlap"]}
{"filename": "src/pipelines/Evaluation.py", "chunked_list": ["'''\nEvaluation of trained models.\n'''\nimport gc\nfrom collections import defaultdict, deque\nfrom enum import Enum\nfrom functools import partial\nfrom typing import Tuple\n\nimport dgl", "\nimport dgl\nimport numpy as np\nimport torch\nimport tqdm\nfrom sklearn.metrics import average_precision_score, roc_auc_score\n\nfrom ..models.BaseModules import BaseLinkEncoderDecoder\nfrom .utils import numpy2torch_dtype\n", "from .utils import numpy2torch_dtype\n\n\nclass EvalMetrics(Enum):\n    '''\n    Enum for evaluation metrics and their string representations.\n    '''\n    ITER = \"Iter\"\n    EPOCH = \"Epoch\"\n    STEP = \"Step\"\n    LOSS = \"Loss\"\n    MRR = \"MRR\"\n    EID = \"EID\"\n    ACC = \"ACC\"\n    ROC_AUC = \"AUC\"\n    ROC_AP = \"AP\"\n    GRAD_NORM = \"Grad Norm\"\n    GPU_VRAM = \"GPU VRAM\"\n    RAM = \"RAM\"\n    TIME = \"Time\"\n    TRAINING_TIME = \"Total Training\"\n    TOTAL_TIME = \"Total Time\"\n    RANK = \"RANK\"", "\n\nclass EvalMetricsCalc:\n    '''\n    Calculation and presentation of evaluation metrics.\n    '''\n\n    # Format strings for printing each metric\n    format_dict = defaultdict(\n        lambda: \"{:.4f}\",\n        {\n            EvalMetrics.EPOCH: \"{:05d}\",\n            EvalMetrics.STEP: \"{:05d}\",\n            EvalMetrics.TIME: \"{:.4f} mins\",\n            EvalMetrics.TOTAL_TIME: \"{:>8.3f} mins\",\n            EvalMetrics.TRAINING_TIME: \"{:>8.3f} mins\",\n            EvalMetrics.GPU_VRAM: \"{:>6.0f} MB\",\n            EvalMetrics.RAM: \"{:>3.2f} GB\",\n            EvalMetrics.RANK: \"{:02d}\"\n        }\n    )\n\n    @staticmethod\n    def roc_auc_ap_score(pos_logits: torch.Tensor, neg_logits: torch.Tensor,\n                         metrics=[EvalMetrics.ROC_AUC, EvalMetrics.ROC_AP],\n                         prob_fn=torch.sigmoid) -> dict[EvalMetrics, float]:\n        '''\n        Calulate AUC and AP scores on ROC curve.\n\n        Arguments:\n        ----------\n        pos_logits: torch.Tensor\n            Logits of positive edge samples.\n        neg_logits: torch.Tensor\n            Logits of negative edge samples.\n        metrics: subset of [EvalMetrics.ROC_AUC, EvalMetrics.ROC_AP]\n            Metrics to calculate.\n        prob_fn: function\n            Function to convert logits to probabilities.\n\n        Returns:\n        --------\n        result_dict: dict[EvalMetrics, float]\n            Dictionary of calculated metrics.\n        '''\n        result_dict = {key: None for key in metrics}\n        with torch.no_grad():\n            pos_prob = prob_fn(pos_logits.squeeze(-1)).cpu().numpy()\n            neg_prob = prob_fn(neg_logits.squeeze(-1)).cpu().numpy()\n\n        preds_all = np.hstack([pos_prob, neg_prob])\n        labels_all = np.hstack(\n            [np.ones(len(pos_prob)), np.zeros(len(neg_prob))])\n\n        if EvalMetrics.ROC_AUC in result_dict:\n            result_dict[EvalMetrics.ROC_AUC] = float(\n                roc_auc_score(labels_all, preds_all))\n        if EvalMetrics.ROC_AP in result_dict:\n            result_dict[EvalMetrics.ROC_AP] = float(\n                average_precision_score(labels_all, preds_all))\n\n        return result_dict\n\n    @staticmethod\n    def rr_score(score_pos: torch.Tensor, score_neg_mat: torch.Tensor) -> torch.Tensor:\n        '''\n        Calculate reciprocal rank. \n\n        Arguments:\n        ----------\n        score_pos: torch.Tensor\n            Scores of positive edge samples.\n        score_neg_mat: torch.Tensor\n            Scores of negative edge samples.\n\n        Returns:\n        --------\n        reciprocal_rank: torch.Tensor\n        '''\n        score_neg_mat = score_neg_mat.sort(-1)[0]  # Sort in ascending order\n        rank = score_neg_mat.shape[1] + 1 - \\\n            torch.searchsorted(score_neg_mat, score_pos)\n        reciprocal_rank = rank.squeeze(-1).reciprocal()\n        return reciprocal_rank\n\n    @classmethod\n    def format_str(cls, resultDict: dict, formatDict=None, as_dict=False, rank=None):\n        '''\n        Format evaluation metrics into a string or dictionary.\n\n        Arguments:\n        ----------\n        resultDict: dict[EvalMetrics, float]\n            Dictionary of evaluation metrics.\n        formatDict: dict[EvalMetrics, str]\n            Dictionary of format strings for each metric.\n        as_dict: bool\n            If True, return a dictionary of metrics and their string representations.\n            If False, return a list of string representations of metrics.\n        rank: int\n            Rank in distributed cluster of the current process.\n        '''\n        if formatDict is None:\n            formatDict = cls.format_dict\n        _r_dict = resultDict.copy()\n        if rank is not None:\n            _r_dict[EvalMetrics.RANK] = rank\n        for key in (EvalMetrics.TIME, EvalMetrics.TRAINING_TIME, EvalMetrics.TOTAL_TIME):\n            if key in _r_dict:\n                _r_dict[key] /= 60 # Convert to minutes\n\n        if not as_dict:\n            return [f\"{key.value} {formatDict[key].format(value)}\"\n                    for key, value in _r_dict.items()]\n        else:\n            return {key.value: formatDict[key].format(value).strip()\n                    for key, value in _r_dict.items()}", "\n\nclass NodeBatchEvaluator:\n    def __init__(self, session, graph, eval_edge: dict,\n                 batch_size: int,\n                 nhood_sampler=dgl.dataloading.MultiLayerFullNeighborSampler(1),\n                 batch_device=None, graph_device=None, clear_cache_every=0, \n                 feature_loader=None, save_embed=False, **kwargs):\n        '''\n        Initialize evaluator.\n\n        Arguments:\n        ----------\n        session: SessionMgr\n            Session manager (see SessionMgr.py)\n        graph: dgl.DGLGraph\n            Graph to evaluate on.\n        eval_edge: dict[str, torch.Tensor]\n            Dictionary of evaluation edges.\n            See `dataloading.BaseDataMgr` for detailed format.\n        batch_size: int\n            Batch size during evaluation.\n        nhood_sampler: default dgl.dataloading.MultiLayerFullNeighborSampler(1)\n            Neighbor sampler to use during evaluation.\n            Default is to sample all neighbors.\n        batch_device: torch.device\n            Device to use for mini-batch evaluation.\n        graph_device: torch.device\n            Device that the graph is stored on.\n        clear_cache_every: int\n            Clear CUDA cache every this many batches.\n        feature_loader: function\n            Function to load node features.\n        save_embed: bool\n            If True, store all node embeddings generated by encoder to `self.node_embedding`.\n        kwargs: dict\n            Additional arguments to be passed to `dgl.dataloading.NodeDataLoader`\n        '''\n        self.session = session\n        self.graph = graph\n        self.save_embed = save_embed\n        self.eval_edge = eval_edge\n        if self.save_embed: # Include all nodes\n            self.eval_nodes = self.graph.nodes()\n        else:\n            self.eval_nodes = self.get_eval_nodes(self.eval_edge)\n        self.nhood_sampler = nhood_sampler\n        self.num_nodes = self.graph.number_of_nodes()\n        if graph_device is None:\n            graph_device = self.graph.device\n        self.graph_device = graph_device\n        self.batch_device = batch_device\n        self.batch_size = batch_size\n        self.clear_cache_every = clear_cache_every\n        \n        self.eval_nodes_mfg = None\n        \n        self.dataloader_list = None\n        self.dataloader_func = partial(\n            dgl.dataloading.NodeDataLoader, \n            graph=self.graph,\n            batch_size=batch_size,\n            graph_sampler=self.nhood_sampler, device=batch_device,\n            **kwargs\n        )\n        self.feature_loader = feature_loader\n        # self.ogb_evaluator = Evaluator(name='ogbl-citation2')\n        self.node_embedding = None\n\n    @property\n    def num_eval_edges(self):\n        '''\n        Get number of evaluation edges.\n        '''\n        return self.eval_edge[\"source_node\"].shape[0]\n\n    @property\n    def num_neg_samples(self):\n        '''\n        Get number of negative samples per evaluation edge.\n        '''\n        if self.eval_edge[\"target_node_neg\"] is not None:\n            return self.eval_edge[\"target_node_neg\"].shape[1]\n        else:\n            return self.eval_edge[\"target_node_neg_gen\"][2]\n    \n    @staticmethod\n    def get_eval_nodes(eval_edge):\n        '''\n        Get a tensor of all node IDs that are involved in evaluation edges.\n        '''\n        if eval_edge[\"target_node_neg\"] is not None:\n            node_list = torch.concat([\n                eval_edge[\"source_node\"].view(-1), \n                eval_edge[\"target_node\"].view(-1), \n                eval_edge[\"target_node_neg\"].view(-1)]\n            )\n        else:\n            node_list = torch.concat([\n                eval_edge[\"source_node\"].view(-1), \n                eval_edge[\"target_node\"].view(-1), \n                torch.arange(*eval_edge[\"target_node_neg_gen\"][:2], \n                    dtype=numpy2torch_dtype(eval_edge[\"target_node_neg_gen\"][-2])\n                )]\n            )\n        return torch.unique(node_list)\n\n    @staticmethod\n    def idx_iter(iter_len: int, batch_size: int) -> Tuple[int, int]:\n        '''\n        Iterate over indices in batches.\n\n        Arguments:\n        ----------\n        iter_len: int\n            Length of the indices [0, iter_len - 1] to iterate over.\n        batch_size: int\n            Batch size.\n        '''\n        for ndx in range(0, iter_len, batch_size):\n            yield ndx, min(ndx + batch_size, iter_len)\n\n    def create_data_loader(self, model):\n        '''\n        Create data loader for evaluation.\n\n        Arguments:\n        ----------\n        model: BaseLinkEncoderDecoder\n            Model to evaluate.\n        '''\n        if self.eval_nodes_mfg is None:\n            self.eval_nodes_mfg = model.get_MFG_nodes(\n                self.graph, self.eval_nodes)\n        \n        self.dataloader_list = [None] * len(self.eval_nodes_mfg)\n        for i in range(len(self.eval_nodes_mfg)):\n            self.dataloader_list[i] = self.dataloader_func(\n                indices=self.eval_nodes_mfg[i]\n            )\n        \n    def __call__(self, model: BaseLinkEncoderDecoder, metrics=[EvalMetrics.MRR], callback=None) -> dict:\n        '''\n        Evaluate model.\n\n        Arguments:\n        ----------\n        model: BaseLinkEncoderDecoder\n            Model to evaluate.\n        metrics: list of EvalMetrics\n            List of metrics to evaluate.\n        callback: function\n            Callback function to call after running each batch of encoder and decoder.\n        '''\n        model.eval()\n        result_dict = {key: None for key in metrics}\n\n        with torch.no_grad():\n            ## Run encoder part of the model\n            postfix_dict = {\n                \"Layer\": None\n            }\n            b_neg_score_mat = None\n            \n            if self.dataloader_list is None:\n                self.create_data_loader(model)\n            progress = tqdm.tqdm(\n                total=sum(map(len, self.eval_nodes_mfg)),\n                desc=\"Eval Encoder Progress\",\n                dynamic_ncols=True\n            )\n\n            encoder_queue = deque()\n            h_mat = None\n            h_mapping : torch.Tensor = None\n            for block_counter in range(max(model.num_conv_layers, 1)):\n                postfix_dict[\"Layer\"] = f\"{block_counter + 1}/{model.num_conv_layers}\"\n                layer_num_nodes = len(self.eval_nodes_mfg[block_counter])\n                postfix_dict[\"Num Nodes\"] = layer_num_nodes\n                prev_h_mat = h_mat\n                prev_h_mapping = h_mapping\n\n                h_mat = None\n                h_mat_ptr = 0\n                h_mapping = None\n                for step, (input_nodes, output_nodes, blocks) in enumerate(\n                    self.dataloader_list[block_counter]):\n                    if block_counter == 0:\n                        # First graph conv layer: create generator\n                        if self.feature_loader is not None:\n                            x = self.feature_loader(blocks[0])\n                        else:\n                            x = blocks[0].srcdata[\"feat\"]\n                        h_gen = model.encoder_generator(blocks[0], x)\n                        b_ptr, h = next(h_gen)  # Run conv layer\n                    else:\n                        # Use previously created generator for follow up layers\n                        idx = prev_h_mapping[input_nodes] - 1\n                        x = prev_h_mat[idx].to(blocks[0].device, non_blocking=True)\n                        if (idx < 0).any():\n                            raise KeyError(\n                                f\"Missing embeddings of {(idx < 0).sum()} nodes \" \n                                f\"from Layer {block_counter - 1}. \"\n                                f\"Please check `get_MFG_nodes` function of your model!\")\n                        gen_ptr, h_gen = encoder_queue.popleft()\n                        assert gen_ptr == block_counter\n                        b_ptr, h = h_gen.send((blocks[0], x))  # Run conv layer\n                    del x, blocks, input_nodes\n                    h = h.to(self.graph_device) # non_blocking=True here will cause performance issues.\n                    if b_ptr >= 0:  # more conv layer expected\n                        if model.num_conv_layers > 0:\n                            assert b_ptr - 1 == block_counter\n                        encoder_queue.append((b_ptr, h_gen))\n                    else:  # last conv layer reached\n                        assert abs(b_ptr) - 1 == block_counter\n                        h_gen.close()\n                    if h_mat is None:\n                        h_mat = torch.zeros(\n                            (layer_num_nodes, h.shape[1]), \n                            device=self.graph_device,\n                            dtype=h.dtype,\n                            pin_memory=True\n                        )\n                    if h_mapping is None:\n                        h_mapping = torch.zeros(\n                            self.num_nodes, dtype=output_nodes.dtype\n                        )\n                        # staring idx mapping from 1 so that 0 is reserved for nodes not calculated\n                    h_mat[h_mat_ptr: h_mat_ptr + h.shape[0]] = h\n                    h_mapping[output_nodes] = torch.arange(\n                        h_mat_ptr + 1, h_mat_ptr + h.shape[0] + 1, \n                        dtype=output_nodes.dtype)\n                    h_mat_ptr += h.shape[0]\n\n                    postfix_dict.update(\n                        EvalMetricsCalc.format_str({\n                            EvalMetrics.GPU_VRAM: self.session.max_gpu_vram\n                        }, as_dict=True)\n                    )\n                    progress.set_postfix(postfix_dict)\n                    progress.update(len(output_nodes))\n                    del output_nodes, h\n                    gc.collect()\n                    if (self.batch_device.type == \"cuda\"\n                        and self.clear_cache_every > 0\n                            and step % self.clear_cache_every == 0):\n                        torch.cuda.empty_cache()\n                    if callback is not None:\n                        callback()\n\n                # Clean unused generators for current layer\n                stop_clean = False\n                while not stop_clean and len(encoder_queue) > 0:\n                    if encoder_queue[0][0] == block_counter:\n                        _, h_gen = encoder_queue.popleft()\n                        h_gen.close()\n                    else:\n                        stop_clean = True\n\n            del prev_h_mat, prev_h_mapping\n            progress.close()\n            gc.collect()\n            \n            if self.save_embed:\n                uidx = h_mapping[self.graph.nodes()] - 1\n                assert not (uidx < 0).any()\n                self.node_embedding = h_mat[uidx]\n\n            ## Run decoder part of the model\n            progress = tqdm.tqdm(\n                total=self.num_eval_edges,\n                desc=\"Eval Decoder Progress\",\n                dynamic_ncols=True\n            )\n            postfix_dict = dict()\n            batch_size = self.batch_size // self.num_neg_samples\n            if EvalMetrics.MRR in metrics:\n                reciprocal_rank = - torch.ones(self.num_eval_edges,\n                                               device=self.batch_device)\n            if self.eval_edge[\"target_node_neg\"] is None:\n                rng = np.random.default_rng(seed=self.eval_edge[\"target_node_neg_gen\"][-1])\n            \n            if \"etypes\" in self.eval_edge:\n                etypes = self.eval_edge[\"etypes\"]\n                if len(etypes) == 1:\n                    etypes = etypes.expand(self.num_eval_edges)\n            else:\n                etypes = None\n            \n            for step, (p, q) in enumerate(self.idx_iter(self.num_eval_edges, batch_size)):\n                uidx = h_mapping[self.eval_edge[\"source_node\"][p:q]] - 1\n                uh = h_mat[uidx].to(self.batch_device, non_blocking=True)\n                vidx = h_mapping[self.eval_edge[\"target_node\"][p:q]] - 1\n                vh = h_mat[vidx].to(self.batch_device, non_blocking=True)\n                if self.eval_edge[\"target_node_neg\"] is not None:\n                    vidx_neg = h_mapping[self.eval_edge[\"target_node_neg\"][p:q]] - 1\n                else: # Generate negative samples on the fly\n                    target_node_neg = rng.integers(\n                        *self.eval_edge[\"target_node_neg_gen\"][:2], \n                        size=(q-p, self.eval_edge[\"target_node_neg_gen\"][2]),\n                        dtype=self.eval_edge[\"target_node_neg_gen\"][3])\n                    vidx_neg = h_mapping[torch.as_tensor(target_node_neg)] - 1\n                vh_neg = h_mat[vidx_neg].to(self.batch_device, non_blocking=True)\n                assert not ((uidx < 0).any() or (vidx < 0).any() or (vidx_neg < 0).any())                \n\n                if etypes is not None:\n                    b_etypes = etypes[p:q].to(self.batch_device)\n                else:\n                    b_etypes = None\n                b_pos_score_mat = model.decoder_mat(uh, vh, b_etypes)\n                b_neg_score_mat = model.decoder_mat(uh[:, None, :], vh_neg, b_etypes)\n                if EvalMetrics.MRR in metrics:\n                    b_reciprocal_rank = EvalMetricsCalc.rr_score(\n                        b_pos_score_mat[:, None], b_neg_score_mat)\n                    reciprocal_rank[p:q] = b_reciprocal_rank\n\n                postfix_dict.update(\n                    EvalMetricsCalc.format_str({\n                        EvalMetrics.GPU_VRAM: self.session.max_gpu_vram\n                    }, as_dict=True)\n                )\n                progress.update(q - p)\n                progress.set_postfix(postfix_dict)\n                gc.collect()\n                if (self.batch_device.type == \"cuda\"\n                    and self.clear_cache_every > 0\n                        and step % self.clear_cache_every == 0):\n                    torch.cuda.empty_cache()\n                if step % 10 == 0 and callback is not None:\n                    if callback() == False:\n                        callback = None\n            progress.close()\n\n            # Calculate final metrics\n            if EvalMetrics.MRR in metrics:\n                assert not (reciprocal_rank < 0).any()\n                result_dict[EvalMetrics.MRR] = reciprocal_rank.mean().item()\n\n        return result_dict", "\n\n"]}
{"filename": "src/pipelines/__init__.py", "chunked_list": [""]}
{"filename": "src/pipelines/utils.py", "chunked_list": ["import contextlib\nimport os\nimport random\nimport re\nimport subprocess\nimport time\nfrom datetime import timedelta\nfrom io import StringIO\nfrom multiprocessing import Process, Value\nfrom pathlib import Path", "from multiprocessing import Process, Value\nfrom pathlib import Path\nfrom typing import Callable\n\nimport dgl\nimport numpy as np\nimport pandas\nimport torch\nimport torch.distributed as dist\nfrom dgl.dataloading import CollateWrapper", "import torch.distributed as dist\nfrom dgl.dataloading import CollateWrapper\nfrom torch.distributed.distributed_c10d import (_object_to_tensor,\n                                                _tensor_to_object)\n\n\ndef vscode_debug():\n    try:\n        import ptvsd\n        print(\"Waiting for debugger attach\")\n        ptvsd.enable_attach(address=('0.0.0.0', 5678), redirect_output=True)\n        ptvsd.wait_for_attach()\n    except KeyboardInterrupt:\n        pass", "\n\ndef write_csv(df: pandas.DataFrame, filename: str):\n    with open(filename) as f:\n        df.to_csv(f)\n\ndef get_peak_mem():\n    ''' Get the peak memory size.\n        Adapted from https://github.com/dmlc/dgl/blob/480a4ae35c84c4497bfa901c25e6e6eca85b67eb/python/dgl/partition.py#L235\n    Returns\n    -------\n    float\n        The peak memory size in GB.\n    '''\n    if not os.path.exists('/proc/self/status'):\n        return 0.0\n    for line in open('/proc/self/status', 'r'):\n        if 'VmPeak' in line:\n            mem = re.findall(r'\\d+', line)[0]\n            return int(mem) / 1024 / 1024\n    return 0.0", "\ndef dist_send_obj(obj, dst):\n    byte_t, size_t = _object_to_tensor(obj)\n    print(f\"Size of tensor to send (GB): \"\n          f\"{byte_t.numel() * byte_t.element_size() / 1024 ** 3}\")\n    dist.send(size_t, dst, tag=0)\n    dist.send(byte_t, dst, tag=1)\n\ndef dist_isend_obj(obj, dst):\n    byte_t, size_t = _object_to_tensor(obj)\n    print(f\"Size of tensor to send (GB): \"\n          f\"{byte_t.numel() * byte_t.element_size() / 1024 ** 3}\")\n    size_req = dist.isend(size_t, dst, tag=0)\n    byte_req = dist.isend(byte_t, dst, tag=1)\n    return size_req, byte_req", "def dist_isend_obj(obj, dst):\n    byte_t, size_t = _object_to_tensor(obj)\n    print(f\"Size of tensor to send (GB): \"\n          f\"{byte_t.numel() * byte_t.element_size() / 1024 ** 3}\")\n    size_req = dist.isend(size_t, dst, tag=0)\n    byte_req = dist.isend(byte_t, dst, tag=1)\n    return size_req, byte_req\n\ndef dist_recv_obj(src):\n    size_t = torch.zeros(1, dtype=torch.long)\n    dist.recv(size_t, src, tag=0)\n    byte_t = torch.empty(size_t.item(), dtype=torch.uint8)\n    dist.recv(byte_t, src, tag=1)\n    obj = _tensor_to_object(byte_t, size_t)\n    return obj", "def dist_recv_obj(src):\n    size_t = torch.zeros(1, dtype=torch.long)\n    dist.recv(size_t, src, tag=0)\n    byte_t = torch.empty(size_t.item(), dtype=torch.uint8)\n    dist.recv(byte_t, src, tag=1)\n    obj = _tensor_to_object(byte_t, size_t)\n    return obj\n\n\ndef get_gpu_usage(flag: Value, gpu_vram: Value, gpu_list: list, interval=0.5):\n    while flag.value > 0:\n        proc = subprocess.run(\n            [\"nvidia-smi\", \"--format=csv\", \n             \"--query-gpu=index,memory.total,memory.used,memory.free,\"\n             \"utilization.gpu,utilization.memory\"\n            ], stdout=subprocess.PIPE, text=True)\n        strio = StringIO(proc.stdout)\n        df = pandas.read_csv(strio, index_col=0)\n        df.replace(regex=r\"\\s*([\\d\\.]*)\\s*(MiB|%)\", value=r\"\\1\", \n            inplace=True)\n        df = df.astype(float)\n\n        gpu_vram.value = df.iloc[gpu_list, 1].sum()\n        time.sleep(interval + 0.5 * random.random())", "\ndef get_gpu_usage(flag: Value, gpu_vram: Value, gpu_list: list, interval=0.5):\n    while flag.value > 0:\n        proc = subprocess.run(\n            [\"nvidia-smi\", \"--format=csv\", \n             \"--query-gpu=index,memory.total,memory.used,memory.free,\"\n             \"utilization.gpu,utilization.memory\"\n            ], stdout=subprocess.PIPE, text=True)\n        strio = StringIO(proc.stdout)\n        df = pandas.read_csv(strio, index_col=0)\n        df.replace(regex=r\"\\s*([\\d\\.]*)\\s*(MiB|%)\", value=r\"\\1\", \n            inplace=True)\n        df = df.astype(float)\n\n        gpu_vram.value = df.iloc[gpu_list, 1].sum()\n        time.sleep(interval + 0.5 * random.random())", "\n\n\n\ndef parse_timedelta(timedelta_str: str) -> timedelta:\n    timedelta_str = timedelta_str.strip()\n    if timedelta_str.endswith(\"h\"):\n        return timedelta(hours=float(timedelta_str[:-1]))\n    elif timedelta_str.endswith(\"min\"):\n        return timedelta(minutes=float(timedelta_str[:-3]))\n    else:\n        raise ValueError(f\"Incorrect time delta: {timedelta_str}\")", "\ndef numpy2torch_dtype(dtype: np.dtype):\n    return torch.as_tensor(np.array(0, dtype=dtype)).dtype\n\nclass CustomDistributedDataParallel(torch.nn.parallel.DistributedDataParallel):\n    def __getattr__(self, name):\n        if name == 'module':\n            return super().__getattr__('module')\n        else:\n            return getattr(self.module, name)", "\n\n# Make them classes to work with pickling in mp.spawn\nclass SharedMemCollateWrapper(CollateWrapper):\n    \"\"\"Wraps a collate function with :func:`remove_parent_storage_columns` for serializing\n    from PyTorch DataLoader workers.\n    \n    \"\"\"\n    def __init__(self, sample_func, graph_name, \n                 ndata_dict : dict = None,\n                 edata_dict : dict = None):\n        self.sample_func = sample_func\n        self.g = None\n        self.graph_name = graph_name\n        self.ndata_dict = ndata_dict\n        self.edata_dict = edata_dict\n\n    def __call__(self, items):\n        if self.g is None:\n            self.g = dgl.hetero_from_shared_memory(self.graph_name)\n            if self.ndata_dict is not None:\n                for key, tensor in self.ndata_dict.items():\n                    self.g.ndata[key] = tensor\n            if self.edata_dict is not None:\n                for key, tensor in self.edata_dict.items():\n                    self.g.edata[key] = tensor\n        return super().__call__(items)", "    "]}
{"filename": "src/dataloading/DataMgr.py", "chunked_list": ["import os\nimport shutil\nimport time\nimport warnings\nfrom pathlib import Path\n\nimport dgl\nimport numpy as np\nimport psutil\nimport torch", "import psutil\nimport torch\nimport tqdm\nfrom dgl.data import AsLinkPredDataset, RedditDataset\nfrom ogb.linkproppred import DglLinkPropPredDataset\nfrom ogb.lsc import MAG240MDataset\n\nfrom .BaseDataMgr import BaseDataMgr\n\n# Get the real root directory of the repo even when the code is running in a temporary dvc directory", "\n# Get the real root directory of the repo even when the code is running in a temporary dvc directory\nrepoRoot = Path(os.getcwd().split(\"/.dvc\", maxsplit=1)[0])\n\nclass DataMgr(BaseDataMgr):\n    '''\n    Load and preprocess data for training and evaluation.\n    '''\n    def __init__(self, dataset_name: str, to_undirected=True, use_self_loops=False, **kwargs):\n        '''\n        Initialize the data manager; load the corresponding dataset.\n        \n        Parameters:\n        -----------\n        dataset_name: str\n            Name of the dataset to load.\n            Currently supported: 'ogbl_citation2', 'reddit', 'mag240m'\n        to_undirected: bool, default True\n            Whether to convert the graph to undirected.\n        use_self_loops: bool, default False\n            Whether to explicitly preprocess the graph to add self-loops edges.\n            Even when self-loop edges are not explicitly added during preprocessing,\n            GNN models can still implicitly add self-loop edges for message passing.\n            Check argument of GNN models for details.\n        kwargs: dict\n            Additional keyword arguments specific to each dataset.\n            Keyword arguments defined under `dataset.{dataset_name}` in `params.yaml` are forwarded here.\n        '''\n        self.dataset_str = dataset_name\n        self.use_feat_loader = False\n        self.train_frac = kwargs.get(\"train_frac\", 1)\n        self.random_seed = kwargs.get(\"rnd_seed\", None)\n        if dataset_name == 'ogbl_citation2':\n            _name = dataset_name.replace(\"_\", \"-\")\n            self.dataset = DglLinkPropPredDataset(\n                name=_name, root=str(repoRoot/\"dataset\"))\n        elif dataset_name == \"reddit\":\n            self.dataset = RedditDataset(\n                self_loop=use_self_loops,\n                raw_dir=str(repoRoot / \"dataset\" / \"reddit\"),\n            )\n        elif dataset_name == \"mag240m\":\n            self.dataset = MAG240MDatasetRAM(\n                tmpfs_dir=kwargs.get(\"tmpfs_dir\", None),\n                root=str(repoRoot / \"dataset\"))\n            self.use_feat_loader = True\n            self.variant = kwargs[\"variant\"]\n            if self.variant == \"citation_only\":\n                print(\"Loading DGL graph...\")\n                self.variant_dir = Path(self.dataset.dir) / \"modified\" / \"citation_only\"\n                if to_undirected:\n                    glist, _ = dgl.load_graphs(str(self.variant_dir / \"train_g_bi.dgl\"))\n                    self.train_graph = glist[0]\n                    self.dataset_str += \"-citation_only-bi\"\n                else:\n                    glist, _ = dgl.load_graphs(str(self.variant_dir / \"train_g.dgl\"))\n                    self.train_graph = glist[0]\n                    self.dataset_str += \"-citation_only\"\n            else:\n                raise NotImplementedError\n            self.__node_features = None\n        else:\n            raise NotImplementedError\n        \n        self.dataset_name = dataset_name\n        self.dataset_kwargs = kwargs\n        self.to_undirected = to_undirected\n        self.use_self_loops = use_self_loops\n        self.dataset_prepared = False\n        self.multigpu_prepared = False\n        \n        self.multigpu_train_graph_name = None\n        self.multigpu_shared_ndata = None\n        self.multigpu_shared_edata = None\n\n        self.multigpu_graph_name = None\n        self.multigpu_g_ndata = None\n        self.multigpu_g_edata = None\n\n    @property\n    def val_use_val_edges(self):\n        '''\n        Whether to use validation and test edges for message passing during evaluation.\n        Default: False\n        '''\n        return getattr(self.dataset, \"val_use_val_edges\", False)\n\n    @property\n    def save_embed(self):\n        '''\n        Whether to save GNN embeddings of all nodes during model testing.\n        Default: False\n        '''\n        return getattr(self.dataset, \"save_embed\", False)\n\n    @property\n    def save_embed_callback(self):\n        '''\n        Get callback function for saving GNN embeddings of all nodes during model testing.\n        That function must be defined in the dataset class.\n        '''\n        return getattr(self.dataset, \"save_embed_callback\", None)\n\n    def prepare_dataset(self):\n        '''\n        Prepare the dataset for training and evaluation:\n        - Preprocess the graph\n        - Split the dataset into train/val/test sets\n\n        Returns: None\n        '''\n        if not self.dataset_prepared:\n            # build test set with 10% positive links\n            if self.dataset_name in ['ogbl_citation2']:\n                graph = self.dataset[0]\n\n                # Extract node features\n                # feats = graph.ndata.pop('feat').to(device)\n                in_dim = graph.ndata[\"feat\"].shape[-1]\n\n                split_edge = self.dataset.get_edge_split()\n                train_edge, valid_edge, test_edge = split_edge[\"train\"], split_edge[\"valid\"], split_edge[\"test\"]\n                assert graph.num_edges() == len(train_edge[\"source_node\"])\n                \n                if self.to_undirected:\n                    print(\"Converting graph to undirected graph...\")\n                    graph = dgl.to_bidirected(graph, copy_ndata=True)\n                \n                if self.use_self_loops:\n                    if (train_edge[\"source_node\"] == train_edge[\"target_node\"]).any():\n                        warnings.warn(\"Self loops included in original training splits!\")\n                    train_graph = dgl.add_self_loop(graph)\n                    train_edge_idx = train_graph.edge_ids(train_edge[\"source_node\"], train_edge[\"target_node\"])\n                \n                else:\n                    train_graph = graph # dgl graph object containing only training edges\n                    train_edge_idx = train_graph.edge_ids(train_edge[\"source_node\"], train_edge[\"target_node\"])\n                \n                self.graph = graph\n                self.train_graph : dgl.DGLHeteroGraph = train_graph\n                \n                self.train_edge = train_edge\n                self.train_edge_idx = train_edge_idx\n                self.valid_edge = valid_edge\n                self.test_edge = test_edge\n                self.in_dim = in_dim\n\n                self.feat_dtype = graph.ndata[\"feat\"].dtype\n            \n            elif self.dataset_name in [\"reddit\"]:\n                self.prev_dataset = self.dataset\n                self.dataset = AsOGBLinkPredDataset(\n                    self.dataset,\n                    self.dataset_kwargs[\"split_ratio\"],\n                    self.dataset_kwargs[\"neg_ratio\"],\n                    save_dir=str(repoRoot / self.prev_dataset.save_dir)\n                )\n                if not self.dataset.has_cache():\n                    print(\"Saving generated dataset...\")\n                    self.dataset.save()\n                self.train_graph: dgl.DGLHeteroGraph = self.dataset.train_graph\n                self.in_dim = self.train_graph.ndata[\"feat\"].shape[-1]\n                self.feat_dtype = self.train_graph.ndata[\"feat\"].dtype\n                self.train_edge_idx = self.train_graph.edges(\"eid\")\n                self.valid_edge = dict(\n                    source_node=self.dataset.val_edges[0][0],\n                    target_node=self.dataset.val_edges[0][1],\n                    target_node_neg=self.dataset.val_edges[1][1]\n                )\n                self.test_edge = dict(\n                    source_node=self.dataset.test_edges[0][0],\n                    target_node=self.dataset.test_edges[0][1],\n                    target_node_neg=self.dataset.test_edges[1][1]\n                )\n\n            elif self.dataset_name in ['mag240m']:\n                if self.variant == \"citation_only\":\n                    self.in_dim = self.dataset.num_paper_features\n\n                    valid_edge = dict()\n                    test_edge = dict()\n                    print(\"Loading edge splits...\")\n                    with np.load(str(self.variant_dir / \"splits.npz\")) as data:\n                        key: str\n                        for key, value in data.items():\n                            set_name, var_name = key.split(\"/\", maxsplit=1)\n                            if set_name == \"valid\":\n                                valid_edge[var_name] = torch.tensor(value)\n                            elif set_name == \"test\":\n                                test_edge[var_name] = torch.tensor(value)\n                    \n                    self.valid_edge = valid_edge\n                    self.test_edge = test_edge\n                    if self.dataset.paper_feat.dtype == np.float16:\n                        self.feat_dtype = torch.float16\n                    else:\n                        self.feat_dtype = torch.float32\n                \n                else:\n                    raise NotImplementedError\n                \n                if self.use_self_loops:\n                    self.train_graph = dgl.add_self_loop(self.train_graph)\n                self.train_edge_idx = self.train_graph.edges(\"eid\")\n\n            self.dataset_prepared = True\n\n            \n    def create_formats_(self):\n        '''\n        Explicitly create all formats of the DGL graph object.\n        '''\n        self.train_graph.create_formats_()\n\n    @property\n    def node_features(self):\n        '''\n        Provide node features from sources other than the ndata storage of the DGL graph object.\n        On its first call, this property will load the node features from the appropriate source. \n        '''\n        if self.dataset_name in ['mag240m']:\n            if self.__node_features is None:\n                self.__node_features = self.dataset.paper_feat\n            return self.__node_features\n        else:\n            return None\n\n    def feature_loader(self, first_block, device=None):\n        '''\n        Load node features from sources other than the ndata storage of the DGL graph object.\n        '''\n        if device is None:\n            device = first_block.device\n        if self.dataset_name in ['mag240m']:\n            nids = first_block.srcdata[dgl.NID].cpu()\n            feat = self.node_features[nids]\n            return torch.as_tensor(feat, device=device)\n        elif self.dataset_name.startswith(\"amazon\"):\n            return self.dataset.feature_loader(first_block, device)\n        else: \n            # Load features from ndata of the DGL graph\n            return None\n\n    @staticmethod\n    def sample_idx(idx: torch.Tensor, frac: float, rnd_seed=None):\n        '''\n        Sample a fraction of idx tensor.\n        The fraction of sampling is not guaranteed to be exactly `frac`,\n        but will be very close to it when the length of idx is large.\n\n        Parameters:\n        -----------\n        idx: torch.Tensor\n            The tensor to be sampled.\n        frac: float\n            The non-exact fraction of idx to be sampled.\n        rnd_seed: int\n            The random seed to be used for sampling.\n        '''\n        torch_rnd_state = torch.random.get_rng_state()\n        if rnd_seed is not None:\n            torch.random.manual_seed(rnd_seed)\n        rand_exps = torch.rand(len(idx), dtype=torch.float16)\n        s_idx = idx[rand_exps < frac]\n        torch.random.set_rng_state(torch_rnd_state)\n        return s_idx\n    \n    def multigpu_preprocess(self):\n        '''\n        Preprocess the dataset for multi-GPU training.\n        DGL graph object will be moved to shared memory and temporarily unlinked from the attribute\n        to avoid being pickled.\n        '''\n        if (self.dataset_name in ['mag240m', 'reddit'] \n            or self.dataset_name.startswith('amazon')):\n            print(\"Moving DGL graph to shared memory...\")\n\n            # The graph object will be written to /dev/shm\n            self.multigpu_train_graph_name = f\"train_graph-{int(time.time())}\"\n            shared_graph = self.train_graph.shared_memory(self.multigpu_train_graph_name)\n            if len(self.train_graph.ndata) > 0:\n                self.multigpu_shared_ndata = {\n                    key: tensor.share_memory_() for key, tensor in \n                    self.train_graph.ndata.items()\n                }\n            if len(self.train_graph.edata) > 0:\n                self.multigpu_shared_edata = {\n                    key: tensor.share_memory_() for key, tensor in \n                    self.train_graph.edata.items()\n                }\n            self.train_graph = None\n\n            if self.val_use_val_edges:\n                self.multigpu_graph_name = f\"graph-{int(time.time())}\"\n                shared_graph = [shared_graph, None]\n                shared_graph[-1] = self.graph.shared_memory(self.multigpu_graph_name)\n                if len(self.graph.ndata) > 0:\n                    self.multigpu_g_ndata = {\n                        key: tensor.share_memory_() for key, tensor in \n                        self.graph.ndata.items()\n                    }\n                if len(self.graph.edata) > 0:\n                    self.multigpu_g_edata = {\n                        key: tensor.share_memory_() for key, tensor in \n                        self.graph.edata.items()\n                    }\n            self.graph = None\n            \n            if self.train_frac < 1.0:\n                print(f\"Sampling training edges using fraction {self.train_frac}...\")\n                self.train_edge_idx = DataMgr.sample_idx(\n                    self.train_edge_idx, self.train_frac, self.random_seed)\n            self.train_edge_idx.share_memory_()\n            for key in [\"source_node\", \"target_node\", \"target_node_neg\"]:\n                if self.valid_edge[key] is not None:\n                    self.valid_edge[key].share_memory_()\n                if (self.test_edge is not None) and (self.test_edge[key] is not None):\n                    self.test_edge[key].share_memory_()\n            \n            if self.dataset_name.startswith(\"amazon\"):\n                self.dataset.multigpu_preprocess()\n\n            self.multigpu_prepared = True\n\n            return shared_graph\n        \n        elif self.dataset_name in ['ogbl_citation2']:\n            for key in [\"source_node\", \"target_node\", \"target_node_neg\"]:\n                self.valid_edge[key].share_memory_()\n                self.test_edge[key].share_memory_()\n    \n    def multigpu_postprocess(self):\n        '''\n        Postprocess the dataset in each spawned process for multi-GPU training.\n        DGL graph object will be loaded from shared memory and re-attached to the attribute.\n        '''\n        if self.multigpu_prepared:\n            print(\"Loading DGL graph from shared memory...\")\n\n            # The following call does not incur additional memory usage \n            # unless the graph structure is modified afterwards; in this case, the graph \n            # in the shared memory will not be modified, but a new copy of the graph\n            # will be created. Attaching ndata / edata to the graph does not affect the \n            # the graph in the shared memory.\n            self.train_graph = dgl.hetero_from_shared_memory(self.multigpu_train_graph_name)\n            if self.multigpu_shared_ndata is not None:\n                for key, tensor in self.multigpu_shared_ndata.items():\n                    self.train_graph.ndata[key] = tensor\n            if self.multigpu_shared_edata is not None:\n                for key, tensor in self.multigpu_shared_edata.items():\n                    self.train_graph.edata[key] = tensor\n            \n            if self.multigpu_graph_name is not None:\n                self.graph = dgl.hetero_from_shared_memory(self.multigpu_graph_name)\n                if self.multigpu_g_ndata is not None:\n                    for key, tensor in self.multigpu_g_ndata.items():\n                        self.graph.ndata[key] = tensor\n                if self.multigpu_g_edata is not None:\n                    for key, tensor in self.multigpu_g_edata.items():\n                        self.graph.edata[key] = tensor\n            \n            self.multigpu_prepared = False", "\nclass MAG240MDatasetRAM(MAG240MDataset):\n    '''\n    Wrapper class for MAG240M dataset to load the paper feature file from RAM disk (tmpfs)\n    '''\n    def __init__(self, root: str = 'dataset', tmpfs_dir = None):\n        '''\n        Parameters:\n        -----------\n        tmpfs_dir: str\n            Path to the RAM disk (tmpfs) directory\n        \n        For other parameters, see MAG240MDataset\n        '''\n        super().__init__(root)\n        self.tmpfs_dir = Path(tmpfs_dir)\n        self.using_tmpfs = False\n\n    @property\n    def paper_feat(self) -> np.ndarray:\n        '''\n        Load (and create) numpy memmap feature file in the RAM disk (tmpfs) \n        for mag240m dataset\n        '''\n        if self.tmpfs_dir is None:\n            return super().paper_feat\n        \n        tmpfs_file = self.tmpfs_dir / 'mag240m_node_feat.npy'\n\n        if self.using_tmpfs or tmpfs_file.exists():\n            if self.using_tmpfs is False:\n                print(f\"Using feature file from tmpfs on {self.tmpfs_dir}\")\n            self.using_tmpfs = True\n            return np.load(str(tmpfs_file), mmap_mode=\"r\")\n        \n        elif (Path(self.tmpfs_dir).exists()):\n            # Please make sure the path is in `tmpfs` filesystem\n            # since the code does not check.\n            feat_file = Path(self.dir) / 'processed' / 'paper' / 'node_feat.npy'\n            print(f\"Loading feature file into tmpfs on {self.tmpfs_dir}...\")\n            shutil.copy2(feat_file, tmpfs_file)\n            self.using_tmpfs = True\n            return np.load(str(tmpfs_file), mmap_mode=\"r\")\n        \n        else:\n            return super().paper_feat", "\nclass AsOGBLinkPredDataset(AsLinkPredDataset):\n    '''\n    Wrapper class of dgl.data.AsLinkPredDataset to match OGB data format\n    '''\n    def process(self):\n        '''\n        Generate train/val/test edges for link prediction in OGB format\n        '''\n        if self.split_ratio is None:\n            return super().process()\n        else:\n            assert self.split_ratio is not None, \"Need to specify split_ratio\"\n            assert self.neg_ratio is not None, \"Need to specify neg_ratio\"\n            ratio = self.split_ratio\n            graph = self.dataset[0]\n            n = graph.num_edges()\n            src, dst = graph.edges()\n            src, dst = dgl.backend.asnumpy(src), dgl.backend.asnumpy(dst)\n            n_train, n_val, n_test = int(\n                n * ratio[0]), int(n * ratio[1]), int(n * ratio[2])\n\n            idx = np.random.permutation(n)\n            train_pos_idx = idx[:n_train]\n            val_pos_idx = idx[n_train:n_train+n_val]\n            test_pos_idx = idx[n_train+n_val:]\n\n            pos_val_src, pos_val_dst = (src[val_pos_idx], dst[val_pos_idx])\n            neg_val_dst = self.negative_sample(\n                graph, pos_val_src, self.neg_ratio)\n            \n            pos_test_src, pos_test_dst = (src[test_pos_idx], dst[test_pos_idx])\n            neg_test_dst = self.negative_sample(\n                graph, pos_test_src, self.neg_ratio)\n\n            self._val_edges = (\n                (dgl.backend.tensor(pos_val_src), dgl.backend.tensor(pos_val_dst)),\n                (dgl.backend.tensor([]), dgl.backend.tensor(neg_val_dst))\n            )\n            \n            self._test_edges = (\n                (dgl.backend.tensor(pos_test_src), dgl.backend.tensor(pos_test_dst)),\n                (dgl.backend.tensor([]), dgl.backend.tensor(neg_test_dst))\n            )\n\n            self._train_graph = dgl.convert.graph(\n                (src[train_pos_idx], dst[train_pos_idx]), num_nodes=self.num_nodes)\n            self._train_graph.ndata[\"feat\"] = graph.ndata[\"feat\"]\n    \n    @classmethod\n    def negative_sample(cls, graph: dgl.DGLGraph, src: np.ndarray, \n            neg_ratio, relation=[], sample_rate=1.2, no_existing_edges=True,\n            rng=None, random_seed=None):\n        '''\n        Sample negative target nodes for source nodes for link prediction evaluation\n\n        Parameters:\n        -----------\n        graph: dgl.DGLGraph\n            Graph for performing negative sampling\n        src: np.ndarray\n            Source nodes for negative sampling\n        neg_ratio: int\n            Number of negative samples per source node\n        relation: list\n            List of edge types for negative sampling\n        sample_rate: float\n            Rate of excessive negative sampling\n            Excessive sampling is needed when no_existing_edges is True,\n            which means some sampled edges need to be filtered out if they have appeared in the graph.\n        no_existing_edges: bool\n            Whether to exclude existing edges in the graph from negative samples\n            Turning this off can significantly speed up negative sampling\n        rng: np.random.Generator, optional\n            Random number generator to use for negative sampling\n        random_seed: int, optional\n            Random seed to use for negative sampling\n        '''\n        if rng is None:\n            rng = np.random.default_rng(seed=random_seed)\n        \n        if not no_existing_edges:\n            sample_rate = 1\n        sample_size_relax = int(np.ceil(sample_rate * neg_ratio))\n        if len(relation) == 0:\n            neg_dst_relax = rng.integers(0, graph.num_nodes(), \n                size=(src.shape[0], sample_size_relax), dtype=src.dtype)\n        elif len(relation) == 1:\n            dst_type = graph.to_canonical_etype(relation[0])[-1]\n            neg_dst_relax = rng.integers(0, graph.num_nodes(dst_type), \n                size=(src.shape[0], sample_size_relax), dtype=src.dtype)\n        else:\n            raise NotImplementedError(\n                \"Val edges with different relations are not supported.\")\n        if not no_existing_edges:\n            return neg_dst_relax\n        \n        neg_dst = np.zeros((src.shape[0], neg_ratio), dtype=src.dtype)\n        for i, (src_id, dst_id) in tqdm.tqdm(\n            enumerate(zip(src, neg_dst_relax)),\n            desc=\"Neg sampling\",\n            total=src.shape[0],\n            dynamic_ncols=True\n        ):\n            dst_id = np.unique(dst_id)\n            # remove self loop\n            mask_self_loop = (src_id.item() == dst_id)\n            # remove existing edges\n            if len(relation) == 0:\n                has_edges = dgl.backend.asnumpy(\n                    graph.has_edges_between(src_id, dst_id))\n            elif len(relation) == 1:\n                has_edges = dgl.backend.asnumpy(\n                    graph.has_edges_between(src_id, dst_id, etype=relation[0]))\n            else:\n                raise NotImplementedError(\n                    \"Val edges with different relations are not supported.\")\n            mask = ~(np.logical_or(mask_self_loop, has_edges))\n            \n            dst_id_final = dst_id[mask]\n            if dst_id_final.shape[0] >= neg_ratio:\n                neg_dst[i, :] = dst_id_final[:neg_ratio]\n            else:\n                # Try automatically resample with increased excessive sampling rate\n                neg_dst[i, :] = cls.negative_sample(\n                    graph, np.array([src_id.item()], neg_ratio, relation, \n                    sample_rate=1.5 * sample_rate), rng=rng)\n                # raise RuntimeError(\n                #     f\"Insufficient sample rate for negative sampling: {dst_id_final.shape[0]} / {self.neg_ratio}\")\n        return neg_dst", ""]}
{"filename": "src/dataloading/__init__.py", "chunked_list": [""]}
{"filename": "src/dataloading/BaseDataMgr.py", "chunked_list": ["from typing import Dict\n\nimport dgl\nimport torch\n\n\nclass BaseDataMgr:\n    '''\n    Abstract base class for data managers.\n    '''\n\n    def __init__(self) -> None:\n        '''\n        Variables that need to be attached to the object (self) in child classes:\n        '''\n        # dgl.DGLGraph that is input to GNN models\n        self.train_graph: dgl.DGLGraph = None\n\n        # DGL edge indices of the edges in the training set\n        self.train_edge_idx: torch.Tensor = None\n\n        # dictionary of edges in the validation and test sets.\n        # - format: dict(\n        #     source_node=tensor(source_node_indices), # size=num_eval_edges\n        #     target_node=tensor(target_node_indices), # size=num_eval_edges\n        #     target_node_neg=tensor(target_node_neg_indices) \n        #        # size=num_eval_edges * num_neg_samples_per_eval_edge\n        #   )\n        # - Optional if no validation / test is performed.\n        self.valid_edge: Dict[str, torch.Tensor] = None\n        self.test_edge: Dict[str, torch.Tensor] = None\n\n        # dimension of node features\n        self.in_dim: int = None\n\n        # dtype of node features.\n        self.feat_dtype: torch.dtype = None", ""]}
{"filename": "src/models/RGCN.py", "chunked_list": ["\"\"\"\nRGCN implemented with DGL\n\nReferences:\n- Modeling Relational Data with Graph Convolutional Networks\n- Paper: https://arxiv.org/abs/1703.06103\n- Code: https://github.com/MichSchli/RelationPrediction\n\"\"\"\nfrom .BaseModules import BaseLinkEncoderDecoder, TensorTypeCast\nimport torch", "from .BaseModules import BaseLinkEncoderDecoder, TensorTypeCast\nimport torch\nimport torch.nn as nn\nimport dgl\nimport dgl.function as fn\n\n\nclass RelGraphConv(dgl.nn.RelGraphConv):\n    '''\n    Wrapper for dgl.nn.RelGraphConv to support edge normalization \n    and automatic loading of edge types.\n    '''\n    def __init__(self, in_feat, out_feat, num_rels,\n                 regularizer=None, num_bases=None,\n                 bias=True, activation=None,\n                 self_loop=True, dropout=0.0, \n                 layer_norm=False, edge_norm=None):\n        '''\n        Parameters:\n        -----------\n        edge_norm: \"right\" or None (default), optional\n            If \"right\", then the edge normalization is applied as in the original paper.\n            If None, then no edge normalization is applied.\n        \n        For usage of other parameters, see `dgl.nn.RelGraphConv`.\n        '''\n        if regularizer is not None and num_bases is None:\n            num_bases = num_rels\n        super().__init__(in_feat, out_feat, num_rels, regularizer, num_bases, \n                         bias, activation, self_loop, dropout, layer_norm)\n        self.edge_norm = edge_norm\n        self.num_rels = num_rels\n    \n    def get_edge_norm(self, g: dgl.DGLGraph):\n        '''\n        Get edge normalization weights for the graph.\n        '''\n        if self.edge_norm == \"right\":\n            with g.local_scope():\n                g.edata[\"etypes_onehot\"] = torch.nn.functional.one_hot(\n                    g.edata[dgl.ETYPE], num_classes=self.num_rels).type(dtype=torch.float32)\n                g.update_all(fn.copy_e(\"etypes_onehot\", \"m\"), fn.sum(\"m\", \"etypes_deg\"))\n                g.dstdata[\"etypes_deg\"].reciprocal_()\n                g.dstdata[\"etypes_deg\"][g.dstdata[\"etypes_deg\"].isinf()] = 0\n                g.apply_edges(fn.e_dot_v(\"etypes_onehot\", \"etypes_deg\", \"norm\"))\n                norm = g.edata[\"norm\"]\n        elif self.edge_norm is None:\n            norm = None\n        else:\n            raise ValueError(f\"Unknown option for RelGraphConv: edge_norm={self.edge_norm}\")\n        return norm\n    \n    def forward(self, g, feat, *, presorted=False):\n        '''\n        Wrapper for `dgl.nn.RelGraphConv.forward` to support edge normalization\n        and automatic loading of edge types.\n        '''\n        etypes = g.edata[dgl.ETYPE]\n        norm = self.get_edge_norm(g)\n        return super().forward(g, feat, etypes, norm=norm, presorted=presorted)", "\nclass TypedLinear(dgl.nn.TypedLinear):\n    '''\n    Wrapper for dgl.nn.TypedLinear.\n    '''\n    def forward(self, h, ntypes):\n        return super().forward(h, ntypes, sorted_by_type=False)\n\nclass RGCN(BaseLinkEncoderDecoder):\n    def __init__(self, in_dim, n_layers, hidden_dims, n_relations, n_nodetypes, device, dtype=None,\n                 activation=nn.PReLU, dropout=0.5, weight_decay=5e-4, regularizer=None,\n                 n_bases=None, edge_norm='right', bias=False, norm=nn.LayerNorm, \n                 add_self_loops=True, decoder_type=None, decoder_n_layers=None, \n                 decoder_hidden_dims=[], decoder_out_dim=1, \n                 feat_encoder_dims=[]):\n        '''\n        Initialize link prediction model (encoder + decoder) with RGCN as encoder.\n\n        Parameters:\n        -----------\n        in_dim: int\n            Input feature dimension\n        n_layers: int\n            Number of graph convolution layers\n        hidden_dims: int or list[int]\n            Hidden dimension of each graph convolution layer\n            if int, then the same hidden dimension is used for all layers\n        n_relations: int\n            Number of relations for edges in the graph\n        n_nodetypes: int\n            Number of node types in the graph\n        device: torch.device\n            Device to run the model\n        dtype: torch.dtype\n            Data type of the model\n        activation : nn.Module or None, optional\n            Activation function for the model, by default nn.PReLU.\n        dropout : float, optional\n            Dropout rate for the model\n        weight_decay : float, optional\n            Weight for L2 regularization\n        norm : nn.Module or None, optional\n            Normalization function for the model, by default None\n        add_self_loops : bool, optional\n            Always add self-loops for each node during message passing, by default True\n        feat_encoder_dims: list[int], optional\n            Dimensions of the additional dense layers (`TypedLinear) for feature embedding \n            before graph convolution, by default [], which uses no such layer.\n        \n        For usages of regularizer, n_bases, bias, edge_norm, see `RelGraphConv`.\n        For usages of decoder_type, decoder_n_layers, decoder_hidden_dims, decoder_out_dim, \n            see `BaseLinkEncoderDecoder`.\n        '''\n        if type(hidden_dims) is int:\n            hidden_dims = [hidden_dims] * n_layers\n        else:\n            assert len(hidden_dims) == n_layers\n        self.n_layers = n_layers\n        self.hidden_dims = hidden_dims\n        self.n_relations = n_relations\n        self.n_nodetypes = n_nodetypes\n        self.edge_norm = edge_norm\n        self.bias = bias\n        if type(norm) is str:\n            norm = eval(norm)\n        self.norm = norm\n        if type(activation) is str:\n            activation = eval(activation)\n        self.activation = activation\n        self.dropout = dropout\n        self.weight_decay = float(weight_decay)\n        self.regularizer = regularizer\n        self.n_bases = n_bases\n        self.add_self_loops = add_self_loops\n        self.feat_encoder_dims = feat_encoder_dims    \n\n        self.decoder_type = decoder_type\n        if self.decoder_type is None:\n            decoder_config = None\n        else:\n            decoder_config = dict(\n                type=self.decoder_type,\n                n_relations=self.n_relations\n            )\n        super().__init__(\n            decoder_n_layers=decoder_n_layers,\n            decoder_hidden_dims=decoder_hidden_dims, \n            decoder_out_dim=decoder_out_dim,\n            decoder_config=decoder_config,\n            norm=None, activation=self.activation, dropout=0,\n            device=device)\n        \n        if len(self.feat_encoder_dims) > 0:\n            # Cast feat tensor type\n            self.layers.append(\n                TensorTypeCast(torch.float32)\n            )\n\n            _dims = [in_dim] + self.feat_encoder_dims\n            for i in range(1, len(_dims)):\n                self.layers.append(\n                    TypedLinear(\n                        _dims[i - 1], _dims[i], \n                        num_types=self.n_nodetypes\n                    )\n                )\n                self.ntype_layer_ind.add(len(self.layers) - 1)\n\n                # order: Conv -> Norm -> Activation -> Dropout\n                if self.norm is not None:\n                    self.layers.append(\n                        self.norm(_dims[i])\n                    )\n                if self.activation is not None:\n                    self.layers.append(\n                        self.activation()\n                    )\n                self.layers.append(\n                    nn.Dropout(self.dropout)\n                )\n\n            _dims = [self.feat_encoder_dims[-1]] + self.hidden_dims\n        else:\n            _dims = [in_dim] + self.hidden_dims\n        \n        for i in range(1, len(_dims)):\n            self.layers.append(\n                RelGraphConv(\n                    _dims[i - 1], _dims[i], self.n_relations,\n                    regularizer=self.regularizer,\n                    num_bases=self.n_bases,\n                    bias=self.bias,\n                    self_loop=self.add_self_loops,\n                    edge_norm=self.edge_norm\n                )\n            )\n            self.graph_layer_ind.add(len(self.layers) - 1)\n            if i != len(_dims) - 1:\n                # order: Conv -> Norm -> Activation -> Dropout\n                if self.norm is not None:\n                    self.layers.append(\n                        self.norm(_dims[i])\n                    )\n                if self.activation is not None:\n                    self.layers.append(\n                        self.activation()\n                    )\n                self.layers.append(\n                    nn.Dropout(self.dropout)\n                )", "class RGCN(BaseLinkEncoderDecoder):\n    def __init__(self, in_dim, n_layers, hidden_dims, n_relations, n_nodetypes, device, dtype=None,\n                 activation=nn.PReLU, dropout=0.5, weight_decay=5e-4, regularizer=None,\n                 n_bases=None, edge_norm='right', bias=False, norm=nn.LayerNorm, \n                 add_self_loops=True, decoder_type=None, decoder_n_layers=None, \n                 decoder_hidden_dims=[], decoder_out_dim=1, \n                 feat_encoder_dims=[]):\n        '''\n        Initialize link prediction model (encoder + decoder) with RGCN as encoder.\n\n        Parameters:\n        -----------\n        in_dim: int\n            Input feature dimension\n        n_layers: int\n            Number of graph convolution layers\n        hidden_dims: int or list[int]\n            Hidden dimension of each graph convolution layer\n            if int, then the same hidden dimension is used for all layers\n        n_relations: int\n            Number of relations for edges in the graph\n        n_nodetypes: int\n            Number of node types in the graph\n        device: torch.device\n            Device to run the model\n        dtype: torch.dtype\n            Data type of the model\n        activation : nn.Module or None, optional\n            Activation function for the model, by default nn.PReLU.\n        dropout : float, optional\n            Dropout rate for the model\n        weight_decay : float, optional\n            Weight for L2 regularization\n        norm : nn.Module or None, optional\n            Normalization function for the model, by default None\n        add_self_loops : bool, optional\n            Always add self-loops for each node during message passing, by default True\n        feat_encoder_dims: list[int], optional\n            Dimensions of the additional dense layers (`TypedLinear) for feature embedding \n            before graph convolution, by default [], which uses no such layer.\n        \n        For usages of regularizer, n_bases, bias, edge_norm, see `RelGraphConv`.\n        For usages of decoder_type, decoder_n_layers, decoder_hidden_dims, decoder_out_dim, \n            see `BaseLinkEncoderDecoder`.\n        '''\n        if type(hidden_dims) is int:\n            hidden_dims = [hidden_dims] * n_layers\n        else:\n            assert len(hidden_dims) == n_layers\n        self.n_layers = n_layers\n        self.hidden_dims = hidden_dims\n        self.n_relations = n_relations\n        self.n_nodetypes = n_nodetypes\n        self.edge_norm = edge_norm\n        self.bias = bias\n        if type(norm) is str:\n            norm = eval(norm)\n        self.norm = norm\n        if type(activation) is str:\n            activation = eval(activation)\n        self.activation = activation\n        self.dropout = dropout\n        self.weight_decay = float(weight_decay)\n        self.regularizer = regularizer\n        self.n_bases = n_bases\n        self.add_self_loops = add_self_loops\n        self.feat_encoder_dims = feat_encoder_dims    \n\n        self.decoder_type = decoder_type\n        if self.decoder_type is None:\n            decoder_config = None\n        else:\n            decoder_config = dict(\n                type=self.decoder_type,\n                n_relations=self.n_relations\n            )\n        super().__init__(\n            decoder_n_layers=decoder_n_layers,\n            decoder_hidden_dims=decoder_hidden_dims, \n            decoder_out_dim=decoder_out_dim,\n            decoder_config=decoder_config,\n            norm=None, activation=self.activation, dropout=0,\n            device=device)\n        \n        if len(self.feat_encoder_dims) > 0:\n            # Cast feat tensor type\n            self.layers.append(\n                TensorTypeCast(torch.float32)\n            )\n\n            _dims = [in_dim] + self.feat_encoder_dims\n            for i in range(1, len(_dims)):\n                self.layers.append(\n                    TypedLinear(\n                        _dims[i - 1], _dims[i], \n                        num_types=self.n_nodetypes\n                    )\n                )\n                self.ntype_layer_ind.add(len(self.layers) - 1)\n\n                # order: Conv -> Norm -> Activation -> Dropout\n                if self.norm is not None:\n                    self.layers.append(\n                        self.norm(_dims[i])\n                    )\n                if self.activation is not None:\n                    self.layers.append(\n                        self.activation()\n                    )\n                self.layers.append(\n                    nn.Dropout(self.dropout)\n                )\n\n            _dims = [self.feat_encoder_dims[-1]] + self.hidden_dims\n        else:\n            _dims = [in_dim] + self.hidden_dims\n        \n        for i in range(1, len(_dims)):\n            self.layers.append(\n                RelGraphConv(\n                    _dims[i - 1], _dims[i], self.n_relations,\n                    regularizer=self.regularizer,\n                    num_bases=self.n_bases,\n                    bias=self.bias,\n                    self_loop=self.add_self_loops,\n                    edge_norm=self.edge_norm\n                )\n            )\n            self.graph_layer_ind.add(len(self.layers) - 1)\n            if i != len(_dims) - 1:\n                # order: Conv -> Norm -> Activation -> Dropout\n                if self.norm is not None:\n                    self.layers.append(\n                        self.norm(_dims[i])\n                    )\n                if self.activation is not None:\n                    self.layers.append(\n                        self.activation()\n                    )\n                self.layers.append(\n                    nn.Dropout(self.dropout)\n                )", ""]}
{"filename": "src/models/GraphSAGE.py", "chunked_list": ["\"\"\"\nGraphSAGE implemented with DGL\n\nReferences:\n- Inductive Representation Learning on Large Graphs\n- Paper: https://arxiv.org/abs/1706.02216\n- Code: https://github.com/williamleif/GraphSAGE\n\"\"\"\nfrom .BaseModules import BaseLinkEncoderDecoder, TensorTypeCast\nimport torch", "from .BaseModules import BaseLinkEncoderDecoder, TensorTypeCast\nimport torch\nimport torch.nn as nn\nimport dgl\n\nclass SAGE(BaseLinkEncoderDecoder):\n    def __init__(self, in_dim, n_layers, hidden_dims, n_relations, device, dtype=None,\n            n_nodetypes=1, activation=nn.PReLU, dropout=0.2, \n            aggr_type=\"mean\", bias=False, norm=nn.LayerNorm,\n            decoder_type=None, decoder_n_layers=None, decoder_hidden_dims=[], decoder_out_dim=1):\n        '''\n        Initialize link prediction model (encoder + decoder) with GraphSAGE as encoder.\n\n        Parameters:\n        -----------\n        in_dim: int\n            Input feature dimension\n        n_layers: int\n            Number of graph convolution layers\n        hidden_dims: int or list[int]\n            Hidden dimension of each graph convolution layer\n            if int, then the same hidden dimension is used for all layers\n        n_relations: int\n            Number of relations for edges in the graph\n        device: torch.device\n            Device to run the model\n        dtype: torch.dtype\n            Data type of the model\n        n_nodetypes: int, optional\n            Number of node types in the graph\n            Optional as GraphSAGE does not use node type information\n        activation : nn.Module or None, optional\n            Activation function for the model, by default nn.PReLU.\n        dropout : float, optional\n            Dropout rate for the model, by default 0.2\n        norm : nn.Module or None, optional\n            Normalization function for the model, by default None\n        \n        \n        For usages of aggr_type and bias, see `dgl.nn.SAGEConv`.\n        For usages of decoder_type, decoder_n_layers, decoder_hidden_dims, decoder_out_dim, \n            see `BaseLinkEncoderDecoder`.\n        '''\n\n        if type(hidden_dims) is int:\n            hidden_dims = [hidden_dims] * n_layers\n        else:\n            assert len(hidden_dims) == n_layers\n        self.n_layers = n_layers\n        self.hidden_dims = hidden_dims\n        self.n_relations = n_relations\n        self.aggr_type = aggr_type\n        self.bias = bias\n        if type(norm) is str:\n            norm = eval(norm)\n        self.norm = norm\n        if type(activation) is str:\n            activation = eval(activation)\n        self.activation = activation\n        self.dropout = dropout\n\n        self.decoder_type = decoder_type\n        if self.decoder_type is None:\n            decoder_config = None\n        else:\n            decoder_config = dict(\n                type=self.decoder_type,\n                n_relations=self.n_relations\n            )\n        super().__init__(\n            decoder_n_layers=decoder_n_layers,\n            decoder_hidden_dims=decoder_hidden_dims, \n            decoder_out_dim=decoder_out_dim,\n            decoder_config=decoder_config,\n            norm=None, activation=self.activation, dropout=0,\n            device=device)\n        \n        self.init(in_dim, hidden_dims, n_layers)\n\n    def init(self, in_feats, n_hidden, n_layers):\n        _dims = [in_feats] + n_hidden\n        \n        # Cast feat tensor type for mag240m dataset\n        self.layers.append(\n            TensorTypeCast(torch.float32)\n        )\n\n        for i in range(1, len(_dims)):\n            self.layers.append(\n                dgl.nn.SAGEConv(_dims[i - 1], _dims[i], self.aggr_type, \n                    bias=self.bias)\n            )\n            self.graph_layer_ind.add(len(self.layers) - 1)\n            if i != len(_dims) - 1:\n                # order: Conv -> Norm -> Activation -> Dropout\n                if self.norm is not None:\n                    self.layers.append(\n                        self.norm(_dims[i])\n                    )\n                if self.activation is not None:\n                    self.layers.append(\n                        self.activation()\n                    )\n                self.layers.append(\n                    nn.Dropout(self.dropout)\n                )", "    "]}
{"filename": "src/models/GCN.py", "chunked_list": ["\"\"\"\nAdopted from https://github.com/dmlc/dgl/blob/master/examples/pytorch/gcn/gcn.py\n\nGCN implemented with DGL\n\nReferences:\n- Semi-Supervised Classification with Graph Convolutional Networks\n- Paper: https://arxiv.org/abs/1609.02907\n- Code: https://github.com/tkipf/gcn\n\"\"\"", "- Code: https://github.com/tkipf/gcn\n\"\"\"\nfrom .BaseModules import BaseLinkEncoderDecoder\nimport torch\nimport torch as th\nimport torch.nn as nn\nimport dgl.function as fn\nfrom dgl.nn.pytorch.conv import graphconv\n\nclass GCN(BaseLinkEncoderDecoder):\n    def __init__(self, in_dim, n_layers, hidden_dims, n_relations, device, dtype=None,\n        n_nodetypes=1, activation=nn.PReLU, dropout=0.5, weight_decay=5e-4,\n        edge_norm='both', bias=False, norm=nn.LayerNorm, add_self_loops=True,\n        decoder_type=None, decoder_n_layers=None, decoder_hidden_dims=[], decoder_out_dim=1):\n        '''\n        Initialize link prediction model (encoder + decoder) with GCN as encoder.\n\n        Parameters:\n        -----------\n        in_dim: int\n            Input feature dimension\n        n_layers: int\n            Number of graph convolution layers\n        hidden_dims: int or list[int]\n            Hidden dimension of each graph convolution layer\n            if int, then the same hidden dimension is used for all layers\n        n_relations: int\n            Number of relations for edges in the graph\n        device: torch.device\n            Device to run the model\n        dtype: torch.dtype\n            Data type of the model\n        n_nodetypes: int, optional\n            Number of node types in the graph\n            Optional as GCN does not use node type information\n        activation : nn.Module or None, optional\n            Activation function for the model, by default nn.PReLU.\n        dropout : float, optional\n            Dropout rate for the model, by default 0\n        weight_decay : float, optional\n            Weight for L2 regularization, by default 5e-4\n        norm : nn.Module or None, optional\n            Normalization function for the model, by default None\n        add_self_loops : bool, optional\n            Always add self-loops for each node during message passing, by default True\n        \n        For usages of edge_norm and bias, see `dgl.nn.pytorch.conv.graphconv`.\n        For usages of decoder_type, decoder_n_layers, decoder_hidden_dims, decoder_out_dim, \n            see `BaseLinkEncoderDecoder`.\n        '''\n\n        if type(hidden_dims) is int:\n            hidden_dims = [hidden_dims] * n_layers\n        else:\n            assert len(hidden_dims) == n_layers\n        self.n_layers = n_layers\n        self.hidden_dims = hidden_dims\n        self.n_relations = n_relations\n        self.edge_norm = edge_norm\n        self.bias = bias\n        if type(norm) is str:\n            norm = eval(norm)\n        self.norm = norm\n        if type(activation) is str:\n            activation = eval(activation)\n        self.activation = activation\n        self.dropout = dropout\n        self.weight_decay = float(weight_decay)\n        self.add_self_loops = add_self_loops\n\n        self.decoder_type = decoder_type\n        if self.decoder_type is None:\n            decoder_config = None\n        else:\n            decoder_config = dict(\n                type=self.decoder_type,\n                n_relations=self.n_relations\n            )\n        super().__init__(\n            decoder_n_layers=decoder_n_layers,\n            decoder_hidden_dims=decoder_hidden_dims, \n            decoder_out_dim=decoder_out_dim,\n            decoder_config=decoder_config,\n            norm=None, activation=self.activation, dropout=0,\n            device=device)\n        \n        _dims = [in_dim] + self.hidden_dims\n\n        for i in range(1, len(_dims)):\n            self.layers.append(\n                GraphConv(_dims[i - 1], _dims[i], \n                    norm=self.edge_norm, bias=self.bias, \n                    add_self_loops=add_self_loops)\n            )\n            self.graph_layer_ind.add(len(self.layers) - 1)\n            if i != len(_dims) - 1:\n                # order: Conv -> Norm -> Activation -> Dropout\n                if self.norm is not None:\n                    self.layers.append(\n                        self.norm(_dims[i])\n                    )\n                if self.activation is not None:\n                    self.layers.append(\n                        self.activation()\n                    )\n                self.layers.append(\n                    nn.Dropout(self.dropout)\n                )\n    \n    def loss_fn(self, pos_graph, neg_graph, pos_logits, neg_logits):\n        '''\n        Training loss function that adds an L2 regularization term in addition to the \n        cross entropy loss.\n\n        Parameters:\n        ----------\n            pos_graph : dgl.DGLGraph\n                Graph with edges as positive link prediction targets\n            neg_graph : dgl.DGLGraph\n                Graph with edges as negative link prediction targets\n            pos_logits : torch.Tensor\n                Link prediction scores for edges in `pos_graph`\n            neg_logits : torch.Tensor\n                Link prediction scores for edges in `neg_graph`\n        \n        Returns:\n        ----------\n            loss : torch.Tensor\n                Cross-entropy loss\n        '''\n        entropy_loss = super().loss_fn(pos_graph, neg_graph, pos_logits, neg_logits)\n        l2_loss = self.weight_decay * torch.linalg.norm(self.layers[0].weight, ord=\"fro\")\n        total_loss = entropy_loss + l2_loss\n        return total_loss", "\nclass GCN(BaseLinkEncoderDecoder):\n    def __init__(self, in_dim, n_layers, hidden_dims, n_relations, device, dtype=None,\n        n_nodetypes=1, activation=nn.PReLU, dropout=0.5, weight_decay=5e-4,\n        edge_norm='both', bias=False, norm=nn.LayerNorm, add_self_loops=True,\n        decoder_type=None, decoder_n_layers=None, decoder_hidden_dims=[], decoder_out_dim=1):\n        '''\n        Initialize link prediction model (encoder + decoder) with GCN as encoder.\n\n        Parameters:\n        -----------\n        in_dim: int\n            Input feature dimension\n        n_layers: int\n            Number of graph convolution layers\n        hidden_dims: int or list[int]\n            Hidden dimension of each graph convolution layer\n            if int, then the same hidden dimension is used for all layers\n        n_relations: int\n            Number of relations for edges in the graph\n        device: torch.device\n            Device to run the model\n        dtype: torch.dtype\n            Data type of the model\n        n_nodetypes: int, optional\n            Number of node types in the graph\n            Optional as GCN does not use node type information\n        activation : nn.Module or None, optional\n            Activation function for the model, by default nn.PReLU.\n        dropout : float, optional\n            Dropout rate for the model, by default 0\n        weight_decay : float, optional\n            Weight for L2 regularization, by default 5e-4\n        norm : nn.Module or None, optional\n            Normalization function for the model, by default None\n        add_self_loops : bool, optional\n            Always add self-loops for each node during message passing, by default True\n        \n        For usages of edge_norm and bias, see `dgl.nn.pytorch.conv.graphconv`.\n        For usages of decoder_type, decoder_n_layers, decoder_hidden_dims, decoder_out_dim, \n            see `BaseLinkEncoderDecoder`.\n        '''\n\n        if type(hidden_dims) is int:\n            hidden_dims = [hidden_dims] * n_layers\n        else:\n            assert len(hidden_dims) == n_layers\n        self.n_layers = n_layers\n        self.hidden_dims = hidden_dims\n        self.n_relations = n_relations\n        self.edge_norm = edge_norm\n        self.bias = bias\n        if type(norm) is str:\n            norm = eval(norm)\n        self.norm = norm\n        if type(activation) is str:\n            activation = eval(activation)\n        self.activation = activation\n        self.dropout = dropout\n        self.weight_decay = float(weight_decay)\n        self.add_self_loops = add_self_loops\n\n        self.decoder_type = decoder_type\n        if self.decoder_type is None:\n            decoder_config = None\n        else:\n            decoder_config = dict(\n                type=self.decoder_type,\n                n_relations=self.n_relations\n            )\n        super().__init__(\n            decoder_n_layers=decoder_n_layers,\n            decoder_hidden_dims=decoder_hidden_dims, \n            decoder_out_dim=decoder_out_dim,\n            decoder_config=decoder_config,\n            norm=None, activation=self.activation, dropout=0,\n            device=device)\n        \n        _dims = [in_dim] + self.hidden_dims\n\n        for i in range(1, len(_dims)):\n            self.layers.append(\n                GraphConv(_dims[i - 1], _dims[i], \n                    norm=self.edge_norm, bias=self.bias, \n                    add_self_loops=add_self_loops)\n            )\n            self.graph_layer_ind.add(len(self.layers) - 1)\n            if i != len(_dims) - 1:\n                # order: Conv -> Norm -> Activation -> Dropout\n                if self.norm is not None:\n                    self.layers.append(\n                        self.norm(_dims[i])\n                    )\n                if self.activation is not None:\n                    self.layers.append(\n                        self.activation()\n                    )\n                self.layers.append(\n                    nn.Dropout(self.dropout)\n                )\n    \n    def loss_fn(self, pos_graph, neg_graph, pos_logits, neg_logits):\n        '''\n        Training loss function that adds an L2 regularization term in addition to the \n        cross entropy loss.\n\n        Parameters:\n        ----------\n            pos_graph : dgl.DGLGraph\n                Graph with edges as positive link prediction targets\n            neg_graph : dgl.DGLGraph\n                Graph with edges as negative link prediction targets\n            pos_logits : torch.Tensor\n                Link prediction scores for edges in `pos_graph`\n            neg_logits : torch.Tensor\n                Link prediction scores for edges in `neg_graph`\n        \n        Returns:\n        ----------\n            loss : torch.Tensor\n                Cross-entropy loss\n        '''\n        entropy_loss = super().loss_fn(pos_graph, neg_graph, pos_logits, neg_logits)\n        l2_loss = self.weight_decay * torch.linalg.norm(self.layers[0].weight, ord=\"fro\")\n        total_loss = entropy_loss + l2_loss\n        return total_loss", "\n\nclass GraphConv(graphconv.GraphConv):\n    '''\n    Modified Graph Convolutional Layer based on DGL 0.7.2 implementation\n    to add option to always include self loops in message passing.\n    '''\n    def __init__(self, in_feats, out_feats, norm='both', \n                 weight=True, bias=True, activation=None, \n                 allow_zero_in_degree=False, add_self_loops=True):\n        '''\n        Parameters:\n        -----------\n            add_self_loops : bool, optional\n                Always include self-loops in the graph for message passing, by default True\n            For usages of all other parameters, see `dgl.nn.pytorch.conv.graphconv`.\n        '''\n        super().__init__(in_feats, out_feats, norm, weight, bias, activation, allow_zero_in_degree)\n        self.add_self_loops = add_self_loops\n\n    def forward(self, graph, feat, weight=None, edge_weight=None):\n        r\"\"\"\n        Parameters\n        ----------\n        graph : DGLGraph\n            The graph.\n        feat : torch.Tensor or pair of torch.Tensor\n            If a torch.Tensor is given, it represents the input feature of shape\n            :math:`(N, D_{in})`\n            where :math:`D_{in}` is size of input feature, :math:`N` is the number of nodes.\n            If a pair of torch.Tensor is given, which is the case for bipartite graph, the pair\n            must contain two tensors of shape :math:`(N_{in}, D_{in_{src}})` and\n            :math:`(N_{out}, D_{in_{dst}})`.\n        weight : torch.Tensor, optional\n            Optional external weight tensor.\n        edge_weight : torch.Tensor, optional\n            Optional tensor on the edge. If given, the convolution will weight\n            with regard to the message.\n\n        Returns\n        -------\n        torch.Tensor\n            The output feature\n\n        Raises\n        ------\n        DGLError\n            Case 1:\n            If there are 0-in-degree nodes in the input graph, it will raise DGLError\n            since no message will be passed to those nodes. This will cause invalid output.\n            The error can be ignored by setting ``allow_zero_in_degree`` parameter to ``True``.\n\n            Case 2:\n            External weight is provided while at the same time the module\n            has defined its own weight parameter.\n\n        Note\n        ----\n        * Input shape: :math:`(N, *, \\text{in_feats})` where * means any number of additional\n          dimensions, :math:`N` is the number of nodes.\n        * Output shape: :math:`(N, *, \\text{out_feats})` where all but the last dimension are\n          the same shape as the input.\n        * Weight shape: :math:`(\\text{in_feats}, \\text{out_feats})`.\n        \"\"\"\n        with graph.local_scope():\n            if not (self._allow_zero_in_degree or self.add_self_loops):\n                if (graph.in_degrees() == 0).any():\n                    raise graphconv.DGLError('There are 0-in-degree nodes in the graph, '\n                                   'output for those nodes will be invalid. '\n                                   'This is harmful for some applications, '\n                                   'causing silent performance regression. '\n                                   'Adding self-loop on the input graph by '\n                                   'calling `g = dgl.add_self_loop(g)` will resolve '\n                                   'the issue. Setting ``allow_zero_in_degree`` '\n                                   'to be `True` when constructing this module will '\n                                   'suppress the check and let the code run.')\n            aggregate_fn = fn.copy_src('h', 'm')\n            if edge_weight is not None:\n                assert edge_weight.shape[0] == graph.number_of_edges()\n                graph.edata['_edge_weight'] = edge_weight\n                aggregate_fn = fn.u_mul_e('h', '_edge_weight', 'm')\n\n            # (BarclayII) For RGCN on heterogeneous graphs we need to support GCN on bipartite.\n            feat_src, feat_dst = graphconv.expand_as_pair(feat, graph)\n            if self._norm in ['left', 'both']:\n                if not self.add_self_loops:\n                    degs = graph.out_degrees().float().clamp(min=1)\n                else:\n                    degs = graph.out_degrees().float()\n                    if graph.is_block:\n                        degs[:graph.num_dst_nodes()] += 1\n                    else:\n                        degs += 1\n                if self._norm == 'both':\n                    norm = th.pow(degs, -0.5)\n                else:\n                    norm = 1.0 / degs\n                shp = norm.shape + (1,) * (feat_src.dim() - 1)\n                norm = th.reshape(norm, shp)\n                feat_src = feat_src * norm\n\n            if weight is not None:\n                if self.weight is not None:\n                    raise graphconv.DGLError('External weight is provided while at the same time the'\n                                   ' module has defined its own weight parameter. Please'\n                                   ' create the module with flag weight=False.')\n            else:\n                weight = self.weight\n\n            if self._in_feats > self._out_feats:\n                # mult W first to reduce the feature size for aggregation.\n                if weight is not None:\n                    feat_src = th.matmul(feat_src, weight)\n                graph.srcdata['h'] = feat_src\n                if self.add_self_loops:\n                    if graph.is_block:\n                        graph.dstdata['h'] = graph.srcdata['h'][:graph.num_dst_nodes()]\n                    else:\n                        graph.dstdata['h'] = graph.srcdata['h']\n                graph.update_all(aggregate_fn, fn.sum(msg='m', out='neigh'))\n                rst = graph.dstdata['neigh'] + graph.dstdata['h']\n            else:\n                # aggregate first then mult W\n                graph.srcdata['h'] = feat_src\n                if self.add_self_loops:\n                    if graph.is_block:\n                        graph.dstdata['h'] = graph.srcdata['h'][:graph.num_dst_nodes()]\n                    else:\n                        graph.dstdata['h'] = graph.srcdata['h']\n                graph.update_all(aggregate_fn, fn.sum(msg='m', out='neigh'))\n                rst = graph.dstdata['neigh'] + graph.dstdata['h']\n                if weight is not None:\n                    rst = th.matmul(rst, weight)\n\n            if self._norm in ['right', 'both']:\n                if not self.add_self_loops:\n                    degs = graph.in_degrees().float().clamp(min=1)\n                else:\n                    degs = graph.in_degrees().float() + 1\n                if self._norm == 'both':\n                    norm = th.pow(degs, -0.5)\n                else:\n                    norm = 1.0 / degs\n                shp = norm.shape + (1,) * (feat_dst.dim() - 1)\n                norm = th.reshape(norm, shp)\n                rst = rst * norm\n\n            if self.bias is not None:\n                rst = rst + self.bias\n\n            if self._activation is not None:\n                rst = self._activation(rst)\n\n            return rst", "\n"]}
{"filename": "src/models/MLP.py", "chunked_list": ["\"\"\"\nMLP implemented with DGL\n\"\"\"\nfrom .BaseModules import BaseLinkEncoderDecoder, TensorTypeCast\nimport torch\nimport torch.nn as nn\n\n\nclass MLP(BaseLinkEncoderDecoder):\n    def __init__(self, in_dim, n_layers, hidden_dims, device, dtype=torch.float32,\n        n_relations=1, n_nodetypes=1, activation=nn.PReLU, dropout=0.5, weight_decay=5e-4,\n        bias=False, norm=nn.LayerNorm,\n        decoder_n_layers=None, decoder_hidden_dims=[], decoder_out_dim=1):\n        '''\n        Initialize link prediction model (encoder + decoder) with graph-agnostic MLP as encoder.\n\n        Parameters:\n        -----------\n        in_dim: int\n            Input feature dimension\n        n_layers: int\n            Number of MLP layers\n        hidden_dims: int or list[int]\n            Hidden dimension of each MLP layer\n            if int, then the same hidden dimension is used for all layers\n        n_relations: int\n            Number of relations for edges in the graph\n            Optional as MLP does not use node type information\n        device: torch.device\n            Device to run the model\n        dtype: torch.dtype\n            Data type of the model\n        n_nodetypes: int, optional\n            Number of node types in the graph\n            Optional as MLP does not use node type information\n        activation : nn.Module or None, optional\n            Activation function for the model, by default nn.PReLU.\n        dropout : float, optional\n            Dropout rate for the model, by default 0.5\n        weight_decay : float, optional\n            Weight for L2 regularization, by default 5e-4\n        norm : nn.Module or None, optional\n            Normalization function for the model, by default None\n        \n        \n        For usages of bias, see `torch.nn.Linear`.\n        For usages of decoder_n_layers, decoder_hidden_dims, decoder_out_dim, \n            see `BaseLinkEncoderDecoder`.\n        '''\n\n        if type(hidden_dims) is int:\n            hidden_dims = [hidden_dims] * n_layers\n        else:\n            assert len(hidden_dims) == n_layers\n        self.n_layers = n_layers\n        self.hidden_dims = hidden_dims\n        self.bias = bias\n        if type(norm) is str:\n            norm = eval(norm)\n        self.norm = norm\n        if type(activation) is str:\n            activation = eval(activation)\n        self.activation = activation\n        self.dropout = dropout\n        self.weight_decay = float(weight_decay)\n\n        super().__init__(\n            decoder_n_layers=decoder_n_layers,\n            decoder_hidden_dims=decoder_hidden_dims, \n            decoder_out_dim=decoder_out_dim,\n            norm=None, activation=self.activation, dropout=0)\n        \n        _dims = [in_dim] + self.hidden_dims\n\n        # Cast feat tensor type for mag240m dataset\n        self.layers.append(\n            TensorTypeCast(torch.float32)\n        )\n        \n        for i in range(1, len(_dims)):\n            self.layers.append(\n                torch.nn.Linear(_dims[i - 1], _dims[i], \n                    bias=self.bias)\n            )\n            # For MLP, no graph layer exists\n            # self.graph_layer_ind.add(len(self.layers) - 1)\n            if i != len(_dims) - 1:\n                # order: Conv -> Norm -> Activation -> Dropout\n                if self.norm is not None:\n                    self.layers.append(\n                        self.norm(_dims[i])\n                    )\n                if self.activation is not None:\n                    self.layers.append(\n                        self.activation()\n                    )\n                self.layers.append(\n                    nn.Dropout(self.dropout)\n                )\n    \n    def loss_fn(self, pos_graph, neg_graph, pos_logits, neg_logits):\n        '''\n        Training loss function that adds an L2 regularization term in addition to the \n        cross entropy loss.\n\n        Parameters:\n        ----------\n            pos_graph : dgl.DGLGraph\n                Graph with edges as positive link prediction targets\n            neg_graph : dgl.DGLGraph\n                Graph with edges as negative link prediction targets\n            pos_logits : torch.Tensor\n                Link prediction scores for edges in `pos_graph`\n            neg_logits : torch.Tensor\n                Link prediction scores for edges in `neg_graph`\n        \n        Returns:\n        ----------\n            loss : torch.Tensor\n                Cross-entropy loss\n        '''\n        entropy_loss = super().loss_fn(pos_graph, neg_graph, pos_logits, neg_logits)\n        l2_loss = self.weight_decay * torch.linalg.norm(self.layers[1].weight, ord=\"fro\")\n        total_loss = entropy_loss + l2_loss\n        return total_loss", "class MLP(BaseLinkEncoderDecoder):\n    def __init__(self, in_dim, n_layers, hidden_dims, device, dtype=torch.float32,\n        n_relations=1, n_nodetypes=1, activation=nn.PReLU, dropout=0.5, weight_decay=5e-4,\n        bias=False, norm=nn.LayerNorm,\n        decoder_n_layers=None, decoder_hidden_dims=[], decoder_out_dim=1):\n        '''\n        Initialize link prediction model (encoder + decoder) with graph-agnostic MLP as encoder.\n\n        Parameters:\n        -----------\n        in_dim: int\n            Input feature dimension\n        n_layers: int\n            Number of MLP layers\n        hidden_dims: int or list[int]\n            Hidden dimension of each MLP layer\n            if int, then the same hidden dimension is used for all layers\n        n_relations: int\n            Number of relations for edges in the graph\n            Optional as MLP does not use node type information\n        device: torch.device\n            Device to run the model\n        dtype: torch.dtype\n            Data type of the model\n        n_nodetypes: int, optional\n            Number of node types in the graph\n            Optional as MLP does not use node type information\n        activation : nn.Module or None, optional\n            Activation function for the model, by default nn.PReLU.\n        dropout : float, optional\n            Dropout rate for the model, by default 0.5\n        weight_decay : float, optional\n            Weight for L2 regularization, by default 5e-4\n        norm : nn.Module or None, optional\n            Normalization function for the model, by default None\n        \n        \n        For usages of bias, see `torch.nn.Linear`.\n        For usages of decoder_n_layers, decoder_hidden_dims, decoder_out_dim, \n            see `BaseLinkEncoderDecoder`.\n        '''\n\n        if type(hidden_dims) is int:\n            hidden_dims = [hidden_dims] * n_layers\n        else:\n            assert len(hidden_dims) == n_layers\n        self.n_layers = n_layers\n        self.hidden_dims = hidden_dims\n        self.bias = bias\n        if type(norm) is str:\n            norm = eval(norm)\n        self.norm = norm\n        if type(activation) is str:\n            activation = eval(activation)\n        self.activation = activation\n        self.dropout = dropout\n        self.weight_decay = float(weight_decay)\n\n        super().__init__(\n            decoder_n_layers=decoder_n_layers,\n            decoder_hidden_dims=decoder_hidden_dims, \n            decoder_out_dim=decoder_out_dim,\n            norm=None, activation=self.activation, dropout=0)\n        \n        _dims = [in_dim] + self.hidden_dims\n\n        # Cast feat tensor type for mag240m dataset\n        self.layers.append(\n            TensorTypeCast(torch.float32)\n        )\n        \n        for i in range(1, len(_dims)):\n            self.layers.append(\n                torch.nn.Linear(_dims[i - 1], _dims[i], \n                    bias=self.bias)\n            )\n            # For MLP, no graph layer exists\n            # self.graph_layer_ind.add(len(self.layers) - 1)\n            if i != len(_dims) - 1:\n                # order: Conv -> Norm -> Activation -> Dropout\n                if self.norm is not None:\n                    self.layers.append(\n                        self.norm(_dims[i])\n                    )\n                if self.activation is not None:\n                    self.layers.append(\n                        self.activation()\n                    )\n                self.layers.append(\n                    nn.Dropout(self.dropout)\n                )\n    \n    def loss_fn(self, pos_graph, neg_graph, pos_logits, neg_logits):\n        '''\n        Training loss function that adds an L2 regularization term in addition to the \n        cross entropy loss.\n\n        Parameters:\n        ----------\n            pos_graph : dgl.DGLGraph\n                Graph with edges as positive link prediction targets\n            neg_graph : dgl.DGLGraph\n                Graph with edges as negative link prediction targets\n            pos_logits : torch.Tensor\n                Link prediction scores for edges in `pos_graph`\n            neg_logits : torch.Tensor\n                Link prediction scores for edges in `neg_graph`\n        \n        Returns:\n        ----------\n            loss : torch.Tensor\n                Cross-entropy loss\n        '''\n        entropy_loss = super().loss_fn(pos_graph, neg_graph, pos_logits, neg_logits)\n        l2_loss = self.weight_decay * torch.linalg.norm(self.layers[1].weight, ord=\"fro\")\n        total_loss = entropy_loss + l2_loss\n        return total_loss"]}
{"filename": "src/models/BaseModules.py", "chunked_list": ["import numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport dgl\nimport dgl.function as fn\nimport tqdm\nfrom collections import deque\nimport time\nfrom functools import cached_property", "import time\nfrom functools import cached_property\nimport warnings\n\nfrom .DistMult import DistMultDecoder\n\nclass BaseLinkEncoderDecoder(nn.Module):\n    '''\n    Base class for link prediction encoder and decoders. \n\n    To implement a complete model, inherit from this class and make sure that:\n    1. All encoder layers must be added to `self.layers` in sequential order.\n    2. Indices of all GNN layers must be added to `self.graph_layer_ind`.\n    3. Indices of all layers that require node type information must be added to `self.node_type_ind`.\n    4. Override `loss_fn` to consider additional loss terms.\n    5. `__init__` function must contain the following arguments to maintain compatibility with \n        the training pipeline:\n        - in_dim: int\n            Input feature dimension\n        - n_relations: int\n            Number of relations for edges in the graph\n        - n_nodetypes: int, optional\n            Number of node types in the graph\n        - device: torch.device\n            Device to run the model\n        - dtype: torch.dtype\n            Data type of the model\n        Other arguments defined in `models.{model_name}.model_params in `params.yaml` will be forwarded as kwargs.\n        See pipeline.SessionMgr.SessionMgr.create_model for more details.\n    6. If any GNN layer conducts message passing beyond 1-hop neighbors of each node (e.g. MixHop, H2GCN), \n       you will need to reimplement `get_MFG_nodes`.\n    '''\n\n    def __init__(self, decoder_config=None, decoder_n_layers=None, decoder_hidden_dims=[],\n                 decoder_out_dim=1, norm=None, activation=nn.PReLU, dropout=0, device=None) -> None:\n        '''\n        Initialize base class and decoder for link prediction models\n        Currently supported decoders include dot-product, MLP, and DistMult.\n\n        Parameters: \n        ----------\n        decoder_config : None or dict, optional\n            Specify the decoder type and its configurations:\n            - For MLP or dot-product decoder, use None (default, see also decoder_hidden_dims)\n            - For DistMult decoder, use {\"type\": \"DistMult\", \"n_relations\": int} and\n                set n_relations as the number of relations in the graph.\n        decoder_hidden_dims : int or list[int], optional\n            Hidden dimensions of the decoder model. \n            - If [] (default), a non-parameterized dot product decoder will be used. \n            - For MLP decoder: \n                * If the type is int, the number of layers must be specified in the decoder_n_layers, \n                    and each layer will have the same hidden dimension as specified.\n                * Use list[int] to specify both the number of layers and the hidden dimensions of each layer.\n            - For DistMult decoder, use list[int] with length 1 to specify the size of relation embeddings.\n        decoder_n_layers : int or None, optional\n            Number of layers in the decoder.\n            - If None, the number of layers will be inferred from the length of decoder_hidden_dims.\n            - Must be specified if decoder_hidden_dims is set as an int.\n        decoder_out_dim : int, optional\n            Output dimension of the decoder, by default 1 for link prediction. \n        norm : nn.Module or None, optional\n            Normalization function for the decoder, by default None\n        activation : nn.Module or None, optional\n            Activation function for the decoder, by default nn.PReLU.\n        dropout : float, optional\n            Dropout rate for the decoder, by default 0\n        device : torch.device, optional\n            Device for the decoder module to run on, by default None\n        '''\n        super().__init__()\n        self.graph_layer_ind = set()\n        self.ntype_layer_ind = set()\n        self.layers = nn.ModuleList()\n\n        if decoder_config is None:  # MLP decoder\n            if type(decoder_hidden_dims) is int:\n                decoder_hidden_dims = [\n                    decoder_hidden_dims] * (decoder_n_layers - 1)\n            elif decoder_n_layers is None:\n                decoder_n_layers = len(decoder_hidden_dims) + 1\n            else:\n                assert len(decoder_hidden_dims) == decoder_n_layers - 1\n            self.decoder_dims = decoder_hidden_dims\n            self.decoder_out_dim = decoder_out_dim\n\n            if len(decoder_hidden_dims) > 0:\n                self.decoder_type = None\n                self.hg_decoder = False\n                self.decoder_layers = nn.ModuleList()\n\n                _dims = [self.hidden_dims[-1], *\n                         self.decoder_dims, decoder_out_dim]\n                for i in range(1, len(_dims)):\n                    self.decoder_layers.append(\n                        nn.Linear(_dims[i - 1], _dims[i], bias=self.bias)\n                    )\n                    if i != len(_dims) - 1:\n                        if norm is not None:\n                            self.decoder_layers.append(\n                                self.norm(_dims[i])\n                            )\n                        if activation is not None:\n                            self.decoder_layers.append(\n                                activation()\n                            )\n                        self.decoder_layers.append(\n                            nn.Dropout(dropout)\n                        )\n\n        elif decoder_config[\"type\"] == \"DistMult\":\n            self.decoder_type = decoder_config[\"type\"]\n            self.hg_decoder = True\n            self.decoder_module = DistMultDecoder(\n                decoder_config[\"n_relations\"],\n                self.hidden_dims[-1],\n                device=device\n            )\n\n        else:\n            raise ValueError(f\"Unknown decoder config {decoder_config}\")\n\n    def encoder(self, blocks, x):\n        '''\n        Run encoder part of the model to generate node embeddings.\n\n        Parameters:\n        ----------\n            blocks : list of dgl.DGLGraph\n                List of graphs (or blocks) for message passing on each GNN layer.\n                The length of the list should be equal to the number of GNN layers.\n            x : torch.Tensor\n                Node features\n        \n        Returns:\n        ----------\n            h : torch.Tensor\n                Node embeddings. \n        '''\n        h = x\n        blocks_queue: deque[dgl.DGLGraph] = deque(blocks)\n        for l, layer in enumerate(self.layers):\n            if l in self.graph_layer_ind: \n                # GNN layer\n                block = blocks_queue[0]\n                blocks_queue.popleft()\n                h = layer(block, h)\n            elif l in self.ntype_layer_ind: \n                # Layer that needs to know node types\n                h = layer(h, ntypes=blocks_queue[0].srcdata[dgl.NTYPE])\n            else: \n                # All other layers that do not consume graph information\n                h = layer(h)\n        if len(blocks_queue) != 0:\n            warnings.warn(\n                \"There are more blocks than GNN layers; please check sampler config.\")\n            time.sleep(5)\n        return h\n\n    def encoder_generator(self, block, h):\n        '''\n        A generator version of encoder that yields the node embeddings obtained after each GNN layer.\n        This function is used during evaluation to conduct layer-wise inference and \n        avoid extensive storage of the intermediate node embeddings, which is a generalization of the \n        `SAGE.inference` function in\n        https://github.com/dmlc/dgl/blob/master/examples/pytorch/graphsage/node_classification.py#L34\n        \n        Parameters:\n        ----------\n            block : dgl.DGLGraph\n                Graph (or block) for message passing on the first GNN layer.\n            h : torch.Tensor\n                Node features for the first GNN layer.\n        \n        Yields:\n        ----------\n            block_counter : int\n                Index of block (or GNN layer) to be consumed (or processed) next.\n                `block_counter < 0` indicates that all GNN layers of the encoder have been processed, \n                    and no value can be yielded from the generator.\n            h : torch.Tensor\n                Node embeddings obtained after the GNN layer indexed by `block_counter`.\n        \n        generator.send(block, h): \n        ----------\n            block : dgl.DGLGraph\n                Graph (or block) for message passing for the next GNN layer\n                (indexed by yielded `block_counter`).\n            h : torch.Tensor\n                Node features for the next GNN layer.\n        '''\n        block_counter = 0\n        h_container = deque([h])\n        del h\n        for l, layer in enumerate(self.layers):\n            if l in self.ntype_layer_ind:  # Layer that needs to know node types\n                if block is None:  # Needs to fetch a new block from generator.send()\n                    h_container.append(None)\n                    # Yield block_counter and h_container[0] (h obtained from previous layer)\n                    # and receive new block and h for the next GNN layer\n                    block, h_container[0] = yield (block_counter, h_container.popleft())\n                h_container[0] = layer(\n                    h_container[0], ntypes=block.srcdata[dgl.NTYPE])\n                # Do not discard block until next GraphConv layer\n            elif l in self.graph_layer_ind:  # GNN layer\n                if block is None:  # Needs to fetch a new block from generator.send()\n                    h_container.append(None)\n                    # Yield block_counter and h_container[0] (h obtained from previous layer)\n                    # and receive new block and h for the next GNN layer\n                    block, h_container[0] = yield (block_counter, h_container.popleft())\n                h_container[0] = layer(block, h_container[0])\n                block = None  # discard used block\n                block_counter += 1\n            else:  # All other layers that do not consume graph information\n                h_container[0] = layer(h_container[0])\n\n        # Return final node embeddings\n        block = None\n        # negate block_counter to indicate the end of generator\n        yield -block_counter, h_container.popleft()\n\n    def decoder(self, z: torch.Tensor, graph: dgl.DGLGraph, neg_graph: dgl.DGLGraph = None):\n        '''\n        Get link prediction scores with node embeddings and DGL graphs.\n\n        Parameters:\n        ----------\n            z : torch.Tensor\n                Node embeddings\n            graph : dgl.DGLGraph\n                Graph with edges as (positive) link prediction targets\n            neg_graph : dgl.DGLGraph, optional\n                Graph with edges as negative link prediction targets\n        \n        Returns: \n        ----------\n            score : torch.Tensor\n                Link prediction scores for edges in `graph`\n            neg_score : torch.Tensor, if neg_graph is not None\n                Link prediction scores for edges in `neg_graph`\n        '''\n\n        if self.decoder_type is None:\n            with graph.local_scope():\n                graph.ndata['h'] = z\n                if len(self.decoder_layers) > 0:\n                    graph.apply_edges(fn.u_mul_v('h', 'h', 'dot_prod'))\n                    h = graph.edata['dot_prod']\n                else:\n                    graph.apply_edges(fn.u_dot_v('h', 'h', 'score'))\n                    score = graph.edata['score']\n\n            if len(self.decoder_layers) > 0:\n                for _, layer in enumerate(self.decoder_layers):\n                    h = layer(h)\n                    score = h\n\n            if neg_graph is not None:\n                neg_score = self.decoder(z, neg_graph)\n                return score, neg_score\n            else:\n                return score\n\n        else:  # DistMult\n            return self.decoder_module.decoder(z, graph, neg_graph)\n\n    def decoder_mat(self, uh, vh, etypes=None):\n        '''\n        Get link prediction scores from embeddings of source and destination nodes.\n\n        Parameters:\n        ----------\n            uh: torch.Tensor\n                Embeddings of source nodes\n            vh: torch.Tensor\n                Embeddings of destination nodes\n            etypes: torch.IntTensor, optional\n                Edge types in heterogeneous graphs\n        \n        Returns: \n        ----------\n            score : torch.Tensor\n                Link prediction scores for edges\n        '''\n        if self.decoder_type is None:\n            h = uh * vh\n            if len(self.decoder_layers) > 0:\n                for _, layer in enumerate(self.decoder_layers):\n                    h = layer(h)\n                score = h.squeeze(-1)\n            else:\n                score = h.sum(-1)\n            return score\n        else:\n            return self.decoder_module.decoder_mat(uh, vh, etypes)\n\n    def forward(self, blocks, features, graph, neg_graph=None):\n        '''\n        Run forward pass (encoder + decoder) of the model. \n\n        Parameters:\n        ----------\n            blocks : list of dgl.DGLGraph\n                List of graphs (or blocks) for message passing on each GNN layer.\n                The length of the list should be equal to the number of GNN layers.\n            features : torch.Tensor\n                Node features\n            graph : dgl.DGLGraph\n                Graph with edges as (positive) link prediction targets\n            neg_graph : dgl.DGLGraph, optional\n                Graph with edges as negative link prediction targets\n        \n        Returns: see function `decoder`.\n        '''\n        z = self.encoder(blocks, features)\n        adj_rec = self.decoder(z, graph, neg_graph)\n        return adj_rec\n\n    def loss_fn(self, pos_graph, neg_graph, pos_logits, neg_logits):\n        '''\n        Cross-entropy loss for link prediction scores.\n        To consider additional loss terms, override this function in child classes.\n\n        Parameters:\n        ----------\n            pos_graph : dgl.DGLGraph\n                Graph with edges as positive link prediction targets\n            neg_graph : dgl.DGLGraph\n                Graph with edges as negative link prediction targets\n            pos_logits : torch.Tensor\n                Link prediction scores for edges in `pos_graph`\n            neg_logits : torch.Tensor\n                Link prediction scores for edges in `neg_graph`\n        \n        Returns:\n        ----------\n            loss : torch.Tensor\n                Cross-entropy loss\n        '''\n        score = torch.cat([pos_logits, neg_logits])\n        label = torch.cat(\n            [torch.ones_like(pos_logits), torch.zeros_like(neg_logits)])\n\n        num_non_pos_edges = float(neg_graph.num_edges())\n        pos_weight = torch.tensor(num_non_pos_edges / pos_graph.num_edges())\n        loss = F.binary_cross_entropy_with_logits(\n            score, label.float(), reduction=\"mean\", pos_weight=pos_weight)\n        return loss\n\n    def get_MFG_nodes(self, graph: dgl.DGLGraph, eval_nodes: np.ndarray,\n                      depth: int = None, include_inputs=False):\n        '''\n        Get nodes in the message flow graph (MFG) for layer-wise inference during evaluation.\n        This is used to determine which nodes to compute embeddings for in a layer-wise inference.\n\n        Parameters:\n        ----------\n            graph : dgl.DGLGraph\n                Graph used for message passing during evaluation. \n            eval_nodes : np.ndarray\n                ID of nodes to evaluate on that needs to be embedded.\n            depth : int, optional\n                Number of GNN layers to derive the MFG.\n                Default: None, which considers all GNN layers.\n            include_inputs : bool, optional\n                Whether to derive the MFG for the input layer.\n                Default: False, since node features are always accessible in the input layer.\n        '''\n        if depth is None:\n            depth = len(self.graph_layer_ind)\n            if not include_inputs:\n                depth -= 1\n\n        node_list = [None] * depth + [eval_nodes]\n        pgs = tqdm.tqdm(\n            reversed(range(depth)),\n            desc=\"Calculate MFG Nodes\",\n            dynamic_ncols=True,\n            total=depth)\n        for i in pgs:\n            pgs.set_postfix(num_nodes=len(node_list[i + 1]))\n            if len(node_list[i + 1]) == graph.num_nodes():\n                # All nodes have already been in the MFG\n                node_list[i] = node_list[i + 1]\n                continue\n            s_graph = dgl.sampling.sample_neighbors(\n                graph, node_list[i + 1], -1,\n                copy_ndata=False, copy_edata=False\n            )\n            u, _ = s_graph.edges()\n            del s_graph\n            nodes = torch.cat((u, node_list[i + 1]))\n            node_list[i] = nodes.unique()\n        pgs.close()\n        return node_list\n\n    def cleanup_step(self):\n        '''\n        Model specific clean up function, which is called after each training step. \n        Default behavior is do nothing; should be overridden in child classes if needed.\n        '''\n\n    @property\n    def num_conv_layers(self) -> int:\n        '''\n        Get number of GNN layers in the model.\n        '''\n        return len(self.graph_layer_ind)\n\n    @cached_property\n    def num_model_params(self) -> int:\n        '''\n        Get number of parameters in the model.\n        '''\n        return sum([p.nelement() for p in self.parameters()])", "\n\nclass TensorTypeCast(torch.nn.Module):\n    '''\n    Cast tensor to a different data type.\n    '''\n    def __init__(self, dtype):\n        '''\n        Parameters:\n        ----------\n            dtype : torch.dtype\n                Data type to cast to.\n        '''\n        super().__init__()\n        self.dst_dtype = dtype\n\n    def forward(self, h):\n        return h.type(dtype=self.dst_dtype)"]}
{"filename": "src/models/__init__.py", "chunked_list": ["from . import GraphSAGE, GCN, MLP, RGCN\n\n# Defines the corresponding model class for each model name used in `params.yaml`.\nmodelDict = {\n    \"GraphSAGE\": GraphSAGE.SAGE,\n    \"GCN\": GCN.GCN,\n    \"RGCN\": RGCN.RGCN,\n    \"ClusterGCN\": GCN.GCN,\n    \"ClusterSAGE\": GraphSAGE.SAGE,\n    \"MLP\": MLP.MLP", "    \"ClusterSAGE\": GraphSAGE.SAGE,\n    \"MLP\": MLP.MLP\n}"]}
{"filename": "src/models/DistMult.py", "chunked_list": ["'''\nDistMult decoder implemented with DGL\n\nReferences:\n- Embedding Entities and Relations for Learning and Inference in Knowledge Bases\n- Paper: https://arxiv.org/abs/1412.6575\n'''\nimport torch\nimport torch.nn as nn\nimport dgl", "import torch.nn as nn\nimport dgl\nimport dgl.function as fn\n\nclass DistMultDecoder(nn.Module):\n    def __init__(self, n_relations: int, hidden_dims: int, \n                 device, gamma=40.0, dtype=torch.float32) -> None:\n        '''\n        Initialize DistMult decoder.\n        \n        Parameters:\n        -----------\n        n_relations: int\n            Number of relations for edges in the graph\n        hidden_dims: int\n            Dimension of DistMult embeddings\n        device: torch.device\n            Device to run the model\n        gamma: float, optional\n            Amplitude of the embedding initialization, by default 40.0\n        dtype: torch.dtype, optional\n            Data type of the model, by default torch.float32\n        '''\n        super().__init__()\n        self.n_relations = n_relations\n        self.hidden_dims = hidden_dims\n        self.gamma = gamma\n        self.device = device\n\n        self._w_relation = nn.Embedding(\n            self.n_relations, self.hidden_dims, \n            device=self.device, dtype=dtype)\n        self.trained_rels = torch.zeros(self.n_relations, \n            device=self.device, dtype=torch.float32)\n        emb_init = self.gamma / self.hidden_dims\n        nn.init.uniform_(self._w_relation.weight, -emb_init, emb_init)\n\n    def decoder(self, z, graph, neg_graph=None):\n        '''\n        Overrides `BaseLinkEncoderDecoder.decoder`.\n        '''\n        with graph.local_scope():\n            graph.ndata['h'] = z\n            graph.apply_edges(fn.u_mul_v('h', 'h', 'dot_prod'))\n            etypes = graph.edata[dgl.ETYPE]\n            check_mask = torch.zeros_like(etypes, dtype=torch.bool)\n            for etype_id in torch.arange(self.n_relations, device=self.device):\n                rel_embedding = self._w_relation(etype_id)\n                rel_mask = (etypes == etype_id)\n                graph.edata[\"dot_prod\"][rel_mask] *= rel_embedding\n                check_mask[rel_mask] = True\n                self.trained_rels[etype_id] += rel_mask.sum()\n            assert check_mask.all()\n            score = graph.edata[\"dot_prod\"].sum(-1, keepdims=True)\n\n        if neg_graph is not None:\n            neg_score = self.decoder(z, neg_graph)\n            return score, neg_score\n        else:\n            return score\n    \n    def decoder_mat(self, uh, vh, etypes):\n        '''\n        Overrides `BaseLinkEncoderDecoder.decoder_mat`.\n        '''\n        h = uh * vh\n        check_mask = torch.zeros_like(etypes, dtype=torch.bool)\n        for etype_id in torch.arange(self.n_relations, device=self.device):\n            rel_embedding = self._w_relation(etype_id)\n            rel_mask = (etypes == etype_id)\n            h[rel_mask] *= rel_embedding\n            check_mask[rel_mask] = True\n        assert check_mask.all()\n        score = h.sum(-1)\n        return score", ""]}
