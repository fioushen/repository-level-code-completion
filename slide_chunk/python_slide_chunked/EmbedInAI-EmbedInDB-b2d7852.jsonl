{"filename": "setup.py", "chunked_list": ["import os\n\nimport setuptools\n\n\ndef read(fname):\n    with open(\n        os.path.join(os.path.dirname(__file__), fname), \"r\", encoding=\"utf-8\"\n    ) as fh:\n        return fh.read()", "\n\nsetuptools.setup(\n    name=\"embedin\",\n    version=\"0.2.2-alpha\",\n    author=\"EmbedInAI\",\n    author_email=\"EmbedInAI@gmail.com\",\n    description=\"A lightweight vector database\",\n    long_description=read(\"README.md\"),\n    long_description_content_type=\"text/markdown\",", "    long_description=read(\"README.md\"),\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/EmbedInAI/EmbedInDB\",\n    packages=setuptools.find_packages(exclude=[\"tests\"]),\n    install_requires=read(\"requirements.txt\"),\n    include_package_data=True,\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Operating System :: OS Independent\",", "        \"License :: OSI Approved :: Apache Software License\",\n        \"Operating System :: OS Independent\",\n    ],\n    python_requires=\">=3.6\",\n)\n"]}
{"filename": "tests/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"]}
{"filename": "tests/index/test_flat_index.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\n", "import unittest\n\nimport numpy as np\nfrom faiss import IndexFlatIP\n\nfrom embedin.index.flat_index import FlatIndex\n\n\nclass TestFlatIndex(unittest.TestCase):\n    def setUp(self):\n        d = 64  # dimension\n        nb = 10**5  # database size\n        nq = 2  # nb of queries - TODO >= 5 will have segmentation fault\n        np.random.seed(1234)  # make reproducible\n        self.xb = np.random.random((nb, d)).astype(\"float32\")\n        self.xb[:, 0] += np.arange(nb) / 1000.0\n        self.xq = np.random.random((nq, d)).astype(\"float32\")\n        self.xq[:, 0] += np.arange(nq) / 1000.0\n\n        self.top_k = 2\n\n        self.gold_answer = np.array(\n            [207, 381, 1394, 1019, 555, 210, 417, 1619, 837, 557]\n        )\n\n        self.nn = FlatIndex(self.xb)\n\n    def test_init(self):\n        self.assertTrue(np.array_equal(self.nn.embeddings, np.array(self.xb)))\n        self.assertIsInstance(self.nn.index, IndexFlatIP)\n        self.assertEqual(self.nn.index.ntotal, len(self.xb))\n\n    def test_build_index(self):\n        index = self.nn._build_index()\n        self.assertTrue(isinstance(index, IndexFlatIP))\n\n    def test_search_index(self):\n        indices = self.nn._search_index(self.xq, top_k=10)\n        self.assertTrue(np.array_equal(indices[0], self.gold_answer))\n\n    def test_search(self):\n        indices = self.nn.search(self.xq, top_k=10)\n        self.assertTrue(np.array_equal(indices[0], self.gold_answer))\n\n    def test_update_index(self):\n        count = len(self.xb)\n        self.assertEqual(self.nn.index.ntotal, count)\n\n        new_embeddings = self.xq[0].tolist()\n        self.nn.update_index(new_embeddings)\n        count += 1\n        self.assertEqual(self.nn.index.ntotal, count)\n        indices = self.nn.search(self.xq[0], top_k=10)\n        self.assertTrue(count - 1 in indices.tolist())\n\n        new_embeddings = [self.xq[0].tolist(), self.xq[0].tolist()]\n        self.nn.update_index(new_embeddings)\n        count += len(new_embeddings)\n        self.assertEqual(self.nn.index.ntotal, count)\n        indices = self.nn.search(self.xq[0], top_k=10)\n        for i in range(len(new_embeddings)):\n            self.assertTrue(count - 1 - i in indices.tolist())\n\n        new_embeddings = []\n        self.nn.update_index(new_embeddings)\n        count += len(new_embeddings)\n        self.assertEqual(self.nn.index.ntotal, count)\n\n        new_embeddings = None\n        self.nn.update_index(new_embeddings)\n        self.assertEqual(self.nn.index.ntotal, count)\n\n    def test_get_embeddings(self):\n        embeddings = self.nn.get_embeddings()\n        self.assertTrue(np.array_equal(embeddings, np.array(self.xb)))", "class TestFlatIndex(unittest.TestCase):\n    def setUp(self):\n        d = 64  # dimension\n        nb = 10**5  # database size\n        nq = 2  # nb of queries - TODO >= 5 will have segmentation fault\n        np.random.seed(1234)  # make reproducible\n        self.xb = np.random.random((nb, d)).astype(\"float32\")\n        self.xb[:, 0] += np.arange(nb) / 1000.0\n        self.xq = np.random.random((nq, d)).astype(\"float32\")\n        self.xq[:, 0] += np.arange(nq) / 1000.0\n\n        self.top_k = 2\n\n        self.gold_answer = np.array(\n            [207, 381, 1394, 1019, 555, 210, 417, 1619, 837, 557]\n        )\n\n        self.nn = FlatIndex(self.xb)\n\n    def test_init(self):\n        self.assertTrue(np.array_equal(self.nn.embeddings, np.array(self.xb)))\n        self.assertIsInstance(self.nn.index, IndexFlatIP)\n        self.assertEqual(self.nn.index.ntotal, len(self.xb))\n\n    def test_build_index(self):\n        index = self.nn._build_index()\n        self.assertTrue(isinstance(index, IndexFlatIP))\n\n    def test_search_index(self):\n        indices = self.nn._search_index(self.xq, top_k=10)\n        self.assertTrue(np.array_equal(indices[0], self.gold_answer))\n\n    def test_search(self):\n        indices = self.nn.search(self.xq, top_k=10)\n        self.assertTrue(np.array_equal(indices[0], self.gold_answer))\n\n    def test_update_index(self):\n        count = len(self.xb)\n        self.assertEqual(self.nn.index.ntotal, count)\n\n        new_embeddings = self.xq[0].tolist()\n        self.nn.update_index(new_embeddings)\n        count += 1\n        self.assertEqual(self.nn.index.ntotal, count)\n        indices = self.nn.search(self.xq[0], top_k=10)\n        self.assertTrue(count - 1 in indices.tolist())\n\n        new_embeddings = [self.xq[0].tolist(), self.xq[0].tolist()]\n        self.nn.update_index(new_embeddings)\n        count += len(new_embeddings)\n        self.assertEqual(self.nn.index.ntotal, count)\n        indices = self.nn.search(self.xq[0], top_k=10)\n        for i in range(len(new_embeddings)):\n            self.assertTrue(count - 1 - i in indices.tolist())\n\n        new_embeddings = []\n        self.nn.update_index(new_embeddings)\n        count += len(new_embeddings)\n        self.assertEqual(self.nn.index.ntotal, count)\n\n        new_embeddings = None\n        self.nn.update_index(new_embeddings)\n        self.assertEqual(self.nn.index.ntotal, count)\n\n    def test_get_embeddings(self):\n        embeddings = self.nn.get_embeddings()\n        self.assertTrue(np.array_equal(embeddings, np.array(self.xb)))", ""]}
{"filename": "tests/index/test_hnsw_index.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\n", "import unittest\n\nimport numpy as np\nimport torch\n\nfrom hnswlib import Index\nfrom embedin.index.hnsw_index import HNSWIndex\n\n\nclass TestHNSWIndex(unittest.TestCase):\n    def setUp(self):\n        d = 64  # dimension\n        nb = 10**5  # database size\n        nq = 10  # nb of queries\n        np.random.seed(1234)  # make reproducible\n        self.xb = np.random.random((nb, d)).astype(\"float32\")\n        self.xb[:, 0] += np.arange(nb) / 1000.0\n        self.xq = np.random.random((nq, d)).astype(\"float32\")\n        self.xq[:, 0] += np.arange(nq) / 1000.0\n\n        self.top_k = 10\n\n        cos = torch.nn.CosineSimilarity()\n        output = cos(torch.from_numpy(self.xq[0]), torch.from_numpy(self.xb))\n        result = torch.topk(output.flatten(), self.top_k).indices.numpy()\n        self.gold_answer = np.array(\n            [207, 381, 1394, 1019, 555, 210, 417, 1619, 837, 557]\n        )\n        self.assertTrue(np.array_equal(self.gold_answer, result))\n\n        self.nn = HNSWIndex(self.xb)\n\n    def test_init(self):\n        self.assertTrue(np.array_equal(self.nn.embeddings, np.array(self.xb)))\n        self.assertIsInstance(self.nn.index, Index)\n        self.assertEqual(self.nn.index.get_current_count(), len(self.xb))\n\n    def test_build_index(self):\n        index = self.nn._build_index()\n        self.assertTrue(isinstance(index, Index))\n\n    def test_search_index(self):\n        indices = self.nn._search_index(self.xq, top_k=10)\n        self.assertTrue(np.array_equal(indices[0], self.gold_answer))\n\n    def test_search(self):\n        indices = self.nn.search(self.xq, top_k=10)\n        self.assertTrue(np.array_equal(indices[0], self.gold_answer))\n\n    def test_update_index(self):\n        count = len(self.xb)\n        self.assertEqual(self.nn.index.get_current_count(), count)\n\n        new_embeddings = self.xq[0].tolist()\n        self.nn.update_index(new_embeddings)\n        count += 1\n        self.assertEqual(self.nn.index.get_current_count(), count)\n        indices = self.nn.search(self.xq, top_k=10)\n        self.assertTrue(count - 1 in indices[0].tolist())\n\n        new_embeddings = [self.xq[0].tolist(), self.xq[0].tolist()]\n        self.nn.update_index(new_embeddings)\n        count += len(new_embeddings)\n        self.assertEqual(self.nn.index.get_current_count(), count)\n        indices = self.nn.search(self.xq, top_k=10)\n        for i in range(len(new_embeddings)):\n            self.assertTrue(count - 1 - i in indices[0].tolist())\n\n        new_embeddings = []\n        self.nn.update_index(new_embeddings)\n        count += len(new_embeddings)\n        self.assertEqual(self.nn.index.get_current_count(), count)\n\n        new_embeddings = None\n        self.nn.update_index(new_embeddings)\n        self.assertEqual(self.nn.index.get_current_count(), count)\n\n    def test_get_embeddings(self):\n        embeddings = self.nn.get_embeddings()\n        self.assertTrue(np.array_equal(embeddings, np.array(self.xb)))", "\nclass TestHNSWIndex(unittest.TestCase):\n    def setUp(self):\n        d = 64  # dimension\n        nb = 10**5  # database size\n        nq = 10  # nb of queries\n        np.random.seed(1234)  # make reproducible\n        self.xb = np.random.random((nb, d)).astype(\"float32\")\n        self.xb[:, 0] += np.arange(nb) / 1000.0\n        self.xq = np.random.random((nq, d)).astype(\"float32\")\n        self.xq[:, 0] += np.arange(nq) / 1000.0\n\n        self.top_k = 10\n\n        cos = torch.nn.CosineSimilarity()\n        output = cos(torch.from_numpy(self.xq[0]), torch.from_numpy(self.xb))\n        result = torch.topk(output.flatten(), self.top_k).indices.numpy()\n        self.gold_answer = np.array(\n            [207, 381, 1394, 1019, 555, 210, 417, 1619, 837, 557]\n        )\n        self.assertTrue(np.array_equal(self.gold_answer, result))\n\n        self.nn = HNSWIndex(self.xb)\n\n    def test_init(self):\n        self.assertTrue(np.array_equal(self.nn.embeddings, np.array(self.xb)))\n        self.assertIsInstance(self.nn.index, Index)\n        self.assertEqual(self.nn.index.get_current_count(), len(self.xb))\n\n    def test_build_index(self):\n        index = self.nn._build_index()\n        self.assertTrue(isinstance(index, Index))\n\n    def test_search_index(self):\n        indices = self.nn._search_index(self.xq, top_k=10)\n        self.assertTrue(np.array_equal(indices[0], self.gold_answer))\n\n    def test_search(self):\n        indices = self.nn.search(self.xq, top_k=10)\n        self.assertTrue(np.array_equal(indices[0], self.gold_answer))\n\n    def test_update_index(self):\n        count = len(self.xb)\n        self.assertEqual(self.nn.index.get_current_count(), count)\n\n        new_embeddings = self.xq[0].tolist()\n        self.nn.update_index(new_embeddings)\n        count += 1\n        self.assertEqual(self.nn.index.get_current_count(), count)\n        indices = self.nn.search(self.xq, top_k=10)\n        self.assertTrue(count - 1 in indices[0].tolist())\n\n        new_embeddings = [self.xq[0].tolist(), self.xq[0].tolist()]\n        self.nn.update_index(new_embeddings)\n        count += len(new_embeddings)\n        self.assertEqual(self.nn.index.get_current_count(), count)\n        indices = self.nn.search(self.xq, top_k=10)\n        for i in range(len(new_embeddings)):\n            self.assertTrue(count - 1 - i in indices[0].tolist())\n\n        new_embeddings = []\n        self.nn.update_index(new_embeddings)\n        count += len(new_embeddings)\n        self.assertEqual(self.nn.index.get_current_count(), count)\n\n        new_embeddings = None\n        self.nn.update_index(new_embeddings)\n        self.assertEqual(self.nn.index.get_current_count(), count)\n\n    def test_get_embeddings(self):\n        embeddings = self.nn.get_embeddings()\n        self.assertTrue(np.array_equal(embeddings, np.array(self.xb)))", ""]}
{"filename": "tests/index/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\n", "import unittest\n\nimport numpy as np\n\nfrom embedin.index import Index, HNSWIndex, FlatIndex\n\n\nclass TestIndex(unittest.TestCase):\n    def test_index_selection(self):\n        # Test when index_hint is hnsw\n        embeddings = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=\"float32\")\n        index = Index(embeddings, \"hnsw\")\n        self.assertIsInstance(index.index, HNSWIndex)\n\n        # Test when index_hint is flat\n        index = Index(embeddings, \"flat\")\n        self.assertIsInstance(index.index, FlatIndex)\n\n        # Test when embeddings length is less than or equal to 10^6\n        embeddings = np.random.random((10**6 - 1, 3)).astype(\"float32\")\n        index = Index(embeddings)\n        self.assertIsInstance(index.index, FlatIndex)\n\n        # Test when embeddings length is greater than 10^6\n        embeddings = np.random.random((10**6 + 1, 3)).astype(\"float32\")\n        index = Index(embeddings)\n        self.assertIsInstance(index.index, HNSWIndex)\n\n        # Test when embeddings is None\n        embeddings = np.random.random((4, 3)).astype(\"float32\")\n        index = Index(embeddings)\n        self.assertIsInstance(index.index, FlatIndex)\n\n    def test_search(self):\n        # Test search method with top_k=3\n        embeddings = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=\"float32\")\n        index = Index(embeddings)\n        query = np.array([1, 2, 3], dtype=\"float32\")\n        results = index.search(query)\n        self.assertEqual(len(results), 3)\n\n        embeddings = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        index = Index(embeddings)\n        query = [1, 2, 3]\n        results = index.search(query)\n        self.assertEqual(len(results), 3)\n\n    def test_update_index(self):\n        # Test update_index method\n        embeddings = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        index = Index(embeddings)\n        new_embeddings = [[10, 11, 12], [13, 14, 15]]\n        index.update_index(new_embeddings)\n        results = index.search([10, 11, 12])\n        self.assertEqual(len(results), 3)", ""]}
{"filename": "tests/repository/test_embedding_repository.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom datetime import datetime\nfrom unittest import TestCase", "from datetime import datetime\nfrom unittest import TestCase\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom embedin.model.embedding_model import EmbeddingModel, Base\nfrom embedin.repository.embedding_repository import EmbeddingRepository\n\nengine = create_engine(\"sqlite:///:memory:\", echo=True)", "\nengine = create_engine(\"sqlite:///:memory:\", echo=True)\nSession = sessionmaker(bind=engine)\n\n\nclass TestEmbeddingRepository(TestCase):\n    def setUp(self):\n        Base.metadata.create_all(engine)\n        self.session = Session()\n        self.repository = EmbeddingRepository(self.session)\n\n        # Create some EmbeddingModel instances for testing\n        self.embeddings_dict = [\n            dict(\n                id=\"id1\",\n                collection_id=\"collection1\",\n                text=\"some text\",\n                embedding_data=[1.0, 2.0, 3.0],\n                meta_data={\"key1\": \"value1\"},\n                hash=\"hash1\",\n                created_at=datetime.now(),\n            ),\n            dict(\n                id=\"id2\",\n                collection_id=\"collection1\",\n                text=\"some other text\",\n                embedding_data=[4.0, 5.0, 6.0],\n                meta_data={\"key2\": \"value2\"},\n                hash=\"hash2\",\n                created_at=datetime.now(),\n            ),\n        ]\n        self.embeddings = [EmbeddingModel(**data) for data in self.embeddings_dict]\n\n    def tearDown(self):\n        self.session.rollback()\n        # Close the session and drop the in-memory database after testing\n        self.session.close()\n        Base.metadata.drop_all(engine)\n\n    def test_add_rows_one_by_one(self):\n        self.assertEqual(len(self.session.query(EmbeddingModel).all()), 0)\n        self.repository._add_rows_one_by_one(self.embeddings)\n        self.assertEqual(len(self.session.query(EmbeddingModel).all()), 2)\n\n        self.assertEqual(\n            self.session.query(EmbeddingModel).filter_by(id=\"id1\").first().text,\n            \"some text\",\n        )\n        self.assertEqual(\n            self.session.query(EmbeddingModel).filter_by(id=\"id2\").first().text,\n            \"some other text\",\n        )\n\n    def test_add_rows_one_by_one_duplicate(self):\n        self.repository.add_all(self.embeddings_dict)\n        # Test adding duplicate embeddings\n        duplicate_embeddings = [\n            EmbeddingModel(\n                id=\"id3\",\n                collection_id=\"collection1\",\n                text=\"some text\",\n                embedding_data=[1.0, 2.0, 3.0],\n                meta_data={\"key1\": \"value1\"},\n                hash=\"hash1\",\n                created_at=datetime.now(),\n            ),\n            EmbeddingModel(\n                id=\"id4\",\n                collection_id=\"collection1\",\n                text=\"some new text\",\n                embedding_data=[7.0, 8.0, 9.0],\n                meta_data={\"key3\": \"value3\"},\n                hash=\"hash4\",\n                created_at=datetime.now(),\n            ),\n        ]\n        self.repository._add_rows_one_by_one(duplicate_embeddings)\n        self.assertEqual(len(self.session.query(EmbeddingModel).all()), 3)\n        self.assertEqual(\n            self.session.query(EmbeddingModel).filter_by(id=\"id1\").first().text,\n            \"some text\",\n        )\n        self.assertEqual(\n            self.session.query(EmbeddingModel).filter_by(id=\"id2\").first().text,\n            \"some other text\",\n        )\n        self.assertEqual(\n            self.session.query(EmbeddingModel).filter_by(id=\"id4\").first().text,\n            \"some new text\",\n        )\n\n    def test_add_all(self):\n        self.assertEqual(len(self.session.query(EmbeddingModel).all()), 0)\n\n        self.repository.add_all(self.embeddings_dict)\n        self.assertEqual(len(self.session.query(EmbeddingModel).all()), 2)\n\n        self.assertEqual(\n            self.session.query(EmbeddingModel).filter_by(id=\"id1\").first().text,\n            \"some text\",\n        )\n        self.assertEqual(\n            self.session.query(EmbeddingModel).filter_by(id=\"id2\").first().text,\n            \"some other text\",\n        )\n\n    def test_add_all_with_duplicates(self):\n        self.repository.add_all(self.embeddings_dict)\n        # Test adding duplicate embeddings\n        duplicate_embeddings = [\n            dict(\n                id=\"id3\",\n                collection_id=\"collection1\",\n                text=\"some text\",\n                embedding_data=[1.0, 2.0, 3.0],\n                meta_data={\"key1\": \"value1\"},\n                hash=\"hash1\",\n                created_at=datetime.now(),\n            ),\n            dict(\n                id=\"id4\",\n                collection_id=\"collection1\",\n                text=\"some new text\",\n                embedding_data=[7.0, 8.0, 9.0],\n                meta_data={\"key3\": \"value3\"},\n                hash=\"hash4\",\n                created_at=datetime.now(),\n            ),\n        ]\n        self.repository.add_all(duplicate_embeddings)\n        self.assertEqual(len(self.session.query(EmbeddingModel).all()), 3)\n        self.assertEqual(\n            self.session.query(EmbeddingModel).filter_by(id=\"id1\").first().text,\n            \"some text\",\n        )\n        self.assertEqual(\n            self.session.query(EmbeddingModel).filter_by(id=\"id2\").first().text,\n            \"some other text\",\n        )\n        self.assertEqual(\n            self.session.query(EmbeddingModel).filter_by(id=\"id4\").first().text,\n            \"some new text\",\n        )\n\n    def test_get_by_ids(self):\n        self.repository.add_all(self.embeddings_dict)\n        ids = [\"id1\", \"id2\"]\n        rows = self.repository.get_by_ids(ids)\n        self.assertEqual(len(rows), 2)\n        self.assertEqual(rows[0].get(\"id\"), \"id1\")\n        self.assertEqual(rows[0].get(\"collection_id\"), \"collection1\")\n        self.assertEqual(rows[0].get(\"text\"), \"some text\")\n        self.assertEqual(rows[0].get(\"embedding_data\"), [1.0, 2.0, 3.0])\n        self.assertEqual(rows[0].get(\"meta_data\"), {\"key1\": \"value1\"})\n        self.assertEqual(rows[0].get(\"hash\"), \"hash1\")\n        self.assertIsInstance(rows[0].get(\"created_at\"), str)\n        self.assertEqual(rows[1].get(\"id\"), \"id2\")\n        self.assertEqual(rows[1].get(\"collection_id\"), \"collection1\")\n        self.assertEqual(rows[1].get(\"text\"), \"some other text\")\n        self.assertEqual(rows[1].get(\"embedding_data\"), [4.0, 5.0, 6.0])\n        self.assertEqual(rows[1].get(\"meta_data\"), {\"key2\": \"value2\"})\n        self.assertEqual(rows[1].get(\"hash\"), \"hash2\")\n        self.assertIsInstance(rows[1].get(\"created_at\"), str)\n\n    def test_get_by_collection_id(self):\n        self.repository.add_all(self.embeddings_dict)\n        collection_id = \"collection1\"\n        rows = self.repository.get_by_collection_id(collection_id)\n        self.assertEqual(len(rows), 2)\n        self.assertEqual(rows[0].get(\"id\"), \"id1\")\n        self.assertEqual(rows[0].get(\"collection_id\"), \"collection1\")\n        self.assertEqual(rows[0].get(\"text\"), \"some text\")\n        self.assertEqual(rows[0].get(\"embedding_data\"), [1.0, 2.0, 3.0])\n        self.assertEqual(rows[0].get(\"meta_data\"), {\"key1\": \"value1\"})\n        self.assertEqual(rows[0].get(\"hash\"), \"hash1\")\n        self.assertIsInstance(rows[0].get(\"created_at\"), str)\n        self.assertEqual(rows[1].get(\"id\"), \"id2\")\n        self.assertEqual(rows[1].get(\"collection_id\"), \"collection1\")\n        self.assertEqual(rows[1].get(\"text\"), \"some other text\")\n        self.assertEqual(rows[1].get(\"embedding_data\"), [4.0, 5.0, 6.0])\n        self.assertEqual(rows[1].get(\"meta_data\"), {\"key2\": \"value2\"})\n        self.assertEqual(rows[1].get(\"hash\"), \"hash2\")\n        self.assertIsInstance(rows[1].get(\"created_at\"), str)", ""]}
{"filename": "tests/repository/test_collection_repository.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom unittest import TestCase, mock\nfrom unittest.mock import Mock, patch, MagicMock", "from unittest import TestCase, mock\nfrom unittest.mock import Mock, patch, MagicMock\n\nfrom embedin.model.collection_model import CollectionModel\nfrom embedin.repository.collection_repository import CollectionRepository\n\n\nclass TestCollectionRepository(TestCase):\n    def setUp(self):\n        self.session_mock = Mock()\n        self.repo = CollectionRepository(self.session_mock)\n\n    def test_get_by_name(self):\n        # Mocking a CollectionModel object\n        collection = CollectionModel(id=\"123\", name=\"test_collection\")\n        self.session_mock.query.return_value.filter_by.return_value.first.return_value = (\n            collection\n        )\n\n        # Call the method and assert the result\n        result = self.repo.get_by_name(\"test_collection\")\n        self.assertEqual(result, collection.to_dict())\n\n        # Verify that the query was executed with the correct arguments\n        self.session_mock.query.assert_called_once_with(CollectionModel)\n        self.session_mock.query.return_value.filter_by.assert_called_once_with(\n            name=\"test_collection\"\n        )\n        self.session_mock.query.return_value.filter_by.return_value.first.assert_called_once()\n\n    def test_get_by_name_return_empty_dict(self):\n        self.session_mock.query.return_value.filter_by.return_value.first.return_value = (\n            None\n        )\n\n        # Call the method and assert the result\n        result = self.repo.get_by_name(\"test_collection\")\n        self.assertEqual(result, {})\n\n    def test_create(self):\n        # call create method\n        name = \"test_collection\"\n\n        # mock the get_by_name method\n        with patch.object(self.repo, \"get_by_name\", return_value=None):\n            collection = self.repo.create(name)\n            self.assertIsInstance(collection, dict)\n            self.assertIsNotNone(collection)\n            self.assertEqual(collection.get(\"name\"), name)\n            self.assertIsInstance(collection.get(\"id\"), str)\n\n    def test_create_raise_exception(self):\n        # call create method\n        name = \"test_collection\"\n        # Mocking a CollectionModel object\n        mock_collection = CollectionModel(id=\"123\", name=name)\n        with patch.object(self.repo, \"get_by_name\", return_value=mock_collection):\n            with self.assertRaises(ValueError):\n                self.repo.create(name, get_if_exist=False)\n\n    def test_create_with_commit_error(self):\n        # Configure the commit method of the mock session to raise an exception\n        self.session_mock.commit.side_effect = Exception(\"Mocked commit error\")\n\n        name = \"test_collection\"\n        with patch.object(self.repo, \"get_by_name\", return_value=None):\n            collection = self.repo.create(name, get_if_exist=True)\n            self.assertIsNone(collection)\n            self.session_mock.rollback.assert_called_once_with()\n\n    def test_create_already_exists(self):\n        # call create method\n        name = \"test_collection\"\n\n        # Mocking a CollectionModel object\n        mock_collection = dict(id=\"123\", name=name)\n        with patch.object(self.repo, \"get_by_name\", return_value=mock_collection):\n            collection = self.repo.create(name)\n            self.assertIsInstance(collection, dict)\n            self.assertIsNotNone(collection)\n            self.assertEqual(collection.get(\"name\"), mock_collection[\"name\"])\n            self.assertEqual(collection.get(\"id\"), mock_collection[\"id\"])", ""]}
{"filename": "tests/repository/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"]}
{"filename": "tests/model/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport unittest", "import datetime\nimport unittest\nfrom unittest.mock import MagicMock\n\nfrom embedin.model import Model\n\n\nclass ModelTestCase(unittest.TestCase):\n    def test_to_dict(self):\n        # Create a mock object for the self.__table__ attribute\n        mock_table = MagicMock()\n\n        # Mock the columns and their names\n        mock_col1 = MagicMock()\n        mock_col2 = MagicMock()\n        mock_col1.name = \"col1\"\n        mock_col2.name = \"col2\"\n        mock_table.c = [mock_col1, mock_col2]\n\n        # Create a mock instance of the Model class\n        model = Model()\n\n        # Set mock values for the attributes\n        model.col1 = \"value1\"\n        model.col2 = datetime.datetime(2023, 5, 20)\n\n        # Assign the mock_table directly to the __table__ attribute\n        Model.__table__ = mock_table\n\n        # Call the to_dict() method\n        result = model.to_dict()\n\n        # Check if the output is as expected\n        expected = {\"col1\": \"value1\", \"col2\": \"2023-05-20T00:00:00\"}\n        self.assertEqual(result, expected)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/model/test_collection_model.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\nfrom sqlalchemy import create_engine", "import unittest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom embedin.model.collection_model import CollectionModel, Base\n\nengine = create_engine(\"sqlite:///:memory:\", echo=True)\nSession = sessionmaker(bind=engine)\n\n\nclass TestCollectionModel(unittest.TestCase):\n    def setUp(self):\n        Base.metadata.create_all(engine)\n        self.session = Session()\n\n    def tearDown(self):\n        self.session.rollback()\n        self.session.close()\n        Base.metadata.drop_all(engine)\n\n    def test_collection_model(self):\n        # Create a new collection\n        collection = CollectionModel(id=\"1\", name=\"test\")\n        self.session.add(collection)\n        self.session.commit()\n\n        # Retrieve the collection from the database\n        retrieved_collection = (\n            self.session.query(CollectionModel).filter_by(id=\"1\").one()\n        )\n\n        # Check that the retrieved collection matches the original collection\n        self.assertEqual(collection.id, retrieved_collection.id)\n        self.assertEqual(collection.name, retrieved_collection.name)\n\n    def test_duplicate_name(self):\n        # Create a new collection with a duplicate name\n        collection1 = CollectionModel(id=\"1\", name=\"test\")\n        collection2 = CollectionModel(id=\"2\", name=\"test\")\n\n        # Add the first collection to the database\n        self.session.add(collection1)\n        self.session.commit()\n\n        # Try to add the second collection to the database\n        with self.assertRaises(Exception):\n            self.session.add(collection2)\n            self.session.commit()\n\n        # Roll back the session to clear the transaction\n        self.session.rollback()\n\n        # Check that the second collection was not added to the database\n        self.assertEqual(\n            self.session.query(CollectionModel).filter_by(name=\"test\").count(), 1\n        )", "\n\nclass TestCollectionModel(unittest.TestCase):\n    def setUp(self):\n        Base.metadata.create_all(engine)\n        self.session = Session()\n\n    def tearDown(self):\n        self.session.rollback()\n        self.session.close()\n        Base.metadata.drop_all(engine)\n\n    def test_collection_model(self):\n        # Create a new collection\n        collection = CollectionModel(id=\"1\", name=\"test\")\n        self.session.add(collection)\n        self.session.commit()\n\n        # Retrieve the collection from the database\n        retrieved_collection = (\n            self.session.query(CollectionModel).filter_by(id=\"1\").one()\n        )\n\n        # Check that the retrieved collection matches the original collection\n        self.assertEqual(collection.id, retrieved_collection.id)\n        self.assertEqual(collection.name, retrieved_collection.name)\n\n    def test_duplicate_name(self):\n        # Create a new collection with a duplicate name\n        collection1 = CollectionModel(id=\"1\", name=\"test\")\n        collection2 = CollectionModel(id=\"2\", name=\"test\")\n\n        # Add the first collection to the database\n        self.session.add(collection1)\n        self.session.commit()\n\n        # Try to add the second collection to the database\n        with self.assertRaises(Exception):\n            self.session.add(collection2)\n            self.session.commit()\n\n        # Roll back the session to clear the transaction\n        self.session.rollback()\n\n        # Check that the second collection was not added to the database\n        self.assertEqual(\n            self.session.query(CollectionModel).filter_by(name=\"test\").count(), 1\n        )", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/model/test_embedding_model.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\nfrom datetime import datetime", "import unittest\nfrom datetime import datetime\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom embedin.model.embedding_model import Base, EmbeddingModel\n\nengine = create_engine(\"sqlite:///:memory:\", echo=True)\nSession = sessionmaker(bind=engine)\n", "Session = sessionmaker(bind=engine)\n\n\nclass EmbeddingModelTestCase(unittest.TestCase):\n    def setUp(self):\n        Base.metadata.create_all(engine)\n        self.session = Session()\n\n        self.embedding = EmbeddingModel(\n            id=\"123\",\n            collection_id=\"abc\",\n            text=\"sample text\",\n            embedding_data={\"sample\": [1, 2, 3]},\n            meta_data={\"created_by\": \"user1\"},\n            hash=\"1234\",\n            created_at=datetime.now(),\n        )\n        self.session.add(self.embedding)\n        self.session.commit()\n\n    def tearDown(self):\n        self.session.rollback()\n        self.session.close()\n        Base.metadata.drop_all(engine)\n\n    def test_embedding_model(self):\n        embedding = self.session.query(EmbeddingModel).first()\n\n        self.assertIsNotNone(embedding)\n        self.assertEqual(embedding.id, \"123\")\n        self.assertEqual(embedding.collection_id, \"abc\")\n        self.assertEqual(embedding.text, \"sample text\")\n        self.assertEqual(embedding.embedding_data, {\"sample\": [1, 2, 3]})\n        self.assertEqual(embedding.meta_data, {\"created_by\": \"user1\"})\n        self.assertEqual(embedding.hash, \"1234\")\n        self.assertIsInstance(embedding.created_at, datetime)\n\n        # Try to add another embedding model with the same hash (should fail due to unique constraint)\n        duplicate_embedding = EmbeddingModel(\n            id=\"2\",\n            collection_id=\"3\",\n            text=\"other text\",\n            embedding_data={\"data\": [4, 5, 6]},\n            meta_data={\"meta\": \"data\"},\n            hash=\"1234\",\n            created_at=datetime.now(),\n        )\n        self.session.add(duplicate_embedding)\n        with self.assertRaises(Exception):\n            self.session.commit()", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/util/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\n", "import unittest\n\nimport numpy as np\n\nfrom embedin.util import to_np_array\n\n\nclass TestToNpArray(unittest.TestCase):\n    def test_to_np_array_none_input(self):\n        query_embeddings = None\n        with self.assertRaises(ValueError):\n            to_np_array(query_embeddings)\n\n    def test_to_np_array_empty_list(self):\n        query_embeddings = []\n        with self.assertRaises(ValueError):\n            to_np_array(query_embeddings)\n\n        query_embeddings = [[]]\n        with self.assertRaises(ValueError):\n            to_np_array(query_embeddings)\n\n        query_embeddings = [[], []]\n        with self.assertRaises(ValueError):\n            to_np_array(query_embeddings)\n\n    def test_to_np_array_one_dim(self):\n        query_embeddings = [1, 2, 3]\n        result = to_np_array(query_embeddings)\n        assert result.shape == (1, 3)\n        assert result.dtype == \"float32\"\n\n    def test_to_np_array_two_dims(self):\n        query_embeddings = [[1, 2, 3]]\n        result = to_np_array(query_embeddings)\n        assert result.shape == (1, 3)\n        assert result.dtype == \"float32\"\n\n    def test_to_np_array_two_dims_multiple(self):\n        query_embeddings = [[1, 2, 3], [4, 5, 6]]\n        result = to_np_array(query_embeddings)\n        assert result.shape == (2, 3)\n        assert result.dtype == \"float32\"\n\n    def test_to_np_array_already_ndarray(self):\n        query_embeddings = np.array([1, 2, 3])\n        result = to_np_array(query_embeddings)\n        assert result.shape == (1, 3)\n        assert result.dtype == \"float32\"", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/client/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\nfrom unittest.mock import MagicMock", "import unittest\nfrom unittest.mock import MagicMock\n\nimport numpy as np\n\nfrom embedin.client import Client\n\n\nclass TestClient(unittest.TestCase):\n    def test_constructor(self):\n        np.random.seed(42)\n        embeddings = np.random.rand(3, 4).astype(np.float32).tolist()\n\n        texts = [\"hello\", \"test\", \"world\"]\n\n        client = Client(\n            collection_name=\"test_collection\", texts=texts, embeddings=embeddings\n        )\n        self.assertIsNotNone(client.collection_service)\n        self.assertIsNotNone(client.embedding_service)\n\n        client = Client(collection_name=\"test_collection\", texts=texts)\n        self.assertIsNotNone(client.collection_service)\n        self.assertIsNotNone(client.embedding_service)\n\n    def test_create_or_get_collection(self):\n        collection_name = \"test_collection\"\n        client = Client(collection_name=collection_name)\n        collection_id = client.create_or_get_collection(collection_name)\n        self.assertIsNotNone(collection_id)\n        self.assertEqual(client.collection_id, collection_id)\n\n    def test_create_collection(self):\n        # Test that a collection is created with the given name\n        collection_name = \"new_collection\"\n        client = Client(collection_name=collection_name)\n        collection_id = client.create_collection(collection_name)\n        self.assertIsNotNone(collection_id)\n        self.assertEqual(client.collection_id, collection_id)\n\n    def test_get_collection(self):\n        # Test that a collection is retrieved with the given name\n        collection_name = \"new_collection\"\n        client = Client(collection_name=collection_name)\n        client.create_collection(collection_name)\n        collection_id = client.get_collection(collection_name)\n        self.assertIsNotNone(collection_id)\n        self.assertEqual(client.collection_id, collection_id)\n\n    def test_add_data(self):\n        collection_name = \"new_collection\"\n        client = Client(collection_name=collection_name)\n\n        # Test that data is added to the collection\n        texts = [\"text1\", \"text2\"]\n        meta_data = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}]\n\n        client.embedding_fn = MagicMock(return_value=[[1, 2, 3], [4, 5, 6]])\n        client.add_data(texts, meta_data)\n\n        client.embedding_fn.assert_called_once_with(texts)\n        self.assertEqual(len(client.embedding_rows), 2)\n\n    def test_query(self):\n        collection_name = \"new_collection\"\n        client = Client(collection_name=collection_name)\n\n        # Test that queries return the expected results\n        client.embedding_fn = MagicMock(return_value=[[1, 2, 3], [4, 5, 6]])\n        client.add_data([\"test\", \"text\"])\n\n        client.embedding_fn = MagicMock(return_value=[[1, 2, 3]])\n        result = client.query(\"test\", top_k=1)\n        expected_result = [{\"text\": \"test\", \"meta_data\": None}]\n        self.assertEqual(result, expected_result)", "class TestClient(unittest.TestCase):\n    def test_constructor(self):\n        np.random.seed(42)\n        embeddings = np.random.rand(3, 4).astype(np.float32).tolist()\n\n        texts = [\"hello\", \"test\", \"world\"]\n\n        client = Client(\n            collection_name=\"test_collection\", texts=texts, embeddings=embeddings\n        )\n        self.assertIsNotNone(client.collection_service)\n        self.assertIsNotNone(client.embedding_service)\n\n        client = Client(collection_name=\"test_collection\", texts=texts)\n        self.assertIsNotNone(client.collection_service)\n        self.assertIsNotNone(client.embedding_service)\n\n    def test_create_or_get_collection(self):\n        collection_name = \"test_collection\"\n        client = Client(collection_name=collection_name)\n        collection_id = client.create_or_get_collection(collection_name)\n        self.assertIsNotNone(collection_id)\n        self.assertEqual(client.collection_id, collection_id)\n\n    def test_create_collection(self):\n        # Test that a collection is created with the given name\n        collection_name = \"new_collection\"\n        client = Client(collection_name=collection_name)\n        collection_id = client.create_collection(collection_name)\n        self.assertIsNotNone(collection_id)\n        self.assertEqual(client.collection_id, collection_id)\n\n    def test_get_collection(self):\n        # Test that a collection is retrieved with the given name\n        collection_name = \"new_collection\"\n        client = Client(collection_name=collection_name)\n        client.create_collection(collection_name)\n        collection_id = client.get_collection(collection_name)\n        self.assertIsNotNone(collection_id)\n        self.assertEqual(client.collection_id, collection_id)\n\n    def test_add_data(self):\n        collection_name = \"new_collection\"\n        client = Client(collection_name=collection_name)\n\n        # Test that data is added to the collection\n        texts = [\"text1\", \"text2\"]\n        meta_data = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}]\n\n        client.embedding_fn = MagicMock(return_value=[[1, 2, 3], [4, 5, 6]])\n        client.add_data(texts, meta_data)\n\n        client.embedding_fn.assert_called_once_with(texts)\n        self.assertEqual(len(client.embedding_rows), 2)\n\n    def test_query(self):\n        collection_name = \"new_collection\"\n        client = Client(collection_name=collection_name)\n\n        # Test that queries return the expected results\n        client.embedding_fn = MagicMock(return_value=[[1, 2, 3], [4, 5, 6]])\n        client.add_data([\"test\", \"text\"])\n\n        client.embedding_fn = MagicMock(return_value=[[1, 2, 3]])\n        result = client.query(\"test\", top_k=1)\n        expected_result = [{\"text\": \"test\", \"meta_data\": None}]\n        self.assertEqual(result, expected_result)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/service/test_embedding_service.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\nfrom datetime import datetime", "import unittest\nfrom datetime import datetime\nfrom unittest.mock import Mock\n\nfrom embedin.model.embedding_model import EmbeddingModel\nfrom embedin.repository.collection_repository import CollectionRepository\nfrom embedin.repository.embedding_repository import EmbeddingRepository\nfrom embedin.service.embedding_service import EmbeddingService\n\n\nclass TestEmbeddingService(unittest.TestCase):\n    def setUp(self):\n        self.session = Mock()\n        self.embedding_repo = EmbeddingRepository(self.session)\n        self.collection_repo = CollectionRepository(self.session)\n        self.service = EmbeddingService(self.session)\n\n    def test_add_all(self):\n        # Define mock data\n        collection_id = \"test_collection\"\n        embeddings = [[1, 2, 3], [4, 5, 6], [1, 2, 3]]\n        texts = [\"test_text_1\", \"test_text_2\", \"test_text_1\"]\n        metadata_list = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}, {\"meta1\": \"value1\"}]\n        expected_rows = [\n            dict(\n                id=\"test_id_1\",\n                collection_id=collection_id,\n                text=texts[0],\n                embedding_data=[1, 2, 3],\n                meta_data=metadata_list[0],\n                hash=\"test_hash_1\",\n                created_at=datetime.now(),\n            ),\n            dict(\n                id=\"test_id_2\",\n                collection_id=collection_id,\n                text=texts[1],\n                embedding_data=[4, 5, 6],\n                meta_data=metadata_list[1],\n                hash=\"test_hash_2\",\n                created_at=datetime.now(),\n            ),\n        ]\n        # Mock dependency methods\n        self.service.embedding_repo.add_all = Mock(return_value=expected_rows)\n\n        # Call the function being tested\n        actual_rows = self.service.add_all(\n            collection_id, embeddings, texts, metadata_list\n        )\n\n        # Check the result\n        self.assertEqual(actual_rows, expected_rows)\n        self.assertEqual(len(actual_rows), 2)\n        self.assertEqual(actual_rows[0].get(\"hash\"), expected_rows[0].get(\"hash\"))\n        self.assertEqual(actual_rows[0].get(\"embedding_data\"), embeddings[0])\n        self.assertEqual(actual_rows[1].get(\"hash\"), expected_rows[1].get(\"hash\"))\n        self.assertEqual(actual_rows[1].get(\"embedding_data\"), embeddings[1])\n\n    def test_get_by_collection_id(self):\n        # Define mock data\n        collection_id = \"test_collection\"\n        embeddings = [[1, 2, 3], [4, 5, 6]]\n        expected_rows = [\n            dict(\n                id=\"test_id_1\",\n                collection_id=collection_id,\n                text=\"test_text_1\",\n                embedding_data=[1, 2, 3],\n                meta_data=None,\n                hash=\"test_hash_1\",\n                created_at=datetime.now(),\n            ),\n            dict(\n                id=\"test_id_2\",\n                collection_id=collection_id,\n                text=\"test_text_2\",\n                embedding_data=[4, 5, 6],\n                meta_data=None,\n                hash=\"test_hash_2\",\n                created_at=datetime.now(),\n            ),\n        ]\n        # Mock dependency methods\n        self.service.embedding_repo.get_by_collection_id = Mock(\n            return_value=expected_rows\n        )\n\n        # Call the function being tested\n        actual_rows = self.service.get_by_collection_id(collection_id)\n\n        # Check the result\n        self.assertEqual(actual_rows, expected_rows)\n        self.assertEqual(len(actual_rows), 2)\n        self.assertEqual(actual_rows[0].get(\"hash\"), expected_rows[0].get(\"hash\"))\n        self.assertEqual(actual_rows[0].get(\"embedding_data\"), embeddings[0])\n        self.assertEqual(actual_rows[1].get(\"hash\"), expected_rows[1].get(\"hash\"))\n        self.assertEqual(actual_rows[1].get(\"embedding_data\"), embeddings[1])", "\n\nclass TestEmbeddingService(unittest.TestCase):\n    def setUp(self):\n        self.session = Mock()\n        self.embedding_repo = EmbeddingRepository(self.session)\n        self.collection_repo = CollectionRepository(self.session)\n        self.service = EmbeddingService(self.session)\n\n    def test_add_all(self):\n        # Define mock data\n        collection_id = \"test_collection\"\n        embeddings = [[1, 2, 3], [4, 5, 6], [1, 2, 3]]\n        texts = [\"test_text_1\", \"test_text_2\", \"test_text_1\"]\n        metadata_list = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}, {\"meta1\": \"value1\"}]\n        expected_rows = [\n            dict(\n                id=\"test_id_1\",\n                collection_id=collection_id,\n                text=texts[0],\n                embedding_data=[1, 2, 3],\n                meta_data=metadata_list[0],\n                hash=\"test_hash_1\",\n                created_at=datetime.now(),\n            ),\n            dict(\n                id=\"test_id_2\",\n                collection_id=collection_id,\n                text=texts[1],\n                embedding_data=[4, 5, 6],\n                meta_data=metadata_list[1],\n                hash=\"test_hash_2\",\n                created_at=datetime.now(),\n            ),\n        ]\n        # Mock dependency methods\n        self.service.embedding_repo.add_all = Mock(return_value=expected_rows)\n\n        # Call the function being tested\n        actual_rows = self.service.add_all(\n            collection_id, embeddings, texts, metadata_list\n        )\n\n        # Check the result\n        self.assertEqual(actual_rows, expected_rows)\n        self.assertEqual(len(actual_rows), 2)\n        self.assertEqual(actual_rows[0].get(\"hash\"), expected_rows[0].get(\"hash\"))\n        self.assertEqual(actual_rows[0].get(\"embedding_data\"), embeddings[0])\n        self.assertEqual(actual_rows[1].get(\"hash\"), expected_rows[1].get(\"hash\"))\n        self.assertEqual(actual_rows[1].get(\"embedding_data\"), embeddings[1])\n\n    def test_get_by_collection_id(self):\n        # Define mock data\n        collection_id = \"test_collection\"\n        embeddings = [[1, 2, 3], [4, 5, 6]]\n        expected_rows = [\n            dict(\n                id=\"test_id_1\",\n                collection_id=collection_id,\n                text=\"test_text_1\",\n                embedding_data=[1, 2, 3],\n                meta_data=None,\n                hash=\"test_hash_1\",\n                created_at=datetime.now(),\n            ),\n            dict(\n                id=\"test_id_2\",\n                collection_id=collection_id,\n                text=\"test_text_2\",\n                embedding_data=[4, 5, 6],\n                meta_data=None,\n                hash=\"test_hash_2\",\n                created_at=datetime.now(),\n            ),\n        ]\n        # Mock dependency methods\n        self.service.embedding_repo.get_by_collection_id = Mock(\n            return_value=expected_rows\n        )\n\n        # Call the function being tested\n        actual_rows = self.service.get_by_collection_id(collection_id)\n\n        # Check the result\n        self.assertEqual(actual_rows, expected_rows)\n        self.assertEqual(len(actual_rows), 2)\n        self.assertEqual(actual_rows[0].get(\"hash\"), expected_rows[0].get(\"hash\"))\n        self.assertEqual(actual_rows[0].get(\"embedding_data\"), embeddings[0])\n        self.assertEqual(actual_rows[1].get(\"hash\"), expected_rows[1].get(\"hash\"))\n        self.assertEqual(actual_rows[1].get(\"embedding_data\"), embeddings[1])", ""]}
{"filename": "tests/service/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"]}
{"filename": "tests/service/test_collection_service.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\nfrom unittest.mock import Mock", "import unittest\nfrom unittest.mock import Mock\nfrom embedin.repository.collection_repository import CollectionRepository\nfrom embedin.service.collection_service import CollectionService\n\n\nclass TestCollectionService(unittest.TestCase):\n    def setUp(self):\n        self.session = Mock()\n        self.collection_repo = CollectionRepository(self.session)\n        self.service = CollectionService(self.session)\n\n    def test_get_by_name(self):\n        # Define mock data\n        name = \"test_collection\"\n        expected_rows = [{\"name\": name, \"id\": 1}]\n        # Mock dependency methods\n        self.service.collection_repo.get_by_name = Mock(return_value=expected_rows)\n\n        # Call the function being tested\n        actual_rows = self.service.get_by_name(name)\n\n        # Check the result\n        self.assertEqual(actual_rows, expected_rows)\n        self.service.collection_repo.get_by_name.assert_called_once_with(name)\n\n    def test_create(self):\n        # Define mock data\n        name = \"test_collection\"\n        get_if_exist = True\n        # Mock dependency methods\n        self.service.collection_repo.create = Mock()\n\n        # Call the function being tested\n        self.service.create(name, get_if_exist)\n\n        # Check the result\n        self.service.collection_repo.create.assert_called_once_with(name, get_if_exist)", ""]}
{"filename": "tests/embedding/test_openai_embedding.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\nfrom unittest.mock import patch", "import unittest\nfrom unittest.mock import patch\n\nfrom embedin.embedding.openai_embedding import OpenAIEmbedding\n\n\nclass TestOpenAIEmbedding(unittest.TestCase):\n    def setUp(self):\n        self.api_key = \"my_api_key\"\n        self.texts = [\"hello\", \"world\"]\n        self.model = \"text-davinci-002\"\n        self.embedding = OpenAIEmbedding(api_key=self.api_key, model=self.model)\n\n    @patch(\"openai.Embedding.create\")\n    def test_call(self, mock_create):\n        mock_create.return_value = {\n            \"data\": [{\"embedding\": [1.0, 2.0, 3.0]}, {\"embedding\": [4.0, 5.0, 6.0]}]\n        }\n        result = self.embedding(self.texts)\n        self.assertEqual(result, [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        mock_create.assert_called_once_with(model=self.model, input=self.texts)\n\n    def tearDown(self):\n        pass", ""]}
{"filename": "tests/embedding/test_embedding_base.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\n", "import unittest\n\nfrom embedin.embedding.embedding_base import EmbeddingBase\n\n\nclass TestEmbedding(unittest.TestCase):\n    def test_call_method_not_implemented(self):\n        embedding = EmbeddingBase()\n        with self.assertRaises(NotImplementedError):\n            embedding([\"some\", \"texts\"])", ""]}
{"filename": "tests/embedding/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\n", "import unittest\n\nfrom embedin.embedding import Embedding, OpenAIEmbedding, SentenceTransformerEmbedding\n\n\nclass TestEmbedding(unittest.TestCase):\n    def test_create_openai_embedding(self):\n        model_type = \"openai\"\n        api_key = \"my_secret_api_key\"\n        embedding = Embedding.create_embedding(model_type, api_key)\n        self.assertIsInstance(embedding, OpenAIEmbedding)\n\n    def test_create_openai_embedding_without_api_key(self):\n        model_type = \"openai\"\n        api_key = None\n        with self.assertRaises(ValueError):\n            Embedding.create_embedding(model_type, api_key)\n\n    def test_create_sentence_transformer_embedding(self):\n        model_type = \"sentence_transformer\"\n        embedding = Embedding.create_embedding(model_type, None)\n        self.assertIsInstance(embedding, SentenceTransformerEmbedding)\n\n    def test_create_unsupported_model_type(self):\n        model_type = \"unsupported\"\n        with self.assertRaises(ValueError):\n            Embedding.create_embedding(model_type, None)\n\n    def test_call_method_not_implemented(self):\n        embedding = Embedding()\n        with self.assertRaises(NotImplementedError):\n            embedding(\"some text\")", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/embedding/test_sentence_transformer_embedding.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\n", "import unittest\n\nfrom embedin.embedding.sentence_transformer import SentenceTransformerEmbedding\n\n\nclass TestSentenceTransformerEmbedding(unittest.TestCase):\n    def test_embedding_single_text(self):\n        embedding = SentenceTransformerEmbedding()\n        text = \"This is a test sentence.\"\n        expected_output = embedding.model.encode([text], convert_to_numpy=True)\n        self.assertTrue((embedding(text) == expected_output).all())\n\n    def test_embedding_multiple_texts(self):\n        embedding = SentenceTransformerEmbedding()\n        texts = [\"This is a test sentence.\", \"This is another test sentence.\"]\n        expected_output = embedding.model.encode(texts, convert_to_numpy=True)\n        self.assertTrue((embedding(texts) == expected_output).all())\n\n    def test_embedding_empty_text(self):\n        embedding = SentenceTransformerEmbedding()\n        text = \"\"\n        expected_output = embedding.model.encode([text], convert_to_numpy=True)\n        self.assertTrue((embedding(text) == expected_output).all())\n\n    def test_embedding_invalid_input(self):\n        embedding = SentenceTransformerEmbedding()\n        invalid_input = 123\n        with self.assertRaises(TypeError):\n            embedding(invalid_input)\n\n        invalid_input = [123, \"string\"]\n        with self.assertRaises(TypeError):\n            embedding(invalid_input)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "embedin/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nembedin - A vector database that empowers AI with persistent memory.", "\"\"\"\nembedin - A vector database that empowers AI with persistent memory.\n\n    >>> from embedin import Embedin\n    >>> client = Embedin(collection_name=\"test_collection\",\n    ...                  texts=[\"This is a test\", \"Hello world!\"])\n    >>> result = client.query(\"These are tests\", top_k=1)\n    >>> print(result)\n\n:copyright: (C) 2023 EmbedInAI", "\n:copyright: (C) 2023 EmbedInAI\n:license: Apache 2.0, see LICENSE for more details.\n\"\"\"\n\nfrom .client import Client as Embedin\n"]}
{"filename": "embedin/index/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom embedin.index.flat_index import FlatIndex\nfrom embedin.index.hnsw_index import HNSWIndex", "from embedin.index.flat_index import FlatIndex\nfrom embedin.index.hnsw_index import HNSWIndex\n\n\nclass Index:\n    def __init__(self, embeddings, index_hint=None):\n        if index_hint == \"hnsw\":\n            self.index = HNSWIndex(embeddings)\n        elif index_hint == \"flat\":\n            self.index = FlatIndex(embeddings)\n        elif len(embeddings) > 10**6:\n            self.index = HNSWIndex(embeddings)\n        else:\n            self.index = FlatIndex(embeddings)\n\n    def search(self, query, top_k=3):\n        return self.index.search(query, top_k)\n\n    def update_index(self, embeddings):\n        self.index.update_index(embeddings)", "        # TODO: switch index when exceeding 10 ** 6\n"]}
{"filename": "embedin/index/index_base.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom abc import ABC, abstractmethod\n", "from abc import ABC, abstractmethod\n\nfrom embedin.util import to_np_array\n\n\nclass IndexBase(ABC):\n    def __init__(self, embeddings):\n        \"\"\"\n        Args:\n            embeddings: A list of embeddings, where each embedding is a list\n            or array of floats.\n        \"\"\"\n        self.embeddings = to_np_array(embeddings)\n        self.index = self._build_index()\n\n    @abstractmethod\n    def _build_index(self):\n        pass\n\n    @abstractmethod\n    def _search_index(self, query_embeddings, top_k):\n        pass\n\n    @abstractmethod\n    def update_index(self, embeddings):\n        pass\n\n    def search(self, query_embeddings, top_k=3):\n        \"\"\"\n        Perform nearest neighbor on a set of embeddings.\n\n        Args:\n            query_embeddings (list or array): The query embedding to use for the\n            nearest neighbor search.\n            top_k (int, optional): The number of nearest neighbors to return.\n            Defaults to 3.\n\n        Returns:\n           A list of the indices of the nearest neighbors, and a list of their\n           corresponding distances.\n        \"\"\"\n        count = len(self.embeddings)\n        top_k = min(top_k, count)\n        query_embeddings = to_np_array(query_embeddings)\n        indices = self._search_index(query_embeddings, top_k)\n        return indices\n\n    def get_embeddings(self):\n        return self.embeddings", ""]}
{"filename": "embedin/index/flat_index.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport faiss\nimport numpy as np", "import faiss\nimport numpy as np\n\nfrom embedin.index.index_base import IndexBase\nfrom embedin.util import to_np_array\n\n\nclass FlatIndex(IndexBase):\n    \"\"\"\n    This class implements a nearest neighbors search using brute-force cosine similarity metric.\n    Inherits from the abstract class 'NearestNeighbors'.\n    \"\"\"\n\n    def _build_index(self):\n        \"\"\"\n        Build an index using the brute-force with the cosine similarity metric and returns it.\n\n        Returns:\n        -------\n        index: faiss.IndexFlatIP\n            The index built using brute-force.\n        \"\"\"\n\n        d = self.embeddings.shape[1]  # dimension\n        index = faiss.IndexFlatIP(d)\n\n        xb_norm = np.linalg.norm(self.embeddings, axis=1, keepdims=True)\n        xb_normalized = self.embeddings / xb_norm\n\n        index.add(xb_normalized)\n        return index\n\n    def update_index(self, embeddings):\n        \"\"\"\n        Updates the index with new embeddings.\n\n        Parameters:\n        ----------\n        embeddings: A list of embeddings, where each embedding is a list\n            or array of floats.\n        \"\"\"\n\n        if not embeddings:\n            return\n        embeddings = to_np_array(embeddings)\n\n        xb_norm = np.linalg.norm(embeddings, axis=1, keepdims=True)\n        xb_normalized = embeddings / xb_norm\n\n        self.index.add(xb_normalized)\n        self.embeddings = np.concatenate((self.embeddings, embeddings), axis=0)\n\n    def _search_index(self, query_embeddings, top_k):\n        \"\"\"\n        Searches the index for the top K nearest embeddings to the given query embeddings.\n\n        Parameters:\n        ----------\n        query_embeddings: numpy array\n            Query embeddings to search the nearest neighbors.\n        top_k: int\n            Number of the top k nearest embeddings to return.\n\n        Returns:\n        -------\n        indices: numpy array\n            Array of indices representing the nearest embeddings to the given query embeddings.\n        \"\"\"\n\n        # faiss.normalize_L2(query_embeddings)\n        xq_norm = np.linalg.norm(query_embeddings, axis=1, keepdims=True)\n        xq_normalized = query_embeddings / xq_norm\n\n        distances, indices = self.index.search(xq_normalized, k=top_k)\n\n        # Remove the singleton dimension\n        indices = np.squeeze(indices)\n\n        return indices", ""]}
{"filename": "embedin/index/hnsw_index.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport numpy as np\nfrom hnswlib import Index", "import numpy as np\nfrom hnswlib import Index\n\nfrom embedin.index.index_base import IndexBase\nfrom embedin.util import to_np_array\n\n\nclass HNSWIndex(IndexBase):\n    \"\"\"\n    This class implements a nearest neighbors search with HNSW algorithm using cosine similarity metric.\n    Inherits from the abstract class 'NearestNeighbors'.\n    \"\"\"\n\n    # TODO: save index to DB; load index from DB\n    def _build_index(self):\n        \"\"\"\n        Build an index using the HNSW algorithm with the cosine similarity metric and returns it.\n\n        Returns:\n        -------\n        index: Index\n            The index built using HNSW algorithm.\n        \"\"\"\n\n        # M - vertex nearest neighbors, affect index size linearly\n        # ef_construction - depth of search during build\n\n        ef_search = 128  # depth of search during search\n        d = self.embeddings.shape[1]  # dimension\n\n        index = Index(\"cosine\", d)\n        index.init_index(\n            max_elements=self.embeddings.shape[0], ef_construction=64, M=32\n        )\n        index.add_items(self.embeddings)\n        index.set_ef(ef_search)\n        return index\n\n    def update_index(self, embeddings):\n        \"\"\"\n        Updates the index with new embeddings.\n\n        Parameters:\n        ----------\n        embeddings: numpy array\n            Embeddings to be added to the index.\n        \"\"\"\n\n        if not embeddings:\n            return\n        embeddings = to_np_array(embeddings)\n        new_index_size = self.index.get_current_count() + embeddings.shape[0]\n        self.index.resize_index(new_index_size)\n        self.index.add_items(embeddings)\n        self.embeddings = np.concatenate((self.embeddings, embeddings), axis=0)\n\n    def _search_index(self, query_embeddings, top_k):\n        \"\"\"\n        Searches the index for the top K nearest embeddings to the given query embeddings.\n\n        Parameters:\n        ----------\n        query_embeddings: numpy array\n            Query embeddings to search the nearest neighbors.\n        top_k: int\n            Number of nearest embeddings to return.\n\n        Returns:\n        -------\n        indices: numpy array\n            Array of indices representing the nearest embeddings to the given query embeddings.\n        \"\"\"\n\n        indices, distances = self.index.knn_query(query_embeddings, k=top_k)\n        return indices", ""]}
{"filename": "embedin/repository/embedding_repository.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport logging\n\nfrom sqlalchemy.exc import IntegrityError", "\nfrom sqlalchemy.exc import IntegrityError\nfrom tqdm import tqdm\n\nfrom embedin.model.embedding_model import EmbeddingModel\n\n# Configure the root logger to output to the console\nlogging.basicConfig(\n    format=\"%(asctime)s - %(levelname)s - %(message)s\", level=logging.INFO\n)", "    format=\"%(asctime)s - %(levelname)s - %(message)s\", level=logging.INFO\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass EmbeddingRepository:\n    \"\"\"\n    This class provides methods to interact with embeddings stored in the database.\n\n    Attributes:\n        session (sqlalchemy.orm.Session): The database session to use for querying and modifying data.\n\n    Methods:\n        create_table(): Creates the EmbeddingModel table in the database.\n        add_all(rows): Adds multiple embeddings to the database, returning the successfully inserted rows.\n        get_by_ids(ids): Returns the embeddings with the given ids.\n        get_by_collection_id(collection_id): Returns all embeddings in the collection with the given id.\n    \"\"\"\n\n    def __init__(self, session):\n        \"\"\"\n        Constructs an EmbeddingRepository object.\n\n        Args:\n            session (sqlalchemy.orm.Session): The database session to use for querying and modifying data.\n        \"\"\"\n\n        self.session = session\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the EmbeddingModel table in the database.\n        \"\"\"\n\n        EmbeddingModel.metadata.create_all(self.session.bind)\n\n    def _add_rows_one_by_one(self, rows):\n        \"\"\"\n        Adds multiple embeddings to the database using loop, returning the successfully inserted rows.\n\n        Args:\n            rows (List[EmbeddingModel]): A list of EmbeddingModel objects to add to the database.\n\n        Returns:\n            List[EmbeddingModel]: A list of successfully inserted EmbeddingModel.\n        \"\"\"\n        inserted_rows = []\n        for row in rows:\n            try:\n                self.session.merge(row)\n                self.session.commit()\n                inserted_rows.append(row)\n            except (IntegrityError, Exception):\n                self.session.rollback()\n        return inserted_rows\n\n    def add_all(self, rows):\n        \"\"\"\n        The method adds multiple embeddings to the database in batches, and in case of exceptions,\n        it switches to adding them one by one. It then returns the list of successfully inserted rows.\n\n        Args:\n            rows (List[dct]): A list of dict objects to add to the database.\n\n        Returns:\n            List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n        \"\"\"\n        rows = [EmbeddingModel(**row) for row in rows]\n\n        inserted_rows = []\n\n        batch_size = 200\n        extra_batch = len(rows) % batch_size > 0\n        num_batches = len(rows) // batch_size + extra_batch\n\n        with tqdm(total=len(rows), desc=\"Inserting rows to database\") as pbar:\n            for batch_index in range(num_batches):\n                batch_start = batch_index * batch_size\n                batch_end = batch_start + batch_size\n                batch = rows[batch_start:batch_end]\n\n                try:\n                    self.session.bulk_save_objects(batch)  # TODO using SQL\n                    self.session.commit()\n                    inserted_rows.extend(batch)\n\n                except (IntegrityError, Exception) as e:\n                    self.session.rollback()\n                    self.session.expunge_all()\n                    inserted_rows.extend(self._add_rows_one_by_one(batch))\n\n                pbar.update(len(batch))\n\n        inserted_rows = [r.to_dict() for r in inserted_rows]\n\n        return inserted_rows\n\n    # This is only needed when bulk add in add_all is implemented\n    def get_by_ids(self, ids):\n        \"\"\"\n        Returns the embeddings with the given ids.\n\n        Args:\n            ids (List[str]): A list of embedding ids to retrieve.\n\n        Returns:\n            List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n        \"\"\"\n\n        # Get the successfully inserted data\n        rows = (\n            self.session.query(EmbeddingModel).filter(EmbeddingModel.id.in_(ids)).all()\n        )\n\n        rows = [r.to_dict() for r in rows]\n\n        return rows\n\n    def get_by_collection_id(self, collection_id):\n        \"\"\"\n        Returns all embeddings in the collection with the given id.\n\n        Args:\n            collection_id (str): The id of the collection to retrieve embeddings from.\n\n        Returns:\n            List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n        \"\"\"\n\n        rows = (\n            self.session.query(EmbeddingModel)\n            .filter(EmbeddingModel.collection_id == collection_id)\n            .all()\n        )\n\n        rows = [r.to_dict() for r in rows]\n\n        return rows", ""]}
{"filename": "embedin/repository/collection_repository.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport logging\nimport uuid\n", "import uuid\n\nfrom sqlalchemy.exc import IntegrityError\n\nfrom embedin.model.collection_model import CollectionModel\n\n# Configure the root logger to output to the console\nlogging.basicConfig(\n    format=\"%(asctime)s - %(levelname)s - %(message)s\", level=logging.INFO\n)", "    format=\"%(asctime)s - %(levelname)s - %(message)s\", level=logging.INFO\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass CollectionRepository:\n    \"\"\"\n    A repository for managing collections in a database.\n\n    Parameters:\n    -----------\n    session: sqlalchemy.orm.Session\n        The database session to use.\n\n    Methods:\n    --------\n    create_table():\n        Creates the table in the database for collections.\n\n    get_by_name(name: str) -> CollectionModel or None:\n        Retrieves a collection from the database by name.\n\n    create(name: str, get_if_exist: bool = True) -> CollectionModel:\n        Creates a new collection in the database with the given name.\n        If the collection already exists and get_if_exist is True, it returns the existing collection.\n        If get_if_exist is False, it raises a ValueError.\n    \"\"\"\n\n    def __init__(self, session):\n        \"\"\"\n        Constructs a new CollectionRepository with the given database session.\n        \"\"\"\n\n        self.session = session\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the table in the database for collections.\n        \"\"\"\n\n        CollectionModel.metadata.create_all(self.session.bind)\n\n    def get_by_name(self, name):\n        \"\"\"\n        Retrieves a collection from the database by name.\n\n        Parameters:\n        -----------\n        name: str\n            The name of the collection to retrieve.\n\n        Returns:\n        --------\n        collection: dict\n            The collection with the given name,\n        \"\"\"\n\n        collection = self.session.query(CollectionModel).filter_by(name=name).first()\n\n        collection = collection.to_dict() if collection else {}\n        return collection\n\n    def create(self, name, get_if_exist=True):\n        \"\"\"\n        Creates a new collection in the database with the given name.\n\n        Parameters:\n        -----------\n        name: str\n            The name of the collection to create.\n        get_if_exist: bool, optional (default=True)\n            If the collection already exists and get_if_exist is True, it returns the existing collection.\n            If get_if_exist is False, it raises a ValueError.\n\n        Returns:\n        --------\n        collection: dict\n            The newly created collection.\n        \"\"\"\n\n        collection = self.get_by_name(name)\n        if collection:\n            if get_if_exist:\n                return collection\n            raise ValueError(f\"Collection with name {name} already exists\")\n\n        collection_id = str(uuid.uuid4())\n        collection_model = CollectionModel(id=collection_id, name=name)\n\n        try:\n            self.session.add(collection_model)\n            self.session.commit()\n            return collection_model.to_dict()\n        except (IntegrityError, Exception) as e:\n            self.session.rollback()\n            logger.error(f\"creating collection encounter an error: {str(e)}\")", ""]}
{"filename": "embedin/repository/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"]}
{"filename": "embedin/model/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport datetime\n\n\nclass Model:\n    def to_dict(self):\n        out = {}\n        for col in self.__table__.c:\n            obj = getattr(self, col.name)\n            if isinstance(obj, datetime.datetime):\n                obj = obj.isoformat()\n            out[col.name] = obj\n        return out", "\n\nclass Model:\n    def to_dict(self):\n        out = {}\n        for col in self.__table__.c:\n            obj = getattr(self, col.name)\n            if isinstance(obj, datetime.datetime):\n                obj = obj.isoformat()\n            out[col.name] = obj\n        return out", ""]}
{"filename": "embedin/model/embedding_model.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom sqlalchemy import Column, String, Text, JSON, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base", "from sqlalchemy import Column, String, Text, JSON, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\n\nfrom embedin.model import Model\n\nBase = declarative_base()\n\n\nclass EmbeddingModel(Base, Model):\n    __tablename__ = \"embedding\"\n\n    id = Column(String(36), primary_key=True)\n    collection_id = Column(String(36))\n    text = Column(Text)\n\n    # TODO: Only Postgres supports ARRAY(Float). Using JSON for now\n    # https://docs.sqlalchemy.org/en/20/core/type_basics.html#sqlalchemy.types.ARRAY\n    embedding_data = Column(JSON)\n\n    meta_data = Column(JSON)\n    hash = Column(String(64), unique=True)\n    created_at = Column(DateTime)", "class EmbeddingModel(Base, Model):\n    __tablename__ = \"embedding\"\n\n    id = Column(String(36), primary_key=True)\n    collection_id = Column(String(36))\n    text = Column(Text)\n\n    # TODO: Only Postgres supports ARRAY(Float). Using JSON for now\n    # https://docs.sqlalchemy.org/en/20/core/type_basics.html#sqlalchemy.types.ARRAY\n    embedding_data = Column(JSON)\n\n    meta_data = Column(JSON)\n    hash = Column(String(64), unique=True)\n    created_at = Column(DateTime)", ""]}
{"filename": "embedin/model/collection_model.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom sqlalchemy import Column, String\nfrom sqlalchemy.ext.declarative import declarative_base", "from sqlalchemy import Column, String\nfrom sqlalchemy.ext.declarative import declarative_base\n\nfrom embedin.model import Model\n\nBase = declarative_base()\n\n\nclass CollectionModel(Base, Model):\n    __tablename__ = \"collection\"\n\n    id = Column(String(36), primary_key=True)\n    name = Column(String(64), unique=True)", "class CollectionModel(Base, Model):\n    __tablename__ = \"collection\"\n\n    id = Column(String(36), primary_key=True)\n    name = Column(String(64), unique=True)\n"]}
{"filename": "embedin/util/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport numpy as np\n", "import numpy as np\n\n\ndef to_np_array(embeddings, dtype=\"float32\"):\n    \"\"\"\n    Convert a list of embeddings to a numpy array.\n\n    Args:\n        embeddings (list): A list of embeddings, where each element is a number or\n        a list of numbers.\n        dtype (string): Data type of the array\n\n    Returns:\n        numpy.ndarray: A 2D numpy array of shape (num_examples, embedding_size), where\n        `num_examples` is the number of embeddings in the input list and `embedding_size`\n        is the length of each individual embedding.\n\n    Raises:\n        ValueError: If the input list is empty or contains embeddings of inconsistent length.\n\n    Example:\n        >>> embeddings_list = [[1,2,3],[4,5,6]]\n        >>> to_np_array(embeddings_list)\n        array([[1, 2, 3],\n               [4, 5, 6]], dtype=float32)\n    \"\"\"\n    if embeddings is None:\n        raise ValueError(\"Input list cannot be None.\")\n\n    if len(embeddings) == 0:\n        raise ValueError(\"Input list cannot contain empty list\")\n\n    embeddings_array = np.array(embeddings, dtype=dtype)\n\n    if embeddings_array.size == 0:\n        raise ValueError(\"Input list cannot be empty\")\n\n    # If the array has only one dimension, add an extra dimension\n    if len(embeddings_array.shape) == 1:\n        embeddings_array = np.expand_dims(embeddings_array, axis=0)\n\n    return embeddings_array", ""]}
{"filename": "embedin/client/__init__.py", "chunked_list": ["import logging\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom embedin.embedding import Embedding\nfrom embedin.index import Index\nfrom embedin.service.collection_service import CollectionService\nfrom embedin.service.embedding_service import EmbeddingService\n", "from embedin.service.embedding_service import EmbeddingService\n\n# Configure the root logger to output to the console\nlogging.basicConfig(\n    format=\"%(asctime)s - %(levelname)s - %(message)s\", level=logging.INFO\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass Client:\n    \"\"\"\n    Client class for managing embeddings and performing nearest neighbor search.\n\n    Args:\n        collection_name (str): Name of the collection.\n        url (str, optional): Database URL. Defaults to None.\n        embedding_fn (str or EmbeddingFunction, optional): The embedding function to use. The default is the SentenceTransformer model. Supported options are 'sentence_transformer' and 'openai'. If 'openai' is selected, the 'OPENAI_API_KEY' environment variable must be set to authenticate with the OpenAI API.\n        index_hint (str, optional): Similarity search index to use. Supports: 'flat' and 'hnsw'\n        debug (bool, optional): Enable debug mode. Defaults to False.\n\n    Attributes:\n        collection_id (int): ID of the collection.\n        embedding_fn (str or EmbeddingFunction): Embedding function to use. Support 'sentence_transformer' and 'openai'.\n        session (Session): SQLAlchemy session.\n        collection_service (CollectionService): CollectionService instance.\n        embedding_service (EmbeddingService): EmbeddingService instance.\n        embedding_rows (List[EmbeddingModel]): List of Embedding instances for the current collection.\n\n    Methods:\n        create_or_get_collection(name): Get the ID of an existing collection or create a new one.\n        create_collection(name): Create a new collection with the given name.\n        get_collection(name): Get the ID of an existing collection with the given name.\n        add_data(texts, meta_data=None): Add new data to the collection.\n        query(query_texts, top_k=3): Find nearest neighbors for the given query text(s).\n    \"\"\"\n\n    def __init__(\n        self,\n        collection_name,\n        url=None,\n        embedding_fn=\"sentence_transformer\",\n        index_hint=None,\n        debug=False,\n        **kwargs\n    ):\n        self.collection_id = None\n\n        if callable(embedding_fn):\n            self.embedding_fn = embedding_fn\n        else:\n            self.embedding_fn = Embedding.create_embedding(embedding_fn)\n\n        if url is None:\n            engine = create_engine(\"sqlite:///:memory:\", echo=debug)\n        else:\n            engine = create_engine(url)\n\n        session = sessionmaker(bind=engine, expire_on_commit=False)\n        self.session = session()\n\n        self.collection_service = CollectionService(self.session)\n        self.embedding_service = EmbeddingService(self.session)\n\n        embeddings = kwargs.get(\"embeddings\")\n        embeddings_meta = kwargs.get(\"meta\")\n        texts = kwargs.get(\"texts\")\n\n        self.collection_id = self.create_or_get_collection(collection_name)\n        self.embedding_rows = self.embedding_service.get_by_collection_id(\n            self.collection_id\n        )\n\n        # Insert user-provided texts and embeddings into the database\n        inserted_rows = []\n        if embeddings is not None and texts is not None:\n            # TODO validate embeddings' shape and dtype; validate text as well\n            inserted_rows = self.embedding_service.add_all(\n                self.collection_id, embeddings, texts, embeddings_meta\n            )\n        elif texts is not None:\n            embeddings = self.embedding_fn(texts)\n            inserted_rows = self.embedding_service.add_all(\n                self.collection_id, embeddings, texts, embeddings_meta\n            )\n\n        self.embedding_rows.extend(inserted_rows)\n        total_embeddings = [row.get(\"embedding_data\") for row in self.embedding_rows]\n\n        self.index_hint = index_hint\n        self.search_index = None\n        if total_embeddings:\n            self.search_index = Index(total_embeddings, self.index_hint)\n\n    def create_or_get_collection(self, name):\n        \"\"\"\n        Get the ID of an existing collection or create a new one with the given name.\n\n        Args:\n            name (str): Name of the collection.\n\n        Returns:\n            str: ID of the collection.\n        \"\"\"\n        collection_id = self.get_collection(name)\n        if not collection_id:\n            collection_id = self.create_collection(name)\n        self.collection_id = collection_id\n        return collection_id\n\n    def create_collection(self, name):\n        \"\"\"\n        Create a new collection with the given name.\n\n        Args:\n            name (str): Name of the collection.\n\n        Returns:\n            str: ID of the new collection.\n        \"\"\"\n        collection = self.collection_service.create(name)\n        self.collection_id = collection.get(\"id\")\n        return self.collection_id\n\n    def get_collection(self, name):\n        \"\"\"\n        Retrieve the ID of an existing collection with the given name.\n\n        Args:\n            name (str): Name of the collection.\n\n        Returns:\n            str: ID of the collection, or None if no collection with the given name exists.\n        \"\"\"\n        collection = self.collection_service.get_by_name(name)\n        self.collection_id = collection.get(\"id\")\n        return self.collection_id\n\n    def add_data(self, texts, meta_data=None):\n        \"\"\"\n        Add new data to the collection.\n\n        Args:\n            texts (list of str): List of text data to add to the collection.\n            meta_data (list or None): List of associated metadata for the added text data (optional).\n\n        Returns:\n            None.\n        \"\"\"\n        embeddings = self.embedding_fn(texts)\n        logger.info(\"Adding embedding to the database\")\n        inserted_data = self.embedding_service.add_all(\n            self.collection_id, embeddings, texts, meta_data\n        )\n\n        self.embedding_rows.extend(inserted_data)\n\n        inserted_embeddings = [row.get(\"embedding_data\") for row in inserted_data]\n\n        if self.search_index is None:\n            self.search_index = Index(embeddings, self.index_hint)\n        else:\n            self.search_index.update_index(inserted_embeddings)\n\n    def query(self, query_texts, top_k=3):\n        \"\"\"\n        Search for the most similar text data in the collection to the given query text.\n\n        Args:\n            query_texts (list or str): List of query text strings or a single query text string.\n            top_k (int): The number of top matches to return (default is 3).\n\n        Returns:\n            list of dict: A list of dictionaries containing the most similar text data in the collection to the given query text.\n                          Each dictionary has the following format:\n                          {'text': str, 'meta_data': object or None}\n        \"\"\"\n        if isinstance(query_texts, str):\n            query_texts = [query_texts]\n        query_embeddings = self.embedding_fn(query_texts)\n        indices = self.search_index.search(query_embeddings, top_k)\n        matched_embeddings = [\n            {\"text\": r.get(\"text\"), \"meta_data\": r.get(\"meta_data\")}\n            for i, r in enumerate(self.embedding_rows)\n            if i in indices\n        ]\n        return matched_embeddings", "\n\nclass Client:\n    \"\"\"\n    Client class for managing embeddings and performing nearest neighbor search.\n\n    Args:\n        collection_name (str): Name of the collection.\n        url (str, optional): Database URL. Defaults to None.\n        embedding_fn (str or EmbeddingFunction, optional): The embedding function to use. The default is the SentenceTransformer model. Supported options are 'sentence_transformer' and 'openai'. If 'openai' is selected, the 'OPENAI_API_KEY' environment variable must be set to authenticate with the OpenAI API.\n        index_hint (str, optional): Similarity search index to use. Supports: 'flat' and 'hnsw'\n        debug (bool, optional): Enable debug mode. Defaults to False.\n\n    Attributes:\n        collection_id (int): ID of the collection.\n        embedding_fn (str or EmbeddingFunction): Embedding function to use. Support 'sentence_transformer' and 'openai'.\n        session (Session): SQLAlchemy session.\n        collection_service (CollectionService): CollectionService instance.\n        embedding_service (EmbeddingService): EmbeddingService instance.\n        embedding_rows (List[EmbeddingModel]): List of Embedding instances for the current collection.\n\n    Methods:\n        create_or_get_collection(name): Get the ID of an existing collection or create a new one.\n        create_collection(name): Create a new collection with the given name.\n        get_collection(name): Get the ID of an existing collection with the given name.\n        add_data(texts, meta_data=None): Add new data to the collection.\n        query(query_texts, top_k=3): Find nearest neighbors for the given query text(s).\n    \"\"\"\n\n    def __init__(\n        self,\n        collection_name,\n        url=None,\n        embedding_fn=\"sentence_transformer\",\n        index_hint=None,\n        debug=False,\n        **kwargs\n    ):\n        self.collection_id = None\n\n        if callable(embedding_fn):\n            self.embedding_fn = embedding_fn\n        else:\n            self.embedding_fn = Embedding.create_embedding(embedding_fn)\n\n        if url is None:\n            engine = create_engine(\"sqlite:///:memory:\", echo=debug)\n        else:\n            engine = create_engine(url)\n\n        session = sessionmaker(bind=engine, expire_on_commit=False)\n        self.session = session()\n\n        self.collection_service = CollectionService(self.session)\n        self.embedding_service = EmbeddingService(self.session)\n\n        embeddings = kwargs.get(\"embeddings\")\n        embeddings_meta = kwargs.get(\"meta\")\n        texts = kwargs.get(\"texts\")\n\n        self.collection_id = self.create_or_get_collection(collection_name)\n        self.embedding_rows = self.embedding_service.get_by_collection_id(\n            self.collection_id\n        )\n\n        # Insert user-provided texts and embeddings into the database\n        inserted_rows = []\n        if embeddings is not None and texts is not None:\n            # TODO validate embeddings' shape and dtype; validate text as well\n            inserted_rows = self.embedding_service.add_all(\n                self.collection_id, embeddings, texts, embeddings_meta\n            )\n        elif texts is not None:\n            embeddings = self.embedding_fn(texts)\n            inserted_rows = self.embedding_service.add_all(\n                self.collection_id, embeddings, texts, embeddings_meta\n            )\n\n        self.embedding_rows.extend(inserted_rows)\n        total_embeddings = [row.get(\"embedding_data\") for row in self.embedding_rows]\n\n        self.index_hint = index_hint\n        self.search_index = None\n        if total_embeddings:\n            self.search_index = Index(total_embeddings, self.index_hint)\n\n    def create_or_get_collection(self, name):\n        \"\"\"\n        Get the ID of an existing collection or create a new one with the given name.\n\n        Args:\n            name (str): Name of the collection.\n\n        Returns:\n            str: ID of the collection.\n        \"\"\"\n        collection_id = self.get_collection(name)\n        if not collection_id:\n            collection_id = self.create_collection(name)\n        self.collection_id = collection_id\n        return collection_id\n\n    def create_collection(self, name):\n        \"\"\"\n        Create a new collection with the given name.\n\n        Args:\n            name (str): Name of the collection.\n\n        Returns:\n            str: ID of the new collection.\n        \"\"\"\n        collection = self.collection_service.create(name)\n        self.collection_id = collection.get(\"id\")\n        return self.collection_id\n\n    def get_collection(self, name):\n        \"\"\"\n        Retrieve the ID of an existing collection with the given name.\n\n        Args:\n            name (str): Name of the collection.\n\n        Returns:\n            str: ID of the collection, or None if no collection with the given name exists.\n        \"\"\"\n        collection = self.collection_service.get_by_name(name)\n        self.collection_id = collection.get(\"id\")\n        return self.collection_id\n\n    def add_data(self, texts, meta_data=None):\n        \"\"\"\n        Add new data to the collection.\n\n        Args:\n            texts (list of str): List of text data to add to the collection.\n            meta_data (list or None): List of associated metadata for the added text data (optional).\n\n        Returns:\n            None.\n        \"\"\"\n        embeddings = self.embedding_fn(texts)\n        logger.info(\"Adding embedding to the database\")\n        inserted_data = self.embedding_service.add_all(\n            self.collection_id, embeddings, texts, meta_data\n        )\n\n        self.embedding_rows.extend(inserted_data)\n\n        inserted_embeddings = [row.get(\"embedding_data\") for row in inserted_data]\n\n        if self.search_index is None:\n            self.search_index = Index(embeddings, self.index_hint)\n        else:\n            self.search_index.update_index(inserted_embeddings)\n\n    def query(self, query_texts, top_k=3):\n        \"\"\"\n        Search for the most similar text data in the collection to the given query text.\n\n        Args:\n            query_texts (list or str): List of query text strings or a single query text string.\n            top_k (int): The number of top matches to return (default is 3).\n\n        Returns:\n            list of dict: A list of dictionaries containing the most similar text data in the collection to the given query text.\n                          Each dictionary has the following format:\n                          {'text': str, 'meta_data': object or None}\n        \"\"\"\n        if isinstance(query_texts, str):\n            query_texts = [query_texts]\n        query_embeddings = self.embedding_fn(query_texts)\n        indices = self.search_index.search(query_embeddings, top_k)\n        matched_embeddings = [\n            {\"text\": r.get(\"text\"), \"meta_data\": r.get(\"meta_data\")}\n            for i, r in enumerate(self.embedding_rows)\n            if i in indices\n        ]\n        return matched_embeddings", "\n\nif __name__ == \"__main__\":\n    url = \"sqlite:///test.db\"\n    texts = [\n        \"Which fourteen hundred years ago were nail'd\",\n        \"Over whose acres walk'd those blessed feet\",\n        \"Which fourteen hundred years ago were nail'd\",\n        \"For our advantage on the bitter cross.\",\n        \"But this our purpose now is twelve month old,\",\n        \"And bootless 'tis to tell you we will go:\",\n        \"Therefore we meet not now. Then let me hear\",\n        \"Of you, my gentle cousin Westmoreland,\",\n        \"What yesternight our council did decree\",\n        \"In forwarding this dear expedience.\",\n        \"My liege, this haste was hot in quest\",\n    ]\n    client = Client(collection_name=\"test_collection\", texts=texts, url=url)\n    client.add_data([\"That is a good day!\"])\n    result = client.query(texts[0:10], top_k=2)\n    print(result)", ""]}
{"filename": "embedin/service/embedding_service.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport hashlib\nimport json", "import hashlib\nimport json\nimport logging\nimport uuid\nfrom datetime import datetime\n\nfrom embedin.repository.embedding_repository import EmbeddingRepository\n\n\n# Configure the root logger to output to the console", "\n# Configure the root logger to output to the console\nlogging.basicConfig(\n    format=\"%(asctime)s - %(levelname)s - %(message)s\", level=logging.INFO\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass EmbeddingService:\n    \"\"\"\n    A service class for handling operations related to embeddings.\n\n    Attributes:\n        embedding_repo (EmbeddingRepository): The repository instance for handling database interactions.\n\n    Methods:\n        add_all(collection_id, embeddings, texts, metadata_list=None):\n            Adds multiple embeddings to the database.\n\n            Args:\n                collection_id (str): The ID of the collection that the embeddings belong to.\n                embeddings (list): A list of embedding vectors, represented as numpy arrays.\n                texts (list): A list of text strings that correspond to the embeddings.\n                metadata_list (list, optional): A list of metadata objects, one for each embedding.\n\n            Returns:\n                List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n\n        get_by_collection_id(collection_id):\n            Fetches all embeddings from the database for a specified collection ID.\n\n            Args:\n                collection_id (str): The ID of the collection to retrieve embeddings for.\n\n            Returns:\n                List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n    \"\"\"\n\n    def __init__(self, session):\n        \"\"\"\n        Initializes a new instance of the EmbeddingService class.\n\n        Args:\n            session (Session): A database session object for making database queries.\n        \"\"\"\n\n        self.embedding_repo = EmbeddingRepository(session)\n\n    def add_all(self, collection_id, embeddings, texts, metadata_list=None):\n        \"\"\"\n        Adds multiple embeddings to the database.\n\n        Args:\n            collection_id (str): The ID of the collection that the embeddings belong to.\n            embeddings (list): A list of embedding vectors, represented as numpy arrays.\n            texts (list): A list of text strings that correspond to the embeddings.\n            metadata_list (list, optional): A list of metadata objects, one for each embedding.\n\n        Returns:\n            List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n        \"\"\"\n\n        # Generate a list of Embedding objects\n        rows = []\n        hash_value_set = set()\n        for i, embedding in enumerate(embeddings):\n            # Generate a UUID for the embedding\n            emb_id = str(uuid.uuid4())\n\n            meta_data = metadata_list[i] if metadata_list else None\n            data = texts[i] + collection_id + json.dumps(meta_data)\n\n            hashed = hashlib.sha256(data.encode()).hexdigest()\n            if hashed in hash_value_set:\n                continue\n            hash_value_set.add(hashed)\n\n            # Construct an Embedding object\n            row = dict(\n                id=emb_id,\n                collection_id=collection_id,\n                text=texts[i],\n                embedding_data=embedding,  # json.dumps(embedding),\n                meta_data=meta_data,\n                hash=hashed,\n                created_at=datetime.now(),\n            )\n            rows.append(row)\n\n        # Add the Embedding objects to the session and commit the transaction\n        inserted_rows = self.embedding_repo.add_all(rows)\n\n        logger.info(f\"{len(inserted_rows)} rows inserted\")\n\n        return inserted_rows\n\n    def get_by_collection_id(self, collection_id):\n        \"\"\"\n        Fetches all embeddings from the database for a specified collection ID.\n\n        Args:\n            collection_id (str): The ID of the collection to retrieve embeddings for.\n\n        Returns:\n            List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n        \"\"\"\n\n        # Get the Embedding objects for the specified collection_id\n        rows = self.embedding_repo.get_by_collection_id(collection_id)\n\n        return rows", "\nclass EmbeddingService:\n    \"\"\"\n    A service class for handling operations related to embeddings.\n\n    Attributes:\n        embedding_repo (EmbeddingRepository): The repository instance for handling database interactions.\n\n    Methods:\n        add_all(collection_id, embeddings, texts, metadata_list=None):\n            Adds multiple embeddings to the database.\n\n            Args:\n                collection_id (str): The ID of the collection that the embeddings belong to.\n                embeddings (list): A list of embedding vectors, represented as numpy arrays.\n                texts (list): A list of text strings that correspond to the embeddings.\n                metadata_list (list, optional): A list of metadata objects, one for each embedding.\n\n            Returns:\n                List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n\n        get_by_collection_id(collection_id):\n            Fetches all embeddings from the database for a specified collection ID.\n\n            Args:\n                collection_id (str): The ID of the collection to retrieve embeddings for.\n\n            Returns:\n                List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n    \"\"\"\n\n    def __init__(self, session):\n        \"\"\"\n        Initializes a new instance of the EmbeddingService class.\n\n        Args:\n            session (Session): A database session object for making database queries.\n        \"\"\"\n\n        self.embedding_repo = EmbeddingRepository(session)\n\n    def add_all(self, collection_id, embeddings, texts, metadata_list=None):\n        \"\"\"\n        Adds multiple embeddings to the database.\n\n        Args:\n            collection_id (str): The ID of the collection that the embeddings belong to.\n            embeddings (list): A list of embedding vectors, represented as numpy arrays.\n            texts (list): A list of text strings that correspond to the embeddings.\n            metadata_list (list, optional): A list of metadata objects, one for each embedding.\n\n        Returns:\n            List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n        \"\"\"\n\n        # Generate a list of Embedding objects\n        rows = []\n        hash_value_set = set()\n        for i, embedding in enumerate(embeddings):\n            # Generate a UUID for the embedding\n            emb_id = str(uuid.uuid4())\n\n            meta_data = metadata_list[i] if metadata_list else None\n            data = texts[i] + collection_id + json.dumps(meta_data)\n\n            hashed = hashlib.sha256(data.encode()).hexdigest()\n            if hashed in hash_value_set:\n                continue\n            hash_value_set.add(hashed)\n\n            # Construct an Embedding object\n            row = dict(\n                id=emb_id,\n                collection_id=collection_id,\n                text=texts[i],\n                embedding_data=embedding,  # json.dumps(embedding),\n                meta_data=meta_data,\n                hash=hashed,\n                created_at=datetime.now(),\n            )\n            rows.append(row)\n\n        # Add the Embedding objects to the session and commit the transaction\n        inserted_rows = self.embedding_repo.add_all(rows)\n\n        logger.info(f\"{len(inserted_rows)} rows inserted\")\n\n        return inserted_rows\n\n    def get_by_collection_id(self, collection_id):\n        \"\"\"\n        Fetches all embeddings from the database for a specified collection ID.\n\n        Args:\n            collection_id (str): The ID of the collection to retrieve embeddings for.\n\n        Returns:\n            List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n        \"\"\"\n\n        # Get the Embedding objects for the specified collection_id\n        rows = self.embedding_repo.get_by_collection_id(collection_id)\n\n        return rows", ""]}
{"filename": "embedin/service/collection_service.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom embedin.repository.collection_repository import CollectionRepository\n", "from embedin.repository.collection_repository import CollectionRepository\n\n\nclass CollectionService:\n    \"\"\"\n    A service class for handling operations related to collections.\n\n    Attributes:\n        collection_repo (CollectionRepository): The repository instance for handling database interactions.\n\n    Methods:\n        get_by_name(name):\n            Fetches a collection from the database by its name.\n\n            Args:\n                name (str): The name of the collection to retrieve.\n\n            Returns:\n                CollectionModel: A CollectionModel representing the row of the collection fetched from the database.\n\n        create(name, get_if_exist=True):\n            Creates a new collection in the database.\n\n            Args:\n                name (str): The name of the new collection.\n                get_if_exist (bool): If True, return the existing collection if it already exists. If False, create a new collection with the given name.\n\n            Returns:\n                CollectionModel: A CollectionModel representing the newly created collection.\n    \"\"\"\n\n    def __init__(self, session):\n        \"\"\"\n        Initializes a new instance of the CollectionService class.\n\n        Args:\n            session (Session): A database session object for making database queries.\n        \"\"\"\n\n        self.collection_repo = CollectionRepository(session)\n\n    def get_by_name(self, name):\n        \"\"\"\n        Fetches a collection from the database by its name.\n\n        Args:\n            name (str): The name of the collection to retrieve.\n\n        Returns:\n            collection: dict\n            The collection with the given name\n        \"\"\"\n\n        row = self.collection_repo.get_by_name(name)\n        return row\n\n    def create(self, name, get_if_exist=True):\n        \"\"\"\n        Creates a new collection in the database.\n\n        Args:\n            name (str): The name of the new collection.\n            get_if_exist (bool): If True, return the existing collection if it already exists. If False, create a new collection with the given name.\n\n        Returns:\n            CollectionModel: A CollectionModel representing the newly created collection.\n        \"\"\"\n\n        collection = self.collection_repo.create(name, get_if_exist)\n        return collection", ""]}
{"filename": "embedin/service/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"]}
{"filename": "embedin/embedding/sentence_transformer.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom sentence_transformers import SentenceTransformer\n", "from sentence_transformers import SentenceTransformer\n\nfrom embedin.embedding.embedding_base import EmbeddingBase\n\n\nclass SentenceTransformerEmbedding(EmbeddingBase):\n    \"\"\"\n    A class for generating text embeddings using the SentenceTransformer model.\n\n    Args:\n    model_name (str): The name or path of the SentenceTransformer model to be used for generating embeddings. Default is \"all-MiniLM-L6-v2\".\n\n    Methods:\n    __call__(texts):\n    Generates embeddings for the given input text(s).\n\n    Returns:\n    embeddings (list): A list of embeddings generated for the input text(s). Each embedding is a list of float values.\n    \"\"\"\n\n    def __init__(self, model=\"all-MiniLM-L6-v2\"):\n        \"\"\"\n        Initialize a SentenceTransformerEmbedding object.\n\n        Args:\n        model_name (str): The name or path of the SentenceTransformer model to be used for generating embeddings. Default is \"all-MiniLM-L6-v2\".\n        \"\"\"\n        self.model = SentenceTransformer(model)\n\n    def __call__(self, texts):\n        \"\"\"\n        Generates embeddings for the given input text(s).\n\n        Args:\n        texts (str/list): The input text(s) for which embeddings are to be generated. It can be a string or a list of strings.\n\n        Returns:\n        embeddings (list): A list of embeddings generated for the input text(s). Each embedding is a list of float values.\n        \"\"\"\n        # Return it as a numpy array\n        # Check if texts is a string\n        if isinstance(texts, str):\n            return self.model.encode(\n                [texts], convert_to_numpy=True, show_progress_bar=True\n            ).tolist()\n        # Check if texts is a list of strings\n        if isinstance(texts, list):\n            if all(isinstance(text, str) for text in texts):\n                return self.model.encode(\n                    texts, convert_to_numpy=True, show_progress_bar=True\n                ).tolist()\n            raise TypeError(\"Input must be a string, a list of strings\")\n        raise TypeError(\"Input must be a string, a list of strings\")", ""]}
{"filename": "embedin/embedding/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\n", "import os\n\nfrom embedin.embedding.openai_embedding import OpenAIEmbedding\nfrom embedin.embedding.sentence_transformer import SentenceTransformerEmbedding\n\n\nclass Embedding:\n    \"\"\"\n    A class for creating text embeddings using different models.\n\n    Methods:\n    create_embedding(model_type, api_key):\n    Creates an instance of an embedding model based on the specified type and API key.\n\n    __call__(texts):\n    Raises a NotImplementedError. Subclasses must implement __call__() method.\n    \"\"\"\n\n    @staticmethod\n    def create_embedding(model_type, api_key=os.getenv(\"OPENAI_API_KEY\")):\n        \"\"\"\n        Creates an instance of an embedding model based on the specified type and API key.\n\n        Args:\n        model_type (str): The type of embedding model to create. Currently supported models are \"openai\" and \"sentence_transformer\".\n        api_key (str): The API key required to use the OpenAI embedding model.\n\n        Returns:\n        An instance of the specified embedding model.\n        \"\"\"\n        if model_type == \"openai\":\n            if api_key is None:\n                raise ValueError(\n                    \"Please set OPENAI_API_KEY environment variable. Windows: set OPENAI_API_KEY=your_api_key macOS/Linux: export OPENAI_API_KEY=your_api_key\"\n                )\n            return OpenAIEmbedding(api_key=api_key)\n        elif model_type == \"sentence_transformer\":\n            return SentenceTransformerEmbedding()\n        raise ValueError(\"Unsupported model type: {}\".format(model_type))\n\n    def __call__(self, texts):\n        \"\"\"\n        Raises a NotImplementedError. Subclasses must implement __call__() method.\n\n        Args:\n        texts: The input text(s) for which embeddings are to be generated.\n\n        Raises:\n        NotImplementedError: This method is not implemented in the parent Embedding class.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement __call__() method.\")", ""]}
{"filename": "embedin/embedding/embedding_base.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nclass EmbeddingBase:\n    def __call__(self, texts):\n        raise NotImplementedError(\"Subclasses must implement __call__() method.\")", "\nclass EmbeddingBase:\n    def __call__(self, texts):\n        raise NotImplementedError(\"Subclasses must implement __call__() method.\")\n"]}
{"filename": "embedin/embedding/openai_embedding.py", "chunked_list": ["# -*- coding: utf-8 -*-\n# embedin - A vector database that empowers AI with persistent memory,\n# (C) 2023 EmbedInAI\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport openai\n", "import openai\n\nfrom embedin.embedding.embedding_base import EmbeddingBase\n\n\nclass OpenAIEmbedding(EmbeddingBase):\n    \"\"\"\n    A class for generating text embeddings using the OpenAI API.\n\n    Args:\n    api_key (str): The API key for authenticating with the OpenAI API.\n    model (str, optional): The name or ID of the OpenAI model to use for generating embeddings. Default is \"text-embedding-ada-002\".\n\n    Methods:\n    __call__(texts):\n    Generates embeddings for the given input text(s).\n\n    Returns:\n    embeddings (list): A list of embeddings generated for the input text(s). Each embedding is a list of float values.\n    \"\"\"\n\n    def __init__(self, api_key, model=\"text-embedding-ada-002\"):\n        \"\"\"\n        Initialize an OpenAIEmbedding object.\n\n        Args:\n        api_key (str): The API key for authenticating with the OpenAI API.\n        model (str, optional): The name or ID of the OpenAI model to use for generating embeddings. Default is \"text-embedding-ada-002\".\n        \"\"\"\n        openai.api_key = api_key\n        self.model = model\n\n    def __call__(self, texts):\n        \"\"\"\n        Generates embeddings for the given input text(s) using the OpenAI API.\n\n        Args:\n        texts (str/list): The input text(s) for which embeddings are to be generated. It can be a string or a list of strings.\n\n        Returns:\n        embeddings (list): A list of embeddings generated for the input text(s). Each embedding is a list of float values.\n        \"\"\"\n        embeddings = openai.Embedding.create(model=self.model, input=texts)\n        embeddings = [data[\"embedding\"] for data in embeddings[\"data\"]]\n        return embeddings", ""]}
