{"filename": "main.py", "chunked_list": ["import sys\nimport os\nfrom antlr4 import *\nfrom lexer.LangLexer import LangLexer\nfrom parser.LangParser import LangParser\nfrom parser.LangParserListener import LangParserListener, SemanticAnalyzerException\nfrom parser.LangParserVisitor import LangParserVisitor\nfrom MyErrorStrategy import MyErrorStrategy\nfrom MyErrorListener import MyErrorListener\n", "from MyErrorListener import MyErrorListener\n\n\ndef get_username():\n    from pwd import getpwuid\n    from os import getuid\n    return getpwuid(getuid())[0]\n\n\nif __name__ == '__main__':\n    print(get_username())\n    if len(sys.argv) > 1:\n        data = FileStream(sys.argv[1])\n        lexer = LangLexer(data)\n        stream = CommonTokenStream(lexer)\n        parser = LangParser(stream)\n        parser.removeErrorListeners()\n        parser.addErrorListener(MyErrorListener())\n        parser.addParseListener(LangParserListener())\n        parser.resetErrHandler(MyErrorStrategy())\n        tree = parser.program()\n        visitor = LangParserVisitor()\n        output = visitor.visit(tree)\n        if output:\n            print(output)\n    else:\n        listener = LangParserListener()\n        while True:\n            try:\n                data = InputStream(input(\">>> \"))\n                lexer = LangLexer(data)\n                stream = CommonTokenStream(lexer)\n                parser = LangParser(stream)\n                parser.removeErrorListeners()\n                parser.addErrorListener(MyErrorListener())\n                parser.addParseListener(listener)\n                parser.resetErrHandler(MyErrorStrategy())\n                tree = parser.program()\n                visitor = LangParserVisitor()\n                output = visitor.visit(tree)\n            except SemanticAnalyzerException as exc:\n                listener.clear_func_cache()\n                print(\"Error - \", exc)", "\nif __name__ == '__main__':\n    print(get_username())\n    if len(sys.argv) > 1:\n        data = FileStream(sys.argv[1])\n        lexer = LangLexer(data)\n        stream = CommonTokenStream(lexer)\n        parser = LangParser(stream)\n        parser.removeErrorListeners()\n        parser.addErrorListener(MyErrorListener())\n        parser.addParseListener(LangParserListener())\n        parser.resetErrHandler(MyErrorStrategy())\n        tree = parser.program()\n        visitor = LangParserVisitor()\n        output = visitor.visit(tree)\n        if output:\n            print(output)\n    else:\n        listener = LangParserListener()\n        while True:\n            try:\n                data = InputStream(input(\">>> \"))\n                lexer = LangLexer(data)\n                stream = CommonTokenStream(lexer)\n                parser = LangParser(stream)\n                parser.removeErrorListeners()\n                parser.addErrorListener(MyErrorListener())\n                parser.addParseListener(listener)\n                parser.resetErrHandler(MyErrorStrategy())\n                tree = parser.program()\n                visitor = LangParserVisitor()\n                output = visitor.visit(tree)\n            except SemanticAnalyzerException as exc:\n                listener.clear_func_cache()\n                print(\"Error - \", exc)", ""]}
{"filename": "MyErrorStrategy.py", "chunked_list": ["from antlr4.error.Errors import RecognitionException, NoViableAltException, InputMismatchException, \\\n    FailedPredicateException\nfrom antlr4.error.ErrorStrategy import DefaultErrorStrategy\nfrom antlr4 import *\nfrom parser.LangParser import LangParser\n\n\nclass MyErrorStrategy(DefaultErrorStrategy):\n    def __init__(self) -> None:\n        super().__init__()\n\n    def reportError(self, recognizer: Parser, e: RecognitionException, localctx: ParserRuleContext = None):\n       # if we've already reported an error and have not matched a token\n       # yet successfully, don't report any errors.\n        if self.inErrorRecoveryMode(recognizer):\n            return # don't report spurious errors\n        self.beginErrorCondition(recognizer)\n        if isinstance( e, NoViableAltException ):\n            msg = self.checkContext(localctx)\n            self.reportNoViableAlternative(recognizer, e, msg)\n        elif isinstance( e, InputMismatchException ):\n            msg = self.checkContext(localctx)\n            self.reportInputMismatch(recognizer, e, msg)\n        elif isinstance( e, FailedPredicateException ):\n            msg = self.checkContext(localctx)\n            self.reportFailedPredicate(recognizer, e, msg)\n        else:\n            print(\"unknown recognition error type: \" + type(e).__name__)\n            recognizer.notifyErrorListeners(e.message, e.offendingToken, e)\n\n    def checkContext(self, localctx : ParserRuleContext):\n        msg = None\n        if isinstance(localctx, LangParser.ForStatContext):\n            msg = \"For statement mismatched input - {}. Expected expression like for(<>;<>;<>)...\"\n        elif isinstance(localctx, LangParser.IfElseStmtContext):\n            msg = \"IF/Else statement mismatched input - {}. Expected expression like if bool_stmt <else >.\"\n        elif isinstance(localctx, LangParser.AssignExprContext):\n            msg = \"Assign expression mismatched form - {}. Expected expression <type> ID [= value];\"\n        elif isinstance(localctx, LangParser.PrintStmtContext):\n            msg = \"Print function mismatched form - {}. Expected print(<value>);\"\n        elif isinstance(localctx, LangParser.FuncContext):\n            msg = \"Function definition mismatched form - {}. Expected <type> function ID (params).\"\n        elif isinstance(localctx, LangParser.WhileStmtContext):\n            msg = \"While statement mismatched form - {}. Expected while(boolExpr)...\"\n        elif isinstance(localctx, LangParser.UntilStmtContext):\n            msg = \"Until statement mismatched form - {}. Expected ...until(boolExpr)\"\n        elif isinstance(localctx, LangParser.IncDecrStatContext):\n            msg = \"Increment or decrement statement mismatched form - {}. Expected ++/--value.\"\n        elif isinstance(localctx, LangParser.VarDeclStmtContext):\n            msg = \"Variable declaration mismatched form - {}. Expected basic_type <name> value?\"\n        elif isinstance(localctx, LangParser.CustFuncCallContext):\n            msg = \"Function call mismatched form - {}. Expected func_name(params)\"\n        elif isinstance(localctx, LangParser.IndexStmtContext):\n            msg = \"Index statement mismatched form - {}. Expected value[value]\"\n        elif isinstance(localctx, LangParser.ReadStrStmtContext):\n            msg = \"read_string function mismatched form - {}. Expected read_string();\"\n        elif isinstance(localctx, LangParser.ReturnStmtContext):\n            msg = \"return statement mismatched form - {}. Expected return value;\"\n        elif isinstance(localctx, (LangParser.CreateColStmtContext, LangParser.CreateRowStmtContext, LangParser.CreateTablStmtContext)):\n            msg = \"create function has a different form - {}. Expected create_function(params).\"\n        elif isinstance(localctx, LangParser.DelFuncContext):\n            msg = \"delete function has a mismatched form - {}. Expected delete_function(params).\"\n        elif isinstance(localctx, LangParser.InsertStmtContext):\n            msg = \"Insert function has a mismatched form - {}. Expected insert(value, value, value).\"\n        elif isinstance(localctx, LangParser.FindStmtContext):\n            msg = \"Find function has a different form - {}. Expected find(val1, val2)\"\n        elif isinstance(localctx, LangParser.LengthStmtContext):\n            msg = \"Find function has a different form - {}. Expected length(value)\"\n        elif isinstance(localctx, LangParser.CustFuncCallContext):\n            msg = \"Custom function call has a different form - {}. Expected func_name(params)\"\n        elif isinstance(localctx, LangParser.MinMaxFuncStmtContext):\n            msg = \"min/max function call has a different form - {}. Expected min_max_name(value)\"\n        elif isinstance(localctx, LangParser.ReshapeStmtContext):\n            msg = \"reshape function has a different form - {}. Expected reshape(val1, val2, val3)\"\n        elif isinstance(localctx, LangParser.ListStmtContext):\n            msg = \"List definition has a different form - {}. Expected [...,...,...]\"\n        elif isinstance(localctx, LangParser.BoolExprContext):\n            msg = \"Boolean expresion has a different form - {}. Expeted val1 <bool_sign> val2\"\n        elif isinstance(localctx, LangParser.ReturnTypeContext):\n            msg = \"Return value has a different form - {}. Gotten non return statement.\"\n        elif isinstance(localctx, LangParser.BasicTypeNameContext):\n            msg = \"Basic type name expected. But {} received.\"\n        elif isinstance(localctx, LangParser.StatContext):\n            msg = \"Expression has an incorrect form - {}.\"\n        return msg\n\n    def reportNoViableAlternative(self, recognizer: Parser, e: NoViableAltException, msg : str = None):\n        tokens = recognizer.getTokenStream()\n        if tokens is not None:\n            if e.startToken.type==Token.EOF:\n                input = \"<EOF>\"\n            else:\n                input = tokens.getText((e.startToken, e.offendingToken))\n        else:\n            input = \"<unknown input>\"\n        if msg:\n            msg = msg.format(self.escapeWSAndQuote(input))\n        else:\n            msg = \"Name \" + self.escapeWSAndQuote(input) + \" is not defined\"\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e)\n\n    def reportInputMismatch(self, recognizer: Parser, e: InputMismatchException, msg : str = None):\n        if msg:\n            msg = msg.format(self.getTokenErrorDisplay(e.offendingToken))\n        if not msg: \n            msg = \"mismatched input \" + self.getTokenErrorDisplay(e.offendingToken) \\\n              + \" expecting \" + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames)\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e)\n\n    def reportFailedPredicate(self, recognizer, e, msg):\n        ruleName = recognizer.ruleNames[recognizer._ctx.getRuleIndex()]\n        msg = msg.format(ruleName)\n        if not msg:\n            msg = \"rule \" + ruleName + \" \" + e.message\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e)\n\n    def reportMissingToken(self, recognizer:Parser):\n        if self.inErrorRecoveryMode(recognizer):\n            return\n        self.beginErrorCondition(recognizer)\n        t = recognizer.getCurrentToken()\n        expecting = self.getExpectedTokens(recognizer)\n        msg = \"missing \" + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) \\\n              + \" after line \" + self.getTokenErrorDisplay(t)\n        recognizer.notifyErrorListeners(msg, t, None)", "\n    "]}
{"filename": "MyErrorListener.py", "chunked_list": ["from antlr4.error.ErrorListener import ErrorListener\n\n\nclass MyErrorListener(ErrorListener):\n    def __init__(self) -> None:\n        super().__init__()\n\n    def syntaxError(self, recognizer, offendingSymbol, line, column, msg, e):\n        raise SyntaxError(f\"Error in line {line}:{column} - {msg}\")\n    ", "    "]}
{"filename": "lexer/LangLexer.py", "chunked_list": ["# Generated from LangLexer.g4 by ANTLR 4.7.2\nfrom antlr4 import *\nfrom io import StringIO\nfrom typing.io import TextIO\nimport sys\n\n\ndef serializedATN():\n    with StringIO() as buf:\n        buf.write(\"\\3\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\\u5964\\2B\")\n        buf.write(\"\\u01db\\b\\1\\4\\2\\t\\2\\4\\3\\t\\3\\4\\4\\t\\4\\4\\5\\t\\5\\4\\6\\t\\6\\4\\7\")\n        buf.write(\"\\t\\7\\4\\b\\t\\b\\4\\t\\t\\t\\4\\n\\t\\n\\4\\13\\t\\13\\4\\f\\t\\f\\4\\r\\t\\r\")\n        buf.write(\"\\4\\16\\t\\16\\4\\17\\t\\17\\4\\20\\t\\20\\4\\21\\t\\21\\4\\22\\t\\22\\4\\23\")\n        buf.write(\"\\t\\23\\4\\24\\t\\24\\4\\25\\t\\25\\4\\26\\t\\26\\4\\27\\t\\27\\4\\30\\t\\30\")\n        buf.write(\"\\4\\31\\t\\31\\4\\32\\t\\32\\4\\33\\t\\33\\4\\34\\t\\34\\4\\35\\t\\35\\4\\36\")\n        buf.write(\"\\t\\36\\4\\37\\t\\37\\4 \\t \\4!\\t!\\4\\\"\\t\\\"\\4#\\t#\\4$\\t$\\4%\\t%\")\n        buf.write(\"\\4&\\t&\\4\\'\\t\\'\\4(\\t(\\4)\\t)\\4*\\t*\\4+\\t+\\4,\\t,\\4-\\t-\\4.\")\n        buf.write(\"\\t.\\4/\\t/\\4\\60\\t\\60\\4\\61\\t\\61\\4\\62\\t\\62\\4\\63\\t\\63\\4\\64\")\n        buf.write(\"\\t\\64\\4\\65\\t\\65\\4\\66\\t\\66\\4\\67\\t\\67\\48\\t8\\49\\t9\\4:\\t:\")\n        buf.write(\"\\4;\\t;\\4<\\t<\\4=\\t=\\4>\\t>\\4?\\t?\\4@\\t@\\4A\\tA\\3\\2\\3\\2\\3\\3\")\n        buf.write(\"\\3\\3\\3\\4\\3\\4\\3\\5\\3\\5\\3\\5\\3\\6\\3\\6\\3\\6\\3\\7\\3\\7\\3\\7\\3\\b\\3\")\n        buf.write(\"\\b\\3\\b\\3\\t\\3\\t\\3\\n\\3\\n\\3\\13\\3\\13\\3\\f\\3\\f\\3\\r\\3\\r\\3\\16\")\n        buf.write(\"\\3\\16\\3\\16\\3\\17\\3\\17\\3\\20\\3\\20\\3\\21\\3\\21\\3\\22\\3\\22\\3\\23\")\n        buf.write(\"\\3\\23\\3\\24\\3\\24\\3\\25\\3\\25\\3\\26\\3\\26\\3\\27\\3\\27\\3\\30\\3\\30\")\n        buf.write(\"\\3\\30\\3\\31\\3\\31\\3\\32\\3\\32\\3\\32\\3\\33\\3\\33\\3\\33\\3\\34\\3\\34\")\n        buf.write(\"\\3\\34\\3\\35\\3\\35\\3\\35\\3\\35\\3\\35\\3\\35\\3\\35\\3\\35\\3\\35\\3\\36\")\n        buf.write(\"\\3\\36\\3\\36\\3\\36\\3\\37\\3\\37\\3\\37\\3\\37\\3\\37\\3\\37\\3\\37\\3 \")\n        buf.write(\"\\3 \\3 \\3!\\3!\\3!\\3!\\3!\\3\\\"\\3\\\"\\3\\\"\\3\\\"\\3\\\"\\3\\\"\\3#\\3#\\3\")\n        buf.write(\"#\\3#\\3#\\3#\\3$\\3$\\7$\\u00ed\\n$\\f$\\16$\\u00f0\\13$\\3%\\3%\\3\")\n        buf.write(\"%\\3%\\3%\\3%\\3&\\3&\\3&\\3&\\3&\\3&\\3&\\3\\'\\3\\'\\3\\'\\3\\'\\3\\'\\3\")\n        buf.write(\"\\'\\3\\'\\3\\'\\3(\\3(\\3(\\3(\\3(\\3(\\3(\\3(\\3)\\3)\\3)\\3)\\3)\\3)\\3\")\n        buf.write(\")\\3)\\3*\\3*\\3*\\3*\\3+\\3+\\3+\\3+\\3+\\3+\\3+\\3,\\3,\\3,\\3,\\3-\\3\")\n        buf.write(\"-\\3-\\3-\\3.\\3.\\3.\\3.\\3.\\3.\\3.\\3/\\3/\\3/\\3/\\3/\\3/\\3/\\3\\60\")\n        buf.write(\"\\3\\60\\3\\60\\3\\60\\3\\60\\3\\61\\3\\61\\3\\61\\3\\61\\3\\61\\3\\61\\3\\61\")\n        buf.write(\"\\3\\61\\3\\61\\3\\61\\3\\61\\3\\62\\3\\62\\3\\62\\3\\62\\3\\62\\3\\62\\3\\62\")\n        buf.write(\"\\3\\62\\3\\62\\3\\62\\3\\62\\3\\62\\3\\62\\3\\63\\3\\63\\3\\63\\3\\63\\3\\63\")\n        buf.write(\"\\3\\63\\3\\63\\3\\63\\3\\63\\3\\63\\3\\63\\3\\63\\3\\63\\3\\63\\3\\64\\3\\64\")\n        buf.write(\"\\3\\64\\3\\64\\3\\64\\3\\64\\3\\64\\3\\64\\3\\64\\3\\64\\3\\64\\3\\64\\3\\65\")\n        buf.write(\"\\3\\65\\3\\65\\3\\65\\3\\65\\3\\66\\3\\66\\3\\66\\3\\66\\3\\66\\3\\67\\3\\67\")\n        buf.write(\"\\3\\67\\3\\67\\3\\67\\3\\67\\3\\67\\38\\38\\38\\38\\38\\38\\39\\39\\39\\3\")\n        buf.write(\"9\\39\\39\\39\\3:\\3:\\3:\\3:\\3;\\3;\\3;\\3;\\3;\\3<\\3<\\5<\\u0198\\n\")\n        buf.write(\"<\\3<\\6<\\u019b\\n<\\r<\\16<\\u019c\\3<\\3<\\6<\\u01a1\\n<\\r<\\16\")\n        buf.write(\"<\\u01a2\\5<\\u01a5\\n<\\3<\\3<\\3<\\5<\\u01aa\\n<\\3<\\6<\\u01ad\\n\")\n        buf.write(\"<\\r<\\16<\\u01ae\\5<\\u01b1\\n<\\3=\\3=\\3=\\3=\\7=\\u01b7\\n=\\f=\")\n        buf.write(\"\\16=\\u01ba\\13=\\3=\\3=\\3>\\3>\\7>\\u01c0\\n>\\f>\\16>\\u01c3\\13\")\n        buf.write(\">\\3?\\6?\\u01c6\\n?\\r?\\16?\\u01c7\\3?\\3?\\3@\\3@\\3@\\3@\\3@\\3@\")\n        buf.write(\"\\3@\\3@\\3A\\3A\\3A\\3A\\3A\\3A\\3A\\3A\\2\\2B\\3\\3\\5\\4\\7\\5\\t\\6\\13\")\n        buf.write(\"\\7\\r\\b\\17\\t\\21\\n\\23\\13\\25\\f\\27\\r\\31\\16\\33\\17\\35\\20\\37\")\n        buf.write(\"\\21!\\22#\\23%\\24\\'\\25)\\26+\\27-\\30/\\31\\61\\32\\63\\33\\65\\34\")\n        buf.write(\"\\67\\359\\36;\\37= ?!A\\\"C#E$G%I&K\\'M(O)Q*S+U,W-Y.[/]\\60_\")\n        buf.write(\"\\61a\\62c\\63e\\64g\\65i\\66k\\67m8o9q:s;u<w=y>{?}@\\177A\\u0081\")\n        buf.write(\"B\\3\\2\\t\\4\\2\\f\\f\\17\\17\\3\\2\\62;\\4\\2GGgg\\4\\2$$^^\\5\\2C\\\\a\")\n        buf.write(\"ac|\\6\\2\\62;C\\\\aac|\\5\\2\\13\\f\\16\\17\\\"\\\"\\2\\u01e8\\2\\3\\3\\2\")\n        buf.write(\"\\2\\2\\2\\5\\3\\2\\2\\2\\2\\7\\3\\2\\2\\2\\2\\t\\3\\2\\2\\2\\2\\13\\3\\2\\2\\2\")\n        buf.write(\"\\2\\r\\3\\2\\2\\2\\2\\17\\3\\2\\2\\2\\2\\21\\3\\2\\2\\2\\2\\23\\3\\2\\2\\2\\2\")\n        buf.write(\"\\25\\3\\2\\2\\2\\2\\27\\3\\2\\2\\2\\2\\31\\3\\2\\2\\2\\2\\33\\3\\2\\2\\2\\2\\35\")\n        buf.write(\"\\3\\2\\2\\2\\2\\37\\3\\2\\2\\2\\2!\\3\\2\\2\\2\\2#\\3\\2\\2\\2\\2%\\3\\2\\2\\2\")\n        buf.write(\"\\2\\'\\3\\2\\2\\2\\2)\\3\\2\\2\\2\\2+\\3\\2\\2\\2\\2-\\3\\2\\2\\2\\2/\\3\\2\\2\")\n        buf.write(\"\\2\\2\\61\\3\\2\\2\\2\\2\\63\\3\\2\\2\\2\\2\\65\\3\\2\\2\\2\\2\\67\\3\\2\\2\\2\")\n        buf.write(\"\\29\\3\\2\\2\\2\\2;\\3\\2\\2\\2\\2=\\3\\2\\2\\2\\2?\\3\\2\\2\\2\\2A\\3\\2\\2\")\n        buf.write(\"\\2\\2C\\3\\2\\2\\2\\2E\\3\\2\\2\\2\\2G\\3\\2\\2\\2\\2I\\3\\2\\2\\2\\2K\\3\\2\")\n        buf.write(\"\\2\\2\\2M\\3\\2\\2\\2\\2O\\3\\2\\2\\2\\2Q\\3\\2\\2\\2\\2S\\3\\2\\2\\2\\2U\\3\")\n        buf.write(\"\\2\\2\\2\\2W\\3\\2\\2\\2\\2Y\\3\\2\\2\\2\\2[\\3\\2\\2\\2\\2]\\3\\2\\2\\2\\2_\")\n        buf.write(\"\\3\\2\\2\\2\\2a\\3\\2\\2\\2\\2c\\3\\2\\2\\2\\2e\\3\\2\\2\\2\\2g\\3\\2\\2\\2\\2\")\n        buf.write(\"i\\3\\2\\2\\2\\2k\\3\\2\\2\\2\\2m\\3\\2\\2\\2\\2o\\3\\2\\2\\2\\2q\\3\\2\\2\\2\")\n        buf.write(\"\\2s\\3\\2\\2\\2\\2u\\3\\2\\2\\2\\2w\\3\\2\\2\\2\\2y\\3\\2\\2\\2\\2{\\3\\2\\2\")\n        buf.write(\"\\2\\2}\\3\\2\\2\\2\\2\\177\\3\\2\\2\\2\\2\\u0081\\3\\2\\2\\2\\3\\u0083\\3\")\n        buf.write(\"\\2\\2\\2\\5\\u0085\\3\\2\\2\\2\\7\\u0087\\3\\2\\2\\2\\t\\u0089\\3\\2\\2\\2\")\n        buf.write(\"\\13\\u008c\\3\\2\\2\\2\\r\\u008f\\3\\2\\2\\2\\17\\u0092\\3\\2\\2\\2\\21\")\n        buf.write(\"\\u0095\\3\\2\\2\\2\\23\\u0097\\3\\2\\2\\2\\25\\u0099\\3\\2\\2\\2\\27\\u009b\")\n        buf.write(\"\\3\\2\\2\\2\\31\\u009d\\3\\2\\2\\2\\33\\u009f\\3\\2\\2\\2\\35\\u00a2\\3\")\n        buf.write(\"\\2\\2\\2\\37\\u00a4\\3\\2\\2\\2!\\u00a6\\3\\2\\2\\2#\\u00a8\\3\\2\\2\\2\")\n        buf.write(\"%\\u00aa\\3\\2\\2\\2\\'\\u00ac\\3\\2\\2\\2)\\u00ae\\3\\2\\2\\2+\\u00b0\")\n        buf.write(\"\\3\\2\\2\\2-\\u00b2\\3\\2\\2\\2/\\u00b4\\3\\2\\2\\2\\61\\u00b7\\3\\2\\2\")\n        buf.write(\"\\2\\63\\u00b9\\3\\2\\2\\2\\65\\u00bc\\3\\2\\2\\2\\67\\u00bf\\3\\2\\2\\2\")\n        buf.write(\"9\\u00c2\\3\\2\\2\\2;\\u00cb\\3\\2\\2\\2=\\u00cf\\3\\2\\2\\2?\\u00d6\\3\")\n        buf.write(\"\\2\\2\\2A\\u00d9\\3\\2\\2\\2C\\u00de\\3\\2\\2\\2E\\u00e4\\3\\2\\2\\2G\\u00ea\")\n        buf.write(\"\\3\\2\\2\\2I\\u00f1\\3\\2\\2\\2K\\u00f7\\3\\2\\2\\2M\\u00fe\\3\\2\\2\\2\")\n        buf.write(\"O\\u0106\\3\\2\\2\\2Q\\u010e\\3\\2\\2\\2S\\u0116\\3\\2\\2\\2U\\u011a\\3\")\n        buf.write(\"\\2\\2\\2W\\u0121\\3\\2\\2\\2Y\\u0125\\3\\2\\2\\2[\\u0129\\3\\2\\2\\2]\\u0130\")\n        buf.write(\"\\3\\2\\2\\2_\\u0137\\3\\2\\2\\2a\\u013c\\3\\2\\2\\2c\\u0147\\3\\2\\2\\2\")\n        buf.write(\"e\\u0154\\3\\2\\2\\2g\\u0162\\3\\2\\2\\2i\\u016e\\3\\2\\2\\2k\\u0173\\3\")\n        buf.write(\"\\2\\2\\2m\\u0178\\3\\2\\2\\2o\\u017f\\3\\2\\2\\2q\\u0185\\3\\2\\2\\2s\\u018c\")\n        buf.write(\"\\3\\2\\2\\2u\\u0190\\3\\2\\2\\2w\\u0197\\3\\2\\2\\2y\\u01b2\\3\\2\\2\\2\")\n        buf.write(\"{\\u01bd\\3\\2\\2\\2}\\u01c5\\3\\2\\2\\2\\177\\u01cb\\3\\2\\2\\2\\u0081\")\n        buf.write(\"\\u01d3\\3\\2\\2\\2\\u0083\\u0084\\7(\\2\\2\\u0084\\4\\3\\2\\2\\2\\u0085\")\n        buf.write(\"\\u0086\\7~\\2\\2\\u0086\\6\\3\\2\\2\\2\\u0087\\u0088\\7#\\2\\2\\u0088\")\n        buf.write(\"\\b\\3\\2\\2\\2\\u0089\\u008a\\7?\\2\\2\\u008a\\u008b\\7?\\2\\2\\u008b\")\n        buf.write(\"\\n\\3\\2\\2\\2\\u008c\\u008d\\7#\\2\\2\\u008d\\u008e\\7?\\2\\2\\u008e\")\n        buf.write(\"\\f\\3\\2\\2\\2\\u008f\\u0090\\7>\\2\\2\\u0090\\u0091\\7?\\2\\2\\u0091\")\n        buf.write(\"\\16\\3\\2\\2\\2\\u0092\\u0093\\7@\\2\\2\\u0093\\u0094\\7?\\2\\2\\u0094\")\n        buf.write(\"\\20\\3\\2\\2\\2\\u0095\\u0096\\7>\\2\\2\\u0096\\22\\3\\2\\2\\2\\u0097\")\n        buf.write(\"\\u0098\\7@\\2\\2\\u0098\\24\\3\\2\\2\\2\\u0099\\u009a\\7-\\2\\2\\u009a\")\n        buf.write(\"\\26\\3\\2\\2\\2\\u009b\\u009c\\7/\\2\\2\\u009c\\30\\3\\2\\2\\2\\u009d\")\n        buf.write(\"\\u009e\\7\\61\\2\\2\\u009e\\32\\3\\2\\2\\2\\u009f\\u00a0\\7\\61\\2\\2\")\n        buf.write(\"\\u00a0\\u00a1\\7\\61\\2\\2\\u00a1\\34\\3\\2\\2\\2\\u00a2\\u00a3\\7,\")\n        buf.write(\"\\2\\2\\u00a3\\36\\3\\2\\2\\2\\u00a4\\u00a5\\7.\\2\\2\\u00a5 \\3\\2\\2\")\n        buf.write(\"\\2\\u00a6\\u00a7\\7=\\2\\2\\u00a7\\\"\\3\\2\\2\\2\\u00a8\\u00a9\\7*\\2\")\n        buf.write(\"\\2\\u00a9$\\3\\2\\2\\2\\u00aa\\u00ab\\7+\\2\\2\\u00ab&\\3\\2\\2\\2\\u00ac\")\n        buf.write(\"\\u00ad\\7}\\2\\2\\u00ad(\\3\\2\\2\\2\\u00ae\\u00af\\7\\177\\2\\2\\u00af\")\n        buf.write(\"*\\3\\2\\2\\2\\u00b0\\u00b1\\7]\\2\\2\\u00b1,\\3\\2\\2\\2\\u00b2\\u00b3\")\n        buf.write(\"\\7_\\2\\2\\u00b3.\\3\\2\\2\\2\\u00b4\\u00b5\\7-\\2\\2\\u00b5\\u00b6\")\n        buf.write(\"\\7?\\2\\2\\u00b6\\60\\3\\2\\2\\2\\u00b7\\u00b8\\7?\\2\\2\\u00b8\\62\\3\")\n        buf.write(\"\\2\\2\\2\\u00b9\\u00ba\\7/\\2\\2\\u00ba\\u00bb\\7?\\2\\2\\u00bb\\64\")\n        buf.write(\"\\3\\2\\2\\2\\u00bc\\u00bd\\7,\\2\\2\\u00bd\\u00be\\7?\\2\\2\\u00be\\66\")\n        buf.write(\"\\3\\2\\2\\2\\u00bf\\u00c0\\7\\61\\2\\2\\u00c0\\u00c1\\7?\\2\\2\\u00c1\")\n        buf.write(\"8\\3\\2\\2\\2\\u00c2\\u00c3\\7h\\2\\2\\u00c3\\u00c4\\7w\\2\\2\\u00c4\")\n        buf.write(\"\\u00c5\\7p\\2\\2\\u00c5\\u00c6\\7e\\2\\2\\u00c6\\u00c7\\7v\\2\\2\\u00c7\")\n        buf.write(\"\\u00c8\\7k\\2\\2\\u00c8\\u00c9\\7q\\2\\2\\u00c9\\u00ca\\7p\\2\\2\\u00ca\")\n        buf.write(\":\\3\\2\\2\\2\\u00cb\\u00cc\\7h\\2\\2\\u00cc\\u00cd\\7q\\2\\2\\u00cd\")\n        buf.write(\"\\u00ce\\7t\\2\\2\\u00ce<\\3\\2\\2\\2\\u00cf\\u00d0\\7t\\2\\2\\u00d0\")\n        buf.write(\"\\u00d1\\7g\\2\\2\\u00d1\\u00d2\\7v\\2\\2\\u00d2\\u00d3\\7w\\2\\2\\u00d3\")\n        buf.write(\"\\u00d4\\7t\\2\\2\\u00d4\\u00d5\\7p\\2\\2\\u00d5>\\3\\2\\2\\2\\u00d6\")\n        buf.write(\"\\u00d7\\7k\\2\\2\\u00d7\\u00d8\\7h\\2\\2\\u00d8@\\3\\2\\2\\2\\u00d9\")\n        buf.write(\"\\u00da\\7g\\2\\2\\u00da\\u00db\\7n\\2\\2\\u00db\\u00dc\\7u\\2\\2\\u00dc\")\n        buf.write(\"\\u00dd\\7g\\2\\2\\u00ddB\\3\\2\\2\\2\\u00de\\u00df\\7y\\2\\2\\u00df\")\n        buf.write(\"\\u00e0\\7j\\2\\2\\u00e0\\u00e1\\7k\\2\\2\\u00e1\\u00e2\\7n\\2\\2\\u00e2\")\n        buf.write(\"\\u00e3\\7g\\2\\2\\u00e3D\\3\\2\\2\\2\\u00e4\\u00e5\\7w\\2\\2\\u00e5\")\n        buf.write(\"\\u00e6\\7p\\2\\2\\u00e6\\u00e7\\7v\\2\\2\\u00e7\\u00e8\\7k\\2\\2\\u00e8\")\n        buf.write(\"\\u00e9\\7n\\2\\2\\u00e9F\\3\\2\\2\\2\\u00ea\\u00ee\\7%\\2\\2\\u00eb\")\n        buf.write(\"\\u00ed\\n\\2\\2\\2\\u00ec\\u00eb\\3\\2\\2\\2\\u00ed\\u00f0\\3\\2\\2\\2\")\n        buf.write(\"\\u00ee\\u00ec\\3\\2\\2\\2\\u00ee\\u00ef\\3\\2\\2\\2\\u00efH\\3\\2\\2\")\n        buf.write(\"\\2\\u00f0\\u00ee\\3\\2\\2\\2\\u00f1\\u00f2\\7r\\2\\2\\u00f2\\u00f3\")\n        buf.write(\"\\7t\\2\\2\\u00f3\\u00f4\\7k\\2\\2\\u00f4\\u00f5\\7p\\2\\2\\u00f5\\u00f6\")\n        buf.write(\"\\7v\\2\\2\\u00f6J\\3\\2\\2\\2\\u00f7\\u00f8\\7n\\2\\2\\u00f8\\u00f9\")\n        buf.write(\"\\7g\\2\\2\\u00f9\\u00fa\\7p\\2\\2\\u00fa\\u00fb\\7i\\2\\2\\u00fb\\u00fc\")\n        buf.write(\"\\7v\\2\\2\\u00fc\\u00fd\\7j\\2\\2\\u00fdL\\3\\2\\2\\2\\u00fe\\u00ff\")\n        buf.write(\"\\7t\\2\\2\\u00ff\\u0100\\7g\\2\\2\\u0100\\u0101\\7u\\2\\2\\u0101\\u0102\")\n        buf.write(\"\\7j\\2\\2\\u0102\\u0103\\7c\\2\\2\\u0103\\u0104\\7r\\2\\2\\u0104\\u0105\")\n        buf.write(\"\\7g\\2\\2\\u0105N\\3\\2\\2\\2\\u0106\\u0107\\7f\\2\\2\\u0107\\u0108\")\n        buf.write(\"\\7g\\2\\2\\u0108\\u0109\\7n\\2\\2\\u0109\\u010a\\7a\\2\\2\\u010a\\u010b\")\n        buf.write(\"\\7e\\2\\2\\u010b\\u010c\\7q\\2\\2\\u010c\\u010d\\7n\\2\\2\\u010dP\\3\")\n        buf.write(\"\\2\\2\\2\\u010e\\u010f\\7f\\2\\2\\u010f\\u0110\\7g\\2\\2\\u0110\\u0111\")\n        buf.write(\"\\7n\\2\\2\\u0111\\u0112\\7a\\2\\2\\u0112\\u0113\\7t\\2\\2\\u0113\\u0114\")\n        buf.write(\"\\7q\\2\\2\\u0114\\u0115\\7y\\2\\2\\u0115R\\3\\2\\2\\2\\u0116\\u0117\")\n        buf.write(\"\\7f\\2\\2\\u0117\\u0118\\7g\\2\\2\\u0118\\u0119\\7n\\2\\2\\u0119T\\3\")\n        buf.write(\"\\2\\2\\2\\u011a\\u011b\\7k\\2\\2\\u011b\\u011c\\7p\\2\\2\\u011c\\u011d\")\n        buf.write(\"\\7u\\2\\2\\u011d\\u011e\\7g\\2\\2\\u011e\\u011f\\7t\\2\\2\\u011f\\u0120\")\n        buf.write(\"\\7v\\2\\2\\u0120V\\3\\2\\2\\2\\u0121\\u0122\\7o\\2\\2\\u0122\\u0123\")\n        buf.write(\"\\7c\\2\\2\\u0123\\u0124\\7z\\2\\2\\u0124X\\3\\2\\2\\2\\u0125\\u0126\")\n        buf.write(\"\\7o\\2\\2\\u0126\\u0127\\7k\\2\\2\\u0127\\u0128\\7p\\2\\2\\u0128Z\\3\")\n        buf.write(\"\\2\\2\\2\\u0129\\u012a\\7o\\2\\2\\u012a\\u012b\\7c\\2\\2\\u012b\\u012c\")\n        buf.write(\"\\7z\\2\\2\\u012c\\u012d\\7n\\2\\2\\u012d\\u012e\\7g\\2\\2\\u012e\\u012f\")\n        buf.write(\"\\7p\\2\\2\\u012f\\\\\\3\\2\\2\\2\\u0130\\u0131\\7o\\2\\2\\u0131\\u0132\")\n        buf.write(\"\\7k\\2\\2\\u0132\\u0133\\7p\\2\\2\\u0133\\u0134\\7n\\2\\2\\u0134\\u0135\")\n        buf.write(\"\\7g\\2\\2\\u0135\\u0136\\7p\\2\\2\\u0136^\\3\\2\\2\\2\\u0137\\u0138\")\n        buf.write(\"\\7h\\2\\2\\u0138\\u0139\\7k\\2\\2\\u0139\\u013a\\7p\\2\\2\\u013a\\u013b\")\n        buf.write(\"\\7f\\2\\2\\u013b`\\3\\2\\2\\2\\u013c\\u013d\\7e\\2\\2\\u013d\\u013e\")\n        buf.write(\"\\7t\\2\\2\\u013e\\u013f\\7g\\2\\2\\u013f\\u0140\\7c\\2\\2\\u0140\\u0141\")\n        buf.write(\"\\7v\\2\\2\\u0141\\u0142\\7g\\2\\2\\u0142\\u0143\\7a\\2\\2\\u0143\\u0144\")\n        buf.write(\"\\7t\\2\\2\\u0144\\u0145\\7q\\2\\2\\u0145\\u0146\\7y\\2\\2\\u0146b\\3\")\n        buf.write(\"\\2\\2\\2\\u0147\\u0148\\7e\\2\\2\\u0148\\u0149\\7t\\2\\2\\u0149\\u014a\")\n        buf.write(\"\\7g\\2\\2\\u014a\\u014b\\7c\\2\\2\\u014b\\u014c\\7v\\2\\2\\u014c\\u014d\")\n        buf.write(\"\\7g\\2\\2\\u014d\\u014e\\7a\\2\\2\\u014e\\u014f\\7v\\2\\2\\u014f\\u0150\")\n        buf.write(\"\\7c\\2\\2\\u0150\\u0151\\7d\\2\\2\\u0151\\u0152\\7n\\2\\2\\u0152\\u0153\")\n        buf.write(\"\\7g\\2\\2\\u0153d\\3\\2\\2\\2\\u0154\\u0155\\7e\\2\\2\\u0155\\u0156\")\n        buf.write(\"\\7t\\2\\2\\u0156\\u0157\\7g\\2\\2\\u0157\\u0158\\7c\\2\\2\\u0158\\u0159\")\n        buf.write(\"\\7v\\2\\2\\u0159\\u015a\\7g\\2\\2\\u015a\\u015b\\7a\\2\\2\\u015b\\u015c\")\n        buf.write(\"\\7e\\2\\2\\u015c\\u015d\\7q\\2\\2\\u015d\\u015e\\7n\\2\\2\\u015e\\u015f\")\n        buf.write(\"\\7w\\2\\2\\u015f\\u0160\\7o\\2\\2\\u0160\\u0161\\7p\\2\\2\\u0161f\\3\")\n        buf.write(\"\\2\\2\\2\\u0162\\u0163\\7t\\2\\2\\u0163\\u0164\\7g\\2\\2\\u0164\\u0165\")\n        buf.write(\"\\7c\\2\\2\\u0165\\u0166\\7f\\2\\2\\u0166\\u0167\\7a\\2\\2\\u0167\\u0168\")\n        buf.write(\"\\7u\\2\\2\\u0168\\u0169\\7v\\2\\2\\u0169\\u016a\\7t\\2\\2\\u016a\\u016b\")\n        buf.write(\"\\7k\\2\\2\\u016b\\u016c\\7p\\2\\2\\u016c\\u016d\\7i\\2\\2\\u016dh\\3\")\n        buf.write(\"\\2\\2\\2\\u016e\\u016f\\7e\\2\\2\\u016f\\u0170\\7q\\2\\2\\u0170\\u0171\")\n        buf.write(\"\\7r\\2\\2\\u0171\\u0172\\7{\\2\\2\\u0172j\\3\\2\\2\\2\\u0173\\u0174\")\n        buf.write(\"\\7p\\2\\2\\u0174\\u0175\\7w\\2\\2\\u0175\\u0176\\7o\\2\\2\\u0176\\u0177\")\n        buf.write(\"\\7d\\2\\2\\u0177l\\3\\2\\2\\2\\u0178\\u0179\\7u\\2\\2\\u0179\\u017a\")\n        buf.write(\"\\7v\\2\\2\\u017a\\u017b\\7t\\2\\2\\u017b\\u017c\\7k\\2\\2\\u017c\\u017d\")\n        buf.write(\"\\7p\\2\\2\\u017d\\u017e\\7i\\2\\2\\u017en\\3\\2\\2\\2\\u017f\\u0180\")\n        buf.write(\"\\7v\\2\\2\\u0180\\u0181\\7c\\2\\2\\u0181\\u0182\\7d\\2\\2\\u0182\\u0183\")\n        buf.write(\"\\7n\\2\\2\\u0183\\u0184\\7g\\2\\2\\u0184p\\3\\2\\2\\2\\u0185\\u0186\")\n        buf.write(\"\\7e\\2\\2\\u0186\\u0187\\7q\\2\\2\\u0187\\u0188\\7n\\2\\2\\u0188\\u0189\")\n        buf.write(\"\\7w\\2\\2\\u0189\\u018a\\7o\\2\\2\\u018a\\u018b\\7p\\2\\2\\u018br\\3\")\n        buf.write(\"\\2\\2\\2\\u018c\\u018d\\7t\\2\\2\\u018d\\u018e\\7q\\2\\2\\u018e\\u018f\")\n        buf.write(\"\\7y\\2\\2\\u018ft\\3\\2\\2\\2\\u0190\\u0191\\7x\\2\\2\\u0191\\u0192\")\n        buf.write(\"\\7q\\2\\2\\u0192\\u0193\\7k\\2\\2\\u0193\\u0194\\7f\\2\\2\\u0194v\\3\")\n        buf.write(\"\\2\\2\\2\\u0195\\u0198\\5\\25\\13\\2\\u0196\\u0198\\5\\27\\f\\2\\u0197\")\n        buf.write(\"\\u0195\\3\\2\\2\\2\\u0197\\u0196\\3\\2\\2\\2\\u0197\\u0198\\3\\2\\2\\2\")\n        buf.write(\"\\u0198\\u019a\\3\\2\\2\\2\\u0199\\u019b\\t\\3\\2\\2\\u019a\\u0199\\3\")\n        buf.write(\"\\2\\2\\2\\u019b\\u019c\\3\\2\\2\\2\\u019c\\u019a\\3\\2\\2\\2\\u019c\\u019d\")\n        buf.write(\"\\3\\2\\2\\2\\u019d\\u01a4\\3\\2\\2\\2\\u019e\\u01a0\\7\\60\\2\\2\\u019f\")\n        buf.write(\"\\u01a1\\t\\3\\2\\2\\u01a0\\u019f\\3\\2\\2\\2\\u01a1\\u01a2\\3\\2\\2\\2\")\n        buf.write(\"\\u01a2\\u01a0\\3\\2\\2\\2\\u01a2\\u01a3\\3\\2\\2\\2\\u01a3\\u01a5\\3\")\n        buf.write(\"\\2\\2\\2\\u01a4\\u019e\\3\\2\\2\\2\\u01a4\\u01a5\\3\\2\\2\\2\\u01a5\\u01b0\")\n        buf.write(\"\\3\\2\\2\\2\\u01a6\\u01a9\\t\\4\\2\\2\\u01a7\\u01aa\\5\\25\\13\\2\\u01a8\")\n        buf.write(\"\\u01aa\\5\\27\\f\\2\\u01a9\\u01a7\\3\\2\\2\\2\\u01a9\\u01a8\\3\\2\\2\")\n        buf.write(\"\\2\\u01a9\\u01aa\\3\\2\\2\\2\\u01aa\\u01ac\\3\\2\\2\\2\\u01ab\\u01ad\")\n        buf.write(\"\\t\\3\\2\\2\\u01ac\\u01ab\\3\\2\\2\\2\\u01ad\\u01ae\\3\\2\\2\\2\\u01ae\")\n        buf.write(\"\\u01ac\\3\\2\\2\\2\\u01ae\\u01af\\3\\2\\2\\2\\u01af\\u01b1\\3\\2\\2\\2\")\n        buf.write(\"\\u01b0\\u01a6\\3\\2\\2\\2\\u01b0\\u01b1\\3\\2\\2\\2\\u01b1x\\3\\2\\2\")\n        buf.write(\"\\2\\u01b2\\u01b8\\7$\\2\\2\\u01b3\\u01b7\\n\\5\\2\\2\\u01b4\\u01b5\")\n        buf.write(\"\\7^\\2\\2\\u01b5\\u01b7\\13\\2\\2\\2\\u01b6\\u01b3\\3\\2\\2\\2\\u01b6\")\n        buf.write(\"\\u01b4\\3\\2\\2\\2\\u01b7\\u01ba\\3\\2\\2\\2\\u01b8\\u01b6\\3\\2\\2\\2\")\n        buf.write(\"\\u01b8\\u01b9\\3\\2\\2\\2\\u01b9\\u01bb\\3\\2\\2\\2\\u01ba\\u01b8\\3\")\n        buf.write(\"\\2\\2\\2\\u01bb\\u01bc\\7$\\2\\2\\u01bcz\\3\\2\\2\\2\\u01bd\\u01c1\\t\")\n        buf.write(\"\\6\\2\\2\\u01be\\u01c0\\t\\7\\2\\2\\u01bf\\u01be\\3\\2\\2\\2\\u01c0\\u01c3\")\n        buf.write(\"\\3\\2\\2\\2\\u01c1\\u01bf\\3\\2\\2\\2\\u01c1\\u01c2\\3\\2\\2\\2\\u01c2\")\n        buf.write(\"|\\3\\2\\2\\2\\u01c3\\u01c1\\3\\2\\2\\2\\u01c4\\u01c6\\t\\b\\2\\2\\u01c5\")\n        buf.write(\"\\u01c4\\3\\2\\2\\2\\u01c6\\u01c7\\3\\2\\2\\2\\u01c7\\u01c5\\3\\2\\2\\2\")\n        buf.write(\"\\u01c7\\u01c8\\3\\2\\2\\2\\u01c8\\u01c9\\3\\2\\2\\2\\u01c9\\u01ca\\b\")\n        buf.write(\"?\\2\\2\\u01ca~\\3\\2\\2\\2\\u01cb\\u01cc\\7e\\2\\2\\u01cc\\u01cd\\7\")\n        buf.write(\"q\\2\\2\\u01cd\\u01ce\\7p\\2\\2\\u01ce\\u01cf\\7u\\2\\2\\u01cf\\u01d0\")\n        buf.write(\"\\7v\\2\\2\\u01d0\\u01d1\\3\\2\\2\\2\\u01d1\\u01d2\\5w<\\2\\u01d2\\u0080\")\n        buf.write(\"\\3\\2\\2\\2\\u01d3\\u01d4\\7e\\2\\2\\u01d4\\u01d5\\7q\\2\\2\\u01d5\\u01d6\")\n        buf.write(\"\\7p\\2\\2\\u01d6\\u01d7\\7u\\2\\2\\u01d7\\u01d8\\7v\\2\\2\\u01d8\\u01d9\")\n        buf.write(\"\\3\\2\\2\\2\\u01d9\\u01da\\5y=\\2\\u01da\\u0082\\3\\2\\2\\2\\17\\2\\u00ee\")\n        buf.write(\"\\u0197\\u019c\\u01a2\\u01a4\\u01a9\\u01ae\\u01b0\\u01b6\\u01b8\")\n        buf.write(\"\\u01c1\\u01c7\\3\\b\\2\\2\")\n        return buf.getvalue()", "\n\nclass LangLexer(Lexer):\n\n    atn = ATNDeserializer().deserialize(serializedATN())\n\n    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]\n\n    AND = 1\n    OR = 2\n    NOT = 3\n    EQUAL = 4\n    NOT_EQUAL = 5\n    LESS_EQUAL = 6\n    GREATER_EQUAL = 7\n    LESS = 8\n    GREATER = 9\n    PLUS = 10\n    MINUS = 11\n    DIV = 12\n    FULL_DIV = 13\n    MULT = 14\n    COMMA = 15\n    SEMI = 16\n    LPAREN = 17\n    RPAREN = 18\n    LCURLY = 19\n    RCURLY = 20\n    L_SQBRACK = 21\n    P_SQBRACK = 22\n    PLUS_EQUAL = 23\n    ASSIGN = 24\n    MINUS_EQUAL = 25\n    MULT_EQUAL = 26\n    DIV_EQUAL = 27\n    FUNCTION = 28\n    FOR = 29\n    RETURN = 30\n    IF = 31\n    ELSE = 32\n    WHILE = 33\n    UNTIL = 34\n    COMMENT = 35\n    PRINT = 36\n    LENGTH = 37\n    RESHAPE = 38\n    DEL_COL = 39\n    DEL_ROW = 40\n    DEL = 41\n    INSERT = 42\n    MAX = 43\n    MIN = 44\n    MAXLEN = 45\n    MINLEN = 46\n    FIND = 47\n    CREATE_ROW = 48\n    CREATE_TABLE = 49\n    CREATE_COL = 50\n    READ_STRING = 51\n    COPY = 52\n    NUMBER_type = 53\n    STRING_type = 54\n    TABLE = 55\n    COLUMN = 56\n    ROW = 57\n    VOID = 58\n    NUMBER = 59\n    STRING = 60\n    ID = 61\n    WS = 62\n    CONST_NUMBER = 63\n    CONST_STRING = 64\n\n    channelNames = [ u\"DEFAULT_TOKEN_CHANNEL\", u\"HIDDEN\" ]\n\n    modeNames = [ \"DEFAULT_MODE\" ]\n\n    literalNames = [ \"<INVALID>\",\n            \"'&'\", \"'|'\", \"'!'\", \"'=='\", \"'!='\", \"'<='\", \"'>='\", \"'<'\", \n            \"'>'\", \"'+'\", \"'-'\", \"'/'\", \"'//'\", \"'*'\", \"','\", \"';'\", \"'('\", \n            \"')'\", \"'{'\", \"'}'\", \"'['\", \"']'\", \"'+='\", \"'='\", \"'-='\", \"'*='\", \n            \"'/='\", \"'function'\", \"'for'\", \"'return'\", \"'if'\", \"'else'\", \n            \"'while'\", \"'until'\", \"'print'\", \"'length'\", \"'reshape'\", \"'del_col'\", \n            \"'del_row'\", \"'del'\", \"'insert'\", \"'max'\", \"'min'\", \"'maxlen'\", \n            \"'minlen'\", \"'find'\", \"'create_row'\", \"'create_table'\", \"'create_column'\", \n            \"'read_string'\", \"'copy'\", \"'numb'\", \"'string'\", \"'table'\", \n            \"'column'\", \"'row'\", \"'void'\" ]\n\n    symbolicNames = [ \"<INVALID>\",\n            \"AND\", \"OR\", \"NOT\", \"EQUAL\", \"NOT_EQUAL\", \"LESS_EQUAL\", \"GREATER_EQUAL\", \n            \"LESS\", \"GREATER\", \"PLUS\", \"MINUS\", \"DIV\", \"FULL_DIV\", \"MULT\", \n            \"COMMA\", \"SEMI\", \"LPAREN\", \"RPAREN\", \"LCURLY\", \"RCURLY\", \"L_SQBRACK\", \n            \"P_SQBRACK\", \"PLUS_EQUAL\", \"ASSIGN\", \"MINUS_EQUAL\", \"MULT_EQUAL\", \n            \"DIV_EQUAL\", \"FUNCTION\", \"FOR\", \"RETURN\", \"IF\", \"ELSE\", \"WHILE\", \n            \"UNTIL\", \"COMMENT\", \"PRINT\", \"LENGTH\", \"RESHAPE\", \"DEL_COL\", \n            \"DEL_ROW\", \"DEL\", \"INSERT\", \"MAX\", \"MIN\", \"MAXLEN\", \"MINLEN\", \n            \"FIND\", \"CREATE_ROW\", \"CREATE_TABLE\", \"CREATE_COL\", \"READ_STRING\", \n            \"COPY\", \"NUMBER_type\", \"STRING_type\", \"TABLE\", \"COLUMN\", \"ROW\", \n            \"VOID\", \"NUMBER\", \"STRING\", \"ID\", \"WS\", \"CONST_NUMBER\", \"CONST_STRING\" ]\n\n    ruleNames = [ \"AND\", \"OR\", \"NOT\", \"EQUAL\", \"NOT_EQUAL\", \"LESS_EQUAL\", \n                  \"GREATER_EQUAL\", \"LESS\", \"GREATER\", \"PLUS\", \"MINUS\", \"DIV\", \n                  \"FULL_DIV\", \"MULT\", \"COMMA\", \"SEMI\", \"LPAREN\", \"RPAREN\", \n                  \"LCURLY\", \"RCURLY\", \"L_SQBRACK\", \"P_SQBRACK\", \"PLUS_EQUAL\", \n                  \"ASSIGN\", \"MINUS_EQUAL\", \"MULT_EQUAL\", \"DIV_EQUAL\", \"FUNCTION\", \n                  \"FOR\", \"RETURN\", \"IF\", \"ELSE\", \"WHILE\", \"UNTIL\", \"COMMENT\", \n                  \"PRINT\", \"LENGTH\", \"RESHAPE\", \"DEL_COL\", \"DEL_ROW\", \"DEL\", \n                  \"INSERT\", \"MAX\", \"MIN\", \"MAXLEN\", \"MINLEN\", \"FIND\", \"CREATE_ROW\", \n                  \"CREATE_TABLE\", \"CREATE_COL\", \"READ_STRING\", \"COPY\", \"NUMBER_type\", \n                  \"STRING_type\", \"TABLE\", \"COLUMN\", \"ROW\", \"VOID\", \"NUMBER\", \n                  \"STRING\", \"ID\", \"WS\", \"CONST_NUMBER\", \"CONST_STRING\" ]\n\n    grammarFileName = \"LangLexer.g4\"\n\n    def __init__(self, input=None, output:TextIO = sys.stdout):\n        super().__init__(input, output)\n        self.checkVersion(\"4.7.2\")\n        self._interp = LexerATNSimulator(self, self.atn, self.decisionsToDFA, PredictionContextCache())\n        self._actions = None\n        self._predicates = None", "\n\n"]}
{"filename": "parser/LangParserListener.py", "chunked_list": ["# Generated from LangParser.g4 by ANTLR 4.7.2\nfrom antlr4 import *\nif __name__ is not None and \".\" in __name__:\n    from .LangParser import LangParser\nelse:\n    from LangParser import LangParser\nfrom src.compilers import ProgramCompiler\nfrom src.variables import *\n\n\nclass SemanticAnalyzerException(Exception):\n    def __init__(self, *args: object) -> None:\n        super().__init__(*args)", "\n\nclass SemanticAnalyzerException(Exception):\n    def __init__(self, *args: object) -> None:\n        super().__init__(*args)\n\n\ndef get_dict(params: list, out_type: str, func_local_vars: list = None):\n    if func_local_vars is None:\n        return {\"params\": params, \"return_type\": out_type}\n    return {\"params\": params, \"return_type\": out_type, \"local_vars\": func_local_vars}", "\n# This class defines a complete listener for a parse tree produced by LangParser.\n\n\nclass LangParserListener(ParseTreeListener):\n\n    global_vars = {}\n    function_vars = {\n        # built-in functions\n        # output is a number == it depends on {number} param\n        \"print\": get_dict([\"table/row/column/string/numb\"], \"void\"),\n        \"length\": get_dict([\"table/row/column\"], \"numb\"),\n        \"reshape\": get_dict([\"table\", \"numb\", \"numb\"], \"table\"),\n        \"del\": get_dict([\"row/column\", \"numb\"], \"0\"),\n        \"insert\": get_dict([\"column/row\", \"string/numb\", \"numb\"], \"0\"),\n        \"max\": get_dict([\"table/row/column\"], \"numb\"),\n        \"min\": get_dict([\"table/row/column\"], \"numb\"),\n        \"maxlen\": get_dict([\"table/row/column\"], \"string\"),\n        \"minlen\": get_dict([\"table/row/column\"], \"string\"),\n        \"find\": get_dict([\"table/row/column\", \"string/numb\"], \"numb\"),\n        \"create_row\": get_dict([\"numb\", \"list\"], \"row\"),\n        \"create_column\": get_dict([\"numb\", \"list\"], \"column\"),\n        \"create_table\": get_dict([\"numb\", \"numb\", \"list\"], \"table\"),\n        \"read_string\": get_dict([], \"string\"),\n        \"copy\": get_dict([\"table/row/column/string/numb\"], \"0\")\n    }\n\n    available_operands = {\n        # bool operators\n        \"==\": (\"numb\", \"string\", \"column\", \"row\", \"table\"),\n        \"!=\": (\"numb\", \"string\", \"column\", \"row\", \"table\"),\n        \"<=\": (\"numb\", \"string\", \"column\", \"row\"),\n        \">=\": (\"numb\", \"string\", \"column\", \"row\"),\n        \"<\": (\"numb\", \"string\", \"column\", \"row\"),\n        \">\": (\"numb\", \"string\", \"column\", \"row\"),\n        \"&\": (\"numb\"),\n        \"|\": (\"numb\"),\n        \"!\": (\"numb\"),\n        # number operators\n        \"+\": (\"numb\", \"string\", \"column\", \"row\", \"table\"),\n        \"-\": (\"numb\"),\n        \"/\": (\"numb\", \"column\", \"row\", \"table\"),\n        \"//\": (\"numb\", \"table\"),\n        \"*\": (\"numb\", \"table\")\n    }\n\n    # Enter a parse tree produced by LangParser#program.\n    def enterProgram(self, ctx: LangParser.ProgramContext):\n        # function vars\n        self.is_func_init = False\n        self.main_func_started = False\n        self.local_func_vars = {}\n        self.local_func_params = {}\n        self.local_func_name = None\n        # for vars\n        self.all_for_vars = {}\n        self.for_stat_init = False\n        # while vars\n        self.local_while_vars = {}\n        # until vars\n        self.local_until_vars = {}\n        # if else vars\n        self.local_ifels_vars = {}\n\n        # init program compiler\n        self.program_compiler = ProgramCompiler()\n\n    # Exit a parse tree produced by LangParser#program.\n    def exitProgram(self, ctx: LangParser.ProgramContext):\n        # print(self.function_vars)\n        # print(self.global_vars)\n        self.program_compiler.finish_compiling()\n\n    # Enter a parse tree produced by LangParser#func.\n    def enterFunc(self, ctx: LangParser.FuncContext):\n        self.is_func_return_smth = False\n\n    def clear_func_cache(self):\n        if self.is_func_init:\n            self.function_vars.pop(self.local_func_name)\n        for key in self.local_func_vars:\n            self.global_vars.pop(key)\n\n    # Exit a parse tree produced by LangParser#func.\n    def exitFunc(self, ctx: LangParser.FuncContext):\n        if not self.is_func_init:\n            self.checkAndInitUserFunc(ctx)\n        if not self.is_func_return_smth and self.local_func_params.get('return_type') != 'void':\n            raise SemanticAnalyzerException(\n                f\"Function doesn't return {self.local_func_params.get('return_type')} value.\")\n        if self.is_func_return_smth and self.local_func_params.get('return_type') == 'void':\n            raise SemanticAnalyzerException(f\"Void function returns value\")\n        for func_param in self.local_func_vars:\n            self.global_vars.pop(func_param)\n        self.is_func_init = False\n        if self.program_compiler.local_function is not None:\n            self.program_compiler.end_local_func()\n\n    def checkAndInitUserFunc(self, ctx: LangParser.FuncContext):\n        func_type = str(ctx.children[0].children[0]) if str(\n            ctx.children[0]) != 'void' else 'void'\n        func_name = str(ctx.ID(0))\n        self.local_func_name = func_name\n\n        func_params = list(map(str, ctx.ID()[1:]))\n        func_params_types = list(map(lambda ctx: str(\n            ctx.children[0]), ctx.basicTypeName()[int(func_type != 'void'):]))\n        self.program_compiler.start_local_func(\n            func_name, func_type, func_params_types)\n\n        if self.function_vars.get(func_name) is not None and self.function_vars.get(func_name).get(\"params\") == func_params_types and\\\n                func_type == self.function_vars.get(func_name).get(\"return_type\"):\n            raise SemanticAnalyzerException(\n                f\"Function {func_name} with such params is already defined\")\n\n        if len(func_params) != len(func_params_types):\n            raise SemanticAnalyzerException(\n                \"Check params number and number of their types\")\n\n        for func_index, func_param in enumerate(func_params):\n            if self.local_func_vars.get(func_param) is not None:\n                raise SemanticAnalyzerException(\n                    f\"Function parameter {func_param} is already defined\")\n            self.local_func_vars[func_param] = func_params_types[func_index]\n            self.addNewVariable(\n                func_param, func_params_types[func_index], self.program_compiler.local_func_args[func_index])\n\n        self.function_vars[func_name] = self.local_func_params = get_dict(\n            func_params_types, func_type, func_params)\n        self.is_func_init = True\n\n    # Enter a parse tree produced by LangParser#stat.\n    def enterStat(self, ctx: LangParser.StatContext):\n        if self.program_compiler.local_function is None and not self.program_compiler.is_main_function_started():\n            self.program_compiler.start_main_func()\n        self.main_func_started = True\n\n    # Exit a parse tree produced by LangParser#stat.\n    def exitStat(self, ctx: LangParser.StatContext):\n        pass\n\n    # Enter a parse tree produced by LangParser#funcStat.\n    def enterFuncStat(self, ctx: LangParser.FuncStatContext):\n        if isinstance(ctx.parentCtx, LangParser.ForStatContext):\n            self.initUserForLocSpace(ctx.parentCtx)\n        if not self.is_func_init and isinstance(ctx.parentCtx, LangParser.FuncContext):\n            self.checkAndInitUserFunc(ctx.parentCtx)\n\n    def initUserForLocSpace(self, ctx: LangParser.ForStatContext):\n        if ctx.assignExpr() and ctx.assignExpr().basicTypeName():\n            ass_ctxt = ctx.assignExpr()\n            type_ = str(ass_ctxt.basicTypeName().children[0])\n            vars_ = list(map(str, ass_ctxt.ID()))\n\n            for_vars = self.all_for_vars.get(\"for_local\")\n            if for_vars:\n                while for_vars.get(\"for_local\"):\n                    for_vars = for_vars.get(\"for_local\")\n            else:\n                for_vars = self.all_for_vars\n            for var in vars_:\n                for_vars[var] = [type_, False]\n\n    # Exit a parse tree produced by LangParser#funcStat.\n    def exitFuncStat(self, ctx: LangParser.FuncStatContext):\n        if ctx.returnStmt() and not self.is_func_init:\n            raise SemanticAnalyzerException(\n                \"Cannot return value outside function space\")\n        elif ctx.returnStmt():\n            self.is_func_return_smth = True\n            return_type = self.findExpressionOutType(\n                ctx.returnStmt().numbExpr())\n            if return_type != self.local_func_params.get('return_type'):\n                raise SemanticAnalyzerException(\n                    f\"{self.local_func_params.get('return_type')} function returns {return_type} object\")\n            self.program_compiler.end_local_func(\n                self.findNumbExprResult(ctx.returnStmt().numbExpr()))\n        elif ctx.stat() and ((ctx.stat().assignExpr() and ctx.stat().assignExpr().basicTypeName()) or ctx.stat().varDeclStmt() is not None):\n            ass_ctxt = ctx.stat().assignExpr() if ctx.stat(\n            ).assignExpr() else ctx.stat().varDeclStmt()\n            if ass_ctxt.basicTypeName() is None:\n                return\n            _type = str(ass_ctxt.basicTypeName().children[0])\n            if isinstance(ctx.parentCtx, LangParser.FuncContext):\n                for id in ass_ctxt.ID():\n                    self.local_func_vars[str(id)] = (_type, False)\n            elif isinstance(ctx.parentCtx, LangParser.ForStatContext):\n                for_vars = self.all_for_vars.get(\"for_local\")\n                if for_vars:\n                    while for_vars:\n                        for_vars = for_vars.get(\"for_local\")\n                else:\n                    for_vars = self.all_for_vars\n                for id in ass_ctxt.ID():\n                    for_vars[str(id)] = (_type, False)\n            elif isinstance(ctx.parentCtx, LangParser.UntilStmtContext):\n                until_vars = self.local_until_vars.get(\"until_local\")\n                while until_vars:\n                    until_vars = until_vars.get(\"until_local\")\n                for id in ass_ctxt.ID():\n                    until_vars[str(id)] = (_type, False)\n            elif isinstance(ctx.parentCtx, LangParser.WhileStmtContext):\n                while_vars = self.local_while_vars.get(\"while_local\")\n                while while_vars:\n                    while_vars = while_vars.get(\"while_local\")\n                for id in ass_ctxt.ID():\n                    while_vars[str(id)] = (_type, False)\n            elif isinstance(ctx.parentCtx, LangParser.IfElseStmtContext):\n                ifels_vars = self.local_ifels_vars.get(\"ifels_local\")\n                while ifels_vars:\n                    ifels_vars = ifels_vars.get(\"ifels_local\")\n                for id in ass_ctxt.ID():\n                    ifels_vars[str(id)] = (_type, False)\n\n    # Enter a parse tree produced by LangParser#forStat.\n    def enterForStat(self, ctx: LangParser.ForStatContext):\n        if isinstance(ctx.parentCtx.parentCtx, LangParser.FuncStatContext):\n            self.all_for_vars = {}\n        elif isinstance(ctx.parentCtx.parentCtx, LangParser.ProgramContext):\n            self.all_for_vars[\"for_local\"] = {}\n\n    # Exit a parse tree produced by LangParser#forStat.\n    def exitForStat(self, ctx: LangParser.ForStatContext):\n        for_vars_space = self.all_for_vars.get(\"for_local\")\n        if for_vars_space:\n            while for_vars_space.get(\"for_local\"):\n                for_vars_space = for_vars_space.get(\"for_local\")\n        else:\n            for_vars_space = self.all_for_vars\n        for local_var in for_vars_space:\n            self.global_vars.pop(local_var)\n\n        # delete\n        if not self.all_for_vars.get(\"for_local\"):\n            self.all_for_vars = {}\n        else:\n            tmp = self.all_for_vars\n            while tmp.get(\"for_local\").get(\"for_local\"):\n                tmp = tmp.get(\"for_local\")\n            tmp.pop(\"for_local\")\n\n    # Enter a parse tree produced by LangParser#assignExpr.\n    def enterAssignExpr(self, ctx: LangParser.AssignExprContext):\n        pass\n\n    def findVarType(self, ctx: LangParser.BasicTypeContext | LangParser.IterBasicTypeContext | str) -> str:\n        if isinstance(ctx, str) or ctx.ID():\n            str_id = str(ctx.ID()) if not isinstance(ctx, str) else ctx\n            if self.global_vars.get(str_id) is None:\n                raise SemanticAnalyzerException(\"Variable {} is not defined\".format(str_id))\n            var_obj = self.global_vars.get(str_id)\n            if isinstance(var_obj, NumbVariable):\n                var_type = 'numb'\n            elif isinstance(var_obj, StringVariable):\n                var_type = 'string'\n            elif isinstance(var_obj, ColumnVariable):\n                var_type = 'column'\n            elif isinstance(var_obj, RowVariable):\n                var_type = 'row'\n            elif isinstance(var_obj, TableVariable):\n                var_type = 'table'\n            else:\n                raise TypeError(\"Bro here is unknown object -- {} | {}\".format(type(var_obj), str_id))\n            return var_type, False\n        elif isinstance(ctx, LangParser.BasicTypeContext) and ctx.NUMBER():\n            return 'numb', False\n        elif isinstance(ctx, LangParser.BasicTypeContext) and ctx.STRING():\n            return 'string', False\n        else:\n            raise SemanticAnalyzerException(\n                \"Incorrect expression construction - {}\".format(str(ctx.children[0])))\n\n    def findBuiltinFunctionType(self, ctx: LangParser.BuiltinFuncStmtContext) -> tuple[str, str]:\n        function_ctxt = ctx.children[0]\n        func_return_type, func_name = None, None\n        func_name = str(function_ctxt.children[0])\n        if isinstance(function_ctxt, LangParser.CustFuncCallContext):\n            find_name = self.function_vars.get(func_name)\n            if find_name is None:\n                raise SemanticAnalyzerException(\n                    f\"Function {func_name} is not found\")\n            func_return_type = find_name.get(\"return_type\")\n        elif isinstance(function_ctxt, LangParser.InsertStmtContext):\n            first_param = function_ctxt.numbExpr(0)\n            func_return_type = self.findExpressionOutType(first_param)\n        elif isinstance(function_ctxt, LangParser.CopyStmtContext):\n            func_return_type = self.findVarType(str(function_ctxt.ID()))[0]\n        elif (isinstance(function_ctxt, LangParser.DelFuncStmtContext) and function_ctxt.delFunc().DEL() is not None):\n            first_param = function_ctxt.numbExpr(0)\n            func_return_type = self.findExpressionOutType(first_param)\n        elif isinstance(function_ctxt, LangParser.MinMaxFuncStmtContext):\n            func_name = str(function_ctxt.minMaxFunc().children[0])\n            func_return_type = self.function_vars.get(\n                func_name).get(\"return_type\")\n        elif isinstance(function_ctxt, LangParser.DelFuncStmtContext):\n            func_name = str(function_ctxt.delFunc().children[0])\n            func_return_type = self.function_vars.get(\n                func_name).get(\"return_type\")\n        else:\n            func_return_type = self.function_vars.get(\n                func_name).get(\"return_type\")\n        if isinstance(function_ctxt, LangParser.DelFuncStmtContext):\n            func_name = str(function_ctxt.delFunc().children[0])\n\n        return func_return_type, func_name\n\n    def findIndexStmtType(self, ctx: LangParser.IndexStmtContext) -> str:\n        if not isinstance(ctx, LangParser.IndexStmtContext):\n            raise TypeError(f\"Incorrect context type {type(ctx)}\")\n        if ctx.iterBasicType():\n            iter_var = ctx.iterBasicType()\n            if iter_var.ID():\n                var_type, _ = self.findVarType(iter_var)\n                if var_type not in ('column', 'row', 'table'):\n                    raise SemanticAnalyzerException(\n                        f\"{var_type} object is not subscriptable\")\n                return var_type\n        elif ctx.builtinFuncStmt():\n            var_type = self.findBuiltinFunctionType(ctx.builtinFuncStmt())[0]\n            if var_type not in ('column', 'row', 'table'):\n                raise SemanticAnalyzerException(\n                    f\"Function {str(ctx.builtinFuncStmt().ID(0))} returns not iterable object\")\n            return var_type\n\n    def findExprTypeWithTwoOperands(self, first_operand_ctxt: LangParser.NumbExprContext,\n                                    sign_ctxt: LangParser.BoolNumbSignContext,\n                                    second_operand_ctxt: LangParser.NumbExprContext\n                                    ) -> str:\n        first_operand_type = self.findExpressionOutType(first_operand_ctxt)\n        second_operand_type = self.findExpressionOutType(second_operand_ctxt)\n        sign = str(sign_ctxt.boolSign().children[0]) if sign_ctxt.boolSign() else str(\n            sign_ctxt.numbSign().children[0])\n        if first_operand_type not in self.available_operands.get(sign) or\\\n                second_operand_type not in self.available_operands.get(sign):\n            raise SemanticAnalyzerException(\n                f\"Incorrect operands types ({first_operand_type},{second_operand_type}) for {sign} sign\")\n        if first_operand_type == second_operand_type:\n            if sign_ctxt.boolSign():\n                return 'numb'\n            elif sign_ctxt.numbSign():\n                if sign in [\"/\", \"//\"] and first_operand_type != 'numb':\n                    raise SemanticAnalyzerException(\n                        f\"Incorrect operands types ({first_operand_type},{second_operand_type}) for {sign} sign\")\n                return first_operand_type\n        else:\n            if sign in [\"==\", \"!=\", \"<=\", \">=\", \">\", \"<\", \"!\", \"&\", \"|\", \"-\", \"*\"]:\n                raise SemanticAnalyzerException(\n                    f\"Operands types for {sign} sign should be equal\")\n            elif sign == '+':\n                types_set = set((first_operand_type, second_operand_type))\n                if not (types_set == {'row', 'table'} or types_set == {'column', 'table'}):\n                    raise SemanticAnalyzerException(\n                        f\"Incorrect operands types ({first_operand_type},{second_operand_type}) for {sign} sign\")\n                return 'table'\n            elif sign == '/':\n                if not (second_operand_type == 'numb' and first_operand_type in ['column', 'row', 'table']):\n                    raise SemanticAnalyzerException(\n                        f\"Incorrect operands types ({first_operand_type},{second_operand_type}) for {sign} sign\")\n                return first_operand_type\n            elif sign == '//':\n                if not (first_operand_type == 'table' and second_operand_type == 'numb'):\n                    raise SemanticAnalyzerException(\n                        f\"Operator // can be used for table and number types\")\n                return 'table'\n\n    def findExpressionOutType(self, expr_context: LangParser.NumbExprContext) -> str:\n        if expr_context.returnType():\n            if expr_context.returnType().basicType():\n                var_type, _ = self.findVarType(\n                    expr_context.returnType().basicType())\n                return var_type\n            elif expr_context.returnType().builtinFuncStmt():\n                func_type, func_name = self.findBuiltinFunctionType(\n                    expr_context.returnType().builtinFuncStmt())\n                return func_type\n            elif expr_context.returnType().indexStmt():\n                index_stmt_type = self.findIndexStmtType(\n                    expr_context.returnType().indexStmt())\n                return index_stmt_type\n        elif expr_context.boolNumbSign():\n            return self.findExprTypeWithTwoOperands(\n                expr_context.numbExpr(0),\n                expr_context.boolNumbSign(),\n                expr_context.numbExpr(1)\n            )\n\n    # Exit a parse tree produced by LangParser#assignExpr.\n    def exitAssignExpr(self, ctx: LangParser.AssignExprContext):\n        if ctx.ID() and ctx.indexStmt():\n            raise SemanticAnalyzerException(\n                \"Cannot initialize variables and index statements in one assign expression\")\n        if ctx.indexStmt():\n            if ctx.basicTypeName():\n                raise SemanticAnalyzerException(\n                    f\"Cannot initialize index stmt with specified type - {str(ctx.basicTypeName().children[0])}\")\n            for idx_stmt in ctx.indexStmt():\n                if idx_stmt.builtinFuncStmt():\n                    raise SemanticAnalyzerException(f\"Function {str(idx_stmt.builtinFuncStmt().children[0].children[0])} only returns values\")\n                self.findIndexStmtType(idx_stmt)\n\n        elif ctx.ID():\n            if ctx.basicTypeName():\n                var_type = str(ctx.basicTypeName().children[0])\n            else:\n                var_type, is_const = self.findVarType(str(ctx.ID(0)))\n                if is_const:\n                    raise SemanticAnalyzerException(\n                        f\"Variable {str(ctx.ID())} is constant\")\n            var_names = []\n            for var_name in ctx.ID():\n                var_names.append(str(var_name))\n            if len(var_names) != len(set(var_names)):\n                raise SemanticAnalyzerException(f\"Attempt to define variables with similar name\")\n            assign_exprs_n = 0\n            for numb_expr in ctx.numbExpr():\n                if numb_expr.returnType() is not None:\n                    return_type = numb_expr.returnType()\n                    if return_type.basicType():\n                        bas_type_ctx = return_type.basicType()\n                        assign_var_type, _ = self.findVarType(bas_type_ctx)\n                        if var_type != assign_var_type:\n                            raise SemanticAnalyzerException(\n                                f\"Variable {str(bas_type_ctx.children[0])} type ({assign_var_type}) is incompatible with '{var_type}' type\")\n                        assign_exprs_n += 1\n                    elif return_type.builtinFuncStmt():\n                        func_type, func_name = self.findBuiltinFunctionType(\n                            return_type.builtinFuncStmt())\n                        if func_type == 'void':\n                            raise SemanticAnalyzerException(\n                                f\"Function {func_name} returns nothing\")\n                        if var_type != func_type:\n                            raise SemanticAnalyzerException(\n                                f\"Function '{func_name}' return type ({func_type}) is incompatible with '{var_type}' type\")\n                        assign_exprs_n += 1\n                    elif return_type.indexStmt():\n                        iter_obj_ctxt = return_type.indexStmt().children[0]\n                        if isinstance(iter_obj_ctxt, LangParser.BuiltinFuncStmtContext):\n                            func_type, func_name = self.findBuiltinFunctionType(\n                                iter_obj_ctxt)\n                            if var_type != func_type:\n                                raise SemanticAnalyzerException(\n                                    f\"Function '{func_name}' return type ({func_type}) is incompatible with '{var_type}' type\")\n                            assign_exprs_n += 1\n                        if isinstance(iter_obj_ctxt, LangParser.IterBasicTypeContext):\n                            obj_type = str(iter_obj_ctxt.children[0])\n                            if iter_obj_ctxt.ID():\n                                obj_type, _ = self.findVarType(\n                                    str(iter_obj_ctxt.ID()))\n                            else:\n                                raise SemanticAnalyzerException(\n                                    f\"Incorrect subscritable variable\")\n                            if var_type != obj_type:\n                                # raise SemanticAnalyzerException(f\"Iterable object output doesn't match to variable type\")\n                                pass\n                            assign_exprs_n += 1\n                elif numb_expr.boolNumbSign() is not None:\n                    sign_ctxt = numb_expr.boolNumbSign()\n                    return_type = self.findExprTypeWithTwoOperands(numb_expr.numbExpr(0),\n                                                                   sign_ctxt,\n                                                                   numb_expr.numbExpr(\n                                                                       1)\n                                                                   )\n                    if var_type != return_type:\n                        raise SemanticAnalyzerException(\"Expression returned type is {} instead of {} type\".format(\n                            return_type, var_type\n                        ))\n                    assign_exprs_n += 1\n\n            if len(var_names) != assign_exprs_n:\n                raise SemanticAnalyzerException(\n                    \"Variables number doesn't match to expressions number\")\n            assign_results = []\n            for numbExprCtxt in ctx.numbExpr():\n                assign_results.append(self.findNumbExprResult(numbExprCtxt))\n            if ctx.basicTypeName():\n                for idx, var_name in enumerate(var_names):\n                    self.addNewVariable(var_name, var_type,\n                                        assign_results[idx])\n            else:\n                if ctx.ID(0):\n                    for idx, var_name in enumerate(var_names):\n                        self.changeVarValue(var_name, str(ctx.assignSign().children[0]), assign_results[idx])\n\n    def changeVarValue(self, str_name: str, ass_sign: str, value: Variable):\n        self.program_compiler.assign_value(\n            self.global_vars.get(str_name),\n            ass_sign,\n            value\n        )\n\n    def addNewVariable(self, str_name: str, var_type: str, value):\n        if self.function_vars.get(str_name):\n            raise SemanticAnalyzerException(\n                f\"Function with name '{str_name}' is already defined\")\n        if self.global_vars.get(str_name):\n            raise SemanticAnalyzerException(\n                f\"Variable with name '{str_name}' is already defined\")\n        if var_type == 'numb':\n            if isinstance(value, NumbVariable):\n                self.global_vars[str_name] = value\n            else:\n                self.global_vars[str_name] = NumbVariable(value, self.program_compiler._builder)\n        elif var_type == 'string':\n            if not isinstance(value, StringVariable):\n                self.global_vars[str_name] = StringVariable(value, self.program_compiler._builder)\n            else:\n                self.global_vars[str_name] = value\n        elif var_type in ['row', 'column', 'table']:\n            self.global_vars[str_name] = value\n\n    def findNumbExprResult(self, ctx: LangParser.NumbExprContext):\n        if ctx.returnType():\n            expr: LangParser.ReturnTypeContext = ctx.returnType()\n            if expr.basicType():\n                if expr.basicType().ID():\n                    return self.global_vars.get(str(expr.basicType().ID()))\n                elif expr.basicType().NUMBER():\n                    value = float(str(expr.basicType().NUMBER()))\n                    return NumbVariable(value, self.program_compiler._builder)\n                elif expr.basicType().STRING():\n                    value = StringVariable(str(expr.basicType().STRING()), self.program_compiler._builder)\n                    return value\n            elif expr.builtinFuncStmt():\n                func_expr: LangParser.BuiltinFuncStmtContext = expr.builtinFuncStmt()\n                if func_expr.createColStmt() or func_expr.createRowStmt():\n                    elements = self.pad_values_in_create_stmt(\n                        func_expr.createColStmt() if func_expr.createColStmt() else func_expr.createRowStmt()\n                    )\n                    var = self.program_compiler.create_row(elements) if func_expr.createRowStmt() \\\n                        else self.program_compiler.create_column(elements)\n                    return var\n                elif func_expr.readStrStmt():\n                    return self.program_compiler.call_function(\"read_string\")\n                elif func_expr.delFuncStmt():\n                    return self.program_compiler.call_function(\n                        \"del\", \n                        [\n                            self.findNumbExprResult(func_expr.delFuncStmt().numbExpr(0)),\n                            self.findNumbExprResult(func_expr.delFuncStmt().numbExpr(1))\n                        ]\n                    )\n                elif func_expr.createTablStmt():\n                    func_ctxt: LangParser.CreateTablStmtContext = func_expr.createTablStmt()\n                    if len(func_ctxt.NUMBER()) > 2:\n                        raise SemanticAnalyzerException(\n                            \"Table can be only 2-dimensional\")\n                    if len(func_ctxt.NUMBER()) < 2:\n                        raise SemanticAnalyzerException(\"n_rows param and n_cols param are required\")\n                    n_cols = int(float(str(func_ctxt.NUMBER(1))))\n                    n_rows = int(float(str(func_ctxt.NUMBER(0))))\n                    if func_ctxt.listStmt():\n                        elements = self.pad_values_in_create_stmt(func_ctxt)\n                    else:\n                        elements = []\n                    if n_cols < 0 or n_rows < 0 or n_rows * n_cols < len(elements):\n                        raise SemanticAnalyzerException(\n                            \"Invalid n_rows and n_cols combination\")\n                    return self.program_compiler.create_table(elements, n_cols, n_rows)\n                elif func_expr.reshapeStmt():\n                    return self.findreshapeStmtCtxtRes(func_expr.reshapeStmt())\n                elif func_expr.lengthStmt():\n                    return self.findLengthStmtCtxtResult(func_expr.lengthStmt())\n                elif func_expr.custFuncCall():\n                    args = [self.findNumbExprResult(\n                        ex) for ex in func_expr.custFuncCall().numbExpr()]\n                    name = str(func_expr.custFuncCall().ID())\n                    return self.program_compiler.call_custom_func(name, args)\n                elif func_expr.copyStmt():\n                    copy_stmt : LangParser.CopyStmtContext = func_expr.copyStmt()\n                    return self.program_compiler.call_function(\"copy\", [self.global_vars[str(copy_stmt.ID())]])\n            elif expr.indexStmt():\n                pass\n        elif ctx.boolNumbSign():\n            result = self.findExprResultWithTwoOperands(\n                ctx.numbExpr(0),\n                self.findExpressionOutType(ctx.numbExpr(0)),\n                ctx.boolNumbSign(),\n                ctx.numbExpr(1),\n                self.findExpressionOutType(ctx.numbExpr(1))\n            )\n            return result\n\n    def findLengthStmtCtxtResult(self, ctx: LangParser.LengthStmtContext):\n        var = self.findNumbExprResult(ctx.numbExpr())\n        return self.program_compiler.call_function(\"length\", [var])\n\n    def findreshapeStmtCtxtRes(self, ctx: LangParser.ReshapeStmtContext):\n        arg1 = self.findNumbExprResult(ctx.numbExpr(0))\n        arg2 = self.findNumbExprResult(ctx.numbExpr(1))\n        arg3 = self.findNumbExprResult(ctx.numbExpr(2))\n        return self.program_compiler.call_reshape_func(arg1, int(arg2), int(arg3))\n\n    def findExprResultWithTwoOperands(self, nexprctx1: LangParser.NumbExprContext,\n                                      type1: str,\n                                      signctxt: LangParser.BoolNumbSignContext,\n                                      nexprctx2: LangParser.NumbExprContext,\n                                      type2: str):\n        res1 = self.findNumbExprResult(nexprctx1)\n        res2 = self.findNumbExprResult(nexprctx2)\n        sign = str(signctxt.boolSign().children[0]) if signctxt.boolSign() else str(\n            signctxt.numbSign().children[0])\n        if type1 == type2:\n            return self.program_compiler.find_expression_result(res1, sign, res2)\n    # Enter a parse tree produced by LangParser#va  rDeclStmt.\n\n    def enterVarDeclStmt(self, ctx: LangParser.VarDeclStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#varDeclStmt.\n    def exitVarDeclStmt(self, ctx: LangParser.VarDeclStmtContext):\n        var_type = str(ctx.basicTypeName().children[0])\n        var_names = list(map(str, ctx.ID()))\n        if len(var_names) != len(set(var_names)):\n            raise SemanticAnalyzerException(\n                f\"Attempt to define variables with similar name\")\n        for var_ctxt in ctx.ID():\n            self.addNewVariable(str(var_ctxt), var_type)\n\n    # Enter a parse tree produced by LangParser#incStat.\n    def enterIncDecrStat(self, ctx: LangParser.IncDecrStatContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#incDecrStat.\n    def exitIncDecrStat(self, ctx: LangParser.IncDecrStatContext):\n        var_type, is_const = self.findVarType(str(ctx.ID()))\n        if var_type != 'numb':\n            raise SemanticAnalyzerException(\n                \"Increment and decrement are used for number variables\")\n        if is_const:\n            raise SemanticAnalyzerException(\n                f\"Variable {str(ctx.ID())} is constant\")\n        var_name = str(ctx.ID())\n        var = self.global_vars.get(var_name)\n        if ctx.PLUS():\n            self.program_compiler.incr_var(var)\n        else:\n            self.global_vars[var_name] = self.program_compiler.decr_var(var)\n\n    # Enter a parse tree produced by LangParser#assignSign.\n    def enterAssignSign(self, ctx: LangParser.AssignSignContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#assignSign.\n    def exitAssignSign(self, ctx: LangParser.AssignSignContext):\n        pass\n\n    # Enter a parse tree produced by LangParser#basicTypeName.\n    def enterBasicTypeName(self, ctx: LangParser.BasicTypeNameContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#basicTypeName.\n    def exitBasicTypeName(self, ctx: LangParser.BasicTypeNameContext):\n        pass\n\n    # Enter a parse tree produced by LangParser#boolSign.\n    def enterBoolSign(self, ctx: LangParser.BoolSignContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#boolSign.\n    def exitBoolSign(self, ctx: LangParser.BoolSignContext):\n        pass\n\n    # Enter a parse tree produced by LangParser#numbSign.\n    def enterNumbSign(self, ctx: LangParser.NumbSignContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#numbSign.\n    def exitNumbSign(self, ctx: LangParser.NumbSignContext):\n        pass\n\n    # Enter a parse tree produced by LangParser#boolNumbSign.\n    def enterBoolNumbSign(self, ctx: LangParser.BoolNumbSignContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#boolNumbSign.\n    def exitBoolNumbSign(self, ctx: LangParser.BoolNumbSignContext):\n        pass\n\n    # Enter a parse tree produced by LangParser#iterBasicType.\n    def enterIterBasicType(self, ctx: LangParser.IterBasicTypeContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#iterBasicType.\n    def exitIterBasicType(self, ctx: LangParser.IterBasicTypeContext):\n        pass\n\n    # Enter a parse tree produced by LangParser#basicType.\n    def enterBasicType(self, ctx: LangParser.BasicTypeContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#basicType.\n    def exitBasicType(self, ctx: LangParser.BasicTypeContext):\n        pass\n\n    # Enter a parse tree produced by LangParser#returnType.\n    def enterReturnType(self, ctx: LangParser.ReturnTypeContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#returnType.\n    def exitReturnType(self, ctx: LangParser.ReturnTypeContext):\n        pass\n\n    # Enter a parse tree produced by LangParser#numbExpr.\n    def enterNumbExpr(self, ctx: LangParser.NumbExprContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#numbExpr.\n    def exitNumbExpr(self, ctx: LangParser.NumbExprContext):\n        self.findExpressionOutType(ctx)\n\n    # Enter a parse tree produced by LangParser#boolExpr.\n    def enterBoolExpr(self, ctx: LangParser.BoolExprContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#boolExpr.\n    def exitBoolExpr(self, ctx: LangParser.BoolExprContext):\n        first_operand_type = self.findExpressionOutType(ctx.numbExpr(0))\n        second_operand_type = self.findExpressionOutType(ctx.numbExpr(1))\n        if first_operand_type != second_operand_type:\n            raise SemanticAnalyzerException(\n                \"Bool operations can perform only with equal types\")\n\n    # Enter a parse tree produced by LangParser#ifElseStmt.\n    def enterIfElseStmt(self, ctx: LangParser.IfElseStmtContext):\n        if isinstance(ctx.parentCtx.parentCtx, LangParser.FuncStatContext):\n            self.local_ifels_vars[\"ifels_local\"] = {}\n        elif isinstance(ctx.parentCtx.parentCtx, LangParser.ProgramContext):\n            self.local_ifels_vars = {}\n\n    # Exit a parse tree produced by LangParser#ifElseStmt.\n    def exitIfElseStmt(self, ctx: LangParser.IfElseStmtContext):\n        ifels_local_space = self.local_ifels_vars.get(\"ifels_local\")\n        if ifels_local_space:\n            while ifels_local_space.get(\"ifels_local\"):\n                ifels_local_space = ifels_local_space.get(\"ifels_local\")\n        else:\n            ifels_local_space = self.local_ifels_vars\n        for local_var in ifels_local_space:\n            if local_var != 'ifels_local':\n                self.global_vars.pop(local_var)\n\n        if not self.local_ifels_vars.get(\"ifels_local\"):\n            self.local_ifels_vars = {}\n        else:\n            tmp = self.local_ifels_vars\n            while tmp.get(\"ifels_local\").get(\"ifels_local\"):\n                tmp = tmp.get(\"ifels_local\")\n            tmp.pop(\"ifels_local\")\n\n    # Enter a parse tree produced by LangParser#whileStmt.\n    def enterWhileStmt(self, ctx: LangParser.WhileStmtContext):\n        if isinstance(ctx.parentCtx.parentCtx, LangParser.FuncStatContext):\n            self.local_while_vars[\"while_local\"] = {}\n        elif isinstance(ctx.parentCtx.parentCtx, LangParser.ProgramContext):\n            self.local_while_vars = {}\n\n    # Exit a parse tree produced by LangParser#whileStmt.\n    def exitWhileStmt(self, ctx: LangParser.WhileStmtContext):\n        while_local_space = self.local_while_vars.get(\"while_local\")\n        if while_local_space:\n            while while_local_space.get(\"while_local\"):\n                while_local_space = while_local_space.get(\"while_local\")\n        else:\n            while_local_space = self.local_while_vars\n        for local_var in while_local_space:\n            if local_var != 'while_local':\n                self.global_vars.pop(local_var)\n\n        if not self.local_while_vars.get(\"while_local\"):\n            self.local_while_vars = {}\n        else:\n            tmp = self.local_while_vars\n            while tmp.get(\"while_local\").get(\"while_local\"):\n                tmp = tmp.get(\"while_local\")\n            tmp.pop(\"while_local\")\n\n    # Enter a parse tree produced by LangParser#untilStmt.\n    def enterUntilStmt(self, ctx: LangParser.UntilStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#untilStmt.\n    def exitUntilStmt(self, ctx: LangParser.UntilStmtContext):\n        until_local_space = self.local_until_vars.get(\"until_local\")\n        if until_local_space:\n            while until_local_space.get(\"while_local\"):\n                until_local_space = until_local_space.get(\"until_local\")\n        else:\n            until_local_space = self.local_until_vars\n        for local_var in until_local_space:\n            if local_var != 'until_local':\n                self.global_vars.pop(local_var)\n\n        if not self.local_until_vars.get(\"until_local\"):\n            self.local_until_vars = {}\n        else:\n            tmp = self.local_until_vars\n            while tmp.get(\"until_local\").get(\"until_local\"):\n                tmp = tmp.get(\"until_local\")\n            tmp.pop(\"until_local\")\n\n    # Enter a parse tree produced by LangParser#custFuncCall.\n    def enterCustFuncCall(self, ctx: LangParser.CustFuncCallContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#custFuncCall.\n    def exitCustFuncCall(self, ctx: LangParser.CustFuncCallContext):\n        self.checkNumbExprCorrectInFunctionCall(ctx, str(ctx.ID()))\n\n    # Enter a parse tree produced by LangParser#indexStmt.\n    def enterIndexStmt(self, ctx: LangParser.IndexStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#indexStmt.\n    def exitIndexStmt(self, ctx: LangParser.IndexStmtContext):\n        self.findIndexStmtType(ctx)\n\n    # Enter a parse tree produced by LangParser#listStmt.\n    def enterListStmt(self, ctx: LangParser.ListStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#listStmt.\n    def exitListStmt(self, ctx: LangParser.ListStmtContext):\n        if ctx.listStmt(0):\n            raise SemanticAnalyzerException(\"Only 1-dim lists are supported\")\n        if ctx.NUMBER(0) and ctx.STRING(0):\n            pass\n\n    # Enter a parse tree produced by LangParser#builtinFuncStmt.\n    def enterBuiltinFuncStmt(self, ctx: LangParser.BuiltinFuncStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#builtinFuncStmt.\n    def exitBuiltinFuncStmt(self, ctx: LangParser.BuiltinFuncStmtContext):\n        pass\n\n    # Enter a parse tree produced by LangParser#lengthStmt.\n    def enterLengthStmt(self, ctx: LangParser.LengthStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#lengthStmt.\n    def exitLengthStmt(self, ctx: LangParser.LengthStmtContext):\n        self.checkNumbExprCorrectInFunctionCall(ctx, str(ctx.LENGTH()))\n\n    # Enter a parse tree produced by LangParser#returnStmt.\n    def enterReturnStmt(self, ctx: LangParser.ReturnStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#returnStmt.\n    def exitReturnStmt(self, ctx: LangParser.ReturnStmtContext):\n        pass\n\n    def extractListVals(self, ctx: LangParser.ListStmtContext):\n        vals = []\n        for idx, child in enumerate(ctx.children):\n            if idx != 0 and str(child) != ',' and idx != len(ctx.children) - 1:\n                vals.append(str(child))\n        return vals\n\n    # Enter a parse tree produced by LangParser#createRowStmt.\n    def enterCreateRowStmt(self, ctx: LangParser.CreateRowStmtContext):\n        pass\n\n    def pad_values_in_create_stmt(self, ctx: LangParser.CreateColStmtContext | LangParser.CreateRowStmtContext | LangParser.CreateTablStmtContext) -> list:\n        vals = self.extractListVals(ctx.listStmt())\n        if not isinstance(ctx, LangParser.CreateTablStmtContext):\n            n_vals = int(str(ctx.NUMBER())) if ctx.NUMBER() else 0\n        else:\n            n_vals = int(str(ctx.NUMBER(0))) * int(str(ctx.NUMBER(1)))\n        if len(vals) < n_vals:\n            while len(vals) != n_vals:\n                vals.append(\" \")\n        if len(vals) != n_vals:\n            raise SemanticAnalyzerException(\"Input list number mismatch\")\n        return vals\n\n    # Exit a parse tree produced by LangParser#createRowStmt.\n    def exitCreateRowStmt(self, ctx: LangParser.CreateRowStmtContext):\n        pass\n\n    # Enter a parse tree produced by LangParser#createTablStmt.\n    def enterCreateTablStmt(self, ctx: LangParser.CreateTablStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#createTablStmt.\n    def exitCreateTablStmt(self, ctx: LangParser.CreateTablStmtContext):\n        pass\n\n    # Enter a parse tree produced by LangParser#createColStmt.\n    def enterCreateColStmt(self, ctx: LangParser.CreateColStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#createColStmt.\n    def exitCreateColStmt(self, ctx: LangParser.CreateColStmtContext):\n        pass\n\n    # Enter a parse tree produced by LangParser#copyStmt.\n    def enterCopyStmt(self, ctx: LangParser.CopyStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#copyStmt.\n    def exitCopyStmt(self, ctx: LangParser.CopyStmtContext):\n        self.findVarType(str(ctx.ID()))\n\n    # Enter a parse tree produced by LangParser#minMaxFunc.\n    def enterMinMaxFunc(self, ctx: LangParser.MinMaxFuncContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#minMaxFunc.\n    def exitMinMaxFunc(self, ctx: LangParser.MinMaxFuncContext):\n        pass\n\n    # Enter a parse tree produced by LangParser#minMaxFuncStmt.\n    def enterMinMaxFuncStmt(self, ctx: LangParser.MinMaxFuncStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#minMaxFuncStmt.\n    def exitMinMaxFuncStmt(self, ctx: LangParser.MinMaxFuncStmtContext):\n        self.checkNumbExprCorrectInFunctionCall(\n            ctx, str(ctx.minMaxFunc().children[0]))\n\n    # Enter a parse tree produced by LangParser#delFunc.\n    def enterDelFunc(self, ctx: LangParser.DelFuncContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#delFunc.\n    def exitDelFunc(self, ctx: LangParser.DelFuncContext):\n        pass\n\n    # Enter a parse tree produced by LangParser#delFuncStmt.\n    def enterDelFuncStmt(self, ctx: LangParser.DelFuncStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#delFuncStmt.\n    def exitDelFuncStmt(self, ctx: LangParser.DelFuncStmtContext):\n        self.checkNumbExprCorrectInFunctionCall(\n            ctx, str(ctx.delFunc().children[0]))\n\n    # Enter a parse tree produced by LangParser#reshapeStmt.\n    def enterReshapeStmt(self, ctx: LangParser.ReshapeStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#reshapeStmt.\n    def exitReshapeStmt(self, ctx: LangParser.ReshapeStmtContext):\n        self.checkNumbExprCorrectInFunctionCall(ctx, str(ctx.RESHAPE()))\n\n    # Enter a parse tree produced by LangParser#insertStmt.\n    def enterInsertStmt(self, ctx: LangParser.InsertStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#insertStmt.\n    def exitInsertStmt(self, ctx: LangParser.InsertStmtContext):\n        self.checkNumbExprCorrectInFunctionCall(ctx, str(ctx.INSERT()))\n\n    # Enter a parse tree produced by LangParser#findStmt.\n    def enterFindStmt(self, ctx: LangParser.FindStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#findStmt.\n    def exitFindStmt(self, ctx: LangParser.FindStmtContext):\n        self.checkNumbExprCorrectInFunctionCall(ctx, str(ctx.FIND()))\n\n    # Enter a parse tree produced by LangParser#printStmt.\n    def enterPrintStmt(self, ctx: LangParser.PrintStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#printStmt.\n    def exitPrintStmt(self, ctx: LangParser.PrintStmtContext):\n        self.checkNumbExprCorrectInFunctionCall(ctx, str(ctx.PRINT()))\n        self.program_compiler.call_function(str(ctx.PRINT()),\n            [self.findNumbExprResult(ctx.numbExpr(0))])\n\n    # Enter a parse tree produced by LangParser#readStrStmt.\n    def enterReadStrStmt(self, ctx: LangParser.ReadStrStmtContext):\n        pass\n\n    # Exit a parse tree produced by LangParser#readStrStmt.\n    def exitReadStrStmt(self, ctx: LangParser.ReadStrStmtContext):\n        pass\n\n    def checkNumbExprCorrectInFunctionCall(self, ctx, func_name):\n        params = ctx.numbExpr() if isinstance(\n            ctx.numbExpr(), list) else [ctx.numbExpr()]\n        params_types = list(map(self.findExpressionOutType, params))\n        if not self.function_vars.get(func_name):\n            raise SemanticAnalyzerException(\n                \"Function {} is not defined\".format(func_name))\n        available_types = [aval_param.split(\n            '/') for aval_param in self.function_vars.get(func_name).get(\"params\")]\n        if len(available_types) != len(params_types):\n            raise SemanticAnalyzerException(\"Expected {} parameters, received - {} in function {}\".format(\n                len(available_types), len(params_types), func_name))\n        for param_index, aval_types_for_each_param in enumerate(available_types):\n            if params_types[param_index] not in aval_types_for_each_param:\n                raise SemanticAnalyzerException(\n                    f\"Expected {param_index} parameter to be {aval_types_for_each_param} in {func_name} function. Received - {params_types[param_index]}\")", ""]}
{"filename": "parser/LangParser.py", "chunked_list": ["# Generated from LangParser.g4 by ANTLR 4.7.2\n# encoding: utf-8\nfrom antlr4 import *\nfrom io import StringIO\nfrom typing.io import TextIO\nfrom antlr4.error.ErrorStrategy import ErrorStrategy\nimport sys\n\ndef serializedATN():\n    with StringIO() as buf:\n        buf.write(\"\\3\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\\u5964\\3B\")\n        buf.write(\"\\u01f1\\4\\2\\t\\2\\4\\3\\t\\3\\4\\4\\t\\4\\4\\5\\t\\5\\4\\6\\t\\6\\4\\7\\t\\7\")\n        buf.write(\"\\4\\b\\t\\b\\4\\t\\t\\t\\4\\n\\t\\n\\4\\13\\t\\13\\4\\f\\t\\f\\4\\r\\t\\r\\4\\16\")\n        buf.write(\"\\t\\16\\4\\17\\t\\17\\4\\20\\t\\20\\4\\21\\t\\21\\4\\22\\t\\22\\4\\23\\t\\23\")\n        buf.write(\"\\4\\24\\t\\24\\4\\25\\t\\25\\4\\26\\t\\26\\4\\27\\t\\27\\4\\30\\t\\30\\4\\31\")\n        buf.write(\"\\t\\31\\4\\32\\t\\32\\4\\33\\t\\33\\4\\34\\t\\34\\4\\35\\t\\35\\4\\36\\t\\36\")\n        buf.write(\"\\4\\37\\t\\37\\4 \\t \\4!\\t!\\4\\\"\\t\\\"\\4#\\t#\\4$\\t$\\4%\\t%\\4&\\t\")\n        buf.write(\"&\\4\\'\\t\\'\\4(\\t(\\4)\\t)\\3\\2\\7\\2T\\n\\2\\f\\2\\16\\2W\\13\\2\\3\\2\")\n        buf.write(\"\\7\\2Z\\n\\2\\f\\2\\16\\2]\\13\\2\\3\\2\\3\\2\\3\\3\\3\\3\\5\\3c\\n\\3\\3\\3\")\n        buf.write(\"\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\5\\3k\\n\\3\\3\\3\\3\\3\\3\\3\\3\\3\\7\\3q\\n\\3\")\n        buf.write(\"\\f\\3\\16\\3t\\13\\3\\3\\3\\3\\3\\3\\3\\7\\3y\\n\\3\\f\\3\\16\\3|\\13\\3\\3\")\n        buf.write(\"\\3\\3\\3\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\")\n        buf.write(\"\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\5\\4\\u0093\\n\\4\\3\\4\\5\\4\\u0096\")\n        buf.write(\"\\n\\4\\3\\5\\3\\5\\5\\5\\u009a\\n\\5\\3\\6\\3\\6\\3\\6\\5\\6\\u009f\\n\\6\\3\")\n        buf.write(\"\\6\\3\\6\\5\\6\\u00a3\\n\\6\\3\\6\\3\\6\\5\\6\\u00a7\\n\\6\\3\\6\\3\\6\\3\\6\")\n        buf.write(\"\\7\\6\\u00ac\\n\\6\\f\\6\\16\\6\\u00af\\13\\6\\3\\6\\3\\6\\3\\7\\5\\7\\u00b4\")\n        buf.write(\"\\n\\7\\3\\7\\3\\7\\5\\7\\u00b8\\n\\7\\3\\7\\3\\7\\3\\7\\7\\7\\u00bd\\n\\7\\f\")\n        buf.write(\"\\7\\16\\7\\u00c0\\13\\7\\3\\7\\3\\7\\3\\7\\3\\7\\7\\7\\u00c6\\n\\7\\f\\7\\16\")\n        buf.write(\"\\7\\u00c9\\13\\7\\3\\b\\3\\b\\3\\b\\3\\b\\7\\b\\u00cf\\n\\b\\f\\b\\16\\b\\u00d2\")\n        buf.write(\"\\13\\b\\3\\t\\3\\t\\3\\t\\3\\t\\5\\t\\u00d8\\n\\t\\3\\t\\3\\t\\3\\n\\3\\n\\3\")\n        buf.write(\"\\13\\3\\13\\3\\f\\3\\f\\3\\r\\3\\r\\3\\16\\3\\16\\5\\16\\u00e6\\n\\16\\3\\17\")\n        buf.write(\"\\3\\17\\3\\20\\3\\20\\3\\21\\3\\21\\3\\21\\5\\21\\u00ef\\n\\21\\3\\22\\3\")\n        buf.write(\"\\22\\3\\22\\3\\22\\3\\22\\3\\22\\3\\22\\7\\22\\u00f8\\n\\22\\f\\22\\16\\22\")\n        buf.write(\"\\u00fb\\13\\22\\3\\23\\3\\23\\3\\23\\3\\23\\3\\24\\3\\24\\3\\24\\3\\24\\7\")\n        buf.write(\"\\24\\u0105\\n\\24\\f\\24\\16\\24\\u0108\\13\\24\\3\\24\\3\\24\\3\\24\\3\")\n        buf.write(\"\\24\\3\\24\\3\\24\\7\\24\\u0110\\n\\24\\f\\24\\16\\24\\u0113\\13\\24\\3\")\n        buf.write(\"\\24\\3\\24\\7\\24\\u0117\\n\\24\\f\\24\\16\\24\\u011a\\13\\24\\3\\24\\3\")\n        buf.write(\"\\24\\3\\24\\7\\24\\u011f\\n\\24\\f\\24\\16\\24\\u0122\\13\\24\\3\\24\\7\")\n        buf.write(\"\\24\\u0125\\n\\24\\f\\24\\16\\24\\u0128\\13\\24\\3\\25\\3\\25\\3\\25\\3\")\n        buf.write(\"\\25\\3\\25\\3\\25\\7\\25\\u0130\\n\\25\\f\\25\\16\\25\\u0133\\13\\25\\3\")\n        buf.write(\"\\25\\3\\25\\3\\26\\3\\26\\7\\26\\u0139\\n\\26\\f\\26\\16\\26\\u013c\\13\")\n        buf.write(\"\\26\\3\\26\\3\\26\\3\\26\\3\\26\\3\\26\\3\\26\\3\\27\\3\\27\\3\\27\\5\\27\")\n        buf.write(\"\\u0147\\n\\27\\3\\27\\3\\27\\7\\27\\u014b\\n\\27\\f\\27\\16\\27\\u014e\")\n        buf.write(\"\\13\\27\\3\\27\\3\\27\\3\\30\\3\\30\\5\\30\\u0154\\n\\30\\3\\30\\3\\30\\5\")\n        buf.write(\"\\30\\u0158\\n\\30\\3\\30\\6\\30\\u015b\\n\\30\\r\\30\\16\\30\\u015c\\3\")\n        buf.write(\"\\31\\3\\31\\3\\31\\3\\31\\5\\31\\u0163\\n\\31\\3\\31\\3\\31\\3\\31\\3\\31\")\n        buf.write(\"\\5\\31\\u0169\\n\\31\\7\\31\\u016b\\n\\31\\f\\31\\16\\31\\u016e\\13\\31\")\n        buf.write(\"\\3\\31\\3\\31\\3\\32\\3\\32\\3\\32\\3\\32\\3\\32\\3\\32\\3\\32\\3\\32\\3\\32\")\n        buf.write(\"\\3\\32\\3\\32\\3\\32\\5\\32\\u017e\\n\\32\\3\\33\\3\\33\\3\\33\\3\\33\\3\")\n        buf.write(\"\\33\\3\\34\\3\\34\\3\\34\\3\\34\\3\\35\\3\\35\\3\\35\\5\\35\\u018c\\n\\35\")\n        buf.write(\"\\3\\35\\3\\35\\5\\35\\u0190\\n\\35\\3\\35\\3\\35\\3\\36\\3\\36\\3\\36\\5\")\n        buf.write(\"\\36\\u0197\\n\\36\\3\\36\\3\\36\\7\\36\\u019b\\n\\36\\f\\36\\16\\36\\u019e\")\n        buf.write(\"\\13\\36\\3\\36\\3\\36\\5\\36\\u01a2\\n\\36\\3\\36\\3\\36\\3\\37\\3\\37\\3\")\n        buf.write(\"\\37\\5\\37\\u01a9\\n\\37\\3\\37\\3\\37\\5\\37\\u01ad\\n\\37\\3\\37\\3\\37\")\n        buf.write(\"\\3 \\3 \\3 \\3 \\3 \\3!\\3!\\3\\\"\\3\\\"\\3\\\"\\3\\\"\\3\\\"\\3#\\3#\\3$\\3$\")\n        buf.write(\"\\3$\\3$\\3$\\3$\\3$\\3%\\3%\\3%\\3%\\3%\\3%\\3%\\3%\\3%\\3&\\3&\\3&\\3\")\n        buf.write(\"&\\3&\\3&\\3&\\3&\\3&\\3\\'\\3\\'\\3\\'\\3\\'\\3\\'\\3\\'\\3\\'\\3(\\3(\\3(\")\n        buf.write(\"\\5(\\u01e2\\n(\\3(\\3(\\7(\\u01e6\\n(\\f(\\16(\\u01e9\\13(\\3(\\3(\")\n        buf.write(\"\\3)\\3)\\3)\\3)\\3)\\2\\3\\\"*\\2\\4\\6\\b\\n\\f\\16\\20\\22\\24\\26\\30\\32\")\n        buf.write(\"\\34\\36 \\\"$&(*,.\\60\\62\\64\\668:<>@BDFHJLNP\\2\\n\\3\\2\\31\\35\")\n        buf.write(\"\\3\\2\\67;\\3\\2\\3\\13\\3\\2\\f\\20\\4\\29;??\\4\\29;=?\\3\\2-\\60\\3\\2\")\n        buf.write(\")+\\2\\u020d\\2U\\3\\2\\2\\2\\4b\\3\\2\\2\\2\\6\\u0092\\3\\2\\2\\2\\b\\u0099\")\n        buf.write(\"\\3\\2\\2\\2\\n\\u009b\\3\\2\\2\\2\\f\\u00b3\\3\\2\\2\\2\\16\\u00ca\\3\\2\")\n        buf.write(\"\\2\\2\\20\\u00d7\\3\\2\\2\\2\\22\\u00db\\3\\2\\2\\2\\24\\u00dd\\3\\2\\2\")\n        buf.write(\"\\2\\26\\u00df\\3\\2\\2\\2\\30\\u00e1\\3\\2\\2\\2\\32\\u00e5\\3\\2\\2\\2\")\n        buf.write(\"\\34\\u00e7\\3\\2\\2\\2\\36\\u00e9\\3\\2\\2\\2 \\u00ee\\3\\2\\2\\2\\\"\\u00f0\")\n        buf.write(\"\\3\\2\\2\\2$\\u00fc\\3\\2\\2\\2&\\u0100\\3\\2\\2\\2(\\u0129\\3\\2\\2\\2\")\n        buf.write(\"*\\u0136\\3\\2\\2\\2,\\u0143\\3\\2\\2\\2.\\u0153\\3\\2\\2\\2\\60\\u015e\")\n        buf.write(\"\\3\\2\\2\\2\\62\\u017d\\3\\2\\2\\2\\64\\u017f\\3\\2\\2\\2\\66\\u0184\\3\")\n        buf.write(\"\\2\\2\\28\\u0188\\3\\2\\2\\2:\\u0193\\3\\2\\2\\2<\\u01a5\\3\\2\\2\\2>\\u01b0\")\n        buf.write(\"\\3\\2\\2\\2@\\u01b5\\3\\2\\2\\2B\\u01b7\\3\\2\\2\\2D\\u01bc\\3\\2\\2\\2\")\n        buf.write(\"F\\u01be\\3\\2\\2\\2H\\u01c5\\3\\2\\2\\2J\\u01ce\\3\\2\\2\\2L\\u01d7\\3\")\n        buf.write(\"\\2\\2\\2N\\u01de\\3\\2\\2\\2P\\u01ec\\3\\2\\2\\2RT\\5\\4\\3\\2SR\\3\\2\\2\")\n        buf.write(\"\\2TW\\3\\2\\2\\2US\\3\\2\\2\\2UV\\3\\2\\2\\2V[\\3\\2\\2\\2WU\\3\\2\\2\\2X\")\n        buf.write(\"Z\\5\\6\\4\\2YX\\3\\2\\2\\2Z]\\3\\2\\2\\2[Y\\3\\2\\2\\2[\\\\\\3\\2\\2\\2\\\\^\")\n        buf.write(\"\\3\\2\\2\\2][\\3\\2\\2\\2^_\\7\\2\\2\\3_\\3\\3\\2\\2\\2`c\\5\\24\\13\\2ac\")\n        buf.write(\"\\7<\\2\\2b`\\3\\2\\2\\2ba\\3\\2\\2\\2cd\\3\\2\\2\\2de\\7\\36\\2\\2ef\\7?\")\n        buf.write(\"\\2\\2fj\\7\\23\\2\\2gh\\5\\24\\13\\2hi\\7?\\2\\2ik\\3\\2\\2\\2jg\\3\\2\\2\")\n        buf.write(\"\\2jk\\3\\2\\2\\2kr\\3\\2\\2\\2lm\\7\\21\\2\\2mn\\5\\24\\13\\2no\\7?\\2\\2\")\n        buf.write(\"oq\\3\\2\\2\\2pl\\3\\2\\2\\2qt\\3\\2\\2\\2rp\\3\\2\\2\\2rs\\3\\2\\2\\2su\\3\")\n        buf.write(\"\\2\\2\\2tr\\3\\2\\2\\2uv\\7\\24\\2\\2vz\\7\\25\\2\\2wy\\5\\b\\5\\2xw\\3\\2\")\n        buf.write(\"\\2\\2y|\\3\\2\\2\\2zx\\3\\2\\2\\2z{\\3\\2\\2\\2{}\\3\\2\\2\\2|z\\3\\2\\2\\2\")\n        buf.write(\"}~\\7\\26\\2\\2~\\5\\3\\2\\2\\2\\177\\u0080\\5\\f\\7\\2\\u0080\\u0081\\7\")\n        buf.write(\"\\22\\2\\2\\u0081\\u0093\\3\\2\\2\\2\\u0082\\u0083\\5\\62\\32\\2\\u0083\")\n        buf.write(\"\\u0084\\7\\22\\2\\2\\u0084\\u0093\\3\\2\\2\\2\\u0085\\u0086\\5N(\\2\")\n        buf.write(\"\\u0086\\u0087\\7\\22\\2\\2\\u0087\\u0093\\3\\2\\2\\2\\u0088\\u0093\")\n        buf.write(\"\\5\\n\\6\\2\\u0089\\u0093\\5&\\24\\2\\u008a\\u0093\\5(\\25\\2\\u008b\")\n        buf.write(\"\\u0093\\5*\\26\\2\\u008c\\u008d\\5\\20\\t\\2\\u008d\\u008e\\7\\22\\2\")\n        buf.write(\"\\2\\u008e\\u0093\\3\\2\\2\\2\\u008f\\u0090\\5\\16\\b\\2\\u0090\\u0091\")\n        buf.write(\"\\7\\22\\2\\2\\u0091\\u0093\\3\\2\\2\\2\\u0092\\177\\3\\2\\2\\2\\u0092\")\n        buf.write(\"\\u0082\\3\\2\\2\\2\\u0092\\u0085\\3\\2\\2\\2\\u0092\\u0088\\3\\2\\2\\2\")\n        buf.write(\"\\u0092\\u0089\\3\\2\\2\\2\\u0092\\u008a\\3\\2\\2\\2\\u0092\\u008b\\3\")\n        buf.write(\"\\2\\2\\2\\u0092\\u008c\\3\\2\\2\\2\\u0092\\u008f\\3\\2\\2\\2\\u0093\\u0095\")\n        buf.write(\"\\3\\2\\2\\2\\u0094\\u0096\\7%\\2\\2\\u0095\\u0094\\3\\2\\2\\2\\u0095\")\n        buf.write(\"\\u0096\\3\\2\\2\\2\\u0096\\7\\3\\2\\2\\2\\u0097\\u009a\\5\\6\\4\\2\\u0098\")\n        buf.write(\"\\u009a\\5\\66\\34\\2\\u0099\\u0097\\3\\2\\2\\2\\u0099\\u0098\\3\\2\\2\")\n        buf.write(\"\\2\\u009a\\t\\3\\2\\2\\2\\u009b\\u009c\\7\\37\\2\\2\\u009c\\u009e\\7\")\n        buf.write(\"\\23\\2\\2\\u009d\\u009f\\5\\f\\7\\2\\u009e\\u009d\\3\\2\\2\\2\\u009e\")\n        buf.write(\"\\u009f\\3\\2\\2\\2\\u009f\\u00a0\\3\\2\\2\\2\\u00a0\\u00a2\\7\\22\\2\")\n        buf.write(\"\\2\\u00a1\\u00a3\\5$\\23\\2\\u00a2\\u00a1\\3\\2\\2\\2\\u00a2\\u00a3\")\n        buf.write(\"\\3\\2\\2\\2\\u00a3\\u00a4\\3\\2\\2\\2\\u00a4\\u00a6\\7\\22\\2\\2\\u00a5\")\n        buf.write(\"\\u00a7\\5\\20\\t\\2\\u00a6\\u00a5\\3\\2\\2\\2\\u00a6\\u00a7\\3\\2\\2\")\n        buf.write(\"\\2\\u00a7\\u00a8\\3\\2\\2\\2\\u00a8\\u00a9\\7\\24\\2\\2\\u00a9\\u00ad\")\n        buf.write(\"\\7\\25\\2\\2\\u00aa\\u00ac\\5\\b\\5\\2\\u00ab\\u00aa\\3\\2\\2\\2\\u00ac\")\n        buf.write(\"\\u00af\\3\\2\\2\\2\\u00ad\\u00ab\\3\\2\\2\\2\\u00ad\\u00ae\\3\\2\\2\\2\")\n        buf.write(\"\\u00ae\\u00b0\\3\\2\\2\\2\\u00af\\u00ad\\3\\2\\2\\2\\u00b0\\u00b1\\7\")\n        buf.write(\"\\26\\2\\2\\u00b1\\13\\3\\2\\2\\2\\u00b2\\u00b4\\5\\24\\13\\2\\u00b3\\u00b2\")\n        buf.write(\"\\3\\2\\2\\2\\u00b3\\u00b4\\3\\2\\2\\2\\u00b4\\u00b7\\3\\2\\2\\2\\u00b5\")\n        buf.write(\"\\u00b8\\7?\\2\\2\\u00b6\\u00b8\\5.\\30\\2\\u00b7\\u00b5\\3\\2\\2\\2\")\n        buf.write(\"\\u00b7\\u00b6\\3\\2\\2\\2\\u00b8\\u00be\\3\\2\\2\\2\\u00b9\\u00ba\\7\")\n        buf.write(\"\\21\\2\\2\\u00ba\\u00bd\\7?\\2\\2\\u00bb\\u00bd\\5.\\30\\2\\u00bc\\u00b9\")\n        buf.write(\"\\3\\2\\2\\2\\u00bc\\u00bb\\3\\2\\2\\2\\u00bd\\u00c0\\3\\2\\2\\2\\u00be\")\n        buf.write(\"\\u00bc\\3\\2\\2\\2\\u00be\\u00bf\\3\\2\\2\\2\\u00bf\\u00c1\\3\\2\\2\\2\")\n        buf.write(\"\\u00c0\\u00be\\3\\2\\2\\2\\u00c1\\u00c2\\5\\22\\n\\2\\u00c2\\u00c7\")\n        buf.write(\"\\5\\\"\\22\\2\\u00c3\\u00c4\\7\\21\\2\\2\\u00c4\\u00c6\\5\\\"\\22\\2\\u00c5\")\n        buf.write(\"\\u00c3\\3\\2\\2\\2\\u00c6\\u00c9\\3\\2\\2\\2\\u00c7\\u00c5\\3\\2\\2\\2\")\n        buf.write(\"\\u00c7\\u00c8\\3\\2\\2\\2\\u00c8\\r\\3\\2\\2\\2\\u00c9\\u00c7\\3\\2\\2\")\n        buf.write(\"\\2\\u00ca\\u00cb\\5\\24\\13\\2\\u00cb\\u00d0\\7?\\2\\2\\u00cc\\u00cd\")\n        buf.write(\"\\7\\21\\2\\2\\u00cd\\u00cf\\7?\\2\\2\\u00ce\\u00cc\\3\\2\\2\\2\\u00cf\")\n        buf.write(\"\\u00d2\\3\\2\\2\\2\\u00d0\\u00ce\\3\\2\\2\\2\\u00d0\\u00d1\\3\\2\\2\\2\")\n        buf.write(\"\\u00d1\\17\\3\\2\\2\\2\\u00d2\\u00d0\\3\\2\\2\\2\\u00d3\\u00d4\\7\\f\")\n        buf.write(\"\\2\\2\\u00d4\\u00d8\\7\\f\\2\\2\\u00d5\\u00d6\\7\\r\\2\\2\\u00d6\\u00d8\")\n        buf.write(\"\\7\\r\\2\\2\\u00d7\\u00d3\\3\\2\\2\\2\\u00d7\\u00d5\\3\\2\\2\\2\\u00d8\")\n        buf.write(\"\\u00d9\\3\\2\\2\\2\\u00d9\\u00da\\7?\\2\\2\\u00da\\21\\3\\2\\2\\2\\u00db\")\n        buf.write(\"\\u00dc\\t\\2\\2\\2\\u00dc\\23\\3\\2\\2\\2\\u00dd\\u00de\\t\\3\\2\\2\\u00de\")\n        buf.write(\"\\25\\3\\2\\2\\2\\u00df\\u00e0\\t\\4\\2\\2\\u00e0\\27\\3\\2\\2\\2\\u00e1\")\n        buf.write(\"\\u00e2\\t\\5\\2\\2\\u00e2\\31\\3\\2\\2\\2\\u00e3\\u00e6\\5\\26\\f\\2\\u00e4\")\n        buf.write(\"\\u00e6\\5\\30\\r\\2\\u00e5\\u00e3\\3\\2\\2\\2\\u00e5\\u00e4\\3\\2\\2\")\n        buf.write(\"\\2\\u00e6\\33\\3\\2\\2\\2\\u00e7\\u00e8\\t\\6\\2\\2\\u00e8\\35\\3\\2\\2\")\n        buf.write(\"\\2\\u00e9\\u00ea\\t\\7\\2\\2\\u00ea\\37\\3\\2\\2\\2\\u00eb\\u00ef\\5\")\n        buf.write(\"\\36\\20\\2\\u00ec\\u00ef\\5\\62\\32\\2\\u00ed\\u00ef\\5.\\30\\2\\u00ee\")\n        buf.write(\"\\u00eb\\3\\2\\2\\2\\u00ee\\u00ec\\3\\2\\2\\2\\u00ee\\u00ed\\3\\2\\2\\2\")\n        buf.write(\"\\u00ef!\\3\\2\\2\\2\\u00f0\\u00f1\\b\\22\\1\\2\\u00f1\\u00f2\\5 \\21\")\n        buf.write(\"\\2\\u00f2\\u00f9\\3\\2\\2\\2\\u00f3\\u00f4\\f\\3\\2\\2\\u00f4\\u00f5\")\n        buf.write(\"\\5\\32\\16\\2\\u00f5\\u00f6\\5\\\"\\22\\4\\u00f6\\u00f8\\3\\2\\2\\2\\u00f7\")\n        buf.write(\"\\u00f3\\3\\2\\2\\2\\u00f8\\u00fb\\3\\2\\2\\2\\u00f9\\u00f7\\3\\2\\2\\2\")\n        buf.write(\"\\u00f9\\u00fa\\3\\2\\2\\2\\u00fa#\\3\\2\\2\\2\\u00fb\\u00f9\\3\\2\\2\")\n        buf.write(\"\\2\\u00fc\\u00fd\\5\\\"\\22\\2\\u00fd\\u00fe\\5\\26\\f\\2\\u00fe\\u00ff\")\n        buf.write(\"\\5\\\"\\22\\2\\u00ff%\\3\\2\\2\\2\\u0100\\u0101\\7!\\2\\2\\u0101\\u0102\")\n        buf.write(\"\\5$\\23\\2\\u0102\\u0106\\7\\25\\2\\2\\u0103\\u0105\\5\\b\\5\\2\\u0104\")\n        buf.write(\"\\u0103\\3\\2\\2\\2\\u0105\\u0108\\3\\2\\2\\2\\u0106\\u0104\\3\\2\\2\\2\")\n        buf.write(\"\\u0106\\u0107\\3\\2\\2\\2\\u0107\\u0109\\3\\2\\2\\2\\u0108\\u0106\\3\")\n        buf.write(\"\\2\\2\\2\\u0109\\u0118\\7\\26\\2\\2\\u010a\\u010b\\7\\\"\\2\\2\\u010b\")\n        buf.write(\"\\u010c\\7!\\2\\2\\u010c\\u010d\\5$\\23\\2\\u010d\\u0111\\7\\25\\2\\2\")\n        buf.write(\"\\u010e\\u0110\\5\\b\\5\\2\\u010f\\u010e\\3\\2\\2\\2\\u0110\\u0113\\3\")\n        buf.write(\"\\2\\2\\2\\u0111\\u010f\\3\\2\\2\\2\\u0111\\u0112\\3\\2\\2\\2\\u0112\\u0114\")\n        buf.write(\"\\3\\2\\2\\2\\u0113\\u0111\\3\\2\\2\\2\\u0114\\u0115\\7\\26\\2\\2\\u0115\")\n        buf.write(\"\\u0117\\3\\2\\2\\2\\u0116\\u010a\\3\\2\\2\\2\\u0117\\u011a\\3\\2\\2\\2\")\n        buf.write(\"\\u0118\\u0116\\3\\2\\2\\2\\u0118\\u0119\\3\\2\\2\\2\\u0119\\u0126\\3\")\n        buf.write(\"\\2\\2\\2\\u011a\\u0118\\3\\2\\2\\2\\u011b\\u011c\\7\\\"\\2\\2\\u011c\\u0120\")\n        buf.write(\"\\7\\25\\2\\2\\u011d\\u011f\\5\\b\\5\\2\\u011e\\u011d\\3\\2\\2\\2\\u011f\")\n        buf.write(\"\\u0122\\3\\2\\2\\2\\u0120\\u011e\\3\\2\\2\\2\\u0120\\u0121\\3\\2\\2\\2\")\n        buf.write(\"\\u0121\\u0123\\3\\2\\2\\2\\u0122\\u0120\\3\\2\\2\\2\\u0123\\u0125\\7\")\n        buf.write(\"\\26\\2\\2\\u0124\\u011b\\3\\2\\2\\2\\u0125\\u0128\\3\\2\\2\\2\\u0126\")\n        buf.write(\"\\u0124\\3\\2\\2\\2\\u0126\\u0127\\3\\2\\2\\2\\u0127\\'\\3\\2\\2\\2\\u0128\")\n        buf.write(\"\\u0126\\3\\2\\2\\2\\u0129\\u012a\\7#\\2\\2\\u012a\\u012b\\7\\23\\2\\2\")\n        buf.write(\"\\u012b\\u012c\\5$\\23\\2\\u012c\\u012d\\7\\24\\2\\2\\u012d\\u0131\")\n        buf.write(\"\\7\\25\\2\\2\\u012e\\u0130\\5\\b\\5\\2\\u012f\\u012e\\3\\2\\2\\2\\u0130\")\n        buf.write(\"\\u0133\\3\\2\\2\\2\\u0131\\u012f\\3\\2\\2\\2\\u0131\\u0132\\3\\2\\2\\2\")\n        buf.write(\"\\u0132\\u0134\\3\\2\\2\\2\\u0133\\u0131\\3\\2\\2\\2\\u0134\\u0135\\7\")\n        buf.write(\"\\26\\2\\2\\u0135)\\3\\2\\2\\2\\u0136\\u013a\\7\\25\\2\\2\\u0137\\u0139\")\n        buf.write(\"\\5\\b\\5\\2\\u0138\\u0137\\3\\2\\2\\2\\u0139\\u013c\\3\\2\\2\\2\\u013a\")\n        buf.write(\"\\u0138\\3\\2\\2\\2\\u013a\\u013b\\3\\2\\2\\2\\u013b\\u013d\\3\\2\\2\\2\")\n        buf.write(\"\\u013c\\u013a\\3\\2\\2\\2\\u013d\\u013e\\7\\26\\2\\2\\u013e\\u013f\")\n        buf.write(\"\\7$\\2\\2\\u013f\\u0140\\7\\23\\2\\2\\u0140\\u0141\\5$\\23\\2\\u0141\")\n        buf.write(\"\\u0142\\7\\24\\2\\2\\u0142+\\3\\2\\2\\2\\u0143\\u0144\\7?\\2\\2\\u0144\")\n        buf.write(\"\\u0146\\7\\23\\2\\2\\u0145\\u0147\\5\\\"\\22\\2\\u0146\\u0145\\3\\2\\2\")\n        buf.write(\"\\2\\u0146\\u0147\\3\\2\\2\\2\\u0147\\u014c\\3\\2\\2\\2\\u0148\\u0149\")\n        buf.write(\"\\7\\21\\2\\2\\u0149\\u014b\\5\\\"\\22\\2\\u014a\\u0148\\3\\2\\2\\2\\u014b\")\n        buf.write(\"\\u014e\\3\\2\\2\\2\\u014c\\u014a\\3\\2\\2\\2\\u014c\\u014d\\3\\2\\2\\2\")\n        buf.write(\"\\u014d\\u014f\\3\\2\\2\\2\\u014e\\u014c\\3\\2\\2\\2\\u014f\\u0150\\7\")\n        buf.write(\"\\24\\2\\2\\u0150-\\3\\2\\2\\2\\u0151\\u0154\\5\\34\\17\\2\\u0152\\u0154\")\n        buf.write(\"\\5\\62\\32\\2\\u0153\\u0151\\3\\2\\2\\2\\u0153\\u0152\\3\\2\\2\\2\\u0154\")\n        buf.write(\"\\u015a\\3\\2\\2\\2\\u0155\\u0157\\7\\27\\2\\2\\u0156\\u0158\\5\\\"\\22\")\n        buf.write(\"\\2\\u0157\\u0156\\3\\2\\2\\2\\u0157\\u0158\\3\\2\\2\\2\\u0158\\u0159\")\n        buf.write(\"\\3\\2\\2\\2\\u0159\\u015b\\7\\30\\2\\2\\u015a\\u0155\\3\\2\\2\\2\\u015b\")\n        buf.write(\"\\u015c\\3\\2\\2\\2\\u015c\\u015a\\3\\2\\2\\2\\u015c\\u015d\\3\\2\\2\\2\")\n        buf.write(\"\\u015d/\\3\\2\\2\\2\\u015e\\u0162\\7\\27\\2\\2\\u015f\\u0163\\5\\60\")\n        buf.write(\"\\31\\2\\u0160\\u0163\\7=\\2\\2\\u0161\\u0163\\7>\\2\\2\\u0162\\u015f\")\n        buf.write(\"\\3\\2\\2\\2\\u0162\\u0160\\3\\2\\2\\2\\u0162\\u0161\\3\\2\\2\\2\\u0162\")\n        buf.write(\"\\u0163\\3\\2\\2\\2\\u0163\\u016c\\3\\2\\2\\2\\u0164\\u0168\\7\\21\\2\")\n        buf.write(\"\\2\\u0165\\u0169\\5\\60\\31\\2\\u0166\\u0169\\7=\\2\\2\\u0167\\u0169\")\n        buf.write(\"\\7>\\2\\2\\u0168\\u0165\\3\\2\\2\\2\\u0168\\u0166\\3\\2\\2\\2\\u0168\")\n        buf.write(\"\\u0167\\3\\2\\2\\2\\u0169\\u016b\\3\\2\\2\\2\\u016a\\u0164\\3\\2\\2\\2\")\n        buf.write(\"\\u016b\\u016e\\3\\2\\2\\2\\u016c\\u016a\\3\\2\\2\\2\\u016c\\u016d\\3\")\n        buf.write(\"\\2\\2\\2\\u016d\\u016f\\3\\2\\2\\2\\u016e\\u016c\\3\\2\\2\\2\\u016f\\u0170\")\n        buf.write(\"\\7\\30\\2\\2\\u0170\\61\\3\\2\\2\\2\\u0171\\u017e\\5\\64\\33\\2\\u0172\")\n        buf.write(\"\\u017e\\58\\35\\2\\u0173\\u017e\\5,\\27\\2\\u0174\\u017e\\5:\\36\\2\")\n        buf.write(\"\\u0175\\u017e\\5<\\37\\2\\u0176\\u017e\\5P)\\2\\u0177\\u017e\\5>\")\n        buf.write(\" \\2\\u0178\\u017e\\5B\\\"\\2\\u0179\\u017e\\5F$\\2\\u017a\\u017e\\5\")\n        buf.write(\"H%\\2\\u017b\\u017e\\5J&\\2\\u017c\\u017e\\5L\\'\\2\\u017d\\u0171\")\n        buf.write(\"\\3\\2\\2\\2\\u017d\\u0172\\3\\2\\2\\2\\u017d\\u0173\\3\\2\\2\\2\\u017d\")\n        buf.write(\"\\u0174\\3\\2\\2\\2\\u017d\\u0175\\3\\2\\2\\2\\u017d\\u0176\\3\\2\\2\\2\")\n        buf.write(\"\\u017d\\u0177\\3\\2\\2\\2\\u017d\\u0178\\3\\2\\2\\2\\u017d\\u0179\\3\")\n        buf.write(\"\\2\\2\\2\\u017d\\u017a\\3\\2\\2\\2\\u017d\\u017b\\3\\2\\2\\2\\u017d\\u017c\")\n        buf.write(\"\\3\\2\\2\\2\\u017e\\63\\3\\2\\2\\2\\u017f\\u0180\\7\\'\\2\\2\\u0180\\u0181\")\n        buf.write(\"\\7\\23\\2\\2\\u0181\\u0182\\5\\\"\\22\\2\\u0182\\u0183\\7\\24\\2\\2\\u0183\")\n        buf.write(\"\\65\\3\\2\\2\\2\\u0184\\u0185\\7 \\2\\2\\u0185\\u0186\\5\\\"\\22\\2\\u0186\")\n        buf.write(\"\\u0187\\7\\22\\2\\2\\u0187\\67\\3\\2\\2\\2\\u0188\\u0189\\7\\62\\2\\2\")\n        buf.write(\"\\u0189\\u018b\\7\\23\\2\\2\\u018a\\u018c\\7=\\2\\2\\u018b\\u018a\\3\")\n        buf.write(\"\\2\\2\\2\\u018b\\u018c\\3\\2\\2\\2\\u018c\\u018f\\3\\2\\2\\2\\u018d\\u018e\")\n        buf.write(\"\\7\\21\\2\\2\\u018e\\u0190\\5\\60\\31\\2\\u018f\\u018d\\3\\2\\2\\2\\u018f\")\n        buf.write(\"\\u0190\\3\\2\\2\\2\\u0190\\u0191\\3\\2\\2\\2\\u0191\\u0192\\7\\24\\2\")\n        buf.write(\"\\2\\u01929\\3\\2\\2\\2\\u0193\\u0194\\7\\63\\2\\2\\u0194\\u0196\\7\\23\")\n        buf.write(\"\\2\\2\\u0195\\u0197\\7=\\2\\2\\u0196\\u0195\\3\\2\\2\\2\\u0196\\u0197\")\n        buf.write(\"\\3\\2\\2\\2\\u0197\\u019c\\3\\2\\2\\2\\u0198\\u0199\\7\\21\\2\\2\\u0199\")\n        buf.write(\"\\u019b\\7=\\2\\2\\u019a\\u0198\\3\\2\\2\\2\\u019b\\u019e\\3\\2\\2\\2\")\n        buf.write(\"\\u019c\\u019a\\3\\2\\2\\2\\u019c\\u019d\\3\\2\\2\\2\\u019d\\u01a1\\3\")\n        buf.write(\"\\2\\2\\2\\u019e\\u019c\\3\\2\\2\\2\\u019f\\u01a0\\7\\21\\2\\2\\u01a0\")\n        buf.write(\"\\u01a2\\5\\60\\31\\2\\u01a1\\u019f\\3\\2\\2\\2\\u01a1\\u01a2\\3\\2\\2\")\n        buf.write(\"\\2\\u01a2\\u01a3\\3\\2\\2\\2\\u01a3\\u01a4\\7\\24\\2\\2\\u01a4;\\3\\2\")\n        buf.write(\"\\2\\2\\u01a5\\u01a6\\7\\64\\2\\2\\u01a6\\u01a8\\7\\23\\2\\2\\u01a7\\u01a9\")\n        buf.write(\"\\7=\\2\\2\\u01a8\\u01a7\\3\\2\\2\\2\\u01a8\\u01a9\\3\\2\\2\\2\\u01a9\")\n        buf.write(\"\\u01ac\\3\\2\\2\\2\\u01aa\\u01ab\\7\\21\\2\\2\\u01ab\\u01ad\\5\\60\\31\")\n        buf.write(\"\\2\\u01ac\\u01aa\\3\\2\\2\\2\\u01ac\\u01ad\\3\\2\\2\\2\\u01ad\\u01ae\")\n        buf.write(\"\\3\\2\\2\\2\\u01ae\\u01af\\7\\24\\2\\2\\u01af=\\3\\2\\2\\2\\u01b0\\u01b1\")\n        buf.write(\"\\7\\66\\2\\2\\u01b1\\u01b2\\7\\23\\2\\2\\u01b2\\u01b3\\7?\\2\\2\\u01b3\")\n        buf.write(\"\\u01b4\\7\\24\\2\\2\\u01b4?\\3\\2\\2\\2\\u01b5\\u01b6\\t\\b\\2\\2\\u01b6\")\n        buf.write(\"A\\3\\2\\2\\2\\u01b7\\u01b8\\5@!\\2\\u01b8\\u01b9\\7\\23\\2\\2\\u01b9\")\n        buf.write(\"\\u01ba\\5\\\"\\22\\2\\u01ba\\u01bb\\7\\24\\2\\2\\u01bbC\\3\\2\\2\\2\\u01bc\")\n        buf.write(\"\\u01bd\\t\\t\\2\\2\\u01bdE\\3\\2\\2\\2\\u01be\\u01bf\\5D#\\2\\u01bf\")\n        buf.write(\"\\u01c0\\7\\23\\2\\2\\u01c0\\u01c1\\5\\\"\\22\\2\\u01c1\\u01c2\\7\\21\")\n        buf.write(\"\\2\\2\\u01c2\\u01c3\\5\\\"\\22\\2\\u01c3\\u01c4\\7\\24\\2\\2\\u01c4G\")\n        buf.write(\"\\3\\2\\2\\2\\u01c5\\u01c6\\7(\\2\\2\\u01c6\\u01c7\\7\\23\\2\\2\\u01c7\")\n        buf.write(\"\\u01c8\\5\\\"\\22\\2\\u01c8\\u01c9\\7\\21\\2\\2\\u01c9\\u01ca\\5\\\"\\22\")\n        buf.write(\"\\2\\u01ca\\u01cb\\7\\21\\2\\2\\u01cb\\u01cc\\5\\\"\\22\\2\\u01cc\\u01cd\")\n        buf.write(\"\\7\\24\\2\\2\\u01cdI\\3\\2\\2\\2\\u01ce\\u01cf\\7,\\2\\2\\u01cf\\u01d0\")\n        buf.write(\"\\7\\23\\2\\2\\u01d0\\u01d1\\5\\\"\\22\\2\\u01d1\\u01d2\\7\\21\\2\\2\\u01d2\")\n        buf.write(\"\\u01d3\\5\\\"\\22\\2\\u01d3\\u01d4\\7\\21\\2\\2\\u01d4\\u01d5\\5\\\"\\22\")\n        buf.write(\"\\2\\u01d5\\u01d6\\7\\24\\2\\2\\u01d6K\\3\\2\\2\\2\\u01d7\\u01d8\\7\\61\")\n        buf.write(\"\\2\\2\\u01d8\\u01d9\\7\\23\\2\\2\\u01d9\\u01da\\5\\\"\\22\\2\\u01da\\u01db\")\n        buf.write(\"\\7\\21\\2\\2\\u01db\\u01dc\\5\\\"\\22\\2\\u01dc\\u01dd\\7\\24\\2\\2\\u01dd\")\n        buf.write(\"M\\3\\2\\2\\2\\u01de\\u01df\\7&\\2\\2\\u01df\\u01e1\\7\\23\\2\\2\\u01e0\")\n        buf.write(\"\\u01e2\\5\\\"\\22\\2\\u01e1\\u01e0\\3\\2\\2\\2\\u01e1\\u01e2\\3\\2\\2\")\n        buf.write(\"\\2\\u01e2\\u01e7\\3\\2\\2\\2\\u01e3\\u01e4\\7\\21\\2\\2\\u01e4\\u01e6\")\n        buf.write(\"\\5\\\"\\22\\2\\u01e5\\u01e3\\3\\2\\2\\2\\u01e6\\u01e9\\3\\2\\2\\2\\u01e7\")\n        buf.write(\"\\u01e5\\3\\2\\2\\2\\u01e7\\u01e8\\3\\2\\2\\2\\u01e8\\u01ea\\3\\2\\2\\2\")\n        buf.write(\"\\u01e9\\u01e7\\3\\2\\2\\2\\u01ea\\u01eb\\7\\24\\2\\2\\u01ebO\\3\\2\\2\")\n        buf.write(\"\\2\\u01ec\\u01ed\\7\\65\\2\\2\\u01ed\\u01ee\\7\\23\\2\\2\\u01ee\\u01ef\")\n        buf.write(\"\\7\\24\\2\\2\\u01efQ\\3\\2\\2\\2\\62U[bjrz\\u0092\\u0095\\u0099\\u009e\")\n        buf.write(\"\\u00a2\\u00a6\\u00ad\\u00b3\\u00b7\\u00bc\\u00be\\u00c7\\u00d0\")\n        buf.write(\"\\u00d7\\u00e5\\u00ee\\u00f9\\u0106\\u0111\\u0118\\u0120\\u0126\")\n        buf.write(\"\\u0131\\u013a\\u0146\\u014c\\u0153\\u0157\\u015c\\u0162\\u0168\")\n        buf.write(\"\\u016c\\u017d\\u018b\\u018f\\u0196\\u019c\\u01a1\\u01a8\\u01ac\")\n        buf.write(\"\\u01e1\\u01e7\")\n        return buf.getvalue()", "def serializedATN():\n    with StringIO() as buf:\n        buf.write(\"\\3\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\\u5964\\3B\")\n        buf.write(\"\\u01f1\\4\\2\\t\\2\\4\\3\\t\\3\\4\\4\\t\\4\\4\\5\\t\\5\\4\\6\\t\\6\\4\\7\\t\\7\")\n        buf.write(\"\\4\\b\\t\\b\\4\\t\\t\\t\\4\\n\\t\\n\\4\\13\\t\\13\\4\\f\\t\\f\\4\\r\\t\\r\\4\\16\")\n        buf.write(\"\\t\\16\\4\\17\\t\\17\\4\\20\\t\\20\\4\\21\\t\\21\\4\\22\\t\\22\\4\\23\\t\\23\")\n        buf.write(\"\\4\\24\\t\\24\\4\\25\\t\\25\\4\\26\\t\\26\\4\\27\\t\\27\\4\\30\\t\\30\\4\\31\")\n        buf.write(\"\\t\\31\\4\\32\\t\\32\\4\\33\\t\\33\\4\\34\\t\\34\\4\\35\\t\\35\\4\\36\\t\\36\")\n        buf.write(\"\\4\\37\\t\\37\\4 \\t \\4!\\t!\\4\\\"\\t\\\"\\4#\\t#\\4$\\t$\\4%\\t%\\4&\\t\")\n        buf.write(\"&\\4\\'\\t\\'\\4(\\t(\\4)\\t)\\3\\2\\7\\2T\\n\\2\\f\\2\\16\\2W\\13\\2\\3\\2\")\n        buf.write(\"\\7\\2Z\\n\\2\\f\\2\\16\\2]\\13\\2\\3\\2\\3\\2\\3\\3\\3\\3\\5\\3c\\n\\3\\3\\3\")\n        buf.write(\"\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\5\\3k\\n\\3\\3\\3\\3\\3\\3\\3\\3\\3\\7\\3q\\n\\3\")\n        buf.write(\"\\f\\3\\16\\3t\\13\\3\\3\\3\\3\\3\\3\\3\\7\\3y\\n\\3\\f\\3\\16\\3|\\13\\3\\3\")\n        buf.write(\"\\3\\3\\3\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\")\n        buf.write(\"\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\5\\4\\u0093\\n\\4\\3\\4\\5\\4\\u0096\")\n        buf.write(\"\\n\\4\\3\\5\\3\\5\\5\\5\\u009a\\n\\5\\3\\6\\3\\6\\3\\6\\5\\6\\u009f\\n\\6\\3\")\n        buf.write(\"\\6\\3\\6\\5\\6\\u00a3\\n\\6\\3\\6\\3\\6\\5\\6\\u00a7\\n\\6\\3\\6\\3\\6\\3\\6\")\n        buf.write(\"\\7\\6\\u00ac\\n\\6\\f\\6\\16\\6\\u00af\\13\\6\\3\\6\\3\\6\\3\\7\\5\\7\\u00b4\")\n        buf.write(\"\\n\\7\\3\\7\\3\\7\\5\\7\\u00b8\\n\\7\\3\\7\\3\\7\\3\\7\\7\\7\\u00bd\\n\\7\\f\")\n        buf.write(\"\\7\\16\\7\\u00c0\\13\\7\\3\\7\\3\\7\\3\\7\\3\\7\\7\\7\\u00c6\\n\\7\\f\\7\\16\")\n        buf.write(\"\\7\\u00c9\\13\\7\\3\\b\\3\\b\\3\\b\\3\\b\\7\\b\\u00cf\\n\\b\\f\\b\\16\\b\\u00d2\")\n        buf.write(\"\\13\\b\\3\\t\\3\\t\\3\\t\\3\\t\\5\\t\\u00d8\\n\\t\\3\\t\\3\\t\\3\\n\\3\\n\\3\")\n        buf.write(\"\\13\\3\\13\\3\\f\\3\\f\\3\\r\\3\\r\\3\\16\\3\\16\\5\\16\\u00e6\\n\\16\\3\\17\")\n        buf.write(\"\\3\\17\\3\\20\\3\\20\\3\\21\\3\\21\\3\\21\\5\\21\\u00ef\\n\\21\\3\\22\\3\")\n        buf.write(\"\\22\\3\\22\\3\\22\\3\\22\\3\\22\\3\\22\\7\\22\\u00f8\\n\\22\\f\\22\\16\\22\")\n        buf.write(\"\\u00fb\\13\\22\\3\\23\\3\\23\\3\\23\\3\\23\\3\\24\\3\\24\\3\\24\\3\\24\\7\")\n        buf.write(\"\\24\\u0105\\n\\24\\f\\24\\16\\24\\u0108\\13\\24\\3\\24\\3\\24\\3\\24\\3\")\n        buf.write(\"\\24\\3\\24\\3\\24\\7\\24\\u0110\\n\\24\\f\\24\\16\\24\\u0113\\13\\24\\3\")\n        buf.write(\"\\24\\3\\24\\7\\24\\u0117\\n\\24\\f\\24\\16\\24\\u011a\\13\\24\\3\\24\\3\")\n        buf.write(\"\\24\\3\\24\\7\\24\\u011f\\n\\24\\f\\24\\16\\24\\u0122\\13\\24\\3\\24\\7\")\n        buf.write(\"\\24\\u0125\\n\\24\\f\\24\\16\\24\\u0128\\13\\24\\3\\25\\3\\25\\3\\25\\3\")\n        buf.write(\"\\25\\3\\25\\3\\25\\7\\25\\u0130\\n\\25\\f\\25\\16\\25\\u0133\\13\\25\\3\")\n        buf.write(\"\\25\\3\\25\\3\\26\\3\\26\\7\\26\\u0139\\n\\26\\f\\26\\16\\26\\u013c\\13\")\n        buf.write(\"\\26\\3\\26\\3\\26\\3\\26\\3\\26\\3\\26\\3\\26\\3\\27\\3\\27\\3\\27\\5\\27\")\n        buf.write(\"\\u0147\\n\\27\\3\\27\\3\\27\\7\\27\\u014b\\n\\27\\f\\27\\16\\27\\u014e\")\n        buf.write(\"\\13\\27\\3\\27\\3\\27\\3\\30\\3\\30\\5\\30\\u0154\\n\\30\\3\\30\\3\\30\\5\")\n        buf.write(\"\\30\\u0158\\n\\30\\3\\30\\6\\30\\u015b\\n\\30\\r\\30\\16\\30\\u015c\\3\")\n        buf.write(\"\\31\\3\\31\\3\\31\\3\\31\\5\\31\\u0163\\n\\31\\3\\31\\3\\31\\3\\31\\3\\31\")\n        buf.write(\"\\5\\31\\u0169\\n\\31\\7\\31\\u016b\\n\\31\\f\\31\\16\\31\\u016e\\13\\31\")\n        buf.write(\"\\3\\31\\3\\31\\3\\32\\3\\32\\3\\32\\3\\32\\3\\32\\3\\32\\3\\32\\3\\32\\3\\32\")\n        buf.write(\"\\3\\32\\3\\32\\3\\32\\5\\32\\u017e\\n\\32\\3\\33\\3\\33\\3\\33\\3\\33\\3\")\n        buf.write(\"\\33\\3\\34\\3\\34\\3\\34\\3\\34\\3\\35\\3\\35\\3\\35\\5\\35\\u018c\\n\\35\")\n        buf.write(\"\\3\\35\\3\\35\\5\\35\\u0190\\n\\35\\3\\35\\3\\35\\3\\36\\3\\36\\3\\36\\5\")\n        buf.write(\"\\36\\u0197\\n\\36\\3\\36\\3\\36\\7\\36\\u019b\\n\\36\\f\\36\\16\\36\\u019e\")\n        buf.write(\"\\13\\36\\3\\36\\3\\36\\5\\36\\u01a2\\n\\36\\3\\36\\3\\36\\3\\37\\3\\37\\3\")\n        buf.write(\"\\37\\5\\37\\u01a9\\n\\37\\3\\37\\3\\37\\5\\37\\u01ad\\n\\37\\3\\37\\3\\37\")\n        buf.write(\"\\3 \\3 \\3 \\3 \\3 \\3!\\3!\\3\\\"\\3\\\"\\3\\\"\\3\\\"\\3\\\"\\3#\\3#\\3$\\3$\")\n        buf.write(\"\\3$\\3$\\3$\\3$\\3$\\3%\\3%\\3%\\3%\\3%\\3%\\3%\\3%\\3%\\3&\\3&\\3&\\3\")\n        buf.write(\"&\\3&\\3&\\3&\\3&\\3&\\3\\'\\3\\'\\3\\'\\3\\'\\3\\'\\3\\'\\3\\'\\3(\\3(\\3(\")\n        buf.write(\"\\5(\\u01e2\\n(\\3(\\3(\\7(\\u01e6\\n(\\f(\\16(\\u01e9\\13(\\3(\\3(\")\n        buf.write(\"\\3)\\3)\\3)\\3)\\3)\\2\\3\\\"*\\2\\4\\6\\b\\n\\f\\16\\20\\22\\24\\26\\30\\32\")\n        buf.write(\"\\34\\36 \\\"$&(*,.\\60\\62\\64\\668:<>@BDFHJLNP\\2\\n\\3\\2\\31\\35\")\n        buf.write(\"\\3\\2\\67;\\3\\2\\3\\13\\3\\2\\f\\20\\4\\29;??\\4\\29;=?\\3\\2-\\60\\3\\2\")\n        buf.write(\")+\\2\\u020d\\2U\\3\\2\\2\\2\\4b\\3\\2\\2\\2\\6\\u0092\\3\\2\\2\\2\\b\\u0099\")\n        buf.write(\"\\3\\2\\2\\2\\n\\u009b\\3\\2\\2\\2\\f\\u00b3\\3\\2\\2\\2\\16\\u00ca\\3\\2\")\n        buf.write(\"\\2\\2\\20\\u00d7\\3\\2\\2\\2\\22\\u00db\\3\\2\\2\\2\\24\\u00dd\\3\\2\\2\")\n        buf.write(\"\\2\\26\\u00df\\3\\2\\2\\2\\30\\u00e1\\3\\2\\2\\2\\32\\u00e5\\3\\2\\2\\2\")\n        buf.write(\"\\34\\u00e7\\3\\2\\2\\2\\36\\u00e9\\3\\2\\2\\2 \\u00ee\\3\\2\\2\\2\\\"\\u00f0\")\n        buf.write(\"\\3\\2\\2\\2$\\u00fc\\3\\2\\2\\2&\\u0100\\3\\2\\2\\2(\\u0129\\3\\2\\2\\2\")\n        buf.write(\"*\\u0136\\3\\2\\2\\2,\\u0143\\3\\2\\2\\2.\\u0153\\3\\2\\2\\2\\60\\u015e\")\n        buf.write(\"\\3\\2\\2\\2\\62\\u017d\\3\\2\\2\\2\\64\\u017f\\3\\2\\2\\2\\66\\u0184\\3\")\n        buf.write(\"\\2\\2\\28\\u0188\\3\\2\\2\\2:\\u0193\\3\\2\\2\\2<\\u01a5\\3\\2\\2\\2>\\u01b0\")\n        buf.write(\"\\3\\2\\2\\2@\\u01b5\\3\\2\\2\\2B\\u01b7\\3\\2\\2\\2D\\u01bc\\3\\2\\2\\2\")\n        buf.write(\"F\\u01be\\3\\2\\2\\2H\\u01c5\\3\\2\\2\\2J\\u01ce\\3\\2\\2\\2L\\u01d7\\3\")\n        buf.write(\"\\2\\2\\2N\\u01de\\3\\2\\2\\2P\\u01ec\\3\\2\\2\\2RT\\5\\4\\3\\2SR\\3\\2\\2\")\n        buf.write(\"\\2TW\\3\\2\\2\\2US\\3\\2\\2\\2UV\\3\\2\\2\\2V[\\3\\2\\2\\2WU\\3\\2\\2\\2X\")\n        buf.write(\"Z\\5\\6\\4\\2YX\\3\\2\\2\\2Z]\\3\\2\\2\\2[Y\\3\\2\\2\\2[\\\\\\3\\2\\2\\2\\\\^\")\n        buf.write(\"\\3\\2\\2\\2][\\3\\2\\2\\2^_\\7\\2\\2\\3_\\3\\3\\2\\2\\2`c\\5\\24\\13\\2ac\")\n        buf.write(\"\\7<\\2\\2b`\\3\\2\\2\\2ba\\3\\2\\2\\2cd\\3\\2\\2\\2de\\7\\36\\2\\2ef\\7?\")\n        buf.write(\"\\2\\2fj\\7\\23\\2\\2gh\\5\\24\\13\\2hi\\7?\\2\\2ik\\3\\2\\2\\2jg\\3\\2\\2\")\n        buf.write(\"\\2jk\\3\\2\\2\\2kr\\3\\2\\2\\2lm\\7\\21\\2\\2mn\\5\\24\\13\\2no\\7?\\2\\2\")\n        buf.write(\"oq\\3\\2\\2\\2pl\\3\\2\\2\\2qt\\3\\2\\2\\2rp\\3\\2\\2\\2rs\\3\\2\\2\\2su\\3\")\n        buf.write(\"\\2\\2\\2tr\\3\\2\\2\\2uv\\7\\24\\2\\2vz\\7\\25\\2\\2wy\\5\\b\\5\\2xw\\3\\2\")\n        buf.write(\"\\2\\2y|\\3\\2\\2\\2zx\\3\\2\\2\\2z{\\3\\2\\2\\2{}\\3\\2\\2\\2|z\\3\\2\\2\\2\")\n        buf.write(\"}~\\7\\26\\2\\2~\\5\\3\\2\\2\\2\\177\\u0080\\5\\f\\7\\2\\u0080\\u0081\\7\")\n        buf.write(\"\\22\\2\\2\\u0081\\u0093\\3\\2\\2\\2\\u0082\\u0083\\5\\62\\32\\2\\u0083\")\n        buf.write(\"\\u0084\\7\\22\\2\\2\\u0084\\u0093\\3\\2\\2\\2\\u0085\\u0086\\5N(\\2\")\n        buf.write(\"\\u0086\\u0087\\7\\22\\2\\2\\u0087\\u0093\\3\\2\\2\\2\\u0088\\u0093\")\n        buf.write(\"\\5\\n\\6\\2\\u0089\\u0093\\5&\\24\\2\\u008a\\u0093\\5(\\25\\2\\u008b\")\n        buf.write(\"\\u0093\\5*\\26\\2\\u008c\\u008d\\5\\20\\t\\2\\u008d\\u008e\\7\\22\\2\")\n        buf.write(\"\\2\\u008e\\u0093\\3\\2\\2\\2\\u008f\\u0090\\5\\16\\b\\2\\u0090\\u0091\")\n        buf.write(\"\\7\\22\\2\\2\\u0091\\u0093\\3\\2\\2\\2\\u0092\\177\\3\\2\\2\\2\\u0092\")\n        buf.write(\"\\u0082\\3\\2\\2\\2\\u0092\\u0085\\3\\2\\2\\2\\u0092\\u0088\\3\\2\\2\\2\")\n        buf.write(\"\\u0092\\u0089\\3\\2\\2\\2\\u0092\\u008a\\3\\2\\2\\2\\u0092\\u008b\\3\")\n        buf.write(\"\\2\\2\\2\\u0092\\u008c\\3\\2\\2\\2\\u0092\\u008f\\3\\2\\2\\2\\u0093\\u0095\")\n        buf.write(\"\\3\\2\\2\\2\\u0094\\u0096\\7%\\2\\2\\u0095\\u0094\\3\\2\\2\\2\\u0095\")\n        buf.write(\"\\u0096\\3\\2\\2\\2\\u0096\\7\\3\\2\\2\\2\\u0097\\u009a\\5\\6\\4\\2\\u0098\")\n        buf.write(\"\\u009a\\5\\66\\34\\2\\u0099\\u0097\\3\\2\\2\\2\\u0099\\u0098\\3\\2\\2\")\n        buf.write(\"\\2\\u009a\\t\\3\\2\\2\\2\\u009b\\u009c\\7\\37\\2\\2\\u009c\\u009e\\7\")\n        buf.write(\"\\23\\2\\2\\u009d\\u009f\\5\\f\\7\\2\\u009e\\u009d\\3\\2\\2\\2\\u009e\")\n        buf.write(\"\\u009f\\3\\2\\2\\2\\u009f\\u00a0\\3\\2\\2\\2\\u00a0\\u00a2\\7\\22\\2\")\n        buf.write(\"\\2\\u00a1\\u00a3\\5$\\23\\2\\u00a2\\u00a1\\3\\2\\2\\2\\u00a2\\u00a3\")\n        buf.write(\"\\3\\2\\2\\2\\u00a3\\u00a4\\3\\2\\2\\2\\u00a4\\u00a6\\7\\22\\2\\2\\u00a5\")\n        buf.write(\"\\u00a7\\5\\20\\t\\2\\u00a6\\u00a5\\3\\2\\2\\2\\u00a6\\u00a7\\3\\2\\2\")\n        buf.write(\"\\2\\u00a7\\u00a8\\3\\2\\2\\2\\u00a8\\u00a9\\7\\24\\2\\2\\u00a9\\u00ad\")\n        buf.write(\"\\7\\25\\2\\2\\u00aa\\u00ac\\5\\b\\5\\2\\u00ab\\u00aa\\3\\2\\2\\2\\u00ac\")\n        buf.write(\"\\u00af\\3\\2\\2\\2\\u00ad\\u00ab\\3\\2\\2\\2\\u00ad\\u00ae\\3\\2\\2\\2\")\n        buf.write(\"\\u00ae\\u00b0\\3\\2\\2\\2\\u00af\\u00ad\\3\\2\\2\\2\\u00b0\\u00b1\\7\")\n        buf.write(\"\\26\\2\\2\\u00b1\\13\\3\\2\\2\\2\\u00b2\\u00b4\\5\\24\\13\\2\\u00b3\\u00b2\")\n        buf.write(\"\\3\\2\\2\\2\\u00b3\\u00b4\\3\\2\\2\\2\\u00b4\\u00b7\\3\\2\\2\\2\\u00b5\")\n        buf.write(\"\\u00b8\\7?\\2\\2\\u00b6\\u00b8\\5.\\30\\2\\u00b7\\u00b5\\3\\2\\2\\2\")\n        buf.write(\"\\u00b7\\u00b6\\3\\2\\2\\2\\u00b8\\u00be\\3\\2\\2\\2\\u00b9\\u00ba\\7\")\n        buf.write(\"\\21\\2\\2\\u00ba\\u00bd\\7?\\2\\2\\u00bb\\u00bd\\5.\\30\\2\\u00bc\\u00b9\")\n        buf.write(\"\\3\\2\\2\\2\\u00bc\\u00bb\\3\\2\\2\\2\\u00bd\\u00c0\\3\\2\\2\\2\\u00be\")\n        buf.write(\"\\u00bc\\3\\2\\2\\2\\u00be\\u00bf\\3\\2\\2\\2\\u00bf\\u00c1\\3\\2\\2\\2\")\n        buf.write(\"\\u00c0\\u00be\\3\\2\\2\\2\\u00c1\\u00c2\\5\\22\\n\\2\\u00c2\\u00c7\")\n        buf.write(\"\\5\\\"\\22\\2\\u00c3\\u00c4\\7\\21\\2\\2\\u00c4\\u00c6\\5\\\"\\22\\2\\u00c5\")\n        buf.write(\"\\u00c3\\3\\2\\2\\2\\u00c6\\u00c9\\3\\2\\2\\2\\u00c7\\u00c5\\3\\2\\2\\2\")\n        buf.write(\"\\u00c7\\u00c8\\3\\2\\2\\2\\u00c8\\r\\3\\2\\2\\2\\u00c9\\u00c7\\3\\2\\2\")\n        buf.write(\"\\2\\u00ca\\u00cb\\5\\24\\13\\2\\u00cb\\u00d0\\7?\\2\\2\\u00cc\\u00cd\")\n        buf.write(\"\\7\\21\\2\\2\\u00cd\\u00cf\\7?\\2\\2\\u00ce\\u00cc\\3\\2\\2\\2\\u00cf\")\n        buf.write(\"\\u00d2\\3\\2\\2\\2\\u00d0\\u00ce\\3\\2\\2\\2\\u00d0\\u00d1\\3\\2\\2\\2\")\n        buf.write(\"\\u00d1\\17\\3\\2\\2\\2\\u00d2\\u00d0\\3\\2\\2\\2\\u00d3\\u00d4\\7\\f\")\n        buf.write(\"\\2\\2\\u00d4\\u00d8\\7\\f\\2\\2\\u00d5\\u00d6\\7\\r\\2\\2\\u00d6\\u00d8\")\n        buf.write(\"\\7\\r\\2\\2\\u00d7\\u00d3\\3\\2\\2\\2\\u00d7\\u00d5\\3\\2\\2\\2\\u00d8\")\n        buf.write(\"\\u00d9\\3\\2\\2\\2\\u00d9\\u00da\\7?\\2\\2\\u00da\\21\\3\\2\\2\\2\\u00db\")\n        buf.write(\"\\u00dc\\t\\2\\2\\2\\u00dc\\23\\3\\2\\2\\2\\u00dd\\u00de\\t\\3\\2\\2\\u00de\")\n        buf.write(\"\\25\\3\\2\\2\\2\\u00df\\u00e0\\t\\4\\2\\2\\u00e0\\27\\3\\2\\2\\2\\u00e1\")\n        buf.write(\"\\u00e2\\t\\5\\2\\2\\u00e2\\31\\3\\2\\2\\2\\u00e3\\u00e6\\5\\26\\f\\2\\u00e4\")\n        buf.write(\"\\u00e6\\5\\30\\r\\2\\u00e5\\u00e3\\3\\2\\2\\2\\u00e5\\u00e4\\3\\2\\2\")\n        buf.write(\"\\2\\u00e6\\33\\3\\2\\2\\2\\u00e7\\u00e8\\t\\6\\2\\2\\u00e8\\35\\3\\2\\2\")\n        buf.write(\"\\2\\u00e9\\u00ea\\t\\7\\2\\2\\u00ea\\37\\3\\2\\2\\2\\u00eb\\u00ef\\5\")\n        buf.write(\"\\36\\20\\2\\u00ec\\u00ef\\5\\62\\32\\2\\u00ed\\u00ef\\5.\\30\\2\\u00ee\")\n        buf.write(\"\\u00eb\\3\\2\\2\\2\\u00ee\\u00ec\\3\\2\\2\\2\\u00ee\\u00ed\\3\\2\\2\\2\")\n        buf.write(\"\\u00ef!\\3\\2\\2\\2\\u00f0\\u00f1\\b\\22\\1\\2\\u00f1\\u00f2\\5 \\21\")\n        buf.write(\"\\2\\u00f2\\u00f9\\3\\2\\2\\2\\u00f3\\u00f4\\f\\3\\2\\2\\u00f4\\u00f5\")\n        buf.write(\"\\5\\32\\16\\2\\u00f5\\u00f6\\5\\\"\\22\\4\\u00f6\\u00f8\\3\\2\\2\\2\\u00f7\")\n        buf.write(\"\\u00f3\\3\\2\\2\\2\\u00f8\\u00fb\\3\\2\\2\\2\\u00f9\\u00f7\\3\\2\\2\\2\")\n        buf.write(\"\\u00f9\\u00fa\\3\\2\\2\\2\\u00fa#\\3\\2\\2\\2\\u00fb\\u00f9\\3\\2\\2\")\n        buf.write(\"\\2\\u00fc\\u00fd\\5\\\"\\22\\2\\u00fd\\u00fe\\5\\26\\f\\2\\u00fe\\u00ff\")\n        buf.write(\"\\5\\\"\\22\\2\\u00ff%\\3\\2\\2\\2\\u0100\\u0101\\7!\\2\\2\\u0101\\u0102\")\n        buf.write(\"\\5$\\23\\2\\u0102\\u0106\\7\\25\\2\\2\\u0103\\u0105\\5\\b\\5\\2\\u0104\")\n        buf.write(\"\\u0103\\3\\2\\2\\2\\u0105\\u0108\\3\\2\\2\\2\\u0106\\u0104\\3\\2\\2\\2\")\n        buf.write(\"\\u0106\\u0107\\3\\2\\2\\2\\u0107\\u0109\\3\\2\\2\\2\\u0108\\u0106\\3\")\n        buf.write(\"\\2\\2\\2\\u0109\\u0118\\7\\26\\2\\2\\u010a\\u010b\\7\\\"\\2\\2\\u010b\")\n        buf.write(\"\\u010c\\7!\\2\\2\\u010c\\u010d\\5$\\23\\2\\u010d\\u0111\\7\\25\\2\\2\")\n        buf.write(\"\\u010e\\u0110\\5\\b\\5\\2\\u010f\\u010e\\3\\2\\2\\2\\u0110\\u0113\\3\")\n        buf.write(\"\\2\\2\\2\\u0111\\u010f\\3\\2\\2\\2\\u0111\\u0112\\3\\2\\2\\2\\u0112\\u0114\")\n        buf.write(\"\\3\\2\\2\\2\\u0113\\u0111\\3\\2\\2\\2\\u0114\\u0115\\7\\26\\2\\2\\u0115\")\n        buf.write(\"\\u0117\\3\\2\\2\\2\\u0116\\u010a\\3\\2\\2\\2\\u0117\\u011a\\3\\2\\2\\2\")\n        buf.write(\"\\u0118\\u0116\\3\\2\\2\\2\\u0118\\u0119\\3\\2\\2\\2\\u0119\\u0126\\3\")\n        buf.write(\"\\2\\2\\2\\u011a\\u0118\\3\\2\\2\\2\\u011b\\u011c\\7\\\"\\2\\2\\u011c\\u0120\")\n        buf.write(\"\\7\\25\\2\\2\\u011d\\u011f\\5\\b\\5\\2\\u011e\\u011d\\3\\2\\2\\2\\u011f\")\n        buf.write(\"\\u0122\\3\\2\\2\\2\\u0120\\u011e\\3\\2\\2\\2\\u0120\\u0121\\3\\2\\2\\2\")\n        buf.write(\"\\u0121\\u0123\\3\\2\\2\\2\\u0122\\u0120\\3\\2\\2\\2\\u0123\\u0125\\7\")\n        buf.write(\"\\26\\2\\2\\u0124\\u011b\\3\\2\\2\\2\\u0125\\u0128\\3\\2\\2\\2\\u0126\")\n        buf.write(\"\\u0124\\3\\2\\2\\2\\u0126\\u0127\\3\\2\\2\\2\\u0127\\'\\3\\2\\2\\2\\u0128\")\n        buf.write(\"\\u0126\\3\\2\\2\\2\\u0129\\u012a\\7#\\2\\2\\u012a\\u012b\\7\\23\\2\\2\")\n        buf.write(\"\\u012b\\u012c\\5$\\23\\2\\u012c\\u012d\\7\\24\\2\\2\\u012d\\u0131\")\n        buf.write(\"\\7\\25\\2\\2\\u012e\\u0130\\5\\b\\5\\2\\u012f\\u012e\\3\\2\\2\\2\\u0130\")\n        buf.write(\"\\u0133\\3\\2\\2\\2\\u0131\\u012f\\3\\2\\2\\2\\u0131\\u0132\\3\\2\\2\\2\")\n        buf.write(\"\\u0132\\u0134\\3\\2\\2\\2\\u0133\\u0131\\3\\2\\2\\2\\u0134\\u0135\\7\")\n        buf.write(\"\\26\\2\\2\\u0135)\\3\\2\\2\\2\\u0136\\u013a\\7\\25\\2\\2\\u0137\\u0139\")\n        buf.write(\"\\5\\b\\5\\2\\u0138\\u0137\\3\\2\\2\\2\\u0139\\u013c\\3\\2\\2\\2\\u013a\")\n        buf.write(\"\\u0138\\3\\2\\2\\2\\u013a\\u013b\\3\\2\\2\\2\\u013b\\u013d\\3\\2\\2\\2\")\n        buf.write(\"\\u013c\\u013a\\3\\2\\2\\2\\u013d\\u013e\\7\\26\\2\\2\\u013e\\u013f\")\n        buf.write(\"\\7$\\2\\2\\u013f\\u0140\\7\\23\\2\\2\\u0140\\u0141\\5$\\23\\2\\u0141\")\n        buf.write(\"\\u0142\\7\\24\\2\\2\\u0142+\\3\\2\\2\\2\\u0143\\u0144\\7?\\2\\2\\u0144\")\n        buf.write(\"\\u0146\\7\\23\\2\\2\\u0145\\u0147\\5\\\"\\22\\2\\u0146\\u0145\\3\\2\\2\")\n        buf.write(\"\\2\\u0146\\u0147\\3\\2\\2\\2\\u0147\\u014c\\3\\2\\2\\2\\u0148\\u0149\")\n        buf.write(\"\\7\\21\\2\\2\\u0149\\u014b\\5\\\"\\22\\2\\u014a\\u0148\\3\\2\\2\\2\\u014b\")\n        buf.write(\"\\u014e\\3\\2\\2\\2\\u014c\\u014a\\3\\2\\2\\2\\u014c\\u014d\\3\\2\\2\\2\")\n        buf.write(\"\\u014d\\u014f\\3\\2\\2\\2\\u014e\\u014c\\3\\2\\2\\2\\u014f\\u0150\\7\")\n        buf.write(\"\\24\\2\\2\\u0150-\\3\\2\\2\\2\\u0151\\u0154\\5\\34\\17\\2\\u0152\\u0154\")\n        buf.write(\"\\5\\62\\32\\2\\u0153\\u0151\\3\\2\\2\\2\\u0153\\u0152\\3\\2\\2\\2\\u0154\")\n        buf.write(\"\\u015a\\3\\2\\2\\2\\u0155\\u0157\\7\\27\\2\\2\\u0156\\u0158\\5\\\"\\22\")\n        buf.write(\"\\2\\u0157\\u0156\\3\\2\\2\\2\\u0157\\u0158\\3\\2\\2\\2\\u0158\\u0159\")\n        buf.write(\"\\3\\2\\2\\2\\u0159\\u015b\\7\\30\\2\\2\\u015a\\u0155\\3\\2\\2\\2\\u015b\")\n        buf.write(\"\\u015c\\3\\2\\2\\2\\u015c\\u015a\\3\\2\\2\\2\\u015c\\u015d\\3\\2\\2\\2\")\n        buf.write(\"\\u015d/\\3\\2\\2\\2\\u015e\\u0162\\7\\27\\2\\2\\u015f\\u0163\\5\\60\")\n        buf.write(\"\\31\\2\\u0160\\u0163\\7=\\2\\2\\u0161\\u0163\\7>\\2\\2\\u0162\\u015f\")\n        buf.write(\"\\3\\2\\2\\2\\u0162\\u0160\\3\\2\\2\\2\\u0162\\u0161\\3\\2\\2\\2\\u0162\")\n        buf.write(\"\\u0163\\3\\2\\2\\2\\u0163\\u016c\\3\\2\\2\\2\\u0164\\u0168\\7\\21\\2\")\n        buf.write(\"\\2\\u0165\\u0169\\5\\60\\31\\2\\u0166\\u0169\\7=\\2\\2\\u0167\\u0169\")\n        buf.write(\"\\7>\\2\\2\\u0168\\u0165\\3\\2\\2\\2\\u0168\\u0166\\3\\2\\2\\2\\u0168\")\n        buf.write(\"\\u0167\\3\\2\\2\\2\\u0169\\u016b\\3\\2\\2\\2\\u016a\\u0164\\3\\2\\2\\2\")\n        buf.write(\"\\u016b\\u016e\\3\\2\\2\\2\\u016c\\u016a\\3\\2\\2\\2\\u016c\\u016d\\3\")\n        buf.write(\"\\2\\2\\2\\u016d\\u016f\\3\\2\\2\\2\\u016e\\u016c\\3\\2\\2\\2\\u016f\\u0170\")\n        buf.write(\"\\7\\30\\2\\2\\u0170\\61\\3\\2\\2\\2\\u0171\\u017e\\5\\64\\33\\2\\u0172\")\n        buf.write(\"\\u017e\\58\\35\\2\\u0173\\u017e\\5,\\27\\2\\u0174\\u017e\\5:\\36\\2\")\n        buf.write(\"\\u0175\\u017e\\5<\\37\\2\\u0176\\u017e\\5P)\\2\\u0177\\u017e\\5>\")\n        buf.write(\" \\2\\u0178\\u017e\\5B\\\"\\2\\u0179\\u017e\\5F$\\2\\u017a\\u017e\\5\")\n        buf.write(\"H%\\2\\u017b\\u017e\\5J&\\2\\u017c\\u017e\\5L\\'\\2\\u017d\\u0171\")\n        buf.write(\"\\3\\2\\2\\2\\u017d\\u0172\\3\\2\\2\\2\\u017d\\u0173\\3\\2\\2\\2\\u017d\")\n        buf.write(\"\\u0174\\3\\2\\2\\2\\u017d\\u0175\\3\\2\\2\\2\\u017d\\u0176\\3\\2\\2\\2\")\n        buf.write(\"\\u017d\\u0177\\3\\2\\2\\2\\u017d\\u0178\\3\\2\\2\\2\\u017d\\u0179\\3\")\n        buf.write(\"\\2\\2\\2\\u017d\\u017a\\3\\2\\2\\2\\u017d\\u017b\\3\\2\\2\\2\\u017d\\u017c\")\n        buf.write(\"\\3\\2\\2\\2\\u017e\\63\\3\\2\\2\\2\\u017f\\u0180\\7\\'\\2\\2\\u0180\\u0181\")\n        buf.write(\"\\7\\23\\2\\2\\u0181\\u0182\\5\\\"\\22\\2\\u0182\\u0183\\7\\24\\2\\2\\u0183\")\n        buf.write(\"\\65\\3\\2\\2\\2\\u0184\\u0185\\7 \\2\\2\\u0185\\u0186\\5\\\"\\22\\2\\u0186\")\n        buf.write(\"\\u0187\\7\\22\\2\\2\\u0187\\67\\3\\2\\2\\2\\u0188\\u0189\\7\\62\\2\\2\")\n        buf.write(\"\\u0189\\u018b\\7\\23\\2\\2\\u018a\\u018c\\7=\\2\\2\\u018b\\u018a\\3\")\n        buf.write(\"\\2\\2\\2\\u018b\\u018c\\3\\2\\2\\2\\u018c\\u018f\\3\\2\\2\\2\\u018d\\u018e\")\n        buf.write(\"\\7\\21\\2\\2\\u018e\\u0190\\5\\60\\31\\2\\u018f\\u018d\\3\\2\\2\\2\\u018f\")\n        buf.write(\"\\u0190\\3\\2\\2\\2\\u0190\\u0191\\3\\2\\2\\2\\u0191\\u0192\\7\\24\\2\")\n        buf.write(\"\\2\\u01929\\3\\2\\2\\2\\u0193\\u0194\\7\\63\\2\\2\\u0194\\u0196\\7\\23\")\n        buf.write(\"\\2\\2\\u0195\\u0197\\7=\\2\\2\\u0196\\u0195\\3\\2\\2\\2\\u0196\\u0197\")\n        buf.write(\"\\3\\2\\2\\2\\u0197\\u019c\\3\\2\\2\\2\\u0198\\u0199\\7\\21\\2\\2\\u0199\")\n        buf.write(\"\\u019b\\7=\\2\\2\\u019a\\u0198\\3\\2\\2\\2\\u019b\\u019e\\3\\2\\2\\2\")\n        buf.write(\"\\u019c\\u019a\\3\\2\\2\\2\\u019c\\u019d\\3\\2\\2\\2\\u019d\\u01a1\\3\")\n        buf.write(\"\\2\\2\\2\\u019e\\u019c\\3\\2\\2\\2\\u019f\\u01a0\\7\\21\\2\\2\\u01a0\")\n        buf.write(\"\\u01a2\\5\\60\\31\\2\\u01a1\\u019f\\3\\2\\2\\2\\u01a1\\u01a2\\3\\2\\2\")\n        buf.write(\"\\2\\u01a2\\u01a3\\3\\2\\2\\2\\u01a3\\u01a4\\7\\24\\2\\2\\u01a4;\\3\\2\")\n        buf.write(\"\\2\\2\\u01a5\\u01a6\\7\\64\\2\\2\\u01a6\\u01a8\\7\\23\\2\\2\\u01a7\\u01a9\")\n        buf.write(\"\\7=\\2\\2\\u01a8\\u01a7\\3\\2\\2\\2\\u01a8\\u01a9\\3\\2\\2\\2\\u01a9\")\n        buf.write(\"\\u01ac\\3\\2\\2\\2\\u01aa\\u01ab\\7\\21\\2\\2\\u01ab\\u01ad\\5\\60\\31\")\n        buf.write(\"\\2\\u01ac\\u01aa\\3\\2\\2\\2\\u01ac\\u01ad\\3\\2\\2\\2\\u01ad\\u01ae\")\n        buf.write(\"\\3\\2\\2\\2\\u01ae\\u01af\\7\\24\\2\\2\\u01af=\\3\\2\\2\\2\\u01b0\\u01b1\")\n        buf.write(\"\\7\\66\\2\\2\\u01b1\\u01b2\\7\\23\\2\\2\\u01b2\\u01b3\\7?\\2\\2\\u01b3\")\n        buf.write(\"\\u01b4\\7\\24\\2\\2\\u01b4?\\3\\2\\2\\2\\u01b5\\u01b6\\t\\b\\2\\2\\u01b6\")\n        buf.write(\"A\\3\\2\\2\\2\\u01b7\\u01b8\\5@!\\2\\u01b8\\u01b9\\7\\23\\2\\2\\u01b9\")\n        buf.write(\"\\u01ba\\5\\\"\\22\\2\\u01ba\\u01bb\\7\\24\\2\\2\\u01bbC\\3\\2\\2\\2\\u01bc\")\n        buf.write(\"\\u01bd\\t\\t\\2\\2\\u01bdE\\3\\2\\2\\2\\u01be\\u01bf\\5D#\\2\\u01bf\")\n        buf.write(\"\\u01c0\\7\\23\\2\\2\\u01c0\\u01c1\\5\\\"\\22\\2\\u01c1\\u01c2\\7\\21\")\n        buf.write(\"\\2\\2\\u01c2\\u01c3\\5\\\"\\22\\2\\u01c3\\u01c4\\7\\24\\2\\2\\u01c4G\")\n        buf.write(\"\\3\\2\\2\\2\\u01c5\\u01c6\\7(\\2\\2\\u01c6\\u01c7\\7\\23\\2\\2\\u01c7\")\n        buf.write(\"\\u01c8\\5\\\"\\22\\2\\u01c8\\u01c9\\7\\21\\2\\2\\u01c9\\u01ca\\5\\\"\\22\")\n        buf.write(\"\\2\\u01ca\\u01cb\\7\\21\\2\\2\\u01cb\\u01cc\\5\\\"\\22\\2\\u01cc\\u01cd\")\n        buf.write(\"\\7\\24\\2\\2\\u01cdI\\3\\2\\2\\2\\u01ce\\u01cf\\7,\\2\\2\\u01cf\\u01d0\")\n        buf.write(\"\\7\\23\\2\\2\\u01d0\\u01d1\\5\\\"\\22\\2\\u01d1\\u01d2\\7\\21\\2\\2\\u01d2\")\n        buf.write(\"\\u01d3\\5\\\"\\22\\2\\u01d3\\u01d4\\7\\21\\2\\2\\u01d4\\u01d5\\5\\\"\\22\")\n        buf.write(\"\\2\\u01d5\\u01d6\\7\\24\\2\\2\\u01d6K\\3\\2\\2\\2\\u01d7\\u01d8\\7\\61\")\n        buf.write(\"\\2\\2\\u01d8\\u01d9\\7\\23\\2\\2\\u01d9\\u01da\\5\\\"\\22\\2\\u01da\\u01db\")\n        buf.write(\"\\7\\21\\2\\2\\u01db\\u01dc\\5\\\"\\22\\2\\u01dc\\u01dd\\7\\24\\2\\2\\u01dd\")\n        buf.write(\"M\\3\\2\\2\\2\\u01de\\u01df\\7&\\2\\2\\u01df\\u01e1\\7\\23\\2\\2\\u01e0\")\n        buf.write(\"\\u01e2\\5\\\"\\22\\2\\u01e1\\u01e0\\3\\2\\2\\2\\u01e1\\u01e2\\3\\2\\2\")\n        buf.write(\"\\2\\u01e2\\u01e7\\3\\2\\2\\2\\u01e3\\u01e4\\7\\21\\2\\2\\u01e4\\u01e6\")\n        buf.write(\"\\5\\\"\\22\\2\\u01e5\\u01e3\\3\\2\\2\\2\\u01e6\\u01e9\\3\\2\\2\\2\\u01e7\")\n        buf.write(\"\\u01e5\\3\\2\\2\\2\\u01e7\\u01e8\\3\\2\\2\\2\\u01e8\\u01ea\\3\\2\\2\\2\")\n        buf.write(\"\\u01e9\\u01e7\\3\\2\\2\\2\\u01ea\\u01eb\\7\\24\\2\\2\\u01ebO\\3\\2\\2\")\n        buf.write(\"\\2\\u01ec\\u01ed\\7\\65\\2\\2\\u01ed\\u01ee\\7\\23\\2\\2\\u01ee\\u01ef\")\n        buf.write(\"\\7\\24\\2\\2\\u01efQ\\3\\2\\2\\2\\62U[bjrz\\u0092\\u0095\\u0099\\u009e\")\n        buf.write(\"\\u00a2\\u00a6\\u00ad\\u00b3\\u00b7\\u00bc\\u00be\\u00c7\\u00d0\")\n        buf.write(\"\\u00d7\\u00e5\\u00ee\\u00f9\\u0106\\u0111\\u0118\\u0120\\u0126\")\n        buf.write(\"\\u0131\\u013a\\u0146\\u014c\\u0153\\u0157\\u015c\\u0162\\u0168\")\n        buf.write(\"\\u016c\\u017d\\u018b\\u018f\\u0196\\u019c\\u01a1\\u01a8\\u01ac\")\n        buf.write(\"\\u01e1\\u01e7\")\n        return buf.getvalue()", "\n\nclass LangParser ( Parser ):\n\n    grammarFileName = \"LangParser.g4\"\n\n    atn = ATNDeserializer().deserialize(serializedATN())\n\n    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]\n\n    sharedContextCache = PredictionContextCache()\n\n    literalNames = [ \"<INVALID>\", \"'&'\", \"'|'\", \"'!'\", \"'=='\", \"'!='\", \"'<='\", \n                     \"'>='\", \"'<'\", \"'>'\", \"'+'\", \"'-'\", \"'/'\", \"'//'\", \n                     \"'*'\", \"','\", \"';'\", \"'('\", \"')'\", \"'{'\", \"'}'\", \"'['\", \n                     \"']'\", \"'+='\", \"'='\", \"'-='\", \"'*='\", \"'/='\", \"'function'\", \n                     \"'for'\", \"'return'\", \"'if'\", \"'else'\", \"'while'\", \"'until'\", \n                     \"<INVALID>\", \"'print'\", \"'length'\", \"'reshape'\", \"'del_col'\", \n                     \"'del_row'\", \"'del'\", \"'insert'\", \"'max'\", \"'min'\", \n                     \"'maxlen'\", \"'minlen'\", \"'find'\", \"'create_row'\", \"'create_table'\", \n                     \"'create_column'\", \"'read_string'\", \"'copy'\", \"'numb'\", \n                     \"'string'\", \"'table'\", \"'column'\", \"'row'\", \"'void'\" ]\n\n    symbolicNames = [ \"<INVALID>\", \"AND\", \"OR\", \"NOT\", \"EQUAL\", \"NOT_EQUAL\", \n                      \"LESS_EQUAL\", \"GREATER_EQUAL\", \"LESS\", \"GREATER\", \n                      \"PLUS\", \"MINUS\", \"DIV\", \"FULL_DIV\", \"MULT\", \"COMMA\", \n                      \"SEMI\", \"LPAREN\", \"RPAREN\", \"LCURLY\", \"RCURLY\", \"L_SQBRACK\", \n                      \"P_SQBRACK\", \"PLUS_EQUAL\", \"ASSIGN\", \"MINUS_EQUAL\", \n                      \"MULT_EQUAL\", \"DIV_EQUAL\", \"FUNCTION\", \"FOR\", \"RETURN\", \n                      \"IF\", \"ELSE\", \"WHILE\", \"UNTIL\", \"COMMENT\", \"PRINT\", \n                      \"LENGTH\", \"RESHAPE\", \"DEL_COL\", \"DEL_ROW\", \"DEL\", \n                      \"INSERT\", \"MAX\", \"MIN\", \"MAXLEN\", \"MINLEN\", \"FIND\", \n                      \"CREATE_ROW\", \"CREATE_TABLE\", \"CREATE_COL\", \"READ_STRING\", \n                      \"COPY\", \"NUMBER_type\", \"STRING_type\", \"TABLE\", \"COLUMN\", \n                      \"ROW\", \"VOID\", \"NUMBER\", \"STRING\", \"ID\", \"WS\", \"CONST_NUMBER\", \n                      \"CONST_STRING\" ]\n\n    RULE_program = 0\n    RULE_func = 1\n    RULE_stat = 2\n    RULE_funcStat = 3\n    RULE_forStat = 4\n    RULE_assignExpr = 5\n    RULE_varDeclStmt = 6\n    RULE_incDecrStat = 7\n    RULE_assignSign = 8\n    RULE_basicTypeName = 9\n    RULE_boolSign = 10\n    RULE_numbSign = 11\n    RULE_boolNumbSign = 12\n    RULE_iterBasicType = 13\n    RULE_basicType = 14\n    RULE_returnType = 15\n    RULE_numbExpr = 16\n    RULE_boolExpr = 17\n    RULE_ifElseStmt = 18\n    RULE_whileStmt = 19\n    RULE_untilStmt = 20\n    RULE_custFuncCall = 21\n    RULE_indexStmt = 22\n    RULE_listStmt = 23\n    RULE_builtinFuncStmt = 24\n    RULE_lengthStmt = 25\n    RULE_returnStmt = 26\n    RULE_createRowStmt = 27\n    RULE_createTablStmt = 28\n    RULE_createColStmt = 29\n    RULE_copyStmt = 30\n    RULE_minMaxFunc = 31\n    RULE_minMaxFuncStmt = 32\n    RULE_delFunc = 33\n    RULE_delFuncStmt = 34\n    RULE_reshapeStmt = 35\n    RULE_insertStmt = 36\n    RULE_findStmt = 37\n    RULE_printStmt = 38\n    RULE_readStrStmt = 39\n\n    ruleNames =  [ \"program\", \"func\", \"stat\", \"funcStat\", \"forStat\", \"assignExpr\", \n                   \"varDeclStmt\", \"incDecrStat\", \"assignSign\", \"basicTypeName\", \n                   \"boolSign\", \"numbSign\", \"boolNumbSign\", \"iterBasicType\", \n                   \"basicType\", \"returnType\", \"numbExpr\", \"boolExpr\", \"ifElseStmt\", \n                   \"whileStmt\", \"untilStmt\", \"custFuncCall\", \"indexStmt\", \n                   \"listStmt\", \"builtinFuncStmt\", \"lengthStmt\", \"returnStmt\", \n                   \"createRowStmt\", \"createTablStmt\", \"createColStmt\", \"copyStmt\", \n                   \"minMaxFunc\", \"minMaxFuncStmt\", \"delFunc\", \"delFuncStmt\", \n                   \"reshapeStmt\", \"insertStmt\", \"findStmt\", \"printStmt\", \n                   \"readStrStmt\" ]\n\n    EOF = Token.EOF\n    AND=1\n    OR=2\n    NOT=3\n    EQUAL=4\n    NOT_EQUAL=5\n    LESS_EQUAL=6\n    GREATER_EQUAL=7\n    LESS=8\n    GREATER=9\n    PLUS=10\n    MINUS=11\n    DIV=12\n    FULL_DIV=13\n    MULT=14\n    COMMA=15\n    SEMI=16\n    LPAREN=17\n    RPAREN=18\n    LCURLY=19\n    RCURLY=20\n    L_SQBRACK=21\n    P_SQBRACK=22\n    PLUS_EQUAL=23\n    ASSIGN=24\n    MINUS_EQUAL=25\n    MULT_EQUAL=26\n    DIV_EQUAL=27\n    FUNCTION=28\n    FOR=29\n    RETURN=30\n    IF=31\n    ELSE=32\n    WHILE=33\n    UNTIL=34\n    COMMENT=35\n    PRINT=36\n    LENGTH=37\n    RESHAPE=38\n    DEL_COL=39\n    DEL_ROW=40\n    DEL=41\n    INSERT=42\n    MAX=43\n    MIN=44\n    MAXLEN=45\n    MINLEN=46\n    FIND=47\n    CREATE_ROW=48\n    CREATE_TABLE=49\n    CREATE_COL=50\n    READ_STRING=51\n    COPY=52\n    NUMBER_type=53\n    STRING_type=54\n    TABLE=55\n    COLUMN=56\n    ROW=57\n    VOID=58\n    NUMBER=59\n    STRING=60\n    ID=61\n    WS=62\n    CONST_NUMBER=63\n    CONST_STRING=64\n\n    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):\n        super().__init__(input, output)\n        self.checkVersion(\"4.7.2\")\n        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)\n        self._predicates = None\n\n\n\n    class ProgramContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def EOF(self):\n            return self.getToken(LangParser.EOF, 0)\n\n        def func(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.FuncContext)\n            else:\n                return self.getTypedRuleContext(LangParser.FuncContext,i)\n\n\n        def stat(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.StatContext)\n            else:\n                return self.getTypedRuleContext(LangParser.StatContext,i)\n\n\n        def getRuleIndex(self):\n            return LangParser.RULE_program\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterProgram\" ):\n                listener.enterProgram(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitProgram\" ):\n                listener.exitProgram(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitProgram\" ):\n                return visitor.visitProgram(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def program(self):\n\n        localctx = LangParser.ProgramContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 0, self.RULE_program)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 83\n            self._errHandler.sync(self)\n            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)\n            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:\n                if _alt==1:\n                    self.state = 80\n                    self.func() \n                self.state = 85\n                self._errHandler.sync(self)\n                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)\n\n            self.state = 89\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n                self.state = 86\n                self.stat()\n                self.state = 91\n                self._errHandler.sync(self)\n                _la = self._input.LA(1)\n\n            self.state = 92\n            self.match(LangParser.EOF)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class FuncContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def FUNCTION(self):\n            return self.getToken(LangParser.FUNCTION, 0)\n\n        def ID(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.ID)\n            else:\n                return self.getToken(LangParser.ID, i)\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def LCURLY(self):\n            return self.getToken(LangParser.LCURLY, 0)\n\n        def RCURLY(self):\n            return self.getToken(LangParser.RCURLY, 0)\n\n        def basicTypeName(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.BasicTypeNameContext)\n            else:\n                return self.getTypedRuleContext(LangParser.BasicTypeNameContext,i)\n\n\n        def VOID(self):\n            return self.getToken(LangParser.VOID, 0)\n\n        def COMMA(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.COMMA)\n            else:\n                return self.getToken(LangParser.COMMA, i)\n\n        def funcStat(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.FuncStatContext)\n            else:\n                return self.getTypedRuleContext(LangParser.FuncStatContext,i)\n\n\n        def getRuleIndex(self):\n            return LangParser.RULE_func\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterFunc\" ):\n                listener.enterFunc(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitFunc\" ):\n                listener.exitFunc(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitFunc\" ):\n                return visitor.visitFunc(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def func(self):\n\n        localctx = LangParser.FuncContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 2, self.RULE_func)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 96\n            self._errHandler.sync(self)\n            token = self._input.LA(1)\n            if token in [LangParser.NUMBER_type, LangParser.STRING_type, LangParser.TABLE, LangParser.COLUMN, LangParser.ROW]:\n                self.state = 94\n                self.basicTypeName()\n                pass\n            elif token in [LangParser.VOID]:\n                self.state = 95\n                self.match(LangParser.VOID)\n                pass\n            else:\n                raise NoViableAltException(self)\n\n            self.state = 98\n            self.match(LangParser.FUNCTION)\n            self.state = 99\n            self.match(LangParser.ID)\n            self.state = 100\n            self.match(LangParser.LPAREN)\n            self.state = 104\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW))) != 0):\n                self.state = 101\n                self.basicTypeName()\n                self.state = 102\n                self.match(LangParser.ID)\n\n\n            self.state = 112\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            while _la==LangParser.COMMA:\n                self.state = 106\n                self.match(LangParser.COMMA)\n                self.state = 107\n                self.basicTypeName()\n                self.state = 108\n                self.match(LangParser.ID)\n                self.state = 114\n                self._errHandler.sync(self)\n                _la = self._input.LA(1)\n\n            self.state = 115\n            self.match(LangParser.RPAREN)\n            self.state = 116\n            self.match(LangParser.LCURLY)\n            self.state = 120\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n                self.state = 117\n                self.funcStat()\n                self.state = 122\n                self._errHandler.sync(self)\n                _la = self._input.LA(1)\n\n            self.state = 123\n            self.match(LangParser.RCURLY)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class StatContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def assignExpr(self):\n            return self.getTypedRuleContext(LangParser.AssignExprContext,0)\n\n\n        def SEMI(self):\n            return self.getToken(LangParser.SEMI, 0)\n\n        def builtinFuncStmt(self):\n            return self.getTypedRuleContext(LangParser.BuiltinFuncStmtContext,0)\n\n\n        def printStmt(self):\n            return self.getTypedRuleContext(LangParser.PrintStmtContext,0)\n\n\n        def forStat(self):\n            return self.getTypedRuleContext(LangParser.ForStatContext,0)\n\n\n        def ifElseStmt(self):\n            return self.getTypedRuleContext(LangParser.IfElseStmtContext,0)\n\n\n        def whileStmt(self):\n            return self.getTypedRuleContext(LangParser.WhileStmtContext,0)\n\n\n        def untilStmt(self):\n            return self.getTypedRuleContext(LangParser.UntilStmtContext,0)\n\n\n        def incDecrStat(self):\n            return self.getTypedRuleContext(LangParser.IncDecrStatContext,0)\n\n\n        def varDeclStmt(self):\n            return self.getTypedRuleContext(LangParser.VarDeclStmtContext,0)\n\n\n        def COMMENT(self):\n            return self.getToken(LangParser.COMMENT, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_stat\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterStat\" ):\n                listener.enterStat(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitStat\" ):\n                listener.exitStat(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitStat\" ):\n                return visitor.visitStat(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def stat(self):\n\n        localctx = LangParser.StatContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 4, self.RULE_stat)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 144\n            self._errHandler.sync(self)\n            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)\n            if la_ == 1:\n                self.state = 125\n                self.assignExpr()\n                self.state = 126\n                self.match(LangParser.SEMI)\n                pass\n\n            elif la_ == 2:\n                self.state = 128\n                self.builtinFuncStmt()\n                self.state = 129\n                self.match(LangParser.SEMI)\n                pass\n\n            elif la_ == 3:\n                self.state = 131\n                self.printStmt()\n                self.state = 132\n                self.match(LangParser.SEMI)\n                pass\n\n            elif la_ == 4:\n                self.state = 134\n                self.forStat()\n                pass\n\n            elif la_ == 5:\n                self.state = 135\n                self.ifElseStmt()\n                pass\n\n            elif la_ == 6:\n                self.state = 136\n                self.whileStmt()\n                pass\n\n            elif la_ == 7:\n                self.state = 137\n                self.untilStmt()\n                pass\n\n            elif la_ == 8:\n                self.state = 138\n                self.incDecrStat()\n                self.state = 139\n                self.match(LangParser.SEMI)\n                pass\n\n            elif la_ == 9:\n                self.state = 141\n                self.varDeclStmt()\n                self.state = 142\n                self.match(LangParser.SEMI)\n                pass\n\n\n            self.state = 147\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            if _la==LangParser.COMMENT:\n                self.state = 146\n                self.match(LangParser.COMMENT)\n\n\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class FuncStatContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def stat(self):\n            return self.getTypedRuleContext(LangParser.StatContext,0)\n\n\n        def returnStmt(self):\n            return self.getTypedRuleContext(LangParser.ReturnStmtContext,0)\n\n\n        def getRuleIndex(self):\n            return LangParser.RULE_funcStat\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterFuncStat\" ):\n                listener.enterFuncStat(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitFuncStat\" ):\n                listener.exitFuncStat(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitFuncStat\" ):\n                return visitor.visitFuncStat(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def funcStat(self):\n\n        localctx = LangParser.FuncStatContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 6, self.RULE_funcStat)\n        try:\n            self.state = 151\n            self._errHandler.sync(self)\n            token = self._input.LA(1)\n            if token in [LangParser.PLUS, LangParser.MINUS, LangParser.LCURLY, LangParser.FOR, LangParser.IF, LangParser.WHILE, LangParser.PRINT, LangParser.LENGTH, LangParser.RESHAPE, LangParser.DEL_COL, LangParser.DEL_ROW, LangParser.DEL, LangParser.INSERT, LangParser.MAX, LangParser.MIN, LangParser.MAXLEN, LangParser.MINLEN, LangParser.FIND, LangParser.CREATE_ROW, LangParser.CREATE_TABLE, LangParser.CREATE_COL, LangParser.READ_STRING, LangParser.COPY, LangParser.NUMBER_type, LangParser.STRING_type, LangParser.TABLE, LangParser.COLUMN, LangParser.ROW, LangParser.ID]:\n                self.enterOuterAlt(localctx, 1)\n                self.state = 149\n                self.stat()\n                pass\n            elif token in [LangParser.RETURN]:\n                self.enterOuterAlt(localctx, 2)\n                self.state = 150\n                self.returnStmt()\n                pass\n            else:\n                raise NoViableAltException(self)\n\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class ForStatContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def FOR(self):\n            return self.getToken(LangParser.FOR, 0)\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def SEMI(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.SEMI)\n            else:\n                return self.getToken(LangParser.SEMI, i)\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def LCURLY(self):\n            return self.getToken(LangParser.LCURLY, 0)\n\n        def RCURLY(self):\n            return self.getToken(LangParser.RCURLY, 0)\n\n        def assignExpr(self):\n            return self.getTypedRuleContext(LangParser.AssignExprContext,0)\n\n\n        def boolExpr(self):\n            return self.getTypedRuleContext(LangParser.BoolExprContext,0)\n\n\n        def incDecrStat(self):\n            return self.getTypedRuleContext(LangParser.IncDecrStatContext,0)\n\n\n        def funcStat(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.FuncStatContext)\n            else:\n                return self.getTypedRuleContext(LangParser.FuncStatContext,i)\n\n\n        def getRuleIndex(self):\n            return LangParser.RULE_forStat\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterForStat\" ):\n                listener.enterForStat(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitForStat\" ):\n                listener.exitForStat(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitForStat\" ):\n                return visitor.visitForStat(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def forStat(self):\n\n        localctx = LangParser.ForStatContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 8, self.RULE_forStat)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 153\n            self.match(LangParser.FOR)\n            self.state = 154\n            self.match(LangParser.LPAREN)\n            self.state = 156\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n                self.state = 155\n                self.assignExpr()\n\n\n            self.state = 158\n            self.match(LangParser.SEMI)\n            self.state = 160\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.NUMBER) | (1 << LangParser.STRING) | (1 << LangParser.ID))) != 0):\n                self.state = 159\n                self.boolExpr()\n\n\n            self.state = 162\n            self.match(LangParser.SEMI)\n            self.state = 164\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            if _la==LangParser.PLUS or _la==LangParser.MINUS:\n                self.state = 163\n                self.incDecrStat()\n\n\n            self.state = 166\n            self.match(LangParser.RPAREN)\n            self.state = 167\n            self.match(LangParser.LCURLY)\n            self.state = 171\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n                self.state = 168\n                self.funcStat()\n                self.state = 173\n                self._errHandler.sync(self)\n                _la = self._input.LA(1)\n\n            self.state = 174\n            self.match(LangParser.RCURLY)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class AssignExprContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def assignSign(self):\n            return self.getTypedRuleContext(LangParser.AssignSignContext,0)\n\n\n        def numbExpr(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n            else:\n                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\n\n        def ID(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.ID)\n            else:\n                return self.getToken(LangParser.ID, i)\n\n        def indexStmt(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.IndexStmtContext)\n            else:\n                return self.getTypedRuleContext(LangParser.IndexStmtContext,i)\n\n\n        def basicTypeName(self):\n            return self.getTypedRuleContext(LangParser.BasicTypeNameContext,0)\n\n\n        def COMMA(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.COMMA)\n            else:\n                return self.getToken(LangParser.COMMA, i)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_assignExpr\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterAssignExpr\" ):\n                listener.enterAssignExpr(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitAssignExpr\" ):\n                listener.exitAssignExpr(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitAssignExpr\" ):\n                return visitor.visitAssignExpr(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def assignExpr(self):\n\n        localctx = LangParser.AssignExprContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 10, self.RULE_assignExpr)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 177\n            self._errHandler.sync(self)\n            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)\n            if la_ == 1:\n                self.state = 176\n                self.basicTypeName()\n\n\n            self.state = 181\n            self._errHandler.sync(self)\n            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)\n            if la_ == 1:\n                self.state = 179\n                self.match(LangParser.ID)\n                pass\n\n            elif la_ == 2:\n                self.state = 180\n                self.indexStmt()\n                pass\n\n\n            self.state = 188\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.COMMA) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n                self.state = 186\n                self._errHandler.sync(self)\n                token = self._input.LA(1)\n                if token in [LangParser.COMMA]:\n                    self.state = 183\n                    self.match(LangParser.COMMA)\n                    self.state = 184\n                    self.match(LangParser.ID)\n                    pass\n                elif token in [LangParser.LENGTH, LangParser.RESHAPE, LangParser.DEL_COL, LangParser.DEL_ROW, LangParser.DEL, LangParser.INSERT, LangParser.MAX, LangParser.MIN, LangParser.MAXLEN, LangParser.MINLEN, LangParser.FIND, LangParser.CREATE_ROW, LangParser.CREATE_TABLE, LangParser.CREATE_COL, LangParser.READ_STRING, LangParser.COPY, LangParser.TABLE, LangParser.COLUMN, LangParser.ROW, LangParser.ID]:\n                    self.state = 185\n                    self.indexStmt()\n                    pass\n                else:\n                    raise NoViableAltException(self)\n\n                self.state = 190\n                self._errHandler.sync(self)\n                _la = self._input.LA(1)\n\n            self.state = 191\n            self.assignSign()\n            self.state = 192\n            self.numbExpr(0)\n            self.state = 197\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            while _la==LangParser.COMMA:\n                self.state = 193\n                self.match(LangParser.COMMA)\n                self.state = 194\n                self.numbExpr(0)\n                self.state = 199\n                self._errHandler.sync(self)\n                _la = self._input.LA(1)\n\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class VarDeclStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def basicTypeName(self):\n            return self.getTypedRuleContext(LangParser.BasicTypeNameContext,0)\n\n\n        def ID(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.ID)\n            else:\n                return self.getToken(LangParser.ID, i)\n\n        def COMMA(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.COMMA)\n            else:\n                return self.getToken(LangParser.COMMA, i)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_varDeclStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterVarDeclStmt\" ):\n                listener.enterVarDeclStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitVarDeclStmt\" ):\n                listener.exitVarDeclStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitVarDeclStmt\" ):\n                return visitor.visitVarDeclStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def varDeclStmt(self):\n\n        localctx = LangParser.VarDeclStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 12, self.RULE_varDeclStmt)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 200\n            self.basicTypeName()\n            self.state = 201\n            self.match(LangParser.ID)\n            self.state = 206\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            while _la==LangParser.COMMA:\n                self.state = 202\n                self.match(LangParser.COMMA)\n                self.state = 203\n                self.match(LangParser.ID)\n                self.state = 208\n                self._errHandler.sync(self)\n                _la = self._input.LA(1)\n\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class IncDecrStatContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def ID(self):\n            return self.getToken(LangParser.ID, 0)\n\n        def PLUS(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.PLUS)\n            else:\n                return self.getToken(LangParser.PLUS, i)\n\n        def MINUS(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.MINUS)\n            else:\n                return self.getToken(LangParser.MINUS, i)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_incDecrStat\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterIncDecrStat\" ):\n                listener.enterIncDecrStat(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitIncDecrStat\" ):\n                listener.exitIncDecrStat(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitIncDecrStat\" ):\n                return visitor.visitIncDecrStat(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def incDecrStat(self):\n\n        localctx = LangParser.IncDecrStatContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 14, self.RULE_incDecrStat)\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 213\n            self._errHandler.sync(self)\n            token = self._input.LA(1)\n            if token in [LangParser.PLUS]:\n                self.state = 209\n                self.match(LangParser.PLUS)\n                self.state = 210\n                self.match(LangParser.PLUS)\n                pass\n            elif token in [LangParser.MINUS]:\n                self.state = 211\n                self.match(LangParser.MINUS)\n                self.state = 212\n                self.match(LangParser.MINUS)\n                pass\n            else:\n                raise NoViableAltException(self)\n\n            self.state = 215\n            self.match(LangParser.ID)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class AssignSignContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def ASSIGN(self):\n            return self.getToken(LangParser.ASSIGN, 0)\n\n        def PLUS_EQUAL(self):\n            return self.getToken(LangParser.PLUS_EQUAL, 0)\n\n        def MINUS_EQUAL(self):\n            return self.getToken(LangParser.MINUS_EQUAL, 0)\n\n        def MULT_EQUAL(self):\n            return self.getToken(LangParser.MULT_EQUAL, 0)\n\n        def DIV_EQUAL(self):\n            return self.getToken(LangParser.DIV_EQUAL, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_assignSign\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterAssignSign\" ):\n                listener.enterAssignSign(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitAssignSign\" ):\n                listener.exitAssignSign(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitAssignSign\" ):\n                return visitor.visitAssignSign(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def assignSign(self):\n\n        localctx = LangParser.AssignSignContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 16, self.RULE_assignSign)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 217\n            _la = self._input.LA(1)\n            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS_EQUAL) | (1 << LangParser.ASSIGN) | (1 << LangParser.MINUS_EQUAL) | (1 << LangParser.MULT_EQUAL) | (1 << LangParser.DIV_EQUAL))) != 0)):\n                self._errHandler.recoverInline(self)\n            else:\n                self._errHandler.reportMatch(self)\n                self.consume()\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class BasicTypeNameContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def NUMBER_type(self):\n            return self.getToken(LangParser.NUMBER_type, 0)\n\n        def STRING_type(self):\n            return self.getToken(LangParser.STRING_type, 0)\n\n        def COLUMN(self):\n            return self.getToken(LangParser.COLUMN, 0)\n\n        def ROW(self):\n            return self.getToken(LangParser.ROW, 0)\n\n        def TABLE(self):\n            return self.getToken(LangParser.TABLE, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_basicTypeName\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterBasicTypeName\" ):\n                listener.enterBasicTypeName(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitBasicTypeName\" ):\n                listener.exitBasicTypeName(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitBasicTypeName\" ):\n                return visitor.visitBasicTypeName(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def basicTypeName(self):\n\n        localctx = LangParser.BasicTypeNameContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 18, self.RULE_basicTypeName)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 219\n            _la = self._input.LA(1)\n            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW))) != 0)):\n                self._errHandler.recoverInline(self)\n            else:\n                self._errHandler.reportMatch(self)\n                self.consume()\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class BoolSignContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def EQUAL(self):\n            return self.getToken(LangParser.EQUAL, 0)\n\n        def NOT_EQUAL(self):\n            return self.getToken(LangParser.NOT_EQUAL, 0)\n\n        def LESS_EQUAL(self):\n            return self.getToken(LangParser.LESS_EQUAL, 0)\n\n        def GREATER_EQUAL(self):\n            return self.getToken(LangParser.GREATER_EQUAL, 0)\n\n        def LESS(self):\n            return self.getToken(LangParser.LESS, 0)\n\n        def GREATER(self):\n            return self.getToken(LangParser.GREATER, 0)\n\n        def AND(self):\n            return self.getToken(LangParser.AND, 0)\n\n        def OR(self):\n            return self.getToken(LangParser.OR, 0)\n\n        def NOT(self):\n            return self.getToken(LangParser.NOT, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_boolSign\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterBoolSign\" ):\n                listener.enterBoolSign(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitBoolSign\" ):\n                listener.exitBoolSign(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitBoolSign\" ):\n                return visitor.visitBoolSign(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def boolSign(self):\n\n        localctx = LangParser.BoolSignContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 20, self.RULE_boolSign)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 221\n            _la = self._input.LA(1)\n            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.AND) | (1 << LangParser.OR) | (1 << LangParser.NOT) | (1 << LangParser.EQUAL) | (1 << LangParser.NOT_EQUAL) | (1 << LangParser.LESS_EQUAL) | (1 << LangParser.GREATER_EQUAL) | (1 << LangParser.LESS) | (1 << LangParser.GREATER))) != 0)):\n                self._errHandler.recoverInline(self)\n            else:\n                self._errHandler.reportMatch(self)\n                self.consume()\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class NumbSignContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def PLUS(self):\n            return self.getToken(LangParser.PLUS, 0)\n\n        def MINUS(self):\n            return self.getToken(LangParser.MINUS, 0)\n\n        def DIV(self):\n            return self.getToken(LangParser.DIV, 0)\n\n        def FULL_DIV(self):\n            return self.getToken(LangParser.FULL_DIV, 0)\n\n        def MULT(self):\n            return self.getToken(LangParser.MULT, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_numbSign\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterNumbSign\" ):\n                listener.enterNumbSign(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitNumbSign\" ):\n                listener.exitNumbSign(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitNumbSign\" ):\n                return visitor.visitNumbSign(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def numbSign(self):\n\n        localctx = LangParser.NumbSignContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 22, self.RULE_numbSign)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 223\n            _la = self._input.LA(1)\n            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.DIV) | (1 << LangParser.FULL_DIV) | (1 << LangParser.MULT))) != 0)):\n                self._errHandler.recoverInline(self)\n            else:\n                self._errHandler.reportMatch(self)\n                self.consume()\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class BoolNumbSignContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def boolSign(self):\n            return self.getTypedRuleContext(LangParser.BoolSignContext,0)\n\n\n        def numbSign(self):\n            return self.getTypedRuleContext(LangParser.NumbSignContext,0)\n\n\n        def getRuleIndex(self):\n            return LangParser.RULE_boolNumbSign\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterBoolNumbSign\" ):\n                listener.enterBoolNumbSign(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitBoolNumbSign\" ):\n                listener.exitBoolNumbSign(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitBoolNumbSign\" ):\n                return visitor.visitBoolNumbSign(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def boolNumbSign(self):\n\n        localctx = LangParser.BoolNumbSignContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 24, self.RULE_boolNumbSign)\n        try:\n            self.state = 227\n            self._errHandler.sync(self)\n            token = self._input.LA(1)\n            if token in [LangParser.AND, LangParser.OR, LangParser.NOT, LangParser.EQUAL, LangParser.NOT_EQUAL, LangParser.LESS_EQUAL, LangParser.GREATER_EQUAL, LangParser.LESS, LangParser.GREATER]:\n                self.enterOuterAlt(localctx, 1)\n                self.state = 225\n                self.boolSign()\n                pass\n            elif token in [LangParser.PLUS, LangParser.MINUS, LangParser.DIV, LangParser.FULL_DIV, LangParser.MULT]:\n                self.enterOuterAlt(localctx, 2)\n                self.state = 226\n                self.numbSign()\n                pass\n            else:\n                raise NoViableAltException(self)\n\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class IterBasicTypeContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def ID(self):\n            return self.getToken(LangParser.ID, 0)\n\n        def COLUMN(self):\n            return self.getToken(LangParser.COLUMN, 0)\n\n        def ROW(self):\n            return self.getToken(LangParser.ROW, 0)\n\n        def TABLE(self):\n            return self.getToken(LangParser.TABLE, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_iterBasicType\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterIterBasicType\" ):\n                listener.enterIterBasicType(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitIterBasicType\" ):\n                listener.exitIterBasicType(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitIterBasicType\" ):\n                return visitor.visitIterBasicType(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def iterBasicType(self):\n\n        localctx = LangParser.IterBasicTypeContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 26, self.RULE_iterBasicType)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 229\n            _la = self._input.LA(1)\n            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0)):\n                self._errHandler.recoverInline(self)\n            else:\n                self._errHandler.reportMatch(self)\n                self.consume()\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class BasicTypeContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def ID(self):\n            return self.getToken(LangParser.ID, 0)\n\n        def NUMBER(self):\n            return self.getToken(LangParser.NUMBER, 0)\n\n        def STRING(self):\n            return self.getToken(LangParser.STRING, 0)\n\n        def COLUMN(self):\n            return self.getToken(LangParser.COLUMN, 0)\n\n        def ROW(self):\n            return self.getToken(LangParser.ROW, 0)\n\n        def TABLE(self):\n            return self.getToken(LangParser.TABLE, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_basicType\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterBasicType\" ):\n                listener.enterBasicType(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitBasicType\" ):\n                listener.exitBasicType(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitBasicType\" ):\n                return visitor.visitBasicType(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def basicType(self):\n\n        localctx = LangParser.BasicTypeContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 28, self.RULE_basicType)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 231\n            _la = self._input.LA(1)\n            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.NUMBER) | (1 << LangParser.STRING) | (1 << LangParser.ID))) != 0)):\n                self._errHandler.recoverInline(self)\n            else:\n                self._errHandler.reportMatch(self)\n                self.consume()\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class ReturnTypeContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def basicType(self):\n            return self.getTypedRuleContext(LangParser.BasicTypeContext,0)\n\n\n        def builtinFuncStmt(self):\n            return self.getTypedRuleContext(LangParser.BuiltinFuncStmtContext,0)\n\n\n        def indexStmt(self):\n            return self.getTypedRuleContext(LangParser.IndexStmtContext,0)\n\n\n        def getRuleIndex(self):\n            return LangParser.RULE_returnType\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterReturnType\" ):\n                listener.enterReturnType(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitReturnType\" ):\n                listener.exitReturnType(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitReturnType\" ):\n                return visitor.visitReturnType(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def returnType(self):\n\n        localctx = LangParser.ReturnTypeContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 30, self.RULE_returnType)\n        try:\n            self.state = 236\n            self._errHandler.sync(self)\n            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)\n            if la_ == 1:\n                self.enterOuterAlt(localctx, 1)\n                self.state = 233\n                self.basicType()\n                pass\n\n            elif la_ == 2:\n                self.enterOuterAlt(localctx, 2)\n                self.state = 234\n                self.builtinFuncStmt()\n                pass\n\n            elif la_ == 3:\n                self.enterOuterAlt(localctx, 3)\n                self.state = 235\n                self.indexStmt()\n                pass\n\n\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class NumbExprContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def returnType(self):\n            return self.getTypedRuleContext(LangParser.ReturnTypeContext,0)\n\n\n        def numbExpr(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n            else:\n                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\n\n        def boolNumbSign(self):\n            return self.getTypedRuleContext(LangParser.BoolNumbSignContext,0)\n\n\n        def getRuleIndex(self):\n            return LangParser.RULE_numbExpr\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterNumbExpr\" ):\n                listener.enterNumbExpr(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitNumbExpr\" ):\n                listener.exitNumbExpr(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitNumbExpr\" ):\n                return visitor.visitNumbExpr(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n    def numbExpr(self, _p:int=0):\n        _parentctx = self._ctx\n        _parentState = self.state\n        localctx = LangParser.NumbExprContext(self, self._ctx, _parentState)\n        _prevctx = localctx\n        _startState = 32\n        self.enterRecursionRule(localctx, 32, self.RULE_numbExpr, _p)\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 239\n            self.returnType()\n            self._ctx.stop = self._input.LT(-1)\n            self.state = 247\n            self._errHandler.sync(self)\n            _alt = self._interp.adaptivePredict(self._input,22,self._ctx)\n            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:\n                if _alt==1:\n                    if self._parseListeners is not None:\n                        self.triggerExitRuleEvent()\n                    _prevctx = localctx\n                    localctx = LangParser.NumbExprContext(self, _parentctx, _parentState)\n                    self.pushNewRecursionContext(localctx, _startState, self.RULE_numbExpr)\n                    self.state = 241\n                    if not self.precpred(self._ctx, 1):\n                        from antlr4.error.Errors import FailedPredicateException\n                        raise FailedPredicateException(self, \"self.precpred(self._ctx, 1)\")\n                    self.state = 242\n                    self.boolNumbSign()\n                    self.state = 243\n                    self.numbExpr(2) \n                self.state = 249\n                self._errHandler.sync(self)\n                _alt = self._interp.adaptivePredict(self._input,22,self._ctx)\n\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.unrollRecursionContexts(_parentctx)\n        return localctx\n\n    class BoolExprContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def numbExpr(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n            else:\n                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\n\n        def boolSign(self):\n            return self.getTypedRuleContext(LangParser.BoolSignContext,0)\n\n\n        def getRuleIndex(self):\n            return LangParser.RULE_boolExpr\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterBoolExpr\" ):\n                listener.enterBoolExpr(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitBoolExpr\" ):\n                listener.exitBoolExpr(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitBoolExpr\" ):\n                return visitor.visitBoolExpr(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def boolExpr(self):\n\n        localctx = LangParser.BoolExprContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 34, self.RULE_boolExpr)\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 250\n            self.numbExpr(0)\n            self.state = 251\n            self.boolSign()\n            self.state = 252\n            self.numbExpr(0)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class IfElseStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def IF(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.IF)\n            else:\n                return self.getToken(LangParser.IF, i)\n\n        def boolExpr(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.BoolExprContext)\n            else:\n                return self.getTypedRuleContext(LangParser.BoolExprContext,i)\n\n\n        def LCURLY(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.LCURLY)\n            else:\n                return self.getToken(LangParser.LCURLY, i)\n\n        def RCURLY(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.RCURLY)\n            else:\n                return self.getToken(LangParser.RCURLY, i)\n\n        def funcStat(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.FuncStatContext)\n            else:\n                return self.getTypedRuleContext(LangParser.FuncStatContext,i)\n\n\n        def ELSE(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.ELSE)\n            else:\n                return self.getToken(LangParser.ELSE, i)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_ifElseStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterIfElseStmt\" ):\n                listener.enterIfElseStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitIfElseStmt\" ):\n                listener.exitIfElseStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitIfElseStmt\" ):\n                return visitor.visitIfElseStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def ifElseStmt(self):\n\n        localctx = LangParser.IfElseStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 36, self.RULE_ifElseStmt)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 254\n            self.match(LangParser.IF)\n            self.state = 255\n            self.boolExpr()\n            self.state = 256\n            self.match(LangParser.LCURLY)\n            self.state = 260\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n                self.state = 257\n                self.funcStat()\n                self.state = 262\n                self._errHandler.sync(self)\n                _la = self._input.LA(1)\n\n            self.state = 263\n            self.match(LangParser.RCURLY)\n            self.state = 278\n            self._errHandler.sync(self)\n            _alt = self._interp.adaptivePredict(self._input,25,self._ctx)\n            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:\n                if _alt==1:\n                    self.state = 264\n                    self.match(LangParser.ELSE)\n                    self.state = 265\n                    self.match(LangParser.IF)\n                    self.state = 266\n                    self.boolExpr()\n                    self.state = 267\n                    self.match(LangParser.LCURLY)\n                    self.state = 271\n                    self._errHandler.sync(self)\n                    _la = self._input.LA(1)\n                    while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n                        self.state = 268\n                        self.funcStat()\n                        self.state = 273\n                        self._errHandler.sync(self)\n                        _la = self._input.LA(1)\n\n                    self.state = 274\n                    self.match(LangParser.RCURLY) \n                self.state = 280\n                self._errHandler.sync(self)\n                _alt = self._interp.adaptivePredict(self._input,25,self._ctx)\n\n            self.state = 292\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            while _la==LangParser.ELSE:\n                self.state = 281\n                self.match(LangParser.ELSE)\n                self.state = 282\n                self.match(LangParser.LCURLY)\n                self.state = 286\n                self._errHandler.sync(self)\n                _la = self._input.LA(1)\n                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n                    self.state = 283\n                    self.funcStat()\n                    self.state = 288\n                    self._errHandler.sync(self)\n                    _la = self._input.LA(1)\n\n                self.state = 289\n                self.match(LangParser.RCURLY)\n                self.state = 294\n                self._errHandler.sync(self)\n                _la = self._input.LA(1)\n\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class WhileStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def WHILE(self):\n            return self.getToken(LangParser.WHILE, 0)\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def boolExpr(self):\n            return self.getTypedRuleContext(LangParser.BoolExprContext,0)\n\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def LCURLY(self):\n            return self.getToken(LangParser.LCURLY, 0)\n\n        def RCURLY(self):\n            return self.getToken(LangParser.RCURLY, 0)\n\n        def funcStat(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.FuncStatContext)\n            else:\n                return self.getTypedRuleContext(LangParser.FuncStatContext,i)\n\n\n        def getRuleIndex(self):\n            return LangParser.RULE_whileStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterWhileStmt\" ):\n                listener.enterWhileStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitWhileStmt\" ):\n                listener.exitWhileStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitWhileStmt\" ):\n                return visitor.visitWhileStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def whileStmt(self):\n\n        localctx = LangParser.WhileStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 38, self.RULE_whileStmt)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 295\n            self.match(LangParser.WHILE)\n            self.state = 296\n            self.match(LangParser.LPAREN)\n            self.state = 297\n            self.boolExpr()\n            self.state = 298\n            self.match(LangParser.RPAREN)\n            self.state = 299\n            self.match(LangParser.LCURLY)\n            self.state = 303\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n                self.state = 300\n                self.funcStat()\n                self.state = 305\n                self._errHandler.sync(self)\n                _la = self._input.LA(1)\n\n            self.state = 306\n            self.match(LangParser.RCURLY)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class UntilStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def LCURLY(self):\n            return self.getToken(LangParser.LCURLY, 0)\n\n        def RCURLY(self):\n            return self.getToken(LangParser.RCURLY, 0)\n\n        def UNTIL(self):\n            return self.getToken(LangParser.UNTIL, 0)\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def boolExpr(self):\n            return self.getTypedRuleContext(LangParser.BoolExprContext,0)\n\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def funcStat(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.FuncStatContext)\n            else:\n                return self.getTypedRuleContext(LangParser.FuncStatContext,i)\n\n\n        def getRuleIndex(self):\n            return LangParser.RULE_untilStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterUntilStmt\" ):\n                listener.enterUntilStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitUntilStmt\" ):\n                listener.exitUntilStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitUntilStmt\" ):\n                return visitor.visitUntilStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def untilStmt(self):\n\n        localctx = LangParser.UntilStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 40, self.RULE_untilStmt)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 308\n            self.match(LangParser.LCURLY)\n            self.state = 312\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n                self.state = 309\n                self.funcStat()\n                self.state = 314\n                self._errHandler.sync(self)\n                _la = self._input.LA(1)\n\n            self.state = 315\n            self.match(LangParser.RCURLY)\n            self.state = 316\n            self.match(LangParser.UNTIL)\n            self.state = 317\n            self.match(LangParser.LPAREN)\n            self.state = 318\n            self.boolExpr()\n            self.state = 319\n            self.match(LangParser.RPAREN)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class CustFuncCallContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def ID(self):\n            return self.getToken(LangParser.ID, 0)\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def numbExpr(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n            else:\n                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\n\n        def COMMA(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.COMMA)\n            else:\n                return self.getToken(LangParser.COMMA, i)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_custFuncCall\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterCustFuncCall\" ):\n                listener.enterCustFuncCall(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitCustFuncCall\" ):\n                listener.exitCustFuncCall(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitCustFuncCall\" ):\n                return visitor.visitCustFuncCall(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def custFuncCall(self):\n\n        localctx = LangParser.CustFuncCallContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 42, self.RULE_custFuncCall)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 321\n            self.match(LangParser.ID)\n            self.state = 322\n            self.match(LangParser.LPAREN)\n            self.state = 324\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.NUMBER) | (1 << LangParser.STRING) | (1 << LangParser.ID))) != 0):\n                self.state = 323\n                self.numbExpr(0)\n\n\n            self.state = 330\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            while _la==LangParser.COMMA:\n                self.state = 326\n                self.match(LangParser.COMMA)\n                self.state = 327\n                self.numbExpr(0)\n                self.state = 332\n                self._errHandler.sync(self)\n                _la = self._input.LA(1)\n\n            self.state = 333\n            self.match(LangParser.RPAREN)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class IndexStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def iterBasicType(self):\n            return self.getTypedRuleContext(LangParser.IterBasicTypeContext,0)\n\n\n        def builtinFuncStmt(self):\n            return self.getTypedRuleContext(LangParser.BuiltinFuncStmtContext,0)\n\n\n        def L_SQBRACK(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.L_SQBRACK)\n            else:\n                return self.getToken(LangParser.L_SQBRACK, i)\n\n        def P_SQBRACK(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.P_SQBRACK)\n            else:\n                return self.getToken(LangParser.P_SQBRACK, i)\n\n        def numbExpr(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n            else:\n                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\n\n        def getRuleIndex(self):\n            return LangParser.RULE_indexStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterIndexStmt\" ):\n                listener.enterIndexStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitIndexStmt\" ):\n                listener.exitIndexStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitIndexStmt\" ):\n                return visitor.visitIndexStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def indexStmt(self):\n\n        localctx = LangParser.IndexStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 44, self.RULE_indexStmt)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 337\n            self._errHandler.sync(self)\n            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)\n            if la_ == 1:\n                self.state = 335\n                self.iterBasicType()\n                pass\n\n            elif la_ == 2:\n                self.state = 336\n                self.builtinFuncStmt()\n                pass\n\n\n            self.state = 344 \n            self._errHandler.sync(self)\n            _alt = 1\n            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:\n                if _alt == 1:\n                    self.state = 339\n                    self.match(LangParser.L_SQBRACK)\n                    self.state = 341\n                    self._errHandler.sync(self)\n                    _la = self._input.LA(1)\n                    if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.NUMBER) | (1 << LangParser.STRING) | (1 << LangParser.ID))) != 0):\n                        self.state = 340\n                        self.numbExpr(0)\n\n\n                    self.state = 343\n                    self.match(LangParser.P_SQBRACK)\n\n                else:\n                    raise NoViableAltException(self)\n                self.state = 346 \n                self._errHandler.sync(self)\n                _alt = self._interp.adaptivePredict(self._input,34,self._ctx)\n\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class ListStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def L_SQBRACK(self):\n            return self.getToken(LangParser.L_SQBRACK, 0)\n\n        def P_SQBRACK(self):\n            return self.getToken(LangParser.P_SQBRACK, 0)\n\n        def listStmt(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.ListStmtContext)\n            else:\n                return self.getTypedRuleContext(LangParser.ListStmtContext,i)\n\n\n        def NUMBER(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.NUMBER)\n            else:\n                return self.getToken(LangParser.NUMBER, i)\n\n        def STRING(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.STRING)\n            else:\n                return self.getToken(LangParser.STRING, i)\n\n        def COMMA(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.COMMA)\n            else:\n                return self.getToken(LangParser.COMMA, i)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_listStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterListStmt\" ):\n                listener.enterListStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitListStmt\" ):\n                listener.exitListStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitListStmt\" ):\n                return visitor.visitListStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def listStmt(self):\n\n        localctx = LangParser.ListStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 46, self.RULE_listStmt)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 348\n            self.match(LangParser.L_SQBRACK)\n            self.state = 352\n            self._errHandler.sync(self)\n            token = self._input.LA(1)\n            if token in [LangParser.L_SQBRACK]:\n                self.state = 349\n                self.listStmt()\n                pass\n            elif token in [LangParser.NUMBER]:\n                self.state = 350\n                self.match(LangParser.NUMBER)\n                pass\n            elif token in [LangParser.STRING]:\n                self.state = 351\n                self.match(LangParser.STRING)\n                pass\n            elif token in [LangParser.COMMA, LangParser.P_SQBRACK]:\n                pass\n            else:\n                pass\n            self.state = 362\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            while _la==LangParser.COMMA:\n                self.state = 354\n                self.match(LangParser.COMMA)\n                self.state = 358\n                self._errHandler.sync(self)\n                token = self._input.LA(1)\n                if token in [LangParser.L_SQBRACK]:\n                    self.state = 355\n                    self.listStmt()\n                    pass\n                elif token in [LangParser.NUMBER]:\n                    self.state = 356\n                    self.match(LangParser.NUMBER)\n                    pass\n                elif token in [LangParser.STRING]:\n                    self.state = 357\n                    self.match(LangParser.STRING)\n                    pass\n                else:\n                    raise NoViableAltException(self)\n\n                self.state = 364\n                self._errHandler.sync(self)\n                _la = self._input.LA(1)\n\n            self.state = 365\n            self.match(LangParser.P_SQBRACK)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class BuiltinFuncStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def lengthStmt(self):\n            return self.getTypedRuleContext(LangParser.LengthStmtContext,0)\n\n\n        def createRowStmt(self):\n            return self.getTypedRuleContext(LangParser.CreateRowStmtContext,0)\n\n\n        def custFuncCall(self):\n            return self.getTypedRuleContext(LangParser.CustFuncCallContext,0)\n\n\n        def createTablStmt(self):\n            return self.getTypedRuleContext(LangParser.CreateTablStmtContext,0)\n\n\n        def createColStmt(self):\n            return self.getTypedRuleContext(LangParser.CreateColStmtContext,0)\n\n\n        def readStrStmt(self):\n            return self.getTypedRuleContext(LangParser.ReadStrStmtContext,0)\n\n\n        def copyStmt(self):\n            return self.getTypedRuleContext(LangParser.CopyStmtContext,0)\n\n\n        def minMaxFuncStmt(self):\n            return self.getTypedRuleContext(LangParser.MinMaxFuncStmtContext,0)\n\n\n        def delFuncStmt(self):\n            return self.getTypedRuleContext(LangParser.DelFuncStmtContext,0)\n\n\n        def reshapeStmt(self):\n            return self.getTypedRuleContext(LangParser.ReshapeStmtContext,0)\n\n\n        def insertStmt(self):\n            return self.getTypedRuleContext(LangParser.InsertStmtContext,0)\n\n\n        def findStmt(self):\n            return self.getTypedRuleContext(LangParser.FindStmtContext,0)\n\n\n        def getRuleIndex(self):\n            return LangParser.RULE_builtinFuncStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterBuiltinFuncStmt\" ):\n                listener.enterBuiltinFuncStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitBuiltinFuncStmt\" ):\n                listener.exitBuiltinFuncStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitBuiltinFuncStmt\" ):\n                return visitor.visitBuiltinFuncStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n    def resetErrHandler(self, newErrHandler : ErrorStrategy):\n        self._errHandler = newErrHandler\n\n    def builtinFuncStmt(self):\n\n        localctx = LangParser.BuiltinFuncStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 48, self.RULE_builtinFuncStmt)\n        try:\n            self.state = 379\n            self._errHandler.sync(self)\n            token = self._input.LA(1)\n            if token in [LangParser.LENGTH]:\n                self.enterOuterAlt(localctx, 1)\n                self.state = 367\n                self.lengthStmt()\n                pass\n            elif token in [LangParser.CREATE_ROW]:\n                self.enterOuterAlt(localctx, 2)\n                self.state = 368\n                self.createRowStmt()\n                pass\n            elif token in [LangParser.ID]:\n                self.enterOuterAlt(localctx, 3)\n                self.state = 369\n                self.custFuncCall()\n                pass\n            elif token in [LangParser.CREATE_TABLE]:\n                self.enterOuterAlt(localctx, 4)\n                self.state = 370\n                self.createTablStmt()\n                pass\n            elif token in [LangParser.CREATE_COL]:\n                self.enterOuterAlt(localctx, 5)\n                self.state = 371\n                self.createColStmt()\n                pass\n            elif token in [LangParser.READ_STRING]:\n                self.enterOuterAlt(localctx, 6)\n                self.state = 372\n                self.readStrStmt()\n                pass\n            elif token in [LangParser.COPY]:\n                self.enterOuterAlt(localctx, 7)\n                self.state = 373\n                self.copyStmt()\n                pass\n            elif token in [LangParser.MAX, LangParser.MIN, LangParser.MAXLEN, LangParser.MINLEN]:\n                self.enterOuterAlt(localctx, 8)\n                self.state = 374\n                self.minMaxFuncStmt()\n                pass\n            elif token in [LangParser.DEL_COL, LangParser.DEL_ROW, LangParser.DEL]:\n                self.enterOuterAlt(localctx, 9)\n                self.state = 375\n                self.delFuncStmt()\n                pass\n            elif token in [LangParser.RESHAPE]:\n                self.enterOuterAlt(localctx, 10)\n                self.state = 376\n                self.reshapeStmt()\n                pass\n            elif token in [LangParser.INSERT]:\n                self.enterOuterAlt(localctx, 11)\n                self.state = 377\n                self.insertStmt()\n                pass\n            elif token in [LangParser.FIND]:\n                self.enterOuterAlt(localctx, 12)\n                self.state = 378\n                self.findStmt()\n                pass\n            else:\n                raise NoViableAltException(self)\n\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class LengthStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def LENGTH(self):\n            return self.getToken(LangParser.LENGTH, 0)\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def numbExpr(self):\n            return self.getTypedRuleContext(LangParser.NumbExprContext,0)\n\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_lengthStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterLengthStmt\" ):\n                listener.enterLengthStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitLengthStmt\" ):\n                listener.exitLengthStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitLengthStmt\" ):\n                return visitor.visitLengthStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def lengthStmt(self):\n\n        localctx = LangParser.LengthStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 50, self.RULE_lengthStmt)\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 381\n            self.match(LangParser.LENGTH)\n            self.state = 382\n            self.match(LangParser.LPAREN)\n            self.state = 383\n            self.numbExpr(0)\n            self.state = 384\n            self.match(LangParser.RPAREN)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class ReturnStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def RETURN(self):\n            return self.getToken(LangParser.RETURN, 0)\n\n        def numbExpr(self):\n            return self.getTypedRuleContext(LangParser.NumbExprContext,0)\n\n\n        def SEMI(self):\n            return self.getToken(LangParser.SEMI, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_returnStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterReturnStmt\" ):\n                listener.enterReturnStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitReturnStmt\" ):\n                listener.exitReturnStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitReturnStmt\" ):\n                return visitor.visitReturnStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def returnStmt(self):\n\n        localctx = LangParser.ReturnStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 52, self.RULE_returnStmt)\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 386\n            self.match(LangParser.RETURN)\n            self.state = 387\n            self.numbExpr(0)\n            self.state = 388\n            self.match(LangParser.SEMI)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class CreateRowStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def CREATE_ROW(self):\n            return self.getToken(LangParser.CREATE_ROW, 0)\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def NUMBER(self):\n            return self.getToken(LangParser.NUMBER, 0)\n\n        def COMMA(self):\n            return self.getToken(LangParser.COMMA, 0)\n\n        def listStmt(self):\n            return self.getTypedRuleContext(LangParser.ListStmtContext,0)\n\n\n        def getRuleIndex(self):\n            return LangParser.RULE_createRowStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterCreateRowStmt\" ):\n                listener.enterCreateRowStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitCreateRowStmt\" ):\n                listener.exitCreateRowStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitCreateRowStmt\" ):\n                return visitor.visitCreateRowStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def createRowStmt(self):\n\n        localctx = LangParser.CreateRowStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 54, self.RULE_createRowStmt)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 390\n            self.match(LangParser.CREATE_ROW)\n            self.state = 391\n            self.match(LangParser.LPAREN)\n            self.state = 393\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            if _la==LangParser.NUMBER:\n                self.state = 392\n                self.match(LangParser.NUMBER)\n\n\n            self.state = 397\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            if _la==LangParser.COMMA:\n                self.state = 395\n                self.match(LangParser.COMMA)\n                self.state = 396\n                self.listStmt()\n\n\n            self.state = 399\n            self.match(LangParser.RPAREN)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class CreateTablStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def CREATE_TABLE(self):\n            return self.getToken(LangParser.CREATE_TABLE, 0)\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def NUMBER(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.NUMBER)\n            else:\n                return self.getToken(LangParser.NUMBER, i)\n\n        def COMMA(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.COMMA)\n            else:\n                return self.getToken(LangParser.COMMA, i)\n\n        def listStmt(self):\n            return self.getTypedRuleContext(LangParser.ListStmtContext,0)\n\n\n        def getRuleIndex(self):\n            return LangParser.RULE_createTablStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterCreateTablStmt\" ):\n                listener.enterCreateTablStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitCreateTablStmt\" ):\n                listener.exitCreateTablStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitCreateTablStmt\" ):\n                return visitor.visitCreateTablStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def createTablStmt(self):\n\n        localctx = LangParser.CreateTablStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 56, self.RULE_createTablStmt)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 401\n            self.match(LangParser.CREATE_TABLE)\n            self.state = 402\n            self.match(LangParser.LPAREN)\n            self.state = 404\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            if _la==LangParser.NUMBER:\n                self.state = 403\n                self.match(LangParser.NUMBER)\n\n\n            self.state = 410\n            self._errHandler.sync(self)\n            _alt = self._interp.adaptivePredict(self._input,42,self._ctx)\n            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:\n                if _alt==1:\n                    self.state = 406\n                    self.match(LangParser.COMMA)\n                    self.state = 407\n                    self.match(LangParser.NUMBER) \n                self.state = 412\n                self._errHandler.sync(self)\n                _alt = self._interp.adaptivePredict(self._input,42,self._ctx)\n\n            self.state = 415\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            if _la==LangParser.COMMA:\n                self.state = 413\n                self.match(LangParser.COMMA)\n                self.state = 414\n                self.listStmt()\n\n\n            self.state = 417\n            self.match(LangParser.RPAREN)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class CreateColStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def CREATE_COL(self):\n            return self.getToken(LangParser.CREATE_COL, 0)\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def NUMBER(self):\n            return self.getToken(LangParser.NUMBER, 0)\n\n        def COMMA(self):\n            return self.getToken(LangParser.COMMA, 0)\n\n        def listStmt(self):\n            return self.getTypedRuleContext(LangParser.ListStmtContext,0)\n\n\n        def getRuleIndex(self):\n            return LangParser.RULE_createColStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterCreateColStmt\" ):\n                listener.enterCreateColStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitCreateColStmt\" ):\n                listener.exitCreateColStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitCreateColStmt\" ):\n                return visitor.visitCreateColStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def createColStmt(self):\n\n        localctx = LangParser.CreateColStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 58, self.RULE_createColStmt)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 419\n            self.match(LangParser.CREATE_COL)\n            self.state = 420\n            self.match(LangParser.LPAREN)\n            self.state = 422\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            if _la==LangParser.NUMBER:\n                self.state = 421\n                self.match(LangParser.NUMBER)\n\n\n            self.state = 426\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            if _la==LangParser.COMMA:\n                self.state = 424\n                self.match(LangParser.COMMA)\n                self.state = 425\n                self.listStmt()\n\n\n            self.state = 428\n            self.match(LangParser.RPAREN)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class CopyStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def COPY(self):\n            return self.getToken(LangParser.COPY, 0)\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def ID(self):\n            return self.getToken(LangParser.ID, 0)\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_copyStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterCopyStmt\" ):\n                listener.enterCopyStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitCopyStmt\" ):\n                listener.exitCopyStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitCopyStmt\" ):\n                return visitor.visitCopyStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def copyStmt(self):\n\n        localctx = LangParser.CopyStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 60, self.RULE_copyStmt)\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 430\n            self.match(LangParser.COPY)\n            self.state = 431\n            self.match(LangParser.LPAREN)\n            self.state = 432\n            self.match(LangParser.ID)\n            self.state = 433\n            self.match(LangParser.RPAREN)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class MinMaxFuncContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def MAX(self):\n            return self.getToken(LangParser.MAX, 0)\n\n        def MIN(self):\n            return self.getToken(LangParser.MIN, 0)\n\n        def MAXLEN(self):\n            return self.getToken(LangParser.MAXLEN, 0)\n\n        def MINLEN(self):\n            return self.getToken(LangParser.MINLEN, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_minMaxFunc\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterMinMaxFunc\" ):\n                listener.enterMinMaxFunc(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitMinMaxFunc\" ):\n                listener.exitMinMaxFunc(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitMinMaxFunc\" ):\n                return visitor.visitMinMaxFunc(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def minMaxFunc(self):\n\n        localctx = LangParser.MinMaxFuncContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 62, self.RULE_minMaxFunc)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 435\n            _la = self._input.LA(1)\n            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN))) != 0)):\n                self._errHandler.recoverInline(self)\n            else:\n                self._errHandler.reportMatch(self)\n                self.consume()\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class MinMaxFuncStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def minMaxFunc(self):\n            return self.getTypedRuleContext(LangParser.MinMaxFuncContext,0)\n\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def numbExpr(self):\n            return self.getTypedRuleContext(LangParser.NumbExprContext,0)\n\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_minMaxFuncStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterMinMaxFuncStmt\" ):\n                listener.enterMinMaxFuncStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitMinMaxFuncStmt\" ):\n                listener.exitMinMaxFuncStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitMinMaxFuncStmt\" ):\n                return visitor.visitMinMaxFuncStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def minMaxFuncStmt(self):\n\n        localctx = LangParser.MinMaxFuncStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 64, self.RULE_minMaxFuncStmt)\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 437\n            self.minMaxFunc()\n            self.state = 438\n            self.match(LangParser.LPAREN)\n            self.state = 439\n            self.numbExpr(0)\n            self.state = 440\n            self.match(LangParser.RPAREN)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class DelFuncContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def DEL_COL(self):\n            return self.getToken(LangParser.DEL_COL, 0)\n\n        def DEL_ROW(self):\n            return self.getToken(LangParser.DEL_ROW, 0)\n\n        def DEL(self):\n            return self.getToken(LangParser.DEL, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_delFunc\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterDelFunc\" ):\n                listener.enterDelFunc(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitDelFunc\" ):\n                listener.exitDelFunc(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitDelFunc\" ):\n                return visitor.visitDelFunc(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def delFunc(self):\n\n        localctx = LangParser.DelFuncContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 66, self.RULE_delFunc)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 442\n            _la = self._input.LA(1)\n            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL))) != 0)):\n                self._errHandler.recoverInline(self)\n            else:\n                self._errHandler.reportMatch(self)\n                self.consume()\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class DelFuncStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def delFunc(self):\n            return self.getTypedRuleContext(LangParser.DelFuncContext,0)\n\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def numbExpr(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n            else:\n                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\n\n        def COMMA(self):\n            return self.getToken(LangParser.COMMA, 0)\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_delFuncStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterDelFuncStmt\" ):\n                listener.enterDelFuncStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitDelFuncStmt\" ):\n                listener.exitDelFuncStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitDelFuncStmt\" ):\n                return visitor.visitDelFuncStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def delFuncStmt(self):\n\n        localctx = LangParser.DelFuncStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 68, self.RULE_delFuncStmt)\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 444\n            self.delFunc()\n            self.state = 445\n            self.match(LangParser.LPAREN)\n            self.state = 446\n            self.numbExpr(0)\n            self.state = 447\n            self.match(LangParser.COMMA)\n            self.state = 448\n            self.numbExpr(0)\n            self.state = 449\n            self.match(LangParser.RPAREN)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class ReshapeStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def RESHAPE(self):\n            return self.getToken(LangParser.RESHAPE, 0)\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def numbExpr(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n            else:\n                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\n\n        def COMMA(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.COMMA)\n            else:\n                return self.getToken(LangParser.COMMA, i)\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_reshapeStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterReshapeStmt\" ):\n                listener.enterReshapeStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitReshapeStmt\" ):\n                listener.exitReshapeStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitReshapeStmt\" ):\n                return visitor.visitReshapeStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def reshapeStmt(self):\n\n        localctx = LangParser.ReshapeStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 70, self.RULE_reshapeStmt)\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 451\n            self.match(LangParser.RESHAPE)\n            self.state = 452\n            self.match(LangParser.LPAREN)\n            self.state = 453\n            self.numbExpr(0)\n            self.state = 454\n            self.match(LangParser.COMMA)\n            self.state = 455\n            self.numbExpr(0)\n            self.state = 456\n            self.match(LangParser.COMMA)\n            self.state = 457\n            self.numbExpr(0)\n            self.state = 458\n            self.match(LangParser.RPAREN)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class InsertStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def INSERT(self):\n            return self.getToken(LangParser.INSERT, 0)\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def numbExpr(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n            else:\n                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\n\n        def COMMA(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.COMMA)\n            else:\n                return self.getToken(LangParser.COMMA, i)\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_insertStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterInsertStmt\" ):\n                listener.enterInsertStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitInsertStmt\" ):\n                listener.exitInsertStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitInsertStmt\" ):\n                return visitor.visitInsertStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def insertStmt(self):\n\n        localctx = LangParser.InsertStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 72, self.RULE_insertStmt)\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 460\n            self.match(LangParser.INSERT)\n            self.state = 461\n            self.match(LangParser.LPAREN)\n            self.state = 462\n            self.numbExpr(0)\n            self.state = 463\n            self.match(LangParser.COMMA)\n            self.state = 464\n            self.numbExpr(0)\n            self.state = 465\n            self.match(LangParser.COMMA)\n            self.state = 466\n            self.numbExpr(0)\n            self.state = 467\n            self.match(LangParser.RPAREN)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class FindStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def FIND(self):\n            return self.getToken(LangParser.FIND, 0)\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def numbExpr(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n            else:\n                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\n\n        def COMMA(self):\n            return self.getToken(LangParser.COMMA, 0)\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_findStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterFindStmt\" ):\n                listener.enterFindStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitFindStmt\" ):\n                listener.exitFindStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitFindStmt\" ):\n                return visitor.visitFindStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def findStmt(self):\n\n        localctx = LangParser.FindStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 74, self.RULE_findStmt)\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 469\n            self.match(LangParser.FIND)\n            self.state = 470\n            self.match(LangParser.LPAREN)\n            self.state = 471\n            self.numbExpr(0)\n            self.state = 472\n            self.match(LangParser.COMMA)\n            self.state = 473\n            self.numbExpr(0)\n            self.state = 474\n            self.match(LangParser.RPAREN)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class PrintStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def PRINT(self):\n            return self.getToken(LangParser.PRINT, 0)\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def numbExpr(self, i:int=None):\n            if i is None:\n                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n            else:\n                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\n\n        def COMMA(self, i:int=None):\n            if i is None:\n                return self.getTokens(LangParser.COMMA)\n            else:\n                return self.getToken(LangParser.COMMA, i)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_printStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterPrintStmt\" ):\n                listener.enterPrintStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitPrintStmt\" ):\n                listener.exitPrintStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitPrintStmt\" ):\n                return visitor.visitPrintStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def printStmt(self):\n\n        localctx = LangParser.PrintStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 76, self.RULE_printStmt)\n        self._la = 0 # Token type\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 476\n            self.match(LangParser.PRINT)\n            self.state = 477\n            self.match(LangParser.LPAREN)\n            self.state = 479\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.NUMBER) | (1 << LangParser.STRING) | (1 << LangParser.ID))) != 0):\n                self.state = 478\n                self.numbExpr(0)\n\n\n            self.state = 485\n            self._errHandler.sync(self)\n            _la = self._input.LA(1)\n            while _la==LangParser.COMMA:\n                self.state = 481\n                self.match(LangParser.COMMA)\n                self.state = 482\n                self.numbExpr(0)\n                self.state = 487\n                self._errHandler.sync(self)\n                _la = self._input.LA(1)\n\n            self.state = 488\n            self.match(LangParser.RPAREN)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n    class ReadStrStmtContext(ParserRuleContext):\n\n        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n            super().__init__(parent, invokingState)\n            self.parser = parser\n\n        def READ_STRING(self):\n            return self.getToken(LangParser.READ_STRING, 0)\n\n        def LPAREN(self):\n            return self.getToken(LangParser.LPAREN, 0)\n\n        def RPAREN(self):\n            return self.getToken(LangParser.RPAREN, 0)\n\n        def getRuleIndex(self):\n            return LangParser.RULE_readStrStmt\n\n        def enterRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"enterReadStrStmt\" ):\n                listener.enterReadStrStmt(self)\n\n        def exitRule(self, listener:ParseTreeListener):\n            if hasattr( listener, \"exitReadStrStmt\" ):\n                listener.exitReadStrStmt(self)\n\n        def accept(self, visitor:ParseTreeVisitor):\n            if hasattr( visitor, \"visitReadStrStmt\" ):\n                return visitor.visitReadStrStmt(self)\n            else:\n                return visitor.visitChildren(self)\n\n\n\n\n    def readStrStmt(self):\n\n        localctx = LangParser.ReadStrStmtContext(self, self._ctx, self.state)\n        self.enterRule(localctx, 78, self.RULE_readStrStmt)\n        try:\n            self.enterOuterAlt(localctx, 1)\n            self.state = 490\n            self.match(LangParser.READ_STRING)\n            self.state = 491\n            self.match(LangParser.LPAREN)\n            self.state = 492\n            self.match(LangParser.RPAREN)\n        except RecognitionException as re:\n            localctx.exception = re\n            self._errHandler.reportError(self, re, localctx)\n            self._errHandler.recover(self, re)\n        finally:\n            self.exitRule()\n        return localctx\n\n\n\n    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):\n        if self._predicates == None:\n            self._predicates = dict()\n        self._predicates[16] = self.numbExpr_sempred\n        pred = self._predicates.get(ruleIndex, None)\n        if pred is None:\n            raise Exception(\"No predicate with index:\" + str(ruleIndex))\n        else:\n            return pred(localctx, predIndex)\n\n    def numbExpr_sempred(self, localctx:NumbExprContext, predIndex:int):\n            if predIndex == 0:\n                return self.precpred(self._ctx, 1)", "         \n\n\n\n\n"]}
{"filename": "parser/LangParserVisitor.py", "chunked_list": ["# Generated from LangParser.g4 by ANTLR 4.7.2\nfrom antlr4 import *\nif __name__ is not None and \".\" in __name__:\n    from .LangParser import LangParser\nelse:\n    from LangParser import LangParser\n\n# This class defines a complete generic visitor for a parse tree produced by LangParser.\n\nclass LangParserVisitor(ParseTreeVisitor):\n\n    # Visit a parse tree produced by LangParser#program.\n    def visitProgram(self, ctx:LangParser.ProgramContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#func.\n    def visitFunc(self, ctx:LangParser.FuncContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#stat.\n    def visitStat(self, ctx:LangParser.StatContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#funcStat.\n    def visitFuncStat(self, ctx:LangParser.FuncStatContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#forStat.\n    def visitForStat(self, ctx:LangParser.ForStatContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#assignExpr.\n    def visitAssignExpr(self, ctx:LangParser.AssignExprContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#varDeclStmt.\n    def visitVarDeclStmt(self, ctx:LangParser.VarDeclStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#incDecrStat.\n    def visitIncDecrStat(self, ctx:LangParser.IncDecrStatContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#assignSign.\n    def visitAssignSign(self, ctx:LangParser.AssignSignContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#basicTypeName.\n    def visitBasicTypeName(self, ctx:LangParser.BasicTypeNameContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#boolSign.\n    def visitBoolSign(self, ctx:LangParser.BoolSignContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#numbSign.\n    def visitNumbSign(self, ctx:LangParser.NumbSignContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#boolNumbSign.\n    def visitBoolNumbSign(self, ctx:LangParser.BoolNumbSignContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#iterBasicType.\n    def visitIterBasicType(self, ctx:LangParser.IterBasicTypeContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#basicType.\n    def visitBasicType(self, ctx:LangParser.BasicTypeContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#returnType.\n    def visitReturnType(self, ctx:LangParser.ReturnTypeContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#numbExpr.\n    def visitNumbExpr(self, ctx:LangParser.NumbExprContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#boolExpr.\n    def visitBoolExpr(self, ctx:LangParser.BoolExprContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#ifElseStmt.\n    def visitIfElseStmt(self, ctx:LangParser.IfElseStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#whileStmt.\n    def visitWhileStmt(self, ctx:LangParser.WhileStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#untilStmt.\n    def visitUntilStmt(self, ctx:LangParser.UntilStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#custFuncCall.\n    def visitCustFuncCall(self, ctx:LangParser.CustFuncCallContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#indexStmt.\n    def visitIndexStmt(self, ctx:LangParser.IndexStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#listStmt.\n    def visitListStmt(self, ctx:LangParser.ListStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#builtinFuncStmt.\n    def visitBuiltinFuncStmt(self, ctx:LangParser.BuiltinFuncStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#lengthStmt.\n    def visitLengthStmt(self, ctx:LangParser.LengthStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#returnStmt.\n    def visitReturnStmt(self, ctx:LangParser.ReturnStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#createRowStmt.\n    def visitCreateRowStmt(self, ctx:LangParser.CreateRowStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#createTablStmt.\n    def visitCreateTablStmt(self, ctx:LangParser.CreateTablStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#createColStmt.\n    def visitCreateColStmt(self, ctx:LangParser.CreateColStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#copyStmt.\n    def visitCopyStmt(self, ctx:LangParser.CopyStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#minMaxFunc.\n    def visitMinMaxFunc(self, ctx:LangParser.MinMaxFuncContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#minMaxFuncStmt.\n    def visitMinMaxFuncStmt(self, ctx:LangParser.MinMaxFuncStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#delFunc.\n    def visitDelFunc(self, ctx:LangParser.DelFuncContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#delFuncStmt.\n    def visitDelFuncStmt(self, ctx:LangParser.DelFuncStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#reshapeStmt.\n    def visitReshapeStmt(self, ctx:LangParser.ReshapeStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#insertStmt.\n    def visitInsertStmt(self, ctx:LangParser.InsertStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#findStmt.\n    def visitFindStmt(self, ctx:LangParser.FindStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#printStmt.\n    def visitPrintStmt(self, ctx:LangParser.PrintStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#readStrStmt.\n    def visitReadStrStmt(self, ctx:LangParser.ReadStrStmtContext):\n        return self.visitChildren(ctx)", "\nclass LangParserVisitor(ParseTreeVisitor):\n\n    # Visit a parse tree produced by LangParser#program.\n    def visitProgram(self, ctx:LangParser.ProgramContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#func.\n    def visitFunc(self, ctx:LangParser.FuncContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#stat.\n    def visitStat(self, ctx:LangParser.StatContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#funcStat.\n    def visitFuncStat(self, ctx:LangParser.FuncStatContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#forStat.\n    def visitForStat(self, ctx:LangParser.ForStatContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#assignExpr.\n    def visitAssignExpr(self, ctx:LangParser.AssignExprContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#varDeclStmt.\n    def visitVarDeclStmt(self, ctx:LangParser.VarDeclStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#incDecrStat.\n    def visitIncDecrStat(self, ctx:LangParser.IncDecrStatContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#assignSign.\n    def visitAssignSign(self, ctx:LangParser.AssignSignContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#basicTypeName.\n    def visitBasicTypeName(self, ctx:LangParser.BasicTypeNameContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#boolSign.\n    def visitBoolSign(self, ctx:LangParser.BoolSignContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#numbSign.\n    def visitNumbSign(self, ctx:LangParser.NumbSignContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#boolNumbSign.\n    def visitBoolNumbSign(self, ctx:LangParser.BoolNumbSignContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#iterBasicType.\n    def visitIterBasicType(self, ctx:LangParser.IterBasicTypeContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#basicType.\n    def visitBasicType(self, ctx:LangParser.BasicTypeContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#returnType.\n    def visitReturnType(self, ctx:LangParser.ReturnTypeContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#numbExpr.\n    def visitNumbExpr(self, ctx:LangParser.NumbExprContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#boolExpr.\n    def visitBoolExpr(self, ctx:LangParser.BoolExprContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#ifElseStmt.\n    def visitIfElseStmt(self, ctx:LangParser.IfElseStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#whileStmt.\n    def visitWhileStmt(self, ctx:LangParser.WhileStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#untilStmt.\n    def visitUntilStmt(self, ctx:LangParser.UntilStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#custFuncCall.\n    def visitCustFuncCall(self, ctx:LangParser.CustFuncCallContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#indexStmt.\n    def visitIndexStmt(self, ctx:LangParser.IndexStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#listStmt.\n    def visitListStmt(self, ctx:LangParser.ListStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#builtinFuncStmt.\n    def visitBuiltinFuncStmt(self, ctx:LangParser.BuiltinFuncStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#lengthStmt.\n    def visitLengthStmt(self, ctx:LangParser.LengthStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#returnStmt.\n    def visitReturnStmt(self, ctx:LangParser.ReturnStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#createRowStmt.\n    def visitCreateRowStmt(self, ctx:LangParser.CreateRowStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#createTablStmt.\n    def visitCreateTablStmt(self, ctx:LangParser.CreateTablStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#createColStmt.\n    def visitCreateColStmt(self, ctx:LangParser.CreateColStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#copyStmt.\n    def visitCopyStmt(self, ctx:LangParser.CopyStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#minMaxFunc.\n    def visitMinMaxFunc(self, ctx:LangParser.MinMaxFuncContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#minMaxFuncStmt.\n    def visitMinMaxFuncStmt(self, ctx:LangParser.MinMaxFuncStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#delFunc.\n    def visitDelFunc(self, ctx:LangParser.DelFuncContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#delFuncStmt.\n    def visitDelFuncStmt(self, ctx:LangParser.DelFuncStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#reshapeStmt.\n    def visitReshapeStmt(self, ctx:LangParser.ReshapeStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#insertStmt.\n    def visitInsertStmt(self, ctx:LangParser.InsertStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#findStmt.\n    def visitFindStmt(self, ctx:LangParser.FindStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#printStmt.\n    def visitPrintStmt(self, ctx:LangParser.PrintStmtContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by LangParser#readStrStmt.\n    def visitReadStrStmt(self, ctx:LangParser.ReadStrStmtContext):\n        return self.visitChildren(ctx)", "\n\n\ndel LangParser"]}
{"filename": "src/configs.py", "chunked_list": ["import json \n\n\n\nif __name__ == '__main__':\n    dict_ = {\n        \"MAX_STR_SIZE\": 20,\n        \"MAX_ARR_SIZE\": 1000\n    }\n    with open(\"src/confs.json\", 'w', encoding='utf-8') as conffile:\n        json.dump(dict_, conffile)", "\n\nwith open(\"src/confs.json\", 'r', encoding='utf-8') as conffile:\n    confs = json.load(conffile)\n\n\nMAX_STR_SIZE = confs[\"MAX_STR_SIZE\"]\nMAX_ARR_SIZE = confs[\"MAX_ARR_SIZE\"]\n", ""]}
{"filename": "src/basic_types.py", "chunked_list": ["from llvmlite import ir\nfrom src.configs import MAX_STR_SIZE\n\n\ni8 = ir.IntType(8)\ni32 = ir.IntType(32)\narray = ir.ArrayType\n\nvoid = ir.VoidType()\nstring = i8.as_pointer()", "void = ir.VoidType()\nstring = i8.as_pointer()\niter = i8.as_pointer().as_pointer()\nnumber = ir.DoubleType()\n"]}
{"filename": "src/RowVariable.py", "chunked_list": ["from llvmlite import ir\nfrom src.IterVariable import IterVariable\nfrom basic_types import iter\n\n\nclass RowVariable(IterVariable):\n\n    def __init__(self, elements: tuple = None, builder: ir.builder.IRBuilder = None, ptr=None) -> None:\n        super().__init__(elements, len(elements), builder, ptr)\n\n    def set_value(self, value):\n        self.size = value.size\n        self.type = value.type\n        self.var = value.var\n        self.compile_init()\n\n    def get_value(self):\n        return self.ptr\n\n    def get_element(self, index: int):\n        return self.ptr\n\n    def insert_element(self, value: int | str, index):\n        return self.builder.insert_value(self.ptr, value, index)", ""]}
{"filename": "src/utils.py", "chunked_list": ["import string\nimport random\n"]}
{"filename": "src/Function.py", "chunked_list": ["from typing import Any, Sequence, Union\nfrom llvmlite import ir\nfrom src.variables import *\n\n\nclass Function:\n    def __init__(self, module: ir.Module, function_type: ir.FunctionType, name: str, return_var_type: Variable | Sequence[Variable]) -> None:\n        self.arg_types = function_type.args\n        self._return_type = return_var_type\n        self.type = function_type\n        self._function = ir.Function(\n            module, \n            function_type,\n            name\n        )\n        self._is_convert_func = \"toDynamic\" in name   # if function is used for dynamic converting -> return raw alloca inst\n\n    def _save_function_result(self, func_res: ir.AllocaInstr, builder: ir.builder, result_size: int | list, first_arg_type: Variable) -> Variable | ir.AllocaInstr:\n        if self._is_convert_func:\n            return func_res\n        if self._return_type == VoidVariable:\n            return None\n        elif self._return_type == StringVariable:\n            return StringVariable(func_res, builder)\n        elif self._return_type == TableVariable:\n            return TableVariable(func_res, *result_size, builder)\n        elif self._return_type == IterVariable:\n            return IterVariable(func_res, result_size, builder)\n        elif isinstance(self._return_type, list):\n            if first_arg_type not in [RowVariable, ColumnVariable, TableVariable]:\n                raise ValueError(f\"Arg type - {first_arg_type}\")\n            if first_arg_type in [RowVariable, ColumnVariable]:\n                return first_arg_type(func_res, result_size, builder)\n            else:\n                return first_arg_type(func_res, *result_size, builder)\n\n\n    def __call__(self, builder: ir.builder, *args, **kwargs) -> Any:\n        raw_args = [arg.get_value() for arg in args]\n        function_result = builder.call(self._function, raw_args)\n        return self._save_function_result(function_result, builder, kwargs.get(\"result_size\"), type(args[0]))", ""]}
{"filename": "src/compilers/ExpressionCompiler.py", "chunked_list": ["from src.variables import NumbVariable, Variable\nfrom llvmlite import ir\n\n\nclass ExpressionCompiler:\n\n    def __init__(self) -> None:\n        pass\n\n    def increment_variable(self, var: NumbVariable, builder: ir.builder.IRBuilder):\n        temp_val = builder.load(var.ptr)\n        new_val = builder.fadd(temp_val, ir.Constant(ir.DoubleType(), 1.))\n        builder.store(new_val, var.ptr)\n        return var\n\n    def decrement_variable(self, var: NumbVariable, builder: ir.builder.IRBuilder):\n        temp_val = builder.load(var.ptr)\n        new_val = builder.fsub(temp_val, ir.Constant(ir.DoubleType(), 1.))\n        builder.store(new_val, var.ptr)\n        return var\n    \n    def process_numb_expr(self, first_var: Variable, operation_sign: str, second_var: Variable):\n        if isinstance(first_var, NumbVariable) and isinstance(second_var, NumbVariable):\n            if operation_sign == '+':\n                return first_var + second_var\n            elif operation_sign == '-':\n                return first_var - second_var\n            elif operation_sign == '/':\n                return first_var / second_var\n            elif operation_sign == '//':\n                return first_var // second_var\n            elif operation_sign == '*':\n                return first_var * second_var\n            elif operation_sign == '==':\n                return first_var == second_var\n            elif operation_sign == '!=':\n                return first_var != second_var\n\n        raise ValueError(f\"Uknown operation operands and sign - {first_var}, {operation_sign}, {second_var}\")", ""]}
{"filename": "src/compilers/AssignExpressionCompiler.py", "chunked_list": ["from llvmlite.ir import Module\nfrom src.variables import Variable\n\nclass AssignExpressionCompiler:\n    def __init__(self, module: Module) -> None:\n        self._module = module\n\n    def compile_assign_expr(self, variable: Variable, assign_sign: str, value: Variable) -> None:\n        if assign_sign == '=':\n            variable.set_value(value)\n        elif assign_sign == '+=':\n            variable.set_value(variable + value)\n        elif assign_sign == '-=':\n            variable.set_value(variable - value)\n        elif assign_sign == '/=':\n            variable.set_value(variable / value)\n        elif assign_sign == '*=':\n            variable.set_value(variable * value)\n        else:\n            raise ValueError(f\"Unknown assign sign - {assign_sign}\")"]}
{"filename": "src/compilers/FunctionCompiler.py", "chunked_list": ["from llvmlite.ir import Module\nfrom llvmlite import ir\nfrom src.basic_types import *\nfrom src.configs import MAX_STR_SIZE, MAX_ARR_SIZE\nfrom src.Function import Function\nfrom src.variables import *\n\n\nclass FunctionCompiler:\n\n    def __init__(self, module: Module) -> None:\n        self.module = module\n        self._functions = {}\n        self._load_builtin_functions()\n        self._call_function_map = {\n            \"print\": self.call_print_func,\n            \"length\": self.call_length_func,\n            \"del\": self.call_del_func,\n            \"copy\": self.call_copy_func\n        }\n        StringVariable.convert_func = self._functions[\"toDynamicStr\"]\n        IterVariable.convert_func = self._functions[\"toDynamic2\"]\n\n    def _load_builtin_functions(self):\n        function_parameters = [\n            [VoidVariable, [string], \"printf\", True],\n            [NumbVariable, [], \"length\", False],\n            [VoidVariable, [iter, number, number], \"print_row_or_column\", False],\n            [StringVariable, [], \"read_string\", False],\n            [VoidVariable, [iter, number, number], \"print_table\", False],\n            [TableVariable, [iter, number, number, iter, number, number], \"mul_tables\", False],\n            [[RowVariable, ColumnVariable, TableVariable], [number, ir.ArrayType(ir.ArrayType(i8, MAX_STR_SIZE), MAX_ARR_SIZE).as_pointer()], \"toDynamic2\", False],\n            [StringVariable, [ir.ArrayType(ir.IntType(8), MAX_STR_SIZE).as_pointer()], \"toDynamicStr\", False],\n            [[RowVariable, ColumnVariable], [iter, number, number], \"delete_el\", False]\n        ]\n        for func_params in function_parameters:\n            self._save_func_to_dict(*func_params)\n\n    def _save_func_to_dict(self, return_var: Variable, arg_types: list, name: str, var_arg: bool = False):\n        function = Function(\n            self.module,\n            ir.FunctionType(\n                return_var.basic_type if not isinstance(return_var, list) else iter,\n                arg_types,\n                var_arg=var_arg\n            ),\n            name,\n            return_var\n        )\n        self._functions[name] = function\n\n    def get_function_by_name(self, name: str) -> ir.Function:\n        return self._functions.get(name)\n\n    def call_function(self, name: str, args: list, builder: ir.builder.IRBuilder):\n        call_function_var = self._call_function_map[name] if self._call_function_map.get(name) is not None \\\n                                                          else self._functions[name]\n        return call_function_var(builder, *args)\n\n    def call_mult_tables_function(self, builder: ir.builder.IRBuilder, first_table: TableVariable, second_table: TableVariable):\n        if first_table.n_rows != second_table.n_rows:\n            raise ValueError(\"N rows is not equal\")\n        args = (\n            first_table,\n            NumbVariable(first_table.n_rows, builder),\n            NumbVariable(second_table.n_cols, builder),\n            second_table,\n            NumbVariable(second_table.n_rows, builder),\n            NumbVariable(second_table.n_cols, builder)\n        )\n\n    def call_print_func(self, builder: ir.builder.IRBuilder, variable: RowVariable | NumbVariable | TableVariable | ColumnVariable | StringVariable) -> VoidVariable:\n        if isinstance(variable, NumbVariable):\n            format_string = StringVariable(\"%.3f\\n\\0\", builder)\n            return self._functions[\"printf\"](builder, format_string, variable)\n        elif isinstance(variable, StringVariable):\n            format_string = StringVariable(\"%s\\n\\0\", builder)\n            return self._functions[\"printf\"](builder, format_string, variable)\n        elif isinstance(variable, (ColumnVariable, RowVariable)):\n            is_column = NumbVariable(1, builder) if isinstance(variable, ColumnVariable) else NumbVariable(0, builder)\n            return self._functions[\"print_row_or_column\"](builder, variable, variable.size, is_column)\n        elif isinstance(variable, TableVariable):\n            return self._functions[\"print_table\"](builder, variable, variable.n_rows, variable.n_cols)\n\n    def call_length_func(self, builder: ir.builder.IRBuilder, variable: IterVariable) -> NumbVariable:\n        return variable.size\n        \n    def call_reshape_func(self, builder, arg1: TableVariable, arg2: NumbVariable, arg3: NumbVariable):\n        if not isinstance(arg1, TableVariable) and not isinstance(arg2, NumbVariable) and not isinstance(arg3, NumbVariable):\n            raise ValueError(\"Invalid arg types combination - {}, {}, {}\".format(type(arg1), type(arg2), type(arg3)))\n        return TableVariable(arg1.var, arg2, arg3, builder)\n    \n    def call_del_func(self, builder: ir.builder.IRBuilder, arg1: RowVariable | ColumnVariable, arg2: NumbVariable):\n        return self._functions[\"delete_el\"](builder, arg1, arg2, arg1.size, result_size=arg1.size - NumbVariable(1, builder))\n    \n    def call_copy_func(self, builder, arg1: Variable):\n        return arg1.copy_variable(builder)", "class FunctionCompiler:\n\n    def __init__(self, module: Module) -> None:\n        self.module = module\n        self._functions = {}\n        self._load_builtin_functions()\n        self._call_function_map = {\n            \"print\": self.call_print_func,\n            \"length\": self.call_length_func,\n            \"del\": self.call_del_func,\n            \"copy\": self.call_copy_func\n        }\n        StringVariable.convert_func = self._functions[\"toDynamicStr\"]\n        IterVariable.convert_func = self._functions[\"toDynamic2\"]\n\n    def _load_builtin_functions(self):\n        function_parameters = [\n            [VoidVariable, [string], \"printf\", True],\n            [NumbVariable, [], \"length\", False],\n            [VoidVariable, [iter, number, number], \"print_row_or_column\", False],\n            [StringVariable, [], \"read_string\", False],\n            [VoidVariable, [iter, number, number], \"print_table\", False],\n            [TableVariable, [iter, number, number, iter, number, number], \"mul_tables\", False],\n            [[RowVariable, ColumnVariable, TableVariable], [number, ir.ArrayType(ir.ArrayType(i8, MAX_STR_SIZE), MAX_ARR_SIZE).as_pointer()], \"toDynamic2\", False],\n            [StringVariable, [ir.ArrayType(ir.IntType(8), MAX_STR_SIZE).as_pointer()], \"toDynamicStr\", False],\n            [[RowVariable, ColumnVariable], [iter, number, number], \"delete_el\", False]\n        ]\n        for func_params in function_parameters:\n            self._save_func_to_dict(*func_params)\n\n    def _save_func_to_dict(self, return_var: Variable, arg_types: list, name: str, var_arg: bool = False):\n        function = Function(\n            self.module,\n            ir.FunctionType(\n                return_var.basic_type if not isinstance(return_var, list) else iter,\n                arg_types,\n                var_arg=var_arg\n            ),\n            name,\n            return_var\n        )\n        self._functions[name] = function\n\n    def get_function_by_name(self, name: str) -> ir.Function:\n        return self._functions.get(name)\n\n    def call_function(self, name: str, args: list, builder: ir.builder.IRBuilder):\n        call_function_var = self._call_function_map[name] if self._call_function_map.get(name) is not None \\\n                                                          else self._functions[name]\n        return call_function_var(builder, *args)\n\n    def call_mult_tables_function(self, builder: ir.builder.IRBuilder, first_table: TableVariable, second_table: TableVariable):\n        if first_table.n_rows != second_table.n_rows:\n            raise ValueError(\"N rows is not equal\")\n        args = (\n            first_table,\n            NumbVariable(first_table.n_rows, builder),\n            NumbVariable(second_table.n_cols, builder),\n            second_table,\n            NumbVariable(second_table.n_rows, builder),\n            NumbVariable(second_table.n_cols, builder)\n        )\n\n    def call_print_func(self, builder: ir.builder.IRBuilder, variable: RowVariable | NumbVariable | TableVariable | ColumnVariable | StringVariable) -> VoidVariable:\n        if isinstance(variable, NumbVariable):\n            format_string = StringVariable(\"%.3f\\n\\0\", builder)\n            return self._functions[\"printf\"](builder, format_string, variable)\n        elif isinstance(variable, StringVariable):\n            format_string = StringVariable(\"%s\\n\\0\", builder)\n            return self._functions[\"printf\"](builder, format_string, variable)\n        elif isinstance(variable, (ColumnVariable, RowVariable)):\n            is_column = NumbVariable(1, builder) if isinstance(variable, ColumnVariable) else NumbVariable(0, builder)\n            return self._functions[\"print_row_or_column\"](builder, variable, variable.size, is_column)\n        elif isinstance(variable, TableVariable):\n            return self._functions[\"print_table\"](builder, variable, variable.n_rows, variable.n_cols)\n\n    def call_length_func(self, builder: ir.builder.IRBuilder, variable: IterVariable) -> NumbVariable:\n        return variable.size\n        \n    def call_reshape_func(self, builder, arg1: TableVariable, arg2: NumbVariable, arg3: NumbVariable):\n        if not isinstance(arg1, TableVariable) and not isinstance(arg2, NumbVariable) and not isinstance(arg3, NumbVariable):\n            raise ValueError(\"Invalid arg types combination - {}, {}, {}\".format(type(arg1), type(arg2), type(arg3)))\n        return TableVariable(arg1.var, arg2, arg3, builder)\n    \n    def call_del_func(self, builder: ir.builder.IRBuilder, arg1: RowVariable | ColumnVariable, arg2: NumbVariable):\n        return self._functions[\"delete_el\"](builder, arg1, arg2, arg1.size, result_size=arg1.size - NumbVariable(1, builder))\n    \n    def call_copy_func(self, builder, arg1: Variable):\n        return arg1.copy_variable(builder)", "\n    "]}
{"filename": "src/compilers/ProgramCompiler.py", "chunked_list": ["import llvmlite.ir as ir\nfrom parser.LangParser import LangParser\nfrom src.variables import *\nfrom .FunctionCompiler import FunctionCompiler\nfrom .ExpressionCompiler import ExpressionCompiler\nfrom .AssignExpressionCompiler import AssignExpressionCompiler\nfrom src.configs import MAX_STR_SIZE\nfrom src.basic_types import *\nimport time\nimport os", "import time\nimport os\n\n\nclass ProgramCompiler:\n    def __init__(self) -> None:\n        print(\"Program compilation into IR code is starting...\")\n        self._module = ir.Module()\n        self._module.triple = \"x86_64-pc-linux-gnu\"\n        self._builtin_funcs = {}", "        self._module.triple = \"x86_64-pc-linux-gnu\"\n        self._builtin_funcs = {}\n        self.function_compiler = FunctionCompiler(self._module)\n        self.expression_compiler = ExpressionCompiler()\n        self.assign_expression_compiler = AssignExpressionCompiler(self._module)\n        self.local_function = None\n        self._main_func = None\n\n    def finish_compiling(self, file_name='ir_program.ll'):\n        self.finish_main_func()", "    def finish_compiling(self, file_name='ir_program.ll'):\n        self.finish_main_func()\n        print(str(self._module))\n        with open(file_name, \"w\") as ir_file:\n            ir_file.write(str(self._module))\n        print(\"Program translation into IR code is finished. IR file - {}\".format(file_name))\n        time.sleep(1)\n        print(\"Program is converting from IR into executable file\")\n        os.system(f\"llvm-as {file_name} -o mylang.bc\")\n        os.system(f\"clang -c -emit-llvm src/main.c -o main.bc\")", "        os.system(f\"llvm-as {file_name} -o mylang.bc\")\n        os.system(f\"clang -c -emit-llvm src/main.c -o main.bc\")\n        os.system(f\"clang -c -emit-llvm src/func_utilities.c -o func_utilities.bc\")\n        os.system(f\"clang mylang.bc main.bc func_utilities.bc -o executable\")\n        os.system(f\"rm main.bc mylang.bc func_utilities.bc\")\n\n    def start_main_func(self):\n        main_type = ir.FunctionType(ir.IntType(32), [])\n        self._main_func = ir.Function(self._module, main_type, name='run_llvmlite_compiler')\n        self._builder = ir.IRBuilder(self._main_func.append_basic_block(name='entry'))", "        self._main_func = ir.Function(self._module, main_type, name='run_llvmlite_compiler')\n        self._builder = ir.IRBuilder(self._main_func.append_basic_block(name='entry'))\n    \n    def is_main_function_started(self):\n        return self._main_func is not None\n\n    def finish_main_func(self):\n        if self._builder is not None:\n            self._builder.ret(ir.Constant(ir.IntType(32), 0))\n", "            self._builder.ret(ir.Constant(ir.IntType(32), 0))\n\n    def start_local_function(self, func_name, return_type, arg_types):\n        if self.local_function is not None:\n            return\n        type_ = self.convert_type(return_type)\n        converted_types = [self.convert_type(\n            arg_type) for arg_type in arg_types]\n        func_type = ir.FunctionType(\n            type_, converted_types)", "        func_type = ir.FunctionType(\n            type_, converted_types)\n        self.local_function = ir.Function(\n            self.module, func_type, name=func_name)\n        self._builder = ir.builder.IRBuilder(\n            self.local_function.append_basic_block(name='entry'))\n        self.builtin_funcs[func_name] = (\n            self.local_function, return_type, arg_types)\n        self.local_func_args = [self.create_var_by_type(\n            arg_type) for arg_type in arg_types]", "        self.local_func_args = [self.create_var_by_type(\n            arg_type) for arg_type in arg_types]\n\n    def finish_local_function(self, return_const: ir.Constant = None):\n        self._builder.ret(return_const.var)\n        self.local_function = None\n        self._builder = None\n\n    def _load_builtin_func(self):\n        self.function_compiler.load_builtin_functions()", "    def _load_builtin_func(self):\n        self.function_compiler.load_builtin_functions()\n\n    def find_expression_result(self, first_variable, operation_sign: str, second_variable):\n        return self.expression_compiler.process_numb_expr(first_variable, operation_sign, second_variable)\n    \n    def call_function(self, name: str, args: list = []):\n        return self.function_compiler.call_function(name, args, self._builder)\n\n    def create_empty_var_by_type(self, type: ir.Type):", "\n    def create_empty_var_by_type(self, type: ir.Type):\n        if type == 'numb':\n            return NumbVariable(1, self._builder)\n        elif type == 'string':\n            return StringVariable(\"\", self._builder)\n        elif type == 'row':\n            return RowVariable([], self._builder)\n        elif type == 'column':\n            return ColumnVariable([], self._builder)", "        elif type == 'column':\n            return ColumnVariable([], self._builder)\n        elif type == 'table':\n            return TableVariable([], self._builder)\n        else:\n            raise ValueError(\"Unkown type - {}\".format(type))\n\n    def create_table(self, elements, n_col, n_row):\n        return TableVariable(elements, NumbVariable(n_row, self._builder), NumbVariable(n_col, self._builder), self._builder)\n    ", "        return TableVariable(elements, NumbVariable(n_row, self._builder), NumbVariable(n_col, self._builder), self._builder)\n    \n    def create_row(self, elements: list[str]):\n        return RowVariable(elements, NumbVariable(len(elements), self._builder), self._builder)\n    \n    def create_column(self, elements: list[str]):\n        return ColumnVariable(elements, NumbVariable(len(elements), self._builder), self._builder)\n        \n    def convert_type(self, type: str) -> ir.Type:\n        result_type = None", "    def convert_type(self, type: str) -> ir.Type:\n        result_type = None\n        match type:\n            case \"numb\":\n                result_type = number\n            case \"string\":\n                result_type = string\n            case \"iter\"|\"row\"|\"table\"|\"column\":\n                result_type = iter\n            case \"void\":", "                result_type = iter\n            case \"void\":\n                result_type = number\n            case \"int\":\n                result_type = i8\n            case _:\n                raise ValueError(\"Unknown type - {}\".format(type))\n        return result_type\n    \n    def assign_value(self, variable: Variable, assign_sign: str, value: Variable) -> None:", "    \n    def assign_value(self, variable: Variable, assign_sign: str, value: Variable) -> None:\n        if type(variable) != type(value):\n            raise TypeError(\"Different type of assign value\")\n        self.assign_expression_compiler.compile_assign_expr(variable, assign_sign, value)\n"]}
{"filename": "src/compilers/__init__.py", "chunked_list": ["from .ProgramCompiler import ProgramCompiler"]}
{"filename": "src/variables/Variable.py", "chunked_list": ["from abc import ABC, abstractmethod, abstractproperty\nfrom llvmlite.ir import Type\n\nclass Variable(ABC):\n\n    basic_type: Type\n\n    @abstractmethod\n    def get_value():\n        pass\n\n    @abstractmethod\n    def copy_variable():\n        pass\n\n    @abstractmethod\n    def set_value(value):\n        pass", ""]}
{"filename": "src/variables/IterVariable.py", "chunked_list": ["from llvmlite import ir\nfrom src.configs import MAX_STR_SIZE, MAX_ARR_SIZE\nfrom ..basic_types import iter, i8\nfrom .NumbVariable import NumbVariable\nfrom .Variable import Variable\n\n\nclass IterVariable(Variable):\n\n    basic_type = iter\n    convert_func: ir.Function\n\n    def __init__(self, elements: tuple | object | ir.instructions.Instruction, size: NumbVariable, builder: ir.builder.IRBuilder, ptr=None) -> None:\n        self.builder = builder\n        self.size = NumbVariable(size, builder) if not isinstance(size, NumbVariable) else size\n\n        if isinstance(elements, ir.instructions.Instruction):\n            self.var = elements\n            self.ptr = self.builder.alloca(self.basic_type)\n            self.builder.store(self.var, self.ptr)\n            self.ptr = self.builder.load(self.ptr)\n            return\n        \n        elif not isinstance(elements, (tuple, list)):\n            self.var = elements.var\n            self.ptr = self.builder.alloca(self.basic_type)\n            self.builder.store(self.var, self.ptr)\n            self.ptr = self.builder.load(self.ptr)\n            return\n\n        elements = [element + \" \" * (MAX_STR_SIZE - len(element) - 1) for element in elements]\n\n        elements += [\" \" * (MAX_STR_SIZE - 1)] * (MAX_ARR_SIZE - len(elements))\n\n        if ptr is not None:\n            self.ptr = ptr\n            self.var = self.builder.load(self.ptr)\n        else:\n            cvars = [ir.Constant(ir.ArrayType(ir.IntType(8), MAX_STR_SIZE), bytearray(\n                var + ' ' * (MAX_STR_SIZE - len(var) - 1) + '\\0', 'utf-8')) for var in elements]\n            type_ = ir.ArrayType(ir.ArrayType(ir.IntType(8), MAX_STR_SIZE), len(elements))\n            self.var = ir.Constant(type_, cvars)\n            self.ptr = self.builder.alloca(type_)\n            self.builder.store(self.var, self.ptr)\n\n            result = self.convert_func(self.builder, self.size, self)\n            self.ptr = self.builder.alloca(self.basic_type)\n            self.builder.store(result, self.ptr)\n            self.ptr = self.builder.load(self.ptr)\n\n    def set_value(self, value):\n        self.var = value.var\n        self.size = value.size\n        self.ptr = value.ptr\n\n    def get_value(self):\n        return self.ptr", "\n    "]}
{"filename": "src/variables/StringVariable.py", "chunked_list": ["from llvmlite import ir\nfrom llvmlite.ir import CallInstr \nfrom src.configs import MAX_STR_SIZE\nfrom ..basic_types import string\nfrom .Variable import Variable\n\n\nclass StringVariable(Variable):\n\n    basic_type: ir.Type = string\n    convert_func: ir.Function\n\n    def __init__(self, value: str | CallInstr | Variable, builder: ir.builder.IRBuilder) -> None:\n        if isinstance(value, CallInstr):\n            self.builder = builder\n            self.ptr = self.builder.alloca(self.basic_type)\n            self.builder.store(value, self.ptr)\n            self.ptr = self.builder.load(self.ptr)\n        elif isinstance(value, str):\n            if len(value) < MAX_STR_SIZE - 1:\n                value += \" \" * (MAX_STR_SIZE - 1 - len(value))\n            value += '\\0'\n            self.builder = builder\n            self.var = ir.Constant(ir.ArrayType(ir.IntType(8), MAX_STR_SIZE), bytearray(value, 'utf-8'))\n            self.ptr = self.builder.alloca(ir.ArrayType(ir.IntType(8), MAX_STR_SIZE))\n            self.builder.store(self.var, self.ptr)\n                \n            result = self.convert_func(self.builder, self)\n            self.ptr = self.builder.alloca(self.basic_type)\n            self.builder.store(result, self.ptr)\n            self.ptr = self.builder.load(self.ptr)\n        else:\n            self.var = self.builder.load(value.ptr)\n            self.ptr = self.builder.alloca(self.basic_type)\n            self.builder.store(self.var, self.ptr)\n\n    def get_value(self):\n        return self.ptr\n    \n    def copy_variable(self, builder: ir.builder.IRBuilder):\n        return StringVariable(self, builder)\n\n    def set_value(self, other_variable, builder):\n        return StringVariable(other_variable, builder)", ""]}
{"filename": "src/variables/__init__.py", "chunked_list": ["from .ColumnVariable import ColumnVariable\nfrom .IterVariable import IterVariable\nfrom .NumbVariable import NumbVariable\nfrom .RowVariable import RowVariable\nfrom .TableVariable import TableVariable\nfrom .StringVariable import StringVariable\nfrom .VoidVariable import VoidVariable\nfrom .Variable import Variable"]}
{"filename": "src/variables/ColumnVariable.py", "chunked_list": ["from llvmlite import ir\nfrom .IterVariable import IterVariable\nfrom .NumbVariable import NumbVariable\n\n\nclass ColumnVariable(IterVariable):\n\n    def __init__(self, elements: tuple, size: NumbVariable, builder: ir.builder.IRBuilder, ptr=None) -> None:\n        super().__init__(elements, size, builder, ptr)\n        \n    def copy_variable(self, builder):\n        return ColumnVariable(self, self.size, builder)", ""]}
{"filename": "src/variables/RowVariable.py", "chunked_list": ["from llvmlite import ir\nfrom .IterVariable import IterVariable\nfrom .NumbVariable import NumbVariable\n\n\nclass RowVariable(IterVariable):\n    def __init__(self, elements: list, size: NumbVariable, builder: ir.builder.IRBuilder) -> None:\n        super().__init__(elements, size, builder)\n\n    def set_value(self, value: IterVariable):\n        self.size = value.size\n        self.var = value.var\n        self.ptr = value.ptr\n\n    def copy_variable(self, builder):\n        return RowVariable(self, self.size, builder)", ""]}
{"filename": "src/variables/VoidVariable.py", "chunked_list": ["from llvmlite import ir\nfrom ..basic_types import void\n\n\nclass VoidVariable:\n    basic_type = void\n\n    def __init__(self) -> None:\n        pass\n", "\n"]}
{"filename": "src/variables/NumbVariable.py", "chunked_list": ["from llvmlite import ir\nfrom .Variable import Variable\n\n\nclass NumbVariable(Variable):\n    basic_type = ir.DoubleType()\n\n    def __init__(self, value: float | Variable | ir.instructions.Instruction, builder: ir.builder.IRBuilder) -> None:\n        self.builder = builder\n        value = float(value) if isinstance(value, int) else value\n        if isinstance(value, float):\n            self.var = ir.Constant(\n                self.basic_type,\n                value\n            )\n        elif isinstance(value, ir.instructions.Instruction):\n            self.var = value\n        else:\n            self.var = self.builder.load(value.ptr)\n        self.ptr = self.builder.alloca(self.basic_type)\n        self.builder.store(self.var, self.ptr)\n\n    def get_value(self):\n        return self.builder.load(self.ptr)\n\n    def copy_variable(self, builder: ir.builder.IRBuilder):\n        return NumbVariable(self, builder) \n\n    def set_value(self, other_variable):\n        self.var = other_variable.var\n        self.ptr = other_variable.ptr\n\n    def __add__(self, other_var) -> int:\n        return NumbVariable(\n            self.builder.fadd(\n                self.get_value(),\n                other_var.get_value()\n            ),\n            self.builder\n        )\n\n    def __eq__(self, other):\n        return NumbVariable(\n            ir.Constant(\n                self.basic_type,\n                self.raw_var == other.raw_var\n            ),\n            self.builder\n        )\n\n    def __ne__(self, other):\n        return NumbVariable(\n            ir.Constant(\n                self.basic_type,\n                self.raw_var != other.raw_var\n            ),\n            self.builder\n        )\n\n    def __sub__(self, other_var):\n        return NumbVariable(\n            self.builder.fsub(\n                self.get_value(),\n                other_var.get_value()\n            ),\n            self.builder\n        )\n\n    def __truediv__(self, other_var):\n        return NumbVariable(\n            self.builder.fdiv(\n                self.get_value(),\n                other_var.get_value()\n            ),\n            self.builder\n        )\n\n    def __floordiv__(self, other_var):\n        var1 = self.get_value()\n        var2 = other_var.get_value()\n        return NumbVariable(\n            self.builder.frem(\n                var1,\n                var2\n            ),\n            self.builder\n        )\n\n    def __mul__(self, other_var):\n        return NumbVariable(\n            self.builder.fmul(\n                self.get_value(),\n                other_var.get_value()\n            ),\n            self.builder\n        )", ""]}
{"filename": "src/variables/TableVariable.py", "chunked_list": ["from llvmlite import ir\nfrom src.configs import MAX_STR_SIZE\nfrom .IterVariable import IterVariable\nfrom .NumbVariable import NumbVariable\n\n\nclass TableVariable(IterVariable):\n\n    def __init__(self, elements: tuple, n_rows: NumbVariable, n_cols: NumbVariable, builder: ir.builder.IRBuilder) -> None:\n        super().__init__(elements, n_cols * n_rows, builder)\n\n        self.n_rows = n_rows\n        self.n_cols = n_cols\n\n    def set_value(self, value):\n        self.n_cols = value.n_cols\n        self.n_rows = value.n_rows\n        self.type = value.type\n        self.var = value.var\n        self.compile_init()\n\n    def copy_variable(self, builder):\n        return TableVariable(self, self.n_rows, self.n_cols, builder)", ""]}
