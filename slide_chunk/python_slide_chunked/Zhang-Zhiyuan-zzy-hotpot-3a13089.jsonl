{"filename": "setup.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : setup\n@Auther : Zhiyuan Zhang\n@Data   : 2023/7/21\n@Time   : 5:25\n\"\"\"\nimport setuptools\n", "import setuptools\n\n\nsetuptools.setup(\n    name=\"hotpot-zzy\",\n    version=\"0.3.1.0\",\n    description=\"A python package designed to communicate among various chemical and materials calculational tools\",\n    long_description=open(\"README.md\", \"r\").read(),\n    long_description_content_type=\"text/markdown\",\n    author=\"Zhiyuan Zhang\",", "    long_description_content_type=\"text/markdown\",\n    author=\"Zhiyuan Zhang\",\n    author_email=\"ZhiyuanZhang_scu@163.com\",\n    url=\"https://github.com/Zhang-Zhiyuan-zzy/hotpot\",\n    project_urls={\n        \"Homepage\": \"https://github.com/Zhang-Zhiyuan-zzy/hotpot\"\n    },\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",", "        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: Unix\",\n    ],\n    packages=setuptools.find_packages(),\n    install_requires=[\n        \"numpy\",\n        \"pandas\",\n        \"thermo\",\n        \"cclib\",", "        \"thermo\",\n        \"cclib\",\n        \"tqdm\",\n        \"rdkit\",\n        \"psutil\",\n    ],\n    include_package_data=True,\n)\n", ""]}
{"filename": "test/test_cheminfo.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : test_cheminfo\n@Auther : Zhiyuan Zhang\n@Data   : 2023/7/16\n@Time   : 22:21\nNotes:\n    Test `hotpot/cheminfo` module\n\"\"\"", "    Test `hotpot/cheminfo` module\n\"\"\"\nfrom pathlib import Path\nimport unittest as ut\nimport hotpot as hp\n\n\nclass TestMolecule(ut.TestCase):\n    \"\"\" Test `hotpot/cheminfo/Molecule` class \"\"\"\n    def test_read_from(self):\n        \"\"\" test the `read_from` method \"\"\"\n        mol_path = Path(hp.hp_root).joinpath('..', 'test', 'inputs', 'struct', 'abnormal_output.log')\n        mol_ab16log = hp.Molecule.read_from(mol_path, 'g16log', force=True)\n\n        self.assertIsInstance(mol_ab16log, hp.Molecule)\n        self.assertTrue(mol_ab16log.has_3d)\n        self.assertGreater(mol_ab16log.conformer_counts, 1)", ""]}
{"filename": "test/__init__.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : __init__.py\n@Auther : Zhiyuan Zhang\n@Data   : 2023/7/16\n@Time   : 22:19\n\"\"\"\n", ""]}
{"filename": "test/test_quantum.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : test_quantum\n@Auther : Zhiyuan Zhang\n@Data   : 2023/7/19\n@Time   : 22:08\n\"\"\"\nimport os\n", "import os\n\nimport unittest as ut\nimport hotpot as hp\n\n\nclass TestGaussian(ut.TestCase):\n    \"\"\"\"\"\"\n    def test_run_gaussian(self):\n        if os.environ.get('g16root'):\n            test_dir = os.path.join(hp.hp_root, '..', 'test', 'output', 'gaussrun')\n            if not os.path.exists(test_dir):\n                os.mkdir(test_dir)\n            os.chdir(test_dir)\n\n            g16root = \"/home/pub\"\n\n            mol = hp.Molecule.read_from('c1cc2(O[Fe+3]O2)(N)ccc1', 'smi')\n            mol.build_3d()\n\n            mol.gaussian(\n                g16root=g16root,\n                link0=[\"nproc=16\", \"mem=64GB\"],\n                route=\"opt M062X/6-311\",\n                inplace_attrs=True\n            )", ""]}
{"filename": "hotpot/cheminfo.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : cheminfo.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/3/14\n@Time   : 4:09\n\"\"\"\nimport copy\nimport json", "import copy\nimport json\nimport os\nimport re\nfrom abc import ABC, abstractmethod\nfrom io import IOBase\nfrom os import PathLike\nfrom os.path import join as opj\nfrom pathlib import Path\nfrom typing import *", "from pathlib import Path\nfrom typing import *\nfrom itertools import product\n\nimport numpy as np\nfrom openbabel import openbabel as ob, pybel as pb\nfrom rdkit import Chem\nfrom rdkit.Chem import Draw\n\nfrom hotpot import data_root", "\nfrom hotpot import data_root\nfrom hotpot.tanks import lmp\nfrom hotpot.tanks.qm.gaussian import Gaussian, GaussianRunError, GaussRun, Debugger\nfrom hotpot.utils.library import library as _lib  # The chemical library\n\n\n# Define Exceptions\nclass OperateOBMolFail(BaseException):\n    \"\"\" Raise for any fail that trys to operate the OBMol \"\"\"", "class OperateOBMolFail(BaseException):\n    \"\"\" Raise for any fail that trys to operate the OBMol \"\"\"\n\n\nclass AddAtomFail(OperateOBMolFail):\n    \"\"\" Raise when add an atom into Molecule fail \"\"\"\n\n\nclass AddBondFail(OperateOBMolFail):\n    \"\"\" Raise when add a bond into Molecule fail \"\"\"", "class AddBondFail(OperateOBMolFail):\n    \"\"\" Raise when add a bond into Molecule fail \"\"\"\n\n\n# periodic_table = json.load(open(opj(data_root, 'periodic_table.json'), encoding='utf-8'))\nperiodic_table = _lib.get('PeriodicTable')  # hotpot.utils.library.PeriodicTabel\n\n_stable_charges = {\n    \"H\": 1,  \"He\": 0,\n    \"Li\": 1, \"Be\": 2, \"B\": 3,  \"C\": 4,  \"N\": -3,  \"O\": -2,  \"F\": -1,  \"Ne\": 0,", "    \"H\": 1,  \"He\": 0,\n    \"Li\": 1, \"Be\": 2, \"B\": 3,  \"C\": 4,  \"N\": -3,  \"O\": -2,  \"F\": -1,  \"Ne\": 0,\n    \"Na\": 1, \"Mg\": 2, \"Al\": 3, \"Si\": 4, \"P\": -3,  \"S\": -2,  \"Cl\": -1, \"Ar\": 0,\n    \"K\": 1,  \"Ca\": 2, \"Ga\": 3, \"Ge\": 4, \"As\": -3, \"Se\": -2, \"Br\": -1, \"Kr\": 0,\n    \"Rb\": 1, \"Sr\": 2, \"In\": 3, \"Sn\": 2, \"Sb\": -3, \"Te\": -2, \"I\": -1,  \"Xe\": 0,\n    \"Cs\": 1, \"Ba\": 2, \"Tl\": 3, \"Pb\": 2, \"Bi\": 3,  \"Po\": -2, \"At\": -1, \"Rn\": 0,\n    \"Fr\": 1, \"Ra\": 2, \"Nh\": 8, \"Fl\": 8, \"Mc\": 8,  \"Lv\": 8,  \"Ts\": 8,  \"Og\": 8,\n\n    \"Sc\": 3, \"Ti\": 4, \"V\": 5,  \"Cr\": 3, \"Mn\": 2,  \"Fe\": 3,  \"Co\": 3,  \"Ni\": 2, \"Cu\": 2, \"Zn\": 2,\n    \"Y\": 3,  \"Zr\": 4, \"Nb\": 5, \"Mo\": 6, \"Tc\": 7,  \"Ru\": 4,  \"Rh\": 3,  \"Pd\": 2, \"Ag\": 1, \"Cd\": 2,", "    \"Sc\": 3, \"Ti\": 4, \"V\": 5,  \"Cr\": 3, \"Mn\": 2,  \"Fe\": 3,  \"Co\": 3,  \"Ni\": 2, \"Cu\": 2, \"Zn\": 2,\n    \"Y\": 3,  \"Zr\": 4, \"Nb\": 5, \"Mo\": 6, \"Tc\": 7,  \"Ru\": 4,  \"Rh\": 3,  \"Pd\": 2, \"Ag\": 1, \"Cd\": 2,\n    \"Lu\": 3, \"Hf\": 4, \"Ta\": 5, \"W\": 6,  \"Re\": 7,  \"Os\": 4,  \"Ir\": 3,  \"Pt\": 2, \"Au\": 1, \"Hg\": 2,\n    \"Lr\": 3, \"Rf\": 4, \"Db\": 5, \"Sg\": 6, \"Bh\": 7,  \"Hs\": 8,  \"Mt\": 8,  \"Ds\": 8, \"Rg\": 8, \"Cn\": 8,\n\n    \"La\": 3, \"Ce\": 4, \"Pr\": 3, \"Nd\": 3, \"Pm\": 3,  \"Sm\": 3,  \"Eu\": 2,  \"Gd\": 3, \"Tb\": 3, \"Dy\": 3, \"Ho\": 3, \"Er\": 3, \"Tm\": 3, \"Yb\": 3,\n    \"Ac\": 3, \"Th\": 4, \"Pa\": 5, \"U\": 6,  \"Np\": 6,  \"Pu\": 6,  \"Am\": 6,  \"Cm\": 6, \"Bk\": 6, \"Cf\": 6, \"Es\": 6, \"Fm\": 6, \"Md\": 6, \"No\": 6,\n}\n\n", "\n\n_bond_type = {\n    'Unknown': 0,\n    'Single': 1,\n    'Double': 2,\n    'Triple': 3,\n    'Aromatic': 5,\n}\n", "}\n\n_type_bond = {\n    0: 'Unknown',\n    1: 'Single',\n    2: 'Double',\n    3: 'Triple',\n    5: 'Aromatic'\n}\n", "}\n\n_ob_data_dict = {\n    0: 'UndefinedData', 1: 'PairData', 2: 'EnergyData', 3: 'CommentData',\n    4: 'ConformerData', 5: 'ExternalBondData', 6: 'RotamerList', 7: 'VirtualBondData',\n    8: 'RingData', 9: 'TorsionData', 10: 'AngleData', 11: 'SerialNums',\n    12: 'UnitCell', 13: 'SpinData', 14: 'ChargeData', 15: 'SymmetryData',\n    16: 'ChiralData', 17: 'OccupationData', 18: 'DensityData', 19: 'ElectronicData',\n    20: 'VibrationData', 21: 'RotationData', 22: 'NuclearData', 23: 'SetData',\n    24: 'GridData', 25: 'VectorData', 26: 'MatrixData', 27: 'StereoData',", "    20: 'VibrationData', 21: 'RotationData', 22: 'NuclearData', 23: 'SetData',\n    24: 'GridData', 25: 'VectorData', 26: 'MatrixData', 27: 'StereoData',\n    28: 'DOSData', 29: 'ElectronicTransitionData', 16384: 'CustomData0', 16385: 'CustomData1',\n    16386: 'CustomData2', 16387: 'CustomData3', 16388: 'CustomData4', 16389: 'CustomData5',\n    16390: 'CustomData6', 16391: 'CustomData7', 16392: 'CustomData8', 16393: 'CustomData9',\n    16394: 'CustomData10', 16395: 'CustomData11', 16396: 'CustomData12', 16397: 'CustomData13',\n    19398: 'CustomData14', 16399: 'CustomData15'\n}\n\n\nclass Wrapper(ABC):\n    \"\"\"\n    A wrapper of chemical information and data.\n    The _set_attrs method is used to set any keyword attribute, the attribute names, in the wrapper context, are defined\n    by the keys from returned dict of _attr_setters; the values of the returned dict of _attr_setters are a collection\n    of specific private method to wrapper and call openbabel method to set the attributes in openbabel object.\n    \"\"\"\n    _data = {}  # all attributes of wrappers are stored into\n\n    @property\n    def _ob_obj(self) -> Union[ob.OBMol, ob.OBAtom, ob.OBBond, ob.OBAngle, ob.OBUnitCell]:\n        return self._data.get('ob_obj')\n\n    @property\n    def _protected_data(self):\n        \"\"\"\n        the protected attr in data which could not be replaced by call methods:\n            - update_attr_data()\n        \"\"\"\n        return ('ob_obj',)\n\n    def _set_attrs(self, **kwargs):\n        \"\"\"    Set any atomic attributes by name    \"\"\"\n        attr_setters = self._attr_setters\n        for name, value in kwargs.items():\n            setter = attr_setters.get(name)\n\n            if setter:  # if the attribute is exist in the object.\n                assert isinstance(setter, Callable)\n                setter(value)\n\n            else:\n                raise NameError(\n                    f'the {name} is cannot be set by {self.__class__.__name__}.set(), '\n                    f'the legal attrs include: {self._attr_setters.keys()}'\n                )\n\n    @property\n    @abstractmethod\n    def _attr_setters(self) -> Dict[str, Callable]:\n        raise NotImplemented\n\n    def _get_ob_comment_data(self, data_name: str):\n        \"\"\" Retrieve OBCommentData according to specific data_name \"\"\"\n        comment = self._ob_obj.GetData(data_name)\n        if comment:\n            comment = ob.toCommentData(comment)\n            return comment.GetData()\n        return None\n\n    @property\n    def data(self) -> dict:\n        \"\"\" Get the clone of attributes data dict \"\"\"\n        return copy.copy(self._data)\n\n    def kwargs_setters(self):\n        list_setters = [f'{k}: {s.__doc__}' for k, s in self._attr_setters.items()]\n        print(\"\\n\".join(list_setters))\n\n    def remove_ob_data(self, data_name: str):\n        \"\"\" Remove specific OBData item by given data_name \"\"\"\n        self._ob_obj.DeleteData(data_name)\n\n    def replace_attr_data(self, data: Dict):\n        \"\"\" Replace the core data dict directly \"\"\"\n        self._data = data\n\n    def set_ob_comment_data(self, attr_name: str, value: str):\n        \"\"\" Set the OBCommentData for ob_obj \"\"\"\n        comment_data = ob.OBCommentData()\n\n        comment_data.SetAttribute(attr_name)\n        comment_data.SetData(value)\n\n        self._ob_obj.CloneData(comment_data)\n\n    @property\n    def setter_keys(self):\n        return list(self._attr_setters.keys())\n\n    @property\n    def temp_label(self):\n        \"\"\" Retrieve the temp label \"\"\"\n        return self._get_ob_comment_data('temp_label')\n\n    def update_attr_data(self, data: dict):\n        \"\"\" update the attribute data by give dict \"\"\"\n        for data_attr in self._protected_data:\n            if data.get(data_attr):\n                data.pop(data_attr)\n\n        self._data.update(data)", "\n\nclass Wrapper(ABC):\n    \"\"\"\n    A wrapper of chemical information and data.\n    The _set_attrs method is used to set any keyword attribute, the attribute names, in the wrapper context, are defined\n    by the keys from returned dict of _attr_setters; the values of the returned dict of _attr_setters are a collection\n    of specific private method to wrapper and call openbabel method to set the attributes in openbabel object.\n    \"\"\"\n    _data = {}  # all attributes of wrappers are stored into\n\n    @property\n    def _ob_obj(self) -> Union[ob.OBMol, ob.OBAtom, ob.OBBond, ob.OBAngle, ob.OBUnitCell]:\n        return self._data.get('ob_obj')\n\n    @property\n    def _protected_data(self):\n        \"\"\"\n        the protected attr in data which could not be replaced by call methods:\n            - update_attr_data()\n        \"\"\"\n        return ('ob_obj',)\n\n    def _set_attrs(self, **kwargs):\n        \"\"\"    Set any atomic attributes by name    \"\"\"\n        attr_setters = self._attr_setters\n        for name, value in kwargs.items():\n            setter = attr_setters.get(name)\n\n            if setter:  # if the attribute is exist in the object.\n                assert isinstance(setter, Callable)\n                setter(value)\n\n            else:\n                raise NameError(\n                    f'the {name} is cannot be set by {self.__class__.__name__}.set(), '\n                    f'the legal attrs include: {self._attr_setters.keys()}'\n                )\n\n    @property\n    @abstractmethod\n    def _attr_setters(self) -> Dict[str, Callable]:\n        raise NotImplemented\n\n    def _get_ob_comment_data(self, data_name: str):\n        \"\"\" Retrieve OBCommentData according to specific data_name \"\"\"\n        comment = self._ob_obj.GetData(data_name)\n        if comment:\n            comment = ob.toCommentData(comment)\n            return comment.GetData()\n        return None\n\n    @property\n    def data(self) -> dict:\n        \"\"\" Get the clone of attributes data dict \"\"\"\n        return copy.copy(self._data)\n\n    def kwargs_setters(self):\n        list_setters = [f'{k}: {s.__doc__}' for k, s in self._attr_setters.items()]\n        print(\"\\n\".join(list_setters))\n\n    def remove_ob_data(self, data_name: str):\n        \"\"\" Remove specific OBData item by given data_name \"\"\"\n        self._ob_obj.DeleteData(data_name)\n\n    def replace_attr_data(self, data: Dict):\n        \"\"\" Replace the core data dict directly \"\"\"\n        self._data = data\n\n    def set_ob_comment_data(self, attr_name: str, value: str):\n        \"\"\" Set the OBCommentData for ob_obj \"\"\"\n        comment_data = ob.OBCommentData()\n\n        comment_data.SetAttribute(attr_name)\n        comment_data.SetData(value)\n\n        self._ob_obj.CloneData(comment_data)\n\n    @property\n    def setter_keys(self):\n        return list(self._attr_setters.keys())\n\n    @property\n    def temp_label(self):\n        \"\"\" Retrieve the temp label \"\"\"\n        return self._get_ob_comment_data('temp_label')\n\n    def update_attr_data(self, data: dict):\n        \"\"\" update the attribute data by give dict \"\"\"\n        for data_attr in self._protected_data:\n            if data.get(data_attr):\n                data.pop(data_attr)\n\n        self._data.update(data)", "\n\nclass MolLinker:\n    \"\"\" This class offer methods to link to parent molecule object and retrieve associated value from the molecule \"\"\"\n    class LinkerKey:\n        def __init__(self, *ob_atoms: ob.OBAtom):\n            self.ob_atoms = ob_atoms\n\n        def __repr__(self):\n            return str(self.key)\n\n        def __eq__(self, other: 'MolLinker.LinkerKey'):\n            return self.key == other.key or self.key == other.key[::-1]\n\n        def __hash__(self):\n            return hash(self.key)\n\n        @property\n        def key(self):\n            return tuple(aba.GetId() for aba in self.ob_atoms)\n\n    def __init__(self, mol: 'Molecule', *ob_ids: int):\n        \"\"\"\"\"\"\n        self.mol = mol\n        self.ob_atoms = tuple(mol.atoms_dict[obi].ob_atom for obi in ob_ids)\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({\", \".join([a.label for a in self.atoms])}; {self._degree})'\n\n    def __eq__(self, other: 'Torsion'):\n        return self.linker_key == other.linker_key\n\n    def __getitem__(self, item):\n        return self.data.get(item, {})\n\n    def __setitem__(self, key, value):\n        self.update_attr_data({key: value})\n\n    @property\n    @abstractmethod\n    def _degree(self) -> float:\n        raise NotImplementedError('')\n\n    @property\n    def atoms(self) -> List['Atom']:\n        return [self.mol.atoms_dict[obi] for obi in self.atoms_ob_id]\n\n    @property\n    def atoms_ob_id(self):\n        return tuple(oba.GetId() for oba in self.ob_atoms)\n\n    @property\n    def data(self) -> Dict:\n        data: Dict[MolLinker.LinkerKey, Dict[Hashable, Any]] = self.mol.data.get(self.__class__.__name__, {})\n        return data.setdefault(self.linker_key, {})\n\n    @property\n    def linker_key(self) -> LinkerKey:\n        return self.LinkerKey(*self.ob_atoms)\n\n    def update_attr_data(self, update_data: Dict):\n        all_angle_data: Dict[MolLinker.LinkerKey, Dict[Hashable, Any]] = self.mol.data.get(self.__class__.__name__, {})\n        data: Dict[Hashable, Any] = all_angle_data.setdefault(self.linker_key, {})\n        data.update(update_data)\n\n        self.mol.update_attr_data({self.__class__.__name__: all_angle_data})", "\n\nclass Molecule(Wrapper, ABC):\n    \"\"\"\"\"\"\n    # All Molecule attribute's items relating to molecule conformers\n    conformer_items = (\n        # the items are ranked by the number of values for each atom, for example:\n        #   - the all_atom_charges and atom_spin_densities have 1 value for each atom, so they are placed in the second\n        #     item (with the index 1)\n        #   - the coordinates have 3 values for each atom, i.e., [x, y, z], so it is placed in the forth\n        #     item (with the index 3\uff09\n        # For the molecular attributes, which have only one value for each conformer and represent the attribute\n        # of whole molecule, they are place in the first item (with the index 0)\n        ('all_energy', 'identifier_array'),\n        ('all_atom_charges', 'all_atom_spin_densities'),\n        (),\n        ('all_coordinates', 'all_forces')\n    )\n\n    def __init__(self, ob_mol: ob.OBMol = None, _data: dict = None, **kwargs):\n        if _data:\n            self._data: dict = _data\n        else:\n            self._data: dict = {\n                'ob_obj': ob_mol if ob_mol else ob.OBMol()\n            }\n        self._set_attrs(**kwargs)\n        self._load_atoms()\n        self._load_bonds()\n\n    def __repr__(self):\n        return f'Mol({self.ob_mol.GetSpacedFormula()})'\n\n    def __add__(self, other: ['Molecule']):\n        \"\"\"\n        Two Molecule objects could add to a new one to merge all of their conformers.\n        All information about the conformer will be merged to one.\n        the other information will reserve the one in the left item\n        Args:\n            other: the right item\n\n        Returns:\n            Molecule\n        \"\"\"\n        # When other obj is a Molecule or a child of Molecule\n        if isinstance(other, Molecule):\n            # If this one is compatible to the other\n            if self.iadd_accessible(other):\n                clone = self.copy()\n                clone += other\n\n                return clone\n\n            # If the other one is compatible to this one\n            if other.iadd_accessible(self):\n                clone = other.copy()\n                clone += self\n\n                return clone\n\n            # If they are compatible, but are Molecule or child of Molecule\n            return bd.MolBundle([self, other])\n\n        # if isinstance(other, MixSameAtomMol):\n        #     return self.to_mix_mol() + other\n\n        # When other obj is a MolBundle\n        if isinstance(other, bd.MolBundle):\n            return other.__class__([self] + other.mols)\n\n        else:\n            raise TypeError('the Molecule only add with Molecule or MolBundle')\n\n    def __iadd__(self, other):\n        \"\"\"\n        Self add with other Molecule object with consist atoms list,\n        The attributes or information about conformers will merge with the other,\n        other attributes or information will be reserved\n        Args:\n            other: the merged Molecule object\n\n        Returns:\n            None\n        \"\"\"\n        if not isinstance(other, Molecule):\n            raise TypeError('the Molecule object is only allowed to add with other Molecule')\n\n        # Check whether left and right Molecules have consist atom list\n        if not self.iadd_accessible(other):\n            raise AttributeError(\n                'the self addition cannot be performed among molecules with different atoms list!'\n            )\n\n        return self._merge_conformer_attr(other)\n\n    def __iter__(self):\n        \"\"\" Return self with different conformers \"\"\"\n\n        def conformer_generator():\n            for i in range(self.conformer_counts):\n                self.conformer_select(i)\n                yield self\n\n        return iter(conformer_generator())\n\n    def __next__(self):\n        config_idx = self._data.get('config_idx', 0)\n        try:\n            self.conformer_select(config_idx)\n            self._data['config_idx'] = config_idx + 1\n            return self\n        except IndexError:\n            raise StopIteration\n\n    def __eq__(self, other):\n        \"\"\" if two molecule with 1.0 similarity in 2FP fingerprint they are identical \"\"\"\n        if self.similarity(other) == 1.0:\n            return True\n        return False\n\n    def _add_temp_atom_labels(self):\n        \"\"\"\n        Add temp atom label, These label will assist in the implementation of certain functions,\n        say Molecule.components. These label should be deleted after the assisted functions have\n        been fulfilled, by call method _delete_temp_atom_labels(self)\n        \"\"\"\n        for i, atom in enumerate(self.atoms):\n            atom.set_ob_comment_data('temp_label', str(i))\n\n    @staticmethod\n    def _assign_coordinates(the_mol: 'Molecule', coordinates: np.ndarray):\n        \"\"\" Assign coordinates for all atoms in the Molecule \"\"\"\n        if len(the_mol.atoms) != coordinates.shape[-2]:\n            raise AttributeError('the coordinate matrix do not match the number of atoms')\n\n        for new_mol_atom, new_atom_coord in zip(the_mol.atoms, coordinates):\n            new_mol_atom.coordinates = new_atom_coord\n\n    @property\n    def _attr_setters(self) -> Dict[str, Callable]:\n        return {\n            'atoms.partial_charge': self._set_atoms_partial_charge,\n            \"identifier\": self._set_identifier,\n            \"energy\": self._set_energy,\n            'all_energy': self._set_all_energy,\n            'charge': self._set_mol_charge,\n            'all_atom_charges': self._set_all_atom_charges,\n            'all_atom_spin_densities': self._set_all_atom_spin_densities,\n            'spin': self._set_spin_multiplicity,\n            'atoms': self._set_atoms,\n            'mol_orbital_energies': self._set_mol_orbital_energies,\n            'coordinates': self._set_coordinates,\n            'all_coordinates': self._set_all_coordinates,\n            'all_forces': self._set_all_forces,\n            'forces': self._set_forces,\n            'crystal': self.create_crystal_by_matrix\n        }\n\n    def _create_ob_unit_cell(self):\n        \"\"\" Create New OBUnitCell for the Molecule \"\"\"\n        ob_unit_cell = ob.OBUnitCell()\n        self.ob_mol.CloneData(ob_unit_cell)\n\n    def _delete_atoms_temp_label(self):\n        \"\"\" Remove temp label of all atoms \"\"\"\n        for a in self.atoms:\n            a.remove_ob_data('temp_label')\n\n    def _delete_bonds_temp_label(self):\n        \"\"\" Remove temp label of all bonds \"\"\"\n        for b in self.bonds:\n            b.remove_ob_data('temp_label')\n\n    def _get_critical_params(self, name: str):\n        critical_params = self._data.get('critical_params')\n        if critical_params is None:\n            critical_params = json.load(open(opj(data_root, 'thermo', 'critical.json'))).get(self.smiles)\n            if critical_params:\n                self._data['critical_params'] = critical_params\n                return critical_params[name]\n            else:\n                self._data['critical_params'] = False\n                return False\n\n        else:\n            return critical_params[name]\n\n    def _has_atom_temp_label(self):\n        return any(atom.temp_label for atom in self.atoms)\n\n    def _pert_mol_generate(self, coordinates: Union[Sequence, np.ndarray]):\n        \"\"\"\n        Generate new molecule obj according to new given coordinate\n        Args:\n            coordinates: New coordinates matrix\n\n        Returns:\n            Molecule, copy of this molecule with new coordinates\n        \"\"\"\n        clone_mol = self.copy()\n        self._assign_coordinates(clone_mol, coordinates)\n        return clone_mol\n\n    def _load_atoms(self) -> Dict[int, 'Atom']:\n        \"\"\"\n        Construct atoms dict according to the OBAtom in the OBMol,\n        where the keys of the dict are the ob_id of OBAtom and the values are the the constructed Atom objects\n        the constructed dict would be place into the _data dict\n        Returns:\n            the atoms dict\n        \"\"\"\n        atoms: Dict[int, Atom] = self._data.get('atoms', {})\n\n        new_atoms = {}\n        for new_ob_id, oba in enumerate(ob.OBMolAtomIter(self.ob_mol)):\n            atom = atoms.get(oba.GetId(), Atom(oba, mol=self))\n            oba.SetId(new_ob_id)\n            new_atoms[new_ob_id] = atom\n\n        self._data['atoms'] = new_atoms\n\n        return new_atoms\n\n    def _load_bonds(self) -> Dict[int, 'Bond']:\n        \"\"\"\n        Construct bonds dict according to the OBBond in the OBMol,\n        where the keys of the dict are the ob_id of OBBond and the values are the the constructed Bond objects\n        the constructed dict would be place into the _data dict\n        Returns:\n            dict of bonds\n        \"\"\"\n        bonds: Dict = self._data.get('bonds', {})  # Get the stored bonds\n\n        new_bonds = {}\n        for new_ob_id, obb in enumerate(ob.OBMolBondIter(self.ob_mol)):\n            bond = bonds.get(obb.GetId(), Bond(obb, self))  # Get old bond by old id\n            obb.SetId(new_ob_id)  # Specify new id\n            new_bonds[new_ob_id] = bond\n\n        self._data['bonds'] = new_bonds\n\n        return new_bonds\n\n    @staticmethod\n    def _melt_quench(\n            elements: Dict[str, float], force_field: Union[str, os.PathLike], mol: \"Molecule\" = None,\n            density: float = 1.0, a: float = 25., b: float = 25., c: float = 25.,\n            alpha: float = 90., beta: float = 90., gamma: float = 90., time_step: float = 0.0001,\n            origin_temp: float = 298.15, melt_temp: float = 4000., highest_temp: float = 10000.,\n            ff_args: Sequence = (), path_writefile: Optional[str] = None, path_dump_to: Optional[str] = None,\n            dump_every: int = 100,\n    ):\n        \"\"\" to perform the melt-quench by call lmp.AmorphousMaker \"\"\"\n        am = lmp.AmorphousMaker(elements, force_field, density, a, b, c, alpha, beta, gamma)\n        mol = am.melt_quench(\n            *ff_args, mol=mol, path_writefile=path_writefile, path_dump_to=path_dump_to, origin_temp=origin_temp,\n            melt_temp=melt_temp, highest_temp=highest_temp, time_step=time_step, dump_every=dump_every\n        )\n\n        return mol\n\n    def _merge_conformer_attr(self, other: 'Molecule'):\n        \"\"\" Merge attributes, relate to molecule conformer, in other Molecule into this Molecule \"\"\"\n\n        def merge_attr(attr_name: str):\n            \"\"\" Merge single conformer attr \"\"\"\n            left_attr = getattr(self, attr_name)\n            right_attr = getattr(other, attr_name)\n\n            if isinstance(left_attr, np.ndarray) and isinstance(right_attr, np.ndarray):\n                self._data[attr_name] = np.concatenate([left_attr, right_attr])\n            elif not (  # If the left and right values are not both empty, raise Attributes error.\n                    (left_attr is None) or (isinstance(left_attr, np.ndarray) and (not left_attr.all())) and\n                    (right_attr is None) or (isinstance(right_attr, np.ndarray) and (not right_attr.all()))\n            ):\n                raise AttributeError(\n                    f'the conformer relational attribute {attr_name} is different in:\\n'\n                    f'  - {self}_identifier: {self.identifier}\\n'\n                    f'  - {other}_identifier: {other.identifier}'\n                    'they cannot to perform addition operation'\n                )\n\n        for i, items in enumerate(self.conformer_items):\n            for item in items:\n                merge_attr(item)\n\n        return self\n\n    def _preserve_atoms_data(self):\n        \"\"\"\n        Preserve atoms data dict before destroy them.\n        Though the atoms are destroyed, their core ob_atom will be prevented,\n        The reserve data will match with the core ob_atoms\n        \"\"\"\n        # Link the old atoms data dict with new atoms by temp labels\n        self._add_temp_atom_labels()\n        return {a.temp_label: a.data for a in self.atoms}\n\n    def _preserve_bonds_data(self):\n        \"\"\"\"\"\"\n        if not self._has_atom_temp_label():\n            self._add_temp_atom_labels()\n\n        return {(b.atom1.temp_label, b.atom2.temp_label): b.data for b in self.bonds}\n\n    def _preserve_angles_data(self):\n        if not self._has_atom_temp_label():\n            self._add_temp_atom_labels()\n\n        return {tuple(atom.temp_label for atom in angle.atoms): angle.data for angle in self.angles}\n\n    def _preserve_torsion_data(self):\n        if not self._has_atom_temp_label():\n            self._add_temp_atom_labels()\n\n        return {tuple(atom.temp_label for atom in torsion.atoms): torsion.data for torsion in self.torsions}\n\n    @property\n    def _protected_data(self):\n        return 'ob_obj', 'atoms', 'bonds', 'angles'\n\n    def _reorder_atom_ob_id(self):\n        \"\"\" Reorder the ob id of atoms \"\"\"\n        new_atom_dict = {}\n        for ob_id, atom in enumerate(self.atoms):\n            atom.ob_atom.SetId(ob_id)\n            new_atom_dict[ob_id] = atom\n\n        self._data['atoms'] = new_atom_dict\n\n    def _reorder_bond_ob_id(self):\n        new_atom_dict = {}\n        for ob_id, bond in enumerate(self.bonds):\n            bond.ob_bond.SetId(ob_id)\n            new_atom_dict[ob_id] = bond\n\n        self._data['bonds'] = new_atom_dict\n\n    def _reorganize_atom_indices(self):\n        \"\"\" reorganize or rearrange the indices for all atoms \"\"\"\n        for i, ob_atom in enumerate(ob.OBMolAtomIter(self.ob_mol)):\n            ob_atom.SetId(i)\n\n    def _set_atoms(self, atoms_kwargs: List[Dict[str, Any]]):\n        \"\"\" add a list of atoms by a list atoms attributes dict \"\"\"\n        for atom_kwarg in atoms_kwargs:\n            a = Atom(**atom_kwarg)\n            self.add_atom(a)\n\n    def _set_atoms_partial_charge(self, partial_charges: [np.ndarray, Sequence[float]]):\n        \"\"\" Set partial charges for all atoms in the molecule \"\"\"\n        if not isinstance(partial_charges, (np.ndarray, Sequence[int])):\n            raise TypeError(\n                f'the `partial_charges` should be np.ndarray or Sequence of float, not {type(partial_charges)}'\n            )\n\n        if self.atom_counts != len(partial_charges):\n            raise ValueError('the given partial charges should have same numbers with the number of atoms')\n\n        for atom, partial_charge in zip(self.atoms, partial_charges):\n            atom.partial_charge = partial_charge\n\n    def _set_all_coordinates(self, all_coordinates: np.ndarray):\n        \"\"\"\n        Assign the coordinates collection directly\n        Args:\n            all_coordinates: numpy array with the shape (M, N, 3), where the M is the number of coordinates\n            in the collection, the N is the number of atoms of the molecule.\n\n        Returns:\n            None\n        \"\"\"\n        if not isinstance(all_coordinates, np.ndarray):\n            raise ValueError(\n                f'the given all_coordinates must be a numpy.ndarray class, instead of {type(all_coordinates)}')\n\n        if all_coordinates.shape[-1] != 3:\n            raise ValueError(f'the coordinate must be 3 dimension, instead of {all_coordinates.shape[-1]}')\n\n        if len(all_coordinates.shape) == 2:\n            # if only give a group of coordinates\n            all_coordinates = all_coordinates.reshape((-1, all_coordinates.shape[-2], 3))\n        elif len(all_coordinates.shape) != 3:\n            raise ValueError(\n                f'the shape of given all_coordinates should with length 2 or 3, now is {len(all_coordinates.shape)}'\n            )\n\n        self._data['all_coordinates'] = all_coordinates\n\n    def _set_coordinates(self, coordinates: np.ndarray):\n        \"\"\" Assign the coordinates for all atoms in the molecule \"\"\"\n        assert isinstance(coordinates, np.ndarray)\n        assert coordinates.shape == (self.atom_counts, 3)\n\n        for a, c in zip(self.atoms, coordinates):\n            a.coordinates = c\n\n    def _set_atom_charges(self, charge: Union[Sequence, np.ndarray]):\n        \"\"\" Set partial charge for each atoms in the mol \"\"\"\n        if not isinstance(charge, (Sequence, np.ndarray)):\n            raise TypeError(f'the charge should be a sequence or np.ndarray, got {type(charge)}')\n\n        if isinstance(charge, np.ndarray):\n            charge = charge.flatten()\n\n        if len(charge) != self.atom_counts:\n            raise ValueError('the number of charges do not match with the atom charge')\n\n        for atom, ch in zip(self.atoms, charge):\n            atom.partial_charge = ch\n\n    def _set_all_atom_charges(self, charges: np.ndarray):\n        \"\"\"\n        set groups of charges for each atoms in the mol, and each group of charges are corresponding to a\n        conformer of the mol\n        Args:\n            charges: group of atoms with the shape of (C, N), where the C is the number of the conformer\n             and the N is the number of the atom in the molecule\n        \"\"\"\n        if not isinstance(charges, np.ndarray):\n            raise TypeError('the arg charges should be np.ndarray')\n\n        if len(charges.shape) != 2 and charges.shape[1] != self.atom_counts:\n            raise ValueError('the shape of the arg: charge should be (number_of_conformer, number_of_atoms),'\n                             f'got the value with shape {charges.shape}')\n\n        self._data['all_atom_charges'] = charges\n\n    def _set_all_atom_spin_densities(self, group_spd: np.ndarray) -> None:\n        \"\"\"\n        assign groups of spin densities for all atom in molecule, each group is corresponding to a conformer\n        Args:\n            group_spd(np.ndarray): group of spin densities, the numpy array with the (C, N) shape,\n             where the C is the number of conformer, the N is the number of atoms\n        \"\"\"\n        if not isinstance(group_spd, np.ndarray):\n            raise TypeError('the arg group_spd should be np.ndarray')\n\n        if len(group_spd.shape) != 2 and group_spd.shape[1] != self.atom_counts:\n            raise ValueError('the shape of the arg: group_spd should be (number_of_conformer, number_of_atoms),'\n                             f'got the value with shape {group_spd.shape}')\n\n        self._data['all_atom_spin_densities'] = group_spd\n\n    def _set_atom_spin_densities(self, spd: Union[Sequence, np.ndarray]):\n        \"\"\" assign the spin density for each of atoms in the mol \"\"\"\n        if not isinstance(spd, (Sequence, np.ndarray)):\n            raise TypeError(f'the charge should be a sequence or np.ndarray, got {type(spd)}')\n\n        if isinstance(spd, np.ndarray):\n            spd = spd.flatten()\n\n        if len(spd) != self.atom_counts:\n            raise ValueError('the number of charges do not match with the atom charge')\n\n        for atom, sp in zip(self.atoms, spd):\n            atom.spin_density = sp\n\n    def _set_forces(self, forces: np.ndarray):\n        \"\"\" Set the force vectors for each atoms in the molecule \"\"\"\n        if not isinstance(forces, np.ndarray):\n            raise TypeError('the forces should be np.ndarray')\n\n        if len(forces.shape) != 2:\n            raise ValueError('the length of shape of forces should be 2')\n\n        if forces.shape[-2] != self.atom_counts:\n            raise ValueError('the give forces do not match to the number of atoms')\n\n        for atom, force_vector in zip(self.atoms, forces):\n            atom.force_vector = force_vector\n\n    def _set_all_forces(self, all_forces: np.ndarray):\n        \"\"\" Store the force matrix into the attribute dict \"\"\"\n        if not isinstance(all_forces, np.ndarray):\n            raise TypeError('the all_forces should be np.ndarray')\n\n        if len(all_forces.shape) != 3:\n            raise ValueError('the length of shape of all_forces should be 3')\n\n        if all_forces.shape[-2] != self.atom_counts:\n            raise ValueError('the give all_forces do not match to the number of atoms')\n\n        self._data['all_forces'] = all_forces\n\n    def _set_mol_charge(self, charge: int):\n        self.ob_mol.SetTotalCharge(charge)\n\n    def _set_mol_orbital_energies(self, orbital_energies: list[np.ndarray]):\n        self._data['mol_orbital_energies'] = orbital_energies[0]\n\n    def _set_energy(self, energy: float):\n        \"\"\" set the energy \"\"\"\n        self.ob_mol.SetEnergy(energy)\n\n    def _set_all_energy(self, all_energy: Union[float, np.ndarray]):\n        \"\"\" set the energy for all conformers \"\"\"\n        if isinstance(all_energy, float):\n            self._data['all_energy'] = np.array([all_energy])\n        else:\n            all_energy = all_energy.flatten()\n            self._data['all_energy'] = all_energy\n\n    def _set_identifier(self, identifier):\n        self.ob_mol.SetTitle(identifier)\n\n    def _set_spin_multiplicity(self, spin):\n        self.ob_mol.SetTotalSpinMultiplicity(spin)\n\n    @staticmethod\n    def _transfer_preserve_data_to_new_atoms(tgt_mol: 'Molecule', preserve_data: Dict, rm_temp_label: bool = False):\n        \"\"\"\n        Transfer preserve data dict to new target Molecule atoms\n        Args:\n            tgt_mol: The target Molecule\n            preserve_data(dict): the old atoms data dict\n            rm_temp_label: whether to remove temp label after data have been transferred.\n        \"\"\"\n        for atom in tgt_mol.atoms:\n            temp_label = atom.temp_label\n            if temp_label:\n                atom.update_attr_data(preserve_data[temp_label])\n\n                if rm_temp_label:\n                    atom.remove_ob_data('temp_label')\n\n    @staticmethod\n    def _transfer_preserve_data_to_new_bonds(tgt_mol: 'Molecule', preserve_data: Dict):\n        \"\"\"\n        Transfer preserve data dict to new target Molecule bonds\n        Args:\n            tgt_mol: The target Molecule\n            preserve_data(dict): the old atoms data dict\n        \"\"\"\n        for bond in tgt_mol.bonds:\n            temp_label = (bond.atom1.temp_label, bond.atom2.temp_label)\n            if all(temp_label):\n                try:\n                    bond.update_attr_data(preserve_data[temp_label])\n                except KeyError:\n                    bond.update_attr_data(preserve_data[temp_label[::-1]])\n\n    @staticmethod\n    def _transfer_preserve_data_to_new_angles(tgt_mol: 'Molecule', preserve_data: Dict):\n        for angle in tgt_mol.angles:\n            temp_label = tuple(atom.temp_label for atom in angle.atoms)\n            if all(temp_label):\n                try:\n                    angle.update_attr_data(preserve_data[temp_label])\n                except KeyError:\n                    angle.update_attr_data(preserve_data[temp_label[::-1]])\n\n    @staticmethod\n    def _transfer_preserve_data_to_new_torsions(tgt_mol: 'Molecule', preserve_data: Dict):\n        for torsion in tgt_mol.torsions:\n            temp_label = tuple(atom.temp_label for atom in torsion.atoms)\n            if all(temp_label):\n                try:\n                    torsion.update_attr_data(preserve_data[temp_label])\n                except KeyError:\n                    torsion.update_attr_data(preserve_data[temp_label[::-1]])\n\n    @property\n    def acentric_factor(self):\n        return self._get_critical_params('acentric_factor')\n\n    def add_atom(self, atom: Union[\"Atom\", str, int], **atom_attrs) -> 'Atom':\n        \"\"\"\n        Add a new atom out of the molecule into the molecule.\n        Args:\n            atom(Atom|str|int):\n\n        atom_kwargs(kwargs for this added atom):\n            atomic_number(int): set atomic number\n            symbol(str): set atomic symbol\n            coordinates(Sequence, numpy.ndarray): coordinates of the atom\n            partial_charge:\n            label:\n            spin_density:\n\n        Returns:\n            the copy of atom in the molecule\n        \"\"\"\n        oba = ob.OBAtom()  # Initialize a new OBAtom\n        data = None\n        if isinstance(atom, str):\n            oba.SetAtomicNum(ob.GetAtomicNum(atom))\n        elif isinstance(atom, int):\n            oba.SetAtomicNum(atom)\n        elif isinstance(atom, Atom):\n            oba.SetAtomicNum(atom.atomic_number)\n            data = atom.data  # Copy the give atoms data\n\n        # add OBAtom to the OBMol\n        success = self.ob_mol.AddAtom(oba)\n\n        if success:\n            atom = self.atoms[-1]  # Retrieve the added atom\n\n            if data:\n                atom.update_attr_data(data)  # replicant the old atom's data to the new\n\n            atom.set(**atom_attrs)  # Set attributes by kwargs\n\n            return atom\n\n        else:\n            raise AddAtomFail(f'Add the atom {atom} into Molecule fail')\n\n    @property\n    def all_atoms_with_unique_symbol(self):\n        return self.atoms_with_unique_symbol + \\\n            self.pseudo_atoms_with_unique_symbol\n\n    def add_bond(\n            self,\n            atom1: Union[str, int, 'Atom'],\n            atom2: Union[str, int, 'Atom'],\n            bond_type: Union[str, int],\n    ):\n        \"\"\" Add a new bond into the molecule \"\"\"\n        inputs = (atom1, atom2)\n        atoms: List[Atom] = []\n        for a in inputs:\n            if isinstance(a, int):\n                atoms.append(self.atoms_dict[a])\n            if isinstance(a, Atom):\n                atoms.append(a)\n            if isinstance(a, str):\n                atoms.append(self.atom(a))\n\n        # Represent the bond type by int, refer to _bond_type dict\n        bond_type = bond_type if isinstance(bond_type, int) else _bond_type[bond_type]\n\n        # Try to add new OBMol\n        # 'openbabel' has an odd behave that `index` of the `OBAtom` with various origin in the `OBMol`.\n        # the `Id` of `OBAtom` from 0; but the `Idx` of `OBAtom` from 1.\n        # To meet the convention, the `Id` is selected to be the unique `index` to specify `Atom`.\n        # However, when try to add a `OBBond` to link each two `OBAtoms`, the `Idx` is the only method\n        # to specify the atoms, so our `index` in `Atom` are added 1 to match the 'Idx'\n        success = self.ob_mol.AddBond(atoms[0].ob_idx, atoms[1].ob_idx, bond_type)\n\n        if success:\n            return self.bonds[-1]  # the new atoms should place in the terminal of the bond list\n\n        elif atoms[0].ob_id not in self.atom_indices:\n            raise KeyError(\"the start atom1 doesn't exist in molecule\")\n\n        elif atoms[1].ob_id not in self.atom_indices:\n            raise KeyError(\"the end atom2 doesn't exist in molecule\")\n\n        else:\n            raise RuntimeError('add bond not successful!')\n\n    def add_hydrogens(\n            self,\n            polar_only: bool = False,\n            correct_for_ph: bool = False,\n            ph: float = 1.0,\n            balance_hydrogen: bool = True,\n    ):\n        \"\"\"\n        add hydrogens for the molecule\n        Args:\n            ph: add hydrogen in which PH environment\n            polar_only: Whether to add hydrogens only to polar atoms (i.e., not to C atoms)\n            correct_for_ph: Correct for pH by applying the OpenBabel::OBPhModel transformations\n            balance_hydrogen: whether to balance the bond valance of heavy atom to their valence\n        \"\"\"\n        self.ob_mol.AddHydrogens(polar_only, correct_for_ph, ph)\n        self._load_atoms()\n        self._load_bonds()\n\n        if balance_hydrogen:\n            for atom in self.atoms:\n                atom.balance_hydrogen()\n\n    def add_pseudo_atom(self, symbol: str, mass: float, coordinates: Union[Sequence, np.ndarray], **kwargs):\n        \"\"\" Add pseudo atom into the molecule \"\"\"\n        list_pseudo_atom = self._data.setdefault('pseudo_atoms', [])\n        pa = PseudoAtom(symbol, mass, coordinates, mol=self, molecule=self, **kwargs)\n        list_pseudo_atom.append(pa)\n\n    @property\n    def all_coordinates(self) -> np.ndarray:\n        \"\"\"\n        Get the collections of the matrix of all atoms coordinates,\n        each matrix represents a conformer.\n        The return array with shape of (C, N, 3),\n        where the C is the number of conformers, the N is the number of atoms\n        \"\"\"\n        all_coordinates = self._data.get('all_coordinates')\n        if isinstance(all_coordinates, np.ndarray):\n            return all_coordinates\n        else:\n            return self.coordinates.reshape((-1, self.atom_counts, 3))\n\n    @property\n    def all_energy(self):\n        return self._data.get('all_energy')\n\n    @property\n    def angles(self):\n        return [Angle(self, *a_idx) for a_idx in ob.OBMolAngleIter(self.ob_mol)]\n\n    def assign_bond_types(self):\n        self.ob_mol.PerceiveBondOrders()\n\n    def atom(self, id_label: Union[int, str]) -> 'Atom':\n        \"\"\" get atom by label or idx \"\"\"\n        if isinstance(id_label, str):\n\n            if not self.is_labels_unique:\n                raise AttributeError(\n                    'the label is not unique, cannot get atom by label. try to get atom by ob_id '\n                    'or normalize the label before'\n                )\n\n            for atom in self.atoms:\n                if atom.label == id_label:\n                    return atom\n            raise KeyError(f'No atom with label {id_label}')\n\n        elif isinstance(id_label, int):\n            return self.atoms_dict[id_label]\n        else:\n            raise TypeError(f'the given idx_label is expected to be int or string, but given {type(id_label)}')\n\n    @property\n    def atom_counts(self):\n        return self.ob_mol.NumAtoms()\n\n    @property\n    def atomic_numbers(self) -> Tuple[int]:\n        return tuple(a.atomic_number for a in self.atoms)\n\n    @property\n    def atomic_numbers_array(self) -> np.ndarray:\n        \"\"\" conformer corresponding attributes with array shape (number_of_atoms, number_of_conformers) \"\"\"\n        return np.array(self.atomic_numbers).reshape(1, -1).repeat(self.conformer_counts, axis=0)\n\n    @property\n    def atomic_symbols(self):\n        return tuple(a.symbol for a in self.atoms)\n\n    @property\n    def atoms(self) -> List['Atom']:\n        \"\"\"\n        Generate dict of Atom objects into the data repository.\n        Return list of Atom objects with the order their index.\n        \"\"\"\n        atoms = self._load_atoms()\n        return list(atoms.values())\n\n    @property\n    def atoms_dict(self) -> Dict[int, 'Atom']:\n        return self._load_atoms()\n\n    @property\n    def atoms_with_unique_symbol(self):\n        uni_atoms, uni_symbol = [], set()\n        for a in self.pseudo_atoms:\n            if a.symbol not in uni_symbol:\n                uni_atoms.append(a)\n                uni_symbol.add(a.symbol)\n\n        return uni_atoms\n\n    @property\n    def pseudo_atoms_with_unique_symbol(self):\n        uni_patoms, uni_psymbol = [], set()\n        for a in self.atoms:\n            if a.symbol not in uni_psymbol:\n                uni_patoms.append(a)\n                uni_psymbol.add(a.symbol)\n\n        return uni_patoms\n\n    @property\n    def all_atoms(self):\n        return self.atoms + self.pseudo_atoms\n\n    @property\n    def atom_charges(self) -> np.ndarray:\n        \"\"\" Return all atoms charges as a numpy array \"\"\"\n        return np.array([a.partial_charge for a in self.atoms])\n\n    @property\n    def all_atom_charges(self) -> np.ndarray:\n        \"\"\" Return all atoms charges as a numpy array for every conformers \"\"\"\n        all_atom_charges = self._data.get('all_atom_charges')\n        if isinstance(all_atom_charges, np.ndarray):\n            return all_atom_charges\n        return self.atom_charges.reshape((-1, self.atom_counts))\n\n    @property\n    def atom_indices(self) -> list[int]:\n        return [a.ob_id for a in self.atoms]\n\n    @property\n    def atom_labels(self) -> list[str]:\n        return [a.label for a in self.atoms]\n\n    @property\n    def atom_spin_densities(self) -> np.ndarray:\n        return np.array([a.spin_density for a in self.atoms])\n\n    @property\n    def all_atom_spin_densities(self):\n        all_atom_spin_densities = self._data.get('all_atom_spin_densities')\n        if all_atom_spin_densities is not None:\n            return all_atom_spin_densities\n        return self.atom_spin_densities.reshape((-1, self.atom_counts))\n\n    def assign_atoms_formal_charge(self):\n        \"\"\" Assign the formal charges for all atoms in the molecule \"\"\"\n        self.add_hydrogens(balance_hydrogen=False)\n\n        for atom in self.atoms:\n            if atom.is_polar_hydrogen:\n                atom.formal_charge = 1\n            elif atom.is_hydrogen or atom.is_carbon:\n                atom.formal_charge = 0\n            elif atom.is_metal:\n                atom.formal_charge = _stable_charges[atom.symbol]\n            elif [a for a in atom.neighbours if a.is_polar_hydrogen]:\n                atom.formal_charge = -(len([a for a in atom.neighbours if a.is_polar_hydrogen]))\n            elif atom.symbol in ['S', 'P']:\n                if not [a for a in atom.neighbours if a.symbol == 'O']:\n                    atom.formal_charge = atom.covalent_valence - (2 if atom.symbol == 'S' else 3)\n                else:\n                    atom.formal_charge = 0\n            else:\n                atom.formal_charge = atom.covalent_valence - atom.stable_valence\n\n    def balance_hydrogens(self):\n        \"\"\" Add or remove hydrogens for make or heave atom to achieve the stable valence \"\"\"\n        for a in self.heavy_atoms():\n            a.balance_hydrogen()\n\n    def angle(self, a: Union[str, int], v: Union[str, int], b: Union[str, int]) -> 'Angle':\n        \"\"\"\n        Get a Angle from Molecule by ob_id or atom label\n        Args:\n            a: the ob_id or atom label of the first end atom\n            v: the ob_id or atom label of the vertex atom\n            b: the ob_id or atom label of the second end atom\n\n        Returns:\n            Angle\n        \"\"\"\n        a: Atom = self.atom(a)\n        v: Atom = self.atom(v)\n        b: Atom = self.atom(b)\n\n        assert self.bond(a.ob_id, v.ob_id)\n        assert self.bond(v.ob_id, b.ob_id)\n\n        return Angle(self, v.ob_id, a.ob_id, b.ob_id)\n\n    def torsion(self, a: Union[str, int], b: Union[str, int], c: Union[str, int], d: Union[str, int]) -> 'Torsion':\n        \"\"\"\n        Get a Torsion from Molecule by ob_id or atom label\n        Args:\n            a: the ob_id or atom label of the first end atom\n            b: the ob_id or atom label of the first internal atom\n            c: the ob_id or atom label of the second internal atom\n            d: the ob_id or atom label of the second internal atom\n\n        Returns:\n            Torsion\n        \"\"\"\n        a: Atom = self.atom(a)\n        b: Atom = self.atom(b)\n        c: Atom = self.atom(c)\n        d: Atom = self.atom(d)\n\n        # Todo: The reason why these assert can't successful is still uncertain,\n        # Todo: Refer to the rule of Z-Matrix in Gaussian16\n        # assert self.bond(a.ob_id, b.ob_id)\n        # assert self.bond(b.ob_id, c.ob_id)\n        # assert self.bond(c.ob_id, d.ob_id)\n\n        return Torsion(self, a.ob_id, b.ob_id, c.ob_id, d.ob_id)\n\n    def bond(self, atom1: Union[int, str], atom2: Union[int, str]) -> 'Bond':\n        \"\"\"\n        Return the Bond by given atom index labels in the bond ends\n        if the bond is missing in the molecule, return None if given miss_raise is False else raise a KeyError\n        Args:\n            atom1(int|str): index or label of atom in one of the bond end\n            atom2(int|str): index or label of atom in the other end of the bond\n\n        Returns:\n            Bond\n\n        Raises:\n            KeyError: when can't find the bond, and the miss_raise passing True\n\n        \"\"\"\n        atom1: Atom = self.atom(atom1)\n        atom2: Atom = self.atom(atom2)\n        ob_bond = self.ob_mol.GetBond(atom1.ob_atom, atom2.ob_atom)\n\n        if ob_bond:\n            return self.bonds_dict[ob_bond.GetId()]\n\n    @property\n    def bond_pair_keys(self):\n        return [b.pair_key for b in self.bonds]\n\n    @property\n    def bonds(self):\n        bonds = self._load_bonds()\n        return list(bonds.values())\n\n    @property\n    def bonds_dict(self) -> Dict[int, 'Bond']:\n        return self._load_bonds()\n\n    def build_2d(self):\n        \"\"\" build 2d conformer \"\"\"\n        pmol = pb.Molecule(self.ob_mol)\n        pmol.make2D()\n\n    def build_3d(self, force_field: str = 'UFF', steps: int = 500):\n        \"\"\" build 3D coordinates for the molecule \"\"\"\n        # Preserve atoms data before building\n        preserve_atoms_data = self._preserve_atoms_data()\n        preserve_bonds_data = self._preserve_bonds_data()\n        preserve_angles_data = self._preserve_angles_data()\n        preserve_torsion_data = self._preserve_torsion_data()\n\n        # Destroy atoms and bonds wrappers\n        self._data['atoms'] = {}\n        self._data['bonds'] = {}\n\n        # Build 3d conformer\n        pymol = pb.Molecule(self.ob_mol)\n        pymol.make3D(force_field, steps)\n\n        # Reload atoms and bonds\n        self._load_atoms()\n        self._load_bonds()\n\n        # Transfer preserve data to new\n        self._transfer_preserve_data_to_new_atoms(self, preserve_atoms_data)\n        self._transfer_preserve_data_to_new_bonds(self, preserve_bonds_data)\n        self._transfer_preserve_data_to_new_angles(self, preserve_angles_data)\n        self._transfer_preserve_data_to_new_torsions(self, preserve_torsion_data)\n\n        # Delete temp label\n        self._delete_atoms_temp_label()\n\n        # Remove redundant hydrogen or supply the lack hydrogens\n        self.balance_hydrogens()\n\n    def build_bonds(self):\n        self.ob_mol.ConnectTheDots()\n\n    @property\n    def center_of_masses(self):\n        return (self.masses * self.coordinates.T).T.sum(axis=0) / self.masses.sum()\n\n    @property\n    def center_of_shape(self):\n        return self.coordinates.mean(axis=0)\n\n    @property\n    def charge(self):\n        return self.ob_mol.GetTotalCharge()\n\n    @charge.setter\n    def charge(self, charge):\n        self._set_mol_charge(charge)\n\n    def clean_bonds(self):\n        \"\"\" Remove all bonds \"\"\"\n        # Iterate directly will fail.\n        ob_bonds = [ob_bond for ob_bond in ob.OBMolBondIter(self.ob_mol)]\n        for ob_bond in ob_bonds:\n            self.ob_mol.DeleteBond(ob_bond)\n\n    def clean_conformers(self, pop: bool = False):\n        \"\"\" clean all config save inside the molecule \"\"\"\n        try:\n            all_coordinates = self._data.pop('all_coordinates')\n        except KeyError:\n            all_coordinates = None\n\n        if pop:\n            return all_coordinates\n\n    @property\n    def components(self):\n        \"\"\" get all fragments don't link each by any bonds \"\"\"\n        # Add temp label for each atom first\n        preserve_data = self._preserve_atoms_data()\n\n        components = [self.__class__(obc) for obc in self.ob_mol.Separate()]\n\n        # Transfer the parent data attr to the children\n        for c in components:\n            for a in c.atoms:\n                a.update_attr_data(preserve_data[a.temp_label])\n                a.remove_ob_data('temp_label')\n\n        # remove temp labels of all atoms\n        self._delete_atoms_temp_label()\n\n        return components\n\n    @property\n    def conformer_counts(self) -> int:\n        \"\"\" The number of conformers in the molecule \"\"\"\n        all_coordinates = self._data.get('all_coordinates')\n        if isinstance(all_coordinates, np.ndarray):\n            return all_coordinates.shape[0]\n        else:\n            return 1\n\n    def conformer_select(self, conf_idx: int):\n        \"\"\" select specific conformer by index \"\"\"\n\n        def assign_numpy_attrs(attrs_name: str, setter: Callable):\n            attrs = self._data.get(attrs_name)\n            if isinstance(attrs, np.ndarray):\n                try:\n                    attr = attrs[conf_idx]\n                except IndexError:\n                    attr = None\n            else:\n                attr = None\n\n            if isinstance(attr, np.ndarray) or attr:\n                setter(attr)\n\n        all_coordinates = self._data.get('all_coordinates')\n        if all_coordinates is None and conf_idx:\n            raise IndexError('Only one conformer here!')\n\n        # assign the coordinates for the molecule\n        coordinates = all_coordinates[conf_idx]\n        self._assign_coordinates(self, coordinates)\n\n        assign_numpy_attrs('all_energy', self._set_energy)\n\n        assign_numpy_attrs('all_atom_charges', self._set_atom_charges)\n\n        assign_numpy_attrs('all_atom_spin_densities', self._set_atom_spin_densities)\n\n        assign_numpy_attrs('all_forces', self._set_forces)\n\n    @property\n    def coordinates(self) -> np.ndarray:\n        \"\"\"\n        Get the matrix of all atoms coordinates,\n        where the row index point to the atom index;\n        the column index point to the (x, y, z)\n        \"\"\"\n        return np.array([atom.coordinates for atom in self.atoms], dtype=np.float64)\n\n    def copy(self) -> 'Molecule':\n        \"\"\" Get a clone of this Molecule \"\"\"\n        clone = self.__class__(self.ob_copy())\n        clone._load_atoms()\n        clone._load_bonds()\n\n        # Copy the Molecule's attr data to the clone one\n        clone.update_attr_data(self.data)\n        # Copy the Atoms' attr data to the clone ones\n        for atom in clone.atoms:\n            atom.update_attr_data(self.atoms_dict[atom.ob_id].data)\n            atom.molecule = clone\n        # Copy the Bonds' attr data to the lone ones\n        for bond in clone.bonds:\n            bond.update_attr_data(self.bonds_dict[bond.ob_id].data)\n            bond.molecule = clone\n\n        return clone\n\n    def compact_crystal(self, inplace=False):\n        \"\"\"\"\"\"\n        mol = self if inplace else self.copy()\n        lattice_params = np.concatenate((self.xyz_diff, [90., 90., 90.]))\n\n        mol.make_crystal(*lattice_params)\n\n        return mol\n\n    def create_crystal_by_vectors(\n            self,\n            va: Union[Sequence, np.ndarray],\n            vb: Union[Sequence, np.ndarray],\n            vc: Union[Sequence, np.ndarray]\n    ):\n        \"\"\" Create a new crystal with specified cell vectors for the Molecule \"\"\"\n        self._create_ob_unit_cell()\n        self.crystal().set_vectors(va, vb, vc)\n\n    def create_crystal_by_matrix(self, matrix: np.ndarray):\n        \"\"\" Create a new crystal with specified cell matrix for the molecule \"\"\"\n        if not (np.logical_not(matrix >= 0.).any() and np.logical_not(matrix < 0.).any()) and np.linalg.det(matrix):\n            self._create_ob_unit_cell()\n            self.crystal().set_matrix(matrix)\n            # self.crystal().space_group = 'P1'\n\n    @classmethod\n    def create_aCryst_by_mq(\n            cls, elements: Dict[str, float], force_field: Union[str, os.PathLike],\n            density: float = 1.0, a: float = 25., b: float = 25., c: float = 25.,\n            alpha: float = 90., beta: float = 90., gamma: float = 90., time_step: float = 0.0001,\n            origin_temp: float = 298.15, melt_temp: float = 4000., highest_temp: float = 10000.,\n            ff_args: Sequence = (), path_writefile: Optional[str] = None, path_dump_to: Optional[str] = None,\n            dump_every: int = 100\n    ):\n        \"\"\"\n        Create a Amorphous crystal materials by Melt-Quench process.\n        This process is performed by LAMMPS package, make sure the LAMMPS is accessible.\n        A suitable force field is required for the process are performed correctly.\n        Args:\n            elements(dict[str, float]): Dict of elements and their composition ratio\n            force_field(str, os.PathLike): The name of force filed or the path to load a force filed. The name\n             of the force filed is refer to the relative path to the 'hotpot_root/data/force_field'.\n            density: the demand density for the created amorphous crystal\n            a: the length of a vector in the crystal\n            b: the length of b vector in the crystal\n            c: the length of c vector in the crystal\n            alpha: alpha angle of crystal param.\n            beta: beta angle of crystal param.\n            gamma: gamma angle of crystal param\n            time_step: time interval between path integrals when performing melt-quench\n            origin_temp: the initial temperature before melt\n            melt_temp: the round melting point to the materials\n            highest_temp: the highest temperature to liquefy the materials\n            ff_args: the arguments the force file requried, refering the LAMMPS pair_coeff:\n             \"pair_coeff I J args\" url: https://docs.lammps.org/pair_coeff.html\n            path_writefile: the path to write the final material (screenshot) to file, if not specify, not save.\n            path_dump_to:  the path to save the trajectory of the melt-quench process, if not specify not save.\n            dump_every: the step interval between each dump operations\n\n        Returns:\n            Molecule, a created amorphous material\n        \"\"\"\n        return cls._melt_quench(\n            elements=elements, force_field=force_field, density=density,\n            a=a, b=b, c=c, alpha=alpha, beta=beta, gamma=gamma, time_step=time_step,\n            origin_temp=origin_temp, melt_temp=melt_temp, highest_temp=highest_temp,\n            ff_args=ff_args, path_writefile=path_writefile, path_dump_to=path_dump_to,\n            dump_every=dump_every\n        )\n\n    @property\n    def critical_pressure(self):\n        return self._get_critical_params('pressure')\n\n    @property\n    def critical_temperature(self):\n        return self._get_critical_params('temperature')\n\n    def crystal(self):\n        \"\"\" Get the Crystal containing the Molecule \"\"\"\n        cell_index = ob.UnitCell  # Get the index the UnitCell data save\n        cell_data = self.ob_mol.GetData(cell_index)\n\n        if cell_data:\n            ob_unit_cell = ob.toUnitCell(cell_data)\n            return Crystal(ob_unit_cell, molecule=self)\n        else:\n            return None\n\n    def dump(self, fmt: str, *args, **kwargs) -> Union[str, bytes, dict, 'DeepSystem']:\n        \"\"\"\"\"\"\n        dumper = Dumper(fmt=fmt, source=self, *args, **kwargs)\n        return dumper()\n\n    @property\n    def elements(self) -> list[str]:\n        return re.findall(r'[A-Z][a-z]*', self.formula)\n\n    @property\n    def energy(self):\n        \"\"\" Return energy with kcal/mol as default \"\"\"\n        return self.ob_mol.GetEnergy()\n\n    def feature_matrix(self, *feature_names: Sequence) -> np.ndarray:\n        \"\"\" Retrieve the feature matrix (collections of feature vector for atoms),\n         The default feature is `atomic_orbital`, if the feature names not be specified, the `atomic_orbital` will be\n         retrieved.\n         Args:\n             feature_names: the feature names are offered in hotpot/data/periodic_table.json\n         \"\"\"\n        if not feature_names:\n            feature_names = ('atomic_orbital',)\n\n        # Matrix with shape (atom_numbers, feature_length)\n        return np.stack([atom.element_features(*feature_names) for atom in self.atoms])\n\n    def fingerprint(self, fptype: Literal['FP2', 'FP3', 'FP4', 'MACCS'] = 'FP2'):\n        \"\"\"\n        Calculate the molecular fingerprint for this molecule, the supporting fingerprint include:\n\n        1. \"FP2\": The FP2 fingerprint is a path-based fingerprint that encodes the presence of linear\n        fragments up to 7 atoms long. It is a 1024-bit fingerprint and is commonly used for substructure\n        searches and similarity calculations.\n\n        2. \"FP3\": The FP3 fingerprint is designed for searching 3D conformations, such as those found\n        in protein-ligand complexes. It encodes the presence of particular pharmacophoric features,\n        such as hydrogen bond donors, acceptors, and hydrophobic regions.\n\n        3. \"FP4\": The FP4 fingerprint is a circular fingerprint based on the Morgan algorithm. It\n        captures information about the local environment of each atom in the molecule, up to a certain\n        radius. It is useful for similarity calculations and machine learning tasks.\n\n        4. \"MACCS\": The MACCS fingerprint is a 166-bit structural key-based fingerprint. It represents\n        the presence of specific substructures or functional groups defined by the MACCS keys. It is\n        commonly used for similarity calculations and substructure searches.\n\n        Return:\n            the Fingerprint object in pybel module\n        \"\"\"\n        return pb.Molecule(self.ob_mol).calcfp(fptype)\n\n    @property\n    def forces(self):\n        \"\"\" return the all force vectors for all atoms in the molecule \"\"\"\n        return np.vstack((atom.force_vector for atom in self.atoms))\n\n    @property\n    def all_forces(self):\n        \"\"\" the force matrix for all conformer \"\"\"\n        force_matrix = self._data.get(\"all_forces\")\n        if isinstance(force_matrix, np.ndarray):\n            return force_matrix\n        return self.forces\n\n    @property\n    def formula(self) -> str:\n        return self.ob_mol.GetSpacedFormula()\n\n    def gaussian(\n            self,\n            g16root: Union[str, PathLike],\n            link0: Union[str, List[str]],\n            route: Union[str, List[str]],\n            path_log_file: Union[str, PathLike] = None,\n            path_err_file: Union[str, PathLike] = None,\n            path_chk_file: Union[str, PathLike] = None,\n            path_rwf_file: Union[str, PathLike] = None,\n            inplace_attrs: bool = False,\n            debugger: Union[str, Debugger] = 'auto',\n            *args, **kwargs\n    ) -> (Union[None, str], str):\n        \"\"\"\n        calculation by Gaussian.\n        for running the method normally, MAKE SURE THE Gaussian16 HAVE BEEN INSTALLED AND ALL ENV VAR SET RITHT !!\n        Args:\n            g16root: the dir Gaussian16 software installed\n            link0: the link0 command in gjf script\n            route: the route command in gjf script\n            path_log_file: Optional, the path to save the out.log file. If not given, the logfile would be written\n             to the work dir\n            path_err_file: Optional, the path to save the error log file. If not given, the err file would be written\n             to the work dir\n            path_chk_file: Optional, the path to the checkpoint file. If not given the chk file would be written\n             to the work dir\n            path_rwf_file: Optional, the path to the read-write file. If not given the rwf file would be written\n             to the work dir\n            inplace_attrs: Whether to inplace self attribute according to the results from attributes.\n            debugger: define the method to handle the Gaussian error, like l9999, l103 or l502 ...,\n             the default method is the 'auto', which just to handle some common error case. More elaborate\n             debugger could be handmade by inherit from `Debugger` abstract class. For detail, seeing\n             the documentation.\n            *args:\n            **kwargs:\n\n        Returns:\n            the standard output of g16 log file(string), the standard output of g16 err file(string)\n        \"\"\"\n        # For 2d molecule, build its confomer by universal force field first\n        if not self.has_3d:\n            self.build_3d()\n\n        # Specify the temporary file\n        if not path_chk_file:\n            path_chk_file = Path.cwd().joinpath('checkpoint.chk')\n        else:\n            path_chk_file = Path(path_chk_file)\n\n        if not path_rwf_file:\n            path_rwf_file = Path.cwd().joinpath('readwrite.rwf')\n        else:\n            path_rwf_file = Path(path_rwf_file)\n\n        if isinstance(link0, str):\n            link0 = [link0]\n\n        link0 = link0 + [f'rwf={str(path_rwf_file)}', 'NoSave', f'chk={str(path_chk_file)}']\n\n        # Make the input gjf script\n        script = self.dump('gjf', *args, link0=link0, route=route, **kwargs)\n\n        gauss = Gaussian(g16root)\n        gauss.path_rwf = path_rwf_file\n        gauss.path_chk = path_chk_file\n\n        grun = GaussRun(gauss, debugger)\n        gauss = grun(script)\n\n        if not gauss.stderr:\n            # save the calculate result into the molecule data dict\n            self._data['gaussian_output'] = gauss.stdout\n            self._data['gaussian_parse_data'] = gauss.parse_log()\n\n            # Inplace the self attribute according to the result from gaussian\n            if inplace_attrs:\n                self._set_attrs(**gauss.molecule_setter_dict())\n\n            # Save log file when the path_log_file has been specified\n            if path_log_file:\n                with open(path_log_file, 'w') as writer:\n                    writer.write(gauss.stdout)\n\n            # return results and error info\n            return gauss.stdout, gauss.stderr\n\n        # If got an error message, save the error and stdout file, before raise the error\n        else:\n            # Save error file\n            if not path_err_file:\n                path_err_file = Path(f'{self.formula}.err')\n            with open(path_err_file, 'w') as writer:\n                writer.write(gauss.stderr)\n\n            # Save log file\n            if not path_log_file:\n                path_log_file = Path(f'{self.formula}.log')\n            with open(path_log_file, 'w') as writer:\n                writer.write(gauss.stdout)\n\n            raise GaussianRunError(gauss.stderr)\n\n    def gcmc(\n            self, *guest: 'Molecule', force_field: Union[str, os.PathLike] = None,\n            work_dir: Union[str, os.PathLike] = None, T: float = 298.15, P: float = 1.0, **kwargs\n    ):\n        \"\"\"\n        Run gcmc to determine the adsorption of guest,\n        Args:\n            self: the framework as the sorbent of guest molecule\n            guest(Molecule): the guest molecule to be adsorbed into the framework\n            force_field(str|PathLike): the path to force field file or the self-existent force file contained\n             in force field directory (in the case, a str should be given as a relative path from the root of\n             force field root to the specified self-existent force filed). By default, the force field is UFF\n             which in the relative path 'UFF/LJ.json' for the force field path.\n            work_dir: the user-specified dir to store the result of GCMC and log file.\n            T: the environmental temperature (default, 298.15 K)\n            P: the relative pressure related to the saturation vapor in the environmental temperature.\n        \"\"\"\n        from tanks.lmp.gcmc import LjGCMC\n        gcmc = LjGCMC(self, force_field, *guest, work_dir=work_dir, T=T, P=P, **kwargs)\n        return gcmc.run()\n\n    def gcmc_for_isotherm(\n            self, *guest: 'Molecule', force_field: Union[str, os.PathLike] = None,\n            work_dir: Union[str, os.PathLike] = None, T: float = 298.15,\n            Ps: Sequence[float] = (1.0,), **kwargs\n    ):\n        \"\"\"\n        Run gcmc to determine the adsorption of guest,\n        Args:\n            self: the framework as the sorbent of guest molecule\n            guest(Molecule): the guest molecule to be adsorbed into the framework\n            force_field(str|PathLike): the path to force field file or the self-existent force file contained\n             in force field directory (in the case, a str should be given as a relative path from the root of\n             force field root to the specified self-existent force filed). By default, the force field is UFF\n             which in the relative path 'UFF/LJ.json' for the force field path.\n            work_dir: the user-specified dir to store the result of GCMC and log file.\n            T: the environmental temperature (default, 298.15 K)\n            Ps(Sequence[float]): A sequence of relative pressure related to the saturation vapor in the environmental temperature.\n        \"\"\"\n        if isinstance(work_dir, str):\n            work_dir = Path(work_dir)\n\n        if not work_dir.exists():\n            work_dir.mkdir()\n\n        for P in Ps:\n            sub_work_dir = work_dir.joinpath('press_' + str(P))\n            if not sub_work_dir.exists():\n                sub_work_dir.mkdir()\n\n            self.gcmc(*guest, force_field=force_field, work_dir=sub_work_dir, T=T, P=P, **kwargs)\n\n    def generate_metal_ligand_pair(\n            self, metal_symbol: str,\n            acceptor_atoms: Sequence = ('O',),\n            opti_force_field: str = 'UFF',\n            opti_before_gen: bool = False,\n            opti_step: int = 500\n    ) -> Generator['Molecule', None, None]:\n        \"\"\"\n        This method could work if the molecule is an organic ligand, or raise AttributeError.\n        Generate metal-ligand pair by link metal with acceptor atoms in the organic ligand.\n\n        Args:\n            metal_symbol: which metal element link to the ligand\n            acceptor_atoms: which elements to be acceptor atom to link to metal\n            opti_force_field: which force field could be used to optimize the configuration of ligand and M-L pair.\n            opti_before_gen: whether to optimize the ligand conformer before generate pair\n            opti_step: the step to optimize the 3d conformer\n\n        Return:\n            A generator for M-L pair\n        \"\"\"\n        ligand = self.copy()\n\n        if opti_before_gen:\n            ligand.build_3d(force_field=opti_force_field, steps=opti_step)\n\n        for atom in ligand.atoms:\n            if atom.symbol in acceptor_atoms:\n                # copy the ligand as the embryo of metal-ligand pairs\n                pair = ligand.copy()\n\n                # Replace the correspondent atom in the pair embryo, i.e., the accepting atom\n                acc_atom = pair.atom(atom.ob_id)\n\n                # assign the initial coordinates, if the pair has 3d conformer\n                # the sum of vector of relative position relate to the accepting atom\n                if pair.has_3d:\n                    sum_relative_coordinates = sum([c for _, c in acc_atom.neighbours_position])\n                    metal_init_coordinates = acc_atom.coordinates_array - sum_relative_coordinates\n\n                    # add metal atom into the acceptor_ligand\n                    added_metal = pair.add_atom(metal_symbol, coordinates=metal_init_coordinates)\n\n                else:  # If the pair has not 3d conformer, add the metal directly\n                    added_metal = pair.add_atom(metal_symbol)\n\n                # add the coordinating bond between metal atom and acceptor atoms\n                pair.add_bond(added_metal, acc_atom, 1)\n\n                # localize optimization of M-L pair by classical force field, if the pair has 3d\n                if pair.has_3d:\n                    pair.localed_optimize(opti_force_field)\n                else:\n                    pair.add_hydrogens()  # Add hydrogens\n\n                pair.identifier = pair.smiles\n                yield pair\n\n    def generate_pairs_bundle(\n            self, metal_symbol: str,\n            acceptor_atoms: Sequence = ('O',),\n            opti_force_field: str = 'UFF',\n            opti_before_gen: bool = False,\n            opti_step: int = 500\n    ) -> 'PairBundle':\n        \"\"\"\n        Generate metal-ligand pairs by bind this ligand with proposed, and put this ligand, metal and all pairs,\n        which are assembled by the ligand and metal, into a PairBundle objects.\n        Args:\n            metal_symbol(str): the symbol of proposed metal\n            acceptor_atoms(Sequence): the atoms to form bond with the proposed metal, the default is Oxygen\n            opti_force_field(str): the force field to optimize the conformer of this ligand and the generated\n             pairs.\n            opti_before_gen: whether to optimize the ligand conformer before generate pair.\n            opti_step: the step to optimize the 3d conformer\n\n        Returns:\n            PairBundle with this ligand, proposed metal and the pairs\n        \"\"\"\n        return PairBundle(\n            metal=Atom(symbol=metal_symbol),\n            ligand=self,\n            pairs=list(self.generate_metal_ligand_pair(\n                metal_symbol,\n                acceptor_atoms,\n                opti_force_field,\n                opti_before_gen\n            )),\n        )\n\n    def graph_representation(self, *feature_names):\n        return self.identifier, self.feature_matrix(*feature_names), self.link_matrix\n\n    def heavy_atoms(self):\n        \"\"\" Get the atoms except for hydrogens \"\"\"\n        return [a for a in self.atoms if a.is_heavy]\n\n    @property\n    def has_3d(self):\n        \"\"\" Whether atoms in the molecule have 3d coordinates \"\"\"\n        return self.ob_mol.Has3D()\n\n    @property\n    def has_hydrogen_added(self):\n        \"\"\" Have hydrogens been added to the molecule by call Molecule.add_hydrogen()? \"\"\"\n        return self.ob_mol.HasHydrogensAdded()\n\n    @property\n    def has_unknown_bond(self):\n        return any(not b.type for b in self.bonds)\n\n    @property\n    def hydrogens(self):\n        return [a for a in self.atoms if a.is_hydrogen]\n\n    @property\n    def identifier(self):\n        return self.ob_mol.GetTitle()\n\n    @identifier.setter\n    def identifier(self, value):\n        self.ob_mol.SetTitle(value)\n\n    @property\n    def identifier_array(self) -> np.ndarray:\n        \"\"\" numpy.array of identifiers has the same number of items with the number of conformers \"\"\"\n        idt_array = self._data.get('identifier_array')\n        if not isinstance(idt_array, np.ndarray):\n            idt_array = []\n            for i, c in enumerate(self.all_coordinates):\n                idt_array.append(f'{self.identifier}_c{i}')\n            self._data['identifier_array'] = idt_array = np.array(idt_array)\n\n        return idt_array\n\n    def iadd_accessible(self, other):\n        if self.atomic_numbers == other.atomic_numbers:\n            return True\n        return False\n\n    @property\n    def inchi(self):\n        return self.dump('inchi').strip()\n\n    @property\n    def is_disorder(self):\n        \"\"\" To judge whether this Molecule has disorder bonds \"\"\"\n        if self.has_3d:\n            if any(not (0.85 < b.length/b.ideal_length < 1.15) for b in self.bonds):\n                return True\n        return False\n\n    @property\n    def is_labels_unique(self):\n        \"\"\" Determine whether all atom labels are unique \"\"\"\n        return len(set(self.labels)) == self.atom_counts\n\n    @property\n    def is_organic(self):\n        \"\"\" To judge whether the molecule is organic, an organic compound is with carbon atoms and without metal \"\"\"\n        if any(a.is_metal for a in self.atoms):\n            return False\n        elif any(a.symbol == 'C' for a in self.atoms):\n            return True\n\n        return False\n\n    def ob_copy(self):\n        \"\"\" Return a clone of OBMol of the Molecule \"\"\"\n        return ob.OBMol(self.ob_mol)\n\n    @property\n    def ob_mol(self):\n        return self._data['ob_obj']\n\n    def ob_mol_pop(self):\n        data: dict = self._data\n\n        atoms: Dict[int, Atom] = data.get('atoms')\n        if atoms:\n            for ob_id, atom in atoms.items():\n                atom.ob_atom_pop()\n\n        bonds: Dict[int, Bond] = data.get('bonds')\n        if bonds:\n            for ob_idx, bond in bonds.items():\n                bond.ob_bond_pop()\n\n        return self._data.pop('ob_obj')\n\n    def ob_mol_rewrap(self, ob_mol: ob.OBMol):\n        if not isinstance(ob_mol, ob.OBMol):\n            raise TypeError('the ob_mol should be OBMol object')\n\n        atoms = self._data.get('atoms')\n        bonds = self._data.get('bonds')\n\n        if any(oba.GetId() not in atoms for oba in ob.OBMolAtomIter(ob_mol)):\n            raise ValueError('the atom number between the wrapper and the core OBMol is not match')\n        if any(obb.GetId() not in bonds for obb in ob.OBMolBondIter(ob_mol)):\n            raise ValueError('the bond number between the wrapper and the core OBMol is not match')\n\n        self._data['ob_obj'] = ob_mol\n        for ob_atom in ob.OBMolAtomIter(ob_mol):\n            atom = atoms.get(ob_atom.GetId())\n            atom.ob_atom_rewrap(ob_atom)\n\n        for ob_bond in ob.OBMolBondIter(ob_mol):\n            bond = bonds.get(ob_bond.GetId())\n            bond.ob_bond_rewrap(ob_bond)\n\n    @property\n    def labels(self):\n        return [a.label for a in self.atoms]\n\n    @property\n    def lmp(self):\n        \"\"\" handle to operate the Lammps object \"\"\"\n        return self._data.get('lmp')\n\n    def lmp_close(self):\n        pop_lmp = self._data.pop('lmp')\n        pop_lmp.close()\n\n    def lmp_setup(self, **kwargs):\n        self._data['lmp'] = lmp.HpLammps(self, **kwargs)\n\n    @property\n    def link_matrix(self):\n        return np.array([[b.ob_atom1_id, b.ob_atom2_id] for b in self.bonds]).T\n\n    def localed_optimize(self, force_field: str = 'UFF', steps: int = 500):\n        \"\"\" Locally optimize the coordinates. seeing openbabel.pybel package \"\"\"\n        pymol = pb.Molecule(self.ob_mol)\n        pymol.localopt(force_field, steps)\n        self.balance_hydrogens()\n\n    def make_crystal(self, a: float, b: float, c: float, alpha: float, beta: float, gamma: float) -> 'Crystal':\n        \"\"\" Put this molecule into the specified crystal \"\"\"\n        ob_unit_cell = ob.OBUnitCell()\n\n        self.ob_mol.CloneData(ob_unit_cell)\n        self.crystal().ob_unit_cell.SetData(a, b, c, alpha, beta, gamma)\n        self.crystal().ob_unit_cell.SetSpaceGroup('P1')\n\n        return self.crystal()\n\n    @property\n    def masses(self) -> np.ndarray:\n        return np.array([a.mass for a in self.atoms])\n\n    def melt_quench(\n            self, elements: Dict[str, float], force_field: Union[str, os.PathLike],\n            density: float = 1.0, a: float = 25., b: float = 25., c: float = 25.,\n            alpha: float = 90., beta: float = 90., gamma: float = 90., time_step: float = 0.0001,\n            origin_temp: float = 298.15, melt_temp: float = 4000., highest_temp: float = 10000.,\n            ff_args: Sequence = (), path_writefile: Optional[str] = None, path_dump_to: Optional[str] = None,\n            dump_every: int = 100\n    ):\n        \"\"\"\n        Create an Amorphous crystal materials by performing Melt-Quench process for this materials.\n        This process is performed by LAMMPS package, make sure the LAMMPS is accessible.\n        A suitable force field is required for the process are performed correctly.\n        Args:\n            elements(dict[str, float]): Dict of elements and their composition ratio\n            force_field(str, os.PathLike): The name of force filed or the path to load a force filed. The name\n             of the force filed is refer to the relative path to the 'hotpot_root/data/force_field'.\n            density: the demand density for the created amorphous crystal\n            a: the length of a vector in the crystal\n            b: the length of b vector in the crystal\n            c: the length of c vector in the crystal\n            alpha: alpha angle of crystal param.\n            beta: beta angle of crystal param.\n            gamma: gamma angle of crystal param\n            time_step: time interval between path integrals when performing melt-quench\n            origin_temp: the initial temperature before melt\n            melt_temp: the round melting point to the materials\n            highest_temp: the highest temperature to liquefy the materials\n            ff_args: the arguments the force file requried, refering the LAMMPS pair_coeff:\n             \"pair_coeff I J args\" url: https://docs.lammps.org/pair_coeff.html\n            path_writefile: the path to write the final material (screenshot) to file, if not specify, not save.\n            path_dump_to:  the path to save the trajectory of the melt-quench process, if not specify not save.\n            dump_every: the step interval between each dump operations\n\n        Returns:\n            Molecule, a created amorphous material\n        \"\"\"\n        return self._melt_quench(\n            elements=elements, force_field=force_field, density=density,\n            a=a, b=b, c=c, alpha=alpha, beta=beta, gamma=gamma, time_step=time_step,\n            origin_temp=origin_temp, melt_temp=melt_temp, highest_temp=highest_temp,\n            ff_args=ff_args, path_writefile=path_writefile, path_dump_to=path_dump_to,\n            dump_every=dump_every, mol=self\n        )\n\n    @property\n    def metals(self) -> List['Atom']:\n        return [a for a in self.atoms if a.is_metal]\n\n    @property\n    def mol_orbital_energies(self):\n        energies = self._data.get('mol_orbital_energies')\n        if energies:\n            return energies\n        else:\n            return None\n\n    def normalize_labels(self):\n        \"\"\" Reorder the atoms labels in the molecule \"\"\"\n        element_counts = {}\n        for atom in self.atoms:\n            count = element_counts.get(atom.symbol, 0)\n            count += 1\n            element_counts[atom.symbol] = count\n            atom.label = f'{atom.symbol}{count}'\n\n    def perturb_atoms_coordinates(\n            self,\n            random_style='uniform',\n            mol_distance=0.5,\n            freeze_dim: Sequence[int] = (),\n            max_generate_num: int = 10,\n            inplace: bool = False\n    ) -> Generator[\"Molecule\", None, None]:\n        \"\"\"\n        Perturb the coordinate of atom in the molecule\n        generate new mol\n        Args:\n            random_style: how to sample, 'uniform' or 'normal'\n            mol_distance: the max distance of perturbation in 'uniform'; the square variance in 'normal'\n            freeze_dim: tuple of int or str, 0 = x, 1 = y, 2 = z\n            max_generate_num: the maximum of generated molecule\n            inplace\n\n        Returns:\n            Generator of perturbed molecule\n        \"\"\"\n        dim_transform = {'x': 0, 'y': 1, 'z': 2}\n\n        coordinates_shape = (self.atom_counts, 3)  # the shape of coordinates matrix (atom counts, 3 dimension)\n        origin_coordinates = self.coordinates\n\n        def coordinates_generator():\n            \"\"\" Generating \"\"\"\n            for _ in range(max_generate_num):\n                if random_style == 'uniform':\n                    perturb_matrix = np.float64(np.random.uniform(-mol_distance, mol_distance, coordinates_shape))\n                elif random_style == 'normal':\n                    perturb_matrix = np.float64(np.random.normal(0, mol_distance, coordinates_shape))\n                else:\n                    raise ValueError('the perturb style is not defined!')\n\n                if freeze_dim:\n                    dim = [\n                        i if (isinstance(i, int) and 0 <= i <= 3) else dim_transform[i]\n                        for i in freeze_dim\n                    ]\n\n                    perturb_matrix[:, dim] = 0.\n\n                new_coord = origin_coordinates + perturb_matrix\n\n                yield new_coord\n\n        if inplace:\n            origin_all_coordinates = self._data.get('all_coordinates')\n            new_all_coordinates = np.array([c for c in coordinates_generator()])\n\n            if origin_all_coordinates is not None:\n                self._data['all_coordinates'] = np.concatenate([origin_all_coordinates, new_all_coordinates])\n            else:\n                self._data['all_coordinates'] = np.concatenate(\n                    [np.reshape(origin_coordinates, (1,) + origin_coordinates.shape), new_all_coordinates]\n                )\n\n        else:\n            return (self._pert_mol_generate(c) for c in coordinates_generator())\n\n    def perturb_cell_params(self):\n        \"\"\" To perturb parameters, i.e., a, b, c, alpha, beta, gamma \"\"\"\n\n    @property\n    def pseudo_atoms(self):\n        return self._data.get('pseudo_atoms', [])\n\n    def quick_build_atoms(self, atomic_numbers: np.ndarray):\n        \"\"\"\n        This method to quick build atoms according an array of atomic numbers.\n        The method bypass to calling more time-consumed method: add_atom().\n        However, the method only assign the elements or atomic number for atoms,\n        more fine attributes like coordinates, can't be specified.\n        Args:\n            atomic_numbers(np.ndarray): 1-D numpy array to add new atoms into the molecule\n\n        Returns:\n            None\n        \"\"\"\n        if not isinstance(atomic_numbers, (np.ndarray, Sequence)):\n            raise TypeError('the atomic_numbers should be np.ndarray or Sequence')\n        if isinstance(atomic_numbers, np.ndarray) and len(atomic_numbers.shape) != 1:\n            raise ValueError('the numpy array must be 1-D')\n\n        for atomic_number in atomic_numbers:\n            ob_atom = ob.OBAtom()\n            ob_atom.SetAtomicNum(int(atomic_number))\n            self.ob_mol.AddAtom(ob_atom)\n\n    @classmethod\n    def read_from(cls, source: Union[str, PathLike, IOBase], fmt=None, *args, **kwargs) -> 'Molecule':\n        \"\"\"\n        read source to the Molecule obj by call _io.Parser class\n        Args:\n            source(str, PathLike, IOBase): the formatted source\n            fmt:\n            *args:\n            **kwargs:\n\n        Returns:\n\n        \"\"\"\n        if not fmt:\n            if isinstance(source, str):\n                source = Path(source)\n\n            if isinstance(source, Path):\n                fmt = source.suffix.strip('.')\n            else:\n                raise ValueError(f'the arguments should be specified for {type(source)} source')\n\n        mol = Parser(fmt, source, *args, **kwargs)()  # initialize parser object and call self\n\n        # Specify the mol identifier if it's None\n        if isinstance(mol, Molecule) and not mol.identifier:\n            mol.identifier = str(source)\n\n        return mol\n\n    def register_critical_params(self, name: str, temperature: float, pressure: float, acentric: float):\n        \"\"\" Register new critical parameters into the critical parameters sheet \"\"\"\n        data = json.load(open(opj(data_root, 'thermo', 'critical.json')))\n        data[self.smiles] = {'name': name, 'temperature': temperature, 'pressure': pressure, 'acentric': acentric}\n        with open(opj(data_root, 'thermo', 'critical.json'), 'w') as writer:\n            json.dump(data, writer, indent=True)\n\n    def remove_atoms(self, *atoms: Union[int, str, 'Atom'], remove_hydrogens: bool = False) -> None:\n        \"\"\"\n        Remove atom according to given atom index, label or the atoms self.\n        Args:\n            atoms(int|str|Atom): the index, label or self of Removed atom\n            remove_hydrogens(bool): remove the hydrogens connecting in the atoms synchronously.\n\n        Returns:\n            None\n        \"\"\"\n        for atom in atoms:\n\n            # Check and locate the atom\n            if isinstance(atom, int):\n                atom = self.atoms_dict[atom]\n            elif isinstance(atom, str):\n                atom = self.atom(atom)\n            elif isinstance(atom, Atom):\n                if not (atom.molecule is self):\n                    raise AttributeError('the given atom not in the molecule')\n            else:\n                raise TypeError('the given atom should be int, str or Atom')\n\n            # remove connecting hydrogens\n            if remove_hydrogens:\n                for nh in atom.neighbours_hydrogen:\n                    self.ob_mol.DeleteAtom(nh.ob_atom)\n\n            # Removing the atom\n            self.ob_mol.DeleteAtom(atom.ob_atom)\n            atom._data['mol'] = None\n\n        # Reload atoms\n        self._load_atoms()\n        self._load_bonds()\n\n    def remove_bonds(self, *bonds: 'Bond'):\n        \"\"\" Remove the bonds in the molecule \"\"\"\n        for bond in bonds:\n            successful = self.ob_mol.DeleteBond(bond.ob_bond)\n            if not successful:\n                raise RuntimeError(f'Fail to remove {bonds}')\n\n        self._load_bonds()\n\n    def remove_hydrogens(self):\n        self.ob_mol.DeleteHydrogens()\n\n    def remove_metals(self):\n        \"\"\" remove all of metal atoms in the molecule \"\"\"\n        self.remove_atoms(*self.metals)\n\n    def remove_solvents(self, remove_disorder: bool = True, remove_isolate_atoms: bool = True):\n        \"\"\" remove all solvents in the molecule \"\"\"\n        self.normalize_labels()\n        for i, ligand in enumerate(self.retrieve_ligands()):\n            if remove_disorder and ligand.is_disorder:  # remove disorder molecular structures first\n                self.remove_atoms(*ligand.atom_labels, remove_hydrogens=False)\n            elif remove_isolate_atoms and len(ligand.atoms) == 1:\n                self.remove_atoms(*ligand.atom_labels, remove_hydrogens=False)\n            elif _lib.get('Solvents').is_solvent(ligand):  # To judge if the ligand is solvents\n                self.remove_atoms(*ligand.atom_labels, remove_hydrogens=False)\n\n    def retrieve_ligands(self) -> List['Molecule']:\n        \"\"\" Retrieve all ligand molecule from this \"\"\"\n        clone = self.copy()\n        clone.remove_metals()\n\n        return clone.components\n\n    def retrieve_metal_ligand_pairs(self) -> List['Molecule']:\n        \"\"\" Retrieve all clone of metal-ligand pairs in the molecule \"\"\"\n        if not self.is_labels_unique:\n            self.normalize_labels()\n\n        ml_pairs = []\n        for metal, ligand in product(self.metals, self.retrieve_ligands()):\n            if set(metal.neighbours_label) & set(ligand.atom_labels):\n                pair = self.copy()\n\n                # Remove all the atoms is not the metal and not on the ligand\n                other_atoms = [a for a in pair.atoms if a.label != metal.label and a.label not in ligand.atom_labels]\n                pair.remove_atoms(*other_atoms, remove_hydrogens=False)\n\n                ml_pairs.append(pair)\n\n        return ml_pairs\n\n    @property\n    def rotatable_bonds_number(self):\n        return self.ob_mol.NumRotors()\n\n    def save_2d_img(self, file_path: Union[str, os.PathLike], **kwargs):\n        \"\"\"\n        Export 2d image to file\n        Args:\n            file_path:\n            **kwargs: other keywords arguments for 2d image make and save\n\n        Keyword Args:\n\n        \"\"\"\n        img = self.to_2d_img(**kwargs)\n        img.save(file_path)\n\n    def set(self, **kwargs):\n        \"\"\" Set the attributes directly \"\"\"\n        self._set_attrs(**kwargs)\n\n    def set_label(self, ob_id: int, label: str):\n        self.atoms_dict[ob_id].label = label\n\n    def similarity(self, other: 'Molecule', fptype: Literal['FP2', 'FP3', 'FP4', 'MACCS'] = 'FP2') -> int:\n        \"\"\"\n        Compare the similarity with other molecule, based on specified fingerprint\n        Args:\n            other(Molecule): the other Molecule\n            fptype(str): the fingerprint type to perform comparison of similarity\n\n        Return:\n            the similarity(int)\n        \"\"\"\n        return self.fingerprint(fptype) | other.fingerprint(fptype)\n\n    def smarts(self):\n        \"\"\" Get the SMARTS string \"\"\"\n        return Chem.MolToSmarts(self.to_rdmol())\n\n    @property\n    def smiles(self):\n        \"\"\" Get the canonical smiles \"\"\"\n        return self.dump('can').split()[0]\n\n    @property\n    def spin(self):\n        return self.ob_mol.GetTotalSpinMultiplicity()\n\n    @spin.setter\n    def spin(self, spin: int):\n        self._set_spin_multiplicity(spin)\n\n    def thermo_init(self, **kwargs):\n        \"\"\"\n        If certain substance don't retrieve information from current database, some required thermodynamical\n        parameters should pass into equation_of_state to initialization\n        Keyword Args:\n            T: the ambient temperature for thermodynamical system\n            P: the ambient pressure for thermodynamical system\n            V: the volume of thermodynamical system\n            Tc: the critical temperature of the molecule\n            Pc: the critical pressure of the molecule\n            omega: acentric factor of the molecule\n\n        Returns:\n            Thermo class\n        \"\"\"\n        from tmo import Thermo\n        self._data['thermo'] = Thermo(self, **kwargs)\n        return self._data['thermo']\n\n    @property\n    def thermo(self):\n        return self._data.get('thermo')\n\n    def thermo_close(self):\n        _ = self._data.pop('thermo')\n        del _\n\n    @property\n    def torsions(self):\n        return [Torsion(self, *obi) for obi in ob.OBMolTorsionIter(self.ob_mol)]\n\n    def to_2d_img(self, **kwargs):\n        \"\"\"\n        Get a 2D image objects for the molecule\n        Keyword Args:\n            kekulize: whether to applying Kekulize style to aromatical rings\n\n        Returns:\n\n        \"\"\"\n        clone = self.copy()\n        clone.build_2d()\n        return Draw.MolToImage(clone.to_rdmol(), **kwargs)\n\n    def to_dpmd_sys(\n            self, system_dir: Union[str, os.PathLike],\n            mode: Literal['std', 'att'] = 'std',\n            validate_ratio: float = None,\n            validate_dir: Union[str, Path] = None\n    ):\n        \"\"\"\n        convert to DeePMD-Kit System, there are two system mode, that `standard` (std) and `attention` (att)\n            1) standard: https://docs.deepmodeling.com/projects/deepmd/en/master/data/system.html\n            2) attention: https://docs.deepmodeling.com/projects/deepmd/en/master/model/train-se-atten.html#data-format\n\n        Args:\n            system_dir: the dir for all system data store, if the validate_dir has been given, this is the dir of\n             training system\n            mode: the system mode, choose from att or std\n            validate_ratio(float): the ratio of validate data set.\n            validate_dir(str|Path): if validate_ratio has been specified, this must be given\n        \"\"\"\n        system: DeepSystem = self.dump('dpmd_sys')\n        system(system_dir, mode, validate_ratio, validate_dir)\n\n    def to_mix_mol(self):\n        \"\"\" Convert this Molecule object to MixSaveAtomMol \"\"\"\n        return MixSameAtomMol(_data=self._data)\n\n    def to_rdmol(self):\n        \"\"\" convert hotpot Molecule object to RdKit mol object \"\"\"\n        return Chem.MolFromMol2Block(self.dump('mol2'))\n\n    @property\n    def unique_all_atoms(self) -> List[Union['Atom', 'PseudoAtom']]:\n        return self.unique_atoms + self.unique_pseudo_atoms\n\n    @property\n    def unique_atoms(self):\n        uni = []\n        for a in self.atoms:\n            if a not in uni:\n                uni.append(a)\n        return uni\n\n    @property\n    def unique_bonds(self):\n        uni = []\n        for b in self.bonds:\n            if b not in uni:\n                uni.append(b)\n        return uni\n\n    @property\n    def unique_bond_pairs(self) -> List[Tuple[int, int, int]]:\n        \"\"\" Retrieve unique bond pair in the molecule, i.e. a bond with same atoms element combination and bond type \"\"\"\n        return [b.pair_key for b in self.unique_bonds]\n\n    @property\n    def unique_pseudo_atoms(self) -> List['PseudoAtom']:\n        uni = []\n        for pa in self.pseudo_atoms:\n            if pa not in uni:\n                uni.append(pa)\n        return uni\n\n    @property\n    def weight(self):\n        return self.ob_mol.GetExactMass()\n\n    def writefile(self, fmt: str, path_file, retrieve_script=False, *args, **kwargs):\n        \"\"\"Write the Molecule Info into a file with specific format(fmt)\"\"\"\n        script = self.dump(fmt=fmt, *args, **kwargs)\n        if isinstance(script, str):\n            mode = 'w'\n        elif isinstance(script, bytes):\n            mode = 'wb'\n        else:\n            raise IOError(f'the {type(script)} type for script is not supported to write into file')\n\n        with open(path_file, mode) as writer:\n            writer.write(script)\n\n        if retrieve_script:\n            return script\n\n    @property\n    def xyz_min(self) -> np.ndarray:\n        \"\"\" Return the minimum of x coordinates wreathing all atoms \"\"\"\n        return self.coordinates.min(axis=0)\n\n    @property\n    def xyz_max(self) -> np.ndarray:\n        return self.coordinates.max(axis=0)\n\n    @property\n    def xyz_diff(self):\n        return self.xyz_max - self.xyz_min\n\n    @property\n    def z_matrix(self) -> 'ZMatrix':\n        return ZMatrix(self)", "\n\nclass MixSameAtomMol(Molecule):\n    \"\"\" the only difference to the Molecule class is the method of their addition  \"\"\"\n\n    def __repr__(self):\n        return f'MixMol({self.formula})'\n\n    def _merge_conformer_attr(self, other: 'Molecule'):\n        \"\"\"\"\"\"\n        # merge the MixSameAtomMol-specific conformer attributes\n        left_atomic_numbers: Dict[Tuple[int], int] = self.atomic_numbers\n        right_atomic_numbers: Union[Dict[Tuple[int], int], Tuple[int]] = other.atomic_numbers\n\n        # If the right atomic_number is a tuple convert it to dict.\n        if isinstance(right_atomic_numbers, tuple):\n            right_atomic_numbers = {right_atomic_numbers: other.conformer_counts}\n\n        for atomic_numbers, conformer_counts in right_atomic_numbers.items():\n            left_atomic_numbers[atomic_numbers] = left_atomic_numbers.get(atomic_numbers, 0) + conformer_counts\n\n        self._set_atomic_numbers(left_atomic_numbers)\n\n        # ##### the super method ######\n        # Merge the basic conformer attributes\n        super(MixSameAtomMol, self)._merge_conformer_attr(other)\n\n        return self\n\n    def _set_atomic_numbers(self, atomic_numbers: Dict[Tuple[int], int]):\n        \"\"\" Set all atoms' atomic numbers and their corresponding number of conformers \"\"\"\n        self.update_attr_data({'atomic_numbers': atomic_numbers})\n\n    @property\n    def atomic_numbers(self) -> Dict[Tuple[int], int]:\n        \"\"\" get each conformer atomic numbers \"\"\"\n        atomic_numbers = self.data.get('atomic_numbers')\n        if not atomic_numbers:\n            atomic_numbers = {super(MixSameAtomMol, self).atomic_numbers: self.conformer_counts}\n            self._set_atomic_numbers(atomic_numbers)\n\n        return atomic_numbers\n\n    @property\n    def atomic_number_counts(self):\n        \"\"\" the counts of series of atomic_numbers \"\"\"\n        return len(self.atomic_numbers)\n\n    @property\n    def atomic_numbers_array(self) -> np.ndarray:\n        \"\"\" the conformer corresponding attributes with array shape (counts_of_atoms, counts_of_conformers) \"\"\"\n        atomic_numbers_array = []\n        for atomic_numbers, conformer_counts in self.atomic_numbers.items():\n            atomic_numbers_array.append(np.array(atomic_numbers).reshape(1, -1).repeat(conformer_counts, axis=0))\n\n        return np.concatenate(atomic_numbers_array)\n\n    def iadd_accessible(self, other):\n        if self.atom_counts == other.atom_counts:\n            return True\n        return False\n\n    def to_mol(self):\n        \"\"\" Convert this MixSameAtomMol object to Molecule \"\"\"\n        if self.atomic_number_counts > 1:\n            raise AttributeError(\n                'Cannot convert the MixSameAtomMol with multipy atomic_number series to Molecule object\\n'\n                f'atomic_number_counts = {self.atomic_number_counts}'\n            )\n\n        return Molecule(_data=self.data)", "\n\nclass Atom(Wrapper, ABC):\n    \"\"\" The Atom wrapper for OBAtom class in openbabel \"\"\"\n\n    def __init__(\n            self,\n            ob_atom: ob.OBAtom = None,\n            **kwargs\n    ):\n        # Contain all data to reappear this Atom\n        self._data: Dict[str, Any] = {\n            'ob_obj': ob_atom if ob_atom else ob.OBAtom(),\n        }\n\n        self._set_attrs(**kwargs)\n\n    def __eq__(self, other):\n        if isinstance(other, Atom):\n            return self.ob_atom == other.ob_atom\n\n    def __hash__(self):\n        return hash(f'Atom({self.atomic_number})')\n\n    @property\n    def ob_atom(self):\n        return self._data['ob_obj']\n\n    @ob_atom.setter\n    def ob_atom(self, oba):\n        self._data['ob_obj'] = oba\n\n    def ob_atom_pop(self):\n        return self._data.pop('ob_obj')\n\n    def ob_atom_rewrap(self, ob_atom):\n        self._data['ob_obj'] = ob_atom\n\n    def __repr__(self):\n        return f\"Atom({self.label if self.label else self.symbol})\"\n\n    def _assign_formal_charge(self):\n        \"\"\" assign formal charge for this atom, the formal charge equal its valence minus its covalent valence \"\"\"\n        if self.is_polar_hydrogen:\n            self.formal_charge = 1\n        elif self.is_hydrogen or self.is_carbon:\n            self.formal_charge = 0\n        elif self.is_metal:\n            self.formal_charge = _stable_charges[self.symbol]\n        else:\n            self.formal_charge = -len([a for a in self.neighbours if a.is_polar_hydrogen])\n\n    @property\n    def _attr_setters(self) -> Dict[str, Callable]:\n        return {\n            '_mol': self._set_molecule,\n            'mol': self._set_molecule,\n            'molecule': self._set_molecule,\n            'atomic_number': self._set_atomic_number,\n            'symbol': self._set_atomic_symbol,\n            'coordinates': self._set_coordinate,\n            'formal_charge': self._set_formal_charge,\n            'partial_charge': self._set_partial_charge,\n            'label': self._set_label,\n            'ob_id': self._set_ob_id,\n            'spin_density': self._set_spin_density\n        }\n\n    def _set_atomic_number(self, atomic_number: int):\n        self.ob_atom.SetAtomicNum(int(atomic_number))\n\n    def _set_atomic_symbol(self, symbol):\n        self.ob_atom.SetAtomicNum(ob.GetAtomicNum(symbol))\n\n    def _set_coordinate(self, coordinates):\n        self.ob_atom.SetVector(*coordinates)\n\n    def _set_force_vector(self, force_vector: Union[Sequence, np.ndarray]):\n        if isinstance(force_vector, Sequence):\n            if all(isinstance(f, float) for f in force_vector):\n                force_vector = np.array(force_vector)\n            else:\n                ValueError('the give force_vector must float vector with dimension 3')\n        elif isinstance(force_vector, np.ndarray):\n            force_vector = force_vector.flatten()\n        else:\n            raise TypeError('the force vector should be Sequence or np.ndarray')\n\n        self._data['force_vector'] = force_vector\n\n    def _set_formal_charge(self, charge: float):\n        self.ob_atom.SetFormalCharge(charge)\n\n    def _set_ob_id(self, ob_id):\n        self.ob_atom.SetId(ob_id)\n\n    def _set_label(self, label):\n        label_data = ob.OBCommentData()\n\n        label_data.SetAttribute('label')\n        label_data.SetData(label)\n\n        self.ob_atom.CloneData(label_data)\n\n    def _set_molecule(self, molecule: Molecule):\n        self._data['mol'] = molecule\n\n    def _set_partial_charge(self, charge):\n        self.ob_atom.SetPartialCharge(charge)\n\n    def _set_spin_density(self, spin_density: float):\n        self._data['spin_density'] = spin_density\n\n    @property\n    def atom_type(self):\n        \"\"\" Some atom have specific type, such as Carbon with sp1, sp2 and sp3, marked as C1, C2 and C3 \"\"\"\n        return self.ob_atom.GetType()\n\n    def add_atom(self, symbol: str, bond_type=1, **atom_attrs):\n        \"\"\" add atom to link with this atom \"\"\"\n        new_atom = self.molecule.add_atom(symbol, **atom_attrs)\n        self.molecule.add_bond(self, new_atom, bond_type)\n\n    def add_hydrogen(self):\n        \"\"\" add hydrogen to the atom \"\"\"\n        self.add_atom('H')\n\n    @property\n    def atomic_number(self):\n        return self.ob_atom.GetAtomicNum()\n\n    def balance_hydrogen(self):\n        \"\"\" Remove or add hydrogens link with this atom, if the bond valence is not equal to the atomic valence \"\"\"\n        if self.is_heavy and not self.is_metal:  # Do not add or remove hydrogens to the metal, H or inert elements\n            while self.valence > self.stable_valence and self.neighbours_hydrogen:\n                self.molecule.remove_atoms(self.neighbours_hydrogen[0])\n\n            # add hydrogen, if the bond valence less than the atomic valence\n            while self.valence < self.stable_valence:\n                self.add_hydrogen()\n\n    @property\n    def bonds(self):\n        \"\"\" Get all bonds link with the atoms \"\"\"\n        return [self.molecule.bonds_dict[obb.GetId()] for obb in ob.OBAtomBondIter(self.ob_atom)]\n\n    @property\n    def coordinates(self) -> (float, float, float):\n        return self.ob_atom.GetX(), self.ob_atom.GetY(), self.ob_atom.GetZ()\n\n    @coordinates.setter\n    def coordinates(self, value):\n        self._set_coordinate(value)\n\n    @property\n    def coordinates_array(self) -> np.ndarray:\n        \"\"\" the array of coordinates \"\"\"\n        return np.array(self.coordinates)\n\n    def copy(self):\n        \"\"\" Make a copy of self \"\"\"\n        # Extract old data\n        data = self.data\n        data.pop('ob_obj')  # Remove the old OBAtom\n        # Remove molecule if the parent atom in a molecule\n        if self.molecule:\n            data.pop('mol')\n\n        # Copy the information contained in OBAtom\n        new_attrs = {\n            \"atomic_number\": self.atomic_number,\n            \"coordinates\": self.coordinates,\n            'partial_charge': self.partial_charge,\n        }\n\n        new_attrs.update(**data)\n\n        return Atom(**new_attrs)\n\n    @property\n    def covalent_valence(self):\n        \"\"\" the number of covalent electrons for this atoms \"\"\"\n        return sum(b.type if b.is_covalent else 0 for b in self.bonds)\n\n    def element_features(self, *feature_names) -> np.ndarray:\n        \"\"\" Retrieve the feature vector \"\"\"\n        atom_feature = periodic_table[self.symbol]\n\n        features = []\n        for feature_name in feature_names:\n            if feature_name == 'atomic_orbital':\n                features.extend(self._atomic_orbital_feature().values())\n            elif feature_name == 'atomic_number':\n                features.append(self.atomic_number)\n            else:\n                features.append(atom_feature[feature_name])\n\n        return np.array(features)\n\n    def _atomic_orbital_feature(self, outermost_layer=True, nonexistent_orbit=0):\n        \"\"\"    Calculating the feature about atomic orbital structures    \"\"\"\n        _atomic_orbital_structure_max = {\n            \"1s\": 2,\n            \"2s\": 2, \"2p\": 6,\n            \"3s\": 2, \"3p\": 6,\n            \"4s\": 2, \"3d\": 10, \"4p\": 6,\n            \"5s\": 2, \"4d\": 10, \"5p\": 6,\n            \"6s\": 2, \"4f\": 14, \"5d\": 10, \"6p\": 6,\n            \"7s\": 2, \"5f\": 14, \"6d\": 10, \"7p\": 6\n        }\n        atomic_orbital_structure = {\n            \"1s\": 0,\n            \"2s\": 0, \"2p\": 0,\n            \"3s\": 0, \"3p\": 0,\n            \"4s\": 0, \"3d\": 0, \"4p\": 0,\n            \"5s\": 0, \"4d\": 0, \"5p\": 0,\n            \"6s\": 0, \"4f\": 0, \"5d\": 0, \"6p\": 0,\n            \"7s\": 0, \"5f\": 0, \"6d\": 0, \"7p\": 0\n        }\n\n        # Calculating atomic orbital structure\n        residual_electron = self.atomic_number\n        n_osl = 0  # Principal qm number (n) of open shell layers (osl)\n        for orbital_name, men in _atomic_orbital_structure_max.items():  # max electron number (men)\n\n            # Update Principal qm number (n)\n            if orbital_name[1] == \"s\":\n                n_osl = int(orbital_name[0])\n\n            # Filled atomic orbital\n            if residual_electron - men >= 0:\n                residual_electron = residual_electron - men\n                atomic_orbital_structure[orbital_name] = men\n            else:\n                atomic_orbital_structure[orbital_name] = residual_electron\n                break\n\n        # Readout and return outermost electron structure\n        atom_orbital_feature = {\"atomic_number\": self.atomic_number, \"n_osl\": n_osl}\n        if outermost_layer:\n            diff_max_n = {\"s\": 0, \"p\": 0, \"d\": -1, \"f\": -2}\n            for layer, diff in diff_max_n.items():  # Angular momentum qm number (l)\n                electron_number = atomic_orbital_structure.get(f\"{n_osl + diff}{layer}\", nonexistent_orbit)\n                atom_orbital_feature[layer] = electron_number\n        else:\n            atom_orbital_feature.update(atomic_orbital_structure)\n\n        # return whole electron structure directly\n        return atom_orbital_feature\n\n    @property\n    def force_vector(self):\n        return self._data.get('force_vector', np.zeros(3, dtype=float))\n\n    @force_vector.setter\n    def force_vector(self, force_vector: Union[Sequence, np.ndarray]):\n        self._set_force_vector(force_vector)\n\n    @property\n    def formal_charge(self) -> float:\n        return self.ob_atom.GetFormalCharge()\n\n    @formal_charge.setter\n    def formal_charge(self, value: float):\n        self.ob_atom.SetFormalCharge(value)\n\n    @property\n    def has_unknown_bond(self) -> bool:\n        return any(not b.type for b in self.bonds)\n\n    @property\n    def hybridization(self):\n        \"\"\" The hybridization of this atom:\n        1 for sp, 2 for sp2, 3 for sp3, 4 for sq. planar, 5 for trig. bipy, 6 for octahedral \"\"\"\n        return self.ob_atom.GetHyb()\n\n    @property\n    def kwargs_attributes(self):\n        return tuple(self._attr_setters.keys())\n\n    @property\n    def ob_id(self):\n        return self.ob_atom.GetId()\n\n    @property\n    def ob_idx(self):\n        return self.ob_atom.GetIdx()\n\n    @property\n    def is_aromatic(self):\n        return self.ob_atom.IsAromatic()\n\n    @property\n    def is_carbon(self):\n        return self.atomic_number == 6\n\n    @property\n    def is_chiral(self):\n        return self.ob_atom.IsChiral()\n\n    @property\n    def is_hydrogen(self):\n        return self.ob_atom.GetAtomicNum() == 1\n\n    @property\n    def is_heavy(self):\n        \"\"\" Whether the atom is heavy atom \"\"\"\n        return not self.is_hydrogen\n\n    @property\n    def is_polar_hydrogen(self) -> bool:\n        \"\"\" Is this atom a hydrogen connected to a polar atom \"\"\"\n        return self.ob_atom.IsPolarHydrogen()\n\n    @property\n    def is_metal(self):\n        return self.ob_atom.IsMetal()\n\n    @property\n    def label(self):\n        label_data = self.ob_atom.GetData('label')\n\n        if label_data:\n            label_data = ob.toCommentData(label_data)\n            return label_data.GetValue()\n        else:\n            return self.symbol\n\n    @label.setter\n    def label(self, value):\n        self._set_label(value)\n\n    @property\n    def link_degree(self) -> int:\n        \"\"\" the degree of the atom in their parent molecule \"\"\"\n        return self.ob_atom.GetTotalDegree()\n\n    @property\n    def mass(self):\n        return self.ob_atom.GetAtomicMass()\n\n    @property\n    def max_bonds(self):\n        \"\"\" the max allowed bond order\"\"\"\n        return ob.GetMaxBonds(self.atomic_number)\n\n    @property\n    def molecule(self) -> Molecule:\n        return self._data.get('mol')\n\n    @molecule.setter\n    def molecule(self, mol: 'Molecule'):\n        self._data['mol'] = mol\n\n    @property\n    def neighbours_hydrogen(self) -> List['Atom']:\n        \"\"\" return all neigh hydrogen atoms \"\"\"\n        return [a for a in self.neighbours if a.is_hydrogen]\n\n    @property\n    def electronegativity(self):\n        return ob.GetElectroNeg(self.atomic_number)\n\n    @property\n    def neighbours(self) -> List['Atom']:\n        \"\"\" Get all atoms bond with this atom in same molecule \"\"\"\n        if self.molecule:\n            _ = self.molecule.atoms  # update the atoms dict\n            return [self.molecule.atoms_dict[ob_atom.GetId()] for ob_atom in ob.OBAtomAtomIter(self.ob_atom)]\n        else:\n            return []\n\n    @property\n    def neighbours_label(self) -> List[str]:\n        \"\"\" return all neighbours labels \"\"\"\n        return [a.label for a in self.neighbours]\n\n    @property\n    def neighbours_position(self) -> Generator[Tuple[Union['Atom', np.ndarray]], None, None]:\n        \"\"\" Retrieve the relative position of neigh atoms, assign this atom as the origin \"\"\"\n        for neigh_atom in self.neighbours:\n            yield neigh_atom, neigh_atom.coordinates_array - self.coordinates_array\n\n    @property\n    def partial_charge(self):\n        return self.ob_atom.GetPartialCharge()\n\n    @partial_charge.setter\n    def partial_charge(self, value: float):\n        # This is necessary to take effect to the assignment.\n        # the reason is unknown\n        self.ob_atom.GetPartialCharge()\n        self._set_partial_charge(value)\n\n    def remove_hydrogen(self):\n        \"\"\" remove the first atom linking with the atoms \"\"\"\n        hydrogens = self.neighbours_hydrogen\n        if hydrogens:\n            self.molecule.remove_atoms(hydrogens[0])\n\n    def remove_hydrogens(self):\n        \"\"\" Remove all hydrogens linking with the atom\"\"\"\n        hydrogens = self.neighbours_hydrogen\n        self.molecule.remove_atoms(*hydrogens)\n\n    def replace_attr_data(self, data: Dict):\n        \"\"\" Replace the core data dict directly \"\"\"\n        self._data = data\n\n    def set(self, **kwargs):\n        \"\"\"\n        Set atom attributes by kwargs\n        Kwargs:\n            atomic_number(int): set atomic number\n            symbol(str): set atomic symbol\n            coordinates(Sequence, numpy.ndarray): coordinates of the atom\n            partial_charge:\n            label:\n            spin_density:\n        \"\"\"\n        self._set_attrs(**kwargs)  # set attributes\n\n    @property\n    def spin_density(self):\n        return self._data.get('spin_density', 0.0)\n\n    @spin_density.setter\n    def spin_density(self, spin_density: float):\n        self._set_spin_density(spin_density)\n\n    @property\n    def stable_valence(self) -> int:\n        if self.is_metal:\n            return 0\n        elif self.symbol == 'S':\n            if not [a for a in self.neighbours if a.symbol == 'O']:\n                return 2\n            elif self.covalent_valence <= 2:\n                return 2\n            elif self.covalent_valence <= 4:\n                return 4\n            else:\n                return 6\n        elif self.symbol == 'S':\n            if not [a for a in self.neighbours if a.symbol == 'O']:\n                return 3\n            elif self.covalent_valence == 0:\n                return 0\n            elif self.covalent_valence == 1:\n                return 1\n            elif self.covalent_valence <= 3:\n                return 3\n            else:\n                return 5\n        else:\n            return abs(_stable_charges[self.symbol])\n\n    @property\n    def symbol(self) -> str:\n        return ob.GetSymbol(self.atomic_number)\n\n    @property\n    def valence(self) -> int:\n        # if self.has_unknown_bond:\n        #     raise AttributeError('Cannot calculate the bond valence, because of the existence of unknown bonds')\n        return sum(b.type if b.type else 0 if b.is_covalent else 1 for b in self.bonds)", "\n\nclass PseudoAtom(Wrapper, ABC):\n    \"\"\" A data wrapper for pseudo atom \"\"\"\n\n    def __init__(self, symbol: str, mass: float, coordinates: Union[Sequence, np.ndarray], **kwargs):\n        if isinstance(coordinates, Sequence):\n            coordinates = np.array(coordinates)\n\n        assert isinstance(coordinates, np.ndarray) and coordinates.shape == (3,)\n\n        self._data = dict(symbol=symbol, mass=mass, coordinates=coordinates, **kwargs)\n\n    def __eq__(self, other):\n        if isinstance(other, PseudoAtom):\n            return self.symbol == other.symbol\n        return False\n\n    def __hash__(self):\n        return hash(f'PseudoAtom({self.symbol})')\n\n    def _attr_setters(self) -> Dict[str, Callable]:\n        return {}\n\n    def __repr__(self):\n        return f'PseudoAtom({self.symbol})'\n\n    def __dir__(self) -> Iterable[str]:\n        return list(self._data.keys())\n\n    def __getattr__(self, item):\n        return self._data.get(item, 0.)", "\n\nclass Bond(Wrapper, ABC):\n    \"\"\"\"\"\"\n\n    def __init__(self, ob_bond: ob.OBBond, _mol: Molecule):\n        self._data = {\n            'ob_obj': ob_bond,\n            'mol': _mol\n        }\n\n    def __repr__(self):\n        return f\"Bond({self.atoms[0].label}, {self.atoms[1].label}, {self.type_name})\"\n\n    def __eq__(self, other: 'Bond'):\n        if isinstance(other, Bond):\n            return self.pair_key == other.pair_key\n\n    def __hash__(self):\n        return hash(self.pair_key)\n\n    def __getitem__(self, item):\n        return self._data.get(item)\n\n    def __setitem__(self, key, value):\n        if key in super()._protected_data:\n            raise KeyError('the protected attr cannot be set be __setitem__ method')\n\n        self._data[key] = value\n\n    @property\n    def _protected_data(self):\n        return 'ob_obj', 'mol'\n\n    @property\n    def ob_bond(self):\n        return self._data['ob_obj']\n\n    def ob_bond_pop(self):\n        return self._data.pop('ob_obj')\n\n    def ob_bond_rewrap(self, ob_bond):\n        self._data['ob_obj'] = ob_bond\n\n    @property\n    def _attr_setters(self) -> Dict[str, Callable]:\n        return {\n        }\n\n    @property\n    def atom1(self) -> Atom:\n        return self.molecule.atoms_dict[self.ob_atom1_id]\n\n    @property\n    def atom2(self) -> Atom:\n        return self.molecule.atoms_dict[self.ob_atom2_id]\n\n    @property\n    def atomic_number1(self):\n        return self.ob_bond.GetBeginAtom().GetAtomicNum()\n\n    @property\n    def atomic_number2(self):\n        return self.ob_bond.GetEndAtom().GetAtomicNum()\n\n    @property\n    def atoms(self):\n        return self.atom1, self.atom2\n\n    @property\n    def begin_end_ob_id(self) -> (int, int):\n        return self.ob_bond.GetBeginAtom().GetId(), self.ob_bond.GetEndAtom().GetId()\n\n    @property\n    def begin_end_atomic_number(self):\n        return self.ob_bond.GetBeginAtom().GetAtomicNum(), self.ob_bond.GetEndAtom().GetAtomicNum()\n\n    @property\n    def is_covalent(self) -> bool:\n        return not self.ob_atom1.IsMetal() and not self.ob_atom2.IsMetal()\n\n    @property\n    def ideal_length(self):\n        return self.ob_bond.GetEquibLength()\n\n    @property\n    def ob_id(self):\n        return self.ob_bond.GetId()\n\n    @property\n    def ob_idx(self):\n        return self.ob_bond.GetIdx()\n\n    @property\n    def ob_atom1(self):\n        return self.ob_bond.GetBeginAtom()\n\n    @property\n    def ob_atom2(self):\n        return self.ob_bond.GetEndAtom()\n\n    @property\n    def ob_atom1_id(self):\n        return self.ob_atom1.GetId()\n\n    @property\n    def ob_atom2_id(self):\n        return self.ob_atom2.GetId()\n\n    @property\n    def pair_key(self):\n        \"\"\" Get the bond pair key, a string that show combination of element of end atoms and bond type,\n        where, the atomic symbol with lower atomic number is placed in the first, the higher in the last\"\"\"\n        if self.atomic_number1 <= self.atomic_number2:\n            return self.atomic_number1, self.type, self.atomic_number2\n        return self.atomic_number2, self.type, self.atomic_number1\n\n    @property\n    def length(self):\n        return self.ob_bond.GetLength()\n\n    @property\n    def molecule(self):\n        return self._data['mol']\n\n    @molecule.setter\n    def molecule(self, mol: Molecule):\n        self._data['mol'] = mol\n\n    @property\n    def type_name(self):\n        return _type_bond[self.type]\n\n    @property\n    def type(self):\n        return self.ob_bond.GetBondOrder()", "\n\nclass Angle(MolLinker, ABC):\n    \"\"\" Data wrapper of angle in molecule \"\"\"\n    def __init__(self, mol: Molecule, *ob_ids: int):\n        assert len(ob_ids) == 3\n        super().__init__(mol, ob_ids[1], ob_ids[0], ob_ids[2])\n\n    @property\n    def _degree(self) -> float:\n        return round(self.mol.ob_mol.GetAngle(*self.ob_atoms), 3)\n\n    @property\n    def degree(self) -> float:\n        return self._degree", "\n\nclass Torsion(MolLinker):\n    \"\"\"\"\"\"\n    @property\n    def _degree(self) -> float:\n        return self.mol.ob_mol.GetTorsion(*self.ob_atoms)\n\n    @property\n    def a(self) -> Atom:\n        \"\"\" The first atom \"\"\"\n        return self.mol.atoms_dict[self.ob_atoms[0].GetId()]\n\n    @property\n    def b(self) -> Atom:\n        \"\"\" The second atom \"\"\"\n        return self.mol.atoms_dict[self.ob_atoms[1].GetId()]\n\n    @property\n    def c(self) -> Atom:\n        \"\"\" The third atom \"\"\"\n        return self.mol.atoms_dict[self.ob_atoms[2].GetId()]\n\n    @property\n    def d(self) -> Atom:\n        \"\"\" The fourth atom \"\"\"\n        return self.mol.atoms_dict[self.ob_atoms[3].GetId()]\n\n    @property\n    def torsion(self) -> float:\n        return self._degree", "\n\nclass Crystal(Wrapper, ABC):\n    \"\"\"\"\"\"\n    _lattice_type = (\n        'Undefined', 'Triclinic', 'Monoclinic', 'Orthorhombic', 'Tetragonal', 'Rhombohedral', 'Hexagonal', 'Cubic'\n    )\n\n    def __init__(self, ob_unitcell: ob.OBUnitCell = None, **kwargs):\n\n        self._data: Dict[str, Any] = {\n            'OBUnitCell': ob_unitcell if ob_unitcell else ob.OBUnitCell(),\n        }\n\n        self._set_attrs(**kwargs)\n\n    def __repr__(self):\n        return f'Crystal({self.lattice_type}, {self.space_group}, {self.molecule})'\n\n    @property\n    def ob_unit_cell(self) -> ob.OBUnitCell:\n        return self._data.get('OBUnitCell')\n\n    @staticmethod\n    def _matrix_to_params(matrix: np.ndarray):\n        \"\"\" Covert the cell matrix to cell parameters: a, b, c, alpha, beta, gamma \"\"\"\n        va, vb, vc = matrix\n        a = sum(va ** 2) ** 0.5\n        b = sum(vb ** 2) ** 0.5\n        c = sum(vc ** 2) ** 0.5\n\n        alpha = np.arccos(np.dot(va, vb) / (a * b)) / np.pi * 180\n        beta = np.arccos(np.dot(va, vc) / (a * c)) / np.pi * 180\n        gamma = np.arccos(np.dot(vb, vc) / (b * c)) / np.pi * 180\n\n        return a, b, c, alpha, beta, gamma\n\n    def _set_molecule(self, molecule: Molecule):\n        if molecule.crystal and isinstance(molecule.crystal, Crystal):\n            print(AttributeError(\"the Molecule have been stored in a Crystal, \"\n                                 \"can't save the same Molecule into two Crystals\"))\n        else:\n            self._data['mol'] = molecule\n\n    def _set_space_group(self, space_group: str):\n        self.ob_unit_cell.SetSpaceGroup(space_group)\n\n    @property\n    def _attr_setters(self) -> Dict[str, Callable]:\n        return {\n            'mol': self._set_molecule,\n            'molecule': self._set_molecule,\n            'space_group': self._set_space_group\n        }\n\n    @property\n    def lattice_type(self) -> str:\n        return self._lattice_type[self.ob_unit_cell.GetLatticeType()]\n\n    @property\n    def lattice_params(self) -> np.ndarray[2, 3]:\n        a = self.ob_unit_cell.GetA()\n        b = self.ob_unit_cell.GetB()\n        c = self.ob_unit_cell.GetC()\n        alpha = self.ob_unit_cell.GetAlpha()\n        beta = self.ob_unit_cell.GetBeta()\n        gamma = self.ob_unit_cell.GetGamma()\n        return np.array([[a, b, c], [alpha, beta, gamma]])\n\n    @property\n    def molecule(self) -> Molecule:\n        return self._data.get('mol')\n\n    @molecule.setter\n    def molecule(self, mol: Molecule):\n        self._data['mol'] = mol\n\n    @property\n    def pack_molecule(self) -> Molecule:\n        mol = self.molecule  # Get the contained Molecule\n\n        if not mol:  # if you get None\n            print(RuntimeWarning(\"the crystal doesn't contain any Molecule!\"))\n\n        pack_mol = mol.copy()\n        self.ob_unit_cell.FillUnitCell(pack_mol.ob_mol)  # Full the crystal\n        pack_mol._reorganize_atom_indices()  # Rearrange the atom indices.\n\n        return pack_mol\n\n    def set_lattice(\n            self,\n            a: float, b: float, c: float,\n            alpha: float, beta: float, gamma: float\n    ):\n        self.ob_unit_cell.SetData(a, b, c, alpha, beta, gamma)\n\n    def set_vectors(\n            self,\n            va: Union[np.ndarray, Sequence],\n            vb: Union[np.ndarray, Sequence],\n            vc: Union[np.ndarray, Sequence]\n    ):\n        \"\"\"\"\"\"\n        vectors = [va, vb, vc]\n        matrix = np.array(vectors)\n        self.set_matrix(matrix)\n\n    def set_matrix(self, matrix: np.ndarray):\n        \"\"\" Set cell matrix for the crystal \"\"\"\n        if matrix.shape != (3, 3):\n            raise AttributeError('the shape of cell_vectors should be [3, 3]')\n\n        cell_params = map(float, self._matrix_to_params(matrix))\n\n        self.ob_unit_cell.SetData(*cell_params)\n\n    @property\n    def space_group(self):\n        space_group = self.ob_unit_cell.GetSpaceGroup()\n        if space_group:\n            return space_group.GetHMName()\n        else:\n            return None\n\n    @space_group.setter\n    def space_group(self, value: str):\n        self._set_space_group(value)\n\n    @property\n    def volume(self):\n        return self.ob_unit_cell.GetCellVolume()\n\n    @property\n    def vector(self):\n        v1, v2, v3 = self.ob_unit_cell.GetCellVectors()\n        return np.array([\n            [v1.GetX(), v1.GetY(), v1.GetZ()],\n            [v2.GetX(), v2.GetY(), v2.GetZ()],\n            [v3.GetX(), v3.GetY(), v3.GetZ()]\n        ])\n\n    def zeo_plus_plus(self):\n        \"\"\" TODO: complete the method after define the Crystal and ZeoPlusPlus tank \"\"\"", "\n\nclass ZMatrix:\n    \"\"\"\n    Represent the Z-Matrix(internal coordinates) in a Molecule.\n    The Z-Matrix of a Molecule objects could be accessed by its attribute `z_matrix`\n\n    Each element of Z-Matrix, like start atom, radium, angle, dihedral could be accessed by subscript.\n    Liking ZMatrix['r10'], it gets a radium start from 10th atoms. the subscripts are encode to be strings\n    with 's'(start atom), 'r'(radium), 'a'(angle), 'd'(dihedral) as the first header, and the number of atoms\n    as the follower. It should be noted that the number of atoms start from 1 instead of the 0, in general\n    it's the ob_id - 1\n\n    Examples:\n        mol = hp.Molecule.read_from(...)\n        zmat = mol.z_matrix\n        print(zmat['s10'], zmat['r10'], zmat['a10'], zmat['d10'])\n\n    \"\"\"\n    class ZMatrixItem:\n        def __init__(self, key: str, item: Union[Atom, Bond, Angle, Torsion], value: float):\n            self.key = key\n            self.item = item\n            self.value = value\n\n        def __repr__(self):\n            return f\"{self.item.__class__.__name__}({self.key}, \" \\\n                   f\"{self.item_value if isinstance(self.item_value, int) else round(self.item_value, 3)})\"\n\n        @property\n        def item_value(self) -> Union[float, int]:\n            if isinstance(self.item, Atom):\n                return self.item.ob_id\n            elif isinstance(self.item, Bond):\n                return self.item.length\n            elif isinstance(self.item, Angle):\n                return self.item.degree\n            elif isinstance(self.item, Torsion):\n                return self.item.torsion\n\n    def __init__(self, mol: Molecule):\n        self.mol = mol\n        self._coords = {}\n        self._coord_line = {}\n        self._update_coords()\n\n    def __repr__(self):\n        return f'InternalCoordinates({len(self)})'\n\n    def __str__(self):\n        return '\\n'.join(' '.join(str(item) for item in line) for _, line in self)\n\n    def __len__(self):\n        return len(self._coord_line)\n\n    def __iter__(self):\n        return iter(self._coord_line.items())\n\n    def __getitem__(self, item):\n        self._update_coords()\n        return self._coords[item]\n\n    def __setitem__(self, key, value):\n        \"\"\" Set the Z-Matrix, TODO: this method do not work now \"\"\"\n        ob_internal_coords = list(self.mol.ob_mol.GetInternalCoord())\n        head, line_count = key[0], int(key[1:])\n\n        # Check the given key\n        if head not in ('r', 'a', 'd') or line_count >= len(ob_internal_coords):\n            raise KeyError(f'cannot not set the attr {key}, it is non-existent or irregular')\n        elif line_count == 2 and head in ('a', 'd'):\n            raise KeyError(f'cannot not set the attr {key}, it is non-existent or irregular')\n        elif line_count == 3 and head == 'd':\n            raise KeyError(f'cannot not set the attr {key}, it is non-existent or irregular')\n\n        # Get the original OBInternalCoord\n        set_coord: ob.OBInternalCoord = ob_internal_coords[line_count]\n\n        # Replace the value of specified item\n        kwargs = {\n            'a': set_coord._a,\n            'b': set_coord._b,\n            'c': set_coord._c,\n            'dst': value if head == 'r' else set_coord._dst,\n            'ang': value if head == 'a' else set_coord._ang,\n            'tor': value if head == 'd' else set_coord._tor\n        }\n        ob_internal_coords[line_count] = ob.OBInternalCoord(**kwargs)\n\n        # Set the parent molecule\n        self.mol.ob_mol.SetInternalCoord(ob_internal_coords)\n\n    def _update_coords(self):\n        \"\"\" Update the internal coordinates data \"\"\"\n        coord_lines, coords = {}, {}\n\n        atoms = self.mol.atoms\n        for i, line in enumerate(self.mol.ob_mol.GetInternalCoord()):\n\n            # ignore the first item, it's None\n            if not line:\n                continue\n\n            atom = atoms[i - 1]\n\n            coords[f's{i}'] = self.ZMatrixItem(f's{i}', atom, i - 1)\n\n            coord_line = coord_lines.setdefault(i, [])\n            coord_line.append(coords[f's{i}'])\n\n            # atom_radial, atom_angle, atom_dihedral, radial, angle, dihedral\n            ar, aa, ad, r, a, d = line._a, line._b, line._c, line._dst, line._ang, line._tor\n\n            if isinstance(ar, ob.OBAtom):\n                assert isinstance(r, float)\n                coords[f'r{i}'] = self.ZMatrixItem(\n                    f'r{i}', self.mol.bond(atom.ob_id, ar.GetId()), r\n                )\n                coord_line.append(coords[f'r{i}'])\n\n            if isinstance(aa, ob.OBAtom):\n                assert isinstance(a, float)\n                coords[f'a{i}'] = self.ZMatrixItem(\n                    f'a{i}', self.mol.angle(atom.ob_id, ar.GetId(), aa.GetId()), a\n                )\n                coord_line.append(coords[f'a{i}'])\n\n            if isinstance(ad, ob.OBAtom):\n                assert isinstance(d, float)\n                coords[f'd{i}'] = self.ZMatrixItem(\n                    f'd{i}', self.mol.torsion(atom.ob_id, ar.GetId(), aa.GetId(), ad.GetId()), d\n                )\n                coord_line.append(coords[f'd{i}'])\n\n        self._coord_line = coord_lines\n        self._coords = coords", "\n\nimport hotpot.bundle as bd\nfrom hotpot._io import Dumper, Parser\nfrom hotpot.tanks.cc import PairBundle\nfrom hotpot.tanks.deepmd import DeepSystem\n"]}
{"filename": "hotpot/tmo.py", "chunked_list": ["\"\"\"\npython v3.7.9\n@Project: hotpot\n@File   : tmo.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/5/9\n@Time   : 5:26\n\"\"\"\nfrom typing import Sequence\nimport thermo as tmo", "from typing import Sequence\nimport thermo as tmo\nimport thermo.chemical as cmc\n\n\nclass Thermo:\n    \"\"\" To determine thermodynamical properties of Csubstance \"\"\"\n    def __init__(self, mol, **kwargs):\n        \"\"\"\"\"\"\n        self._data = {\n            'mol': mol\n        }\n\n        self._data.update(kwargs)\n        self._init_property()  # initialization\n\n    def __dir__(self) -> Sequence[str]:\n        d = set(self.__dict__.keys())\n        chem = self.chem\n        eos = self.eos\n\n        if chem:\n            d.update(dir(chem))\n        if eos:\n            d.update(dir(eos))\n\n        return list(d)\n\n    def __getattr__(self, item):\n        chem = self._data.get('chem')  # Get chemical substance\n        eos = self._data.get('eos_')  # Get equation of state\n\n        if chem:\n            attr = getattr(chem, item, None)\n            if attr:\n                return attr\n\n        if eos:\n            attr = getattr(eos, item, None)\n            if attr:\n                return attr\n\n        return None\n\n    def _init_property(self):\n        # Retrieve the substance data by molecule smiles\n        T = self._data.get('T')\n        P = self._data.get('P')\n        V = self._data.get('V')\n        chem_kwargs = {}\n        if T:\n            chem_kwargs['T'] = T\n        if P:\n            chem_kwargs['P'] = P\n\n        try:\n            chem = cmc.Chemical(self.mol.inchi, **chem_kwargs)\n            Tc = chem.Tc\n            Pc = chem.Pc\n            omega = chem.omega\n\n            self._data['chem'] = chem\n\n        except ValueError:\n            Tc = self._data.get('Tc')\n            Pc = self._data.get('Pc')\n            omega = self._data.get('omega')\n\n        # Retrieve the state of equation for thermo.eos module\n        eos_name = self._data.get('eos', 'PR')\n        eos = getattr(tmo.eos, 'PR')\n\n        if eos and Tc and Pc and omega:\n            # if the eos and the critical params are all be retrieved, build eos\n            if T and P:\n                self._data['eos_'] = eos(T=T, P=P, Tc=Tc, Pc=Pc, omega=omega)\n            elif T and V:\n                self._data['eos_'] = eos(T=T, V=V, Tc=Tc, Pc=Pc, omega=omega)\n            elif P and T:\n                self._data['eos_'] = eos(P=P, V=V, Tc=Tc, Pc=Pc, omega=omega)\n            else:\n                self._data['eos_'] = eos(T=298.15, P=101325, Tc=Tc, Pc=Pc, omega=omega)\n\n    @property\n    def chem(self):\n        return self._data.get('chem')\n\n    @property\n    def eos(self):\n        return self._data.get('eos_')\n\n    @property\n    def mol(self):\n        return self._data.get('mol')\n\n    @property\n    def Tc(self):\n        return self.chem.Tc\n\n    @property\n    def mu_l(self):\n        \"\"\" TODO: chemical potential in certain state \"\"\"\n        return", ""]}
{"filename": "hotpot/__init__.py", "chunked_list": ["\"\"\"\npython v3.7.9\n@Project: hotpot\n@File   : __init__.py.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/3/14\n@Time   : 4:06\n\"\"\"\nimport os\nimport sys", "import os\nimport sys\n\nsys.path.append(os.path.abspath(os.path.dirname(__file__)))\n\nhp_root = os.path.abspath(os.path.dirname(__file__))\ndata_root = os.path.abspath(os.path.join(hp_root, 'data'))\n\nfrom hotpot.cheminfo import Molecule\nfrom hotpot.bundle import MolBundle", "from hotpot.cheminfo import Molecule\nfrom hotpot.bundle import MolBundle\n\n__version__ = '0.3.1.0'\n"]}
{"filename": "hotpot/tools.py", "chunked_list": ["\"\"\"\npython v3.7.9\n@Project: hotpot\n@File   : utils.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/3/29\n@Time   : 0:30\n\nNotes:\n    Private common functions", "Notes:\n    Private common functions\n\"\"\"\nfrom os import PathLike\nfrom pathlib import Path\nfrom typing import *\n\n\nclass PathNotExistError(Exception):\n    \"\"\" Raise when can't find a file or dir \"\"\"", "class PathNotExistError(Exception):\n    \"\"\" Raise when can't find a file or dir \"\"\"\n\n\ndef check_path(\n        path: Optional[Union[str, PathLike]],\n        none_allowed: Optional[bool] = True,\n        check_exist: Optional[bool] = False,\n        mkdir: Optional[bool] = False,\n        file_or_dir: Optional[Literal['file', 'dir']] = None\n) -> Union[NoReturn, Path]:\n    \"\"\"\n    Check whether the given path is valid and process str path to a Path object.\n\n    Args:\n        path (Optional[Union[str, PathLike]]): The path to be checked.\n        none_allowed (Optional[bool], default=True): Whether to allow the path to be None.\n        check_exist (Optional[bool], default=False): Whether to check if the path exists.\n        mkdir (Optional[bool], default=False): Whether to create the directory if it doesn't exist.\n        file_or_dir (Optional[Literal['file', 'dir']], default=None): Whether to check if the path is a file or directory.\n\n    Returns:\n        Union[None, Path]: The processed path as a Path object or None if allowed and given as None.\n\n    Raises:\n        ValueError: If the path is None and not allowed, or if `mkdir=True` and `file_or_dir='file'`.\n        TypeError: If the given path is neither a str nor a PathLike object.\n        PathNotExistError: If the path doesn't exist and check_exist is True or mkdir is False.\n        IsADirectoryError: If the path is a directory and file_or_dir is 'file'.\n        NotADirectoryError: If the path is a file and file_or_dir is 'dir'\n    \"\"\"\n    # If get the None, keep it or raise!\n    if not path:\n        if none_allowed:\n            return path\n        else:\n            raise ValueError(\"the path shouldn't to be None\")\n\n    # Check the given path type and transform the str path to Path\n    if isinstance(path, str):\n        path = Path(path)\n    elif not isinstance(path, PathLike):\n        raise TypeError(f'the given path should be str or PathLick, instead of{type(path)}')\n\n    is_exist = path.exists() if (check_exist or mkdir or file_or_dir) else None\n\n    if is_exist is False:\n        if file_or_dir == 'file' and mkdir:\n            raise ValueError(\"the mkdir=True and file_or_dir='file' can't to be set simultaneously!\")\n\n        if mkdir:\n            path.mkdir()\n        else:\n            raise PathNotExistError(f'the path {str(path)} not exist!')\n\n    if file_or_dir == 'file' and not path.is_file():\n        raise IsADirectoryError(f'{str(path)} is a directory!')\n    if file_or_dir == 'dir' and not path.is_dir():\n        raise NotADirectoryError(f'{str(path)} is a file!')\n\n    return path", ""]}
{"filename": "hotpot/_io.py", "chunked_list": ["\"\"\"\npython v3.7.9\n@Project: hotpot\n@File   : _io.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/3/14\n@Time   : 4:18\n\"\"\"\nimport os\nimport re", "import os\nimport re\nfrom pathlib import Path\nfrom os import PathLike\nfrom typing import *\nfrom abc import ABCMeta, abstractmethod\nfrom copy import copy\nimport io\nfrom io import IOBase\nfrom openbabel import pybel", "from io import IOBase\nfrom openbabel import pybel\nimport cclib\nimport numpy as np\n\nimport hotpot.cheminfo as ci\nfrom hotpot.tanks.deepmd import DeepSystem\n\n\"\"\"\nNotes:", "\"\"\"\nNotes:\nThis module contain Classes to IO between the Molecule object and various file formats.\nthe main classes are:\n    - Reader: from Formatted files to Molecule, called by the Molecule.read() method.\n    - Writer: from Molecule to formatted files, called by the Molecule.write() method.\n    - Dumper: from Molecule to formatted Literals(str or bytes), called by the Molecule.dump() method.\n    - Parser: from formatted Literals to the Molecule obj, called by the Molecule.parse() method.\nall of them are inherit from the _IOBase class.\n", "all of them are inherit from the _IOBase class.\n\nFor the implementation of dump and parse:\n    - some third-part package are used, like openbabel, cclib and so on.\n    - there are some self own IO function be defined too.\n    - the user also custom and register to the Dumper and Parser too.\n\nWhen implementing the IO: \n    1) the IO class will firstly check whether a custom IO function is defined and register, if the IO function \n        are defined and registered, the IO are implemented by the registered.", "    1) the IO class will firstly check whether a custom IO function is defined and register, if the IO function \n        are defined and registered, the IO are implemented by the registered.\n    2) else, the IO class will try to call, in turn, try to call some third-part packages,\n    3) finally, if all third-part packages fail to complement IO, Raise the IOError !!!\n\nFollowing the steps to customise your IO function:\n    1) determine which IO operation(read, write, dump or parse) you want to define\uff0c import the relevant IO class\n        into your own python modules.\n    2) define the IO function which customises your IO implementation, the custom function should meet the base\n        requirements demand by the corresponding IO class. When the IO functions are defined, applying the", "    2) define the IO function which customises your IO implementation, the custom function should meet the base\n        requirements demand by the corresponding IO class. When the IO functions are defined, applying the\n        `IOClass`.register decorator to register the IO function into the `IOClass`, the `IOClass`.register should\n        pass some args. This is a example:\n        --------------------------------- Example ------------------------------------\n        Examples:\n        # importing the relevant IO classes\n        from hotpot.io import Dumper, Reader\n        \n        # define and register a read function", "        \n        # define and register a read function\n        # the fmt defined the format key to handle the custom IO function\n        # the types defined where the IO function will be applied, pre: preprocess, io: main io, post: postprocess\n        @Reader.register(fmt='the/format/key', types='pre|io|post')\n        def my_read_func(*arg, **kwargs)  # the args should meet the Reader demand\n            ...\n            \n        # define and register a dump function\n        def my_dump_func(*arg, **kwargs) # the args should meet the Dumper demand", "        # define and register a dump function\n        def my_dump_func(*arg, **kwargs) # the args should meet the Dumper demand\n            ...\n        ---------------------------------- END ---------------------------------------\n\"\"\"\n\n\n# Define custom Exceptions\nclass IOEarlyStop(BaseException):\n    \"\"\" monitor the situation that the IO should early stop and return None and the IO result \"\"\"", "class IOEarlyStop(BaseException):\n    \"\"\" monitor the situation that the IO should early stop and return None and the IO result \"\"\"\n\n\n# Define the IO function types\nIOFuncPrefix = Literal['pre', 'io', 'post']\nIOStream = Union[IOBase, str, bytes]\n\n\ndef _parse_lmp_data_script(script: str):\n    \"\"\" Parse the LAMMPS data script to two dict, header and body\"\"\"\n    # Define_body_title\n    bt_name = (\n        # atom-property sections\n        'Atoms', 'Velocities', 'Masses', 'Ellipsoids', 'Lines', 'Triangles', 'Bodies',\n        # molecular topology sections\n        'Bonds', 'Angles', 'Dihedrals', 'Impropers',\n        # force field sections\n        'Pair Coeffs', 'PairIJ Coeffs', 'Bond Coeffs', 'Angle Coeffs', 'Dihedral Coeffs', 'Improper Coeffs',\n        # class 2 force field sections\n        'BondBond Coeffs', 'BondAngle Coeffs', 'MiddleBondTorsion Coeffs', 'EndBondTorsion Coeffs',\n        'AngleTorsion Coeffs', 'AngleAngleTorsion Coeffs', 'BondBond13 Coeffs', 'AngleAngle Coeffs'\n    )\n\n    # Compile the body and header pattern\n    header_title = re.compile(r'[a-z]+')\n    header_int = re.compile(r'[0-9]+')\n    header_float = re.compile(r'-?[0-9]+\\.[0-9]*')\n\n    lines = script.split('\\n')\n    body_split_point = [i for i, lin in enumerate(lines) if lin in bt_name] + [len(lines)]\n\n    # Extract header info\n    headers = {}\n    for line in lines[1:body_split_point[0]]:\n        line = line.strip()\n        if line:\n            ht = ' '.join(header_title.findall(line))\n            hvs = line[:line.find(ht)].strip()  # header values\n            header_values = []\n            for hv in re.split(r'\\s+', hvs):\n                if header_int.fullmatch(hv):\n                    header_values.append(int(hv))\n                elif header_float.fullmatch(hv):\n                    header_values.append(float(hv))\n                else:\n                    raise ValueError('the header line not match well')\n\n            headers[ht] = header_values\n\n    # Extract bodies info\n    bodies = {}\n    for sl_idx, el_idx in zip(body_split_point[:-1], body_split_point[1:]):\n        bt = lines[sl_idx].strip()  # body title\n        bc = [line.strip() for line in lines[sl_idx+1: el_idx] if line.strip()]  # body content\n        bodies[bt] = bc\n\n    return lines[0], headers, bodies", "\ndef _parse_lmp_data_script(script: str):\n    \"\"\" Parse the LAMMPS data script to two dict, header and body\"\"\"\n    # Define_body_title\n    bt_name = (\n        # atom-property sections\n        'Atoms', 'Velocities', 'Masses', 'Ellipsoids', 'Lines', 'Triangles', 'Bodies',\n        # molecular topology sections\n        'Bonds', 'Angles', 'Dihedrals', 'Impropers',\n        # force field sections\n        'Pair Coeffs', 'PairIJ Coeffs', 'Bond Coeffs', 'Angle Coeffs', 'Dihedral Coeffs', 'Improper Coeffs',\n        # class 2 force field sections\n        'BondBond Coeffs', 'BondAngle Coeffs', 'MiddleBondTorsion Coeffs', 'EndBondTorsion Coeffs',\n        'AngleTorsion Coeffs', 'AngleAngleTorsion Coeffs', 'BondBond13 Coeffs', 'AngleAngle Coeffs'\n    )\n\n    # Compile the body and header pattern\n    header_title = re.compile(r'[a-z]+')\n    header_int = re.compile(r'[0-9]+')\n    header_float = re.compile(r'-?[0-9]+\\.[0-9]*')\n\n    lines = script.split('\\n')\n    body_split_point = [i for i, lin in enumerate(lines) if lin in bt_name] + [len(lines)]\n\n    # Extract header info\n    headers = {}\n    for line in lines[1:body_split_point[0]]:\n        line = line.strip()\n        if line:\n            ht = ' '.join(header_title.findall(line))\n            hvs = line[:line.find(ht)].strip()  # header values\n            header_values = []\n            for hv in re.split(r'\\s+', hvs):\n                if header_int.fullmatch(hv):\n                    header_values.append(int(hv))\n                elif header_float.fullmatch(hv):\n                    header_values.append(float(hv))\n                else:\n                    raise ValueError('the header line not match well')\n\n            headers[ht] = header_values\n\n    # Extract bodies info\n    bodies = {}\n    for sl_idx, el_idx in zip(body_split_point[:-1], body_split_point[1:]):\n        bt = lines[sl_idx].strip()  # body title\n        bc = [line.strip() for line in lines[sl_idx+1: el_idx] if line.strip()]  # body content\n        bodies[bt] = bc\n\n    return lines[0], headers, bodies", "\n\nclass Register:\n    \"\"\"\n    Register the IO function for Dumper, Parser or so on\n    \"\"\"\n    def __init__(self):\n        # these dicts are container to store the custom io functions\n        # the keys of the dict are serve as the handle to get the mapped io functions(the values)\n        self.pre_methods = {}\n        self.io_methods = {}\n        self.post_methods = {}\n\n    def __repr__(self):\n        return f\"Register:\\n\" + \\\n               f\"pre_method:\\n\" + \\\n               f\"\\n\\t\".join([n for n in self.pre_methods]) + \"\\n\\n\" + \\\n               f\"io methods:\\n\" + \\\n               f\"\\n\\t\".join([n for n in self.io_methods]) + '\\n\\n' + \\\n               f\"post methods:\\n\" + \\\n               f\"\\n\\t\".join([n for n in self.post_methods])\n\n    def __call__(self, io_cls: type, fmt: str, prefix: IOFuncPrefix):\n        \"\"\"\n        To register any function as a dumper or a postprocess to convert mol to formats\n        Args:\n            fmt:\n            prefix:\n\n        Returns:\n\n        \"\"\"\n\n        def decorator(func: Callable):\n\n            if prefix == 'pre':\n                self.pre_methods[fmt] = func\n            elif prefix == 'io':\n                self.io_methods[fmt] = func\n            elif prefix == 'post':\n                self.post_methods[fmt] = func\n            else:\n                raise TypeError('the type of register is not supported')\n\n            return func\n\n        return decorator\n\n    def pre(self, fmt: str):\n        return self.pre_methods.get(fmt)\n\n    def io(self, fmt: str):\n        return self.io_methods.get(fmt)\n\n    def post(self, fmt: str):\n        return self.post_methods.get(fmt)", "\n\n# Retrieve the IO class by its format name\ndef retrieve_format(fmt: str = None):\n    return _MoleculeIO.registered_format().get(fmt)\n\n\n# Get all registered format name\ndef registered_format_name():\n    return tuple(_MoleculeIO.registered_format().keys())", "def registered_format_name():\n    return tuple(_MoleculeIO.registered_format().keys())\n\n\n# TODO: deprecated in the later version\nclass _MoleculeIO(ABCMeta):\n    \"\"\"    Metaclass for registration of IO class format \"\"\"\n    _registered_format = {}\n\n    def __new__(mcs, name, bases, namespace, **kwargs):\n        # Get the format keywords\n        fmt = namespace.get('format')(mcs)\n\n        if not fmt:\n            return super(_MoleculeIO, mcs).__new__(mcs, name, bases, namespace, **kwargs)\n        elif not isinstance(fmt, str):\n            raise TypeError('the defined format should be a string')\n        elif fmt in mcs._registered_format:\n            raise ValueError(f'the format {fmt} have been defined before')\n        else:\n            cls = super(_MoleculeIO, mcs).__new__(mcs, name, bases, namespace, **kwargs)\n            mcs._registered_format[fmt] = cls\n            return cls\n\n    @classmethod\n    def registered_format(mcs):\n        return copy(mcs._registered_format)", "\n\nclass MetaIO(type):\n    \"\"\"\n    The Meta class to specify how to construct the IO class\n    This Meta class is defined to register IO function conveniently.\n\n    The IO functions are divided into three categories:\n        - preprocess: do something before performing any of IO operation, with prefix '_pre'\n        - io: performing the IO operation, with prefix '_io'\n        - postprocess: do something after preforming IO operation, with prefix '_post'\n\n    This Meta class offer two approach to defined and register the IO functions:\n        - Define inside the IO class (IOClass)\n        - Define outside the IO class and decorate the defined function by IOClass.register function\n\n    To define inside the IOClass, one should name the IO function with the pattern:\n        def _prefix_keys():\n            ...\n    where, the prefix is one of 'pre', 'io' or 'post'; the keys is the handle name to retrieve the\n    IO functions.\n\n    To define outside the IOClass, one should applied the class method register as the decorator of the\n    IO functions, specified the prefix and the handle name as the decorator arguments, like:\n        @IOClass.register(fmt='keys', types='prefix')\n        def outside_io_func(*args, **kwargs):\n            ...\n    where the IOClass is one of Reader, Writer, Dumper, Parser or other custom IOClass, the 'key' and 'prefix'\n    should be replace to the handle name and prefix you specified.\n    \"\"\"\n\n    def __new__(mcs, name: str, bases: tuple, namespace: dict, **kwargs):\n        \"\"\" If the subclasses contain methods with the prefix of '_pre', '_io' or '_post'\n        they are seen as the IO function, that the preprocess, io or postprocess functions, respectively\n        \"\"\"\n        _register = Register()\n\n        for attr_name, attr in namespace.items():\n\n            # Make sure the io function is a Callable obj\n            if not isinstance(attr, Callable):\n                continue\n\n            split_names = attr_name.split('_')\n\n            # the custom IO function should with prefix: '_pre', '_io' and '_post'\n            # the handle keys of these function are follow the above prefix and separate be '_'\n            # for example:\n            #     def _pre_gjf(*args, **kwargs):\n            #         ...\n            # this is a preprocess IO function with a handle key: 'gjf' to retrieve the function.\n            if len(split_names) <= 2:\n                continue\n\n            io_type = split_names[1]\n\n            # Register the io functions:\n            # if a define methods with the prefix '_pre', '_io' or '_post'\n            # these methods are seen as preprocess, io or postprocess functions, respectively\n            if io_type == 'pre':\n                _register.pre_methods['_'.join(split_names[2:])] = attr\n            if io_type == 'io':\n                _register.io_methods['_'.join(split_names[2:])] = attr\n            if io_type == 'post':\n                _register.post_methods['_'.join(split_names[2:])] = attr\n\n        namespace[f'_register'] = _register\n\n        return type(name, bases, namespace, **kwargs)", "\n\nclass IOBase:\n    \"\"\" The base IO class \"\"\"\n    # Initialize the register function, which is a callable obj embed in IO classes\n    # When to register new IO function, apply the register function as decorator\n\n    # _register = None\n\n    def __init__(self, fmt: str, source: Union['ci.Molecule', IOStream], *args, **kwargs):\n        \"\"\"\"\"\"\n        self.fmt = fmt\n        self.src = source\n\n        self.args = args\n        self.kwargs = kwargs\n\n        # override this methods to check the\n        self.result = self._checks()\n\n    def __call__(self):\n        \"\"\" Call for the performing of IO \"\"\"\n        try:\n            self._pre()\n            # For dumper, the obj is Literal str or bytes obj\n            # For parser, the obj is Molecule obj\n            io_func = self._get_io()\n            if io_func:  # If a custom io function have been defined, run custom functions\n                obj = io_func(self)\n            else:  # else get the general io function define in class\n                obj = self._io()\n\n            return self._post(obj)\n\n        except IOEarlyStop:\n            return None\n\n    @abstractmethod\n    def _checks(self) -> Dict[str, Any]:\n        \"\"\"\n        This method should be overriden when definition of new IO class\n        The purpose of this class is to check the regulation of initialized arguments.\n        If not any arguments should be checked, return None directly.\n        \"\"\"\n        raise NotImplemented()\n\n    def _get_pre(self) -> Callable:\n        return self.register.pre(self.fmt)\n\n    def _get_io(self) -> Callable:\n        return self.register.io(self.fmt)\n\n    def _get_post(self) -> Callable:\n        return self.register.post(self.fmt)\n\n    def _pre(self, *args, **kwargs):\n        \"\"\" Regulate the method of preprocess \"\"\"\n        pre_func = self._get_pre()\n        if pre_func:\n            pre_func(self)\n\n    @abstractmethod\n    def _io(self, *args, **kwargs):\n        \"\"\" Regulate the main io method \"\"\"\n        raise NotImplemented\n\n    def _post(self, obj, *args, **kwargs):\n        \"\"\" Regulate the method of postprocess \"\"\"\n        post_func = self._get_post()\n        if post_func:\n            return post_func(self, obj)\n        else:\n            return obj\n\n    @property\n    def register(self) -> Register:\n        return getattr(self, f'_register')", "\n\nclass Dumper(IOBase, metaclass=MetaIO):\n    \"\"\"\n    Dump the Molecule information into specific format.\n    The output in general is the string or bytes\n    \"\"\"\n\n    _pybel_fmt_convert = {\n    }\n\n    def _preprocess_for_gjf(self):\n        \"\"\" Perform preprocess for  conversion of all gaussian input \"\"\"\n        if not self.src.has_3d:\n            self.src.build_3d()\n\n        self.src.assign_atoms_formal_charge()\n        self.src.identifier = self.src.formula\n\n    def _postprocess_for_gjf_head(self, script) -> (List[str], int):\n        \"\"\" Postprocess the context before the Molecular specification partition \"\"\"\n        # To count the insert lines\n        inserted_lines = 0\n\n        # separate keyword arguments:\n        link0 = self.kwargs['link0']\n        route = self.kwargs['route']\n        custom_charge = self.kwargs.get('charge')\n        custom_spin = self.kwargs.get('spin')\n\n        lines = script.splitlines()\n\n        # Write link0 command\n        if isinstance(link0, str):\n            lines[0] = f'%{link0}'\n        elif isinstance(link0, list):\n            for i, stc in enumerate(link0):  # stc=sentence\n                assert isinstance(stc, str)\n                if not i:  # For the first line of link0, replace the original line in raw script\n                    lines[0] = f'%{stc}'\n                else:  # For the other lines, insert into after the 1st line\n                    inserted_lines += 1\n                    lines.insert(inserted_lines, f'%{stc}')\n        else:\n            raise TypeError('the link0 should be string or list of string')\n\n        # Write route command\n        if isinstance(route, str):\n            lines[1+inserted_lines] = f'# {route}'\n        elif isinstance(route, list):\n            for i, stc in enumerate(route):\n                assert isinstance(stc, str)\n                if not i:  # For the first line of link0, replace the original line in raw script\n                    lines[1+inserted_lines] = f'#{stc}'\n                else:  # For the other lines, insert into after the original route line.\n                    inserted_lines += 1\n                    lines.insert(inserted_lines+1, f'%{stc}')\n        else:\n            raise TypeError('the route should be string or list of string')\n\n        charge, spin = lines[5+inserted_lines].split()\n        if custom_charge:\n            charge = str(custom_charge)\n        if custom_spin:\n            spin = str(custom_spin)\n\n        lines[5+inserted_lines] = f'{charge} {spin}'\n\n        return lines, 6 + inserted_lines\n\n    def _process_lmpdat_bonds(self, bond_contents: list):\n        \"\"\"\"\"\"\n        uni_bonds = tuple(self.src.unique_bonds)\n        bonds = self.src.bonds\n        sep = re.compile(r'\\s+')\n        for i, bc in enumerate(bond_contents):\n            split_bc = sep.split(bc)\n            split_bc[1] = str(uni_bonds.index(bonds[i]) + 1)\n            bond_contents[i] = '  '.join(split_bc)\n\n        return bond_contents\n\n    def _io(self):\n        \"\"\" Performing the IO operation, convert the Molecule obj to Literal obj \"\"\"\n        # Try to dump by openbabel.pybel\n        type_err_pattern = re.compile(\n            r\"write\\(\\) got an unexpected keyword argument '\\w+'\"\n        )\n        pb_mol = pybel.Molecule(self.src.ob_mol)\n        kwargs = copy(self.kwargs)\n\n        while kwargs:\n            try:\n                return pb_mol.write(self._pybel_fmt_convert.get(self.fmt, self.fmt), **kwargs)\n\n            except TypeError as error:\n                if type_err_pattern.match(str(error)):\n                    pop_kwargs = str(error).split()[-1].strip(\"'\")\n                    kwargs.pop(pop_kwargs)\n                else:\n                    raise error\n\n            except ValueError:\n                print(IOError(f'the cheminfo.Molecule obj cannot dump to Literal'))\n                return None\n\n        return pb_mol.write(self._pybel_fmt_convert.get(self.fmt, self.fmt))\n\n    def _checks(self) -> Dict[str, Any]:\n        if not isinstance(self.src, ci.Molecule):\n            raise TypeError(f'the dumped object should be hotpot.cheminfo.Molecule, instead of {type(self.src)}')\n\n        return {}\n\n    def _pre_cif(self):\n        \"\"\"\n        pre-process for Molecule object to convert to cif file.\n        if the hotpot object do not place in a Crystal, create a P1 compact Crystal for it\n        \"\"\"\n        crystal = self.src.crystal()\n        if not isinstance(crystal, ci.Crystal) or (\n                np.logical_not(crystal.vector >= 0.).any() and np.logical_not(crystal.vector < 0.).any()\n        ):\n            self.src.compact_crystal(inplace=True)\n\n        if self.src.crystal().space_group:\n            self.src.crystal().space_group = 'P1'\n\n    def _pre_gjf(self):\n        \"\"\" Assign the Molecule charge before to dump to gjf file \"\"\"\n        self._preprocess_for_gjf()\n\n    def _pre_gzmat(self):\n        self._preprocess_for_gjf()\n\n    def _io_dpmd_sys(self):\n        \"\"\" convert molecule information to numpy arrays \"\"\"\n        return DeepSystem(self.src)\n\n    def _io_lmpmol(self):\n        \"\"\"\n        write a molecule script\n        default values: coordinates, velocities, atom IDs and types\n        additional attributes for atomic: Bonds\n        additional attributes for full: Bonds + molecular + charge\n        \"\"\"\n\n        def bonds(m):\n            \"\"\" Add bond body \"\"\"\n            bond_str = 'Bonds' + '\\n\\n'  # bond body title\n\n            # the formula of bond_type key: atom1[bond_type]atom2\n            uni_bonds = tuple(m.unique_bonds)  # store bonds type\n            for j, bond in enumerate(m.bonds, 1):\n\n                bt_id = uni_bonds.index(bond) + 1\n                bond_str += f'{j} {bt_id} {bond.ob_atom1_id + 1} {bond.ob_atom2_id + 1}\\n'\n\n            bond_str += '\\n'\n\n            return bond_str\n\n        def charge():\n            \"\"\" Retrieve atom charge information \"\"\"\n            charge_str = '\\n' + 'Charges' + '\\n\\n'\n\n            for ic, a in enumerate(atoms_list, 1):  # ID of charge, atom\n                if isinstance(a, ci.Atom):\n                    charge_str += f'{ic} {a.partial_charge}\\n'\n                else:\n                    assert isinstance(a, ci.PseudoAtom)\n                    charge_str += f'{ic} {a.charge}\\n'\n\n            charge_str += '\\n'\n\n            return charge_str\n\n        mol = self.src\n        kwargs = self.kwargs  # keywords arguments\n\n        # default values: coordinates, velocities, atom IDs and types;\n        # additional attributes for atomic: None;\n        # additional attributes for full: molecular + charge\n        atom_style = kwargs.get('atom_style', 'atomic')   # default atom_style is atomic\n        mol_name = kwargs.get('mol_name', mol.smiles)\n\n        # combine real atoms with pseudo atoms in a list\n        atoms_list = []\n        for m_a in mol.atoms:\n            atoms_list.append(m_a)\n\n        if mol.pseudo_atoms:   # determine if there are pseudo_atoms\n            for pse_a in mol.pseudo_atoms:\n                atoms_list.append(pse_a)\n\n        # title information\n        title = f\"Create by hotpot package, convert from {mol_name}\"\n        script = title + '\\n\\n'   # write the molecular script for lammps\n\n        # TODO: some header information missing\n        # Header partition\n        # add atom header\n        num_atoms = len(atoms_list)\n        num_atoms_str = f'{num_atoms}  atoms'\n        script += num_atoms_str + '\\n'\n\n        # add bond header\n        num_bonds = len(mol.bonds)\n        num_bonds_str = f'{num_bonds}  bonds'\n        script += num_bonds_str + '\\n'\n\n        # Add new blank line to end the header partition\n        script += '\\n'\n\n        # Body partition\n        # Coords body\n        script += 'Coords' + '\\n\\n'\n        for i, atom in enumerate(atoms_list, 1):\n            script += f'{i}' + '  ' + '  '.join(map(str, atom.coordinates)) + '\\n'\n        script += '\\n'\n\n        # Types body\n        script += 'Types' + '\\n\\n'\n\n        dict_types = {}\n        for i, atom in enumerate(atoms_list, 1):\n            atom_type = dict_types.setdefault(atom.symbol, len(dict_types)+1)\n            script += f'{i} {atom_type}  # {atom.symbol}\\n'\n\n        script += '\\n'\n\n        # additional attributes\n        # to atomic style, only basis information (ID\uff0cCoords, types, velocitier)\n        if atom_style == 'atomic':\n            if num_bonds:\n                script += bonds(mol)\n\n        # to full style, basis information + molecular + charge\n        elif atom_style == 'full':\n            if num_bonds:\n                script += bonds(mol)\n            script += charge()\n\n        return script\n\n    def _post_gjf(self, script):\n        \"\"\" postprocess the dumped Gaussian 16 .gjf script to add the link0 and route context \"\"\"\n        lines, _ = self._postprocess_for_gjf_head(script)\n        script = '\\n'.join(lines)\n\n        # End black line\n        script += '\\n\\n'\n\n        return script\n\n    def _post_gzmat(self, script):\n        \"\"\" postprocess the dumped Gaussian 16 .gjf script to add the link0 and route content with Z-matrix \"\"\"\n        lines, current_line = self._postprocess_for_gjf_head(script)\n        zmat = re.compile('\\s+')\n\n        # Extract the symbol of atoms, bonds, angles and torsions\n        z_counts, atoms, var = 0, self.src.atoms, {}\n        while lines[current_line + z_counts].strip() != 'Variables:':\n            items = zmat.split(lines[current_line + z_counts])\n\n            assert items[0] == atoms[z_counts].symbol\n\n            if len(items) == 1:\n                assert not z_counts\n            elif len(items) == 3:\n                assert z_counts == 1\n                var[items[2]] = self.src.bond(z_counts, int(items[1])-1)\n            elif len(items) == 5:\n                assert z_counts == 2\n                var[items[2]] = self.src.bond(z_counts, int(items[1])-1)\n                var[items[4]] = self.src.angle(z_counts, int(items[1])-1, int(items[3])-1)\n            elif len(items) == 7:\n                var[items[2]] = self.src.bond(z_counts, int(items[1])-1)\n                var[items[4]] = self.src.angle(z_counts, int(items[1])-1, int(items[3])-1)\n                var[items[6]] = self.src.torsion(z_counts, int(items[1])-1, int(items[3])-1, int(items[5])-1)\n            else:\n                raise ValueError('Get an error string from Z-matrix')\n\n            z_counts += 1  # Next line\n\n        current_line += z_counts + 1  # update the current line\n        while lines[current_line].strip():\n            key, _ = lines[current_line].split('= ')\n            lines[current_line] += f\" {var[key]['scan_step']}\" if var[key][\"scan_step\"] else ''\n\n            current_line += 1\n\n        script = '\\n'.join(lines)\n        # End black line\n        script += '\\n\\n'\n\n        return script\n\n    def _post_lmpdat(self, script: str):\n        \"\"\" post-process for LAMMPS data file \"\"\"\n\n        title, headers, bodies = _parse_lmp_data_script(script)\n        script = title + '\\n'\n\n        for ht, hvs in headers.items():\n            if ht == 'bond types':  # header title, header values\n                hvs[0] = len(self.src.unique_bonds)\n\n            script += ' '.join(map(str, hvs)) + ' ' + ht + '\\n'\n\n        script += '\\n' * 3\n\n        for bt, bcs in bodies.items():  # body title, body contents\n            if bt == 'Bonds':\n                bcs = self._process_lmpdat_bonds(bcs)\n\n            if bcs:  # if the body contents exist\n                script += bt + '\\n' * 2\n                script += '\\n'.join(bcs)\n                script += '\\n' * 3\n\n        return script", "\n\nclass Parser(IOBase, metaclass=MetaIO):\n    \"\"\" Parse the str or bytes obj to Molecule obj \"\"\"\n    _pybel_fmt_convert = {\n        'g16log': 'g16'\n    }\n\n    def _open_source_to_string_lines(self, *which_allowed: str, output_type: Literal['lines', 'script'] = 'lines'):\n        \"\"\"\n        Open the source file to string lines\n        Args:\n            which_allowed: which types of source are allowed to process to string lines\n\n        Returns:\n            (List of string|string)\n        \"\"\"\n        src_type = self.result.get('src_type')\n        if src_type not in which_allowed:\n            raise RuntimeError(f'the source type {type(self.src)} have not been supported')\n        else:\n            if src_type == 'str':\n                script = self.src\n\n            elif src_type == 'path':\n                with open(self.src) as file:\n                    try:\n                        script = file.read()\n                    # If the file pointed by the path is not a text file\n                    # such as a bytes file\n                    except UnicodeDecodeError:\n                        raise IOEarlyStop()\n\n            elif src_type == 'IOString':\n                script = self.src.read()\n\n            else:\n                raise RuntimeError(f'the source type {type(self.src)} have not been supported')\n\n            if output_type == 'lines':\n                return script.split('\\n')\n            elif output_type == 'script':\n                return script\n            else:\n                raise ValueError('the arg output_type given a wrong values, lines or script allow only')\n\n    def _checks(self) -> Dict[str, Any]:\n        if not isinstance(self.src, (IOBase, str, bytes, PathLike)):\n            raise TypeError(f'the parsed object should be IOBase, str or bytes, instead of {type(self.src)}')\n\n        if isinstance(self.src, str):\n            if os.path.exists(self.src):\n                return {'src_type': 'path'}\n            else:\n                return {'src_type': 'str'}\n\n        if isinstance(self.src, PathLike):\n            return {'src_type': 'path'}\n\n        if isinstance(self.src, bytes):\n            return {'src_type': 'bytes'}\n        if isinstance(self.src, io.StringIO):\n            return {'src_type': 'StringIO'}\n        if isinstance(self.src, io.BytesIO):\n            return {'src_type': 'BytesIO'}\n        if isinstance(self.src, io.FileIO):\n            return {'src_type': 'FileIO'}\n        print(f'the get source type is {type(self.src)}')\n        return {'src_type': type(self.src)}\n\n    def _ob_io(self):\n        \"\"\" IO by openbabel.pybel \"\"\"\n        # Get the source type name\n        src_type = self.result.get('src_type')\n        try:\n            if src_type == 'str':\n                pybel_mol = pybel.readstring(self._pybel_fmt_convert.get(self.fmt, self.fmt), self.src)\n            elif src_type == 'path':\n                pybel_mol = next(pybel.readfile(self._pybel_fmt_convert.get(self.fmt, self.fmt), str(self.src)))\n            elif src_type == 'IOString':\n                pybel_mol = pybel.readstring(self._pybel_fmt_convert.get(self.fmt, self.fmt), self.src.read())\n            else:\n                raise RuntimeError(f'the source type {type(self.src)} have not been supported')\n\n            obj = ci.Molecule(pybel_mol.OBMol)\n\n        except RuntimeError:\n            obj = None\n\n        return obj\n\n    def _cclib_io(self, obj):\n        \"\"\" IO by cclib package \"\"\"\n        src_type = self.result.get('src_type')\n\n        try:\n            if src_type == 'str':\n                data = cclib.ccopen(io.StringIO(self.src)).parse()\n            elif src_type == 'path':\n                data = cclib.ccopen(self.src).parse()\n            elif src_type == 'IOString':\n                data = cclib.ccopen(self.src).parse()\n            else:\n                raise RuntimeError(f'the source type {type(self.src)} have not been supported in cclib')\n\n        except (RuntimeError, AttributeError):\n            data = None\n\n        if data:\n            if not obj:\n                # when get information about the atoms species\n                if hasattr(data, 'atomnos'):\n                    atoms_attrs = [{'atomic_number': an} for an in getattr(data, 'atomnos')]\n                    obj = ci.Molecule(atoms=atoms_attrs)\n                else:\n                    print(IOError(f'the parsing of {self.src} is not successful!'))\n                    return obj  # Return None\n\n            # if get information about the coordination collections\n            if hasattr(data, 'atomcoords'):\n                obj.set(all_coordinates=getattr(data, 'atomcoords'))\n\n            # if get information about the energy (SCF energies) vector\n            if hasattr(data, 'scfenergies'):\n                obj.set(all_energy=getattr(data, 'scfenergies'))\n\n        return obj\n\n    def _io(self, *args, **kwargs):\n        \"\"\" Standard IO process \"\"\"\n        # Try parse the log file by openbabel.pybel file firstly\n        return self._ob_io()\n\n    # Start to the prefix IO functions\n\n    # preprocess for g16log file\n    # This preprocess is used to judge whether a Error happened when perform g16 calculate\n    def _pre_g16log(self):\n        \"\"\" g16log preprocess to judge whether some Error happened \"\"\"\n        def is_convergence_failure():\n            if 'Convergence failure -- run terminated.' in script:\n                return True\n            return False\n\n        def is_hessian_no_longer_linear_valid():\n            march_pattern = re.compile(r'Error termination via Lnk1e in (/.+)*/l103\\.exe')\n\n            if any(march_pattern.match(line.strip()) for line in script.splitlines()[-5:]):\n                return True\n            return False\n\n        script = self._open_source_to_string_lines('str', 'path', \"IOString\", output_type='script')\n\n        try:\n            # Check whether a failure have happened when calculation.\n            if is_convergence_failure():\n                raise IOEarlyStop('Gaussian16 SCF cannot convergence!')\n            if is_hessian_no_longer_linear_valid():\n                raise IOEarlyStop('Gaussian16 Hessian no longer linear valid')\n\n        except IOEarlyStop as error:\n            if self.kwargs.get('force'):\n                print(error)\n            else:\n                raise error\n\n    # Parse the XYZ file\n    def _io_xyz(self):\n        \"\"\" Parse the XYZ file \"\"\"\n        src_type = self.result['src_type']\n        if src_type != 'path':\n            return self._io()\n        else:\n            from ase import io\n            from openbabel import openbabel as ob\n            data_generator = io.iread(self.src)\n\n            # atomic_numbers, coordinates, cell_params\n            atomic_numbers, all_coordinates, cell_matrix = [], [], None\n            for data in data_generator:\n                atomic_numbers.append(data.numbers)\n                all_coordinates.append(data.positions)\n                if cell_matrix is None:\n                    cell_matrix = data.cell.array\n\n            atomic_numbers = np.stack(atomic_numbers)\n            all_coordinates = np.stack(all_coordinates)\n\n            number_min = atomic_numbers.min(axis=0)\n            number_max = atomic_numbers.max(axis=0)\n\n            # the values in same columns should be same.\n            assert all(number_max == number_min)\n\n            obj = ci.Molecule()\n            obj.quick_build_atoms(number_min)\n\n            obj.set(all_coordinates=all_coordinates)\n            obj.set(crystal=cell_matrix)\n            obj.conformer_select(0)\n\n            return obj\n\n    # postprocess for g16log file\n    def _post_g16log(self, obj: 'ci.Molecule'):\n        \"\"\"\n        post process for g16log format, to extract:\n            1) Mulliken charge\n            2) Spin densities\n        \"\"\"\n        def extract_charges_spin():\n            \"\"\" Extract charges and spin information from g16.log file \"\"\"\n            # Get the line index of Mulliken charges\n            head_lines = [i for i, line in enumerate(lines) if line.strip() == 'Mulliken charges and spin densities:']\n            if not head_lines:\n                head_lines = [i for i, line in enumerate(lines) if line.strip() == 'Mulliken charges:']\n                charge_only = True\n            else:\n                charge_only = False\n\n            # Skip the first charge&spin sheet, it can't find corresponding coordinates\n            if not head_lines:\n                raise IOEarlyStop\n            elif len(head_lines) == obj.conformer_counts + 1:\n                head_lines = head_lines[1:]\n\n            # Extract the Mulliken charge and spin densities\n            charges, spin_densities = [], []  # changes(cgs) spin_densities(sds)\n            for i in head_lines:\n                # Enhance inspection\n                col_heads = lines[i + 1].strip().split()\n                if charge_only:\n                    assert len(col_heads) == 1 and col_heads[0] == '1'\n                else:\n                    assert len(col_heads) == 2 and col_heads[0] == '1' and col_heads\n\n                HEAD_LINES_NUM = 2\n                cg, sd = [], []  # change, spin_density\n\n                while True:\n                    split_line = lines[i + HEAD_LINES_NUM].strip().split()\n                    if charge_only and len(split_line) == 3:\n                        row, syb, c = split_line  # row number, symbol, charges\n                        s = 0.0  # spin density\n                    elif not charge_only and len(split_line) == 4:\n                        row, syb, c, s = split_line  # row number, symbol, charges, spin density\n                    else:\n                        break\n\n                    try:\n                        row, c, s = int(row), float(c), float(s)\n                        # check the sheet row number\n                        if row != HEAD_LINES_NUM - 1:\n                            break\n\n                    # Inspect the types of values\n                    except ValueError:\n                        break\n\n                    # record the charge and spin density\n                    cg.append(c)\n                    sd.append(s)\n                    HEAD_LINES_NUM += 1\n\n                # store the extracted\n                if cg and sd:\n                    if len(cg) == len(sd) == len(obj.atoms):\n                        charges.append(cg)\n                        spin_densities.append(sd)\n                    else:\n                        raise ValueError('the number of charges do not match to the number of atoms')\n                else:\n                    raise ValueError('get a empty charge and spin list, check the input!!')\n\n            obj.set(all_atom_charges=np.array(charges))\n            obj.set(all_atom_spin_densities=np.array(spin_densities))\n                \n        def extract_force_matrix():\n            # Define the format of force sheet\n            # the Force sheet like this:\n            #  -------------------------------------------------------------------\n            #  Center     Atomic                   Forces (Hartrees/Bohr)\n            #  Number     Number              X              Y              Z\n            #  -------------------------------------------------------------------\n            #       1        8           0.039901671    0.000402574    0.014942530\n            #       2        8           0.017381613    0.001609531    0.006381231\n            #       3        6          -0.092853735   -0.025654844   -0.005885898\n            #       4        6           0.067801154    0.024130172   -0.022794721\n            #       5        8          -0.023702905    0.005486251   -0.004938175\n            #       6        8          -0.006359715   -0.008543465    0.010350815\n            #       7       55          -0.002168084    0.002569781    0.001944217\n            #  -------------------------------------------------------------------\n            force_head1 = re.compile(r'\\s*Center\\s+Atomic\\s+Forces\\s\\(Hartrees/Bohr\\)\\s*')\n            force_head2 = re.compile(r'\\s*Number\\s+Number\\s+X\\s+Y\\s+Z\\s*')\n            sheet_line = re.compile(r'\\s*----+\\s*')\n\n            HEAD_LINES_NUM = 3  # the offset line to write the header\n\n            head_lines = [i for i, line in enumerate(lines) if force_head1.match(line)]\n\n            all_forces = []\n            for i in head_lines:\n                # enhance the inspection of Force sheet head\n                assert force_head2.match(lines[i + 1])\n                assert sheet_line.match(lines[i + 2])\n\n                rows = 0\n                forces = []\n                while True:\n\n                    if sheet_line.match(lines[i + HEAD_LINES_NUM + rows]):\n                        if len(forces) == obj.atom_counts:\n                            all_forces.append(forces)\n                            break\n                        else:\n                            raise ValueError('the number of force vector do not match the number of atoms')\n\n                    ac, an, x, y, z = map(\n                        lambda v: int(v[1]) if v[0] < 2 else float(v[1]),\n                        enumerate(lines[i + HEAD_LINES_NUM + rows].split())\n                    )\n\n                    # Enhance the inspection\n                    assert ac == rows + 1\n                    if obj.atoms[rows].atomic_number != an:\n                        raise ValueError('the atomic number do not match')\n\n                    forces.append([x, y, z])\n\n                    rows += 1\n\n            try:\n                obj.set(all_forces=np.array(all_forces))\n            except ValueError:\n                return\n\n        obj = self._cclib_io(obj)  # Try to supplementary Molecule data by cclib\n\n        lines = self._open_source_to_string_lines('str', 'path', 'IOString')\n\n        try:  # TODO: For now, this is the case, the spin densities may lost in some case  # the units is Hartree/Bohr\n            extract_charges_spin()\n        except IOEarlyStop:\n            if self.kwargs.get('must_have_charge'):\n                raise IOEarlyStop\n\n        try:\n            extract_force_matrix()\n        except IndexError:\n            raise IOEarlyStop\n\n        # assign the first conformer for the molecule\n        obj.conformer_select(0)\n\n        return obj", "\n\n"]}
{"filename": "hotpot/bundle.py", "chunked_list": ["\"\"\"\npython v3.7.9\n@Project: hotpot\n@File   : bundle.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/3/22\n@Time   : 3:18\n\"\"\"\nimport copy\nimport os", "import copy\nimport os\nimport random\nimport time\nfrom os import PathLike\nfrom typing import *\nfrom pathlib import Path\nimport numpy as np\nfrom tqdm import tqdm\nfrom openbabel import pybel as pb", "from tqdm import tqdm\nfrom openbabel import pybel as pb\nimport hotpot.cheminfo as ci\nfrom hotpot.tools import check_path\nimport multiprocessing as mp\n\nfeature_formats = {\n    'basic': ['atomic_number', 's', 'p', 'f']\n}\n", "}\n\n# the dict to store all defined bundle classes\n_bundle_classes = {}\n\n\ndef register_bundles(bundle: Type):\n    \"\"\" register the bundle to _bundle_classes \"\"\"\n    _bundle_classes[bundle.__name__] = bundle\n    return bundle", "\n\n@register_bundles\nclass MolBundle:\n    \"\"\" The basic class for all molecular bundle \"\"\"\n\n    def __init__(self, mols: Union[Sequence[ci.Molecule], Generator[ci.Molecule, None, None]] = None):\n        self._data = {'mols': mols}\n\n    def __repr__(self):\n        class_name = self.__class__.__name__\n        return f\"{class_name}(generator)\" if isinstance(self.mols, Generator) else f\"{class_name}({self.mols})\"\n\n    def __iter__(self):\n        return iter(self.mols)\n\n    def __add__(self, other: Union['MolBundle', ci.Molecule]):\n        \"\"\"\"\"\"\n        if isinstance(other, MolBundle):\n            return MolBundle(self.to_list() + other.to_list())\n        elif isinstance(other, ci.Molecule):\n            return MolBundle(self.to_list() + [other])\n        else:\n            raise TypeError('the MolBundle is only allowed to add with Molecule or MolBundle object')\n\n    def __len__(self):\n        return len(self.mols)\n\n    def __getitem__(self, item: int):\n        return self.mols[item]\n\n    def __get_all_unique_attrs(self, attr_name: str):\n        \"\"\" Given a Molecule attr_name, get all unique values of the attributes among all Molecule in the MolBundle\"\"\"\n        if self.is_generator:\n            self.to_list()\n\n        dict_attrs = {}\n        for i, mol in enumerate(self):\n            list_indices = dict_attrs.setdefault(getattr(mol, attr_name), [])\n            list_indices.append(i)\n\n        if not dict_attrs:\n            return 0\n        if len(dict_attrs) == 1:\n            return getattr(self.mols[0], attr_name)\n        else:\n            return dict_attrs\n\n    @property\n    def atom_counts(self) -> Dict[int, List[int]]:\n        \"\"\"\n        Notes:\n            if the Bundle is a generator, convert to a list of Molecule first.\n        Returns:\n            returns a dict with the key is the number of the atoms and the key is the indices of Molecules\n        \"\"\"\n        return self.__get_all_unique_attrs('atom_counts')\n\n    @property\n    def atomic_numbers(self):\n        return self.__get_all_unique_attrs('atomic_numbers')\n\n    def choice(\n            self, size: int = 1, replace: bool = True,\n            p: Union[Sequence, float, Callable] = None,\n            get_remain: bool = False\n    ) -> Union['MolBundle', tuple['MolBundle', 'MolBundle']]:\n        \"\"\"\n         Generate new MolBundle with a list of random Molecule objects from the current MolBundle\n        Args:\n            size: the size of generating MolBundle, that the number of contained Molecule objects\n            replace: whether allow to choice a Molecule object multiply times. It must be noted that\n             if this MolBundle is a generator or the get_remain arg has been specified, this arg\n             would not work.\n            p: If the current MolBundle is a Generator it should be a float or a Callable object\n             which arg is the generated molecule. If the current MolBundle is a Sequence, the p\n             should bea sequence with same size as the number of Molecule objects in current\n             MolBundle, specify the probability of each Molecule to be chosen.\n            get_remain: whether to get the remain Molecule object, if the current MolBundle is a Generator\n             this arg would not work\n\n        Return:\n            MolBundle contained specified-number molecules\n        \"\"\"\n        def choice_from_generator():\n            \"\"\" Generator molecule according to specified probability \"\"\"\n            if isinstance(p, float):\n                for mol in self:\n                    if random.choices([0, 1], [1-p, p]):\n                        yield mol\n\n            if isinstance(p, Callable):\n                for mol in self:\n                    if p(mol):\n                        yield mol\n\n        # if the MolBundle is a generator, the derivative one is still generator\n        if self.is_generator:\n            if isinstance(p, (float, Callable)):\n                return MolBundle(choice_from_generator())\n            else:\n                raise TypeError('When the MolBundle is a generator, the p should be a float or Callable object')\n\n        elif get_remain:  # get remain molecules as the second return\n            mol_indices = np.arange(len(self))\n            chosen_idx = np.random.choice(mol_indices, size=int(len(self) * p))\n            remain_idx = np.setdiff1d(mol_indices, chosen_idx)\n\n            chosen_mol = np.array(self.mols)[chosen_idx].tolist()\n            remain_mol = np.array(self.mols)[remain_idx].tolist()\n\n            return self.__class__(chosen_mol), self.__class__(remain_mol)\n\n        else:\n            return self.__class__(np.random.choice(self.mols, size=size, replace=replace, p=p))\n\n    def collect_identical(self, inplace: bool = False) -> 'MolBundle':\n        \"\"\" Merge the molecules with same graph structures to one \"\"\"\n        dict_umol = {}\n        for mol in self.mols:\n            list_umol = dict_umol.setdefault(mol.atom_counts, [])\n\n            if not list_umol:\n                list_umol.append(mol)\n            if all(umol != mol for umol in list_umol):\n                list_umol.append(mol)\n\n        if inplace:\n            self.mols = [umol for list_umol in dict_umol.values() for umol in list_umol]\n        else:\n            return self.__class__([umol for list_umol in dict_umol.values() for umol in list_umol])\n\n    @property\n    def data(self):\n        return self._data\n\n    @data.setter\n    def data(self, data):\n        if isinstance(data, dict):\n            self._data = data\n        else:\n            raise TypeError(f'the {self.__class__.__name__}.data must be a dict')\n\n    @classmethod\n    def read_from(\n            cls, fmt: str,\n            dir_or_strings: Union[str, PathLike, Iterable[str]],\n            match_pattern: str = '*',\n            generate: bool = False,\n            ranges: Union[Sequence[int], range] = None,\n            condition: Callable = None,\n            num_proc: int = None\n    ):\n        \"\"\"\n        Read Molecule objects from a directory.\n\n        Args:\n            fmt(str): read file with the specified-format method.\n            dir_or_strings(str|PathLike): the directory all file put, or a sequence of string\n            match_pattern(str): the file name pattern\n            generate(bool): read file to a generator of Molecule object\n            ranges(Sequence[int]|range): A list or range of integers representing the indices of\n                the input files to read. Defaults to None.\n            condition(Callable): A callable object that takes two arguments (the path of the input file\n                and the corresponding Molecule object) and returns a boolean value indicating whether to include the\n                Molecule object in the output. Defaults to None.\n            num_proc: the number of process to read\n\n        Returns:\n            List(Molecule) or Generator(Molecule)\n        \"\"\"\n        def read_mol(pm: Path, conn):\n\n            try:\n                mol = ci.Molecule.read_from(pm, fmt)\n\n                # the OBMol, OBAtom, OBBond are C++ objects wrapped by SWIG,\n                # they can't be pickle, so pop them from Molecule and convert their info to .mol2 string\n                pmol = pb.Molecule(mol.ob_mol_pop())\n                script = pmol.write('mol2')  # Write to the mol2 script to allow it to pickle\n\n                # communicate with the main process\n                conn.send((mol, script, pm))\n\n            except AttributeError:\n                conn.send((None, None, pm))\n\n            except StopIteration:\n                conn.send((None, None, pm))\n\n        def mol_generator():\n            nonlocal dir_or_strings\n            for i, path_mol in enumerate(generate_path_or_string()):\n\n                if not ranges or i in ranges:\n                    try:\n                        mol = ci.Molecule.read_from(path_mol, fmt)\n                    except StopIteration:\n                        mol = None\n                else:\n                    continue\n\n                if mol and (not condition or condition(path_mol, mol)):\n                    yield mol\n\n        def mol_mp_generator():\n            mols_info = []\n\n            parent_conn, child_conn = mp.Pipe()\n            ps = []  # list of Process: Queue pairs\n\n            for i, source in enumerate(generate_path_or_string()):\n\n                # if the number of process more than num_proc, get the read molecule info and stop to start new process\n                while len(ps) >= num_proc:\n                    for p in ps:\n                        if not p.is_alive():\n                            mols_info.append(parent_conn.recv())\n                            p.terminate()\n                            ps.remove(p)\n\n                # When received some Molecule info, reorganize these info and yield\n                while mols_info:\n                    mol, script, pf = mols_info.pop()  # hotpot Molecule, mol2_script, path_file of Molecule\n\n                    # If you get a valid Molecule info, re-wrap to be hotpot Molecule\n                    if mol and script:\n                        pmol = pb.readstring('mol2', script)  # pybel Molecule object\n                        mol.ob_mol_rewrap(pmol.OBMol)  # re-wrap OBMol by hotpot Molecule\n\n                        # if the reorganized Molecule is expected, yield\n                        if not condition or condition(mol, pf):\n                            yield mol\n\n                # Start new process to read Molecule from file\n                if not ranges or i in ranges:\n                    p = mp.Process(target=read_mol, args=(source, child_conn))\n                    p.start()\n                    ps.append(p)\n\n            # After all path_file have pass into process to read\n            while ps:\n                for p in ps:\n                    if not p.is_alive():\n                        mols_info.append(parent_conn.recv())\n                        p.terminate()\n                        ps.remove(p)\n\n            for mol, script, pf in mols_info:\n                # if get a valid Molecule info, re-wrap to be hotpot Molecule\n                if mol and script:\n                    pmol = pb.readstring('mol2', script)  # pybel Molecule object\n                    mol.ob_mol_rewrap(pmol.OBMol)  # re-wrap OBMol by hotpot Molecule\n\n                    # if the reorganized Molecule is expected, yield\n                    if not condition or condition(mol, pf):\n                        yield mol\n\n        def generate_path_or_string():\n            \"\"\"\"\"\"\n            if isinstance(dir_or_strings, Path):\n                for path in dir_or_strings.glob(match_pattern):\n                    yield path\n\n            elif isinstance(dir_or_strings, Iterable):\n                for string in dir_or_strings:\n                    yield string\n\n            else:\n                raise TypeError(f'the dir_or_strings is required to be a Path or str, get {type(dir_or_strings)}')\n\n        if isinstance(dir_or_strings, str):\n            dir_or_strings = Path(dir_or_strings)\n        elif not isinstance(dir_or_strings, PathLike) and not isinstance(dir_or_strings, Iterable):\n            raise TypeError(\n                f'the read_dir should be a str, PathLike or iterable str, instead of {type(dir_or_strings)}'\n            )\n\n        generator = mol_mp_generator() if num_proc else mol_generator()\n\n        if generate:\n            return cls(generator)\n        else:\n            return cls([m for m in tqdm(generator, 'reading molecules')])\n\n    def gcmc_for_isotherm(\n            self, *guest: 'ci.Molecule', force_field: Union[str, PathLike] = None,\n            work_dir: Union[str, PathLike] = None, T: float = 298.15,\n            Ps: Sequence[float] = (1.0,), procs: int = 1, named_identifier: bool = False,\n            **kwargs\n    ):\n        \"\"\"\n        Run gcmc to determine the adsorption of guest,\n        Args:\n            self: the framework as the sorbent of guest molecule\n            guest(Molecule): the guest molecule to be adsorbed into the framework\n            force_field(str|PathLike): the path to force field file or the self-existent force file contained\n             in force field directory (in the case, a str should be given as a relative path from the root of\n             force field root to the specified self-existent force filed). By default, the force field is UFF\n             which in the relative path 'UFF/LJ.json' for the force field path.\n            work_dir: the user-specified dir to store the result of GCMC and log file.\n            T: the environmental temperature (default, 298.15 K)\n            Ps(Sequence[float]): A sequence of relative pressure related to the saturation vapor in the environmental temperature.\n            procs(int): the number of processes, default 1.\n            named_identifier: Whether to name the dir by the identifier of frames\n        \"\"\"\n        if isinstance(work_dir, str):\n            work_dir = Path(work_dir)\n\n        # Assemble keywords arguments for multiprocess\n        processes = []\n        for i, frame in enumerate(self.mols, 1):\n\n            # When the running proc more than the specified values, waiting for terminate\n            while len(processes) >= procs:\n                for p in processes:\n                    if not p.is_alive():\n                        processes.pop(processes.index(p))\n                        p.terminate()\n\n                time.sleep(10)\n\n            if named_identifier:\n                sub_work_dir = work_dir.joinpath(frame.identifier)\n            else:\n                idt_map = self._data.setdefault('identifier_map', {})\n                idt_map[i] = frame.identifier\n                sub_work_dir = work_dir.joinpath('mol_' + str(i))\n\n            if not sub_work_dir.exists():\n                sub_work_dir.mkdir()\n\n            kwargs.update({\n                'force_field': force_field,\n                'work_dir': sub_work_dir,\n                'T': T, 'Ps': Ps\n            })\n\n            p = mp.Process(target=frame.gcmc_for_isotherm, args=guest, kwargs=kwargs)\n\n            p.start()\n            processes.append(p)\n\n        for p in processes:\n            p.join()\n            p.terminate()\n\n        return self._data.get('identifier_map')\n\n    def graph_representation(self, *feature_names) -> Generator[Union[str, np.ndarray, np.ndarray], None, None]:\n        \"\"\" Transform molecules to their graph representation \"\"\"\n        for mol in self.mols:\n            yield mol.graph_representation(*feature_names)\n\n    def gaussian(\n            self, g16root: Union[str, PathLike], dir_out: Union[str, PathLike],\n            link0: Union[str, List[str]], route: Union[str, List[str]],\n            dir_err: Optional[Union[str, PathLike]] = None,\n            dir_chk: Optional[Union[str, PathLike]] = None,\n            clean_conformers: bool = True,\n            perturb_kwargs: Optional[Union[Dict[str, Any], List[Dict[str, Any]]]] = None,\n            *args, **kwargs\n    ) -> None:\n        \"\"\"\n        Run Gaussian16 calculations for Molecule objects stored in the MolBundle.\n        These Molecules are allowed to be perturbed their atoms' coordinates before submit to Gaussian 16\n\n        Args:\n            g16root (Union[str, PathLike]): The path to the Gaussian16 root directory.\n            dir_out (Union[str, PathLike]): The path to the directory to output the log files.\n            link0 (Union[str, List[str]]): The link0 information for Gaussian16 calculations.\n            route (Union[str, List[str]]): The route information for Gaussian16 calculations.\n            dir_err (Optional[Union[str, PathLike]], optional): The path to the directory to output the error files.\n                Defaults to None.\n            dir_chk (Optional[Union[str, PathLike]], optional): The path to the directory to store the .chk files.\n                Defaults to None.\n            clean_conformers (bool, optional): A flag indicating whether to clean the configuration before perturbing\n                the molecule or lattice. Defaults to True.\n            perturb_kwargs (Optional[Union[Dict[str, Any], List[Dict[str, Any]]]], optional): The parameters for\n                perturbing the molecule or lattice. Defaults to None.\n            *args: Additional positional arguments.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            None\n        \"\"\"\n        # Check and process paths\n        g16root: Path = check_path(g16root, file_or_dir='dir')\n        dir_out: Path = check_path(dir_out, mkdir=True)\n        dir_err: Optional[Path] = check_path(dir_err, mkdir=True)\n        dir_chk: Optional[Path] = check_path(dir_chk, mkdir=True)\n\n        for mol in self.mols:\n            assert isinstance(mol, ci.Molecule)\n\n            # Clean before perturb conformers\n            if clean_conformers:\n                mol.clean_conformers()\n\n            # Assign the dirs\n            # assign the dir to put out.log files for the mol\n            dir_out_mol = dir_out.joinpath(mol.identifier)\n            if not dir_out_mol.exists():\n                dir_out_mol.mkdir()\n\n            # assign the dir to put err.log files for the mol\n            if dir_err:\n                dir_err_mol = dir_err.joinpath(mol.identifier)\n                if not dir_err_mol.exists():\n                    dir_err_mol.mkdir()\n            else:\n                dir_err_mol = None\n\n            # Performing the molecule or lattice perturb\n            if isinstance(perturb_kwargs, Dict):\n                perturb_kwargs = [perturb_kwargs]  # Wrap it into a list\n\n            if isinstance(perturb_kwargs, List) and all(isinstance(pk, dict) for pk in perturb_kwargs):\n                for pk in perturb_kwargs:\n                    pk['inplace'] = True  # Force to inplace\n                    mol.perturb_atoms_coordinates(**pk)\n            elif perturb_kwargs is not None:\n                ValueError('The perturb_kwargs should be a dict or list of dict')\n\n            # Running the gaussian16\n            for config_idx in range(mol.conformer_counts):\n                mol.conformer_select(config_idx)\n\n                # Reorganize the arguments for each conformer\n                path_out = dir_out_mol.joinpath(f'{config_idx}.log')\n                path_err = dir_err_mol.joinpath(f'{config_idx}.err') if dir_err else None\n\n                if dir_chk:  # for dir_chk\n                    dir_chk_mol = dir_chk.joinpath(mol.identifier)\n                    dir_chk_mol.mkdir(exist_ok=True)\n\n                    if isinstance(link0, str):\n                        link0_cfg = [f'chk={str(dir_chk_mol)}/{config_idx}.chk', link0]\n                    elif isinstance(link0, list):\n                        link0_cfg = copy.copy(link0)\n                        link0_cfg.insert(0, f'chk={str(dir_chk_mol)}/{config_idx}.chk')\n                    else:\n                        TypeError('the link0 should be str or list of str!')\n                else:\n                    link0_cfg = link0\n\n                mol.gaussian(\n                    g16root=g16root,\n                    link0=link0_cfg,\n                    route=route,\n                    path_log_file=str(path_out.absolute()),\n                    path_err_file=str(path_err) if path_err else None,\n                    *args, **kwargs\n                )\n\n    @property\n    def is_generator(self):\n        \"\"\" To judge weather the object is a Molecule generator \"\"\"\n        return isinstance(self.mols, Generator)\n\n    @property\n    def mols(self):\n        return self._data.get('mols', [])\n\n    @mols.setter\n    def mols(self, mols):\n        self._data['mols'] = mols\n\n    @staticmethod\n    def registered_bundle_names():\n        \"\"\" Return all registered bundle names \"\"\"\n        return list(_bundle_classes.keys())\n\n    def to(self, bundle_name: str):\n        \"\"\" Convert this bundle to other bundle type \"\"\"\n        return _bundle_classes[bundle_name](self.mols)\n\n    def to_list(self) -> List[ci.Molecule]:\n        \"\"\" Convert the molecule container (self.mol) to list \"\"\"\n        if isinstance(self.mols, Generator):\n            self.mols = list(self)\n\n        return self.mols\n\n    def unique_mols(self, mode: Literal['smiles', 'similarity'] = 'smiles'):\n        \"\"\"\n        get a new Bundle with all unique Molecule objects\n        Args:\n            mode: the standard to identify whether two molecule to be regard as identical\n\n        Returns:\n            A new Bundle with all the unique Molecule objects\n        \"\"\"\n        clone = copy.copy(self)\n        clone.data = copy.copy(self.data)\n        if mode == 'smiles':\n            clone.mols = ({m.smiles: m for m in self.mols}.values())\n            return clone\n        elif mode == 'similarity':\n            dict_mols = {}\n            for mol in self.mols:\n                mols_with_same_atom_num = dict_mols.setdefault(mol.atom_counts, [])\n                mols_with_same_atom_num.append(mol)\n\n            new_mols = []\n            for _, mols_with_same_atom_num in dict_mols.items():\n                uni_mols = []\n                for mol in mols_with_same_atom_num:\n                    if mol not in uni_mols:\n                        uni_mols.append(mol)\n\n                new_mols.extend(uni_mols)\n\n            clone.mols = new_mols\n\n            return clone", "\n\n@register_bundles\nclass DeepModelBundle(MolBundle):\n    \"\"\" Specific MolBundle to carry out the tasks in DeepModeling packages \"\"\"\n\n    def merge_conformers(self):\n        \"\"\"\n        Get the sum of conformers for all molecule in the mol bundle \"self.mols\"\n        This method can only be successfully executed\n        when all molecules in the molecular bundle can be added to each other\n        Returns:\n            a Molecule object with all conformers in the self.mols\n        \"\"\"\n        atomic_numbers = self.atomic_numbers\n\n        if isinstance(atomic_numbers, tuple):\n            return sum(self.mols[1:], start=self.mols[0])\n        elif isinstance(atomic_numbers, dict):\n            mol_array = np.array(self.mols)\n            return self.__class__([mol_array[i].sum() for ans, i in self.atomic_numbers.items()])\n\n    def merge_atoms_same_mols(self) -> 'DeepModelBundle':\n        \"\"\" Merge Molecules with same atoms to a MixSameAtomMol \"\"\"\n        bundle: DeepModelBundle = self.to_mix_mols()\n        atom_counts = bundle.atom_counts\n\n        if isinstance(atom_counts, tuple):\n            return sum(bundle.mols[1:], start=bundle.mols[0])\n        elif isinstance(atom_counts, dict):\n            mol_array = np.array(bundle.mols)\n            return self.__class__([mol_array[i].sum() for ans, i in atom_counts.items()])\n\n    def to_dpmd_sys(\n            self, system_dir: Union[str, os.PathLike],\n            validate_ratio: float,\n            mode: Literal['std', 'att'] = 'std',\n            split_mode: Optional[Literal['inside', 'outside']] = None\n    ):\n        \"\"\"\"\"\"\n        def to_files(mb: MolBundle, save_root: Path):\n            for c, m in enumerate(mb):  # c: counts, m: molecule\n                mol_save_root = \\\n                    save_root.joinpath(str(m.atom_counts)) if mode == 'att' else save_root.joinpath(str(c))\n                if not mol_save_root.exists():\n                    mol_save_root.mkdir()\n\n                m.to_dpmd_sys(mol_save_root, mode)\n\n        if split_mode and split_mode not in ['inside', 'outside']:\n            raise ValueError(\"the split_mode must be 'inside' or 'outside'\")\n\n        if not 0.0 < validate_ratio < 1.0:\n            raise ValueError('the validate_ratio must be from 0.0 to 1.0')\n\n        # Organize dirs\n        if not isinstance(system_dir, Path):\n            system_dir = Path(system_dir)\n        if not system_dir.exists():\n            system_dir.mkdir()\n\n        training_dir = system_dir.joinpath('training_data')\n        validate_dir = system_dir.joinpath('validate_data')\n        if not training_dir.exists():\n            training_dir.mkdir()\n        if not validate_dir.exists():\n            validate_dir.mkdir()\n\n        if mode == 'att':\n            bundle = self.merge_atoms_same_mols()\n            if not split_mode:\n                split_mode = 'inside'\n\n        elif mode == 'std':\n            bundle = self.merge_conformers()\n            if not split_mode:\n                split_mode = 'outside'\n\n        else:\n            raise ValueError(\"the mode is only allowed to be 'att' or 'std'!\")\n\n        if split_mode == 'inside':\n            for i, mol in enumerate(bundle):\n                mol_training_dir = \\\n                    training_dir.joinpath(str(mol.atom_counts)) if mode == 'att' else system_dir.joinpath(str(i))\n                mol_validate_dir = \\\n                    validate_dir.joinpath(str(mol.atom_counts)) if mode == 'att' else system_dir.joinpath(str(i))\n\n                if not mol_training_dir.exists():\n                    mol_training_dir.mkdir()\n                if not mol_validate_dir.exists():\n                    mol_validate_dir.mkdir()\n\n                mol.to_dpmd_sys(mol_training_dir, mode, validate_ratio, mol_validate_dir)\n\n        elif split_mode == 'outside':\n            validate_bundle, training_bundle = bundle.choice(p=validate_ratio, get_remain=True)\n\n            # Save to files\n            to_files(training_bundle, training_dir)\n            to_files(validate_bundle, validate_dir)\n\n    def to_mix_mols(self):\n        \"\"\"\n        Return a new MolBundle, in which Molecule objects in container are converted to MixSameAtomMol\n        Returns:\n            MolBundle(MixSameAtomMol)\n        \"\"\"\n        return self.__class__([m.to_mix_mol() if not isinstance(m, ci.MixSameAtomMol) else m for m in self])\n\n    def to_mols(self):\n        \"\"\"\n        Return a new MolBundle, in which MixSameAtomMol objects in container are converted to Molecule\n        Returns:\n            MolBundle(Molecule)\n        \"\"\"\n        return self.__class__([m.to_mol() if isinstance(m, ci.MixSameAtomMol) else m for m in self])", "\n"]}
{"filename": "hotpot/tanks/cc.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : cc\n@Auther : Zhiyuan Zhang\n@Data   : 2023/6/4\n@Time   : 21:05\n\nThis module is to perform `Task` about Coordination Chemistry (cc)\n\"\"\"", "This module is to perform `Task` about Coordination Chemistry (cc)\n\"\"\"\nimport os\nfrom pathlib import Path\nfrom typing import *\nimport json\n\nimport numpy as np\nimport pandas as pd\nfrom openbabel import openbabel as ob", "import pandas as pd\nfrom openbabel import openbabel as ob\n\nfrom hotpot import data_root\nfrom hotpot.cheminfo import Molecule, Atom\nfrom hotpot.bundle import MolBundle\nfrom hotpot.utils.manage_machine import machine\n\n# the atomic single point energies determined Gaussian with various methods and basis sets\n_atom_single_point: dict = json.load(open(Path(data_root).joinpath('atom_single_point.json')))", "# the atomic single point energies determined Gaussian with various methods and basis sets\n_atom_single_point: dict = json.load(open(Path(data_root).joinpath('atom_single_point.json')))\n\n\nclass MetalLigandPair(Molecule):\n    \"\"\" The Molecule to represent a metal-ligand pair \"\"\"\n    def _set_bond_dissociation_energy(self, bde: float):\n        \"\"\"\"\"\"\n        bde_store = ob.OBCommentData()\n        bde_store.SetData(str(bde))\n        bde_store.SetAttribute('BDE')\n        self.ob_mol.CloneData(bde_store)\n\n    @property\n    def bond_dissociation_energy(self):\n        bde_store = self.ob_mol.GetData('BDE')\n        if bde_store:\n            bde = ob.toCommentData(bde_store).GetValue()\n            return float(bde)\n\n        return 0.0\n\n    @bond_dissociation_energy.setter\n    def bond_dissociation_energy(self, bde: float):\n        print(bde)\n        self._set_bond_dissociation_energy(bde)", "\n\nclass PairBundle(MolBundle):\n    \"\"\"The MolBundle which contains a ligands, a metal as well as their pairs assembled by them\"\"\"\n\n    class DirsFiles:\n        \"\"\"\n        Specify directory and files path for utils in Gaussian calculation\n        Attributes:\n            work_dir: the root dir for all results af Gaussian calculation\n            log_dir: the dir to store Gaussian log files\n            err_dir: the dir to store Gaussian error message\n            struct_dir: the structure after optimizing\n            energy_path: path of the csv file for storing energy of each structures (metal, ligand, pairs)\n            bde_path: path of the csv file for storing bond dissociation energy of each pairs\n        \"\"\"\n\n        def __init__(self, work_dir: Union[str, os.PathLike]):\n            if isinstance(work_dir, str):\n                work_dir = Path(work_dir)\n\n            self.work_dir = work_dir\n            self.chk_dir = work_dir.joinpath('chk')\n            self.log_dir = work_dir.joinpath('log')\n            self.err_dir = work_dir.joinpath('err')\n            self.struct_dir = work_dir.joinpath('struct')\n            self.energy_path = work_dir.joinpath('energy.csv')\n            self.bde_path = work_dir.joinpath('bde.csv')\n\n        @property\n        def ligand_chk_path(self):\n            return self.chk_dir.joinpath('ligand.chk')\n\n        @property\n        def ligand_log_path(self):\n            return self.log_dir.joinpath('ligand.log')\n\n        @property\n        def ligand_err_path(self):\n            return self.err_dir.joinpath('ligand.err')\n\n        @property\n        def ligand_struct_path(self):\n            return self.struct_dir.joinpath('ligand.mol2')\n\n        def make_dirs(self):\n            \"\"\" Check and make dirs \"\"\"\n            if not self.work_dir.exists():\n                self.work_dir.mkdir()\n            if not self.log_dir.exists():\n                self.log_dir.mkdir()\n            if not self.err_dir.exists():\n                self.err_dir.mkdir()\n            if not self.struct_dir.exists():\n                self.struct_dir.mkdir()\n\n        @property\n        def metal_chk_path(self):\n            return self.chk_dir.joinpath('metal.log')\n\n        @property\n        def metal_log_path(self):\n            return self.log_dir.joinpath('metal.log')\n\n        @property\n        def metal_err_path(self):\n            return self.err_dir.joinpath('metal.err')\n\n        @property\n        def metal_struct_path(self):\n            return self.struct_dir.joinpath('metal.mol2')\n\n        def pair_chk_path(self, idx: int):\n            return self.chk_dir.joinpath(f'pair_{idx}.chk')\n\n        def pair_log_path(self, idx: int):\n            return self.log_dir.joinpath(f'pair_{idx}.log')\n\n        def pair_err_path(self, idx: int):\n            return self.err_dir.joinpath(f'pair_{idx}.err')\n\n        def pair_struct_path(self, idx: int):\n            return self.struct_dir.joinpath(f'pair_{idx}.mol2')\n\n    def __init__(self, metal: Atom, ligand: Molecule, pairs: Sequence[Molecule]):\n        self.metal = Molecule()\n        self.metal.add_atom(metal)\n        self.metal.identifier = metal.symbol\n\n        self.ligand = ligand\n\n        super(PairBundle, self).__init__(pairs)\n\n    @classmethod\n    def _specify_dir_files(cls, work_dir: Union[str, os.PathLike]):\n        return cls.DirsFiles(work_dir)\n\n    @property\n    def pairs(self):\n        return self.mols\n\n    def determine_metal_ligand_bind_energy(\n            self, g16root: Union[str, os.PathLike], work_dir: Union[str, os.PathLike],\n            method: str = 'B3LYP', basis_set: str = '6-311', route: str = '',\n            cpu_uti: float = 0.75, skip_complete=False\n    ) -> pd.DataFrame:\n        def _run_gaussian(gauss_func: Callable, path_log_file, path_err_file):\n            \"\"\" Run Gaussian calculation \"\"\"\n            gauss_func(\n                g16root,\n                link0=[\n                    f'nproc={machine.take_CPUs(cpu_uti)}',\n                    f'Mem={machine.take_memory(cpu_uti)}GB'\n                ],\n                route=f'opt {method}/{basis_set} ' + route,\n                path_log_file=path_log_file,\n                path_err_file=path_err_file,\n                inplace_attrs=True\n            )\n\n        # Merge the pairs which same graph firstly\n        self.collect_identical(inplace=True)\n\n        # Specify directories and make these dirs\n        dirs_files = self._specify_dir_files(work_dir)\n        dirs_files.make_dirs()\n\n        # Energy sheet, bond dissociation energy (BDE) sheet\n        e_sheet, bde_sheet = [], []\n\n        # #####################################################################################################\n        # Save the initialized ligand structure\n        self.ligand.writefile('mol2', dirs_files.ligand_struct_path)\n\n        if skip_complete and dirs_files.ligand_log_path.exists():\n            # TODO: only l9999 error could be read\n            read_ligand = Molecule.read_from(dirs_files.ligand_log_path, 'g16log')\n            if isinstance(read_ligand, Molecule) and read_ligand.all_energy[-1]:\n                ligand_energy = read_ligand.all_energy[-1]\n            else:\n                _run_gaussian(self.ligand.gaussian, dirs_files.ligand_log_path, dirs_files.ligand_err_path)\n                ligand_energy = self.ligand.energy  # Retrieve the energy after optimizing the conformer\n\n        else:\n            # optimize the configure of ligand and calculate their total energy after optimization\n            _run_gaussian(self.ligand.gaussian, dirs_files.ligand_log_path, dirs_files.ligand_err_path)\n            ligand_energy = self.ligand.energy  # Retrieve the energy after optimizing the conformer\n\n        e_sheet.append(['ligand', self.ligand.smiles, ligand_energy])\n\n        # save the optimized structures\n        self.ligand.writefile('mol2', dirs_files.ligand_struct_path)\n\n        # ######################################################################################################\n        # Calculate the single point (sp) energy for metal\n        try:\n            metal_sp = _atom_single_point[self.metal.atoms[0].symbol][method][basis_set]\n        except KeyError:\n            _run_gaussian(self.metal.gaussian, dirs_files.metal_log_path, dirs_files.ligand_err_path)\n\n            ele_dict = _atom_single_point.setdefault(self.metal.atoms[0].symbol, {})\n            ele_method_dict = ele_dict.setdefault(method, {})\n\n            metal_sp = ele_method_dict[basis_set] = self.metal.energy  # Recording the calculate SCF energy to the dict\n\n            # Save the single point as package data\n            json.dump(_atom_single_point, open(Path(data_root).joinpath('atom_single_point.json'), 'w'), indent=True)\n\n        # Append the metal energy values to energy sheet\n        e_sheet.append(['metal', self.metal.smiles, metal_sp])\n        # Save metal structure\n        self.metal.writefile('mol2', dirs_files.metal_struct_path)\n\n        # #####################################################################################################\n        # Optimizing the conformer of metal-ligands pairs and Retrieve the energies in the last stable conformer\n        for i, pair in enumerate(self.pairs):\n            # Save initialized Metal-ligand pair struct\n            pair.writefile('mol2', dirs_files.pair_struct_path(i))\n\n            if skip_complete and dirs_files.pair_log_path(i).exists():\n                # TODO: only l9999 error could be read\n                read_pair = Molecule.read_from(dirs_files.pair_log_path(i), 'g16log')\n                if isinstance(read_pair, Molecule) and read_pair.all_energy[-1]:\n                    pair_energy = read_pair.all_energy[-1]\n                else:\n                    _run_gaussian(pair.gaussian, dirs_files.pair_log_path(i), dirs_files.pair_err_path(i))\n                    pair_energy = pair.energy  # Retrieve the energy after optimizing the conformer\n\n            else:\n                # optimize the configure of ligand and calculate their total energy after optimization\n                _run_gaussian(pair.gaussian, dirs_files.pair_log_path(i), dirs_files.pair_err_path(i))\n                pair_energy = pair.energy  # Retrieve the energy after optimizing the conformer\n\n            # Append the pairs energy values to energy sheet\n            e_sheet.append([f'pair_{i}', pair.smiles, pair_energy])\n            bde_sheet.append([f'pair_{i}', pair.smiles, pair_energy - ligand_energy - metal_sp])\n            # Save refined Metal-ligand pair struct\n            pair.writefile('mol2', dirs_files.pair_struct_path(i))\n\n        # #####################################################################################################\n        # Save the energy sheet to csv\n        e_sheet = np.array(e_sheet)\n        df = pd.DataFrame(e_sheet[:, 1:], index=e_sheet[:, 0], columns=['smiles', 'Energy(eV)'])\n        df.to_csv(dirs_files.energy_path)\n\n        # Save the BDE sheet to csv\n        bde_sheet = np.array(bde_sheet)\n        df = pd.DataFrame(bde_sheet[:, 1:], index=bde_sheet[:, 0], columns=['smiles', 'BDE(eV)'])\n        df.to_csv(dirs_files.bde_path)\n\n        return df\n\n    @classmethod\n    def read_2d_bde_results(cls, work_dir: Union[str, os.PathLike]):\n        \"\"\"\n        Read Calculated BDE results with the 2d molecular results, restore from SMILES str\n        Args:\n            work_dir: work dir to calculate the results\n\n        Returns:\n            PairBundle\n        \"\"\"\n        dirs_files = cls._specify_dir_files(work_dir)\n\n        bde_sheet = pd.read_csv(dirs_files.bde_path, index_col=0)\n\n        mols = []\n        for i, row in bde_sheet.iterrows():\n            mol = Molecule.read_from(row['smiles'], 'smi')\n            mol.bde = row['energy']\n\n        return mols\n\n    @classmethod\n    def read_3d_bde_results(cls, work_dir: Union[str, os.PathLike]):\n        \"\"\"\n        TODO\n        Read calculated BDE results with the 3d molecular results, the 3d structure stored in mol2 file\n        Args:\n            work_dir:  work dir to calculate the results\n\n        Returns:\n\n        \"\"\"\n        dirs_files = cls._specify_dir_files(work_dir)\n\n    @classmethod\n    def read_all_results(cls, work_dir):\n        \"\"\"\n        Read all direct calculated result in gaussian log file, include ligand, metal, pair, energy, force, charge,et al\n        Args:\n            work_dir:  work dir to calculate the results\n        Returns:\n\n        \"\"\"", ""]}
{"filename": "hotpot/tanks/__init__.py", "chunked_list": ["\"\"\"\npython v3.7.9\n@Project: hotpot\n@File   : __init__.py.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/3/20\n@Time   : 2:43\n\"\"\"\nimport os\nimport sys", "import os\nimport sys\n\nsys.path.append(os.path.abspath(os.path.dirname(__file__)))\n"]}
{"filename": "hotpot/tanks/features.py", "chunked_list": ["\"\"\"\npython v3.7.9\n@Project: hotpot\n@File   : features.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/3/23\n@Time   : 3:56\n\"\"\"\n\n\nclass ZeoPlusPlus:\n    ...", "\n\nclass ZeoPlusPlus:\n    ...\n"]}
{"filename": "hotpot/tanks/deepmd.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : deepmd.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/6/26\n@Time   : 21:42\n\"\"\"\nimport os\nimport json", "import os\nimport json\nfrom typing import *\nfrom pathlib import Path\nfrom copy import copy\n\nimport numpy as np\nimport pandas as pd\n\nfrom hotpot import data_root", "\nfrom hotpot import data_root\nfrom hotpot.cheminfo import Molecule, periodic_table\n\n# Manuscript training script\n_script = json.load(open(os.path.join(data_root, 'deepmd_script.json')))\n\n\nclass DeepSystem:\n    \"\"\"\n    A handle to convert the Molecule object ot DeepModeling System data format\n    Args:\n        mol(Molecule):\n\n    \"\"\"\n\n    required_items = ('coord', 'type')\n    check_atom_num = ('coord', 'force', 'charge')\n    share_same_conformers = ('type', 'coord', 'energy', 'force', 'charge', 'virial', 'box', 'identifiers')\n    need_reshape = ('coord', 'force')\n\n    def __init__(self, mol: Molecule = None, data: dict = None):\n        if mol:\n            self.data = self._organize_data(mol)\n            # check numpy.ndarray shape\n            self._check_shape()\n            # reshape array\n            self._reshape_array()\n        elif data:\n            self.data = data\n        else:\n            raise ValueError('the args mol or data should be given at least one!')\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({len(self.data[\"coord\"])})'\n\n    def __call__(\n            self,\n            save_dir: Union[str, os.PathLike], mode: str = 'std',\n            validate_ratio: Optional[float] = None,\n            validate_dir: Union[str, os.PathLike] = None\n    ):\n        \"\"\"\n        Save the DeepMData to files\n        Args:\n            save_dir(str|os.PathLike|Path): the root dir for all corresponding DeepMDate system files,\n             if the validate ratio is given, this the represent the training set save dir\n            validate_ratio(float): the ratio of validate set, if not given, not split the dataset\n            validate_dir: should be give when validate_ratio has been given, the root dir for validate data\n        \"\"\"\n        if not isinstance(save_dir, Path):\n            save_dir = Path(save_dir)\n\n        if validate_ratio:\n            if not isinstance(validate_dir, (str, os.PathLike)):\n                raise ValueError('the arguments validate_dir has not been given!')\n            elif isinstance(validate_dir, str):\n                validate_dir = Path(validate_dir)\n\n            if not 0 < validate_ratio < 1:\n                raise ValueError('the validate ratio should from 0 to 1')\n\n            indices = np.arange(len(self))\n            validate_idx = np.random.choice(indices, size=int(len(self) * validate_ratio), replace=False)\n            training_idx = np.setdiff1d(indices, validate_idx)\n\n            validate_data = self[validate_idx]\n            training_data = self[training_idx]\n\n            self._save_deep_md(training_data, save_dir, mode)\n            self._save_deep_md(validate_data, validate_dir, mode)\n\n        else:\n            self._save_deep_md(self, save_dir, mode)\n\n    def __getitem__(self, item: Union[int, slice, np.ndarray]):\n        data = copy(self.data)\n        if not isinstance(item, (int, slice, np.ndarray)):\n            raise TypeError('the item should be int, slice or numpy.ndarray')\n\n        for name in self.share_same_conformers:\n            arrays = self.data.get(name)\n            if isinstance(arrays, np.ndarray):\n                data[name] = arrays[item]\n\n        return self.__class__(data=data)\n\n    def __getattr__(self, item: str):\n        if item not in self.__dir__():\n            raise AttributeError(f'the {self.__class__.__name__} not have attribute {item}')\n        return self.data.get(item, None)\n\n    def __dir__(self) -> Iterable[str]:\n        return [\n            'type', 'type_map', 'nopbc', 'coord', 'box', 'energy', 'force', 'charge',\n            'atom_counts','virial', 'atom_ener', 'atom_pref', 'dipole', 'atom_dipole',\n            'polarizability', 'atomic_polarizability'\n        ]\n\n    def __len__(self):\n        return len(self.data['coord'])\n\n    def _check_shape(self):\n        \"\"\" Check whether the shape ndarray is correct \"\"\"\n        conf_counts = len(self.data['coord'])\n        atom_counts = self.data['atom_counts']\n\n        for name in self.required_items:\n            if self.data.get(name) is None:\n                raise ValueError('the required composition to make the dpmd system is incomplete!')\n\n        # Check whether the number of conformers are matching among data\n        if any(len(self.data[n]) != conf_counts for n in self.share_same_conformers if self.data[n] is not None):\n            raise ValueError('the number of conformers is not match')\n\n        # Check whether the number of atoms in data are matching to the molecular atoms\n        if any(self.data[n].shape[1] != atom_counts for n in self.check_atom_num if self.data[n] is not None):\n            raise ValueError('the number of atoms is not matching the number of atom is the molecule')\n\n    def _reshape_array(self):\n        for name in self.need_reshape:\n            item = self.data.get(name)\n            if isinstance(item, np.ndarray):\n                shape = item.shape\n\n                assert len(shape) == 3\n\n                self.data[name] = item.reshape((shape[0], shape[1] * shape[2]))\n\n    @staticmethod\n    def _organize_data(mol: Molecule) -> Dict[str, Any]:\n        \"\"\" Organize the conformer data to a dict \"\"\"\n        conf_num = len(mol.all_coordinates)\n        crystal = mol.crystal()\n        if crystal:\n            box = mol.crystal().vector  # angstrom\n            is_periodic = True\n        else:\n            box = np.zeros((3, 3))\n            for i in range(3):\n                box[i, i] = 100.\n            is_periodic = False\n        box = box.reshape(-1, 9).repeat(conf_num, axis=0)\n\n        return {\n            'type': mol.atomic_numbers_array,  # matrix of (conformer_counts, atom_counts)\n            'type_map': ['-'] + list(periodic_table.symbols),\n            'nopbc': not is_periodic,\n            'coord': mol.all_coordinates,  # angstrom,\n            'box': box,\n            'energy': mol.all_energy,  # eV\n            'force': mol.all_forces,  # Hartree/Bohr,\n            'charge': mol.all_atom_charges,  # q\n            'atom_counts': mol.atom_counts,\n            'identifiers': mol.identifier_array,\n            'virial': None,\n            'atom_ener': None,\n            'atom_pref': None,\n            'dipole': None,\n            'atom_dipole': None,\n            'polarizability': None,\n            'atomic_polarizability': None\n        }\n\n    @staticmethod\n    def _save_deep_md(system: 'DeepSystem', save_dir: Path, mode: str):\n        \"\"\" Save DeepMData to dir \"\"\"\n        if not save_dir.exists():\n            save_dir.mkdir()\n\n        # the dir of set data\n        set_root = save_dir.joinpath('set.000')\n        if not set_root.exists():\n            set_root.mkdir()\n\n        for name, value in system.data.items():\n\n            # if the value is None, go to next\n            if value is None:\n                continue\n\n            # Write the type raw\n            if name == 'type':\n                if mode == 'std':\n                    type_raw = value[0]\n                elif mode == 'att':\n                    type_raw = np.zeros(value[0].shape, dtype=int)\n                    np.save(set_root.joinpath(\"real_atom_types.npy\"), value)\n                else:\n                    raise ValueError('the mode just allows to be \"std\" or \"att\"')\n\n                with open(save_dir.joinpath('type.raw'), 'w') as writer:\n                    writer.write('\\n'.join([str(i) for i in type_raw]))\n\n            elif name == 'type_map':\n                with open(save_dir.joinpath('type_map.raw'), 'w') as writer:\n                    writer.write('\\n'.join([str(i) for i in value]))\n\n            # Create an empty 'nopbc', when the system is not periodical\n            elif name == 'nopbc' and value is True:\n                with open(save_dir.joinpath('nopbc'), 'w') as writer:\n                    writer.write('')\n\n            # Save the numpy format data\n            elif isinstance(value, np.ndarray):\n                np.save(str(set_root.joinpath(f'{name}.npy')), value)", "class DeepSystem:\n    \"\"\"\n    A handle to convert the Molecule object ot DeepModeling System data format\n    Args:\n        mol(Molecule):\n\n    \"\"\"\n\n    required_items = ('coord', 'type')\n    check_atom_num = ('coord', 'force', 'charge')\n    share_same_conformers = ('type', 'coord', 'energy', 'force', 'charge', 'virial', 'box', 'identifiers')\n    need_reshape = ('coord', 'force')\n\n    def __init__(self, mol: Molecule = None, data: dict = None):\n        if mol:\n            self.data = self._organize_data(mol)\n            # check numpy.ndarray shape\n            self._check_shape()\n            # reshape array\n            self._reshape_array()\n        elif data:\n            self.data = data\n        else:\n            raise ValueError('the args mol or data should be given at least one!')\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({len(self.data[\"coord\"])})'\n\n    def __call__(\n            self,\n            save_dir: Union[str, os.PathLike], mode: str = 'std',\n            validate_ratio: Optional[float] = None,\n            validate_dir: Union[str, os.PathLike] = None\n    ):\n        \"\"\"\n        Save the DeepMData to files\n        Args:\n            save_dir(str|os.PathLike|Path): the root dir for all corresponding DeepMDate system files,\n             if the validate ratio is given, this the represent the training set save dir\n            validate_ratio(float): the ratio of validate set, if not given, not split the dataset\n            validate_dir: should be give when validate_ratio has been given, the root dir for validate data\n        \"\"\"\n        if not isinstance(save_dir, Path):\n            save_dir = Path(save_dir)\n\n        if validate_ratio:\n            if not isinstance(validate_dir, (str, os.PathLike)):\n                raise ValueError('the arguments validate_dir has not been given!')\n            elif isinstance(validate_dir, str):\n                validate_dir = Path(validate_dir)\n\n            if not 0 < validate_ratio < 1:\n                raise ValueError('the validate ratio should from 0 to 1')\n\n            indices = np.arange(len(self))\n            validate_idx = np.random.choice(indices, size=int(len(self) * validate_ratio), replace=False)\n            training_idx = np.setdiff1d(indices, validate_idx)\n\n            validate_data = self[validate_idx]\n            training_data = self[training_idx]\n\n            self._save_deep_md(training_data, save_dir, mode)\n            self._save_deep_md(validate_data, validate_dir, mode)\n\n        else:\n            self._save_deep_md(self, save_dir, mode)\n\n    def __getitem__(self, item: Union[int, slice, np.ndarray]):\n        data = copy(self.data)\n        if not isinstance(item, (int, slice, np.ndarray)):\n            raise TypeError('the item should be int, slice or numpy.ndarray')\n\n        for name in self.share_same_conformers:\n            arrays = self.data.get(name)\n            if isinstance(arrays, np.ndarray):\n                data[name] = arrays[item]\n\n        return self.__class__(data=data)\n\n    def __getattr__(self, item: str):\n        if item not in self.__dir__():\n            raise AttributeError(f'the {self.__class__.__name__} not have attribute {item}')\n        return self.data.get(item, None)\n\n    def __dir__(self) -> Iterable[str]:\n        return [\n            'type', 'type_map', 'nopbc', 'coord', 'box', 'energy', 'force', 'charge',\n            'atom_counts','virial', 'atom_ener', 'atom_pref', 'dipole', 'atom_dipole',\n            'polarizability', 'atomic_polarizability'\n        ]\n\n    def __len__(self):\n        return len(self.data['coord'])\n\n    def _check_shape(self):\n        \"\"\" Check whether the shape ndarray is correct \"\"\"\n        conf_counts = len(self.data['coord'])\n        atom_counts = self.data['atom_counts']\n\n        for name in self.required_items:\n            if self.data.get(name) is None:\n                raise ValueError('the required composition to make the dpmd system is incomplete!')\n\n        # Check whether the number of conformers are matching among data\n        if any(len(self.data[n]) != conf_counts for n in self.share_same_conformers if self.data[n] is not None):\n            raise ValueError('the number of conformers is not match')\n\n        # Check whether the number of atoms in data are matching to the molecular atoms\n        if any(self.data[n].shape[1] != atom_counts for n in self.check_atom_num if self.data[n] is not None):\n            raise ValueError('the number of atoms is not matching the number of atom is the molecule')\n\n    def _reshape_array(self):\n        for name in self.need_reshape:\n            item = self.data.get(name)\n            if isinstance(item, np.ndarray):\n                shape = item.shape\n\n                assert len(shape) == 3\n\n                self.data[name] = item.reshape((shape[0], shape[1] * shape[2]))\n\n    @staticmethod\n    def _organize_data(mol: Molecule) -> Dict[str, Any]:\n        \"\"\" Organize the conformer data to a dict \"\"\"\n        conf_num = len(mol.all_coordinates)\n        crystal = mol.crystal()\n        if crystal:\n            box = mol.crystal().vector  # angstrom\n            is_periodic = True\n        else:\n            box = np.zeros((3, 3))\n            for i in range(3):\n                box[i, i] = 100.\n            is_periodic = False\n        box = box.reshape(-1, 9).repeat(conf_num, axis=0)\n\n        return {\n            'type': mol.atomic_numbers_array,  # matrix of (conformer_counts, atom_counts)\n            'type_map': ['-'] + list(periodic_table.symbols),\n            'nopbc': not is_periodic,\n            'coord': mol.all_coordinates,  # angstrom,\n            'box': box,\n            'energy': mol.all_energy,  # eV\n            'force': mol.all_forces,  # Hartree/Bohr,\n            'charge': mol.all_atom_charges,  # q\n            'atom_counts': mol.atom_counts,\n            'identifiers': mol.identifier_array,\n            'virial': None,\n            'atom_ener': None,\n            'atom_pref': None,\n            'dipole': None,\n            'atom_dipole': None,\n            'polarizability': None,\n            'atomic_polarizability': None\n        }\n\n    @staticmethod\n    def _save_deep_md(system: 'DeepSystem', save_dir: Path, mode: str):\n        \"\"\" Save DeepMData to dir \"\"\"\n        if not save_dir.exists():\n            save_dir.mkdir()\n\n        # the dir of set data\n        set_root = save_dir.joinpath('set.000')\n        if not set_root.exists():\n            set_root.mkdir()\n\n        for name, value in system.data.items():\n\n            # if the value is None, go to next\n            if value is None:\n                continue\n\n            # Write the type raw\n            if name == 'type':\n                if mode == 'std':\n                    type_raw = value[0]\n                elif mode == 'att':\n                    type_raw = np.zeros(value[0].shape, dtype=int)\n                    np.save(set_root.joinpath(\"real_atom_types.npy\"), value)\n                else:\n                    raise ValueError('the mode just allows to be \"std\" or \"att\"')\n\n                with open(save_dir.joinpath('type.raw'), 'w') as writer:\n                    writer.write('\\n'.join([str(i) for i in type_raw]))\n\n            elif name == 'type_map':\n                with open(save_dir.joinpath('type_map.raw'), 'w') as writer:\n                    writer.write('\\n'.join([str(i) for i in value]))\n\n            # Create an empty 'nopbc', when the system is not periodical\n            elif name == 'nopbc' and value is True:\n                with open(save_dir.joinpath('nopbc'), 'w') as writer:\n                    writer.write('')\n\n            # Save the numpy format data\n            elif isinstance(value, np.ndarray):\n                np.save(str(set_root.joinpath(f'{name}.npy')), value)", "\n\ndef make_script():\n    \"\"\"\"\"\"\n\n\ndef convert_lcurve_to_csv(path_lcurve: Union[str, Path], path_csv: Union[str, Path] = None) -> pd.DataFrame:\n    \"\"\" Convert the lcurve.out file to csv file \"\"\"\n    path_lcurve = Path(path_lcurve)\n    if not path_csv:\n        path_csv = path_lcurve.parent.joinpath('lcurve.csv')\n    else:\n        path_csv = Path(path_csv)\n\n    df = pd.DataFrame(np.genfromtxt(path_lcurve, names=True))\n    df.set_index(df.columns[0], inplace=True)\n    df.to_csv(path_csv)\n\n    return df", ""]}
{"filename": "hotpot/tanks/qm/abacus.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : abacus\n@Auther : Zhiyuan Zhang\n@Data   : 2023/7/24\n@Time   : 18:09\n\"\"\"\n", ""]}
{"filename": "hotpot/tanks/qm/gaussian.py", "chunked_list": ["\"\"\"\npython v3.7.9\n@Project: hotpot\n@File   : qm.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/3/20chgrp\n@Time   : 2:44\n\"\"\"\nimport os\nimport re", "import os\nimport re\nfrom pathlib import Path\nimport resource\nimport subprocess\nimport io\nfrom typing import *\nfrom abc import ABC, abstractmethod\n\nimport numpy as np", "\nimport numpy as np\nimport cclib\n\n\nclass GaussianRunError(BaseException):\n    \"\"\" Raise when the encounter error in run gaussian \"\"\"\n\n\nclass FailToHandle(Warning):\n    \"\"\" Report this Warning when GaussErrorHandle Fail to handle an error \"\"\"", "\nclass FailToHandle(Warning):\n    \"\"\" Report this Warning when GaussErrorHandle Fail to handle an error \"\"\"\n\n\nclass GaussOut:\n    \"\"\"\n    This class is used to store Gaussian output and error message from g16 process.\n    In addition, this class will extract and organize critical information.\n    \"\"\"\n\n    # Compile the error notice sentence\n    _head = re.compile('Error termination via Lnk1e in')\n    _link = re.compile(r'l\\d+[.]exe')\n    _path = re.compile(r'([/|\\\\]\\S+)*[/|\\\\]' + _link.pattern)\n    _week = re.compile('(Mon|Tue|Wed|Thu|Fri|Sat|Sun)')\n    _month = re.compile('(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)')\n    _date = re.compile(_week.pattern + ' ' + _month.pattern + r' [0-2]?\\d')\n    _time = re.compile(r'\\d{2}:\\d{2}:\\d{2} 20\\d{2}\\.')\n\n    _error_link = re.compile(_head.pattern + ' ' + _path.pattern + ' at ' + _date.pattern + ' ' + _time.pattern)\n\n    def __init__(self, stdout: str, stderr: str):\n        self.stdout = stdout\n        self.stderr = stderr\n\n    @property\n    def is_error(self) -> bool:\n        return True if self.stderr else False\n\n    @property\n    def error_link(self) -> str:\n        if self.is_error:\n            match = self._error_link.search(self.stdout)\n            if match:\n                matched_line = self.stdout[match.start():match.end()]\n\n                link = self._link.search(matched_line)\n                return matched_line[link.start(): link.end()][:-4]\n\n    @property\n    def is_hangup_error(self):\n        if self.is_error and self.stderr.find('Error: hangup'):\n            return True\n        return False\n\n    @property\n    def is_opti_convergence_error(self):\n        \"\"\" The gaussian error is caused by the non-convergence of the optimizing conformer \"\"\"\n        if self.is_error and self.error_link == 'l9999' and self.stdout.find('-- Number of steps exceeded,'):\n            return True\n        return False\n\n    @property\n    def is_scf_convergence_error(self):\n        \"\"\" Get True when the Output show the SCF non-convergence \"\"\"\n        if self.error_link == 'l502' and self.stdout.find(\"Convergence failure -- run terminated.\"):\n            return True\n        return False\n\n    @property\n    def is_scrf_Vdw_cage_error(self):\n        \"\"\" Error caused by the Vdw surface is not suitable to estimate the accessible surface inside molecular cage \"\"\"\n        if self.error_link == 'l502' and self.stdout.find(\"Inv3 failed in PCMMkU.\"):\n            return True\n        return False\n\n    @property\n    def is_ZMatrix_error(self):\n        if self.error_link == 'l103' and \\\n                self.stdout.find('FormBX had a problem.') and \\\n                self.stdout.find('Berny optimization.'):\n            return True\n\n        return False\n\n    def report(self) -> list[str]:\n        \"\"\" Report all error messages \"\"\"\n        error_judge = re.compile(r'is_.+_error')\n\n        print(\"Meet Gaussian Error:\")\n        errors = []\n        for name in self.__dir__():\n            if hasattr(self, name) and error_judge.fullmatch(name) and getattr(self, name):\n                print(f'\\t--{name[3:]};')\n                errors.append(name)\n\n        return errors", "\n\nclass Gaussian:\n    \"\"\"\n    A class for setting up and running Gaussian 16 calculations.\n\n    Attributes:\n        g16root (str): The path to the Gaussian 16 root directory.\n\n    \"\"\"\n    def __init__(\n            self,\n            g16root: Union[str, os.PathLike],\n            path_gjf: Union[str, os.PathLike] = None,\n            path_log: Union[str, os.PathLike] = None,\n            path_err: Union[str, os.PathLike] = None,\n            report_set_resource_error: bool = False,\n    ):\n        \"\"\"\n        This method sets up the required environment variables and resource limits for Gaussian 16.\n        Args:\n            g16root (Union[str, os.PathLike]): The path to the Gaussian 16 root directory.\n            path_gjf: the path of input script to be written and read\n            path_log: the path of output result to be written and read\n            path_err: the path of  error message to be written\n            report_set_resource_error: Whether to report the errors when set the environments and resource\n\n        Keyword Args:\n            this could give any arguments for GaussErrorHandle\n\n        Raises:\n            TypeError: If `g16root` is not a string or a path-like object.\n        \"\"\"\n        self.g16root = Path(g16root)\n\n        # Configure running environments and resources\n        self.envs = self._set_environs()\n        self._set_resource_limits(report_set_resource_error)\n\n        # the default running input and output file\n        self.p_input = Path('input.gjf') if not path_gjf else Path(path_gjf)\n        self.p_output = Path('output.log') if not path_log else Path(path_log)\n        self.p_err = Path(path_err) if path_err else None\n\n        # preserve for storing running data\n        self.path_chk = None\n        self.path_rwf = None\n\n        self.parsed_input = None\n        self.g16process = None  # to link to the g16 subprocess\n\n        self.output = None\n        self.stdout = None\n        self.stderr = None\n\n    @staticmethod\n    def _parse_route(route: str) -> Dict:\n        \"\"\" Parse the route of gjf file \"\"\"\n        # compile regular expressions\n        parenthesis = re.compile(r'\\(.+\\)')\n\n        # Normalize the input route\n        route = re.sub(r'\\s*=\\s*', r'=', route)  # Omit the whitespace surround with the equal signal\n        route = re.sub(r'=\\(', r'\\(', route)  # Omit the equal signal before the opening parenthesis\n        route = re.sub(r'\\s+', ' ', route)  # Reduce the multiply whitespace to one\n\n        # Replace the delimiter outside the parenthesis to whitespace, inside to common\n        in_parenthesis = {m.start(): m.end() for m in parenthesis.finditer(route)}\n        list_route = []\n        for i, char in enumerate(route):\n            if char in [',', '\\t', '/', ' ']:\n                if any(si < i < ei for si, ei in in_parenthesis.items()):\n                    list_route.append(',')\n                else:\n                    list_route.append(' ')\n            else:\n                list_route.append(char)\n\n        route = ''.join(list_route)\n\n        # Separate route to items\n        items = route.split()\n\n        parsed_route = {}\n        for item in items:\n            opening_parenthesis = re.findall(r'\\(', item)\n            closing_parenthesis = re.findall(r'\\)', item)\n\n            if opening_parenthesis:\n                assert len(opening_parenthesis) == 1 and len(closing_parenthesis) == 1 and item[-1] == ')'\n                kword = item[:item.index('(')]\n                options = item[item.index('(') + 1:-1]\n\n                opt_dict = parsed_route.setdefault(kword, {})\n                for option in options.split(','):\n                    opt_value = option.split('=')\n                    if len(opt_value) == 1:\n                        opt_dict[opt_value[0]] = None\n                    elif len(opt_value) == 2:\n                        opt_dict[opt_value[0]] = opt_value[1]\n                    else:\n                        raise ValueError('the given route string is wrong!!')\n\n            else:\n                kword_opt_value = item.split('=')\n                if len(kword_opt_value) == 1:\n                    parsed_route[kword_opt_value[0]] = None\n                elif len(kword_opt_value) == 2:\n                    parsed_route[kword_opt_value[0]] = kword_opt_value[1]\n                elif len(kword_opt_value) == 3:\n                    parsed_route[kword_opt_value[0]] = {kword_opt_value[1]: kword_opt_value[2]}\n                else:\n                    raise ValueError('the given route string is wrong!!')\n\n        return parsed_route\n\n    def _parse_input_script(self, script: str) -> dict:\n        \"\"\" Parse the input script to dict \"\"\"\n        lines = script.splitlines()\n        c = 0  # count of current line\n\n        info = {}\n\n        # Extract link0\n        link0 = []\n        while lines[c][0] == '%':\n            link0.append(lines[c])\n            c += 1\n\n        # Check link0\n        if not link0:\n            raise ValueError('the provided input script is incorrect, not found link0 lines')\n\n        # Parse link0\n        link0 = ' '.join(link0)\n        parsed_link0 = info.setdefault('link0', {})\n        for l0 in link0.split():\n            assert l0[0] == '%'\n            cmd_value = l0[1:].split('=')\n            if len(cmd_value) == 1:\n                parsed_link0[cmd_value[0]] = None\n            elif len(cmd_value) == 2:\n                parsed_link0[cmd_value[0]] = cmd_value[1]\n            else:\n                raise ValueError(\"can't parse the link0, the give input script might wrong!!\")\n\n        # Extract route\n        route = []\n        while lines[c] and lines[c][0] == '#':\n            route.append(lines[c][2:])\n            c += 1\n\n        if not route:\n            raise ValueError('the provided input script is incorrect, not found route lines')\n\n        # Parse the route\n        route = ' '.join(route)\n        info['route'] = self._parse_route(route)\n\n        # Extract the title line\n        c += 1  # skip the blank line\n        if lines[c]:\n            info['title'] = lines[c]\n        else:\n            raise ValueError('the provided input script is incorrect, not found title lines')\n        c += 2  # skip the blank line\n\n        # Extract the molecular specification\n        # Extract the charge and spin\n        charge, spin = map(int, lines[c].strip().split())\n        info['charge'], info['spin'] = charge, spin\n        c += 1\n\n        # Extract the atoms information\n        atoms, coordinates = [], []\n        while lines[c].strip():\n            atom_line: list[str] = lines[c].strip().split()\n            atom = atom_line[0]\n            xyz = list(map(float, atom_line[1:4]))\n\n            atoms.append(atom)\n            coordinates.append(xyz)\n\n            c += 1\n\n        info['atoms'] = atoms\n        info['coordinates'] = np.array(coordinates)\n\n        # Extract other info\n        i = 0\n        while c < len(lines):\n            other = info.setdefault(f'other_{i}', [])\n            if lines[c].strip():\n                other.append(lines[c])\n            elif other:\n                i += 1\n\n            c += 1\n\n        return info\n\n    def _rewrite_input_script(self):\n        \"\"\"\"\"\"\n        # Whether the input info have been given\u3002\n        if not self.parsed_input:\n            raise AttributeError(\n                \"Can't find the structured input data, the input script should be given by string script or parsed dict\"\n            )\n\n        info = self.parsed_input\n        script = \"\"\n\n        # Link0 commands\n        link0: dict = info['link0']\n        for cmd, value in link0.items():\n            if value:\n                script += f'%{cmd}={value}\\n'\n            else:\n                script += f'%{cmd}\\n'\n\n        # Route keywords\n        script += '#'\n        route: dict = info['route']\n        for kw, opt in route.items():\n            if not opt:\n                script += f' {kw}'\n            elif isinstance(opt, str):\n                script += f' {kw}={opt}'\n            elif isinstance(opt, dict):\n                list_opt = []\n                for k, v in opt.items():\n                    if v:\n                        list_opt.append(f'{k}={v}')\n                    else:\n                        list_opt.append(k)\n                script += f' {kw}(' + ','.join(list_opt) + ')'\n            else:\n                ValueError('the give gjf input info is wrong')\n\n        script += '\\n\\n'\n\n        # Title\n        script += info['title']\n        script += '\\n\\n'\n\n        # Charge and spin\n        script += f\"{info['charge']} {info['spin']}\\n\"\n\n        # Atoms specification\n        assert len(info['atoms']) == len(info['coordinates'])\n        for atom, xyz in zip(info['atoms'], info['coordinates']):\n            x, y, z = xyz\n            script += f'{atom} {x} {y} {z}\\n'\n\n        script += '\\n'\n\n        # Other contents\n        i = 0\n        while True:\n            other = info.get(f'other_{i}')\n            if other:\n                script += '\\n'.join(other)\n            else:\n                break\n\n        script += '\\n\\n'\n\n        return script\n\n    def _set_environs(self):\n        \"\"\"\n        Sets up the environment variables required for running Gaussian 16.\n\n        This method sets the environment variables required for Gaussian 16 to function correctly. If the\n        `g16root` attribute is not set, the method sets it to the user's home directory.\n\n        Returns:\n            Dict[str, str]: A dictionary of the updated environment variables.\n        \"\"\"\n\n        if self.g16root:\n            g16root = str(self.g16root)\n        else:\n            g16root = os.path.expanduser(\"~\")\n\n        GAUOPEN = f'{g16root}:gauopen'\n        GAUSS_EXEDIR = f'{g16root}/g16/bsd:{g16root}/g16'\n        GAUSS_LEXEDIR = f\"{g16root}/g16/linda-exe\"\n        GAUSS_ARCHDIR = f\"{g16root}/g16/arch\"\n        GAUSS_BSDDIR = f\"{g16root}/g16/bsd\"\n        GV_DIR = f\"{g16root}/gv\"\n\n        PATH = os.environ.get('PATH')\n        if PATH:\n            PATH = f'{PATH}:{GAUOPEN}:{GAUSS_EXEDIR}'\n        else:\n            PATH = f'{GAUOPEN}:{GAUSS_EXEDIR}'\n\n        PERLLIB = os.environ.get('PERLLIB')\n        if PERLLIB:\n            PERLLIB = f'{PERLLIB}:{GAUOPEN}:{GAUSS_EXEDIR}'\n        else:\n            PERLLIB = f'{GAUOPEN}:{GAUSS_EXEDIR}'\n\n        PYTHONPATH = os.environ.get('PYTHONPATH')\n        if PYTHONPATH:\n            PYTHONPATH = f'{PYTHONPATH}:{GAUOPEN}:{GAUSS_EXEDIR}'\n        else:\n            PYTHONPATH = f'{PYTHONPATH}:{GAUSS_EXEDIR}'\n\n        _DSM_BARRIER = \"SHM\"\n        LD_LIBRARY64_PATH = None\n        LD_LIBRARY_PATH = None\n        if os.environ.get('LD_LIBRARY64_PATH'):\n            LD_LIBRARY64_PATH = f\"{GAUSS_EXEDIR}:{GV_DIR}/lib:{os.environ['LD_LIBRARY64_PATH']}\"\n        elif os.environ.get('LD_LIBRARY64_PATH'):\n            LD_LIBRARY_PATH = f\"{GAUSS_EXEDIR}:{os.environ['LD_LIBRARY_PATH']}:{GV_DIR}/lib\"\n        else:\n            LD_LIBRARY_PATH = f\"{GAUSS_EXEDIR}:{GV_DIR}/lib\"\n\n        G16BASIS = f'{g16root}/g16/basis'\n        PGI_TEAM = f'trace,abort'\n\n        env_vars = {\n            'g16root': g16root,\n            'GAUSS_EXEDIR': GAUSS_EXEDIR,\n            'GAUSS_LEXEDIR': GAUSS_LEXEDIR,\n            'GAUSS_ARCHDIR': GAUSS_ARCHDIR,\n            'GAUSS_BSDDIR': GAUSS_BSDDIR,\n            'GV_DIR': GV_DIR,\n            'PATH': PATH,\n            'PERLLIB': PERLLIB,\n            'PYTHONPATH': PYTHONPATH,\n            '_DSM_BARRIER': _DSM_BARRIER,\n            'LD_LIBRARY64_PATH': LD_LIBRARY64_PATH,\n            'LD_LIBRARY_PATH': LD_LIBRARY_PATH,\n            'G16BASIS': G16BASIS,\n            'PGI_TERM': PGI_TEAM\n        }\n        env_vars = {n: v for n, v in env_vars.items() if v is not None}\n\n        # Merge the environment variables with the current environment\n        updated_env = os.environ.copy()\n        updated_env.update(env_vars)\n\n        return updated_env\n\n    @staticmethod\n    def _set_resource_limits(report_error: bool):\n        \"\"\"Sets resource limits for the Gaussian 16 process to avoid system crashes.\n\n        This method sets resource limits for the Gaussian 16 process to avoid system crashes. Specifically,\n        it sets the limits for the following resources: core dump size, data segment size, file size,\n        locked-in-memory address space, resident set size, number of open files, stack size, CPU time,\n        and number of processes.\n        \"\"\"\n        try:\n            resource.setrlimit(resource.RLIMIT_CORE, (0, 0))\n        except ValueError:\n            if report_error:\n                print(RuntimeWarning('Unable to raise the RLIMIT_CORE limit.'))\n\n        try:\n            resource.setrlimit(resource.RLIMIT_DATA, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))\n        except ValueError:\n            if report_error:\n                print(RuntimeWarning('Unable to raise the RLIMIT_DATA limit.'))\n\n        try:\n            resource.setrlimit(resource.RLIMIT_FSIZE, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))\n        except ValueError:\n            if report_error:\n                print(RuntimeWarning('Unable to raise the RLIMIT_FSIZE limit.'))\n\n        try:\n            resource.setrlimit(resource.RLIMIT_MEMLOCK, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))\n        except ValueError:\n            if report_error:\n                print(RuntimeWarning('Unable to raise the RLIMIT_MEMLOCK limit.'))\n\n        try:\n            resource.setrlimit(resource.RLIMIT_RSS, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))\n        except ValueError:\n            if report_error:\n                print(RuntimeWarning('Unable to raise the RLIMIT_RSS limit.'))\n\n        try:\n            resource.setrlimit(resource.RLIMIT_NOFILE, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))\n        except ValueError:\n            if report_error:\n                print(RuntimeWarning('Unable to raise the RLIMIT_NOFILE limit.'))\n\n        try:\n            resource.setrlimit(resource.RLIMIT_STACK, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))\n        except ValueError:\n            if report_error:\n                print(RuntimeWarning('Unable to raise the RLIMIT_STACK limit.'))\n\n        try:\n            resource.setrlimit(resource.RLIMIT_CPU, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))\n        except ValueError:\n            if report_error:\n                print(RuntimeWarning('Unable to raise the RLIMIT_CPU limit.'))\n\n        try:\n            resource.setrlimit(resource.RLIMIT_NPROC, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))\n        except ValueError:\n            if report_error:\n                print(RuntimeWarning('Unable to raise the RLIMIT_NPROC limit.'))\n\n    def full_option_values(self, title: str, kwd: str = None, op: Any = None, value: Optional = None):\n        \"\"\"\n        Full the value to gauss parsed_input dict\n        Args:\n            title: the first level of parsed input, like: 'link0', 'route', 'title', 'charge', 'spin', ...\n            kwd:\n            op:\n            value:\n\n        Returns:\n\n        \"\"\"\n        option_values = self.parsed_input[title].get(kwd)\n\n        if option_values is None:\n            if value is None:\n                self.parsed_input[title][kwd] = op  # Note: the op could be None, it's allowed\n            else:\n                self.parsed_input[title][kwd] = {op: value}\n\n        elif isinstance(option_values, dict):\n            self.parsed_input[title][kwd].update({op: value})\n\n        else:\n            self.parsed_input[title][kwd] = {option_values: None, op: value}\n\n    def molecule_setter_dict(self) -> dict:\n        \"\"\" Prepare the property dict for Molecule setters \"\"\"\n        data = self.parse_log()\n        return {\n            'atoms.partial_charge': data.atomcharges['mulliken'],\n            'energy': data.scfenergies[-1],\n            'spin': data.mult,\n            'charge': data.charge,\n            'mol_orbital_energies': data.moenergies,  # eV,\n            'coordinates': data.atomcoords[-1]\n        }\n\n    def parse_log(self):\n        \"\"\" Parse the gaussian log file and save them into self \"\"\"\n        string_buffer = io.StringIO(self.stdout)\n        return cclib.ccopen(string_buffer).parse()\n\n    def run(self, script: str = None):\n        \"\"\"Runs the Gaussian 16 process with the given script and additional arguments.\n\n        This method sets up the required environment variables and resource limits for Gaussian 16 before\n        running the process using `subprocess.Popen`. It takes an input script and any additional arguments\n        to pass to `Popen`, and returns a tuple of the standard output and standard error of the process.\n\n        Args:\n            script (str): The input script for the Gaussian 16 process.\n        Returns\n            Tuple[str, str]: A tuple of the standard output and standard error of the process\n        \"\"\"\n        if script:\n            self.parsed_input = self._parse_input_script(script)  # parse input data\n\n        script = self._rewrite_input_script()\n\n        with open(self.p_input, 'w') as writer:\n            writer.write(script)\n\n        # Run Gaussian using subprocess\n        self.g16process = subprocess.Popen(\n            ['g16', str(self.p_input), str(self.p_output)],\n            bufsize=-1, stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n            env=self.envs, universal_newlines=True\n        )\n        self.stdout, self.stderr = self.g16process.communicate()\n\n        if not self.stdout:\n            with open(self.p_output) as file:\n                self.stdout = file.read()\n\n        self.output = GaussOut(self.stdout, self.stderr)\n\n    def to_conformer(self, cfm_idx=-1, fail_raise=False):\n        \"\"\"\n        read the conformers from stdout, and convert the initial conformer in the input.gjf file to be specific one\n        Args:\n            cfm_idx: which conformer in the stdout is converted to the input file, default: last conformer(-1)\n            fail_raise: whether to raise error, if fail to convert to the specific conformer.\n             the error might be caused by the format of stdout is unreadable for Molecule class\n        \"\"\"\n        if not self.stdout:\n            raise AttributeError('the stdout do not save any conformers')\n\n        # If success, optimize with ses surface from the last conformer\n        from hotpot.cheminfo import Molecule\n        mol = Molecule.read_from(self.stdout, 'g16log', force=True)\n\n        try:\n            self.parsed_input['coordinates'] = mol.all_coordinates[-cfm_idx]\n            self.parsed_input['atoms'] = [a.label for a in mol.atoms]\n\n        except AttributeError:\n            if fail_raise:\n                raise RuntimeError('Fail to convert the conformers, the stdout might be unreadable!')\n            else:\n                print(RuntimeWarning('Fail to convert the conformers, the stdout might be unreadable!'))\n\n        except IndexError as err:\n            if fail_raise:\n                raise err\n            else:\n                print(err)", "\n\nclass GaussRun:\n    \"\"\" Run the Gaussian program \"\"\"\n    def __init__(self, gauss: Gaussian, debugger: Optional[Union[str, \"Debugger\"]] = 'auto', **kwargs):\n        self.gauss = gauss\n\n        self.stdout = []\n        self.stderr = []\n\n        # Configure Error Handle\n        if debugger is None:\n            self.debugger = None\n\n        elif isinstance(debugger, str):\n            kwargs['max_try'] = kwargs.get('max_try', 2)\n\n            if debugger == 'auto':\n                self.debugger = AutoDebug()\n            elif debugger == 'restart':\n                self.debugger = Restart(**kwargs)\n            elif debugger == 'last_conformer':\n                self.debugger = RerunFromLastConformer(**kwargs)\n            else:\n                raise ValueError(f\"can't find error handle name {debugger}\")\n\n        elif isinstance(debugger, Debugger):\n            self.debugger = debugger\n\n        else:\n            raise TypeError('the given error handle should be str or a GaussErrorHandle type')\n\n    def __call__(self, script=None, max_debug=5):\n        \"\"\"\"\"\"\n        self.gauss.run(script)\n\n        run_time = 0\n        while self.gauss.stderr and run_time < max_debug:\n            if self.debugger and self.debugger(self.gauss):\n\n                self.stdout.append(self.gauss.stdout)\n                self.stderr.append(self.gauss.stderr)\n\n                self.gauss.run()\n\n                if self.gauss.stderr:\n                    print(f\"Fail to debug with error: {self.gauss.output.error_link}!!!\")\n                else:\n                    print(\"Debug Successful!!!\")\n\n                run_time += 1\n\n            else:\n                break\n\n        # Report the results\n        if self.gauss.stderr:\n            print(f\"Terminate {self.gauss.parsed_input['title']} Gaussian with {self.gauss.output.error_link} Error!!!\")\n        else:\n            print(f\"Normalize Complete {self.gauss.parsed_input['title']} Gaussian Calculation !!!\")\n\n        return self.gauss", "\n\n# Error Handles\nclass Debugger(ABC):\n    \"\"\" Basic class to handle the error release from gaussian16 \"\"\"\n\n    def __call__(self, gauss: Gaussian) -> bool:\n        \"\"\" Call for handle the g16 errors \"\"\"\n        if self.trigger(gauss):\n            self.notice()\n            self.handle(gauss)\n            return True\n\n        return False\n\n    @staticmethod\n    def _find_keyword_name(target: dict, shortest: str) -> Union[None, str]:\n        \"\"\"\n        Find the input keyword by their allowed shortest name.\n        For example:\n            the shortest name `optimization` in route is `opt`, so any keyword from the `opt` to `optimization`\n            are allowed. In the input script, the user might give any one of the allowed keyword, such as `opt`,\n            `optimiz` or `optimizati`, this method will find the real user-given keyword by `opt`.\n        Args:\n            target(dict): the subitem of parsed_input, like: link0, route.\n            shortest: the shortest name, say `opt`\n\n        Returns:\n            the actual user-given keyword\n        \"\"\"\n        searcher = re.compile(f\"{shortest}.*\", re.IGNORECASE)\n\n        kwd_name = None\n        for name in target:\n            match = searcher.fullmatch(name)\n            if match:\n                kwd_name = match.string[match.start():match.end()]\n                break\n\n        return kwd_name\n\n    @abstractmethod\n    def trigger(self, gauss: Gaussian) -> bool:\n        \"\"\" Could the ErrorHandle is suitable for this error \"\"\"\n\n    @abstractmethod\n    def handle(self, gauss: Gaussian):\n        \"\"\" Specified by the children classes \"\"\"\n\n    def notice(self):\n        print(f'Gauss Debug by {self.__class__.__name__}')", "\n\nclass AutoDebug(Debugger, ABC):\n    \"\"\" AutoHandle Gaussian Error \"\"\"\n    _handles = {}\n\n    def __init__(self, *selected_method: str, invert=False):\n        if not selected_method:\n            self.handles = {name: handle() for name, handle in self._handles.items()}\n        else:\n            if invert:\n                self.handles = {name: handle() for name, handle in self._handles.items() if name not in selected_method}\n            else:\n                self.handles = {name: handle() for name, handle in self._handles.items() if name in selected_method}\n\n        self.applied_handle_name = None\n\n    @classmethod\n    def register(cls, handle_type: type):\n        cls._handles[handle_type.__name__] = handle_type\n        return handle_type\n\n    def trigger(self, gauss: Gaussian) -> bool:\n        for name, handle in self.handles.items():\n            if handle.trigger(gauss):\n                self.applied_handle_name = name\n                return True\n\n        return False\n\n    def handle(self, gauss: Gaussian):\n        handle = self.handles[self.applied_handle_name]\n        handle(gauss)", "\n\n@AutoDebug.register\nclass Ignore(Debugger, ABC):\n    \"\"\"\n    To handle the optimization can't fall into the optimal point which a tiny imaginary frequency.\n\n    The optimization tasks might be hard to converge for certain reasons.\n    In especial, the Minnesota functional(like M062X) might oscillate near the optimal point with imaginary frequency.\n\n    There are some complicated method to solve this problem. However, If someone discovers that during the final stage\n    of optimization, the molecules are only making slight vibrations around a certain equilibrium point, it would be\n    more direct to ignore this error because the final configuration is likely not far from the optimal configuration.\n\n    Trigger:\n        task: optimization\n        method: unspecific\n        basis: unspecific\n        keywords: unspecific\n        error_link: l9999\n        message: -- Number of steps exceeded,\n        other:\n            Among last 10% opti steps, Max(|E(N)-E(N-1)|) < 0.05 eV and Min(|E(N)-E(N-1)|) / Max(|E(N)-E(N-1)|) > 0.9\n            where, the E(N) is the electron energy at the N opti step.\n\n    Handle:\n        ignore this error and continue the next work.\n    \"\"\"\n    def trigger(self, gauss: Gaussian) -> bool:\n        if gauss.output.is_opti_convergence_error:\n            from hotpot.cheminfo import Molecule\n            mol = Molecule.read_from(gauss.stdout, fmt='g16log')\n\n            if not mol:\n                raise IOError('the stdout cannot parse to Molecule object')\n\n            last_energies = mol.all_energy[-int(len(mol.all_energy)):]\n            diff_energies = np.abs(last_energies[1:] - last_energies[:-1])\n\n            if diff_energies.max() < 0.05 and diff_energies.min() / diff_energies.max() > 0.9:\n                return True\n\n            return False\n\n    def handle(self, gauss: Gaussian):\n        \"\"\" Continue the next work and save the calculation data \"\"\"", "\n\n@AutoDebug.register\nclass ReOptiWithSASSurfaceSCRF(Debugger, ABC):\n    \"\"\"\n    This Handle for the optimization task in solvent, when some tiny molecular cages are formed.\n    In this case, the default vdW surface overestimate the accessible surface inside the cages,\n    and cause inverse PCM matrix the non-convergent.\n\n    To handle the error, the Gaussian will re-optimize the molecule with SAS surface first and\n    optimize with SES surface finally.\n\n    Trigger:\n        task: optimization\n        methods: unspecified\n        basis: unspecified\n        keywords: SCRF\n        error_link: l502, l508\n        message: Inv3 failed in PCMMkU.\n\n    Handle:\n        rerun the optimization with SAS and SES surfaces serially\n    \"\"\"\n    def trigger(self, gauss: Gaussian) -> bool:\n        if gauss.output.is_scrf_Vdw_cage_error and \\\n          all(self._find_keyword_name(gauss.parsed_input['route'], kwd) for kwd in ('opt', 'scrf')):\n            return True\n\n        return False\n\n    def handle(self, gauss: Gaussian):\n        route = gauss.parsed_input['route']\n\n        scrf_name = self._find_keyword_name(route, 'scrf')\n\n        gauss.full_option_values('route', scrf_name, 'smd')\n        gauss.full_option_values('route', scrf_name, 'read')\n\n        # convert the last conformer to the input script\n        gauss.to_conformer()\n\n        # the other items in the end of input script, add sas surface\n        max_other = max(map(int, [t.split('_')[1] for t in gauss.parsed_input if 'other_' in t]))\n        new_other = f\"other_{max_other+1}\"\n        gauss.parsed_input[new_other] = 'surface=sas'\n\n        # optimize with sas surface first\n        gauss.run()\n        # if the optimization is unsuccessful, terminate\n        if gauss.stderr:\n            print('Fail to optimize in SAS surface!!!')\n            return None\n\n        gauss.to_conformer()\n        gauss.parsed_input[new_other] = 'surface=ses AddSph'", "\n\n@AutoDebug.register\nclass ReOptiByCartesian(Debugger, ABC):\n    \"\"\" \"\"\"\n    def trigger(self, gauss: Gaussian) -> bool:\n        # If the error is ZMatrix trouble and the original task is optimization\n        return gauss.output.is_ZMatrix_error and self._find_keyword_name(gauss.parsed_input['route'], 'opt')\n\n    def handle(self, gauss: Gaussian):\n        route = gauss.parsed_input['route']\n        opt_name = self._find_keyword_name(route, 'opt')\n\n        gauss.full_option_values('route', opt_name, \"Cartesian\")", "\n\n@AutoDebug.register\nclass Restart(Debugger, ABC):\n    \"\"\" Handle Gaussian error by Restart \"\"\"\n    def trigger(self, gauss: Gaussian) -> bool:\n        if gauss.output.is_hangup_error:\n            return True\n\n        return False\n\n    def handle(self, gauss: Gaussian):\n        route = gauss.parsed_input['route']\n        opt_name = self._find_keyword_name(route, 'opt')  # Get the actual user-give keyword for optimization\n\n        gauss.full_option_values('route', opt_name, 'Restart')", "\n\n@AutoDebug.register\nclass RerunFromLastConformer(Debugger, ABC):\n    \"\"\" Handle the error by rerun the Gaussian from the last conformer \"\"\"\n    def trigger(self, gauss: Gaussian) -> bool:\n        return True\n\n    def handle(self, gauss: Gaussian):\n        gauss.to_conformer()  # convert to the last conformer in the stdout", ""]}
{"filename": "hotpot/tanks/qm/__init__.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : __init__.py\n@Auther : Zhiyuan Zhang\n@Data   : 2023/7/19\n@Time   : 2:28\n\"\"\"\n", ""]}
{"filename": "hotpot/tanks/lmp/materials.py", "chunked_list": ["\"\"\"\npython v3.7.9\n@Project: hotpot\n@File   : materials.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/4/26\n@Time   : 1:50\nNotes:\n    This package is to perform some specific tasks base on the LAMMPS\n\"\"\"", "    This package is to perform some specific tasks base on the LAMMPS\n\"\"\"\nimport os\nimport os.path as osp\nfrom os.path import join as ptj\nfrom typing import *\nimport random\nimport numpy as np\nfrom scipy import spatial\nimport openbabel.openbabel as ob", "from scipy import spatial\nimport openbabel.openbabel as ob\nimport hotpot\nimport hotpot.cheminfo as ci\n\n\ndir_force_field = osp.abspath(ptj(hotpot.data_root, 'force_field'))\n\n# Constants\navogadro = 6.02214076e23  # Avogadro numbers", "# Constants\navogadro = 6.02214076e23  # Avogadro numbers\nangstrom = 1e-8  # cm\n\n\nclass AmorphousMaker:\n    \"\"\" To make Amorphous Materials \"\"\"\n    def __init__(\n            self,\n            element_composition: Dict[str, float],\n            force_field: Union[str, os.PathLike],\n            density: float = 1.0,  # g/cm^3\n            a: float = 25., b: float = 25., c: float = 25.,\n            alpha: float = 90., beta: float = 90., gamma: float = 90.,\n    ):\n        \"\"\"\"\"\"\n        # Check the arguments\n        # Determine the path of force field.\n        if isinstance(force_field, os.PathLike):\n            pff = str(force_field)\n        elif osp.exists(force_field):\n            pff = force_field\n        else:\n            pff = ptj(dir_force_field, force_field)\n\n        # Make sure the existence of force field file\n        if not osp.exists(pff):\n            raise FileNotFoundError('the given force field file is not found!')\n\n        pff = osp.abspath(pff)\n\n        # assign attrs\n        sum_freq = sum(f for f in element_composition.values())\n        self.elements = {e: f/sum_freq for e, f in element_composition.items()}  # Normalize the elements' frequency\n        self.path_force_field = pff\n        self.density = density * 1.123592147466166\n        self.cryst_params = (a, b, c, alpha, beta, gamma)\n\n    @staticmethod\n    def calc_cryst_density(cryst):\n        \"\"\" Calculation the density for Crystal object \"\"\"\n        return (cryst.molecule.weight * avogadro) / (cryst.volume * angstrom ** 3)  # Density, g/cm^3\n\n    @staticmethod\n    def _density2atom_numbers(ratio_elements: dict, density: float, cryst):\n        \"\"\"\n        Calculate the round atom numbers in a crystal.\n        Args:\n            ratio_elements: Ratio of elements in the crystal\n            density: the demand density in the crystal\n            cryst: the crystal\n\n        Returns:\n            int, the number of atoms\n        \"\"\"\n        # Convert the dict of elements and possibility to numpy array\n        elements = np.array(list(ratio_elements.keys()))\n        possibility = np.array(list(ratio_elements.values()))\n        possibility = possibility / possibility.sum()  # Normalize\n\n        average_mol_mass = sum(ob.GetMass(ob.GetAtomicNum(e)) * p for e, p in zip(elements, possibility))\n\n        # Terms:       [Mole in Crystal(Total Mass in Crystal (gram)/Average Mole Mass)]/Avogadro Number\n        # Units:           g/cm^3     angstrom^3  angstrom/cm             g/mol             _\n        num_atom = round(((density * (cryst.volume * angstrom ** 3)) / average_mol_mass) * avogadro)\n\n        # calculate the fraction coordinates in the crystal cell\n        fraction_coordinates = np.array([np.random.uniform(size=3) for _ in range(num_atom)])\n\n        # the actual coordinates in the cartesian coordinates\n        cartesian_coordinates = np.matmul(cryst.vector, fraction_coordinates.T).T\n\n        distance_matrix = spatial.distance_matrix(cartesian_coordinates, cartesian_coordinates)\n        distance_matrix = np.tril(distance_matrix, k=-1)\n        distance_matrix[distance_matrix > 0.5] = 0\n\n        # loose the closing points\n        try_number = 0\n        while distance_matrix.any() and try_number < 100:\n            points1_idx, points2_idx = rows, cols = distance_matrix.nonzero()\n\n            points1_coords = cartesian_coordinates[points1_idx]\n            points2_coords = cartesian_coordinates[points2_idx]\n\n            vector12 = points2_coords - points1_coords\n\n            e12 = vector12/np.tile(np.linalg.norm(vector12, axis=1).reshape(-1, 1), 3)\n            scalar_displace = np.tile((0.51-np.linalg.norm(vector12, axis=1)).reshape(-1, 1)/2, 3)\n\n            displacement12 = e12 * scalar_displace\n            displacement21 = -displacement12\n\n            cartesian_coordinates[points1_idx] += displacement21\n            cartesian_coordinates[points2_idx] += displacement12\n\n            distance_matrix = spatial.distance_matrix(cartesian_coordinates, cartesian_coordinates)\n            distance_matrix = np.tril(distance_matrix, k=-1)\n            distance_matrix[distance_matrix > 0.5] = 0\n\n            try_number += 1\n\n        atomic_symbols = np.random.choice(elements, num_atom, p=possibility)\n        atomic_numbers = np.array([ob.GetAtomicNum(symbol) for symbol in atomic_symbols])\n\n        return atomic_numbers, cartesian_coordinates\n\n    def load_atoms(self):\n        mol = ci.Molecule()\n        mol.make_crystal(*self.cryst_params)\n\n        cryst = mol.crystal()\n        atomic_number, coordinates = self._density2atom_numbers(\n            self.elements, self.density, cryst\n        )\n\n        mol.quick_build_atoms(atomic_number)\n        mol.set(all_coordinates=coordinates.reshape((-1, len(coordinates), 3)))\n\n        mol.conformer_select(0)\n\n        return mol\n\n    def melt_quench(\n            self, *ff_args, mol=None, path_writefile: Optional[str] = None,\n            origin_temp: float = 298.15, melt_temp: float = 4000., highest_temp: float = 10000,\n            time_step: float = 0.0001, path_dump_to: Optional[str] = None, dump_every: int = 100,\n    ):\n        \"\"\"\n        Perform melt-quench process to manufacture a amorphous materials\n        Args:\n            *ff_args: the arguments the force file requried, refering the LAMMPS pair_coeff:\n             \"pair_coeff I J args\" url: https://docs.lammps.org/pair_coeff.html\n            mol: the molecule to be performed melt-quench. if not given, initialize according to elemental\n             compositions\n            path_writefile: the path to write the final material (screenshot) to file, if not specify, not save.\n            origin_temp: the initial temperature before melt\n            melt_temp: the round melting point to the materials\n            highest_temp: the highest temperature to liquefy the materials\n            time_step: time interval between path integrals when performing melt-quench\n            path_dump_to: the path to save the trajectory of the melt-quench process, if not specify not save\n            dump_every: the step interval between each dumps\n        Returns:\n            Molecule obj after melt-quench.\n        \"\"\"\n        if not isinstance(mol, ci.Molecule):\n            mol = self.load_atoms()\n\n        mol.lmp_setup(units='metal')\n\n        # initialization\n        mol.lmp.commands_string(\n            \"\"\"\n            units metal\n            dimension 3\n            atom_style full\n            \"\"\"\n        )\n\n        # Read molecule into LAMMPS\n        mol.lmp.read_main_data()\n\n        # Configure the force field\n        mol.lmp(\"pair_style tersoff\")\n        mol.lmp(f\"pair_coeff * * {self.path_force_field} {' '.join(ff_args)}\")\n\n        # Specify the thermodynamical output to screen\n        mol.lmp('thermo_style    custom step temp pe etotal press vol density')\n        mol.lmp('thermo          1000')\n\n        # the step interval of integral\n        mol.lmp(f'timestep {time_step}')\n\n        # Specify the dump configuration\n        if path_dump_to:\n            dump_fmt = path_dump_to.split('.')[-1]  # the dump fmt is the suffix of file name\n            mol.lmp(f'dump mq all {dump_fmt} {dump_every} {path_dump_to}')\n            mol.lmp(f'dump_modify mq element {\" \".join(set(mol.atomic_symbols))}')\n\n        # Initialize the temperature for system\n        mol.lmp(f'velocity all create {origin_temp} {random.randint(100000, 999999)}')\n\n        # Melt\n        mol.lmp(f'fix 0 all nvt temp {origin_temp} {highest_temp} 0.7')\n        mol.lmp(f'run 10000')\n\n        mol.lmp(f'fix 0 all nvt temp {highest_temp} {highest_temp} 1000')\n        while mol.lmp.eval('temp') < highest_temp * 0.95:\n            mol.lmp(f'run 1000')\n\n        mol.lmp(f'run 10000')\n\n        # Relax\n        mol.lmp('thermo          250')\n        mol.lmp(f'fix 0 all nvt temp {melt_temp} {melt_temp} 1000.0')\n        while mol.lmp.eval('temp') > melt_temp * 1.05:\n            mol.lmp(f'velocity all scale {melt_temp}')\n            mol.lmp(f'run 2000')\n\n        mol.lmp('thermo          1000')\n        mol.lmp(f'run 20000')\n\n        # Quench\n        mol.lmp('thermo          250')\n        mol.lmp(f'fix 0 all nvt temp {origin_temp} {origin_temp} 1000.0')\n        while mol.lmp.eval('temp') > origin_temp*1.05:\n            mol.lmp(f'velocity all scale {(mol.lmp.eval(\"temp\") - origin_temp) / 2 + origin_temp}')\n            mol.lmp(f'run 2000')\n\n        if not path_writefile:\n            pwf = ptj(os.getcwd(), 'write_dump.xyz')\n            write_fmt = 'xyz'\n        else:\n            pwf = path_writefile\n            write_fmt = path_writefile.split('.')[-1]\n\n        mol.lmp(f'write_dump all {write_fmt} {pwf} modify element {\" \".join(set(mol.atomic_symbols))}')\n        made_mol = ci.Molecule.read_from(pwf)\n        if not path_writefile:\n            os.remove(pwf)\n\n        made_mol.create_crystal_by_matrix(mol.lmp.cryst_matrix)\n\n        return made_mol", "\n"]}
{"filename": "hotpot/tanks/lmp/gcmc.py", "chunked_list": ["\"\"\"\npython v3.7.9\n@Project: hotpot\n@File   : gcmc.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/4/30\n@Time   : 22:19\n\"\"\"\nimport json\nimport os", "import json\nimport os\nimport os.path as osp\nimport random\nfrom os.path import join as ptj\nfrom typing import *\nimport hotpot\n\ndir_force_field = osp.abspath(ptj(hotpot.data_root, 'force_field'))\n", "dir_force_field = osp.abspath(ptj(hotpot.data_root, 'force_field'))\n\n\nclass LjGCMC:\n    \"\"\" Performing Grand Canonical Monte Carlo Simulation by LAMMPS, based on LJ potential \"\"\"\n    def __init__(\n            self, frame: 'ci.Molecule', ff: Union[str, os.PathLike], *guests: 'ci.Molecule',\n            work_dir: Union[str, os.PathLike], **kwargs\n    ):\n        self._data = {\n            'frame': frame,\n            'guests': guests,\n            'work_dir': work_dir,\n            'pff': self._force_field_file(ff)  # the path of force field\n        }\n\n        # Preprocessing data\n        self._data.update(kwargs)\n        self._load_lj()  # Load force field\n        self._extract_type_map()\n\n    def _extract_type_map(self):\n        def ext_tm(mol: 'ci.Molecule', which):\n            atom_types_map = self._data.setdefault('atom_types_map', {})\n            atom_types = self._data.setdefault('atom_types', {})\n            list_atom_types = atom_types.setdefault(which, [])\n            for atom in mol.all_atoms_with_unique_symbol:\n                atom_type = len(atom_types_map) + 1\n                atom_types_map[atom_type] = atom\n                list_atom_types.append(atom_type)\n\n        ext_tm(self.frame, 'frame')\n        for guest in self.guests:\n            ext_tm(guest, 'guest')\n\n    def _fix_gcmc(self, lmp):\n        \"\"\"\"\"\"\n        T = self._data.get('T')  # temperature\n        P = self._data.get('P', 1.0)  # the ratio pressure to saturation pressure\n\n        for i, guest in enumerate(self.guests, 1):\n            guest.thermo_init(T=T)\n            phi_g = guest.thermo.phi_g  # the fugacity coefficient\n            P_sat = guest.thermo.Psat\n            lmp(\n                f'fix gcmc{i} gg{i} gcmc 1 $((20+abs(count(gg{i})-20))/2) $((20+abs(count(gg{i})-20))/2)'\n                f' 0 {random.randint(10000, 999999)} {T} 0 12.5 mol guest{i} fugacity_coeff {phi_g} pressure {P_sat * P}'\n            )\n\n    @staticmethod\n    def _force_field_file(ff: Union[str, os.PathLike]):\n        \"\"\" Retrieve the exact file path of force file \"\"\"\n\n        # If the force filed not be given, use the UFF as default.\n        if not ff:\n            ff = 'UFF/LJ.json'\n\n        # Check the arguments\n        # Determine the path of force field.\n        if isinstance(ff, os.PathLike):\n            pff = str(ff)\n        elif osp.exists(ff):\n            pff = ff\n        else:\n            pff = ptj(dir_force_field, ff)\n\n        # Make sure the existence of force field file\n        if not osp.exists(pff):\n            raise FileNotFoundError('the given force field file is not found!')\n\n        pff = osp.abspath(pff)\n\n        return pff\n\n    def _print_uptake(self, lmp):\n        \"\"\" print the guest uptake with guest(g)/framework(g) into file \"\"\"\n        data = '\"' + '$(step),' + ','.join(f'$(mass(gg{i})/mass(frame))' for i, _ in enumerate(self.guests, 1)) + '\"'\n        title = '\"' + 'step,' + ','.join(f'{g.smiles}(g/g)' for i, g in enumerate(self.guests, 1)) + '\"'\n\n        p_file = osp.abspath(ptj(self.work_dir, 'step_uptake.csv'))\n\n        cmd = f'fix uptake all print 1 {data} title {title} file {p_file} screen no'\n\n        lmp(cmd)\n\n    def _load_guest_mol(self, lmp):\n        \"\"\"\"\"\"\n        num_ft = len(self.frame_type_map)\n        num_fbt = len(self.frame.unique_bonds)  # the number of atom types in framework\n        num_gat = 0  # the number of atom types before current guest\n        num_gbt = 0  # the number of bond types before current guest\n        for i, guest in enumerate(self.guests, 1):\n            if self.work_dir:\n                p_guest_mol = osp.abspath(ptj(self.work_dir, f'guest{i}'))\n            else:\n                p_guest_mol = osp.abspath(f'guest{i}')\n\n            guest.writefile('lmpmol', p_guest_mol, retrieve_script=True, atom_style='metal')\n\n            lmp(f'molecule guest{i} {p_guest_mol} toff {num_ft+num_gat} boff {num_fbt + num_gbt}')\n            lmp(f'group gg{i} empty')  # Empty group to contain the molecule atoms insert by GCMC\n\n            num_gat += len(set(guest.atomic_symbols)) + len(set(pa.symbol for pa in guest.pseudo_atoms))\n            num_fbt += len(guest.unique_bond_pairs)\n\n    def _load_lj(self):\n        \"\"\" load force file from file \"\"\"\n        self._data['lj'] = json.load(open(self._data['pff']))\n\n    def _set_guest_mass(self, lmp: \"HpLammps\"):\n        for atom_type, atom in self.guest_type_map.items():\n            lmp(f'mass {atom_type} {atom.mass}  # {atom.symbol}')\n\n    def _set_lj_coeff(self, lmp: 'HpLammps'):\n        # the LJ cut off\n        lmp(f'pair_style lj/cut {self._data.get(\"cut\", 12.5)}')\n\n        # LJ coefficient for guest atoms\n        # atom: the atom or pseudo atom corresponding to the atom_type\n        # TODO: the coefficient of epsilon\n        for atom_type, atom in self.atom_types_map.items():\n            try:\n                eps = self.lj[atom.symbol][\"epsilon\"]\n                sigma = self.lj[atom.symbol][\"sigma\"]\n            except KeyError:\n                assert isinstance(atom, ci.PseudoAtom)\n                eps = atom.epsilon\n                sigma = atom.sigma\n\n            lmp(f'pair_coeff {atom_type} {atom_type} {eps * 0.001987} {sigma}')\n\n    @property\n    def atom_types_map(self) -> Dict[int, Union['ci.Atom', 'ci.PseudoAtom']]:\n        return self._data.get('atom_types_map')\n\n    @property\n    def frame_atom_types(self) -> List[int]:\n        return self._data.get('atom_types')['frame']\n\n    @property\n    def guest_atom_types(self) -> List[int]:\n        return self._data.get('atom_types')['guest']\n\n    @property\n    def frame(self):\n        return self._data.get('frame')\n\n    @property\n    def frame_type_map(self) -> Dict[int, Union['ci.Atom', 'ci.PseudoAtom']]:\n        \"\"\" Return the dict mapping from type_numbers to Atom or PseudoAtom objects in framework \"\"\"\n        return {t_num: atom for t_num, atom in self.atom_types_map.items() if t_num in self.frame_atom_types}\n\n    @property\n    def guest_type_map(self) -> Dict[int, Union['ci.Atom', 'ci.PseudoAtom']]:\n        \"\"\" Return the dict mapping from type_numbers to Atom or PseudoAtom objects in guests \"\"\"\n        return {t_num: atom for t_num, atom in self.atom_types_map.items() if t_num in self.guest_atom_types}\n\n    @property\n    def guests(self):\n        return self._data.get('guests')\n\n    @property\n    def lj(self):\n        \"\"\" Retrieve the lj potential saved in the class \"\"\"\n        return self._data.get('lj')\n\n    @property\n    def num_atom_types(self):\n        return len(self.atom_types_map)\n\n    @property\n    def num_frame_atom_types(self) -> int:\n        return len(self.frame_atom_types)\n\n    @property\n    def num_guest_atom_types(self) -> int:\n        return len(self.guest_atom_types)\n\n    def run(self):\n        self.frame.lmp_setup(work_dir=self.work_dir)\n        lmp = self.frame.lmp\n\n        # Initialization\n        lmp('units real')\n        lmp('dimension 3')\n        lmp('atom_style full')\n\n        # lmp('read_data /home/zz1/qyq/main.data group frame extra/atom/types 1')\n        lmp.read_main_data(\n            extra_atom_types=self.num_guest_atom_types,\n            extra_bond_types=sum([len(g.unique_bonds) for g in self.guests]),\n            group='frame'\n        )\n\n        self._set_guest_mass(lmp)\n\n        self._load_guest_mol(lmp)\n\n        self._set_lj_coeff(lmp)\n\n        # Keep the atom in frameworks in immobility\n        lmp('fix stand frame setforce 0.0 0.0 0.0')\n\n        self._fix_gcmc(lmp)\n\n        self._print_uptake(lmp)\n\n        # lmp('variable uptake equal mass(Igas)/mass(frame)')\n        # lmp('fix ave all ave/time 1 50 50 v_uptake file /home/zz1/qyq/ave')\n\n        lmp('thermo_style    custom step temp pe etotal press vol density')\n        lmp('thermo          1000')\n        lmp('compute_modify thermo_temp dynamic/dof yes')\n\n        dir_dump = osp.abspath(ptj(self.work_dir, \"dump.xyz\"))\n        lmp(f'dump mq all xyz 100 {dir_dump}')\n        lmp(f'dump_modify mq element ' + ', '.join(self.type_symbol_map))\n\n        lmp('timestep 0.0001')\n        lmp('run 15000')\n\n    @property\n    def type_symbol_map(self) -> List[str]:\n        return [atom.symbol for atom in self.atom_types_map.values()]\n\n    @property\n    def work_dir(self):\n        return self._data.get('work_dir', os.getcwd())", "\n\nimport hotpot.cheminfo as ci\nfrom hotpot.tanks.lmp.base import HpLammps\n"]}
{"filename": "hotpot/tanks/lmp/base.py", "chunked_list": ["\"\"\"\npython v3.7.9\n@Project: hotpot\n@File   : base.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/4/24\n@Time   : 3:43\n\"\"\"\nimport os\nimport re", "import os\nimport re\nfrom os.path import join as ptj\nimport json\n\nimport numpy as np\nfrom lammps import PyLammps, Atom\nfrom typing import *\nimport hotpot\n", "import hotpot\n\n\nclass HpLammps:\n    \"\"\"\n    A wrapper to run LAMMPS tasks\n    \"\"\"\n    def __init__(self, main, **kwargs):\n        \"\"\"\n\n        Args:\n            main: the main Molecule object\n\n        Keyword Args:\n            work_dir: the work dir, where the io operations are performed\n        \"\"\"\n        self._data = {\n            'main': main,\n            'pylmp': PyLammps()\n        }  # store any data\n        self._data.update(kwargs)\n\n    def __call__(self, cmd: str):\n        self.command(cmd)\n\n    # def __dir__(self) -> Iterable[str]:\n    #     return self.pylmp.__dir__() + [\"commands_list\", \"commands_string\", 'read_main_data', \"script\"]\n    #\n    # def __getattr__(self, item):\n    #     return self.pylmp.__getattr__(item)\n\n    def atom(self, idx: int):\n        \"\"\" retrieve the LAMMPS atom object by atom index \"\"\"\n        return Atom(self, idx)\n\n    @property\n    def atoms(self):\n        return [self.atom(i) for i in range(self.atom_number)]\n\n    @property\n    def atom_number(self):\n        return len(self.pylmp.atoms)\n\n    @property\n    def box(self):\n        return np.array([\n            [self.eval('xlo'), self.eval('xhi')],\n            [self.eval('ylo'), self.eval('yhi')],\n            [self.eval('zlo'), self.eval('zhi')]\n        ])\n\n    def close(self):\n        self.pylmp.close()\n        del self\n\n    def command(self, cmd: str):\n        self.pylmp.command(cmd)\n\n    def commands_list(self, list_cmd: List[str]):\n        for cmd in list_cmd:\n            self.command(cmd)\n\n    def commands_string(self, multicod: str):\n        cmd_list = multicod.split('\\n')\n        for cmd in cmd_list:\n            self.command(cmd.strip())\n\n    @property\n    def computes(self):\n        return self.pylmp.computes\n\n    @property\n    def cryst_matrix(self):\n        xl = self.eval('xhi')-self.eval('xlo')  # length of the crystal box in the x axis\n        yl = self.eval('xhi')-self.eval('xlo')  # length of the crystal box in the y axis\n        zl = self.eval('xhi')-self.eval('xlo')  # length of the crystal box in the z axis\n        xy = self.eval('xy')  # the project v_b to x axis\n        xz = self.eval('xz')  # the project v_c to x axis\n        yz = self.eval('yz')  # the project v_c to y axis\n        return np.array([[xl, 0., 0.], [xy, yl, 0.], [xz, yz, zl]])\n\n    def data_to_labelmap(self, script: str, offset: int = 0):\n        \"\"\" Convert the LAMMPS data format script (string) to labelmap dict \"\"\"\n        pattern = re.compile(r\"[A-Z].+s\")\n        data_body_headers = pattern.findall(script)\n        masses_idx = data_body_headers.index('Masses')\n        masses_body_contents: List[str] = pattern.split(script)[masses_idx+1].split('\\n')\n\n        type_map = self._data.setdefault('type_map', {})\n        for line in masses_body_contents:\n            line = line.strip()\n            if line:\n                type_num, _, _, type_label = line.split()\n                type_num = int(type_num) + offset  # offset\n                former_label = type_map.get(type_num)\n\n                if not former_label:  # if the atom type have not been recorded\n                    type_map[type_num] = type_label\n                else:\n                    # Never allow to change the type_map for defined atom type\n                    # if the current type label is different from the former, raise error\n                    # if the current type label is same with the former, keeping still.\n                    if former_label != type_label:\n                        raise RuntimeError(\n                            f'the the type_map for atom type {type_num} is attempt to change '\n                            f'from {former_label} to {type_label}, Never allowed!!'\n                        )\n\n        return type_map\n\n    @property\n    def dumps(self):\n        return self.pylmp.dumps\n\n    def eval(self, expr):\n        return self.pylmp.eval(expr)\n\n    @property\n    def fixes(self):\n        return self.pylmp.fixes\n\n    @property\n    def groups(self):\n        return self.pylmp.groups\n\n    def file(self, filepath: str):\n        self.pylmp.file(filepath)\n\n    @property\n    def lmp(self):\n        return self.pylmp.lmp\n\n    @property\n    def main(self):\n        return self._data.get('main')\n\n    @property\n    def pylmp(self):\n        return self._data.get('pylmp')\n\n    def read_main_data(\n            self, add: str = None, offset: Sequence[int] = (), shift: Sequence[int] = (),\n            extra_atom_types=0, extra_bond_types=0, extra_angle_types=0, extra_dihedral_types=0,\n            extra_improper_types=0, extra_bond_per_atom=0, extra_angle_per_atom=0, extra_dihedral_per_atom=0,\n            extra_improper_per_atom=0, extra_special_per_atom=0, group: str = None, nocoeff: bool = False,\n            fix: str = None\n    ):\n        \"\"\"\"\"\"\n        path_main_data = os.path.join(self.work_dir, 'main.data')\n\n        # to the main.data file\n        self.main.writefile('lmpdat', path_main_data, retrieve_script=False)\n        # self.data_to_labelmap(script, atom_offset)\n\n        # read to LAMMPS\n        cmd = f'read_data {path_main_data}'\n\n        # add keywords to specify the extra atoms\n        if add:\n            cmd += f' add {add}'\n        if offset:\n            assert len(offset) == 5\n            cmd += f' offset ' + ' '.join(offset)\n        if shift:\n            assert len(shift) == 3\n            cmd += f' shift ' + ' '.join(shift)\n        if extra_atom_types:\n            cmd += f' extra/atom/types {extra_atom_types}'\n        if extra_bond_types:\n            cmd += f' extra/bond/types {extra_bond_types}'\n        if extra_angle_types:\n            cmd += f' extra/angle/types {extra_angle_types}'\n        if extra_dihedral_types:\n            cmd += f' extra/dihedral_types {extra_dihedral_types}'\n        if extra_improper_types:\n            cmd += f' extra/improper/types {extra_improper_types}'\n        if extra_bond_per_atom:\n            cmd += f' extra/bond/per/atom {extra_bond_per_atom}'\n        if extra_angle_per_atom:\n            cmd += f' extra/angle/per/atom {extra_angle_per_atom}'\n        if extra_dihedral_per_atom:\n            cmd += f' extra/dihedral_per_atom {extra_dihedral_per_atom}'\n        if extra_improper_per_atom:\n            cmd += f' extra/improper/per/atom {extra_improper_per_atom}'\n        if extra_special_per_atom:\n            cmd += f' extra/special/per/atom {extra_special_per_atom}'\n        if group:\n            cmd += f' group {group}'\n        if nocoeff:\n            cmd += f' group true'\n        if fix:\n            cmd += f' fix {fix}'\n\n        self.command(cmd)\n\n    def run(self, *args, **kwargs):\n        self.pylmp.run(*args, **kwargs)\n\n    @property\n    def runs(self):\n        return self.pylmp.runs\n\n    def script(self):\n        path_tmp_script = os.path.join(os.getcwd(), 'script.in')\n        self.pylmp.write_script(path_tmp_script)\n        with open(path_tmp_script) as file:\n            script = file.read()\n\n        return script\n\n    @property\n    def type_map(self):\n        return self._data.get('type_map')\n\n    @property\n    def variables(self):\n        return self.pylmp.variables\n\n    @property\n    def version(self):\n        return self.pylmp.version()\n\n    @property\n    def work_dir(self):\n        work_dir = self._data.get('work_dir', os.getcwd())\n        if not work_dir:\n            os.mkdir(work_dir)\n        return work_dir\n\n    def write_script(self, filepath: str):\n        self.pylmp.write_script(filepath)", "\n\nclass LmpTask:\n    \"\"\" The base class for performing LAMMPS tasks with Molecule objects \"\"\"\n    def __init__(self, mol: 'ci.Molecule'):\n        self.mol = mol\n\n\nimport hotpot.cheminfo as ci\n", "import hotpot.cheminfo as ci\n"]}
{"filename": "hotpot/tanks/lmp/__init__.py", "chunked_list": ["\"\"\"\npython v3.7.9\n@Project: hotpot\n@File   : __init__.py.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/4/26\n@Time   : 1:47\n\"\"\"\nimport os\nimport sys", "import os\nimport sys\n\nsys.path.append(os.path.abspath(os.path.dirname(__file__)))\n\nfrom base import HpLammps\nfrom materials import AmorphousMaker\n"]}
{"filename": "hotpot/utils/units_convert.py", "chunked_list": ["\"\"\"\npython v3.7.9\n@Project: hotpot\n@File   : units_convert.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/4/18\n@Time   : 21:18\nNotes: this module is used to convert the quantity from a unit metric to other\nURL: to query units conversion: https://www.convertunits.com/\nthe relationship among units: https://www.nist.gov/pml/owm/metric-si/si-units", "URL: to query units conversion: https://www.convertunits.com/\nthe relationship among units: https://www.nist.gov/pml/owm/metric-si/si-units\n\"\"\"\n\n\nclass UnitsConvert:\n    \"\"\"\"\"\"\n    __path_unit_json = 'data/units.json'\n    SI = {\n        'mass': 'kg',\n        'length': 'm',\n        'temperature': 'K',\n        'time': 's',\n        'amount_of_substance': 'mole',\n        'luminous_intensity': 'cd'\n    }\n\n    def __init__(self):\n        pass", ""]}
{"filename": "hotpot/utils/manage_machine.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : manage_machine.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/6/26\n@Time   : 17:20\n\nNotes:\n    Manage the machine, link memory, processors, GPUs", "Notes:\n    Manage the machine, link memory, processors, GPUs\n\"\"\"\nimport os\nfrom typing import *\nimport psutil\n\n\nclass Machine:\n    \"\"\" The special class to retrieve the machine information and adjust the system parameters \"\"\"\n\n    @property\n    def memory_info(self):\n        return psutil.virtual_memory()\n\n    @property\n    def available_memory(self) -> int:\n        \"\"\" Available memory with GB units \"\"\"\n        return self.memory_info.available / 1024 ** 3\n\n    def take_memory(self, ratio: float = 0.5, integer: bool = True) -> Union[int, float]:\n        \"\"\"\n        take a partial memory from machine available memory\n        Args:\n            ratio: How many ratio of taken memory take from the available\n            integer: whether to force to take an integer values\n\n        Returns:\n\n        \"\"\"\n        if integer:\n            return int(self.available_memory * ratio)\n        else:\n            return self.available_memory * ratio\n\n    @staticmethod\n    def take_CPUs(ratio: float = 0.5) -> int:\n        \"\"\"\n        Take a partial memory from machine available CPUs\n        Args:\n            ratio: The ratio of CPUs the user want to take\n\n        Returns:\n            the number of CPUs\n        \"\"\"\n        return int(os.cpu_count()/2 * ratio)", "class Machine:\n    \"\"\" The special class to retrieve the machine information and adjust the system parameters \"\"\"\n\n    @property\n    def memory_info(self):\n        return psutil.virtual_memory()\n\n    @property\n    def available_memory(self) -> int:\n        \"\"\" Available memory with GB units \"\"\"\n        return self.memory_info.available / 1024 ** 3\n\n    def take_memory(self, ratio: float = 0.5, integer: bool = True) -> Union[int, float]:\n        \"\"\"\n        take a partial memory from machine available memory\n        Args:\n            ratio: How many ratio of taken memory take from the available\n            integer: whether to force to take an integer values\n\n        Returns:\n\n        \"\"\"\n        if integer:\n            return int(self.available_memory * ratio)\n        else:\n            return self.available_memory * ratio\n\n    @staticmethod\n    def take_CPUs(ratio: float = 0.5) -> int:\n        \"\"\"\n        Take a partial memory from machine available CPUs\n        Args:\n            ratio: The ratio of CPUs the user want to take\n\n        Returns:\n            the number of CPUs\n        \"\"\"\n        return int(os.cpu_count()/2 * ratio)", "\n\nmachine = Machine()\n"]}
{"filename": "hotpot/utils/__init__.py", "chunked_list": ["\"\"\"\npython v3.7.9\n@Project: hotpot\n@File   : __init__.py.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/4/18\n@Time   : 21:17\n\"\"\"\n\n", "\n"]}
{"filename": "hotpot/utils/ob2netwx.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : ob2netwx\n@Auther : Zhiyuan Zhang\n@Data   : 2023/7/16\n@Time   : 21:17\n\nNotes:\n    This module to perform the conversion from openbabel objects or networkx to each other.", "Notes:\n    This module to perform the conversion from openbabel objects or networkx to each other.\n\"\"\"\nfrom openbabel import openbabel as ob\nimport networkx as nx\n\n\ndef ob_mol2nxg(ob_mol: ob.OBMol) -> np.Graph:\n    \"\"\"\"\"\"\n", "\n\ndef nxg2ob_mol(nxg: nx.Graph) -> ob.OBMol:\n    \"\"\" Convert the networkx Graph class to an openbabel OBMol class \"\"\"\n\n"]}
{"filename": "hotpot/utils/library.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : load_chem_lib\n@Auther : Zhiyuan Zhang\n@Data   : 2023/6/8\n@Time   : 3:27\n\nThis module is used to lazily load the chemical information database when other modules need it.\n\"\"\"", "This module is used to lazily load the chemical information database when other modules need it.\n\"\"\"\nfrom os.path import join as opj\nimport json\nfrom typing import *\nfrom pathlib import Path\n\n\nclass Library:\n    \"\"\" the Main class to load and save chemical information lazily \"\"\"\n\n    _lib = {}  # library for chemical books\n\n    def __init__(self):\n        self._books = {}\n\n    def __repr__(self):\n        return f'Library({self.book_list})'\n\n    @property\n    def book_list(self):\n        return list(self._lib.keys())\n\n    @classmethod\n    def register(cls, book_class: type):\n        \"\"\" sign up the chemical books \"\"\"\n        cls._lib[book_class.__name__] = book_class\n\n    def get(self, book_name: str):\n        return self._books.setdefault(book_name, self._lib[book_name]())", "class Library:\n    \"\"\" the Main class to load and save chemical information lazily \"\"\"\n\n    _lib = {}  # library for chemical books\n\n    def __init__(self):\n        self._books = {}\n\n    def __repr__(self):\n        return f'Library({self.book_list})'\n\n    @property\n    def book_list(self):\n        return list(self._lib.keys())\n\n    @classmethod\n    def register(cls, book_class: type):\n        \"\"\" sign up the chemical books \"\"\"\n        cls._lib[book_class.__name__] = book_class\n\n    def get(self, book_name: str):\n        return self._books.setdefault(book_name, self._lib[book_name]())", "\n\nclass ChemicalBook:\n    \"\"\" The base class for all chemical books \"\"\"\n\n\n@Library.register\nclass Solvents(ChemicalBook):\n    \"\"\" the ChemicalBook to store common solvents \"\"\"\n    def __init__(self):\n        dir_solvents = Path(hp.data_root).joinpath('solvents')\n        self._solvents = [hp.Molecule.read_from(p) for p in dir_solvents.glob('*.mol2')]\n        self._sols_smi = [m.smiles for m in self._solvents]\n\n    def __iter__(self):\n        return self._solvents\n\n    def __getitem__(self, item):\n        return self._solvents[item]\n\n    def __repr__(self):\n        return f'SolventsBook({len(self._solvents)})'\n\n    def is_solvent(self, mol: 'hp.Molecule'):\n        \"\"\" to judge whether a molecule is a solvent \"\"\"\n        return any(solvent.similarity(mol) == 1.0 for solvent in self._solvents)", "\n\n@Library.register\nclass PeriodicTable(ChemicalBook):\n    \"\"\" the periodic tabel contain detail information for each element \"\"\"\n    class Element:\n        \"\"\" Contain information for a specific element \"\"\"\n        def __init__(self, symbol: str, data: dict):\n            self.symbol = symbol\n            self.data = data\n\n        def __repr__(self):\n            return f'{self.symbol}'\n\n        def __getitem__(self, item):\n            return self.data[item]\n\n        def __getattr__(self, item):\n            return self.data[item]\n\n        def __dir__(self) -> Iterable[str]:\n            return list(self.data.keys())\n\n    class Settings:\n        \"\"\" the setting tools for PeriodicTabel \"\"\"\n        def __init__(self, _table: 'PeriodicTable'):\n            self.data_path = opj(hp.data_root, 'periodic_table.json')\n            self._table = _table\n\n        def overwrite_source_data(self):\n            \"\"\" Overwrite existing data with a new form \"\"\"\n            json.dump(self._table.data_dict, self.data_path, indent=True)\n\n    def __init__(self):\n        self.settings = self.Settings(self)\n        self._elements = {\n            s: self.Element(s, data)\n            for s, data in json.load(open(self._data_path, encoding='utf-8')).items()\n        }\n\n    def __repr__(self):\n        return f'PeriodicTabel{tuple(self._elements.keys())}'\n\n    def __getitem__(self, item):\n        return self._elements[item]\n\n    def __getattr__(self, item):\n        return self._elements[item]\n\n    def __dir__(self) -> Iterable[str]:\n        dirs = ['settings', 'symbols', 'elements']\n\n        return list(self._elements.keys()) + dirs\n\n    def __iter__(self):\n        return iter(self._elements.values())\n\n    def __len__(self):\n        return len(self._elements)\n\n    @property\n    def _data_path(self):\n        \"\"\" the PeriodicTable data retrieve from \"\"\"\n        return self.settings.data_path\n\n    @property\n    def data_dict(self):\n        return {s: e.data for s, e in self._elements.items()}\n\n    @property\n    def symbols(self):\n        return list(self._elements.keys())\n\n    @property\n    def elements(self):\n        return list(self._elements.values())", "\n\nimport hotpot as hp\n\n# initialization Chemical Library\nlibrary = Library()\n\n# the public variable\n__all__ = ['library']\n", "__all__ = ['library']\n"]}
{"filename": "examples/extract_ml_pair.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : extract_ml_pair\n@Auther : Zhiyuan Zhang\n@Data   : 2023/7/3\n@Time   : 2:34\n\nNote:\n    This python code to perform extraction of metal-ligand pairs from cif file", "Note:\n    This python code to perform extraction of metal-ligand pairs from cif file\n\"\"\"\nimport tqdm\nfrom pathlib import Path\nimport hotpot as hp\n\n\nif __name__ == '__main__':\n    path_cif = Path('/home/zz1/database/CSD')\n    bundle = hp.MolBundle.read_from('cif', path_cif, ranges=range(1000))\n    for i, mol in enumerate(tqdm.tqdm(bundle)):\n        mol.remove_solvents()", "if __name__ == '__main__':\n    path_cif = Path('/home/zz1/database/CSD')\n    bundle = hp.MolBundle.read_from('cif', path_cif, ranges=range(1000))\n    for i, mol in enumerate(tqdm.tqdm(bundle)):\n        mol.remove_solvents()\n"]}
{"filename": "examples/calc_bde.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : calc_bde.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/6/14\n@Time   : 10:30\n\nNote:\n    This script to high-throughput determine the bind energy when a metal cation coordinate to a ligand with", "Note:\n    This script to high-throughput determine the bind energy when a metal cation coordinate to a ligand with\n    specified coordination pattern\n\"\"\"\nimport os\nfrom pathlib import Path\nimport hotpot as hp\n\n\nif __name__ == '__main__':\n\n    START_NUM = 8\n\n    path_smiles = Path('/home/zz1/proj/be/struct/choice_ligand')\n    g16root = '/home/pub'\n    work_dir = Path('/home/zz1/proj/be/g161')\n    os.chdir(work_dir)\n\n    smiles = open(path_smiles).readlines()\n\n    for i, s in enumerate(smiles[START_NUM:], START_NUM):\n\n        mol = hp.Molecule.read_from(s, 'smi')\n        pair_bundle = mol.generate_pairs_bundle('Sr')\n\n        if len(pair_bundle) == 0:\n            continue\n\n        pair_bundle.determine_metal_ligand_bind_energy(\n            g16root, work_dir.joinpath(str(i)), 'M062X', 'Def2SVP', 'SCRF pop(Always)', cpu_uti=0.75,\n            skip_complete=True\n        )", "\nif __name__ == '__main__':\n\n    START_NUM = 8\n\n    path_smiles = Path('/home/zz1/proj/be/struct/choice_ligand')\n    g16root = '/home/pub'\n    work_dir = Path('/home/zz1/proj/be/g161')\n    os.chdir(work_dir)\n\n    smiles = open(path_smiles).readlines()\n\n    for i, s in enumerate(smiles[START_NUM:], START_NUM):\n\n        mol = hp.Molecule.read_from(s, 'smi')\n        pair_bundle = mol.generate_pairs_bundle('Sr')\n\n        if len(pair_bundle) == 0:\n            continue\n\n        pair_bundle.determine_metal_ligand_bind_energy(\n            g16root, work_dir.joinpath(str(i)), 'M062X', 'Def2SVP', 'SCRF pop(Always)', cpu_uti=0.75,\n            skip_complete=True\n        )", ""]}
{"filename": "examples/run_gcmc.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : train_gcmc.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/6/27\n@Time   : 19: 56\n\nNotes:\n    Training a DeepModeling model.", "Notes:\n    Training a DeepModeling model.\n\"\"\"\nimport sys\nsys.path.append('/home/qyq/hp')\n\nfrom pathlib import Path\nimport hotpot as hp\n\n\ndef run_single_gcmc():\n    path_frame = Path('/home/qyq/proj/aC_database/cif_48954/mq_0.8_4754_9588_14480.cif')\n    work_dir = Path('/home/qyq/proj/lammps/I2/single/gcmc_5')\n    frame = hp.Molecule.read_from(path_frame)\n    iodine = hp.Molecule.read_from('II', 'smi')\n    iodine.build_3d()\n    script = iodine.dump('lmpmol')\n\n    ps = [1e-5, 3e-5, 1e-4, 3e-4, 1e-3, 3e-3, 1e-2, 3e-2, 1e-1, 3e-1, 0.5, 1.0]\n\n    frame.gcmc_for_isotherm(iodine, work_dir=work_dir, Ps=ps)", "\n\ndef run_single_gcmc():\n    path_frame = Path('/home/qyq/proj/aC_database/cif_48954/mq_0.8_4754_9588_14480.cif')\n    work_dir = Path('/home/qyq/proj/lammps/I2/single/gcmc_5')\n    frame = hp.Molecule.read_from(path_frame)\n    iodine = hp.Molecule.read_from('II', 'smi')\n    iodine.build_3d()\n    script = iodine.dump('lmpmol')\n\n    ps = [1e-5, 3e-5, 1e-4, 3e-4, 1e-3, 3e-3, 1e-2, 3e-2, 1e-1, 3e-1, 0.5, 1.0]\n\n    frame.gcmc_for_isotherm(iodine, work_dir=work_dir, Ps=ps)", "\n\nif __name__ == '__main__':\n    frames_dir = Path('/home/qyq/proj/aC_database/cif_48954/cif_10_test')  #/home/qyq/proj/aC_database/cif_48954/mq_1.0_test100\n    work_dir = Path('/home/qyq/proj/lammps/I2/bundle/gcmc_18')\n    ps = [1e-5, 3e-5, 1e-4, 3e-4, 1e-3, 3e-3, 1e-2, 3e-2, 1e-1, 3e-1, 0.5, 1.0]\n    I2 = hp.Molecule.read_from('II', 'smi')\n\n    I2.build_3d()\n\n    bundle = hp.MolBundle.read_from(\n        'cif', frames_dir, generate=True, num_proc=10\n    )\n\n    idt_map = bundle.gcmc_for_isotherm(I2, work_dir=work_dir, Ps=ps, procs=30)", "\n"]}
{"filename": "examples/train_dp_model.py", "chunked_list": ["\"\"\"\npython v3.9.0\n@Project: hotpot\n@File   : train_dp_model.py\n@Author : Zhiyuan Zhang\n@Date   : 2023/6/26\n@Time   : 10:49\n\nNotes:\n    Training a DeepModeling model.", "Notes:\n    Training a DeepModeling model.\n\"\"\"\nfrom pathlib import Path\nimport hotpot as hp\nfrom hotpot.bundle import DeepModelBundle\n\n\ndef extract_dpmd_sys():\n    dir_log_file = Path('/home/zz1/proj/gauss/new/log')\n    dpmd_root = Path('/home/zz1/proj/dpmd/sys1/')\n    bundle = hp.MolBundle.read_from('g16log', dir_log_file, '*/*.log', num_proc=32)\n    bundle: DeepModelBundle = bundle.to('DeepModelBundle')\n\n    bundle.to_dpmd_sys(dpmd_root, 0.2, mode='std', split_mode='inside')\n    return bundle", "def extract_dpmd_sys():\n    dir_log_file = Path('/home/zz1/proj/gauss/new/log')\n    dpmd_root = Path('/home/zz1/proj/dpmd/sys1/')\n    bundle = hp.MolBundle.read_from('g16log', dir_log_file, '*/*.log', num_proc=32)\n    bundle: DeepModelBundle = bundle.to('DeepModelBundle')\n\n    bundle.to_dpmd_sys(dpmd_root, 0.2, mode='std', split_mode='inside')\n    return bundle\n\n\nif __name__ == '__main__':\n    b = extract_dpmd_sys()", "\n\nif __name__ == '__main__':\n    b = extract_dpmd_sys()\n"]}
