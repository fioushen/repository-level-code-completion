{"filename": "badger_os/launcher.py", "chunked_list": ["import gc\nimport os\nimport time\nimport math\nimport badger2040\nimport badger_os\nimport jpegdec\n\nAPP_DIR = \"/examples\"\nFONT_SIZE = 2", "APP_DIR = \"/examples\"\nFONT_SIZE = 2\n\nchanged = False\nexited_to_launcher = False\nwoken_by_button = badger2040.woken_by_button()  # Must be done before we clear_pressed_to_wake\n\nif badger2040.pressed_to_wake(badger2040.BUTTON_A) and badger2040.pressed_to_wake(badger2040.BUTTON_C):\n    # Pressing A and C together at start quits app\n    exited_to_launcher = badger_os.state_clear_running()\n    badger2040.reset_pressed_to_wake()\nelse:\n    # Otherwise restore previously running app\n    badger_os.state_launch()", "\n\ndisplay = badger2040.Badger2040()\ndisplay.set_font(\"bitmap8\")\ndisplay.led(128)\n\njpeg = jpegdec.JPEG(display.display)\n\nstate = {\n    \"page\": 0,", "state = {\n    \"page\": 0,\n    \"running\": \"launcher\"\n}\n\nbadger_os.state_load(\"launcher\", state)\n\nexamples = [x[:-3] for x in os.listdir(\"/examples\") if x.endswith(\".py\")]\n\n# Approximate center lines for buttons A, B and C", "\n# Approximate center lines for buttons A, B and C\ncenters = (41, 147, 253)\n\nMAX_PAGE = math.ceil(len(examples) / 3)\n\nWIDTH = 296\n\n\ndef map_value(input, in_min, in_max, out_min, out_max):\n    return (((input - in_min) * (out_max - out_min)) / (in_max - in_min)) + out_min", "\ndef map_value(input, in_min, in_max, out_min, out_max):\n    return (((input - in_min) * (out_max - out_min)) / (in_max - in_min)) + out_min\n\n\ndef draw_disk_usage(x):\n    _, f_used, _ = badger_os.get_disk_usage()\n\n    display.set_pen(15)\n    display.image(\n        bytearray(\n            (\n                0b00000000,\n                0b00111100,\n                0b00111100,\n                0b00111100,\n                0b00111000,\n                0b00000000,\n                0b00000000,\n                0b00000001,\n            )\n        ),\n        8,\n        8,\n        x,\n        4,\n    )\n    display.rectangle(x + 10, 3, 80, 10)\n    display.set_pen(0)\n    display.rectangle(x + 11, 4, 78, 8)\n    display.set_pen(15)\n    display.rectangle(x + 12, 5, int(76 / 100.0 * f_used), 6)\n    display.text(\"{:.2f}%\".format(f_used), x + 91, 4, WIDTH, 1.0)", "\n\ndef render():\n    display.set_pen(15)\n    display.clear()\n    display.set_pen(0)\n\n    max_icons = min(3, len(examples[(state[\"page\"] * 3):]))\n\n    for i in range(max_icons):\n        x = centers[i]\n        label = examples[i + (state[\"page\"] * 3)]\n        icon_label = label.replace(\"_\", \"-\")\n        icon = f\"{APP_DIR}/icon-{icon_label}.jpg\"\n        label = label.replace(\"_\", \" \")\n        jpeg.open_file(icon)\n        jpeg.decode(x - 26, 30)\n        display.set_pen(0)\n        w = display.measure_text(label, FONT_SIZE)\n        display.text(label, int(x - (w / 2)), 16 + 80, WIDTH, FONT_SIZE)\n\n    for i in range(MAX_PAGE):\n        x = 286\n        y = int((128 / 2) - (MAX_PAGE * 10 / 2) + (i * 10))\n        display.set_pen(0)\n        display.rectangle(x, y, 8, 8)\n        if state[\"page\"] != i:\n            display.set_pen(15)\n            display.rectangle(x + 1, y + 1, 6, 6)\n\n    display.set_pen(0)\n    display.rectangle(0, 0, WIDTH, 16)\n    draw_disk_usage(90)\n    display.set_pen(15)\n    display.text(\"badgerOS\", 4, 4, WIDTH, 1.0)\n\n    display.update()", "\n\ndef wait_for_user_to_release_buttons():\n    while display.pressed_any():\n        time.sleep(0.01)\n\n\ndef launch_example(index):\n    wait_for_user_to_release_buttons()\n\n    file = examples[(state[\"page\"] * 3) + index]\n    file = f\"{APP_DIR}/{file}\"\n\n    for k in locals().keys():\n        if k not in (\"gc\", \"file\", \"badger_os\"):\n            del locals()[k]\n\n    gc.collect()\n\n    badger_os.launch(file)", "\n\ndef button(pin):\n    global changed\n    changed = True\n\n    if pin == badger2040.BUTTON_A:\n        launch_example(0)\n    if pin == badger2040.BUTTON_B:\n        launch_example(1)\n    if pin == badger2040.BUTTON_C:\n        launch_example(2)\n    if pin == badger2040.BUTTON_UP:\n        if state[\"page\"] > 0:\n            state[\"page\"] -= 1\n        render()\n    if pin == badger2040.BUTTON_DOWN:\n        if state[\"page\"] < MAX_PAGE - 1:\n            state[\"page\"] += 1\n        render()", "\n\nif exited_to_launcher or not woken_by_button:\n    wait_for_user_to_release_buttons()\n    display.set_update_speed(badger2040.UPDATE_MEDIUM)\n    render()\n\ndisplay.set_update_speed(badger2040.UPDATE_FAST)\n\nwhile True:", "\nwhile True:\n    # Sometimes a button press or hold will keep the system\n    # powered *through* HALT, so latch the power back on.\n    display.keepalive()\n\n    if display.pressed(badger2040.BUTTON_A):\n        button(badger2040.BUTTON_A)\n    if display.pressed(badger2040.BUTTON_B):\n        button(badger2040.BUTTON_B)\n    if display.pressed(badger2040.BUTTON_C):\n        button(badger2040.BUTTON_C)", "    if display.pressed(badger2040.BUTTON_B):\n        button(badger2040.BUTTON_B)\n    if display.pressed(badger2040.BUTTON_C):\n        button(badger2040.BUTTON_C)\n\n    if display.pressed(badger2040.BUTTON_UP):\n        button(badger2040.BUTTON_UP)\n    if display.pressed(badger2040.BUTTON_DOWN):\n        button(badger2040.BUTTON_DOWN)\n\n    if changed:\n        badger_os.state_save(\"launcher\", state)\n        changed = False", "\n    if changed:\n        badger_os.state_save(\"launcher\", state)\n        changed = False\n\n    display.halt()\n"]}
{"filename": "badger_os/main.py", "chunked_list": ["import launcher  # noqa F401\n"]}
{"filename": "badger_os/WIFI_CONFIG.py", "chunked_list": ["SSID = \"\"\nPSK = \"\"\nCOUNTRY = \"\"\n"]}
{"filename": "badger_os/examples/help.py", "chunked_list": ["import badger2040\nfrom badger2040 import WIDTH\n\nTEXT_SIZE = 0.45\nLINE_HEIGHT = 20\n\ndisplay = badger2040.Badger2040()\ndisplay.led(128)\ndisplay.set_thickness(2)\n", "display.set_thickness(2)\n\n# Clear to white\ndisplay.set_pen(15)\ndisplay.clear()\n\ndisplay.set_font(\"bitmap8\")\ndisplay.set_pen(0)\ndisplay.rectangle(0, 0, WIDTH, 16)\ndisplay.set_pen(15)", "display.rectangle(0, 0, WIDTH, 16)\ndisplay.set_pen(15)\ndisplay.text(\"badgerOS\", 3, 4, WIDTH, 1)\ndisplay.text(\"help\", WIDTH - display.measure_text(\"help\", 0.4) - 4, 4, WIDTH, 1)\n\ndisplay.set_font(\"sans\")\ndisplay.set_pen(0)\n\nTEXT_SIZE = 0.62\ny = 20 + int(LINE_HEIGHT / 2)", "TEXT_SIZE = 0.62\ny = 20 + int(LINE_HEIGHT / 2)\n\ndisplay.set_font(\"sans\")\ndisplay.text(\"Up/Down - Change page\", 0, y, WIDTH, TEXT_SIZE)\ny += LINE_HEIGHT\ndisplay.text(\"a, b or c - Launch app\", 0, y, WIDTH, TEXT_SIZE)\ny += LINE_HEIGHT\ndisplay.text(\"a & c - Exit app\", 0, y, WIDTH, TEXT_SIZE)\ny += LINE_HEIGHT", "display.text(\"a & c - Exit app\", 0, y, WIDTH, TEXT_SIZE)\ny += LINE_HEIGHT\n\ndisplay.update()\n\n# Call halt in a loop, on battery this switches off power.\n# On USB, the app will exit when A+C is pressed because the launcher picks that up.\nwhile True:\n    display.keepalive()\n    display.halt()", "    display.keepalive()\n    display.halt()\n"]}
{"filename": "badger_os/examples/info.py", "chunked_list": ["import badger2040\nfrom badger2040 import WIDTH\n\nTEXT_SIZE = 1\nLINE_HEIGHT = 15\n\ndisplay = badger2040.Badger2040()\ndisplay.led(128)\n\n# Clear to white", "\n# Clear to white\ndisplay.set_pen(15)\ndisplay.clear()\n\ndisplay.set_font(\"bitmap8\")\ndisplay.set_pen(0)\ndisplay.rectangle(0, 0, WIDTH, 16)\ndisplay.set_pen(15)\ndisplay.text(\"badgerOS\", 3, 4, WIDTH, 1)", "display.set_pen(15)\ndisplay.text(\"badgerOS\", 3, 4, WIDTH, 1)\ndisplay.text(\"info\", WIDTH - display.measure_text(\"help\", 0.4) - 4, 4, WIDTH, 1)\n\ndisplay.set_pen(0)\n\ny = 16 + int(LINE_HEIGHT / 2)\n\ndisplay.text(\"Made by Pimoroni, powered by MicroPython\", 5, y, WIDTH, TEXT_SIZE)\ny += LINE_HEIGHT", "display.text(\"Made by Pimoroni, powered by MicroPython\", 5, y, WIDTH, TEXT_SIZE)\ny += LINE_HEIGHT\ndisplay.text(\"Dual-core RP2040, 133MHz, 264KB RAM\", 5, y, WIDTH, TEXT_SIZE)\ny += LINE_HEIGHT\ndisplay.text(\"2MB Flash (1MB OS, 1MB Storage)\", 5, y, WIDTH, TEXT_SIZE)\ny += LINE_HEIGHT\ndisplay.text(\"296x128 pixel Black/White e-Ink\", 5, y, WIDTH, TEXT_SIZE)\ny += LINE_HEIGHT\ny += LINE_HEIGHT\n", "y += LINE_HEIGHT\n\ndisplay.text(\"For more info:\", 5, y, WIDTH, TEXT_SIZE)\ny += LINE_HEIGHT\ndisplay.text(\"https://pimoroni.com/badger2040\", 5, y, WIDTH, TEXT_SIZE)\n\ndisplay.update()\n\n# Call halt in a loop, on battery this switches off power.\n# On USB, the app will exit when A+C is pressed because the launcher picks that up.", "# Call halt in a loop, on battery this switches off power.\n# On USB, the app will exit when A+C is pressed because the launcher picks that up.\nwhile True:\n    display.keepalive()\n    display.halt()\n"]}
{"filename": "badger_os/examples/news.py", "chunked_list": ["import badger2040\nfrom badger2040 import WIDTH\nimport machine\nfrom urllib import urequest\nimport gc\nimport qrcode\nimport badger_os\n\n# URLS to use (Entertainment, Science and Technology)\nURL = [\"http://feeds.bbci.co.uk/news/entertainment_and_arts/rss.xml\",", "# URLS to use (Entertainment, Science and Technology)\nURL = [\"http://feeds.bbci.co.uk/news/entertainment_and_arts/rss.xml\",\n       \"http://feeds.bbci.co.uk/news/science_and_environment/rss.xml\",\n       \"http://feeds.bbci.co.uk/news/technology/rss.xml\"]\n\ncode = qrcode.QRCode()\n\nstate = {\n    \"current_page\": 0,\n    \"feed\": 2", "    \"current_page\": 0,\n    \"feed\": 2\n}\n\nbadger_os.state_load(\"news\", state)\n\n# Display Setup\ndisplay = badger2040.Badger2040()\ndisplay.led(128)\ndisplay.set_update_speed(2)", "display.led(128)\ndisplay.set_update_speed(2)\n\n# Setup buttons\nbutton_a = machine.Pin(badger2040.BUTTON_A, machine.Pin.IN, machine.Pin.PULL_DOWN)\nbutton_b = machine.Pin(badger2040.BUTTON_B, machine.Pin.IN, machine.Pin.PULL_DOWN)\nbutton_c = machine.Pin(badger2040.BUTTON_C, machine.Pin.IN, machine.Pin.PULL_DOWN)\nbutton_down = machine.Pin(badger2040.BUTTON_DOWN, machine.Pin.IN, machine.Pin.PULL_DOWN)\nbutton_up = machine.Pin(badger2040.BUTTON_UP, machine.Pin.IN, machine.Pin.PULL_DOWN)\n", "button_up = machine.Pin(badger2040.BUTTON_UP, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\n\ndef read_until(stream, char):\n    result = b\"\"\n    while True:\n        c = stream.read(1)\n        if c == char:\n            return result\n        result += c", "\n\ndef discard_until(stream, c):\n    while stream.read(1) != c:\n        pass\n\n\ndef parse_xml_stream(s, accept_tags, group_by, max_items=3):\n    tag = []\n    text = b\"\"\n    count = 0\n    current = {}\n    while True:\n        char = s.read(1)\n        if len(char) == 0:\n            break\n\n        if char == b\"<\":\n            next_char = s.read(1)\n\n            # Discard stuff like <?xml vers...\n            if next_char == b\"?\":\n                discard_until(s, b\">\")\n                continue\n\n            # Detect <![CDATA\n            elif next_char == b\"!\":\n                s.read(1)  # Discard [\n                discard_until(s, b\"[\")  # Discard CDATA[\n                text = read_until(s, b\"]\")\n                discard_until(s, b\">\")  # Discard ]>\n                gc.collect()\n\n            elif next_char == b\"/\":\n                current_tag = read_until(s, b\">\")\n                top_tag = tag[-1]\n\n                # Populate our result dict\n                if top_tag in accept_tags:\n                    current[top_tag.decode(\"utf-8\")] = text.decode(\"utf-8\")\n\n                # If we've found a group of items, yield the dict\n                elif top_tag == group_by:\n                    yield current\n                    current = {}\n                    count += 1\n                    if count == max_items:\n                        return\n                tag.pop()\n                text = b\"\"\n                gc.collect()\n                continue\n\n            else:\n                current_tag = read_until(s, b\">\")\n                tag += [next_char + current_tag.split(b\" \")[0]]\n                text = b\"\"\n                gc.collect()\n\n        else:\n            text += char", "\n\ndef measure_qr_code(size, code):\n    w, h = code.get_size()\n    module_size = int(size / w)\n    return module_size * w, module_size\n\n\ndef draw_qr_code(ox, oy, size, code):\n    size, module_size = measure_qr_code(size, code)\n    display.set_pen(15)\n    display.rectangle(ox, oy, size, size)\n    display.set_pen(0)\n    for x in range(size):\n        for y in range(size):\n            if code.get_module(x, y):\n                display.rectangle(ox + x * module_size, oy + y * module_size, module_size, module_size)", "def draw_qr_code(ox, oy, size, code):\n    size, module_size = measure_qr_code(size, code)\n    display.set_pen(15)\n    display.rectangle(ox, oy, size, size)\n    display.set_pen(0)\n    for x in range(size):\n        for y in range(size):\n            if code.get_module(x, y):\n                display.rectangle(ox + x * module_size, oy + y * module_size, module_size, module_size)\n", "\n\n# A function to get the data from an RSS Feed, this in case BBC News.\ndef get_rss(url):\n    try:\n        stream = urequest.urlopen(url)\n        output = list(parse_xml_stream(stream, [b\"title\", b\"description\", b\"guid\", b\"pubDate\"], b\"item\"))\n        return output\n\n    except OSError as e:\n        print(e)\n        return False", "\n\n# Connects to the wireless network. Ensure you have entered your details in WIFI_CONFIG.py :).\ndisplay.connect()\n\nprint(state[\"feed\"])\nfeed = get_rss(URL[state[\"feed\"]])\n\n\ndef draw_page():\n\n    # Clear the display\n    display.set_pen(15)\n    display.clear()\n    display.set_pen(0)\n\n    # Draw the page header\n    display.set_font(\"bitmap6\")\n    display.set_pen(0)\n    display.rectangle(0, 0, WIDTH, 20)\n    display.set_pen(15)\n    display.text(\"News\", 3, 4)\n    display.text(\"Page: \" + str(state[\"current_page\"] + 1), WIDTH - display.measure_text(\"Page:  \") - 4, 4)\n    display.set_pen(0)\n\n    display.set_font(\"bitmap8\")\n\n    # Draw articles from the feed if they're available.\n    if feed:\n        page = state[\"current_page\"]\n        display.set_pen(0)\n        display.text(feed[page][\"title\"], 2, 30, WIDTH - 130, 2)\n        code.set_text(feed[page][\"guid\"])\n        draw_qr_code(WIDTH - 100, 25, 100, code)\n\n    else:\n        display.set_pen(0)\n        display.rectangle(0, 60, WIDTH, 25)\n        display.set_pen(15)\n        display.text(\"Unable to display news! Check your network settings in WIFI_CONFIG.py\", 5, 65, WIDTH, 1)\n\n    display.update()", "\ndef draw_page():\n\n    # Clear the display\n    display.set_pen(15)\n    display.clear()\n    display.set_pen(0)\n\n    # Draw the page header\n    display.set_font(\"bitmap6\")\n    display.set_pen(0)\n    display.rectangle(0, 0, WIDTH, 20)\n    display.set_pen(15)\n    display.text(\"News\", 3, 4)\n    display.text(\"Page: \" + str(state[\"current_page\"] + 1), WIDTH - display.measure_text(\"Page:  \") - 4, 4)\n    display.set_pen(0)\n\n    display.set_font(\"bitmap8\")\n\n    # Draw articles from the feed if they're available.\n    if feed:\n        page = state[\"current_page\"]\n        display.set_pen(0)\n        display.text(feed[page][\"title\"], 2, 30, WIDTH - 130, 2)\n        code.set_text(feed[page][\"guid\"])\n        draw_qr_code(WIDTH - 100, 25, 100, code)\n\n    else:\n        display.set_pen(0)\n        display.rectangle(0, 60, WIDTH, 25)\n        display.set_pen(15)\n        display.text(\"Unable to display news! Check your network settings in WIFI_CONFIG.py\", 5, 65, WIDTH, 1)\n\n    display.update()", "\n\ndraw_page()\n\nwhile True:\n    changed = False\n\n    if button_down.value():\n        if state[\"current_page\"] < 2:\n            state[\"current_page\"] += 1\n            changed = True", "\n    if button_up.value():\n        if state[\"current_page\"] > 0:\n            state[\"current_page\"] -= 1\n            changed = True\n\n    if button_a.value():\n        state[\"feed\"] = 0\n        state[\"current_page\"] = 0\n        feed = get_rss(URL[state[\"feed\"]])\n        badger_os.state_save(\"news\", state)\n        changed = True", "\n    if button_b.value():\n        state[\"feed\"] = 1\n        state[\"current_page\"] = 0\n        feed = get_rss(URL[state[\"feed\"]])\n        badger_os.state_save(\"news\", state)\n        changed = True\n\n    if button_c.value():\n        state[\"feed\"] = 2\n        state[\"current_page\"] = 0\n        feed = get_rss(URL[state[\"feed\"]])\n        badger_os.state_save(\"news\", state)\n        changed = True", "    if button_c.value():\n        state[\"feed\"] = 2\n        state[\"current_page\"] = 0\n        feed = get_rss(URL[state[\"feed\"]])\n        badger_os.state_save(\"news\", state)\n        changed = True\n\n    if changed:\n        draw_page()\n", ""]}
{"filename": "badger_os/examples/fonts.py", "chunked_list": ["import badger2040\nimport badger_os\n\n# Global Constants\nFONT_NAMES = (\n    (\"sans\", 0.7, 2),\n    (\"gothic\", 0.7, 2),\n    (\"cursive\", 0.7, 2),\n    (\"serif\", 0.7, 2),\n    (\"serif_italic\", 0.7, 2),", "    (\"serif\", 0.7, 2),\n    (\"serif_italic\", 0.7, 2),\n    (\"bitmap6\", 3, 1),\n    (\"bitmap8\", 2, 1),\n    (\"bitmap14_outline\", 1, 1)\n)\n\nWIDTH = badger2040.WIDTH\nHEIGHT = badger2040.HEIGHT\n", "HEIGHT = badger2040.HEIGHT\n\nMENU_TEXT_SIZE = 0.5\nMENU_SPACING = 16\nMENU_WIDTH = 84\nMENU_PADDING = 5\n\nTEXT_INDENT = MENU_WIDTH + 10\n\nARROW_THICKNESS = 3", "\nARROW_THICKNESS = 3\nARROW_WIDTH = 18\nARROW_HEIGHT = 14\nARROW_PADDING = 2\n\n\n# ------------------------------\n#      Drawing functions\n# ------------------------------", "#      Drawing functions\n# ------------------------------\n\n# Draw a upward arrow\ndef draw_up(x, y, width, height, thickness, padding):\n    border = (thickness // 4) + padding\n    display.line(x + border, y + height - border,\n                 x + (width // 2), y + border)\n    display.line(x + (width // 2), y + border,\n                 x + width - border, y + height - border)", "\n\n# Draw a downward arrow\ndef draw_down(x, y, width, height, thickness, padding):\n    border = (thickness // 2) + padding\n    display.line(x + border, y + border,\n                 x + (width // 2), y + height - border)\n    display.line(x + (width // 2), y + height - border,\n                 x + width - border, y + border)\n", "\n\n# Draw the frame of the reader\ndef draw_frame():\n    display.set_pen(15)\n    display.clear()\n    display.set_pen(12)\n    display.rectangle(WIDTH - ARROW_WIDTH, 0, ARROW_WIDTH, HEIGHT)\n    display.set_pen(0)\n    draw_up(WIDTH - ARROW_WIDTH, (HEIGHT // 4) - (ARROW_HEIGHT // 2),\n            ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n    draw_down(WIDTH - ARROW_WIDTH, ((HEIGHT * 3) // 4) - (ARROW_HEIGHT // 2),\n              ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)", "\n\n# Draw the fonts and menu\ndef draw_fonts():\n    display.set_font(\"bitmap8\")\n    for i in range(len(FONT_NAMES)):\n        name, size, thickness = FONT_NAMES[i]\n        display.set_pen(0)\n        if i == state[\"selected_font\"]:\n            display.rectangle(0, i * MENU_SPACING, MENU_WIDTH, MENU_SPACING)\n            display.set_pen(15)\n\n        display.text(name, MENU_PADDING, (i * MENU_SPACING) + int((MENU_SPACING - 8) / 2), WIDTH, MENU_TEXT_SIZE)\n\n    name, size, thickness = FONT_NAMES[state[\"selected_font\"]]\n    display.set_font(name)\n\n    y = 0 if name.startswith(\"bitmap\") else 10\n\n    display.set_pen(0)\n    for line in (\"The quick\", \"brown fox\", \"jumps over\", \"the lazy dog.\", \"0123456789\", \"!\\\"\u00a3$%^&*()\"):\n        display.text(line, TEXT_INDENT, y, WIDTH, size)\n        y += 22\n\n    display.update()", "\n\n# ------------------------------\n#        Program setup\n# ------------------------------\n\n# Global variables\nstate = {\"selected_font\": 0}\nbadger_os.state_load(\"fonts\", state)\n", "badger_os.state_load(\"fonts\", state)\n\n# Create a new Badger and set it to update FAST\ndisplay = badger2040.Badger2040()\ndisplay.led(128)\ndisplay.set_update_speed(badger2040.UPDATE_FAST)\n\nchanged = True\n\n# ------------------------------", "\n# ------------------------------\n#       Main program loop\n# ------------------------------\n\nwhile True:\n    # Sometimes a button press or hold will keep the system\n    # powered *through* HALT, so latch the power back on.\n    display.keepalive()\n\n    if display.pressed(badger2040.BUTTON_UP):\n        state[\"selected_font\"] -= 1\n        if state[\"selected_font\"] < 0:\n            state[\"selected_font\"] = len(FONT_NAMES) - 1\n        changed = True", "    display.keepalive()\n\n    if display.pressed(badger2040.BUTTON_UP):\n        state[\"selected_font\"] -= 1\n        if state[\"selected_font\"] < 0:\n            state[\"selected_font\"] = len(FONT_NAMES) - 1\n        changed = True\n\n    if display.pressed(badger2040.BUTTON_DOWN):\n        state[\"selected_font\"] += 1\n        if state[\"selected_font\"] >= len(FONT_NAMES):\n            state[\"selected_font\"] = 0\n        changed = True", "    if display.pressed(badger2040.BUTTON_DOWN):\n        state[\"selected_font\"] += 1\n        if state[\"selected_font\"] >= len(FONT_NAMES):\n            state[\"selected_font\"] = 0\n        changed = True\n\n    if changed:\n        draw_frame()\n        draw_fonts()\n        badger_os.state_save(\"fonts\", state)\n        changed = False", "\n    display.halt()\n"]}
{"filename": "badger_os/examples/clock.py", "chunked_list": ["import time\nimport machine\nimport badger2040\n\n\ndisplay = badger2040.Badger2040()\ndisplay.set_update_speed(2)\ndisplay.set_thickness(4)\n\nWIDTH, HEIGHT = display.get_bounds()", "\nWIDTH, HEIGHT = display.get_bounds()\n\nif badger2040.is_wireless():\n    import ntptime\n    try:\n        display.connect()\n        if display.isconnected():\n            ntptime.settime()\n    except (RuntimeError, OSError) as e:\n        print(f\"Wireless Error: {e.value}\")", "\n# Thonny overwrites the Pico RTC so re-sync from the physical RTC if we can\ntry:\n    badger2040.pcf_to_pico_rtc()\nexcept RuntimeError:\n    pass\n\nrtc = machine.RTC()\n\ndisplay.set_font(\"gothic\")", "\ndisplay.set_font(\"gothic\")\n\ncursors = [\"year\", \"month\", \"day\", \"hour\", \"minute\"]\nset_clock = False\ntoggle_set_clock = False\ncursor = 0\nlast = 0\n\nbutton_a = badger2040.BUTTONS[badger2040.BUTTON_A]", "\nbutton_a = badger2040.BUTTONS[badger2040.BUTTON_A]\nbutton_b = badger2040.BUTTONS[badger2040.BUTTON_B]\nbutton_c = badger2040.BUTTONS[badger2040.BUTTON_C]\n\nbutton_up = badger2040.BUTTONS[badger2040.BUTTON_UP]\nbutton_down = badger2040.BUTTONS[badger2040.BUTTON_DOWN]\n\n\n# Button handling function\ndef button(pin):\n    global last, set_clock, toggle_set_clock, cursor, year, month, day, hour, minute\n\n    time.sleep(0.01)\n    if not pin.value():\n        return\n\n    if button_a.value() and button_c.value():\n        machine.reset()\n\n    adjust = 0\n\n    if pin == button_b:\n        toggle_set_clock = True\n        if set_clock:\n            rtc.datetime((year, month, day, 0, hour, minute, second, 0))\n            if badger2040.is_wireless():\n                badger2040.pico_rtc_to_pcf()\n        return\n\n    if set_clock:\n        if pin == button_c:\n            cursor += 1\n            cursor %= len(cursors)\n\n        if pin == button_a:\n            cursor -= 1\n            cursor %= len(cursors)\n\n        if pin == button_up:\n            adjust = 1\n\n        if pin == button_down:\n            adjust = -1\n\n        if cursors[cursor] == \"year\":\n            year += adjust\n            year = max(year, 2022)\n            day = min(day, days_in_month(month, year))\n\n        if cursors[cursor] == \"month\":\n            month += adjust\n            month = min(max(month, 1), 12)\n            day = min(day, days_in_month(month, year))\n\n        if cursors[cursor] == \"day\":\n            day += adjust\n            day = min(max(day, 1), days_in_month(month, year))\n\n        if cursors[cursor] == \"hour\":\n            hour += adjust\n            hour %= 24\n\n        if cursors[cursor] == \"minute\":\n            minute += adjust\n            minute %= 60\n\n        draw_clock()", "\n# Button handling function\ndef button(pin):\n    global last, set_clock, toggle_set_clock, cursor, year, month, day, hour, minute\n\n    time.sleep(0.01)\n    if not pin.value():\n        return\n\n    if button_a.value() and button_c.value():\n        machine.reset()\n\n    adjust = 0\n\n    if pin == button_b:\n        toggle_set_clock = True\n        if set_clock:\n            rtc.datetime((year, month, day, 0, hour, minute, second, 0))\n            if badger2040.is_wireless():\n                badger2040.pico_rtc_to_pcf()\n        return\n\n    if set_clock:\n        if pin == button_c:\n            cursor += 1\n            cursor %= len(cursors)\n\n        if pin == button_a:\n            cursor -= 1\n            cursor %= len(cursors)\n\n        if pin == button_up:\n            adjust = 1\n\n        if pin == button_down:\n            adjust = -1\n\n        if cursors[cursor] == \"year\":\n            year += adjust\n            year = max(year, 2022)\n            day = min(day, days_in_month(month, year))\n\n        if cursors[cursor] == \"month\":\n            month += adjust\n            month = min(max(month, 1), 12)\n            day = min(day, days_in_month(month, year))\n\n        if cursors[cursor] == \"day\":\n            day += adjust\n            day = min(max(day, 1), days_in_month(month, year))\n\n        if cursors[cursor] == \"hour\":\n            hour += adjust\n            hour %= 24\n\n        if cursors[cursor] == \"minute\":\n            minute += adjust\n            minute %= 60\n\n        draw_clock()", "\n\ndef days_in_month(month, year):\n    if month == 2 and ((year % 4 == 0 and year % 100 != 0) or year % 400 == 0):\n        return 29\n    return (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)[month - 1]\n\n\ndef draw_clock():\n    global second_offset, second_unit_offset\n\n    hms = \"{:02}:{:02}:{:02}\".format(hour, minute, second)\n    ymd = \"{:04}/{:02}/{:02}\".format(year, month, day)\n\n    hms_width = display.measure_text(hms, 1.8)\n    hms_offset = int((badger2040.WIDTH / 2) - (hms_width / 2))\n    h_width = display.measure_text(hms[0:2], 1.8)\n    mi_width = display.measure_text(hms[3:5], 1.8)\n    mi_offset = display.measure_text(hms[0:3], 1.8)\n\n    ymd_width = display.measure_text(ymd, 1.0)\n    ymd_offset = int((badger2040.WIDTH / 2) - (ymd_width / 2))\n    y_width = display.measure_text(ymd[0:4], 1.0)\n    m_width = display.measure_text(ymd[5:7], 1.0)\n    m_offset = display.measure_text(ymd[0:5], 1.0)\n    d_width = display.measure_text(ymd[8:10], 1.0)\n    d_offset = display.measure_text(ymd[0:8], 1.0)\n\n    display.set_pen(15)\n    display.clear()\n    display.set_pen(0)\n\n    display.text(hms, hms_offset, 40, 0, 1.8)\n    display.text(ymd, ymd_offset, 100, 0, 1.0)\n\n    hms = \"{:02}:{:02}:\".format(hour, minute)\n    second_offset = hms_offset + display.measure_text(hms, 1.8)\n    hms = \"{:02}:{:02}:{}\".format(hour, minute, second // 10)\n    second_unit_offset = hms_offset + display.measure_text(hms, 1.8)\n\n    if set_clock:\n        display.set_pen(0)\n        if cursors[cursor] == \"year\":\n            display.line(ymd_offset, 120, ymd_offset + y_width, 120, 4)\n        if cursors[cursor] == \"month\":\n            display.line(ymd_offset + m_offset, 120, ymd_offset + m_offset + m_width, 120, 4)\n        if cursors[cursor] == \"day\":\n            display.line(ymd_offset + d_offset, 120, ymd_offset + d_offset + d_width, 120, 4)\n\n        if cursors[cursor] == \"hour\":\n            display.line(hms_offset, 70, hms_offset + h_width, 70, 4)\n        if cursors[cursor] == \"minute\":\n            display.line(hms_offset + mi_offset, 70, hms_offset + mi_offset + mi_width, 70, 4)\n\n    display.set_update_speed(2)\n    display.update()\n    display.set_update_speed(3)", "def draw_clock():\n    global second_offset, second_unit_offset\n\n    hms = \"{:02}:{:02}:{:02}\".format(hour, minute, second)\n    ymd = \"{:04}/{:02}/{:02}\".format(year, month, day)\n\n    hms_width = display.measure_text(hms, 1.8)\n    hms_offset = int((badger2040.WIDTH / 2) - (hms_width / 2))\n    h_width = display.measure_text(hms[0:2], 1.8)\n    mi_width = display.measure_text(hms[3:5], 1.8)\n    mi_offset = display.measure_text(hms[0:3], 1.8)\n\n    ymd_width = display.measure_text(ymd, 1.0)\n    ymd_offset = int((badger2040.WIDTH / 2) - (ymd_width / 2))\n    y_width = display.measure_text(ymd[0:4], 1.0)\n    m_width = display.measure_text(ymd[5:7], 1.0)\n    m_offset = display.measure_text(ymd[0:5], 1.0)\n    d_width = display.measure_text(ymd[8:10], 1.0)\n    d_offset = display.measure_text(ymd[0:8], 1.0)\n\n    display.set_pen(15)\n    display.clear()\n    display.set_pen(0)\n\n    display.text(hms, hms_offset, 40, 0, 1.8)\n    display.text(ymd, ymd_offset, 100, 0, 1.0)\n\n    hms = \"{:02}:{:02}:\".format(hour, minute)\n    second_offset = hms_offset + display.measure_text(hms, 1.8)\n    hms = \"{:02}:{:02}:{}\".format(hour, minute, second // 10)\n    second_unit_offset = hms_offset + display.measure_text(hms, 1.8)\n\n    if set_clock:\n        display.set_pen(0)\n        if cursors[cursor] == \"year\":\n            display.line(ymd_offset, 120, ymd_offset + y_width, 120, 4)\n        if cursors[cursor] == \"month\":\n            display.line(ymd_offset + m_offset, 120, ymd_offset + m_offset + m_width, 120, 4)\n        if cursors[cursor] == \"day\":\n            display.line(ymd_offset + d_offset, 120, ymd_offset + d_offset + d_width, 120, 4)\n\n        if cursors[cursor] == \"hour\":\n            display.line(hms_offset, 70, hms_offset + h_width, 70, 4)\n        if cursors[cursor] == \"minute\":\n            display.line(hms_offset + mi_offset, 70, hms_offset + mi_offset + mi_width, 70, 4)\n\n    display.set_update_speed(2)\n    display.update()\n    display.set_update_speed(3)", "\n\ndef draw_second():\n    global second_offset, second_unit_offset\n\n    display.set_pen(15)\n    display.rectangle(second_offset, 8, 75, 56)\n    display.set_pen(0)\n\n    if second // 10 != last_second // 10:\n        s = \"{:02}\".format(second)\n        display.text(s, second_offset, 40, 0, 1.8)\n        display.partial_update(second_offset, 8, 75, 56)\n\n        s = \"{}\".format(second // 10)\n        second_unit_offset = second_offset + display.measure_text(s, 1.8)\n\n    else:\n        s = \"{}\".format(second % 10)\n        display.text(s, second_unit_offset, 40, 0, 1.8)\n        display.partial_update(second_unit_offset, 8, 75 - (second_unit_offset - second_offset), 56)\n        time.sleep(0.9)", "\n\nfor b in badger2040.BUTTONS.values():\n    b.irq(trigger=machine.Pin.IRQ_RISING, handler=button)\n\nyear, month, day, wd, hour, minute, second, _ = rtc.datetime()\n\nif (year, month, day) == (2021, 1, 1):\n    rtc.datetime((2022, 2, 28, 0, 12, 0, 0, 0))\n", "\nlast_second = second\nlast_minute = minute\ndraw_clock()\n\n\nwhile True:\n    if not set_clock:\n        year, month, day, wd, hour, minute, second, _ = rtc.datetime()\n        if second != last_second:\n            if minute != last_minute:\n                draw_clock()\n                last_minute = minute\n            else:\n                draw_second()\n            last_second = second", "\n    if toggle_set_clock:\n        set_clock = not set_clock\n        print(f\"Set clock changed to: {set_clock}\")\n        toggle_set_clock = False\n        draw_clock()\n\n    time.sleep(0.01)\n", ""]}
{"filename": "badger_os/examples/weather.py", "chunked_list": ["# This example grabs current weather details from Open Meteo and displays them on Badger 2040 W.\n# Find out more about the Open Meteo API at https://open-meteo.com\n\nimport badger2040\nfrom badger2040 import WIDTH\nimport urequests\nimport jpegdec\n\n# Set your latitude/longitude here (find yours by right clicking in Google Maps!)\nLAT = 53.38609085276884", "# Set your latitude/longitude here (find yours by right clicking in Google Maps!)\nLAT = 53.38609085276884\nLNG = -1.4239983439328177\nTIMEZONE = \"auto\"  # determines time zone from lat/long\n\nURL = \"http://api.open-meteo.com/v1/forecast?latitude=\" + str(LAT) + \"&longitude=\" + str(LNG) + \"&current_weather=true&timezone=\" + TIMEZONE\n\n# Display Setup\ndisplay = badger2040.Badger2040()\ndisplay.led(128)", "display = badger2040.Badger2040()\ndisplay.led(128)\ndisplay.set_update_speed(2)\n\njpeg = jpegdec.JPEG(display.display)\n\n# Connects to the wireless network. Ensure you have entered your details in WIFI_CONFIG.py :).\ndisplay.connect()\n\n\ndef get_data():\n    global weathercode, temperature, windspeed, winddirection, date, time\n    print(f\"Requesting URL: {URL}\")\n    r = urequests.get(URL)\n    # open the json data\n    j = r.json()\n    print(\"Data obtained!\")\n    print(j)\n\n    # parse relevant data from JSON\n    current = j[\"current_weather\"]\n    temperature = current[\"temperature\"]\n    windspeed = current[\"windspeed\"]\n    winddirection = calculate_bearing(current[\"winddirection\"])\n    weathercode = current[\"weathercode\"]\n    date, time = current[\"time\"].split(\"T\")\n\n    r.close()", "\n\ndef get_data():\n    global weathercode, temperature, windspeed, winddirection, date, time\n    print(f\"Requesting URL: {URL}\")\n    r = urequests.get(URL)\n    # open the json data\n    j = r.json()\n    print(\"Data obtained!\")\n    print(j)\n\n    # parse relevant data from JSON\n    current = j[\"current_weather\"]\n    temperature = current[\"temperature\"]\n    windspeed = current[\"windspeed\"]\n    winddirection = calculate_bearing(current[\"winddirection\"])\n    weathercode = current[\"weathercode\"]\n    date, time = current[\"time\"].split(\"T\")\n\n    r.close()", "\n\ndef calculate_bearing(d):\n    # calculates a compass direction from the wind direction in degrees\n    dirs = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW']\n    ix = round(d / (360. / len(dirs)))\n    return dirs[ix % len(dirs)]\n\n\ndef draw_page():\n    # Clear the display\n    display.set_pen(15)\n    display.clear()\n    display.set_pen(0)\n\n    # Draw the page header\n    display.set_font(\"bitmap6\")\n    display.set_pen(0)\n    display.rectangle(0, 0, WIDTH, 20)\n    display.set_pen(15)\n    display.text(\"Weather\", 3, 4)\n    display.set_pen(0)\n\n    display.set_font(\"bitmap8\")\n\n    if temperature is not None:\n        # Choose an appropriate icon based on the weather code\n        # Weather codes from https://open-meteo.com/en/docs\n        # Weather icons from https://fontawesome.com/\n        if weathercode in [71, 73, 75, 77, 85, 86]:  # codes for snow\n            jpeg.open_file(\"/icons/icon-snow.jpg\")\n        elif weathercode in [51, 53, 55, 56, 57, 61, 63, 65, 66, 67, 80, 81, 82]:  # codes for rain\n            jpeg.open_file(\"/icons/icon-rain.jpg\")\n        elif weathercode in [1, 2, 3, 45, 48]:  # codes for cloud\n            jpeg.open_file(\"/icons/icon-cloud.jpg\")\n        elif weathercode in [0]:  # codes for sun\n            jpeg.open_file(\"/icons/icon-sun.jpg\")\n        elif weathercode in [95, 96, 99]:  # codes for storm\n            jpeg.open_file(\"/icons/icon-storm.jpg\")\n        jpeg.decode(13, 40, jpegdec.JPEG_SCALE_FULL)\n        display.set_pen(0)\n        display.text(f\"Temperature: {temperature}\u00b0C\", int(WIDTH / 3), 28, WIDTH - 105, 2)\n        display.text(f\"Wind Speed: {windspeed}kmph\", int(WIDTH / 3), 48, WIDTH - 105, 2)\n        display.text(f\"Wind Direction: {winddirection}\", int(WIDTH / 3), 68, WIDTH - 105, 2)\n        display.text(f\"Last update: {date}, {time}\", int(WIDTH / 3), 88, WIDTH - 105, 2)\n\n    else:\n        display.set_pen(0)\n        display.rectangle(0, 60, WIDTH, 25)\n        display.set_pen(15)\n        display.text(\"Unable to display weather! Check your network settings in WIFI_CONFIG.py\", 5, 65, WIDTH, 1)\n\n    display.update()", "\ndef draw_page():\n    # Clear the display\n    display.set_pen(15)\n    display.clear()\n    display.set_pen(0)\n\n    # Draw the page header\n    display.set_font(\"bitmap6\")\n    display.set_pen(0)\n    display.rectangle(0, 0, WIDTH, 20)\n    display.set_pen(15)\n    display.text(\"Weather\", 3, 4)\n    display.set_pen(0)\n\n    display.set_font(\"bitmap8\")\n\n    if temperature is not None:\n        # Choose an appropriate icon based on the weather code\n        # Weather codes from https://open-meteo.com/en/docs\n        # Weather icons from https://fontawesome.com/\n        if weathercode in [71, 73, 75, 77, 85, 86]:  # codes for snow\n            jpeg.open_file(\"/icons/icon-snow.jpg\")\n        elif weathercode in [51, 53, 55, 56, 57, 61, 63, 65, 66, 67, 80, 81, 82]:  # codes for rain\n            jpeg.open_file(\"/icons/icon-rain.jpg\")\n        elif weathercode in [1, 2, 3, 45, 48]:  # codes for cloud\n            jpeg.open_file(\"/icons/icon-cloud.jpg\")\n        elif weathercode in [0]:  # codes for sun\n            jpeg.open_file(\"/icons/icon-sun.jpg\")\n        elif weathercode in [95, 96, 99]:  # codes for storm\n            jpeg.open_file(\"/icons/icon-storm.jpg\")\n        jpeg.decode(13, 40, jpegdec.JPEG_SCALE_FULL)\n        display.set_pen(0)\n        display.text(f\"Temperature: {temperature}\u00b0C\", int(WIDTH / 3), 28, WIDTH - 105, 2)\n        display.text(f\"Wind Speed: {windspeed}kmph\", int(WIDTH / 3), 48, WIDTH - 105, 2)\n        display.text(f\"Wind Direction: {winddirection}\", int(WIDTH / 3), 68, WIDTH - 105, 2)\n        display.text(f\"Last update: {date}, {time}\", int(WIDTH / 3), 88, WIDTH - 105, 2)\n\n    else:\n        display.set_pen(0)\n        display.rectangle(0, 60, WIDTH, 25)\n        display.set_pen(15)\n        display.text(\"Unable to display weather! Check your network settings in WIFI_CONFIG.py\", 5, 65, WIDTH, 1)\n\n    display.update()", "\n\nget_data()\ndraw_page()\n\n# Call halt in a loop, on battery this switches off power.\n# On USB, the app will exit when A+C is pressed because the launcher picks that up.\nwhile True:\n    display.keepalive()\n    display.halt()", "    display.keepalive()\n    display.halt()\n"]}
{"filename": "badger_os/examples/list.py", "chunked_list": ["import binascii\n\nimport badger2040\nimport badger_os\n\n# **** Put your list title here *****\nlist_title = \"Checklist\"\nlist_file = \"checklist.txt\"\n\n", "\n\n# Global Constantsu\nWIDTH = badger2040.WIDTH\nHEIGHT = badger2040.HEIGHT\n\nARROW_THICKNESS = 3\nARROW_WIDTH = 18\nARROW_HEIGHT = 14\nARROW_PADDING = 2", "ARROW_HEIGHT = 14\nARROW_PADDING = 2\n\nMAX_ITEM_CHARS = 26\nTITLE_TEXT_SIZE = 0.7\nITEM_TEXT_SIZE = 0.6\nITEM_SPACING = 20\n\nLIST_START = 40\nLIST_PADDING = 2", "LIST_START = 40\nLIST_PADDING = 2\nLIST_WIDTH = WIDTH - LIST_PADDING - LIST_PADDING - ARROW_WIDTH\nLIST_HEIGHT = HEIGHT - LIST_START - LIST_PADDING - ARROW_HEIGHT\n\n\n# Default list items - change the list items by editing checklist.txt\nlist_items = [\"Badger\", \"Badger\", \"Badger\", \"Badger\", \"Badger\", \"Mushroom\", \"Mushroom\", \"Snake\"]\nsave_checklist = False\n\ntry:\n    with open(\"checklist.txt\", \"r\") as f:\n        raw_list_items = f.read()\n\n    if raw_list_items.find(\" X\\n\") != -1:\n        # Have old style checklist, preserve state and note we should resave the list to remove the Xs\n        list_items = []\n        state = {\n            \"current_item\": 0,\n            \"checked\": []\n        }\n        for item in raw_list_items.strip().split(\"\\n\"):\n            if item.endswith(\" X\"):\n                state[\"checked\"].append(True)\n                item = item[:-2]\n            else:\n                state[\"checked\"].append(False)\n            list_items.append(item)\n        state[\"items_hash\"] = binascii.crc32(\"\\n\".join(list_items))\n\n        badger_os.state_save(\"list\", state)\n        save_checklist = True\n    else:\n        list_items = [item.strip() for item in raw_list_items.strip().split(\"\\n\")]\n\nexcept OSError:\n    save_checklist = True", "save_checklist = False\n\ntry:\n    with open(\"checklist.txt\", \"r\") as f:\n        raw_list_items = f.read()\n\n    if raw_list_items.find(\" X\\n\") != -1:\n        # Have old style checklist, preserve state and note we should resave the list to remove the Xs\n        list_items = []\n        state = {\n            \"current_item\": 0,\n            \"checked\": []\n        }\n        for item in raw_list_items.strip().split(\"\\n\"):\n            if item.endswith(\" X\"):\n                state[\"checked\"].append(True)\n                item = item[:-2]\n            else:\n                state[\"checked\"].append(False)\n            list_items.append(item)\n        state[\"items_hash\"] = binascii.crc32(\"\\n\".join(list_items))\n\n        badger_os.state_save(\"list\", state)\n        save_checklist = True\n    else:\n        list_items = [item.strip() for item in raw_list_items.strip().split(\"\\n\")]\n\nexcept OSError:\n    save_checklist = True", "\nif save_checklist:\n    with open(\"checklist.txt\", \"w\") as f:\n        for item in list_items:\n            f.write(item + \"\\n\")\n\n\n# ------------------------------\n#      Drawing functions\n# ------------------------------", "#      Drawing functions\n# ------------------------------\n\n# Draw the list of items\ndef draw_list(items, item_states, start_item, highlighted_item, x, y, width, height, item_height, columns):\n    item_x = 0\n    item_y = 0\n    current_col = 0\n    for i in range(start_item, len(items)):\n        if i == highlighted_item:\n            display.set_pen(12)\n            display.rectangle(item_x, item_y + y - (item_height // 2), width // columns, item_height)\n        display.set_pen(0)\n        display.text(items[i], item_x + x + item_height, item_y + y, WIDTH, ITEM_TEXT_SIZE)\n        draw_checkbox(item_x, item_y + y - (item_height // 2), item_height, 15, 0, 2, item_states[i], 2)\n        item_y += item_height\n        if item_y >= height - (item_height // 2):\n            item_x += width // columns\n            item_y = 0\n            current_col += 1\n            if current_col >= columns:\n                return", "\n\n# Draw a upward arrow\ndef draw_up(x, y, width, height, thickness, padding):\n    border = (thickness // 4) + padding\n    display.line(x + border, y + height - border,\n                 x + (width // 2), y + border)\n    display.line(x + (width // 2), y + border,\n                 x + width - border, y + height - border)\n", "\n\n# Draw a downward arrow\ndef draw_down(x, y, width, height, thickness, padding):\n    border = (thickness // 2) + padding\n    display.line(x + border, y + border,\n                 x + (width // 2), y + height - border)\n    display.line(x + (width // 2), y + height - border,\n                 x + width - border, y + border)\n", "\n\n# Draw a left arrow\ndef draw_left(x, y, width, height, thickness, padding):\n    border = (thickness // 2) + padding\n    display.line(x + width - border, y + border,\n                 x + border, y + (height // 2))\n    display.line(x + border, y + (height // 2),\n                 x + width - border, y + height - border)\n", "\n\n# Draw a right arrow\ndef draw_right(x, y, width, height, thickness, padding):\n    border = (thickness // 2) + padding\n    display.line(x + border, y + border,\n                 x + width - border, y + (height // 2))\n    display.line(x + width - border, y + (height // 2),\n                 x + border, y + height - border)\n", "\n\n# Draw a tick\ndef draw_tick(x, y, width, height, thickness, padding):\n    border = (thickness // 2) + padding\n    display.line(x + border, y + ((height * 2) // 3),\n                 x + (width // 2), y + height - border)\n    display.line(x + (width // 2), y + height - border,\n                 x + width - border, y + border)\n", "\n\n# Draw a cross\ndef draw_cross(x, y, width, height, thickness, padding):\n    border = (thickness // 2) + padding\n    display.line(x + border, y + border, x + width - border, y + height - border)\n    display.line(x + width - border, y + border, x + border, y + height - border)\n\n\n# Draw a checkbox with or without a tick\ndef draw_checkbox(x, y, size, background, foreground, thickness, tick, padding):\n    border = (thickness // 2) + padding\n    display.set_pen(background)\n    display.rectangle(x + border, y + border, size - (border * 2), size - (border * 2))\n    display.set_pen(foreground)\n    display.line(x + border, y + border, x + size - border, y + border)\n    display.line(x + border, y + border, x + border, y + size - border)\n    display.line(x + size - border, y + border, x + size - border, y + size - border)\n    display.line(x + border, y + size - border, x + size - border, y + size - border)\n    if tick:\n        draw_tick(x, y, size, size, thickness, 2 + border)", "\n# Draw a checkbox with or without a tick\ndef draw_checkbox(x, y, size, background, foreground, thickness, tick, padding):\n    border = (thickness // 2) + padding\n    display.set_pen(background)\n    display.rectangle(x + border, y + border, size - (border * 2), size - (border * 2))\n    display.set_pen(foreground)\n    display.line(x + border, y + border, x + size - border, y + border)\n    display.line(x + border, y + border, x + border, y + size - border)\n    display.line(x + size - border, y + border, x + size - border, y + size - border)\n    display.line(x + border, y + size - border, x + size - border, y + size - border)\n    if tick:\n        draw_tick(x, y, size, size, thickness, 2 + border)", "\n\n# ------------------------------\n#        Program setup\n# ------------------------------\n\nchanged = True\nstate = {\n    \"current_item\": 0,\n}", "    \"current_item\": 0,\n}\nbadger_os.state_load(\"list\", state)\nitems_hash = binascii.crc32(\"\\n\".join(list_items))\nif \"items_hash\" not in state or state[\"items_hash\"] != items_hash:\n    # Item list changed, or not yet written reset the list\n    state[\"current_item\"] = 0\n    state[\"items_hash\"] = items_hash\n    state[\"checked\"] = [False] * len(list_items)\n    changed = True", "\n# Global variables\nitems_per_page = 0\n\n# Create a new Badger and set it to update FAST\ndisplay = badger2040.Badger2040()\ndisplay.led(128)\ndisplay.set_font(\"sans\")\ndisplay.set_thickness(2)\nif changed:\n    display.set_update_speed(badger2040.UPDATE_FAST)\nelse:\n    display.set_update_speed(badger2040.UPDATE_TURBO)", "display.set_thickness(2)\nif changed:\n    display.set_update_speed(badger2040.UPDATE_FAST)\nelse:\n    display.set_update_speed(badger2040.UPDATE_TURBO)\n\n# Find out what the longest item is\nlongest_item = 0\nfor i in range(len(list_items)):\n    while True:\n        item = list_items[i]\n        item_length = display.measure_text(item, ITEM_TEXT_SIZE)\n        if item_length > 0 and item_length > LIST_WIDTH - ITEM_SPACING:\n            list_items[i] = item[:-1]\n        else:\n            break\n    longest_item = max(longest_item, display.measure_text(list_items[i], ITEM_TEXT_SIZE))", "for i in range(len(list_items)):\n    while True:\n        item = list_items[i]\n        item_length = display.measure_text(item, ITEM_TEXT_SIZE)\n        if item_length > 0 and item_length > LIST_WIDTH - ITEM_SPACING:\n            list_items[i] = item[:-1]\n        else:\n            break\n    longest_item = max(longest_item, display.measure_text(list_items[i], ITEM_TEXT_SIZE))\n", "\n\n# And use that to calculate the number of columns we can fit onscreen and how many items that would give\nlist_columns = 1\nwhile longest_item + ITEM_SPACING < (LIST_WIDTH // (list_columns + 1)):\n    list_columns += 1\n\nitems_per_page = ((LIST_HEIGHT // ITEM_SPACING) + 1) * list_columns\n\n", "\n\n# ------------------------------\n#       Main program loop\n# ------------------------------\n\nwhile True:\n    # Sometimes a button press or hold will keep the system\n    # powered *through* HALT, so latch the power back on.\n    display.keepalive()", "    # powered *through* HALT, so latch the power back on.\n    display.keepalive()\n\n    if len(list_items) > 0:\n        if display.pressed(badger2040.BUTTON_A):\n            if state[\"current_item\"] > 0:\n                page = state[\"current_item\"] // items_per_page\n                state[\"current_item\"] = max(state[\"current_item\"] - (items_per_page) // list_columns, 0)\n                if page != state[\"current_item\"] // items_per_page:\n                    display.update_speed(badger2040.UPDATE_FAST)\n                changed = True\n        if display.pressed(badger2040.BUTTON_B):\n            state[\"checked\"][state[\"current_item\"]] = not state[\"checked\"][state[\"current_item\"]]\n            changed = True\n        if display.pressed(badger2040.BUTTON_C):\n            if state[\"current_item\"] < len(list_items) - 1:\n                page = state[\"current_item\"] // items_per_page\n                state[\"current_item\"] = min(state[\"current_item\"] + (items_per_page) // list_columns, len(list_items) - 1)\n                if page != state[\"current_item\"] // items_per_page:\n                    display.update_speed(badger2040.UPDATE_FAST)\n                changed = True\n        if display.pressed(badger2040.BUTTON_UP):\n            if state[\"current_item\"] > 0:\n                state[\"current_item\"] -= 1\n                changed = True\n        if display.pressed(badger2040.BUTTON_DOWN):\n            if state[\"current_item\"] < len(list_items) - 1:\n                state[\"current_item\"] += 1\n                changed = True", "\n    if changed:\n        badger_os.state_save(\"list\", state)\n\n        display.set_pen(15)\n        display.clear()\n\n        display.set_pen(12)\n        display.rectangle(WIDTH - ARROW_WIDTH, 0, ARROW_WIDTH, HEIGHT)\n        display.rectangle(0, HEIGHT - ARROW_HEIGHT, WIDTH, ARROW_HEIGHT)\n\n        y = LIST_PADDING + 12\n        display.set_pen(0)\n        display.text(list_title, LIST_PADDING, y, WIDTH, TITLE_TEXT_SIZE)\n\n        y += 12\n        display.set_pen(0)\n        display.line(LIST_PADDING, y, WIDTH - LIST_PADDING - ARROW_WIDTH, y)\n\n        if len(list_items) > 0:\n            page_item = 0\n            if items_per_page > 0:\n                page_item = (state[\"current_item\"] // items_per_page) * items_per_page\n\n            # Draw the list\n            display.set_pen(0)\n            draw_list(list_items, state[\"checked\"], page_item, state[\"current_item\"], LIST_PADDING, LIST_START,\n                      LIST_WIDTH, LIST_HEIGHT, ITEM_SPACING, list_columns)\n\n            # Draw the interaction button icons\n            display.set_pen(0)\n\n            # Previous item\n            if state[\"current_item\"] > 0:\n                draw_up(WIDTH - ARROW_WIDTH, (HEIGHT // 4) - (ARROW_HEIGHT // 2),\n                        ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n\n            # Next item\n            if state[\"current_item\"] < (len(list_items) - 1):\n                draw_down(WIDTH - ARROW_WIDTH, ((HEIGHT * 3) // 4) - (ARROW_HEIGHT // 2),\n                          ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n\n            # Previous column\n            if state[\"current_item\"] > 0:\n                draw_left((WIDTH // 7) - (ARROW_WIDTH // 2), HEIGHT - ARROW_HEIGHT,\n                          ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n\n            # Next column\n            if state[\"current_item\"] < (len(list_items) - 1):\n                draw_right(((WIDTH * 6) // 7) - (ARROW_WIDTH // 2), HEIGHT - ARROW_HEIGHT,\n                           ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n\n            if state[\"checked\"][state[\"current_item\"]]:\n                # Tick off item\n                draw_cross((WIDTH // 2) - (ARROW_WIDTH // 2), HEIGHT - ARROW_HEIGHT,\n                           ARROW_HEIGHT, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n            else:\n                # Untick item\n                draw_tick((WIDTH // 2) - (ARROW_WIDTH // 2), HEIGHT - ARROW_HEIGHT,\n                          ARROW_HEIGHT, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n        else:\n            # Say that the list is empty\n            empty_text = \"Nothing Here\"\n            text_length = display.measure_text(empty_text, ITEM_TEXT_SIZE)\n            display.text(empty_text, ((LIST_PADDING + LIST_WIDTH) - text_length) // 2, (LIST_HEIGHT // 2) + LIST_START - (ITEM_SPACING // 4), WIDTH, ITEM_TEXT_SIZE)\n\n        display.update()\n        display.set_update_speed(badger2040.UPDATE_TURBO)\n        changed = False", "\n    display.halt()\n"]}
{"filename": "badger_os/examples/image.py", "chunked_list": ["import os\nimport badger2040\nfrom badger2040 import HEIGHT, WIDTH\nimport badger_os\nimport jpegdec\n\n\nTOTAL_IMAGES = 0\n\n", "\n\n# Turn the act LED on as soon as possible\ndisplay = badger2040.Badger2040()\ndisplay.led(128)\ndisplay.set_update_speed(badger2040.UPDATE_NORMAL)\n\njpeg = jpegdec.JPEG(display.display)\n\n", "\n\n# Load images\ntry:\n    IMAGES = [f for f in os.listdir(\"/images\") if f.endswith(\".jpg\")]\n    TOTAL_IMAGES = len(IMAGES)\nexcept OSError:\n    pass\n\n", "\n\nstate = {\n    \"current_image\": 0,\n    \"show_info\": True\n}\n\n\ndef show_image(n):\n    file = IMAGES[n]\n    name = file.split(\".\")[0]\n    jpeg.open_file(\"/images/{}\".format(file))\n    jpeg.decode()\n\n    if state[\"show_info\"]:\n        name_length = display.measure_text(name, 0.5)\n        display.set_pen(0)\n        display.rectangle(0, HEIGHT - 21, name_length + 11, 21)\n        display.set_pen(15)\n        display.rectangle(0, HEIGHT - 20, name_length + 10, 20)\n        display.set_pen(0)\n        display.text(name, 5, HEIGHT - 10, WIDTH, 0.5)\n\n        for i in range(TOTAL_IMAGES):\n            x = 286\n            y = int((128 / 2) - (TOTAL_IMAGES * 10 / 2) + (i * 10))\n            display.set_pen(0)\n            display.rectangle(x, y, 8, 8)\n            if state[\"current_image\"] != i:\n                display.set_pen(15)\n                display.rectangle(x + 1, y + 1, 6, 6)\n\n    display.update()", "def show_image(n):\n    file = IMAGES[n]\n    name = file.split(\".\")[0]\n    jpeg.open_file(\"/images/{}\".format(file))\n    jpeg.decode()\n\n    if state[\"show_info\"]:\n        name_length = display.measure_text(name, 0.5)\n        display.set_pen(0)\n        display.rectangle(0, HEIGHT - 21, name_length + 11, 21)\n        display.set_pen(15)\n        display.rectangle(0, HEIGHT - 20, name_length + 10, 20)\n        display.set_pen(0)\n        display.text(name, 5, HEIGHT - 10, WIDTH, 0.5)\n\n        for i in range(TOTAL_IMAGES):\n            x = 286\n            y = int((128 / 2) - (TOTAL_IMAGES * 10 / 2) + (i * 10))\n            display.set_pen(0)\n            display.rectangle(x, y, 8, 8)\n            if state[\"current_image\"] != i:\n                display.set_pen(15)\n                display.rectangle(x + 1, y + 1, 6, 6)\n\n    display.update()", "\n\nif TOTAL_IMAGES == 0:\n    raise RuntimeError(\"To run this demo, create an /images directory on your device and upload some 1bit 296x128 pixel images.\")\n\n\nbadger_os.state_load(\"image\", state)\n\nchanged = True\n", "changed = True\n\n\nwhile True:\n    # Sometimes a button press or hold will keep the system\n    # powered *through* HALT, so latch the power back on.\n    display.keepalive()\n\n    if display.pressed(badger2040.BUTTON_UP):\n        if state[\"current_image\"] > 0:\n            state[\"current_image\"] -= 1\n            changed = True", "    if display.pressed(badger2040.BUTTON_UP):\n        if state[\"current_image\"] > 0:\n            state[\"current_image\"] -= 1\n            changed = True\n\n    if display.pressed(badger2040.BUTTON_DOWN):\n        if state[\"current_image\"] < TOTAL_IMAGES - 1:\n            state[\"current_image\"] += 1\n            changed = True\n\n    if display.pressed(badger2040.BUTTON_A):\n        state[\"show_info\"] = not state[\"show_info\"]\n        changed = True", "\n    if display.pressed(badger2040.BUTTON_A):\n        state[\"show_info\"] = not state[\"show_info\"]\n        changed = True\n\n    if changed:\n        show_image(state[\"current_image\"])\n        badger_os.state_save(\"image\", state)\n        changed = False\n", "\n    # Halt the Badger to save power, it will wake up if any of the front buttons are pressed\n    display.halt()\n"]}
{"filename": "badger_os/examples/ebook.py", "chunked_list": ["import badger2040\nimport gc\nimport badger_os\n\n# **** Put the name of your text file here *****\ntext_file = \"/books/289-0-wind-in-the-willows-abridged.txt\"  # File must be on the MicroPython device\n\ngc.collect()\n\n# Global Constants", "\n# Global Constants\nWIDTH = badger2040.WIDTH\nHEIGHT = badger2040.HEIGHT\n\nARROW_THICKNESS = 3\nARROW_WIDTH = 18\nARROW_HEIGHT = 14\nARROW_PADDING = 2\n", "ARROW_PADDING = 2\n\nTEXT_PADDING = 4\nTEXT_WIDTH = WIDTH - TEXT_PADDING - TEXT_PADDING - ARROW_WIDTH\n\nFONTS = [\"sans\", \"gothic\", \"cursive\", \"serif\"]\nTHICKNESSES = [2, 1, 1, 2]\n# ------------------------------\n#      Drawing functions\n# ------------------------------", "#      Drawing functions\n# ------------------------------\n\n\n# Draw a upward arrow\ndef draw_up(x, y, width, height, thickness, padding):\n    border = (thickness // 4) + padding\n    display.line(x + border, y + height - border,\n                 x + (width // 2), y + border)\n    display.line(x + (width // 2), y + border,\n                 x + width - border, y + height - border)", "\n\n# Draw a downward arrow\ndef draw_down(x, y, width, height, thickness, padding):\n    border = (thickness // 2) + padding\n    display.line(x + border, y + border,\n                 x + (width // 2), y + height - border)\n    display.line(x + (width // 2), y + height - border,\n                 x + width - border, y + border)\n", "\n\n# Draw the frame of the reader\ndef draw_frame():\n    display.set_pen(15)\n    display.clear()\n    display.set_pen(12)\n    display.rectangle(WIDTH - ARROW_WIDTH, 0, ARROW_WIDTH, HEIGHT)\n    display.set_pen(0)\n    if state[\"current_page\"] > 0:\n        draw_up(WIDTH - ARROW_WIDTH, (HEIGHT // 4) - (ARROW_HEIGHT // 2),\n                ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)\n    draw_down(WIDTH - ARROW_WIDTH, ((HEIGHT * 3) // 4) - (ARROW_HEIGHT // 2),\n              ARROW_WIDTH, ARROW_HEIGHT, ARROW_THICKNESS, ARROW_PADDING)", "\n\n# ------------------------------\n#        Program setup\n# ------------------------------\n\n# Global variables\nstate = {\n    \"last_offset\": 0,\n    \"current_page\": 0,", "    \"last_offset\": 0,\n    \"current_page\": 0,\n    \"font_idx\": 0,\n    \"text_size\": 0.5,\n    \"offsets\": []\n}\nbadger_os.state_load(\"ebook\", state)\n\ntext_spacing = int(34 * state[\"text_size\"])\n", "text_spacing = int(34 * state[\"text_size\"])\n\n\n# Create a new Badger and set it to update FAST\ndisplay = badger2040.Badger2040()\ndisplay.led(128)\ndisplay.set_update_speed(badger2040.UPDATE_FAST)\n\n\n# ------------------------------", "\n# ------------------------------\n#         Render page\n# ------------------------------\n\ndef render_page():\n    row = 0\n    line = \"\"\n    pos = ebook.tell()\n    next_pos = pos\n    add_newline = False\n    display.set_font(FONTS[state[\"font_idx\"]])\n    display.set_thickness(THICKNESSES[state[\"font_idx\"]])\n\n    while True:\n        # Read a full line and split it into words\n        words = ebook.readline().split(\" \")\n\n        # Take the length of the first word and advance our position\n        next_word = words[0]\n        if len(words) > 1:\n            next_pos += len(next_word) + 1\n        else:\n            next_pos += len(next_word)  # This is the last word on the line\n\n        # Advance our position further if the word contains special characters\n        if '\\u201c' in next_word:\n            next_word = next_word.replace('\\u201c', '\\\"')\n            next_pos += 2\n        if '\\u201d' in next_word:\n            next_word = next_word.replace('\\u201d', '\\\"')\n            next_pos += 2\n        if '\\u2019' in next_word:\n            next_word = next_word.replace('\\u2019', '\\'')\n            next_pos += 2\n\n        # Rewind the file back from the line end to the start of the next word\n        ebook.seek(next_pos)\n\n        # Strip out any new line characters from the word\n        next_word = next_word.strip()\n\n        # If an empty word is encountered assume that means there was a blank line\n        if len(next_word) == 0:\n            add_newline = True\n\n        # Append the word to the current line and measure its length\n        appended_line = line\n        if len(line) > 0 and len(next_word) > 0:\n            appended_line += \" \"\n        appended_line += next_word\n        appended_length = display.measure_text(appended_line, state[\"text_size\"])\n\n        # Would this appended line be longer than the text display area, or was a blank line spotted?\n        if appended_length >= TEXT_WIDTH or add_newline:\n\n            # Yes, so write out the line prior to the append\n            print(line)\n            display.set_pen(0)\n            display.text(line, TEXT_PADDING, (row * text_spacing) + (text_spacing // 2) + TEXT_PADDING, WIDTH, state[\"text_size\"])\n\n            # Clear the line and move on to the next row\n            line = \"\"\n            row += 1\n\n            # Have we reached the end of the page?\n            if (row * text_spacing) + text_spacing >= HEIGHT:\n                print(\"+++++\")\n                display.update()\n\n                # Reset the position to the start of the word that made this line too long\n                ebook.seek(pos)\n                return\n            else:\n                # Set the line to the word and advance the current position\n                line = next_word\n                pos = next_pos\n\n            # A new line was spotted, so advance a row\n            if add_newline:\n                print(\"\")\n                row += 1\n                if (row * text_spacing) + text_spacing >= HEIGHT:\n                    print(\"+++++\")\n                    display.update()\n                    return\n                add_newline = False\n        else:\n            # The appended line was not too long, so set it as the line and advance the current position\n            line = appended_line\n            pos = next_pos", "\n\n# ------------------------------\n#       Main program loop\n# ------------------------------\n\nlaunch = True\nchanged = False\n\n# Open the book file", "\n# Open the book file\nebook = open(text_file, \"r\")\nif len(state[\"offsets\"]) > state[\"current_page\"]:\n    ebook.seek(state[\"offsets\"][state[\"current_page\"]])\nelse:\n    state[\"current_page\"] = 0\n    state[\"offsets\"] = []\n\nwhile True:", "\nwhile True:\n    # Sometimes a button press or hold will keep the system\n    # powered *through* HALT, so latch the power back on.\n    display.keepalive()\n\n    # Was the next page button pressed?\n    if display.pressed(badger2040.BUTTON_DOWN):\n        state[\"current_page\"] += 1\n\n        changed = True", "\n    # Was the previous page button pressed?\n    if display.pressed(badger2040.BUTTON_UP):\n        if state[\"current_page\"] > 0:\n            state[\"current_page\"] -= 1\n            if state[\"current_page\"] == 0:\n                ebook.seek(0)\n            else:\n                ebook.seek(state[\"offsets\"][state[\"current_page\"] - 1])  # Retrieve the start position of the last page\n            changed = True", "\n    if display.pressed(badger2040.BUTTON_A):\n        state[\"text_size\"] += 0.1\n        if state[\"text_size\"] > 0.8:\n            state[\"text_size\"] = 0.5\n        text_spacing = int(34 * state[\"text_size\"])\n        state[\"offsets\"] = []\n        ebook.seek(0)\n        state[\"current_page\"] = 0\n        changed = True", "\n    if display.pressed(badger2040.BUTTON_B):\n        state[\"font_idx\"] += 1\n        if (state[\"font_idx\"] >= len(FONTS)):\n            state[\"font_idx\"] = 0\n        state[\"offsets\"] = []\n        ebook.seek(0)\n        state[\"current_page\"] = 0\n        changed = True\n\n    if launch and not changed:\n        if state[\"current_page\"] > 0 and len(state[\"offsets\"]) > state[\"current_page\"] - 1:\n            ebook.seek(state[\"offsets\"][state[\"current_page\"] - 1])\n        changed = True\n        launch = False", "\n    if launch and not changed:\n        if state[\"current_page\"] > 0 and len(state[\"offsets\"]) > state[\"current_page\"] - 1:\n            ebook.seek(state[\"offsets\"][state[\"current_page\"] - 1])\n        changed = True\n        launch = False\n\n    if changed:\n        draw_frame()\n        render_page()\n\n        # Is the next page one we've not displayed before?\n        if state[\"current_page\"] >= len(state[\"offsets\"]):\n            state[\"offsets\"].append(ebook.tell())  # Add its start position to the state[\"offsets\"] list\n        badger_os.state_save(\"ebook\", state)\n\n        changed = False", "\n    display.halt()\n"]}
{"filename": "badger_os/examples/badge.py", "chunked_list": ["import badger2040\nimport jpegdec\n\n\n# Global Constants\nWIDTH = badger2040.WIDTH\nHEIGHT = badger2040.HEIGHT\n\nIMAGE_WIDTH = 104\n", "IMAGE_WIDTH = 104\n\nCOMPANY_HEIGHT = 30\nDETAILS_HEIGHT = 20\nNAME_HEIGHT = HEIGHT - COMPANY_HEIGHT - (DETAILS_HEIGHT * 2) - 2\nTEXT_WIDTH = WIDTH - IMAGE_WIDTH - 1\n\nCOMPANY_TEXT_SIZE = 0.6\nDETAILS_TEXT_SIZE = 0.5\n", "DETAILS_TEXT_SIZE = 0.5\n\nLEFT_PADDING = 5\nNAME_PADDING = 20\nDETAIL_SPACING = 10\n\nBADGE_PATH = \"/badges/badge.txt\"\n\nDEFAULT_TEXT = \"\"\"mustelid inc\nH. Badger", "DEFAULT_TEXT = \"\"\"mustelid inc\nH. Badger\nRP2040\n2MB Flash\nE ink\n296x128px\n/badges/badge.jpg\n\"\"\"\n\n# ------------------------------", "\n# ------------------------------\n#      Utility functions\n# ------------------------------\n\n\n# Reduce the size of a string until it fits within a given width\ndef truncatestring(text, text_size, width):\n    while True:\n        length = display.measure_text(text, text_size)\n        if length > 0 and length > width:\n            text = text[:-1]\n        else:\n            text += \"\"\n            return text", "\n\n# ------------------------------\n#      Drawing functions\n# ------------------------------\n\n# Draw the badge, including user text\ndef draw_badge():\n    display.set_pen(0)\n    display.clear()\n\n    # Draw badge image\n    jpeg.open_file(badge_image)\n    jpeg.decode(WIDTH - IMAGE_WIDTH, 0)\n\n    # Draw a border around the image\n    display.set_pen(0)\n    display.line(WIDTH - IMAGE_WIDTH, 0, WIDTH - 1, 0)\n    display.line(WIDTH - IMAGE_WIDTH, 0, WIDTH - IMAGE_WIDTH, HEIGHT - 1)\n    display.line(WIDTH - IMAGE_WIDTH, HEIGHT - 1, WIDTH - 1, HEIGHT - 1)\n    display.line(WIDTH - 1, 0, WIDTH - 1, HEIGHT - 1)\n\n    # Uncomment this if a white background is wanted behind the company\n    # display.set_pen(15)\n    # display.rectangle(1, 1, TEXT_WIDTH, COMPANY_HEIGHT - 1)\n\n    # Draw the company\n    display.set_pen(15)  # Change this to 0 if a white background is used\n    display.set_font(\"serif\")\n    display.text(company, LEFT_PADDING, (COMPANY_HEIGHT // 2) + 1, WIDTH, COMPANY_TEXT_SIZE)\n\n    # Draw a white background behind the name\n    display.set_pen(15)\n    display.rectangle(1, COMPANY_HEIGHT + 1, TEXT_WIDTH, NAME_HEIGHT)\n\n    # Draw the name, scaling it based on the available width\n    display.set_pen(0)\n    display.set_font(\"sans\")\n    name_size = 2.0  # A sensible starting scale\n    while True:\n        name_length = display.measure_text(name, name_size)\n        if name_length >= (TEXT_WIDTH - NAME_PADDING) and name_size >= 0.1:\n            name_size -= 0.01\n        else:\n            display.text(name, (TEXT_WIDTH - name_length) // 2, (NAME_HEIGHT // 2) + COMPANY_HEIGHT + 1, WIDTH, name_size)\n            break\n\n    # Draw a white backgrounds behind the details\n    display.set_pen(15)\n    display.rectangle(1, HEIGHT - DETAILS_HEIGHT * 2, TEXT_WIDTH, DETAILS_HEIGHT - 1)\n    display.rectangle(1, HEIGHT - DETAILS_HEIGHT, TEXT_WIDTH, DETAILS_HEIGHT - 1)\n\n    # Draw the first detail's title and text\n    display.set_pen(0)\n    display.set_font(\"sans\")\n    name_length = display.measure_text(detail1_title, DETAILS_TEXT_SIZE)\n    display.text(detail1_title, LEFT_PADDING, HEIGHT - ((DETAILS_HEIGHT * 3) // 2), WIDTH, DETAILS_TEXT_SIZE)\n    display.text(detail1_text, 5 + name_length + DETAIL_SPACING, HEIGHT - ((DETAILS_HEIGHT * 3) // 2), WIDTH, DETAILS_TEXT_SIZE)\n\n    # Draw the second detail's title and text\n    name_length = display.measure_text(detail2_title, DETAILS_TEXT_SIZE)\n    display.text(detail2_title, LEFT_PADDING, HEIGHT - (DETAILS_HEIGHT // 2), WIDTH, DETAILS_TEXT_SIZE)\n    display.text(detail2_text, LEFT_PADDING + name_length + DETAIL_SPACING, HEIGHT - (DETAILS_HEIGHT // 2), WIDTH, DETAILS_TEXT_SIZE)\n\n    display.update()", "\n\n# ------------------------------\n#        Program setup\n# ------------------------------\n\n# Create a new Badger and set it to update NORMAL\ndisplay = badger2040.Badger2040()\ndisplay.led(128)\ndisplay.set_update_speed(badger2040.UPDATE_NORMAL)", "display.led(128)\ndisplay.set_update_speed(badger2040.UPDATE_NORMAL)\ndisplay.set_thickness(2)\n\njpeg = jpegdec.JPEG(display.display)\n\n# Open the badge file\ntry:\n    badge = open(BADGE_PATH, \"r\")\nexcept OSError:\n    with open(BADGE_PATH, \"w\") as f:\n        f.write(DEFAULT_TEXT)\n        f.flush()\n    badge = open(BADGE_PATH, \"r\")", "\n# Read in the next 6 lines\ncompany = badge.readline()        # \"mustelid inc\"\nname = badge.readline()           # \"H. Badger\"\ndetail1_title = badge.readline()  # \"RP2040\"\ndetail1_text = badge.readline()   # \"2MB Flash\"\ndetail2_title = badge.readline()  # \"E ink\"\ndetail2_text = badge.readline()   # \"296x128px\"\nbadge_image = badge.readline()    # /badges/badge.jpg\n", "badge_image = badge.readline()    # /badges/badge.jpg\n\n# Truncate all of the text (except for the name as that is scaled)\ncompany = truncatestring(company, COMPANY_TEXT_SIZE, TEXT_WIDTH)\n\ndetail1_title = truncatestring(detail1_title, DETAILS_TEXT_SIZE, TEXT_WIDTH)\ndetail1_text = truncatestring(detail1_text, DETAILS_TEXT_SIZE,\n                              TEXT_WIDTH - DETAIL_SPACING - display.measure_text(detail1_title, DETAILS_TEXT_SIZE))\n\ndetail2_title = truncatestring(detail2_title, DETAILS_TEXT_SIZE, TEXT_WIDTH)", "\ndetail2_title = truncatestring(detail2_title, DETAILS_TEXT_SIZE, TEXT_WIDTH)\ndetail2_text = truncatestring(detail2_text, DETAILS_TEXT_SIZE,\n                              TEXT_WIDTH - DETAIL_SPACING - display.measure_text(detail2_title, DETAILS_TEXT_SIZE))\n\n\n# ------------------------------\n#       Main program\n# ------------------------------\n", "# ------------------------------\n\ndraw_badge()\n\nwhile True:\n    # Sometimes a button press or hold will keep the system\n    # powered *through* HALT, so latch the power back on.\n    display.keepalive()\n\n    # If on battery, halt the Badger to save power, it will wake up if any of the front buttons are pressed", "\n    # If on battery, halt the Badger to save power, it will wake up if any of the front buttons are pressed\n    display.halt()\n"]}
{"filename": "badger_os/examples/qrgen.py", "chunked_list": ["import badger2040\nimport qrcode\nimport time\nimport os\nimport badger_os\n\n# Check that the qrcodes directory exists, if not, make it\ntry:\n    os.mkdir(\"/qrcodes\")\nexcept OSError:\n    pass", "\n# Check that there is a qrcode.txt, if not preload\ntry:\n    text = open(\"/qrcodes/qrcode.txt\", \"r\")\nexcept OSError:\n    text = open(\"/qrcodes/qrcode.txt\", \"w\")\n    if badger2040.is_wireless():\n        text.write(\"\"\"https://pimoroni.com/badger2040w\nBadger 2040 W\n* 296x128 1-bit e-ink\n* 2.4GHz wireless & RTC\n* five user buttons\n* user LED\n* 2MB QSPI flash\n\nScan this code to learn\nmore about Badger 2040 W.\n\"\"\")\n    else:\n        text.write(\"\"\"https://pimoroni.com/badger2040\nBadger 2040\n* 296x128 1-bit e-ink\n* five user buttons\n* user LED\n* 2MB QSPI flash\n\nScan this code to learn\nmore about Badger 2040.\n\"\"\")\n    text.flush()\n    text.seek(0)", "\n# Load all available QR Code Files\ntry:\n    CODES = [f for f in os.listdir(\"/qrcodes\") if f.endswith(\".txt\")]\n    TOTAL_CODES = len(CODES)\nexcept OSError:\n    pass\n\n\nprint(f'There are {TOTAL_CODES} QR Codes available:')\nfor codename in CODES:\n    print(f'File: {codename}')", "\nprint(f'There are {TOTAL_CODES} QR Codes available:')\nfor codename in CODES:\n    print(f'File: {codename}')\n\ndisplay = badger2040.Badger2040()\n\ncode = qrcode.QRCode()\n\nstate = {", "\nstate = {\n    \"current_qr\": 0\n}\n\n\ndef measure_qr_code(size, code):\n    w, h = code.get_size()\n    module_size = int(size / w)\n    return module_size * w, module_size", "\n\ndef draw_qr_code(ox, oy, size, code):\n    size, module_size = measure_qr_code(size, code)\n    display.set_pen(15)\n    display.rectangle(ox, oy, size, size)\n    display.set_pen(0)\n    for x in range(size):\n        for y in range(size):\n            if code.get_module(x, y):\n                display.rectangle(ox + x * module_size, oy + y * module_size, module_size, module_size)", "\n\ndef draw_qr_file(n):\n    display.led(128)\n    file = CODES[n]\n    codetext = open(\"/qrcodes/{}\".format(file), \"r\")\n\n    lines = codetext.read().strip().split(\"\\n\")\n    code_text = lines.pop(0)\n    title_text = lines.pop(0)\n    detail_text = lines\n\n    # Clear the Display\n    display.set_pen(15)  # Change this to 0 if a white background is used\n    display.clear()\n    display.set_pen(0)\n\n    code.set_text(code_text)\n    size, _ = measure_qr_code(128, code)\n    left = top = int((badger2040.HEIGHT / 2) - (size / 2))\n    draw_qr_code(left, top, 128, code)\n\n    left = 128 + 5\n\n    display.text(title_text, left, 20, badger2040.WIDTH, 2)\n\n    top = 40\n    for line in detail_text:\n        display.text(line, left, top, badger2040.WIDTH, 1)\n        top += 10\n\n    if TOTAL_CODES > 1:\n        for i in range(TOTAL_CODES):\n            x = 286\n            y = int((128 / 2) - (TOTAL_CODES * 10 / 2) + (i * 10))\n            display.set_pen(0)\n            display.rectangle(x, y, 8, 8)\n            if state[\"current_qr\"] != i:\n                display.set_pen(15)\n                display.rectangle(x + 1, y + 1, 6, 6)\n    display.update()", "\n\nbadger_os.state_load(\"qrcodes\", state)\nchanged = True\n\nwhile True:\n    # Sometimes a button press or hold will keep the system\n    # powered *through* HALT, so latch the power back on.\n    display.keepalive()\n\n    if TOTAL_CODES > 1:\n        if display.pressed(badger2040.BUTTON_UP):\n            if state[\"current_qr\"] > 0:\n                state[\"current_qr\"] -= 1\n                changed = True\n\n        if display.pressed(badger2040.BUTTON_DOWN):\n            if state[\"current_qr\"] < TOTAL_CODES - 1:\n                state[\"current_qr\"] += 1\n                changed = True", "    display.keepalive()\n\n    if TOTAL_CODES > 1:\n        if display.pressed(badger2040.BUTTON_UP):\n            if state[\"current_qr\"] > 0:\n                state[\"current_qr\"] -= 1\n                changed = True\n\n        if display.pressed(badger2040.BUTTON_DOWN):\n            if state[\"current_qr\"] < TOTAL_CODES - 1:\n                state[\"current_qr\"] += 1\n                changed = True", "\n    if display.pressed(badger2040.BUTTON_B) or display.pressed(badger2040.BUTTON_C):\n        display.set_pen(15)\n        display.clear()\n        badger_os.warning(display, \"To add QR codes, connect Badger 2040 W to a PC, load up Thonny, and add files to /qrcodes directory.\")\n        time.sleep(4)\n        changed = True\n\n    if changed:\n        draw_qr_file(state[\"current_qr\"])\n        badger_os.state_save(\"qrcodes\", state)\n        changed = False", "    if changed:\n        draw_qr_file(state[\"current_qr\"])\n        badger_os.state_save(\"qrcodes\", state)\n        changed = False\n\n    # Halt the Badger to save power, it will wake up if any of the front buttons are pressed\n    display.halt()\n"]}
{"filename": "badger_os/examples/net_info.py", "chunked_list": ["import badger2040\nfrom badger2040 import WIDTH\nimport network\n\nTEXT_SIZE = 1\nLINE_HEIGHT = 16\n\n# Display Setup\ndisplay = badger2040.Badger2040()\ndisplay.led(128)", "display = badger2040.Badger2040()\ndisplay.led(128)\n\n# Connects to the wireless network. Ensure you have entered your details in WIFI_CONFIG.py :).\ndisplay.connect()\nnet = network.WLAN(network.STA_IF).ifconfig()\n\n# Page Header\ndisplay.set_pen(15)\ndisplay.clear()", "display.set_pen(15)\ndisplay.clear()\ndisplay.set_pen(0)\n\ndisplay.set_pen(0)\ndisplay.rectangle(0, 0, WIDTH, 20)\ndisplay.set_pen(15)\ndisplay.text(\"badgerOS\", 3, 4)\ndisplay.text(\"Network Details\", WIDTH - display.measure_text(\"Network Details\") - 4, 4)\ndisplay.set_pen(0)", "display.text(\"Network Details\", WIDTH - display.measure_text(\"Network Details\") - 4, 4)\ndisplay.set_pen(0)\n\ny = 35 + int(LINE_HEIGHT / 2)\n\nif net:\n    display.text(\"> LOCAL IP: {}\".format(net[0]), 0, y, WIDTH)\n    y += LINE_HEIGHT\n    display.text(\"> Subnet: {}\".format(net[1]), 0, y, WIDTH)\n    y += LINE_HEIGHT\n    display.text(\"> Gateway: {}\".format(net[2]), 0, y, WIDTH)\n    y += LINE_HEIGHT\n    display.text(\"> DNS: {}\".format(net[3]), 0, y, WIDTH)\nelse:\n    display.text(\"> No network connection!\", 0, y, WIDTH)\n    y += LINE_HEIGHT\n    display.text(\"> Check details in WIFI_CONFIG.py\", 0, y, WIDTH)", "\ndisplay.update()\n\n# Call halt in a loop, on battery this switches off power.\n# On USB, the app will exit when A+C is pressed because the launcher picks that up.\nwhile True:\n    display.keepalive()\n    display.halt()\n", ""]}
{"filename": "firmware/PIMORONI_BADGER2040W/manifest.py", "chunked_list": ["include(\"$(PORT_DIR)/boards/manifest.py\")\n\nfreeze(\"lib/\")\n\n# mip, ntptime, urequests, webrepl etc - see:\n# https://github.com/micropython/micropython-lib/blob/master/micropython/bundles/bundle-networking/manifest.py\nrequire(\"bundle-networking\")\n\n# Bluetooth\nrequire(\"aioble\")", "# Bluetooth\nrequire(\"aioble\")\n\nrequire(\"urllib.urequest\")\nrequire(\"umqtt.simple\")"]}
{"filename": "firmware/PIMORONI_BADGER2040W/lib/badger2040.py", "chunked_list": ["import machine\nimport micropython\nfrom picographics import PicoGraphics, DISPLAY_INKY_PACK\nimport time\nimport wakeup\nimport pcf85063a\n\n\nBUTTON_DOWN = 11\nBUTTON_A = 12", "BUTTON_DOWN = 11\nBUTTON_A = 12\nBUTTON_B = 13\nBUTTON_C = 14\nBUTTON_UP = 15\nBUTTON_USER = None  # User button not available on W\n\nBUTTON_MASK = 0b11111 << 11\n\nSYSTEM_VERY_SLOW = 0", "\nSYSTEM_VERY_SLOW = 0\nSYSTEM_SLOW = 1\nSYSTEM_NORMAL = 2\nSYSTEM_FAST = 3\nSYSTEM_TURBO = 4\n\nUPDATE_NORMAL = 0\nUPDATE_MEDIUM = 1\nUPDATE_FAST = 2", "UPDATE_MEDIUM = 1\nUPDATE_FAST = 2\nUPDATE_TURBO = 3\n\nRTC_ALARM = 8\nLED = 22\nENABLE_3V3 = 10\nBUSY = 26\n\nWIDTH = 296", "\nWIDTH = 296\nHEIGHT = 128\n\nSYSTEM_FREQS = [\n    4000000,\n    12000000,\n    48000000,\n    133000000,\n    250000000", "    133000000,\n    250000000\n]\n\nBUTTONS = {\n    BUTTON_DOWN: machine.Pin(BUTTON_DOWN, machine.Pin.IN, machine.Pin.PULL_DOWN),\n    BUTTON_A: machine.Pin(BUTTON_A, machine.Pin.IN, machine.Pin.PULL_DOWN),\n    BUTTON_B: machine.Pin(BUTTON_B, machine.Pin.IN, machine.Pin.PULL_DOWN),\n    BUTTON_C: machine.Pin(BUTTON_C, machine.Pin.IN, machine.Pin.PULL_DOWN),\n    BUTTON_UP: machine.Pin(BUTTON_UP, machine.Pin.IN, machine.Pin.PULL_DOWN),", "    BUTTON_C: machine.Pin(BUTTON_C, machine.Pin.IN, machine.Pin.PULL_DOWN),\n    BUTTON_UP: machine.Pin(BUTTON_UP, machine.Pin.IN, machine.Pin.PULL_DOWN),\n}\n\nWAKEUP_MASK = 0\n\ni2c = machine.I2C(0)\nrtc = pcf85063a.PCF85063A(i2c)\ni2c.writeto_mem(0x51, 0x00, b'\\x00')  # ensure rtc is running (this should be default?)\nrtc.enable_timer_interrupt(False)", "i2c.writeto_mem(0x51, 0x00, b'\\x00')  # ensure rtc is running (this should be default?)\nrtc.enable_timer_interrupt(False)\n\nenable = machine.Pin(ENABLE_3V3, machine.Pin.OUT)\nenable.on()\n\n\ndef is_wireless():\n    return True\n", "\n\ndef woken_by_rtc():\n    return bool(wakeup.get_gpio_state() & (1 << RTC_ALARM))\n\n\ndef woken_by_button():\n    return wakeup.get_gpio_state() & BUTTON_MASK > 0\n\n\ndef pressed_to_wake(button):\n    return wakeup.get_gpio_state() & (1 << button) > 0", "\n\ndef pressed_to_wake(button):\n    return wakeup.get_gpio_state() & (1 << button) > 0\n\n\ndef reset_pressed_to_wake():\n    wakeup.reset_gpio_state()\n\n\ndef pressed_to_wake_get_once(button):\n    global WAKEUP_MASK\n    result = (wakeup.get_gpio_state() & ~WAKEUP_MASK & (1 << button)) > 0\n    WAKEUP_MASK |= (1 << button)\n    return result", "\n\ndef pressed_to_wake_get_once(button):\n    global WAKEUP_MASK\n    result = (wakeup.get_gpio_state() & ~WAKEUP_MASK & (1 << button)) > 0\n    WAKEUP_MASK |= (1 << button)\n    return result\n\n\ndef system_speed(speed):\n    try:\n        machine.freq(SYSTEM_FREQS[speed])\n    except IndexError:\n        pass", "\ndef system_speed(speed):\n    try:\n        machine.freq(SYSTEM_FREQS[speed])\n    except IndexError:\n        pass\n\n\ndef turn_on():\n    enable.on()", "def turn_on():\n    enable.on()\n\n\ndef turn_off():\n    time.sleep(0.05)\n    enable.off()\n    # Simulate an idle state on USB power by blocking\n    # until an RTC alarm or button event\n    rtc_alarm = machine.Pin(RTC_ALARM)\n    while True:\n        if rtc_alarm.value():\n            return\n        for button in BUTTONS.values():\n            if button.value():\n                return", "\n\ndef pico_rtc_to_pcf():\n    # Set the PCF85063A to the time stored by Pico W's RTC\n    year, month, day, dow, hour, minute, second, _ = machine.RTC().datetime()\n    rtc.datetime((year, month, day, hour, minute, second, dow))\n\n\ndef pcf_to_pico_rtc():\n    # Set Pico W's RTC to the time stored by the PCF85063A\n    t = rtc.datetime()\n    # BUG ERRNO 22, EINVAL, when date read from RTC is invalid for the Pico's RTC.\n    try:\n        machine.RTC().datetime((t[0], t[1], t[2], t[6], t[3], t[4], t[5], 0))\n        return True\n    except OSError:\n        return False", "def pcf_to_pico_rtc():\n    # Set Pico W's RTC to the time stored by the PCF85063A\n    t = rtc.datetime()\n    # BUG ERRNO 22, EINVAL, when date read from RTC is invalid for the Pico's RTC.\n    try:\n        machine.RTC().datetime((t[0], t[1], t[2], t[6], t[3], t[4], t[5], 0))\n        return True\n    except OSError:\n        return False\n", "\n\ndef sleep_for(minutes):\n    year, month, day, hour, minute, second, dow = rtc.datetime()\n\n    # if the time is very close to the end of the minute, advance to the next minute\n    # this aims to fix the edge case where the board goes to sleep right as the RTC triggers, thus never waking up\n    if second >= 55:\n        minute += 1\n\n    # Can't sleep beyond a month, so clamp the sleep to a 28 day maximum\n    minutes = min(minutes, 40320)\n\n    # Calculate the future alarm date; first, turn the current time into seconds since epoch\n    sec_since_epoch = time.mktime((year, month, day, hour, minute, second, dow, 0))\n\n    # Add the required minutes to this\n    sec_since_epoch += minutes * 60\n\n    # And convert it back into a more useful tuple\n    (ayear, amonth, aday, ahour, aminute, asecond, adow, adoy) = time.localtime(sec_since_epoch)\n\n    # And now set the alarm as before, now including the day\n    rtc.clear_alarm_flag()\n    rtc.set_alarm(0, aminute, ahour, aday)\n    rtc.enable_alarm_interrupt(True)\n\n    turn_off()", "\n\nclass Badger2040():\n    def __init__(self):\n        self.display = PicoGraphics(DISPLAY_INKY_PACK)\n        self._led = machine.PWM(machine.Pin(LED))\n        self._led.freq(1000)\n        self._led.duty_u16(0)\n        self._update_speed = 0\n\n    def __getattr__(self, item):\n        # Glue to redirect calls to PicoGraphics\n        return getattr(self.display, item)\n\n    def update(self):\n        t_start = time.ticks_ms()\n        self.display.update()\n        t_elapsed = time.ticks_ms() - t_start\n\n        delay_ms = [4700, 2600, 900, 250][self._update_speed]\n\n        if t_elapsed < delay_ms:\n            time.sleep((delay_ms - t_elapsed) / 1000)\n\n    def set_update_speed(self, speed):\n        self.display.set_update_speed(speed)\n        self._update_speed = speed\n\n    def led(self, brightness):\n        brightness = max(0, min(255, brightness))\n        self._led.duty_u16(int(brightness * 256))\n\n    def invert(self, invert):\n        raise RuntimeError(\"Display invert not supported in PicoGraphics.\")\n\n    def thickness(self, thickness):\n        raise RuntimeError(\"Thickness not supported in PicoGraphics.\")\n\n    def halt(self):\n        turn_off()\n\n    def keepalive(self):\n        turn_on()\n\n    def pressed(self, button):\n        return BUTTONS[button].value() == 1 or pressed_to_wake_get_once(button)\n\n    def pressed_any(self):\n        for button in BUTTONS.values():\n            if button.value():\n                return True\n        return False\n\n    @micropython.native\n    def icon(self, data, index, data_w, icon_size, x, y):\n        s_x = (index * icon_size) % data_w\n        s_y = int((index * icon_size) / data_w)\n\n        for o_y in range(icon_size):\n            for o_x in range(icon_size):\n                o = ((o_y + s_y) * data_w) + (o_x + s_x)\n                bm = 0b10000000 >> (o & 0b111)\n                if data[o >> 3] & bm:\n                    self.display.pixel(x + o_x, y + o_y)\n\n    def image(self, data, w, h, x, y):\n        for oy in range(h):\n            row = data[oy]\n            for ox in range(w):\n                if row & 0b1 == 0:\n                    self.display.pixel(x + ox, y + oy)\n                row >>= 1\n\n    def status_handler(self, mode, status, ip):\n        self.display.set_update_speed(2)\n        print(mode, status, ip)\n        self.display.set_pen(15)\n        self.display.clear()\n        self.display.set_pen(0)\n        if status:\n            self.display.text(\"Connected!\", 10, 10, 300, 0.5)\n            self.display.text(ip, 10, 30, 300, 0.5)\n        else:\n            self.display.text(\"Connecting...\", 10, 10, 300, 0.5)\n        self.update()\n\n    def isconnected(self):\n        import network\n        return network.WLAN(network.STA_IF).isconnected()\n\n    def ip_address(self):\n        import network\n        return network.WLAN(network.STA_IF).ifconfig()[0]\n\n    def connect(self, **args):\n        from network_manager import NetworkManager\n        import WIFI_CONFIG\n        import uasyncio\n        import gc\n\n        status_handler = args.get(\"status_handler\", self.status_handler)\n\n        if WIFI_CONFIG.COUNTRY == \"\":\n            raise RuntimeError(\"You must populate WIFI_CONFIG.py for networking.\")\n\n        network_manager = NetworkManager(WIFI_CONFIG.COUNTRY, status_handler=status_handler)\n        uasyncio.get_event_loop().run_until_complete(network_manager.client(WIFI_CONFIG.SSID, WIFI_CONFIG.PSK))\n        gc.collect()", ""]}
{"filename": "firmware/PIMORONI_BADGER2040W/lib/badger_os.py", "chunked_list": ["import os\nimport gc\nimport time\nimport json\nimport machine\nimport badger2040\n\n\ndef get_battery_level():\n    return 0\n    # Battery measurement\n    vbat_adc = machine.ADC(badger2040.PIN_BATTERY)\n    vref_adc = machine.ADC(badger2040.PIN_1V2_REF)\n    vref_en = machine.Pin(badger2040.PIN_VREF_POWER)\n    vref_en.init(machine.Pin.OUT)\n    vref_en.value(0)\n\n    # Enable the onboard voltage reference\n    vref_en.value(1)\n\n    # Calculate the logic supply voltage, as will be lower that the usual 3.3V when running off low batteries\n    vdd = 1.24 * (65535 / vref_adc.read_u16())\n    vbat = (\n        (vbat_adc.read_u16() / 65535) * 3 * vdd\n    )  # 3 in this is a gain, not rounding of 3.3V\n\n    # Disable the onboard voltage reference\n    vref_en.value(0)\n\n    # Convert the voltage to a level to display onscreen\n    return vbat", "def get_battery_level():\n    return 0\n    # Battery measurement\n    vbat_adc = machine.ADC(badger2040.PIN_BATTERY)\n    vref_adc = machine.ADC(badger2040.PIN_1V2_REF)\n    vref_en = machine.Pin(badger2040.PIN_VREF_POWER)\n    vref_en.init(machine.Pin.OUT)\n    vref_en.value(0)\n\n    # Enable the onboard voltage reference\n    vref_en.value(1)\n\n    # Calculate the logic supply voltage, as will be lower that the usual 3.3V when running off low batteries\n    vdd = 1.24 * (65535 / vref_adc.read_u16())\n    vbat = (\n        (vbat_adc.read_u16() / 65535) * 3 * vdd\n    )  # 3 in this is a gain, not rounding of 3.3V\n\n    # Disable the onboard voltage reference\n    vref_en.value(0)\n\n    # Convert the voltage to a level to display onscreen\n    return vbat", "\n\ndef get_disk_usage():\n    # f_bfree and f_bavail should be the same?\n    # f_files, f_ffree, f_favail and f_flag are unsupported.\n    f_bsize, f_frsize, f_blocks, f_bfree, _, _, _, _, _, f_namemax = os.statvfs(\"/\")\n\n    f_total_size = f_frsize * f_blocks\n    f_total_free = f_bsize * f_bfree\n    f_total_used = f_total_size - f_total_free\n\n    f_used = 100 / f_total_size * f_total_used\n    f_free = 100 / f_total_size * f_total_free\n\n    return f_total_size, f_used, f_free", "\n\ndef state_running():\n    state = {\"running\": \"launcher\"}\n    state_load(\"launcher\", state)\n    return state[\"running\"]\n\n\ndef state_clear_running():\n    running = state_running()\n    state_modify(\"launcher\", {\"running\": \"launcher\"})\n    return running != \"launcher\"", "def state_clear_running():\n    running = state_running()\n    state_modify(\"launcher\", {\"running\": \"launcher\"})\n    return running != \"launcher\"\n\n\ndef state_set_running(app):\n    state_modify(\"launcher\", {\"running\": app})\n\n\ndef state_launch():\n    app = state_running()\n    if app is not None and app != \"launcher\":\n        launch(app)", "\n\ndef state_launch():\n    app = state_running()\n    if app is not None and app != \"launcher\":\n        launch(app)\n\n\ndef state_delete(app):\n    try:\n        os.remove(\"/state/{}.json\".format(app))\n    except OSError:\n        pass", "def state_delete(app):\n    try:\n        os.remove(\"/state/{}.json\".format(app))\n    except OSError:\n        pass\n\n\ndef state_save(app, data):\n    try:\n        with open(\"/state/{}.json\".format(app), \"w\") as f:\n            f.write(json.dumps(data))\n            f.flush()\n    except OSError:\n        import os\n        try:\n            os.stat(\"/state\")\n        except OSError:\n            os.mkdir(\"/state\")\n            state_save(app, data)", "\n\ndef state_modify(app, data):\n    state = {}\n    state_load(app, state)\n    state.update(data)\n    state_save(app, state)\n\n\ndef state_load(app, defaults):\n    try:\n        data = json.loads(open(\"/state/{}.json\".format(app), \"r\").read())\n        if type(data) is dict:\n            defaults.update(data)\n            return True\n    except (OSError, ValueError):\n        pass\n\n    state_save(app, defaults)\n    return False", "\ndef state_load(app, defaults):\n    try:\n        data = json.loads(open(\"/state/{}.json\".format(app), \"r\").read())\n        if type(data) is dict:\n            defaults.update(data)\n            return True\n    except (OSError, ValueError):\n        pass\n\n    state_save(app, defaults)\n    return False", "\n\ndef launch(file):\n    state_set_running(file)\n\n    gc.collect()\n\n    button_a = machine.Pin(badger2040.BUTTON_A, machine.Pin.IN, machine.Pin.PULL_DOWN)\n    button_c = machine.Pin(badger2040.BUTTON_C, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\n    def quit_to_launcher(pin):\n        if button_a.value() and button_c.value():\n            machine.reset()\n\n    button_a.irq(trigger=machine.Pin.IRQ_RISING, handler=quit_to_launcher)\n    button_c.irq(trigger=machine.Pin.IRQ_RISING, handler=quit_to_launcher)\n\n    try:\n        __import__(file)\n\n    except ImportError:\n        # If the app doesn't exist, notify the user\n        warning(None, f\"Could not launch: {file}\")\n        time.sleep(4.0)\n    except Exception as e:\n        # If the app throws an error, catch it and display!\n        print(e)\n        warning(None, str(e))\n        time.sleep(4.0)\n\n    # If the app exits or errors, do not relaunch!\n    state_clear_running()\n    machine.reset()  # Exit back to launcher", "\n\n# Draw an overlay box with a given message within it\ndef warning(display, message, width=badger2040.WIDTH - 20, height=badger2040.HEIGHT - 20, line_spacing=20, text_size=0.6):\n    print(message)\n\n    if display is None:\n        display = badger2040.Badger2040()\n        display.led(128)\n\n    # Draw a light grey background\n    display.set_pen(12)\n    display.rectangle((badger2040.WIDTH - width) // 2, (badger2040.HEIGHT - height) // 2, width, height)\n\n    width -= 20\n    height -= 20\n\n    display.set_pen(15)\n    display.rectangle((badger2040.WIDTH - width) // 2, (badger2040.HEIGHT - height) // 2, width, height)\n\n    # Take the provided message and split it up into\n    # lines that fit within the specified width\n    words = message.split(\" \")\n\n    lines = []\n    current_line = \"\"\n    for word in words:\n        if display.measure_text(current_line + word + \" \", text_size) < width:\n            current_line += word + \" \"\n        else:\n            lines.append(current_line.strip())\n            current_line = word + \" \"\n    lines.append(current_line.strip())\n\n    display.set_pen(0)\n\n    # Display each line of text from the message, centre-aligned\n    num_lines = len(lines)\n    for i in range(num_lines):\n        length = display.measure_text(lines[i], text_size)\n        current_line = (i * line_spacing) - ((num_lines - 1) * line_spacing) // 2\n        display.text(lines[i], (badger2040.WIDTH - length) // 2, (badger2040.HEIGHT // 2) + current_line, badger2040.WIDTH, text_size)\n\n    display.update()", ""]}
{"filename": "firmware/PIMORONI_BADGER2040W/lib/network_manager.py", "chunked_list": ["import rp2\nimport network\nimport machine\nimport uasyncio\n\n\nclass NetworkManager:\n    _ifname = (\"Client\", \"Access Point\")\n\n    def __init__(self, country=\"GB\", client_timeout=60, access_point_timeout=5, status_handler=None, error_handler=None):\n        rp2.country(country)\n        self._ap_if = network.WLAN(network.AP_IF)\n        self._sta_if = network.WLAN(network.STA_IF)\n\n        self._mode = network.STA_IF\n        self._client_timeout = client_timeout\n        self._access_point_timeout = access_point_timeout\n        self._status_handler = status_handler\n        self._error_handler = error_handler\n        self.UID = (\"{:02X}\" * 8).format(*machine.unique_id())\n\n    def isconnected(self):\n        return self._sta_if.isconnected() or self._ap_if.isconnected()\n\n    def config(self, var):\n        if self._sta_if.active():\n            return self._sta_if.config(var)\n        else:\n            if var == \"password\":\n                return self.UID\n            return self._ap_if.config(var)\n\n    def mode(self):\n        if self._sta_if.isconnected():\n            return self._ifname[0]\n        if self._ap_if.isconnected():\n            return self._ifname[1]\n        return None\n\n    def ifaddress(self):\n        if self._sta_if.isconnected():\n            return self._sta_if.ifconfig()[0]\n        if self._ap_if.isconnected():\n            return self._ap_if.ifconfig()[0]\n        return '0.0.0.0'\n\n    def disconnect(self):\n        if self._sta_if.isconnected():\n            self._sta_if.disconnect()\n        if self._ap_if.isconnected():\n            self._ap_if.disconnect()\n\n    async def wait(self, mode):\n        while not self.isconnected():\n            self._handle_status(mode, None)\n            await uasyncio.sleep_ms(1000)\n\n    def _handle_status(self, mode, status):\n        if callable(self._status_handler):\n            self._status_handler(self._ifname[mode], status, self.ifaddress())\n\n    def _handle_error(self, mode, msg):\n        if callable(self._error_handler):\n            if self._error_handler(self._ifname[mode], msg):\n                return\n        raise RuntimeError(msg)\n\n    async def client(self, ssid, psk):\n        if self._sta_if.isconnected():\n            self._handle_status(network.STA_IF, True)\n            return\n\n        self._ap_if.disconnect()\n        self._ap_if.active(False)\n\n        self._sta_if.active(True)\n        self._sta_if.config(pm=0xa11140)\n        self._sta_if.connect(ssid, psk)\n\n        try:\n            await uasyncio.wait_for(self.wait(network.STA_IF), self._client_timeout)\n            self._handle_status(network.STA_IF, True)\n\n        except uasyncio.TimeoutError:\n            self._sta_if.active(False)\n            self._handle_status(network.STA_IF, False)\n            self._handle_error(network.STA_IF, \"WIFI Client Failed\")\n\n    async def access_point(self):\n        if self._ap_if.isconnected():\n            self._handle_status(network.AP_IF, True)\n            return\n\n        self._sta_if.disconnect()\n        self._sta_if.active(False)\n\n        self._ap_if.ifconfig((\"10.10.1.1\", \"255.255.255.0\", \"10.10.1.1\", \"10.10.1.1\"))\n        self._ap_if.config(password=self.UID)\n        self._ap_if.active(True)\n\n        try:\n            await uasyncio.wait_for(self.wait(network.AP_IF), self._access_point_timeout)\n            self._handle_status(network.AP_IF, True)\n\n        except uasyncio.TimeoutError:\n            self._sta_if.active(False)\n            self._handle_status(network.AP_IF, False)\n            self._handle_error(network.AP_IF, \"WIFI Client Failed\")", ""]}
{"filename": "firmware/PIMORONI_BADGER2040/manifest.py", "chunked_list": ["include(\"$(PORT_DIR)/boards/manifest.py\")\n\nfreeze(\"lib/\")"]}
{"filename": "firmware/PIMORONI_BADGER2040/lib/badger2040.py", "chunked_list": ["import machine\nimport micropython\nfrom picographics import PicoGraphics, DISPLAY_INKY_PACK\nimport time\nimport wakeup\n\n\nBUTTON_DOWN = 11\nBUTTON_A = 12\nBUTTON_B = 13", "BUTTON_A = 12\nBUTTON_B = 13\nBUTTON_C = 14\nBUTTON_UP = 15\nBUTTON_USER = 23\n\nBUTTON_MASK = 0b11111 << 11\n\nSYSTEM_VERY_SLOW = 0\nSYSTEM_SLOW = 1", "SYSTEM_VERY_SLOW = 0\nSYSTEM_SLOW = 1\nSYSTEM_NORMAL = 2\nSYSTEM_FAST = 3\nSYSTEM_TURBO = 4\n\nUPDATE_NORMAL = 0\nUPDATE_MEDIUM = 1\nUPDATE_FAST = 2\nUPDATE_TURBO = 3", "UPDATE_FAST = 2\nUPDATE_TURBO = 3\n\nLED = 25\nENABLE_3V3 = 10\nBUSY = 26\n\nWIDTH = 296\nHEIGHT = 128\n", "HEIGHT = 128\n\nSYSTEM_FREQS = [\n    4000000,\n    12000000,\n    48000000,\n    133000000,\n    250000000\n]\n", "]\n\nBUTTONS = {\n    BUTTON_DOWN: machine.Pin(BUTTON_DOWN, machine.Pin.IN, machine.Pin.PULL_DOWN),\n    BUTTON_A: machine.Pin(BUTTON_A, machine.Pin.IN, machine.Pin.PULL_DOWN),\n    BUTTON_B: machine.Pin(BUTTON_B, machine.Pin.IN, machine.Pin.PULL_DOWN),\n    BUTTON_C: machine.Pin(BUTTON_C, machine.Pin.IN, machine.Pin.PULL_DOWN),\n    BUTTON_UP: machine.Pin(BUTTON_UP, machine.Pin.IN, machine.Pin.PULL_DOWN),\n    BUTTON_USER: machine.Pin(BUTTON_USER, machine.Pin.IN, machine.Pin.PULL_UP),\n}", "    BUTTON_USER: machine.Pin(BUTTON_USER, machine.Pin.IN, machine.Pin.PULL_UP),\n}\n\nWAKEUP_MASK = 0\n\nenable = machine.Pin(ENABLE_3V3, machine.Pin.OUT)\nenable.on()\n\n\ndef is_wireless():\n    return False", "\ndef is_wireless():\n    return False\n\n\ndef woken_by_rtc():\n    return False  # Badger 2040 does not include an RTC\n\n\ndef woken_by_button():\n    return wakeup.get_gpio_state() & BUTTON_MASK > 0", "\ndef woken_by_button():\n    return wakeup.get_gpio_state() & BUTTON_MASK > 0\n\n\ndef pressed_to_wake(button):\n    return wakeup.get_gpio_state() & (1 << button) > 0\n\n\ndef reset_pressed_to_wake():\n    wakeup.reset_gpio_state()", "\ndef reset_pressed_to_wake():\n    wakeup.reset_gpio_state()\n\n\ndef pressed_to_wake_get_once(button):\n    global WAKEUP_MASK\n    if button == BUTTON_USER:\n        return False\n    result = (wakeup.get_gpio_state() & ~WAKEUP_MASK & (1 << button)) > 0\n    WAKEUP_MASK |= (1 << button)\n    return result", "\n\ndef system_speed(speed):\n    try:\n        machine.freq(SYSTEM_FREQS[speed])\n    except IndexError:\n        pass\n\n\ndef turn_on():\n    enable.on()", "\ndef turn_on():\n    enable.on()\n\n\ndef turn_off():\n    time.sleep(0.05)\n    enable.off()\n    # Simulate an idle state on USB power by blocking\n    # until a button event\n    while True:\n        for pin, button in BUTTONS.items():\n            if pin == BUTTON_USER:\n                if not button.value():\n                    return\n                continue\n            if button.value():\n                return", "\n\ndef sleep_for(minutes=None):\n    raise RuntimeError(\"Badger 2040 does not include an RTC.\")\n\n\npico_rtc_to_pcf = pcf_to_pico_rtc = sleep_for\n\n\nclass Badger2040():\n    def __init__(self):\n        self.display = PicoGraphics(DISPLAY_INKY_PACK)\n        self._led = machine.PWM(machine.Pin(LED))\n        self._led.freq(1000)\n        self._led.duty_u16(0)\n        self._update_speed = 0\n\n    def __getattr__(self, item):\n        # Glue to redirect calls to PicoGraphics\n        return getattr(self.display, item)\n\n    def update(self):\n        t_start = time.ticks_ms()\n        self.display.update()\n        t_elapsed = time.ticks_ms() - t_start\n\n        delay_ms = [4700, 2600, 900, 250][self._update_speed]\n\n        if t_elapsed < delay_ms:\n            time.sleep((delay_ms - t_elapsed) / 1000)\n\n    def set_update_speed(self, speed):\n        self.display.set_update_speed(speed)\n        self._update_speed = speed\n\n    def led(self, brightness):\n        brightness = max(0, min(255, brightness))\n        self._led.duty_u16(int(brightness * 256))\n\n    def invert(self, invert):\n        raise RuntimeError(\"Display invert not supported in PicoGraphics.\")\n\n    def thickness(self, thickness):\n        raise RuntimeError(\"Thickness not supported in PicoGraphics.\")\n\n    def halt(self):\n        turn_off()\n\n    def keepalive(self):\n        turn_on()\n\n    def pressed(self, button):\n        return BUTTONS[button].value() == (0 if button == BUTTON_USER else 1) or pressed_to_wake_get_once(button)\n\n    def pressed_any(self):\n        for pin, button in BUTTONS.items():\n            if pin == BUTTON_USER:\n                if not button.value():\n                    return True\n                continue\n            if button.value():\n                return True\n        return False\n\n    @micropython.native\n    def icon(self, data, index, data_w, icon_size, x, y):\n        s_x = (index * icon_size) % data_w\n        s_y = int((index * icon_size) / data_w)\n\n        for o_y in range(icon_size):\n            for o_x in range(icon_size):\n                o = ((o_y + s_y) * data_w) + (o_x + s_x)\n                bm = 0b10000000 >> (o & 0b111)\n                if data[o >> 3] & bm:\n                    self.display.pixel(x + o_x, y + o_y)\n\n    def image(self, data, w, h, x, y):\n        for oy in range(h):\n            row = data[oy]\n            for ox in range(w):\n                if row & 0b1 == 0:\n                    self.display.pixel(x + ox, y + oy)\n                row >>= 1\n\n    def isconnected(self):\n        return False\n\n    def ip_address(self):\n        return (0, 0, 0, 0)\n\n    def connect(self):\n        pass", "\nclass Badger2040():\n    def __init__(self):\n        self.display = PicoGraphics(DISPLAY_INKY_PACK)\n        self._led = machine.PWM(machine.Pin(LED))\n        self._led.freq(1000)\n        self._led.duty_u16(0)\n        self._update_speed = 0\n\n    def __getattr__(self, item):\n        # Glue to redirect calls to PicoGraphics\n        return getattr(self.display, item)\n\n    def update(self):\n        t_start = time.ticks_ms()\n        self.display.update()\n        t_elapsed = time.ticks_ms() - t_start\n\n        delay_ms = [4700, 2600, 900, 250][self._update_speed]\n\n        if t_elapsed < delay_ms:\n            time.sleep((delay_ms - t_elapsed) / 1000)\n\n    def set_update_speed(self, speed):\n        self.display.set_update_speed(speed)\n        self._update_speed = speed\n\n    def led(self, brightness):\n        brightness = max(0, min(255, brightness))\n        self._led.duty_u16(int(brightness * 256))\n\n    def invert(self, invert):\n        raise RuntimeError(\"Display invert not supported in PicoGraphics.\")\n\n    def thickness(self, thickness):\n        raise RuntimeError(\"Thickness not supported in PicoGraphics.\")\n\n    def halt(self):\n        turn_off()\n\n    def keepalive(self):\n        turn_on()\n\n    def pressed(self, button):\n        return BUTTONS[button].value() == (0 if button == BUTTON_USER else 1) or pressed_to_wake_get_once(button)\n\n    def pressed_any(self):\n        for pin, button in BUTTONS.items():\n            if pin == BUTTON_USER:\n                if not button.value():\n                    return True\n                continue\n            if button.value():\n                return True\n        return False\n\n    @micropython.native\n    def icon(self, data, index, data_w, icon_size, x, y):\n        s_x = (index * icon_size) % data_w\n        s_y = int((index * icon_size) / data_w)\n\n        for o_y in range(icon_size):\n            for o_x in range(icon_size):\n                o = ((o_y + s_y) * data_w) + (o_x + s_x)\n                bm = 0b10000000 >> (o & 0b111)\n                if data[o >> 3] & bm:\n                    self.display.pixel(x + o_x, y + o_y)\n\n    def image(self, data, w, h, x, y):\n        for oy in range(h):\n            row = data[oy]\n            for ox in range(w):\n                if row & 0b1 == 0:\n                    self.display.pixel(x + ox, y + oy)\n                row >>= 1\n\n    def isconnected(self):\n        return False\n\n    def ip_address(self):\n        return (0, 0, 0, 0)\n\n    def connect(self):\n        pass", ""]}
{"filename": "firmware/PIMORONI_BADGER2040/lib/badger_os.py", "chunked_list": ["import os\nimport gc\nimport time\nimport json\nimport machine\nimport badger2040\n\n\ndef get_battery_level():\n    return 0\n    # Battery measurement\n    vbat_adc = machine.ADC(badger2040.PIN_BATTERY)\n    vref_adc = machine.ADC(badger2040.PIN_1V2_REF)\n    vref_en = machine.Pin(badger2040.PIN_VREF_POWER)\n    vref_en.init(machine.Pin.OUT)\n    vref_en.value(0)\n\n    # Enable the onboard voltage reference\n    vref_en.value(1)\n\n    # Calculate the logic supply voltage, as will be lower that the usual 3.3V when running off low batteries\n    vdd = 1.24 * (65535 / vref_adc.read_u16())\n    vbat = (\n        (vbat_adc.read_u16() / 65535) * 3 * vdd\n    )  # 3 in this is a gain, not rounding of 3.3V\n\n    # Disable the onboard voltage reference\n    vref_en.value(0)\n\n    # Convert the voltage to a level to display onscreen\n    return vbat", "def get_battery_level():\n    return 0\n    # Battery measurement\n    vbat_adc = machine.ADC(badger2040.PIN_BATTERY)\n    vref_adc = machine.ADC(badger2040.PIN_1V2_REF)\n    vref_en = machine.Pin(badger2040.PIN_VREF_POWER)\n    vref_en.init(machine.Pin.OUT)\n    vref_en.value(0)\n\n    # Enable the onboard voltage reference\n    vref_en.value(1)\n\n    # Calculate the logic supply voltage, as will be lower that the usual 3.3V when running off low batteries\n    vdd = 1.24 * (65535 / vref_adc.read_u16())\n    vbat = (\n        (vbat_adc.read_u16() / 65535) * 3 * vdd\n    )  # 3 in this is a gain, not rounding of 3.3V\n\n    # Disable the onboard voltage reference\n    vref_en.value(0)\n\n    # Convert the voltage to a level to display onscreen\n    return vbat", "\n\ndef get_disk_usage():\n    # f_bfree and f_bavail should be the same?\n    # f_files, f_ffree, f_favail and f_flag are unsupported.\n    f_bsize, f_frsize, f_blocks, f_bfree, _, _, _, _, _, f_namemax = os.statvfs(\"/\")\n\n    f_total_size = f_frsize * f_blocks\n    f_total_free = f_bsize * f_bfree\n    f_total_used = f_total_size - f_total_free\n\n    f_used = 100 / f_total_size * f_total_used\n    f_free = 100 / f_total_size * f_total_free\n\n    return f_total_size, f_used, f_free", "\n\ndef state_running():\n    state = {\"running\": \"launcher\"}\n    state_load(\"launcher\", state)\n    return state[\"running\"]\n\n\ndef state_clear_running():\n    running = state_running()\n    state_modify(\"launcher\", {\"running\": \"launcher\"})\n    return running != \"launcher\"", "def state_clear_running():\n    running = state_running()\n    state_modify(\"launcher\", {\"running\": \"launcher\"})\n    return running != \"launcher\"\n\n\ndef state_set_running(app):\n    state_modify(\"launcher\", {\"running\": app})\n\n\ndef state_launch():\n    app = state_running()\n    if app is not None and app != \"launcher\":\n        launch(app)", "\n\ndef state_launch():\n    app = state_running()\n    if app is not None and app != \"launcher\":\n        launch(app)\n\n\ndef state_delete(app):\n    try:\n        os.remove(\"/state/{}.json\".format(app))\n    except OSError:\n        pass", "def state_delete(app):\n    try:\n        os.remove(\"/state/{}.json\".format(app))\n    except OSError:\n        pass\n\n\ndef state_save(app, data):\n    try:\n        with open(\"/state/{}.json\".format(app), \"w\") as f:\n            f.write(json.dumps(data))\n            f.flush()\n    except OSError:\n        import os\n        try:\n            os.stat(\"/state\")\n        except OSError:\n            os.mkdir(\"/state\")\n            state_save(app, data)", "\n\ndef state_modify(app, data):\n    state = {}\n    state_load(app, state)\n    state.update(data)\n    state_save(app, state)\n\n\ndef state_load(app, defaults):\n    try:\n        data = json.loads(open(\"/state/{}.json\".format(app), \"r\").read())\n        if type(data) is dict:\n            defaults.update(data)\n            return True\n    except (OSError, ValueError):\n        pass\n\n    state_save(app, defaults)\n    return False", "\ndef state_load(app, defaults):\n    try:\n        data = json.loads(open(\"/state/{}.json\".format(app), \"r\").read())\n        if type(data) is dict:\n            defaults.update(data)\n            return True\n    except (OSError, ValueError):\n        pass\n\n    state_save(app, defaults)\n    return False", "\n\ndef launch(file):\n    state_set_running(file)\n\n    gc.collect()\n\n    button_a = machine.Pin(badger2040.BUTTON_A, machine.Pin.IN, machine.Pin.PULL_DOWN)\n    button_c = machine.Pin(badger2040.BUTTON_C, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\n    def quit_to_launcher(pin):\n        if button_a.value() and button_c.value():\n            machine.reset()\n\n    button_a.irq(trigger=machine.Pin.IRQ_RISING, handler=quit_to_launcher)\n    button_c.irq(trigger=machine.Pin.IRQ_RISING, handler=quit_to_launcher)\n\n    try:\n        __import__(file)\n\n    except ImportError:\n        # If the app doesn't exist, notify the user\n        warning(None, f\"Could not launch: {file}\")\n        time.sleep(4.0)\n    except Exception as e:\n        # If the app throws an error, catch it and display!\n        print(e)\n        warning(None, str(e))\n        time.sleep(4.0)\n\n    # If the app exits or errors, do not relaunch!\n    state_clear_running()\n    machine.reset()  # Exit back to launcher", "\n\n# Draw an overlay box with a given message within it\ndef warning(display, message, width=badger2040.WIDTH - 20, height=badger2040.HEIGHT - 20, line_spacing=20, text_size=0.6):\n    print(message)\n\n    if display is None:\n        display = badger2040.Badger2040()\n        display.led(128)\n\n    # Draw a light grey background\n    display.set_pen(12)\n    display.rectangle((badger2040.WIDTH - width) // 2, (badger2040.HEIGHT - height) // 2, width, height)\n\n    width -= 20\n    height -= 20\n\n    display.set_pen(15)\n    display.rectangle((badger2040.WIDTH - width) // 2, (badger2040.HEIGHT - height) // 2, width, height)\n\n    # Take the provided message and split it up into\n    # lines that fit within the specified width\n    words = message.split(\" \")\n\n    lines = []\n    current_line = \"\"\n    for word in words:\n        if display.measure_text(current_line + word + \" \", text_size) < width:\n            current_line += word + \" \"\n        else:\n            lines.append(current_line.strip())\n            current_line = word + \" \"\n    lines.append(current_line.strip())\n\n    display.set_pen(0)\n\n    # Display each line of text from the message, centre-aligned\n    num_lines = len(lines)\n    for i in range(num_lines):\n        length = display.measure_text(lines[i], text_size)\n        current_line = (i * line_spacing) - ((num_lines - 1) * line_spacing) // 2\n        display.text(lines[i], (badger2040.WIDTH - length) // 2, (badger2040.HEIGHT // 2) + current_line, badger2040.WIDTH, text_size)\n\n    display.update()", ""]}
