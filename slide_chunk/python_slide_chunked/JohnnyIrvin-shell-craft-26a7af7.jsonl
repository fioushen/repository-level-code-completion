{"filename": "shell_craft/__main__.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom shell_craft.cli import main\n\nif __name__ == \"__main__\":\n    main()\n", ""]}
{"filename": "shell_craft/__init__.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"]}
{"filename": "shell_craft/configuration.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nimport json\nfrom typing import Any, Protocol\nimport pathlib\n\n\nclass Configuration(Protocol):\n    def get(self, key: Any, default=None) -> Any:\n        ...", "\nclass Configuration(Protocol):\n    def get(self, key: Any, default=None) -> Any:\n        ...\n\nclass JSONConfiguration(dict):\n    def __init__(self, text: str) -> None:\n        \"\"\"\n        Initialize the JSON configuration with the given text.\n\n        Args:\n            text (str): The text to parse as JSON.\n        \"\"\"        \n        super().__init__(json.loads(text))\n\n    @classmethod\n    def from_file(cls, path: str) -> \"JSONConfiguration\":\n        \"\"\"\n        Initialize the JSON configuration from the given file.\n\n        Args:\n            path (str): The path to the JSON file.\n\n        Returns:\n            JSONConfiguration: The JSON configuration.\n        \"\"\"        \n        with open(path, \"r\") as file:\n            return cls(file.read())", "\nclass AggregateConfiguration(dict):\n    def __init__(self, configurations: list) -> None:\n        \"\"\"\n        Aggregate the given configurations into a single configuration.\n\n        Args:\n            configurations (list): The configurations to aggregate.\n        \"\"\"        \n        super().__init__({\n            key: config.get(key)\n            for config in configurations[::-1]\n            for key in config.keys()\n        })\n\n    @classmethod\n    def from_files(cls, paths: list[str]) -> \"AggregateConfiguration\":\n        \"\"\"\n        Initialize the aggregate configuration from the given files.\n\n        If a file does not exist, it will be ignored.\n\n        Args:\n            paths (list[str]): The paths to the JSON files.\n\n        Returns:\n            AggregateConfiguration: The aggregate configuration.\n        \"\"\"\n        return cls([\n            JSONConfiguration.from_file(path)\n            for path in paths\n            if path and pathlib.Path(path).exists()\n        ])", ""]}
{"filename": "shell_craft/cli/parser.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom argparse import ArgumentParser, Namespace\nfrom dataclasses import asdict\nfrom sys import argv, stdin\nfrom typing import Callable\n\nfrom shell_craft.configuration import Configuration", "\nfrom shell_craft.configuration import Configuration\nfrom shell_craft.factories import PromptFactory\n\nfrom .commands import Command, CommandGroup, CommandRestriction\n\n\nclass ShellCraftParser:\n    def __init__(self, parser: ArgumentParser, config: Configuration) -> None:\n        \"\"\"\n        Initialize the application parser with the given argparse parser. This\n        is known as a proxy pattern or facade pattern.\n\n        Args:\n            parser (ArgumentParser): The argparse parser to use for the application.\n        \"\"\"        \n        self._parser = parser\n        self._config = config\n        self._commands: list[Command | CommandGroup] = []\n\n    @property\n    def flags(self) -> list[str]:\n        \"\"\"\n        Get the flags for the parser.\n\n        Returns:\n            list[str]: The flags for the parser.\n        \"\"\"\n        return [\n            flag\n            for command in self._commands\n            for flag in command.flags\n        ]\n\n    def add_command(self, command: Command, override: Callable = None) -> \"ShellCraftParser\":\n        \"\"\"\n        Add a command to the parser.\n\n        Args:\n            command (Command): The command to add to the parser.\n            override (Callable, optional): A function to call to override\n                the add_argument function. Defaults to None.\n\n        Returns:\n            ShellCraftParser: The parser with the command added.\n        \"\"\"\n        adder = override or self._parser.add_argument\n\n        flags = ' '.join(command.flags)\n        kwargs = {\n            key: value\n            for key, value in asdict(command).items()\n            if value is not None\n            and key not in ['flags', 'restrictions', 'config']\n        }\n        kwargs['default'] = self._config.get(command.config) or command.default\n\n        adder(flags, **kwargs)\n        self._commands.append(command)\n\n        return self\n    \n    def add_group(self, group: CommandGroup) -> \"ShellCraftParser\":\n        \"\"\"\n        Add a command group to the parser.\n\n        Args:\n            group (CommandGroup): The command group to add to the parser.\n\n        Returns:\n            ShellCraftParser: The parser with the command group added.\n        \"\"\"\n        adder = self._parser.add_argument\n        if group.exclusive:\n            adder = self._parser.add_mutually_exclusive_group().add_argument\n\n        for command in group.commands:\n            self.add_command(command, adder)\n\n        return self\n\n    def can_add(self, command: Command | CommandGroup) -> bool:\n        \"\"\"\n        Determine if the given command can be added to the parser.\n\n        Args:\n            command (Command): The command to check.\n\n        Returns:\n            bool: True if the command can be added, otherwise False.\n        \"\"\"\n        if not command.restrictions:\n            return True\n        \n        if '--prompt' not in self.flags:\n            return False\n        \n        known_args, l = self._parser.parse_known_args()\n        if not known_args.prompt:\n            return False\n        \n        prompt = PromptFactory.get_prompt(known_args.prompt)\n        \n        for restriction in command.restrictions:\n            if restriction == CommandRestriction.PROMPT_TYPE:\n                if type(prompt).__name__ in command.restrictions[restriction]:\n                    continue\n\n            if restriction == CommandRestriction.PROMPT_NAME:\n                prompt_name = known_args.prompt.upper() + \"_PROMPT\"\n\n                if prompt_name in command.restrictions[restriction]:\n                    continue\n            \n            return False\n        \n        return True", "\n\ndef initialize_parser(parser: ArgumentParser, commands: list[Command | CommandGroup], configuration: Configuration) -> ArgumentParser:\n    \"\"\"\n    Initialize the parser with the given commands and command groups. This will add\n    the commands and command groups to the parser and return the parser.\n\n    Args:\n        parser (ArgumentParser): The parser to initialize.\n        commands (list[Command  |  CommandGroup]): The commands and command groups to add to the parser.\n        configuration (Configuration): The configuration to use for the parser.\n\n    Returns:\n        ArgumentParser: The parser with the commands and command groups added.\n    \"\"\"\n    _parser = ShellCraftParser(parser, configuration)\n    for command in commands:\n        if not _parser.can_add(command):\n            continue\n\n        if isinstance(command, Command):\n            _parser.add_command(command)\n        elif isinstance(command, CommandGroup):\n            _parser.add_group(command)\n        \n    return parser", "\ndef get_arguments(parser: ArgumentParser) -> Namespace:\n    \"\"\"\n    Get the arguments from the parser. If there is no input from stdin, then\n    the arguments will be parsed from the command line. If there is input from\n    stdin, then the arguments will be parsed from the command line and stdin after\n    calling a flush on stdin.\n\n    Args:\n        parser (ArgumentParser): The parser to get arguments from.\n\n    Returns:\n        Namespace: The arguments from the parser.\n    \"\"\"\n    arguments: list[str] = argv[1:]\n\n    if not stdin.isatty():\n        stdin.flush()\n        arguments += stdin.readlines()\n\n    return parser.parse_args(arguments)", "\n__all__ = [\n    \"get_arguments\",\n    \"initialize_parser\"\n    \"ShellCraftParser\"\n]\n\n"]}
{"filename": "shell_craft/cli/main.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nimport os\nfrom argparse import ArgumentParser\n\nfrom shell_craft.cli.github import GitHubArguments\nfrom shell_craft.configuration import AggregateConfiguration\nfrom shell_craft.factories import PromptFactory", "from shell_craft.configuration import AggregateConfiguration\nfrom shell_craft.factories import PromptFactory\nfrom shell_craft.services import OpenAIService, OpenAISettings\n\nfrom .commands import _COMMANDS\nfrom .parser import get_arguments, initialize_parser\n\n\ndef _get_configuration() -> AggregateConfiguration:\n    \"\"\"\n    Returns the configuration for the shell-craft CLI.\n\n    Returns:\n        AggregateConfiguration: The configuration for the shell-craft CLI.\n    \"\"\"\n    paths = [\n        os.path.join(os.getcwd(), 'config.json'),\n        os.environ.get('SHELLCRAFT_CONFIG'),\n        '~/.config/shell-craft/config.json'\n    ]\n\n    if os.environ.get('XDG_CONFIG_HOME'):\n        paths.append(os.path.join(os.environ.get('XDG_CONFIG_HOME'), 'shell-craft', 'config.json'))\n\n    return AggregateConfiguration.from_files(paths) | {\n        key.lower(): value\n        for key, value in os.environ.items() \n        if key.isupper()\n    }", "def _get_configuration() -> AggregateConfiguration:\n    \"\"\"\n    Returns the configuration for the shell-craft CLI.\n\n    Returns:\n        AggregateConfiguration: The configuration for the shell-craft CLI.\n    \"\"\"\n    paths = [\n        os.path.join(os.getcwd(), 'config.json'),\n        os.environ.get('SHELLCRAFT_CONFIG'),\n        '~/.config/shell-craft/config.json'\n    ]\n\n    if os.environ.get('XDG_CONFIG_HOME'):\n        paths.append(os.path.join(os.environ.get('XDG_CONFIG_HOME'), 'shell-craft', 'config.json'))\n\n    return AggregateConfiguration.from_files(paths) | {\n        key.lower(): value\n        for key, value in os.environ.items() \n        if key.isupper()\n    }", "\ndef get_github_url_or_error(prompt: str, repository: str) -> str:\n    \"\"\"\n    Returns the GitHub URL for the prompt.\n\n    Args:\n        prompt (str): The prompt to generate the GitHub URL for.\n        repository (str): The GitHub URL to generate the URL for.\n\n    Returns:\n        str: The GitHub URL for the prompt.\n    \"\"\"\n    try:\n        return GitHubArguments.from_prompt(\n            prompt\n        ).as_url(\n            repository\n        )\n    except Exception:\n        return \"Error: Unable to generate GitHub URL.\"", "\n\ndef main():\n    \"\"\"\n    Main function that processes the command-line arguments and queries the\n    OpenAI API using shell_craft.\n    \"\"\"\n    config = _get_configuration()\n    args = get_arguments(\n        initialize_parser(\n            ArgumentParser(\n                prog=\"shell-craft\",\n                description=\"Generating shell commands and code using natural language models (OpenAI ChatGPT).\",\n                add_help=False\n            ),\n            commands=_COMMANDS,\n            configuration=config\n        ),\n    )\n    prompt = PromptFactory.get_prompt(args.prompt)\n\n    if getattr(args, \"refactor\", False):\n        prompt = prompt.refactoring\n    elif getattr(args, \"document\", False):\n        prompt = prompt.documentation\n    elif getattr(args, \"test\", False):\n        prompt = prompt.testing\n\n    results = OpenAIService(\n        OpenAISettings(\n            api_key=args.api_key,\n            model=args.model,\n            count=args.count,\n            temperature=args.temperature,\n            messages=prompt.messages,\n        )\n    ).query(\n        message=' '.join(args.request),\n    )\n\n    github_url = getattr(args, \"github\", None)\n    for _, r in enumerate(results):\n        if github_url:\n            print(get_github_url_or_error(r, github_url))\n        else:\n            print(r)", ""]}
{"filename": "shell_craft/cli/types.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom argparse import ArgumentTypeError\nfrom typing import Callable\n\n\ndef limited_float(min: float, max: float) -> Callable:\n    \"\"\"\n    Create a function that will validate a float is between the given min and\n    max values for use with argparse.\n\n    Args:\n        min (float): The minimum value for the float.\n        max (float): The maximum value for the float.\n\n    Returns:\n        Callable: A function that will validate a float is between the given min\n    \"\"\"    \n    def _ret_func(arg: str) -> float:\n        if arg is None or not str(arg).isdecimal:\n            raise ArgumentTypeError(f\"{arg} is not a decimal\")\n        \n        f = float(arg)\n        if f in [float(\"inf\"), float(\"-inf\")]:\n            raise ArgumentTypeError(f\"{arg} is not a decimal\")\n        \n        if f != f:\n            raise ArgumentTypeError(f\"{arg} is not a decimal\")\n\n        if f < min or f > max:\n            raise ArgumentTypeError(f\"{arg} is not between {min} and {max}\")\n        \n        return f\n    \n    return _ret_func", "def limited_float(min: float, max: float) -> Callable:\n    \"\"\"\n    Create a function that will validate a float is between the given min and\n    max values for use with argparse.\n\n    Args:\n        min (float): The minimum value for the float.\n        max (float): The maximum value for the float.\n\n    Returns:\n        Callable: A function that will validate a float is between the given min\n    \"\"\"    \n    def _ret_func(arg: str) -> float:\n        if arg is None or not str(arg).isdecimal:\n            raise ArgumentTypeError(f\"{arg} is not a decimal\")\n        \n        f = float(arg)\n        if f in [float(\"inf\"), float(\"-inf\")]:\n            raise ArgumentTypeError(f\"{arg} is not a decimal\")\n        \n        if f != f:\n            raise ArgumentTypeError(f\"{arg} is not a decimal\")\n\n        if f < min or f > max:\n            raise ArgumentTypeError(f\"{arg} is not between {min} and {max}\")\n        \n        return f\n    \n    return _ret_func", ""]}
{"filename": "shell_craft/cli/__init__.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom .main import main\n\n__all__ = [\"main\"]\n"]}
{"filename": "shell_craft/cli/prompt.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom os import getppid\n\nfrom psutil import NoSuchProcess, Process\n\n\ndef get_calling_shell() -> str:\n    \"\"\"\n    Get the name of the shell that called this script. This is used to determine\n    the default prompt type. If the calling shell is PowerShell or pwsh, it is converted\n    to \"powershell\" to match the prompt type. If the calling shell is not recognized,\n    the default prompt type is \"bash\".\n\n    If the calling shell cannot be determined, the default prompt type is \"bash\".\n\n    Returns:\n        str: The name of the shell.\n    \"\"\"\n    try:\n        return (\n            \"powershell\" \n            if Process(getppid()).name() in \n            [\"pwsh\", \"powershell\"] else \"bash\"\n        )\n    except NoSuchProcess:\n        return \"bash\"", "\ndef get_calling_shell() -> str:\n    \"\"\"\n    Get the name of the shell that called this script. This is used to determine\n    the default prompt type. If the calling shell is PowerShell or pwsh, it is converted\n    to \"powershell\" to match the prompt type. If the calling shell is not recognized,\n    the default prompt type is \"bash\".\n\n    If the calling shell cannot be determined, the default prompt type is \"bash\".\n\n    Returns:\n        str: The name of the shell.\n    \"\"\"\n    try:\n        return (\n            \"powershell\" \n            if Process(getppid()).name() in \n            [\"pwsh\", \"powershell\"] else \"bash\"\n        )\n    except NoSuchProcess:\n        return \"bash\"", ""]}
{"filename": "shell_craft/cli/github.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom dataclasses import dataclass\nfrom urllib.parse import urlencode, urljoin\n\n\n@dataclass\nclass GitHubArguments:\n    title: str\n    labels: list[str]\n    body: str\n\n    def as_url(self, repository: str) -> str:\n        \"\"\"\n        Generates a URL to open an issue or feature request for the\n        GitHub repository.\n\n        Args:\n            repository (str): The URL to the GitHub repository.\n\n        Returns:\n            str: The URL to open an issue or feature request for the\n                GitHub repository.\n        \"\"\"        \n        return (\n            urljoin(\n                repository.rstrip('/') + '/',\n                'issues/new'\n            )\n            + '?'\n            + urlencode({\n                'title': self.title,\n                'labels': ','.join(self.labels),\n                'body': self.body\n            })\n        )\n    \n    @staticmethod\n    def from_prompt(prompt: str) -> 'GitHubArguments':\n        \"\"\"\n        Parses data from\n\n        ```\n        ---\n        name: <Name Of Bug>\n        about: <Short Description>\n        labels: < Documentation, Enhancement, Question, Bug, etc. >\n        ---\n\n        <body>\n        ```\n        \"\"\"\n        tokens = prompt.split('---')\n\n        if len(tokens) != 3:\n            raise ValueError('Invalid prompt.')\n        \n        _, metadata, body = tokens\n\n        tokens = metadata.split('\\n')\n        metadata = {\n            token.split(':')[0].strip(): ':'.join(token.split(':')[1:]).strip()\n            for token in tokens\n        }\n\n        return GitHubArguments(\n            title=metadata['name'],\n            labels=metadata['labels'].split(','),\n            body=metadata['about'] + '\\n\\n' + body.strip()\n        )", "@dataclass\nclass GitHubArguments:\n    title: str\n    labels: list[str]\n    body: str\n\n    def as_url(self, repository: str) -> str:\n        \"\"\"\n        Generates a URL to open an issue or feature request for the\n        GitHub repository.\n\n        Args:\n            repository (str): The URL to the GitHub repository.\n\n        Returns:\n            str: The URL to open an issue or feature request for the\n                GitHub repository.\n        \"\"\"        \n        return (\n            urljoin(\n                repository.rstrip('/') + '/',\n                'issues/new'\n            )\n            + '?'\n            + urlencode({\n                'title': self.title,\n                'labels': ','.join(self.labels),\n                'body': self.body\n            })\n        )\n    \n    @staticmethod\n    def from_prompt(prompt: str) -> 'GitHubArguments':\n        \"\"\"\n        Parses data from\n\n        ```\n        ---\n        name: <Name Of Bug>\n        about: <Short Description>\n        labels: < Documentation, Enhancement, Question, Bug, etc. >\n        ---\n\n        <body>\n        ```\n        \"\"\"\n        tokens = prompt.split('---')\n\n        if len(tokens) != 3:\n            raise ValueError('Invalid prompt.')\n        \n        _, metadata, body = tokens\n\n        tokens = metadata.split('\\n')\n        metadata = {\n            token.split(':')[0].strip(): ':'.join(token.split(':')[1:]).strip()\n            for token in tokens\n        }\n\n        return GitHubArguments(\n            title=metadata['name'],\n            labels=metadata['labels'].split(','),\n            body=metadata['about'] + '\\n\\n' + body.strip()\n        )", ""]}
{"filename": "shell_craft/cli/commands.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Optional, Type\n\nimport shell_craft.prompts as prompts\n", "import shell_craft.prompts as prompts\n\nfrom .prompt import get_calling_shell\nfrom .types import limited_float\n\n\nclass CommandRestriction(Enum):\n    \"\"\"\n    An enumeration of the different types of restrictions that can be placed on\n    a command. Restrictions are whitelists of values that can be used for a\n    given command.\n    \"\"\"\n    PROMPT_TYPE: str = 'prompt_type'\n    PROMPT_NAME: str = 'prompt_name'", "\n@dataclass\nclass Command:\n    flags: list\n    dest: Optional[str] = None\n    type: Optional[Type] = None\n    default: Optional[str] = None\n    config: Optional[str] = None\n    action: Optional[str] = None\n    help: Optional[str] = None\n    nargs: Optional[str] = None\n    choices: Optional[list] = None\n    restrictions: Optional[dict[CommandRestriction, list]] = None", "\n@dataclass\nclass CommandGroup:\n    name: str\n    commands: list[Command]\n    restrictions: Optional[dict[CommandRestriction, list]] = None\n    exclusive: Optional[bool] = False\n\n_COMMANDS = [\n    Command(", "_COMMANDS = [\n    Command(\n        flags=['request'],\n        type=str,\n        action='store',\n        help='The request to make.',\n        nargs='*',\n    ),\n    Command(\n        flags=['--api-key'],", "    Command(\n        flags=['--api-key'],\n        dest='api_key',\n        type=str,\n        config='openai_api_key',\n        action='store',\n        help='The OpenAI API key to use.',\n    ),\n    Command(\n        flags=['--model'],", "    Command(\n        flags=['--model'],\n        type=str,\n        config='openai_model',\n        default=\"gpt-3.5-turbo\",\n        action='store',\n        help='The OpenAI model to use.',\n        choices=[\n            \"gpt-4\",\n            \"gpt-4-0613\",", "            \"gpt-4\",\n            \"gpt-4-0613\",\n            \"gpt-4-32k\",\n            \"gpt-4-32k-0613\",\n            \"gpt-3.5-turbo\",\n            \"gpt-3.5-turbo-0613\",\n            'gpt-3.5-turbo-16k',\n            'gpt-3.5-turbo-16k-0613',\n        ]\n    ),", "        ]\n    ),\n    Command(\n        flags=['-t', '--temperature'],\n        dest='temperature',\n        type=limited_float(0.0, 2.0),\n        config='openai_temperature',\n        default=1.0,\n        action='store',\n        help='The temperature to use when generating text. Must be between 0 and 2.',", "        action='store',\n        help='The temperature to use when generating text. Must be between 0 and 2.',\n    ),\n    Command(\n        flags=['-c', '--count'],\n        dest='count',\n        type=int,\n        config='openai_count',\n        default=1,\n        action='store',", "        default=1,\n        action='store',\n        help='The number of responses to generate.',\n    ),\n    Command(\n        flags=['--prompt'],\n        dest='prompt',\n        config='shell_craft_prompt',\n        type=str,\n        choices=[", "        type=str,\n        choices=[\n            prompt.removesuffix('_PROMPT').lower()\n            for prompt in dir(prompts)\n            if prompt.endswith(\"PROMPT\")\n        ],\n        default=get_calling_shell(),\n        action='store',\n        help='The type of prompt to use.',\n        nargs='?',", "        help='The type of prompt to use.',\n        nargs='?',\n    ),\n    Command(\n        flags=['--github'],\n        type=str,\n        config='github_repository',\n        action='store',\n        help='The URL to the GitHub repository to open an issue or feature request for.',\n        restrictions={", "        help='The URL to the GitHub repository to open an issue or feature request for.',\n        restrictions={\n            CommandRestriction.PROMPT_NAME: ['BUG_REPORT_PROMPT', 'FEATURE_REQUEST_PROMPT']\n        }\n    ),\n    CommandGroup(\n        name='code',\n        commands=[\n            Command(\n                flags=['--refactor'],", "            Command(\n                flags=['--refactor'],\n                action='store_true',\n                help='Refactor the code.',\n            ),\n            Command(\n                flags=['--test'],\n                action='store_true',\n                help='Test the code.',\n            ),", "                help='Test the code.',\n            ),\n            Command(\n                flags=['--document'],\n                action='store_true',\n                help='Document the code.',\n            ),\n        ],\n        restrictions={\n            CommandRestriction.PROMPT_TYPE: ['LanguagePrompt']", "        restrictions={\n            CommandRestriction.PROMPT_TYPE: ['LanguagePrompt']\n        },\n        exclusive=True\n    ),\n    Command(\n        flags=['--help'],\n        action='help',\n        help='Show this help message and exit.',\n    )", "        help='Show this help message and exit.',\n    )\n]\n\n\n__all__ = [\n    'Command',\n    'CommandGroup',\n    'CommandRestriction',\n]", "    'CommandRestriction',\n]\n"]}
{"filename": "shell_craft/prompts/templates.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom .prompt import Prompt\n\nFEATURE_REQUEST_PROMPT = Prompt(\n    content=\"\"\"\nFill out this form:\n", "Fill out this form:\n\n```\n---\nname: <Name Of Feature>\nabout: <Short Description>\nlabels: < Documentation, Enhancement, Question, Bug, etc. >\n---\n\n**Is your feature request related to a problem? Please describe.**", "\n**Is your feature request related to a problem? Please describe.**\nA clear and concise description of what the problem is. Ex. I'm always frustrated when [...]\n\n**Describe the solution you'd like**\nA clear and concise description of what you want to happen.\n\n**Describe alternatives you've considered**\nA clear and concise description of any alternative solutions or features you've considered.\n```", "A clear and concise description of any alternative solutions or features you've considered.\n```\n\"\"\")\n\nBUG_REPORT_PROMPT = Prompt(\n    content=\"\"\"\nFill out this form with as much detail as possible with the provided information:\n```\n---\nname: <Name Of Bug>", "---\nname: <Name Of Bug>\nabout: <Short Description>\nlabels: < Documentation, Enhancement, Question, Bug, etc. >\n---\n\n**Describe the bug**\nA clear and concise description of what the bug is.\n\n**To Reproduce**", "\n**To Reproduce**\nSteps to reproduce the behavior:\n1. Go to '...'\n2. Click on '....'\n3. Scroll down to '....'\n4. See error\n\n**Expected behavior**\nA clear and concise description of what you expected to happen.", "**Expected behavior**\nA clear and concise description of what you expected to happen.\n```\"\"\")\n"]}
{"filename": "shell_craft/prompts/__init__.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom .languages import (BASH_PROMPT, C_PROMPT, C_SHARP_PROMPT, GO_PROMPT,\n                        JAVA_PROMPT, JAVASCRIPT_PROMPT, POWERSHELL_PROMPT,\n                        PYTHON_PROMPT)\nfrom .prompt import Prompt\nfrom .templates import BUG_REPORT_PROMPT, FEATURE_REQUEST_PROMPT\n", "from .templates import BUG_REPORT_PROMPT, FEATURE_REQUEST_PROMPT\n\n__all__ = [\n    \"BASH_PROMPT\",\n    \"BUG_REPORT_PROMPT\",\n    \"C_PROMPT\",\n    \"C_SHARP_PROMPT\",\n    \"GO_PROMPT\",\n    \"JAVA_PROMPT\",\n    \"JAVASCRIPT_PROMPT\",", "    \"JAVA_PROMPT\",\n    \"JAVASCRIPT_PROMPT\",\n    \"FEATURE_REQUEST_PROMPT\",\n    \"POWERSHELL_PROMPT\",\n    \"PYTHON_PROMPT\",\n    \"Prompt\"\n]\n"]}
{"filename": "shell_craft/prompts/prompt.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom dataclasses import dataclass, field\n\nMODEL_MESSAGE = list[dict[str, str]]\n\n@dataclass(frozen=True)\nclass Prompt:\n    \"\"\"\n    A prompt is a guide for OpenAI models to generate text. It is a\n    string that is used to seed the model's text generation. It is\n    typically a question or a statement that the model is asked to\n    respond to.\n\n    Examples refer to \"user\" messages that are sent to the model, and\n    \"assistant\" messages that are sent from the model. We use this\n    as additional context for the model to generate text.\n    \"\"\"    \n    content: str\n    examples: list[MODEL_MESSAGE] = field(default_factory=list)\n\n    @property\n    def messages(self) -> list[MODEL_MESSAGE]:\n        \"\"\"\n        Get the messages to send to the model. This includes the prompt\n        and any examples. The prompt is sent as a \"system\" message, and\n        the examples are sent as \"user\" and \"assistant\" messages.\n\n        The dictionary is formatted as follows:\n        {\n            \"role\": <\"system\" | \"user\" | \"assistant\">,\n            \"content\": <str>\n        }\n\n        Returns:\n            list[MODEL_MESSAGE]: The messages to send to the model.\n        \"\"\"        \n        return [\n            {\n                \"role\": \"user\",\n                \"content\": self.content\n            }\n        ] + self.examples", "@dataclass(frozen=True)\nclass Prompt:\n    \"\"\"\n    A prompt is a guide for OpenAI models to generate text. It is a\n    string that is used to seed the model's text generation. It is\n    typically a question or a statement that the model is asked to\n    respond to.\n\n    Examples refer to \"user\" messages that are sent to the model, and\n    \"assistant\" messages that are sent from the model. We use this\n    as additional context for the model to generate text.\n    \"\"\"    \n    content: str\n    examples: list[MODEL_MESSAGE] = field(default_factory=list)\n\n    @property\n    def messages(self) -> list[MODEL_MESSAGE]:\n        \"\"\"\n        Get the messages to send to the model. This includes the prompt\n        and any examples. The prompt is sent as a \"system\" message, and\n        the examples are sent as \"user\" and \"assistant\" messages.\n\n        The dictionary is formatted as follows:\n        {\n            \"role\": <\"system\" | \"user\" | \"assistant\">,\n            \"content\": <str>\n        }\n\n        Returns:\n            list[MODEL_MESSAGE]: The messages to send to the model.\n        \"\"\"        \n        return [\n            {\n                \"role\": \"user\",\n                \"content\": self.content\n            }\n        ] + self.examples", ""]}
{"filename": "shell_craft/prompts/languages.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom dataclasses import dataclass\nfrom typing import Optional\n\nfrom .prompt import Prompt\n\n", "\n\n@dataclass(frozen=True)\nclass LanguagePrompt(Prompt):\n    refactoring: Optional[Prompt] = None\n    documentation: Optional[Prompt] = None\n    testing: Optional[Prompt] = None\n\n\ndef _generate_prompt(language: str) -> LanguagePrompt:\n    return LanguagePrompt(\n        content=\" \".join(f\"\"\"\n            You are {language}.\n            You reply with valid {language}, nothing else.\n            No explanations.\n            You receive descriptions and return {language}.\n        \"\"\".split()),\n        refactoring=Prompt(\n            content=\" \".join(f\"\"\"\n                You receive {language} and return {language}.\n                You shorten the code.\n                You remove bugs.\n                You make the code more efficient.\n            \"\"\".split())\n        ),\n        documentation=Prompt(\n            content=\" \".join(f\"\"\"\n                You receive {language} and return {language} with document strings.\n                You add documentation to each function.\n                You add documentation to each class.\n                You explain parameters and return values.\n                You run the code with the documentation in place.\n            \"\"\".split())\n        ),\n        testing=Prompt(\n            content=\" \".join(f\"\"\"\n                You receive {language} and return {language} with tests.\n                You write tests for each function.\n                Tests are written in AAA (Arrange, Act, Assert) format.\n                You do not repeat yourself.\n                You do not return the original code.\n            \"\"\".split())\n        )\n    )", "\ndef _generate_prompt(language: str) -> LanguagePrompt:\n    return LanguagePrompt(\n        content=\" \".join(f\"\"\"\n            You are {language}.\n            You reply with valid {language}, nothing else.\n            No explanations.\n            You receive descriptions and return {language}.\n        \"\"\".split()),\n        refactoring=Prompt(\n            content=\" \".join(f\"\"\"\n                You receive {language} and return {language}.\n                You shorten the code.\n                You remove bugs.\n                You make the code more efficient.\n            \"\"\".split())\n        ),\n        documentation=Prompt(\n            content=\" \".join(f\"\"\"\n                You receive {language} and return {language} with document strings.\n                You add documentation to each function.\n                You add documentation to each class.\n                You explain parameters and return values.\n                You run the code with the documentation in place.\n            \"\"\".split())\n        ),\n        testing=Prompt(\n            content=\" \".join(f\"\"\"\n                You receive {language} and return {language} with tests.\n                You write tests for each function.\n                Tests are written in AAA (Arrange, Act, Assert) format.\n                You do not repeat yourself.\n                You do not return the original code.\n            \"\"\".split())\n        )\n    )", "\ndef get_prompts() -> list[LanguagePrompt]:\n    \"\"\"\n    Returns all of the language prompts. This is used to generate the\n    language prompt choices. This is also used to define the exports.\n\n    Returns:\n        list[LanguagePrompt]: All of the language prompts.\n    \"\"\"    \n    return [\n        prompt for prompt\n        in globals().values()\n        if isinstance(prompt, LanguagePrompt)\n    ]", "\nBASH_PROMPT = _generate_prompt(\"Bash\")\nC_PROMPT = _generate_prompt(\"C\")\nC_SHARP_PROMPT = _generate_prompt(\"C#\")\nGO_PROMPT = _generate_prompt(\"GoLang\")\nPOWERSHELL_PROMPT = _generate_prompt(\"PowerShell\")\nPYTHON_PROMPT = _generate_prompt(\"Python\")\nJAVA_PROMPT = _generate_prompt(\"Java\")\nJAVASCRIPT_PROMPT = _generate_prompt(\"JavaScript\")\n", "JAVASCRIPT_PROMPT = _generate_prompt(\"JavaScript\")\n\n\n__all__ = get_prompts()\n"]}
{"filename": "shell_craft/factories/__init__.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom .prompt import PromptFactory\n\n__all__ = [\"PromptFactory\"]\n"]}
{"filename": "shell_craft/factories/prompt.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom shell_craft.prompts import Prompt\n\n\nclass PromptFactory:\n    @staticmethod\n    def get_prompt(prompt: str) -> Prompt:\n        \"\"\"\n        Generates a new prompt object based on the prompt type. If the prompt\n        type is not supported, a ValueError is raised.\n\n        Args:\n            prompt (str): A string representing the prompt type.\n\n        Raises:\n            ValueError: If the prompt type is not supported.\n\n        Returns:\n            Prompt: A new prompt object.\n        \"\"\"        \n        import shell_craft.prompts as prompts\n\n        if not prompt:\n            return None\n\n        available_prompts = [\n            prompt.removesuffix('_PROMPT').casefold()\n            for prompt in dir(prompts)\n            if prompt.endswith(\"_PROMPT\")\n        ]\n\n        if prompt.casefold() in available_prompts:\n            return getattr(prompts, f\"{prompt.upper()}_PROMPT\")\n\n\n        raise ValueError(f\"Unknown prompt type: {prompt}\")", ""]}
{"filename": "shell_craft/services/__init__.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom .openai import OpenAIService, OpenAISettings\n\n__all__ = [\n    \"OpenAIService\",\n    \"OpenAISettings\",\n]", "    \"OpenAISettings\",\n]\n"]}
{"filename": "shell_craft/services/service.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom typing import Protocol\n\n\nclass Service(Protocol):\n    def query(self, message: str) -> list[str]:\n        \"\"\"\n        Querys the foreign service with the given message and returns the\n        results.\n\n        Args:\n            message (str): The message to query the foreign service with.\n\n        Returns:\n            list[str]: The results of the query.\n        \"\"\"        \n        ...", ""]}
{"filename": "shell_craft/services/openai/settings.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass OpenAISettings:\n    api_key: str\n    model: str\n    count: int\n    temperature: float\n    messages: list[str]", "class OpenAISettings:\n    api_key: str\n    model: str\n    count: int\n    temperature: float\n    messages: list[str]\n"]}
{"filename": "shell_craft/services/openai/__init__.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom .service import OpenAIService, OpenAISettings\n\n__all__ = [\n    'OpenAIService',\n    'OpenAISettings',\n]", "    'OpenAISettings',\n]\n"]}
{"filename": "shell_craft/services/openai/service.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nimport openai\n\nfrom .settings import OpenAISettings\n\n\nclass OpenAIService:\n    def __init__(self, settings: OpenAISettings) -> None:\n        \"\"\"\n        Initialize a new OpenAI service with the given settings. This\n        service is responsible for querying the OpenAI API.\n\n        Args:\n            config (Configuration): The configuration to use for the service.\n        \"\"\"\n        self._settings = settings\n\n    def query(self, message: str) -> list[str]:\n        \"\"\"\n        Query the model with a message.\n\n        Args:\n            message (str): The message to query the model with.\n\n        Returns:\n            list[str]: The response from the model as a string or a list of strings.\n        \"\"\"\n        choices = openai.ChatCompletion.create(\n            api_key=self._settings.api_key,\n            model=self._settings.model,\n            messages=self._settings.messages + [\n                {\n                    \"role\": \"user\",\n                    \"content\": message\n                }\n            ],\n            n=self._settings.count,\n            temperature=self._settings.temperature,\n        )['choices']\n\n        return [choice['message']['content'] for choice in choices]", "\nclass OpenAIService:\n    def __init__(self, settings: OpenAISettings) -> None:\n        \"\"\"\n        Initialize a new OpenAI service with the given settings. This\n        service is responsible for querying the OpenAI API.\n\n        Args:\n            config (Configuration): The configuration to use for the service.\n        \"\"\"\n        self._settings = settings\n\n    def query(self, message: str) -> list[str]:\n        \"\"\"\n        Query the model with a message.\n\n        Args:\n            message (str): The message to query the model with.\n\n        Returns:\n            list[str]: The response from the model as a string or a list of strings.\n        \"\"\"\n        choices = openai.ChatCompletion.create(\n            api_key=self._settings.api_key,\n            model=self._settings.model,\n            messages=self._settings.messages + [\n                {\n                    \"role\": \"user\",\n                    \"content\": message\n                }\n            ],\n            n=self._settings.count,\n            temperature=self._settings.temperature,\n        )['choices']\n\n        return [choice['message']['content'] for choice in choices]", ""]}
{"filename": "tests/test_cli_types.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nimport pytest\nfrom shell_craft.cli.types import limited_float\nfrom argparse import ArgumentTypeError\n\n\n@pytest.mark.parametrize(", "\n@pytest.mark.parametrize(\n    'value, min_value, max_value, expected',\n    [\n        (0.0, 0.0, 1.0, 0.0),\n        (0.5, 0.0, 1.0, 0.5),\n        (1.0, 0.0, 1.0, 1.0),\n        (0.0, 0.0, 1.0, 0.0),\n        (0.5, 0.0, 1.0, 0.5),\n        (1.0, 0.0, 1.0, 1.0),", "        (0.5, 0.0, 1.0, 0.5),\n        (1.0, 0.0, 1.0, 1.0),\n    ]\n)\ndef test_limited_float(value: float, min_value: float, max_value: float, expected: float):\n    assert limited_float(min_value, max_value)(value) == expected\n\n@pytest.mark.parametrize(\n    'value, min_value, max_value, expected',\n    [", "    'value, min_value, max_value, expected',\n    [\n        (0.0, 0.0, 1.0, 0.0),\n        (0.5, 0.0, 1.0, 0.5),\n        (1.0, 0.0, 1.0, 1.0),\n    ]\n)\ndef test_limited_float_min(value: float, min_value: float, max_value: float, expected: float):\n    assert limited_float(min_value, max_value)(value) == expected\n", "\n@pytest.mark.parametrize(\n    'value, min_value, max_value, expected',\n    [\n        (0.0, 0.0, 1.0, 0.0),\n        (0.5, 0.0, 1.0, 0.5),\n        (1.0, 0.0, 1.0, 1.0),\n    ]\n)\ndef test_limited_float_max(value: float, min_value: float, max_value: float, expected: float):\n    assert limited_float(min_value, max_value)(value) == expected", ")\ndef test_limited_float_max(value: float, min_value: float, max_value: float, expected: float):\n    assert limited_float(min_value, max_value)(value) == expected\n\n@pytest.mark.parametrize(\n    'value, min_value, max_value, exception',\n    [\n        (-1.0, 0.0, 1.0, ArgumentTypeError),\n        (2.0, 0.0, 1.0, ArgumentTypeError),\n        (float('inf'), 0.0, 1.0, ArgumentTypeError),", "        (2.0, 0.0, 1.0, ArgumentTypeError),\n        (float('inf'), 0.0, 1.0, ArgumentTypeError),\n        (float('nan'), 0.0, 1.0, ArgumentTypeError),\n        (float('-inf'), 0.0, 1.0, ArgumentTypeError),\n        (None, 0.0, 1.0, ArgumentTypeError),\n    ]\n)\ndef test_limited_float_range_exception(value: float, min_value: float, max_value: float, exception: Exception):\n    with pytest.raises(exception):\n        limited_float(min_value, max_value)(value)"]}
{"filename": "tests/test_factories.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nimport pytest\n\nimport shell_craft.prompts as prompts\nfrom shell_craft.factories import PromptFactory\n\nPROMPTS = [", "\nPROMPTS = [\n    prompt\n    for prompt in dir(prompts)\n    if prompt.endswith(\"_PROMPT\")\n    and not prompt.startswith(\"_\")\n]\n\n@pytest.mark.parametrize(\"prompt\", PROMPTS)\ndef test_prompt_factory(prompt: str):\n    \"\"\"\n    Test that the prompt factory returns the correct prompt.\n\n    Args:\n        prompt (str): The prompt to test.\n    \"\"\"    \n    assert PromptFactory.get_prompt(prompt.removesuffix(\"_PROMPT\")) == getattr(prompts, prompt)", "@pytest.mark.parametrize(\"prompt\", PROMPTS)\ndef test_prompt_factory(prompt: str):\n    \"\"\"\n    Test that the prompt factory returns the correct prompt.\n\n    Args:\n        prompt (str): The prompt to test.\n    \"\"\"    \n    assert PromptFactory.get_prompt(prompt.removesuffix(\"_PROMPT\")) == getattr(prompts, prompt)\n", ""]}
{"filename": "tests/test_configuration.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom unittest.mock import mock_open, patch\n\nimport pytest\nfrom shell_craft.configuration import (AggregateConfiguration, Configuration,\n                                       JSONConfiguration)\n", "                                       JSONConfiguration)\n\n\ndef json_configuration() -> JSONConfiguration:\n    return JSONConfiguration(\n        text=\"\"\"{\n            \"key\": \"json\"\n        }\"\"\"\n    )\n\ndef dictionary_configuration() -> dict:\n    return {\n        \"key\": \"dictionary\"\n    }", "\ndef dictionary_configuration() -> dict:\n    return {\n        \"key\": \"dictionary\"\n    }\n\ndef aggregate_configuration() -> AggregateConfiguration:\n    return AggregateConfiguration(\n        configurations=[\n            json_configuration(),\n            dictionary_configuration(),\n        ]\n    )", "\n@pytest.mark.parametrize(\n    \"configuration, key, value\", [\n    (json_configuration(), \"key\", \"json\"),\n    (dictionary_configuration(), \"key\", \"dictionary\"),\n    (aggregate_configuration(), \"key\", \"json\"),\n])\ndef test_get(configuration: Configuration, key: str, value: str) -> None:\n    assert configuration.get(key) == value\n", "\n@pytest.mark.parametrize(\n    \"configuration, keys\", [\n    (json_configuration(), [\"key\"]),\n    (dictionary_configuration(), [\"key\"]),\n    (aggregate_configuration(), [\"key\"]),\n])\ndef test_get_keys(configuration: Configuration, keys: list[str]) -> None:\n    assert list(configuration.keys()) == keys\n\ndef test_json_from_file() -> None:\n    with patch(\"builtins.open\", mock_open(read_data=\"\"\"{\n        \"key\": \"json\"\n    }\"\"\")):\n        assert JSONConfiguration.from_file(\"file.json\").get(\"key\") == \"json\"", "\ndef test_json_from_file() -> None:\n    with patch(\"builtins.open\", mock_open(read_data=\"\"\"{\n        \"key\": \"json\"\n    }\"\"\")):\n        assert JSONConfiguration.from_file(\"file.json\").get(\"key\") == \"json\"\n\ndef test_aggregate_from_files() -> None:\n    with patch(\"builtins.open\", mock_open(read_data=\"\"\"{\n        \"key\": \"json\"\n    }\"\"\")):\n        with patch(\"pathlib.Path.exists\", return_value=True):\n            assert AggregateConfiguration.from_files([\"file.json\"]).get(\"key\") == \"json\"", ""]}
{"filename": "build/semver_bump.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfrom semver import Version\nfrom pydantic import BaseModel\n\n\nclass VersionBump(BaseModel):\n    version: str\n\n    def bump(self, commit_messages: list[str]) -> \"VersionBump\":\n        \"\"\"\n        Bumps the version based on the commit messages.\n\n        Args:\n            commit_messages (list[str]): The commit messages to use for bumping the version.\n\n        Returns:\n            VersionBump: A new VersionBump object with the bumped version.\n        \"\"\"\n        version = Version.parse(self.version)\n\n        if any(\"BREAKING CHANGE\" in message for message in commit_messages):\n            return VersionBump(version=str(version.bump_major()))\n        elif any(message.strip().startswith('feat') for message in commit_messages):\n            return VersionBump(version=str(version.bump_minor()))\n        elif any(message.strip().startswith(\"fix\") for message in commit_messages):\n            return VersionBump(version=str(version.bump_patch()))\n        \n        return VersionBump(version=str(version))", "class VersionBump(BaseModel):\n    version: str\n\n    def bump(self, commit_messages: list[str]) -> \"VersionBump\":\n        \"\"\"\n        Bumps the version based on the commit messages.\n\n        Args:\n            commit_messages (list[str]): The commit messages to use for bumping the version.\n\n        Returns:\n            VersionBump: A new VersionBump object with the bumped version.\n        \"\"\"\n        version = Version.parse(self.version)\n\n        if any(\"BREAKING CHANGE\" in message for message in commit_messages):\n            return VersionBump(version=str(version.bump_major()))\n        elif any(message.strip().startswith('feat') for message in commit_messages):\n            return VersionBump(version=str(version.bump_minor()))\n        elif any(message.strip().startswith(\"fix\") for message in commit_messages):\n            return VersionBump(version=str(version.bump_patch()))\n        \n        return VersionBump(version=str(version))", "    \ndef get_version() -> VersionBump:\n    \"\"\"\n    Gets the version from the \"pyproject.toml\" file.\n\n    Returns:\n        VersionBump: A VersionBump object with the version.\n    \"\"\"\n    with open(\"pyproject.toml\", \"r\") as f:\n        for line in f:\n            if line.startswith(\"version\"):\n                return VersionBump(version=line.split(\"=\")[1].strip().replace('\"', ''))", "            \ndef write_version(version: VersionBump) -> None:\n    \"\"\"\n    Writes the version to the \"pyproject.toml\" file.\n\n    Args:\n        version (VersionBump): The version to write to the file.\n    \"\"\"\n    with open(\"pyproject.toml\", \"r\") as f:\n        lines = f.readlines()\n        \n    with open(\"pyproject.toml\", \"w\") as f:\n        for line in lines:\n            if line.startswith(\"version\"):\n                f.write(f'version = \"{version.version}\"\\n')\n            else:\n                f.write(line)", "\ndef main() -> None:\n    \"\"\"\n    The main entry point for the script. Assumes that \"git\" is installed.\n    Makes an assumption that the first argument is the tag to use for the\n    version bump.\n\n    If the first argument is \"--version\", then the version will be printed\n    to the console.\n\n    Example:\n        python build/semver_bump.py trunk\n\n        or\n\n        python build/semver_bump.py --version\n\n    Raises:\n        ValueError: If the first argument is not a valid tag.\n\n    Returns:\n        None: None\n    \"\"\"\n    import sys\n    import subprocess\n\n    if sys.argv[1] == \"--version\":\n        print(get_version().version)\n        return\n    \n    write_version(\n        get_version().bump(\n            subprocess.run([\n                \"git\", \"log\", \"--format=%B\", \"--no-merges\",\n                f\"{sys.argv[1]}..HEAD\"],\n                capture_output=True\n            ).stdout.decode(\n                \"utf-8\"\n            ).split(\"\\n\")\n        )\n    )", "\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "build/change_log.py", "chunked_list": ["# Copyright (c) 2023 Johnathan P. Irvin and contributors\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#", "# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION", "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\ndef main() -> None:\n    \"\"\"\n    The main entry point for the script. Assumes that \"git\" is installed.\n    Makes an assumption that the first argument is the tag to use for the\n    changelog.\n\n    Example:\n        python build/change_log.py trunk\n\n    Raises:\n        ValueError: If the first argument is not a valid tag.\n\n    Returns:\n        None: None\n    \"\"\"\n    import sys\n    import subprocess\n\n    print(\n        subprocess.run(\n            [ \n                \"git\",\n                \"log\",\n                '--pretty=format:\"[%H](https://github.com/JohnnyIrvin/shell-craft/commit/%H) %s ([%an](mailto:%ae))%C(auto)\"',\n                \"--no-merges\",\n                \"--source\",\n                f\"{sys.argv[1]}..HEAD\",\n            ],\n            capture_output=True,\n            text=True,\n        ).stdout\n    )", "\nif __name__ == \"__main__\":\n    main()\n"]}
