{"filename": "main.py", "chunked_list": ["#!/usr/bin/python3\n#\n# The MIT License (MIT)\n#\n# Copyright (c) 2013 Andrian Nord\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell", "# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,", "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n#\n\nimport logging", "\nimport logging\nimport io\nimport os\nimport sys\nimport time\n\nimport ljd.rawdump.parser\nimport ljd.rawdump.code\nimport ljd.pseudoasm.writer", "import ljd.rawdump.code\nimport ljd.pseudoasm.writer\nimport ljd.pseudoasm.instructions\nimport ljd.ast.builder\nimport ljd.ast.slotworks\nimport ljd.ast.validator\nimport ljd.ast.locals\nimport ljd.ast.unwarper\nimport ljd.ast.mutator\nimport ljd.ast.printast", "import ljd.ast.mutator\nimport ljd.ast.printast\nimport ljd.lua.writer\n\nlogger = logging.getLogger(__name__)\n\n\nclass MakeFileHandler(logging.FileHandler):\n    def __init__(self, filename, *args, **kwargs):\n        os.makedirs(os.path.dirname(filename), exist_ok=True)\n        logging.FileHandler.__init__(self, filename, *args, **kwargs)", "\n\ndef set_luajit_version():\n    if ljd.CURRENT_VERSION == 21:\n        return\n    from ljd.rawdump.opcodes import _OPCODES as opcodes\n    ljd.CURRENT_VERSION=21\n    ljd.rawdump.code.init(opcodes)\n    ljd.ast.builder.init()\n    ljd.pseudoasm.instructions.init()", "\n\ndef decompile(header, prototype):\n    ast = ljd.ast.builder.build(header, prototype)\n    assert ast, 'invalid ast %r' % ast\n\n    ljd.ast.validator.validate(ast, warped=True)\n    ljd.ast.mutator.pre_pass(ast)\n    ljd.ast.validator.validate(ast, warped=True)\n    ljd.ast.locals.mark_locals(ast)\n    ljd.ast.slotworks.eliminate_temporary(ast, identify_slots=True)\n    ljd.ast.unwarper.unwarp(ast, False)\n    ljd.ast.locals.mark_local_definitions(ast)\n    ljd.ast.mutator.primary_pass(ast)\n    ljd.ast.validator.validate(ast, warped=False)\n    ljd.ast.locals.mark_locals(ast, alt_mode=True)\n    ljd.ast.locals.mark_local_definitions(ast)\n    return ast", "\n\ndef process_file(path_in, path_out=\"o.lua\"):\n    logger.debug('process file start %s -> %s', path_in, path_out)\n    header, prototype = ljd.rawdump.parser.parse(path_in)\n    assert prototype\n    ast = decompile(header, prototype)\n    with open(path_out, 'w', -1, 'UTF8') as f:\n        ljd.lua.writer.write(f, ast)\n    f =open(path_out, 'r', -1, 'UTF8')\n    data = f.read()\n    print(data)\n    f.close()", "\n\ndef process_bytes(data):\n    f = io.BytesIO(data)\n\n    header, prototype = ljd.rawdump.parser.parse(f)\n    ast = decompile(header, prototype)\n    fout = io.StringIO()\n    ljd.lua.writer.write(fout, ast)\n    return fout.getvalue()", "\n\ndef process_folder(in_dir, out_dir, update_outputname=None):\n    from concurrent.futures.process import ProcessPoolExecutor\n    from pathlib import Path\n\n    start = time.time()\n\n    in_dir = Path(in_dir)\n    out_dir = Path(out_dir)\n\n    executor = ProcessPoolExecutor()\n    fs = []\n    for root, _, names in os.walk(in_dir):\n        root = Path(root)\n        reldir = root.relative_to(in_dir)\n        out_root = out_dir / reldir\n        out_root.mkdir(parents=True, exist_ok=True)\n\n        for name in names:\n            relpath = reldir / name\n            path_in = root / name\n            if update_outputname is not None:\n                out_name = update_outputname(name)\n            else:\n                out_name = Path(name).with_suffix('.lua')\n            path_out = out_root / out_name\n            f = executor.submit(process_file, str(path_in), str(path_out))\n            f.path = str(relpath)\n            fs.append(f)\n    failed = []\n    success = []\n    for f in fs:\n        try:\n            f.result()\n            logger.debug(\"SUCCESS %s\" % f.path)\n            success.append(f.path)\n        except Exception as e:\n            failed.append([f.path, e])\n\n    dt = time.time() - start\n    for path, e in failed:\n        logger.info(\"FAILED %s %r\", path, e)\n    logger.warning(\n        \"\u53cd\u7f16\u8bd1\u6210\u529f %s -> %s: success %s, fail %s in %.3fs\",\n        in_dir,\n        out_dir,\n        len(success),\n        len(failed),\n        dt,\n    )\n    return success", "\nif __name__ == '__main__':\n    set_luajit_version()\n    process_file(sys.argv[1])\n"]}
{"filename": "ljd/__init__.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\n# The currently selected LuaJIT bytecode version we're reading\nCURRENT_VERSION = None\n"]}
{"filename": "ljd/rawdump/parser.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\n# !/usr/bin/python3\n\nimport ljd.bytecode.prototype\nimport ljd.rawdump.header\nimport ljd.rawdump.prototype\nimport ljd.util.binstream", "import ljd.rawdump.prototype\nimport ljd.util.binstream\nfrom ljd.util.log import errprint\n\n\nclass _State:\n    def __init__(self):\n        self.stream = ljd.util.binstream.BinStream()\n        self.flags = ljd.rawdump.header.Flags()\n        self.prototypes = []", "\n\ndef parse(filename, on_parse_header=None):\n    parser = _State()\n\n    parser.stream.open(filename)\n\n    header = ljd.rawdump.header.Header()\n\n    r = True\n\n    try:\n        r = r and _read_header(parser, header)\n\n        if r and on_parse_header:\n            on_parse_header(header)\n\n        r = r and _read_prototypes(parser, parser.prototypes)\n    except IOError as e:\n        errprint(\"I/O error while reading dump: {0}\", str(e))\n        r = False\n\n    if r and not parser.stream.eof():\n        errprint(\"Stopped before whole file was read, something wrong\")\n        r = False\n\n    if r and len(parser.prototypes) != 1:\n        errprint(\"Invalid prototypes stack order\")\n        r = False\n\n    parser.stream.close()\n\n    if r:\n        return header, parser.prototypes[0]\n    else:\n        return None, None", "\n\ndef _read_header(parser, header):\n    if not ljd.rawdump.header.read(parser, header):\n        errprint(\"Failed to read raw-dump header\")\n        return False\n\n    if header.flags.is_big_endian:\n        parser.stream.data_byteorder = 'big'\n    else:\n        parser.stream.data_byteorder = 'little'\n\n    parser.header = header  # TODO yzg\n    return True", "\n\ndef _read_prototypes(state, prototypes):\n    while not state.stream.eof():\n        prototype = ljd.bytecode.prototype.Prototype()\n\n        if not ljd.rawdump.prototype.read(state, prototype):\n            if state.stream.eof():\n                break\n            else:\n                errprint(\"Failed to read prototype\")\n                return False\n\n        prototypes.append(prototype)\n\n    return True", ""]}
{"filename": "ljd/rawdump/prototype.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport ljd.bytecode.instructions as ins\nimport ljd.rawdump.code\nimport ljd.rawdump.constants\nimport ljd.rawdump.debuginfo\nfrom ljd.util.log import errprint\n", "from ljd.util.log import errprint\n\nFLAG_HAS_CHILD = 0b00000001\nFLAG_IS_VARIADIC = 0b00000010\nFLAG_HAS_FFI = 0b00000100\nFLAG_JIT_DISABLED = 0b00001000\nFLAG_HAS_ILOOP = 0b00010000\n\n\nclass _State:\n    def __init__(self, parser):\n        for key, value in parser.__dict__.items():\n            setattr(self, key, value)\n\n        self.upvalues_count = 0\n        self.complex_constants_count = 0\n        self.numeric_constants_count = 0\n        self.instructions_count = 0\n        self.debuginfo_size = 0", "\nclass _State:\n    def __init__(self, parser):\n        for key, value in parser.__dict__.items():\n            setattr(self, key, value)\n\n        self.upvalues_count = 0\n        self.complex_constants_count = 0\n        self.numeric_constants_count = 0\n        self.instructions_count = 0\n        self.debuginfo_size = 0", "\n\ndef read(parser, prototype):\n    parser = _State(parser)\n\n    size = parser.stream.read_uleb128()\n\n    if size == 0:\n        return False\n\n    if not parser.stream.check_data_available(size):\n        errprint(\"File truncated\")\n        return False\n\n    start = parser.stream.pos\n\n    r = True\n\n    r = r and _read_flags(parser, prototype)\n    r = r and _read_counts_and_sizes(parser, prototype)\n    r = r and _read_instructions(parser, prototype)\n    r = r and _read_constants(parser, prototype)\n    r = r and _read_debuginfo(parser, prototype)\n\n    end = parser.stream.pos\n\n    if r:\n        assert end - start == size, \\\n            \"Incorrectly read: from {0} to {1} ({2}) instead of {3}\" \\\n            .format(start, end, end - start, size)\n\n    return r", "\n\ndef _read_flags(parser, prototype):\n    bits = parser.stream.read_byte()\n\n    prototype.flags.has_ffi = bool(bits & FLAG_HAS_FFI)\n    bits &= ~FLAG_HAS_FFI\n\n    prototype.flags.has_iloop = bool(bits & FLAG_HAS_ILOOP)\n    bits &= ~FLAG_HAS_ILOOP\n\n    prototype.flags.has_jit = not (bits & FLAG_JIT_DISABLED)\n    bits &= ~FLAG_JIT_DISABLED\n\n    prototype.flags.has_sub_prototypes = bool(bits & FLAG_HAS_CHILD)\n    bits &= ~FLAG_HAS_CHILD\n\n    prototype.flags.is_variadic = bool(bits & FLAG_IS_VARIADIC)\n    bits &= ~FLAG_IS_VARIADIC\n\n    if bits != 0:\n        errprint(\"Unknown prototype flags: {0:08b}\", bits)\n        return False\n\n    return True", "\n\ndef _read_counts_and_sizes(parser, prototype):\n    prototype.arguments_count = parser.stream.read_byte()\n    prototype.framesize = parser.stream.read_byte()\n\n    parser.upvalues_count = parser.stream.read_byte()\n    parser.complex_constants_count = parser.stream.read_uleb128()\n    parser.numeric_constants_count = parser.stream.read_uleb128()\n    parser.instructions_count = parser.stream.read_uleb128()\n\n    if parser.header.flags.is_stripped:\n        parser.debuginfo_size = 0\n    else:\n        parser.debuginfo_size = parser.stream.read_uleb128()\n\n    if parser.debuginfo_size == 0:\n        return True\n\n    prototype.first_line_number = parser.stream.read_uleb128()\n    prototype.lines_count = parser.stream.read_uleb128()\n\n    parser.lines_count = prototype.lines_count\n\n    return True", "\n\ndef _read_instructions(parser, prototype):\n    i = 0\n\n    if prototype.flags.is_variadic:\n        header = ins.FUNCV()\n    else:\n        header = ins.FUNCF()\n\n    header.A = prototype.framesize\n    prototype.instructions.append(header)\n\n    while i < parser.instructions_count:\n        instruction = ljd.rawdump.code.read(parser)\n\n        if not instruction:\n            return False\n\n        prototype.instructions.append(instruction)\n\n        i += 1\n\n    return True", "\n\ndef _read_constants(parser, prototype):\n    return ljd.rawdump.constants.read(parser, prototype.constants)\n\n\ndef _read_debuginfo(stream, prototype):\n    if stream.debuginfo_size == 0:\n        return True\n\n    return ljd.rawdump.debuginfo.read(stream,\n                                      prototype.first_line_number,\n                                      prototype.debuginfo)", ""]}
{"filename": "ljd/rawdump/__init__.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n"]}
{"filename": "ljd/rawdump/opcodes.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport ljd.bytecode.instructions as instructions\n\n_OPCODES = (\n    # Comparison ops\n\n    (0x00, instructions.ISLT),  # @UndefinedVariable", "\n    (0x00, instructions.ISLT),  # @UndefinedVariable\n    (0x01, instructions.ISGE),  # @UndefinedVariable\n    (0x02, instructions.ISLE),  # @UndefinedVariable\n    (0x03, instructions.ISGT),  # @UndefinedVariable\n\n    (0x04, instructions.ISEQV),  # @UndefinedVariable\n    (0x05, instructions.ISNEV),  # @UndefinedVariable\n\n    (0x06, instructions.ISEQS),  # @UndefinedVariable", "\n    (0x06, instructions.ISEQS),  # @UndefinedVariable\n    (0x07, instructions.ISNES),  # @UndefinedVariable\n\n    (0x08, instructions.ISEQN),  # @UndefinedVariable\n    (0x09, instructions.ISNEN),  # @UndefinedVariable\n\n    (0x0A, instructions.ISEQP),  # @UndefinedVariable\n    (0x0B, instructions.ISNEP),  # @UndefinedVariable\n", "    (0x0B, instructions.ISNEP),  # @UndefinedVariable\n\n    # Unary test and copy ops\n\n    (0x0C, instructions.ISTC),  # @UndefinedVariable\n    (0x0D, instructions.ISFC),  # @UndefinedVariable\n\n    (0x0E, instructions.IST),  # @UndefinedVariable\n    (0x0F, instructions.ISF),  # @UndefinedVariable\n    (0x10, instructions.ISTYPE),  # @UndefinedVariable", "    (0x0F, instructions.ISF),  # @UndefinedVariable\n    (0x10, instructions.ISTYPE),  # @UndefinedVariable\n    (0x11, instructions.ISNUM),  # @UndefinedVariable\n\n    # Unary ops\n\n    (0x12, instructions.MOV),  # @UndefinedVariable\n    (0x13, instructions.NOT),  # @UndefinedVariable\n    (0x14, instructions.UNM),  # @UndefinedVariable\n    (0x15, instructions.LEN),  # @UndefinedVariable", "    (0x14, instructions.UNM),  # @UndefinedVariable\n    (0x15, instructions.LEN),  # @UndefinedVariable\n\n    # Binary ops\n\n    (0x16, instructions.ADDVN),  # @UndefinedVariable\n    (0x17, instructions.SUBVN),  # @UndefinedVariable\n    (0x18, instructions.MULVN),  # @UndefinedVariable\n    (0x19, instructions.DIVVN),  # @UndefinedVariable\n    (0x1A, instructions.MODVN),  # @UndefinedVariable", "    (0x19, instructions.DIVVN),  # @UndefinedVariable\n    (0x1A, instructions.MODVN),  # @UndefinedVariable\n\n    (0x1B, instructions.ADDNV),  # @UndefinedVariable\n    (0x1C, instructions.SUBNV),  # @UndefinedVariable\n    (0x1D, instructions.MULNV),  # @UndefinedVariable\n    (0x1E, instructions.DIVNV),  # @UndefinedVariable\n    (0x1F, instructions.MODNV),  # @UndefinedVariable\n\n    (0x20, instructions.ADDVV),  # @UndefinedVariable", "\n    (0x20, instructions.ADDVV),  # @UndefinedVariable\n    (0x21, instructions.SUBVV),  # @UndefinedVariable\n    (0x22, instructions.MULVV),  # @UndefinedVariable\n    (0x23, instructions.DIVVV),  # @UndefinedVariable\n    (0x24, instructions.MODVV),  # @UndefinedVariable\n\n    (0x25, instructions.POW),  # @UndefinedVariable\n    (0x26, instructions.CAT),  # @UndefinedVariable\n", "    (0x26, instructions.CAT),  # @UndefinedVariable\n\n    # Constant ops\n\n    (0x27, instructions.KSTR),  # @UndefinedVariable\n    (0x28, instructions.KCDATA),  # @UndefinedVariable\n    (0x29, instructions.KSHORT),  # @UndefinedVariable\n    (0x2A, instructions.KNUM),  # @UndefinedVariable\n    (0x2B, instructions.KPRI),  # @UndefinedVariable\n", "    (0x2B, instructions.KPRI),  # @UndefinedVariable\n\n    (0x2C, instructions.KNIL),  # @UndefinedVariable\n\n    # Upvalue and function ops\n\n    (0x2D, instructions.UGET),  # @UndefinedVariable\n\n    (0x2E, instructions.USETV),  # @UndefinedVariable\n    (0x2F, instructions.USETS),  # @UndefinedVariable", "    (0x2E, instructions.USETV),  # @UndefinedVariable\n    (0x2F, instructions.USETS),  # @UndefinedVariable\n    (0x30, instructions.USETN),  # @UndefinedVariable\n    (0x31, instructions.USETP),  # @UndefinedVariable\n\n    (0x32, instructions.UCLO),  # @UndefinedVariable\n\n    (0x33, instructions.FNEW),  # @UndefinedVariable\n\n    # Table ops", "\n    # Table ops\n\n    (0x34, instructions.TNEW),  # @UndefinedVariable\n\n    (0x35, instructions.TDUP),  # @UndefinedVariable\n\n    (0x36, instructions.GGET),  # @UndefinedVariable\n    (0x37, instructions.GSET),  # @UndefinedVariable\n", "    (0x37, instructions.GSET),  # @UndefinedVariable\n\n    (0x38, instructions.TGETV),  # @UndefinedVariable\n    (0x39, instructions.TGETS),  # @UndefinedVariable\n    (0x3A, instructions.TGETB),  # @UndefinedVariable\n    (0x3B, instructions.TGETR),  # @UndefinedVariable\n\n    (0x3C, instructions.TSETV),  # @UndefinedVariable\n    (0x3D, instructions.TSETS),  # @UndefinedVariable\n    (0x3E, instructions.TSETB),  # @UndefinedVariable", "    (0x3D, instructions.TSETS),  # @UndefinedVariable\n    (0x3E, instructions.TSETB),  # @UndefinedVariable\n\n    (0x3F, instructions.TSETM),  # @UndefinedVariable\n    (0x40, instructions.TSETR),  # @UndefinedVariable\n\n    # Calls and vararg handling\n\n    (0x41, instructions.CALLM),  # @UndefinedVariable\n    (0x42, instructions.CALL),  # @UndefinedVariable", "    (0x41, instructions.CALLM),  # @UndefinedVariable\n    (0x42, instructions.CALL),  # @UndefinedVariable\n    (0x43, instructions.CALLMT),  # @UndefinedVariable\n    (0x44, instructions.CALLT),  # @UndefinedVariable\n\n    (0x45, instructions.ITERC),  # @UndefinedVariable\n    (0x46, instructions.ITERN),  # @UndefinedVariable\n\n    (0x47, instructions.VARG),  # @UndefinedVariable\n", "    (0x47, instructions.VARG),  # @UndefinedVariable\n\n    (0x48, instructions.ISNEXT),  # @UndefinedVariable\n\n    # Returns\n\n    (0x49, instructions.RETM),  # @UndefinedVariable\n    (0x4A, instructions.RET),  # @UndefinedVariable\n    (0x4B, instructions.RET0),  # @UndefinedVariable\n    (0x4C, instructions.RET1),  # @UndefinedVariable", "    (0x4B, instructions.RET0),  # @UndefinedVariable\n    (0x4C, instructions.RET1),  # @UndefinedVariable\n\n    # Loops and branches\n\n    (0x4D, instructions.FORI),  # @UndefinedVariable\n    (0x4E, instructions.JFORI),  # @UndefinedVariable\n\n    (0x4F, instructions.FORL),  # @UndefinedVariable\n    (0x50, instructions.IFORL),  # @UndefinedVariable", "    (0x4F, instructions.FORL),  # @UndefinedVariable\n    (0x50, instructions.IFORL),  # @UndefinedVariable\n    (0x51, instructions.JFORL),  # @UndefinedVariable\n\n    (0x52, instructions.ITERL),  # @UndefinedVariable\n    (0x53, instructions.IITERL),  # @UndefinedVariable\n    (0x54, instructions.JITERL),  # @UndefinedVariable\n\n    (0x55, instructions.LOOP),  # @UndefinedVariable\n    (0x56, instructions.ILOOP),  # @UndefinedVariable", "    (0x55, instructions.LOOP),  # @UndefinedVariable\n    (0x56, instructions.ILOOP),  # @UndefinedVariable\n    (0x57, instructions.JLOOP),  # @UndefinedVariable\n\n    (0x58, instructions.JMP),  # @UndefinedVariable\n\n    # Function headers\n\n    (0x59, instructions.FUNCF),  # @UndefinedVariable\n    (0x5A, instructions.IFUNCF),  # @UndefinedVariable", "    (0x59, instructions.FUNCF),  # @UndefinedVariable\n    (0x5A, instructions.IFUNCF),  # @UndefinedVariable\n    (0x5B, instructions.JFUNCF),  # @UndefinedVariable\n\n    (0x5C, instructions.FUNCV),  # @UndefinedVariable\n    (0x5D, instructions.IFUNCV),  # @UndefinedVariable\n    (0x5E, instructions.JFUNCV),  # @UndefinedVariable\n\n    (0x5F, instructions.FUNCC),  # @UndefinedVariable\n    (0x60, instructions.FUNCCW)  # @UndefinedVariable", "    (0x5F, instructions.FUNCC),  # @UndefinedVariable\n    (0x60, instructions.FUNCCW)  # @UndefinedVariable\n)\n"]}
{"filename": "ljd/rawdump/constants.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport struct\nimport sys\n\nimport ljd.bytecode.constants\n\nBCDUMP_KGC_CHILD = 0", "\nBCDUMP_KGC_CHILD = 0\nBCDUMP_KGC_TAB = 1\nBCDUMP_KGC_I64 = 2\nBCDUMP_KGC_U64 = 3\nBCDUMP_KGC_COMPLEX = 4\nBCDUMP_KGC_STR = 5\n\nBCDUMP_KTAB_NIL = 0\nBCDUMP_KTAB_FALSE = 1", "BCDUMP_KTAB_NIL = 0\nBCDUMP_KTAB_FALSE = 1\nBCDUMP_KTAB_TRUE = 2\nBCDUMP_KTAB_INT = 3\nBCDUMP_KTAB_NUM = 4\nBCDUMP_KTAB_STR = 5\n\n\ndef read(parser, constants):\n    r = True\n\n    r = r and _read_upvalue_references(parser, constants.upvalue_references)\n    r = r and _read_complex_constants(parser, constants.complex_constants)\n    r = r and _read_numeric_constants(parser, constants.numeric_constants)\n\n    return r", "def read(parser, constants):\n    r = True\n\n    r = r and _read_upvalue_references(parser, constants.upvalue_references)\n    r = r and _read_complex_constants(parser, constants.complex_constants)\n    r = r and _read_numeric_constants(parser, constants.numeric_constants)\n\n    return r\n\n\ndef _read_upvalue_references(parser, references):\n    i = 0\n\n    while i < parser.upvalues_count:\n        i += 1\n        upvalue = parser.stream.read_uint(2)\n        references.append(upvalue)\n\n    return True", "\n\ndef _read_upvalue_references(parser, references):\n    i = 0\n\n    while i < parser.upvalues_count:\n        i += 1\n        upvalue = parser.stream.read_uint(2)\n        references.append(upvalue)\n\n    return True", "\n\ndef _read_complex_constants(parser, complex_constants):\n    i = 0\n\n    while i < parser.complex_constants_count:\n        constant_type = parser.stream.read_uleb128()\n\n        if constant_type >= BCDUMP_KGC_STR:\n            length = constant_type - BCDUMP_KGC_STR\n\n            string = parser.stream.read_bytes(length)\n\n            complex_constants.append(string.decode(\"utf-8\", \"backslashreplace\"))\n        elif constant_type == BCDUMP_KGC_TAB:\n            table = ljd.bytecode.constants.Table()\n\n            if not _read_table(parser, table):\n                return False\n\n            complex_constants.append(table)\n        elif constant_type != BCDUMP_KGC_CHILD:\n            number = _read_number(parser)\n\n            if constant_type == BCDUMP_KGC_COMPLEX:\n                imaginary = _read_number(parser)\n                complex_constants.append((number, imaginary))\n            else:\n                complex_constants.append(number)\n        else:\n            complex_constants.append(parser.prototypes.pop())\n\n        i += 1\n\n    return True", "\n\ndef _read_numeric_constants(parser, numeric_constants):\n    i = 0\n\n    while i < parser.numeric_constants_count:\n        isnum, lo = parser.stream.read_uleb128_from33bit()\n\n        if isnum:\n            hi = parser.stream.read_uleb128()\n\n            number = _assemble_number(lo, hi)\n        else:\n            number = _process_sign(lo)\n\n        numeric_constants.append(number)\n\n        i += 1\n\n    return True", "\n\ndef _read_number(parser):\n    lo = parser.stream.read_uleb128()\n    hi = parser.stream.read_uleb128()\n\n    return _assemble_number(lo, hi)\n\n\ndef _read_signed_int(parser):\n    number = parser.stream.read_uleb128()\n\n    return _process_sign(number)", "\ndef _read_signed_int(parser):\n    number = parser.stream.read_uleb128()\n\n    return _process_sign(number)\n\n\ndef _assemble_number(lo, hi):\n    if sys.byteorder == 'big':\n        float_as_int = lo << 32 | hi\n    else:\n        float_as_int = hi << 32 | lo\n\n    raw_bytes = struct.pack(\"=Q\", float_as_int)\n    return struct.unpack(\"=d\", raw_bytes)[0]", "\n\ndef _process_sign(number):\n    if number & 0x80000000:\n        return -0x100000000 + number\n    else:\n        return number\n\n\ndef _read_table(parser, table):\n    array_items_count = parser.stream.read_uleb128()\n    hash_items_count = parser.stream.read_uleb128()\n\n    while array_items_count > 0:\n        constant = _read_table_item(parser)\n\n        table.array.append(constant)\n\n        array_items_count -= 1\n\n    while hash_items_count > 0:\n        key = _read_table_item(parser)\n        value = _read_table_item(parser)\n\n        table.dictionary.append((key, value))\n\n        hash_items_count -= 1\n\n    return True", "\ndef _read_table(parser, table):\n    array_items_count = parser.stream.read_uleb128()\n    hash_items_count = parser.stream.read_uleb128()\n\n    while array_items_count > 0:\n        constant = _read_table_item(parser)\n\n        table.array.append(constant)\n\n        array_items_count -= 1\n\n    while hash_items_count > 0:\n        key = _read_table_item(parser)\n        value = _read_table_item(parser)\n\n        table.dictionary.append((key, value))\n\n        hash_items_count -= 1\n\n    return True", "\n\ndef _read_table_item(parser):\n    data_type = parser.stream.read_uleb128()\n\n    if data_type >= BCDUMP_KTAB_STR:\n        length = data_type - BCDUMP_KTAB_STR\n\n        return parser.stream.read_bytes(length).decode(\"utf-8\", \"backslashreplace\")\n\n    elif data_type == BCDUMP_KTAB_INT:\n        return _read_signed_int(parser)\n\n    elif data_type == BCDUMP_KTAB_NUM:\n        return _read_number(parser)\n\n    elif data_type == BCDUMP_KTAB_TRUE:\n        return True\n\n    elif data_type == BCDUMP_KTAB_FALSE:\n        return False\n\n    else:\n        assert data_type == BCDUMP_KTAB_NIL\n\n        return None", ""]}
{"filename": "ljd/rawdump/header.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nfrom ljd.util.log import errprint\n\n_MAGIC = b'\\x1bLJ'\n\n_MAX_VERSION = 0x80\n", "_MAX_VERSION = 0x80\n\n_FLAG_IS_BIG_ENDIAN = 0b00000001\n_FLAG_IS_STRIPPED = 0b00000010\n_FLAG_HAS_FFI = 0b00000100\n_FLAG_FR2 = 0b00001000\n\n\nclass Flags:\n    def __init__(self):\n        self.is_big_endian = False\n        self.is_stripped = False\n        self.has_ffi = False\n        self.fr2 = False", "class Flags:\n    def __init__(self):\n        self.is_big_endian = False\n        self.is_stripped = False\n        self.has_ffi = False\n        self.fr2 = False\n\n\nclass Header:\n    def __init__(self):\n        self.version = 0\n        self.flags = Flags()\n        self.origin = b''\n        self.name = b''", "class Header:\n    def __init__(self):\n        self.version = 0\n        self.flags = Flags()\n        self.origin = b''\n        self.name = b''\n\n\ndef read(state, header):\n    r = True\n\n    header.origin = state.stream.name\n\n    r = r and _check_magic(state)\n\n    r = r and _read_version(state, header)\n    r = r and _read_flags(state, header)\n    r = r and _read_name(state, header)\n\n    return r", "def read(state, header):\n    r = True\n\n    header.origin = state.stream.name\n\n    r = r and _check_magic(state)\n\n    r = r and _read_version(state, header)\n    r = r and _read_flags(state, header)\n    r = r and _read_name(state, header)\n\n    return r", "\n\ndef _check_magic(state):\n    if state.stream.read_bytes(3) != _MAGIC:\n        errprint(\"Invalid magic, not a LuaJIT format\")\n        return False\n\n    return True\n\n\ndef _read_version(state, header):\n    header.version = state.stream.read_byte()\n\n    if header.version > _MAX_VERSION:\n        errprint(\"Version {0}: proprietary modifications\",\n                 header.version)\n        return False\n\n    return True", "\n\ndef _read_version(state, header):\n    header.version = state.stream.read_byte()\n\n    if header.version > _MAX_VERSION:\n        errprint(\"Version {0}: proprietary modifications\",\n                 header.version)\n        return False\n\n    return True", "\n\ndef _read_flags(parser, header):\n    bits = parser.stream.read_uleb128()\n\n    header.flags.is_big_endian = bool(bits & _FLAG_IS_BIG_ENDIAN)\n    bits &= ~_FLAG_IS_BIG_ENDIAN\n\n    header.flags.is_stripped = bool(bits & _FLAG_IS_STRIPPED)\n    bits &= ~_FLAG_IS_STRIPPED\n\n    header.flags.has_ffi = bool(bits & _FLAG_HAS_FFI)\n    bits &= ~_FLAG_HAS_FFI\n\n    header.flags.fr2 = bool(bits & _FLAG_FR2)\n    bits &= ~_FLAG_FR2\n\n    parser.flags.is_stripped = header.flags.is_stripped\n    if bits != 0:\n        errprint(\"Unknown flags set: {0:08b}\", bits)\n        return False\n\n    return True", "\n\ndef _read_name(state, header):\n    if header.flags.is_stripped:\n        header.name = state.stream.name\n    else:\n        length = state.stream.read_uleb128()\n        header.name = state.stream.read_bytes(length).decode(\"utf-8\", \"backslashreplace\")\n\n    return True", ""]}
{"filename": "ljd/rawdump/debuginfo.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport sys\n\nimport ljd.bytecode.debuginfo\n\nVARNAME_END = 0\nVARNAME_FOR_IDX = 1", "VARNAME_END = 0\nVARNAME_FOR_IDX = 1\nVARNAME_FOR_STOP = 2\nVARNAME_FOR_STEP = 3\nVARNAME_FOR_GEN = 4\nVARNAME_FOR_STATE = 5\nVARNAME_FOR_CTL = 6\nVARNAME__MAX = 7\n\nINTERNAL_VARNAMES = [", "\nINTERNAL_VARNAMES = [\n    None,\n    \"<index>\",\n    \"<limit>\",\n    \"<step>\",\n    \"<generator>\",\n    \"<state>\",\n    \"<control>\"\n]", "    \"<control>\"\n]\n\n\ndef read(parser, line_offset, debuginfo):\n    r = True\n\n    r = r and _read_lineinfo(parser, line_offset, debuginfo.addr_to_line_map)\n    r = r and _read_upvalue_names(parser, debuginfo.upvalue_variable_names)\n    r = r and _read_variable_infos(parser, debuginfo.variable_info)\n\n    return r", "\n\ndef _read_lineinfo(parser, line_offset, lineinfo):\n    if parser.lines_count >= 65536:\n        lineinfo_size = 4\n    elif parser.lines_count >= 256:\n        lineinfo_size = 2\n    else:\n        lineinfo_size = 1\n\n    lineinfo.append(0)\n\n    while len(lineinfo) < parser.instructions_count + 1:\n        line_number = parser.stream.read_uint(lineinfo_size)\n        lineinfo.append(line_offset + line_number)\n\n    return True", "\n\ndef _read_upvalue_names(parser, names):\n    while len(names) < parser.upvalues_count:\n        string = parser.stream.read_zstring()\n        names.append(string.decode(\"utf-8\", \"backslashreplace\"))\n\n    return True\n\n\ndef _read_variable_infos(parser, infos):\n    # pc - program counter\n    last_addr = 0\n\n    while True:\n        info = ljd.bytecode.debuginfo.VariableInfo()\n\n        internal_vartype = parser.stream.read_byte()\n\n        if internal_vartype >= VARNAME__MAX:\n            prefix = internal_vartype.to_bytes(1, sys.byteorder)\n            suffix = parser.stream.read_zstring()\n\n            info.name = (prefix + suffix).decode(\"utf-8\", \"backslashreplace\")\n            info.type = info.T_VISIBLE\n\n        elif internal_vartype == VARNAME_END:\n            break\n        else:\n            index = internal_vartype\n            info.name = INTERNAL_VARNAMES[index]\n            info.type = info.T_INTERNAL\n\n        start_addr = last_addr + parser.stream.read_uleb128()\n        end_addr = start_addr + parser.stream.read_uleb128()\n\n        info.start_addr = start_addr\n        info.end_addr = end_addr\n\n        last_addr = start_addr\n\n        infos.append(info)\n\n    return True", "\n\ndef _read_variable_infos(parser, infos):\n    # pc - program counter\n    last_addr = 0\n\n    while True:\n        info = ljd.bytecode.debuginfo.VariableInfo()\n\n        internal_vartype = parser.stream.read_byte()\n\n        if internal_vartype >= VARNAME__MAX:\n            prefix = internal_vartype.to_bytes(1, sys.byteorder)\n            suffix = parser.stream.read_zstring()\n\n            info.name = (prefix + suffix).decode(\"utf-8\", \"backslashreplace\")\n            info.type = info.T_VISIBLE\n\n        elif internal_vartype == VARNAME_END:\n            break\n        else:\n            index = internal_vartype\n            info.name = INTERNAL_VARNAMES[index]\n            info.type = info.T_INTERNAL\n\n        start_addr = last_addr + parser.stream.read_uleb128()\n        end_addr = start_addr + parser.stream.read_uleb128()\n\n        info.start_addr = start_addr\n        info.end_addr = end_addr\n\n        last_addr = start_addr\n\n        infos.append(info)\n\n    return True", ""]}
{"filename": "ljd/rawdump/code.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport ljd.bytecode.instructions as instructions\nfrom ljd.util.log import errprint\n\n_MAP = [None] * 256\n\n\ndef read(parser):\n    global _MAP\n\n    codeword = parser.stream.read_uint(4)\n\n    opcode = codeword & 0xFF\n\n    instruction_class = _MAP[opcode]\n\n    if instruction_class is None:\n        errprint(\"Warning: unknown opcode {0:08x}\", opcode)\n        instruction_class = instructions.UNKNW  # @UndefinedVariable\n\n    instruction = instruction_class()\n    instruction.Bytecode = codeword\n\n    if instruction_class.opcode != opcode:\n        instruction.opcode = opcode\n    \n    _set_instruction_operands(parser, codeword, instruction)\n\n    return instruction", "\n\ndef read(parser):\n    global _MAP\n\n    codeword = parser.stream.read_uint(4)\n\n    opcode = codeword & 0xFF\n\n    instruction_class = _MAP[opcode]\n\n    if instruction_class is None:\n        errprint(\"Warning: unknown opcode {0:08x}\", opcode)\n        instruction_class = instructions.UNKNW  # @UndefinedVariable\n\n    instruction = instruction_class()\n    instruction.Bytecode = codeword\n\n    if instruction_class.opcode != opcode:\n        instruction.opcode = opcode\n    \n    _set_instruction_operands(parser, codeword, instruction)\n\n    return instruction", "\n\ndef _set_instruction_operands(parser, codeword, instruction):\n    if instruction.args_count == 3:\n        A = (codeword >> 8) & 0xFF\n        CD = (codeword >> 16) & 0xFF\n        B = (codeword >> 24) & 0xFF\n    else:\n        A = (codeword >> 8) & 0xFF\n        CD = (codeword >> 16) & 0xFFFF\n\n    if instruction.A_type is not None:\n        instruction.A = _process_operand(parser, instruction.A_type, A)\n\n    if instruction.B_type is not None:\n        instruction.B = _process_operand(parser, instruction.B_type, B)\n\n    if instruction.CD_type is not None:\n        instruction.CD = _process_operand(parser, instruction.CD_type, CD)", "\n\ndef _process_operand(parser, operand_type, operand):\n    if operand_type == instructions.T_STR \\\n            or operand_type == instructions.T_TAB \\\n            or operand_type == instructions.T_FUN \\\n            or operand_type == instructions.T_CDT:\n        return parser.complex_constants_count - operand - 1\n    elif operand_type == instructions.T_JMP:\n        return operand - 0x8000\n    else:\n        return operand", "\n\ndef init(opcodes):\n    global _MAP\n\n    for opcode, instruction in sorted(opcodes, key=lambda x: x[0]):\n        _MAP[opcode] = instruction\n\n        # Set's the opcode's code. This used to be done by the\n        # opcode itself, it's now done here. See the comments around\n        # ljd.bytecode.instructions._IDef for a description of\n        # why this is done.\n        instruction.opcode = opcode", ""]}
{"filename": "ljd/bytecode/instructions.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\n#\n# Almost direct wiki-to-code from\n# http://wiki.luajit.org/Bytecode-2.0\n#\n\n", "\n\n# What the hell is an upvalue?\n# It is value from the upper prototype, i.e. a variable stored in a closure.\n\n# What the hell is the MULTRES thing?\n# The magical VM's variable that counts the CALL* or VARG returns.\n# I.e. it's used to speed-up things like foo(var1, var2, bar(var3, var4)) or\n#\n# function foo(...)", "#\n# function foo(...)\n# \tbla-bla\n# \tbar(...)\n#\n\n# Argument types\n\nT_VAR = 0  # variable slot number\nT_DST = 1  # variable slot number, used as a destination", "T_VAR = 0  # variable slot number\nT_DST = 1  # variable slot number, used as a destination\n\nT_BS = 2  # base slot number, read-write\nT_RBS = 3  # base slot number, read-only\n\nT_UV = 4  # upvalue number (slot number, but specific to upvalues)\n\nT_LIT = 5  # literal\nT_SLIT = 6  # signed literal", "T_LIT = 5  # literal\nT_SLIT = 6  # signed literal\n\nT_PRI = 7  # primitive type (0 = nil, 1 = false, 2 = true)\nT_NUM = 8  # numeric constant, index into constant table\nT_STR = 9  # string constant, negated index into constant table\n\nT_TAB = 10  # template table, negated index into constant table\nT_FUN = 11  # function prototype, negated index into constant table\nT_CDT = 12  # cdata constant, negated index into constant table", "T_FUN = 11  # function prototype, negated index into constant table\nT_CDT = 12  # cdata constant, negated index into constant table\nT_JMP = 13  # branch target, relative to next instruction, biased with 0x8000\n\nSLOT_FALSE = 30000  # placeholder slot value for logical false\nSLOT_TRUE = 30001  # placeholder slot value for logical true\n\n\nclass _Instruction:\n    def __init__(self, definition):\n        for key, value in definition.__dict__.items():\n            setattr(self, key, value)\n\n        self.Bytecode = 0\n        if self.A_type is not None:\n            self.A = 0\n\n        if self.B_type is not None:\n            self.B = 0\n\n        if self.CD_type is not None:\n            self.CD = 0", "class _Instruction:\n    def __init__(self, definition):\n        for key, value in definition.__dict__.items():\n            setattr(self, key, value)\n\n        self.Bytecode = 0\n        if self.A_type is not None:\n            self.A = 0\n\n        if self.B_type is not None:\n            self.B = 0\n\n        if self.CD_type is not None:\n            self.CD = 0", "\n\n# Represents a bytecode instruction\n#\n# Note about opcodes:\n# These were previously set from the order the objects were created\n# in. They are now set by ljd.rawdump.code.init, from the luajit_opcode\n# files. (this means the opcodes were duplicated, as they were stored both\n# explicitly in the luajit_opcode files and implicitly in the order of\n# the instruction objects)", "# explicitly in the luajit_opcode files and implicitly in the order of\n# the instruction objects)\n#\n# See ljd.ast.builder.init for a description of why this change was made.\nclass _IDef:\n    def __init__(self, name, A_type, B_type, CD_type, description):\n        self.name = name\n        self.opcode = None  # This gets assigned by ljd.rawdump.code.init\n        self.A_type = A_type\n        self.B_type = B_type\n        self.CD_type = CD_type\n        self.description = description\n\n        self.args_count = (self.A_type is not None) \\\n            + (self.B_type is not None) \\\n            + (self.CD_type is not None)\n\n    def __call__(self):\n        return _Instruction(self)", "\n\n# Names and order are in sync with luaJIT bytecode for ease of changing\n\n# class = name\t\t\tA\tB\tC\tdescription\n# Comparison ops\n\nISLT = _IDef(\"ISLT\", T_VAR, None, T_VAR, \"if {A} < {D}\")\nISGE = _IDef(\"ISGE\", T_VAR, None, T_VAR, \"if {A} >= {D}\")\nISLE = _IDef(\"ISLE\", T_VAR, None, T_VAR, \"if {A} <= {D}\")", "ISGE = _IDef(\"ISGE\", T_VAR, None, T_VAR, \"if {A} >= {D}\")\nISLE = _IDef(\"ISLE\", T_VAR, None, T_VAR, \"if {A} <= {D}\")\nISGT = _IDef(\"ISGT\", T_VAR, None, T_VAR, \"if {A} > {D}\")\n\nISEQV = _IDef(\"ISEQV\", T_VAR, None, T_VAR, \"if {A} == {D}\")\nISNEV = _IDef(\"ISNEV\", T_VAR, None, T_VAR, \"if {A} ~= {D}\")\n\nISEQS = _IDef(\"ISEQS\", T_VAR, None, T_STR, \"if {A} == {D}\")\nISNES = _IDef(\"ISNES\", T_VAR, None, T_STR, \"if {A} ~= {D}\")\n", "ISNES = _IDef(\"ISNES\", T_VAR, None, T_STR, \"if {A} ~= {D}\")\n\nISEQN = _IDef(\"ISEQN\", T_VAR, None, T_NUM, \"if {A} == {D}\")\nISNEN = _IDef(\"ISNEN\", T_VAR, None, T_NUM, \"if {A} ~= {D}\")\n\nISEQP = _IDef(\"ISEQP\", T_VAR, None, T_PRI, \"if {A} == {D}\")\nISNEP = _IDef(\"ISNEP\", T_VAR, None, T_PRI, \"if {A} ~= {D}\")\n\n# Unary test and copy ops\n", "# Unary test and copy ops\n\nISTC = _IDef(\"ISTC\", T_DST, None, T_VAR, \"{A} = {D}; if {D}\")\nISFC = _IDef(\"ISFC\", T_DST, None, T_VAR, \"{A} = {D}; if not {D}\")\n\nIST = _IDef(\"IST\", None, None, T_VAR, \"if {D}\")\nISF = _IDef(\"ISF\", None, None, T_VAR, \"if not {D}\")\n\n# Added in bytecode version 2\nISTYPE = _IDef(\"ISTYPE\", T_VAR, None, T_LIT, \"see lj vm source\")", "# Added in bytecode version 2\nISTYPE = _IDef(\"ISTYPE\", T_VAR, None, T_LIT, \"see lj vm source\")\nISNUM = _IDef(\"ISNUM\", T_VAR, None, T_LIT, \"see lj vm source\")\n\n# Unary ops\n\nMOV = _IDef(\"MOV\", T_DST, None, T_VAR, \"{A} = {D}\")\nNOT = _IDef(\"NOT\", T_DST, None, T_VAR, \"{A} = not {D}\")\nUNM = _IDef(\"UNM\", T_DST, None, T_VAR, \"{A} = -{D}\")\nLEN = _IDef(\"LEN\", T_DST, None, T_VAR, \"{A} = #{D}\")", "UNM = _IDef(\"UNM\", T_DST, None, T_VAR, \"{A} = -{D}\")\nLEN = _IDef(\"LEN\", T_DST, None, T_VAR, \"{A} = #{D}\")\n\n# Binary ops\n\nADDVN = _IDef(\"ADDVN\", T_DST, T_VAR, T_NUM, \"{A} = {B} + {C}\")\nSUBVN = _IDef(\"SUBVN\", T_DST, T_VAR, T_NUM, \"{A} = {B} - {C}\")\nMULVN = _IDef(\"MULVN\", T_DST, T_VAR, T_NUM, \"{A} = {B} * {C}\")\nDIVVN = _IDef(\"DIVVN\", T_DST, T_VAR, T_NUM, \"{A} = {B} / {C}\")\nMODVN = _IDef(\"MODVN\", T_DST, T_VAR, T_NUM, \"{A} = {B} % {C}\")", "DIVVN = _IDef(\"DIVVN\", T_DST, T_VAR, T_NUM, \"{A} = {B} / {C}\")\nMODVN = _IDef(\"MODVN\", T_DST, T_VAR, T_NUM, \"{A} = {B} % {C}\")\n\nADDNV = _IDef(\"ADDNV\", T_DST, T_VAR, T_NUM, \"{A} = {C} + {B}\")\nSUBNV = _IDef(\"SUBNV\", T_DST, T_VAR, T_NUM, \"{A} = {C} - {B}\")\nMULNV = _IDef(\"MULNV\", T_DST, T_VAR, T_NUM, \"{A} = {C} * {B}\")\nDIVNV = _IDef(\"DIVNV\", T_DST, T_VAR, T_NUM, \"{A} = {C} / {B}\")\nMODNV = _IDef(\"MODNV\", T_DST, T_VAR, T_NUM, \"{A} = {C} % {B}\")\n\nADDVV = _IDef(\"ADDVV\", T_DST, T_VAR, T_VAR, \"{A} = {B} + {C}\")", "\nADDVV = _IDef(\"ADDVV\", T_DST, T_VAR, T_VAR, \"{A} = {B} + {C}\")\nSUBVV = _IDef(\"SUBVV\", T_DST, T_VAR, T_VAR, \"{A} = {B} - {C}\")\nMULVV = _IDef(\"MULVV\", T_DST, T_VAR, T_VAR, \"{A} = {B} * {C}\")\nDIVVV = _IDef(\"DIVVV\", T_DST, T_VAR, T_VAR, \"{A} = {B} / {C}\")\nMODVV = _IDef(\"MODVV\", T_DST, T_VAR, T_VAR, \"{A} = {B} % {C}\")\n\nPOW = _IDef(\"POW\", T_DST, T_VAR, T_VAR, \"{A} = {B} ^ {C} (pow)\")\nCAT = _IDef(\"CAT\", T_DST, T_RBS, T_RBS,\n            \"{A} = {concat_from_B_to_C}\")", "CAT = _IDef(\"CAT\", T_DST, T_RBS, T_RBS,\n            \"{A} = {concat_from_B_to_C}\")\n\n# Constant ops.\n\nKSTR = _IDef(\"KSTR\", T_DST, None, T_STR, \"{A} = {D}\")\nKCDATA = _IDef(\"KCDATA\", T_DST, None, T_CDT, \"{A} = {D}\")\nKSHORT = _IDef(\"KSHORT\", T_DST, None, T_SLIT, \"{A} = {D}\")\nKNUM = _IDef(\"KNUM\", T_DST, None, T_NUM, \"{A} = {D}\")\nKPRI = _IDef(\"KPRI\", T_DST, None, T_PRI, \"{A} = {D}\")", "KNUM = _IDef(\"KNUM\", T_DST, None, T_NUM, \"{A} = {D}\")\nKPRI = _IDef(\"KPRI\", T_DST, None, T_PRI, \"{A} = {D}\")\n\nKNIL = _IDef(\"KNIL\", T_BS, None, T_BS, \"{from_A_to_D} = nil\")\n\n# Upvalue and function ops.\n\nUGET = _IDef(\"UGET\", T_DST, None, T_UV, \"{A} = {D}\")\n\nUSETV = _IDef(\"USETV\", T_UV, None, T_VAR, \"{A} = {D}\")", "\nUSETV = _IDef(\"USETV\", T_UV, None, T_VAR, \"{A} = {D}\")\nUSETS = _IDef(\"USETS\", T_UV, None, T_STR, \"{A} = {D}\")\nUSETN = _IDef(\"USETN\", T_UV, None, T_NUM, \"{A} = {D}\")\nUSETP = _IDef(\"USETP\", T_UV, None, T_PRI, \"{A} = {D}\")\n\nUCLO = _IDef(\"UCLO\", T_RBS, None, T_JMP,\n             \"nil uvs >= {A}; goto {D}\")\n\nFNEW = _IDef(\"FNEW\", T_DST, None, T_FUN, \"{A} = function {D}\")", "\nFNEW = _IDef(\"FNEW\", T_DST, None, T_FUN, \"{A} = function {D}\")\n\n# Table ops.\n\nTNEW = _IDef(\"TNEW\", T_DST, None, T_LIT, \"{A} = new table(\"\n                                         \" array: {D_array},\"\n                                         \" dict: {D_dict})\")\n\nTDUP = _IDef(\"TDUP\", T_DST, None, T_TAB, \"{A} = copy {D}\")", "\nTDUP = _IDef(\"TDUP\", T_DST, None, T_TAB, \"{A} = copy {D}\")\n\nGGET = _IDef(\"GGET\", T_DST, None, T_STR, \"{A} = _env[{D}]\")\nGSET = _IDef(\"GSET\", T_VAR, None, T_STR, \"_env[{D}] = {A}\")\n\nTGETV = _IDef(\"TGETV\", T_DST, T_VAR, T_VAR, \"{A} = {B}[{C}]\")\nTGETS = _IDef(\"TGETS\", T_DST, T_VAR, T_STR, \"{A} = {B}.{C}\")\nTGETB = _IDef(\"TGETB\", T_DST, T_VAR, T_LIT, \"{A} = {B}[{C}]\")\n", "TGETB = _IDef(\"TGETB\", T_DST, T_VAR, T_LIT, \"{A} = {B}[{C}]\")\n\n# Added in bytecode version 2\nTGETR = _IDef(\"TGETR\", T_DST, T_VAR, T_VAR, \"{A} = {B}[{C}]\")\n\nTSETV = _IDef(\"TSETV\", T_VAR, T_VAR, T_VAR, \"{B}[{C}] = {A}\")\nTSETS = _IDef(\"TSETS\", T_VAR, T_VAR, T_STR, \"{B}.{C} = {A}\")\nTSETB = _IDef(\"TSETB\", T_VAR, T_VAR, T_LIT, \"{B}[{C}] = {A}\")\n\nTSETM = _IDef(\"TSETM\", T_BS, None, T_NUM,", "\nTSETM = _IDef(\"TSETM\", T_BS, None, T_NUM,\n              \"for i = 0, MULTRES, 1 do\"\n              \" {A_minus_one}[{D_low} + i] = slot({A} + i)\")\n\n# Added in bytecode version 2\nTSETR = _IDef(\"TSETR\", T_VAR, T_VAR, T_VAR, \"{B}[{C}] = {A}\")\n\n# Calls and vararg handling. T = tail call.\n", "# Calls and vararg handling. T = tail call.\n\nCALLM = _IDef(\"CALLM\", T_BS, T_LIT, T_LIT,\n              \"{from_A_x_B_minus_two} = {A}({from_A_plus_one_x_C}, ...MULTRES)\")\n\nCALL = _IDef(\"CALL\", T_BS, T_LIT, T_LIT,\n             \"{from_A_x_B_minus_two} = {A}({from_A_plus_one_x_C_minus_one})\")\n\nCALLMT = _IDef(\"CALLMT\", T_BS, None, T_LIT,\n               \"return {A}({from_A_plus_one_x_D}, ...MULTRES)\")", "CALLMT = _IDef(\"CALLMT\", T_BS, None, T_LIT,\n               \"return {A}({from_A_plus_one_x_D}, ...MULTRES)\")\n\nCALLT = _IDef(\"CALLT\", T_BS, None, T_LIT,\n              \"return {A}({from_A_plus_one_x_D_minus_one})\")\n\nITERC = _IDef(\"ITERC\", T_BS, T_LIT, T_LIT,\n              \"{A}, {A_plus_one}, {A_plus_two} =\"\n              \" {A_minus_three}, {A_minus_two}, {A_minus_one};\"\n              \" {from_A_x_B_minus_two} =\"", "              \" {A_minus_three}, {A_minus_two}, {A_minus_one};\"\n              \" {from_A_x_B_minus_two} =\"\n              \" {A_minus_three}({A_minus_two}, {A_minus_one})\")\n\nITERN = _IDef(\"ITERN\", T_BS, T_LIT, T_LIT,\n              \"{A}, {A_plus_one}, {A_plus_two} =\"\n              \" {A_minus_three}, {A_minus_two}, {A_minus_one};\"\n              \" {from_A_x_B_minus_two} =\"\n              \" {A_minus_three}({A_minus_two}, {A_minus_one})\")\n", "              \" {A_minus_three}({A_minus_two}, {A_minus_one})\")\n\nVARG = _IDef(\"VARG\", T_BS, T_LIT, T_LIT,\n             \"{from_A_x_B_minus_two} = ...\")\n\nISNEXT = _IDef(\"ISNEXT\", T_BS, None, T_JMP,\n               \"Verify ITERN at {D}; goto {D}\")\n\n# Returns.\n", "# Returns.\n\nRETM = _IDef(\"RETM\", T_BS, None, T_LIT,\n             \"return {from_A_x_D_minus_one}, ...MULTRES\")\n\nRET = _IDef(\"RET\", T_RBS, None, T_LIT,\n            \"return {from_A_x_D_minus_two}\")\n\nRET0 = _IDef(\"RET0\", T_RBS, None, T_LIT, \"return\")\nRET1 = _IDef(\"RET1\", T_RBS, None, T_LIT, \"return {A}\")", "RET0 = _IDef(\"RET0\", T_RBS, None, T_LIT, \"return\")\nRET1 = _IDef(\"RET1\", T_RBS, None, T_LIT, \"return {A}\")\n\n# Loops and branches. I/J = interp/JIT, I/C/L = init/call/loop.\n\nFORI = _IDef(\"FORI\", T_BS, None, T_JMP,\n             \"for {A_plus_three} = {A},{A_plus_one},{A_plus_two}\"\n             \" else goto {D}\")\n\nJFORI = _IDef(\"JFORI\", T_BS, None, T_JMP,", "\nJFORI = _IDef(\"JFORI\", T_BS, None, T_JMP,\n              \"for {A_plus_three} = {A},{A_plus_one},{A_plus_two}\"\n              \" else goto {D}\")\n\nFORL = _IDef(\"FORL\", T_BS, None, T_JMP,\n             \"{A} = {A} + {A_plus_two};\"\n             \" if cmp({A}, sign {A_plus_two},  {A_plus_one}) goto {D}\")\n\nIFORL = _IDef(\"IFORL\", T_BS, None, T_JMP,", "\nIFORL = _IDef(\"IFORL\", T_BS, None, T_JMP,\n              \"{A} = {A} + {A_plus_two};\"\n              \" if cmp({A}, sign {A_plus_two}, {A_plus_one}) goto {D}\")\n\nJFORL = _IDef(\"JFORL\", T_BS, None, T_JMP,\n              \"{A} = {A} + {A_plus_two};\"\n              \" if cmp({A}, sign {A_plus_two}, {A_plus_one}) goto {D}\")\n\nITERL = _IDef(\"ITERL\", T_BS, None, T_JMP,", "\nITERL = _IDef(\"ITERL\", T_BS, None, T_JMP,\n              \"{A_minus_one} = {A}; if {A} != nil goto {D}\")\n\nIITERL = _IDef(\"IITERL\", T_BS, None, T_JMP,\n               \"{A_minus_one} = {A}; if {A} != nil goto {D}\")\n\nJITERL = _IDef(\"JITERL\", T_BS, None, T_LIT,\n               \"{A_minus_one} = {A}; if {A} != nil goto {D}\")\n", "               \"{A_minus_one} = {A}; if {A} != nil goto {D}\")\n\nLOOP = _IDef(\"LOOP\", T_RBS, None, T_JMP, \"Loop start, exit goto {D}\")\nILOOP = _IDef(\"ILOOP\", T_RBS, None, T_JMP, \"Noop\")\nJLOOP = _IDef(\"JLOOP\", T_RBS, None, T_LIT, \"Noop\")\n\nJMP = _IDef(\"JMP\", T_RBS, None, T_JMP, \"\tgoto {D}\")\n\n# Function headers. I/J = interp/JIT, F/V/C = fixarg/vararg/C func.\n# Shouldn't be ever seen - they are not stored in raw dump?", "# Function headers. I/J = interp/JIT, F/V/C = fixarg/vararg/C func.\n# Shouldn't be ever seen - they are not stored in raw dump?\n\nFUNCF = _IDef(\"FUNCF\", T_RBS, None, None,\n              \"Fixed-arg function with frame size {A}\")\n\nIFUNCF = _IDef(\"IFUNCF\", T_RBS, None, None,\n               \"Interpreted fixed-arg function with frame size {A}\")\n\nJFUNCF = _IDef(\"JFUNCF\", T_RBS, None, T_LIT,", "\nJFUNCF = _IDef(\"JFUNCF\", T_RBS, None, T_LIT,\n               \"JIT compiled fixed-arg function with frame size {A}\")\n\nFUNCV = _IDef(\"FUNCV\", T_RBS, None, None,\n              \"Var-arg function with frame size {A}\")\n\nIFUNCV = _IDef(\"IFUNCV\", T_RBS, None, None,\n               \"Interpreted var-arg function with frame size {A}\")\n", "               \"Interpreted var-arg function with frame size {A}\")\n\nJFUNCV = _IDef(\"JFUNCV\", T_RBS, None, T_LIT,\n               \"JIT compiled var-arg function with frame size {A}\")\n\nFUNCC = _IDef(\"FUNCC\", T_RBS, None, None,\n              \"C function with frame size {A}\")\nFUNCCW = _IDef(\"FUNCCW\", T_RBS, None, None,\n               \"Wrapped C function with frame size {A}\")\n", "               \"Wrapped C function with frame size {A}\")\n\nUNKNW = _IDef(\"UNKNW\", T_LIT, T_LIT, T_LIT, \"Unknown instruction\")\n"]}
{"filename": "ljd/bytecode/prototype.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport ljd.bytecode.constants as constants\nimport ljd.bytecode.debuginfo as debug\n\n\nclass Flags:\n    def __init(self):\n        self.has_sub_prototypes = False\n        self.is_variadic = False\n        self.has_ffi = False\n        self.has_jit = True\n        self.has_iloop = False", "class Flags:\n    def __init(self):\n        self.has_sub_prototypes = False\n        self.is_variadic = False\n        self.has_ffi = False\n        self.has_jit = True\n        self.has_iloop = False\n\n\nclass Prototype:\n    def __init__(self):\n        self.flags = Flags()\n\n        self.arguments_count = 0\n\n        self.framesize = 0\n\n        self.first_line_number = 0\n        self.lines_count = 0\n\n        self.instructions = []\n        self.constants = constants.Constants()\n        self.debuginfo = debug.DebugInformation()", "\nclass Prototype:\n    def __init__(self):\n        self.flags = Flags()\n\n        self.arguments_count = 0\n\n        self.framesize = 0\n\n        self.first_line_number = 0\n        self.lines_count = 0\n\n        self.instructions = []\n        self.constants = constants.Constants()\n        self.debuginfo = debug.DebugInformation()", ""]}
{"filename": "ljd/bytecode/__init__.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n"]}
{"filename": "ljd/bytecode/constants.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nT_NIL = 0\nT_FALSE = 1\nT_TRUE = 2\n\n\nclass Table:\n    def __init__(self):\n        self.array = []\n\n        # Use a list so we can keep the original items order in the\n        # table\n        self.dictionary = []", "\nclass Table:\n    def __init__(self):\n        self.array = []\n\n        # Use a list so we can keep the original items order in the\n        # table\n        self.dictionary = []\n\n\nclass Constants:\n    def __init__(self):\n        self.upvalue_references = []\n        self.numeric_constants = []\n        self.complex_constants = []", "\n\nclass Constants:\n    def __init__(self):\n        self.upvalue_references = []\n        self.numeric_constants = []\n        self.complex_constants = []\n"]}
{"filename": "ljd/bytecode/debuginfo.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\n\nclass VariableInfo:\n    T_VISIBLE = 0\n    T_INTERNAL = 1\n\n    def __init__(self):\n        self.start_addr = 0\n        self.end_addr = 0\n        self.type = -1\n        self.name = \"\"", "\n\nclass DebugInformation:\n    def __init__(self):\n        self.addr_to_line_map = []\n        self.upvalue_variable_names = []\n        self.variable_info = []\n\n    def lookup_line_number(self, addr):\n        try:\n            return self.addr_to_line_map[addr]\n        except IndexError:\n            return 0\n\n    def lookup_local_name(self, addr, slot, alt_mode=False):\n        for i, info in enumerate(self.variable_info):\n            if info.start_addr > addr:\n                break\n            if info.end_addr <= addr:\n                if alt_mode and info.end_addr == addr:\n                    if slot == 0:\n                        return info\n                    else:\n                        slot -= 1\n                continue\n            elif slot == 0:\n                return info\n            else:\n                slot -= 1\n\n        return None\n\n    def lookup_upvalue_name(self, slot):\n        try:\n            return self.upvalue_variable_names[slot]\n        except IndexError:\n            return None", ""]}
{"filename": "ljd/bytecode/helpers.py", "chunked_list": ["def get_jump_destination(addr, instruction):\n    return addr + instruction.CD + 1\n\n\ndef set_jump_destination(addr, instruction, value):\n    instruction.CD = value - addr - 1\n"]}
{"filename": "ljd/util/log.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport sys\n\n\ndef errprint(*args):\n    fmt = None\n\n    args = list(args)\n\n    if isinstance(args[0], str):\n        fmt = args.pop(0)\n\n    if fmt:\n        print(fmt.format(*args), file=sys.stderr)\n    else:\n        strs = [repr(x) for x in args]\n        print(\" \".join(strs), file=sys.stderr)", ""]}
{"filename": "ljd/util/binstream.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport io\nimport os\nimport sys\n\n\nclass BinStream:\n    def __init__(self):\n        self.fd = None\n\n        self.size = 0\n        self.pos = 0\n        self.name = \"\"\n\n        self.data_byteorder = sys.byteorder\n\n    def open(self, filename):\n        # support for io.BytesIO\n        if hasattr(filename, 'read'):\n            data = filename.read()\n            self.name = ''\n            self.fd = io.BytesIO(data)\n            self.size = len(data)\n        else:\n            self.name = filename\n            self.fd = io.open(filename, 'rb')\n            self.size = os.stat(filename).st_size\n\n    def close(self):\n        self.fd.close()\n        self.size = 0\n        self.pos = 0\n\n    def eof(self):\n        return self.pos >= self.size\n\n    def check_data_available(self, size=1):\n        return self.pos + size <= self.size\n\n    def read_bytes(self, size=1):\n        if not self.check_data_available(size):\n            raise IOError(\"Unexpected EOF while trying to read {0} bytes\"\n                          .format(size))\n\n        data = self.fd.read(size)\n        self.pos += size\n\n        return data\n\n    def read_byte(self):\n        if not self.check_data_available(1):\n            raise IOError(\"Unexpected EOF while trying to read 1 byte\")\n\n        data = self.fd.read(1)\n        self.pos += 1\n\n        return int.from_bytes(data,\n                              byteorder=sys.byteorder,\n                              signed=False)\n\n    def read_zstring(self):\n        string = b''\n\n        while not self.eof():\n            byte = self.read_bytes(1)\n\n            if byte == b'\\x00':\n                return string\n            else:\n                string += byte\n\n        return string\n\n    def read_uleb128(self):\n        value = self.read_byte()\n\n        if value >= 0x80:\n            bitshift = 0\n            value &= 0x7f\n\n            while True:\n                byte = self.read_byte()\n\n                bitshift += 7\n                value |= (byte & 0x7f) << bitshift\n\n                if byte < 0x80:\n                    break\n\n        return value\n\n    def read_uleb128_str(self, length=1):\n        string = \"\"\n        i = 0\n\n        while length > i:\n            string += chr(self.read_uleb128())\n            i = i + 1\n\n        return string\n\n    @staticmethod\n    def decode_uleb128(buff, buff_len):\n        string = \"\"\n        i = 0\n\n        while buff_len > i:\n            value = buff[i]\n            i = i + 1\n\n            print(str(value))\n            print(chr(value))\n            print(value >= 0x80)\n\n            if value >= 0x80 and buff_len > i:\n                bitshift = 0\n                value &= 0x7f\n\n                print(str(value))\n                print(chr(value))\n\n                while buff_len > i:\n                    byte = buff[i]\n                    i = i + 1\n\n                    bitshift += 7\n                    value |= (byte & 0x7f) << bitshift\n\n                    if byte < 0x80:\n                        break\n\n            print(str(value))\n            print(chr(value))\n\n            if value == 0 or value == 128:\n                string += \"\\\\\" + str(value)\n            else:\n                string += chr(value)\n\n        return string\n\n    def read_uleb128_from33bit(self):\n        first_byte = self.read_byte()\n\n        is_number_bit = first_byte & 0x1\n        value = first_byte >> 1\n\n        if value >= 0x40:\n            bitshift = -1\n            value &= 0x3f\n\n            while True:\n                byte = self.read_byte()\n\n                bitshift += 7\n                value |= (byte & 0x7f) << bitshift\n\n                if byte < 0x80:\n                    break\n\n        return is_number_bit, value\n\n    def read_uint(self, size=4):\n        value = self.read_bytes(size)\n\n        return int.from_bytes(value, byteorder=self.data_byteorder,\n                              signed=False)", "\nclass BinStream:\n    def __init__(self):\n        self.fd = None\n\n        self.size = 0\n        self.pos = 0\n        self.name = \"\"\n\n        self.data_byteorder = sys.byteorder\n\n    def open(self, filename):\n        # support for io.BytesIO\n        if hasattr(filename, 'read'):\n            data = filename.read()\n            self.name = ''\n            self.fd = io.BytesIO(data)\n            self.size = len(data)\n        else:\n            self.name = filename\n            self.fd = io.open(filename, 'rb')\n            self.size = os.stat(filename).st_size\n\n    def close(self):\n        self.fd.close()\n        self.size = 0\n        self.pos = 0\n\n    def eof(self):\n        return self.pos >= self.size\n\n    def check_data_available(self, size=1):\n        return self.pos + size <= self.size\n\n    def read_bytes(self, size=1):\n        if not self.check_data_available(size):\n            raise IOError(\"Unexpected EOF while trying to read {0} bytes\"\n                          .format(size))\n\n        data = self.fd.read(size)\n        self.pos += size\n\n        return data\n\n    def read_byte(self):\n        if not self.check_data_available(1):\n            raise IOError(\"Unexpected EOF while trying to read 1 byte\")\n\n        data = self.fd.read(1)\n        self.pos += 1\n\n        return int.from_bytes(data,\n                              byteorder=sys.byteorder,\n                              signed=False)\n\n    def read_zstring(self):\n        string = b''\n\n        while not self.eof():\n            byte = self.read_bytes(1)\n\n            if byte == b'\\x00':\n                return string\n            else:\n                string += byte\n\n        return string\n\n    def read_uleb128(self):\n        value = self.read_byte()\n\n        if value >= 0x80:\n            bitshift = 0\n            value &= 0x7f\n\n            while True:\n                byte = self.read_byte()\n\n                bitshift += 7\n                value |= (byte & 0x7f) << bitshift\n\n                if byte < 0x80:\n                    break\n\n        return value\n\n    def read_uleb128_str(self, length=1):\n        string = \"\"\n        i = 0\n\n        while length > i:\n            string += chr(self.read_uleb128())\n            i = i + 1\n\n        return string\n\n    @staticmethod\n    def decode_uleb128(buff, buff_len):\n        string = \"\"\n        i = 0\n\n        while buff_len > i:\n            value = buff[i]\n            i = i + 1\n\n            print(str(value))\n            print(chr(value))\n            print(value >= 0x80)\n\n            if value >= 0x80 and buff_len > i:\n                bitshift = 0\n                value &= 0x7f\n\n                print(str(value))\n                print(chr(value))\n\n                while buff_len > i:\n                    byte = buff[i]\n                    i = i + 1\n\n                    bitshift += 7\n                    value |= (byte & 0x7f) << bitshift\n\n                    if byte < 0x80:\n                        break\n\n            print(str(value))\n            print(chr(value))\n\n            if value == 0 or value == 128:\n                string += \"\\\\\" + str(value)\n            else:\n                string += chr(value)\n\n        return string\n\n    def read_uleb128_from33bit(self):\n        first_byte = self.read_byte()\n\n        is_number_bit = first_byte & 0x1\n        value = first_byte >> 1\n\n        if value >= 0x40:\n            bitshift = -1\n            value &= 0x3f\n\n            while True:\n                byte = self.read_byte()\n\n                bitshift += 7\n                value |= (byte & 0x7f) << bitshift\n\n                if byte < 0x80:\n                    break\n\n        return is_number_bit, value\n\n    def read_uint(self, size=4):\n        value = self.read_bytes(size)\n\n        return int.from_bytes(value, byteorder=self.data_byteorder,\n                              signed=False)", ""]}
{"filename": "ljd/util/__init__.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n"]}
{"filename": "ljd/util/indentedstream.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\n_TAB_WIDTH = \" \" * 8\n\n\nclass IndentedStream:\n    def __init__(self, fd):\n        self.fd = fd\n\n        self.indent = 0\n        self.line_open = False\n\n    def write_multiline(self, fmt, *args, **kargs):\n        assert not self.line_open\n\n        if len(args) + len(kargs) > 0:\n            text = fmt.format(*args, **kargs)\n        else:\n            text = fmt\n\n        lines = text.split(\"\\n\")\n\n        if lines[0] == \"\":\n            lines.pop(0)\n\n        if lines[-1] == \"\":\n            lines.pop(-1)\n\n        spaces = \"\\t\" * self.indent\n\n        for line in lines:\n            self.fd.write(spaces + line + \"\\n\")\n\n    def start_line(self):\n        assert not self.line_open\n        self.line_open = True\n\n        self.fd.write(\"\\t\" * self.indent)\n\n    def write(self, fmt=\"\", *args, **kargs):\n        assert self.line_open\n\n        if len(args) + len(kargs) > 0:\n            text = fmt.format(*args, **kargs)\n        elif isinstance(fmt, str):\n            text = fmt\n        else:\n            text = str(fmt)\n\n        self.fd.write(text)\n\n    def end_line(self):\n        assert self.line_open\n\n        self.fd.write(\"\\n\")\n\n        self.line_open = False\n\n    def write_line(self, *args, **kargs):\n        self.start_line()\n        self.write(*args, **kargs)\n        self.end_line()\n\n    def open_block(self, *args, **kargs):\n        if len(args) + len(kargs) > 0:\n            self.write_line(*args, **kargs)\n\n        self.indent += 1\n\n    def close_block(self, *args, **kargs):\n        if len(args) + len(kargs) > 0:\n            self.write_line(*args, **kargs)\n\n        self.indent -= 1", ""]}
{"filename": "ljd/lua/writer.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport re\nimport sys\nimport traceback\nimport warnings\n\nimport ljd.ast.nodes as nodes", "\nimport ljd.ast.nodes as nodes\nimport ljd.ast.traverse as traverse\nimport ljd\nfrom ljd.bytecode.instructions import SLOT_FALSE, SLOT_TRUE\n\ncompact_table_constructors = False\ncomment_empty_blocks = True\nshow_slot_ids = False\nshow_line_info = False", "show_slot_ids = False\nshow_line_info = False\n# use sytanx `name = function( ...`\n# so that we can search 'name =' for function definition\nraw_function_sytanx = True\n\nCMD_START_STATEMENT = 0\nCMD_END_STATEMENT = 1\nCMD_END_LINE = 3\nCMD_START_BLOCK = 4", "CMD_END_LINE = 3\nCMD_START_BLOCK = 4\nCMD_END_BLOCK = 5\nCMD_WRITE = 6\n\nOPERATOR_TYPES = (nodes.BinaryOperator, nodes.UnaryOperator)\n\nSTATEMENT_NONE = -1\n\nSTATEMENT_ASSIGNMENT = 0", "\nSTATEMENT_ASSIGNMENT = 0\nSTATEMENT_FUNCTION_CALL = 1\nSTATEMENT_RETURN = 2\nSTATEMENT_BREAK = 3\n\nSTATEMENT_IF = 4\n\nSTATEMENT_ITERATOR_FOR = 5\nSTATEMENT_NUMERIC_FOR = 6", "STATEMENT_ITERATOR_FOR = 5\nSTATEMENT_NUMERIC_FOR = 6\nSTATEMENT_REPEAT_UNTIL = 7\nSTATEMENT_WHILE = 8\n\nSTATEMENT_FUNCTION = 9\n\nVALID_IDENTIFIER = re.compile(r'^[a-zA-Z_][\\w]*$')\n\nRESERVED_WORDS = [", "\nRESERVED_WORDS = [\n    \"and\",\n    \"break\",\n    \"do\",\n    \"else\",\n    \"elseif\",\n    \"end\",\n    \"false\",\n    \"for\",", "    \"false\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"in\",\n    \"local\",\n    \"nil\",\n    \"not\",\n    \"or\",\n    \"repeat\",", "    \"or\",\n    \"repeat\",\n    \"return\",\n    \"then\",\n    \"true\",\n    \"until\",\n    \"while\"\n]\n\nLIST_TYPES = (nodes.VariablesList,", "\nLIST_TYPES = (nodes.VariablesList,\n              nodes.IdentifiersList,\n              nodes.ExpressionsList,\n              nodes.StatementsList)\n\n\nclass _State:\n    def __init__(self):\n        self.current_statement = STATEMENT_NONE\n        self.function_name = None\n        self.function_local = False\n        self.function_method = False", "\n\nclass Visitor(traverse.Visitor):\n    def __init__(self):\n        traverse.Visitor.__init__(self)\n\n        self.print_queue = []\n\n        self._path = []\n        self._visited_nodes = [set()]\n        self._states = [_State()]\n\n        self.line_token_map = {}\n\n    # ##\n\n    def _start_statement(self, statement):\n        assert self._state().current_statement == STATEMENT_NONE\n        self._state().current_statement = statement\n        self.print_queue.append((CMD_START_STATEMENT, statement))\n\n    def _end_statement(self, statement):\n        assert statement == self._state().current_statement\n        self._state().current_statement = STATEMENT_NONE\n        self.print_queue.append((CMD_END_STATEMENT, statement))\n\n    def _end_line(self):\n        self.print_queue.append((CMD_END_LINE,))\n\n    def _start_block(self):\n        self.print_queue.append((CMD_START_BLOCK,))\n\n    def _end_block(self):\n        self.print_queue.append((CMD_END_BLOCK,))\n\n    def _write(self, fmt, *args, **kargs):\n        self.print_queue.append((CMD_WRITE, fmt, args, kargs))\n\n    def _state(self):\n        return self._states[-1]\n\n    def _push_state(self):\n        return self._states.append(_State())\n\n    def _pop_state(self):\n        return self._states.pop()\n\n    # ##\n\n    def _write_slot(self, node):\n        slot = None\n        slot_ids = None\n\n        if isinstance(node, nodes.Identifier):\n            slot = node.slot\n\n            if node.id != -1:\n                slot_ids = node.id\n            else:\n                slot_ids = getattr(node, \"_ids\", None)\n        else:\n            slot = getattr(node, \"_slot\", None)\n            slot_id = getattr(node, \"_slot_id\", None)\n\n        assert slot is not None\n\n        name = \"slot\" + str(slot)\n\n        if show_slot_ids:\n            if slot_ids and slot_ids != -1:\n                name += \"_\"\n                if isinstance(slot_ids, list):\n                    for i, slot_id in enumerate(slot_ids):\n                        if i > 0:\n                            name += \"$\"\n                        name += str(slot_id)\n                else:\n                    name += str(slot_ids)\n\n        self._write(name)\n\n    # ##\n\n    def visit_function_definition(self, node):\n        is_statement = self._state().function_name is not None\n        is_method = self._state().function_method\n\n        if is_statement:\n            self._start_statement(STATEMENT_FUNCTION)\n\n            lineinfo = show_line_info and getattr(node, \"_lineinfo\", None)\n            if lineinfo:\n                self._write(\"-- Lines {0}-{1}\".format(lineinfo[0], lineinfo[0] + lineinfo[1]))\n                self._end_line()\n\n            if self._state().function_local:\n                self._write(\"local \")\n\n            fn = self._state().function_name\n            if raw_function_sytanx:\n                # Use raw sytanx:\n                # local name = function(...\n                self._visit(fn)\n                self._write(\" = function\")\n            else:\n                # local function name(...\n                self._write(\"function \")\n\n                if is_method:\n                    self._visit(fn.table)\n                    self._write(\":\")\n                    self._write(fn.key)\n                else:\n                    self._visit(fn)\n\n            self._write(\"(\")\n\n            self._state().function_name = None\n        else:\n            self._write(\"function (\")\n\n        args = node.arguments\n\n        # If this is a method, and raw_function_sytanx=False, remove the \"self\" argument\n        if is_method and not raw_function_sytanx:\n            # AFAIK we don't ever use the args again, and if we\n            #  use a new args object then the original one gets written later on\n            orig = args.contents\n            args.contents = orig[1:]\n\n            assert orig[0].name == \"self\"\n\n            # Same as above with function_name, set this to false afterwards\n            # This is because it is only set in visit_assignment if it is a\n            # simple assignment. If we have two functions one after the other,\n            # and the first is a method while the other is not but uses\n            # a complex assignment, then this variable will not be reset and\n            # the above assertion will fail, as the writer thinks it is a method.\n            # See https://gitlab.com/znixian/luajit-decompiler/issues/13\n            self._state().function_method = False\n\n        self._visit(args)\n\n        self._write(\")\")\n\n        self._end_line()\n\n        # If there were unrecoverable errors in the function (namely invalid bytecodes), an error will\n        # be set for the entire function. Print it out as a comment, along with an error to crash the\n        # program should the generated source be recompiled.\n        if node.error:\n            self._start_block()\n            self._write('error(\"Decompilation failed\")')\n            self._end_line()\n            self._write(\"-- Exception in function building!\")\n            self._end_line()\n            for entry in traceback.format_exception(value=node.error, tb=node.error.__traceback__, etype=None):\n                for line in entry.strip().split(\"\\n\"):\n                    self._write(\"-- \" + line)\n                    self._end_line()\n            self._end_block()\n\n        # Syntactic Sugar: Cull empty returns at the ends of functions\n        if len(node.statements.contents) > 1:\n            end_node = node.statements.contents[-1]\n            if isinstance(end_node, nodes.Return) and len(end_node.returns.contents) == 0:\n                node.statements.contents.pop(-1)\n\n        self._visit(node.statements)\n\n        self._write(\"end\")\n\n        if is_statement:\n            self._end_statement(STATEMENT_FUNCTION)\n\n    # ##\n\n    def visit_table_constructor(self, node):\n        self._write(\"{\")\n\n        # These are both delt with in the contents array, no need to visit them separately\n        self._skip(node.array)\n        self._skip(node.records)\n\n        contents = node.array.contents + node.records.contents\n\n        if len(node.array.contents) > 0:\n            # Since we're using array+records in that order, the first\n            #  array item is also the first combined item.\n            first = contents.pop(0).value\n\n            if not isinstance(first, nodes.Primitive) or first.type != first.T_NIL:\n                record = nodes.TableRecord()\n                record.key = nodes.Constant()\n                record.key.type = nodes.Constant.T_INTEGER\n                record.key.value = 0\n                record.value = first\n\n                contents.insert(0, record)\n\n        if compact_table_constructors and len(contents) == 1:\n            self._visit(contents[0])\n        elif len(contents) > 0:\n            self._end_line()\n\n            self._start_block()\n\n            all_records = nodes.RecordsList()\n            all_records.contents = contents\n\n            self._visit(all_records)\n\n            self._end_block()\n\n        self._write(\"}\")\n\n    def visit_table_record(self, node):\n        if self._is_valid_name(node.key):\n            self._write(node.key.value)\n\n            self._skip(node.key)\n\n            self._write(\" = \")\n        else:\n            self._write(\"[\")\n\n            self._visit(node.key)\n\n            self._write(\"] = \")\n\n        self._visit(node.value)\n\n    # visit_array_record is a passthough\n\n    # ##\n\n    def visit_assignment(self, node):\n        is_local = node.type == node.T_LOCAL_DEFINITION\n\n        dsts = node.destinations.contents\n        srcs = node.expressions.contents\n\n        num_dsts = len(dsts)\n        num_srcs = len(srcs)\n\n        src_is_function = False\n        if num_dsts == 1 and num_srcs == 1:\n            dst = dsts[0]\n            src = srcs[0]\n\n            src_is_function = isinstance(src, nodes.FunctionDefinition)\n            dst_is_simple = self._is_acceptable_func_dst(dst)\n\n            if src_is_function:\n                if dst_is_simple:\n                    self._state().function_name = dst\n                    self._state().function_local = is_local\n                    self._state().function_method = self._is_method(dst, src)\n\n                    self._visit(src)\n\n                    self._skip(node.destinations)\n                    self._skip(node.expressions)\n\n                    return\n\n        if is_local:\n            self._write(\"local \")\n\n        if src_is_function:\n            self._start_statement(STATEMENT_FUNCTION)\n        else:\n            self._start_statement(STATEMENT_ASSIGNMENT)\n\n        self._visit(node.destinations)\n\n        self._write(\" = \")\n\n        self._visit(node.expressions)\n\n        if src_is_function:\n            self._end_statement(STATEMENT_FUNCTION)\n        else:\n            self._end_statement(STATEMENT_ASSIGNMENT)\n\n    def _is_variable(self, node):\n        if isinstance(node, nodes.Identifier):\n            return True\n\n        return self._is_global(node)\n\n    def _is_global(self, node):\n        if isinstance(node, nodes.GetItem):\n            return self._is_builtin(node.table)\n\n        return False\n\n    def _is_acceptable_func_dst(self, dst):\n        # If this is an identifier, we're fine\n        if isinstance(dst, nodes.Identifier):\n            return True\n\n        # Otherwise, it must be a table element\n        if not isinstance(dst, nodes.GetItem):\n            return False\n\n        # It's key must be a constant\n        if not isinstance(dst.key, nodes.Constant):\n            return False\n\n        # Ensure the key is a string\n        if dst.key.type != nodes.Constant.T_STRING:\n            return False\n\n        # Ensure the key is alphanumeric, and the first character is a letter\n        key = dst.key.value\n        if key[0].isdigit():\n            # TODO I don't think the code in this generator checks this - so you can end up with a.1234.b\n            return False\n\n        for char in key:\n            if not char.isalnum() and char != \"_\":\n                return False\n\n        # Finally, recurse up the chain\n        return self._is_acceptable_func_dst(dst.table)\n\n    def _is_method(self, dst, func):\n        if not func.arguments.contents:\n            return False\n\n        selfarg = func.arguments.contents[0]\n\n        # This chokes on functions with their first argument being the vararg symbol\n        #  otherwise, since they don't have a `name` property\n        #  ex. `function myfunc(...)`\n        if not isinstance(selfarg, nodes.Identifier):\n            return False\n\n        if selfarg.name != \"self\":\n            return False\n\n        # Ensure the destination is on a table\n        if not isinstance(dst, nodes.GetItem):\n            return False\n\n        return True\n\n    @staticmethod\n    def _is_builtin(node):\n        if not isinstance(node, nodes.Identifier):\n            return False\n\n        return node.type == nodes.Identifier.T_BUILTIN\n\n    @staticmethod\n    def _is_valid_name(key):\n        if not isinstance(key, nodes.Constant) or key.type != key.T_STRING:\n            return False\n\n        if not VALID_IDENTIFIER.match(key.value):\n            return False\n\n        return key.value not in RESERVED_WORDS\n\n    # ##\n\n    def visit_binary_operator(self, node):\n        is_left_op = isinstance(node.left, OPERATOR_TYPES)\n        is_right_op = isinstance(node.right, OPERATOR_TYPES)\n\n        # If the subexpressions are less in order then this expression,\n        # they should go with parentheses\n\n        left_parentheses = False\n        right_parentheses = False\n\n        binop = nodes.BinaryOperator\n\n        # Rules for braces:\n        #  * A group MUST be braced if it is of a lower precedence (eg, if a * has a +, then the + must be braced)\n        #  * Braces are unnecessary if the group has a higher precedence\n        #  * If a group is of the same precedence, it must be braced if it is not on the associative side - so\n        #     `(a * b) / (c * d)` comes out to `a * b / (c * d)`\n\n        if is_left_op:\n            if node.is_right_associative():\n                left_parentheses = node.left.precedence() <= node.precedence()\n            else:\n                left_parentheses = node.left.precedence() < node.precedence()\n\n        if is_right_op:\n            if node.is_right_associative():\n                right_parentheses = node.right.precedence() < node.precedence()\n            else:\n                right_parentheses = node.right.precedence() <= node.precedence()\n\n                # If this is either `a + (b + c)`, `a + (b - c)`, `a * (b * c)`, or `a * (b / c)`, we\n                #  can drop the braces:\n                if node.type == binop.T_ADD and binop.T_ADD <= node.right.type <= binop.T_SUBTRACT:\n                    right_parentheses = False\n\n                elif node.type == binop.T_MULTIPLY and binop.T_MULTIPLY <= node.right.type <= binop.T_DIVISION:\n                    right_parentheses = False\n\n        if left_parentheses:\n            self._write(\"(\")\n\n        self._visit(node.left)\n\n        if left_parentheses:\n            self._write(\")\")\n\n        if node.type == nodes.BinaryOperator.T_LOGICAL_OR:\n            self._write(\" or \")\n        elif node.type == nodes.BinaryOperator.T_LOGICAL_AND:\n            self._write(\" and \")\n\n        elif node.type == nodes.BinaryOperator.T_LESS_THEN:\n            self._write(\" < \")\n        elif node.type == nodes.BinaryOperator.T_GREATER_THEN:\n            self._write(\" > \")\n        elif node.type == nodes.BinaryOperator.T_LESS_OR_EQUAL:\n            self._write(\" <= \")\n        elif node.type == nodes.BinaryOperator.T_GREATER_OR_EQUAL:\n            self._write(\" >= \")\n\n        elif node.type == nodes.BinaryOperator.T_NOT_EQUAL:\n            self._write(\" ~= \")\n        elif node.type == nodes.BinaryOperator.T_EQUAL:\n            self._write(\" == \")\n\n        elif node.type == nodes.BinaryOperator.T_CONCAT:\n            self._write(\" .. \")\n\n        elif node.type == nodes.BinaryOperator.T_ADD:\n            self._write(\" + \")\n        elif node.type == nodes.BinaryOperator.T_SUBTRACT:\n            self._write(\" - \")\n\n        elif node.type == nodes.BinaryOperator.T_DIVISION:\n            self._write(\" / \")\n        elif node.type == nodes.BinaryOperator.T_MULTIPLY:\n            self._write(\" * \")\n        elif node.type == nodes.BinaryOperator.T_MOD:\n            self._write(\" % \")\n\n        else:\n            assert node.type == nodes.BinaryOperator.T_POW\n            self._write(\"^\")\n\n        if right_parentheses:\n            self._write(\"(\")\n\n        self._visit(node.right)\n\n        if right_parentheses:\n            self._write(\")\")\n\n    def visit_unary_operator(self, node):\n        if node.type == nodes.UnaryOperator.T_LENGTH_OPERATOR:\n            self._write(\"#\")\n        elif node.type == nodes.UnaryOperator.T_MINUS:\n            self._write(\"-\")\n        elif node.type == nodes.UnaryOperator.T_NOT:\n            if hasattr(node.operand, \"slot\"):\n                if not node.operand.slot == SLOT_FALSE:\n                    self._write(\"not \")\n                else:\n                    node.operand.slot = SLOT_TRUE\n            else:\n                self._write(\"not \")\n        elif ljd.CURRENT_VERSION > 2.0:\n            # TODO\n            if node.type == nodes.UnaryOperator.T_TOSTRING:\n                self._write(\"tostring\")\n            elif node.type == nodes.UnaryOperator.T_TONUMBER:\n                self._write(\"tonumber\")\n\n        has_subexp = isinstance(node.operand, OPERATOR_TYPES)\n        need_parentheses = has_subexp and node.operand.type < node.type\n\n        if need_parentheses:\n            self._write(\"(\")\n\n        self._visit(node.operand)\n\n        if need_parentheses:\n            self._write(\")\")\n\n    # ##\n\n    def visit_statements_list(self, node):\n        if len(self._states) > 1:\n            self._start_block()\n\n        self._push_state()\n\n        if comment_empty_blocks and len(self._path) > 1:\n            add_comment = False\n            if len(node.contents) == 0:\n                add_comment = isinstance(self._path[-2], (nodes.IteratorFor, nodes.If, nodes.ElseIf))\n            elif len(node.contents) == 1:\n                add_comment = isinstance(node.contents[0], nodes.NoOp)\n\n            if add_comment:\n                self._write(\"-- Nothing\")\n                self._end_line()\n\n    def leave_statements_list(self, node):\n        self._pop_state()\n\n        if len(self._states) > 1:\n            self._end_block()\n\n    def _visit_comma_separated_list(self, node):\n        if not node.contents:\n            return\n\n        for subnode in node.contents[:-1]:\n            self._visit(subnode)\n            self._write(\", \")\n\n        self._visit(node.contents[-1])\n\n    visit_identifiers_list = _visit_comma_separated_list\n\n    def visit_records_list(self, node):\n        if not node.contents:\n            return\n\n        for subnode in node.contents[:-1]:\n            self._visit(subnode)\n\n            self._write(\",\")\n            self._end_line()\n\n        self._visit(node.contents[-1])\n        self._end_line()\n\n    visit_variables_list = _visit_comma_separated_list\n    visit_expressions_list = _visit_comma_separated_list\n\n    # ##\n\n    def visit_identifier(self, node):\n        if node.type == nodes.Identifier.T_SLOT:\n            if node.slot == SLOT_FALSE:\n                self._write(\"false\")\n            elif node.slot == SLOT_TRUE:\n                self._write(\"true\")\n            else:\n                self._write_slot(node)\n        elif not node.name and node.type == nodes.Identifier.T_UPVALUE:\n            placeholder_identifier = \"uv{0}\"\n            self._write(placeholder_identifier, node.slot)\n        else:\n            self._write(node.name)\n\n    def visit_multres(self, node):\n        self._write(\"MULTRES\")\n\n    def visit_table_element(self, node):\n        key = node.key\n        base = node.table\n\n        is_valid_name = self._is_valid_name(key)\n\n        if self._is_global(node):\n            assert is_valid_name\n\n            self._skip(base)\n            self._skip(key)\n\n            self._write(key.value)\n\n            return\n\n        base_is_constructor = isinstance(base, nodes.TableConstructor) \\\n                              or isinstance(base, OPERATOR_TYPES) \\\n                              or (isinstance(base, nodes.Constant) and base.type == nodes.Constant.T_STRING)\n\n        if base_is_constructor:\n            self._write(\"(\")\n\n        self._visit(base)\n\n        if base_is_constructor:\n            self._write(\")\")\n\n        if is_valid_name:\n            self._write(\".\")\n            self._write(key.value)\n            self._skip(key)\n        else:\n            self._write(\"[\")\n            self._visit(key)\n            self._write(\"]\")\n\n    def visit_vararg(self, node):\n        self._write(\"...\")\n\n    def visit_function_call(self, node):\n        is_statement = self._state().current_statement == STATEMENT_NONE\n\n        if is_statement:\n            self._start_statement(STATEMENT_FUNCTION_CALL)\n\n        func = node.function\n\n        # We are going to modify this list so we can remove the first argument\n        args = node.arguments.contents\n\n        if node.is_method:\n            func = node.function\n            base = func.table\n            base_is_constructor = isinstance(base, nodes.TableConstructor) \\\n                                  or isinstance(base, OPERATOR_TYPES) \\\n                                  or (isinstance(base, nodes.Constant) and base.type == nodes.Constant.T_STRING)\n\n            if base_is_constructor:\n                self._write(\"(\")\n\n            self._visit(base)\n\n            if base_is_constructor:\n                self._write(\")\")\n\n            self._write(\":\")\n\n            if self._is_valid_name(func.key):\n                self._write(func.key.value)\n            else:\n                warnings.warn(\"Invalid function name: %s\" % func.key)\n                if isinstance(func.key, nodes.Identifier):\n                    if func.key.type == nodes.Identifier.T_SLOT:\n                        val = 'slot%s_%s' % (func.key.slot, func.key.name)\n                    else:\n                        val = str(func.key.name)\n                else:\n                    val = str(func.key)\n                self._write('__%s__' % val)\n\n            self._skip(func.key)\n\n            self._skip(node.function)\n\n            self._write(\"(\")\n            self._visit(node.arguments)\n            self._write(\")\")\n\n            self._skip(node.arguments)\n        else:\n            # handle anonymous function\n            is_anon = isinstance(func, nodes.FunctionDefinition)\n            if is_anon:\n                self._write(\"(\")\n            self._visit(node.function)\n            if is_anon:\n                self._write(\")\")\n\n            self._write(\"(\")\n            self._visit(node.arguments)\n            self._write(\")\")\n\n        if is_statement:\n            self._end_statement(STATEMENT_FUNCTION_CALL)\n\n    # ##\n\n    def visit_if(self, node):\n        self._start_statement(STATEMENT_IF)\n\n        self._write(\"if \")\n\n        self._visit(node.expression)\n\n        self._write(\" then\")\n\n        self._end_line()\n\n        self._visit(node.then_block)\n\n        self._visit_list(node.elseifs)\n\n        if len(node.else_block.contents) > 0:\n            self._write(\"else\")\n\n            self._end_line()\n\n            self._visit(node.else_block)\n        else:\n            self._skip(node.else_block)\n\n        self._write(\"end\")\n\n        self._end_statement(STATEMENT_IF)\n\n    def visit_elseif(self, node):\n        self._write(\"elseif \")\n\n        self._visit(node.expression)\n\n        self._write(\" then\")\n\n        self._end_line()\n\n        self._visit(node.then_block)\n\n    # ##\n\n    def visit_block(self, node):\n        self._write(\"--- BLOCK #{0} {1}-{2}, warpins: {3} ---\",\n                    node.index,\n                    node.first_address, node.last_address,\n                    node.warpins_count)\n\n        self._end_line()\n\n        self._visit_list(node.contents)\n\n        self._write(\"--- END OF BLOCK #{0} ---\", node.index)\n\n        self._end_line()\n\n        self._end_line()\n        self._visit(node.warp)\n        self._end_line()\n\n        self._end_line()\n\n    def visit_unconditional_warp(self, node):\n        if node.type == nodes.UnconditionalWarp.T_FLOW:\n            self._write(\"FLOW\")\n        elif node.type == nodes.UnconditionalWarp.T_JUMP:\n            self._write(\"UNCONDITIONAL JUMP\")\n\n        self._write(\"; TARGET BLOCK #{0}\", node.target.index)\n\n        self._end_line()\n\n    def visit_conditional_warp(self, node):\n        if hasattr(node, \"_slot\"):\n            self._write_slot(node)\n            self._write(\" = \")\n\n        self._write(\"if \")\n\n        self._visit(node.condition)\n\n        self._write(\" then\")\n        self._end_line()\n\n        self._write(\"JUMP TO BLOCK #{0}\", node.true_target.index)\n\n        self._end_line()\n        self._write(\"else\")\n        self._end_line()\n\n        self._write(\"JUMP TO BLOCK #{0}\", node.false_target.index)\n\n        self._end_line()\n\n        self._write(\"end\")\n        self._end_line()\n\n    def visit_iterator_warp(self, node):\n        self._write(\"for \")\n\n        self._visit(node.variables)\n\n        self._write(\" in \")\n\n        self._visit(node.controls)\n\n        self._end_line()\n        self._write(\"LOOP BLOCK #{0}\", node.body.index)\n\n        self._end_line()\n        self._write(\"GO OUT TO BLOCK #{0}\", node.way_out.index)\n\n        self._end_line()\n\n    def visit_numeric_loop_warp(self, node):\n        self._write(\"for \")\n\n        self._visit(node.index)\n\n        self._write(\"=\")\n\n        self._visit(node.controls)\n\n        self._end_line()\n        self._write(\"LOOP BLOCK #{0}\", node.body.index)\n\n        self._end_line()\n        self._write(\"GO OUT TO BLOCK #{0}\", node.way_out.index)\n\n    # ##\n\n    def visit_return(self, node):\n        self._start_statement(STATEMENT_RETURN)\n\n        if len(node.returns.contents) > 0:\n            self._write(\"return \")\n        else:\n            self._write(\"return\")\n\n        self._visit(node.returns)\n\n        self._end_statement(STATEMENT_RETURN)\n\n    def visit_break(self, node):\n        self._start_statement(STATEMENT_BREAK)\n\n        self._write(\"break\")\n\n        self._end_statement(STATEMENT_BREAK)\n\n    # ##\n\n    def visit_while(self, node):\n        self._start_statement(STATEMENT_WHILE)\n\n        self._write(\"while \")\n        self._visit(node.expression)\n        self._write(\" do\")\n\n        self._end_line()\n\n        self._visit(node.statements)\n\n        self._write(\"end\")\n        self._end_statement(STATEMENT_WHILE)\n\n    def visit_repeat_until(self, node):\n        self._start_statement(STATEMENT_REPEAT_UNTIL)\n\n        self._write(\"repeat\")\n        self._end_line()\n\n        self._visit(node.statements)\n\n        self._write(\"until \")\n        self._visit(node.expression)\n\n        self._end_statement(STATEMENT_REPEAT_UNTIL)\n\n    def visit_numeric_for(self, node):\n        self._start_statement(STATEMENT_NUMERIC_FOR)\n\n        self._write(\"for \")\n        self._visit(node.variable)\n        self._write(\" = \")\n\n        # Manually visit the expressions so we have the option to skip the default increment\n        self._skip(node.expressions)\n\n        expressions = node.expressions.contents\n        assert len(expressions) == 3\n        if isinstance(expressions[2], nodes.Constant) and expressions[2].value == 1:\n            expressions = expressions[:-1]\n\n        for subnode in expressions[:-1]:\n            self._visit(subnode)\n            self._write(\", \")\n\n        self._visit(expressions[-1])\n\n        self._write(\" do\")\n\n        self._end_line()\n\n        self._visit(node.statements)\n\n        self._write(\"end\")\n        self._end_statement(STATEMENT_NUMERIC_FOR)\n\n    def visit_iterator_for(self, node):\n        self._start_statement(STATEMENT_ITERATOR_FOR)\n\n        self._write(\"for \")\n        self._visit(node.identifiers)\n        self._write(\" in \")\n        self._visit(node.expressions)\n        self._write(\" do\")\n\n        self._end_line()\n\n        self._visit(node.statements)\n\n        self._write(\"end\")\n        self._end_statement(STATEMENT_ITERATOR_FOR)\n\n    # ##\n\n    def visit_constant(self, node):\n        if node.type != nodes.Constant.T_STRING:\n            self._write(node.value)\n            return\n\n        lines = node.value.count(\"\\n\")\n\n        if lines > 2:\n            self._write(\"[[\")\n\n            self._write(\"\\n\")\n\n            self._write(node.value)\n\n            self._write(\"]]\")\n        else:\n            text = node.value\n\n            text = text.replace(\"\\\\\", \"\\\\\\\\\")\n            text = text.replace(\"\\t\", \"\\\\t\")\n            text = text.replace(\"\\n\", \"\\\\n\")\n            text = text.replace(\"\\r\", \"\\\\r\")\n            text = text.replace(\"\\\"\", \"\\\\\\\"\")\n\n            self._write('\"' + text + '\"')\n\n    def visit_primitive(self, node):\n        if node.type == nodes.Primitive.T_FALSE:\n            self._write(\"false\")\n        elif node.type == nodes.Primitive.T_TRUE:\n            self._write(\"true\")\n        else:\n            self._write(\"nil\")\n\n    def _visit_node(self, handler, node):\n        self._path.append(node)\n\n        traverse.Visitor._visit_node(self, handler, node)\n\n    def _leave_node(self, handler, node):\n        self._path.pop()\n\n        traverse.Visitor._leave_node(self, handler, node)\n\n    def _skip(self, node):\n        self._visited_nodes[-1].add(node)\n\n    def _visit(self, node):\n        assert node is not None\n\n        if node in self._visited_nodes[-1]:\n            return\n\n        self._visited_nodes[-1].add(node)\n\n        # TODO: add check\n        # \"It looks like you forgot about some node changes...\"\n\n        self._visited_nodes.append(set())\n\n        if hasattr(node, \"_decompilation_error_here\"):\n            self._end_line()\n            self._write(\"-- Decompilation error in this vicinity:\")\n            self._end_line()\n\n        if hasattr(node, \"_line\") and node._line:\n            line = node._line\n            self.line_token_map[line] = len(self.print_queue)\n\n        traverse.Visitor._visit(self, node)\n\n        self._visited_nodes.pop()", "\n\ndef write(fd, ast, generate_linemap=False):\n    assert isinstance(ast, nodes.FunctionDefinition)\n\n    visitor = Visitor()\n\n    traverse.traverse(visitor, ast.statements)\n\n    line_map = {}\n    token_map = _process_queue(fd, visitor.print_queue, visitor.line_token_map.values() if generate_linemap else None)\n\n    if generate_linemap:\n        for inline, tok in visitor.line_token_map.items():\n            line_map[inline] = token_map[tok]\n\n        return line_map", "\n\ndef wrapped_write(fd, *objects, sep=' ', end='\\n', file=sys.stdout):\n    # TODO find out why this was added (asking Aussiemon might be a good place to start)\n    # For now, just write it without reencoding\n    # Also, it made the output platform-dependant, rather than being identical across platforms\n    fd.write(*objects)\n\n    # enc = fd.encoding\n    # if enc == 'UTF-8':", "    # enc = fd.encoding\n    # if enc == 'UTF-8':\n    #     fd.write(*objects)\n    # else:\n    #     f = lambda obj: str(obj).encode(enc, errors='backslashreplace').decode(enc)\n    #     fd.write(*map(f, objects))\n\n\ndef _get_next_significant(queue, i):\n    i += 1\n\n    while i < len(queue):\n        cmd = queue[i]\n\n        if cmd[0] not in (CMD_END_LINE, CMD_WRITE):\n            break\n\n        i += 1\n\n    if i < len(queue):\n        return queue[i]\n    else:\n        return CMD_END_BLOCK,", "def _get_next_significant(queue, i):\n    i += 1\n\n    while i < len(queue):\n        cmd = queue[i]\n\n        if cmd[0] not in (CMD_END_LINE, CMD_WRITE):\n            break\n\n        i += 1\n\n    if i < len(queue):\n        return queue[i]\n    else:\n        return CMD_END_BLOCK,", "\n\ndef _process_queue(fd, queue, wanted_tokens):\n    indent = 0\n\n    line_broken = True\n\n    token_map = {}\n    line_num = 1\n\n    for i, cmd in enumerate(queue):\n        assert isinstance(cmd, tuple)\n\n        if wanted_tokens and i in wanted_tokens:\n            token_map[i] = line_num\n\n        if cmd[0] == CMD_START_STATEMENT:\n            # assert line_broken\n            pass\n        elif cmd[0] == CMD_END_STATEMENT:\n            wrapped_write(fd, \"\\n\")\n            line_num += 1\n            line_broken = True\n\n            next_cmd = _get_next_significant(queue, i)\n\n            if next_cmd[0] not in (CMD_END_BLOCK, CMD_START_BLOCK):\n                assert next_cmd[0] == CMD_START_STATEMENT\n\n                if next_cmd[1] != cmd[1] \\\n                        or cmd[1] >= STATEMENT_IF \\\n                        or next_cmd[1] >= STATEMENT_IF:\n                    wrapped_write(fd, \"\\n\")\n                    line_num += 1\n        elif cmd[0] == CMD_END_LINE:\n            wrapped_write(fd, \"\\n\")\n            line_num += 1\n            line_broken = True\n        elif cmd[0] == CMD_START_BLOCK:\n            indent += 1\n        elif cmd[0] == CMD_END_BLOCK:\n            indent -= 1\n\n            assert indent >= 0\n        else:\n            assert cmd[0] == CMD_WRITE\n\n            if line_broken:\n                wrapped_write(fd, indent * '\\t')\n                line_broken = False\n\n            _id, fmt, args, kargs = cmd\n\n            if len(args) + len(kargs) > 0:\n                text = fmt.format(*args, **kargs)\n            elif isinstance(fmt, str):\n                text = fmt\n            else:\n                text = str(fmt)\n\n            wrapped_write(fd, text)\n\n    return token_map", ""]}
{"filename": "ljd/lua/__init__.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n"]}
{"filename": "ljd/pseudoasm/writer.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport ljd.pseudoasm.prototype\nimport ljd.util.indentedstream\n\n\nclass _State:\n    def __init__(self):\n        self.flags = None\n        self.stream = None\n        self.source = None", "class _State:\n    def __init__(self):\n        self.flags = None\n        self.stream = None\n        self.source = None\n\n\ndef write(fd, header, prototype):\n    writer = _State()\n\n    writer.stream = ljd.util.indentedstream.IndentedStream(fd)\n    writer.flags = header.flags\n    writer.source = \"N/A\" if header.flags.is_stripped else header.name\n\n    _write_header(writer, header)\n\n    ljd.pseudoasm.prototype.write(writer, prototype)", "\n\ndef _write_header(writer, header):\n    writer.stream.write_multiline(\"\"\"\n;\n; Disassemble of {origin}\n;\n; Source file: {source}\n;\n; Flags:\n;\tStripped: {stripped}\n;\tEndianness: {endianness}\n;\tFFI: {ffi}\n;\n\n\"\"\", origin=header.origin,\n                                  source=writer.source,\n                                  stripped=\"Yes\" if header.flags.is_stripped else \"No\",\n                                  endianness=\"Big\" if header.flags.is_big_endian else \"Little\",\n                                  ffi=\"Present\" if header.flags.has_ffi else \"Not present\")", ""]}
{"filename": "ljd/pseudoasm/instructions.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport bisect\n\nimport ljd.bytecode.instructions as ins\nimport ljd.pseudoasm.prototype\nfrom ljd.bytecode.constants import T_NIL, T_FALSE, T_TRUE\n", "from ljd.bytecode.constants import T_NIL, T_FALSE, T_TRUE\n\n_FORMAT = \"{addr:3}\\t[{line:3}]\\t{name:<5}\\t{a:3}\\t{b}\\t{c}\\t; {description}\"\n\n# Set in init(), see it's comment\n_DESCRIPTION_HANDLERS = None\n\n\nclass _State:\n    def __init__(self, writer, prototype, instructions):\n        for key, value in writer.__dict__.items():\n            setattr(self, key, value)\n\n        self.prototype = prototype\n        self.instructions = instructions", "class _State:\n    def __init__(self, writer, prototype, instructions):\n        for key, value in writer.__dict__.items():\n            setattr(self, key, value)\n\n        self.prototype = prototype\n        self.instructions = instructions\n\n\ndef write(writer, prototype):\n    global _MAP\n\n    # skip the first function header\n    addr = 1\n\n    instructions = prototype.instructions\n\n    writer = _State(writer, prototype, instructions)\n\n    while addr < len(instructions):\n        instruction = instructions[addr]\n        line = prototype.debuginfo.lookup_line_number(addr)\n\n        if instruction.opcode == ins.FNEW.opcode:\n            _write_function(writer, addr, line, instruction)\n        else:\n            _write_instruction(writer, addr, line, instruction)\n\n        addr += 1", "\ndef write(writer, prototype):\n    global _MAP\n\n    # skip the first function header\n    addr = 1\n\n    instructions = prototype.instructions\n\n    writer = _State(writer, prototype, instructions)\n\n    while addr < len(instructions):\n        instruction = instructions[addr]\n        line = prototype.debuginfo.lookup_line_number(addr)\n\n        if instruction.opcode == ins.FNEW.opcode:\n            _write_function(writer, addr, line, instruction)\n        else:\n            _write_instruction(writer, addr, line, instruction)\n\n        addr += 1", "\n\ndef _write_instruction(writer, addr, line, instruction):\n    description = _translate_description(writer, addr, line, instruction)\n\n    byte_array = instruction.Bytecode.to_bytes(4, byteorder=\"little\")\n    print(\"[\"+\"\".join(r'%02X ' % x for x in byte_array)[0:-1]+\"]\",end=\"\")\n\n    writer.stream.write_multiline(_FORMAT,\n                                  addr=addr,\n                                  line=line,\n                                  name=instruction.name,\n                                  a=instruction.A if instruction.A_type is not None else \"\",\n                                  b=instruction.B if instruction.B_type is not None else \"\",\n                                  c=instruction.CD if instruction.CD_type is not None else \"\",\n                                  description=description\n                                  )", "\n\ndef _write_function(writer, addr, line, instruction):\n    prototype = writer.prototype.constants.complex_constants[instruction.CD]\n\n    description = ljd.pseudoasm.prototype.format_header(writer, prototype)\n\n    writer.stream.open_block(_FORMAT,\n                             addr=addr,\n                             line=line,\n                             name=\"FNEW\",\n                             a=instruction.A,\n                             b=\"\",\n                             c=instruction.CD,\n                             description=description\n                             )\n\n    writer.stream.write_line()\n\n    ljd.pseudoasm.prototype.write_body(writer, prototype)\n\n    writer.stream.close_block()", "\n\ndef _translate_description(writer, addr, line, instruction):\n    global _DESCRIPTION_HANDLERS\n\n    handler = _DESCRIPTION_HANDLERS[instruction.opcode]\n    description = instruction.description\n\n    return handler(writer, description, addr, line, instruction)\n", "\n\ndef _translate(writer, addr, value, attr_type):\n    prototype = writer.prototype\n\n    if attr_type == ins.T_DST or attr_type == ins.T_BS:\n        return \"slot\" + str(value)\n    if attr_type == ins.T_VAR:\n        name = _lookup_variable_name(writer, addr, value)\n\n        if name is not None:\n            return name\n        else:\n            return \"slot\" + str(value)\n    elif attr_type == ins.T_UV:\n        name = prototype.debuginfo.lookup_upvalue_name(value)\n        if name is None:\n            name = \"unknwon\"\n        return \"uv\" + str(value) + '\"' + name + '\"'\n    elif attr_type == ins.T_PRI:\n        if value is None or value == T_NIL:\n            return \"nil\"\n        elif value is True or value == T_TRUE:\n            return \"true\"\n        else:\n            assert value is False or value == T_FALSE\n            return \"false\"\n    elif attr_type == ins.T_NUM:\n        return str(prototype.constants.numeric_constants[value])\n    elif attr_type == ins.T_STR:\n        binary = prototype.constants.complex_constants[value]\n        return '\"' + binary + '\"'\n    elif attr_type == ins.T_TAB:\n        return \"table#k\" + str(value)\n    elif attr_type == ins.T_CDT:\n        return str(prototype.constants.complex_constants[value])\n    elif attr_type == ins.T_JMP:\n        return str(1 + addr + value)\n    elif attr_type == ins.T_LIT or attr_type == ins.T_SLIT:\n        return str(value)\n    elif attr_type == ins.T_BS or attr_type == ins.T_RBS:\n        return \"r\" + str(value)\n    else:\n        return \" \"  # \"r\" + str(value)", "\n\ndef _lookup_variable_name(writer, addr, slot):\n    while True:\n        result = _lookup_variable_name_step(writer, addr, slot)\n\n        if isinstance(result, tuple):\n            addr = result[0]\n            slot = result[1]\n            continue\n\n        return result", "\n\ndef _lookup_variable_name_step(writer, addr, slot):\n    info = writer.prototype.debuginfo.lookup_local_name(addr, slot)\n\n    if info is not None:\n        name = info.name\n\n        if name[0] == '<':\n            name = \"slot\" + str(slot) + name\n\n        return name\n\n    instructions = writer.instructions\n\n    knil_opcode = ins.KNIL.opcode\n    constants = writer.prototype.constants.complex_constants\n\n    while addr > 1:\n        addr -= 1\n        instruction = instructions[addr]\n\n        if instruction.A_type == ins.T_BS:\n            if slot >= instruction.A \\\n                    and (instruction.opcode == knil_opcode\n                         or slot <= instruction.CD):\n                return None\n\n            continue\n\n        if instruction.A_type != ins.T_DST or instruction.A != slot:\n            continue\n\n        if instruction.opcode == ins.MOV.opcode:\n            # Retry with new addr and slot\n            return _lookup_variable_name_step(writer, addr, instruction.CD)\n\n        if instruction.opcode == ins.GGET.opcode:\n            binary = constants[instruction.CD]\n            return binary\n\n        # field or method\n        if instruction.opcode == ins.TGETS.opcode:\n            table_slot = instruction.B\n            table = _lookup_variable_name_step(writer, addr, table_slot)\n\n            if table is None:\n                table = \"<unknown table>\"\n            elif not isinstance(table, str):\n                table = \"<table \" + str(table) + \">\"\n\n            binary = constants[instruction.CD]\n            return table + \".\" + binary\n\n        if instruction.opcode == ins.UGET.opcode:\n            uv = instruction.CD\n            name = writer.prototype.debuginfo.lookup_upvalue_name(uv)\n            if name is None:\n                name = \"unknown\"\n\n            return \"uv\" + str(uv) + '\"' + name + '\"'\n\n        return None\n\n    return None", "\n\ndef _translate_standard(writer, addr, line, instruction):\n    A = None\n    B = None\n    CD = None\n\n    if instruction.A_type is not None:\n        A = _translate(writer, addr, instruction.A, instruction.A_type)\n\n    if instruction.B_type is not None:\n        B = _translate(writer, addr, instruction.B, instruction.B_type)\n\n    if instruction.CD_type is not None:\n        CD = _translate(writer, addr, instruction.CD, instruction.CD_type)\n\n    return A, B, CD", "\n\ndef _translate_normal(writer, description, addr, line, instruction):\n    A, B, CD = _translate_standard(writer, addr, line, instruction)\n\n    return description.format(A=A, B=B, C=CD, D=CD)\n\n\ndef _translate_concat(writer, description, addr, line, instruction):\n    A = _translate(writer, addr, instruction.A, instruction.A_type)\n\n    args = []\n\n    start = instruction.B\n    end = instruction.CD + 1\n\n    while start != end:\n        var = _translate(writer, addr, start, ins.T_VAR)\n        args.append(var)\n        start += 1\n\n    return description.format(A=A, concat_from_B_to_C=\" .. \".join(args))", "def _translate_concat(writer, description, addr, line, instruction):\n    A = _translate(writer, addr, instruction.A, instruction.A_type)\n\n    args = []\n\n    start = instruction.B\n    end = instruction.CD + 1\n\n    while start != end:\n        var = _translate(writer, addr, start, ins.T_VAR)\n        args.append(var)\n        start += 1\n\n    return description.format(A=A, concat_from_B_to_C=\" .. \".join(args))", "\n\ndef _translate_nil(writer, description, addr, line, instruction):\n    args = []\n\n    start = instruction.A\n    end = instruction.CD + 1\n\n    while start != end:\n        var = _translate(writer, addr, start, ins.T_VAR)\n        args.append(var)\n        start += 1\n\n    return description.format(from_A_to_D=\", \".join(args))", "\n\ndef _translate_table_str_op(writer, description, addr, line, instruction):\n    A, B, CD = _translate_standard(writer, addr, line, instruction)\n\n    C = CD[1:-1]\n\n    return description.format(A=A, B=B, C=C)\n\n\ndef _translate_new_table(writer, description, addr, line, instruction):\n    A = _translate(writer, addr, instruction.A, instruction.A_type)\n\n    size = instruction.CD\n\n    array_size = size & 0b0000011111111111\n    dict_size = 2 ** (size >> 11)\n\n    return description.format(\n        A=A,\n        D_array=array_size,\n        D_dict=dict_size,\n    )", "\n\ndef _translate_new_table(writer, description, addr, line, instruction):\n    A = _translate(writer, addr, instruction.A, instruction.A_type)\n\n    size = instruction.CD\n\n    array_size = size & 0b0000011111111111\n    dict_size = 2 ** (size >> 11)\n\n    return description.format(\n        A=A,\n        D_array=array_size,\n        D_dict=dict_size,\n    )", "\n\ndef _translate_mass_set(writer, description, addr, line, instruction):\n    base = instruction.A\n\n    table_var = _translate(writer, addr, base - 1, ins.T_VAR)\n\n    first = instruction.CD\n\n    return description.format(\n        A_minus_one=table_var,\n        A=base,\n        D_low=first,\n    )", "\n\ndef _translate_varg_call(writer, description, addr, line, instruction):\n    base = instruction.A\n    argn = instruction.CD\n    retn = instruction.B - 1\n\n    args = []\n    returns = []\n\n    i = 0\n    while i < argn:\n        args.append(_translate(writer, addr, base + i + 1, ins.T_VAR))\n        i += 1\n\n    i = 0\n    while i < retn:\n        returns.append(_translate(writer, addr, base + i, ins.T_DST))\n        i += 1\n\n    func_var = _translate(writer, addr, base, ins.T_VAR)\n\n    return description.format(\n        A=func_var,\n        from_A_x_B_minus_two=\", \".join(returns) if retn >= 0 else \"MULTRES\",\n        from_A_plus_one_x_C=\", \".join(args)\n    )", "\n\ndef _translate_call(writer, description, addr, line, instruction):\n    base = instruction.A\n    argn = instruction.CD - 1\n    retn = instruction.B - 1\n\n    args = []\n    returns = []\n\n    i = 0\n    while i < argn:\n        args.append(_translate(writer, addr, base + i + 1, ins.T_VAR))\n        i += 1\n\n    i = 0\n    while i < retn:\n        returns.append(_translate(writer, addr, base + i, ins.T_DST))\n        i += 1\n\n    func_var = _translate(writer, addr, base, ins.T_VAR)\n\n    return description.format(\n        A=func_var,\n        from_A_x_B_minus_two=\", \".join(returns) if retn >= 0 else \"MULTRES\",\n        from_A_plus_one_x_C_minus_one=\", \".join(args)\n    )", "\n\ndef _translate_varg_tailcall(writer, description, addr, line, instruction):\n    base = instruction.A\n    argn = instruction.CD - 1\n\n    args = []\n\n    i = 0\n    while i < argn:\n        args.append(_translate(writer, addr, base + i + 1, ins.T_VAR))\n        i += 1\n\n    func_var = _translate(writer, addr, base, ins.T_VAR)\n\n    return description.format(\n        A=func_var,\n        from_A_plus_one_x_D=\", \".join(args)\n    )", "\n\ndef _translate_tailcall(writer, description, addr, line, instruction):\n    base = instruction.A\n    argn = instruction.CD - 1\n\n    args = []\n\n    i = 0\n    while i < argn:\n        args.append(_translate(writer, addr, base + i + 1, ins.T_VAR))\n        i += 1\n\n    func_var = _translate(writer, addr, base, ins.T_VAR)\n\n    return description.format(\n        A=func_var,\n        from_A_plus_one_x_D_minus_one=\", \".join(args)\n    )", "\n\ndef _translate_iterator(writer, description, addr, line, instruction):\n    base = instruction.A\n\n    A = _translate(writer, addr, instruction.A, ins.T_DST)\n    A_plus_one = _translate(writer, addr, instruction.A + 1, ins.T_DST)\n    A_plus_two = _translate(writer, addr, instruction.A + 2, ins.T_DST)\n\n    A_minus_three = _translate(writer, addr, instruction.A - 3, ins.T_VAR)\n    A_minus_two = _translate(writer, addr, instruction.A - 2, ins.T_VAR)\n    A_minus_one = _translate(writer, addr, instruction.A - 1, ins.T_VAR)\n\n    retn = instruction.B - 1\n\n    returns = []\n\n    i = 0\n    while i < retn:\n        returns.append(_translate(writer, addr, base + i, ins.T_DST))\n        i += 1\n\n    return description.format(\n        A=A,\n        A_plus_one=A_plus_one,\n        A_plus_two=A_plus_two,\n        A_minus_three=A_minus_three,\n        A_minus_two=A_minus_two,\n        A_minus_one=A_minus_one,\n        from_A_x_B_minus_two=\", \".join(returns)\n    )", "\n\ndef _translate_vararg(writer, description, addr, line, instruction):\n    returns = []\n\n    base = instruction.A\n\n    count = instruction.B - 2\n\n    if count < 0:\n        return description.format(from_A_x_B_minus_two=\"MULTRES\")\n\n    i = 0\n    while i <= count:\n        returns.append(_translate(writer, addr, base + i, ins.T_DST))\n        i += 1\n\n    return description.format(\n        from_A_x_B_minus_two=\", \".join(returns)\n    )", "\n\ndef _translate_return_mult(writer, description, addr, line, instruction):\n    returns = []\n\n    base = instruction.A\n\n    count = instruction.CD - 1\n\n    i = 0\n    while i < count:\n        returns.append(_translate(writer, addr, base + i, ins.T_VAR))\n        i += 1\n\n    return description.format(\n        from_A_x_D_minus_one=\", \".join(returns)\n    )", "\n\ndef _translate_return_many(writer, description, addr, line, instruction):\n    returns = []\n\n    base = instruction.A\n\n    count = instruction.CD - 2\n\n    i = 0\n    while i <= count:\n        returns.append(_translate(writer, addr, base + i, ins.T_VAR))\n        i += 1\n\n    return description.format(\n        from_A_x_D_minus_two=\", \".join(returns)\n    )", "\n\ndef _translate_return_one(writer, description, addr, line, instruction):\n    A = _translate(writer, addr, instruction.A, ins.T_VAR)\n\n    return description.format(A=A)\n\n\ndef _translate_for_init(writer, description, addr, line, instruction):\n    idx = _translate(writer, addr, instruction.A, ins.T_BS)\n    stop = _translate(writer, addr, instruction.A + 1, ins.T_BS)\n    step = _translate(writer, addr, instruction.A + 2, ins.T_BS)\n    ext_idx = _translate(writer, addr, instruction.A + 3, ins.T_VAR)\n\n    return description.format(\n        A=idx,\n        A_plus_one=stop,\n        A_plus_two=step,\n        A_plus_three=ext_idx,\n        D=_translate(writer, addr, instruction.CD, ins.T_JMP)\n    )", "def _translate_for_init(writer, description, addr, line, instruction):\n    idx = _translate(writer, addr, instruction.A, ins.T_BS)\n    stop = _translate(writer, addr, instruction.A + 1, ins.T_BS)\n    step = _translate(writer, addr, instruction.A + 2, ins.T_BS)\n    ext_idx = _translate(writer, addr, instruction.A + 3, ins.T_VAR)\n\n    return description.format(\n        A=idx,\n        A_plus_one=stop,\n        A_plus_two=step,\n        A_plus_three=ext_idx,\n        D=_translate(writer, addr, instruction.CD, ins.T_JMP)\n    )", "\n\ndef _translate_numeric_loop(writer, description, addr, line, instruction):\n    stop = _translate(writer, addr, instruction.A + 1, ins.T_VAR)\n    step = _translate(writer, addr, instruction.A + 2, ins.T_VAR)\n    ext_idx = _translate(writer, addr, instruction.A + 3, ins.T_VAR)\n\n    # ext_idx isn't correct var here, but for the visualisation sake we will\n    # omit all the stuff with the internal idx var\n\n    return description.format(\n        A=ext_idx,\n        A_plus_one=stop,\n        A_plus_two=step,\n        D=_translate(writer, addr, instruction.CD, ins.T_JMP)\n    )", "\n\ndef _translate_iter_loop(writer, description, addr, line, instruction):\n    A_minus_one = _translate(writer, addr, instruction.A - 1, ins.T_VAR)\n    A = _translate(writer, addr, instruction.A, ins.T_VAR)\n\n    return description.format(\n        A_minus_one=A_minus_one,\n        A=A,\n        D=_translate(writer, addr, instruction.CD, ins.T_JMP)\n    )", "\n\n# See ljd.ast.builder.init for a description of why this is done, rather than\n# setting everything up statically. TLDR is that the the opcode's 'opcode' fields\n# are not yet set.\ndef init():\n    _HANDLERS_MAP = [\n        # Comparison ops\n\n        (ins.ISLT.opcode, _translate_normal),\n        (ins.ISGE.opcode, _translate_normal),\n        (ins.ISLE.opcode, _translate_normal),\n        (ins.ISGT.opcode, _translate_normal),\n\n        (ins.ISEQV.opcode, _translate_normal),\n        (ins.ISNEV.opcode, _translate_normal),\n\n        (ins.ISEQS.opcode, _translate_normal),\n        (ins.ISNES.opcode, _translate_normal),\n\n        (ins.ISEQN.opcode, _translate_normal),\n        (ins.ISNEN.opcode, _translate_normal),\n\n        (ins.ISEQP.opcode, _translate_normal),\n        (ins.ISNEP.opcode, _translate_normal),\n\n        # Unary test and copy ops\n\n        (ins.ISTC.opcode, _translate_normal),\n        (ins.ISFC.opcode, _translate_normal),\n\n        (ins.IST.opcode, _translate_normal),\n        (ins.ISF.opcode, _translate_normal),\n\n        # Unary ops\n\n        (ins.MOV.opcode, _translate_normal),\n        (ins.NOT.opcode, _translate_normal),\n        (ins.UNM.opcode, _translate_normal),\n        (ins.LEN.opcode, _translate_normal),\n\n        # Binary ops\n\n        (ins.ADDVN.opcode, _translate_normal),\n        (ins.SUBVN.opcode, _translate_normal),\n        (ins.MULVN.opcode, _translate_normal),\n        (ins.DIVVN.opcode, _translate_normal),\n        (ins.MODVN.opcode, _translate_normal),\n\n        (ins.ADDNV.opcode, _translate_normal),\n        (ins.SUBNV.opcode, _translate_normal),\n        (ins.MULNV.opcode, _translate_normal),\n        (ins.DIVNV.opcode, _translate_normal),\n        (ins.MODNV.opcode, _translate_normal),\n\n        (ins.ADDVV.opcode, _translate_normal),\n        (ins.SUBVV.opcode, _translate_normal),\n        (ins.MULVV.opcode, _translate_normal),\n        (ins.DIVVV.opcode, _translate_normal),\n        (ins.MODVV.opcode, _translate_normal),\n\n        (ins.POW.opcode, _translate_normal),\n        (ins.CAT.opcode, _translate_concat),\n\n        # Constant ops\n\n        (ins.KSTR.opcode, _translate_normal),\n        (ins.KCDATA.opcode, _translate_normal),\n        (ins.KSHORT.opcode, _translate_normal),\n        (ins.KNUM.opcode, _translate_normal),\n        (ins.KPRI.opcode, _translate_normal),\n\n        (ins.KNIL.opcode, _translate_nil),\n\n        # Upvalue and function ops\n\n        (ins.UGET.opcode, _translate_normal),\n\n        (ins.USETV.opcode, _translate_normal),\n        (ins.USETS.opcode, _translate_normal),\n        (ins.USETN.opcode, _translate_normal),\n        (ins.USETP.opcode, _translate_normal),\n\n        (ins.UCLO.opcode, _translate_normal),\n\n        (ins.FNEW.opcode, _translate_normal),\n\n        # Table ops\n\n        (ins.TNEW.opcode, _translate_new_table),\n\n        (ins.TDUP.opcode, _translate_normal),\n\n        (ins.GGET.opcode, _translate_normal),\n        (ins.GSET.opcode, _translate_normal),\n\n        (ins.TGETV.opcode, _translate_normal),\n        (ins.TGETS.opcode, _translate_table_str_op),\n        (ins.TGETB.opcode, _translate_normal),\n\n        (ins.TSETV.opcode, _translate_normal),\n        (ins.TSETS.opcode, _translate_table_str_op),\n        (ins.TSETB.opcode, _translate_normal),\n\n        (ins.TSETM.opcode, _translate_mass_set),\n\n        # Calls and vararg handling\n\n        (ins.CALLM.opcode, _translate_varg_call),\n        (ins.CALL.opcode, _translate_call),\n        (ins.CALLMT.opcode, _translate_varg_tailcall),\n        (ins.CALLT.opcode, _translate_tailcall),\n\n        (ins.ITERC.opcode, _translate_iterator),\n        (ins.ITERN.opcode, _translate_iterator),\n\n        (ins.VARG.opcode, _translate_vararg),\n\n        (ins.ISNEXT.opcode, _translate_normal),\n\n        # Returns\n\n        (ins.RETM.opcode, _translate_return_mult),\n        (ins.RET.opcode, _translate_return_many),\n        (ins.RET0.opcode, _translate_normal),\n        (ins.RET1.opcode, _translate_return_one),\n\n        # Loops and branches\n\n        (ins.FORI.opcode, _translate_for_init),\n        (ins.JFORI.opcode, _translate_for_init),\n\n        (ins.FORL.opcode, _translate_numeric_loop),\n        (ins.IFORL.opcode, _translate_numeric_loop),\n        (ins.JFORL.opcode, _translate_numeric_loop),\n\n        (ins.ITERL.opcode, _translate_iter_loop),\n        (ins.IITERL.opcode, _translate_iter_loop),\n        (ins.JITERL.opcode, _translate_iter_loop),\n\n        (ins.LOOP.opcode, _translate_normal),\n        (ins.ILOOP.opcode, _translate_normal),\n        (ins.JLOOP.opcode, _translate_normal),\n\n        (ins.JMP.opcode, _translate_normal),\n\n        # Function headers\n\n        (ins.FUNCF.opcode, _translate_normal),\n        (ins.IFUNCF.opcode, _translate_normal),\n        (ins.JFUNCF.opcode, _translate_normal),\n\n        (ins.FUNCV.opcode, _translate_normal),\n        (ins.IFUNCV.opcode, _translate_normal),\n        (ins.JFUNCV.opcode, _translate_normal),\n\n        (ins.FUNCC.opcode, _translate_normal),\n        (ins.FUNCCW.opcode, _translate_normal)\n    ]\n\n    bisect.insort(_HANDLERS_MAP, (ins.ISTYPE.opcode, _translate_normal))\n    bisect.insort(_HANDLERS_MAP, (ins.ISNUM.opcode, _translate_normal))\n    bisect.insort(_HANDLERS_MAP, (ins.TGETR.opcode, _translate_normal))\n    bisect.insort(_HANDLERS_MAP, (ins.TSETR.opcode, _translate_normal))\n\n    global _DESCRIPTION_HANDLERS\n    _DESCRIPTION_HANDLERS = [None] * 255\n\n    for opcode, handler in _HANDLERS_MAP:\n        _DESCRIPTION_HANDLERS[opcode] = handler", ""]}
{"filename": "ljd/pseudoasm/prototype.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport ljd.pseudoasm.constants\nimport ljd.pseudoasm.instructions\n\n\ndef write(writer, prototype):\n    _write_header(writer, prototype)\n    write_body(writer, prototype)\n\n    writer.stream.close_block(\"\")", "def write(writer, prototype):\n    _write_header(writer, prototype)\n    write_body(writer, prototype)\n\n    writer.stream.close_block(\"\")\n\n\ndef _write_header(writer, prototype):\n    writer.stream.open_block(\"main {0}\", format_header(writer, prototype))\n", "\n\ndef format_header(writer, prototype):\n    return \"{s}:{start}-{end}: {argn}{varg} args,\" \\\n           \" {uvs} upvalues, {slots} slots\".format(\n            s=writer.source,\n            start=prototype.first_line_number,\n            end=prototype.first_line_number + prototype.lines_count,\n            argn=prototype.arguments_count,\n            varg=\"+\" if prototype.flags.is_variadic else \"\",\n            uvs=len(prototype.constants.upvalue_references),\n            slots=prototype.framesize\n        )", "\n\ndef write_debug_info(writer, prototype):\n    if prototype.lines_count == 0:\n        return\n\n    debuginfo = prototype.debuginfo\n    upvalue_name = debuginfo.upvalue_variable_names\n    writer.stream.write_line(\";;;; upvalue names ;;;;\")\n    for slot, name in enumerate(upvalue_name):\n        writer.stream.write_line(\"  {0}:\\t{1}\".format(slot, name))\n\n    writer.stream.write_line(\";;;; variable info ;;;;\")\n    variable_info = debuginfo.variable_info\n    for var in variable_info:\n        writer.stream.write_line(\"  {start}-{end}:\\t{name}\".format(\n            start=max(0, var.start_addr - 1),\n            end=var.end_addr - 1,\n            name=var.name,\n        ));", "\n\ndef write_body(writer, prototype):\n    writer.stream.write_line(\";;;; constant tables ;;;;\")\n    ljd.pseudoasm.constants.write_tables(writer, prototype)\n\n    write_debug_info(writer, prototype)\n\n    writer.stream.write_line(\";;;; instructions ;;;;\")\n    ljd.pseudoasm.instructions.write(writer, prototype)", ""]}
{"filename": "ljd/pseudoasm/__init__.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n"]}
{"filename": "ljd/pseudoasm/constants.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport ljd.bytecode.constants\n\n\ndef write_tables(writer, prototype):\n    i = 0\n\n    for element in prototype.constants.complex_constants:\n        if isinstance(element, ljd.bytecode.constants.Table):\n            _write_table(writer, i, element)\n\n        i += 1", "\n\ndef _write_table(writer, index, table):\n    writer.stream.open_block(\"ktable#{0} = [\", index)\n\n    i = 0\n\n    for element in table.array:\n        if i != 0 or element is not None:\n            text = _translate_element(element)\n\n            writer.stream.write_line(\"#{0}: {1},\", i, text)\n\n        i += 1\n\n    for key, value in table.dictionary:\n        key = _translate_element(key)\n        value = _translate_element(value)\n\n        writer.stream.write_line(\"[{0}] = {1},\", key, value)\n\n    writer.stream.close_block(\"]\")\n    writer.stream.write_line()\n    writer.stream.write_line()", "\n\ndef _translate_element(element):\n    if element is True:\n        return \"true\"\n    elif element is False:\n        return \"false\"\n    elif element is None:\n        return \"nil\"\n    elif isinstance(element, bytes):\n        return '\"' + element.decode(\"utf-8\", \"backslashreplace\") + '\"'\n    else:\n        return str(element)", ""]}
{"filename": "ljd/ast/slotworks.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport warnings\nimport os\nimport logging\nimport ljd.ast.nodes as nodes\nimport ljd.ast.traverse as traverse\nfrom ljd.ast.helpers import insert_table_record", "import ljd.ast.traverse as traverse\nfrom ljd.ast.helpers import insert_table_record\n\nfrom typing import List\nfrom dataclasses import dataclass\n\ncatch_asserts = False\ndebug_verify = \"LJD_DEBUG\" in os.environ\nlogger = logging.getLogger(__name__)\n\"\"\"", "logger = logging.getLogger(__name__)\n\"\"\"\nTemporary slot cleanup eliminating assignments - general documentation\n\nImagine the following:\n\nslot0 = \"mything\"\nslot1 = slot0\nreturn slot1\n", "return slot1\n\nThere's a couple of ways this could be simplified. If slot0 is eliminated first, it will look like this:\n\n(slot0 = \"mything\" -- marked for deletion)\nslot1 = \"mything\"\nreturn slot1\n\nreturn \"mything\"\n", "return \"mything\"\n\nIf, however (and this can happen under some situations) slot1 is eliminated first, the following can occur:\n\nslot0 = \"mything\"\n(slot1 = slot0 -- marked for deletion)\nreturn slot0\n\n(slot0 = \"mything\" -- marked for deletion)\n(slot1 = \"mything\" -- marked for deletion, substituion was made here)", "(slot0 = \"mything\" -- marked for deletion)\n(slot1 = \"mything\" -- marked for deletion, substituion was made here)\nreturn slot0\n\nWhich method is used depends on the ordering of the collected slots.\n\nNow, why does this occur? The visitor system that collects all the slots does so node-by-node so it should\npick up the earlier slots first. This is broken due to the committing system: when a slot is first used, it\nit not immediately added to the slots list. Rather, it is marked as a 'known slot', and any references to\nit will be added. This is done as one slot may refer to multiple variables, as per below:", "it not immediately added to the slots list. Rather, it is marked as a 'known slot', and any references to\nit will be added. This is done as one slot may refer to multiple variables, as per below:\n\naddr1:   slot0 = my_global\naddr2:   slot1 = slot0 -- slot1 is my_global\naddr3:   slot1 = slot1() -- slot1 is the result of the function execution\n\nWhenever a slot is reassigned, it is \"committed\" into the slots array. At the end of parsing, any uncommitted\nslots are committed. In this case the slot0, it is only assigned at addr1, and is therefore committed at the\nvery end, after everything else. slot1 is assigned both at addr2 and addr3. When addr3 is visited, slot1 gets", "slots are committed. In this case the slot0, it is only assigned at addr1, and is therefore committed at the\nvery end, after everything else. slot1 is assigned both at addr2 and addr3. When addr3 is visited, slot1 gets\ncommitted to the stack as the same slot is used to hold another different value.\nThe slots list is then as follows: [addr2_slot1, addr1_slot0, addr3_slot1], and we get broken output.\n\nHere's a minimal code sample to reproduce this:\nlocal some_local = my_global\nlocal testing = some_local()\n\nThis is now fixed via _sort_slots - slots are given an ID in the order they first appear, and this is used to", "\nThis is now fixed via _sort_slots - slots are given an ID in the order they first appear, and this is used to\nsort them. This should solve this issue for good.\n\"\"\"\n\n\n@dataclass\nclass RefsProcessData:\n    slots: List['SlotInfo']\n    simple: List\n    massive: List\n    tables: List\n    iterators: List\n    unsafe: List", "\n\ndef eliminate_temporary(ast, ignore_ambiguous=True, identify_slots=False, safe_mode=True, unwarped=False):\n    logger.debug('Before eliminate %s', ast)\n    _eliminate_multres(ast)\n\n    slots, unused = _collect_slots(ast, identify_slots=identify_slots, unwarped=unwarped)\n    _sort_slots(slots)\n    \n    _eliminate_temporary(ast, slots, ignore_ambiguous, safe_mode=safe_mode, unwarped=unwarped)\n\n    _remove_unused(unused)\n\n    if not unwarped:\n        _cleanup_invalid_nodes(ast)\n    logger.debug('After eliminate %s', ast)\n    return ast", "\n\ndef simplify_ast(ast, dirty_callback=None):\n    traverse.traverse(_SimplifyVisitor(dirty_callback=dirty_callback), ast)\n\n\ndef _eliminate_temporary(ast, slots, ignore_ambiguous=True, safe_mode=True, unwarped=False):\n    data = RefsProcessData(slots, [], [], [], [], [])\n\n    _fill_refs(data, ignore_ambiguous and safe_mode, True)\n\n    _eliminate_simple_cases(data.simple)\n    _recheck_unsafe_cases(ast, data.unsafe, ignore_ambiguous=False, safe_mode=safe_mode, unwarped=unwarped)\n\n    _eliminate_into_table_constructors(data.tables)\n    _eliminate_mass_assignments(data.massive)\n    _eliminate_iterators(data.iterators)", "\n\ndef _fill_refs(data: RefsProcessData, ignore_ambiguous=True, safe_mode=True):\n    \"\"\"\n    A SlotInfo represents a slot being used in a specific, limited context. There must be only\n    one write into the slot, but there can by any number of reads from it.\n    For example (slot1 being the slot in question, hence in caps):\n    \n    slot0 = f()\n    SLOT1 = slot0\n    my_gbl_1 = SLOT1\n    my_gbl_2 = SLOT1\n    \n    This is a limited enough scope that we can - under some conditions - inline through that\n    slot. See the comment at the top of the file for more context.\n    \n    A massive slot is when it's in a large assignment, such as:\n    slot0, slot1 = f()\n    \"\"\"\n\n    for info in data.slots:\n        assignment = info.assignment\n\n        if not isinstance(assignment, nodes.Assignment):\n            assert isinstance(assignment, (nodes.IteratorWarp,\n                                           nodes.NumericLoopWarp,\n                                           nodes.FunctionDefinition))\n\n            src = info.references[1].identifier\n            data.simple.append((info.references, src))\n            continue\n\n        assert len(assignment.expressions.contents) == 1\n\n        is_massive = len(assignment.destinations.contents) > 1\n\n        if is_massive:\n            _fill_massive_refs(info, data, ignore_ambiguous, safe_mode)\n        else:\n            _fill_simple_refs(info, data, ignore_ambiguous, safe_mode)", "\n\ndef _recheck_unsafe_cases(ast, unsafe, ignore_ambiguous, safe_mode=True, unwarped=False):\n    if not unsafe:\n        return\n\n    blocks = set()\n    slots = set()\n    for info in unsafe:\n        slots.add(str(info.slot) + \"#\" + str(info.slot_id))\n        if not unwarped:\n            for ref in info.references[1:]:\n                for node in reversed(ref.path):\n                    if isinstance(node, nodes.Block):\n                        blocks.add(node)\n                        break\n\n    if not blocks and not unwarped:\n        return\n\n    def _node_dirty_cb(node):\n        if not unwarped and not isinstance(node, nodes.Block):\n            return\n\n        _cleanup_invalid_nodes(node)\n\n        # Collect slots in the block, but only keep those that were deemed unsafe to eliminate before.\n        new_slots, _ = _collect_slots(node, unwarped=unwarped)\n        if safe_mode:\n            for idx, info in enumerate(new_slots):\n                if (str(info.slot) + \"#\" + str(info.slot_id)) not in slots:\n                    del new_slots[idx]\n\n        _sort_slots(new_slots)\n\n        new_data = RefsProcessData(new_slots, [], [], [], [], [])\n\n        _fill_refs(new_data, ignore_ambiguous and safe_mode, safe_mode)\n        _eliminate_simple_cases(new_data.simple)\n\n    if unwarped:\n        simplify_ast(ast, dirty_callback=_node_dirty_cb)\n    else:\n        for block in blocks:\n            simplify_ast(block, dirty_callback=_node_dirty_cb)", "\n\ndef _fill_massive_refs(info: 'SlotInfo', data: RefsProcessData, ignore_ambiguous, safe_mode=True):\n    ref = info.references[1]\n    holder = _get_holder(ref.path)\n\n    src = info.assignment.expressions.contents[0]\n\n    # When the compiler needs to null out multiple variables, it can use\n    # the KNIL instruction to do so. For example, the following:\n    #   local a = nil; local b = nil; local c = nil;\n    # Compiles down to a single KNIL instruction (assuming a-c are slots 0-2):\n    #   KNIL 0 2\n    # There's no point in treating it like the result of a function call or\n    # vararg, since (AFAIK) the point of massive refs for those is since they\n    # can't really be inlined around because they're all tied together. That's\n    # not an issue with KNIL (since all the values are independently nil), so\n    # we can just hand over to the simple ref filler, which will (or should, may\n    # need to look into it) inline it as usual.\n    #\n    # In particular, this solves the massive_nils test crashing since the results\n    # are referenced more than twice.\n    if isinstance(src, nodes.Primitive):\n        assert src.type == src.T_NIL\n\n        _fill_simple_refs(info, data, ignore_ambiguous, safe_mode)\n        return\n\n    def _remove_invalid_references():\n        if not safe_mode:\n            return\n        # TODO need to check why these invalid references end up here and whether they're actually invalid\n        while len(info.references) > 2:\n            current_ref = info.references[-1].identifier\n            if current_ref.id != -1:\n                break\n            possible_ids = getattr(current_ref, \"_ids\", [])\n            if info.slot_id in possible_ids:\n                possible_ids.remove(info.slot_id)\n            else:\n                warnings.warn('info.slot_id %s not in possible id list' % info.slot_id)\n            del info.references[-1]\n\n    assert isinstance(src, (nodes.FunctionCall, nodes.Vararg))\n    if isinstance(holder, nodes.Assignment):\n        dst = holder.destinations.contents[0]\n\n        _remove_invalid_references()\n\n        # It's perfectly valid for there to be >2 references. This does mean we can't eliminate them as\n        # massive references. Instead, leave them as a local variable.\n        if len(info.references) != 2:\n            data.unsafe.append(info)\n            return\n\n        orig = info.references[0].identifier\n\n        assignment = ref.path[-3]\n\n        assert isinstance(assignment, nodes.Assignment)\n\n        data.massive.append((orig, info, assignment, dst))\n    elif isinstance(holder, nodes.IteratorWarp):\n        _remove_invalid_references()\n        if len(info.references) != 2:\n            warnings.warn('invalid info.references: len=%s' % len(info.references))\n            data.unsafe.append(info)\n            return\n        data.iterators.append((info, src, holder))", "\n\ndef _fill_simple_refs(info, data: RefsProcessData, ignore_ambiguous, safe_mode=True):\n    src = info.assignment.expressions.contents[0]\n\n    src_is_table = isinstance(src, nodes.TableConstructor)\n\n    holders = set()\n\n    # Collect all the simple refs as we go through, then make a policy decision about what to\n    # do with them at the end. This also folds in the table constructor elements, even if simple\n    # inlining cannot be performed (though mutator.py would likely pick this up regardless).\n    new_simple = []\n\n    # Check if we've had a single non-table-constructor-write reference yet. If so, none of the\n    # following references can be part of the constructor.\n    # Without this, the following:\n    #\n    # local test = {}\n    # f(test)\n    # test.abc = \"hi\"\n    #\n    # Decompiles to:\n    #\n    # slot0 = { abc = \"hi\" }\n    # f(slot0)\n    #\n    # Note that when debugging this, it may be wise to disable mutator.py - it can interfere\n    # with the results and move things into the constructor that otherwise wouldn't be.\n    all_ctor_refs = True\n\n    for ref in info.references[1:]:\n        if ignore_ambiguous and ref.identifier.id == -1:\n            continue\n\n        holder = _get_holder(ref.path)\n\n        is_element = isinstance(holder, nodes.GetItem)\n\n        if is_element:\n            # Fixes an error on this:\n            # local a = tbl[var or 123]:func()\n            # This is due to the compiler only evaluating (var or 123) once, then mov-ing that to\n            # another slot, and this results in two different slot references that have the same holder.\n            if holder in holders:\n                continue\n\n            holders.add(holder)\n\n        path_index = ref.path.index(holder)\n\n        statement = _get_holder(ref.path[:path_index])\n\n        statement_is_assignment = isinstance(statement, nodes.Assignment)\n\n        if statement_is_assignment:\n            is_dst = statement.destinations.contents[0] == holder\n        else:\n            is_dst = False\n\n        if debug_verify:\n            for tst_info, tst_ref, _ in new_simple:\n                if tst_info == info:\n                    tst_holder = tst_ref.path[-2]\n                    assert tst_holder != ref.path[-2]\n                    assert tst_holder != holder\n        \n        # Could be more then one reference here\n        if src_is_table and is_element and is_dst and all_ctor_refs:\n            if holder.table != ref.identifier:\n                warnings.warn('holder.table %s != ref.identifier %s' % (holder.table, ref.identifier))\n                new_simple.append((info, ref, None))\n                all_ctor_refs = False\n            else:\n                data.tables.append((info, ref))\n        else:\n            new_simple.append((info, ref, None))\n            all_ctor_refs = False\n\n    # Don't attempt to simplify any slots that have more than two usages (excluding table constructor elements).\n    # This is a major policy change, as slotworks used to inline almost anything and\n    # everything, with the exception of the results of function calls with more than three\n    # uses.\n    # This caused a LOT of incorrect decompilation results, however this is only noticeable\n    # when running against stripped code - when a slot has a name attached, it cannot be\n    # simplified and thus many of these issues would not appear.\n    # For an example of the issues this caused, see issue #19 (https://gitlab.com/znixian/luajit-decompiler/issues/19)\n    # Also note that we only inline the use if it's still valid at the end.\n    #\n    # And as for the issue 19 problem, why isn't that still happening like this? There's still\n    # only one simple reference, since the other one has been moved into the tables system. The\n    # answer is 55b2f5c, which introduced all_ctor_refs. Since the table is referenced before the\n    # third use, it cannot be moved into the constructor (well, mutator will move it in, but it'll\n    # be safe from being eliminated)\n    nr_simple_cases = len(new_simple)\n    if nr_simple_cases == 1 or (not safe_mode and nr_simple_cases == 2):\n        data.simple += new_simple\n    elif nr_simple_cases > 1:\n        data.unsafe.append(info)", "\n\nLIST_TYPES = (nodes.VariablesList,\n              nodes.IdentifiersList,\n              nodes.ExpressionsList,\n              nodes.StatementsList)\n\nOPERATOR_TYPES = (nodes.BinaryOperator, nodes.UnaryOperator)\n\n\ndef _get_holder(path):\n    for node in reversed(path[:-1]):\n        if not isinstance(node, LIST_TYPES):\n            return node\n\n    return None", "\n\ndef _get_holder(path):\n    for node in reversed(path[:-1]):\n        if not isinstance(node, LIST_TYPES):\n            return node\n\n    return None\n\n\ndef _eliminate_simple_cases(simple):\n    for info, ref, src in simple:\n        holder = ref.path[-2]\n        dst = ref.identifier\n\n        if src is None:\n            src = info.assignment.expressions.contents[0]\n\n        # Set later on if we'd be simplifying something down to illegal Lua code. This is when we\n        # substitute a primitive to somewhere it's not allowed, such as:\n        #    local a=nil; a()  ---> nil()\n        # We're doing this here rather than in _fill_simple_refs, since that doesn't actually know what\n        # it's substituting - a primitive could work it's way down a bunch of slots and it'd only know about\n        # the primitive when eliminating the first slot.\n        # See the illegal_type_eliminations test for an example of this\n        if isinstance(src, nodes.Primitive) or isinstance(src, nodes.Constant):\n            is_str = isinstance(src, nodes.Constant) and src.type == nodes.Constant.T_STRING\n            if isinstance(holder, nodes.FunctionCall) and holder.function == ref.identifier:\n                continue\n            elif isinstance(holder, nodes.GetItem) and holder.table == ref.identifier and not is_str:\n                continue\n\n        # if the assignment's src is FunctionDefinition and references 3 times(one time for assignment,and two\n        # times for call),so marked the identifier to local type and set the name to tmp slot\n        # TODO figure out *why* the functions are ending up here and fix it there\n        if isinstance(src, nodes.FunctionDefinition) and len(info.references) >= 3:\n            # Make sure it's actually 3 references, ignoring the ambiguous ones\n            nr_references = 0\n            for _ref in info.references:\n                if _ref.identifier.id == -1 and len(getattr(_ref, \"_ids\", [])) != 1:\n                    continue\n                nr_references += 1\n            if nr_references >= 3:\n                first = info.references[0]\n                first.identifier.type = nodes.Identifier.T_LOCAL\n                if first.identifier.name is None:\n                    first.identifier.name = 'slot%d' % first.identifier.slot\n                continue\n        elif isinstance(src, OPERATOR_TYPES) \\\n                and isinstance(holder, nodes.GetItem) \\\n                and holder.key == dst \\\n                and isinstance(ref.path[-3], nodes.FunctionCall):\n            # Handle a special case where a function has been incorrectly marked as a method now that\n            # a slot will be reduced to an expression with an operator\n            function = ref.path[-3]\n            if function.is_method and \\\n                    (not isinstance(function, nodes.GetItem)\n                     or function.key.type != nodes.Constant.T_STRING):\n                function.arguments.contents.insert(0, holder.table)\n                function.is_method = False\n\n        _mark_invalidated(info.assignment)\n\n        if isinstance(holder, LIST_TYPES):\n            conts = holder.contents\n            found = _replace_node_in_list(conts, dst, src)\n        else:\n            found = _replace_node(holder, dst, src)\n\n        assert found", "\n\ndef _eliminate_simple_cases(simple):\n    for info, ref, src in simple:\n        holder = ref.path[-2]\n        dst = ref.identifier\n\n        if src is None:\n            src = info.assignment.expressions.contents[0]\n\n        # Set later on if we'd be simplifying something down to illegal Lua code. This is when we\n        # substitute a primitive to somewhere it's not allowed, such as:\n        #    local a=nil; a()  ---> nil()\n        # We're doing this here rather than in _fill_simple_refs, since that doesn't actually know what\n        # it's substituting - a primitive could work it's way down a bunch of slots and it'd only know about\n        # the primitive when eliminating the first slot.\n        # See the illegal_type_eliminations test for an example of this\n        if isinstance(src, nodes.Primitive) or isinstance(src, nodes.Constant):\n            is_str = isinstance(src, nodes.Constant) and src.type == nodes.Constant.T_STRING\n            if isinstance(holder, nodes.FunctionCall) and holder.function == ref.identifier:\n                continue\n            elif isinstance(holder, nodes.GetItem) and holder.table == ref.identifier and not is_str:\n                continue\n\n        # if the assignment's src is FunctionDefinition and references 3 times(one time for assignment,and two\n        # times for call),so marked the identifier to local type and set the name to tmp slot\n        # TODO figure out *why* the functions are ending up here and fix it there\n        if isinstance(src, nodes.FunctionDefinition) and len(info.references) >= 3:\n            # Make sure it's actually 3 references, ignoring the ambiguous ones\n            nr_references = 0\n            for _ref in info.references:\n                if _ref.identifier.id == -1 and len(getattr(_ref, \"_ids\", [])) != 1:\n                    continue\n                nr_references += 1\n            if nr_references >= 3:\n                first = info.references[0]\n                first.identifier.type = nodes.Identifier.T_LOCAL\n                if first.identifier.name is None:\n                    first.identifier.name = 'slot%d' % first.identifier.slot\n                continue\n        elif isinstance(src, OPERATOR_TYPES) \\\n                and isinstance(holder, nodes.GetItem) \\\n                and holder.key == dst \\\n                and isinstance(ref.path[-3], nodes.FunctionCall):\n            # Handle a special case where a function has been incorrectly marked as a method now that\n            # a slot will be reduced to an expression with an operator\n            function = ref.path[-3]\n            if function.is_method and \\\n                    (not isinstance(function, nodes.GetItem)\n                     or function.key.type != nodes.Constant.T_STRING):\n                function.arguments.contents.insert(0, holder.table)\n                function.is_method = False\n\n        _mark_invalidated(info.assignment)\n\n        if isinstance(holder, LIST_TYPES):\n            conts = holder.contents\n            found = _replace_node_in_list(conts, dst, src)\n        else:\n            found = _replace_node(holder, dst, src)\n\n        assert found", "\n\ndef _eliminate_into_table_constructors(tables):\n    for info, ref in tables:\n        constructor = info.assignment.expressions.contents[0]\n        table_element = ref.path[-2]\n        assignment = ref.path[-4]\n\n        assert isinstance(assignment, nodes.Assignment)\n\n        assert len(assignment.expressions.contents) == 1\n        key = table_element.key\n        value = assignment.expressions.contents[0]\n\n        success = insert_table_record(constructor, key, value, False)\n\n        # If this would involve overwriting another record, handle it normally\n        if not success:\n            continue\n\n        _mark_invalidated(assignment)", "\n\ndef _eliminate_mass_assignments(massive):\n    for identifier, info, base_assignment, globalvar in massive:\n        # If the assignment using the slot has already been invalidated, then skip it.\n        # For example, the following:\n        #\n        # local a, b = f()\n        # print(a)\n        #\n        # Would be (roughly) compiled to:\n        #\n        # 001 local slot1, slot2 = f()\n        # 002 local slot3 = slot1\n        # 003 print(slot3)\n        #\n        # Both the massives elimination and simples elimination would eliminate 002 (corresponding\n        # to the base_assignment variable in this method), moving slot3 into the massive assignment.\n        # The simple elimination would also eliminate slot3, substituting slot1 into the print directly.\n        # This would result in:\n        #\n        # local slot3, slot2 = f()\n        # print(slot1)\n        #\n        # Since this is run after the simple elimination, check to ensure our target hasn't been swept\n        # out from under us.\n        if _is_invalidated(base_assignment):\n            continue\n\n        destinations = info.assignment.destinations.contents\n        found = _replace_node_in_list(destinations, identifier, globalvar)\n\n        _mark_invalidated(base_assignment)\n\n        assert found", "\n\ndef _replace_node(holder, original, replacement):\n    for key, value in holder.__dict__.items():\n        if value == original:\n            setattr(holder, key, replacement)\n            return True\n\n    return False\n", "\n\ndef _replace_node_in_list(node_list, original, replacement):\n    try:\n        index = node_list.index(original)\n    except ValueError:\n        return False\n\n    node_list[index] = replacement\n    return True", "\n\ndef _eliminate_iterators(iterators):\n    processed_warps = set()\n\n    for info, src, warp in iterators:\n        assignment = info.assignment\n        if warp in processed_warps:\n            continue\n\n        # Handle `for a in b` where `b` is a variable, or indexing a table (`a.b`)\n        # In those cases, the first element in cts will be whatever we should iterate\n        #  over, and assignment.destination.contents will only contain two items\n        pre = None\n        cts = warp.controls.contents\n        if len(assignment.destinations.contents) == 2 and len(cts) == 3:\n            pre = [cts[0]]\n            cts = cts[1:]\n\n        for i, slot in enumerate(assignment.destinations.contents):\n            if hasattr(cts[i], \"slot\"):\n                try:\n                    assert cts[i].slot == slot.slot\n                except (AttributeError, AssertionError):\n                    if catch_asserts:\n                        setattr(assignment, \"_decompilation_error_here\", True)\n                        print(\"-- WARNING: Error occurred during decompilation.\")\n                        print(\"--   Code may be incomplete or incorrect.\")\n                    else:\n                        raise\n\n        warp.controls.contents = pre or [src]\n        processed_warps.add(warp)\n\n        _mark_invalidated(assignment)", "\n\ndef _mark_invalidated(node):\n    setattr(node, \"_invalidated\", True)\n\n\ndef _is_invalidated(node):\n    return getattr(node, \"_invalidated\", False)\n\n\ndef _remove_unused(unused):\n    pass", "\n\ndef _remove_unused(unused):\n    pass\n\n\ndef _collect_slots(ast, identify_slots=False, unwarped=False):\n    collector = _SlotsCollector(identify_slots, unwarped)\n    traverse.traverse(collector, ast)\n\n    return collector.slots, collector.unused", "\n\ndef _eliminate_multres(ast):\n    traverse.traverse(_MultresEliminator(), ast)\n    _cleanup_invalid_nodes(ast)\n\n\ndef _sort_slots(slots):\n    def get_slot_id(slot):\n        return slot.slot_id\n\n    slots.sort(key=get_slot_id)", "\n\nclass _MultresEliminator(traverse.Visitor):\n    def __init__(self):\n        super().__init__()\n        self._last_multres_value = None\n\n    def leave_assignment(self, node):\n        src = node.expressions.contents[0]\n        dst = node.destinations.contents[0]\n\n        if isinstance(dst, nodes.MULTRES):\n            assert len(node.destinations.contents) == 1\n            assert len(node.expressions.contents) == 1\n\n            assert isinstance(src, (nodes.FunctionCall, nodes.Vararg))\n\n            assert self._last_multres_value is None\n\n            self._last_multres_value = src\n\n            _mark_invalidated(node)\n        else:\n            for i, src in enumerate(node.expressions.contents):\n                if isinstance(src, nodes.MULTRES):\n                    break\n            else:\n                return\n\n            assert self._last_multres_value is not None\n\n            node.expressions.contents[i] = self._last_multres_value\n            self._last_multres_value = None\n\n    def _process_multres_in_list(self, nodes_list):\n        for i, node in enumerate(nodes_list):\n            if isinstance(node, nodes.MULTRES):\n                break\n        else:\n            return\n\n        assert self._last_multres_value is not None\n\n        nodes_list[i] = self._last_multres_value\n        self._last_multres_value = None\n\n    def visit_function_call(self, node):\n        self._process_multres_in_list(node.arguments.contents)\n\n    def visit_return(self, node):\n        self._process_multres_in_list(node.returns.contents)", "\n\nclass SlotReference:\n    def __init__(self):\n        self.path = []\n        self.identifier = None\n\n    def __repr__(self) -> str:\n        return 'Ref(%s %s)' % (self.identifier, self.path)\n    \n    __str__ = __repr__", "\nclass SlotInfo:\n    references: List[SlotReference]\n\n    def __init__(self, id):\n        self.slot = 0\n\n        self.assignment = None\n        self.references = []\n        self.termination = None\n\n        self.function = None\n\n        # An ID representing the position in the input\n        # This is used to ensure correct ordering of the slots, preventing reverse references (see comment about\n        # the temporary slot cleanup eliminating assignments)\n        self.slot_id = id\n\n    def __repr__(self) -> str:\n        return 'slot%s_%s' % (self.slot, self.slot_id)", "\nclass _SlotsCollector(traverse.Visitor):\n    class _State:\n        def __init__(self):\n            self.known_slots = {}\n            self.all_known_slots = {}\n\n            self.block_slots = {}\n            self.block_refs = {}\n            self.block = None\n\n            self.function = None\n\n    # ##\n\n    def __init__(self, identify_slots=False, unwarped=False):\n        super().__init__()\n        self._states = []\n        self._path = []\n        self._root = None\n        self._skip = None\n        self._next_slot_id = 0\n        self._identify = identify_slots\n        self._unwarped = unwarped\n        self._level = 0\n\n        self.slots = []\n        self.unused = []\n\n        self._push_state()\n\n    # ##\n\n    def _state(self):\n        return self._states[-1]\n\n    def _push_state(self):\n        self._states.append(_SlotsCollector._State())\n\n    def _pop_state(self):\n        self._states.pop()\n\n    # ##\n\n    # Slots are stored (at most) twice: once by their id and the most recent slot assignment\n    # will be stored with id -1. This way we can prevent the loss of information after an elimination\n    # step where an expression references the same slot at multiple states (ids).\n    def _get_slot(self, slot, exact=True):\n        slot_states = self._state().known_slots.get(slot.slot)\n        if slot_states:\n            info = slot_states.get(slot.id)\n            if exact and info and info.slot_id != slot.id:\n                return None\n            return info\n        return None\n\n    def _set_slot(self, slot, info):\n        state = self._state()\n        for target in [state.known_slots, state.all_known_slots]:\n            slot_states = target.get(slot.slot)\n            if not slot_states:\n                slot_states = {}\n                target[slot.slot] = slot_states\n            slot_states[slot.id] = info\n            if slot.id != -1:\n                slot_states[-1] = info\n\n    def _remove_slot(self, slot):\n        state = self._state()\n        for target in [state.known_slots, state.all_known_slots]:\n            slot_states = target.get(slot.slot)\n            if slot_states:\n                if slot.id != -1:\n                    info = slot_states.get(slot.id)\n                    if info == slot_states.get(-1):\n                        del slot_states[-1]\n                del slot_states[slot.id]\n                if not slot_states:\n                    del target[slot.slot]\n\n    def _find_slot_assignments(self, index, block=None, visited=None):\n        state = self._state()\n        refs = state.block_refs\n        block = block or state.block\n\n        known_slots = state.block_slots.get(block)\n        slot_states = known_slots and known_slots.get(index)\n        if slot_states:\n            info = slot_states.get(-1)\n            if info:\n                return [info]\n\n        blocks_to_check = refs.get(block)\n        if not blocks_to_check:\n            return None\n\n        # Keep track of visited nodes to prevent infinite loops\n        visited = visited or set()\n        visited.add(block)\n\n        possibilities = set()\n        for ref in blocks_to_check:\n            if ref in visited:\n                continue\n\n            found = self._find_slot_assignments(index, ref, visited)\n            if found:\n                for info in found:\n                    possibilities.add(info)\n\n        return list(possibilities)\n\n    def _commit_info(self, info):\n        assert len(info.references) > 0\n\n        if len(info.references) == 1:\n            self.unused.append(info)\n        else:\n            self.slots.append(info)\n\n    def _commit_slot(self, slot, node):\n        info = self._get_slot(slot) # False\n\n        if info is None:\n            return\n\n        info.termination = node\n\n        self._remove_slot(slot)\n\n        self._commit_info(info)\n\n    def _register_slot(self, slot, node):\n        self._commit_slot(slot, node)\n\n        # We need to re-use known slot ids here to avoid assigning a new id to a slot that has been registered on a\n        # previous slot collection run.\n        slot_id = slot.id\n        if slot_id == -1:\n            slot_id = self._next_slot_id\n            self._next_slot_id += 1\n            slot.id = slot_id\n\n        info = SlotInfo(slot_id)\n        info.slot = slot.slot\n        info.assignment = node\n        info.function = self._state().function\n\n        self._set_slot(slot, info)\n\n    def _register_all_slots(self, node, slots):\n        for slot in slots:\n            if not isinstance(slot, nodes.Identifier):\n                continue\n\n            if slot.type != nodes.Identifier.T_SLOT:\n                continue\n\n            self._register_slot(slot, node)\n\n    def _commit_all_slots(self, slots, node):\n        for slot in slots:\n            if not isinstance(slot, nodes.Identifier):\n                continue\n\n            self._commit_slot(slot, node)\n\n    def _register_slot_reference(self, info: 'SlotInfo', node, update_id=True):\n        reference = SlotReference()\n        reference.identifier = node\n\n        # Make sure the identifier node stores the correct slot reference.\n        if node.id == -1:\n            possible_ids = getattr(node, \"_ids\", [])\n            if info.slot_id not in possible_ids:\n                if update_id:\n                    if len(possible_ids) > 0:\n                        # Slot matches, but not the id.\n                        return\n                    node.id = info.slot_id\n                elif self._identify:\n                    possible_ids.append(info.slot_id)\n                    setattr(node, \"_ids\", possible_ids)\n                    possible_ids.sort()\n\n        # Copy the list, but not contents\n        reference.path = self._path[:]\n\n        info.references.append(reference)\n\n    # ##\n\n    def visit_assignment(self, node: nodes.Assignment):\n        self._visit(node.expressions)\n        self._skip = node.expressions\n\n        self._register_all_slots(node, node.destinations.contents)\n\n    def leave_assignment(self, node):\n        self._skip = None\n\n    def visit_identifier(self, node):\n        if node.type != nodes.Identifier.T_SLOT:\n            return\n\n        # Slot references may have a reference to a slot that was identified in a previous block. When\n        # this is the case, we need to use the slot that has been assigned most recently.\n        info = self._get_slot(node, False)\n        if info:\n            self._register_slot_reference(info, node)\n            return\n\n        # No direct reference is found, so look through blocks and register all references\n        assignments = self._find_slot_assignments(node.slot)\n        if assignments:\n            update_ids = self._identify and len(assignments) == 1\n            for info in assignments:\n                self._register_slot_reference(info, node, False)\n\n    # ##\n\n    def visit_function_definition(self, node):\n        self._push_state()\n        self._state().function = node\n\n        self._level += 1\n\n    def leave_function_definition(self, node):\n        self._level -= 1\n        if self._unwarped and self._level == 0:\n            state = self._state()\n            for info_states in state.known_slots.values():\n                for slot_id, info in info_states.items():\n                    # Commit slots only once, so ignore the extra references to the \"most recent\" slots.\n                    if slot_id == info.slot_id:\n                        self._commit_info(info)\n\n        self._pop_state()\n\n    def visit_block(self, node):\n        state = self._state()\n        state.block = node\n        state.block_slots[node] = state.known_slots\n\n    def leave_block(self, node):\n        state = self._state()\n\n        refs = None\n        warp = node.warp\n        if isinstance(warp, nodes.ConditionalWarp):\n            refs = [warp.true_target, warp.false_target]\n        elif isinstance(warp, nodes.UnconditionalWarp):\n            refs = [warp.target]\n        elif isinstance(warp, nodes.NumericLoopWarp):\n            refs = [warp.way_out]\n        elif isinstance(warp, nodes.IteratorWarp):\n            refs = [warp.way_out]\n\n        for ref in refs or []:\n            if not ref: continue\n            block_refs = state.block_refs.setdefault(ref, set())\n            block_refs.add(node)\n\n        for info_states in state.known_slots.values():\n            for slot_id, info in info_states.items():\n                # Commit slots only once, so ignore the extra references to the \"most recent\" slots.\n                if slot_id == info.slot_id:\n                    self._commit_info(info)\n\n        state.known_slots = {}\n\n    # ##\n\n    def _visit_node(self, handler, node):\n        self._path.append(node)\n\n        traverse.Visitor._visit_node(self, handler, node)\n\n    def _leave_node(self, handler, node):\n        self._path.pop()\n\n        traverse.Visitor._leave_node(self, handler, node)\n\n    def _visit(self, node):\n        if self._skip == node:\n            return\n\n        is_root_node = False\n        if self._root is None:\n            is_root_node = True\n            self._root = node\n\n        traverse.Visitor._visit(self, node)\n\n        if is_root_node:\n            self._root = None", "\n\ndef _cleanup_invalid_nodes(ast):\n    traverse.traverse(_TreeCleanup(), ast)\n\n\nclass _TreeCleanup(traverse.Visitor):\n    def visit_block(self, node):\n        patched = []\n\n        for subnode in node.contents:\n            if not _is_invalidated(subnode):\n                patched.append(subnode)\n\n        node.contents = patched", "\n\nclass _SimplifyVisitor(traverse.Visitor):\n\n    def __init__(self, dirty_callback=None):\n        super().__init__()\n        self._dirty = False\n        self._dirty_cb = dirty_callback\n        self._root = None\n\n    def _visit_node(self, handler, node):\n        if not self._root:\n            self._root = node\n\n        traverse.Visitor._visit_node(self, handler, node)\n\n    def _leave_node(self, handler, node):\n        if self._root == node:\n            self._root = None\n            if self._dirty:\n                if self._dirty_cb:\n                    self._dirty_cb(node)\n                self._dirty = False\n\n        traverse.Visitor._leave_node(self, handler, node)\n\n    def leave_block(self, node):\n        if self._dirty:\n            if self._dirty_cb:\n                self._dirty_cb(node)\n            self._dirty = False\n\n    # Identify method calls, and mark them as such early. This eliminates their 'this' argument, which allows\n    # the elimination of slots that would otherwise have three uses.\n    def visit_function_call(self, node):\n        if node.is_method:\n            return\n\n        args = node.arguments.contents\n        func = node.function\n\n        if len(args) < 1 or not isinstance(args[0], nodes.Identifier):\n            return\n\n        arg0 = args[0]\n        if not isinstance(func, nodes.GetItem) or not isinstance(func.table, nodes.Identifier):\n            return\n        elif isinstance(func.key, nodes.Identifier):\n            if func.key.type != nodes.Identifier.T_SLOT:\n                return\n        elif not isinstance(func.key, nodes.Constant) or func.key.type != nodes.Constant.T_STRING:\n            return\n\n        table = func.table\n\n        if arg0.name != table.name or arg0.type != table.type or arg0.slot != table.slot:\n            return\n\n        self._dirty = True\n        node.is_method = True\n        del args[0]", ""]}
{"filename": "ljd/ast/validator.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport ljd.ast.nodes as nodes\nimport ljd.ast.traverse as traverse\nimport ljd\n\ncatch_asserts = False\n", "catch_asserts = False\n\n\nclass TypeRestriction:\n    def __init__(self, default, specific):\n        if isinstance(default, dict) and specific == {}:\n            specific = default\n            default = None\n\n        self.default = default\n        self.specific = specific\n\n    def check(self, node):\n        try:\n            typespec = self.specific[node]\n        except KeyError:\n            typespec = self.default\n\n        assert typespec, \"Unknown node: {0}\".format(node)\n\n        try:\n            assert isinstance(node, typespec), \\\n                \"Invalid node type: {0} should be: {1}\" \\\n                    .format(type(node), typespec)\n        except AssertionError:\n            if catch_asserts:\n                if node is not None:\n                    setattr(node, \"_decompilation_error_here\", True)\n                print(\"-- WARNING: Error occurred during decompilation.\")\n                print(\"--   Code may be incomplete or incorrect.\")\n            else:\n                raise", "\n\nSTATEMENT_TYPES = (\n    nodes.Assignment,\n    nodes.If,\n    nodes.IteratorFor,\n    nodes.NumericFor,\n    nodes.RepeatUntil,\n    nodes.Return,\n    nodes.Break,", "    nodes.Return,\n    nodes.Break,\n    nodes.FunctionCall,\n    nodes.NoOp,\n    nodes.While\n)\n\nEXPRESSION_TYPES = (\n    nodes.FunctionCall,\n    nodes.Primitive,", "    nodes.FunctionCall,\n    nodes.Primitive,\n    nodes.Constant,\n    nodes.Identifier,\n    nodes.FunctionDefinition,\n    nodes.TableConstructor,\n    nodes.Vararg,\n    nodes.BinaryOperator,\n    nodes.UnaryOperator,\n    nodes.MULTRES,", "    nodes.UnaryOperator,\n    nodes.MULTRES,\n    nodes.GetItem,\n)\n\nVARIABLE_TYPES = (\n    nodes.Identifier,\n    nodes.GetItem,\n    nodes.MULTRES  # It's not valid here, but it is a hack anyway...\n)", "    nodes.MULTRES  # It's not valid here, but it is a hack anyway...\n)\n\nIDENTIFIER = (\n    nodes.Identifier,\n)\n\nWARP_TYPES = (\n    nodes.UnconditionalWarp,\n    nodes.ConditionalWarp,", "    nodes.UnconditionalWarp,\n    nodes.ConditionalWarp,\n    nodes.IteratorWarp,\n    nodes.NumericLoopWarp,\n    nodes.EndWarp\n)\n\n\nclass Visitor(traverse.Visitor):\n    def __init__(self, warped=True):\n        # Restrictions for the upmost level\n        self.restrictions = [None]\n        self.warped = warped\n\n    def _set_restrictions(self, default, specific=None):\n        if specific is None:\n            specific = {}\n        self.restrictions[-1] = TypeRestriction(default, specific)\n\n    # ##\n\n    def visit_function_definition(self, node):\n        self._set_restrictions(nodes.Block, {\n            node.arguments: nodes.IdentifiersList,\n            node.statements: nodes.StatementsList\n        })\n\n    # ##\n\n    def visit_table_constructor(self, node):\n        self._set_restrictions(nodes.RecordsList)\n\n    def visit_array_record(self, node):\n        self._set_restrictions(EXPRESSION_TYPES)\n\n    def visit_table_record(self, node):\n        self._set_restrictions(EXPRESSION_TYPES)\n\n    # ##\n\n    def visit_assignment(self, node):\n        self._set_restrictions({\n            node.destinations: nodes.VariablesList,\n            node.expressions: nodes.ExpressionsList\n        })\n\n        if not isinstance(node.destinations.contents[0], nodes.Identifier):\n            return\n\n        if node.destinations.contents[0].type != nodes.Identifier.T_LOCAL:\n            return\n\n    # Don't test type flag here\n    # ##\n\n    def visit_binary_operator(self, node):\n        self._set_restrictions(EXPRESSION_TYPES)\n\n        assert node.type == nodes.BinaryOperator.T_LOGICAL_OR \\\n               or node.type == nodes.BinaryOperator.T_LOGICAL_AND \\\n \\\n               or node.type == nodes.BinaryOperator.T_LESS_THEN \\\n               or node.type == nodes.BinaryOperator.T_GREATER_THEN \\\n               or node.type == nodes.BinaryOperator.T_LESS_OR_EQUAL \\\n               or node.type == nodes.BinaryOperator.T_GREATER_OR_EQUAL \\\n \\\n               or node.type == nodes.BinaryOperator.T_NOT_EQUAL \\\n               or node.type == nodes.BinaryOperator.T_EQUAL \\\n \\\n               or node.type == nodes.BinaryOperator.T_CONCAT \\\n \\\n               or node.type == nodes.BinaryOperator.T_ADD \\\n               or node.type == nodes.BinaryOperator.T_SUBTRACT \\\n \\\n               or node.type == nodes.BinaryOperator.T_MULTIPLY \\\n               or node.type == nodes.BinaryOperator.T_DIVISION \\\n               or node.type == nodes.BinaryOperator.T_MOD \\\n \\\n               or node.type == nodes.BinaryOperator.T_POW\n\n    def visit_unary_operator(self, node):\n        self._set_restrictions(EXPRESSION_TYPES)\n\n        assert node.type == nodes.UnaryOperator.T_NOT \\\n            or node.type == nodes.UnaryOperator.T_LENGTH_OPERATOR \\\n            or node.type == nodes.UnaryOperator.T_MINUS \\\n            or (ljd.CURRENT_VERSION > 2.0\n                and (node.type == nodes.UnaryOperator.T_TOSTRING\n                     or node.type == nodes.UnaryOperator.T_TONUMBER))\n\n    # ##\n\n    def visit_statements_list(self, node):\n        if self.warped:\n            types = nodes.Block\n        else:\n            types = STATEMENT_TYPES\n\n        self._set_restrictions(types)\n\n    def visit_identifiers_list(self, node):\n        # HACK\n        self._set_restrictions((nodes.Identifier, nodes.Vararg))\n\n    def visit_records_list(self, node):\n        self._set_restrictions((nodes.TableRecord,\n                                nodes.ArrayRecord,\n                                nodes.FunctionCall,\n                                nodes.Vararg))\n\n        if len(node.contents) == 0:\n            return\n\n        is_array = isinstance(node.contents[0], nodes.ArrayRecord)\n\n        for i, x in enumerate(node.contents):\n            if is_array:\n                assert isinstance(x, nodes.ArrayRecord)\n            elif not isinstance(x, nodes.TableRecord):\n                assert i == (len(node.contents) - 1)\n\n    def visit_variables_list(self, node):\n        self._set_restrictions(VARIABLE_TYPES)\n\n    def visit_expressions_list(self, node):\n        self._set_restrictions(EXPRESSION_TYPES)\n\n    # ##\n\n    def visit_identifier(self, node):\n        assert node.type == nodes.Identifier.T_SLOT \\\n               or node.type == nodes.Identifier.T_BUILTIN \\\n               or node.type == nodes.Identifier.T_UPVALUE \\\n               or (node.name is not None\n                   and node.type == nodes.Identifier.T_LOCAL)\n\n        assert node.type == nodes.Identifier.T_BUILTIN or node.slot >= 0\n\n    def visit_table_element(self, node):\n        self._set_restrictions(EXPRESSION_TYPES)\n\n    def visit_function_call(self, node):\n        # Originally node.function had to be a variable type, but that's too strict - something\n        #  like `loadstring(...)()` is perfectly valid.\n\n        self._set_restrictions({\n            node.function: EXPRESSION_TYPES,\n            node.arguments: nodes.ExpressionsList\n        })\n        assert node._line is not None\n\n    # ##\n\n    def visit_if(self, node):\n        self._set_restrictions(nodes.ElseIf, {\n            node.expression: EXPRESSION_TYPES,\n            node.then_block: nodes.StatementsList,\n            node.else_block: nodes.StatementsList\n        })\n\n    def visit_elseif(self, node):\n        self._set_restrictions({\n            node.expression: EXPRESSION_TYPES,\n            node.then_block: nodes.StatementsList\n        })\n\n    # ##\n\n    def visit_block(self, node):\n        self._set_restrictions(STATEMENT_TYPES, {\n            node.warp: WARP_TYPES\n        })\n\n        assert node.index >= 0\n\n        assert 0 <= node.first_address <= node.last_address\n\n    # if false produce a statements without warps in\n    # assert node.warpins_count > 0\n\n    def visit_unconditional_warp(self, node):\n        assert node.target is not None\n\n        assert node.type == nodes.UnconditionalWarp.T_JUMP \\\n            or node.type == nodes.UnconditionalWarp.T_FLOW\n\n    def visit_conditional_warp(self, node):\n        self._set_restrictions({\n            node.condition: EXPRESSION_TYPES\n        })\n\n        assert node.true_target is not None\n        assert node.false_target is not None\n\n    # It might happen in case of if blabla or true stuff\n    # or in case of a = a and foo(a) or a type expression\n    # assert node.true_target != node.false_target\n    # assert node.true_target.index != node.false_target.index\n\n    def visit_iterator_warp(self, node):\n        assert node.body is not None\n        assert node.way_out is not None\n\n        assert node.way_out.index > node.body.index\n\n        self._set_restrictions(nodes.Block, {\n            node.variables: nodes.VariablesList,\n            node.controls: nodes.ExpressionsList\n        })\n\n    def visit_numeric_loop_warp(self, node):\n        assert node.body is not None\n        assert node.way_out is not None\n\n        self._set_restrictions(nodes.Block, {\n            node.index: nodes.Identifier,\n            node.controls: nodes.ExpressionsList\n        })\n\n    # ##\n\n    def visit_return(self, node):\n        self._set_restrictions(nodes.ExpressionsList)\n        assert node._line is not None\n\n    # ##\n\n    def visit_while(self, node):\n        self._set_restrictions({\n            node.expression: EXPRESSION_TYPES,\n            node.statements: nodes.StatementsList\n        })\n\n    def visit_repeat_until(self, node):\n        self._set_restrictions({\n            node.expression: EXPRESSION_TYPES,\n            node.statements: nodes.StatementsList\n        })\n\n    def visit_numeric_for(self, node):\n        self._set_restrictions({\n            node.expressions: nodes.ExpressionsList,\n            node.statements: nodes.StatementsList,\n            node.variable: IDENTIFIER\n        })\n\n    def visit_iterator_for(self, node):\n        self._set_restrictions({\n            node.expressions: nodes.ExpressionsList,\n            node.identifiers: nodes.VariablesList,\n            node.statements: nodes.StatementsList\n        })\n\n    # ##\n\n    def visit_constant(self, node):\n        assert node.type == nodes.Constant.T_CDATA \\\n               or node.type == nodes.Constant.T_FLOAT \\\n               or node.type == nodes.Constant.T_INTEGER \\\n               or node.type == nodes.Constant.T_STRING\n\n    def visit_primitive(self, node):\n        assert node.type == nodes.Primitive.T_NIL \\\n               or node.type == nodes.Primitive.T_TRUE \\\n               or node.type == nodes.Primitive.T_FALSE\n\n    # ##\n\n    def _visit(self, node):\n        restrictions = self.restrictions[-1]\n\n        if restrictions is not None:\n            restrictions.check(node)\n\n        # Add layer for the child node\n        self.restrictions.append(None)\n\n        traverse.Visitor._visit(self, node)\n\n        # And pop it back\n        self.restrictions.pop()", "class Visitor(traverse.Visitor):\n    def __init__(self, warped=True):\n        # Restrictions for the upmost level\n        self.restrictions = [None]\n        self.warped = warped\n\n    def _set_restrictions(self, default, specific=None):\n        if specific is None:\n            specific = {}\n        self.restrictions[-1] = TypeRestriction(default, specific)\n\n    # ##\n\n    def visit_function_definition(self, node):\n        self._set_restrictions(nodes.Block, {\n            node.arguments: nodes.IdentifiersList,\n            node.statements: nodes.StatementsList\n        })\n\n    # ##\n\n    def visit_table_constructor(self, node):\n        self._set_restrictions(nodes.RecordsList)\n\n    def visit_array_record(self, node):\n        self._set_restrictions(EXPRESSION_TYPES)\n\n    def visit_table_record(self, node):\n        self._set_restrictions(EXPRESSION_TYPES)\n\n    # ##\n\n    def visit_assignment(self, node):\n        self._set_restrictions({\n            node.destinations: nodes.VariablesList,\n            node.expressions: nodes.ExpressionsList\n        })\n\n        if not isinstance(node.destinations.contents[0], nodes.Identifier):\n            return\n\n        if node.destinations.contents[0].type != nodes.Identifier.T_LOCAL:\n            return\n\n    # Don't test type flag here\n    # ##\n\n    def visit_binary_operator(self, node):\n        self._set_restrictions(EXPRESSION_TYPES)\n\n        assert node.type == nodes.BinaryOperator.T_LOGICAL_OR \\\n               or node.type == nodes.BinaryOperator.T_LOGICAL_AND \\\n \\\n               or node.type == nodes.BinaryOperator.T_LESS_THEN \\\n               or node.type == nodes.BinaryOperator.T_GREATER_THEN \\\n               or node.type == nodes.BinaryOperator.T_LESS_OR_EQUAL \\\n               or node.type == nodes.BinaryOperator.T_GREATER_OR_EQUAL \\\n \\\n               or node.type == nodes.BinaryOperator.T_NOT_EQUAL \\\n               or node.type == nodes.BinaryOperator.T_EQUAL \\\n \\\n               or node.type == nodes.BinaryOperator.T_CONCAT \\\n \\\n               or node.type == nodes.BinaryOperator.T_ADD \\\n               or node.type == nodes.BinaryOperator.T_SUBTRACT \\\n \\\n               or node.type == nodes.BinaryOperator.T_MULTIPLY \\\n               or node.type == nodes.BinaryOperator.T_DIVISION \\\n               or node.type == nodes.BinaryOperator.T_MOD \\\n \\\n               or node.type == nodes.BinaryOperator.T_POW\n\n    def visit_unary_operator(self, node):\n        self._set_restrictions(EXPRESSION_TYPES)\n\n        assert node.type == nodes.UnaryOperator.T_NOT \\\n            or node.type == nodes.UnaryOperator.T_LENGTH_OPERATOR \\\n            or node.type == nodes.UnaryOperator.T_MINUS \\\n            or (ljd.CURRENT_VERSION > 2.0\n                and (node.type == nodes.UnaryOperator.T_TOSTRING\n                     or node.type == nodes.UnaryOperator.T_TONUMBER))\n\n    # ##\n\n    def visit_statements_list(self, node):\n        if self.warped:\n            types = nodes.Block\n        else:\n            types = STATEMENT_TYPES\n\n        self._set_restrictions(types)\n\n    def visit_identifiers_list(self, node):\n        # HACK\n        self._set_restrictions((nodes.Identifier, nodes.Vararg))\n\n    def visit_records_list(self, node):\n        self._set_restrictions((nodes.TableRecord,\n                                nodes.ArrayRecord,\n                                nodes.FunctionCall,\n                                nodes.Vararg))\n\n        if len(node.contents) == 0:\n            return\n\n        is_array = isinstance(node.contents[0], nodes.ArrayRecord)\n\n        for i, x in enumerate(node.contents):\n            if is_array:\n                assert isinstance(x, nodes.ArrayRecord)\n            elif not isinstance(x, nodes.TableRecord):\n                assert i == (len(node.contents) - 1)\n\n    def visit_variables_list(self, node):\n        self._set_restrictions(VARIABLE_TYPES)\n\n    def visit_expressions_list(self, node):\n        self._set_restrictions(EXPRESSION_TYPES)\n\n    # ##\n\n    def visit_identifier(self, node):\n        assert node.type == nodes.Identifier.T_SLOT \\\n               or node.type == nodes.Identifier.T_BUILTIN \\\n               or node.type == nodes.Identifier.T_UPVALUE \\\n               or (node.name is not None\n                   and node.type == nodes.Identifier.T_LOCAL)\n\n        assert node.type == nodes.Identifier.T_BUILTIN or node.slot >= 0\n\n    def visit_table_element(self, node):\n        self._set_restrictions(EXPRESSION_TYPES)\n\n    def visit_function_call(self, node):\n        # Originally node.function had to be a variable type, but that's too strict - something\n        #  like `loadstring(...)()` is perfectly valid.\n\n        self._set_restrictions({\n            node.function: EXPRESSION_TYPES,\n            node.arguments: nodes.ExpressionsList\n        })\n        assert node._line is not None\n\n    # ##\n\n    def visit_if(self, node):\n        self._set_restrictions(nodes.ElseIf, {\n            node.expression: EXPRESSION_TYPES,\n            node.then_block: nodes.StatementsList,\n            node.else_block: nodes.StatementsList\n        })\n\n    def visit_elseif(self, node):\n        self._set_restrictions({\n            node.expression: EXPRESSION_TYPES,\n            node.then_block: nodes.StatementsList\n        })\n\n    # ##\n\n    def visit_block(self, node):\n        self._set_restrictions(STATEMENT_TYPES, {\n            node.warp: WARP_TYPES\n        })\n\n        assert node.index >= 0\n\n        assert 0 <= node.first_address <= node.last_address\n\n    # if false produce a statements without warps in\n    # assert node.warpins_count > 0\n\n    def visit_unconditional_warp(self, node):\n        assert node.target is not None\n\n        assert node.type == nodes.UnconditionalWarp.T_JUMP \\\n            or node.type == nodes.UnconditionalWarp.T_FLOW\n\n    def visit_conditional_warp(self, node):\n        self._set_restrictions({\n            node.condition: EXPRESSION_TYPES\n        })\n\n        assert node.true_target is not None\n        assert node.false_target is not None\n\n    # It might happen in case of if blabla or true stuff\n    # or in case of a = a and foo(a) or a type expression\n    # assert node.true_target != node.false_target\n    # assert node.true_target.index != node.false_target.index\n\n    def visit_iterator_warp(self, node):\n        assert node.body is not None\n        assert node.way_out is not None\n\n        assert node.way_out.index > node.body.index\n\n        self._set_restrictions(nodes.Block, {\n            node.variables: nodes.VariablesList,\n            node.controls: nodes.ExpressionsList\n        })\n\n    def visit_numeric_loop_warp(self, node):\n        assert node.body is not None\n        assert node.way_out is not None\n\n        self._set_restrictions(nodes.Block, {\n            node.index: nodes.Identifier,\n            node.controls: nodes.ExpressionsList\n        })\n\n    # ##\n\n    def visit_return(self, node):\n        self._set_restrictions(nodes.ExpressionsList)\n        assert node._line is not None\n\n    # ##\n\n    def visit_while(self, node):\n        self._set_restrictions({\n            node.expression: EXPRESSION_TYPES,\n            node.statements: nodes.StatementsList\n        })\n\n    def visit_repeat_until(self, node):\n        self._set_restrictions({\n            node.expression: EXPRESSION_TYPES,\n            node.statements: nodes.StatementsList\n        })\n\n    def visit_numeric_for(self, node):\n        self._set_restrictions({\n            node.expressions: nodes.ExpressionsList,\n            node.statements: nodes.StatementsList,\n            node.variable: IDENTIFIER\n        })\n\n    def visit_iterator_for(self, node):\n        self._set_restrictions({\n            node.expressions: nodes.ExpressionsList,\n            node.identifiers: nodes.VariablesList,\n            node.statements: nodes.StatementsList\n        })\n\n    # ##\n\n    def visit_constant(self, node):\n        assert node.type == nodes.Constant.T_CDATA \\\n               or node.type == nodes.Constant.T_FLOAT \\\n               or node.type == nodes.Constant.T_INTEGER \\\n               or node.type == nodes.Constant.T_STRING\n\n    def visit_primitive(self, node):\n        assert node.type == nodes.Primitive.T_NIL \\\n               or node.type == nodes.Primitive.T_TRUE \\\n               or node.type == nodes.Primitive.T_FALSE\n\n    # ##\n\n    def _visit(self, node):\n        restrictions = self.restrictions[-1]\n\n        if restrictions is not None:\n            restrictions.check(node)\n\n        # Add layer for the child node\n        self.restrictions.append(None)\n\n        traverse.Visitor._visit(self, node)\n\n        # And pop it back\n        self.restrictions.pop()", "\n\ndef validate(ast, warped=True):\n    visitor = Visitor(warped)\n    traverse.traverse(visitor, ast)\n"]}
{"filename": "ljd/ast/unwarper.py", "chunked_list": ["import copy\nimport warnings\nimport sys\n\nimport ljd.ast.nodes as nodes\nimport ljd.ast.slotworks as slotworks\nimport ljd.ast.traverse as traverse\nfrom ljd.ast.helpers import *\n\nbinop = nodes.BinaryOperator", "\nbinop = nodes.BinaryOperator\n\nverbose = False\ncatch_asserts = False\nskip_eliminate = True\n\ndef exp_debug(*args):\n    if verbose:\n        print(*args, file=sys.stdout)", "\n\n# ##\n# ## REMEMBER\n# ##\n# ## Block indices are unreliable while you are mangling them!\n# ##\n# ## P.S. Probably they should not be named indices... But they ARE used as\n# ## indices during other phases. Sometimes.\n# ##", "# ## indices during other phases. Sometimes.\n# ##\n\n\nclass _StatementsCollector(traverse.Visitor):\n    def __init__(self):\n        super().__init__()\n        self.result = []\n\n    def visit_statements_list(self, node):\n        if len(node.contents) > 0 or hasattr(node, \"_decompilation_error_here\"):\n            self.result.append(node)", "\n\nclass _FunctionsCollector(traverse.Visitor):\n    def __init__(self):\n        super().__init__()\n        self.result = []\n\n    def visit_function_definition(self, node):\n        self.result.append(node)\n", "\n\ndef unwarp(node, conservative=False):\n    try:\n        _run_step(_fix_loops, node, repeat_until=False)\n        _run_step(_fix_loops, node, repeat_until=True)\n    except:\n        if catch_asserts:\n            print(\"-- Decompilation Error: _run_step(_fix_loops, node)\\n\", file=sys.stdout)\n        else:\n            raise\n\n    try:\n        _run_step(_unwarp_expressions, node)\n\n        # Under some conditions the expressions unwarper causes new assignments to become expressions themselves.\n        # Instead of doing some difficult bookkeeping, we just unwarp expressions again.\n        #\n        # An example where this is needed is an expression like x = x or { a and b }\n        #\n        # There's probably a better (read: faster) way to do this, but it works for now.\n        _run_step(_unwarp_expressions, node)\n    except:\n        if catch_asserts:\n            print(\"-- Decompilation Error: _run_step(_unwarp_expressions, node)\\n\", file=sys.stdout)\n        else:\n            raise\n\n    # There could be many negative jumps within while conditions, so\n    # filter them first\n    try:\n        _run_step(_unwarp_loops, node, repeat_until=False)\n    except:\n        if catch_asserts:\n            print(\"-- Decompilation Error: _run_step(_unwarp_loops, node, repeat_until=False)\\n\", file=sys.stdout)\n        else:\n            raise\n\n    try:\n        _run_step(_unwarp_loops, node, repeat_until=True)\n    except:\n        if catch_asserts:\n            print(\"-- Decompilation Error: _run_step(_unwarp_loops, node, repeat_until=True)\\n\", file=sys.stdout)\n        else:\n            raise\n\n    try:\n        _run_step(_unwarp_ifs, node)\n    except:\n        if catch_asserts:\n            print(\"-- Decompilation Error: _run_step(_unwarp_ifs, node)\\n\", file=sys.stdout)\n        else:\n            raise\n\n    try:\n        _run_step(_cleanup_ast, node)\n        pass\n    except:\n        if catch_asserts:\n            print(\"-- Decompilation Error: _run_step(_cleanup_ast, node)\\n\", file=sys.stdout)\n        else:\n            raise\n\n    try:\n        _glue_flows(node, conservative)\n    except:\n        if catch_asserts:\n            print(\"-- Decompilation Error: _glue_flows(node)\\n\", file=sys.stdout)\n        else:\n            raise\n\n    try:\n        _trim_redundant_returns(node)\n    except:\n        if catch_asserts:\n            print(\"-- Decompilation Error: _trim_redundant_returns(node)\\n\", file=sys.stdout)\n        else:\n            raise", "\n    # try:\n    #     slotworks.simplify_ast(node)\n    # except:\n    #     if catch_asserts:\n    #         print(\"-- Decompilation Error: ljd.ast.slotworks.simplify_ast(self.ast)\\n\", file=sys.stdout)\n    #     else:\n    #         raise\n\n\ndef _run_step(step, node, **kargs):\n    for statements in _gather_statements_lists(node):\n        statements.contents = step(statements.contents, **kargs)\n\n    # Fix block indices in case anything was moved\n    for statements in _gather_statements_lists(node):\n        for i, block in enumerate(statements.contents):\n            if block.index != i:\n                block.former_index = block.index\n                block.index = i", "\n\ndef _run_step(step, node, **kargs):\n    for statements in _gather_statements_lists(node):\n        statements.contents = step(statements.contents, **kargs)\n\n    # Fix block indices in case anything was moved\n    for statements in _gather_statements_lists(node):\n        for i, block in enumerate(statements.contents):\n            if block.index != i:\n                block.former_index = block.index\n                block.index = i", "\n\ndef _gather_statements_lists(node):\n    collector = _StatementsCollector()\n    traverse.traverse(collector, node)\n    return collector.result\n\n\ndef _glue_flows(node, conservative=False):\n    error_pending = False\n\n    for statements in _gather_statements_lists(node):\n        blocks = statements.contents\n\n        # TODO(yzg): 'Return' object has no attribute 'contents'\n        assert isinstance(blocks[-1], nodes.Return) or isinstance(blocks[-1].warp, nodes.EndWarp)\n\n        for i, block in enumerate(blocks[:-1]):\n            if hasattr(block, \"_decompilation_error_here\"):\n                error_pending = True\n            if len(block.contents) == 0:\n                continue\n            if error_pending:\n                setattr(block.contents[0], \"_decompilation_error_here\", True)\n                error_pending = False\n\n            warp = block.warp\n\n            assert _is_flow(warp)\n\n            target = warp.target\n\n            assert target == blocks[i + 1]\n\n            target.contents = block.contents + target.contents\n            block.contents = []\n\n        # Most visitors make assumptions on blocks being present. If we want to simplify the AST in multiple passes,\n        # these outer blocks cannot simply be eliminated.\n        if not conservative or not isinstance(node, nodes.FunctionDefinition):\n            if hasattr(blocks[-1], \"contents\"):  # TODO(yzg): 'Return' object has no attribute 'contents'\n                statements.contents = blocks[-1].contents", "def _glue_flows(node, conservative=False):\n    error_pending = False\n\n    for statements in _gather_statements_lists(node):\n        blocks = statements.contents\n\n        # TODO(yzg): 'Return' object has no attribute 'contents'\n        assert isinstance(blocks[-1], nodes.Return) or isinstance(blocks[-1].warp, nodes.EndWarp)\n\n        for i, block in enumerate(blocks[:-1]):\n            if hasattr(block, \"_decompilation_error_here\"):\n                error_pending = True\n            if len(block.contents) == 0:\n                continue\n            if error_pending:\n                setattr(block.contents[0], \"_decompilation_error_here\", True)\n                error_pending = False\n\n            warp = block.warp\n\n            assert _is_flow(warp)\n\n            target = warp.target\n\n            assert target == blocks[i + 1]\n\n            target.contents = block.contents + target.contents\n            block.contents = []\n\n        # Most visitors make assumptions on blocks being present. If we want to simplify the AST in multiple passes,\n        # these outer blocks cannot simply be eliminated.\n        if not conservative or not isinstance(node, nodes.FunctionDefinition):\n            if hasattr(blocks[-1], \"contents\"):  # TODO(yzg): 'Return' object has no attribute 'contents'\n                statements.contents = blocks[-1].contents", "\n\n# Delete returns on the last line of a function, when those returns don't have any arguments\ndef _trim_redundant_returns(node):\n    collector = _FunctionsCollector()\n    traverse.traverse(collector, node)\n\n    for funcdef in collector.result:\n        statements = funcdef.statements.contents\n\n        if not statements:\n            continue\n\n        # If there is an empty return block at the end of this\n        last = statements[-1]\n\n        if isinstance(last, nodes.Return):\n            if not last.returns.contents:\n                del statements[-1]", "\n\n# ##\n# ## IFs AND EXPRESSIONs PROCESSING\n# ##\n\ndef _unwarp_expressions(blocks):\n    pack = []\n    pack_set = set()\n\n    start_index = 0\n    end_index = 0\n    while start_index < len(blocks) - 1:\n        start = blocks[start_index]\n        warp = start.warp\n\n        if isinstance(warp, nodes.UnconditionalWarp):\n            if warp.type == nodes.UnconditionalWarp.T_FLOW:\n                start_index += 1\n                continue\n            elif start_index > 0 and len(start.contents) > 0:\n                # Don't continue in the 'false and false' / 'true or true' cases\n                if start_index != end_index \\\n                        or not isinstance(start.contents[-1], nodes.Assignment) \\\n                        or len(start.contents[-1].expressions.contents) == 0 \\\n                        or not isinstance(start.contents[-1].expressions.contents[-1], nodes.Primitive):\n\n                    # NOTE Don't skip the last statement (before the return), it may be an expression\n                    if start_index == end_index:\n                        end_index += 1\n\n                        if end_index < blocks[-1].index - 1:\n                            start_index += 1\n                        continue\n                    elif start_index <= end_index - 1:\n                        if start_index != end_index - 1 or end_index < blocks[-1].index - 1:\n                            start_index += 1\n                            continue\n\n        body, end, end_index = _extract_if_body(start_index, blocks, None)\n\n        if body is None:\n            raise NotImplementedError(\"GOTO statements are not supported\")\n        elif start_index > 0 and len(body) == 1 and body[0].warpins_count == 0:\n            # Unreached true/false, don't include it. This should deal with some unwanted 'and true' expressions.\n            if isinstance(body[0].contents[-1], nodes.Assignment) \\\n                    and len(body[0].contents[-1].expressions.contents) > 0 \\\n                    and isinstance(body[0].contents[-1].expressions.contents[-1], nodes.Primitive) \\\n                    and start_index + 1 < blocks[-1].index:\n                start_index += 1\n                continue\n\n        try:\n            expressions, unused = _find_expressions(start, body, end)\n        except AttributeError:\n            if catch_asserts:\n                setattr(start, \"_decompilation_error_here\", True)\n                print(\"-- WARNING: Error occurred during decompilation.\")\n                print(\"--   Code may be incomplete or incorrect.\")\n                expressions, unused = [], []\n            else:\n                raise\n\n        if len(expressions) == 0:\n            start_index += 1\n            continue\n\n        assert pack_set.isdisjoint(expressions)\n\n        expressions_set = set(expressions)\n\n        assert len(expressions_set) == len(expressions)\n\n        endest_end = _find_endest_end(expressions)\n\n        if endest_end != end:\n            end_index = blocks.index(endest_end)\n\n        if unused:\n            expression_start_index = blocks.index(expressions[0][1])\n            if expression_start_index > start_index + 1:\n                # Too big of a gap, there may be stuff we missed\n                # TODO Unsure if the check is still needed\n\n                missed = []\n                for i in range(0, len(unused)):\n                    sub_block = unused[i][0]\n                    for sub_index in range(start_index + 1, end_index - 1):\n                        if sub_block == blocks[sub_index]:\n                            missed.append(unused[i])\n\n                missed_set = set(missed)\n\n                assert len(missed_set) == len(missed)\n\n                pack += list(reversed(missed))\n                pack_set |= missed_set\n\n        pack += list(reversed(expressions))\n        pack_set |= expressions_set\n\n        start_index = end_index\n\n    return _unwarp_expressions_pack(blocks, pack)", "\n\ndef _find_endest_end(expressions):\n    endest_end = expressions[0][2]\n\n    for _, _, exp_end, *_ in expressions[1:]:\n        if exp_end.index > endest_end.index:\n            endest_end = exp_end\n\n    return endest_end", "\n\ndef _unwarp_ifs(blocks, top_end=None, topmost_end=None):\n    boundaries = []\n\n    start_index = 0\n\n    while start_index < len(blocks) - 1:\n        start = blocks[start_index]\n        warp = start.warp\n\n        abort_loop = False\n        if isinstance(warp, nodes.UnconditionalWarp):\n            if warp.type == nodes.UnconditionalWarp.T_FLOW:\n                start_index += 1\n                continue\n\n            # Remove unreachable True assignments that are the result of expressions in assignments\n            while True:\n                if len(start.contents) != 1 \\\n                        or not isinstance(start.contents[0], nodes.Assignment) \\\n                        or len(start.contents[0].destinations.contents) != 1 \\\n                        or start_index >= len(blocks) - 1:\n                    break\n\n                expression = start.contents[0].expressions.contents[0]\n                if not isinstance(expression, nodes.Primitive) or expression.type != nodes.Primitive.T_FALSE:\n                    break\n\n                next_block = blocks[start_index + 1]\n                if next_block.warpins_count != 0:\n                    break\n\n                if len(next_block.contents) != 1:\n                    break\n\n                expression = next_block.contents[0].expressions.contents[0]\n                if not isinstance(expression, nodes.Primitive) or expression.type != nodes.Primitive.T_TRUE:\n                    break\n\n                abort_loop = True\n                break\n\n        body, end, end_index = _extract_if_body(start_index, blocks, topmost_end)\n\n        if body is None:\n            if catch_asserts:\n                setattr(start, \"_decompilation_error_here\", True)\n                print(\"-- WARNING: Error occurred during decompilation.\")\n                # print(\"--   GOTO statements are not supported\")\n                print(\"--   Code may be incomplete or incorrect.\")\n                _set_flow_to(start, blocks[start_index + 1])\n                start_index += 1\n                continue\n            else:\n                raise NotImplementedError(\"GOTO statements are not\"\n                                          \" supported\")\n\n        is_end = isinstance(body[-1].warp, nodes.EndWarp)\n\n        # Check for empty else blocks and skip them\n        if is_end and len(body) == 1 and not body[0].contents \\\n                and _get_target(start.warp, True) == _get_target(body[0].warp, True):\n            abort_loop = True\n\n        if not abort_loop:\n            try:\n                _unwarp_if_statement(start, body, end, end)\n            except (AssertionError, IndexError):\n                if catch_asserts:\n                    setattr(start, \"_decompilation_error_here\", True)\n                    print(\"-- WARNING: Error occurred during decompilation.\")\n                    print(\"--   Code may be incomplete or incorrect.\")\n                else:\n                    raise\n\n        if is_end:\n            _set_end(start)\n        else:\n            _set_flow_to(start, end)\n\n        boundaries.append((start_index, end_index - 1))\n\n        start_index = end_index\n\n    return _remove_processed_blocks(blocks, boundaries)", "\n\ndef _extract_if_body(start_index, blocks, topmost_end):\n    body = start_index > 0 and blocks[start_index:] or blocks\n    end = _find_branching_end(body, topmost_end)\n\n    try:\n        end_index = blocks.index(end)\n    except ValueError:\n        if end == topmost_end:\n            end_index = len(blocks)\n        else:\n            return None, None, None\n\n    body = blocks[start_index + 1:end_index]\n\n    return body, end, end_index", "\n\ndef _unwarp_expressions_pack(blocks, pack):\n    replacements = {}\n\n    for i, (block, start, end, slot, slot_type, slot_ref, needs_validation) in enumerate(reversed(pack)):\n        end = replacements.get(end, end)\n\n        start_index = blocks.index(start)\n        end_index = blocks.index(end)\n\n        is_special = False\n        skip_expression = False\n        before = blocks[:start_index]\n        body = blocks[start_index + 1:end_index]\n\n        if block == start and isinstance(block.warp, nodes.UnconditionalWarp):\n            skip_expression = True\n\n        if needs_validation:\n            # Count the number of assignments. We want to skip long chains.\n            num_assignments = 0\n            for b in body:\n                for c in b.contents:\n                    if not isinstance(c, nodes.Assignment):\n                        continue\n\n                    if len(c.destinations.contents) != 1:\n                        continue\n\n                    if len(c.expressions.contents) != 1:\n                        continue\n\n                    destination = c.destinations.contents[0]\n                    if is_equal(destination, slot_ref):\n                        num_assignments += 1\n\n            skip_expression = num_assignments > 2\n\n        if needs_validation and not skip_expression and isinstance(start.warp, nodes.ConditionalWarp):\n            # Make sure the special case should actually be an expression. These special cases have\n            # no operations in their true warp, but be conservative and skip nested expressions\n            for b in filter(lambda x: isinstance(x.warp, nodes.ConditionalWarp), [start] + body):\n                if len(b.warp.true_target.contents) == 1 \\\n                        and isinstance(b.warp.true_target.contents[0], nodes.NoOp) \\\n                        and isinstance(b.warp.true_target.warp, nodes.UnconditionalWarp):\n\n                    is_special = True\n                    if b != start or (i > 0 and any(w != blocks[i - 1].warp for w in _find_warps_to(before, b))):\n                        skip_expression = True\n                        break\n\n        if not skip_expression:\n            # Check if there's any other warpins to the expressions body. If so,\n            # then this subexpression will be taken care of later on\n            for body_block in body:\n                if _find_warps_to(before, body_block):\n                    skip_expression = True\n                    break\n\n        if skip_expression:\n            continue\n\n        try:\n            # Find the subexpression, and place it into the first block. After this\n            #  point, the body of the subexpression is no longer needed.\n            _unwarp_logical_expression(start, end, body)\n        except (AssertionError, IndexError):\n            if catch_asserts:\n                setattr(start, \"_decompilation_error_here\", True)\n                print(\"-- WARNING: Error occurred during decompilation.\")\n                print(\"--   Code may be incomplete or incorrect.\")\n            else:\n                raise\n\n        # Make sure the expression is equivalent -- check special case, it has to end with the destination\n        if is_special:\n            expression = start.contents[-1]\n\n            skip_expression = True\n            while True:\n                if not isinstance(expression, nodes.Assignment):\n                    break\n\n                if len(expression.destinations.contents) != 1:\n                    break\n\n                if len(expression.expressions.contents) != 1:\n                    break\n\n                destination = expression.destinations.contents[0]\n                value = expression.expressions.contents[0]\n\n                if isinstance(value, nodes.BinaryOperator):\n                    value = value.right\n\n                if not is_equal(value, destination) and \\\n                        (not isinstance(value, nodes.Primitive) or value.type == nodes.Primitive.T_FALSE):\n                    break\n\n                skip_expression = False\n                break\n\n            if skip_expression:\n                del start.contents[-1]\n                continue\n\n\n        # Note that from here on, this function has basically been rewritten\n        #  in order to support subexpressions in subexpressions - eg:\n        #\n        # a = a and a[c or d]\n        #\n        # and this affected function calls too:\n        #\n        # a = a and a(c or d)\n        #\n        # These were generating results such as:\n        #\n        # if a then\n        #  slot0 = a[c or d]\n        # end\n        # a = slot0\n        #\n        # (Actually this isn't it directly - it's to work with a modification\n        #   made to _find_expressions, but this is where most of the changes occur)\n\n        # Now the subexpression is gone, the start should warp to the block\n        #  directly after the end of the subexpression, which is where the flow\n        #  would have ended up anyway.\n        _set_flow_to(start, end)\n\n        # We no longer need the body, but there may still be some slots we need to eliminate before we lose\n        # the definitions. This works because the expressions we found earlier still have a reference to\n        # the nodes these body blocks. Create a temporary block to take care of this.\n        if end_index - start_index > 2:\n            # TODO: Avoid using a temporary block and process \"unused\" slots as well\n            tmp_block = nodes.Block()\n            first_block = blocks[start_index + 1]\n            last_block = blocks[end_index - 1]\n            tmp_block.first_address = first_block.first_address\n            tmp_block.last_address = last_block.last_address\n            tmp_block.index = first_block.index\n            tmp_block.warpins_count = first_block.warpins_count\n            tmp_block.warp = last_block.warp\n            for j in range(start_index + 1, end_index):\n                tmp_block.contents += blocks[j].contents\n            slotworks.eliminate_temporary(tmp_block, False)\n\n        # Leave the starting block in for now, but delete the rest of\n        #  the body since we need to do so anyway and not doing so now\n        #  will result in it ending up in end_warps\n        del blocks[start_index + 1:end_index]\n\n        # Here, we have to act in two different potential ways:\n        #  - If there is an if condition that skips this subexpression and jumps straight to end, we\n        #     should leave the expression in start, and leave end alone\n        #  - If nothing else is referring to end, we should move the subexpression to it and delete the\n        #     start node, compacting things down to ensure it gets used correctly later, in an enclosing\n        #     subexpression.\n        #\n        # To do this, look for any nodes warping to the end block\n        end_warps = _find_warps_to(blocks, end)\n\n        # This should contain start, at the very least\n        assert start in end_warps\n\n        if start_index > 0:\n            preceding_block = blocks[start_index - 1]\n            if hasattr(preceding_block, \"warp\") \\\n                    and isinstance(preceding_block.warp, nodes.UnconditionalWarp):\n                target_index = blocks.index(_get_target(preceding_block.warp))\n\n                if target_index in range(start_index + 1, end_index - 1):\n                    continue\n\n        if len(end_warps) == 1:\n            # Nothing (aside from the start block) is referring to the end block, thus it's safe\n            #  to merge them.\n\n            end.contents = start.contents + end.contents\n            start.contents = []\n\n            del blocks[start_index]\n\n            _replace_targets(blocks, start, end)\n\n            replacements[start] = end\n\n            slotworks.eliminate_temporary(end, False)\n            slotworks.simplify_ast(end, dirty_callback=slotworks.eliminate_temporary)\n        else:\n            slotworks.eliminate_temporary(start, False)\n            slotworks.simplify_ast(end, dirty_callback=slotworks.eliminate_temporary)\n\n    return blocks", "\n\ndef _split_by_slot_use(statements, min_i, warp, slot):\n    known_slots = {slot}\n\n    split_i = min_i\n\n    for i, statement in enumerate(statements):\n        if isinstance(statement, nodes.Assignment):\n            sets = _extract_destination_slots(statement)\n\n            if i < min_i:\n                known_slots |= sets\n            else:\n                known_slots -= sets\n\n            if len(known_slots) == 0:\n                break\n\n        split_i = i + 1\n\n    if split_i < len(statements):\n        return split_i\n\n    if isinstance(warp, nodes.ConditionalWarp):\n        known_slots -= _gather_slots(warp)\n\n        if len(known_slots) == 0:\n            split_i += 1\n\n    return split_i", "\n\ndef _extract_destination_slots(statement):\n    sets = set()\n\n    for node in statement.destinations.contents:\n        if not isinstance(node, nodes.Identifier):\n            continue\n\n        if node.type == nodes.Identifier.T_SLOT:\n            sets.add(node.slot)\n\n    return sets", "\n\ndef _gather_slots(node):\n    class Collector(traverse.Visitor):\n        def __init__(self):\n            super().__init__()\n            self.slots = set()\n\n        def visit_identifier(self, visited_node):\n            if visited_node.type == nodes.Identifier.T_SLOT:\n                self.slots.add(visited_node.slot)\n\n    collector = Collector()\n\n    traverse.traverse(collector, node)\n\n    return collector.slots", "\n\ndef _find_expressions(start, body, end, level=0, known_blocks=None):\n    block = None\n    known_blocks = known_blocks or set()\n    known_blocks.add(start)\n\n    def _add_warps_to_known_blocks(node):\n        refs = None\n        warp = node.warp\n        if isinstance(warp, nodes.ConditionalWarp):\n            refs = [warp.true_target, warp.false_target]\n        elif isinstance(warp, nodes.UnconditionalWarp):\n            refs = [warp.target]\n\n        for ref in refs or []:\n            if not ref: continue\n            known_blocks.add(ref)\n\n    _add_warps_to_known_blocks(start)\n\n    # Explicitly allow the local a = x ~= \"b\" case\n    slot, slot_type, slot_ref = _get_simple_local_assignment_slot(start, body, end)\n\n    slot_assignments = []\n    expressions = []\n    unused = []\n\n    # We have something at the end, but not the true/false?\n\n    i = 0\n    extbody = [start] + body\n\n    is_local = False\n    sure_expression = None\n    needs_validation = False\n\n    # Note the subexpression processing here has been rewritten from earlier versions - there\n    #  used to be a problem where the following code:\n    #\n    # if a then\n    #  if b then\n    #   c()\n    #  end\n    #  d = e or f -- note, you need two of these\n    #  g = h or i\n    # end\n    #\n    # Would come out as the following:\n    #\n    # if a then\n    #  if b then\n    #   c()\n    #   d = e or f\n    #   g = h or i\n    #  end\n    # end\n    #\n    # It seems the processing wasn't taking note of the second (index=1) block, and\n    #  this led to everything getting merged together. In the end it became quicker to\n    #  rewrite the subexpression code, and avoid processing blocks already done so as part\n    #  of the subexpression checks. So far I have not seen any issues with this, but if you find\n    #  any (which isn't unlikely), please report it.\n    #\n    # Rewriting it also had the nice side-effect of cleaning up the code somewhat, since it's\n    #  significantly shorter, easier to read readable, and should in fact run faster too.\n\n    while i < len(extbody):\n        current_i = i\n        i += 1\n        block = extbody[current_i]\n\n        if block in known_blocks:\n            _add_warps_to_known_blocks(block)\n\n        subs = []\n        subs_unused = []\n\n        # Look for a self-contained conditional, and process that, then skip\n        #  over it.\n        branch_end = _find_branching_end(extbody[current_i:], None)\n        if branch_end and branch_end in extbody:\n            be_index = extbody.index(branch_end)\n            i = be_index  # NOTE This misses things, so re-check it later\n\n            body = extbody[current_i+1:be_index]\n            subs, subs_unused = _find_expressions(block, body, branch_end, level + 1, known_blocks)\n\n        if len(subs) != 0:\n            endest_end = _find_endest_end(subs)\n            new_i = extbody.index(endest_end)\n\n            # Loop? No way!\n            assert new_i > current_i\n\n            # It should end with a conditional warp if that's\n            # really a subexpression-as-operand\n            end_warp = endest_end.warp\n\n            # If any of the subexpressions are put into local variables, then this\n            #  must be an if block, rather than an expression.\n            for _, sub_start, sub_end, sub_slot, sub_slot_type, *_ in subs:\n                if sub_slot_type == nodes.Identifier.T_LOCAL:\n                    return expressions, unused\n\n                # Search the body of the subexpression - if it contains anything other\n                # than assignments, then it must be an if..end rather than an expression\n                #\n                # Here's an example of something that fails to decompile without this:\n                #\n                # local myvar = nil\n                # if test_var then\n                #         unrelated_func()\n                #         myvar = (myvar or f()) + var\n                # else\n                #         unrelated_func()\n                #         myvar = (myvar or f()) + var\n                # end\n\n                # Fetch the subexpression body\n                sub_start_i = extbody.index(sub_start)\n                sub_end_i = extbody.index(sub_end)\n                sub_body = extbody[sub_start_i:sub_end_i]\n\n                # And check it\n                for sub_block in sub_body:\n                    for item in sub_block.contents:\n                        if not isinstance(item, nodes.Assignment):\n                            return expressions, subs\n\n            # TODO This can skip expressions in the current blocks body. Solved by a second call for now.\n\n            expressions = subs + expressions\n            i = new_i\n            continue\n        elif subs_unused:\n            unused = subs_unused + unused\n        elif i > current_i + 1:\n            # We may not have checked all sub expressions\n            i = current_i + 1\n\n        if isinstance(block.warp, nodes.ConditionalWarp):\n            condition = block.warp.condition\n\n            is_end = block.warp.false_target == end\n            is_binop = isinstance(condition, nodes.BinaryOperator)\n            block_slot = getattr(block.warp, \"_slot\", slot)\n\n            if is_end:\n                if is_binop:\n                    return expressions, unused\n                elif slot < 0 <= block_slot:\n                    slot = block_slot\n                    slot_type = nodes.Identifier.T_SLOT\n                    slot_ref = block\n\n                    if sure_expression is None:\n                        sure_expression = True\n                elif slot != block_slot:\n                    # TODO: We need to check the rest, but it's too eager\n                    sure_expression = False\n                    continue\n                elif sure_expression is None:\n                    sure_expression = True\n            elif len(block.warp.true_target.contents) == 1:\n                skip = False\n\n                # Check for a special case 'x = y and z' that has a no-op condition in the true case\n                if isinstance(block.warp.true_target.contents[0], nodes.NoOp) \\\n                        and isinstance(block.warp.true_target.warp, nodes.UnconditionalWarp):\n                    sure_expression = True\n                    needs_validation = True\n                    skip = True\n                if skip:\n                    slot_ref = block\n                    i += 1\n                    continue\n\n        elif isinstance(block.warp, nodes.UnconditionalWarp):\n            if block == start and len(block.contents) == 0:\n                return [], expressions\n\n        if len(block.contents) == 0:\n            continue\n\n        if block != start and len(block.contents) > 1:\n            return expressions, unused\n\n        assignment = block.contents[-1]\n\n        if not isinstance(assignment, nodes.Assignment):\n            if block == start:\n                continue\n\n            if isinstance(assignment, nodes.NoOp):\n                if _get_target(block.warp, True) != end:\n                    continue\n\n            return expressions, unused\n\n        destinations = assignment.destinations.contents\n\n        if len(destinations) != 1:\n            if block == start:\n                continue\n\n            return expressions, unused\n\n        if block.warpins_count == 0 and level > 0:\n            return expressions, unused\n\n        dst = destinations[0]\n\n        if not isinstance(dst, nodes.Identifier):\n            if block == start:\n                continue\n\n            return expressions, unused\n\n        if isinstance(block.warp, nodes.ConditionalWarp):\n            if block == start:\n                continue\n\n            return expressions, unused\n\n        if not sure_expression and sure_expression is not None:\n            return expressions, unused\n\n        if slot < 0:\n            # If all encounters are locals, which means\n            # that the first encounter is a local\n            if dst.type == nodes.Identifier.T_LOCAL:\n                is_local = True\n            elif dst.type == nodes.Identifier.T_UPVALUE:\n                return [], expressions\n\n            slot_assignments.append(assignment)\n\n            slot = dst.slot\n            slot_type = dst.type\n            slot_ref = dst\n        elif slot == dst.slot:\n            slot_assignments.append(assignment)\n\n            slot_type = dst.type\n            slot_ref = dst\n\n            if dst.type == nodes.Identifier.T_UPVALUE:\n                return [], expressions\n        else:\n            assert block != start\n\n            return [], expressions\n\n    if slot < 0:\n        return [], expressions\n\n    true, _false, body = _get_terminators(body)\n\n    if sure_expression is None:\n        if true is not None:\n            sure_expression = True\n\n        if len(expressions) > 0 and block in known_blocks:\n            matching_end_warp = False\n            for _, _, exp_end, *_ in expressions:\n                if exp_end.warp == block.warp:\n                    matching_end_warp = True\n                    break\n            if not matching_end_warp:\n                needs_validation = True  # may be better off as a regular if statement\n                sure_expression = True\n\n    if not sure_expression and is_local:\n        allow_through = False\n\n        # allow constants\n        if len(slot_assignments) == 2 and (start.index == 0 or start.contents):\n            value = slot_assignments[-2].expressions.contents[0]\n            if isinstance(value, nodes.Constant) \\\n                    or (isinstance(value, nodes.Primitive) and value.type == nodes.Primitive.T_TRUE):\n\n                allow_through = True\n                # Constant assignment, but don't make it an expression if the previous assignment assigns the same slot\n                if start.contents \\\n                        and isinstance(start.contents[-1], nodes.Assignment) \\\n                        and len(assignment.expressions.contents) == 1:\n                    assignment = start.contents[-1]\n                    expression = assignment.expressions.contents[0]\n                    if isinstance(expression, nodes.Primitive) and expression.type == nodes.Primitive.T_NIL:\n                        for dst in assignment.destinations.contents:\n                            if isinstance(dst, nodes.Identifier) and dst.slot == slot:\n                                allow_through = False\n                                break\n\n        if not allow_through:\n            return expressions, unused\n\n    # TODO Actually prevent bad blocks from being part of the body instead of trying to eliminate it here\n    if not sure_expression and block not in known_blocks and \\\n            (isinstance(end, nodes.EndWarp) or extbody.index(block) < len(extbody) - 1):\n        return expressions, unused\n\n    return expressions + [(block, start, end, slot, slot_type, slot_ref, needs_validation)], unused", "\n\ndef _get_simple_local_assignment_slot(start, body, end):\n    if len(body) != 2:\n        return -1, None, None\n\n    true, _false, body = _get_terminators(body)\n\n    if true is None:\n        return -1, None, None\n    else:\n        slot = true.contents[0].destinations.contents[0]\n        if not isinstance(slot, nodes.GetItem):\n            return slot.slot, slot.type, slot\n        elif isinstance(slot.table, nodes.Identifier):\n            return slot.table.slot, slot.table.type, slot.table\n        else:\n            return -1, None, None", "\n\ndef _find_expression_slot(body):\n    slot = None\n\n    for block in reversed(body):\n        if len(block.contents) == 0: # TODO Why was this != 1? Does it always need to be just one?\n            continue\n\n        slot = block.contents[-1].destinations.contents[0]\n        break\n\n    return slot", "\n\ndef _unwarp_logical_expression(start, end, body):\n    slot = _find_expression_slot(body)\n\n    if slot is None:\n        warnings.warn('slot is None!')\n        return\n\n    true, false, body = _get_terminators(body)\n\n    expression = _compile_expression([start] + (body or []), end, true, false)\n\n    dst = copy.deepcopy(slot)\n\n    assignment = nodes.Assignment()\n    assignment.destinations.contents.append(dst)\n    assignment.expressions.contents.append(expression)\n\n    start.contents.append(assignment)", "\n\ndef _compile_expression(body, end, true, false):\n    parts = _unwarp_expression(body, end, true, false)\n\n    if len(parts) < 3:\n        assert len(parts) == 1\n        return parts[0]\n\n    explicit_parts = _make_explicit_subexpressions(parts)\n    expr = _assemble_expression(explicit_parts)\n    expr = _optimise_expression(expr)\n    return expr", "\n\n# Rearrange the contents of the expression (without changing it's meaning), to make it easier for the writer\n#  to write without adding unnecessary braces. To do that, ensure that chains of operators appear in the\n#  correct direction - eg, make (1 + (2 + 3)) into ((1 + 2) + 3). This can't be done on non-commutative\n#  operators.\ndef _optimise_expression(expr, skip_type=None):\n    if not isinstance(expr, nodes.BinaryOperator):\n        return expr\n\n    type = expr.type\n\n    expr.left = _optimise_expression(expr.left, skip_type=type)\n    expr.right = _optimise_expression(expr.right, skip_type=type)\n\n    # Don't reorganise children of a top-level node that's already being reorganised\n    if skip_type == expr.type:\n        return expr\n\n    # If this operator isn't commutative, we can't rearrange anything for it\n    if not expr.is_commutative():\n        return expr\n\n    # While == and != are commutative, we can't swap them around like this\n    if nodes.BinaryOperator.T_NOT_EQUAL <= expr.type <= nodes.BinaryOperator.T_EQUAL:\n        return expr\n\n    # Don't bother handling right-associative operators for now, since that currently only\n    #  includes the exponent operator, which isn't commutative.\n    if expr.is_right_associative():\n        return expr\n\n    children = _find_binary_operator_children(expr, type)\n\n    expr = children.pop(0)\n    for op in children:\n        next = nodes.BinaryOperator()\n        next.type = type\n        next.left = expr\n        next.right = op\n        expr = next\n\n    return expr", "\n\ndef _find_binary_operator_children(op, type):\n    if not isinstance(op, nodes.BinaryOperator):\n        return [op]\n\n    if op.type != type:\n        return [op]\n\n    return _find_binary_operator_children(op.left, type) + _find_binary_operator_children(op.right, type)", "\n\n#\n# The logical expressions:\n#\n# There are terminators: a true, a false and an end\n#\n# For an if case the true will be a \"then\" clause and the false - an \"else\" or\n# \"after-the-if\" clause. The end is required for a single-variable (unary)\n# components and is only used at during topmost phase.", "# \"after-the-if\" clause. The end is required for a single-variable (unary)\n# components and is only used at during topmost phase.\n#\n# The last block in expression is always \"double terminal\" - both ends are\n# pointing at terminators. It's rather useless so we just append it's condition\n# (inverted if needed - it's easy to see if true end targets the false\n# terminator) at the end of processing.\n#\n# Then we need to pack all other blocks into subexpressions. Subexpressions\n# always end with a _terminal block_, i.e. the block which warp points to a", "# Then we need to pack all other blocks into subexpressions. Subexpressions\n# always end with a _terminal block_, i.e. the block which warp points to a\n# terminator. Idea is that we can guess the operator only right of a\n# terminal block, because we can check if the block's warp condition is\n# inverted or not.\n#\n# If that's an \"OR\" clause then it will jump out of the current expression if\n# the condition is true, so the condition is inverted and the false branch is\n# pointing at the way out (at the TRUE terminator - because the result of the\n# expression level will be true). (because in the bytecode there", "# pointing at the way out (at the TRUE terminator - because the result of the\n# expression level will be true). (because in the bytecode there\n# is only one JMP, so a ConditionalWarp's true branch is actually a fake and\n# always points to the next block - in the bytecode a \"positive\" jump\n# will be represented by a normal negative jump with inverted condition).\n#\n# Otherwise, if that's an \"AND\" clause then it will jump out of the current\n# expression level if a condition is false, so the condition is not inverted\n# and a false branch points to the false.\n#", "# and a false branch points to the false.\n#\n# This way we can understand which operators go just right of terminal blocks.\n# Everything in-between these block is considered a subexpression. And just\n# because we don't know where exactly the subexpression ends we are using\n# greedy approach and trying to pack into a subexpression as much blocks as\n# possible, including any terminal blocks pointing at the same terminator\n# with the same inversion status (that is - we are always using the\n# rightmost block if there are consequitive similar terminal blocks, ignoring\n# all the blocks to the left).", "# rightmost block if there are consequitive similar terminal blocks, ignoring\n# all the blocks to the left).\n#\n# Then comes the trick: the subexpression is a component of this expression and\n# we know the operator to the right of it. We can guess now what will\n# be evaluated if the subexpression evaluates to \"false\" and what - if it's\n# \"true\". If the operator is \"AND\" then the subexpression failure will cause\n# the expression failure too, i.e. the \"FALSE\" target remains the same and the\n# true terminator is set to the next block (after the \"AND\").\n#", "# true terminator is set to the next block (after the \"AND\").\n#\n# If the operator is \"OR\" the the subexpression success will cause the success\n# of the expression, so the \"TRUE\" target remains the same, but the false\n# target is set to the next block (after the \"OR\").\n#\n# Now we have a subexpression and both TRUE and FALSE terminators for it.\n# Recurse and repeat.\n#\ndef _unwarp_expression(body, end, true, false):\n    parts = []\n\n    if true is not None:\n        terminator_index = min(true.index, false.index)\n\n        if end is not None:\n            terminator_index = min(end.index, terminator_index)\n    else:\n        assert end is not None\n\n        terminator_index = end.index\n\n    terminators = [true, false, end]\n\n    subexpression_start = 0\n\n    i = 0\n    while i < len(body) - 1:\n        block = body[i]\n        warp = block.warp\n\n        target = _get_target(warp)\n\n        #\n        # A chance for\n        # (foo and (bar and y or z)) or x\n        # type expressions, because the first \"foo and ... )) or\" part\n        # will be broken by the \"or z))\" part in the code below.\n        #\n        # So we are going to intercept subexpressions by it's start\n        # instead of an end, but only if we are already at the\n        # subexpression start (so nothing formally changes, but creates\n        # a bit more correct execution order)\n        #\n        if target.index < terminator_index:\n            if i != subexpression_start:\n                i += 1\n                continue\n\n            target_index = body.index(target)\n            last_block = body[target_index - 1]\n\n            last_block_target = _get_target(last_block.warp)\n\n            if last_block_target.index < terminator_index:\n                i += 1\n                continue\n\n            assert last_block_target in terminators, '%s not in terminators' % last_block_target\n\n            subexpression = body[i:target_index]\n        else:\n            # assert target in terminators\n\n            while i < len(body) - 2:\n                next_block = body[i + 1]\n                next_target = _get_target(next_block.warp)\n\n                if next_target != target:\n                    break\n\n                next_inv = _is_inverted(next_block.warp, true, end)\n\n                this_inv = _is_inverted(warp, true, end)\n\n                # Special hack for unary expressions (x, not x)...\n                if next_inv != this_inv:\n                    break\n\n                warp = next_block.warp\n                i += 1\n\n            subexpression = body[subexpression_start:i + 1]\n\n        last_block = subexpression[-1]\n        last_block_index = body.index(last_block)\n\n        next_block = body[last_block_index + 1]\n\n        operator = _get_operator(last_block, true, end)\n\n        new_subexpression = _compile_subexpression(subexpression, operator,\n                                               last_block, next_block,\n                                               true, end)\n\n        if new_subexpression:\n            parts.append(new_subexpression)\n            parts.append(operator)\n\n        i = last_block_index + 1\n        subexpression_start = i\n\n    last = body[-1]\n\n    if isinstance(last.warp, nodes.ConditionalWarp):\n        if _is_inverted(last.warp, true, end):\n            last = _invert(last.warp.condition)\n        else:\n            last = last.warp.condition\n\n        parts.append(last)\n    else:\n        assert isinstance(last.warp, (nodes.EndWarp,\n                                      nodes.UnconditionalWarp))\n\n        src = _get_last_assignment_source(last)\n\n        if src is None:\n\n            special = None\n            if len(last.contents) == 1 and isinstance(last.contents[0], nodes.NoOp):\n                # Check for a special A = B and A case\n                if false.warpins_count == 0 and len(true.contents) == 1:\n                    special = false\n                elif true.warpins_count == 0 and len(false.contents) == 1:\n                    special = true\n\n            if special and special.contents:\n                # Special case: use destination\n                assignment = special.contents[-1]\n                src = assignment.destinations.contents[0]\n            else:\n                src = nodes.Primitive()\n\n                if last.warp.target == true:\n                    src.type = nodes.Primitive.T_TRUE\n                else:\n                    src.type = nodes.Primitive.T_FALSE\n\n        parts.append(src)\n\n    return parts", "#\ndef _unwarp_expression(body, end, true, false):\n    parts = []\n\n    if true is not None:\n        terminator_index = min(true.index, false.index)\n\n        if end is not None:\n            terminator_index = min(end.index, terminator_index)\n    else:\n        assert end is not None\n\n        terminator_index = end.index\n\n    terminators = [true, false, end]\n\n    subexpression_start = 0\n\n    i = 0\n    while i < len(body) - 1:\n        block = body[i]\n        warp = block.warp\n\n        target = _get_target(warp)\n\n        #\n        # A chance for\n        # (foo and (bar and y or z)) or x\n        # type expressions, because the first \"foo and ... )) or\" part\n        # will be broken by the \"or z))\" part in the code below.\n        #\n        # So we are going to intercept subexpressions by it's start\n        # instead of an end, but only if we are already at the\n        # subexpression start (so nothing formally changes, but creates\n        # a bit more correct execution order)\n        #\n        if target.index < terminator_index:\n            if i != subexpression_start:\n                i += 1\n                continue\n\n            target_index = body.index(target)\n            last_block = body[target_index - 1]\n\n            last_block_target = _get_target(last_block.warp)\n\n            if last_block_target.index < terminator_index:\n                i += 1\n                continue\n\n            assert last_block_target in terminators, '%s not in terminators' % last_block_target\n\n            subexpression = body[i:target_index]\n        else:\n            # assert target in terminators\n\n            while i < len(body) - 2:\n                next_block = body[i + 1]\n                next_target = _get_target(next_block.warp)\n\n                if next_target != target:\n                    break\n\n                next_inv = _is_inverted(next_block.warp, true, end)\n\n                this_inv = _is_inverted(warp, true, end)\n\n                # Special hack for unary expressions (x, not x)...\n                if next_inv != this_inv:\n                    break\n\n                warp = next_block.warp\n                i += 1\n\n            subexpression = body[subexpression_start:i + 1]\n\n        last_block = subexpression[-1]\n        last_block_index = body.index(last_block)\n\n        next_block = body[last_block_index + 1]\n\n        operator = _get_operator(last_block, true, end)\n\n        new_subexpression = _compile_subexpression(subexpression, operator,\n                                               last_block, next_block,\n                                               true, end)\n\n        if new_subexpression:\n            parts.append(new_subexpression)\n            parts.append(operator)\n\n        i = last_block_index + 1\n        subexpression_start = i\n\n    last = body[-1]\n\n    if isinstance(last.warp, nodes.ConditionalWarp):\n        if _is_inverted(last.warp, true, end):\n            last = _invert(last.warp.condition)\n        else:\n            last = last.warp.condition\n\n        parts.append(last)\n    else:\n        assert isinstance(last.warp, (nodes.EndWarp,\n                                      nodes.UnconditionalWarp))\n\n        src = _get_last_assignment_source(last)\n\n        if src is None:\n\n            special = None\n            if len(last.contents) == 1 and isinstance(last.contents[0], nodes.NoOp):\n                # Check for a special A = B and A case\n                if false.warpins_count == 0 and len(true.contents) == 1:\n                    special = false\n                elif true.warpins_count == 0 and len(false.contents) == 1:\n                    special = true\n\n            if special and special.contents:\n                # Special case: use destination\n                assignment = special.contents[-1]\n                src = assignment.destinations.contents[0]\n            else:\n                src = nodes.Primitive()\n\n                if last.warp.target == true:\n                    src.type = nodes.Primitive.T_TRUE\n                else:\n                    src.type = nodes.Primitive.T_FALSE\n\n        parts.append(src)\n\n    return parts", "\n\ndef _get_target(warp, allow_end=False):\n    if isinstance(warp, nodes.ConditionalWarp):\n        return warp.false_target\n    else:\n        if allow_end and isinstance(warp, nodes.EndWarp):\n            return getattr(warp, \"_target\", None)\n\n        assert isinstance(warp, nodes.UnconditionalWarp)\n        return warp.target", "\n\ndef _set_target(warp, target):\n    if isinstance(warp, nodes.ConditionalWarp):\n        warp.false_target = target\n    else:\n        assert isinstance(warp, nodes.UnconditionalWarp)\n        warp.target = target\n\n\ndef _get_operator(block, true, end):\n    if isinstance(block.warp, nodes.UnconditionalWarp):\n        src = _get_last_assignment_source(block)\n\n        if isinstance(src, nodes.Constant):\n            is_true = True\n        elif isinstance(src, nodes.BinaryOperator):\n            is_true = True\n        elif isinstance(src, nodes.Primitive):\n            is_true = src.type == nodes.Primitive.T_TRUE\n        elif isinstance(src, nodes.Identifier):\n            is_true = True\n        # walterr: apparently unnecessary?\n        # elif isinstance(src, nodes.NoOp):\n        #     is_true = block.warp.target == end\n        else:\n            # assert src is None\n\n            is_true = block.warp.target == true\n\n        if is_true:\n            return binop.T_LOGICAL_OR\n        else:\n            return binop.T_LOGICAL_AND\n    else:\n        is_inverted = _is_inverted(block.warp, true, end)\n\n        if is_inverted:\n            return binop.T_LOGICAL_OR\n        else:\n            return binop.T_LOGICAL_AND", "\n\ndef _get_operator(block, true, end):\n    if isinstance(block.warp, nodes.UnconditionalWarp):\n        src = _get_last_assignment_source(block)\n\n        if isinstance(src, nodes.Constant):\n            is_true = True\n        elif isinstance(src, nodes.BinaryOperator):\n            is_true = True\n        elif isinstance(src, nodes.Primitive):\n            is_true = src.type == nodes.Primitive.T_TRUE\n        elif isinstance(src, nodes.Identifier):\n            is_true = True\n        # walterr: apparently unnecessary?\n        # elif isinstance(src, nodes.NoOp):\n        #     is_true = block.warp.target == end\n        else:\n            # assert src is None\n\n            is_true = block.warp.target == true\n\n        if is_true:\n            return binop.T_LOGICAL_OR\n        else:\n            return binop.T_LOGICAL_AND\n    else:\n        is_inverted = _is_inverted(block.warp, true, end)\n\n        if is_inverted:\n            return binop.T_LOGICAL_OR\n        else:\n            return binop.T_LOGICAL_AND", "\n\ndef _get_last_assignment_source(block):\n    if len(block.contents) == 0:\n        return None\n\n    assignment = block.contents[-1]\n\n    if isinstance(assignment, nodes.Assignment):\n        return assignment.expressions.contents[0]\n    elif isinstance(assignment, nodes.FunctionCall):\n        return None\n    elif isinstance(assignment, nodes.NoOp):\n        return None\n    elif isinstance(assignment, nodes.Return):\n        return assignment.returns.contents[0]\n    else:\n        assert False", "\n\ndef _get_and_remove_last_assignment_source(block):\n    assignment = block.contents.pop()\n\n    if False:  # TODO(yzg)\n        assert isinstance(assignment, nodes.Assignment)\n        return assignment.expressions.contents[0]\n    else:\n        if isinstance(assignment, nodes.Assignment):\n            return assignment.expressions.contents[0]\n        else:\n            return assignment", "\n\ndef _compile_subexpression(subexpression, operator,\n                           block, next_block, true, end):\n    warp = block.warp\n\n    if len(subexpression) == 1:\n        if isinstance(warp, nodes.UnconditionalWarp):\n            return _get_and_remove_last_assignment_source(block)\n        elif _is_inverted(warp, true, end):\n            return _invert(warp.condition)\n        else:\n            return warp.condition\n    else:\n        if isinstance(warp, nodes.UnconditionalWarp):\n            if operator == binop.T_LOGICAL_OR:\n                subtrue = warp.target\n                subfalse = next_block\n            else:\n                subtrue = next_block\n                subfalse = warp.target\n        else:\n            if operator == binop.T_LOGICAL_OR:\n                subtrue = warp.false_target\n                subfalse = warp.true_target\n            else:\n                subtrue = warp.true_target\n                subfalse = warp.false_target\n\n        return _unwarp_expression(subexpression, None, subtrue, subfalse)", "\n\ndef _is_inverted(warp, true, end):\n    if isinstance(warp, nodes.UnconditionalWarp):\n        return warp.target == end\n\n    if warp.false_target == true:\n        return True\n    elif warp.false_target == end:\n        assert not isinstance(warp.condition, nodes.BinaryOperator)\n\n        if not isinstance(warp.condition, nodes.UnaryOperator):\n            return False\n\n        return warp.condition.type == nodes.UnaryOperator.T_NOT\n\n    return False", "\n\n_NEGATION_MAP = [None] * 100\n\n_NEGATION_MAP[binop.T_LESS_THEN] = binop.T_GREATER_OR_EQUAL\n_NEGATION_MAP[binop.T_GREATER_THEN] = binop.T_LESS_OR_EQUAL\n_NEGATION_MAP[binop.T_LESS_OR_EQUAL] = binop.T_GREATER_THEN\n_NEGATION_MAP[binop.T_GREATER_OR_EQUAL] = binop.T_LESS_THEN\n\n_NEGATION_MAP[binop.T_NOT_EQUAL] = binop.T_EQUAL", "\n_NEGATION_MAP[binop.T_NOT_EQUAL] = binop.T_EQUAL\n_NEGATION_MAP[binop.T_EQUAL] = binop.T_NOT_EQUAL\n\n\ndef _invert(expression):\n    if isinstance(expression, nodes.UnaryOperator):\n        return expression.operand\n\n    if not isinstance(expression, nodes.BinaryOperator):\n        node = nodes.UnaryOperator()\n        node.type = nodes.UnaryOperator.T_NOT\n        node.operand = expression\n\n        return node\n\n    # Just in case\n    expression = copy.deepcopy(expression)\n\n    new_type = _NEGATION_MAP[expression.type]\n\n    if new_type is None:\n        if expression.type == binop.T_LOGICAL_OR:\n            new_type = binop.T_LOGICAL_AND\n        elif expression.type == binop.T_LOGICAL_AND:\n            new_type = binop.T_LOGICAL_OR\n\n        expression.left = _invert(expression.left)\n        expression.right = _invert(expression.right)\n\n    assert new_type is not None\n\n    expression.type = new_type\n\n    return expression", "\n\ndef _get_terminators(body):\n    if len(body) < 2:\n        return None, None, body\n\n    last = body[-1]\n\n    if len(last.contents) != 1:\n        return None, None, body\n\n    assignment = last.contents[0]\n\n    if not isinstance(assignment, nodes.Assignment):\n        return None, None, body\n\n    src = assignment.expressions.contents[0]\n\n    if not isinstance(src, nodes.Primitive) or src.type != src.T_TRUE:\n        return None, None, body\n\n    prev = body[-2]\n\n    if len(prev.contents) != 1:\n        return None, None, body\n\n    # TODO(yzg) origin: src = prev.contents[0].expressions.contents[0]\n    if hasattr(prev.contents[0], \"expressions\"):\n        src = prev.contents[0].expressions.contents[0]\n    else:\n        src = prev.contents[0]\n\n    if not isinstance(src, nodes.Primitive) or src.type != src.T_FALSE:\n        return None, None, body\n\n    return last, prev, body[:-2]", "\n\ndef _assemble_expression(parts):\n    if not isinstance(parts, list):\n        return parts\n\n    if len(parts) == 1:\n        return parts[0]\n\n    node = nodes.BinaryOperator()\n    node.left = _assemble_expression(parts[-3])\n\n    node.type = parts[-2]\n    assert isinstance(node.type, int)\n\n    node.right = _assemble_expression(parts[-1])\n\n    i = len(parts) - 4\n\n    while i > 0:\n        operator = parts[i]\n        component = parts[i - 1]\n\n        upper_node = nodes.BinaryOperator()\n        upper_node.right = node\n        upper_node.left = _assemble_expression(component)\n\n        upper_node.type = operator\n\n        node = upper_node\n\n        i -= 2\n\n    return node", "\n\n# Split the topmost expression into smaller subexpressions at each\n# operator change to simplify the assembly phase\ndef _make_explicit_subexpressions(parts):\n    patched = []\n\n    i = 0\n\n    last_operator = parts[1]\n    subexpression_start = -1\n\n    while i < len(parts) - 1:\n        component = parts[i]\n        operator = parts[i + 1]\n\n        if operator < last_operator:\n            subexpression_start = i\n            last_operator = operator\n        elif subexpression_start > 0:\n            if operator > last_operator \\\n                    and (i - subexpression_start) % 2 != 0:\n                subexpression = parts[subexpression_start:i]\n\n                patched.append(subexpression)\n                subexpression_start = -1\n        else:\n            patched += [component, operator]\n\n        i += 2\n\n    if subexpression_start >= 0:\n        patched.append(parts[subexpression_start:])\n    else:\n        patched.append(parts[-1])\n\n    return patched", "\n\ndef _unwarp_if_statement(start, body, end, topmost_end):\n    expression, body, false = _extract_if_expression(start, body, end,\n                                                     topmost_end)\n\n    node = nodes.If()\n    node.expression = expression\n\n    # has an else branch\n    if false != end and false != topmost_end:\n        else_start = false\n\n        else_start_index = body.index(else_start)\n\n        then_body = body[:else_start_index]\n\n        then_warp_out = then_body[-1].warp\n\n        assert _is_jump(then_warp_out)\n        assert then_warp_out.target in (end, topmost_end)\n\n        else_body = body[else_start_index:]\n\n        else_warp_out = else_body[-1].warp\n\n        if isinstance(else_warp_out, nodes.UnconditionalWarp):\n            if else_warp_out.type == nodes.UnconditionalWarp.T_JUMP:\n                assert else_warp_out.target in (end, topmost_end)\n            else:\n                assert else_warp_out.target == end\n        else:\n            assert isinstance(else_warp_out, nodes.EndWarp)\n\n        _set_end(then_body[-1])\n        then_blocks = _unwarp_ifs(then_body, then_body[-1], topmost_end)\n        node.then_block.contents = then_blocks\n\n        _set_end(else_body[-1])\n        else_blocks = _unwarp_ifs(else_body, else_body[-1], topmost_end)\n        node.else_block.contents = else_blocks\n\n        if _get_target(then_warp_out, True) == _get_target(else_warp_out, True) \\\n                and len(then_blocks) == 1 \\\n                and len(then_blocks[0].contents) == 1 \\\n                and isinstance(then_blocks[0].contents[0], nodes.NoOp):\n\n            # Good to merge, but we don't want to break up else-ifs\n            if len(else_blocks) != 1 or not isinstance(else_blocks[0].contents[-1], nodes.If):\n\n                # Invert condition and move else block to then\n                node.expression = _invert(expression)\n                node.then_block.contents = else_blocks\n                node.else_block.contents = []\n\n    else:\n        warp_out = body[-1].warp\n\n        if not isinstance(warp_out, nodes.EndWarp):\n            assert isinstance(warp_out, nodes.UnconditionalWarp)\n            assert warp_out.target in (end, topmost_end)\n\n        _set_end(body[-1])\n        then_blocks = _unwarp_ifs(body, body[-1], topmost_end)\n        node.then_block.contents = then_blocks\n\n    start.contents.append(node)", "\n\ndef _extract_if_expression(start, body, end, topmost_end):\n    i = 0\n    for i, block in enumerate(body):\n        if len(block.contents) != 0:\n            break\n\n    assert i < len(body)\n\n    expression = [start] + body[:i]\n    body = body[i:]\n\n    falses = set()\n\n    for i, block in enumerate(body[:-1]):\n        if not isinstance(block.warp, nodes.UnconditionalWarp):\n            continue\n\n        if block.warp.type != nodes.UnconditionalWarp.T_JUMP:\n            continue\n\n        if block.warp.target != end and block.warp.target != topmost_end:\n            continue\n\n        falses.add(body[i + 1])\n\n    falses.add(end)\n\n    if topmost_end is not None:\n        falses.add(topmost_end)\n\n    false, end_i = _search_expression_end(expression, falses)\n\n    if false is None:\n        unpacked_falses = sorted(falses,\n                                 key=lambda unpacked_false: unpacked_false.index)\n        false = unpacked_falses[-1]\n        end_i = len(expression)\n\n    assert false is not None\n    assert end_i >= 0\n\n    body = expression[end_i:] + body\n    expression = expression[:end_i]\n\n    assert len(expression) > 0\n\n    true = body[0]\n\n    expression = _compile_expression(expression, None, true, false)\n\n    return expression, body, false", "\n\ndef _search_expression_end(expression, falses):\n    expression_end = -1\n    false = None\n\n    for i, block in enumerate(expression):\n        target = _get_target(block.warp, True)\n\n        if target not in falses:\n            continue\n\n        if false is None or target == false:\n            false = target\n            expression_end = i + 1\n        else:\n            break\n\n    return false, expression_end", "\n\ndef _find_branching_end(blocks, topmost_end, loop_start=None):\n    end = blocks[0]\n\n    for block in blocks:\n        warp = block.warp\n\n        target = _get_target(warp, allow_end=True)\n\n        if isinstance(warp, nodes.EndWarp) and target is None:\n            try:\n                assert block == end\n            except AssertionError:\n                if catch_asserts:\n                    setattr(block, \"_decompilation_error_here\", True)\n                    print(\"-- WARNING: Error occurred during decompilation.\")\n                    print(\"--   Code may be incomplete or incorrect.\")\n                    if hasattr(end, \"warp\") and _get_target(end.warp) == block:\n                        return end\n                else:\n                    raise\n            return block\n\n        if isinstance(warp, nodes.UnconditionalWarp) and target == end:\n            return end\n\n        if target.index > end.index:\n            end = target\n\n    return end", "\n\ndef _remove_processed_blocks(blocks, boundaries):\n    remains = []\n    last_end_index = -1\n\n    for start, end in boundaries:\n        if start == end:\n            up_to_index = start\n        else:\n            up_to_index = start + 1\n\n        remains += blocks[last_end_index + 1:up_to_index]\n        last_end_index = end\n\n    remains += blocks[last_end_index + 1:]\n\n    return remains", "\n\n# ##\n# ## LOOPS PROCESSING\n# ##\n\n\ndef _fix_loops(blocks, repeat_until):\n    loops = _find_all_loops(blocks, repeat_until=repeat_until)\n\n    if len(loops) == 0:\n        return blocks\n\n    fixed = _cleanup_breaks_and_if_ends(loops, blocks)\n\n    replacements = {}\n\n    for start, end in fixed:\n        end = replacements.get(end, end)\n        start_index = blocks.index(start)\n        end_index = blocks.index(end)\n\n        # Try and find the outermost loop-marking block - this indicates the start of the\n        # loop body is the next block.\n        loop_block = None\n        for block in blocks[start_index:end_index]:\n            if block.loop:\n                loop_block = block\n                break\n\n        # If this is an iterator loop (for a in b), then there's no body marker (for other types\n        # of loops, block.loop would be set on the last block before the body). In this case, don't\n        # use the detected loop block as that would cause issues, such as in this program:\n        #\n        # for a in b do\n        #   if id then\n        #     for i = c, d, 1 do\n        #       print(i)\n        #     end\n        #   end\n        # end\n        if isinstance(start.warp, nodes.IteratorWarp):\n            loop_block = None\n\n        if not loop_block:\n            blocks = _handle_single_loop(start, end, blocks, repeat_until)\n            continue\n\n        assert loop_block\n\n        body_start_index = blocks.index(loop_block)\n\n        # Skip the LOOP (or similar) instruction\n        # Note that is it guaranteed that there will only be repeat...until loops if\n        #  repeat_until is set, due to `assert not repeat_until` in _find_all_loops\n        # Also note we don't do this in repeat...until loops is that their first block\n        #  contains the user's code, and skipping this would omit that\n        if body_start_index == start_index and not repeat_until:\n            body_start_index += 1\n\n        loop = _unwarp_loop(start, end, expr_body=blocks[start_index:body_start_index], body=blocks[body_start_index:end_index])\n        body = loop.statements.contents\n\n        block = _loop_build_block(start, body, end, blocks, loop, body_start_index)\n\n        if body_start_index == start_index:\n            blocks = blocks[:start_index + 1] + [block] + blocks[end_index:]\n        else:\n            if isinstance(loop, nodes.While) and start_index < body_start_index - 1:\n                if any(len(node.contents) > 0 for node in blocks[start_index:body_start_index]):\n                    start_index = body_start_index\n\n                # TODO deal with mixed conditions and sub expressions\n                before = blocks[:start_index]\n                if before:\n                    old_start = blocks[start_index]\n                    _replace_targets(before, old_start, block)\n                    replacements[old_start] = block\n            else:\n                before = blocks[:body_start_index]\n            blocks = before + [block] + blocks[end_index:]\n\n        for i, block in enumerate(body):\n            warp = block.warp\n\n            if _is_flow(warp):\n                assert _get_target(warp) == body[i + 1]\n\n            if isinstance(warp, nodes.ConditionalWarp):\n                assert warp.true_target in body\n                assert warp.false_target in body\n            elif isinstance(warp, nodes.UnconditionalWarp):\n                if warp.target:\n                    assert warp.target in body\n\n    # do validate\n    for i, block in enumerate(blocks):\n        warp = block.warp\n\n        if _is_flow(warp):\n            assert _get_target(warp) == blocks[i + 1]\n\n        if isinstance(warp, nodes.ConditionalWarp):\n            assert warp.true_target in blocks\n            assert warp.false_target in blocks\n        else:\n            target = _get_target(warp, True)\n            if target:\n                assert target in blocks\n\n    return blocks", "\n\ndef _handle_single_loop(start, end, blocks, repeat_until):\n    start_index = blocks.index(start)\n    end_index = blocks.index(end)\n\n    if repeat_until:\n        body = blocks[start_index:end_index]\n    else:\n        body = blocks[start_index + 1:end_index]\n\n    loop = _unwarp_loop(start, end, body)\n    body = loop.statements.contents\n\n    block = _loop_build_block(start, body, end, blocks, loop, start.index + 1)\n\n    blocks = blocks[:start_index + 1] + [block] + blocks[end_index:]\n    return blocks", "\n\ndef _loop_build_block(start, body, end, blocks, loop, block_index):\n    block = nodes.Block()\n    block.first_address = body[0].first_address\n    block.last_address = body[-1].last_address\n    block.index = block_index\n    block.contents.append(loop)\n\n    block.warp = nodes.UnconditionalWarp()\n    block.warp.type = nodes.UnconditionalWarp.T_FLOW\n    block.warp.target = end\n\n    _replace_targets(blocks, body[0], block)\n\n    # Don't set the _target property of the end block - this will trip up the\n    # verification logic down below in very specific situations.\n    # See https://gitlab.com/znixian/luajit-decompiler/issues/7#note_149912326\n    # for an explanation of why this is a problem.\n    # To elaborate on the 'invalid value' part of the comment: this will normally\n    # (for nested loops) set an invalid _target property for the end block - that is,\n    # it's pointing outside the contents of the loop. This isn't caught by the\n    # validator below, since it's still within the 'blocks' variable.\n    _set_end(body[-1], force_no_target=True)\n\n    _unwarp_breaks(start, body, end)\n\n    return block", "\n\ndef _unwarp_loops(blocks, repeat_until):\n    loops = _find_all_loops(blocks, repeat_until)\n\n    assert not loops\n\n    return blocks\n\n\ndef _cleanup_breaks_and_if_ends(loops, blocks):\n    outer_start_index = -1\n    outer_end = None\n\n    current_start_index = -1\n    current_end = None\n\n    fixed = []\n\n    for start, end in loops:\n        if start.index in (outer_start_index, current_start_index):\n            end_i = blocks.index(end)\n            last_in_body = blocks[end_i - 1]\n            warp = last_in_body.warp\n\n            assert isinstance(warp, nodes.UnconditionalWarp)\n            assert warp.target == start\n\n            # Break\n            if start.index == outer_start_index:\n                assert outer_end is not None\n\n                outer_end_i = blocks.index(outer_end)\n                warp.target = blocks[outer_end_i - 1]\n\n                assert blocks[outer_end_i - 2] != end\n            else:\n                assert current_end is not None\n                assert start.index == current_start_index\n\n                current_end_i = blocks.index(current_end)\n\n                last = blocks[current_end_i - 1]\n\n                if last == end:\n                    last = _create_next_block(end)\n                    last.warp = end.warp\n\n                    _set_flow_to(end, last)\n\n                    blocks.insert(current_end_i, last)\n\n                assert not last.contents\n                assert isinstance(last.warp, nodes.UnconditionalWarp)\n                assert last.warp.target == start\n\n                warp.target = last\n        else:\n            fixed.append((start, end))\n\n            if current_end is not None \\\n                    and current_start_index < start.index \\\n                    and current_end.index >= end.index:\n                outer_start_index = current_start_index\n                outer_end = current_end\n            else:\n                outer_start_index = -1\n                outer_end = None\n\n            current_start_index = start.index\n            current_end = end\n\n    return fixed", "\n\ndef _cleanup_breaks_and_if_ends(loops, blocks):\n    outer_start_index = -1\n    outer_end = None\n\n    current_start_index = -1\n    current_end = None\n\n    fixed = []\n\n    for start, end in loops:\n        if start.index in (outer_start_index, current_start_index):\n            end_i = blocks.index(end)\n            last_in_body = blocks[end_i - 1]\n            warp = last_in_body.warp\n\n            assert isinstance(warp, nodes.UnconditionalWarp)\n            assert warp.target == start\n\n            # Break\n            if start.index == outer_start_index:\n                assert outer_end is not None\n\n                outer_end_i = blocks.index(outer_end)\n                warp.target = blocks[outer_end_i - 1]\n\n                assert blocks[outer_end_i - 2] != end\n            else:\n                assert current_end is not None\n                assert start.index == current_start_index\n\n                current_end_i = blocks.index(current_end)\n\n                last = blocks[current_end_i - 1]\n\n                if last == end:\n                    last = _create_next_block(end)\n                    last.warp = end.warp\n\n                    _set_flow_to(end, last)\n\n                    blocks.insert(current_end_i, last)\n\n                assert not last.contents\n                assert isinstance(last.warp, nodes.UnconditionalWarp)\n                assert last.warp.target == start\n\n                warp.target = last\n        else:\n            fixed.append((start, end))\n\n            if current_end is not None \\\n                    and current_start_index < start.index \\\n                    and current_end.index >= end.index:\n                outer_start_index = current_start_index\n                outer_end = current_end\n            else:\n                outer_start_index = -1\n                outer_end = None\n\n            current_start_index = start.index\n            current_end = end\n\n    return fixed", "\n\ndef _replace_targets(blocks, original, replacement, allow_add_jumpback=False):\n    for block in blocks:\n        warp = block.warp\n\n        if isinstance(warp, nodes.UnconditionalWarp):\n            if warp.target == original:\n                warp.target = replacement\n        elif isinstance(warp, nodes.ConditionalWarp):\n            if warp.true_target == original:\n                warp.true_target = replacement\n\n            if warp.false_target == original \\\n                    and (warp.false_target.last_address > block.last_address or allow_add_jumpback):\n                warp.false_target = replacement\n        elif isinstance(warp, nodes.EndWarp):\n            pass\n        else:\n            if warp.way_out == original:\n                warp.way_out = replacement\n\n            if warp.body == original:\n                warp.body = replacement", "\n\ndef _unwarp_loop(start, end, body, expr_body=None):\n    if len(body) > 0:\n        last = body[-1]\n    else:\n        last = start\n\n    if isinstance(start.warp, nodes.IteratorWarp):\n        assert isinstance(last.warp, nodes.UnconditionalWarp)\n        assert last.warp.target == start\n\n        loop = nodes.IteratorFor()\n        loop.statements.contents = body\n        loop.identifiers = start.warp.variables\n        loop.expressions = start.warp.controls\n        loop._addr = body[0].first_address\n\n        _set_flow_to(start, body[0])\n\n    elif isinstance(start.warp, nodes.NumericLoopWarp):\n        assert isinstance(last.warp, nodes.UnconditionalWarp)\n        assert last.warp.target == start\n\n        loop = nodes.NumericFor()\n        loop.statements.contents = body\n        loop.variable = start.warp.index\n        loop.expressions = start.warp.controls\n        loop._addr = body[0].first_address\n        _set_flow_to(start, body[0])\n\n    # While (including \"while true\" and \"repeat until false\")\n    elif isinstance(last.warp, nodes.UnconditionalWarp):\n        assert last.warp.target == start\n\n        # while true / repeat until false\n        if _is_flow(start.warp):\n\n            prev_to_last = body[-2] if len(body) > 1 else None\n            if prev_to_last and isinstance(prev_to_last.warp, nodes.UnconditionalWarp) \\\n                    and prev_to_last.warp.type == nodes.UnconditionalWarp.T_JUMP \\\n                    and prev_to_last.warp.target == last \\\n                    and (len(body) <= 2 or _is_flow(body[-3].warp)):  # not strictly needed, but better be safe\n                loop = nodes.RepeatUntil()\n                loop.expression = nodes.Primitive()\n                loop.expression.type = nodes.Primitive.T_FALSE\n                body.pop()  # Remove the jump block specific to this case\n            else:\n                loop = nodes.While()\n                loop.expression = nodes.Primitive()\n                loop.expression.type = nodes.Primitive.T_TRUE\n\n            loop.statements.contents = body\n        else:\n            # There shouldn't be many problems similar to ifs, as\n            # we are processing loops in the order from innermost\n            # to outermost\n            i = 0\n            for i, block in enumerate(body):\n                # walterr seems to be the only actual code change on the\n                # 'experimental' branch.\n                # assert len(block.contents) == 0\n\n                if _is_flow(block.warp):\n                    break\n\n            assert i < len(body)\n\n            expression = expr_body + body[:i]\n            body = body[i:]\n\n            # Sometimes expression may decide to jump to the\n            # outer loop start instead\n            _fix_expression(expression, start, end)\n\n            true = body[0]\n            false = end\n\n            expression = _compile_expression(expression, None,\n                                             true, false)\n\n            # If something jumps to the start (instead of the end)\n            # - that's a nested if\n            loop = nodes.While()\n            loop.expression = expression\n            loop.statements.contents = body\n\n        _fix_nested_ifs(body, start)\n\n        condition_end = expr_body[-1] if expr_body else start\n        _set_flow_to(condition_end, body[0])\n\n    # Repeat until\n    else:\n        assert isinstance(last.warp, nodes.ConditionalWarp)\n        assert last.warp.false_target == start\n\n        i = len(body) - 1\n\n        while i >= 0:\n            block = body[i]\n            warp = block.warp\n\n            if _is_flow(warp):\n                i += 1\n                break\n\n            if len(block.contents) != 0:\n                break\n\n            i -= 1\n\n        expression = body[i:]\n        body = body[:i + 1]\n\n        assert len(expression) > 0\n\n        first = expression[0]\n        if _is_jump(first.warp):\n            # Don't append to the body - it already has it\n            expression.pop(0)\n            if len(body[-1].contents) == 1 and isinstance(body[-1].contents, nodes.NoOp):\n                body[-1].contents = []\n            body[-1].contents.append(nodes.Break())\n\n        false = body[0]\n        # Don't use end as it could be broken by a previous\n        # repeat until pass\n        true = expression[-1].warp.true_target\n\n        loop = nodes.RepeatUntil()\n        loop.expression = _compile_expression(expression, None,\n                                              true, false)\n\n        start_copy = copy.copy(start)\n        start.contents = []\n\n        if len(body) > 1:\n            _set_flow_to(start_copy, body[1])\n        else:\n            _set_end(start_copy)\n\n        _set_flow_to(start, start_copy)\n\n        body[0] = start_copy\n\n        loop.statements.contents = body\n\n    return loop", "\n\ndef _create_next_block(original):\n    block = nodes.Block()\n    block.first_address = original.last_address + 1\n    block.last_address = block.first_address\n    block.index = original.index + 1\n    block.warpins_count = original.warpins_count\n\n    return block", "\n\ndef _set_flow_to(block, target):\n    block.warp = nodes.UnconditionalWarp()\n    block.warp.type = nodes.UnconditionalWarp.T_FLOW\n    block.warp.target = target\n\n\ndef _set_end(block, force_no_target=False):\n    target = None\n\n    if block.warp is not None and not force_no_target:\n        target = _get_target(block.warp, allow_end=True)\n\n    block.warp = nodes.EndWarp()\n\n    setattr(block.warp, \"_target\", target)", "def _set_end(block, force_no_target=False):\n    target = None\n\n    if block.warp is not None and not force_no_target:\n        target = _get_target(block.warp, allow_end=True)\n\n    block.warp = nodes.EndWarp()\n\n    setattr(block.warp, \"_target\", target)\n", "\n\ndef _is_flow(warp):\n    return isinstance(warp, nodes.UnconditionalWarp) \\\n           and warp.type == nodes.UnconditionalWarp.T_FLOW\n\n\ndef _is_jump(warp):\n    return isinstance(warp, nodes.UnconditionalWarp) \\\n           and warp.type == nodes.UnconditionalWarp.T_JUMP", "\n\ndef _fix_nested_ifs(blocks, start):\n    # We can't point both targets of a conditional warp to the\n    # same block. We will have to create a new block\n    last = _create_next_block(blocks[-1])\n\n    if isinstance(blocks[-1].warp, nodes.ConditionalWarp):\n        blocks[-1].warp.false_target = last\n    else:\n        _set_flow_to(blocks[-1], last)\n\n    blocks.append(last)\n    _set_end(last)\n\n    for block in blocks[:-1]:\n        target = _get_target(block.warp)\n\n        if target == start:\n            _set_target(block.warp, last)", "\n\ndef _fix_expression(blocks, start, end):\n    for block in blocks:\n        if len(block.contents) != 0:\n            break\n\n        target = _get_target(block.warp)\n\n        if target.index < start.index:\n            _set_target(block.warp, end)", "\n\ndef _gather_possible_ends(block):\n    warp = block.warp\n\n    ends = {block}\n\n    while _is_jump(warp):\n        block = warp.target\n        warp = block.warp\n\n        ends.add(block)\n\n    return ends", "\n\nBREAK_INFINITE = 0\nBREAK_ONE_USE = 1\n\n\ndef _unwarp_breaks(start, blocks, next_block):\n    blocks_set = set([start] + blocks)\n\n    ends = _gather_possible_ends(next_block)\n\n    breaks = set()\n\n    patched = []\n\n    for i, block in enumerate(blocks):\n        warp = block.warp\n\n        if not isinstance(warp, nodes.UnconditionalWarp):\n            patched.append(block)\n            continue\n\n        target = _get_target(warp)\n\n        if target in blocks_set:\n            patched.append(block)\n            continue\n\n        assert target in ends, \"GOTO statements are not supported\"\n\n        if block.warpins_count != 0 \\\n                and not (len(block.contents) == 1 and isinstance(block.contents[0], nodes.NoOp)):\n            new_block = _create_next_block(block)\n            new_block.warpins_count = block.warpins_count\n            _set_flow_to(block, new_block)\n\n            patched.append(block)\n            patched.append(new_block)\n\n            block = new_block\n        else:\n            patched.append(block)\n\n        if len(block.contents) == 1 and isinstance(block.contents[0], nodes.NoOp):\n            block.contents = []\n        block.contents.append(nodes.Break())\n\n        if i + 1 == len(blocks):\n            _set_end(block)\n        else:\n            _set_flow_to(block, blocks[i + 1])\n\n        breaks.add(block)\n\n    blocks[:] = patched\n\n    if len(breaks) == 0:\n        return\n\n    breaks_stack = []\n    warps_out = []\n    pending_break = None\n\n    for i, block in enumerate(reversed(blocks)):\n        if block in breaks:\n            pending_break = None\n\n            if block.warpins_count == 0:\n                breaks_stack.append((BREAK_ONE_USE, block))\n            else:\n                breaks_stack.append((BREAK_INFINITE, block))\n\n            continue\n\n        warp = block.warp\n\n        if not isinstance(warp, nodes.ConditionalWarp):\n            if _is_flow(warp):\n                pending_break = None\n\n            continue\n\n        target = _get_target(warp)\n\n        if target in blocks_set:\n            continue\n\n        assert target in ends, \"GOTO statements are not supported\"\n\n        if pending_break is None:\n            assert len(breaks_stack) > 0\n\n            top_break = breaks_stack[-1]\n\n            _set_target(warp, top_break[1])\n\n            if top_break[0] == BREAK_ONE_USE:\n                pending_break = breaks_stack.pop()\n\n                warps_out = []\n            else:\n                warps_out.append(block)\n        else:\n            _set_target(warp, pending_break[1])\n            warps_out.append(block)\n\n        if len(block.contents) > 0:\n            pending_break = None\n\n    while len(breaks_stack) > 0 and breaks_stack[-1][0] == BREAK_INFINITE:\n        breaks_stack.pop()\n\n    # And pray for the best...\n    while len(warps_out) > 0 and len(breaks_stack) > 0:\n        _set_target(warps_out.pop().warp, breaks_stack.pop()[1])", "\n\n#\n# We don't need any complex checks here.\n#\n# Just search for any negative jump - that's a loop and what it's jumping to is\n# a loop start.\n#\ndef _find_all_loops(blocks, repeat_until):\n    # Duplicates are NOT possible\n    loops = []\n\n    # If two points jump back to the same start, they must (if you know of any\n    #  exceptions to this, please let me know) be the same loop, and all but the\n    #  last jump are LuaJIT-generated 'continue' statements. These are almost\n    #  always conditional jumps, but there is one case I know of which bucks this:\n    #\n    # while a do\n    #  if b then\n    #   ...\n    #  elseif c\n    #   ...\n    #  end\n    # end\n    #\n    # Without anything after the if/else statement, the compiler will place an unconditional\n    #  jump from the end of the true block back to the start of the loop\n    # This keeps track of the loops starting at each potential index, and if\n    #  we find a jump to this point, check it and if so remove that loop.\n    #\n    # This is also not removed by _cleanup_breaks_and_if_ends, for some reason. However it may\n    #  end up being possible to remove that pass altogether, and doing it here is simpler.\n    starts = dict()\n\n    i = 0\n\n    while i < len(blocks):\n        block = blocks[i]\n        warp = block.warp\n\n        if isinstance(warp, nodes.UnconditionalWarp):\n            if warp.type == nodes.UnconditionalWarp.T_FLOW:\n                i += 1\n                continue\n\n            start = warp.target\n            if start.index <= block.index:\n                assert not repeat_until\n                assert i < len(blocks) - 1\n\n                if start in starts:\n                    pass\n                    loops.remove(starts[start])\n\n                loops.append((start, blocks[i + 1]))\n                starts[start] = loops[-1]\n\n        # The inline continues mentioned above shouldn't be an issue here, since they\n        #  will all be removed during the first pass, and point forwards to their new\n        #  EndWarp-containing nodes\n        elif repeat_until and isinstance(warp, nodes.ConditionalWarp):\n            if warp.false_target.index > block.index:\n                i += 1\n                continue\n\n            start = warp.false_target\n            first = block\n            end = block\n            last_i = i\n\n            # Find the end of the expression\n            while i < len(blocks):\n                block = blocks[i]\n                warp = block.warp\n\n                if block != first and len(block.contents) != 0:\n                    break\n\n                if isinstance(warp, nodes.EndWarp):\n                    break\n\n                # Go up to a first negative jump of an\n                # another loop\n\n                target = _get_target(warp)\n                if target.index < block.index:\n                    if target == start:\n                        start = target\n                        end = block\n                        last_i = i\n                    else:\n                        break\n\n                i += 1\n\n            # And then rollback to the last known negative jump\n            # of our loop\n            i = last_i\n\n            # There always should be at least one return block\n            end_index = blocks.index(end)\n            end = blocks[end_index + 1]\n\n            loops.append((start, end))\n\n        i += 1\n\n    # Reverse the order so inner \"while\" loops are processed before\n    # outer loops\n    return list(reversed(sorted(loops, key=lambda x: x[0].index)))", "def _find_all_loops(blocks, repeat_until):\n    # Duplicates are NOT possible\n    loops = []\n\n    # If two points jump back to the same start, they must (if you know of any\n    #  exceptions to this, please let me know) be the same loop, and all but the\n    #  last jump are LuaJIT-generated 'continue' statements. These are almost\n    #  always conditional jumps, but there is one case I know of which bucks this:\n    #\n    # while a do\n    #  if b then\n    #   ...\n    #  elseif c\n    #   ...\n    #  end\n    # end\n    #\n    # Without anything after the if/else statement, the compiler will place an unconditional\n    #  jump from the end of the true block back to the start of the loop\n    # This keeps track of the loops starting at each potential index, and if\n    #  we find a jump to this point, check it and if so remove that loop.\n    #\n    # This is also not removed by _cleanup_breaks_and_if_ends, for some reason. However it may\n    #  end up being possible to remove that pass altogether, and doing it here is simpler.\n    starts = dict()\n\n    i = 0\n\n    while i < len(blocks):\n        block = blocks[i]\n        warp = block.warp\n\n        if isinstance(warp, nodes.UnconditionalWarp):\n            if warp.type == nodes.UnconditionalWarp.T_FLOW:\n                i += 1\n                continue\n\n            start = warp.target\n            if start.index <= block.index:\n                assert not repeat_until\n                assert i < len(blocks) - 1\n\n                if start in starts:\n                    pass\n                    loops.remove(starts[start])\n\n                loops.append((start, blocks[i + 1]))\n                starts[start] = loops[-1]\n\n        # The inline continues mentioned above shouldn't be an issue here, since they\n        #  will all be removed during the first pass, and point forwards to their new\n        #  EndWarp-containing nodes\n        elif repeat_until and isinstance(warp, nodes.ConditionalWarp):\n            if warp.false_target.index > block.index:\n                i += 1\n                continue\n\n            start = warp.false_target\n            first = block\n            end = block\n            last_i = i\n\n            # Find the end of the expression\n            while i < len(blocks):\n                block = blocks[i]\n                warp = block.warp\n\n                if block != first and len(block.contents) != 0:\n                    break\n\n                if isinstance(warp, nodes.EndWarp):\n                    break\n\n                # Go up to a first negative jump of an\n                # another loop\n\n                target = _get_target(warp)\n                if target.index < block.index:\n                    if target == start:\n                        start = target\n                        end = block\n                        last_i = i\n                    else:\n                        break\n\n                i += 1\n\n            # And then rollback to the last known negative jump\n            # of our loop\n            i = last_i\n\n            # There always should be at least one return block\n            end_index = blocks.index(end)\n            end = blocks[end_index + 1]\n\n            loops.append((start, end))\n\n        i += 1\n\n    # Reverse the order so inner \"while\" loops are processed before\n    # outer loops\n    return list(reversed(sorted(loops, key=lambda x: x[0].index)))", "\n\ndef _get_previous_block(block, blocks):\n    block_index = blocks.index(block)\n\n    assert block_index > 0\n\n    return blocks[block_index - 1]\n\n", "\n\n# Remove any unnecessary empty blocks (ie, those which are only flowed into once), and\n#  merge any two blocks where the first flows into the second, and only the first warps to\n#  the second.\ndef _cleanup_ast(blocks):\n    next_i = 0\n    while next_i < len(blocks):\n        i = next_i\n        next_i += 1\n        block = blocks[i]\n\n        # Skip the first block, don't want to touch it for now\n        if i == 0:\n            continue\n\n        targets = _find_warps_to(blocks, block)\n\n        assert targets\n\n        if len(targets) != 1:\n            continue\n\n        src = targets[0]\n        warp = src.warp\n\n        if not isinstance(warp, nodes.UnconditionalWarp):\n            continue\n\n        if warp.type != nodes.UnconditionalWarp.T_FLOW:\n            continue\n\n        assert blocks.index(src) == i - 1\n\n        # Move the to-be-deleted block's contents over\n        src.contents += block.contents\n        src.warp = block.warp\n        src.last_address = block.last_address\n\n        blocks.remove(block)\n\n        # Because we're deleting this block, we need to stay at the\n        #  same index since the list moved back\n        next_i = i\n\n    # Now that everything is nicely packed together, the code to eliminate temporary variables that\n    #  are used in the input part of a for..in loop should be able to get everything.\n    # TODO: eliminate_temporary here is skipped. need to check and fix side effects.\n    if not skip_eliminate:\n        slotworks.eliminate_temporary(blocks[0], False)\n    return blocks", "\n\ndef _find_warps_to(blocks, target):\n    sources = []\n\n    for block in blocks:\n        warp = block.warp\n\n        if isinstance(warp, nodes.UnconditionalWarp):\n            if warp.target == target:\n                sources.append(block)\n        elif isinstance(warp, nodes.ConditionalWarp):\n            if warp.false_target == target or warp.true_target == target:\n                sources.append(block)\n        elif isinstance(warp, nodes.EndWarp):\n            pass\n        else:\n            if warp.way_out == target or warp.body == target:\n                sources.append(block)\n\n    return sources", ""]}
{"filename": "ljd/ast/mutator.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport copy\nimport logging\nimport warnings\n\nfrom ljd.ast.helpers import *\nfrom ljd.bytecode.instructions import SLOT_FALSE, SLOT_TRUE", "from ljd.ast.helpers import *\nfrom ljd.bytecode.instructions import SLOT_FALSE, SLOT_TRUE\n\n\nlogger = logging.getLogger(__name__)\n\nclass SimpleLoopWarpSwapper(traverse.Visitor):\n    class _State:\n        def __init__(self):\n            self.loops = []\n            self.jumps = []\n\n    def __init__(self):\n        self._states = []\n\n    def visit_function_definition(self, node):\n        self._states.append(self._State())\n\n    def leave_function_definition(self, node):\n        state = self._states.pop()\n        if not state:\n            return\n\n        # Process UCLO returns. Prefer breaks when possible.\n        for blocks, i in state.jumps:\n            use_break = False\n\n            block = blocks[i]\n            warp = block.warp\n            target = warp.target\n\n            for start, end in state.loops:\n                if end == target:\n                    use_break = blocks.index(start) < i\n                    break\n\n            if use_break:\n                statement = nodes.Break()\n            elif not target.contents:\n                warnings.warn('target.contents is empty, skip blocks')\n                continue\n            else:\n                statement = target.contents[0]\n                target.contents = []\n\n            block.contents.append(statement)\n            statement._addr = block.last_address\n\n            warp.type = nodes.UnconditionalWarp.T_FLOW\n            warp.target = blocks[i + 1]\n\n    def visit_statements_list(self, node):\n        blocks = node.contents\n\n        fixed = []\n        index_shift = 0\n\n        for i, block in enumerate(node.contents):\n            warp = block.warp\n            fixed.append(block)\n\n            block.index += index_shift\n\n            is_loop_warp = True\n            if isinstance(warp, nodes.IteratorWarp):\n                self._swap_iterator_warps(blocks, block)\n            elif isinstance(warp, nodes.NumericLoopWarp):\n                self._swap_numeric_loop_warps(blocks, block)\n            else:\n                is_loop_warp = False\n\n            if is_loop_warp:\n                self._states[-1].loops.append((warp.body, warp.way_out))\n                continue\n\n            if isinstance(warp, nodes.UnconditionalWarp) \\\n                    and warp.is_uclo:\n                assert block != node.contents[-1]\n                self._fix_uclo_return(node.contents, i)\n\n            if not isinstance(warp, nodes.ConditionalWarp):\n                continue\n\n            if warp.true_target != warp.false_target:\n                self._simplify_unreachable_conditional_warps(blocks, i)\n                continue\n\n            slot = getattr(warp, \"_slot\", -1)\n\n            if slot < 0:\n                continue\n\n            next_index = block.index - index_shift + 1\n            assert block.warp.false_target.index == next_index\n\n            new_block = self._create_dummy_block(block, slot)\n\n            fixed.append(new_block)\n\n            index_shift += 1\n\n        node.contents = fixed\n\n    def _fix_uclo_return(self, blocks, i):\n        block = blocks[i]\n        warp = block.warp\n        target = warp.target\n\n        if len(target.contents) != 1:\n            return\n\n        statement = target.contents[0]\n\n        if not isinstance(statement, nodes.Return):\n            return\n\n        if block.contents and \\\n                isinstance(block.contents[-1], nodes.Return):\n            return\n\n        self._states[-1].jumps.append((blocks, i))\n\n    @staticmethod\n    def _create_dummy_block(block, slot):\n        new_block = nodes.Block()\n        new_block.first_address = block.last_address\n        new_block.last_address = new_block.first_address\n        new_block.index = block.index + 1\n        new_block.warpins_count = 1\n\n        new_block.warp = nodes.UnconditionalWarp()\n        new_block.warp.type = nodes.UnconditionalWarp.T_FLOW\n        new_block.warp.target = block.warp.false_target\n\n        statement = nodes.Assignment()\n\n        identifier = nodes.Identifier()\n        identifier.type = nodes.Identifier.T_SLOT\n        identifier.slot = slot\n\n        statement.destinations.contents.append(identifier)\n        statement.expressions.contents.append(copy.copy(identifier))\n\n        new_block.contents.append(statement)\n\n        block.warp.true_target = new_block\n\n        return new_block\n\n    @staticmethod\n    def _swap_iterator_warps(blocks, end):\n        warp = end.warp\n        index = blocks.index(warp.body)\n\n        assert index > 0\n\n        start = blocks[index - 1]\n\n        assert isinstance(start.warp, nodes.UnconditionalWarp)\n        assert start.warp.type == nodes.UnconditionalWarp.T_JUMP\n        assert start.warp.target == end\n\n        end_addr = end.warp._addr\n        start_addr = start.warp._addr\n\n        new_end_warp = start.warp\n        new_end_warp._addr = end_addr\n\n        new_start_warp = end.warp\n        new_start_warp._addr = start_addr\n\n        end.warp = new_end_warp\n        start.warp = new_start_warp\n\n        new_end_warp.target = start\n\n    @staticmethod\n    def _swap_numeric_loop_warps(blocks, end):\n        warp = end.warp\n        index = blocks.index(warp.body)\n\n        assert index > 0\n\n        start = blocks[index - 1]\n\n        assert isinstance(start.warp, nodes.UnconditionalWarp)\n        assert start.warp.type == nodes.UnconditionalWarp.T_FLOW\n        assert start.warp.target == warp.body\n\n        end_addr = end.warp._addr\n        start_addr = start.warp._addr\n\n        new_end_warp = start.warp\n        new_end_warp._addr = end_addr\n\n        new_start_warp = end.warp\n        new_start_warp._addr = start_addr\n\n        end.warp = new_end_warp\n        start.warp = new_start_warp\n\n        new_end_warp.type = nodes.UnconditionalWarp.T_JUMP\n        new_end_warp.target = start\n\n    @staticmethod\n    def _simplify_unreachable_conditional_warps(blocks, i):\n        block = blocks[i]\n        target = block.warp.true_target\n\n        if not target:\n            return\n\n        node = target\n        while node:\n            warp = target.warp\n            if not isinstance(warp, nodes.UnconditionalWarp):\n                return\n\n            if warp.type == nodes.UnconditionalWarp.T_FLOW:\n                return\n\n            if target.contents:\n                if len(target.contents) > 1:\n                    return\n\n                if not isinstance(target.contents[0], nodes.NoOp):\n                    return\n\n            if node != target:\n                break\n\n            node = warp.target\n\n        if not isinstance(node.warp, nodes.UnconditionalWarp):\n            return\n\n        if node.warp.target != block.warp.false_target:\n            return\n\n        old_block_index = blocks.index(node)\n        next_block = blocks[old_block_index + 1]\n\n        next_block.warpins_count += 1\n        node.warp.target.warpins_count -= 1\n\n        del blocks[old_block_index]\n\n        # Change block to restore the false condition\n        new_warp = nodes.ConditionalWarp()\n        new_warp.true_target = next_block\n        new_warp.false_target = block.warp.false_target\n        false_cond = nodes.Identifier()\n        false_cond.slot = SLOT_FALSE\n        false_cond.type = false_cond.T_SLOT\n        new_warp.condition = false_cond\n        setattr(new_warp, \"_slot\", SLOT_FALSE)\n        setattr(new_warp, \"_addr\", getattr(block.warp, \"_addr\", None))\n        target.warp = new_warp\n        target.last_address += 1\n        del target.contents[0]  # remove noop", "\n\nclass MutatorVisitor(traverse.Visitor):\n    # ##\n\n    def leave_if(self, node):\n        if len(node.else_block.contents) != 1:\n            return\n\n        subif = node.else_block.contents[0]\n\n        if not isinstance(subif, nodes.If):\n            return\n\n        elseif = nodes.ElseIf()\n        if hasattr(subif, \"_decompilation_error_here\"):\n            setattr(elseif, \"_decompilation_error_here\", True)\n        elseif.expression = subif.expression\n        elseif.then_block = subif.then_block\n\n        node.elseifs.append(elseif)\n        node.elseifs += subif.elseifs\n        node.else_block = subif.else_block\n\n    def visit_statements_list(self, node):\n        patched = []\n\n        i = -1\n\n        while i < len(node.contents) - 1:\n            i += 1\n            statement = node.contents[i]\n\n            patched.append(statement)\n\n            if not isinstance(statement, nodes.Assignment):\n                continue\n\n            src = statement.expressions.contents[0]\n\n            if not isinstance(src, nodes.TableConstructor):\n                continue\n\n            assert len(statement.destinations.contents) == 1\n\n            dst = statement.destinations.contents[0]\n\n            i += self._fill_constructor(dst, src, node.contents[i + 1:])\n\n        node.contents = patched\n\n    @staticmethod\n    def _fill_constructor(table, constructor, statements):\n        consumed = 0\n\n        for statement in statements:\n            if not isinstance(statement, nodes.Assignment):\n                break\n\n            if len(statement.destinations.contents) > 1:\n                break\n\n            dst = statement.destinations.contents[0]\n\n            if not isinstance(dst, nodes.GetItem):\n                break\n\n            if not is_equal(dst.table, table, False):\n                break\n\n            assert len(statement.expressions.contents) == 1\n\n            src = statement.expressions.contents[0]\n\n            if has_same_table(src, table):\n                break\n\n            success = insert_table_record(constructor, dst.key, src, False)\n\n            if not success:\n                break\n            consumed += 1\n\n        return consumed", "\n\ndef pre_pass(ast):\n    traverse.traverse(SimpleLoopWarpSwapper(), ast)\n\n    return ast\n\n\ndef primary_pass(ast):\n    traverse.traverse(MutatorVisitor(), ast)\n\n    return ast", "def primary_pass(ast):\n    traverse.traverse(MutatorVisitor(), ast)\n\n    return ast\n"]}
{"filename": "ljd/ast/__init__.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n"]}
{"filename": "ljd/ast/locals.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\nimport copy\n\nimport ljd.ast.nodes as nodes\nimport ljd.ast.traverse as traverse\n\n\ndef mark_locals(ast, alt_mode=False):\n    traverse.traverse(_LocalsMarker(alt_mode), ast)", "\n\ndef mark_locals(ast, alt_mode=False):\n    traverse.traverse(_LocalsMarker(alt_mode), ast)\n\n\ndef mark_local_definitions(ast):\n    traverse.traverse(_LocalDefinitionsMarker(), ast)\n\n", "\n\nLIST_TYPES = (nodes.VariablesList,\n              nodes.IdentifiersList,\n              nodes.ExpressionsList,\n              nodes.StatementsList)\n\n\ndef _get_holder(path):\n    for idx, node in enumerate(reversed(path[:-1])):\n        if not isinstance(node, LIST_TYPES):\n            return node, len(path) - 2 - idx\n\n    return None, -1", "def _get_holder(path):\n    for idx, node in enumerate(reversed(path[:-1])):\n        if not isinstance(node, LIST_TYPES):\n            return node, len(path) - 2 - idx\n\n    return None, -1\n\n\nclass _LocalsMarker(traverse.Visitor):\n    class _State:\n        def __init__(self):\n            self.pending_slots = {}\n            self.debuginfo = None\n            self.addr = -1\n\n    def __init__(self, alt_mode=False):\n        super().__init__()\n        self._states = []\n        self._alt_mode = alt_mode\n\n    # ##\n\n    def _push_state(self):\n        self._states.append(_LocalsMarker._State())\n\n    def _pop_state(self):\n        self._states.pop()\n\n    def _state(self):\n        return self._states[-1]\n\n    def _process_slots(self, addr):\n        debuginfo = self._state().debuginfo\n\n        cleanup = []\n\n        for slot, pending_slot_nodes in self._state().pending_slots.items():\n            varinfo = debuginfo.lookup_local_name(addr, slot, self._alt_mode)\n\n            if varinfo is None:\n                continue\n\n            cleanup.append(slot)\n\n            if varinfo.type == varinfo.T_INTERNAL:\n                continue\n\n            for node in pending_slot_nodes:\n                node.name = varinfo.name\n                node.type = node.T_LOCAL\n\n                setattr(node, \"_varinfo\", varinfo)\n\n        for slot in cleanup:\n            del self._state().pending_slots[slot]\n\n    def _reset_slot(self, slot):\n        self._state().pending_slots.pop(slot, None)\n\n    def _reset_all(self, slots):\n        for slot in slots:\n            if isinstance(slot, nodes.Identifier):\n                self._reset_slot(slot.slot)\n\n    # ##\n\n    def _get_addr(self, node):\n        addr = getattr(node, \"_addr\", None)\n\n        if not addr:\n            if isinstance(node, nodes.Assignment):\n                return self._get_addr(node.destinations.contents[0])\n            elif isinstance(node, nodes.If):\n                return self._get_addr(node.expression)\n            elif isinstance(node, nodes.UnaryOperator):\n                return self._get_addr(node.operand)\n            elif isinstance(node, nodes.BinaryOperator):\n                return self._get_addr(node.left) or self._get_addr(node.right)\n\n        return addr\n\n    # ##\n\n    def visit_function_definition(self, node):\n        self._push_state()\n        self._state().debuginfo = node._debuginfo\n\n    def leave_function_definition(self, node):\n        addr = node._instructions_count\n        if self._alt_mode:\n            addr -= 1\n        self._process_slots(addr)\n\n        self._pop_state()\n\n    # ##\n\n    def visit_variables_list(self, node):\n        # Last chance for a local = local + 1 type assignments\n        self._process_slots(self._state().addr)\n        self._reset_all(node.contents)\n\n    def visit_identifiers_list(self, node):\n        self._reset_all(node.contents)\n\n    def visit_numeric_loop_warp(self, node):\n        self._reset_slot(node.index.slot)\n\n    def leave_numeric_for(self, node):\n        if self._alt_mode:\n            addr = self._get_addr(node)\n            if addr:\n                self._process_slots(addr)\n\n    def leave_iterator_for(self, node):\n        if self._alt_mode:\n            addr = self._get_addr(node)\n            if addr:\n                self._process_slots(addr)\n\n    def leave_assignment(self, node):\n        if self._alt_mode:\n            for exp in node.destinations.contents:\n                self._process_slots(self._state().addr + 1)\n                self._process_slots(self._state().addr + 2)\n\n    # ##\n\n    def visit_identifier(self, node):\n        if node.type == nodes.Identifier.T_SLOT:\n            queue = self._state().pending_slots\n            slots = queue.setdefault(node.slot, [])\n\n            slots.append(node)\n\n    # ##\n\n    def _process_worthy_node(self, node):\n        addr = getattr(node, \"_addr\", None)\n\n        if not isinstance(node, nodes.Identifier) and addr is not None:\n            # TODO This was an assertion, but it doesn't always hold up. Why was this required?\n            if self._state().addr < addr:\n                self._state().addr = addr\n            if not self._alt_mode:\n                self._process_slots(addr)\n\n    # We need to process slots twice as it could be the last\n    # statement in the function/block and it could be an assignment\n    # as well so we need to process slots before the reset\n\n    def _leave_node(self, handler, node):\n        traverse.Visitor._leave_node(self, handler, node)\n\n        self._process_worthy_node(node)\n\n    def _visit_node(self, handler, node):\n        self._process_worthy_node(node)\n\n        traverse.Visitor._visit_node(self, handler, node)", "class _LocalsMarker(traverse.Visitor):\n    class _State:\n        def __init__(self):\n            self.pending_slots = {}\n            self.debuginfo = None\n            self.addr = -1\n\n    def __init__(self, alt_mode=False):\n        super().__init__()\n        self._states = []\n        self._alt_mode = alt_mode\n\n    # ##\n\n    def _push_state(self):\n        self._states.append(_LocalsMarker._State())\n\n    def _pop_state(self):\n        self._states.pop()\n\n    def _state(self):\n        return self._states[-1]\n\n    def _process_slots(self, addr):\n        debuginfo = self._state().debuginfo\n\n        cleanup = []\n\n        for slot, pending_slot_nodes in self._state().pending_slots.items():\n            varinfo = debuginfo.lookup_local_name(addr, slot, self._alt_mode)\n\n            if varinfo is None:\n                continue\n\n            cleanup.append(slot)\n\n            if varinfo.type == varinfo.T_INTERNAL:\n                continue\n\n            for node in pending_slot_nodes:\n                node.name = varinfo.name\n                node.type = node.T_LOCAL\n\n                setattr(node, \"_varinfo\", varinfo)\n\n        for slot in cleanup:\n            del self._state().pending_slots[slot]\n\n    def _reset_slot(self, slot):\n        self._state().pending_slots.pop(slot, None)\n\n    def _reset_all(self, slots):\n        for slot in slots:\n            if isinstance(slot, nodes.Identifier):\n                self._reset_slot(slot.slot)\n\n    # ##\n\n    def _get_addr(self, node):\n        addr = getattr(node, \"_addr\", None)\n\n        if not addr:\n            if isinstance(node, nodes.Assignment):\n                return self._get_addr(node.destinations.contents[0])\n            elif isinstance(node, nodes.If):\n                return self._get_addr(node.expression)\n            elif isinstance(node, nodes.UnaryOperator):\n                return self._get_addr(node.operand)\n            elif isinstance(node, nodes.BinaryOperator):\n                return self._get_addr(node.left) or self._get_addr(node.right)\n\n        return addr\n\n    # ##\n\n    def visit_function_definition(self, node):\n        self._push_state()\n        self._state().debuginfo = node._debuginfo\n\n    def leave_function_definition(self, node):\n        addr = node._instructions_count\n        if self._alt_mode:\n            addr -= 1\n        self._process_slots(addr)\n\n        self._pop_state()\n\n    # ##\n\n    def visit_variables_list(self, node):\n        # Last chance for a local = local + 1 type assignments\n        self._process_slots(self._state().addr)\n        self._reset_all(node.contents)\n\n    def visit_identifiers_list(self, node):\n        self._reset_all(node.contents)\n\n    def visit_numeric_loop_warp(self, node):\n        self._reset_slot(node.index.slot)\n\n    def leave_numeric_for(self, node):\n        if self._alt_mode:\n            addr = self._get_addr(node)\n            if addr:\n                self._process_slots(addr)\n\n    def leave_iterator_for(self, node):\n        if self._alt_mode:\n            addr = self._get_addr(node)\n            if addr:\n                self._process_slots(addr)\n\n    def leave_assignment(self, node):\n        if self._alt_mode:\n            for exp in node.destinations.contents:\n                self._process_slots(self._state().addr + 1)\n                self._process_slots(self._state().addr + 2)\n\n    # ##\n\n    def visit_identifier(self, node):\n        if node.type == nodes.Identifier.T_SLOT:\n            queue = self._state().pending_slots\n            slots = queue.setdefault(node.slot, [])\n\n            slots.append(node)\n\n    # ##\n\n    def _process_worthy_node(self, node):\n        addr = getattr(node, \"_addr\", None)\n\n        if not isinstance(node, nodes.Identifier) and addr is not None:\n            # TODO This was an assertion, but it doesn't always hold up. Why was this required?\n            if self._state().addr < addr:\n                self._state().addr = addr\n            if not self._alt_mode:\n                self._process_slots(addr)\n\n    # We need to process slots twice as it could be the last\n    # statement in the function/block and it could be an assignment\n    # as well so we need to process slots before the reset\n\n    def _leave_node(self, handler, node):\n        traverse.Visitor._leave_node(self, handler, node)\n\n        self._process_worthy_node(node)\n\n    def _visit_node(self, handler, node):\n        self._process_worthy_node(node)\n\n        traverse.Visitor._visit_node(self, handler, node)", "\n\nclass _LocalDefinitionsMarker(traverse.Visitor):\n    class _State:\n        def __init__(self):\n            self.known_locals = [None] * 255\n            self.addr = 0\n\n    def __init__(self):\n        super().__init__()\n        self._states = []\n        self._path = []\n\n    def _push_state(self):\n        self._states.append(_LocalDefinitionsMarker._State())\n\n    def _pop_state(self):\n        self._states.pop()\n\n    def _state(self):\n        return self._states[-1]\n\n    def _update_known_locals(self, local, addr):\n        state = self._state()\n        varinfo = state.known_locals[local.slot]\n\n        state.known_locals[local.slot] = getattr(local,\n                                                         \"_varinfo\",\n                                                         None)\n\n        if varinfo is None:\n            return False\n\n        if varinfo.end_addr <= addr:\n            return False\n\n        return True\n\n    # ##\n\n    def visit_function_definition(self, node):\n        self._push_state()\n\n        for local in node.arguments.contents:\n            if not isinstance(local, nodes.Vararg):\n                self._update_known_locals(local, 1)\n\n    def leave_function_definition(self, node):\n        self._pop_state()\n\n    def visit_iterator_for(self, node):\n        addr = node._addr\n\n        for local in node.identifiers.contents:\n            if local.type == nodes.Identifier.T_LOCAL:\n                self._update_known_locals(local, addr)\n\n    def visit_numeric_for(self, node):\n        addr = node._addr\n\n        if node.variable.type == nodes.Identifier.T_LOCAL:\n            self._update_known_locals(node.variable, addr)\n\n    # ##\n\n    def visit_assignment(self, node):\n        dst = node.destinations.contents[0]\n\n        addr = self._state().addr\n        dst_addr = getattr(dst, \"_addr\", addr)\n\n        # Update address if necessary\n        if addr != dst_addr:\n            self._state().addr = dst_addr\n            addr = dst_addr\n\n        if not isinstance(dst, nodes.Identifier):\n            return\n\n        if dst.type != nodes.Identifier.T_LOCAL:\n            return\n\n        known_slot = self._update_known_locals(dst, addr)\n\n        for slot_index, slot in enumerate(node.destinations.contents[1:]):\n            slot_is_local = isinstance(slot, nodes.Identifier) and slot.type == nodes.Identifier.T_LOCAL\n            also_known = slot_is_local and self._update_known_locals(slot, addr)\n\n            if not known_slot and (not slot_is_local or also_known):\n                # Slot is not known, so it cannot be in the same assignment\n                new_node = copy.copy(node)\n                new_node.destinations = nodes.VariablesList()\n                new_node.destinations.contents = node.destinations.contents[slot_index + 1:]\n                node.destinations.contents = node.destinations.contents[:slot_index + 1]\n\n                # Find node in the holder\n                _, idx = _get_holder(self._path)\n                contents = self._path[idx + 1].contents\n\n                for node_index, child_node in enumerate(contents):\n                    if node != child_node:\n                        continue\n\n                    contents.insert(node_index + 1, new_node)\n\n                # Split off the bad parts, so what remains is good for a local declaration\n                break\n\n            elif not slot_is_local:\n                return\n\n            assert known_slot == also_known\n\n        if not known_slot:\n            node.type = nodes.Assignment.T_LOCAL_DEFINITION\n\n    def _visit_node(self, handler, node):\n        self._path.append(node)\n\n        traverse.Visitor._visit_node(self, handler, node)\n\n    def _leave_node(self, handler, node):\n        self._path.pop()\n\n        traverse.Visitor._leave_node(self, handler, node)\n\n    def _visit(self, node):\n        node_addr = getattr(node, \"_addr\", -1)\n\n        if node_addr >= 0:\n            self._state().addr = node_addr\n\n        traverse.Visitor._visit(self, node)", ""]}
{"filename": "ljd/ast/nodes.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\n\n\n# We should visit stuff in it's execution order. That's important\nfrom functools import lru_cache\nimport warnings\n\nfrom ljd.ast.traverse import Visitor", "\nfrom ljd.ast.traverse import Visitor\n\n\n@lru_cache()\ndef subclass_name_mapping(cls):\n    mapping = {}\n    for subcls in cls.__subclasses__():\n        name = subcls.__name__\n        if name in mapping:\n            warnings.warn('Found duplicate class: %s %s', mapping[name], subcls)\n        mapping[name] = subcls\n        for subname, subsubcls in subclass_name_mapping(subcls).items():\n            mapping[subname] = subsubcls\n    return mapping", "\n\ndef to_dict(obj, visited=None):\n    if visited is None:\n        visited = set()\n    if isinstance(obj, list):\n        return [to_dict(item, visited) for item in obj]\n    if not isinstance(obj, AstNode):\n        return obj\n\n    objid = id(obj)\n    if objid in visited:\n        return {'class': 'Ref', '_id': objid}\n    visited.add(objid)\n\n    d = {'class': obj.__class__.__name__, '_id': objid}\n    for name in obj._slots:\n        slot = getattr(obj, name, None)\n        d[name] = to_dict(slot, visited)\n    return d", "\n\ndef load_dict(data, mapping={}):\n    if isinstance(data, list):\n        return [load_dict(item, mapping) for item in data]\n    if not isinstance(data, dict):\n        return data\n    cls_map = subclass_name_mapping(AstNode)\n    data = data.copy()\n    cls_name = data.pop('class')\n    obj_id = data.pop('_id')\n    if cls_name == 'Ref':\n        return mapping[obj_id]\n    subcls = cls_map[cls_name]\n    mapping[obj_id] = res = subcls()\n    for key in data:\n        setattr(res, key, load_dict(data[key], mapping))\n    return res", "\n\nclass AstNode(object):\n    _slots = []\n\n    def __str__(self) -> str:\n        contains = []\n        for key in self._slots:\n            item = getattr(self, key, None)\n            if isinstance(item, (StatementsList, list)):\n                key = '%d %s' % (len(item), key)\n            contains.append(key)\n        if contains:\n            contains = ': ' + ', '.join(contains)\n        else:\n            contains = ''\n        return '%s(%s%s)' % (self.__class__.__name__, id(self), contains)\n\n    def __repr__(self):\n        return '%s(%s)' % (self.__class__.__name__, id(self))\n\n    def to_dict(self):\n        return to_dict(self)\n\n    @staticmethod\n    def load_dict(data):\n        return load_dict(data)", "\n\nclass FunctionDefinition(AstNode):\n    _slots = ['arguments', 'statements']\n\n    def __init__(self):\n        self.arguments = IdentifiersList()\n        self.statements = StatementsList()\n\n        self._upvalues = None\n        self._debuginfo = None\n        self._instructions_count = 0\n\n        # If there was an exception parsing this function (eg, invalid bytecodes) and catch asserts is\n        # enabled, the parsing error will be stored here and the rest of the function will be left empty.\n        self.error = None\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_function_definition, self)\n\n        visitor._visit(self.arguments)\n        visitor._visit(self.statements)\n\n        visitor._leave_node(visitor.leave_function_definition, self)\n\n    def __str__(self) -> str:\n        return 'FunctionDef(%s, %s)' % (self.arguments, self.statements)\n\n    __repr__ = __str__", "\n\nclass Block(AstNode):\n    _slots = ['index', 'first_address', 'last_address', 'contents', 'warp', 'loop']\n\n    def __init__(self):\n        self.index = -1\n        self.warp = None\n        self.contents = []\n        self.first_address = 0\n        self.last_address = 0\n        self.warpins_count = 0\n        self.loop = False\n\n    def _accept(self, visitor: Visitor):\n        visitor._visit_node(visitor.visit_block, self)\n\n        visitor._visit_list(self.contents)\n        visitor._visit(self.warp)\n\n        visitor._leave_node(visitor.leave_block, self)\n\n    def __str__(self):\n        return (\n            \"{Block: {index: \"\n            + str(self.index)\n            + \", warp: \"\n            + str(self.warp)\n            + \", contents: \"\n            + str(self.contents)\n            + \", first_address: \"\n            + str(self.first_address)\n            + \", last_address: \"\n            + str(self.last_address)\n            + \", warpins_count: \"\n            + str(self.warpins_count)\n            + \", loop: \"\n            + str(self.loop)\n            + \"}}\"\n        )\n\n    __repr__ = __str__", "\n\nclass TableConstructor(AstNode):\n    _slots = ['array', 'records']\n    anti_loop = set()\n    cur_visitor = None\n\n    def __init__(self):\n        self.array = RecordsList()\n        self.records = RecordsList()\n\n    def _accept(self, visitor):\n        if TableConstructor.cur_visitor is not None:\n            if TableConstructor.cur_visitor != visitor:\n                TableConstructor.cur_visitor = visitor\n                TableConstructor.anti_loop.clear()\n        else:\n            TableConstructor.cur_visitor = visitor\n\n        if self in TableConstructor.anti_loop:\n            return\n\n        TableConstructor.anti_loop.add(self)\n\n        visitor._visit_node(visitor.visit_table_constructor, self)\n\n        visitor._visit(self.array)\n        visitor._visit(self.records)\n\n        visitor._leave_node(visitor.leave_table_constructor, self)\n\n    def __str__(self) -> str:\n        return 'Table(...)'", "\n\nclass ArrayRecord(AstNode):\n    _slots = ['value']\n\n    def __init__(self):\n        self.value = None\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_array_record, self)\n\n        visitor._visit(self.value)\n\n        visitor._leave_node(visitor.leave_array_record, self)", "\n\nclass TableRecord(AstNode):\n    _slots = ['key', 'value']\n\n    def __init__(self):\n        self.key = None\n        self.value = None\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_table_record, self)\n\n        visitor._visit(self.key)\n        visitor._visit(self.value)\n\n        visitor._leave_node(visitor.leave_table_record, self)", "\n\nclass Assignment(AstNode):\n    _slots = ['destinations', 'expressions']\n\n    T_LOCAL_DEFINITION = 0\n    T_NORMAL = 1\n\n    def __init__(self):\n        self.expressions = ExpressionsList()\n        self.destinations = VariablesList()\n        self.type = -1\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_assignment, self)\n\n        visitor._visit(self.expressions)\n        visitor._visit(self.destinations)\n\n        visitor._leave_node(visitor.leave_assignment, self)\n\n    def __str__(self):\n        typ = [\"LOCAL\", \"NORMAL\"][self.type]\n        return \"Assignment<%s>(%s, %s)\" % (typ, self.destinations, self.expressions)\n\n    __repr__ = __str__", "\n\nclass BinaryOperator(AstNode):\n    _slots = ['left', 'type', 'right']\n\n    name_map = {\n        0: 'or',\n        10: 'and',\n        20: 'lt',\n        21: 'gt',\n        22: 'le',\n        23: 'ge',\n        24: 'ne',\n        25: 'eq',\n        30: 'concat',\n        40: 'add',\n        41: 'subtract',\n        50: 'multiply',\n        51: 'divide',\n        52: 'mod',\n        70: 'pow',\n    }\n    T_LOGICAL_OR = 0  # left or right\n    T_LOGICAL_AND = 10  # left and right\n\n    T_LESS_THEN = 20  # left < right\n    T_GREATER_THEN = 21  # left > right\n    T_LESS_OR_EQUAL = 22  # left <= right\n    T_GREATER_OR_EQUAL = 23  # left >= right\n\n    T_NOT_EQUAL = 24  # left ~= right\n    T_EQUAL = 25  # left == right\n\n    T_CONCAT = 30  # left .. right\n\n    T_ADD = 40  # left + right\n    T_SUBTRACT = 41  # left - right\n\n    T_MULTIPLY = 50  # left * right\n    T_DIVISION = 51  # left / right\n    T_MOD = 52  # left % right\n\n    T_POW = 70  # left ^ right\n\n    # Precedences are shared with UnaryOperator\n    PR_OR = 1\n    PR_AND = 2\n    PR_COMPARISON = 3\n    PR_CONCATENATE = 4\n    PR_MATH_ADDSUB = 5\n    PR_MATH = 6\n    PR_UNARY = 7\n    PR_EXPONENT = 8\n\n    def __init__(self):\n        self.type = -1\n        self.left = None\n        self.right = None\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_binary_operator, self)\n\n        visitor._visit(self.left)\n        visitor._visit(self.right)\n\n        visitor._leave_node(visitor.leave_binary_operator, self)\n\n    # Use this instead of the type field, as stuff like + and - have the same precedence this way\n    def precedence(self):\n        # Note that print(1 or 2 and false) prints 1\n        if self.type <= self.T_LOGICAL_OR:\n            return BinaryOperator.PR_OR\n\n        elif self.type <= self.T_LOGICAL_AND:\n            return BinaryOperator.PR_AND\n\n        elif self.type <= self.T_EQUAL:\n            return BinaryOperator.PR_COMPARISON\n\n        elif self.type <= self.T_CONCAT:\n            return BinaryOperator.PR_CONCATENATE\n\n        elif self.type <= self.T_SUBTRACT:\n            return BinaryOperator.PR_MATH_ADDSUB\n\n        elif self.type <= self.T_MOD:\n            return BinaryOperator.PR_MATH\n\n        elif self.type <= self.T_POW:\n            return BinaryOperator.PR_EXPONENT\n\n        else:\n            raise ValueError('invalid type %d' % self.type)\n\n    def is_right_associative(self):\n        if self.type == self.T_CONCAT:\n            # Although this is right-associative per the Lua manual, since that\n            #  doesn't matter here since `(\"a\" .. \"b\") .. \"c\"` is the same as `\"a\" .. (\"b\" .. \"c\")`,\n            #  LuaJIT doesn't consider it to be right-associative and thus groups it accordingly. Hence,\n            #  setting this to True results in unnecessary braces being introduced.\n            return False\n\n        elif self.type == self.T_POW:\n            return True\n\n        else:\n            return False\n\n    def is_commutative(self):\n        if self.type <= self.T_LOGICAL_AND:\n            return True\n\n        elif self.type <= self.T_GREATER_OR_EQUAL:\n            return False\n\n        elif self.type <= self.T_EQUAL:\n            return True\n\n        elif self.type <= self.T_CONCAT:\n            return False\n\n        elif self.type <= self.T_ADD:\n            return True\n\n        elif self.type <= self.T_SUBTRACT:\n            return False\n\n        elif self.type <= self.T_MULTIPLY:\n            return True\n\n        elif self.type <= self.T_MOD:\n            return False\n\n        elif self.type <= self.T_POW:\n            return False\n\n        else:\n            assert False\n\n    def __str__(self):\n        op = self.name_map.get(self.type, self.type)\n        return 'BinOp({} {} {})'.format(self.left, op, self.right)", "\n\nclass UnaryOperator(AstNode):\n    _slots = ['type', 'operand']\n\n    name_map = {60: 'not', 61: 'len', 62: 'minus', 63: 'str', 64: 'number'}\n    T_NOT = 60  # not operand\n    T_LENGTH_OPERATOR = 61  # #operand\n    T_MINUS = 62  # -operand\n\n    # Only available on bytecode revision 2 (LuaJIT 2.1)\n    # This used to be if'd off so accessing it would be\n    # an error, that is unfortunately no longer possible\n    # due to the switchable version system.\n    T_TOSTRING = 63  # tostring()\n    T_TONUMBER = 64  # tonumber()\n\n    def __init__(self):\n        self.type = -1\n        self.operand = None\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_unary_operator, self)\n\n        visitor._visit(self.operand)\n\n        visitor._leave_node(visitor.leave_unary_operator, self)\n\n    def precedence(self):\n        return BinaryOperator.PR_UNARY\n\n    def __str__(self):\n        op = self.name_map.get(self.type, self.type)\n        return 'BinOp({} {})'.format(op, self.operand)", "\n\nclass StatementsList(AstNode):\n    _slots = ['contents']\n\n    def __init__(self):\n        self.contents = []\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_statements_list, self)\n\n        visitor._visit_list(self.contents)\n\n        visitor._leave_node(visitor.leave_statements_list, self)\n\n    def __str__(self):\n        items = [str(c) for c in self.contents]\n        return '%s(\\n%s\\n)' % (self.__class__.__name__, '\\n'.join(items))\n\n    __repr__ = __str__\n\n    def __len__(self):\n        return len(self.contents)", "\n\nclass IdentifiersList(StatementsList):\n    def __init__(self):\n        self.contents = []\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_identifiers_list, self)\n\n        visitor._visit_list(self.contents)\n\n        visitor._leave_node(visitor.leave_identifiers_list, self)", "\n\nclass RecordsList(StatementsList):\n    def __init__(self):\n        self.contents = []\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_records_list, self)\n\n        visitor._visit_list(self.contents)\n\n        visitor._leave_node(visitor.leave_records_list, self)", "\n\nclass VariablesList(StatementsList):\n    def __init__(self):\n        self.contents = []\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_variables_list, self)\n\n        visitor._visit_list(self.contents)\n\n        visitor._leave_node(visitor.leave_variables_list, self)", "\n\nclass ExpressionsList(StatementsList):\n    def __init__(self):\n        self.contents = []\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_expressions_list, self)\n\n        visitor._visit_list(self.contents)\n\n        visitor._leave_node(visitor.leave_expressions_list, self)", "\n\n# Called Name in the Lua 5.1 reference\nclass Identifier(AstNode):\n    _slots = ['name', 'type', 'slot', 'id']\n\n    T_SLOT = 0\n    T_LOCAL = 1\n    T_UPVALUE = 2\n    T_BUILTIN = 3\n\n    def __init__(self):\n        self.name = None\n        self.type = -1\n        self.slot = -1\n        self.id = -1\n        self._varinfo = None\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_identifier, self)\n        visitor._leave_node(visitor.leave_identifier, self)\n\n    def _slot_name(self):\n        name = str(self.slot)\n        if self.id != -1:\n            name += \"_\" + str(self.id)\n        else:\n            slot_ids = getattr(self, \"_ids\", None)\n            if slot_ids:\n                for i, slot_id in enumerate(slot_ids):\n                    name += \"_\" + str(slot_id)\n        return name\n\n    def __str__(self):\n        if self.type == Identifier.T_SLOT:\n            if self.name:\n                name = ':' + self.name\n            else:\n                name = ''\n            return \"IdentSlot(%s%s)\" % (self._slot_name(), name)\n\n        if self.type == Identifier.T_BUILTIN:\n            return \"IdentBuiltin(%s)\" % self.name\n\n        return (\n            \"{ Identifier: {name: \"\n            + str(self.name)\n            + \", type: \"\n            + [\"T_SLOT\", \"T_LOCAL\", \"T_UPVALUE\", \"T_BUILTIN\"][self.type]\n            + \", slot: \"\n            + self._slot_name()\n            + \"} }\"\n        )\n\n    __repr__ = __str__", "\n\n# helper vararg/varreturn\n\n\nclass MULTRES(AstNode):\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_multres, self)\n        visitor._leave_node(visitor.leave_multres, self)\n", "\n\nclass GetItem(AstNode):\n    _slots = ['table', 'key']\n\n    def __init__(self):\n        self.table = None\n        self.key = None\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_table_element, self)\n\n        visitor._visit(self.key)\n        visitor._visit(self.table)\n\n        visitor._leave_node(visitor.leave_table_element, self)\n\n    def __str__(self):\n        return str(self.table) + \"[\" + str(self.key) + \"]\"\n\n    def __repr__(self):\n        return \"{0}@{1}\".format(str(self.key), str(self.table))", "\n\nclass Vararg(AstNode):\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_vararg, self)\n        visitor._leave_node(visitor.leave_vararg, self)\n\n\nclass FunctionCall(AstNode):\n    _slots = ['function', 'arguments', 'is_method']\n\n    def __init__(self):\n        self.function = None\n        self.arguments = ExpressionsList()\n        self.is_method = False\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_function_call, self)\n\n        visitor._visit(self.arguments)\n        visitor._visit(self.function)\n\n        visitor._leave_node(visitor.leave_function_call, self)\n\n    def __str__(self):\n        return \"FunctionCall(%s %s)\" % (self.function, self.arguments)", "class FunctionCall(AstNode):\n    _slots = ['function', 'arguments', 'is_method']\n\n    def __init__(self):\n        self.function = None\n        self.arguments = ExpressionsList()\n        self.is_method = False\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_function_call, self)\n\n        visitor._visit(self.arguments)\n        visitor._visit(self.function)\n\n        visitor._leave_node(visitor.leave_function_call, self)\n\n    def __str__(self):\n        return \"FunctionCall(%s %s)\" % (self.function, self.arguments)", "\n\nclass If(AstNode):\n    _slots = ['expression', 'then_block', 'elseifs', 'else_block']\n\n    def __init__(self):\n        self.expression = None\n        self.then_block = StatementsList()\n        self.elseifs = []\n        self.else_block = StatementsList()\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_if, self)\n\n        visitor._visit(self.expression)\n        visitor._visit(self.then_block)\n\n        visitor._visit_list(self.elseifs)\n\n        visitor._visit(self.else_block)\n\n        visitor._leave_node(visitor.leave_if, self)", "\n\nclass ElseIf(AstNode):\n    _slots = ['expression', 'then_block']\n\n    def __init__(self):\n        self.expression = None\n        self.then_block = StatementsList()\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_elseif, self)\n\n        visitor._visit(self.expression)\n        visitor._visit(self.then_block)\n\n        visitor._leave_node(visitor.leave_elseif, self)", "\n\n# ##\n\n\nclass UnconditionalWarp(AstNode):\n    _slots = ['type', 'target', 'is_uclo']\n\n    T_JUMP = 0\n    T_FLOW = 1\n\n    def __init__(self):\n        self.type = -1\n        self.target = None\n        self.is_uclo = False\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_unconditional_warp, self)\n\n        # DO NOT VISIT self.target - warps are not part of the tree\n\n        visitor._leave_node(visitor.leave_unconditional_warp, self)", "\n\nclass ConditionalWarp(AstNode):\n    _slots = ['condition', 'true_target', 'false_target']\n\n    def __init__(self):\n        self.condition = None\n        self.true_target = None\n        self.false_target = None\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_conditional_warp, self)\n\n        visitor._visit(self.condition)\n        # DO NOT VISIT self.true_target - warps are not part of the tree\n        # DO NOT VISIT self.false_target - warps are not part of the tree\n\n        visitor._leave_node(visitor.leave_conditional_warp, self)", "\n\nclass IteratorWarp(AstNode):\n    _slots = ['variables', 'controls', 'body', 'way_out']\n\n    def __init__(self):\n        self.variables = VariablesList()\n        self.controls = ExpressionsList()\n        self.body = None\n        self.way_out = None\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_iterator_warp, self)\n\n        visitor._visit(self.variables)\n        visitor._visit(self.controls)\n        # DO NOT VISIT self.body - warps are not part of the tree\n        # DO NOT VISIT self.way_out - warps are not part of the tree\n\n        visitor._leave_node(visitor.leave_iterator_warp, self)", "\n\nclass NumericLoopWarp(AstNode):\n    _slots = ['index', 'controls', 'body', 'way_out']\n\n    def __init__(self):\n        self.index = Identifier()\n        self.controls = ExpressionsList()\n        self.body = None\n        self.way_out = None\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_numeric_loop_warp, self)\n\n        visitor._visit(self.index)\n        visitor._visit(self.controls)\n        # DO NOT VISIT self.body - warps are not part of the tree\n        # DO NOT VISIT self.way_out - warps are not part of the tree\n\n        visitor._leave_node(visitor.leave_numeric_loop_warp, self)", "\n\nclass EndWarp(AstNode):\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_end_warp, self)\n        visitor._leave_node(visitor.leave_end_warp, self)\n\n    def __str__(self):\n        return \"EndWarp\"\n\n    __repr__ = __str__", "\n\n# ##\n\n\nclass Return(AstNode):\n    _slots = ['returns']\n\n    def __init__(self):\n        self.returns = ExpressionsList()\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_return, self)\n\n        visitor._visit(self.returns)\n\n        visitor._leave_node(visitor.leave_return, self)\n\n    def __str__(self) -> str:\n        return 'Return(%s)' % self.returns\n\n    __repr__ = __str__", "\n\nclass Break(AstNode):\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_break, self)\n        visitor._leave_node(visitor.leave_break, self)\n\n\nclass While(AstNode):\n    _slots = ['expression', 'statements']\n\n    def __init__(self):\n        self.expression = None\n        self.statements = StatementsList()\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_while, self)\n\n        visitor._visit(self.expression)\n        visitor._visit(self.statements)\n\n        visitor._leave_node(visitor.leave_while, self)", "class While(AstNode):\n    _slots = ['expression', 'statements']\n\n    def __init__(self):\n        self.expression = None\n        self.statements = StatementsList()\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_while, self)\n\n        visitor._visit(self.expression)\n        visitor._visit(self.statements)\n\n        visitor._leave_node(visitor.leave_while, self)", "\n\nclass RepeatUntil(AstNode):\n    _slots = ['expression', 'statements']\n\n    def __init__(self):\n        self.expression = None\n        self.statements = StatementsList()\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_repeat_until, self)\n\n        visitor._visit(self.statements)\n        visitor._visit(self.expression)\n\n        visitor._leave_node(visitor.leave_repeat_until, self)", "\n\nclass NumericFor(AstNode):\n    _slots = ['variable', 'expression', 'statements']\n\n    def __init__(self):\n        self.variable = None\n        self.expressions = ExpressionsList()\n        self.statements = StatementsList()\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_numeric_for, self)\n\n        visitor._visit(self.variable)\n        visitor._visit(self.expressions)\n        visitor._visit(self.statements)\n\n        visitor._leave_node(visitor.leave_numeric_for, self)", "\n\nclass IteratorFor(AstNode):\n    _slots = ['expressions', 'expression', 'statements']\n\n    def __init__(self):\n        self.expressions = ExpressionsList()\n        self.identifiers = VariablesList()\n        self.statements = StatementsList()\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_iterator_for, self)\n\n        visitor._visit(self.expressions)\n        visitor._visit(self.identifiers)\n        visitor._visit(self.statements)\n\n        visitor._leave_node(visitor.leave_iterator_for, self)\n\n    def __str__(self) -> str:\n        return 'For(%s, %s, %s)' % (self.expressions, self.identifiers, self.statements)\n\n    __repr__ = __str__", "\n\nclass Constant(AstNode):\n    _slots = ['type', 'value']\n    T_INTEGER = 0\n    T_FLOAT = 1\n    T_STRING = 2\n    T_CDATA = 3\n\n    def __init__(self):\n        self.type = -1\n        self.value = None\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_constant, self)\n        visitor._leave_node(visitor.leave_constant, self)\n\n    def __str__(self):\n        return str(self.value)", "\n\nclass Primitive(AstNode):\n    _slots = ['type']\n\n    T_NIL = 0\n    T_TRUE = 1\n    T_FALSE = 2\n\n    def __init__(self):\n        self.type = -1\n\n    def _accept(self, visitor):\n        visitor._visit_node(visitor.visit_primitive, self)\n        visitor._leave_node(visitor.leave_primitive, self)\n\n    def __str__(self):\n        return [\"nil\", \"True\", \"False\"][self.type]", "\n\nclass NoOp(AstNode):\n    def _accept(self, visitor):\n        pass\n"]}
{"filename": "ljd/ast/traverse.py", "chunked_list": ["class Visitor:\n    def __init__(self):\n        pass\n\n    # ##\n\n    def visit_function_definition(self, node):\n        pass\n\n    def leave_function_definition(self, node):\n        pass\n\n    # ##\n\n    def visit_table_constructor(self, node):\n        pass\n\n    def leave_table_constructor(self, node):\n        pass\n\n    def visit_table_record(self, node):\n        pass\n\n    def leave_table_record(self, node):\n        pass\n\n    def visit_array_record(self, node):\n        pass\n\n    def leave_array_record(self, node):\n        pass\n\n    # ##\n\n    def visit_assignment(self, node):\n        pass\n\n    def leave_assignment(self, node):\n        pass\n\n    # ##\n\n    def visit_binary_operator(self, node):\n        pass\n\n    def leave_binary_operator(self, node):\n        pass\n\n    def visit_unary_operator(self, node):\n        pass\n\n    def leave_unary_operator(self, node):\n        pass\n\n    # ##\n\n    def visit_statements_list(self, node):\n        pass\n\n    def leave_statements_list(self, node):\n        pass\n\n    def visit_identifiers_list(self, node):\n        pass\n\n    def leave_identifiers_list(self, node):\n        pass\n\n    def visit_records_list(self, node):\n        pass\n\n    def leave_records_list(self, node):\n        pass\n\n    def visit_variables_list(self, node):\n        pass\n\n    def leave_variables_list(self, node):\n        pass\n\n    def visit_expressions_list(self, node):\n        pass\n\n    def leave_expressions_list(self, node):\n        pass\n\n    # ##\n\n    def visit_identifier(self, node):\n        pass\n\n    def leave_identifier(self, node):\n        pass\n\n    def visit_multres(self, node):\n        pass\n\n    def leave_multres(self, node):\n        pass\n\n    def visit_table_element(self, node):\n        pass\n\n    def leave_table_element(self, node):\n        pass\n\n    def visit_vararg(self, node):\n        pass\n\n    def leave_vararg(self, node):\n        pass\n\n    def visit_function_call(self, node):\n        pass\n\n    def leave_function_call(self, node):\n        pass\n\n    # ##\n\n    def visit_if(self, node):\n        pass\n\n    def leave_if(self, node):\n        pass\n\n    def visit_elseif(self, node):\n        pass\n\n    def leave_elseif(self, node):\n        pass\n\n    # ##\n\n    def visit_block(self, node):\n        pass\n\n    def leave_block(self, node):\n        pass\n\n    def visit_unconditional_warp(self, node):\n        pass\n\n    def leave_unconditional_warp(self, node):\n        pass\n\n    def visit_conditional_warp(self, node):\n        pass\n\n    def leave_conditional_warp(self, node):\n        pass\n\n    def visit_iterator_warp(self, node):\n        pass\n\n    def leave_iterator_warp(self, node):\n        pass\n\n    def visit_numeric_loop_warp(self, node):\n        pass\n\n    def leave_numeric_loop_warp(self, node):\n        pass\n\n    def visit_end_warp(self, node):\n        pass\n\n    def leave_end_warp(self, node):\n        pass\n\n    # ##\n\n    def visit_return(self, node):\n        pass\n\n    def leave_return(self, node):\n        pass\n\n    def visit_break(self, node):\n        pass\n\n    def leave_break(self, node):\n        pass\n\n    # ##\n\n    def visit_while(self, node):\n        pass\n\n    def leave_while(self, node):\n        pass\n\n    def visit_repeat_until(self, node):\n        pass\n\n    def leave_repeat_until(self, node):\n        pass\n\n    def visit_numeric_for(self, node):\n        pass\n\n    def leave_numeric_for(self, node):\n        pass\n\n    def visit_iterator_for(self, node):\n        pass\n\n    def leave_iterator_for(self, node):\n        pass\n\n    # ##\n\n    def visit_constant(self, node):\n        pass\n\n    def leave_constant(self, node):\n        pass\n\n    def visit_primitive(self, node):\n        pass\n\n    def leave_primitive(self, node):\n        pass\n\n    # ##\n\n    def _visit_node(self, handler, node):\n        handler(node)\n\n    def _leave_node(self, handler, node):\n        handler(node)\n\n    # ##\n\n    def _visit(self, node):\n        assert node is not None\n\n        node._accept(self)\n\n    def _visit_list(self, nodes_list):\n        assert isinstance(nodes_list, list)\n\n        for node in nodes_list:\n            self._visit(node)", "\n\ndef traverse(visitor: Visitor, node):\n    if isinstance(node, list):\n        visitor._visit_list(node)\n    else:\n        visitor._visit(node)\n"]}
{"filename": "ljd/ast/builder.py", "chunked_list": ["#\n# Copyright (C) 2013 Andrian Nord. See Copyright Notice in main.py\n#\nimport warnings\n\nimport ljd.ast.nodes as nodes\nimport ljd.bytecode.instructions as ins\nimport ljd\nfrom ljd.bytecode.constants import T_FALSE, T_NIL, T_TRUE\nfrom ljd.bytecode.helpers import get_jump_destination", "from ljd.bytecode.constants import T_FALSE, T_NIL, T_TRUE\nfrom ljd.bytecode.helpers import get_jump_destination\n\nhandle_invalid_functions = False\n\nclass _State:\n    def __init__(self):\n        self.constants = None\n        self.debuginfo = None\n        self.block = None\n        self.blocks = []\n        self.block_starts = {}\n        self.header = None\n\n    def _warp_in_block(self, addr):\n        block = self.block_starts[addr]\n        block.warpins_count += 1\n        return block", "\n\ndef build(header, prototype):\n    return _build_function_definition(prototype, header)\n\n\ndef _build_function_definition(prototype, header):\n    node = nodes.FunctionDefinition()\n\n    state = _State()\n\n    state.constants = prototype.constants\n    state.debuginfo = prototype.debuginfo\n    state.header = header\n\n    node._upvalues = prototype.constants.upvalue_references\n    node._debuginfo = prototype.debuginfo\n    node._instructions_count = len(prototype.instructions)\n\n    if prototype.first_line_number:\n        setattr(node, \"_lineinfo\", (prototype.first_line_number, prototype.lines_count))\n\n    node.arguments.contents = _build_function_arguments(state, prototype)\n\n    if prototype.flags.is_variadic:\n        node.arguments.contents.append(nodes.Vararg())\n\n    instructions = prototype.instructions\n    node.statements.contents = _build_function_blocks(state, instructions)\n\n    return node", "\n\ndef _build_function_arguments(state, prototype):\n    arguments = []\n\n    count = prototype.arguments_count\n\n    slot = 0\n    while slot < count:\n        variable = _build_slot(state, 0, slot)\n\n        arguments.append(variable)\n        slot += 1\n\n    return arguments", "\n\ndef _build_function_blocks(state, instructions):\n    _blockenize(state, instructions)\n    _establish_warps(state, instructions)\n\n    state.blocks[0].warpins_count = 1\n    prev_block = None\n\n    for block in state.blocks:\n        addr = block.first_address\n        state.block = block\n\n        while addr <= block.last_address:\n            instruction = instructions[addr]\n\n            # Check if this is a loop\n            # We need to do this counting until block.last_address not block._last_body_addr, as otherwise\n            # we'll often miss stuff like FORI instructions that would otherwise be trimmed off.\n            opcode = instruction.opcode\n            if ins.LOOP.opcode <= opcode <= ins.JLOOP.opcode:\n                block.loop = True\n            elif ins.FORI.opcode <= opcode <= ins.JFORI.opcode:\n                block.loop = True\n\n            if addr > block._last_body_addr:\n                addr += 1\n                continue\n\n            statement, line_marked_elements = _build_statement(state, addr, instruction)\n\n            if statement is not None:\n                line = state.debuginfo.lookup_line_number(addr)\n\n                if not line_marked_elements:\n                    line_marked_elements = []\n\n                for elem in line_marked_elements + [statement]:\n                    setattr(elem, \"_addr\", addr)\n                    setattr(elem, \"_line\", line)\n\n                block.contents.append(statement)\n\n            addr += 1\n\n        # walterr this and other fix maybe belong in mutator.SimpleLoopWarpSwapper?\n        if (len(block.contents) == 0 and\n                isinstance(block.warp, nodes.UnconditionalWarp) and\n                block.warp.type == nodes.UnconditionalWarp.T_JUMP and\n                prev_block is not None and\n                isinstance(prev_block.warp, nodes.ConditionalWarp)):\n            _create_no_op(state, block.first_address, block)\n\n        prev_block = block\n\n    return state.blocks", "\n\n# Set in init() - see it's comment\n_JUMP_WARP_INSTRUCTIONS = None\n_WARP_INSTRUCTIONS = None\n\n\ndef _blockenize(state, instructions):\n    # Fix inverted comparison expressions (e.g. 0 < variable):\n    _fix_inverted_comparison_expressions(state, instructions)\n\n    # Fix \"repeat until true\" encapsulated by another loop\n    _fix_broken_repeat_until_loops(state, instructions)\n\n    # Fix \"var_1 = var_1 [comparison] var_2 and (operation) var_1 or var_1\" edge case\n    _fix_broken_unary_expressions(state, instructions)\n\n    addr = 1\n\n    # Duplicates are possible and ok, but we need to sort them out\n    last_addresses = set()\n\n    while addr < len(instructions):\n        instruction = instructions[addr]\n        opcode = instruction.opcode\n\n        if opcode not in _WARP_INSTRUCTIONS:\n            addr += 1\n            continue\n\n        if opcode in _JUMP_WARP_INSTRUCTIONS:\n            destination = get_jump_destination(addr, instruction)\n\n            if opcode != ins.UCLO.opcode or destination != addr + 1:\n                last_addresses.add(destination - 1)\n                last_addresses.add(addr)\n        else:\n            last_addresses.add(addr)\n\n        addr += 1\n\n    last_addresses = sorted(list(last_addresses))\n    last_addresses.append(len(instructions) - 1)\n\n    # This could happen if something jumps to the first instruction\n    # We don't need \"zero block\" with function header, so simply ignore\n    # this\n    if last_addresses[0] == 0:\n        last_addresses.pop(0)\n\n    previous_last_address = 0\n\n    index = 0\n    for last_address in last_addresses:\n        block = nodes.Block()\n        block.index = index\n        block.first_address = previous_last_address + 1\n        block.last_address = last_address\n\n        state.blocks.append(block)\n        state.block_starts[block.first_address] = block\n\n        previous_last_address = last_address\n\n        index += 1", "\n\ndef _establish_warps(state, instructions):\n    state.blocks[0].warpins_count = 1\n\n    enumerated_blocks = enumerate(state.blocks[:-1])\n    for i, block in enumerated_blocks:\n        if state.blocks.__contains__(block) is None:\n            continue\n\n        state.block = block\n\n        end_addr = block.last_address + 1\n        start_addr = max(block.last_address - 1, block.first_address)\n\n        # Catch certain double unconditional jumps caused by logical primitives in expressions:\n        if start_addr == (end_addr - 1) \\\n                and end_addr + 1 < len(instructions) \\\n                and instructions[start_addr].opcode == ins.JMP.opcode \\\n                and instructions[end_addr].opcode == ins.JMP.opcode \\\n                and instructions[start_addr].A == instructions[end_addr].A \\\n                and instructions[start_addr].CD == 0:\n\n            end_instruction_destination = end_addr + instructions[end_addr].CD + 1\n            target_instruction_A = instructions[start_addr].A\n            exit_instruction_found = False\n\n            # When two consecutive jumps are found with the same A operand, lookahead for the end jump.\n            following_destination = -1\n            for j in range(end_addr + 1, len(instructions) - 1):\n                following_instruction = instructions[j]\n                if following_instruction.opcode == ins.JMP.opcode:\n                    if following_instruction.A == target_instruction_A:\n                        following_destination = get_jump_destination(j, following_instruction)\n                        exit_instruction_found = True\n                        break\n\n            # If we find the exit jump and we're not skipping it (if true then break else),\n            #  form the original two jumps into a fake conditional warp.\n            if exit_instruction_found \\\n                    and end_instruction_destination <= following_destination:\n                fixed_instruction = ins.ISF()\n                fixed_instruction.CD = ins.SLOT_FALSE\n\n                instructions[start_addr] = fixed_instruction\n                state.blocks.pop(state.blocks.index(block) + 1)\n\n                block.last_address += 1\n                start_addr = max(block.last_address - 1, block.first_address)\n                end_addr = block.last_address + 1\n\n        warp = instructions[start_addr:end_addr]\n\n        block.warp, shift = _build_warp(state, block.last_address, warp)\n\n        setattr(block, \"_last_body_addr\", block.last_address - shift)\n        setattr(block.warp, \"_addr\", block.last_address - shift + 1)\n\n    last_block = state.blocks[-1]\n    last_block.warp = nodes.EndWarp()\n\n    setattr(last_block, \"_last_body_addr\", last_block.last_address)\n    setattr(last_block.warp, \"_addr\", last_block.last_address)", "\n\ndef _build_warp(state, last_addr, instructions):\n    last = instructions[-1]\n\n    if last.opcode in (ins.JMP.opcode, ins.UCLO.opcode, ins.ISNEXT.opcode):\n        return _build_jump_warp(state, last_addr, instructions)\n\n    elif ins.ITERL.opcode <= last.opcode <= ins.JITERL.opcode:\n        assert len(instructions) == 2\n        return _build_iterator_warp(state, last_addr, instructions)\n\n    elif ins.FORL.opcode <= last.opcode <= ins.JFORL.opcode:\n        return _build_numeric_loop_warp(state, last_addr, last)\n\n    else:\n        return _build_flow_warp(state, last_addr, last)", "\n\ndef _build_jump_warp(state, last_addr, instructions):\n    last = instructions[-1]\n    opcode = 256 if len(instructions) == 1 else instructions[-2].opcode\n\n    if opcode <= ins.ISF.opcode:\n        assert last.opcode != ins.ISNEXT.opcode\n        return _build_conditional_warp(state, last_addr, instructions)\n    else:\n        return _build_unconditional_warp(state, last_addr, last)", "\n\ndef _build_conditional_warp(state, last_addr, instructions):\n    condition = instructions[-2]\n    condition_addr = last_addr - 1\n\n    warp = nodes.ConditionalWarp()\n\n    if condition.opcode in (ins.ISTC.opcode, ins.ISFC.opcode):\n        expression = _build_unary_expression(state,\n                                             condition_addr,\n                                             condition)\n\n        setattr(warp, \"_slot\", condition.A)\n    elif condition.opcode >= ins.IST.opcode:\n        expression = _build_unary_expression(state,\n                                             condition_addr,\n                                             condition)\n\n        setattr(warp, \"_slot\", condition.CD)\n    else:\n        expression = _build_comparison_expression(state,\n                                                  condition_addr,\n                                                  condition)\n\n    warp.condition = expression\n\n    jump = instructions[-1]\n    jump_addr = last_addr\n\n    destination = get_jump_destination(jump_addr, jump)\n\n    # A condition is inverted during the preparation phase above\n    warp.false_target = state._warp_in_block(destination)\n    warp.true_target = state._warp_in_block(jump_addr + 1)\n\n    shift = 2\n    if destination == (jump_addr + 1) \\\n            and condition.opcode not in (ins.ISTC.opcode, ins.ISFC.opcode):\n        # This is an empty 'then' or 'else'. The simplest way to handle it is\n        # to insert a Block containing just a no-op statement.\n        block = nodes.Block()\n        block.first_address = jump_addr + 1\n        block.last_address = block.first_address\n        block.index = warp.true_target.index\n        block.warpins_count = 1\n        setattr(block, \"_last_body_addr\", block.last_address - shift)\n\n        block.warp = nodes.UnconditionalWarp()\n        block.warp.type = nodes.UnconditionalWarp.T_FLOW\n        block.warp.target = warp.true_target\n        setattr(block.warp, \"_addr\", block.last_address - shift + 1)\n\n        state.blocks.insert(state.blocks.index(warp.true_target), block)\n        warp.true_target = block\n\n        _create_no_op(state, jump_addr, block)\n\n    return warp, shift", "\n\ndef _create_no_op(state, addr, block):\n    statement = nodes.NoOp()\n    setattr(statement, \"_addr\", addr)\n    setattr(statement, \"_line\", state.debuginfo.lookup_line_number(addr))\n    block.contents.append(statement)\n\n\ndef _build_unconditional_warp(state, addr, instruction):\n    warp = nodes.UnconditionalWarp()\n    warp.type = nodes.UnconditionalWarp.T_JUMP\n\n    opcode = instruction.opcode\n\n    warp.is_uclo = opcode == ins.UCLO.opcode\n\n    shift = 1\n    if warp.is_uclo and instruction.CD == 0:\n        # Not a jump\n        return _build_flow_warp(state, addr, instruction)\n    else:\n        destination = get_jump_destination(addr, instruction)\n        warp.target = state._warp_in_block(destination)\n\n    return warp, shift", "\ndef _build_unconditional_warp(state, addr, instruction):\n    warp = nodes.UnconditionalWarp()\n    warp.type = nodes.UnconditionalWarp.T_JUMP\n\n    opcode = instruction.opcode\n\n    warp.is_uclo = opcode == ins.UCLO.opcode\n\n    shift = 1\n    if warp.is_uclo and instruction.CD == 0:\n        # Not a jump\n        return _build_flow_warp(state, addr, instruction)\n    else:\n        destination = get_jump_destination(addr, instruction)\n        warp.target = state._warp_in_block(destination)\n\n    return warp, shift", "\n\ndef _build_iterator_warp(state, last_addr, instructions):\n    iterator = instructions[-2]\n    iterator_addr = last_addr - 1\n\n    assert iterator.opcode in (ins.ITERC.opcode, ins.ITERN.opcode)\n\n    warp = nodes.IteratorWarp()\n\n    base = iterator.A\n\n    warp.controls.contents = [\n        _build_slot(state, iterator_addr, base - 3),  # generator\n        _build_slot(state, iterator_addr, base - 2),  # state\n        _build_slot(state, iterator_addr, base - 1)  # control\n    ]\n\n    last_slot = base + iterator.B - 2\n\n    slot = base\n\n    while slot <= last_slot:\n        variable = _build_slot(state, iterator_addr - 1, slot)\n        warp.variables.contents.append(variable)\n        slot += 1\n\n    jump = instructions[-1]\n    jump_addr = last_addr\n\n    destination = get_jump_destination(jump_addr, jump)\n    warp.way_out = state._warp_in_block(jump_addr + 1)\n    warp.body = state._warp_in_block(destination)\n\n    return warp, 2", "\n\ndef _build_numeric_loop_warp(state, addr, instruction):\n    warp = nodes.NumericLoopWarp()\n\n    base = instruction.A\n\n    warp.index = _build_slot(state, addr, base + 3)\n    warp.controls.contents = [\n        _build_slot(state, addr, base + 0),  # start\n        _build_slot(state, addr, base + 1),  # limit\n        _build_slot(state, addr, base + 2)  # step\n    ]\n\n    destination = get_jump_destination(addr, instruction)\n    warp.body = state._warp_in_block(destination)\n    warp.way_out = state._warp_in_block(addr + 1)\n\n    return warp, 1", "\n\ndef _build_flow_warp(state, addr, instruction):\n    warp = nodes.UnconditionalWarp()\n    warp.type = nodes.UnconditionalWarp.T_FLOW\n    warp.target = state._warp_in_block(addr + 1)\n\n    opcode = instruction.opcode\n    shift = 1 if opcode in (ins.FORI.opcode, ins.UCLO.opcode) else 0\n\n    return warp, shift", "\n\ndef _assignment_marked(func):\n    def decorated(*args, **kwargs):\n        assn = func(*args, **kwargs)\n        assert isinstance(assn, nodes.Assignment)\n        return assn, assn.expressions.contents\n\n    return decorated\n", "\n\ndef _build_statement(state, addr, instruction):\n    opcode = instruction.opcode\n    A_type = instruction.A_type\n\n    # Generic assignments - handle the ASSIGNMENT stuff below\n    if A_type == ins.T_DST or A_type == ins.T_UV:\n        return _build_var_assignment(state, addr, instruction)\n\n    # ASSIGNMENT starting from MOV and ending at KPRI\n\n    elif opcode == ins.KNIL.opcode:\n        return _build_knil(state, addr, instruction)\n\n    # ASSIGNMENT starting from UGET and ending at USETP\n\n    # SKIP UCL0 is handled below\n\n    # ASSIGNMENT starting from FNEW and ending at GGET\n\n    elif opcode == ins.GSET.opcode:\n        return _build_global_assignment(state, addr, instruction)\n\n    # ASSIGNMENT starting from TGETV and ending at TGETR\n\n    elif opcode >= ins.TSETV.opcode and (opcode <= ins.TSETB.opcode\n                                         or (ljd.CURRENT_VERSION > 2.0\n                                             and opcode == ins.TSETR.opcode)):\n        return _build_table_assignment(state, addr, instruction)\n\n    elif opcode == ins.TSETM.opcode:\n        return _build_table_mass_assignment(state, addr, instruction)\n\n    elif ins.CALLM.opcode <= opcode <= ins.CALLT.opcode:\n        return _build_call(state, addr, instruction)\n\n    elif opcode == ins.VARG.opcode:\n        return _build_vararg(state, addr, instruction)\n\n    elif ins.RETM.opcode <= opcode <= ins.RET1.opcode:\n        return _build_return(state, addr, instruction)\n\n    else:\n        assert opcode == ins.UCLO.opcode or (\n                ins.LOOP.opcode <= opcode <= ins.JLOOP.opcode)\n        # NoOp\n        # TODO get the line no. for the loop set up\n        return None, None", "\n\n@_assignment_marked\ndef _build_var_assignment(state, addr, instruction):\n    opcode = instruction.opcode\n\n    assignment = nodes.Assignment()\n\n    # Unary assignment operators (A = op D)\n    if opcode == ins.MOV.opcode \\\n            or opcode == ins.NOT.opcode \\\n            or opcode == ins.UNM.opcode \\\n            or (ljd.CURRENT_VERSION > 2.0 and opcode == ins.ISTYPE.opcode) \\\n            or (ljd.CURRENT_VERSION > 2.0 and opcode == ins.ISNUM.opcode) \\\n            or opcode == ins.LEN.opcode:\n        expression = _build_unary_expression(state, addr, instruction)\n\n    # Binary assignment operators (A = B op C)\n    elif opcode <= ins.POW.opcode:\n        expression = _build_binary_expression(state, addr, instruction)\n\n    # Concat assignment type (A = B .. B + 1 .. ... .. C - 1 .. C)\n    elif opcode == ins.CAT.opcode:\n        expression = _build_concat_expression(state, addr, instruction)\n\n    # Constant assignment operators except KNIL, which is weird anyway\n    elif opcode <= ins.KPRI.opcode:\n        expression = _build_const_expression(state, addr, instruction)\n\n    elif opcode == ins.UGET.opcode:\n        expression = _build_upvalue(state, addr, instruction.CD)\n\n    elif opcode == ins.USETV.opcode:\n        expression = _build_slot(state, addr, instruction.CD)\n\n    elif opcode <= ins.USETP.opcode:\n        expression = _build_const_expression(state, addr, instruction)\n\n    elif opcode == ins.FNEW.opcode:\n        expression = _build_function(state, instruction.CD)\n\n    elif opcode == ins.TNEW.opcode:\n        expression = nodes.TableConstructor()\n\n    elif opcode == ins.TDUP.opcode:\n        expression = _build_table_copy(state, instruction.CD)\n\n    elif opcode == ins.GGET.opcode:\n        expression = _build_global_variable(state, addr, instruction.CD)\n\n    else:\n        if ljd.CURRENT_VERSION > 2.0:\n            assert opcode <= ins.TGETR.opcode\n            expression = _build_table_element(state, addr, instruction)\n        else:\n            assert opcode <= ins.TGETB.opcode\n            expression = _build_table_element(state, addr, instruction)\n\n    assignment.expressions.contents.append(expression)\n\n    if instruction.A_type == ins.T_DST:\n        destination = _build_slot(state, addr, instruction.A)\n    else:\n        assert instruction.A_type == ins.T_UV\n\n        destination = _build_upvalue(state, addr, instruction.A)\n\n    assignment.destinations.contents.append(destination)\n\n    return assignment", "\n\n@_assignment_marked\ndef _build_knil(state, addr, instruction):\n    node = _build_range_assignment(state, addr, instruction.A, instruction.CD)\n\n    node.expressions.contents = [_build_primitive(state, None)]\n\n    return node\n", "\n\n@_assignment_marked\ndef _build_global_assignment(state, addr, instruction):\n    assignment = nodes.Assignment()\n\n    variable = _build_global_variable(state, addr, instruction.CD)\n    expression = _build_slot(state, addr, instruction.A)\n\n    assignment.destinations.contents.append(variable)\n    assignment.expressions.contents.append(expression)\n\n    return assignment", "\n\n@_assignment_marked\ndef _build_table_assignment(state, addr, instruction):\n    assignment = nodes.Assignment()\n\n    destination = _build_table_element(state, addr, instruction)\n    expression = _build_slot(state, addr, instruction.A)\n\n    assignment.destinations.contents.append(destination)\n    assignment.expressions.contents.append(expression)\n\n    return assignment", "\n\n@_assignment_marked\ndef _build_table_mass_assignment(state, addr, instruction):\n    assignment = nodes.Assignment()\n\n    base = instruction.A\n\n    destination = nodes.GetItem()\n    destination.key = nodes.MULTRES()\n    destination.table = _build_slot(state, addr, base - 1)\n\n    assignment.destinations.contents = [destination]\n    assignment.expressions.contents = [nodes.MULTRES()]\n\n    return assignment", "\n\ndef _build_call(state, addr, instruction):\n    call = nodes.FunctionCall()\n    call.function = _build_slot(state, addr, instruction.A)\n    call.arguments.contents = _build_call_arguments(state, addr, instruction)\n\n    line_marked = [call]\n\n    if instruction.opcode <= ins.CALL.opcode:\n        if instruction.B == 0:\n            node = nodes.Assignment()\n            node.destinations.contents.append(nodes.MULTRES())\n            node.expressions.contents.append(call)\n        elif instruction.B == 1:\n            node = call\n        else:\n            from_slot = instruction.A\n            to_slot = instruction.A + instruction.B - 2\n            node = _build_range_assignment(state, addr, from_slot,\n                                           to_slot)\n            node.expressions.contents.append(call)\n    else:\n        assert instruction.opcode <= ins.CALLT.opcode\n        node = nodes.Return()\n        node.returns.contents.append(call)\n        line_marked.append(node)\n\n    return node, line_marked", "\n\n@_assignment_marked\ndef _build_vararg(state, addr, instruction):\n    base = instruction.A\n    last_slot = base + instruction.B - 2\n\n    if last_slot < base:\n        node = nodes.Assignment()\n        node.destinations.contents.append(nodes.MULTRES())\n        node.expressions.contents.append(nodes.Vararg())\n    else:\n        node = _build_range_assignment(state, addr, base, last_slot)\n        node.expressions.contents.append(nodes.Vararg())\n\n    return node", "\n\ndef _build_return(state, addr, instruction):\n    node = nodes.Return()\n\n    base = instruction.A\n    last_slot = base + instruction.CD - 1\n\n    if instruction.opcode != ins.RETM.opcode:\n        last_slot -= 1\n\n    slot = base\n\n    # Negative count for the RETM is OK\n    while slot <= last_slot:\n        variable = _build_slot(state, addr, slot)\n        node.returns.contents.append(variable)\n        slot += 1\n\n    if instruction.opcode == ins.RETM.opcode:\n        node.returns.contents.append(nodes.MULTRES())\n\n    return node, [node] + node.returns.contents", "\n\ndef _build_call_arguments(state, addr, instruction):\n    base = instruction.A\n    last_argument_slot = base + instruction.CD\n\n    is_variadic = (instruction.opcode == ins.CALLM.opcode\n                   or instruction.opcode == ins.CALLMT.opcode)\n\n    if not is_variadic:\n        last_argument_slot -= 1\n\n    arguments = []\n\n    slot = base + 1\n\n    # LJ_FR2 flag, required for 64-bit LuaJIT\n    # To the best of my knowledge, with this flag enabled there is a empty space on the\n    #  stack between the function and the arguments - when normally you would push the function\n    #  onto the stack followed by arguments, like so:\n    #\n    # /----------\n    # | 0. FUNCTION OBJ\n    # | 1. ARG1\n    # | 2. ARG2\n    # \\----------\n    #\n    # With the flag enabled, it would go like so\n    #\n    # /----------\n    # | 0. FUNCTION OBJ\n    # | 1. <unused, reserved for runtime>\n    # | 2. ARG1\n    # | 3. ARG2\n    # \\----------\n    #\n    # And thus we have to skip that bit\n    #\n    # (if you're curious about why it does this - it's to allow LuaJIT to store some pointers in the space\n    #  usually used by the stack contents. See https://github.com/LuaJIT/LuaJIT/issues/25#issuecomment-183660706 for\n    #  more information)\n    if state.header.flags.fr2:\n        slot += 1\n        last_argument_slot += 1\n\n    while slot <= last_argument_slot:\n        argument = _build_slot(state, addr, slot)\n        arguments.append(argument)\n        slot += 1\n\n    if is_variadic:\n        arguments.append(nodes.MULTRES())\n\n    return arguments", "\n\ndef _build_range_assignment(state, addr, from_slot, to_slot):\n    assignment = nodes.Assignment()\n\n    slot = from_slot\n\n    assert from_slot <= to_slot\n\n    while slot <= to_slot:\n        destination = _build_slot(state, addr, slot)\n\n        assignment.destinations.contents.append(destination)\n\n        slot += 1\n\n    return assignment", "\n\n# Set in init() - see it's comment\n_BINARY_OPERATOR_MAP = None\n\n\ndef _build_binary_expression(state, addr, instruction):\n    operator = nodes.BinaryOperator()\n    opcode = instruction.opcode\n\n    if opcode == ins.POW.opcode:\n        operator.type = nodes.BinaryOperator.T_POW\n    else:\n        map_index = opcode - ins.ADDVN.opcode\n        map_index %= 5\n        map_index += ins.ADDVN.opcode\n\n        operator.type = _BINARY_OPERATOR_MAP[map_index]\n\n    assert (ins.ADDVN.opcode <= opcode <= ins.POW.opcode)\n    assert instruction.B_type == ins.T_VAR\n\n    # VN\n    if opcode < ins.ADDNV.opcode:\n        operator.left = _build_slot(state, addr, instruction.B)\n        operator.right = _build_numeric_constant(state, instruction.CD)\n\n    # NV\n    elif opcode < ins.ADDVV.opcode:\n        operator.right = _build_slot(state, addr, instruction.B)\n        operator.left = _build_numeric_constant(state, instruction.CD)\n\n    # VV\n    else:\n        assert instruction.CD_type == ins.T_VAR\n        operator.left = _build_slot(state, addr, instruction.B)\n        operator.right = _build_slot(state, addr, instruction.CD)\n\n    return operator", "\n\ndef _build_concat_expression(state, addr, instruction):\n    operator = nodes.BinaryOperator()\n    operator.type = nodes.BinaryOperator.T_CONCAT\n\n    slot = instruction.B\n\n    operator.left = _build_slot(state, addr, slot)\n    operator.right = _build_slot(state, addr, slot + 1)\n\n    slot += 2\n\n    while slot <= instruction.CD:\n        upper_operator = nodes.BinaryOperator()\n        upper_operator.left = operator\n        upper_operator.right = _build_slot(state, addr, slot)\n        upper_operator.type = nodes.BinaryOperator.T_CONCAT\n\n        operator = upper_operator\n\n        slot += 1\n\n    return operator", "\n\ndef _build_const_expression(state, addr, instruction):\n    CD_type = instruction.CD_type\n\n    if CD_type == ins.T_STR:\n        return _build_string_constant(state, instruction.CD)\n    elif CD_type == ins.T_CDT:\n        return _build_cdata_constant(state, instruction.CD)\n    elif CD_type == ins.T_SLIT:\n        value = instruction.CD\n\n        if value & 0x8000:\n            value = -0x10000 + value\n\n        return _build_literal(state, value)\n    elif CD_type == ins.T_LIT:\n        return _build_literal(state, instruction.CD)\n    elif CD_type == ins.T_NUM:\n        return _build_numeric_constant(state, instruction.CD)\n    else:\n        assert CD_type == ins.T_PRI\n        return _build_primitive(state, instruction.CD)", "\n\ndef _build_table_element(state, addr, instruction):\n    node = nodes.GetItem()\n    node.table = _build_slot(state, addr, instruction.B)\n\n    if instruction.CD_type == ins.T_VAR:\n        node.key = _build_slot(state, addr, instruction.CD)\n    else:\n        node.key = _build_const_expression(state, addr, instruction)\n\n    return node", "\n\ndef _build_function(state, slot):\n    prototype = state.constants.complex_constants[slot]\n\n    try:\n        return _build_function_definition(prototype, state.header)\n    except Exception as err:\n        if not handle_invalid_functions:\n            raise err\n        fd = nodes.FunctionDefinition()\n        fd.error = err\n        return fd", "\n\ndef _build_table_copy(state, slot):\n    node = nodes.TableConstructor()\n\n    table = state.constants.complex_constants[slot]\n\n    i = 0\n\n    for value in table.array:\n        record = nodes.ArrayRecord()\n        record.value = _build_table_record_item(value)\n\n        node.array.contents.append(record)\n\n        i += 1\n\n    for key, value in table.dictionary:\n        record = nodes.TableRecord()\n        record.key = _build_table_record_item(key)\n        record.value = _build_table_record_item(value)\n\n        node.records.contents.append(record)\n\n    return node", "\n\ndef _build_table_record_item(value):\n    item = None\n    if value is None:\n        item = nodes.Primitive()\n        item.type = nodes.Primitive.T_NIL\n    elif value is True:\n        item = nodes.Primitive()\n        item.type = nodes.Primitive.T_TRUE\n    elif value is False:\n        item = nodes.Primitive()\n        item.type = nodes.Primitive.T_FALSE\n    elif isinstance(value, int):\n        item = nodes.Constant()\n        item.value = value\n        item.type = nodes.Constant.T_INTEGER\n    elif isinstance(value, float):\n        item = nodes.Constant()\n        item.value = value\n        item.type = nodes.Constant.T_FLOAT\n    elif isinstance(value, str):\n        item = nodes.Constant()\n        item.value = value\n        item.type = nodes.Constant.T_STRING\n\n    return item", "\n\n# Set in init() - see it's comment\n_COMPARISON_MAP = None\n\n\ndef _build_comparison_expression(state, addr, instruction):\n    operator = nodes.BinaryOperator()\n\n    operator.left = _build_slot(state, addr, instruction.A)\n\n    opcode = instruction.opcode\n\n    if opcode == ins.ISEQS.opcode or opcode == ins.ISNES.opcode:\n        operator.right = _build_string_constant(state, instruction.CD)\n    elif opcode == ins.ISEQN.opcode or opcode == ins.ISNEN.opcode:\n        operator.right = _build_numeric_constant(state, instruction.CD)\n    elif opcode == ins.ISEQP.opcode or opcode == ins.ISNEP.opcode:\n        operator.right = _build_primitive(state, instruction.CD)\n    else:\n        operator.right = _build_slot(state, addr, instruction.CD)\n\n    operator.type = _COMPARISON_MAP[instruction.opcode]\n    assert operator.type is not None\n\n    return operator", "\n\ndef _build_unary_expression(state, addr, instruction):\n    opcode = instruction.opcode\n\n    variable = _build_slot(state, addr, instruction.CD)\n\n    # Mind the inversion\n    if opcode == ins.ISFC.opcode \\\n            or opcode == ins.ISF.opcode \\\n            or opcode == ins.MOV.opcode:\n        return variable\n\n    operator = nodes.UnaryOperator()\n    operator.operand = variable\n\n    if opcode == ins.ISTC.opcode \\\n            or opcode == ins.IST.opcode \\\n            or opcode == ins.NOT.opcode:\n        operator.type = nodes.UnaryOperator.T_NOT\n    elif opcode == ins.UNM.opcode:\n        operator.type = nodes.UnaryOperator.T_MINUS\n    elif ljd.CURRENT_VERSION > 2.0 and opcode == ins.ISTYPE.opcode:\n        operator.type = nodes.UnaryOperator.T_TOSTRING\n    elif ljd.CURRENT_VERSION > 2.0 and opcode == ins.ISNUM.opcode:\n        operator.type = nodes.UnaryOperator.T_TONUMBER\n    else:\n        assert opcode == ins.LEN.opcode\n        operator.type = nodes.UnaryOperator.T_LENGTH_OPERATOR\n\n    return operator", "\n\ndef _build_slot(state, addr, slot):\n    return _build_identifier(state, addr, slot, nodes.Identifier.T_LOCAL)\n\n\ndef _build_upvalue(state, addr, slot):\n    return _build_identifier(state, addr, slot, nodes.Identifier.T_UPVALUE)\n\n\ndef _build_identifier(state, addr, slot, want_type):\n    node = nodes.Identifier()\n    setattr(node, \"_addr\", addr)\n\n    node.slot = slot\n    node.type = nodes.Identifier.T_SLOT\n\n    if want_type == nodes.Identifier.T_UPVALUE:\n        name = state.debuginfo.lookup_upvalue_name(slot)\n\n        # No problem if name is None, that'll be fixed in writer.Visitor.visit_identifier\n        node.name = name\n        node.type = want_type\n\n    return node", "\n\ndef _build_identifier(state, addr, slot, want_type):\n    node = nodes.Identifier()\n    setattr(node, \"_addr\", addr)\n\n    node.slot = slot\n    node.type = nodes.Identifier.T_SLOT\n\n    if want_type == nodes.Identifier.T_UPVALUE:\n        name = state.debuginfo.lookup_upvalue_name(slot)\n\n        # No problem if name is None, that'll be fixed in writer.Visitor.visit_identifier\n        node.name = name\n        node.type = want_type\n\n    return node", "\n\ndef _build_global_variable(state, addr, slot):\n    node = nodes.GetItem()\n    node.table = nodes.Identifier()\n    node.table.type = nodes.Identifier.T_BUILTIN\n    node.table.name = \"_env\"\n\n    node.key = _build_string_constant(state, slot)\n\n    return node", "\n\ndef _build_string_constant(state, index):\n    node = nodes.Constant()\n    node.type = nodes.Constant.T_STRING\n    node.value = state.constants.complex_constants[index]\n\n    return node\n\n\ndef _build_cdata_constant(state, index):\n    node = nodes.Constant()\n    node.type = nodes.Constant.T_CDATA\n    node.value = state.constants.complex_constants[index]\n\n    return node", "\n\ndef _build_cdata_constant(state, index):\n    node = nodes.Constant()\n    node.type = nodes.Constant.T_CDATA\n    node.value = state.constants.complex_constants[index]\n\n    return node\n\n\ndef _build_numeric_constant(state, index):\n    number = state.constants.numeric_constants[index]\n\n    node = nodes.Constant()\n    node.value = number\n\n    if isinstance(number, int):\n        node.type = nodes.Constant.T_INTEGER\n    else:\n        node.type = nodes.Constant.T_FLOAT\n\n    return node", "\n\ndef _build_numeric_constant(state, index):\n    number = state.constants.numeric_constants[index]\n\n    node = nodes.Constant()\n    node.value = number\n\n    if isinstance(number, int):\n        node.type = nodes.Constant.T_INTEGER\n    else:\n        node.type = nodes.Constant.T_FLOAT\n\n    return node", "\n\ndef _build_primitive(state, value):\n    node = nodes.Primitive()\n\n    if value is True or value == T_TRUE:\n        node.type = nodes.Primitive.T_TRUE\n    elif value is False or value == T_FALSE:\n        node.type = nodes.Primitive.T_FALSE\n    else:\n        assert value is None or value == T_NIL\n\n        node.type = nodes.Primitive.T_NIL\n\n    return node", "\n\ndef _build_literal(state, value):\n    node = nodes.Constant()\n    node.value = value\n    node.type = nodes.Constant.T_INTEGER\n\n    return node\n\n\ndef _fix_inverted_comparison_expressions(state, instructions):\n    for i, instruction in enumerate(instructions):\n\n        if ins.ISLT.opcode <= instruction.opcode <= ins.ISGT.opcode:\n            left_slot = instruction.A\n            right_slot = instruction.CD\n\n            is_inverted = False\n            if i > 0:\n                preceding_instruction = instructions[i - 1]\n\n                # Matching A slot for left slot\n                if hasattr(preceding_instruction, \"A\") and preceding_instruction.A == left_slot:\n                    opcode = preceding_instruction.opcode\n\n                    # Previous instruction is likely a number assignment to left slot\n                    if ins.UNM.opcode <= opcode <= ins.POW.opcode \\\n                            or ins.KSHORT.opcode <= opcode <= ins.KNUM.opcode:\n                        is_inverted = True\n\n            # Invert order of slots\n            if is_inverted:\n                instruction.A = right_slot\n                instruction.CD = left_slot\n\n                if instruction.opcode == ins.ISGT.opcode:\n                    instruction.opcode = ins.ISLT.opcode\n                elif instruction.opcode == ins.ISGE.opcode:\n                    instruction.opcode = ins.ISLE.opcode\n\n                elif instruction.opcode == ins.ISLT.opcode:\n                    instruction.opcode = ins.ISGT.opcode\n                elif instruction.opcode == ins.ISLE.opcode:\n                    instruction.opcode = ins.ISGE.opcode", "\n\ndef _fix_inverted_comparison_expressions(state, instructions):\n    for i, instruction in enumerate(instructions):\n\n        if ins.ISLT.opcode <= instruction.opcode <= ins.ISGT.opcode:\n            left_slot = instruction.A\n            right_slot = instruction.CD\n\n            is_inverted = False\n            if i > 0:\n                preceding_instruction = instructions[i - 1]\n\n                # Matching A slot for left slot\n                if hasattr(preceding_instruction, \"A\") and preceding_instruction.A == left_slot:\n                    opcode = preceding_instruction.opcode\n\n                    # Previous instruction is likely a number assignment to left slot\n                    if ins.UNM.opcode <= opcode <= ins.POW.opcode \\\n                            or ins.KSHORT.opcode <= opcode <= ins.KNUM.opcode:\n                        is_inverted = True\n\n            # Invert order of slots\n            if is_inverted:\n                instruction.A = right_slot\n                instruction.CD = left_slot\n\n                if instruction.opcode == ins.ISGT.opcode:\n                    instruction.opcode = ins.ISLT.opcode\n                elif instruction.opcode == ins.ISGE.opcode:\n                    instruction.opcode = ins.ISLE.opcode\n\n                elif instruction.opcode == ins.ISLT.opcode:\n                    instruction.opcode = ins.ISGT.opcode\n                elif instruction.opcode == ins.ISLE.opcode:\n                    instruction.opcode = ins.ISGE.opcode", "\n\ndef _fix_broken_repeat_until_loops(state, instructions):\n    enumerated_instructions = enumerate(instructions)\n    for i, instruction in enumerated_instructions:\n\n        if instruction.opcode == ins.LOOP.opcode:\n\n            # Check for the conditional jump that restarts the loop\n            loop_exit_addr = get_jump_destination(i, instruction)\n            loop_condition_addr = loop_exit_addr - 1\n            loop_condition_instruction = instructions[loop_condition_addr]\n            if not loop_condition_instruction.opcode == ins.JMP.opcode:\n                if get_jump_destination(loop_condition_addr, loop_condition_instruction) <= i:\n                    continue\n\n                # It's not there, so this is probably a repeat-until true loop.\n\n                # We need a fake conditional warp that is treated as 'true' by the writer\n                fixed_cond_instruction = ins.ISF()\n                fixed_cond_instruction.CD = ins.SLOT_TRUE\n\n                # Resulting jump to the loop starting point\n                fixed_jump_instruction = ins.JMP()\n                fixed_jump_instruction.CD = i - loop_condition_addr - 1\n\n                # Add fake conditional instructions\n                insertion_index = loop_condition_addr + 1\n                _insert_instruction(state, instructions, insertion_index, fixed_jump_instruction)\n                _insert_instruction(state, instructions, insertion_index, fixed_cond_instruction)\n\n                shift = 2\n\n                # Fix non-break destinations within the loop\n                # Breaks in the empty-condition loop point towards the same exit destination\n                # as non-breaks, so we'll have to search for a pattern of jumps.\n\n                leading_jump = False\n                start_index = i + 1\n                for j in range(start_index, insertion_index):\n                    checked_instruction = instructions[j]\n\n                    # Look for following JMP instructions\n                    if checked_instruction.opcode == ins.JMP.opcode:\n\n                        # Leading jump indicates this is a break?\n                        if not leading_jump:\n                            checked_instruction_destination \\\n                                = get_jump_destination(j, checked_instruction)\n\n                            # If the destination would've been moved\n                            if checked_instruction.CD >= shift \\\n                                    and checked_instruction_destination == insertion_index + shift:\n\n                                # Check for an inverted jump pair\n                                next_index = j + 1\n                                following_instruction = instructions[next_index]\n                                if following_instruction.opcode == ins.JMP.opcode:\n                                    following_destination \\\n                                        = get_jump_destination(next_index, following_instruction)\n\n                                    # e.g. goto 277 followed directly by goto 176\n                                    if following_destination < checked_instruction_destination:\n                                        leading_jump = True\n                                        continue\n\n                                    # e.g. goto 277 followed directly by goto 277\n                                    elif following_destination == checked_instruction_destination:\n                                        leading_jump = False\n                                        continue\n\n                                # Check for else-break-end following this jump\n                                following_else_break_found = False\n                                prev_jump = False\n                                for k in range(next_index, insertion_index):\n                                    following_instruction = instructions[k]\n                                    if following_instruction.opcode == ins.JMP.opcode:\n                                        if not prev_jump:\n                                            prev_jump = True\n\n                                        else:\n                                            following_destination \\\n                                                = get_jump_destination(k, following_instruction)\n\n                                            # Don't adjust the checked jump, it's probably a break\n                                            if following_instruction.CD >= shift \\\n                                                    and following_destination \\\n                                                    == checked_instruction_destination:\n                                                following_else_break_found = True\n                                                break\n\n                                            prev_jump = False\n\n                                    else:\n                                        if prev_jump:\n                                            last_destination \\\n                                                = get_jump_destination(k - 1, instructions[k - 1])\n                                            # We can adjust, it's probably not a break\n                                            if last_destination < checked_instruction_destination:\n                                                break\n                                        prev_jump = False\n\n                                if not following_else_break_found:\n                                    checked_instruction.CD -= shift\n                        leading_jump = True\n\n                    else:\n                        leading_jump = False", "\n\ndef _fix_broken_unary_expressions(state, instructions):\n    enumerated_instructions = enumerate(instructions)\n    for i, instruction in enumerated_instructions:\n        if i > 2 and instruction.opcode == ins.ISTC.opcode \\\n                and ins.ADDVN.opcode <= instructions[i - 1].opcode <= ins.CAT.opcode:\n\n            # Search for a jump that precedes the ISTC op\n            leading_jump_found = False\n            for j in range(1, i):\n                if instructions[i - j].opcode == ins.JMP.opcode:\n                    leading_jump_found = True\n                    break\n                elif instructions[i - j].opcode not in range(ins.ADDVN.opcode, ins.CAT.opcode):\n                    break\n\n            # Make sure the preceding jump matches the destination of the ISTC op\n            instruction_destination = get_jump_destination(i + 1, instructions[i + 1])\n            if instruction_destination == i + 2 and leading_jump_found:\n                # Additional jump edge case of an edge case when expression is in an else body\n                if not instruction_destination == get_jump_destination(i - j, instructions[i - j]):\n\n                    if instructions[i + 2].opcode == ins.JMP.opcode:\n                        instruction_destination = get_jump_destination(i + 2, instructions[i + 2])\n\n                        if instruction_destination == get_jump_destination(i - j, instructions[i - j]):\n                            instructions[i - 1].A = instruction.A\n\n                            # Remove the broken condition\n                            _remove_instruction(state, instructions, i + 1)\n                            _remove_instruction(state, instructions, i)\n\n                else:\n                    instructions[i - 1].A = instruction.A\n\n                    # Remove the broken condition\n                    _remove_instruction(state, instructions, i + 1)\n                    _remove_instruction(state, instructions, i)", "\n\ndef _insert_instruction(state, instructions, index, new_instruction):\n    preceding_index = index - 1\n    line_mapping = state.debuginfo.addr_to_line_map[preceding_index]\n\n    instructions.insert(index, new_instruction)\n    state.debuginfo.addr_to_line_map.insert(index, line_mapping)\n\n    # Offset\n    shift = 1\n\n    # Update warp destinations with regards to the inserted instruction\n    _shift_warp_destinations(state, instructions, shift, index)\n\n    # Update variable info ranges\n    _shift_debug_variable_info(state, shift, index)", "\n\ndef _remove_instruction(state, instructions, index):\n    removed_instruction = instructions.pop(index)\n    if not state.debuginfo.addr_to_line_map:\n        warnings.warn('skip pop %s from empty state.debuginfo.addr_to_line_map' % index)\n    else:\n        state.debuginfo.addr_to_line_map.pop(index)\n\n    # Offset\n    shift = -1\n\n    # Update warp destinations with regards to the removed instruction\n    _shift_warp_destinations(state, instructions, shift, index)\n\n    # Update variable info ranges\n    _shift_debug_variable_info(state, shift, index)\n\n    return removed_instruction", "\n\ndef _shift_warp_destinations(state, instructions, shift, modified_index):\n    for current_index, moved_instruction in enumerate(instructions):\n        opcode = moved_instruction.opcode\n\n        if opcode in _WARP_INSTRUCTIONS:\n            if current_index < modified_index and moved_instruction.CD >= 0:\n                destination = get_jump_destination(current_index, moved_instruction)\n                if destination > modified_index or (destination == modified_index and shift > 0):\n                    moved_instruction.CD += shift\n\n            elif current_index >= modified_index and moved_instruction.CD < 0:\n                destination = current_index + moved_instruction.CD - shift + 1\n                if destination < modified_index or (destination == modified_index and shift > 0):\n                    moved_instruction.CD -= shift", "\n\ndef _shift_debug_variable_info(state, shift, modified_index):\n    for variable_info in state.debuginfo.variable_info:\n\n        if variable_info.end_addr > modified_index \\\n                or (shift > 0 and variable_info.end_addr == modified_index):\n            variable_info.end_addr += shift\n\n        if variable_info.start_addr > modified_index \\\n                or (shift > 0 and variable_info.start_addr == modified_index):\n            variable_info.start_addr += shift", "\n\n# Sets up _BINARY_OPERATOR_MAP and _COMPARISON_MAP\n# The reason we have to do it in the init method is due to\n# the new initialisation system for opcodes. Previously,\n# they were set by the order they were specified in ljd.bytecode.instructions,\n# but now their opcode fields are set by ljd.rawdump.code.init from the luajit_opcode\n# files. This will eventually allow the decompiler to switch between\n# different LuaJIT versions.\ndef init():\n    global _BINARY_OPERATOR_MAP\n    global _COMPARISON_MAP\n\n    _BINARY_OPERATOR_MAP = [None] * 255\n\n    _BINARY_OPERATOR_MAP[ins.ADDVN.opcode] = nodes.BinaryOperator.T_ADD\n    _BINARY_OPERATOR_MAP[ins.SUBVN.opcode] = nodes.BinaryOperator.T_SUBTRACT\n    _BINARY_OPERATOR_MAP[ins.MULVN.opcode] = nodes.BinaryOperator.T_MULTIPLY\n    _BINARY_OPERATOR_MAP[ins.DIVVN.opcode] = nodes.BinaryOperator.T_DIVISION\n    _BINARY_OPERATOR_MAP[ins.MODVN.opcode] = nodes.BinaryOperator.T_MOD\n\n    _COMPARISON_MAP = [None] * 255\n\n    # Mind the inversion - comparison operators are affecting JMP to the next block\n    # So in the normal code a comparison will be inverted\n    _COMPARISON_MAP[ins.ISLT.opcode] = nodes.BinaryOperator.T_GREATER_OR_EQUAL\n    _COMPARISON_MAP[ins.ISGE.opcode] = nodes.BinaryOperator.T_LESS_THEN\n    _COMPARISON_MAP[ins.ISLE.opcode] = nodes.BinaryOperator.T_GREATER_THEN\n    _COMPARISON_MAP[ins.ISGT.opcode] = nodes.BinaryOperator.T_LESS_OR_EQUAL\n\n    _COMPARISON_MAP[ins.ISEQV.opcode] = nodes.BinaryOperator.T_NOT_EQUAL\n    _COMPARISON_MAP[ins.ISNEV.opcode] = nodes.BinaryOperator.T_EQUAL\n\n    _COMPARISON_MAP[ins.ISEQS.opcode] = nodes.BinaryOperator.T_NOT_EQUAL\n    _COMPARISON_MAP[ins.ISNES.opcode] = nodes.BinaryOperator.T_EQUAL\n\n    _COMPARISON_MAP[ins.ISEQN.opcode] = nodes.BinaryOperator.T_NOT_EQUAL\n    _COMPARISON_MAP[ins.ISNEN.opcode] = nodes.BinaryOperator.T_EQUAL\n\n    _COMPARISON_MAP[ins.ISEQP.opcode] = nodes.BinaryOperator.T_NOT_EQUAL\n    _COMPARISON_MAP[ins.ISNEP.opcode] = nodes.BinaryOperator.T_EQUAL\n\n    global _JUMP_WARP_INSTRUCTIONS\n    global _WARP_INSTRUCTIONS\n\n    _JUMP_WARP_INSTRUCTIONS = {ins.UCLO.opcode, ins.ISNEXT.opcode, ins.JMP.opcode, ins.FORI.opcode, ins.JFORI.opcode}\n\n    _WARP_INSTRUCTIONS = _JUMP_WARP_INSTRUCTIONS | {ins.FORL.opcode, ins.IFORL.opcode, ins.JFORL.opcode,\n                                                    ins.ITERL.opcode, ins.IITERL.opcode, ins.JITERL.opcode,\n                                                    ins.LOOP.opcode}", "# different LuaJIT versions.\ndef init():\n    global _BINARY_OPERATOR_MAP\n    global _COMPARISON_MAP\n\n    _BINARY_OPERATOR_MAP = [None] * 255\n\n    _BINARY_OPERATOR_MAP[ins.ADDVN.opcode] = nodes.BinaryOperator.T_ADD\n    _BINARY_OPERATOR_MAP[ins.SUBVN.opcode] = nodes.BinaryOperator.T_SUBTRACT\n    _BINARY_OPERATOR_MAP[ins.MULVN.opcode] = nodes.BinaryOperator.T_MULTIPLY\n    _BINARY_OPERATOR_MAP[ins.DIVVN.opcode] = nodes.BinaryOperator.T_DIVISION\n    _BINARY_OPERATOR_MAP[ins.MODVN.opcode] = nodes.BinaryOperator.T_MOD\n\n    _COMPARISON_MAP = [None] * 255\n\n    # Mind the inversion - comparison operators are affecting JMP to the next block\n    # So in the normal code a comparison will be inverted\n    _COMPARISON_MAP[ins.ISLT.opcode] = nodes.BinaryOperator.T_GREATER_OR_EQUAL\n    _COMPARISON_MAP[ins.ISGE.opcode] = nodes.BinaryOperator.T_LESS_THEN\n    _COMPARISON_MAP[ins.ISLE.opcode] = nodes.BinaryOperator.T_GREATER_THEN\n    _COMPARISON_MAP[ins.ISGT.opcode] = nodes.BinaryOperator.T_LESS_OR_EQUAL\n\n    _COMPARISON_MAP[ins.ISEQV.opcode] = nodes.BinaryOperator.T_NOT_EQUAL\n    _COMPARISON_MAP[ins.ISNEV.opcode] = nodes.BinaryOperator.T_EQUAL\n\n    _COMPARISON_MAP[ins.ISEQS.opcode] = nodes.BinaryOperator.T_NOT_EQUAL\n    _COMPARISON_MAP[ins.ISNES.opcode] = nodes.BinaryOperator.T_EQUAL\n\n    _COMPARISON_MAP[ins.ISEQN.opcode] = nodes.BinaryOperator.T_NOT_EQUAL\n    _COMPARISON_MAP[ins.ISNEN.opcode] = nodes.BinaryOperator.T_EQUAL\n\n    _COMPARISON_MAP[ins.ISEQP.opcode] = nodes.BinaryOperator.T_NOT_EQUAL\n    _COMPARISON_MAP[ins.ISNEP.opcode] = nodes.BinaryOperator.T_EQUAL\n\n    global _JUMP_WARP_INSTRUCTIONS\n    global _WARP_INSTRUCTIONS\n\n    _JUMP_WARP_INSTRUCTIONS = {ins.UCLO.opcode, ins.ISNEXT.opcode, ins.JMP.opcode, ins.FORI.opcode, ins.JFORI.opcode}\n\n    _WARP_INSTRUCTIONS = _JUMP_WARP_INSTRUCTIONS | {ins.FORL.opcode, ins.IFORL.opcode, ins.JFORL.opcode,\n                                                    ins.ITERL.opcode, ins.IITERL.opcode, ins.JITERL.opcode,\n                                                    ins.LOOP.opcode}", ""]}
{"filename": "ljd/ast/printast.py", "chunked_list": ["import ljd.ast.nodes as nodes\n\n_printers = {}\n_indent_unit = '\\t'\n\n\ndef dump(name, obj, level=0, **kwargs):\n    indent = level * _indent_unit\n\n    if name is not None:\n        prefix = indent + name + \" = \"\n    else:\n        prefix = indent\n\n    if isinstance(obj, (int, float, str)):\n        print(prefix + str(obj))\n    elif isinstance(obj, list):\n        if len(obj) == 0:\n            print(prefix + \"[]\")\n            return\n\n        print(prefix + \"[\")\n\n        for value in obj:\n            dump(None, value, level + 1)\n\n        print(indent + \"]\")\n    elif isinstance(obj, dict):\n        print(prefix + \"{\")\n\n        for key, value in obj.items():\n            dump(key, value, level + 1)\n\n        print(indent + \"}\")\n    elif type(obj) in _printers:\n        _printers[type(obj)](obj, prefix, level, **kwargs)\n    else:\n        _print_default(obj, prefix, level)", "\n\ndef _print_default(obj, prefix, level, exclude_blocks=False, extra_attrs=None):\n    header_keys = _header(prefix, obj, attrs=extra_attrs)\n\n    for key in dir(obj):\n        if key.startswith(\"__\") or key in header_keys:\n            continue\n\n        val = getattr(obj, key)\n\n        # Exclude methods, they're of no use\n        if callable(val):\n            continue\n\n        # Definitely don't show the blocks, otherwise it explodes the output\n        if exclude_blocks and isinstance(val, nodes.Block):\n            print(_indent_unit * (level + 1) + key + \" = Block[index=%d]\" % val.index)\n            continue\n\n        dump(key, val, level + 1)", "\n\ndef _header(prefix, obj, attrs=None, suffix=\"\", **values):\n    if attrs is None:\n        attrs = [\"_addr\", \"_line\"]\n\n    for name in attrs:\n        if not hasattr(obj, name):\n            continue\n        pretty_name = name.lstrip(\"_\")\n        values[pretty_name] = getattr(obj, name)\n\n    if len(values) == 0:\n        attr_block = \"\"\n    else:\n        attr_block = \"[%s]\" % \", \".join([\"%s=%s\" % (k, v) for k, v in values.items()])\n\n    if suffix != \"\":\n        suffix = \": \" + str(suffix)\n\n    print(prefix + type(obj).__name__ + attr_block + suffix)\n\n    return attrs", "\n\ndef _printer(klass):\n    def wrapper(func):\n        _printers[klass] = func\n        return func\n\n    return wrapper\n\n", "\n\n# TODO add some way to show the _addr elements of all these\n\n@_printer(nodes.Identifier)\ndef _print_str(obj, prefix, level):\n    print(prefix + str(obj))\n\n\n@_printer(nodes.Constant)\ndef _print_const(obj: nodes.Constant, prefix, level):\n    s = '\"' + obj.value + '\"' if obj.type == nodes.Constant.T_STRING else obj.value\n    _header(prefix, obj, suffix=s)", "\n@_printer(nodes.Constant)\ndef _print_const(obj: nodes.Constant, prefix, level):\n    s = '\"' + obj.value + '\"' if obj.type == nodes.Constant.T_STRING else obj.value\n    _header(prefix, obj, suffix=s)\n\n\n@_printer(nodes.Assignment)\ndef _print_assn(obj: nodes.Assignment, prefix, level):\n    print(prefix + \"Assignment[type=%s]\" % [\"T_LOCAL_DEFINITION\", \"T_NORMAL\"][obj.type])\n    dump(\"dest\", obj.destinations, level + 1, omit_single=True)\n    dump(\"expr\", obj.expressions, level + 1, omit_single=True)", "def _print_assn(obj: nodes.Assignment, prefix, level):\n    print(prefix + \"Assignment[type=%s]\" % [\"T_LOCAL_DEFINITION\", \"T_NORMAL\"][obj.type])\n    dump(\"dest\", obj.destinations, level + 1, omit_single=True)\n    dump(\"expr\", obj.expressions, level + 1, omit_single=True)\n\n\n@_printer(nodes.VariablesList)\n@_printer(nodes.ExpressionsList)\n@_printer(nodes.StatementsList)\ndef _print_list(obj: nodes.VariablesList, prefix: str, level, omit_single=False):\n    name = prefix[:-2].strip()  # chop out the = and strip it to recover the name\n\n    if len(obj.contents) == 0:\n        print(prefix + type(obj).__name__ + \"[empty]\")\n    elif len(obj.contents) == 1:\n        if omit_single:\n            dump(name, obj.contents[0], level)\n        else:\n            print(prefix + type(obj).__name__ + \"[single]: \", end='')\n            dump(None, obj.contents[0], 0)\n    else:\n        print(prefix + type(obj).__name__ + \"[\")\n        for value in obj.contents:\n            dump(None, value, level + 1)\n        print(_indent_unit * level + \"]\")", "@_printer(nodes.StatementsList)\ndef _print_list(obj: nodes.VariablesList, prefix: str, level, omit_single=False):\n    name = prefix[:-2].strip()  # chop out the = and strip it to recover the name\n\n    if len(obj.contents) == 0:\n        print(prefix + type(obj).__name__ + \"[empty]\")\n    elif len(obj.contents) == 1:\n        if omit_single:\n            dump(name, obj.contents[0], level)\n        else:\n            print(prefix + type(obj).__name__ + \"[single]: \", end='')\n            dump(None, obj.contents[0], 0)\n    else:\n        print(prefix + type(obj).__name__ + \"[\")\n        for value in obj.contents:\n            dump(None, value, level + 1)\n        print(_indent_unit * level + \"]\")", "\n\n@_printer(nodes.GetItem)\ndef _print_table_elem(obj: nodes.GetItem, prefix, level):\n    print(prefix + \"GetItem\")\n    dump(\"table\", obj.table, level + 1)\n    dump(\"key\", obj.key, level + 1)\n\n\n@_printer(nodes.UnconditionalWarp)", "\n@_printer(nodes.UnconditionalWarp)\n@_printer(nodes.ConditionalWarp)\n@_printer(nodes.IteratorWarp)\n@_printer(nodes.NumericLoopWarp)\n@_printer(nodes.EndWarp)\ndef _print_warp(obj, prefix, level):\n    _print_default(obj, prefix, level, exclude_blocks=True)\n\n", "\n\n@_printer(nodes.Block)\ndef _print_block(obj, prefix, level):\n    _print_default(obj, prefix, level, extra_attrs=[\"index\", \"first_address\", \"last_address\"])\n"]}
{"filename": "ljd/ast/helpers.py", "chunked_list": ["import ljd.ast.nodes as nodes\nimport ljd.ast.traverse as traverse\n\n\ndef insert_table_record(constructor, key, value, replace, allow_duplicates=True):\n    array = constructor.array.contents\n    records = constructor.records.contents\n\n    if isinstance(key, nodes.MULTRES):\n        assert len(records) == 0 \\\n               or isinstance(records[-1], nodes.TableRecord)\n\n        records.append(value)\n        return True\n\n    while isinstance(key, nodes.Constant) \\\n            and key.type == key.T_INTEGER \\\n            and key.value >= 0:\n        index = key.value\n\n        if index == 1 and len(array) == 0:\n            record = nodes.ArrayRecord()\n            record.value = nodes.Primitive()\n            record.value.type = nodes.Primitive.T_NIL\n\n            array.append(record)\n\n        if index > len(array):\n            break\n\n        record = nodes.ArrayRecord()\n        record.value = value\n\n        if len(array) == 0 or index == len(array):\n            array.append(record)\n            return True\n        elif replace:\n            array[index] = record\n            return True\n        else:\n            current_value = array[index].value\n            if isinstance(current_value, nodes.Primitive) and current_value.type == nodes.Primitive.T_NIL:\n                array[index] = record\n                return True\n            return False\n\n    # Check for record duplicates\n    # This isn't nearly as important as duplicate protection with arrays, since both values\n    # end up in the table to the user can make sense of what happened. Nonetheless, we should still\n    # reject stuff like this.\n    if not allow_duplicates:\n        for rec in records:\n            if isinstance(rec, nodes.TableRecord):\n                if is_equal(rec.key, key, strict=False):\n                    return False\n\n    record = nodes.TableRecord()\n    record.key = key\n    record.value = value\n\n    if len(records) == 0:\n        records.append(record)\n        return True\n\n    last = records[-1]\n\n    if isinstance(last, (nodes.FunctionCall, nodes.Vararg)):\n        records.insert(-1, record)\n    else:\n        records.append(record)\n\n    return True", "\n\ndef has_same_table(node, table):\n    class Checker(traverse.Visitor):\n        def __init__(self, checker_table):\n            super().__init__()\n            self.found = False\n            self.table = checker_table\n            self.current_function_depth = 0\n\n        def visit_table_element(self, checked_node):\n            if is_equal(self.table, checked_node.table):\n                self.found = True\n\n        def visit_function_definition(self, node):\n            self.current_function_depth += 1\n\n        def leave_function_definition(self, node):\n            self.current_function_depth -= 1\n\n        def visit_identifier(self, node):\n            if self.current_function_depth > 0 and node.type == node.T_UPVALUE:\n                if getattr(self.table, \"name\", False) == node.name:  # Use False to avoid matches on None\n                    self.found = True\n\n        def _visit(self, checked_node):\n            if not self.found:\n                traverse.Visitor._visit(self, checked_node)\n\n        def _visit_list(self, nodes_list):\n            if not self.found:\n                traverse.Visitor._visit_list(self, nodes_list)\n\n    checker = Checker(table)\n    traverse.traverse(checker, node)\n\n    return checker.found", "\n\ndef is_equal(a, b, strict=True):\n    if type(a) != type(b):\n        return False\n\n    if isinstance(a, nodes.Identifier):\n        return a.type == b.type and a.slot == b.slot\n    elif isinstance(a, nodes.GetItem):\n        return is_equal(a.table, b.table, strict) \\\n               and is_equal(a.key, b.key, strict)\n    elif isinstance(a, nodes.Constant):\n        return a.type == b.type and a.value == b.value\n    else:\n        assert not strict\n        return False", ""]}
