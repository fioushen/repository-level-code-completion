{"filename": "setup.py", "chunked_list": ["from setuptools import setup, find_packages\n\nsetup(\n  name = 'babylm_baseline_train',\n  package_dir={\"\": \"src\"},\n  packages=find_packages(\"src\"),\n  version = '1.0.0',\n  license='MIT',\n  description = 'BabyLM Baseline Training',\n  long_description_content_type = 'text/markdown',", "  description = 'BabyLM Baseline Training',\n  long_description_content_type = 'text/markdown',\n  keywords = [\n    'artificial intelligence',\n    'deep learning',\n    'transformers',\n  ],\n  install_requires=[\n    'torch==1.10.2',\n    'transformers',", "    'torch==1.10.2',\n    'transformers',\n    'ipdb',\n    'datasets',\n    'jax==0.3.21',\n    'jaxlib==0.3.20',   # NOTE: use this to train on GPU: pip install jaxlib==0.3.20+cuda11.cudnn82 -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html\n    'flax==0.6.1',\n    'sentencepiece',\n  ],\n  classifiers=[", "  ],\n  classifiers=[\n    'Development Status :: 4 - Beta',\n    'Intended Audience :: Developers',\n    'Topic :: Scientific/Engineering :: Artificial Intelligence',\n    'License :: OSI Approved :: MIT License',\n    'Programming Language :: Python :: 3.9',\n  ],\n)\n", ")\n"]}
{"filename": "scripts/run_t5_mlm_flax.py", "chunked_list": ["#!/usr/bin/env python\n# coding=utf-8\n# Copyright 2021 The HuggingFace Team All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"\nPretraining the library models for T5-like span-masked language modeling on a text file or a dataset.\n", "Pretraining the library models for T5-like span-masked language modeling on a text file or a dataset.\n\nHere is the full list of checkpoints on the hub that can be pretrained by this script:\nhttps://huggingface.co/models?filter=t5\n\"\"\"\nimport json\nimport logging\nimport math\nimport os\nimport sys", "import os\nimport sys\nimport time\nfrom dataclasses import asdict, dataclass, field\n\n# You can also adapt this script on your own masked language modeling task. Pointers for this are left as comments.\nfrom enum import Enum\nfrom itertools import chain\nfrom pathlib import Path\nfrom typing import Dict, List, Optional", "from pathlib import Path\nfrom typing import Dict, List, Optional\n\nimport numpy as np\nfrom datasets import load_dataset\nfrom tqdm import tqdm\n\nimport flax\nimport jax\nimport jax.numpy as jnp", "import jax\nimport jax.numpy as jnp\nimport optax\nfrom flax import jax_utils, traverse_util\nfrom flax.jax_utils import pad_shard_unpad\nfrom flax.training import train_state\nfrom flax.training.common_utils import get_metrics, onehot, shard\nfrom huggingface_hub import Repository\nfrom transformers import (\n    CONFIG_MAPPING,", "from transformers import (\n    CONFIG_MAPPING,\n    FLAX_MODEL_FOR_MASKED_LM_MAPPING,\n    AutoTokenizer,\n    BatchEncoding,\n    FlaxT5ForConditionalGeneration,\n    HfArgumentParser,\n    PreTrainedTokenizerBase,\n    T5Config,\n    is_tensorboard_available,", "    T5Config,\n    is_tensorboard_available,\n    set_seed,\n)\nfrom transformers.models.t5.modeling_flax_t5 import shift_tokens_right\nfrom transformers.utils import get_full_repo_name, send_example_telemetry\n\n\nMODEL_CONFIG_CLASSES = list(FLAX_MODEL_FOR_MASKED_LM_MAPPING.keys())\nMODEL_TYPES = tuple(conf.model_type for conf in MODEL_CONFIG_CLASSES)", "MODEL_CONFIG_CLASSES = list(FLAX_MODEL_FOR_MASKED_LM_MAPPING.keys())\nMODEL_TYPES = tuple(conf.model_type for conf in MODEL_CONFIG_CLASSES)\n\n\n@dataclass\nclass TrainingArguments:\n    output_dir: str = field(\n        metadata={\"help\": \"The output directory where the model predictions and checkpoints will be written.\"},\n    )\n    overwrite_output_dir: bool = field(\n        default=False,\n        metadata={\n            \"help\": (\n                \"Overwrite the content of the output directory. \"\n                \"Use this to continue training if output_dir points to a checkpoint directory.\"\n            )\n        },\n    )\n    do_train: bool = field(default=False, metadata={\"help\": \"Whether to run training.\"})\n    do_eval: bool = field(default=False, metadata={\"help\": \"Whether to run eval on the dev set.\"})\n    per_device_train_batch_size: int = field(\n        default=8, metadata={\"help\": \"Batch size per GPU/TPU core/CPU for training.\"}\n    )\n    per_device_eval_batch_size: int = field(\n        default=8, metadata={\"help\": \"Batch size per GPU/TPU core/CPU for evaluation.\"}\n    )\n    learning_rate: float = field(default=5e-5, metadata={\"help\": \"The initial learning rate for AdamW.\"})\n    weight_decay: float = field(default=0.0, metadata={\"help\": \"Weight decay for AdamW if we apply some.\"})\n    adam_beta1: float = field(default=0.9, metadata={\"help\": \"Beta1 for AdamW optimizer\"})\n    adam_beta2: float = field(default=0.999, metadata={\"help\": \"Beta2 for AdamW optimizer\"})\n    adam_epsilon: float = field(default=1e-8, metadata={\"help\": \"Epsilon for AdamW optimizer.\"})\n    adafactor: bool = field(default=False, metadata={\"help\": \"Whether or not to replace AdamW by Adafactor.\"})\n    num_train_epochs: float = field(default=3.0, metadata={\"help\": \"Total number of training epochs to perform.\"})\n    num_train_steps: int = field(default=-1, metadata={\"help\": \"Total number of training steps top perform.\"})\n    warmup_steps: int = field(default=0, metadata={\"help\": \"Linear warmup over warmup_steps.\"})\n    logging_steps: int = field(default=500, metadata={\"help\": \"Log every X updates steps.\"})\n    save_steps: int = field(default=500, metadata={\"help\": \"Save checkpoint every X updates steps.\"})\n    save_epochs: int = field(default=-1, metadata={\"help\": \"Save checkpoint every X epochs.\"})\n    eval_steps: int = field(default=-1, metadata={\"help\": \"Run an evaluation every X steps.\"})\n    eval_epochs: int = field(default=-1, metadata={\"help\": \"Run an evaluation every X epochs.\"})\n    seed: int = field(default=42, metadata={\"help\": \"Random seed that will be set at the beginning of training.\"})\n    push_to_hub: bool = field(\n        default=False, metadata={\"help\": \"Whether or not to upload the trained model to the model hub after training.\"}\n    )\n    hub_model_id: str = field(\n        default=None, metadata={\"help\": \"The name of the repository to keep in sync with the local `output_dir`.\"}\n    )\n    hub_token: str = field(default=None, metadata={\"help\": \"The token to use to push to the Model Hub.\"})\n\n    def __post_init__(self):\n        if self.output_dir is not None:\n            self.output_dir = os.path.expanduser(self.output_dir)\n\n    def to_dict(self):\n        \"\"\"\n        Serializes this instance while replace `Enum` by their values (for JSON serialization support). It obfuscates\n        the token values by removing their value.\n        \"\"\"\n        d = asdict(self)\n        for k, v in d.items():\n            if isinstance(v, Enum):\n                d[k] = v.value\n            if isinstance(v, list) and len(v) > 0 and isinstance(v[0], Enum):\n                d[k] = [x.value for x in v]\n            if k.endswith(\"_token\"):\n                d[k] = f\"<{k.upper()}>\"\n        return d", "\n\n@dataclass\nclass ModelArguments:\n    \"\"\"\n    Arguments pertaining to which model/config/tokenizer we are going to fine-tune, or train from scratch.\n    \"\"\"\n\n    model_name_or_path: Optional[str] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"The model checkpoint for weights initialization.Don't set if you want to train a model from scratch.\"\n            )\n        },\n    )\n    model_type: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"If training from scratch, pass a model type from the list: \" + \", \".join(MODEL_TYPES)},\n    )\n    config_name: Optional[str] = field(\n        default=None, metadata={\"help\": \"Pretrained config name or path if not the same as model_name\"}\n    )\n    tokenizer_name: Optional[str] = field(\n        default=None, metadata={\"help\": \"Pretrained tokenizer name or path if not the same as model_name\"}\n    )\n    cache_dir: Optional[str] = field(\n        default=None, metadata={\"help\": \"Where do you want to store the pretrained models downloaded from s3\"}\n    )\n    use_fast_tokenizer: bool = field(\n        default=True,\n        metadata={\"help\": \"Whether to use one of the fast tokenizer (backed by the tokenizers library) or not.\"},\n    )\n    dtype: Optional[str] = field(\n        default=\"float32\",\n        metadata={\n            \"help\": (\n                \"Floating-point format in which the model weights should be initialized and trained. Choose one of\"\n                \" `[float32, float16, bfloat16]`.\"\n            )\n        },\n    )\n    use_auth_token: bool = field(\n        default=False,\n        metadata={\n            \"help\": (\n                \"Will use the token generated when running `huggingface-cli login` (necessary to use this script \"\n                \"with private models).\"\n            )\n        },\n    )\n    rerandomize: bool = field(\n        default = False,\n        metadata={\n            \"help\": (\n                \"Rerandomizes the initial weighst of the model by using model.init_weights() instead of \"\n                \"flax functions.\"\n            )\n        },\n    )", "\n\n@dataclass\nclass DataTrainingArguments:\n    \"\"\"\n    Arguments pertaining to what data we are going to input our model for training and eval.\n    \"\"\"\n\n    dataset_name: Optional[str] = field(\n        default=None, metadata={\"help\": \"The name of the dataset to use (via the datasets library).\"}\n    )\n    dataset_config_name: Optional[str] = field(\n        default=None, metadata={\"help\": \"The configuration name of the dataset to use (via the datasets library).\"}\n    )\n    train_file: Optional[str] = field(default=None, metadata={\"help\": \"The input training data file (a text file).\"})\n    validation_file: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"An optional input evaluation data file to evaluate the perplexity on (a text file).\"},\n    )\n    train_ref_file: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"An optional input train ref data file for whole word masking in Chinese.\"},\n    )\n    validation_ref_file: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"An optional input validation ref data file for whole word masking in Chinese.\"},\n    )\n    overwrite_cache: bool = field(\n        default=False, metadata={\"help\": \"Overwrite the cached training and evaluation sets\"}\n    )\n    validation_split_percentage: Optional[int] = field(\n        default=5,\n        metadata={\n            \"help\": \"The percentage of the train set used as validation set in case there's no validation split\"\n        },\n    )\n    max_seq_length: Optional[int] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"The maximum total input sequence length after tokenization and masking. Sequences longer than this\"\n                \" will be truncated. Default to the max input length of the model.\"\n            )\n        },\n    )\n    preprocessing_num_workers: Optional[int] = field(\n        default=None,\n        metadata={\"help\": \"The number of processes to use for the preprocessing.\"},\n    )\n    mlm_probability: float = field(\n        default=0.15, metadata={\"help\": \"Ratio of tokens to mask for span masked language modeling loss\"}\n    )\n    mean_noise_span_length: float = field(\n        default=3.0,\n        metadata={\"help\": \"Mean span length of masked tokens\"},\n    )\n\n    def __post_init__(self):\n        if self.dataset_name is None and self.train_file is None and self.validation_file is None:\n            raise ValueError(\"Need either a dataset name or a training/validation file.\")\n        else:\n            if self.train_file is not None:\n                extension = self.train_file.split(\".\")[-1]\n                assert extension in [\"csv\", \"json\", \"txt\"], \"`train_file` should be a csv, a json or a txt file.\"\n            if self.validation_file is not None:\n                extension = self.validation_file.split(\".\")[-1]\n                assert extension in [\"csv\", \"json\", \"txt\"], \"`validation_file` should be a csv, a json or a txt file.\"", "\n\ndef compute_input_and_target_lengths(inputs_length, noise_density, mean_noise_span_length):\n    \"\"\"This function is copy of `random_spans_helper <https://github.com/google-research/text-to-text-transfer-transformer/blob/84f8bcc14b5f2c03de51bd3587609ba8f6bbd1cd/t5/data/preprocessors.py#L2466>`__ .\n\n    Training parameters to avoid padding with random_spans_noise_mask.\n    When training a model with random_spans_noise_mask, we would like to set the other\n    training hyperparmeters in a way that avoids padding.\n    This function helps us compute these hyperparameters.\n    We assume that each noise span in the input is replaced by extra_tokens_per_span_inputs sentinel tokens,\n    and each non-noise span in the targets is replaced by extra_tokens_per_span_targets sentinel tokens.\n    This function tells us the required number of tokens in the raw example (for split_tokens())\n    as well as the length of the encoded targets. Note that this function assumes\n    the inputs and targets will have EOS appended and includes that in the reported length.\n\n    Args:\n        inputs_length: an integer - desired length of the tokenized inputs sequence\n        noise_density: a float\n        mean_noise_span_length: a float\n    Returns:\n        tokens_length: length of original text in tokens\n        targets_length: an integer - length in tokens of encoded targets sequence\n    \"\"\"\n\n    def _tokens_length_to_inputs_length_targets_length(tokens_length):\n        num_noise_tokens = int(round(tokens_length * noise_density))\n        num_nonnoise_tokens = tokens_length - num_noise_tokens\n        num_noise_spans = int(round(num_noise_tokens / mean_noise_span_length))\n        # inputs contain all nonnoise tokens, sentinels for all noise spans\n        # and one EOS token.\n        _input_length = num_nonnoise_tokens + num_noise_spans + 1\n        _output_length = num_noise_tokens + num_noise_spans + 1\n        return _input_length, _output_length\n\n    tokens_length = inputs_length\n\n    while _tokens_length_to_inputs_length_targets_length(tokens_length + 1)[0] <= inputs_length:\n        tokens_length += 1\n\n    inputs_length, targets_length = _tokens_length_to_inputs_length_targets_length(tokens_length)\n\n    # minor hack to get the targets length to be equal to inputs length\n    # which is more likely to have been set to a nice round number.\n    if noise_density == 0.5 and targets_length > inputs_length:\n        tokens_length -= 1\n        targets_length -= 1\n    return tokens_length, targets_length", "\n\n@flax.struct.dataclass\nclass FlaxDataCollatorForT5MLM:\n    \"\"\"\n    Data collator used for T5 span-masked language modeling.\n    It is made sure that after masking the inputs are of length `data_args.max_seq_length` and targets are also of fixed length.\n    For more information on how T5 span-masked language modeling works, one can take a look\n    at the `official paper <https://arxiv.org/pdf/1910.10683.pdf>`__\n    or the `official code for preprocessing <https://github.com/google-research/text-to-text-transfer-transformer/blob/master/t5/data/preprocessors.py>`__ .\n\n    Args:\n        tokenizer (:class:`~transformers.PreTrainedTokenizer` or :class:`~transformers.PreTrainedTokenizerFast`):\n            The tokenizer used for encoding the data.\n        noise_density (:obj:`float`):\n            The probability with which to (randomly) mask tokens in the input.\n        mean_noise_span_length (:obj:`float`):\n            The average span length of the masked tokens.\n        input_length (:obj:`int`):\n            The expected input length after masking.\n        target_length (:obj:`int`):\n            The expected target length after masking.\n        pad_token_id: (:obj:`int`):\n            The pad token id of the model\n        decoder_start_token_id: (:obj:`int):\n            The decoder start token id of the model\n    \"\"\"\n\n    tokenizer: PreTrainedTokenizerBase\n    noise_density: float\n    mean_noise_span_length: float\n    input_length: int\n    target_length: int\n    pad_token_id: int\n    decoder_start_token_id: int\n\n    def __call__(self, examples: List[Dict[str, np.ndarray]]) -> BatchEncoding:\n\n        # convert list to dict and tensorize input\n        batch = BatchEncoding(\n            {k: np.array([examples[i][k] for i in range(len(examples))]) for k, v in examples[0].items()}\n        )\n\n        input_ids = batch[\"input_ids\"]\n        batch_size, expandend_input_length = input_ids.shape\n\n        mask_indices = np.asarray([self.random_spans_noise_mask(expandend_input_length) for i in range(batch_size)])\n        labels_mask = ~mask_indices\n\n        input_ids_sentinel = self.create_sentinel_ids(mask_indices.astype(np.int8))\n        labels_sentinel = self.create_sentinel_ids(labels_mask.astype(np.int8))\n\n        batch[\"input_ids\"] = self.filter_input_ids(input_ids, input_ids_sentinel)\n        batch[\"labels\"] = self.filter_input_ids(input_ids, labels_sentinel)\n\n        if batch[\"input_ids\"].shape[-1] != self.input_length:\n            raise ValueError(\n                f\"`input_ids` are incorrectly preprocessed. `input_ids` length is {batch['input_ids'].shape[-1]}, but\"\n                f\" should be {self.target_length}.\"\n            )\n\n        if batch[\"labels\"].shape[-1] != self.target_length:\n            raise ValueError(\n                f\"`labels` are incorrectly preprocessed. `labels` length is {batch['labels'].shape[-1]}, but should be\"\n                f\" {self.target_length}.\"\n            )\n\n        # to check that tokens are correctly preprocessed, one can run `self.tokenizer.batch_decode(input_ids)` and `self.tokenizer.batch_decode(labels)` here...\n        batch[\"decoder_input_ids\"] = shift_tokens_right(\n            batch[\"labels\"], self.pad_token_id, self.decoder_start_token_id\n        )\n\n        return batch\n\n    def create_sentinel_ids(self, mask_indices):\n        \"\"\"\n        Sentinel ids creation given the indices that should be masked.\n        The start indices of each mask are replaced by the sentinel ids in increasing\n        order. Consecutive mask indices to be deleted are replaced with `-1`.\n        \"\"\"\n        start_indices = mask_indices - np.roll(mask_indices, 1, axis=-1) * mask_indices\n        start_indices[:, 0] = mask_indices[:, 0]\n\n        sentinel_ids = np.where(start_indices != 0, np.cumsum(start_indices, axis=-1), start_indices)\n        sentinel_ids = np.where(sentinel_ids != 0, (len(self.tokenizer) - sentinel_ids), 0)\n        sentinel_ids -= mask_indices - start_indices\n\n        return sentinel_ids\n\n    def filter_input_ids(self, input_ids, sentinel_ids):\n        \"\"\"\n        Puts sentinel mask on `input_ids` and fuse consecutive mask tokens into a single mask token by deleting.\n        This will reduce the sequence length from `expanded_inputs_length` to `input_length`.\n        \"\"\"\n        batch_size = input_ids.shape[0]\n\n        input_ids_full = np.where(sentinel_ids != 0, sentinel_ids, input_ids)\n        # input_ids tokens and sentinel tokens are >= 0, tokens < 0 are\n        # masked tokens coming after sentinel tokens and should be removed\n        input_ids = input_ids_full[input_ids_full >= 0].reshape((batch_size, -1))\n        input_ids = np.concatenate(\n            [input_ids, np.full((batch_size, 1), self.tokenizer.eos_token_id, dtype=np.int32)], axis=-1\n        )\n        return input_ids\n\n    def random_spans_noise_mask(self, length):\n\n        \"\"\"This function is copy of `random_spans_helper <https://github.com/google-research/text-to-text-transfer-transformer/blob/84f8bcc14b5f2c03de51bd3587609ba8f6bbd1cd/t5/data/preprocessors.py#L2682>`__ .\n\n        Noise mask consisting of random spans of noise tokens.\n        The number of noise tokens and the number of noise spans and non-noise spans\n        are determined deterministically as follows:\n        num_noise_tokens = round(length * noise_density)\n        num_nonnoise_spans = num_noise_spans = round(num_noise_tokens / mean_noise_span_length)\n        Spans alternate between non-noise and noise, beginning with non-noise.\n        Subject to the above restrictions, all masks are equally likely.\n\n        Args:\n            length: an int32 scalar (length of the incoming token sequence)\n            noise_density: a float - approximate density of output mask\n            mean_noise_span_length: a number\n\n        Returns:\n            a boolean tensor with shape [length]\n        \"\"\"\n\n        orig_length = length\n\n        num_noise_tokens = int(np.round(length * self.noise_density))\n        # avoid degeneracy by ensuring positive numbers of noise and nonnoise tokens.\n        num_noise_tokens = min(max(num_noise_tokens, 1), length - 1)\n        num_noise_spans = int(np.round(num_noise_tokens / self.mean_noise_span_length))\n\n        # avoid degeneracy by ensuring positive number of noise spans\n        num_noise_spans = max(num_noise_spans, 1)\n        num_nonnoise_tokens = length - num_noise_tokens\n\n        # pick the lengths of the noise spans and the non-noise spans\n        def _random_segmentation(num_items, num_segments):\n            \"\"\"Partition a sequence of items randomly into non-empty segments.\n            Args:\n                num_items: an integer scalar > 0\n                num_segments: an integer scalar in [1, num_items]\n            Returns:\n                a Tensor with shape [num_segments] containing positive integers that add\n                up to num_items\n            \"\"\"\n            mask_indices = np.arange(num_items - 1) < (num_segments - 1)\n            np.random.shuffle(mask_indices)\n            first_in_segment = np.pad(mask_indices, [[1, 0]])\n            segment_id = np.cumsum(first_in_segment)\n            # count length of sub segments assuming that list is sorted\n            _, segment_length = np.unique(segment_id, return_counts=True)\n            return segment_length\n\n        noise_span_lengths = _random_segmentation(num_noise_tokens, num_noise_spans)\n        nonnoise_span_lengths = _random_segmentation(num_nonnoise_tokens, num_noise_spans)\n\n        interleaved_span_lengths = np.reshape(\n            np.stack([nonnoise_span_lengths, noise_span_lengths], axis=1), [num_noise_spans * 2]\n        )\n        span_starts = np.cumsum(interleaved_span_lengths)[:-1]\n        span_start_indicator = np.zeros((length,), dtype=np.int8)\n        span_start_indicator[span_starts] = True\n        span_num = np.cumsum(span_start_indicator)\n        is_noise = np.equal(span_num % 2, 1)\n\n        return is_noise[:orig_length]", "\n\ndef generate_batch_splits(samples_idx: np.ndarray, batch_size: int, drop_last=True) -> np.ndarray:\n    \"\"\"Generate batches of data for a specified batch size from sample indices. If the dataset size is not divisible by\n    the batch size and `drop_last` is `True`, the last incomplete batch is dropped. Else, it is returned.\"\"\"\n    num_samples = len(samples_idx)\n    if drop_last:\n        samples_to_remove = num_samples % batch_size\n        if samples_to_remove != 0:\n            samples_idx = samples_idx[:-samples_to_remove]\n        sections_split = num_samples // batch_size\n        samples_idx = samples_idx.reshape((sections_split, batch_size))\n    else:\n        sections_split = math.ceil(num_samples / batch_size)\n        samples_idx = np.array_split(samples_idx, sections_split)\n    return samples_idx", "\n\ndef write_train_metric(summary_writer, train_metrics, train_time, step):\n    summary_writer.scalar(\"train_time\", train_time, step)\n\n    train_metrics = get_metrics(train_metrics)\n    for key, vals in train_metrics.items():\n        tag = f\"train_{key}\"\n        for i, val in enumerate(vals):\n            summary_writer.scalar(tag, val, step - len(vals) + i + 1)", "\n\ndef write_eval_metric(summary_writer, eval_metrics, step):\n    for metric_name, value in eval_metrics.items():\n        summary_writer.scalar(f\"eval_{metric_name}\", value, step)\n\n\ndef main():\n    # See all possible arguments in src/transformers/training_args.py\n    # or by passing the --help flag to this script.\n    # We now keep distinct sets of args, for a cleaner separation of concerns.\n\n    parser = HfArgumentParser((ModelArguments, DataTrainingArguments, TrainingArguments))\n    if len(sys.argv) == 2 and sys.argv[1].endswith(\".json\"):\n        # If we pass only one argument to the script and it's the path to a json file,\n        # let's parse it to get our arguments.\n        model_args, data_args, training_args = parser.parse_json_file(json_file=os.path.abspath(sys.argv[1]))\n    else:\n        model_args, data_args, training_args = parser.parse_args_into_dataclasses()\n\n    # Sending telemetry. Tracking the example usage helps us better allocate resources to maintain them. The\n    # information sent is the one passed as arguments along with your Python/PyTorch versions.\n    send_example_telemetry(\"run_t5_mlm\", model_args, data_args, framework=\"flax\")\n\n    if (\n        os.path.exists(training_args.output_dir)\n        and os.listdir(training_args.output_dir)\n        and training_args.do_train\n        and not training_args.overwrite_output_dir\n    ):\n        raise ValueError(\n            f\"Output directory ({training_args.output_dir}) already exists and is not empty.\"\n            \"Use --overwrite_output_dir to overcome.\"\n        )\n\n    # Setup logging\n    logging.basicConfig(\n        format=\"%(asctime)s - %(levelname)s - %(name)s -   %(message)s\",\n        level=logging.INFO,\n        datefmt=\"[%X]\",\n    )\n\n    # Log on each process the small summary:\n    logger = logging.getLogger(__name__)\n\n    # Set the verbosity to info of the Transformers logger (on main process only):\n    logger.info(f\"Training/evaluation parameters {training_args}\")\n\n    # Set seed before initializing model.\n    set_seed(training_args.seed)\n\n    # Handle the repository creation\n    if training_args.push_to_hub:\n        if training_args.hub_model_id is None:\n            repo_name = get_full_repo_name(\n                Path(training_args.output_dir).absolute().name, token=training_args.hub_token\n            )\n        else:\n            repo_name = training_args.hub_model_id\n        repo = Repository(training_args.output_dir, clone_from=repo_name)\n\n    # Get the datasets: you can either provide your own CSV/JSON/TXT training and evaluation files (see below)\n    # or just provide the name of one of the public datasets available on the hub at https://huggingface.co/datasets/\n    # (the dataset will be downloaded automatically from the datasets Hub).\n    #\n    # For CSV/JSON files, this script will use the column called 'text' or the first column if no column called\n    # 'text' is found. You can easily tweak this behavior (see below).\n    if data_args.dataset_name is not None:\n        # Downloading and loading a dataset from the hub.\n        datasets = load_dataset(\n            data_args.dataset_name,\n            data_args.dataset_config_name,\n            cache_dir=model_args.cache_dir,\n            use_auth_token=True if model_args.use_auth_token else None,\n        )\n\n        if \"validation\" not in datasets.keys():\n            datasets[\"validation\"] = load_dataset(\n                data_args.dataset_name,\n                data_args.dataset_config_name,\n                split=f\"train[:{data_args.validation_split_percentage}%]\",\n                cache_dir=model_args.cache_dir,\n                use_auth_token=True if model_args.use_auth_token else None,\n            )\n            datasets[\"train\"] = load_dataset(\n                data_args.dataset_name,\n                data_args.dataset_config_name,\n                split=f\"train[{data_args.validation_split_percentage}%:]\",\n                cache_dir=model_args.cache_dir,\n                use_auth_token=True if model_args.use_auth_token else None,\n            )\n    else:\n        data_files = {}\n        if data_args.train_file is not None:\n            data_files[\"train\"] = data_args.train_file\n        if data_args.validation_file is not None:\n            data_files[\"validation\"] = data_args.validation_file\n        extension = data_args.train_file.split(\".\")[-1]\n        if extension == \"txt\":\n            extension = \"text\"\n        datasets = load_dataset(\n            extension,\n            data_files=data_files,\n            cache_dir=model_args.cache_dir,\n            use_auth_token=True if model_args.use_auth_token else None,\n        )\n\n        if \"validation\" not in datasets.keys():\n            datasets[\"validation\"] = load_dataset(\n                extension,\n                data_files=data_files,\n                split=f\"train[:{data_args.validation_split_percentage}%]\",\n                cache_dir=model_args.cache_dir,\n                use_auth_token=True if model_args.use_auth_token else None,\n            )\n            datasets[\"train\"] = load_dataset(\n                extension,\n                data_files=data_files,\n                split=f\"train[{data_args.validation_split_percentage}%:]\",\n                cache_dir=model_args.cache_dir,\n                use_auth_token=True if model_args.use_auth_token else None,\n            )\n    # See more about loading any type of standard or custom dataset (from files, python dict, pandas DataFrame, etc) at\n    # https://huggingface.co/docs/datasets/loading_datasets.html.\n\n    # Load pretrained model and tokenizer\n\n    if model_args.tokenizer_name:\n        tokenizer = AutoTokenizer.from_pretrained(\n            model_args.tokenizer_name,\n            cache_dir=model_args.cache_dir,\n            use_fast=model_args.use_fast_tokenizer,\n            use_auth_token=True if model_args.use_auth_token else None,\n        )\n    elif model_args.model_name_or_path:\n        tokenizer = AutoTokenizer.from_pretrained(\n            model_args.model_name_or_path,\n            cache_dir=model_args.cache_dir,\n            use_fast=model_args.use_fast_tokenizer,\n            use_auth_token=True if model_args.use_auth_token else None,\n        )\n    else:\n        raise ValueError(\n            \"You are instantiating a new tokenizer from scratch. This is not supported by this script.\"\n            \"You can do it from another script, save it, and load it from here, using --tokenizer_name.\"\n        )\n\n    if model_args.config_name:\n        config = T5Config.from_pretrained(\n            model_args.config_name,\n            cache_dir=model_args.cache_dir,\n            vocab_size=len(tokenizer),\n            use_auth_token=True if model_args.use_auth_token else None,\n        )\n    elif model_args.model_name_or_path:\n        config = T5Config.from_pretrained(\n            model_args.model_name_or_path,\n            cache_dir=model_args.cache_dir,\n            use_auth_token=True if model_args.use_auth_token else None,\n        )\n    else:\n        config = CONFIG_MAPPING[model_args.model_type]()\n        logger.warning(\"You are instantiating a new config instance from scratch.\")\n\n    # Preprocessing the datasets.\n    # First we tokenize all the texts.\n    if training_args.do_train:\n        column_names = datasets[\"train\"].column_names\n    else:\n        column_names = datasets[\"validation\"].column_names\n    text_column_name = \"text\" if \"text\" in column_names else column_names[0]\n\n    max_seq_length = min(data_args.max_seq_length, tokenizer.model_max_length)\n\n    # Otherwise, we tokenize every text, then concatenate them together before splitting them in smaller parts.\n    # Since we make sure that all sequences are of the same length, no attention_mask is needed.\n    def tokenize_function(examples):\n        return tokenizer(examples[text_column_name], return_attention_mask=False)\n\n    tokenized_datasets = datasets.map(\n        tokenize_function,\n        batched=True,\n        num_proc=data_args.preprocessing_num_workers,\n        remove_columns=column_names,\n        load_from_cache_file=not data_args.overwrite_cache,\n    )\n\n    # T5-like span masked language modeling will fuse consecutively masked tokens to a single sentinel token.\n    # To ensure that the input length is `max_seq_length`, we need to increase the maximum length\n    # according to `mlm_probability` and `mean_noise_span_length`. We can also define the label length accordingly.\n    expanded_inputs_length, targets_length = compute_input_and_target_lengths(\n        inputs_length=max_seq_length,\n        noise_density=data_args.mlm_probability,\n        mean_noise_span_length=data_args.mean_noise_span_length,\n    )\n\n    # Main data processing function that will concatenate all texts from our dataset and generate chunks of expanded_inputs_length.\n    def group_texts(examples):\n        # Concatenate all texts.\n        concatenated_examples = {k: list(chain(*examples[k])) for k in examples.keys()}\n        total_length = len(concatenated_examples[list(examples.keys())[0]])\n        # We drop the small remainder, we could add padding if the model supported it instead of this drop, you can\n        # customize this part to your needs.\n        if total_length >= expanded_inputs_length:\n            total_length = (total_length // expanded_inputs_length) * expanded_inputs_length\n        # Split by chunks of max_len.\n        result = {\n            k: [t[i : i + expanded_inputs_length] for i in range(0, total_length, expanded_inputs_length)]\n            for k, t in concatenated_examples.items()\n        }\n        return result\n\n    # Note that with `batched=True`, this map processes 1,000 texts together, so group_texts throws away a\n    # remainder for each of those groups of 1,000 texts. You can adjust that batch_size here but a higher value\n    # might be slower to preprocess.\n    #\n    # To speed up this part, we use multiprocessing. See the documentation of the map method for more information:\n    # https://huggingface.co/docs/datasets/package_reference/main_classes.html#datasets.Dataset.map\n    tokenized_datasets = tokenized_datasets.map(\n        group_texts,\n        batched=True,\n        num_proc=data_args.preprocessing_num_workers,\n        load_from_cache_file=not data_args.overwrite_cache,\n    )\n\n    # Enable tensorboard only on the master node\n    has_tensorboard = is_tensorboard_available()\n    if has_tensorboard and jax.process_index() == 0:\n        try:\n            from flax.metrics.tensorboard import SummaryWriter\n\n            summary_writer = SummaryWriter(log_dir=Path(training_args.output_dir))\n        except ImportError as ie:\n            has_tensorboard = False\n            logger.warning(\n                f\"Unable to display metrics through TensorBoard because some package are not installed: {ie}\"\n            )\n    else:\n        logger.warning(\n            \"Unable to display metrics through TensorBoard because the package is not installed: \"\n            \"Please run pip install tensorboard to enable.\"\n        )\n\n    # Initialize our training\n    rng = jax.random.PRNGKey(training_args.seed)\n    dropout_rngs = jax.random.split(rng, jax.local_device_count())\n\n    if model_args.model_name_or_path:\n        model = FlaxT5ForConditionalGeneration.from_pretrained(\n            model_args.model_name_or_path,\n            config=config,\n            seed=training_args.seed,\n            dtype=getattr(jnp, model_args.dtype),\n            use_auth_token=True if model_args.use_auth_token else None,\n        )\n    else:\n        config.vocab_size = len(tokenizer)\n        model = FlaxT5ForConditionalGeneration(\n            config,\n            seed=training_args.seed,\n            dtype=getattr(jnp, model_args.dtype),\n        )\n\n    if model_args.rerandomize:\n        model.init_weights(rng, model.input_shape)\n\n    # Data collator\n    # This one will take care of randomly masking the tokens.\n    data_collator = FlaxDataCollatorForT5MLM(\n        tokenizer=tokenizer,\n        noise_density=data_args.mlm_probability,\n        mean_noise_span_length=data_args.mean_noise_span_length,\n        input_length=max_seq_length,\n        target_length=targets_length,\n        pad_token_id=model.config.pad_token_id,\n        decoder_start_token_id=model.config.decoder_start_token_id,\n    )\n\n    # Store some constant\n    num_epochs = int(training_args.num_train_epochs)\n    num_steps = int(training_args.num_train_steps)\n    train_batch_size = int(training_args.per_device_train_batch_size) * jax.device_count()\n    per_device_eval_batch_size = int(training_args.per_device_eval_batch_size)\n    eval_batch_size = per_device_eval_batch_size * jax.device_count()\n\n    num_train_steps = len(tokenized_datasets[\"train\"]) // train_batch_size * num_epochs\n    if num_steps > 0:\n        num_train_steps = num_steps\n        num_epochs = math.ceil((num_train_steps * train_batch_size) / len(tokenized_datasets[\"train\"]))\n\n    if training_args.save_epochs > 0:\n        save_steps = len(tokenized_datasets[\"train\"]) // train_batch_size * training_args.save_epochs\n    else:\n        save_steps = training_args.save_steps\n    if training_args.eval_epochs > 0:\n        eval_steps = len(tokenized_datasets[\"train\"]) // train_batch_size * training_args.eval_epochs\n    else:\n        eval_steps = training_args.eval_steps\n\n\n    num_of_hosts = jax.process_count()\n    current_host_idx = jax.process_index()\n\n    # Create learning rate schedule\n    warmup_fn = optax.linear_schedule(\n        init_value=0.0, end_value=training_args.learning_rate, transition_steps=training_args.warmup_steps\n    )\n    decay_fn = optax.linear_schedule(\n        init_value=training_args.learning_rate,\n        end_value=0,\n        transition_steps=num_train_steps - training_args.warmup_steps,\n    )\n    linear_decay_lr_schedule_fn = optax.join_schedules(\n        schedules=[warmup_fn, decay_fn], boundaries=[training_args.warmup_steps]\n    )\n\n    # We use Optax's \"masking\" functionality to not apply weight decay\n    # to bias and LayerNorm scale parameters. decay_mask_fn returns a\n    # mask boolean with the same structure as the parameters.\n    # The mask is True for parameters that should be decayed.\n    def decay_mask_fn(params):\n        flat_params = traverse_util.flatten_dict(params)\n        # find out all LayerNorm parameters\n        layer_norm_candidates = [\"layernorm\", \"layer_norm\", \"ln\"]\n        layer_norm_named_params = set(\n            [\n                layer[-2:]\n                for layer_norm_name in layer_norm_candidates\n                for layer in flat_params.keys()\n                if layer_norm_name in \"\".join(layer).lower()\n            ]\n        )\n        flat_mask = {path: (path[-1] != \"bias\" and path[-2:] not in layer_norm_named_params) for path in flat_params}\n        return traverse_util.unflatten_dict(flat_mask)\n\n    # create adam optimizer\n    if training_args.adafactor:\n        # We use the default parameters here to initialize adafactor,\n        # For more details about the parameters please check https://github.com/deepmind/optax/blob/ed02befef9bf81cbbf236be3d2b0e032e9ed4a40/optax/_src/alias.py#L74\n        optimizer = optax.adafactor(\n            learning_rate=linear_decay_lr_schedule_fn,\n        )\n    else:\n        optimizer = optax.adamw(\n            learning_rate=linear_decay_lr_schedule_fn,\n            b1=training_args.adam_beta1,\n            b2=training_args.adam_beta2,\n            weight_decay=training_args.weight_decay,\n            mask=decay_mask_fn,\n        )\n\n    # Setup train state\n    state = train_state.TrainState.create(apply_fn=model.__call__, params=model.params, tx=optimizer)\n\n    # Define gradient update step fn\n    def train_step(state, batch, dropout_rng):\n        dropout_rng, new_dropout_rng = jax.random.split(dropout_rng)\n\n        def loss_fn(params):\n            labels = batch.pop(\"labels\")\n\n            logits = state.apply_fn(**batch, params=params, dropout_rng=dropout_rng, train=True)[0]\n\n            # compute loss\n            loss = optax.softmax_cross_entropy(logits, onehot(labels, logits.shape[-1])).mean()\n\n            return loss\n\n        grad_fn = jax.value_and_grad(loss_fn)\n        loss, grad = grad_fn(state.params)\n        grad = jax.lax.pmean(grad, \"batch\")\n        new_state = state.apply_gradients(grads=grad)\n\n        metrics = jax.lax.pmean(\n            {\"loss\": loss, \"learning_rate\": linear_decay_lr_schedule_fn(state.step)}, axis_name=\"batch\"\n        )\n\n        return new_state, metrics, new_dropout_rng\n\n    # Create parallel version of the train step\n    p_train_step = jax.pmap(train_step, \"batch\", donate_argnums=(0,))\n\n    # Define eval fn\n    def eval_step(params, batch):\n        labels = batch.pop(\"labels\")\n\n        logits = model(**batch, params=params, train=False)[0]\n\n        # compute loss\n        loss = optax.softmax_cross_entropy(logits, onehot(labels, logits.shape[-1]))\n\n        # compute accuracy\n        accuracy = jnp.equal(jnp.argmax(logits, axis=-1), labels)\n\n        # summarize metrics\n        metrics = {\"loss\": loss.mean(), \"accuracy\": accuracy.mean()}\n        metrics = jax.lax.pmean(metrics, axis_name=\"batch\")\n\n        return metrics\n\n    \n    p_eval_step = jax.pmap(eval_step, \"batch\", donate_argnums=(0,))\n\n    # Replicate the train state on each device\n    state = jax_utils.replicate(state)\n\n    train_time = 0\n    epochs = tqdm(range(num_epochs), desc=\"Epoch ... \", position=0)\n    for epoch in epochs:\n        # ======================== Training ================================\n        train_start = time.time()\n        train_metrics = []\n\n        # Create sampling rng\n        rng, input_rng = jax.random.split(rng)\n\n        # Generate an epoch by shuffling sampling indices from the train dataset\n        num_train_samples = len(tokenized_datasets[\"train\"])\n        # Avoid using jax.numpy here in case of TPU training\n        train_samples_idx = np.random.permutation(np.arange(num_train_samples))\n        train_batch_idx = generate_batch_splits(train_samples_idx, train_batch_size)\n\n        # Gather the indexes for creating the batch and do a training step\n        for step, batch_idx in enumerate(tqdm(train_batch_idx, desc=\"Training...\", position=1)):\n            samples = [tokenized_datasets[\"train\"][int(idx)] for idx in batch_idx]\n            model_inputs = data_collator(samples)\n\n            local_host_model_inputs = {\n                key: np.split(model_inputs.data[key], num_of_hosts, axis=0)[current_host_idx]\n                for key, value in model_inputs.data.items()\n            }\n\n            # Model forward\n            model_inputs = shard(local_host_model_inputs)\n            state, train_metric, dropout_rngs = p_train_step(state, model_inputs, dropout_rngs)\n            train_metrics.append(train_metric)\n\n            cur_step = epoch * (num_train_samples // train_batch_size) + step\n\n            if cur_step % training_args.logging_steps == 0 and cur_step > 0:\n                # Save metrics\n                train_metric = jax_utils.unreplicate(train_metric)\n                train_time += time.time() - train_start\n                if has_tensorboard and jax.process_index() == 0:\n                    write_train_metric(summary_writer, train_metrics, train_time, cur_step)\n\n                epochs.write(\n                    f\"Step... ({cur_step} | Loss: {train_metric['loss'].mean()}, Learning Rate:\"\n                    f\" {train_metric['learning_rate'].mean()})\"\n                )\n\n                train_metrics = []\n\n            if cur_step % eval_steps == 0 and cur_step > 0:\n                # ======================== Evaluating ==============================\n                num_eval_samples = len(tokenized_datasets[\"validation\"])\n                # Avoid using jax.numpy here in case of TPU training\n                eval_samples_idx = np.arange(num_eval_samples)\n                eval_batch_idx = generate_batch_splits(eval_samples_idx, eval_batch_size, drop_last=False)\n\n                eval_metrics = []\n                for i, batch_idx in enumerate(tqdm(eval_batch_idx, desc=\"Evaluating ...\", position=2)):\n                    samples = [tokenized_datasets[\"validation\"][int(idx)] for idx in batch_idx]\n                    model_inputs = data_collator(samples)\n\n                    # Model forward\n                    metrics = pad_shard_unpad(p_eval_step, static_return=True)(\n                        state.params, model_inputs.data, min_device_batch=per_device_eval_batch_size\n                    )\n                    eval_metrics.append(metrics)\n\n                # get eval metrics\n                eval_metrics = get_metrics(eval_metrics)\n                eval_metrics = jax.tree_util.tree_map(jnp.mean, eval_metrics)\n\n                # Update progress bar\n                epochs.write(f\"Step... ({cur_step} | Loss: {eval_metrics['loss']}, Acc: {eval_metrics['accuracy']})\")\n\n                # Save metrics\n                if has_tensorboard and jax.process_index() == 0:\n                    write_eval_metric(summary_writer, eval_metrics, cur_step)\n\n            if cur_step % save_steps == 0 and cur_step > 0:\n                # save checkpoint after each epoch and push checkpoint to the hub\n                if jax.process_index() == 0:\n                    params = jax.device_get(jax.tree_util.tree_map(lambda x: x[0], state.params))\n                    checkpoint_dir = os.path.join(training_args.output_dir, f\"checkpoint-{cur_step}\")\n                    model.save_pretrained(checkpoint_dir, params=params)\n                    tokenizer.save_pretrained(training_args.output_dir)\n                    if training_args.push_to_hub:\n                        repo.push_to_hub(commit_message=f\"Saving weights and logs of step {cur_step}\", blocking=False)\n            \n            if num_steps > 0 and cur_step >= num_train_steps:\n                break\n\n    # Eval after training\n    if training_args.do_eval:\n        num_eval_samples = len(tokenized_datasets[\"validation\"])\n        # Avoid using jax.numpy here in case of TPU training\n        eval_samples_idx = np.arange(num_eval_samples)\n        eval_batch_idx = generate_batch_splits(eval_samples_idx, eval_batch_size, drop_last=False)\n\n        eval_metrics = []\n        for i, batch_idx in enumerate(tqdm(eval_batch_idx, desc=\"Evaluating ...\", position=2)):\n            samples = [tokenized_datasets[\"validation\"][int(idx)] for idx in batch_idx]\n            model_inputs = data_collator(samples)\n\n            # Model forward\n            metrics = pad_shard_unpad(p_eval_step, static_return=True)(\n                state.params, model_inputs.data, min_device_batch=per_device_eval_batch_size\n            )\n            eval_metrics.append(metrics)\n\n        # get eval metrics\n        eval_metrics = get_metrics(eval_metrics)\n        eval_metrics = jax.tree_util.tree_map(lambda metric: jnp.mean(metric).item(), eval_metrics)\n\n        if jax.process_index() == 0:\n            eval_metrics = {f\"eval_{metric_name}\": value for metric_name, value in eval_metrics.items()}\n            path = os.path.join(training_args.output_dir, \"eval_results.json\")\n            with open(path, \"w\") as f:\n                json.dump(eval_metrics, f, indent=4, sort_keys=True)", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "scripts/general_train.py", "chunked_list": ["import argparse\nimport os\nimport pdb\nimport importlib\nimport setuptools\nimport functools\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n", "warnings.filterwarnings(\"ignore\")\n\nfrom pt_framework.epoch_based_runner import EpochBasedRunner\nfrom pt_framework.dist_utils import init_dist\n\n\nfrom babylm_baseline_train.basic_param_setter import ParamsBuilder\nimport babylm_baseline_train.models.helper as helper\nfrom babylm_baseline_train.train.tk_funcs import\\\n        get_tokenizer_func", "from babylm_baseline_train.train.tk_funcs import\\\n        get_tokenizer_func\nfrom babylm_baseline_train.datasets.babyLM import get_babyLM_10M\nfrom babylm_baseline_train.datasets.utils import collate_fn\nfrom babylm_baseline_train.train.utils import get_setting_func\n\n\ndef get_parser():\n    parser = argparse.ArgumentParser(\n            description='Pytorch training framework for general dist training')\n    parser.add_argument(\n            '--setting', \n            default=None, type=str, \n            action='store')\n    parser.add_argument(\n            '--local_rank', type=int, default=0,\n            help='Used during distributed training')\n    parser.add_argument(\n            '--train_upto_epoch', type=int, default=None,\n            help='Number of epochs to be run upto')\n    parser.add_argument(\n            '--exp_id', \n            default='test_strict_small', type=str, \n            action='store')\n    parser.add_argument(\n            '--opt_model_size', \n            default='125m', type=str, \n            action='store')\n    return parser", "\n\ndef get_key_params(args):\n    get_model_func = functools.partial(\n            helper.get_opt_func, \n            opt_model_size=args.opt_model_size)\n\n    tokenizer = get_tokenizer_func()\n    add_train_loader_kwargs = dict(collate_fn=collate_fn)\n\n    params = dict(\n            exp_id=args.exp_id, col_name='babylm_test',\n            get_model_func=get_model_func,\n            get_dataset_func=functools.partial(\n                get_babyLM_10M, tokenizer=tokenizer),\n            optimizer_cfg=dict(\n                type='AdamW', lr=1e-4, weight_decay=0.1,\n                ),\n            add_train_loader_kwargs=add_train_loader_kwargs,\n            desired_batch_size=128,\n            base_batch_size=128,\n            )\n    return params", "\n\ndef main():\n    parser = get_parser()\n    args = parser.parse_args()\n\n    if 'LOCAL_RANK' not in os.environ:\n        os.environ['LOCAL_RANK'] = str(args.local_rank)\n    init_dist('pytorch')\n    \n    key_params = get_key_params(args)\n    if args.setting is not None:\n        setting_func = get_setting_func(args.setting)\n        key_params = setting_func(key_params)\n\n    params = ParamsBuilder(\n            opt_use_fp16=False,\n            **key_params).build_params()\n    runner = EpochBasedRunner(**params)\n    runner.train(args.train_upto_epoch)", "\n\nif __name__ == '__main__':\n    main()\n"]}
{"filename": "src/babylm_baseline_train/__init__.py", "chunked_list": [""]}
{"filename": "src/babylm_baseline_train/env_vars.py", "chunked_list": ["import os\nimport sys\nfrom os.path import expanduser\n\nhome = expanduser(\"~\")\nROOT_DIR = os.environ.get(\n        'BABYLM_ROOT_DIR',\n        home)\nROOT_DIR_FREQ = os.environ.get(\n        'BABYLM_ROOT_DIR_FREQ',", "ROOT_DIR_FREQ = os.environ.get(\n        'BABYLM_ROOT_DIR_FREQ',\n        ROOT_DIR)\nDATASET_ROOT_DIR = os.environ.get(\n        'BABYLM_DATASET_ROOT_DIR',\n        os.path.join(ROOT_DIR, 'datasets'))\nDEBUG = int(os.environ.get(\n        'DEBUG',\n        '0')) == 1\n", "        '0')) == 1\n"]}
{"filename": "src/babylm_baseline_train/basic_param_setter.py", "chunked_list": ["import argparse\nimport copy\nimport random\nimport pdb\nimport os\nimport os.path as osp\nimport sys\nimport json\nimport re\nimport numpy as np", "import re\nimport numpy as np\nimport logging\nimport time\nimport torch\nimport functools\nfrom tqdm import tqdm\nfrom torch import nn\nimport torch.backends.cudnn as cudnn\nimport torch.optim", "import torch.backends.cudnn as cudnn\nimport torch.optim\nimport torch.utils.data\nimport torchvision.datasets as datasets\nimport torch.distributed as dist\n\nimport pt_framework.hooks.lr_updater as lr_updater\nfrom pt_framework.dist_utils import get_dist_info, init_dist\nfrom pt_framework.utils import mkdir_or_exist, get_root_logger, print_log\nfrom pt_framework.hooks.hook import Hook", "from pt_framework.utils import mkdir_or_exist, get_root_logger, print_log\nfrom pt_framework.hooks.hook import Hook\nfrom pt_framework.hooks.record_saver import MongoDBSaver\nfrom pt_framework.hooks.optimizer import OptimizerHook, DistOptimizerHook\nfrom pt_framework.hooks.checkpoint import CkptSpecifySaveHook\nimport torch.optim as optimizers\n\nfrom .train.env_params import MODEL_SAVE_FOLDER, USE_TPU, REC_SAVE_FOLDER\n\nSAVE_REC_TO_FILE = os.environ.get('SAVE_REC_TO_FILE', '1')", "\nSAVE_REC_TO_FILE = os.environ.get('SAVE_REC_TO_FILE', '1')\nDEBUG = os.environ.get('DEBUG', '0')\nPERSISTENT_WORKERS = int(os.environ.get('PERSISTENT_WORKERS', 1))==1\n\n\ndef build_optimizer(model, optimizer_cfg, verbose=True):\n    \"\"\"Build optimizer from configs.\n\n    Args:\n        model (:obj:`nn.Module`): The model with parameters to be optimized.\n        optimizer_cfg (dict): The config dict of the optimizer.\n            Positional fields are:\n                - type: class name of the optimizer.\n                - lr: base learning rate.\n            Optional fields are:\n                - any arguments of the corresponding optimizer type, e.g.,\n                  weight_decay, momentum, etc.\n                - paramwise_options: a dict with regular expression as keys\n                  to match parameter names and a dict containing options as\n                  values. Options include 6 fields: lr, lr_mult, momentum,\n                  momentum_mult, weight_decay, weight_decay_mult.\n\n    Returns:\n        torch.optim.Optimizer: The initialized optimizer.\n\n    Example:\n        >>> model = torch.nn.modules.Conv1d(1, 1, 1)\n        >>> paramwise_options = {\n        >>>     '(bn|gn)(\\d+)?.(weight|bias)': dict(weight_decay_mult=0.1),\n        >>>     '\\Ahead.': dict(lr_mult=10, momentum=0)}\n        >>> optimizer_cfg = dict(type='SGD', lr=0.01, momentum=0.9,\n        >>>                      weight_decay=0.0001,\n        >>>                      paramwise_options=paramwise_options)\n        >>> optimizer = build_optimizer(model, optimizer_cfg)\n    \"\"\"\n    if hasattr(model, 'module'):\n        model = model.module\n\n    optimizer_cfg = optimizer_cfg.copy()\n    paramwise_options = optimizer_cfg.pop('paramwise_options', None)\n    # if no paramwise option is specified, just use the global setting\n    if paramwise_options is None:\n        optimizer_cls = getattr(optimizers, optimizer_cfg.pop('type'))\n        return optimizer_cls(params=model.parameters(), **optimizer_cfg)\n    else:\n        assert isinstance(paramwise_options, dict)\n        params = []\n        for name, param in model.named_parameters():\n            param_group = {'params': [param]}\n            if not param.requires_grad:\n                params.append(param_group)\n                continue\n\n            for regexp, options in paramwise_options.items():\n                if re.search(regexp, name):\n                    for key, value in options.items():\n                        if key.endswith('_mult'): # is a multiplier\n                            key = key[:-5]\n                            assert key in optimizer_cfg, \\\n                                \"{} not in optimizer_cfg\".format(key)\n                            value = optimizer_cfg[key] * value\n                        param_group[key] = value\n                        if not dist.is_initialized() or dist.get_rank() == 0:\n                            if verbose:\n                                print_log('paramwise_options -- {}: {}={}'.format(\n                                    name, key, value))\n\n            # otherwise use the global settings\n            params.append(param_group)\n\n        optimizer_cls = getattr(optimizers, optimizer_cfg.pop('type'))\n        return optimizer_cls(params, **optimizer_cfg)", "\n\ndef set_random_seed(seed, deterministic=False):\n    \"\"\"Set random seed.\n    Args:\n        seed (int): Seed to be used.\n        deterministic (bool): Whether to set the deterministic option for\n            CUDNN backend, i.e., set `torch.backends.cudnn.deterministic`\n            to True and `torch.backends.cudnn.benchmark` to False.\n            Default: False.\n    \"\"\"\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    if deterministic:\n        torch.backends.cudnn.deterministic = True\n        torch.backends.cudnn.benchmark = False", "\n\nclass SetEpochHook(Hook):\n    def before_epoch(self, runner):\n        dataset = runner.data_loader.dataset\n        assert hasattr(dataset, 'set_epoch')\n        dataset.set_epoch(runner.epoch)\n\n\nclass ParamsBuilder(object):\n    def __init__(\n            self, exp_id, col_name,\n            get_dataset_func, get_model_func,  \n            optimizer_cfg,\n            add_train_loader_kwargs={},\n            batch_processor_params=None,\n            save_rec_to_file=False,\n            opt_update_interval=None,\n            opt_grad_clip={'max_norm': 1.0},\n            opt_use_fp16=True,\n            model_find_unused=False,\n            database_name='babylm_train',\n            desired_batch_size=None, \n            base_batch_size=16,\n            max_epochs=400,\n            seed=None,\n            specify_iter=[50, 200, 1000, 2000, 4000],\n            specify_epoch=[1, 2, 4, 8, 20, 40],\n            ckpt_save_interval=50,\n            shuffle=True):\n        self.exp_id = exp_id\n        self.params = {'max_epochs': max_epochs}\n        self.col_name = col_name\n        self.get_dataset_func = get_dataset_func\n        self.get_model_func = get_model_func\n        self.add_train_loader_kwargs = add_train_loader_kwargs\n        self.batch_processor_params = batch_processor_params\n        self.optimizer_cfg = optimizer_cfg\n        self.save_rec_to_file = save_rec_to_file \\\n                or (int(SAVE_REC_TO_FILE) == 1)\n        self.opt_update_interval = opt_update_interval\n        self.opt_grad_clip = opt_grad_clip\n        self.opt_use_fp16 = opt_use_fp16\n        self.model_find_unused = model_find_unused\n        self.database_name = database_name\n        self.desired_batch_size = desired_batch_size\n        self.base_batch_size = base_batch_size\n        self.shuffle = shuffle\n        self.specify_iter = specify_iter\n        self.specify_epoch = specify_epoch\n        self.ckpt_save_interval = ckpt_save_interval\n        self.setup_opt_update_interval()\n        if seed is not None:\n            set_random_seed(seed)\n\n    def get_save_params(self):\n        ckpt_work_dir = os.path.join(\n                MODEL_SAVE_FOLDER, self.col_name, self.exp_id)\n        rec_work_dir = os.path.join(\n                REC_SAVE_FOLDER, self.col_name, self.exp_id)\n        save_params = {\n                'cache_ckpt_keep_nums': 3,\n                'ckpt_hook_builder': CkptSpecifySaveHook,\n                'ckpt_hook_kwargs': {\n                    'interval': self.ckpt_save_interval,\n                    'out_dir': ckpt_work_dir,\n                    'cache_interval': 1,\n                    'specify_epoch': self.specify_epoch,\n                    'specify_iter': self.specify_iter,\n                    },\n                }\n        if self.save_rec_to_file:\n            save_params['record_saver_kwargs'] = {\n                    'out_dir': rec_work_dir}\n        else:\n            save_params['record_saver_kwargs'] = {\n                    'port': 26001,\n                    'database_name': self.database_name,\n                    'collection_name': self.col_name,\n                    'exp_id': self.exp_id,\n                    'interval': 2500,\n                    'by_epoch': False,\n                    }\n            save_params['record_saver_builder'] = MongoDBSaver\n        self.params['save_params'] = save_params\n\n        rank, _ = get_dist_info()\n        if rank == 0:\n            mkdir_or_exist(rec_work_dir)\n            mkdir_or_exist(ckpt_work_dir)\n        timestamp = time.strftime('%Y%m%d_%H%M%S', time.localtime())\n        log_file = osp.join(rec_work_dir, 'train_{}.log'.format(timestamp))\n        logger = get_root_logger(log_file)\n        self.params['logger'] = logger\n\n    def get_num_workers_batch_size(self):\n        num_workers = int(os.environ.get(\n                'NUM_WORKERS', 8))\n        batch_size = int(os.environ.get(\n                'BATCH_SIZE', self.base_batch_size))\n        rel_batch_size = float(os.environ.get('REL_BATCH_SIZE', 1.0))\n        return num_workers, int(batch_size * rel_batch_size)\n\n    def setup_opt_update_interval(self):\n        if self.desired_batch_size is not None:\n            assert isinstance(self.desired_batch_size, int)\n            _, batch_size = self.get_num_workers_batch_size()\n            _, world_size = get_dist_info()\n            opt_update_interval = self.desired_batch_size // (batch_size * world_size)\n            if opt_update_interval > 1:\n                self.opt_update_interval = opt_update_interval\n\n    def add_one_hook_params(self, one_hook_params):\n        if 'extra_hook_params' not in self.params:\n            self.params['extra_hook_params'] = []\n        self.params['extra_hook_params'].append(one_hook_params)\n\n    def add_set_epoch_hook(self):\n        set_epoch_hook_params = {'builder': SetEpochHook}\n        self.add_one_hook_params(set_epoch_hook_params)\n\n    def get_train_data_params(self):\n        train_data_params = {\n                'dataset_builder': self.get_dataset_func,\n                'shuffle': self.shuffle,\n                }\n        num_workers, batch_size = self.get_num_workers_batch_size()\n          \n        train_data_params.update({\n            'batch_size': int(batch_size),\n            'num_workers': int(num_workers),\n            'distributed': True,\n            'data_loader_kwargs': {\n                'drop_last': True,\n                'persistent_workers': PERSISTENT_WORKERS,\n                },\n            })\n        train_data_params['data_loader_kwargs'].update(\n                self.add_train_loader_kwargs)\n        self.params['train_data_params'] = train_data_params\n        if not self.shuffle:\n            self.add_set_epoch_hook()\n\n    def build_model_optimizer(\n            self, get_model_func, optimizer_cfg):\n        self.model = get_model_func().cuda()\n        self.optimizer = build_optimizer(\n                self.model, \n                optimizer_cfg)\n        if self.opt_use_fp16:\n            import apex\n            self.model, self.optimizer = apex.amp.initialize(self.model, self.optimizer)\n        self.model = torch.nn.parallel.DistributedDataParallel(\n                self.model,\n                device_ids=[torch.cuda.current_device()],\n                find_unused_parameters=self.model_find_unused,\n                )\n        return self.model, self.optimizer\n\n    def get_model_optimizer_params(self):\n        model_optimizer_params = {\n                'builder': self.build_model_optimizer,\n                'builder_kwargs': dict(\n                    get_model_func=self.get_model_func,\n                    optimizer_cfg=self.optimizer_cfg),\n                }\n        self.params['model_optimizer_params'] = model_optimizer_params\n\n    def empty_func(self):\n        return None\n\n    def get_loss_params(self):\n        loss_params = {}\n        loss_params['builder'] = self.empty_func\n        self.params['loss_params'] = loss_params\n\n    def get_learning_rate_params(self):\n        builder_name = 'Fixed'\n        builder = getattr(lr_updater, builder_name + 'LrUpdaterHook')\n        lr_config = dict(\n            warmup='linear',\n            warmup_iters=5000 if self.opt_update_interval is None\\\n                         else 5000 * self.opt_update_interval,\n            warmup_ratio=0.0001, # cannot be 0\n            warmup_by_epoch=False)\n        learning_rate_params = {\n                'builder': builder,\n                'builder_kwargs': lr_config,\n                }\n        self.params['learning_rate_params'] = learning_rate_params\n\n    def naive_processor(self, model, loss_func, data_batch):\n        if not USE_TPU:\n            model_outputs = model(**data_batch)\n            return {'loss': model_outputs['loss']}\n        else:\n            model_outputs = model(\n                    return_dict=False, **data_batch)\n            return {'loss': model_outputs[0]}\n\n    def get_batch_processor_params(self):\n        if self.batch_processor_params is None:\n            batch_processor_params = {\n                    'func': self.naive_processor,\n                    }\n        else:\n            batch_processor_params = self.batch_processor_params\n        self.params['batch_processor_params'] = batch_processor_params\n\n    def get_validation_params(self):\n        self.params['validation_params'] = {}\n\n    def get_optimizer_hook_params(self):\n        optimizer_hook_params = {\n                'builder': OptimizerHook,\n                'builder_kwargs': {\n                    'grad_clip': self.opt_grad_clip,\n                    }}\n        if self.opt_update_interval is not None:\n            assert isinstance(self.opt_update_interval, int)\n            optimizer_hook_params['builder'] = DistOptimizerHook\n            optimizer_hook_params['builder_kwargs'].update({\n                        'update_interval': self.opt_update_interval})\n        if self.opt_use_fp16:\n            optimizer_hook_params['builder'] = DistOptimizerHook\n            optimizer_hook_params['builder_kwargs'].update({\n                        'use_fp16': self.opt_use_fp16})\n        self.params['optimizer_hook_params'] = optimizer_hook_params\n\n    def build_params(self):\n        self.get_save_params()\n        self.get_train_data_params()\n        self.get_model_optimizer_params()\n        self.get_loss_params()\n        self.get_learning_rate_params()\n        self.get_batch_processor_params()\n        self.get_validation_params()\n        self.get_optimizer_hook_params()\n        return self.params", "\nclass ParamsBuilder(object):\n    def __init__(\n            self, exp_id, col_name,\n            get_dataset_func, get_model_func,  \n            optimizer_cfg,\n            add_train_loader_kwargs={},\n            batch_processor_params=None,\n            save_rec_to_file=False,\n            opt_update_interval=None,\n            opt_grad_clip={'max_norm': 1.0},\n            opt_use_fp16=True,\n            model_find_unused=False,\n            database_name='babylm_train',\n            desired_batch_size=None, \n            base_batch_size=16,\n            max_epochs=400,\n            seed=None,\n            specify_iter=[50, 200, 1000, 2000, 4000],\n            specify_epoch=[1, 2, 4, 8, 20, 40],\n            ckpt_save_interval=50,\n            shuffle=True):\n        self.exp_id = exp_id\n        self.params = {'max_epochs': max_epochs}\n        self.col_name = col_name\n        self.get_dataset_func = get_dataset_func\n        self.get_model_func = get_model_func\n        self.add_train_loader_kwargs = add_train_loader_kwargs\n        self.batch_processor_params = batch_processor_params\n        self.optimizer_cfg = optimizer_cfg\n        self.save_rec_to_file = save_rec_to_file \\\n                or (int(SAVE_REC_TO_FILE) == 1)\n        self.opt_update_interval = opt_update_interval\n        self.opt_grad_clip = opt_grad_clip\n        self.opt_use_fp16 = opt_use_fp16\n        self.model_find_unused = model_find_unused\n        self.database_name = database_name\n        self.desired_batch_size = desired_batch_size\n        self.base_batch_size = base_batch_size\n        self.shuffle = shuffle\n        self.specify_iter = specify_iter\n        self.specify_epoch = specify_epoch\n        self.ckpt_save_interval = ckpt_save_interval\n        self.setup_opt_update_interval()\n        if seed is not None:\n            set_random_seed(seed)\n\n    def get_save_params(self):\n        ckpt_work_dir = os.path.join(\n                MODEL_SAVE_FOLDER, self.col_name, self.exp_id)\n        rec_work_dir = os.path.join(\n                REC_SAVE_FOLDER, self.col_name, self.exp_id)\n        save_params = {\n                'cache_ckpt_keep_nums': 3,\n                'ckpt_hook_builder': CkptSpecifySaveHook,\n                'ckpt_hook_kwargs': {\n                    'interval': self.ckpt_save_interval,\n                    'out_dir': ckpt_work_dir,\n                    'cache_interval': 1,\n                    'specify_epoch': self.specify_epoch,\n                    'specify_iter': self.specify_iter,\n                    },\n                }\n        if self.save_rec_to_file:\n            save_params['record_saver_kwargs'] = {\n                    'out_dir': rec_work_dir}\n        else:\n            save_params['record_saver_kwargs'] = {\n                    'port': 26001,\n                    'database_name': self.database_name,\n                    'collection_name': self.col_name,\n                    'exp_id': self.exp_id,\n                    'interval': 2500,\n                    'by_epoch': False,\n                    }\n            save_params['record_saver_builder'] = MongoDBSaver\n        self.params['save_params'] = save_params\n\n        rank, _ = get_dist_info()\n        if rank == 0:\n            mkdir_or_exist(rec_work_dir)\n            mkdir_or_exist(ckpt_work_dir)\n        timestamp = time.strftime('%Y%m%d_%H%M%S', time.localtime())\n        log_file = osp.join(rec_work_dir, 'train_{}.log'.format(timestamp))\n        logger = get_root_logger(log_file)\n        self.params['logger'] = logger\n\n    def get_num_workers_batch_size(self):\n        num_workers = int(os.environ.get(\n                'NUM_WORKERS', 8))\n        batch_size = int(os.environ.get(\n                'BATCH_SIZE', self.base_batch_size))\n        rel_batch_size = float(os.environ.get('REL_BATCH_SIZE', 1.0))\n        return num_workers, int(batch_size * rel_batch_size)\n\n    def setup_opt_update_interval(self):\n        if self.desired_batch_size is not None:\n            assert isinstance(self.desired_batch_size, int)\n            _, batch_size = self.get_num_workers_batch_size()\n            _, world_size = get_dist_info()\n            opt_update_interval = self.desired_batch_size // (batch_size * world_size)\n            if opt_update_interval > 1:\n                self.opt_update_interval = opt_update_interval\n\n    def add_one_hook_params(self, one_hook_params):\n        if 'extra_hook_params' not in self.params:\n            self.params['extra_hook_params'] = []\n        self.params['extra_hook_params'].append(one_hook_params)\n\n    def add_set_epoch_hook(self):\n        set_epoch_hook_params = {'builder': SetEpochHook}\n        self.add_one_hook_params(set_epoch_hook_params)\n\n    def get_train_data_params(self):\n        train_data_params = {\n                'dataset_builder': self.get_dataset_func,\n                'shuffle': self.shuffle,\n                }\n        num_workers, batch_size = self.get_num_workers_batch_size()\n          \n        train_data_params.update({\n            'batch_size': int(batch_size),\n            'num_workers': int(num_workers),\n            'distributed': True,\n            'data_loader_kwargs': {\n                'drop_last': True,\n                'persistent_workers': PERSISTENT_WORKERS,\n                },\n            })\n        train_data_params['data_loader_kwargs'].update(\n                self.add_train_loader_kwargs)\n        self.params['train_data_params'] = train_data_params\n        if not self.shuffle:\n            self.add_set_epoch_hook()\n\n    def build_model_optimizer(\n            self, get_model_func, optimizer_cfg):\n        self.model = get_model_func().cuda()\n        self.optimizer = build_optimizer(\n                self.model, \n                optimizer_cfg)\n        if self.opt_use_fp16:\n            import apex\n            self.model, self.optimizer = apex.amp.initialize(self.model, self.optimizer)\n        self.model = torch.nn.parallel.DistributedDataParallel(\n                self.model,\n                device_ids=[torch.cuda.current_device()],\n                find_unused_parameters=self.model_find_unused,\n                )\n        return self.model, self.optimizer\n\n    def get_model_optimizer_params(self):\n        model_optimizer_params = {\n                'builder': self.build_model_optimizer,\n                'builder_kwargs': dict(\n                    get_model_func=self.get_model_func,\n                    optimizer_cfg=self.optimizer_cfg),\n                }\n        self.params['model_optimizer_params'] = model_optimizer_params\n\n    def empty_func(self):\n        return None\n\n    def get_loss_params(self):\n        loss_params = {}\n        loss_params['builder'] = self.empty_func\n        self.params['loss_params'] = loss_params\n\n    def get_learning_rate_params(self):\n        builder_name = 'Fixed'\n        builder = getattr(lr_updater, builder_name + 'LrUpdaterHook')\n        lr_config = dict(\n            warmup='linear',\n            warmup_iters=5000 if self.opt_update_interval is None\\\n                         else 5000 * self.opt_update_interval,\n            warmup_ratio=0.0001, # cannot be 0\n            warmup_by_epoch=False)\n        learning_rate_params = {\n                'builder': builder,\n                'builder_kwargs': lr_config,\n                }\n        self.params['learning_rate_params'] = learning_rate_params\n\n    def naive_processor(self, model, loss_func, data_batch):\n        if not USE_TPU:\n            model_outputs = model(**data_batch)\n            return {'loss': model_outputs['loss']}\n        else:\n            model_outputs = model(\n                    return_dict=False, **data_batch)\n            return {'loss': model_outputs[0]}\n\n    def get_batch_processor_params(self):\n        if self.batch_processor_params is None:\n            batch_processor_params = {\n                    'func': self.naive_processor,\n                    }\n        else:\n            batch_processor_params = self.batch_processor_params\n        self.params['batch_processor_params'] = batch_processor_params\n\n    def get_validation_params(self):\n        self.params['validation_params'] = {}\n\n    def get_optimizer_hook_params(self):\n        optimizer_hook_params = {\n                'builder': OptimizerHook,\n                'builder_kwargs': {\n                    'grad_clip': self.opt_grad_clip,\n                    }}\n        if self.opt_update_interval is not None:\n            assert isinstance(self.opt_update_interval, int)\n            optimizer_hook_params['builder'] = DistOptimizerHook\n            optimizer_hook_params['builder_kwargs'].update({\n                        'update_interval': self.opt_update_interval})\n        if self.opt_use_fp16:\n            optimizer_hook_params['builder'] = DistOptimizerHook\n            optimizer_hook_params['builder_kwargs'].update({\n                        'use_fp16': self.opt_use_fp16})\n        self.params['optimizer_hook_params'] = optimizer_hook_params\n\n    def build_params(self):\n        self.get_save_params()\n        self.get_train_data_params()\n        self.get_model_optimizer_params()\n        self.get_loss_params()\n        self.get_learning_rate_params()\n        self.get_batch_processor_params()\n        self.get_validation_params()\n        self.get_optimizer_hook_params()\n        return self.params", ""]}
{"filename": "src/babylm_baseline_train/configs/general.py", "chunked_list": ["import babylm_baseline_train.models.helper as helper\nfrom babylm_baseline_train.train.tk_funcs import\\\n        get_tokenizer_func\nimport functools\nfrom transformers import DataCollatorForLanguageModeling\nfrom itertools import product\nimport copy\n\n\ndef add_collate_fn_for_MLM(key_params, tokenizer):\n    if 'add_train_loader_kwargs' not in key_params:\n        key_params['add_train_loader_kwargs'] = {}\n    key_params['add_train_loader_kwargs'].update(\n            {'collate_fn': DataCollatorForLanguageModeling(\n                tokenizer=tokenizer,\n                mlm=True,\n                mlm_probability=0.15,\n                )})\n    return key_params", "\ndef add_collate_fn_for_MLM(key_params, tokenizer):\n    if 'add_train_loader_kwargs' not in key_params:\n        key_params['add_train_loader_kwargs'] = {}\n    key_params['add_train_loader_kwargs'].update(\n            {'collate_fn': DataCollatorForLanguageModeling(\n                tokenizer=tokenizer,\n                mlm=True,\n                mlm_probability=0.15,\n                )})\n    return key_params", "\n\ndef add_func_in_general(\n        func_name,\n        data_func,\n        exp_name=None,\n        seed=None,\n        model_name=None,\n        all_things=None,\n        post_func=None,\n        **kwargs):\n\n    if exp_name is None:\n        exp_name = func_name\n    def _func(key_params):\n        key_params = data_func(key_params)\n        if model_name == '350m':\n            key_params['get_model_func'] = functools.partial(\n                    helper.get_opt_func, \n                    opt_model_size='350m')\n        elif model_name == 'roberta-base':\n            key_params['get_model_func'] = helper.get_roberta_func\n        elif model_name == 'roberta-large':\n            key_params['get_model_func'] = functools.partial(\n                    helper.get_roberta_func,\n                    model_name=model_name)\n        elif model_name is not None:\n            raise NotImplementedError\n        key_params['exp_id'] = exp_name\n        key_params['seed'] = seed\n        key_params.update(kwargs)\n        if post_func is not None:\n            key_params = post_func(key_params)\n        return key_params\n\n    if all_things is None:\n        all_things = globals()\n    all_things[func_name] = _func", "\nadd_func_in_general_for_opt = add_func_in_general\n\ndef get_general_data_func(\n        data_func, tokenizer=None, \n        max_epochs=100, ckpt_save_interval=50,\n        col_name=None):\n    def _func(key_params):\n        if col_name is not None:\n            key_params['col_name'] = col_name\n        if tokenizer is None:\n            _tokenizer = get_tokenizer_func()\n        else:\n            _tokenizer = tokenizer\n        key_params['get_dataset_func'] = functools.partial(\n                    data_func,\n                    tokenizer=_tokenizer)\n        key_params['max_epochs'] = max_epochs\n        key_params['ckpt_save_interval'] = ckpt_save_interval\n        return key_params\n    return _func", ""]}
{"filename": "src/babylm_baseline_train/configs/__init__.py", "chunked_list": [""]}
{"filename": "src/babylm_baseline_train/configs/BabyLM/exp_strict.py", "chunked_list": ["import babylm_baseline_train.datasets.babyLM as babyLM\nfrom babylm_baseline_train.configs.general import\\\n        add_func_in_general_for_opt, get_general_data_func\nimport functools\nfrom itertools import product\nimport babylm_baseline_train.train.tk_funcs as tk_funcs\n\n\nKWARGS = dict(\n        all_things=globals(),", "KWARGS = dict(\n        all_things=globals(),\n        specify_iter=[],\n        specify_epoch=[5, 10, 20],\n        )\nDATA_KWARGS = dict(\n        max_epochs=20, ckpt_save_interval=15,\n        col_name='babyLM_10M')\n\ndef add_exp_seeds(\n        exp_names, seeds, data_func,\n        model_name=None,\n        tokenizer=None,\n        ):\n    for exp_name, seed in zip(exp_names, seeds):\n        add_func_in_general_for_opt(\n                func_name=exp_name,\n                data_func=get_general_data_func(\n                    data_func,\n                    tokenizer=tokenizer,\n                    **DATA_KWARGS),\n                seed=seed,\n                model_name=model_name,\n                **KWARGS)", "\ndef add_exp_seeds(\n        exp_names, seeds, data_func,\n        model_name=None,\n        tokenizer=None,\n        ):\n    for exp_name, seed in zip(exp_names, seeds):\n        add_func_in_general_for_opt(\n                func_name=exp_name,\n                data_func=get_general_data_func(\n                    data_func,\n                    tokenizer=tokenizer,\n                    **DATA_KWARGS),\n                seed=seed,\n                model_name=model_name,\n                **KWARGS)", "\nadd_exp_seeds(\n        exp_names=[\n            'opt125m_s1',\n            'opt125m_s2',\n            'opt125m_s3',\n            'opt125m_s4',\n            ], \n        seeds=[1, 2, 3, 4], \n        data_func=babyLM.get_babyLM_10M)", "        seeds=[1, 2, 3, 4], \n        data_func=babyLM.get_babyLM_10M)\n\nadd_exp_seeds(\n        exp_names=[\n            'opt350m_s1',\n            'opt350m_s2',\n            'opt350m_s3',\n            'opt350m_s4',\n            ], ", "            'opt350m_s4',\n            ], \n        seeds=[1, 2, 3, 4], \n        data_func=babyLM.get_babyLM_10M,\n        model_name='350m')\n"]}
{"filename": "src/babylm_baseline_train/configs/BabyLM/__init__.py", "chunked_list": [""]}
{"filename": "src/babylm_baseline_train/configs/BabyLM/exp_strict_mask.py", "chunked_list": ["import babylm_baseline_train.datasets.babyLM as babyLM\nfrom babylm_baseline_train.configs.general import\\\n        add_func_in_general, get_general_data_func,\\\n        add_collate_fn_for_MLM\nimport functools\nfrom itertools import product\nimport babylm_baseline_train.train.tk_funcs as tk_funcs\n\n\nKWARGS = dict(", "\nKWARGS = dict(\n        all_things=globals(),\n        specify_iter=[],\n        specify_epoch=[5, 10, 20],\n        )\nDATA_KWARGS = dict(\n        max_epochs=20, ckpt_save_interval=15,\n        col_name='babyLM_10M')\n\ndef add_exp_seeds(\n        exp_names, seeds, data_func,\n        model_name='roberta-base',\n        tokenizer=None,\n        ):\n    for exp_name, seed in zip(exp_names, seeds):\n        if tokenizer is None:\n            MLM_tokenizer = tk_funcs.get_roberta_tokenizer_func(\n                    model_name=model_name)\n        else:\n            MLM_tokenizer = tokenizer\n        add_func_in_general(\n                func_name=exp_name,\n                data_func=get_general_data_func(\n                    data_func,\n                    tokenizer=MLM_tokenizer,\n                    **DATA_KWARGS),\n                seed=seed,\n                model_name=model_name,\n                post_func=functools.partial(\n                    add_collate_fn_for_MLM,\n                    tokenizer=MLM_tokenizer),\n                **KWARGS)", "        col_name='babyLM_10M')\n\ndef add_exp_seeds(\n        exp_names, seeds, data_func,\n        model_name='roberta-base',\n        tokenizer=None,\n        ):\n    for exp_name, seed in zip(exp_names, seeds):\n        if tokenizer is None:\n            MLM_tokenizer = tk_funcs.get_roberta_tokenizer_func(\n                    model_name=model_name)\n        else:\n            MLM_tokenizer = tokenizer\n        add_func_in_general(\n                func_name=exp_name,\n                data_func=get_general_data_func(\n                    data_func,\n                    tokenizer=MLM_tokenizer,\n                    **DATA_KWARGS),\n                seed=seed,\n                model_name=model_name,\n                post_func=functools.partial(\n                    add_collate_fn_for_MLM,\n                    tokenizer=MLM_tokenizer),\n                **KWARGS)", "\nadd_exp_seeds(\n        exp_names=[\n            'roberta_s1',\n            ], \n        seeds=[1], \n        data_func=babyLM.get_babyLM_10M)\n\nadd_exp_seeds(\n        exp_names=[", "add_exp_seeds(\n        exp_names=[\n            'roberta_large_s1',\n            ], \n        seeds=[1], \n        data_func=babyLM.get_babyLM_10M,\n        model_name='roberta-large')\n"]}
{"filename": "src/babylm_baseline_train/models/ckpt_loader.py", "chunked_list": ["import os\nimport ipdb\nimport setuptools\nimport torch\nimport transformers\n\nimport babylm_baseline_train.train.tk_funcs as tk_funcs\nimport babylm_baseline_train.models.helper as helper\n\ndef load_opt125m():\n    tokenizer = tk_funcs.get_tokenizer_func()\n    model = helper.get_opt_func()\n    saved_model = torch.load(\n            './babyLM_10M/opt125m_s1/epoch_20.pth', # path to your pretrained model\n            map_location=torch.device('cpu'))\n    model.load_state_dict(saved_model['state_dict'])", "\ndef load_opt125m():\n    tokenizer = tk_funcs.get_tokenizer_func()\n    model = helper.get_opt_func()\n    saved_model = torch.load(\n            './babyLM_10M/opt125m_s1/epoch_20.pth', # path to your pretrained model\n            map_location=torch.device('cpu'))\n    model.load_state_dict(saved_model['state_dict'])\n\n\ndef load_roberta():\n    tokenizer = tk_funcs.get_roberta_tokenizer_func()\n    model = helper.get_roberta_func(tokenizer=tokenizer)\n    saved_model = torch.load(\n            './babyLM_10M/roberta_s1/epoch_20.pth', # path to your pretrained model\n            map_location=torch.device('cpu'))\n    saved_model['state_dict'].pop('roberta.embeddings.token_type_ids')\n    model.load_state_dict(saved_model['state_dict'])", "\n\ndef load_roberta():\n    tokenizer = tk_funcs.get_roberta_tokenizer_func()\n    model = helper.get_roberta_func(tokenizer=tokenizer)\n    saved_model = torch.load(\n            './babyLM_10M/roberta_s1/epoch_20.pth', # path to your pretrained model\n            map_location=torch.device('cpu'))\n    saved_model['state_dict'].pop('roberta.embeddings.token_type_ids')\n    model.load_state_dict(saved_model['state_dict'])", "\ndef load_t5():\n    tokenizer = tk_funcs.get_t5_tokenizer_func()\n    model = transformers.AutoModelForSeq2SeqLM.from_pretrained(\n            \"./babyLM_10M/t5_s1/\",                  # path to your pretrained model\n            from_flax=True,\n    )\n"]}
{"filename": "src/babylm_baseline_train/models/__init__.py", "chunked_list": [""]}
{"filename": "src/babylm_baseline_train/models/helper.py", "chunked_list": ["import os\nimport pdb\nimport setuptools\nimport torch\nimport ipdb\nimport copy\n\nfrom transformers import OPTForCausalLM\nfrom transformers.models.opt.modeling_opt import OPTConfig\nDEBUG = int(os.environ.get(", "from transformers.models.opt.modeling_opt import OPTConfig\nDEBUG = int(os.environ.get(\n        'DEBUG',\n        '0')) == 1\n\n\ndef get_opt_func(opt_model_size='125m'):\n    model_name = f\"facebook/opt-{opt_model_size}\"\n    config = OPTConfig.from_pretrained(model_name)\n    model = OPTForCausalLM(config=config)\n    return model", "\n\ndef get_roberta_func(model_name=\"roberta-base\", tokenizer=None):\n    from transformers import RobertaConfig, RobertaForMaskedLM\n    config = RobertaConfig.from_pretrained(model_name)\n    model = RobertaForMaskedLM(config)\n    if tokenizer is not None:\n        model.resize_token_embeddings(len(tokenizer))\n    return model\n", ""]}
{"filename": "src/babylm_baseline_train/train/__init__.py", "chunked_list": [""]}
{"filename": "src/babylm_baseline_train/train/tk_funcs.py", "chunked_list": ["import os\nimport pdb\nimport setuptools\nimport torch\n\nfrom transformers import AutoTokenizer\nfrom transformers import GPT2Tokenizer\n\n\ndef get_gpt2_tokenizer_func(model_name='gpt2'):\n    tokenizer = GPT2Tokenizer.from_pretrained(model_name)\n    return tokenizer", "\ndef get_gpt2_tokenizer_func(model_name='gpt2'):\n    tokenizer = GPT2Tokenizer.from_pretrained(model_name)\n    return tokenizer\n\n\ndef get_roberta_tokenizer_func(model_name=\"roberta-base\"):\n    from transformers import RobertaTokenizer\n    tokenizer = RobertaTokenizer.from_pretrained(model_name)\n    return tokenizer", "\ndef get_t5_tokenizer_func(model_name=\"t5-base\"):\n    from transformers import T5Tokenizer\n    tokenizer = T5Tokenizer.from_pretrained(model_name)\n    return tokenizer\n\ndef get_tokenizer_func(opt_model_size='125m'):\n    model_name = f\"facebook/opt-{opt_model_size}\"\n    tokenizer = GPT2Tokenizer.from_pretrained(model_name)\n    tokenizer.add_bos_token = False\n    tokenizer.add_special_tokens(\n            {\n                'bos_token': '<s>', \n                'unk_token': '<unk>',\n                'additional_special_tokens': [\n                    '<image>', '</c>', \n                    '<PERSON>', # C-12M for person names\n                    ]\n            })\n    return tokenizer", ""]}
{"filename": "src/babylm_baseline_train/train/utils.py", "chunked_list": ["import importlib\n\n\ndef get_setting_func(setting):\n    assert len(setting.split(':')) == 2, \\\n            'Setting should be \"script_path:func_name\"'\n    script_path, func_name = setting.split(':')\n    assert script_path.endswith('.py'), \\\n            'Script should end with \".py\"'\n    module_name = script_path[:-3].replace('/', '.')\n    while module_name.startswith('.'):\n        module_name = module_name[1:]\n    try:\n        load_setting_module = importlib.import_module(module_name)\n    except:\n        module_name = 'babylm_baseline_train.configs.' + module_name\n        load_setting_module = importlib.import_module(module_name)\n    setting_func = getattr(load_setting_module, func_name)\n    return setting_func", ""]}
{"filename": "src/babylm_baseline_train/train/env_params.py", "chunked_list": ["import os\nfrom pt_framework.dist_utils import use_tpu\nfrom ..env_vars import ROOT_DIR, ROOT_DIR_FREQ\n\n\nMODEL_SAVE_FOLDER = os.environ.get(\n        'BABYLM_MODEL_SAVE_FOLDER',\n        os.path.join(\n            ROOT_DIR, 'models/'))\nREC_SAVE_FOLDER = os.environ.get(", "            ROOT_DIR, 'models/'))\nREC_SAVE_FOLDER = os.environ.get(\n        'BABYLM_REC_SAVE_FOLDER',\n        os.path.join(\n            ROOT_DIR_FREQ, 'model_recs/'))\nUSE_TPU = use_tpu()\nMANUAL_FORCE_TPU = int(os.environ.get('MANUAL_FORCE_TPU', 0)) == 1\nUSE_TPU = USE_TPU or MANUAL_FORCE_TPU\n", ""]}
{"filename": "src/babylm_baseline_train/datasets/base.py", "chunked_list": ["from transformers import AutoTokenizer\nimport torch\nfrom abc import ABC, abstractmethod\nfrom transformers import GPT2Tokenizer\nimport ipdb\nfrom tqdm import tqdm\n\nfrom .utils import Group_Texts\n\n\nclass BaseGroupDataset(ABC):\n    def __init__(self, seq_len, tokenizer):\n        self.seq_len = seq_len\n        self.tokenizer = tokenizer\n\n    def prepare_tokenizer(self):\n        if self.tokenizer is None:\n            #self.tokenizer = AutoTokenizer.from_pretrained(\n            #        \"gpt2\", fast=False)\n            model_name = f\"facebook/opt-125m\"\n            self.tokenizer = GPT2Tokenizer.from_pretrained(model_name)\n\n    @abstractmethod\n    def get_dataset(self):\n        pass\n\n    def tokenize_function(self, examples):\n        outputs = self.tokenizer(examples['text'])\n        return outputs\n\n    def get_group_dataset(self, just_dataset=False):\n        self.prepare_tokenizer()\n        self.get_dataset()\n        if just_dataset == True:\n            return self.dataset\n        elif just_dataset == 'self':\n            return self\n\n        tokenized_datasets = self.dataset.map(\n                self.tokenize_function, batched=True, \n                remove_columns=[\"text\"])\n        group_text_default = Group_Texts(\n                tokenized_datasets, self.tokenizer, \n                seq_len=self.seq_len)\n\n        grouped_dataset_default = group_text_default.group_texts()\n        return grouped_dataset_default\n\n    def count_num_of_words(self):\n        import re\n        import inflect\n        import nltk.data\n        from tqdm import tqdm\n\n        tokenizer = nltk.data.load('tokenizers/punkt/english.pickle')\n        num = 0\n        for data in tqdm(self.dataset):\n            sents = tokenizer.tokenize(data['text'])\n            for sent in sents:\n                tokens = re.findall('\\w+', sent)\n                num += len(tokens)\n        return num\n\n    def count_num_of_tks(self):\n        num_of_tks = 0\n        for line in tqdm(self.dataset):\n            txt_in_tks = self.tokenize_function(line)\n            num_of_tks += len(txt_in_tks.input_ids)\n        return num_of_tks", "\n\nclass BaseGroupDataset(ABC):\n    def __init__(self, seq_len, tokenizer):\n        self.seq_len = seq_len\n        self.tokenizer = tokenizer\n\n    def prepare_tokenizer(self):\n        if self.tokenizer is None:\n            #self.tokenizer = AutoTokenizer.from_pretrained(\n            #        \"gpt2\", fast=False)\n            model_name = f\"facebook/opt-125m\"\n            self.tokenizer = GPT2Tokenizer.from_pretrained(model_name)\n\n    @abstractmethod\n    def get_dataset(self):\n        pass\n\n    def tokenize_function(self, examples):\n        outputs = self.tokenizer(examples['text'])\n        return outputs\n\n    def get_group_dataset(self, just_dataset=False):\n        self.prepare_tokenizer()\n        self.get_dataset()\n        if just_dataset == True:\n            return self.dataset\n        elif just_dataset == 'self':\n            return self\n\n        tokenized_datasets = self.dataset.map(\n                self.tokenize_function, batched=True, \n                remove_columns=[\"text\"])\n        group_text_default = Group_Texts(\n                tokenized_datasets, self.tokenizer, \n                seq_len=self.seq_len)\n\n        grouped_dataset_default = group_text_default.group_texts()\n        return grouped_dataset_default\n\n    def count_num_of_words(self):\n        import re\n        import inflect\n        import nltk.data\n        from tqdm import tqdm\n\n        tokenizer = nltk.data.load('tokenizers/punkt/english.pickle')\n        num = 0\n        for data in tqdm(self.dataset):\n            sents = tokenizer.tokenize(data['text'])\n            for sent in sents:\n                tokens = re.findall('\\w+', sent)\n                num += len(tokens)\n        return num\n\n    def count_num_of_tks(self):\n        num_of_tks = 0\n        for line in tqdm(self.dataset):\n            txt_in_tks = self.tokenize_function(line)\n            num_of_tks += len(txt_in_tks.input_ids)\n        return num_of_tks", ""]}
{"filename": "src/babylm_baseline_train/datasets/__init__.py", "chunked_list": [""]}
{"filename": "src/babylm_baseline_train/datasets/utils.py", "chunked_list": ["from copy import deepcopy\nfrom typing import Optional\nimport torch\n\n\n# New class based off of group_texts with stride, padding, and padding token inputs\nclass Group_Texts:\n    def __init__(self,\n                 tokenized_dataset,\n                 tokenizer,\n                 seq_len: int,\n                 stride: Optional[int] = None,\n                 padding: Optional[bool] = False,\n                 padding_tok: Optional[int] = None\n                 ):\n        # Set values for the class variables\n        self.dataset = tokenized_dataset\n        self.seq_len = seq_len\n\n        # if-else for setting stride/padding/padding token\n        # Padding false, stride None -> Default\n        if padding is False and stride is None:\n            self.stride = seq_len\n            self.padding = padding\n        # Padding true, stride None -> Only padding\n        elif padding is True and stride is None:\n            self.stride = seq_len\n            self.padding = padding\n            if padding_tok is not None:\n                self.padding_tok = padding_tok\n            elif padding_tok is None:\n                # Doesn't matter what the padding token is since it will be masked dually by labels and attention mask\n                # Can also set to the input id value of eos token\n                self.padding_tok = (tokenizer(tokenizer.eos_token))[\"input_ids\"][0]\n                print(\n                    f'Padding token defaulting to {(tokenizer(tokenizer.eos_token))[\"input_ids\"][0]} (debugging), it will be masked by labels and attention mask')\n        # Padding false, stride a value -> Only stride\n        elif padding is False and stride is not None:\n            self.stride = stride\n            self.padding = padding\n        # Padding true, stride a value -> Stride with padding\n        elif padding is True and stride is not None:\n            self.stride = stride\n            self.padding = padding\n            if padding_tok is not None:\n                self.padding_tok = padding_tok\n            elif padding_tok is None:\n                self.padding_tok = (tokenizer(tokenizer.eos_token))[\"input_ids\"][0]\n                print(\n                    f'Padding token defaulting to {(tokenizer(tokenizer.eos_token))[\"input_ids\"][0]} (debugging), it will be masked by labels and attention mask')\n\n        # Split function calls by the inputs\n        if self.padding is False and self.stride is self.seq_len:\n            print(\"Grouping texts with default mode without padding or stride at context length of\", self.seq_len)\n        elif self.padding is True and self.stride is self.seq_len:\n            print(\"Grouping texts with padding with padding token\", self.padding_tok, \"at context length of\", self.seq_len)\n        elif self.padding is False and self.stride is not self.seq_len:\n            print(\"Grouping texts at a stride of\", self.stride, \"at context length of\", self.seq_len)\n        elif self.padding is True and self.stride is not self.seq_len:\n            print(\"Grouping texts with padding with padding token\", self.padding_tok, \"and stride of\", self.stride, \"at context length of\", self.seq_len)\n\n    def group_texts(self):\n        # Call preferred grouping function\n        return self.dataset.map(self.get_grouping, batched=True, batch_size=1000)\n\n    # Default function with no padding or striding\n    # Leaves out tokens that do not fit into a multiple of seq_len\n    def group_default(self, examples):\n        concatenated_examples = {k: sum(examples[k], []) for k in examples.keys()}\n        total_length = len(concatenated_examples[list(examples.keys())[0]])\n        total_length_use = (total_length // self.seq_len) * self.seq_len\n        result = {\n            k: [t[i: i + self.seq_len] for i in range(0, total_length_use, self.seq_len)]\n            for k, t in concatenated_examples.items()\n        }\n        result[\"labels\"] = result[\"input_ids\"].copy()\n\n        # Some checks\n        assert all([len(x) == self.seq_len for x in result[\"input_ids\"]])\n        if 'attention_mask' in result:\n            assert all([len(x) == self.seq_len for x in result[\"attention_mask\"]])\n        assert all([len(x) == self.seq_len for x in result[\"labels\"]])\n\n        return result\n\n    # Only Padding function\n    # Takes the left out tokens and pads to seq_len\n    def group_padding(self, examples):\n        concatenated_examples = {k: sum(examples[k], []) for k in examples.keys()}\n        total_length = len(concatenated_examples[list(examples.keys())[0]])\n\n        # Find what length to add padding\n        remainder = total_length % self.seq_len\n        if remainder != 0:\n            to_add = self.seq_len - remainder\n        elif remainder == 0:\n            to_add = 0\n        to_add_input_id = [self.padding_tok] * to_add\n        to_add_atten_mask = [0] * to_add\n        # Merge the two Dict variables\n        pad_dict = dict(input_ids=to_add_input_id, attention_mask=to_add_atten_mask)\n        for key in concatenated_examples.keys():\n            t = concatenated_examples[key]\n            t1 = [item for sublist in [t, pad_dict[key]] for item in sublist]\n            assert not len(t1) % self.seq_len\n            concatenated_examples[key] = t1\n        total_length_use = len(concatenated_examples[list(examples.keys())[0]])\n        result = {\n            k: [t[i: i + self.seq_len] for i in range(0, total_length_use, self.seq_len)]\n            for k, t in concatenated_examples.items()\n        }\n        # Labels is copied from input ids\n        result[\"labels\"] = result[\"input_ids\"].copy()\n\n        # Label is -100 if attention mask is 0, otherwise same as input ids\n        result[\"labels\"] = [\n            [-100 if mask == 0 else token for mask, token in mask_and_tokens] for mask_and_tokens in\n            [zip(masks, labels) for masks, labels in zip(result[\"attention_mask\"], result[\"labels\"])]\n        ]\n\n        # Some checks\n        assert all([len(x) == self.seq_len for x in result[\"input_ids\"]])\n        assert all([len(x) == self.seq_len for x in result[\"attention_mask\"]])\n        assert all([len(x) == self.seq_len for x in result[\"labels\"]])\n\n        return result\n\n    # Only Stride function\n    # Takes batches at length seq_len, moving every stride\n    # Masks out tokens that are reused the next batch\n    def group_stride(self, examples):\n        concatenated_examples = {k: sum(examples[k], []) for k in examples.keys()}\n        total_length = len(concatenated_examples[list(examples.keys())[0]])\n        if self.stride < self.seq_len:\n            total_length_use = ((total_length - self.seq_len + self.stride) // self.stride) * self.stride\n            result = {\n                k: [t[i: i + self.seq_len] for i in range(0, total_length_use, self.stride)]\n                for k, t in concatenated_examples.items()}\n        elif self.stride > self.seq_len:\n            count_indice = 1\n            count_length = total_length - self.seq_len\n            while count_length >= self.stride + self.seq_len:\n                count_indice += 1\n                count_length = count_length - self.stride - self.seq_len\n            total_length_use = count_indice * self.stride\n            result = {\n                k: [t[0:self.seq_len]] for k, t in concatenated_examples.items()}\n            result_add = {\n                k: [t[i + self.stride + 1: i + self.seq_len + self.stride + 1] for i in range(self.stride, total_length_use, self.stride)]\n                for k, t in concatenated_examples.items()}\n            for key in result.keys():\n                t = result[key]\n                t1 = [item for sublist in [t, result_add[key]] for item in sublist]\n                result[key] = t1\n        # Copies over input ids to new column called labels\n        result[\"labels\"] = deepcopy(result[\"input_ids\"])\n\n        # Mask out losses in overlapping regions\n        # Changes masked labels to -100 and attention mask to 0\n        for i, labels in enumerate(result[\"labels\"]):\n            # Skip the first index since the first batch will not have any masking\n            if i == 0:\n                continue\n            # For every j in range from 0 to length-stride, label to -100 to mask them\n            for j in range(self.seq_len - self.stride):\n                labels[j] = -100\n            # Set the newly masked list of labels to result Dict object\n            result[\"labels\"][i] = labels\n\n        for i, attention in enumerate(result[\"attention_mask\"]):\n            # Skip the first index since the first batch will not have any masking\n            if i == 0:\n                continue\n            # For every j in range from 0 to length-stride, label to -100 to mask them\n            for j in range(self.seq_len - self.stride):\n                attention[j] = 0\n            # Set the newly masked list of labels to result Dict object\n            result[\"attention_mask\"][i] = attention\n\n        # Some checks\n\n        #assert all([len(x) == self.seq_len for x in result[\"input_ids\"]])\n        #assert all([len(x) == self.seq_len for x in result[\"attention_mask\"]])\n        #assert all([len(x) == self.seq_len for x in result[\"labels\"]])\n\n        return result\n\n    # Padding and stride function\n    def group_padding_stride(self, examples):\n        concatenated_examples = {k: sum(examples[k], []) for k in examples.keys()}\n        total_length = len(concatenated_examples[list(examples.keys())[0]])\n        # Finds just the quotient of total_length - seq_len by stride\n        total_length_stride = ((total_length - self.seq_len + self.stride) // self.stride) * self.stride\n        # Get the remainder and subtract to get the length of padding to add to fit the last stride\n        # Different padding for stride > or < than seq_len\n        if self.stride < self.seq_len:\n            remainder = (total_length - self.seq_len) % self.stride\n            to_add = self.seq_len - remainder\n            to_add_input_id = [self.padding_tok] * to_add\n            to_add_atten_mask = [0] * to_add\n            pad_dict = dict(input_ids=to_add_input_id, attention_mask=to_add_atten_mask)\n            for key in concatenated_examples.keys():\n                t = concatenated_examples[key]\n                t1 = [item for sublist in [t, pad_dict[key]] for item in sublist]\n                # assert not len(t1) % self.stride\n                concatenated_examples[key] = t1\n            total_length_use = total_length_stride + 1\n            # New Dict object based that samples at length seq_len with stride\n            result = {k: [t[i: i + self.seq_len] for i in range(0, total_length_use, self.stride)] for k, t in\n                      concatenated_examples.items()}\n        elif self.stride > self.seq_len:\n            count_index = 1\n            count_length = total_length - self.seq_len\n            while count_length >= self.stride + self.seq_len:\n                count_index += 1\n                count_length = count_length - self.stride - self.seq_len\n            to_add = self.seq_len\n            to_add_input_id = [self.padding_tok] * to_add\n            to_add_atten_mask = [0] * to_add\n            total_length_use = count_index * self.stride\n            pad_dict = dict(input_ids=to_add_input_id, attention_mask=to_add_atten_mask)\n            for key in concatenated_examples.keys():\n                t = concatenated_examples[key]\n                t1 = [item for sublist in [t, pad_dict[key]] for item in sublist]\n                # assert not len(t1) % self.stride\n                concatenated_examples[key] = t1\n\n            # New Dict object based that samples at length seq_len with stride\n            result = {k: [t[0:self.seq_len]] for k, t in concatenated_examples.items()}\n            result_add = {\n                k: [t[i + self.stride - 1: i + self.seq_len + self.stride - 1] for i in\n                    range(self.stride, total_length_use, self.stride)]\n                for k, t in concatenated_examples.items()}\n            for key in result.keys():\n                t = result[key]\n                t1 = [item for sublist in [t, result_add[key]] for item in sublist]\n                result[key] = t1\n\n        # Copies over input ids to new column called labels\n        result[\"labels\"] = deepcopy(result[\"input_ids\"])\n\n        # Label is -100 if attention mask is 0, otherwise same as input ids\n        # Just for padding at the end\n        result[\"labels\"] = [\n            [-100 if mask == 0 else token for mask, token in mask_and_tokens] for mask_and_tokens in\n            [zip(masks, labels) for masks, labels in zip(result[\"attention_mask\"], result[\"labels\"])]\n        ]\n\n        # Mask out losses in overlapping regions. If training data, string will be equal to seq_len\n        for i, labels in enumerate(result[\"labels\"]):\n            # Skip the first index since the first batch will not have any masking\n            if i == 0:\n                continue\n            # For every j in range from 0 to length-stride, change label to -100 to mask them\n            for j in range(self.seq_len - self.stride):\n                labels[j] = -100\n            # Set the newly masked list of labels to result Dict object\n            result[\"labels\"][i] = labels\n\n        for i, attention in enumerate(result[\"attention_mask\"]):\n            # Skip the first index since the first batch will not have any masking\n            if i == 0:\n                continue\n            # For every j in range from 0 to length-stride, change attention mask to 0 to mask them\n            for j in range(self.seq_len - self.stride):\n                attention[j] = 0\n            # Set the newly masked list of labels to result Dict object\n            result[\"attention_mask\"][i] = attention\n\n        # Some checks\n        # assert all([len(x) == self.seq_len for x in result[\"input_ids\"]])\n        # assert all([len(x) == self.seq_len for x in result[\"attention_mask\"]])\n        # assert all([len(x) == self.seq_len for x in result[\"labels\"]])\n\n        return result\n\n    # If-else function calls based on padding and stride values of self\n    def get_grouping(self, examples):\n        # Split function calls by the inputs\n        if self.padding is False and self.stride is self.seq_len:\n            return self.group_default(examples)\n        elif self.padding is True and self.stride is self.seq_len:\n            return self.group_padding(examples)\n        elif self.padding is False and self.stride is not self.seq_len:\n            return self.group_stride(examples)\n        elif self.padding is True and self.stride is not self.seq_len:\n            return self.group_padding_stride(examples)", "\n\ndef collate_fn(all_data):\n    keys = list(all_data[0].keys())\n    ret_dict = {}\n    for other_key in keys:\n        all_other_value = [torch.LongTensor(_data[other_key]) for _data in all_data]\n        all_other_value = torch.stack(all_other_value, 0)\n        ret_dict[other_key] = all_other_value\n    return ret_dict", ""]}
{"filename": "src/babylm_baseline_train/datasets/hf_loaders.py", "chunked_list": ["from datasets import load_dataset\nfrom ..env_vars import ROOT_DIR, DATASET_ROOT_DIR\nimport os\nimport babylm_baseline_train\n\nrepo_path = babylm_baseline_train.__path__[0]\n\n\ndef get_babyLM(name, split):\n    dataset = load_dataset(\n            path=os.path.join(\n                repo_path, 'datasets', \"babyLM_for_hf.py\"),\n            name=name,\n            split=split)\n    return dataset", "def get_babyLM(name, split):\n    dataset = load_dataset(\n            path=os.path.join(\n                repo_path, 'datasets', \"babyLM_for_hf.py\"),\n            name=name,\n            split=split)\n    return dataset\n"]}
{"filename": "src/babylm_baseline_train/datasets/babyLM_for_hf.py", "chunked_list": ["import os\nimport datasets\nfrom babylm_baseline_train.env_vars import DATASET_ROOT_DIR\n\n\n_CITATION = \"\"\"\n\"\"\"\n\n_DESCRIPTION = \"\"\"\\\nBabyLM data", "_DESCRIPTION = \"\"\"\\\nBabyLM data\n\"\"\"\n_HOMEPAGE = \"https://babylm.github.io/\"\n_LICENSE = \"????\"\n_DATA_URL = DATASET_ROOT_DIR\n\n\nclass babyLMConfig(datasets.BuilderConfig):\n    \"\"\"BuilderConfig for babyLM.\"\"\"\n\n    def __init__(self, data_url, **kwargs):\n        \"\"\"BuilderConfig for babyLM\n        Args:\n          data_url: `string`, url to the dataset (word or raw level)\n          **kwargs: keyword arguments forwarded to super.\n        \"\"\"\n        super().__init__(\n            version=datasets.Version(\n                \"1.0.0\",\n            ),\n            **kwargs,\n        )\n        self.data_url = data_url", "class babyLMConfig(datasets.BuilderConfig):\n    \"\"\"BuilderConfig for babyLM.\"\"\"\n\n    def __init__(self, data_url, **kwargs):\n        \"\"\"BuilderConfig for babyLM\n        Args:\n          data_url: `string`, url to the dataset (word or raw level)\n          **kwargs: keyword arguments forwarded to super.\n        \"\"\"\n        super().__init__(\n            version=datasets.Version(\n                \"1.0.0\",\n            ),\n            **kwargs,\n        )\n        self.data_url = data_url", "\n\nclass babyLM(datasets.GeneratorBasedBuilder):\n    \"\"\"TODO: Short description of dataset dataset.\"\"\"\n    DATA_SOURCES = [\n            'aochildes', 'bnc_spoken', 'cbt', 'children_stories',\n            'gutenberg', 'open_subtitles', 'qed',  'simple_wikipedia',\n            'switchboard',  'wikipedia']\n    VERSION = datasets.Version(\"0.0.0\")\n    BUILDER_CONFIGS = [\n            babyLMConfig(\n                name=\"babyLM-10M\",\n                data_url=os.path.join(_DATA_URL, 'babylm_10M'),\n                description=\"Raw level dataset: the raw tokens before the addition of <unk> tokens. 10M tokens.\",\n            ),\n            babyLMConfig(\n                name=\"babyLM-100M\",\n                data_url=os.path.join(_DATA_URL, 'babylm_100M'),\n                description=\"Raw level dataset: the raw tokens before the addition of <unk> tokens. 100M tokens.\",\n            ),\n            ]\n\n    def _info(self):\n        return datasets.DatasetInfo(\n            # This is the description that will appear on the datasets page.\n            description=_DESCRIPTION,\n            # datasets.features.FeatureConnectors\n            features=datasets.Features(\n                {\n                    \"text\": datasets.Value(\"string\")\n                    # These are the features of your dataset like images, labels ...\n                }\n            ),\n            # If there's a common (input, target) tuple from the features,\n            # specify them here. They'll be used if as_supervised=True in\n            # builder.as_dataset.\n            supervised_keys=None,\n            homepage=_HOMEPAGE,\n            license=_LICENSE,\n            citation=_CITATION,\n        )\n\n    def _split_generators(self, dl_manager):\n        \"\"\"Returns SplitGenerators.\"\"\"\n        ret_list = [\n            datasets.SplitGenerator(\n                name=datasets.Split.TEST,\n                gen_kwargs={\"data_folder\": os.path.join(_DATA_URL, \"babylm_test\"), \"split\": \"test\"},\n            ),\n            datasets.SplitGenerator(\n                name=datasets.Split.VALIDATION,\n                gen_kwargs={\"data_folder\": os.path.join(_DATA_URL, \"babylm_dev\"), \"split\": \"dev\"},\n            ),\n            datasets.SplitGenerator(\n                name=datasets.Split.TRAIN,\n                gen_kwargs={\"data_folder\": self.config.data_url, \"split\": \"train\"},\n            ),\n        ]\n        return ret_list\n\n    def _generate_examples(self, data_folder, split):\n        \"\"\"Yields examples.\"\"\"\n        all_data_files = [\n                os.path.join(data_folder, f'{source}.{split}')\n                for source in self.DATA_SOURCES]\n        all_lines = []\n        for data_file in all_data_files:\n            with open(data_file, encoding=\"utf-8\") as f:\n                all_lines.extend(f.readlines())\n        for idx, row in enumerate(all_lines):\n            if row.strip():\n                yield idx, {\"text\": row}\n            else:\n                yield idx, {\"text\": \"\"}", ""]}
{"filename": "src/babylm_baseline_train/datasets/babyLM.py", "chunked_list": ["from datasets import load_dataset, concatenate_datasets\nfrom transformers import AutoTokenizer\nimport numpy as np\nimport pdb\n\nfrom .utils import Group_Texts\nfrom .base import BaseGroupDataset\nfrom . import hf_loaders\n\n\nclass BabyLM(BaseGroupDataset):\n    def __init__(\n            self, \n            seq_len=128, tokenizer=None,\n            name='babyLM-10M',\n            ):\n        super().__init__(seq_len, tokenizer)\n        self.name = name\n\n    def get_dataset(self):\n        self.dataset = hf_loaders.get_babyLM(\n                name=self.name,\n                split=\"train\")", "\n\nclass BabyLM(BaseGroupDataset):\n    def __init__(\n            self, \n            seq_len=128, tokenizer=None,\n            name='babyLM-10M',\n            ):\n        super().__init__(seq_len, tokenizer)\n        self.name = name\n\n    def get_dataset(self):\n        self.dataset = hf_loaders.get_babyLM(\n                name=self.name,\n                split=\"train\")", "\n\ndef get_babyLM_10M(seq_len=128, tokenizer=None, just_dataset=False):\n    dataset_builder = BabyLM(\n            seq_len=seq_len,\n            tokenizer=tokenizer,\n            name='babyLM-10M',\n            )\n    return dataset_builder.get_group_dataset(just_dataset=just_dataset)\n", "\n\ndef get_babyLM_100M(seq_len=128, tokenizer=None, just_dataset=False):\n    dataset_builder = BabyLM(\n            seq_len=seq_len,\n            tokenizer=tokenizer,\n            name='babyLM-100M',\n            )\n    return dataset_builder.get_group_dataset(just_dataset=just_dataset)\n", ""]}
