{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/fixtures/__init__.py", "chunked_list": [""]}
{"filename": "tests/fixtures/pynetbox/devices.py", "chunked_list": ["from unittest.mock import Mock\n\nfrom pynetbox.core.response import Record\nfrom pynetbox.models.dcim import Devices\n\napi = Mock(base_url='http://netbox')\n\n_common = {\n    'airflow': None,\n    'asset_tag': None,", "    'airflow': None,\n    'asset_tag': None,\n    'cluster': None,\n    'comments': '',\n    'config_context': {},\n    'created': '2023-01-01T12:00:00.000000Z',\n    'custom_fields': {},\n    'device_role': Record({'display': 'Unknown'}, api, None),\n    'device_type': Record({'display': 'Unknown'}, api, None),\n    'face': None,", "    'device_type': Record({'display': 'Unknown'}, api, None),\n    'face': None,\n    'has_details': False,\n    'last_updated': '2023-01-01T12:00:00.000000Z',\n    'local_context_data': None,\n    'location': None,\n    'parent_device': None,\n    'platform': None,\n    'position': None,\n    'primary_ip6': None,", "    'position': None,\n    'primary_ip6': None,\n    'rack': None,\n    'serial': '',\n    'site': None,\n    'status': Record({'label': 'Active', 'value': 'active'}, api, None),\n    'tags': [],\n    'tenant': None,\n    'vc_position': None,\n    'vc_priority': None,", "    'vc_position': None,\n    'vc_priority': None,\n    'virtual_chassis': None}\n\n_dev_400 = _common.copy()\n_dev_400.update({\n    'display': 'pc',\n    'id': 400,\n    'name': 'pc',\n    # Primary IP addresse associations are postponed into ip_addresses module", "    'name': 'pc',\n    # Primary IP addresse associations are postponed into ip_addresses module\n    # to avoid circular import failures.\n    # 'primary_ip':  ip_addresses.ip_address_200,\n    # 'primary_ip4': ip_addresses.ip_address_200,\n    'url': 'http://netbox/api/dcim/devices/400/'})\n\ndevice_400 = Devices(_dev_400, api, None)\n", ""]}
{"filename": "tests/fixtures/pynetbox/prefixes.py", "chunked_list": ["from unittest.mock import Mock\n\nfrom pynetbox.core.response import Record\nfrom pynetbox.models.ipam import Prefixes\n\napi = Mock(base_url='http://netbox')\n\n_common = {\n    'children': 0,\n    'comments': '',", "    'children': 0,\n    'comments': '',\n    'created': '2023-01-01T12:00:00.000000Z',\n    'custom_fields': {'dhcp_enable': True,\n                      'dhcp_option_data_domain_search': 'local, lan',\n                      'dhcp_option_data_routers': '192.168.0.254'},\n    'description': '',\n    'family': Record({'label': 'IPv4', 'value': 4}, api, None),\n    'has_details': False,\n    'is_pool': False,", "    'has_details': False,\n    'is_pool': False,\n    'last_updated': '2023-01-01T12:00:00.000000Z',\n    'mark_utilized': False,\n    'role': None,\n    'site': None,\n    'status': Record({'label': 'Active', 'value': 'active'}, api, None),\n    'tags': [],\n    'tenant': None,\n    'url': 'http://netbox/api/ipam/prefixes/100/',", "    'tenant': None,\n    'url': 'http://netbox/api/ipam/prefixes/100/',\n    'vlan': None,\n    'vrf': None}\n\n_pref_100 = _common.copy()\n_pref_100.update({\n    'display': '192.168.0.0/24',\n    'id': 100,\n    'prefix': '192.168.0.0/24'})", "    'id': 100,\n    'prefix': '192.168.0.0/24'})\n\nprefix_100 = Prefixes(_pref_100, api, None)\n\n_pref_101 = _common.copy()\n_pref_101.update({\n    'custom_fields': {'dhcp_enable': True,\n                      'dhcp_option_data_domain_search': 'local, lan10',\n                      'dhcp_option_data_routers': '10.254.254.254'},", "                      'dhcp_option_data_domain_search': 'local, lan10',\n                      'dhcp_option_data_routers': '10.254.254.254'},\n    'display': '10.0.0.0/8',\n    'id': 101,\n    'prefix': '10.0.0.0/8'})\nprefix_101 = Prefixes(_pref_101, api, None)\n"]}
{"filename": "tests/fixtures/pynetbox/virtual_machines.py", "chunked_list": ["from unittest.mock import Mock\n\nfrom pynetbox.core.response import Record\nfrom pynetbox.models.virtualization import VirtualMachines\n\napi = Mock(base_url='http://netbox')\n\n_common = {\n    'cluster': Record({'display': 'My cluster'}, api, None),\n    'comments': '',", "    'cluster': Record({'display': 'My cluster'}, api, None),\n    'comments': '',\n    'config_context': {},\n    'created': '2023-01-01T12:00:00.000000Z',\n    'custom_fields': {},\n    'device': None,\n    'disk': None,\n    'has_details': False,\n    'last_updated': '2023-01-01T12:00:00.000000Z',\n    'local_context_data': None,", "    'last_updated': '2023-01-01T12:00:00.000000Z',\n    'local_context_data': None,\n    'memory': None,\n    'platform': None,\n    'primary_ip6': None,\n    'role': None,\n    'site': None,\n    'status': Record({'label': 'Active', 'value': 'active'}, api, None),\n    'tags': [],\n    'tenant': None,", "    'tags': [],\n    'tenant': None,\n    'vcpus': None}\n\n_vm_450 = _common.copy()\n_vm_450.update({\n    'display': 'vm',\n    'id': 450,\n    'name': 'vm',\n    # Primary IP addresse associations are postponed into ip_addresses module", "    'name': 'vm',\n    # Primary IP addresse associations are postponed into ip_addresses module\n    # to avoid circular import failures.\n    # 'primary_ip': ip_addresse.ip_address_300,\n    # 'primary_ip4': ip_addresses.ip_address_300,\n    'url': 'http://netbox/api/virtualization/virtual-machines/450/'})\n\nvirtual_machine_450 = VirtualMachines(_vm_450, api, None)\n", ""]}
{"filename": "tests/fixtures/pynetbox/__init__.py", "chunked_list": [""]}
{"filename": "tests/fixtures/pynetbox/vminterfaces.py", "chunked_list": ["from unittest.mock import Mock\n\nfrom pynetbox.core.response import Record\n\nfrom . import virtual_machines\n\napi = Mock(base_url='http://netbox')\n\n# Note: record method \"full_detail()\" was called\n_common = {", "# Note: record method \"full_detail()\" was called\n_common = {\n    'bridge': None,\n    'count_fhrp_groups': 0,\n    'created': '2023-01-01T12:00:00.000000Z',\n    'custom_fields': {},\n    'description': '',\n    'enabled': True,\n    'has_details': True,\n    'l2vpn_termination': None,", "    'has_details': True,\n    'l2vpn_termination': None,\n    'last_updated': '2023-03-28T08:15:56.256950Z',\n    'mac_address': '55:55:55:55:55:55',\n    'mode': None,\n    'mtu': None,\n    'parent': None,\n    'tagged_vlans': [],\n    'tags': [],\n    'untagged_vlan': None,", "    'tags': [],\n    'untagged_vlan': None,\n    'vrf': None}\n\n_vif_350 = _common.copy()\n_vif_350.update({\n    'count_ipaddresses': 1,\n    'display': 'vm001-if0',\n    'id': 350,\n    'name': 'vm001-if0',", "    'id': 350,\n    'name': 'vm001-if0',\n    'virtual_machine': virtual_machines.virtual_machine_450,\n    'url': 'http://netbox:8000/api/virtualization/interfaces/350/'})\n\nvminterface_350 = Record(_vif_350, api, None)\n"]}
{"filename": "tests/fixtures/pynetbox/ip_addresses.py", "chunked_list": ["from unittest.mock import Mock\n\nfrom pynetbox.core.response import Record\nfrom pynetbox.models.ipam import IpAddresses\n\nfrom . import devices, interfaces, virtual_machines, vminterfaces\n\nALL_IP = []\n\n\ndef get(id_):\n    \"\"\" Emulate pynetbox.[\u2026].Record.get()\"\"\"\n    for ip in ALL_IP:\n        if ip.id == id_:\n            return ip", "\n\ndef get(id_):\n    \"\"\" Emulate pynetbox.[\u2026].Record.get()\"\"\"\n    for ip in ALL_IP:\n        if ip.id == id_:\n            return ip\n\n\ndef filter_(interface_id=None, device_id=None, vminterface_id=None,\n            virtual_machine_id=None, **kwargs):\n    \"\"\" Emulate pynetbox.[\u2026].Record.filter()\"\"\"\n\n    intf_id = vminterface_id if vminterface_id else interface_id\n    if intf_id:\n        return iter([ip for ip in ALL_IP if ip.assigned_object and\n                     ip.assigned_object.id == intf_id])\n    elif device_id:\n        return iter([ip for ip in ALL_IP if\n                     ip.assigned_object_type == 'dcim.interface'\n                     and ip.assigned_object.device.id == device_id])\n    elif virtual_machine_id:\n        return iter([ip for ip in ALL_IP if\n                     ip.assigned_object_type == 'virtualization.vminterface'\n                     and ip.assigned_object.virtual_machine.id ==\n                     virtual_machine_id])\n    else:\n        return iter(ALL_IP)", "\ndef filter_(interface_id=None, device_id=None, vminterface_id=None,\n            virtual_machine_id=None, **kwargs):\n    \"\"\" Emulate pynetbox.[\u2026].Record.filter()\"\"\"\n\n    intf_id = vminterface_id if vminterface_id else interface_id\n    if intf_id:\n        return iter([ip for ip in ALL_IP if ip.assigned_object and\n                     ip.assigned_object.id == intf_id])\n    elif device_id:\n        return iter([ip for ip in ALL_IP if\n                     ip.assigned_object_type == 'dcim.interface'\n                     and ip.assigned_object.device.id == device_id])\n    elif virtual_machine_id:\n        return iter([ip for ip in ALL_IP if\n                     ip.assigned_object_type == 'virtualization.vminterface'\n                     and ip.assigned_object.virtual_machine.id ==\n                     virtual_machine_id])\n    else:\n        return iter(ALL_IP)", "\n\napi = Mock(base_url='http://netbox')\n\n_common = {\n    'assigned_object': None,\n    'assigned_object_id': None,\n    'assigned_object_type': None,\n    'comments': '',\n    'created': '2023-01-01T12:00:00.000000Z',", "    'comments': '',\n    'created': '2023-01-01T12:00:00.000000Z',\n    'custom_fields': {},\n    'description': '',\n    'family': Record({'label': 'IPv4', 'value': 4}, api, None),\n    'has_details': False,\n    'last_updated': '2023-01-01T12:00:00.000000Z',\n    'nat_inside': None,\n    'nat_outside': [],\n    'role': None,", "    'nat_outside': [],\n    'role': None,\n    'tags': [],\n    'tenant': None,\n    'vrf': None}\n\n_ip_200 = _common.copy()\n_ip_200.update({\n    'address': '192.168.0.1/24',\n    'assigned_object': interfaces.interface_300,", "    'address': '192.168.0.1/24',\n    'assigned_object': interfaces.interface_300,\n    'assigned_object_id': 300,\n    'assigned_object_type': 'dcim.interface',\n    'display': '192.168.0.1/24',\n    'dns_name': 'pc.lan',\n    'id': 200,\n    'status': Record({'label': 'DHCP', 'value': 'dhcp'}, api, None),\n    'url': 'https://netbox/api/ipam/ip-addresses/200/'})\n", "    'url': 'https://netbox/api/ipam/ip-addresses/200/'})\n\nip_address_200 = IpAddresses(_ip_200, api, None)\nALL_IP.append(ip_address_200)\n# Associate here IP address with device to avoid circular import failure\ndevices.device_400.primary_ip = ip_address_200\ndevices.device_400.primary_ip4 = ip_address_200\n\n_ip_201 = _common.copy()\n_ip_201.update({", "_ip_201 = _common.copy()\n_ip_201.update({\n    'address': '192.168.0.2/24',\n    'custom_fields': {'dhcp_resa_hw_address': '22:22:22:22:22:22'},\n    'display': '192.168.0.2/24',\n    'dns_name': 'pc2.lan',\n    'id': 201,\n    'status': Record({'label': 'DHCP', 'value': 'dhcp'}, api, None),\n    'url': 'https://netbox/api/ipam/ip-addresses/201/'})\nip_address_201 = IpAddresses(_ip_201, api, None)", "    'url': 'https://netbox/api/ipam/ip-addresses/201/'})\nip_address_201 = IpAddresses(_ip_201, api, None)\nALL_IP.append(ip_address_201)\n\n_ip_202 = _common.copy()\n_ip_202.update({\n    'address': '192.168.0.3/24',\n    'assigned_object': interfaces.interface_300,\n    'assigned_object_id': 300,\n    'assigned_object_type': 'dcim.interface',", "    'assigned_object_id': 300,\n    'assigned_object_type': 'dcim.interface',\n    'custom_fields': {'dhcp_resa_hw_address': '33:33:33:33:33:33'},\n    'display': '192.168.0.3/24',\n    'dns_name': 'pc3.lan',\n    'id': 202,\n    'status': Record({'label': 'DHCP', 'value': 'dhcp'}, api, None),\n    'url': 'https://netbox/api/ipam/ip-addresses/202/'})\nip_address_202 = IpAddresses(_ip_202, api, None)\nALL_IP.append(ip_address_202)", "ip_address_202 = IpAddresses(_ip_202, api, None)\nALL_IP.append(ip_address_202)\n\n_ip_250 = _common.copy()\n_ip_250.update({\n    'address': '10.0.0.50/8',\n    'assigned_object': vminterfaces.vminterface_350,\n    'assigned_object_id': 350,\n    'assigned_object_type': 'virtualization.vminterface',\n    'display': '10.0.0.50/8',", "    'assigned_object_type': 'virtualization.vminterface',\n    'display': '10.0.0.50/8',\n    'dns_name': 'vm.lan10',\n    'id': 250,\n    'status': Record({'label': 'DHCP', 'value': 'dhcp'}, api, None),\n    'url': 'https://netbox/api/ipam/ip-addresses/250/'})\n\nip_address_250 = IpAddresses(_ip_250, api, None)\nALL_IP.append(ip_address_250)\n# Associate here IP address with device to avoid circular import failure", "ALL_IP.append(ip_address_250)\n# Associate here IP address with device to avoid circular import failure\nvirtual_machines.virtual_machine_450.primary_ip = ip_address_250\nvirtual_machines.virtual_machine_450.primary_ip4 = ip_address_250\n"]}
{"filename": "tests/fixtures/pynetbox/ip_ranges.py", "chunked_list": ["from unittest.mock import Mock\n\nfrom pynetbox.core.response import Record\nfrom pynetbox.models.ipam import IpRanges\n\napi = Mock(base_url='http://netbox')\n\n_common = {\n    'comments': '',\n    'created': '2023-01-01T12:00:00.000000Z',", "    'comments': '',\n    'created': '2023-01-01T12:00:00.000000Z',\n    'custom_fields': {},\n    'description': '',\n    'family': Record({'label': 'IPv4', 'value': 4}, api, None),\n    'has_details': False,\n    'last_updated': '2023-01-01T12:00:00.000000Z',\n    'role': None,\n    'size': 100,\n    'tags': [],", "    'size': 100,\n    'tags': [],\n    'tenant': None,\n    'vrf': None}\n\n_r_250 = _common.copy()\n_r_250.update({\n    'display': '192.168.0.100-200/24',\n    'end_address': '192.168.0.199/24',\n    'id': 250,", "    'end_address': '192.168.0.199/24',\n    'id': 250,\n    'start_address': '192.168.0.100/24',\n    'status': Record({'label': 'DHCP', 'value': 'dhcp'}, api, None),\n    'url': 'http://netbox/api/ipam/ip-ranges/250/'})\n\nip_range_250 = IpRanges(_r_250, api, None)\n"]}
{"filename": "tests/fixtures/pynetbox/interfaces.py", "chunked_list": ["from unittest.mock import Mock\n\nfrom pynetbox.core.response import Record\nfrom pynetbox.models.dcim import Interfaces\n\nfrom . import devices\n\napi = Mock(base_url='http://netbox')\n\n_common = {", "\n_common = {\n    '_occupied': False,\n    'bridge': None,\n    'cable': None,\n    'cable_end': '',\n    'created': '2023-01-01T12:00:00.000000Z',\n    'connected_endpoints': None,\n    'connected_endpoints_reachable': None,\n    'connected_endpoints_type': None,", "    'connected_endpoints_reachable': None,\n    'connected_endpoints_type': None,\n    'count_fhrp_groups': 0,\n    'custom_fields': {},\n    'description': '',\n    'duplex': None,\n    'enabled': True,\n    'has_details': False,\n    'l2vpn_termination': None,\n    'label': '',", "    'l2vpn_termination': None,\n    'label': '',\n    'lag': None,\n    'last_updated': '2023-01-01T12:00:00.000000Z',\n    'link_peers': [],\n    'link_peers_type': None,\n    'mark_connected': False,\n    'mgmt_only': False,\n    'mode': None,\n    'module': None,", "    'mode': None,\n    'module': None,\n    'mtu': None,\n    'parent': None,\n    'poe_mode': None,\n    'poe_type': None,\n    'rf_channel': None,\n    'rf_channel_frequency': None,\n    'rf_channel_width': None,\n    'rf_role': None,", "    'rf_channel_width': None,\n    'rf_role': None,\n    'speed': None,\n    'tagged_vlans': [],\n    'tags': [],\n    'tx_power': None,\n    'type': Record(\n        {'label': '1000BASE-T (1GE)', 'value': '1000base-t'}, api, None),\n    'untagged_vlan': None,\n    'vdcs': [],", "    'untagged_vlan': None,\n    'vdcs': [],\n    'vrf': None,\n    'wireless_lans': [],\n    'wireless_link': None,\n    'wwn': None}\n\n# pynetbox record __dict__ attribute\n_if_300 = _common.copy()\n_if_300.update({", "_if_300 = _common.copy()\n_if_300.update({\n    'count_ipaddresses': 1,\n    #'device': tests.fixtures.pynetbox.devices.device_400,\n    'device': devices.device_400,\n    'display': 'pc-if0',\n    'id': 300,\n    'mac_address': '11:11:11:11:11:11',\n    'name': 'pc-if0',\n    'url': 'http://netbox/api/dcim/interfaces/300/',", "    'name': 'pc-if0',\n    'url': 'http://netbox/api/dcim/interfaces/300/',\n    })\n\ninterface_300 = Interfaces(_if_300, api, None)\n"]}
{"filename": "tests/unit/test_connector.py", "chunked_list": ["import unittest\nfrom unittest.mock import Mock, call\n\nfrom netboxkea.connector import _get_nested, _set_dhcp_attr, Connector\nfrom netboxkea.kea.exceptions import SubnetNotFound\nfrom ..fixtures.pynetbox import ip_addresses as fixtip\nfrom ..fixtures.pynetbox import ip_ranges as fixtr\nfrom ..fixtures.pynetbox import prefixes as fixtp\n\n\nclass TestConnectorFunctions(unittest.TestCase):\n\n    def test_01_get_nested_attr(self):\n        obj = {'assigned': {'device': {'name': 'pc.lan'}}}\n        hostname = _get_nested(obj, 'assigned.device.name')\n        self.assertEqual(hostname, 'pc.lan')\n\n    def test_02_set_dhcp_attr(self):\n        dhcp_item = {}\n        _set_dhcp_attr(dhcp_item, 'next-server', '10.0.0.1')\n        _set_dhcp_attr(dhcp_item, 'option-data.routers', '192.168.0.254')\n        _set_dhcp_attr(dhcp_item, 'option-data.domain-search', 'lan')\n        _set_dhcp_attr(dhcp_item, 'user-context.desc', 'Test')\n        _set_dhcp_attr(dhcp_item, 'user-context.note', 'Hello')\n        self.assertEqual(dhcp_item, {\n            'next-server': '10.0.0.1',\n            'option-data': [\n                {'name': 'routers', 'data': '192.168.0.254'},\n                {'name': 'domain-search', 'data': 'lan'}],\n            'user-context': {'desc': 'Test', 'note': 'Hello'}})", "\n\nclass TestConnectorFunctions(unittest.TestCase):\n\n    def test_01_get_nested_attr(self):\n        obj = {'assigned': {'device': {'name': 'pc.lan'}}}\n        hostname = _get_nested(obj, 'assigned.device.name')\n        self.assertEqual(hostname, 'pc.lan')\n\n    def test_02_set_dhcp_attr(self):\n        dhcp_item = {}\n        _set_dhcp_attr(dhcp_item, 'next-server', '10.0.0.1')\n        _set_dhcp_attr(dhcp_item, 'option-data.routers', '192.168.0.254')\n        _set_dhcp_attr(dhcp_item, 'option-data.domain-search', 'lan')\n        _set_dhcp_attr(dhcp_item, 'user-context.desc', 'Test')\n        _set_dhcp_attr(dhcp_item, 'user-context.note', 'Hello')\n        self.assertEqual(dhcp_item, {\n            'next-server': '10.0.0.1',\n            'option-data': [\n                {'name': 'routers', 'data': '192.168.0.254'},\n                {'name': 'domain-search', 'data': 'lan'}],\n            'user-context': {'desc': 'Test', 'note': 'Hello'}})", "\n\nclass TestConnector(unittest.TestCase):\n\n    def setUp(self):\n        self.nb = Mock()\n        self.kea = Mock()\n\n        # Set up connector\n        resa_ip_map = {\n            'hw-address': ['custom_fields.dhcp_resa_hw_address',\n                           'assigned_object.mac_address'],\n            'hostname': ['dns_name', 'assigned_object.device.name',\n                         'assigned_object.virtual_machine.name']}\n        self.conn = Connector(self.nb, self.kea, {}, {}, resa_ip_map)\n\n        # Set up netbox mock\n        self.nb.prefix.return_value = fixtp.prefix_100\n        self.nb.prefixes.return_value = iter([fixtp.prefix_100])\n        self.nb.all_prefixes.return_value = iter([fixtp.prefix_100])\n        self.nb.ip_range.return_value = fixtr.ip_range_250\n        self.nb.ip_ranges.return_value = iter([fixtr.ip_range_250])\n        self.nb.ip_address.side_effect = fixtip.get\n        self.nb.ip_addresses.side_effect = fixtip.filter_\n\n        # Define kea calls\n        self.call_subnet100 = call(100, {'subnet': '192.168.0.0/24'})\n        self.call_subnet101 = call(101, {'subnet': '10.0.0.0/8'})\n        self.call_resa200 = call(100, 200, {\n            'ip-address': '192.168.0.1', 'hw-address': '11:11:11:11:11:11',\n            'hostname': 'pc.lan'})\n        self.call_resa201 = call(100, 201, {\n            'ip-address': '192.168.0.2', 'hw-address': '22:22:22:22:22:22',\n            'hostname': 'pc2.lan'})\n        self.call_resa202 = call(100, 202, {\n            'ip-address': '192.168.0.3', 'hw-address': '33:33:33:33:33:33',\n            'hostname': 'pc3.lan'})\n        self.call_resa250 = call(100, 250, {\n            'ip-address': '10.0.0.50', 'hw-address': '55:55:55:55:55:55',\n            'hostname': 'vm.lan10'})\n        self.call_pool250 = call(100, 250, {\n            'pool': '192.168.0.100-192.168.0.199'})\n\n    def test_01_sync_ip_address_with_assigned_interface(self):\n        self.conn.sync_ipaddress(200)\n        self.nb.ip_address.assert_called_once_with(200)\n        self.nb.prefixes.assert_called_once_with(contains='192.168.0.1/24')\n        self.kea.set_reservation.assert_has_calls([self.call_resa200])\n\n    def test_02_sync_ip_address_with_custom_field(self):\n        self.conn.sync_ipaddress(201)\n        self.nb.ip_address.assert_called_once_with(201)\n        self.nb.prefixes.assert_called_once_with(contains='192.168.0.2/24')\n        self.kea.set_reservation.assert_has_calls([self.call_resa201])\n\n    def test_03_sync_ip_address_with_assigned_and_custom_field(self):\n        self.conn.sync_ipaddress(202)\n        self.nb.ip_address.assert_called_once_with(202)\n        self.nb.prefixes.assert_called_once_with(contains='192.168.0.3/24')\n        self.kea.set_reservation.assert_has_calls([self.call_resa202])\n\n    def test_05_sync_ip_address_vm(self):\n        self.conn.sync_ipaddress(250)\n        self.nb.ip_address.assert_called_once_with(250)\n        self.nb.prefixes.assert_called_once_with(contains='10.0.0.50/8')\n        self.kea.set_reservation.assert_has_calls([self.call_resa250])\n\n    def test_09_sync_ip_address_del(self):\n        self.conn.sync_ipaddress(249)\n        self.nb.ip_address.assert_called_once_with(249)\n        self.kea.del_resa.assert_called_once_with(249)\n\n    def test_10_sync_interface(self):\n        self.conn.sync_interface(300)\n        self.nb.ip_addresses.assert_called_once_with(interface_id=300)\n        self.kea.set_reservation.assert_has_calls([self.call_resa200])\n\n    def test_11_sync_device(self):\n        self.conn.sync_device(400)\n        self.nb.ip_addresses.assert_called_once_with(device_id=400)\n        self.kea.set_reservation.assert_has_calls([self.call_resa200])\n\n    def test_15_sync_vminterface(self):\n        self.conn.sync_vminterface(350)\n        self.nb.ip_addresses.assert_called_once_with(vminterface_id=350)\n        self.kea.set_reservation.assert_has_calls([self.call_resa250])\n\n    def test_16_sync_virtualmachine(self):\n        self.conn.sync_virtualmachine(450)\n        self.nb.ip_addresses.assert_called_once_with(virtual_machine_id=450)\n        self.kea.set_reservation.assert_has_calls([self.call_resa250])\n\n    def test_20_sync_ip_range(self):\n        self.conn.sync_iprange(250)\n        self.kea.set_pool.assert_has_calls([self.call_pool250])\n\n    def test_21_sync_ip_range_del(self):\n        self.nb.ip_range.return_value = None\n        self.conn.sync_iprange(299)\n        self.kea.del_pool.assert_called_once_with(299)\n\n    def test_30_sync_prefix_update(self):\n        self.conn.sync_prefix(100)\n        self.kea.update_subnet.assert_called_once_with(100, {\n            'subnet': '192.168.0.0/24'})\n\n    def test_31_sync_prefix_fullsync(self):\n        self.kea.update_subnet.side_effect = SubnetNotFound()\n        self.conn.sync_prefix(100)\n        self.nb.ip_addresses.assert_called_once_with(parent='192.168.0.0/24')\n        self.nb.ip_ranges.assert_called_once_with(parent='192.168.0.0/24')\n        self.kea.set_subnet.assert_has_calls([self.call_subnet100])\n        self.kea.set_reservation.assert_has_calls(\n            [self.call_resa200, self.call_resa201, self.call_resa202])\n        self.kea.set_pool.assert_has_calls([self.call_pool250])\n\n    def test_39_sync_prefix_del(self):\n        self.nb.prefix.return_value = None\n        self.conn.sync_prefix(199)\n        self.kea.del_subnet.assert_called_once_with(199)\n\n    def test_99_sync_all(self):\n        self.conn.sync_all()\n        self.kea.set_subnet.assert_has_calls([self.call_subnet100])\n        self.kea.set_reservation.assert_has_calls(\n            [self.call_resa200, self.call_resa201, self.call_resa202,\n             self.call_resa250])\n        self.kea.set_pool.assert_has_calls([self.call_pool250])\n        self.kea.commit.assert_called()\n        self.kea.push.assert_called()", ""]}
{"filename": "tests/unit/__init__.py", "chunked_list": [""]}
{"filename": "tests/unit/test_kea.py", "chunked_list": ["import unittest\nfrom copy import deepcopy\nfrom unittest.mock import MagicMock, call\n\nfrom netboxkea.kea.app import DHCP4App\nfrom netboxkea.kea.exceptions import KeaClientError, SubnetNotFound\n\n\nclass TestKea(unittest.TestCase):\n", "class TestKea(unittest.TestCase):\n\n    def _set_std_subnet(self):\n        self.kea.set_subnet(100, {'subnet': '192.168.0.0/24'})\n\n    def _set_std_resa(self):\n        self.kea.set_reservation(100, 200, {\n            'ip-address': '192.168.0.1', 'hw-address': '11:22:33:44:55:66',\n            'hostname': 'pc.lan'})\n", "            'hostname': 'pc.lan'})\n\n    def _set_std_pool(self):\n        self.kea.set_pool(100, 250, {'pool': '192.168.0.100-192.168.0.199'})\n\n    def setUp(self):\n        self.kea = DHCP4App('http://keasrv/api')\n        self.req = MagicMock()\n        self.kea.api._request_kea = self.req\n        self.srv_conf = {'Dhcp4': {}}", "        self.kea.api._request_kea = self.req\n        self.srv_conf = {'Dhcp4': {}}\n        self.srv_check_res = True\n\n        def req_result(cmd, params=None):\n            match cmd:\n                case 'config-get':\n                    return deepcopy(self.srv_conf)\n                case 'config-set':\n                    self.srv_conf = deepcopy(params)", "                case 'config-set':\n                    self.srv_conf = deepcopy(params)\n                case 'config-test':\n                    return self.srv_check_res\n                case 'config-write':\n                    pass\n                case _:\n                    raise ValueError(cmd)\n\n        self.req.side_effect = req_result", "\n        self.req.side_effect = req_result\n        self.kea.pull()\n        self.req.reset_mock()\n\n    def test_01_pull(self):\n        self.assertEqual(self.kea.conf, {'subnet4': []})\n        self.assertEqual(self.kea.commit_conf, self.kea.conf)\n\n    def test_02_commit(self):", "\n    def test_02_commit(self):\n        newconf = {'subnet4': [{'garbage': True}]}\n        self.kea.conf = deepcopy(newconf)\n        self.kea.commit()\n        self.req.assert_called_once_with('config-test', {'Dhcp4': newconf})\n        self.assertEqual(self.kea.conf, self.kea.commit_conf)\n\n    def test_03_push_wo_commit(self):\n        self.kea.push()", "    def test_03_push_wo_commit(self):\n        self.kea.push()\n        self.req.assert_not_called()\n\n    def test_04_push_w_commit(self):\n        newconf = {'subnet4': [{'garbage': True}]}\n        self.kea.conf = deepcopy(newconf)\n        self.kea.commit()\n        self.kea.push()\n        calls = [call('config-test', {'Dhcp4': newconf}),", "        self.kea.push()\n        calls = [call('config-test', {'Dhcp4': newconf}),\n                 call('config-set', {'Dhcp4': newconf}),\n                 call('config-write', {'Dhcp4': newconf})]\n        self.req.has_calls(calls)\n        self.assertEqual(self.srv_conf['Dhcp4'], newconf)\n        self.assertEqual(self.kea.conf, self.kea.commit_conf)\n\n    def test_10_set_subnet(self):\n        expected = {'subnet4': [", "    def test_10_set_subnet(self):\n        expected = {'subnet4': [\n            {'id': 100, 'subnet': '192.168.0.0/24', 'pools': [],\n             'reservations': []}]}\n        self._set_std_subnet()\n        self.kea.push()\n        self.assertEqual(self.srv_conf['Dhcp4'], expected)\n\n    def test_11_set_subnet_replace(self):\n        self.kea.set_subnet(100, {'subnet': '10.0.0.0/8'})", "    def test_11_set_subnet_replace(self):\n        self.kea.set_subnet(100, {'subnet': '10.0.0.0/8'})\n        self._set_std_subnet()\n        self.kea.push()\n        self.assertEqual(\n            self.srv_conf['Dhcp4']['subnet4'][0]['subnet'], '192.168.0.0/24')\n        self.assertEqual(len(self.srv_conf['Dhcp4']['subnet4']), 1)\n\n    def test_12_set_subnet_conflict(self):\n        self._set_std_subnet()", "    def test_12_set_subnet_conflict(self):\n        self._set_std_subnet()\n        with self.assertRaises(KeaClientError):\n            self.kea.set_subnet(101, {'subnet': '192.168.0.0/24'})\n\n    def test_13_update_subnet_notfound(self):\n        with self.assertRaises(SubnetNotFound):\n            self.kea.update_subnet(100, {'subnet': '10.0.0.0/8', 'opt': 1})\n\n    def test_14_update_subnet_ok(self):", "\n    def test_14_update_subnet_ok(self):\n        self._set_std_subnet()\n        self.kea.update_subnet(100, {'subnet': '192.168.0.0/24', 'opt': 1})\n        self.kea.push()\n        self.assertEqual(self.srv_conf['Dhcp4']['subnet4'][0]['opt'], 1)\n\n    def test_15_del_subnet(self):\n        self._set_std_subnet()\n        self.kea.del_subnet(100)", "        self._set_std_subnet()\n        self.kea.del_subnet(100)\n        self.kea.push()\n        self.assertEqual(len(self.srv_conf['Dhcp4']['subnet4']), 0)\n\n    def test_16_del_all_subnets(self):\n        self._set_std_subnet()\n        self.kea.del_all_subnets()\n        self.kea.push()\n        self.assertEqual(len(self.srv_conf['Dhcp4']['subnet4']), 0)", "        self.kea.push()\n        self.assertEqual(len(self.srv_conf['Dhcp4']['subnet4']), 0)\n\n    def test_20_set_reservation(self):\n        expected = {'subnet4': [\n            {'id': 100, 'subnet': '192.168.0.0/24', 'pools': [],\n             'reservations': [{\n                'ip-address': '192.168.0.1', 'hw-address': '11:22:33:44:55:66',\n                'hostname': 'pc.lan', 'user-context': {\n                    'netbox_ip_address_id': 200}}]", "                'hostname': 'pc.lan', 'user-context': {\n                    'netbox_ip_address_id': 200}}]\n             }]}\n        self._set_std_subnet()\n        self._set_std_resa()\n        self.kea.push()\n        self.assertEqual(self.srv_conf['Dhcp4'], expected)\n\n    def test_21_set_reservation_replace(self):\n        self._set_std_subnet()", "    def test_21_set_reservation_replace(self):\n        self._set_std_subnet()\n        self._set_std_resa()\n        self.kea.set_reservation(100, 200, {\n            'ip-address': '192.168.0.9', 'hw-address': '11:22:33:44:55:66',\n            'hostname': 'pc.lan'})\n        self.kea.push()\n        self.assertEqual(\n            self.srv_conf['Dhcp4']['subnet4'][0]['reservations'][0]\n            ['ip-address'], '192.168.0.9')", "            self.srv_conf['Dhcp4']['subnet4'][0]['reservations'][0]\n            ['ip-address'], '192.168.0.9')\n        self.assertEqual(len(\n            self.srv_conf['Dhcp4']['subnet4'][0]['reservations']), 1)\n\n    def test_22_set_reservation_subnet_not_found(self):\n        with self.assertRaises(SubnetNotFound):\n            self._set_std_resa()\n\n    def test_23_set_reservation_conflict_hw(self):", "\n    def test_23_set_reservation_conflict_hw(self):\n        self._set_std_subnet()\n        self._set_std_resa()\n        with self.assertRaises(KeaClientError):\n            self.kea.set_reservation(100, 201, {\n                'ip-address': '192.168.0.2', 'hw-address': '11:22:33:44:55:66',\n                'hostname': 'pc2.lan'})\n\n    def test_24_set_reservation_conflict_ip(self):", "\n    def test_24_set_reservation_conflict_ip(self):\n        self._set_std_subnet()\n        self._set_std_resa()\n        with self.assertRaises(KeaClientError):\n            self.kea.set_reservation(100, 201, {\n                'ip-address': '192.168.0.1', 'hw-address': '11:22:33:33:22:11',\n                'hostname': 'pc2.lan'})\n\n    def test_25_set_reservation_no_conflict_ip(self):", "\n    def test_25_set_reservation_no_conflict_ip(self):\n        self.srv_conf['Dhcp4']['ip-reservations-unique'] = False\n        self.kea.pull()\n        self._set_std_subnet()\n        self._set_std_resa()\n        self.kea.set_reservation(100, 201, {\n            'ip-address': '192.168.0.1', 'hw-address': '11:22:33:33:22:11',\n            'hostname': 'pc2.lan'})\n        self.assertEqual(len(self.kea.conf['subnet4'][0]['reservations']), 2)", "            'hostname': 'pc2.lan'})\n        self.assertEqual(len(self.kea.conf['subnet4'][0]['reservations']), 2)\n\n    def test_26_del_reservation(self):\n        self._set_std_subnet()\n        self._set_std_resa()\n        self.kea.del_resa(200)\n        self.assertEqual(len(self.kea.conf['subnet4'][0]['reservations']), 0)\n\n    def test_30_set_pool(self):", "\n    def test_30_set_pool(self):\n        expected = {'subnet4': [\n            {'id': 100, 'subnet': '192.168.0.0/24', 'pools': [{\n                'pool': '192.168.0.100-192.168.0.199',\n                'user-context': {'netbox_ip_range_id': 250}\n                }], 'reservations': []}]}\n        self._set_std_subnet()\n        self._set_std_pool()\n        self.kea.push()", "        self._set_std_pool()\n        self.kea.push()\n        self.assertEqual(self.srv_conf['Dhcp4'], expected)\n\n    def test_33_set_pool_conflict_overlap(self):\n        self._set_std_subnet()\n        self._set_std_pool()\n        with self.assertRaises(KeaClientError):\n            self.kea.set_pool(100, 251, {'pool': '192.168.0.50-192.168.0.100'})\n        with self.assertRaises(KeaClientError):", "            self.kea.set_pool(100, 251, {'pool': '192.168.0.50-192.168.0.100'})\n        with self.assertRaises(KeaClientError):\n            self.kea.set_pool(100, 251, {\n                'pool': '192.168.0.199-192.168.0.250'})\n\n    def test_35_del_pool(self):\n        self._set_std_subnet()\n        self._set_std_pool()\n        self.kea.del_pool(250)\n        self.assertEqual(len(self.kea.conf['subnet4'][0]['pools']), 0)", "        self.kea.del_pool(250)\n        self.assertEqual(len(self.kea.conf['subnet4'][0]['pools']), 0)\n"]}
{"filename": "src/netboxkea/config.py", "chunked_list": ["import logging\nimport sys\nfrom argparse import ArgumentParser\nfrom dataclasses import dataclass, field\ntry:\n    import tomllib\nexcept ModuleNotFoundError:\n    import tomli as tomllib\n\nfrom .__about__ import __version__", "\nfrom .__about__ import __version__\n\n\n@dataclass(frozen=True)\nclass Config:\n    config_file: str = None\n    check_only: bool = False\n    full_sync_at_startup: bool = False\n    listen: bool = False\n    bind: str = '127.0.0.1'\n    port: int = 8001\n    secret: str = None\n    secret_header: str = 'X-netbox2kea-secret'\n    log_level: str = 'warning'\n    ext_log_level: str = 'warning'\n    syslog_level_prefix: bool = False\n    kea_url: str = None\n    netbox_url: str = None\n    netbox_token: str = None\n    prefix_filter: dict = field(default_factory=lambda: {\n        'cf_dhcp_enabled': True})\n    ipaddress_filter: dict = field(default_factory=lambda: {'status': 'dhcp'})\n    iprange_filter: dict = field(default_factory=lambda: {'status': 'dhcp'})\n    subnet_prefix_map: dict = field(default_factory=lambda: {\n        'option-data.routers': 'custom_fields.dhcp_option_data_routers',\n        'option-data.domain-search':\n            'custom_fields.dhcp_option_data_domain_search',\n        'option-data.domain-name-servers':\n            'custom_fields.dhcp_option_data_domain_name_servers',\n        'next-server': 'custom_fields.dhcp_next_server',\n        'boot-file-name': 'custom_fields.dhcp_boot_file_name',\n        'valid-lifetime': 'custom_fields.dhcp_valid_lifetime'})\n    pool_iprange_map: dict = field(default_factory=lambda: {})\n    reservation_ipaddr_map: dict = field(default_factory=lambda: {\n        # Get MAC address from custom field, fallback to assigned interface\n        'hw-address': ['custom_fields.dhcp_reservation_hw_address',\n                       'assigned_object.mac_address'],\n        # Get hostname from DNS name, fallback to device/vm name\n        'hostname': ['dns_name', 'assigned_object.device.name',\n                     'assigned_object.virtual_machine.name']\n        })", "\n\ndef get_config():\n    settings = {}\n\n    parser = ArgumentParser()\n    parser.add_argument(\n        '--version', action='version', version=f'Version {__version__}')\n    parser.add_argument('-c', '--config-file', help='configuration file')\n    parser.add_argument('-n', '--netbox-url', help='')\n    parser.add_argument('-t', '--netbox-token', help='')\n    parser.add_argument('-k', '--kea-url', help='')\n    parser.add_argument(\n        '-l', '--listen', action='store_true', default=None, help='')\n    parser.add_argument('-b', '--bind', help='')\n    parser.add_argument('-p', '--port', type=int, help='')\n    parser.add_argument(\n        '--secret', help=f'Default header: {Config.secret_header}')\n    parser.add_argument(\n        '-s', '--sync-now', action='store_true', dest='full_sync_at_startup',\n        default=None, help='')\n    parser.add_argument(\n        '--check', action='store_true', dest='check_only', default=None,\n        help='')\n    parser.add_argument(\n        '-v', '--verbose', action='count', default=0,\n        help='Increase verbosity. May be specified up to 3 times')\n    # TODO: parser.add_argument('-f', '--foreground', help='')\n    args = parser.parse_args()\n\n    # Load TOML config file\n    if args.config_file is not None:\n        with open(args.config_file, 'rb') as f:\n            tomlconf = tomllib.load(f)\n        settings.update(tomlconf)\n\n    # Load non-None command line arguments\n    if args.verbose == 1:\n        args.log_level = 'info'\n    elif args.verbose == 2:\n        args.log_level = 'debug'\n        settings['ext_log_level'] = 'info'\n    elif args.verbose >= 3:\n        args.log_level = 'debug'\n        settings['ext_log_level'] = 'debug'\n    del args.verbose\n    settings.update({k: v for k, v in args.__dict__.items() if v is not None})\n\n    # Check existence of required settings\n    for attr in ('kea_url', 'netbox_url'):\n        if attr not in settings:\n            logging.fatal(\n                f'Setting \"{attr}\" not found, neither on command line '\n                'arguments nor in configuration file (if any)')\n            sys.exit(1)\n\n    conf = Config(**settings)\n\n    if not set(['hw-address', 'hostname']).issubset(\n            conf.reservation_ipaddr_map):\n        logging.fatal(\n            'Setting \"reservation_ipaddr_map\" must have a mapping for '\n            '\"hw-address\" and \"hostname\" DHCP parameters')\n        sys.exit(1)\n\n    return conf", ""]}
{"filename": "src/netboxkea/logger.py", "chunked_list": ["import logging\nimport syslog\n\n_SD_DAEMON_MAP = {\n    logging.DEBUG: syslog.LOG_DEBUG,\n    logging.INFO: syslog.LOG_INFO,\n    logging.WARNING: syslog.LOG_WARNING,\n    logging.ERROR: syslog.LOG_ERR,\n    logging.CRITICAL: syslog.LOG_CRIT\n    }", "    logging.CRITICAL: syslog.LOG_CRIT\n    }\n\n\ndef init_logger(log_level_name, ext_log_level_name, syslog_level_prefix):\n    \"\"\" Configure loggers \"\"\"\n\n    log_level = _level_name_to_int(log_level_name)\n    if syslog_level_prefix:\n        logger = logging.getLogger()\n        logger.setLevel(log_level)\n        ch = logging.StreamHandler()\n        ch.setFormatter(_SdDaemonFormatter())\n        logger.addHandler(ch)\n    else:\n        logging.basicConfig(\n            level=log_level, format='%(asctime)s [%(levelname)s] %(message)s')\n        logger = logging.getLogger()\n\n    # Log level for external modules\n    ext_log_level = _level_name_to_int(ext_log_level_name)\n    logging.getLogger('urllib3.connectionpool').setLevel(ext_log_level)", "\n\ndef _level_name_to_int(name):\n    num = getattr(logging, name.upper(), None)\n    if not isinstance(num, int):\n        raise ValueError(f'Invalid log level name: {name}')\n    return num\n\n\nclass _SdDaemonFormatter(logging.Formatter):\n    def format(self, record):\n        sd_levelno = _SD_DAEMON_MAP.get(record.levelno, syslog.LOG_INFO)\n        return f'<{sd_levelno}>' + super().format(record)", "\nclass _SdDaemonFormatter(logging.Formatter):\n    def format(self, record):\n        sd_levelno = _SD_DAEMON_MAP.get(record.levelno, syslog.LOG_INFO)\n        return f'<{sd_levelno}>' + super().format(record)\n"]}
{"filename": "src/netboxkea/entry_point.py", "chunked_list": ["import logging\n\nfrom .config import get_config\nfrom .connector import Connector\nfrom .kea.app import DHCP4App\nfrom .listener import WebhookListener\nfrom .logger import init_logger\nfrom .netbox import NetboxApp\n\n\ndef run():\n    conf = get_config()\n    init_logger(conf.log_level, conf.ext_log_level, conf.syslog_level_prefix)\n\n    # Instanciate source, sink and connector\n    logging.info(f'netbox: {conf.netbox_url}, kea: {conf.kea_url}')\n    nb = NetboxApp(\n        conf.netbox_url, conf.netbox_token, prefix_filter=conf.prefix_filter,\n        iprange_filter=conf.iprange_filter,\n        ipaddress_filter=conf.ipaddress_filter)\n    kea = DHCP4App(conf.kea_url)\n    conn = Connector(\n        nb, kea, conf.subnet_prefix_map, conf.pool_iprange_map,\n        conf.reservation_ipaddr_map, check=conf.check_only)\n\n    if not conf.full_sync_at_startup and not conf.listen:\n        logging.warning('Neither full sync nor listen mode has been asked')\n\n    # Start a full synchronisation\n    if conf.full_sync_at_startup:\n        logging.info('Start full sync')\n        conn.sync_all()\n\n    # Start listening for events\n    if conf.listen:\n        logging.info(f'Listen for events on {conf.bind}:{conf.port}')\n        server = WebhookListener(\n            connector=conn, host=conf.bind, port=conf.port, secret=conf.secret,\n            secret_header=conf.secret_header)\n        server.run()", "\n\ndef run():\n    conf = get_config()\n    init_logger(conf.log_level, conf.ext_log_level, conf.syslog_level_prefix)\n\n    # Instanciate source, sink and connector\n    logging.info(f'netbox: {conf.netbox_url}, kea: {conf.kea_url}')\n    nb = NetboxApp(\n        conf.netbox_url, conf.netbox_token, prefix_filter=conf.prefix_filter,\n        iprange_filter=conf.iprange_filter,\n        ipaddress_filter=conf.ipaddress_filter)\n    kea = DHCP4App(conf.kea_url)\n    conn = Connector(\n        nb, kea, conf.subnet_prefix_map, conf.pool_iprange_map,\n        conf.reservation_ipaddr_map, check=conf.check_only)\n\n    if not conf.full_sync_at_startup and not conf.listen:\n        logging.warning('Neither full sync nor listen mode has been asked')\n\n    # Start a full synchronisation\n    if conf.full_sync_at_startup:\n        logging.info('Start full sync')\n        conn.sync_all()\n\n    # Start listening for events\n    if conf.listen:\n        logging.info(f'Listen for events on {conf.bind}:{conf.port}')\n        server = WebhookListener(\n            connector=conn, host=conf.bind, port=conf.port, secret=conf.secret,\n            secret_header=conf.secret_header)\n        server.run()", ""]}
{"filename": "src/netboxkea/netbox.py", "chunked_list": ["import pynetbox\nfrom ipaddress import ip_interface, ip_network\n\n\nclass NetboxApp:\n\n    def __init__(self, url, token, prefix_filter={}, iprange_filter={},\n                 ipaddress_filter={'status': 'dhcp'}):\n        self.nb = pynetbox.api(url, token=token)\n        self.prefix_filter = prefix_filter\n        self.iprange_filter = iprange_filter\n        self.ipaddress_filter = ipaddress_filter\n\n    def prefix(self, id_):\n        return self.nb.ipam.prefixes.get(id=id_, **self.prefix_filter)\n\n    def prefixes(self, contains):\n        return self.nb.ipam.prefixes.filter(\n            **self.prefix_filter, contains=contains)\n\n    def all_prefixes(self):\n        return self.nb.ipam.prefixes.filter(**self.prefix_filter)\n\n    def ip_range(self, id_):\n        return self.nb.ipam.ip_ranges.get(id=id_, **self.iprange_filter)\n\n    def ip_ranges(self, parent):\n        # Emulate \"parent\" filter as NetBox API doesn\u2019t support it on\n        # ip-ranges objects (v3.4).\n        parent_net = ip_network(parent)\n        for r in self.nb.ipam.ip_ranges.filter(\n                parent=parent, **self.iprange_filter):\n            if (ip_interface(r.start_address) in parent_net\n                    and ip_interface(r.end_address) in parent_net):\n                yield r\n\n    def ip_address(self, id_):\n        return self.nb.ipam.ip_addresses.get(id=id_, **self.ipaddress_filter)\n\n    def ip_addresses(self, **filters):\n        if not filters:\n            raise ValueError(\n                'Netboxapp.ip_addresses() requires at least one keyword arg')\n        for i in self.nb.ipam.ip_addresses.filter(\n                **self.ipaddress_filter, **filters):\n            yield i", ""]}
{"filename": "src/netboxkea/listener.py", "chunked_list": ["import logging\nfrom json.decoder import JSONDecodeError\n\nimport bottle\n\n\nclass WebhookListener:\n    \"\"\" Listen for netbox webhook requests and change DHCP configuration \"\"\"\n\n    def __init__(self, connector, host='127.0.0.1', port=8001, secret=None,\n                 secret_header=None):\n        self.conn = connector\n        self.host = host\n        self.port = port\n        self.secret = secret\n        self.secret_header = secret_header\n\n    def run(self):\n        \"\"\" Start web server \"\"\"\n\n        @bottle.route('/event/<name>/', 'POST')\n        def new_event(name):\n            \"\"\" Define an all-in-one route for our web server \"\"\"\n\n            logging.debug(f'Receive data on /event/{name}/')\n\n            # import json\n            # body = bottle.request.body.getvalue()\n            # try:\n            #     print(json.dumps(json.loads(body), indent=4))\n            # except Exception:\n            #     print(body.decode())\n\n            if (self.secret_header and bottle.request.get_header(\n                    self.secret_header) != self.secret):\n                self._abort(403, 'wrong secret or secret header')\n\n            # Parse JSON body from request\n            try:\n                body = bottle.request.json\n            except JSONDecodeError:\n                body = bottle.request.body.getvalue().decode()\n                self._abort(400, f'malformed body (not JSON):  {body}')\n\n            logging.debug(f'Parsed JSON request: {body}')\n            try:\n                model, id_, event = (\n                    body['model'], body['data']['id'], body['event'])\n            except KeyError as e:\n                self._abort(400, f'request missing key: {e}')\n\n            try:\n                sync_func = getattr(self.conn, f'sync_{model}')\n            except AttributeError:\n                self._abort(400, f'unsupported target \"{model}\"')\n            else:\n                logging.info(f'process event: {model} id={id_} {event}')\n                # Reload DHCP config before applying any changes\n                self.conn.reload_dhcp_config()\n                sync_func(id_)\n\n            bottle.response.status = 201\n\n            # Push change to DHCP server\n            self.conn.push_to_dhcp()\n        \n        # very basic health check, basically proves bottle is already/still running\n        # enough for Kubernetes probes\n        @bottle.route('/health/')\n        def health():\n            return 'ok'\n\n        # start server\n        bottle.run(host=self.host, port=self.port)\n\n    def _abort(self, code, msg):\n        logging.error(msg)\n        bottle.abort(code, msg)", ""]}
{"filename": "src/netboxkea/__init__.py", "chunked_list": [""]}
{"filename": "src/netboxkea/connector.py", "chunked_list": ["import logging\n\nfrom ipaddress import ip_interface\n\nfrom .kea.exceptions import (KeaError, KeaClientError, SubnetNotEqual,\n                             SubnetNotFound)\n\n\ndef _get_nested(obj, attrs, sep='.'):\n    \"\"\" Get value from a nested list of attributes or keys separated by sep \"\"\"\n\n    value = obj\n    for a in attrs.split(sep):\n        # getattr must be tried before dict.get because it is able to trigger\n        # additionnal queries to netbox API.\n        try:\n            value = getattr(value, a)\n        except AttributeError:\n            value = value[a]\n\n    return value", "def _get_nested(obj, attrs, sep='.'):\n    \"\"\" Get value from a nested list of attributes or keys separated by sep \"\"\"\n\n    value = obj\n    for a in attrs.split(sep):\n        # getattr must be tried before dict.get because it is able to trigger\n        # additionnal queries to netbox API.\n        try:\n            value = getattr(value, a)\n        except AttributeError:\n            value = value[a]\n\n    return value", "\n\ndef _set_dhcp_attr(dhcp_item, key, value):\n    \"\"\"\n    Set value to DHCP item dictionary. Key may be nested keys separated\n    by dots, in which case each key represents a nested dictionary (or list, if\n    the parent attribut is known to use a list).\n    \"\"\"\n\n    k1, _, k2 = key.partition('.')\n    if not k2:\n        dhcp_item[key] = value\n    elif k1 in ['option-data']:\n        # Some keys hold a list of name/data dicts\n        dhcp_item.setdefault(k1, []).append(\n            {'name': k2, 'data': value})\n    else:\n        dhcp_item.setdefault(k1, {})[k2] = value", "\n\ndef _mk_dhcp_item(nb_obj, mapping):\n    \"\"\" Convert a netbox object to a DHCP dictionary item \"\"\"\n\n    dhcp_item = {}\n    for dhcp_attr, nb_attr in mapping.items():\n        # Get value from netbox object\n        attrs = [nb_attr] if isinstance(nb_attr, str) else nb_attr\n        # Map value is expected to be list of attributes. The first\n        # existing and non-null attribute will be used as the DHCP value\n        value = None\n        for a in attrs:\n            try:\n                value = _get_nested(nb_obj, a)\n            except (TypeError, KeyError):\n                continue\n            if value:\n                break\n\n        # Set value to DHCP setting\n        # Kea don\u2019t like None value (TODO even if JSON converts it to \"null\"?)\n        if value is not None:\n            _set_dhcp_attr(dhcp_item, dhcp_attr, value)\n\n    return dhcp_item", "\n\nclass Connector:\n    \"\"\" Main class that connects Netbox objects to Kea DHCP config items \"\"\"\n\n    def __init__(self, nb, kea, prefix_subnet_map, pool_iprange_map,\n                 reservation_ipaddr_map, check=False):\n        self.nb = nb\n        self.kea = kea\n        self.subnet_prefix_map = prefix_subnet_map\n        self.pool_iprange_map = pool_iprange_map\n        self.reservation_ipaddr_map = reservation_ipaddr_map\n        self.check = check\n\n    def sync_all(self):\n        \"\"\" Replace current DHCP configuration by a new generated one \"\"\"\n\n        self.kea.pull()\n        self.kea.del_all_subnets()\n\n        # Create DHCP configuration for each prefix\n        all_failed = None\n        for p in self.nb.all_prefixes():\n            if all_failed is None:\n                all_failed = True\n            pl = f'prefix {p}: '\n            logging.debug(f'{pl}generate DHCP config')\n            # Speed up things by disabling auto-commit\n            self.kea.auto_commit = False\n            try:\n                self._prefix_to_subnet(p, fullsync=True)\n            except KeaError as e:\n                logging.error(f'{pl}config failed. Error: {e}')\n                continue\n\n            # Make intermediate commits only when not in check mode to avoid\n            # false errors of missing, not yet created, subnets.\n            if not self.check:\n                try:\n                    self.kea.commit()\n                except KeaError as e:\n                    logging.error(f'{pl}commit failed. Error: {e}')\n                    # Retry with auto-commit enabled to catch the faulty item\n                    logging.warning(f'{pl}retry with auto commit on')\n                    self.kea.auto_commit = True\n                    try:\n                        self._prefix_to_subnet(p, fullsync=True)\n                    except KeaError as e:\n                        logging.error(f'{pl}config failed. Error: {e}')\n                        continue\n\n            all_failed = False\n\n        self.kea.auto_commit = True\n        if all_failed is not True:\n            self.push_to_dhcp()\n\n    def push_to_dhcp(self):\n        if self.check:\n            logging.info('check mode on: config will NOT be pushed to server')\n        else:\n            self.kea.push()\n\n    def reload_dhcp_config(self):\n        self.kea.pull()\n\n    def sync_prefix(self, id_):\n        p = self.nb.prefix(id_)\n        self._prefix_to_subnet(p) if p else self.kea.del_subnet(id_)\n\n    def sync_iprange(self, id_):\n        r = self.nb.ip_range(id_)\n        self._iprange_to_pool(r) if r else self.kea.del_pool(id_)\n\n    def sync_ipaddress(self, id_):\n        i = self.nb.ip_address(id_)\n        self._ipaddr_to_resa(i) if i else self.kea.del_resa(id_)\n\n    def sync_interface(self, id_):\n        for i in self.nb.ip_addresses(interface_id=id_):\n            self.sync_ipaddress(i.id)\n\n    def sync_device(self, id_):\n        for i in self.nb.ip_addresses(device_id=id_):\n            self.sync_ipaddress(i.id)\n\n    def sync_vminterface(self, id_):\n        for i in self.nb.ip_addresses(vminterface_id=id_):\n            self.sync_ipaddress(i.id)\n\n    def sync_virtualmachine(self, id_):\n        for i in self.nb.ip_addresses(virtual_machine_id=id_):\n            self.sync_ipaddress(i.id)\n\n    def _prefix_to_subnet(self, pref, fullsync=False):\n        subnet = _mk_dhcp_item(pref, self.subnet_prefix_map)\n        subnet['subnet'] = pref.prefix\n        if not fullsync:\n            try:\n                self.kea.update_subnet(pref.id, subnet)\n            except (SubnetNotEqual, SubnetNotFound):\n                # Subnet address has changed or subnet is missing, recreate it\n                fullsync = True\n\n        if fullsync:\n            self.kea.set_subnet(pref.id, subnet)\n            # Add host reservations\n            for i in self.nb.ip_addresses(parent=pref.prefix):\n                try:\n                    self._ipaddr_to_resa(i, prefix=pref)\n                except KeaClientError as e:\n                    logging.error(f'prefix {pref} > IP {i}: {e}')\n            # Add pools\n            for r in self.nb.ip_ranges(parent=pref.prefix):\n                try:\n                    self._iprange_to_pool(r, prefix=pref)\n                except KeaClientError as e:\n                    logging.error(f'prefix {pref} > range {r}: {e}')\n\n    def _iprange_to_pool(self, iprange, prefix=None):\n        prefixes = [prefix] if prefix else self.nb.prefixes(\n            contains=iprange.start_address)\n        pool = _mk_dhcp_item(iprange, self.pool_iprange_map)\n        start = str(ip_interface(iprange.start_address).ip)\n        end = str(ip_interface(iprange.end_address).ip)\n        pool['pool'] = f'{start}-{end}'\n        for pref in prefixes:\n            try:\n                self.kea.set_pool(pref.id, iprange.id, pool)\n            except SubnetNotFound:\n                if not prefix:\n                    logging.warning(\n                        f'subnet {pref.prefix} is missing, sync it again')\n                    self._prefix_to_subnet(pref, fullsync=True)\n                else:\n                    logging.error(f'requested subnet {pref.prefix} not found')\n\n    def _ipaddr_to_resa(self, ip, prefix=None):\n        prefixes = [prefix] if prefix else self.nb.prefixes(\n            contains=ip.address)\n        resa = _mk_dhcp_item(ip, self.reservation_ipaddr_map)\n        if not resa.get('hw-address'):\n            self.kea.del_resa(ip.id)\n            return\n\n        resa['ip-address'] = str(ip_interface(ip.address).ip)\n        for pref in prefixes:\n            try:\n                self.kea.set_reservation(pref.id, ip.id, resa)\n            except SubnetNotFound:\n                if not prefix:\n                    logging.warning(\n                        f'subnet {pref.prefix} is missing, sync it again')\n                    self._prefix_to_subnet(pref)\n                else:\n                    logging.error(f'requested subnet {pref.prefix} not found')", ""]}
{"filename": "src/netboxkea/__about__.py", "chunked_list": ["__version__ = \"0.0.1a10\"\n"]}
{"filename": "src/netboxkea/kea/app.py", "chunked_list": ["import logging\nfrom copy import deepcopy\nfrom ipaddress import ip_interface, ip_network\n\nfrom .api import DHCP4API, FileAPI\nfrom .exceptions import (DuplicateValue, KeaCmdError, SubnetNotEqual,\n                         SubnetNotFound)\n\n# Kea configuration keys\nSUBNETS = 'subnet4'", "# Kea configuration keys\nSUBNETS = 'subnet4'\nUSR_CTX = 'user-context'\nPOOLS = 'pools'\nRESAS = 'reservations'\nPREFIX = 'id'\nIP_RANGE = 'netbox_ip_range_id'\nIP_ADDR = 'netbox_ip_address_id'\n\n\ndef _autocommit(func):\n    \"\"\" Decorator to autocommit changes after method execution \"\"\"\n\n    def wrapper(self, *args, **kwargs):\n        res = func(self, *args, **kwargs)\n        commit_arg = kwargs.get('commit')\n        if commit_arg is True or (commit_arg is None and self.auto_commit):\n            self.commit()\n        return res\n    return wrapper", "\n\ndef _autocommit(func):\n    \"\"\" Decorator to autocommit changes after method execution \"\"\"\n\n    def wrapper(self, *args, **kwargs):\n        res = func(self, *args, **kwargs)\n        commit_arg = kwargs.get('commit')\n        if commit_arg is True or (commit_arg is None and self.auto_commit):\n            self.commit()\n        return res\n    return wrapper", "\n\ndef _boundaries(ip_range):\n    \"\"\" Return a tuple of first and last ip_interface of the pool \"\"\"\n\n    # pool may be expressed by a \"-\" seperated range or by a network\n    try:\n        start, end = ip_range.split('-')\n    except ValueError:\n        net = ip_network(ip_range)\n        return ip_interface(net.network_address), ip_interface(\n            net.broadcast_address)\n    else:\n        return ip_interface(start), ip_interface(end)", "\n\nclass DHCP4App:\n\n    def __init__(self, url=None):\n        if url.startswith('http://') or url.startswith('https://'):\n            self.api = DHCP4API(url)\n        elif url.startswith('file://'):\n            self.api = FileAPI(url.removeprefix('file://'))\n        else:\n            raise ValueError(\n                'Kea URL must starts either with \"http(s)://\" or \"file://\"')\n        self.conf = None\n        self.commit_conf = None\n        self._has_commit = False\n        self.auto_commit = True\n\n    def pull(self):\n        \"\"\" Fetch configuration from DHCP server  \"\"\"\n\n        logging.info('pull running config from DHCP server')\n        self.conf = self.api.get_conf()\n        # Set minimal expected keys\n        self.conf.setdefault(SUBNETS, [])\n        for s in self.conf[SUBNETS]:\n            for r in s.setdefault(RESAS, []):\n                r.setdefault(USR_CTX, {}).setdefault(IP_ADDR, None)\n            for p in s.setdefault(POOLS, []):\n                p.setdefault(USR_CTX, {}).setdefault(IP_RANGE, None)\n\n        self.commit_conf = deepcopy(self.conf)\n        self.ip_uniqueness = self.conf.get('ip-reservations-unique', True)\n\n    def commit(self):\n        \"\"\" Record changes to the configuration. Return True if success \"\"\"\n\n        try:\n            logging.debug('check configuration')\n            self.api.raise_conf_error(self.conf)\n        except KeaCmdError:\n            # Drop current working config\n            logging.error('config check failed, drop uncommited changes')\n            self.conf = deepcopy(self.commit_conf)\n            raise\n        else:\n            logging.debug('commit configuration')\n            self.commit_conf = deepcopy(self.conf)\n            self._has_commit = True\n            return True\n\n    def push(self):\n        \"\"\" Update DHCP server configuration \"\"\"\n\n        if self._has_commit:\n            logging.info('push configuration to runtime DHCP server')\n            try:\n                self.api.set_conf(self.commit_conf)\n                logging.info('write configuration to permanent file')\n                self.api.write_conf()\n            except KeaCmdError as e:\n                logging.error(f'config push or write rejected: {e}')\n\n            self._has_commit = None\n        else:\n            logging.debug('no commit to push')\n\n    def _check_commit(self, commit=None):\n        \"\"\" Commit conf if required by argument or instance attribute \"\"\"\n\n        if commit is True or (commit is None and self.auto_commit):\n            self.commit()\n\n    @_autocommit\n    def set_subnet(self, prefix_id, subnet_item):\n        \"\"\" Replace subnet with prefix ID or append a new one \"\"\"\n\n        self._set_subnet(prefix_id, subnet_item, only_update_options=False)\n\n    @_autocommit\n    def update_subnet(self, prefix_id, subnet_item):\n        \"\"\"\n        Update subnet options (preserve current reservations and pools). Raise\n        SubnetNotEqual if network address differs, or SubnetNotFound if no\n        subnet prefix ID matches.\n        \"\"\"\n\n        self._set_subnet(prefix_id, subnet_item, only_update_options=True)\n\n    def _set_subnet(self, prefix_id, subnet_item, only_update_options):\n        \"\"\" Update subnet options, replace subnet or append a new one \"\"\"\n\n        try:\n            subnet = subnet_item['subnet']\n        except KeyError as e:\n            raise TypeError(f'Missing mandatory subnet key: {e}')\n\n        sfound = None\n        for s in self.conf[SUBNETS]:\n            if s[PREFIX] == prefix_id:\n                sfound = s\n                if s['subnet'] == subnet:\n                    # No network addr change, no need to inspect other subnets\n                    break\n                elif only_update_options:\n                    raise SubnetNotEqual(f'subnet {s[\"subnet\"]} \u2260 {subnet}')\n\n            # Continue in order to check duplicates\n            elif s['subnet'] == subnet:\n                raise DuplicateValue(f'duplicate subnet {subnet}')\n\n        subnet_item[PREFIX] = prefix_id\n        if sfound:\n            if only_update_options:\n                logging.info(f'subnet {subnet}: update with {subnet_item}')\n                # Preserve reservations and pools\n                subnet_item[RESAS] = sfound[RESAS]\n                subnet_item[POOLS] = sfound[POOLS]\n            else:\n                subnet_item.setdefault(RESAS, [])\n                subnet_item.setdefault(POOLS, [])\n                logging.info(f'subnet ID {prefix_id}: replace with {subnet}')\n            # Clear current subnet (except reservations and pools) in order to\n            # drop Kea default options, as they may conflict with our new\n            # settings (like min/max-valid-lifetime against valid-lifetime).\n            sfound.clear()\n            sfound.update(subnet_item)\n        elif only_update_options:\n            raise SubnetNotFound(f'subnet ID {prefix_id}')\n        else:\n            subnet_item.setdefault(RESAS, [])\n            subnet_item.setdefault(POOLS, [])\n            logging.info(f'subnets: add {subnet}, ID {prefix_id}')\n            self.conf[SUBNETS].append(subnet_item)\n\n    @_autocommit\n    def del_subnet(self, prefix_id, commit=None):\n        logging.info(f'subnets: remove subnet {prefix_id} if it exists')\n        self.conf[SUBNETS] = [\n            s for s in self.conf[SUBNETS] if s[PREFIX] != prefix_id]\n\n    @_autocommit\n    def del_all_subnets(self):\n        logging.info('delete all current subnets')\n        self.conf[SUBNETS].clear()\n\n    @_autocommit\n    def set_pool(self, prefix_id, iprange_id, pool_item):\n        \"\"\" Replace pool or append a new one \"\"\"\n\n        try:\n            start, end = pool_item['pool'].split('-')\n        except KeyError as e:\n            raise TypeError(f'Missing mandatory pool key: {e}')\n\n        pool_item.setdefault(USR_CTX, {})[IP_RANGE] = iprange_id\n        ip_start, ip_end = ip_interface(start), ip_interface(end)\n\n        def raise_conflict(p):\n            pl = p.get('pool')\n            if pl:\n                s, e = _boundaries(pl)\n                if s <= ip_start <= e or s <= ip_end <= e:\n                    raise DuplicateValue(f'overlaps existing pool {pl}')\n\n        self._set_subnet_item(\n            prefix_id, POOLS, IP_RANGE, iprange_id, pool_item, raise_conflict,\n            pool_item['pool'])\n\n    @_autocommit\n    def del_pool(self, iprange_id):\n        self._del_prefix_item(POOLS, IP_RANGE, iprange_id)\n\n    @_autocommit\n    def set_reservation(self, prefix_id, ipaddr_id, resa_item):\n        \"\"\" Replace host reservation or append a new one \"\"\"\n\n        for k in ('ip-address', 'hw-address'):\n            if k not in resa_item:\n                raise TypeError(f'Missing mandatory reservation key: {k}')\n\n        resa_item.setdefault(USR_CTX, {})[IP_ADDR] = ipaddr_id\n\n        def raise_conflict(r):\n            if r.get('hw-address') == resa_item['hw-address']:\n                raise DuplicateValue(\n                    f'duplicate hw-address={r[\"hw-address\"]}')\n            elif (self.ip_uniqueness and r.get('ip-address') ==\n                    resa_item['ip-address']):\n                raise DuplicateValue(f'duplicate address={r[\"ip-address\"]}')\n\n        self._set_subnet_item(\n            prefix_id, RESAS, IP_ADDR, ipaddr_id, resa_item, raise_conflict,\n            resa_item['hw-address'])\n\n    @_autocommit\n    def del_resa(self, ipaddr_id):\n        self._del_prefix_item(RESAS, IP_ADDR, ipaddr_id)\n\n    def _set_subnet_item(self, prefix_id, item_list, item_key, item_id, new,\n                         raise_conflict, display):\n        \"\"\" Replace either a pool or a host reservation \"\"\"\n\n        for s in self.conf[SUBNETS]:\n            found = None\n            if s[PREFIX] == prefix_id:\n                # Prefix found\n                for i in s[item_list]:\n                    if i[USR_CTX][item_key] == item_id:\n                        found = i\n                    # Continue in order to check duplicates\n                    else:\n                        raise_conflict(i)\n\n                if found:\n                    logging.info(\n                        f'subnet {prefix_id} > {item_list} > ID {item_id}: '\n                        f'replace with {display}')\n                    found.clear()\n                    found.update(new)\n                else:\n                    logging.info(\n                        f'subnet {prefix_id} > {item_list}: add {display}, '\n                        f'ID {item_id}')\n                    s[item_list].append(new)\n                break\n        else:\n            raise SubnetNotFound(f'subnet {prefix_id}')\n\n    def _del_prefix_item(self, item_list, item_key, item_id):\n        \"\"\" Delete item from all subnets. Silently ignore non-existent item \"\"\"\n\n        logging.info(f'{item_list}: delete resa {item_id} if it exists')\n        for s in self.conf[SUBNETS]:\n            s[item_list] = [\n                i for i in s[item_list] if i[USR_CTX][item_key] != item_id]", ""]}
{"filename": "src/netboxkea/kea/api.py", "chunked_list": ["import json\nimport logging\nimport requests\n\nfrom .exceptions import KeaServerError, KeaCmdError\n\n\nclass FileAPI:\n    \"\"\" Fake Kea DHCP4 API that keep configuration in memory and file \"\"\"\n\n    def __init__(self, uri):\n        self.config_file = uri\n        if self.config_file:\n            try:\n                with open(self.config_file, 'rb') as f:\n                    self.conf = json.load(f)\n            except FileNotFoundError:\n                self.conf = {}\n        else:\n            self.conf = {}\n\n    def get_conf(self):\n        return self.conf.get('Dhcp4', {})\n\n    def raise_conf_error(self, config):\n        json.dumps(config)\n\n    def set_conf(self, config):\n        self.raise_conf_error(config)\n        self.conf['Dhcp4'] = config\n\n    def write_conf(self):\n        if self.config_file:\n            with open(self.config_file, 'w') as f:\n                json.dump(self.conf, f, indent=4)", "\n\nclass DHCP4API:\n    def __init__(self, url):\n        self.url = url\n        self.session = requests.Session()\n\n    def _request_kea(self, command, arguments={}):\n        \"\"\" Send command to Kea APP \"\"\"\n\n        payload = {'command': command, 'service': ['dhcp4']}\n        if arguments:\n            payload['arguments'] = arguments\n        try:\n            r = self.session.post(self.url, json=payload)\n            r.raise_for_status()\n            rj = r.json()\n        except requests.exceptions.RequestException as e:\n            raise KeaServerError(f'API error: {e}')\n        # One single command should return a list with one single item\n        assert len(rj) == 1\n        rj = rj.pop(0)\n        result, text = rj['result'], rj.get('text')\n        if result != 0:\n            raise KeaCmdError(f'command \"{command}\" returns \"{text}\"')\n        else:\n            logging.debug(f'command \"{command}\" OK (text: {text})')\n            return rj.get('arguments')\n\n    def get_conf(self):\n        \"\"\" Return configuration from Kea \"\"\"\n\n        return self._request_kea('config-get')['Dhcp4']\n\n    def raise_conf_error(self, config):\n        \"\"\" Test configuration and raise errors \"\"\"\n\n        self._request_kea('config-test', {'Dhcp4': config})\n\n    def set_conf(self, config):\n        \"\"\" Set configuration on DHCP server \"\"\"\n\n        self._request_kea('config-set', {'Dhcp4': config})\n\n    def write_conf(self):\n        \"\"\" On DHCP\u202fserver write configuration to persitent storage \"\"\"\n\n        self._request_kea('config-write')", ""]}
{"filename": "src/netboxkea/kea/__init__.py", "chunked_list": [""]}
{"filename": "src/netboxkea/kea/exceptions.py", "chunked_list": ["class KeaError(Exception):\n    pass\n\n\nclass KeaServerError(KeaError):\n    pass\n\n\nclass KeaClientError(KeaError):\n    pass", "class KeaClientError(KeaError):\n    pass\n\n\nclass SubnetNotEqual(KeaError):\n    pass\n\n\nclass SubnetNotFound(KeaClientError):\n    pass", "class SubnetNotFound(KeaClientError):\n    pass\n\n\nclass DuplicateValue(KeaClientError):\n    pass\n\n\nclass KeaCmdError(KeaClientError):\n    pass", "class KeaCmdError(KeaClientError):\n    pass\n"]}
