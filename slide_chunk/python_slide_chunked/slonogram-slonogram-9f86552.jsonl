{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "slonogram/bot.py", "chunked_list": ["import warnings\nfrom adaptix import Retort, name_mapping\n\nfrom typing import Optional, Self\n\nfrom .types.api_session import ApiSession\nfrom .schemas import Message, Update\n\nfrom .consts import DEFAULT_API_URL\nfrom .call_groups import chat, user, updates, queries", "from .consts import DEFAULT_API_URL\nfrom .call_groups import chat, user, updates, queries\n\n\nclass Bot:\n    def __init__(\n        self,\n        token: Optional[str] = None,\n        base_url: Optional[str] = None,\n        session: Optional[ApiSession] = None,\n    ) -> None:\n        u_session: ApiSession\n        retort = Retort(\n            debug_path=True,\n            recipe=[\n                name_mapping(Update, map={\"id\": \"update_id\"}),\n                name_mapping(Message, map={\"id\": \"message_id\"}),\n                name_mapping(trim_trailing_underscore=True),\n            ],\n        )\n\n        if session is None:\n            from .extra.aiohttp_session import Session\n\n            if token is None:\n                raise ValueError(\"No bot token passed\")\n\n            u_session = Session(\n                token=token, base_url=base_url or DEFAULT_API_URL\n            )\n        else:\n            u_session = session\n\n        self.chat = chat.ChatCallGroup(retort, u_session)\n        self.user = user.UserCallGroup(retort, u_session)\n        self.updates = updates.UpdatesCallGroup(retort, u_session)\n        self.queries = queries.QueriesCallGroup(retort, u_session)\n\n        self._session = u_session\n        self._finalized = False\n\n    async def __aenter__(self) -> Self:\n        return self\n\n    async def __aexit__(self, exc_type, exc_value, traceback) -> None:\n        _ = exc_value\n        _ = traceback\n\n        await self.finalize()\n        if exc_type is not None:\n            raise exc_type\n\n    async def finalize(self) -> None:\n        if self._finalized:\n            warnings.warn(\n                \"tried to call `finalize` when `Bot`\"\n                \" instance is already finalized.\"\n            )\n            return\n\n        await self._session.finalize()\n        self._finalized = True\n\n    def __del__(self) -> None:\n        if not self._finalized:\n            warnings.warn(\n                \"`Bot` is not finalized properly, you can do\"\n                \" this either by calling `await bot.finalize()` or wrapping \"\n                \"`Bot` creation in the `async with` context\"\n            )", ""]}
{"filename": "slonogram/consts.py", "chunked_list": ["DEFAULT_API_URL = \"https://api.telegram.org/\"\nCOMMAND_REGEX = r\"\\/([\\w\\d_\\-]+)(@([\\w\\d_]+))?\"\n\n__all__ = [\"COMMAND_REGEX\", \"DEFAULT_API_URL\"]\n"]}
{"filename": "slonogram/schemas.py", "chunked_list": ["from __future__ import annotations\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\n\nclass ChatAction(str, Enum):\n    TYPING = \"typing\"\n    UPLOAD_PHOTO = \"upload_photo\"\n    RECORD_VIDEO = \"record_video\"\n    UPLOAD_VIDEO = \"upload_video\"\n    RECORD_VOICE = \"record_voice\"\n    UPLOAD_VOICE = \"upload_voice\"\n    UPLOAD_DOCUMENT = \"upload_document\"\n    CHOOSE_STICKER = \"choose_sticker\"\n    FIND_LOCATION = \"find_location\"\n    RECORD_VIDEO_NOTE = \"record_video_note\"\n    UPLOAD_VIDEO_NOTE = \"upload_video_note\"", "\n\nclass EntityType(str, Enum):\n    MENTION = \"mention\"\n    HASHTAG = \"hashtag\"\n    CASHTAG = \"cashtag\"\n    BOT_COMMAND = \"bot_command\"\n    URL = \"url\"\n    EMAIL = \"email\"\n    PHONE_NUMBER = \"phone_number\"\n    BOLD = \"bold\"\n    ITALIC = \"italic\"\n    UNDERLINE = \"underline\"\n    STRIKETHROUGH = \"strikethrough\"\n    SPOILER = \"spoiler\"\n    CODE = \"code\"\n    PRE = \"pre\"\n    TEXT_LINK = \"text_link\"\n    TEXT_MENTION = \"text_mention\"\n    CUSTOM_EMOJI = \"custom_emoji\"", "\n\nclass UpdateType(str, Enum):\n    MESSAGE = \"message\"\n    EDITED_MESSAGE = \"edited_message\"\n    CHANNEL_POST = \"channel_post\"\n    EDITED_CHANNEL_POST = \"edited_channel_post\"\n    INLINE_QUERY = \"inline_query\"\n    CHOSEN_INLINE_RESULT = \"chosen_inline_result\"\n    CALLBACK_QUERY = \"callback_query\"\n    SHIPPING_QUERY = \"shipping_query\"\n    PRE_CHECKOUT_QUERY = \"pre_checkout_query\"\n    POLL = \"poll\"\n    POLL_ANSWER = \"poll_answer\"\n    MY_CHAT_MEMBER = \"my_chat_member\"\n    CHAT_MEMBER = \"chat_member\"\n    CHAT_JOIN_REQUEST = \"chat_join_request\"", "\n\nclass ParseMode(str, Enum):\n    MARKDOWN_V2 = \"MarkdownV2\"\n    HTML = \"HTML\"\n    MARKDOWN = \"Markdown\"\n\n\n@dataclass(slots=True)\nclass Update:\n    id: int\n    message: Optional[Message] = None\n    edited_message: Optional[Message] = None\n    channel_post: Optional[Message] = None\n    edited_channel_post: Optional[Message] = None\n    inline_query: Optional[InlineQuery] = None\n    chosen_inline_result: Optional[ChosenInlineResult] = None\n    callback_query: Optional[CallbackQuery] = None\n    shipping_query: Optional[ShippingQuery] = None\n    pre_checkout_query: Optional[PreCheckoutQuery] = None\n    poll: Optional[Poll] = None\n    poll_answer: Optional[PollAnswer] = None\n    my_chat_member: Optional[ChatMemberUpdated] = None\n    chat_member: Optional[ChatMemberUpdated] = None\n    chat_join_request: Optional[ChatJoinRequest] = None", "@dataclass(slots=True)\nclass Update:\n    id: int\n    message: Optional[Message] = None\n    edited_message: Optional[Message] = None\n    channel_post: Optional[Message] = None\n    edited_channel_post: Optional[Message] = None\n    inline_query: Optional[InlineQuery] = None\n    chosen_inline_result: Optional[ChosenInlineResult] = None\n    callback_query: Optional[CallbackQuery] = None\n    shipping_query: Optional[ShippingQuery] = None\n    pre_checkout_query: Optional[PreCheckoutQuery] = None\n    poll: Optional[Poll] = None\n    poll_answer: Optional[PollAnswer] = None\n    my_chat_member: Optional[ChatMemberUpdated] = None\n    chat_member: Optional[ChatMemberUpdated] = None\n    chat_join_request: Optional[ChatJoinRequest] = None", "\n\n@dataclass(slots=True)\nclass WebhookInfo:\n    url: str\n    has_custom_certificate: bool\n    pending_update_count: int\n    ip_address: Optional[str] = None\n    last_error_date: Optional[int] = None\n    last_error_message: Optional[str] = None\n    last_synchronization_error_date: Optional[int] = None\n    max_connections: Optional[int] = None\n    allowed_updates: Optional[List[str]] = None", "\n\n@dataclass(slots=True)\nclass User:\n    id: int\n    is_bot: bool\n    first_name: str\n    last_name: Optional[str] = None\n    username: Optional[str] = None\n    language_code: Optional[str] = None\n    is_premium: Optional[bool] = None\n    added_to_attachment_menu: Optional[bool] = None\n    can_join_groups: Optional[bool] = None\n    can_read_all_group_messages: Optional[bool] = None\n    supports_inline_queries: Optional[bool] = None", "\n\n@dataclass(slots=True)\nclass Chat:\n    id: int\n    type: str\n    title: Optional[str] = None\n    username: Optional[str] = None\n    first_name: Optional[str] = None\n    last_name: Optional[str] = None\n    is_forum: Optional[bool] = None\n    photo: Optional[ChatPhoto] = None\n    active_usernames: Optional[List[str]] = None\n    emoji_status_custom_emoji_id: Optional[str] = None\n    bio: Optional[str] = None\n    has_private_forwards: Optional[bool] = None\n    has_restricted_voice_and_video_messages: Optional[bool] = None\n    join_to_send_messages: Optional[bool] = None\n    join_by_request: Optional[bool] = None\n    description: Optional[str] = None\n    invite_link: Optional[str] = None\n    pinned_message: Optional[Message] = None\n    permissions: Optional[ChatPermissions] = None\n    slow_mode_delay: Optional[int] = None\n    message_auto_delete_time: Optional[int] = None\n    has_aggressive_anti_spam_enabled: Optional[bool] = None\n    has_hidden_members: Optional[bool] = None\n    has_protected_content: Optional[bool] = None\n    sticker_set_name: Optional[str] = None\n    can_set_sticker_set: Optional[bool] = None\n    linked_chat_id: Optional[int] = None\n    location: Optional[ChatLocation] = None", "\n\n@dataclass(slots=True)\nclass Message:\n    id: int\n    date: int\n    chat: Chat\n    message_thread_id: Optional[int] = None\n    from_: Optional[User] = None\n    sender_chat: Optional[Chat] = None\n    forward_from: Optional[User] = None\n    forward_from_chat: Optional[Chat] = None\n    forward_from_message_id: Optional[int] = None\n    forward_signature: Optional[str] = None\n    forward_sender_name: Optional[str] = None\n    forward_date: Optional[int] = None\n    is_topic_message: Optional[bool] = None\n    is_automatic_forward: Optional[bool] = None\n    reply_to_message: Optional[Message] = None\n    via_bot: Optional[User] = None\n    edit_date: Optional[int] = None\n    has_protected_content: Optional[bool] = None\n    media_group_id: Optional[str] = None\n    author_signature: Optional[str] = None\n    text: Optional[str] = None\n    entities: Optional[List[MessageEntity]] = None\n    animation: Optional[Animation] = None\n    audio: Optional[Audio] = None\n    document: Optional[Document] = None\n    photo: Optional[List[PhotoSize]] = None\n    sticker: Optional[Sticker] = None\n    video: Optional[Video] = None\n    video_note: Optional[VideoNote] = None\n    voice: Optional[Voice] = None\n    caption: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    has_media_spoiler: Optional[bool] = None\n    contact: Optional[Contact] = None\n    dice: Optional[Dice] = None\n    game: Optional[Game] = None\n    poll: Optional[Poll] = None\n    venue: Optional[Venue] = None\n    location: Optional[Location] = None\n    new_chat_members: Optional[List[User]] = None\n    left_chat_member: Optional[User] = None\n    new_chat_title: Optional[str] = None\n    new_chat_photo: Optional[List[PhotoSize]] = None\n    delete_chat_photo: Optional[bool] = None\n    group_chat_created: Optional[bool] = None\n    supergroup_chat_created: Optional[bool] = None\n    channel_chat_created: Optional[bool] = None\n    message_auto_delete_timer_changed: Optional[\n        MessageAutoDeleteTimerChanged\n    ] = None\n    migrate_to_chat_id: Optional[int] = None\n    migrate_from_chat_id: Optional[int] = None\n    pinned_message: Optional[Message] = None\n    invoice: Optional[Invoice] = None\n    successful_payment: Optional[SuccessfulPayment] = None\n    user_shared: Optional[UserShared] = None\n    chat_shared: Optional[ChatShared] = None\n    connected_website: Optional[str] = None\n    write_access_allowed: Optional[WriteAccessAllowed] = None\n    passport_data: Optional[PassportData] = None\n    proximity_alert_triggered: Optional[ProximityAlertTriggered] = None\n    forum_topic_created: Optional[ForumTopicCreated] = None\n    forum_topic_edited: Optional[ForumTopicEdited] = None\n    forum_topic_closed: Optional[ForumTopicClosed] = None\n    forum_topic_reopened: Optional[ForumTopicReopened] = None\n    general_forum_topic_hidden: Optional[GeneralForumTopicHidden] = None\n    general_forum_topic_unhidden: Optional[\n        GeneralForumTopicUnhidden\n    ] = None\n    video_chat_scheduled: Optional[VideoChatScheduled] = None\n    video_chat_started: Optional[VideoChatStarted] = None\n    video_chat_ended: Optional[VideoChatEnded] = None\n    video_chat_participants_invited: Optional[\n        VideoChatParticipantsInvited\n    ] = None\n    web_app_data: Optional[WebAppData] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None", "\n\n@dataclass(slots=True)\nclass MessageId:\n    message_id: int\n\n\n@dataclass(slots=True)\nclass MessageEntity:\n    type: EntityType\n    offset: int\n    length: int\n    url: Optional[str] = None\n    user: Optional[User] = None\n    language: Optional[str] = None\n    custom_emoji_id: Optional[str] = None", "class MessageEntity:\n    type: EntityType\n    offset: int\n    length: int\n    url: Optional[str] = None\n    user: Optional[User] = None\n    language: Optional[str] = None\n    custom_emoji_id: Optional[str] = None\n\n", "\n\n@dataclass(slots=True)\nclass PhotoSize:\n    file_id: str\n    file_unique_id: str\n    width: int\n    height: int\n    file_size: Optional[int] = None\n", "\n\n@dataclass(slots=True)\nclass Animation:\n    file_id: str\n    file_unique_id: str\n    width: int\n    height: int\n    duration: int\n    thumbnail: Optional[PhotoSize] = None\n    file_name: Optional[str] = None\n    mime_type: Optional[str] = None\n    file_size: Optional[int] = None", "\n\n@dataclass(slots=True)\nclass Audio:\n    file_id: str\n    file_unique_id: str\n    duration: int\n    performer: Optional[str] = None\n    title: Optional[str] = None\n    file_name: Optional[str] = None\n    mime_type: Optional[str] = None\n    file_size: Optional[int] = None\n    thumbnail: Optional[PhotoSize] = None", "\n\n@dataclass(slots=True)\nclass Document:\n    file_id: str\n    file_unique_id: str\n    thumbnail: Optional[PhotoSize] = None\n    file_name: Optional[str] = None\n    mime_type: Optional[str] = None\n    file_size: Optional[int] = None", "\n\n@dataclass(slots=True)\nclass Video:\n    file_id: str\n    file_unique_id: str\n    width: int\n    height: int\n    duration: int\n    thumbnail: Optional[PhotoSize] = None\n    file_name: Optional[str] = None\n    mime_type: Optional[str] = None\n    file_size: Optional[int] = None", "\n\n@dataclass(slots=True)\nclass VideoNote:\n    file_id: str\n    file_unique_id: str\n    length: int\n    duration: int\n    thumbnail: Optional[PhotoSize] = None\n    file_size: Optional[int] = None", "\n\n@dataclass(slots=True)\nclass Voice:\n    file_id: str\n    file_unique_id: str\n    duration: int\n    mime_type: Optional[str] = None\n    file_size: Optional[int] = None\n", "\n\n@dataclass(slots=True)\nclass Contact:\n    phone_number: str\n    first_name: str\n    last_name: Optional[str] = None\n    user_id: Optional[int] = None\n    vcard: Optional[str] = None\n", "\n\n@dataclass(slots=True)\nclass Dice:\n    emoji: str\n    value: int\n\n\n@dataclass(slots=True)\nclass PollOption:\n    text: str\n    voter_count: int", "@dataclass(slots=True)\nclass PollOption:\n    text: str\n    voter_count: int\n\n\n@dataclass(slots=True)\nclass PollAnswer:\n    poll_id: str\n    user: User\n    option_ids: List[int]", "\n\n@dataclass(slots=True)\nclass Poll:\n    id: str\n    question: str\n    options: List[PollOption]\n    total_voter_count: int\n    is_closed: bool\n    is_anonymous: bool\n    type: str\n    allows_multiple_answers: bool\n    correct_option_id: Optional[int] = None\n    explanation: Optional[str] = None\n    explanation_entities: Optional[List[MessageEntity]] = None\n    open_period: Optional[int] = None\n    close_date: Optional[int] = None", "\n\n@dataclass(slots=True)\nclass Location:\n    longitude: float\n    latitude: float\n    horizontal_accuracy: Optional[float] = None\n    live_period: Optional[int] = None\n    heading: Optional[int] = None\n    proximity_alert_radius: Optional[int] = None", "\n\n@dataclass(slots=True)\nclass Venue:\n    location: Location\n    title: str\n    address: str\n    foursquare_id: Optional[str] = None\n    foursquare_type: Optional[str] = None\n    google_place_id: Optional[str] = None\n    google_place_type: Optional[str] = None", "\n\n@dataclass(slots=True)\nclass WebAppData:\n    data: str\n    button_text: str\n\n\n@dataclass(slots=True)\nclass ProximityAlertTriggered:\n    traveler: User\n    watcher: User\n    distance: int", "@dataclass(slots=True)\nclass ProximityAlertTriggered:\n    traveler: User\n    watcher: User\n    distance: int\n\n\n@dataclass(slots=True)\nclass MessageAutoDeleteTimerChanged:\n    message_auto_delete_time: int", "class MessageAutoDeleteTimerChanged:\n    message_auto_delete_time: int\n\n\n@dataclass(slots=True)\nclass ForumTopicCreated:\n    name: str\n    icon_color: int\n    icon_custom_emoji_id: Optional[str] = None\n", "\n\n@dataclass(slots=True)\nclass ForumTopicClosed:\n    pass\n\n\n@dataclass(slots=True)\nclass ForumTopicEdited:\n    name: Optional[str] = None\n    icon_custom_emoji_id: Optional[str] = None", "class ForumTopicEdited:\n    name: Optional[str] = None\n    icon_custom_emoji_id: Optional[str] = None\n\n\n@dataclass(slots=True)\nclass ForumTopicReopened:\n    pass\n\n", "\n\n@dataclass(slots=True)\nclass GeneralForumTopicHidden:\n    pass\n\n\n@dataclass(slots=True)\nclass GeneralForumTopicUnhidden:\n    pass", "class GeneralForumTopicUnhidden:\n    pass\n\n\n@dataclass(slots=True)\nclass UserShared:\n    request_id: int\n    user_id: int\n\n", "\n\n@dataclass(slots=True)\nclass ChatShared:\n    request_id: int\n    chat_id: int\n\n\n@dataclass(slots=True)\nclass WriteAccessAllowed:\n    web_app_name: Optional[str] = None", "@dataclass(slots=True)\nclass WriteAccessAllowed:\n    web_app_name: Optional[str] = None\n\n\n@dataclass(slots=True)\nclass VideoChatScheduled:\n    start_date: int\n\n", "\n\n@dataclass(slots=True)\nclass VideoChatStarted:\n    pass\n\n\n@dataclass(slots=True)\nclass VideoChatEnded:\n    duration: int", "class VideoChatEnded:\n    duration: int\n\n\n@dataclass(slots=True)\nclass VideoChatParticipantsInvited:\n    users: List[User]\n\n\n@dataclass(slots=True)\nclass UserProfilePhotos:\n    total_count: int\n    photos: List[List[PhotoSize]]", "\n@dataclass(slots=True)\nclass UserProfilePhotos:\n    total_count: int\n    photos: List[List[PhotoSize]]\n\n\n@dataclass(slots=True)\nclass File:\n    file_id: str\n    file_unique_id: str\n    file_size: Optional[int] = None\n    file_path: Optional[str] = None", "class File:\n    file_id: str\n    file_unique_id: str\n    file_size: Optional[int] = None\n    file_path: Optional[str] = None\n\n\n@dataclass(slots=True)\nclass WebAppInfo:\n    url: str", "class WebAppInfo:\n    url: str\n\n\n@dataclass(slots=True)\nclass ReplyKeyboardMarkup:\n    keyboard: List[List[KeyboardButton]]\n    is_persistent: Optional[bool] = None\n    resize_keyboard: Optional[bool] = None\n    one_time_keyboard: Optional[bool] = None\n    input_field_placeholder: Optional[str] = None\n    selective: Optional[bool] = None", "\n\n@dataclass(slots=True)\nclass KeyboardButton:\n    text: str\n    request_user: Optional[KeyboardButtonRequestUser] = None\n    request_chat: Optional[KeyboardButtonRequestChat] = None\n    request_contact: Optional[bool] = None\n    request_location: Optional[bool] = None\n    request_poll: Optional[KeyboardButtonPollType] = None\n    web_app: Optional[WebAppInfo] = None", "\n\n@dataclass(slots=True)\nclass KeyboardButtonRequestUser:\n    request_id: int\n    user_is_bot: Optional[bool] = None\n    user_is_premium: Optional[bool] = None\n\n\n@dataclass(slots=True)\nclass KeyboardButtonRequestChat:\n    request_id: int\n    chat_is_channel: bool\n    chat_is_forum: Optional[bool] = None\n    chat_has_username: Optional[bool] = None\n    chat_is_created: Optional[bool] = None\n    user_administrator_rights: Optional[ChatAdministratorRights] = None\n    bot_administrator_rights: Optional[ChatAdministratorRights] = None\n    bot_is_member: Optional[bool] = None", "\n@dataclass(slots=True)\nclass KeyboardButtonRequestChat:\n    request_id: int\n    chat_is_channel: bool\n    chat_is_forum: Optional[bool] = None\n    chat_has_username: Optional[bool] = None\n    chat_is_created: Optional[bool] = None\n    user_administrator_rights: Optional[ChatAdministratorRights] = None\n    bot_administrator_rights: Optional[ChatAdministratorRights] = None\n    bot_is_member: Optional[bool] = None", "\n\n@dataclass(slots=True)\nclass KeyboardButtonPollType:\n    type: Optional[str] = None\n\n\n@dataclass(slots=True)\nclass ReplyKeyboardRemove:\n    remove_keyboard: bool\n    selective: Optional[bool] = None", "class ReplyKeyboardRemove:\n    remove_keyboard: bool\n    selective: Optional[bool] = None\n\n\n@dataclass(slots=True)\nclass InlineKeyboardMarkup:\n    inline_keyboard: List[List[InlineKeyboardButton]]\n\n", "\n\n@dataclass(slots=True)\nclass InlineKeyboardButton:\n    text: str\n    url: Optional[str] = None\n    callback_data: Optional[str] = None\n    web_app: Optional[WebAppInfo] = None\n    login_url: Optional[LoginUrl] = None\n    switch_inline_query: Optional[str] = None\n    switch_inline_query_current_chat: Optional[str] = None\n    switch_inline_query_chosen_chat: Optional[\n        SwitchInlineQueryChosenChat\n    ] = None\n    callback_game: Optional[CallbackGame] = None\n    pay: Optional[bool] = None", "\n\n@dataclass(slots=True)\nclass LoginUrl:\n    url: str\n    forward_text: Optional[str] = None\n    bot_username: Optional[str] = None\n    request_write_access: Optional[bool] = None\n\n", "\n\n@dataclass(slots=True)\nclass SwitchInlineQueryChosenChat:\n    query: Optional[str] = None\n    allow_user_chats: Optional[bool] = None\n    allow_bot_chats: Optional[bool] = None\n    allow_group_chats: Optional[bool] = None\n    allow_channel_chats: Optional[bool] = None\n", "\n\n@dataclass(slots=True)\nclass CallbackQuery:\n    id: str\n    from_: User\n    chat_instance: str\n    message: Optional[Message] = None\n    inline_message_id: Optional[str] = None\n    data: Optional[str] = None\n    game_short_name: Optional[str] = None", "\n\n@dataclass(slots=True)\nclass ForceReply:\n    force_reply: bool\n    input_field_placeholder: Optional[str] = None\n    selective: Optional[bool] = None\n\n\n@dataclass(slots=True)\nclass ChatPhoto:\n    small_file_id: str\n    small_file_unique_id: str\n    big_file_id: str\n    big_file_unique_id: str", "\n@dataclass(slots=True)\nclass ChatPhoto:\n    small_file_id: str\n    small_file_unique_id: str\n    big_file_id: str\n    big_file_unique_id: str\n\n\n@dataclass(slots=True)\nclass ChatInviteLink:\n    invite_link: str\n    creator: User\n    creates_join_request: bool\n    is_primary: bool\n    is_revoked: bool\n    name: Optional[str] = None\n    expire_date: Optional[int] = None\n    member_limit: Optional[int] = None\n    pending_join_request_count: Optional[int] = None", "\n@dataclass(slots=True)\nclass ChatInviteLink:\n    invite_link: str\n    creator: User\n    creates_join_request: bool\n    is_primary: bool\n    is_revoked: bool\n    name: Optional[str] = None\n    expire_date: Optional[int] = None\n    member_limit: Optional[int] = None\n    pending_join_request_count: Optional[int] = None", "\n\n@dataclass(slots=True)\nclass ChatAdministratorRights:\n    is_anonymous: bool\n    can_manage_chat: bool\n    can_delete_messages: bool\n    can_manage_video_chats: bool\n    can_restrict_members: bool\n    can_promote_members: bool\n    can_change_info: bool\n    can_invite_users: bool\n    can_post_messages: Optional[bool] = None\n    can_edit_messages: Optional[bool] = None\n    can_pin_messages: Optional[bool] = None\n    can_manage_topics: Optional[bool] = None", "\n\n@dataclass(slots=True)\nclass ChatMember:\n    pass\n\n\n@dataclass(slots=True)\nclass ChatMemberOwner:\n    status: str\n    user: User\n    is_anonymous: bool\n    custom_title: Optional[str] = None", "class ChatMemberOwner:\n    status: str\n    user: User\n    is_anonymous: bool\n    custom_title: Optional[str] = None\n\n\n@dataclass(slots=True)\nclass ChatMemberAdministrator:\n    status: str\n    user: User\n    can_be_edited: bool\n    is_anonymous: bool\n    can_manage_chat: bool\n    can_delete_messages: bool\n    can_manage_video_chats: bool\n    can_restrict_members: bool\n    can_promote_members: bool\n    can_change_info: bool\n    can_invite_users: bool\n    can_post_messages: Optional[bool] = None\n    can_edit_messages: Optional[bool] = None\n    can_pin_messages: Optional[bool] = None\n    can_manage_topics: Optional[bool] = None\n    custom_title: Optional[str] = None", "class ChatMemberAdministrator:\n    status: str\n    user: User\n    can_be_edited: bool\n    is_anonymous: bool\n    can_manage_chat: bool\n    can_delete_messages: bool\n    can_manage_video_chats: bool\n    can_restrict_members: bool\n    can_promote_members: bool\n    can_change_info: bool\n    can_invite_users: bool\n    can_post_messages: Optional[bool] = None\n    can_edit_messages: Optional[bool] = None\n    can_pin_messages: Optional[bool] = None\n    can_manage_topics: Optional[bool] = None\n    custom_title: Optional[str] = None", "\n\n@dataclass(slots=True)\nclass ChatMemberMember:\n    status: str\n    user: User\n\n\n@dataclass(slots=True)\nclass ChatMemberRestricted:\n    status: str\n    user: User\n    is_member: bool\n    can_send_messages: bool\n    can_send_audios: bool\n    can_send_documents: bool\n    can_send_photos: bool\n    can_send_videos: bool\n    can_send_video_notes: bool\n    can_send_voice_notes: bool\n    can_send_polls: bool\n    can_send_other_messages: bool\n    can_add_web_page_previews: bool\n    can_change_info: bool\n    can_invite_users: bool\n    can_pin_messages: bool\n    can_manage_topics: bool\n    until_date: int", "@dataclass(slots=True)\nclass ChatMemberRestricted:\n    status: str\n    user: User\n    is_member: bool\n    can_send_messages: bool\n    can_send_audios: bool\n    can_send_documents: bool\n    can_send_photos: bool\n    can_send_videos: bool\n    can_send_video_notes: bool\n    can_send_voice_notes: bool\n    can_send_polls: bool\n    can_send_other_messages: bool\n    can_add_web_page_previews: bool\n    can_change_info: bool\n    can_invite_users: bool\n    can_pin_messages: bool\n    can_manage_topics: bool\n    until_date: int", "\n\n@dataclass(slots=True)\nclass ChatMemberLeft:\n    status: str\n    user: User\n\n\n@dataclass(slots=True)\nclass ChatMemberBanned:\n    status: str\n    user: User\n    until_date: int", "@dataclass(slots=True)\nclass ChatMemberBanned:\n    status: str\n    user: User\n    until_date: int\n\n\n@dataclass(slots=True)\nclass ChatMemberUpdated:\n    chat: Chat\n    from_: User\n    date: int\n    old_chat_member: ChatMember\n    new_chat_member: ChatMember\n    invite_link: Optional[ChatInviteLink] = None\n    via_chat_folder_invite_link: Optional[bool] = None", "class ChatMemberUpdated:\n    chat: Chat\n    from_: User\n    date: int\n    old_chat_member: ChatMember\n    new_chat_member: ChatMember\n    invite_link: Optional[ChatInviteLink] = None\n    via_chat_folder_invite_link: Optional[bool] = None\n\n", "\n\n@dataclass(slots=True)\nclass ChatJoinRequest:\n    chat: Chat\n    from_: User\n    user_chat_id: int\n    date: int\n    bio: Optional[str] = None\n    invite_link: Optional[ChatInviteLink] = None", "\n\n@dataclass(slots=True)\nclass ChatPermissions:\n    can_send_messages: Optional[bool] = None\n    can_send_audios: Optional[bool] = None\n    can_send_documents: Optional[bool] = None\n    can_send_photos: Optional[bool] = None\n    can_send_videos: Optional[bool] = None\n    can_send_video_notes: Optional[bool] = None\n    can_send_voice_notes: Optional[bool] = None\n    can_send_polls: Optional[bool] = None\n    can_send_other_messages: Optional[bool] = None\n    can_add_web_page_previews: Optional[bool] = None\n    can_change_info: Optional[bool] = None\n    can_invite_users: Optional[bool] = None\n    can_pin_messages: Optional[bool] = None\n    can_manage_topics: Optional[bool] = None", "\n\n@dataclass(slots=True)\nclass ChatLocation:\n    location: Location\n    address: str\n\n\n@dataclass(slots=True)\nclass ForumTopic:\n    message_thread_id: int\n    name: str\n    icon_color: int\n    icon_custom_emoji_id: Optional[str] = None", "@dataclass(slots=True)\nclass ForumTopic:\n    message_thread_id: int\n    name: str\n    icon_color: int\n    icon_custom_emoji_id: Optional[str] = None\n\n\n@dataclass(slots=True)\nclass BotCommand:\n    command: str\n    description: str", "@dataclass(slots=True)\nclass BotCommand:\n    command: str\n    description: str\n\n\n@dataclass(slots=True)\nclass BotCommandScope:\n    pass\n", "\n\n@dataclass(slots=True)\nclass BotCommandScopeDefault:\n    type: str\n\n\n@dataclass(slots=True)\nclass BotCommandScopeAllPrivateChats:\n    type: str", "class BotCommandScopeAllPrivateChats:\n    type: str\n\n\n@dataclass(slots=True)\nclass BotCommandScopeAllGroupChats:\n    type: str\n\n\n@dataclass(slots=True)\nclass BotCommandScopeAllChatAdministrators:\n    type: str", "\n@dataclass(slots=True)\nclass BotCommandScopeAllChatAdministrators:\n    type: str\n\n\n@dataclass(slots=True)\nclass BotCommandScopeChat:\n    type: str\n    chat_id: int | str", "\n\n@dataclass(slots=True)\nclass BotCommandScopeChatAdministrators:\n    type: str\n    chat_id: int | str\n\n\n@dataclass(slots=True)\nclass BotCommandScopeChatMember:\n    type: str\n    chat_id: int | str\n    user_id: int", "@dataclass(slots=True)\nclass BotCommandScopeChatMember:\n    type: str\n    chat_id: int | str\n    user_id: int\n\n\n@dataclass(slots=True)\nclass BotName:\n    name: str", "class BotName:\n    name: str\n\n\n@dataclass(slots=True)\nclass BotDescription:\n    description: str\n\n\n@dataclass(slots=True)\nclass BotShortDescription:\n    short_description: str", "\n@dataclass(slots=True)\nclass BotShortDescription:\n    short_description: str\n\n\n@dataclass(slots=True)\nclass MenuButton:\n    pass\n", "\n\n@dataclass(slots=True)\nclass MenuButtonCommands:\n    type: str\n\n\n@dataclass(slots=True)\nclass MenuButtonWebApp:\n    type: str\n    text: str\n    web_app: WebAppInfo", "class MenuButtonWebApp:\n    type: str\n    text: str\n    web_app: WebAppInfo\n\n\n@dataclass(slots=True)\nclass MenuButtonDefault:\n    type: str\n", "\n\n@dataclass(slots=True)\nclass ResponseParameters:\n    migrate_to_chat_id: Optional[int] = None\n    retry_after: Optional[int] = None\n\n\n@dataclass(slots=True)\nclass InputMedia:\n    pass", "@dataclass(slots=True)\nclass InputMedia:\n    pass\n\n\n@dataclass(slots=True)\nclass InputMediaPhoto:\n    type: str\n    media: str\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    has_spoiler: Optional[bool] = None", "\n\n@dataclass(slots=True)\nclass InputMediaVideo:\n    type: str\n    media: str\n    thumbnail: Optional[InputFile | str] = None\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    width: Optional[int] = None\n    height: Optional[int] = None\n    duration: Optional[int] = None\n    supports_streaming: Optional[bool] = None\n    has_spoiler: Optional[bool] = None", "\n\n@dataclass(slots=True)\nclass InputMediaAnimation:\n    type: str\n    media: str\n    thumbnail: Optional[InputFile | str] = None\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    width: Optional[int] = None\n    height: Optional[int] = None\n    duration: Optional[int] = None\n    has_spoiler: Optional[bool] = None", "\n\n@dataclass(slots=True)\nclass InputMediaAudio:\n    type: str\n    media: str\n    thumbnail: Optional[InputFile | str] = None\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    duration: Optional[int] = None\n    performer: Optional[str] = None\n    title: Optional[str] = None", "\n\n@dataclass(slots=True)\nclass InputMediaDocument:\n    type: str\n    media: str\n    thumbnail: Optional[InputFile | str] = None\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    disable_content_type_detection: Optional[bool] = None", "\n\n@dataclass(slots=True)\nclass InputFile:\n    pass\n\n\n@dataclass(slots=True)\nclass Sticker:\n    file_id: str\n    file_unique_id: str\n    type: str\n    width: int\n    height: int\n    is_animated: bool\n    is_video: bool\n    thumbnail: Optional[PhotoSize] = None\n    emoji: Optional[str] = None\n    set_name: Optional[str] = None\n    premium_animation: Optional[File] = None\n    mask_position: Optional[MaskPosition] = None\n    custom_emoji_id: Optional[str] = None\n    needs_repainting: Optional[bool] = None\n    file_size: Optional[int] = None", "class Sticker:\n    file_id: str\n    file_unique_id: str\n    type: str\n    width: int\n    height: int\n    is_animated: bool\n    is_video: bool\n    thumbnail: Optional[PhotoSize] = None\n    emoji: Optional[str] = None\n    set_name: Optional[str] = None\n    premium_animation: Optional[File] = None\n    mask_position: Optional[MaskPosition] = None\n    custom_emoji_id: Optional[str] = None\n    needs_repainting: Optional[bool] = None\n    file_size: Optional[int] = None", "\n\n@dataclass(slots=True)\nclass StickerSet:\n    name: str\n    title: str\n    sticker_type: str\n    is_animated: bool\n    is_video: bool\n    stickers: List[Sticker]\n    thumbnail: Optional[PhotoSize] = None", "\n\n@dataclass(slots=True)\nclass MaskPosition:\n    point: str\n    x_shift: float\n    y_shift: float\n    scale: float\n\n", "\n\n@dataclass(slots=True)\nclass InputSticker:\n    sticker: InputFile | str\n    emoji_list: List[str]\n    mask_position: Optional[MaskPosition] = None\n    keywords: Optional[List[str]] = None\n\n", "\n\n@dataclass(slots=True)\nclass InlineQuery:\n    id: str\n    from_: User\n    query: str\n    offset: str\n    chat_type: Optional[str] = None\n    location: Optional[Location] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultsButton:\n    text: str\n    web_app: Optional[WebAppInfo] = None\n    start_parameter: Optional[str] = None\n\n\n@dataclass(slots=True)\nclass InlineQueryResult:\n    pass", "\n@dataclass(slots=True)\nclass InlineQueryResult:\n    pass\n\n\n@dataclass(slots=True)\nclass InlineQueryResultArticle:\n    type: str\n    id: str\n    title: str\n    input_message_content: InputMessageContent\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    url: Optional[str] = None\n    hide_url: Optional[bool] = None\n    description: Optional[str] = None\n    thumbnail_url: Optional[str] = None\n    thumbnail_width: Optional[int] = None\n    thumbnail_height: Optional[int] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultPhoto:\n    type: str\n    id: str\n    photo_url: str\n    thumbnail_url: str\n    photo_width: Optional[int] = None\n    photo_height: Optional[int] = None\n    title: Optional[str] = None\n    description: Optional[str] = None\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultGif:\n    type: str\n    id: str\n    gif_url: str\n    thumbnail_url: str\n    gif_width: Optional[int] = None\n    gif_height: Optional[int] = None\n    gif_duration: Optional[int] = None\n    thumbnail_mime_type: Optional[str] = None\n    title: Optional[str] = None\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultMpeg4Gif:\n    type: str\n    id: str\n    mpeg4_url: str\n    thumbnail_url: str\n    mpeg4_width: Optional[int] = None\n    mpeg4_height: Optional[int] = None\n    mpeg4_duration: Optional[int] = None\n    thumbnail_mime_type: Optional[str] = None\n    title: Optional[str] = None\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultVideo:\n    type: str\n    id: str\n    video_url: str\n    mime_type: str\n    thumbnail_url: str\n    title: str\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    video_width: Optional[int] = None\n    video_height: Optional[int] = None\n    video_duration: Optional[int] = None\n    description: Optional[str] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultAudio:\n    type: str\n    id: str\n    audio_url: str\n    title: str\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    performer: Optional[str] = None\n    audio_duration: Optional[int] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultVoice:\n    type: str\n    id: str\n    voice_url: str\n    title: str\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    voice_duration: Optional[int] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultDocument:\n    type: str\n    id: str\n    title: str\n    document_url: str\n    mime_type: str\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    description: Optional[str] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None\n    thumbnail_url: Optional[str] = None\n    thumbnail_width: Optional[int] = None\n    thumbnail_height: Optional[int] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultLocation:\n    type: str\n    id: str\n    latitude: float\n    longitude: float\n    title: str\n    horizontal_accuracy: Optional[float] = None\n    live_period: Optional[int] = None\n    heading: Optional[int] = None\n    proximity_alert_radius: Optional[int] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None\n    thumbnail_url: Optional[str] = None\n    thumbnail_width: Optional[int] = None\n    thumbnail_height: Optional[int] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultVenue:\n    type: str\n    id: str\n    latitude: float\n    longitude: float\n    title: str\n    address: str\n    foursquare_id: Optional[str] = None\n    foursquare_type: Optional[str] = None\n    google_place_id: Optional[str] = None\n    google_place_type: Optional[str] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None\n    thumbnail_url: Optional[str] = None\n    thumbnail_width: Optional[int] = None\n    thumbnail_height: Optional[int] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultContact:\n    type: str\n    id: str\n    phone_number: str\n    first_name: str\n    last_name: Optional[str] = None\n    vcard: Optional[str] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None\n    thumbnail_url: Optional[str] = None\n    thumbnail_width: Optional[int] = None\n    thumbnail_height: Optional[int] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultGame:\n    type: str\n    id: str\n    game_short_name: str\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n\n", "\n\n@dataclass(slots=True)\nclass InlineQueryResultCachedPhoto:\n    type: str\n    id: str\n    photo_file_id: str\n    title: Optional[str] = None\n    description: Optional[str] = None\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultCachedGif:\n    type: str\n    id: str\n    gif_file_id: str\n    title: Optional[str] = None\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultCachedMpeg4Gif:\n    type: str\n    id: str\n    mpeg4_file_id: str\n    title: Optional[str] = None\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultCachedSticker:\n    type: str\n    id: str\n    sticker_file_id: str\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None\n", "\n\n@dataclass(slots=True)\nclass InlineQueryResultCachedDocument:\n    type: str\n    id: str\n    title: str\n    document_file_id: str\n    description: Optional[str] = None\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultCachedVideo:\n    type: str\n    id: str\n    video_file_id: str\n    title: str\n    description: Optional[str] = None\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultCachedVoice:\n    type: str\n    id: str\n    voice_file_id: str\n    title: str\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None", "\n\n@dataclass(slots=True)\nclass InlineQueryResultCachedAudio:\n    type: str\n    id: str\n    audio_file_id: str\n    caption: Optional[str] = None\n    parse_mode: Optional[str] = None\n    caption_entities: Optional[List[MessageEntity]] = None\n    reply_markup: Optional[InlineKeyboardMarkup] = None\n    input_message_content: Optional[InputMessageContent] = None", "\n\n@dataclass(slots=True)\nclass InputMessageContent:\n    pass\n\n\n@dataclass(slots=True)\nclass InputTextMessageContent:\n    message_text: str\n    parse_mode: Optional[str] = None\n    entities: Optional[List[MessageEntity]] = None\n    disable_web_page_preview: Optional[bool] = None", "class InputTextMessageContent:\n    message_text: str\n    parse_mode: Optional[str] = None\n    entities: Optional[List[MessageEntity]] = None\n    disable_web_page_preview: Optional[bool] = None\n\n\n@dataclass(slots=True)\nclass InputLocationMessageContent:\n    latitude: float\n    longitude: float\n    horizontal_accuracy: Optional[float] = None\n    live_period: Optional[int] = None\n    heading: Optional[int] = None\n    proximity_alert_radius: Optional[int] = None", "class InputLocationMessageContent:\n    latitude: float\n    longitude: float\n    horizontal_accuracy: Optional[float] = None\n    live_period: Optional[int] = None\n    heading: Optional[int] = None\n    proximity_alert_radius: Optional[int] = None\n\n\n@dataclass(slots=True)\nclass InputVenueMessageContent:\n    latitude: float\n    longitude: float\n    title: str\n    address: str\n    foursquare_id: Optional[str] = None\n    foursquare_type: Optional[str] = None\n    google_place_id: Optional[str] = None\n    google_place_type: Optional[str] = None", "\n@dataclass(slots=True)\nclass InputVenueMessageContent:\n    latitude: float\n    longitude: float\n    title: str\n    address: str\n    foursquare_id: Optional[str] = None\n    foursquare_type: Optional[str] = None\n    google_place_id: Optional[str] = None\n    google_place_type: Optional[str] = None", "\n\n@dataclass(slots=True)\nclass InputContactMessageContent:\n    phone_number: str\n    first_name: str\n    last_name: Optional[str] = None\n    vcard: Optional[str] = None\n\n", "\n\n@dataclass(slots=True)\nclass InputInvoiceMessageContent:\n    title: str\n    description: str\n    payload: str\n    provider_token: str\n    currency: str\n    prices: List[LabeledPrice]\n    max_tip_amount: Optional[int] = None\n    suggested_tip_amounts: Optional[List[int]] = None\n    provider_data: Optional[str] = None\n    photo_url: Optional[str] = None\n    photo_size: Optional[int] = None\n    photo_width: Optional[int] = None\n    photo_height: Optional[int] = None\n    need_name: Optional[bool] = None\n    need_phone_number: Optional[bool] = None\n    need_email: Optional[bool] = None\n    need_shipping_address: Optional[bool] = None\n    send_phone_number_to_provider: Optional[bool] = None\n    send_email_to_provider: Optional[bool] = None\n    is_flexible: Optional[bool] = None", "\n\n@dataclass(slots=True)\nclass ChosenInlineResult:\n    result_id: str\n    from_: User\n    query: str\n    location: Optional[Location] = None\n    inline_message_id: Optional[str] = None\n", "\n\n@dataclass(slots=True)\nclass SentWebAppMessage:\n    inline_message_id: Optional[str] = None\n\n\n@dataclass(slots=True)\nclass LabeledPrice:\n    label: str\n    amount: int", "class LabeledPrice:\n    label: str\n    amount: int\n\n\n@dataclass(slots=True)\nclass Invoice:\n    title: str\n    description: str\n    start_parameter: str\n    currency: str\n    total_amount: int", "\n\n@dataclass(slots=True)\nclass ShippingAddress:\n    country_code: str\n    state: str\n    city: str\n    street_line1: str\n    street_line2: str\n    post_code: str", "\n\n@dataclass(slots=True)\nclass OrderInfo:\n    name: Optional[str] = None\n    phone_number: Optional[str] = None\n    email: Optional[str] = None\n    shipping_address: Optional[ShippingAddress] = None\n\n", "\n\n@dataclass(slots=True)\nclass ShippingOption:\n    id: str\n    title: str\n    prices: List[LabeledPrice]\n\n\n@dataclass(slots=True)\nclass SuccessfulPayment:\n    currency: str\n    total_amount: int\n    invoice_payload: str\n    telegram_payment_charge_id: str\n    provider_payment_charge_id: str\n    shipping_option_id: Optional[str] = None\n    order_info: Optional[OrderInfo] = None", "\n@dataclass(slots=True)\nclass SuccessfulPayment:\n    currency: str\n    total_amount: int\n    invoice_payload: str\n    telegram_payment_charge_id: str\n    provider_payment_charge_id: str\n    shipping_option_id: Optional[str] = None\n    order_info: Optional[OrderInfo] = None", "\n\n@dataclass(slots=True)\nclass ShippingQuery:\n    id: str\n    from_: User\n    invoice_payload: str\n    shipping_address: ShippingAddress\n\n", "\n\n@dataclass(slots=True)\nclass PreCheckoutQuery:\n    id: str\n    from_: User\n    currency: str\n    total_amount: int\n    invoice_payload: str\n    shipping_option_id: Optional[str] = None\n    order_info: Optional[OrderInfo] = None", "\n\n@dataclass(slots=True)\nclass PassportData:\n    data: List[EncryptedPassportElement]\n    credentials: EncryptedCredentials\n\n\n@dataclass(slots=True)\nclass PassportFile:\n    file_id: str\n    file_unique_id: str\n    file_size: int\n    file_date: int", "@dataclass(slots=True)\nclass PassportFile:\n    file_id: str\n    file_unique_id: str\n    file_size: int\n    file_date: int\n\n\n@dataclass(slots=True)\nclass EncryptedPassportElement:\n    type: str\n    hash: str\n    data: Optional[str] = None\n    phone_number: Optional[str] = None\n    email: Optional[str] = None\n    files: Optional[List[PassportFile]] = None\n    front_side: Optional[PassportFile] = None\n    reverse_side: Optional[PassportFile] = None\n    selfie: Optional[PassportFile] = None\n    translation: Optional[List[PassportFile]] = None", "@dataclass(slots=True)\nclass EncryptedPassportElement:\n    type: str\n    hash: str\n    data: Optional[str] = None\n    phone_number: Optional[str] = None\n    email: Optional[str] = None\n    files: Optional[List[PassportFile]] = None\n    front_side: Optional[PassportFile] = None\n    reverse_side: Optional[PassportFile] = None\n    selfie: Optional[PassportFile] = None\n    translation: Optional[List[PassportFile]] = None", "\n\n@dataclass(slots=True)\nclass EncryptedCredentials:\n    data: str\n    hash: str\n    secret: str\n\n\n@dataclass(slots=True)\nclass PassportElementError:\n    pass", "\n@dataclass(slots=True)\nclass PassportElementError:\n    pass\n\n\n@dataclass(slots=True)\nclass PassportElementErrorDataField:\n    source: str\n    type: str\n    field_name: str\n    data_hash: str\n    message: str", "\n\n@dataclass(slots=True)\nclass PassportElementErrorFrontSide:\n    source: str\n    type: str\n    file_hash: str\n    message: str\n\n", "\n\n@dataclass(slots=True)\nclass PassportElementErrorReverseSide:\n    source: str\n    type: str\n    file_hash: str\n    message: str\n\n", "\n\n@dataclass(slots=True)\nclass PassportElementErrorSelfie:\n    source: str\n    type: str\n    file_hash: str\n    message: str\n\n", "\n\n@dataclass(slots=True)\nclass PassportElementErrorFile:\n    source: str\n    type: str\n    file_hash: str\n    message: str\n\n", "\n\n@dataclass(slots=True)\nclass PassportElementErrorFiles:\n    source: str\n    type: str\n    file_hashes: List[str]\n    message: str\n\n", "\n\n@dataclass(slots=True)\nclass PassportElementErrorTranslationFile:\n    source: str\n    type: str\n    file_hash: str\n    message: str\n\n", "\n\n@dataclass(slots=True)\nclass PassportElementErrorTranslationFiles:\n    source: str\n    type: str\n    file_hashes: List[str]\n    message: str\n\n", "\n\n@dataclass(slots=True)\nclass PassportElementErrorUnspecified:\n    source: str\n    type: str\n    element_hash: str\n    message: str\n\n", "\n\n@dataclass(slots=True)\nclass Game:\n    title: str\n    description: str\n    photo: List[PhotoSize]\n    text: Optional[str] = None\n    text_entities: Optional[List[MessageEntity]] = None\n    animation: Optional[Animation] = None", "\n\n@dataclass(slots=True)\nclass CallbackGame:\n    pass\n\n\n@dataclass(slots=True)\nclass GameHighScore:\n    position: int\n    user: User\n    score: int", "class GameHighScore:\n    position: int\n    user: User\n    score: int\n"]}
{"filename": "slonogram/__init__.py", "chunked_list": ["from .bot import Bot\n\nfrom .dispatching.dispatcher import Dispatcher\nfrom .dispatching.local_set import LocalSet\n\n__all__ = [\"Bot\", \"Dispatcher\", \"LocalSet\"]\n"]}
{"filename": "slonogram/extra/__init__.py", "chunked_list": [""]}
{"filename": "slonogram/extra/aiohttp_session.py", "chunked_list": ["from typing import Any, Dict, AnyStr\n\ntry:\n    from aiohttp import ClientSession\nexcept ImportError as ie:\n    raise ImportError(\n        \"failed to import `aiohttp`, install slonogram[aiohttp] \"\n        \"to use aiohttp client\"\n    ) from ie\n", "\nfrom ..types.api_session import ApiSession, MethodArgs\nfrom ..utils.json import loads\n\n\nclass Session(ApiSession):\n    def __init__(self, token: str, base_url: str) -> None:\n        self._token = token\n        self._session = ClientSession(base_url=base_url)\n\n    async def call_method(\n        self, method: str, args: MethodArgs\n    ) -> Dict[AnyStr, Any]:\n        async with self._session.post(\n            f\"/bot{self._token}/{method}\", data=args\n        ) as response:\n            raw = await response.read()\n            return loads(raw)\n\n    async def finalize(self) -> None:\n        await self._session.close()", "\n\n__all__ = [\"Session\"]\n"]}
{"filename": "slonogram/extra/scratches.py", "chunked_list": ["from typing import Optional\n\nfrom ..types.scratch import attr_scratch, Scratch\nfrom ..schemas import Message\n\n\nText: Scratch[Message, Optional[str]] = attr_scratch(\"text\")\n\n__all__ = [\"Text\"]\n", "__all__ = [\"Text\"]\n"]}
{"filename": "slonogram/extra/di.py", "chunked_list": ["from functools import partial\nfrom inspect import Parameter\nfrom typing import (\n    Any,\n    Dict,\n    Mapping,\n    TypeVar,\n    Generic,\n    Tuple,\n    Callable,", "    Tuple,\n    Callable,\n    TypeAlias,\n    List,\n    get_origin,\n)\n\nfrom slonodi.container import Container\nfrom slonodi.specifiers import DeferredEvaluation\nfrom slonodi.injector import Provider, Injector", "from slonodi.specifiers import DeferredEvaluation\nfrom slonodi.injector import Provider, Injector\n\nfrom ..bot import Bot\n\nfrom ..types.model_types import MODEL_TYPES\nfrom ..types.scratch import Scratch\nfrom ..types.context import Context\n\nT = TypeVar(\"T\")", "\nT = TypeVar(\"T\")\nR = TypeVar(\"R\")\n_EMPTY_DICT: dict = {}\n\n\ndef create_injector() -> Injector:\n    return Injector(\n        SlonodiProvider(),\n        default_specifiers=(DefaultSpecifier(),),\n    )", "\n\nNameItem: TypeAlias = Tuple[str, Callable[[Context[T]], Any]]\n\n\ndef _bot(context: Context[Any]) -> Bot:\n    return context.inter.bot\n\n\ndef _identity(v: T) -> T:\n    return v", "\ndef _identity(v: T) -> T:\n    return v\n\n\ndef _model(context: Context[T]) -> T:\n    return context.model\n\n\nclass DefaultSpecifier:\n    def _deferred(\n        self,\n        names: Tuple[NameItem[Any], ...],\n        context: Context[Any],\n    ) -> Dict[str, Any]:\n        return {name: getter(context) for name, getter in names}\n\n    def write_dependencies(\n        self, params: Mapping[str, Parameter], _: Container\n    ) -> Dict[str, Any] | Tuple[Dict[str, Any], DeferredEvaluation]:\n        names: List[NameItem[Any]] = []\n        for name, param in params.items():\n            annot = param.annotation\n            origin = get_origin(annot)\n\n            if annot is Bot:\n                names.append((name, _bot))\n            elif origin is Context:\n                names.append((name, _identity))\n            elif annot in MODEL_TYPES:\n                names.append((name, _model))\n\n        return (_EMPTY_DICT, partial(self._deferred, tuple(names)))", "\nclass DefaultSpecifier:\n    def _deferred(\n        self,\n        names: Tuple[NameItem[Any], ...],\n        context: Context[Any],\n    ) -> Dict[str, Any]:\n        return {name: getter(context) for name, getter in names}\n\n    def write_dependencies(\n        self, params: Mapping[str, Parameter], _: Container\n    ) -> Dict[str, Any] | Tuple[Dict[str, Any], DeferredEvaluation]:\n        names: List[NameItem[Any]] = []\n        for name, param in params.items():\n            annot = param.annotation\n            origin = get_origin(annot)\n\n            if annot is Bot:\n                names.append((name, _bot))\n            elif origin is Context:\n                names.append((name, _identity))\n            elif annot in MODEL_TYPES:\n                names.append((name, _model))\n\n        return (_EMPTY_DICT, partial(self._deferred, tuple(names)))", "\n\nclass SlonodiProvider(Provider[Context[Any]]):\n    def provide_ctx(self, data: Any) -> Context[Any]:\n        return data\n\n    def provide_container(self, ctx: Context[Any]) -> Container:\n        return ctx.inter.data\n\n\nclass FromScratchSpecifier(Generic[T, R]):\n    __slots__ = (\"scratch\", \"name\")\n\n    def __init__(self, name: str, scratch: Scratch[T, R]) -> None:\n        self.scratch = scratch\n        self.name = name\n\n    def _deferred(self, context: Context[T]) -> Dict[str, Any]:\n        return {self.name: context.pad[self.scratch]}\n\n    def write_dependencies(\n        self, _: Mapping[str, Parameter], __: Container\n    ) -> Dict[str, Any] | Tuple[Dict[str, Any], DeferredEvaluation]:\n        return (_EMPTY_DICT, self._deferred)", "\n\nclass FromScratchSpecifier(Generic[T, R]):\n    __slots__ = (\"scratch\", \"name\")\n\n    def __init__(self, name: str, scratch: Scratch[T, R]) -> None:\n        self.scratch = scratch\n        self.name = name\n\n    def _deferred(self, context: Context[T]) -> Dict[str, Any]:\n        return {self.name: context.pad[self.scratch]}\n\n    def write_dependencies(\n        self, _: Mapping[str, Parameter], __: Container\n    ) -> Dict[str, Any] | Tuple[Dict[str, Any], DeferredEvaluation]:\n        return (_EMPTY_DICT, self._deferred)", "\n\ndef from_scratch(\n    name: str, scratch: Scratch[T, R]\n) -> FromScratchSpecifier[T, R]:\n    return FromScratchSpecifier(name, scratch)\n"]}
{"filename": "slonogram/utils/__init__.py", "chunked_list": [""]}
{"filename": "slonogram/utils/dict.py", "chunked_list": [""]}
{"filename": "slonogram/utils/json.py", "chunked_list": ["from typing import Callable, Any\n\nloads: Callable[[bytes], Any]\n\ntry:\n    import orjson\n\n    loads = orjson.loads\n\n    def dumps(d: Any) -> str:\n        return orjson.dumps(d).decode()\n\nexcept ImportError:\n    from json import loads, dumps  # type: ignore", "\n\n__all__ = [\"loads\", \"dumps\"]\n"]}
{"filename": "slonogram/exceptions/control_flow.py", "chunked_list": ["class _ShowIsABug(Exception):\n    def __init__(self) -> None:\n        super().__init__(\n            \"This exception should never be shown, \"\n            \"this is a bug in `slonogram`\"\n        )\n\n\nclass SkipLocalSet(_ShowIsABug):\n    \"\"\"\n    Skips current `LocalSet`\n    \"\"\"", "class SkipLocalSet(_ShowIsABug):\n    \"\"\"\n    Skips current `LocalSet`\n    \"\"\"\n\n\nclass DontHandle(_ShowIsABug):\n    \"\"\"\n    Skips current update\n    \"\"\"", "\n\n__all__ = [\"SkipLocalSet\"]\n"]}
{"filename": "slonogram/exceptions/__init__.py", "chunked_list": [""]}
{"filename": "slonogram/exceptions/api_error.py", "chunked_list": ["class ApiError(Exception):\n    def __init__(self, code: int, description: str) -> None:\n        self.code = code\n        self.description = description\n\n        super().__init__(f\"{description} (code = {code})\")\n"]}
{"filename": "slonogram/filtering/__init__.py", "chunked_list": [""]}
{"filename": "slonogram/filtering/text/word.py", "chunked_list": ["from typing import Iterable\n\nfrom slonogram.types.filter import ExtendedFilter\nfrom slonogram.types.context import Context\n\nfrom slonogram.extra.scratches import Text\nfrom slonogram.schemas import Message\n\nimport re\n", "import re\n\n\nclass Word(ExtendedFilter[Message]):\n    __slots__ = \"pattern\", \"ignore_case\"\n\n    def __init__(\n        self,\n        variants: Iterable[str],\n        regex: bool = False,\n        ignore_case: bool = True,\n    ) -> None:\n        if isinstance(variants, str):\n            variants = (variants,)\n        if ignore_case:\n            variants = map(str.casefold, variants)\n        if not regex:\n            variants = map(re.escape, variants)\n\n        self.pattern = re.compile(\n            \"(\" + \"|\".join(variants) + \")\",\n            re.IGNORECASE if ignore_case else 0,\n        )\n        self.ignore_case = ignore_case\n\n    def __repr__(self) -> str:\n        i = \"i\" if self.ignore_case else \"\"\n        return f\"Word({i}/{self.pattern.pattern}/)\"\n\n    async def __call__(self, ctx: Context[Message]) -> bool:\n        text = ctx.pad[Text]\n        if not text:\n            return False\n\n        space_pos = text.find(\" \")\n        if space_pos == -1:\n            found_word = text\n        else:\n            found_word = text[:space_pos]\n\n        if match := self.pattern.fullmatch(found_word):\n            ctx.pad[Text] = text[match.end() :].lstrip()  # type: ignore\n            return True\n        return False", ""]}
{"filename": "slonogram/filtering/text/__init__.py", "chunked_list": ["from .prefix import Prefix\nfrom .word import Word\nfrom .command import Command\n\n__all__ = [\"Prefix\", \"Word\", \"Command\"]\n"]}
{"filename": "slonogram/filtering/text/prefix.py", "chunked_list": ["from slonogram.types.filter import ExtendedFilter\nfrom slonogram.types.context import Context\nfrom slonogram.schemas import Message\n\nfrom slonogram.extra.scratches import Text\n\nimport re\n\n\nclass Prefix(ExtendedFilter[Message]):\n    __slots__ = \"ignore_case\", \"pattern\"\n\n    def __init__(self, pattern: str, ignore_case: bool = True) -> None:\n        self.pattern = re.compile(\n            pattern, re.IGNORECASE if ignore_case else 0\n        )\n        self.ignore_case = ignore_case\n\n    async def __call__(self, ctx: Context[Message]) -> bool:\n        text = ctx.pad[Text]\n        if text is None:\n            return False\n\n        match = self.pattern.match(text)\n        if match is None:\n            return False\n\n        end = match.end(0)\n        ctx.pad[Text] = text[end:]  # type: ignore\n\n        return True", "\nclass Prefix(ExtendedFilter[Message]):\n    __slots__ = \"ignore_case\", \"pattern\"\n\n    def __init__(self, pattern: str, ignore_case: bool = True) -> None:\n        self.pattern = re.compile(\n            pattern, re.IGNORECASE if ignore_case else 0\n        )\n        self.ignore_case = ignore_case\n\n    async def __call__(self, ctx: Context[Message]) -> bool:\n        text = ctx.pad[Text]\n        if text is None:\n            return False\n\n        match = self.pattern.match(text)\n        if match is None:\n            return False\n\n        end = match.end(0)\n        ctx.pad[Text] = text[end:]  # type: ignore\n\n        return True", ""]}
{"filename": "slonogram/filtering/text/command.py", "chunked_list": ["import re\n\nfrom typing import Iterable, Callable, TypeAlias, Optional\n\nfrom slonogram.types.filter import ExtendedFilter\nfrom slonogram.types.context import Context\n\nfrom slonogram.extra.scratches import Text\nfrom slonogram.schemas import Message, User\n", "from slonogram.schemas import Message, User\n\nUsernamePredicate: TypeAlias = Callable[[User, str], bool]\n\n\ndef same_username(user: User, given: str) -> bool:\n    return user.username == given\n\n\nclass Command(ExtendedFilter[Message]):\n    __slots__ = \"variants\", \"ignore_case\", \"pattern\", \"username_predicate\"\n\n    def __init__(\n        self,\n        variants: Iterable[str],\n        ignore_case: bool = True,\n        username_predicate: Optional[UsernamePredicate] = None,\n    ) -> None:\n        if isinstance(variants, str):\n            variants = (variants,)\n        if ignore_case:\n            variants = map(str.casefold, variants)\n\n        self.variants = tuple(variants)\n        self.ignore_case = ignore_case\n        self.pattern = re.compile(\n            r\"\\/([\\w\\d_\\-]+)(@([\\w\\d_]+))?\",\n            re.IGNORECASE if ignore_case else 0,\n        )\n        self.username_predicate = username_predicate or same_username\n\n    def __repr__(self) -> str:\n        return f\"Command({self.variants!r})\"\n\n    async def __call__(self, ctx: Context[Message]) -> bool:\n        text = ctx.pad[Text]\n        if text is None:\n            return False\n\n        command_match = self.pattern.match(text)\n        if command_match is None:\n            return False\n\n        command = command_match.group(1)\n        if self.ignore_case:\n            command = command.casefold()\n\n        if command not in self.variants:\n            return False\n\n        username = command_match.group(3)\n        if username is not None and not self.username_predicate(\n            ctx.inter.me, username\n        ):\n            return False\n\n        ctx.pad[Text] = text[command_match.end(0) :].lstrip()  # type: ignore\n\n        return True", "\nclass Command(ExtendedFilter[Message]):\n    __slots__ = \"variants\", \"ignore_case\", \"pattern\", \"username_predicate\"\n\n    def __init__(\n        self,\n        variants: Iterable[str],\n        ignore_case: bool = True,\n        username_predicate: Optional[UsernamePredicate] = None,\n    ) -> None:\n        if isinstance(variants, str):\n            variants = (variants,)\n        if ignore_case:\n            variants = map(str.casefold, variants)\n\n        self.variants = tuple(variants)\n        self.ignore_case = ignore_case\n        self.pattern = re.compile(\n            r\"\\/([\\w\\d_\\-]+)(@([\\w\\d_]+))?\",\n            re.IGNORECASE if ignore_case else 0,\n        )\n        self.username_predicate = username_predicate or same_username\n\n    def __repr__(self) -> str:\n        return f\"Command({self.variants!r})\"\n\n    async def __call__(self, ctx: Context[Message]) -> bool:\n        text = ctx.pad[Text]\n        if text is None:\n            return False\n\n        command_match = self.pattern.match(text)\n        if command_match is None:\n            return False\n\n        command = command_match.group(1)\n        if self.ignore_case:\n            command = command.casefold()\n\n        if command not in self.variants:\n            return False\n\n        username = command_match.group(3)\n        if username is not None and not self.username_predicate(\n            ctx.inter.me, username\n        ):\n            return False\n\n        ctx.pad[Text] = text[command_match.end(0) :].lstrip()  # type: ignore\n\n        return True", "\n\n__all__ = [\"same_username\", \"Command\"]\n"]}
{"filename": "slonogram/handling/__init__.py", "chunked_list": [""]}
{"filename": "slonogram/handling/handler.py", "chunked_list": ["from __future__ import annotations\n\nfrom ..types.context import Context\nfrom ..types.filter import FilterFn\nfrom ..types.middleware import MiddlewareFn\nfrom ..types.handler_fn import HandlerFn, AnyHandlerFn, into_handler_fn\n\nfrom typing import Generic, TypeVar, Optional\n\nT = TypeVar(\"T\")", "\nT = TypeVar(\"T\")\n\n\nclass Handler(Generic[T]):\n    def __init__(\n        self,\n        fn: AnyHandlerFn[T],\n        observer: bool,\n        filter_: Optional[FilterFn[T]],\n        middleware: Optional[MiddlewareFn[T]],\n    ) -> None:\n        self.filter_ = filter_\n        self.middleware = middleware\n\n        self._fn_name = getattr(fn, \"__name__\", repr(fn))\n        self.observer = observer\n        self.fn: HandlerFn[T] = into_handler_fn(fn)\n\n    def __repr__(self) -> str:\n        obs_flag = \":observer\" if self.observer else \"\"\n        return f\"<Handler{obs_flag} name={self._fn_name!r}>\"\n\n    async def try_invoke(self, ctx: Context[T]) -> bool:\n        filter_ = self.filter_\n        prev_pad = ctx.pad\n        ctx.pad = prev_pad.create_child()\n\n        try:\n            if filter_ is not None:\n                if not await filter_(ctx):\n                    return False\n            mw = self.middleware\n            if mw is not None:\n                await mw(ctx)\n\n            await self.fn(ctx)\n        finally:\n            ctx.pad = prev_pad\n\n        return not self.observer", "\n\n__all__ = [\n    \"Handler\",\n]\n"]}
{"filename": "slonogram/types/scratch_pad.py", "chunked_list": ["from __future__ import annotations\nfrom copy import copy\nfrom typing import Generic, TypeVar, Dict, Any, Optional\n\nfrom .scratch import Scratch\n\nT = TypeVar(\"T\")\nR = TypeVar(\"R\")\n\n\nclass ScratchPad(Generic[T]):\n    __slots__ = (\"_scratches\", \"_model\", \"_parent\")\n\n    def __init__(\n        self, model: T, parent: Optional[ScratchPad[T]] = None\n    ) -> None:\n        self._scratches: Dict[Scratch[T, Any], Any] = {}\n        self._model = model\n        self._parent = parent\n\n    def copy(self) -> ScratchPad[T]:\n        \"\"\"\n        Returns new `ScratchPad` with exact same parameters, but\n        scratches dict is copied, so scratches modification will not\n        affect original `ScratchPad`\n        \"\"\"\n\n        pad = ScratchPad(self._model, self._parent)\n        pad._scratches = copy(self._scratches)\n        return pad\n\n    def __repr__(self) -> str:\n        return (\n            f\"<ScratchPad scratches={self._scratches!r} \"\n            f\"parent={self._parent!r}>\"\n        )\n\n    def __setitem__(self, scratch: Scratch[T, R], value: R) -> None:\n        self._scratches[scratch] = value\n\n    def __getitem__(self, scratch: Scratch[T, R]) -> R:\n        try:\n            return self._scratches[scratch]\n        except KeyError:\n            parent = self._parent\n            if parent is None:\n                return scratch(self._model)\n            return parent[scratch]\n\n    def create_child(self) -> ScratchPad[T]:\n        return ScratchPad(self._model, self)\n\n    def clear(self) -> None:\n        self._scratches.clear()", "\n\nclass ScratchPad(Generic[T]):\n    __slots__ = (\"_scratches\", \"_model\", \"_parent\")\n\n    def __init__(\n        self, model: T, parent: Optional[ScratchPad[T]] = None\n    ) -> None:\n        self._scratches: Dict[Scratch[T, Any], Any] = {}\n        self._model = model\n        self._parent = parent\n\n    def copy(self) -> ScratchPad[T]:\n        \"\"\"\n        Returns new `ScratchPad` with exact same parameters, but\n        scratches dict is copied, so scratches modification will not\n        affect original `ScratchPad`\n        \"\"\"\n\n        pad = ScratchPad(self._model, self._parent)\n        pad._scratches = copy(self._scratches)\n        return pad\n\n    def __repr__(self) -> str:\n        return (\n            f\"<ScratchPad scratches={self._scratches!r} \"\n            f\"parent={self._parent!r}>\"\n        )\n\n    def __setitem__(self, scratch: Scratch[T, R], value: R) -> None:\n        self._scratches[scratch] = value\n\n    def __getitem__(self, scratch: Scratch[T, R]) -> R:\n        try:\n            return self._scratches[scratch]\n        except KeyError:\n            parent = self._parent\n            if parent is None:\n                return scratch(self._model)\n            return parent[scratch]\n\n    def create_child(self) -> ScratchPad[T]:\n        return ScratchPad(self._model, self)\n\n    def clear(self) -> None:\n        self._scratches.clear()", ""]}
{"filename": "slonogram/types/event_flags.py", "chunked_list": ["from enum import IntFlag, auto\nfrom typing import TypeAlias\n\n\nclass MessageFlags(IntFlag):\n    SENT = auto()\n    EDITED = auto()\n\n\nEventFlags: TypeAlias = MessageFlags", "\nEventFlags: TypeAlias = MessageFlags\n"]}
{"filename": "slonogram/types/scratch.py", "chunked_list": ["from typing import TypeVar, TypeAlias, Callable\n\nT = TypeVar(\"T\")\nR = TypeVar(\"R\")\n\nScratch: TypeAlias = Callable[[T], R]\n\n\ndef attr_scratch(attr: str) -> Scratch[T, R]:\n    class Impl:\n        def __repr__(self) -> str:\n            return f\"<Scratch:attr attr={attr!r}>\"\n\n        def __call__(self, model: T) -> R:\n            return getattr(model, attr)\n\n    return Impl()", "def attr_scratch(attr: str) -> Scratch[T, R]:\n    class Impl:\n        def __repr__(self) -> str:\n            return f\"<Scratch:attr attr={attr!r}>\"\n\n        def __call__(self, model: T) -> R:\n            return getattr(model, attr)\n\n    return Impl()\n", ""]}
{"filename": "slonogram/types/context.py", "chunked_list": ["from __future__ import annotations\nfrom anyio.abc import TaskGroup\n\nfrom typing import TypeVar, Generic, Any\n\nfrom .event_flags import EventFlags\nfrom .scratch_pad import ScratchPad\n\nfrom ..schemas import User\nfrom ..bot import Bot", "from ..schemas import User\nfrom ..bot import Bot\n\n\nT = TypeVar(\"T\")\nR = TypeVar(\"R\")\n\n\nclass InterContextData:\n    __slots__ = \"data\", \"bot\", \"me\", \"task_group\"\n\n    def __init__(\n        self, me: User, data: Any, bot: Bot, task_group: TaskGroup\n    ) -> None:\n        self.data = data\n        self.bot = bot\n        self.me = me\n        self.task_group = task_group", "class InterContextData:\n    __slots__ = \"data\", \"bot\", \"me\", \"task_group\"\n\n    def __init__(\n        self, me: User, data: Any, bot: Bot, task_group: TaskGroup\n    ) -> None:\n        self.data = data\n        self.bot = bot\n        self.me = me\n        self.task_group = task_group", "\n\nclass Context(Generic[T]):\n    __slots__ = \"pad\", \"inter\", \"flags\"\n\n    def __init__(\n        self, inter: InterContextData, flags: EventFlags, model: T\n    ) -> None:\n        self.flags = flags\n        self.inter = inter\n        self.pad = ScratchPad[T](model)\n\n    @property\n    def model(self) -> T:\n        return self.pad._model\n\n    @model.setter\n    def model(self, value: T) -> None:\n        self.pad._model = value", ""]}
{"filename": "slonogram/types/filter.py", "chunked_list": ["from __future__ import annotations\n\nfrom abc import ABCMeta, abstractmethod\n\nfrom typing import Callable, TypeAlias, Awaitable, TypeVar, Generic\nfrom .context import Context\n\nT = TypeVar(\"T\")\n\nFilterFn: TypeAlias = Callable[[Context[T]], Awaitable[bool]]", "\nFilterFn: TypeAlias = Callable[[Context[T]], Awaitable[bool]]\n\n\nclass AlwaysConst:\n    def __init__(self, const: bool) -> None:\n        self.const = const\n\n    def __repr__(self) -> str:\n        return f\"const({self.const})\"\n\n    async def __call__(self, _: Context[T]) -> bool:\n        return self.const", "\n\nalways_true = AlwaysConst(True)\nalways_false = AlwaysConst(False)\n\n\nclass ExtendedFilter(Generic[T], metaclass=ABCMeta):\n    def __invert__(self) -> Inverted[T]:\n        return Inverted(self)\n\n    def __or__(self, rhs: FilterFn[T]) -> Or[T]:\n        return Or(self, rhs, False)\n\n    def __xor__(self, rhs: FilterFn[T]) -> Or[T]:\n        return Or(self, rhs, True)\n\n    def __and__(self, rhs: FilterFn[T]) -> And[T]:\n        return And(self, rhs)\n\n    @abstractmethod\n    def __call__(self, ctx: Context[T]) -> Awaitable[bool]:\n        _ = ctx\n        raise NotImplementedError", "\n\nclass If(ExtendedFilter[T]):\n    __slots__ = \"condition\", \"on_then\", \"on_else\"\n\n    def __init__(\n        self,\n        condition: FilterFn[T],\n        on_then: FilterFn[T] = always_true,\n        on_else: FilterFn[T] = always_false,\n        restore_scratches: bool = True,\n    ) -> None:\n        self.condition = condition\n        self.on_then = on_then\n        self.on_else = on_else\n        self.restore_scratches = restore_scratches\n\n    def then(self, new_then: FilterFn[T]) -> If[T]:\n        return If(self.condition, new_then, self.on_else)\n\n    def else_(self, new_else: FilterFn[T]) -> If[T]:\n        return If(self.condition, self.on_then, new_else)\n\n    def __repr__(self) -> str:\n        restore_flag = \"\" if self.restore_scratches else \"!r\"\n        return (\n            f\"(if{restore_flag} {self.condition} then\"\n            f\" {self.on_then} else {self.on_else})\"\n        )\n\n    async def __call__(self, ctx: Context[T]) -> bool:\n        if self.restore_scratches:\n            _copy = ctx.pad.copy()\n        cond = await self.condition(ctx)\n        if cond:\n            return await self.on_then(ctx)\n        elif self.restore_scratches:\n            ctx.pad = _copy\n        return await self.on_else(ctx)", "\n\nclass Predicate(ExtendedFilter[T]):\n    __slots__ = (\"fn\",)\n\n    def __init__(self, fn: FilterFn[T]) -> None:\n        self.fn = fn\n\n    def __call__(self, ctx: Context[T]) -> Awaitable[bool]:\n        return self.fn(ctx)", "\n\nclass Or(ExtendedFilter[T]):\n    __slots__ = \"lhs_fn\", \"rhs_fn\", \"exclusive\"\n\n    def __init__(\n        self, lhs: FilterFn[T], rhs: FilterFn[T], exclusive: bool\n    ) -> None:\n        self.lhs_fn = lhs\n        self.rhs_fn = rhs\n        self.exclusive = exclusive\n\n    @property\n    def symbol(self) -> str:\n        return \"^\" if self.exclusive else \"|\"\n\n    def __repr__(self) -> str:\n        return f\"{self.lhs_fn} {self.symbol} {self.rhs_fn}\"\n\n    async def __call__(self, ctx: Context[T]) -> bool:\n        if self.exclusive:\n            lhs = await self.lhs_fn(ctx)\n            rhs = await self.rhs_fn(ctx)\n            return bool(lhs ^ rhs)\n        else:\n            lhs = await self.lhs_fn(ctx)\n            if not lhs:\n                return await self.rhs_fn(ctx)\n            return lhs", "\n\nclass And(ExtendedFilter[T]):\n    __slots__ = \"lhs_fn\", \"rhs_fn\"\n\n    def __init__(self, lhs: FilterFn[T], rhs: FilterFn[T]) -> None:\n        self.lhs_fn = lhs\n        self.rhs_fn = rhs\n\n    def __repr__(self) -> str:\n        return f\"{self.lhs_fn} & {self.rhs_fn}\"\n\n    async def __call__(self, ctx: Context[T]) -> bool:\n        lhs = await self.lhs_fn(ctx)\n        if not lhs:\n            return False\n        return await self.rhs_fn(ctx)", "\n\nclass Inverted(ExtendedFilter[T]):\n    __slots__ = (\"fn\",)\n\n    def __init__(self, fn: FilterFn[T]) -> None:\n        self.fn = fn\n\n    def __repr__(self) -> str:\n        return f\"~{self.fn}\"\n\n    async def __call__(self, ctx: Context[T]) -> bool:\n        result = await self.fn(ctx)\n        return not result", "\n\ndef not_(fn: FilterFn[T]) -> Inverted[T]:\n    return Inverted(fn)\n\n\n__all__ = [\n    \"FilterFn\",\n    \"ExtendedFilter\",\n    \"Inverted\",", "    \"ExtendedFilter\",\n    \"Inverted\",\n    \"And\",\n    \"Or\",\n    \"Predicate\",\n    \"If\",\n]\n"]}
{"filename": "slonogram/types/handler_fn.py", "chunked_list": ["from typing import (\n    Awaitable,\n    Protocol,\n    TypeAlias,\n    Generic,\n    TypeVar,\n    Callable,\n    cast,\n    get_origin,\n)", "    get_origin,\n)\n\nfrom inspect import signature\nfrom .context import Context\nfrom ..bot import Bot\n\nT = TypeVar(\"T\")\nR = TypeVar(\"R\")\n", "R = TypeVar(\"R\")\n\n_Single: TypeAlias = Callable[[T], Awaitable[None]]\n_Two: TypeAlias = Callable[[T, R], Awaitable[None]]\n\nAnyHandlerFn: TypeAlias = (\n    _Single[Bot]\n    | _Single[T]\n    | _Single[Context[T]]\n    | _Two[Bot, T]", "    | _Single[Context[T]]\n    | _Two[Bot, T]\n    | _Two[T, Bot]\n)\n\n\nclass HandlerFn(Protocol, Generic[T]):\n    def __call__(self, context: Context[T], /) -> Awaitable[None]:\n        ...\n", "\n\nclass _WrappedFn(Generic[T]):\n    __slots__ = \"fn\", \"__name__\", \"__call__\"\n\n    def __init__(self, anyfn: AnyHandlerFn[T], call_method: str) -> None:\n        self.fn = anyfn\n        self.__call__ = getattr(self, call_method)\n        self.__name__ = getattr(anyfn, \"__name__\", \"<unnamed>\")\n\n    def only_bot(self, ctx: Context[T]) -> Awaitable[None]:\n        return self.fn(ctx.inter.bot)  # type: ignore\n\n    def only_model(self, ctx: Context[T]) -> Awaitable[None]:\n        return self.fn(ctx.model)  # type: ignore\n\n    def bot_model(self, ctx: Context[T]) -> Awaitable[None]:\n        return self.fn(ctx.inter.bot, ctx.model)  # type: ignore\n\n    def model_bot(self, ctx: Context[T]) -> Awaitable[None]:\n        return self.fn(ctx.model, ctx.inter.bot)  # type: ignore", "\n\ndef into_handler_fn(anyfn: AnyHandlerFn[T]) -> HandlerFn[T]:\n    if getattr(anyfn, \"__cast_ctxed__\", False):\n        return cast(HandlerFn[T], anyfn)\n\n    sig = signature(anyfn)\n    params = sig.parameters\n    leading_pos = len(params)\n\n    if leading_pos == 1:\n        first = next(iter(params.values()))\n        annot = first.annotation\n        if annot is Bot:\n            return _WrappedFn(anyfn, \"only_bot\")\n        else:\n            return cast(HandlerFn[T], anyfn)\n    elif leading_pos == 2:\n        it = iter(params.values())\n        first = next(it)\n        second = next(it)\n\n        f_annot = first.annotation\n        s_annot = second.annotation\n\n        f_ty = get_origin(f_annot) or f_annot\n        s_ty = get_origin(s_annot) or s_annot\n        tps = (f_ty, s_ty)\n\n        if tps[0] is Bot:\n            return _WrappedFn(anyfn, \"bot_model\")\n        elif tps[1] is Bot:\n            return _WrappedFn(anyfn, \"model_bot\")\n        else:\n            raise TypeError(\"Unknown `AnyHandlerFn[T]` signature pattern\")\n\n    raise TypeError(\n        \"`AnyHandlerFn[T]` should take exactly 2 or 1 arguments\"\n    )", "\n\n__all__ = [\"AnyHandlerFn\", \"HandlerFn\", \"into_handler_fn\"]\n"]}
{"filename": "slonogram/types/__init__.py", "chunked_list": [""]}
{"filename": "slonogram/types/api_session.py", "chunked_list": ["from __future__ import annotations\nfrom abc import ABCMeta, abstractmethod\nfrom typing import Dict, AnyStr, TypeAlias, Any\n\nScalarSerializable: TypeAlias = AnyStr | float | int | bool\nMethodArgs: TypeAlias = Dict[AnyStr, ScalarSerializable]\n\n\nclass ApiSession(metaclass=ABCMeta):\n    @abstractmethod\n    async def call_method(\n        self, method: str, args: MethodArgs\n    ) -> Dict[AnyStr, Any]:\n        raise NotImplementedError\n\n    @abstractmethod\n    async def finalize(self) -> None:\n        pass", "class ApiSession(metaclass=ABCMeta):\n    @abstractmethod\n    async def call_method(\n        self, method: str, args: MethodArgs\n    ) -> Dict[AnyStr, Any]:\n        raise NotImplementedError\n\n    @abstractmethod\n    async def finalize(self) -> None:\n        pass", "\n\n__all__ = [\"ScalarSerializable\", \"MethodArgs\", \"ApiSession\"]\n"]}
{"filename": "slonogram/types/middleware.py", "chunked_list": ["from __future__ import annotations\n\nfrom .context import Context\n\nfrom typing import TypeVar, TypeAlias, Callable, Awaitable, List, Generic\nfrom functools import partial\n\nT = TypeVar(\"T\")\n\nMiddlewareFn: TypeAlias = Callable[[Context[T]], Awaitable[None]]", "\nMiddlewareFn: TypeAlias = Callable[[Context[T]], Awaitable[None]]\nAnyMiddlewareFn: TypeAlias = Callable[\n    [MiddlewareFn[T], Context[T]], Awaitable[None]\n]\n\n\nclass Chain(Generic[T]):\n    def __init__(self, *middlewares: AnyMiddlewareFn[T]) -> None:\n        tail: MiddlewareFn[T] = do_nothing\n        path: List[str] = []\n        for middleware in reversed(middlewares):\n            tail = partial(middleware, tail)\n            path.append(middleware.__name__)\n\n        self._fn = tail\n        self._path = path\n\n    def __call__(self, context: Context[T]) -> Awaitable[None]:\n        return self._fn(context)\n\n    def __matmul__(self, rhs: MiddlewareFn[T]) -> Group[T]:\n        return Group(self, rhs)\n\n    def __repr__(self) -> str:\n        return \" <| \".join(self._path)", "\n\nclass Group(Generic[T]):\n    def __init__(self, *chains: MiddlewareFn[T]) -> None:\n        self._chains = chains\n\n    async def __call__(self, context: Context[T]) -> None:\n        for chain in self._chains:\n            await chain(context)\n\n    def __matmul__(self, rhs: MiddlewareFn[T]) -> Group[T]:\n        return Group(*self._chains, rhs)\n\n    def __repr__(self) -> str:\n        wrapped = map(lambda chain: f\"({chain!r})\", self._chains)\n\n        return \" -> \".join(wrapped)", "\n\nasync def do_nothing(_: Context[T]) -> None:\n    pass\n"]}
{"filename": "slonogram/types/model_types.py", "chunked_list": ["from ..schemas import Message\n\nMODEL_TYPES = (Message,)\n"]}
{"filename": "slonogram/dispatching/_registrants.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import (\n    TYPE_CHECKING,\n    Optional,\n    TypeVar,\n    TypeAlias,\n    Callable,\n)\n", ")\n\nfrom ..types.filter import FilterFn\nfrom ..types.middleware import MiddlewareFn\nfrom ..types.event_flags import MessageFlags\nfrom ..types.handler_fn import AnyHandlerFn\n\nfrom ..handling.handler import Handler\nfrom ..schemas import Message\n\nif TYPE_CHECKING:\n    from .local_set import LocalSet", "from ..schemas import Message\n\nif TYPE_CHECKING:\n    from .local_set import LocalSet\n\nT = TypeVar(\"T\")\n\nMsgHandler: TypeAlias = Handler[Message]\n_OptFilterFn: TypeAlias = Optional[FilterFn[T]]\n_OptMid: TypeAlias = Optional[MiddlewareFn[T]]", "_OptFilterFn: TypeAlias = Optional[FilterFn[T]]\n_OptMid: TypeAlias = Optional[MiddlewareFn[T]]\n_RegRetDeco: TypeAlias = Callable[[AnyHandlerFn[T]], Handler[T]]\n\n\nclass OnMessage:\n    def __init__(self, set_: LocalSet) -> None:\n        self._set = set_\n\n    def _register(\n        self,\n        observer: bool,\n        subtypes: MessageFlags,\n        filter_: _OptFilterFn[Message],\n        middleware: _OptMid[Message],\n    ) -> _RegRetDeco[Message]:\n        def inner(fn: AnyHandlerFn) -> MsgHandler:\n            handler = MsgHandler(fn, observer, filter_, middleware)\n            if MessageFlags.SENT in subtypes:\n                self._set._sent_message_handlers.append(handler)\n            if MessageFlags.EDITED in subtypes:\n                self._set._edited_message_handlers.append(handler)\n\n            return handler\n\n        return inner\n\n    def __call__(\n        self,\n        subtypes: MessageFlags,\n        filter_: _OptFilterFn[Message] = None,\n        observer: bool = False,\n        middleware: _OptMid[Message] = None,\n    ) -> _RegRetDeco[Message]:\n        return self._register(observer, subtypes, filter_, middleware)\n\n    def sent(\n        self,\n        filter_: _OptFilterFn[Message] = None,\n        observer: bool = False,\n        middleware: _OptMid[Message] = None,\n    ) -> _RegRetDeco[Message]:\n        return self._register(\n            observer, MessageFlags.SENT, filter_, middleware\n        )\n\n    def edited(\n        self,\n        filter_: _OptFilterFn[Message] = None,\n        observer: bool = False,\n        middleware: _OptMid[Message] = None,\n    ) -> _RegRetDeco[Message]:\n        return self._register(\n            observer, MessageFlags.EDITED, filter_, middleware\n        )", ""]}
{"filename": "slonogram/dispatching/dispatcher.py", "chunked_list": ["from typing import (\n    TypeVar,\n    List,\n    NoReturn,\n    Optional,\n    TypeAlias,\n)\nfrom anyio import create_task_group\n\nfrom ..types.event_flags import MessageFlags", "\nfrom ..types.event_flags import MessageFlags\nfrom ..types.context import InterContextData, Context\n\nfrom ..exceptions.control_flow import DontHandle, SkipLocalSet\nfrom ..handling.handler import Handler\n\nfrom ..schemas import Message, UpdateType, Update\nfrom ..bot import Bot\n", "from ..bot import Bot\n\nfrom .local_set import LocalSet\n\n\nT = TypeVar(\"T\")\nMsgCtx: TypeAlias = Context[Message]\n\n\nclass Dispatcher:\n    \"\"\"\n    ### skip_pending:\n\n    skips updates sent before the current time\n    (time is retrieved through the `time.time`)\n    \"\"\"\n\n    def __init__(self, bot: Bot, skip_pending: bool = False) -> None:\n        self.set: LocalSet = LocalSet(\"__dispatcher__\")\n        self.skip_pending = skip_pending\n        self._bot = bot\n        self.data = None\n\n    async def _handle_set(\n        self, attr: str, set_: LocalSet, ctx: Context[T]\n    ) -> bool:\n        filter_ = set_.filter_\n        parent_pad = ctx.pad\n        ctx.pad = parent_pad.create_child()\n\n        try:\n            if filter_ is not None and not await filter_(ctx):\n                return False\n\n            mw = set_._middleware\n            if mw is not None:\n                await mw(ctx)\n            h_list: List[Handler[T]] = getattr(set_, attr)\n\n            for handler in h_list:\n                if await handler.try_invoke(ctx):\n                    return True\n\n            for child in set_._children:\n                if await self._handle_set(attr, child, ctx):\n                    return True\n        except SkipLocalSet:\n            return False\n        finally:\n            ctx.pad = parent_pad\n\n        return False\n\n    async def feed_update(\n        self, inter: InterContextData, update: Update\n    ) -> bool:\n        try:\n            if update.message is not None:\n                return await self._handle_set(\n                    \"_sent_message_handlers\",\n                    self.set,\n                    Context(inter, MessageFlags.SENT, update.message),\n                )\n            elif update.edited_message is not None:\n                return await self._handle_set(\n                    \"_edited_message_handlers\",\n                    self.set,\n                    Context(\n                        inter, MessageFlags.EDITED, update.edited_message\n                    ),\n                )\n            elif update.callback_query is not None:\n                raise NotImplementedError\n            elif update.inline_query is not None:\n                raise NotImplementedError\n\n            elif update.channel_post is not None:\n                raise NotImplementedError\n            elif update.chat_join_request is not None:\n                raise NotImplementedError\n            elif update.chat_member is not None:\n                raise NotImplementedError\n            elif update.chosen_inline_result is not None:\n                raise NotImplementedError\n            elif update.edited_channel_post is not None:\n                raise NotImplementedError\n            elif update.my_chat_member is not None:\n                raise NotImplementedError\n            elif update.poll is not None:\n                raise NotImplementedError\n            elif update.poll_answer is not None:\n                raise NotImplementedError\n            elif update.pre_checkout_query is not None:\n                raise NotImplementedError\n            elif update.shipping_query is not None:\n                raise NotImplementedError\n        except DontHandle:\n            pass\n\n        return False\n\n    async def create_intercontext_data(self) -> InterContextData:\n        me = await self._bot.user.get_me()\n        return InterContextData(\n            me, self.data, self._bot, create_task_group()\n        )\n\n    async def run_polling(\n        self,\n        offset: Optional[int] = None,\n        limit: Optional[int] = None,\n        timeout: Optional[int] = None,\n        allowed_updates: Optional[List[UpdateType]] = None,\n    ) -> NoReturn:\n        inter = await self.create_intercontext_data()\n        get_updates = self._bot.updates.get\n        feed = self.feed_update\n\n        async with inter.task_group as tg:\n            while True:\n                updates = await get_updates(\n                    offset, limit, timeout, allowed_updates\n                )\n\n                if updates:\n                    offset = updates[-1].id + 1\n\n                for update in updates:\n                    tg.start_soon(feed, inter, update)  # type: ignore", "\nclass Dispatcher:\n    \"\"\"\n    ### skip_pending:\n\n    skips updates sent before the current time\n    (time is retrieved through the `time.time`)\n    \"\"\"\n\n    def __init__(self, bot: Bot, skip_pending: bool = False) -> None:\n        self.set: LocalSet = LocalSet(\"__dispatcher__\")\n        self.skip_pending = skip_pending\n        self._bot = bot\n        self.data = None\n\n    async def _handle_set(\n        self, attr: str, set_: LocalSet, ctx: Context[T]\n    ) -> bool:\n        filter_ = set_.filter_\n        parent_pad = ctx.pad\n        ctx.pad = parent_pad.create_child()\n\n        try:\n            if filter_ is not None and not await filter_(ctx):\n                return False\n\n            mw = set_._middleware\n            if mw is not None:\n                await mw(ctx)\n            h_list: List[Handler[T]] = getattr(set_, attr)\n\n            for handler in h_list:\n                if await handler.try_invoke(ctx):\n                    return True\n\n            for child in set_._children:\n                if await self._handle_set(attr, child, ctx):\n                    return True\n        except SkipLocalSet:\n            return False\n        finally:\n            ctx.pad = parent_pad\n\n        return False\n\n    async def feed_update(\n        self, inter: InterContextData, update: Update\n    ) -> bool:\n        try:\n            if update.message is not None:\n                return await self._handle_set(\n                    \"_sent_message_handlers\",\n                    self.set,\n                    Context(inter, MessageFlags.SENT, update.message),\n                )\n            elif update.edited_message is not None:\n                return await self._handle_set(\n                    \"_edited_message_handlers\",\n                    self.set,\n                    Context(\n                        inter, MessageFlags.EDITED, update.edited_message\n                    ),\n                )\n            elif update.callback_query is not None:\n                raise NotImplementedError\n            elif update.inline_query is not None:\n                raise NotImplementedError\n\n            elif update.channel_post is not None:\n                raise NotImplementedError\n            elif update.chat_join_request is not None:\n                raise NotImplementedError\n            elif update.chat_member is not None:\n                raise NotImplementedError\n            elif update.chosen_inline_result is not None:\n                raise NotImplementedError\n            elif update.edited_channel_post is not None:\n                raise NotImplementedError\n            elif update.my_chat_member is not None:\n                raise NotImplementedError\n            elif update.poll is not None:\n                raise NotImplementedError\n            elif update.poll_answer is not None:\n                raise NotImplementedError\n            elif update.pre_checkout_query is not None:\n                raise NotImplementedError\n            elif update.shipping_query is not None:\n                raise NotImplementedError\n        except DontHandle:\n            pass\n\n        return False\n\n    async def create_intercontext_data(self) -> InterContextData:\n        me = await self._bot.user.get_me()\n        return InterContextData(\n            me, self.data, self._bot, create_task_group()\n        )\n\n    async def run_polling(\n        self,\n        offset: Optional[int] = None,\n        limit: Optional[int] = None,\n        timeout: Optional[int] = None,\n        allowed_updates: Optional[List[UpdateType]] = None,\n    ) -> NoReturn:\n        inter = await self.create_intercontext_data()\n        get_updates = self._bot.updates.get\n        feed = self.feed_update\n\n        async with inter.task_group as tg:\n            while True:\n                updates = await get_updates(\n                    offset, limit, timeout, allowed_updates\n                )\n\n                if updates:\n                    offset = updates[-1].id + 1\n\n                for update in updates:\n                    tg.start_soon(feed, inter, update)  # type: ignore", ""]}
{"filename": "slonogram/dispatching/__init__.py", "chunked_list": ["from .dispatcher import Dispatcher\nfrom .local_set import LocalSet\n\n__all__ = [\"Dispatcher\", \"LocalSet\"]\n"]}
{"filename": "slonogram/dispatching/local_set.py", "chunked_list": ["from __future__ import annotations\nfrom typing import (\n    Optional,\n    List,\n    TypeVar,\n    Any,\n)\n\nfrom ..types.middleware import MiddlewareFn\nfrom ..types.filter import FilterFn", "from ..types.middleware import MiddlewareFn\nfrom ..types.filter import FilterFn\nfrom ._registrants import OnMessage, MsgHandler\n\nT = TypeVar(\"T\")\n\n\nclass LocalSet:\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        filter_: Optional[FilterFn[Any]] = None,\n        middleware: Optional[MiddlewareFn[Any]] = None,\n    ) -> None:\n        self.name = name\n\n        self._children: List[LocalSet] = []\n        self.filter_ = filter_\n\n        self._sent_message_handlers: List[MsgHandler] = []\n        self._edited_message_handlers: List[MsgHandler] = []\n\n        self._middleware = middleware\n\n    def include(self, *sets: LocalSet) -> None:\n        self._children.extend(sets)\n\n    @property\n    def on_message(self) -> OnMessage:\n        return OnMessage(self)", ""]}
{"filename": "slonogram/call_groups/updates.py", "chunked_list": ["from typing import Optional, List, Awaitable\n\nfrom ..schemas import UpdateType, Update\nfrom .group import CallsGroup, UseRetort\n\n\nclass UpdatesCallGroup(CallsGroup):\n    def get(\n        self,\n        offset: Optional[int] = None,\n        limit: Optional[int] = None,\n        timeout: Optional[int] = None,\n        allowed_updates: Optional[List[UpdateType]] = None,\n    ) -> Awaitable[List[Update]]:\n        return self._call(\n            List[Update],\n            \"getUpdates\",\n            {},\n            (\n                (\"offset\", offset),\n                (\"limit\", limit),\n                (\"timeout\", timeout),\n                UseRetort(\"allowed_updates\", allowed_updates),\n            ),\n        )", ""]}
{"filename": "slonogram/call_groups/__init__.py", "chunked_list": [""]}
{"filename": "slonogram/call_groups/group.py", "chunked_list": ["from adaptix import Retort\nfrom typing import TypeVar, Type, Iterable, Tuple, Any, Generic, Optional\n\nfrom ..utils.json import dumps\nfrom ..types.api_session import (\n    ApiSession,\n    MethodArgs,\n    ScalarSerializable,\n)\nfrom ..exceptions.api_error import ApiError", ")\nfrom ..exceptions.api_error import ApiError\n\nT = TypeVar(\"T\")\n\n\nclass UseRetort(Generic[T]):\n    __slots__ = \"name\", \"value\"\n\n    def __init__(self, name: str, value: Optional[T]) -> None:\n        self.name = name\n        self.value = value", "\n\nclass CallsGroup:\n    def __init__(self, retort: Retort, session: ApiSession) -> None:\n        self._session = session\n        self._retort = retort\n\n    async def _call(\n        self,\n        ty: Type[T],\n        method: str,\n        args: MethodArgs,\n        optional_args: Iterable[\n            Tuple[str, Optional[ScalarSerializable]] | UseRetort[Any]\n        ] = [],\n    ) -> T:\n        retort = self._retort\n        for arg in optional_args:\n            if isinstance(arg, UseRetort):\n                i_value = arg.value\n                if i_value is None:\n                    continue\n\n                name = arg.name\n                value = dumps(retort.dump(i_value))\n\n                args[name] = value\n            else:\n                key, value = arg  # type: ignore\n                if value is not None:\n                    args[key] = value\n\n        result = await self._session.call_method(method, args)\n        if not result[\"ok\"]:\n            raise ApiError(\n                result[\"error_code\"],\n                result[\"description\"],\n            )\n\n        # TODO: Do we need ability to \"delay\" model loading?\n        # for example, when result is not used\n        return self._retort.load(result[\"result\"], ty)", ""]}
{"filename": "slonogram/call_groups/user.py", "chunked_list": ["from typing import Awaitable\n\nfrom .group import CallsGroup\nfrom ..schemas import User\n\n\nclass UserCallGroup(CallsGroup):\n    def get_me(self) -> Awaitable[User]:\n        return self._call(User, \"getMe\", {})\n", ""]}
{"filename": "slonogram/call_groups/chat.py", "chunked_list": ["from __future__ import annotations\nfrom typing import Optional, Awaitable, List\n\nfrom ..schemas import (\n    ParseMode,\n    Message,\n    MessageEntity,\n    InlineKeyboardMarkup,\n    ChatAction,\n    ReplyKeyboardMarkup,", "    ChatAction,\n    ReplyKeyboardMarkup,\n    ReplyKeyboardRemove,\n    ForceReply,\n)\nfrom .group import CallsGroup, UseRetort\n\n\nclass ChatCallGroup(CallsGroup):\n    def send_action(\n        self,\n        chat_id: int | str,\n        action: ChatAction,\n        message_thread_id: Optional[int] = None,\n    ) -> Awaitable[bool]:\n        return self._call(\n            bool,\n            \"sendChatAction\",\n            {\"chat_id\": chat_id, \"action\": action},\n            ((\"message_thread_id\", message_thread_id),),\n        )\n\n    def send_message(\n        self,\n        chat_id: int | str,\n        text: Optional[str] = None,\n        parse_mode: Optional[ParseMode] = None,\n        reply_to: Optional[int] = None,\n        entities: Optional[List[MessageEntity]] = None,\n        disable_web_page_preview: Optional[bool] = None,\n        disable_notification: Optional[bool] = None,\n        protect_content: Optional[bool] = None,\n        allow_sending_without_reply: Optional[bool] = None,\n        reply_markup: Optional[\n            InlineKeyboardMarkup\n            | ReplyKeyboardMarkup\n            | ReplyKeyboardRemove\n            | ForceReply\n        ] = None,\n    ) -> Awaitable[Message]:\n        \"\"\"\n        Sends a message to chat\n        :param chat_id: Chat's ID\n        :param text: Text of message\n        :param parse_mode: Parse-mode, can be `html` or `markdown`\n        :param reply_to: Reply to message? Pass `ID` of message to reply\n        :param entities: List of message's entities\n        :param disable_web_page_preview: Disable preview?\n        :param disable_notification: Disable notification?\n        :param protect_content: Protect content?\n        :param allow_sending_without_reply: Allow sending without reply?\n        :return: Sent message on success\n        \"\"\"\n\n        return self._call(\n            Message,\n            \"sendMessage\",\n            {\"chat_id\": chat_id},\n            (\n                (\"text\", text),\n                (\"parse_mode\", parse_mode),\n                (\"reply_to_message_id\", reply_to),\n                (\"entities\", entities),\n                (\"disable_web_page_preview\", disable_web_page_preview),\n                (\"disable_notification\", disable_notification),\n                (\"protect_content\", protect_content),\n                (\n                    \"allow_sending_without_reply\",\n                    allow_sending_without_reply,\n                ),\n                UseRetort(\"reply_markup\", reply_markup),\n            ),\n        )\n\n    def forward_message(\n        self,\n        chat_id: int | str,\n        from_chat_id: int | str,\n        message_id: int,\n        message_thread_id: Optional[int] = None,\n        disable_notification: Optional[bool] = None,\n        protect_content: Optional[bool] = None,\n    ) -> Awaitable[Message]:\n        \"\"\"\n        Use this method to forward messages of any kind\n        Service messages can't be forwarded.\n        On success, the sent `Message` is returned.\n\n        :param chat_id: Chat's ID\n        :param from_chat_id: Identifier for the chat where the original\n                             message was sent\n        :param message_id: Message identifier in the chat specified in\n                           `from_chat_id`\n        :param message_thread_id: Identifier for the target message thread\n                                  (topic) of the forum\n        :param disable_notification: Send the message silently?\n        :param protect_content: Protects the contents of the forwarded message\n                                from forwarding and saving\n        \"\"\"\n\n        return self._call(\n            Message,\n            \"forwardMessage\",\n            {\n                \"chat_id\": chat_id,\n                \"from_chat_id\": from_chat_id,\n                \"message_id\": message_id,\n            },\n            (\n                (\"message_thread_id\", message_thread_id),\n                (\"disable_notification\", disable_notification),\n                (\"protect_content\", protect_content),\n            ),\n        )\n\n    def edit_message_text(\n        self,\n        text: str,\n        chat_id: Optional[int | str] = None,\n        message_id: Optional[int] = None,\n        inline_message_id: Optional[str] = None,\n        parse_mode: Optional[ParseMode] = None,\n        entities: Optional[List[MessageEntity]] = None,\n        disable_web_page_preview: Optional[bool] = None,\n        reply_markup: Optional[InlineKeyboardMarkup] = None,\n    ) -> Awaitable[Message]:\n        \"\"\"\n        Edits message's text.\n        Pass `chat_id` with `message_id` or `inline_message_id`\n\n        :param text: New text for the message\n        :param chat_id: Chat's ID\n        :param parse_mode: Parse-mode, can be `html` or `markdown`\n        :param entities: List of message's entities\n        :param disable_web_page_preview: Disable preview?\n        :param reply_markup: New reply-markup\n        :return: Edited message on success\n        \"\"\"\n        return self._call(\n            Message,\n            \"editMessageText\",\n            {\"text\": text},\n            (\n                (\"chat_id\", chat_id),\n                (\"message_id\", message_id),\n                (\"inline_message_id\", inline_message_id),\n                (\"parse_mode\", parse_mode),\n                (\"entities\", entities),\n                (\"disable_web_page_preview\", disable_web_page_preview),\n                (\"reply_markup\", reply_markup),\n            ),\n        )", "class ChatCallGroup(CallsGroup):\n    def send_action(\n        self,\n        chat_id: int | str,\n        action: ChatAction,\n        message_thread_id: Optional[int] = None,\n    ) -> Awaitable[bool]:\n        return self._call(\n            bool,\n            \"sendChatAction\",\n            {\"chat_id\": chat_id, \"action\": action},\n            ((\"message_thread_id\", message_thread_id),),\n        )\n\n    def send_message(\n        self,\n        chat_id: int | str,\n        text: Optional[str] = None,\n        parse_mode: Optional[ParseMode] = None,\n        reply_to: Optional[int] = None,\n        entities: Optional[List[MessageEntity]] = None,\n        disable_web_page_preview: Optional[bool] = None,\n        disable_notification: Optional[bool] = None,\n        protect_content: Optional[bool] = None,\n        allow_sending_without_reply: Optional[bool] = None,\n        reply_markup: Optional[\n            InlineKeyboardMarkup\n            | ReplyKeyboardMarkup\n            | ReplyKeyboardRemove\n            | ForceReply\n        ] = None,\n    ) -> Awaitable[Message]:\n        \"\"\"\n        Sends a message to chat\n        :param chat_id: Chat's ID\n        :param text: Text of message\n        :param parse_mode: Parse-mode, can be `html` or `markdown`\n        :param reply_to: Reply to message? Pass `ID` of message to reply\n        :param entities: List of message's entities\n        :param disable_web_page_preview: Disable preview?\n        :param disable_notification: Disable notification?\n        :param protect_content: Protect content?\n        :param allow_sending_without_reply: Allow sending without reply?\n        :return: Sent message on success\n        \"\"\"\n\n        return self._call(\n            Message,\n            \"sendMessage\",\n            {\"chat_id\": chat_id},\n            (\n                (\"text\", text),\n                (\"parse_mode\", parse_mode),\n                (\"reply_to_message_id\", reply_to),\n                (\"entities\", entities),\n                (\"disable_web_page_preview\", disable_web_page_preview),\n                (\"disable_notification\", disable_notification),\n                (\"protect_content\", protect_content),\n                (\n                    \"allow_sending_without_reply\",\n                    allow_sending_without_reply,\n                ),\n                UseRetort(\"reply_markup\", reply_markup),\n            ),\n        )\n\n    def forward_message(\n        self,\n        chat_id: int | str,\n        from_chat_id: int | str,\n        message_id: int,\n        message_thread_id: Optional[int] = None,\n        disable_notification: Optional[bool] = None,\n        protect_content: Optional[bool] = None,\n    ) -> Awaitable[Message]:\n        \"\"\"\n        Use this method to forward messages of any kind\n        Service messages can't be forwarded.\n        On success, the sent `Message` is returned.\n\n        :param chat_id: Chat's ID\n        :param from_chat_id: Identifier for the chat where the original\n                             message was sent\n        :param message_id: Message identifier in the chat specified in\n                           `from_chat_id`\n        :param message_thread_id: Identifier for the target message thread\n                                  (topic) of the forum\n        :param disable_notification: Send the message silently?\n        :param protect_content: Protects the contents of the forwarded message\n                                from forwarding and saving\n        \"\"\"\n\n        return self._call(\n            Message,\n            \"forwardMessage\",\n            {\n                \"chat_id\": chat_id,\n                \"from_chat_id\": from_chat_id,\n                \"message_id\": message_id,\n            },\n            (\n                (\"message_thread_id\", message_thread_id),\n                (\"disable_notification\", disable_notification),\n                (\"protect_content\", protect_content),\n            ),\n        )\n\n    def edit_message_text(\n        self,\n        text: str,\n        chat_id: Optional[int | str] = None,\n        message_id: Optional[int] = None,\n        inline_message_id: Optional[str] = None,\n        parse_mode: Optional[ParseMode] = None,\n        entities: Optional[List[MessageEntity]] = None,\n        disable_web_page_preview: Optional[bool] = None,\n        reply_markup: Optional[InlineKeyboardMarkup] = None,\n    ) -> Awaitable[Message]:\n        \"\"\"\n        Edits message's text.\n        Pass `chat_id` with `message_id` or `inline_message_id`\n\n        :param text: New text for the message\n        :param chat_id: Chat's ID\n        :param parse_mode: Parse-mode, can be `html` or `markdown`\n        :param entities: List of message's entities\n        :param disable_web_page_preview: Disable preview?\n        :param reply_markup: New reply-markup\n        :return: Edited message on success\n        \"\"\"\n        return self._call(\n            Message,\n            \"editMessageText\",\n            {\"text\": text},\n            (\n                (\"chat_id\", chat_id),\n                (\"message_id\", message_id),\n                (\"inline_message_id\", inline_message_id),\n                (\"parse_mode\", parse_mode),\n                (\"entities\", entities),\n                (\"disable_web_page_preview\", disable_web_page_preview),\n                (\"reply_markup\", reply_markup),\n            ),\n        )", ""]}
{"filename": "slonogram/call_groups/queries.py", "chunked_list": ["from .group import CallsGroup\nfrom typing import Awaitable, Optional\n\n\nclass QueriesCallGroup(CallsGroup):\n    def answer_callback(\n        self,\n        query_id: str,\n        text: Optional[str] = None,\n        show_alert: Optional[bool] = None,\n        url: Optional[str] = None,\n        cache_time: Optional[int] = None,\n    ) -> Awaitable[bool]:\n        return self._call(\n            bool,\n            \"answerCallbackQuery\",\n            {\"query_id\": query_id},\n            (\n                (\"text\", text),\n                (\"show_alert\", show_alert),\n                (\"url\", url),\n                (\"cache_time\", cache_time),\n            ),\n        )", ""]}
{"filename": "examples/di_example.py", "chunked_list": ["import asyncio\n\nfrom typing import NewType\n\nfrom slonodi import Container\nfrom slonodi.specifiers import requires\n\nfrom slonogram.extra.scratches import Text\nfrom slonogram.extra.di import (\n    from_scratch,", "from slonogram.extra.di import (\n    from_scratch,\n    create_injector,\n)\n\nfrom slonogram.bot import Bot\nfrom slonogram.schemas import Message\nfrom slonogram.filtering.text import Command\nfrom slonogram.dispatching import LocalSet, Dispatcher\n", "from slonogram.dispatching import LocalSet, Dispatcher\n\nMaster = NewType(\"Master\", str)\n\ncontainer = Container()\ncontainer[Master] = Master(\"Nero\")\n\ninjector = create_injector()\ninject = injector.inject\n", "inject = injector.inject\n\n\nset_ = LocalSet()\n\n\n@set_.on_message.sent(Command(\"get_master\"))\n@inject(from_scratch(\"text\", Text), requires(\"master\"))\nasync def on_get_master(\n    bot: Bot, message: Message, text: str, master: Master", "async def on_get_master(\n    bot: Bot, message: Message, text: str, master: Master\n) -> None:\n    await bot.chat.send_message(\n        message.chat.id,\n        f\"My master is {master} (scratch text = {text})\",\n    )\n\n\nasync def main() -> None:", "\nasync def main() -> None:\n    async with Bot(open(\".test_token\").read()) as bot:\n        dp = Dispatcher(bot)\n        dp.data = container\n        dp.set.include(set_)\n        await dp.run_polling()\n\n\nasyncio.run(main())", "\nasyncio.run(main())\n"]}
{"filename": "examples/edited_repeater.py", "chunked_list": ["import asyncio\n\nfrom slonogram import Bot\n\nfrom slonogram.schemas import Message\nfrom slonogram.dispatching import Dispatcher, LocalSet\n\nfrom slonogram.filtering.text import Command\n\nTOKEN = open(\".test_token\").read()", "\nTOKEN = open(\".test_token\").read()\n\nset_ = LocalSet()\n\n\n@set_.on_message.sent(Command(\"start\"))\nasync def start(bot: Bot, message: Message) -> None:\n    await bot.chat.send_message(\n        message.chat.id, \"Hello! I'll repeat everything you edit\"", "    await bot.chat.send_message(\n        message.chat.id, \"Hello! I'll repeat everything you edit\"\n    )\n\n\n@set_.on_message.edited()\nasync def edit_callback(bot: Bot, message: Message) -> None:\n    await bot.chat.send_message(\n        message.chat.id, f\"Edited: {message.text}\", reply_to=message.id\n    )", "        message.chat.id, f\"Edited: {message.text}\", reply_to=message.id\n    )\n\n\nasync def main() -> None:\n    async with Bot(TOKEN) as bot:\n        dp = Dispatcher(bot)\n        dp.set.include(set_)\n\n        await dp.run_polling()", "\n        await dp.run_polling()\n\n\nasyncio.run(main())\n"]}
{"filename": "misc/code_generator/parser.py", "chunked_list": ["from typing import Sequence\nfrom keyword import kwlist\n\nTP_MAPPINGS = {\n    \"String\": \"str\",\n    \"Integer\": \"int\",\n    \"Boolean\": \"bool\",\n    \"Float\": \"float\",\n}\n", "}\n\n\ndef escape_hard_keywords(name: str) -> str:\n    if name in kwlist:\n        return name + \"_\"\n    return name\n\n\ndef parse_multiple_types(telegram_tps: Sequence[str]) -> str:", "\ndef parse_multiple_types(telegram_tps: Sequence[str]) -> str:\n    match telegram_tps:\n        case [tp]:\n            return parse_type(tp)\n        case anything:\n            return \" | \".join(parse_type(tp) for tp in anything)\n\n\ndef parse_type(telegram_tp: str) -> str:", "\ndef parse_type(telegram_tp: str) -> str:\n    tp = telegram_tp.strip()\n    if tp in TP_MAPPINGS:\n        return TP_MAPPINGS[tp]\n\n    if (wo_prefix := tp.removeprefix(\"Array of \")) != tp:\n        inside = parse_type(wo_prefix)\n        return f\"List[{inside}]\"\n    return tp", "        return f\"List[{inside}]\"\n    return tp\n"]}
{"filename": "misc/code_generator/__main__.py", "chunked_list": ["from pathlib import Path\n\nfrom os import mkdir\nfrom sys import argv, exit\nfrom json import load\n\nfrom .schemas_generator import generate_schemas\nfrom .types import CodegenerationConfig, Spec, RETORT\n\ntry:\n    config_path = Path(argv[1])\n    schemas_path = Path(argv[2])\n    call_groups_directory = Path(argv[3])\nexcept IndexError:\n    print(\n        \"usage: misc.code_generator <config_path>\"\n        \" <schemas_outpath> <call_groups_directory>\"\n    )\n    exit(1)", "\ntry:\n    config_path = Path(argv[1])\n    schemas_path = Path(argv[2])\n    call_groups_directory = Path(argv[3])\nexcept IndexError:\n    print(\n        \"usage: misc.code_generator <config_path>\"\n        \" <schemas_outpath> <call_groups_directory>\"\n    )\n    exit(1)", "\nconfig = CodegenerationConfig.read_from(config_path)\nspec_root = Path(__file__).parent.parent / \"telegram-bot-api-spec\"\nraw_spec = load(open(spec_root / \"api.min.json\"))\nspec = RETORT.load(raw_spec, Spec)\n\nif not call_groups_directory.exists():\n    print(f\"> mkdir {call_groups_directory}\")\n    mkdir(call_groups_directory)\n\nif not (call_groups_directory / \"__init__.py\").exists():\n    print(\"> creating __init__.py file in the call groups directory\")\n    open(call_groups_directory / \"__init__.py\", \"wb\").close()", "\nif not (call_groups_directory / \"__init__.py\").exists():\n    print(\"> creating __init__.py file in the call groups directory\")\n    open(call_groups_directory / \"__init__.py\", \"wb\").close()\n\nschemas = generate_schemas(spec, config)\n\nwith open(schemas_path, \"w\") as fp:\n    wrote = fp.write(schemas)\n    print(f\">>[Schema] Wrote {wrote} bytes to {schemas_path}\")", ""]}
{"filename": "misc/code_generator/types.py", "chunked_list": ["from yaml import safe_load  # type: ignore\nfrom adaptix import Retort\nfrom pathlib import Path\nfrom typing import Dict, NewType, TypeAlias, List\nfrom dataclasses import dataclass, field\n\nRETORT = Retort()\n\nAbsolutePath = NewType(\"AbsolutePath\", str)\nTy = NewType(\"Ty\", str)", "AbsolutePath = NewType(\"AbsolutePath\", str)\nTy = NewType(\"Ty\", str)\n\nAlias: TypeAlias = str\nRenameValue: TypeAlias = str\n\n\n@dataclass\nclass Field:\n    name: str\n    types: List[str]\n    required: bool\n    description: str", "class Field:\n    name: str\n    types: List[str]\n    required: bool\n    description: str\n\n\n@dataclass\nclass Type:\n    name: str\n    href: str\n    description: List[str]\n    fields: List[Field] = field(default_factory=list)", "class Type:\n    name: str\n    href: str\n    description: List[str]\n    fields: List[Field] = field(default_factory=list)\n\n\n@dataclass\nclass Spec:\n    types: Dict[str, Type]", "class Spec:\n    types: Dict[str, Type]\n\n\n@dataclass\nclass EnumsConfig:\n    types: Dict[Ty, List[Alias] | Dict[Alias, RenameValue]]\n    overrides: Dict[AbsolutePath, Ty]\n\n", "\n\n@dataclass\nclass CodegenerationConfig:\n    enums: EnumsConfig\n    renames: Dict[AbsolutePath, RenameValue]\n\n    @classmethod\n    def read_from(cls, path: Path) -> \"CodegenerationConfig\":\n        d = safe_load(open(path, \"r\"))\n        return RETORT.load(d, cls)", ""]}
{"filename": "misc/code_generator/schemas_generator.py", "chunked_list": ["from typing import List\n\nfrom .parser import parse_multiple_types, escape_hard_keywords\nfrom .types import CodegenerationConfig, Spec, AbsolutePath\nfrom .helpers import (\n    GenerationHelper,\n    Import,\n    Class,\n    ClassField,\n    generate,", "    ClassField,\n    generate,\n    Decorate,\n)\n\n\ndef generate_schemas(spec: Spec, config: CodegenerationConfig) -> str:\n    schemas: List[GenerationHelper] = [\n        Import(\"__future__\", \"annotations\"),\n        Import(\"enum\", \"Enum\"),\n        Import(\"dataclasses\", \"dataclass\"),\n        Import(\"typing\", (\"List\", \"Optional\")),\n    ]\n\n    # Enums generation\n    for name, variants in config.enums.types.items():\n        fields: List[ClassField] = []\n        if isinstance(variants, dict):\n            for alias, rename in variants.items():\n                fields.append(\n                    ClassField(alias.upper(), default=repr(rename))\n                )\n        else:\n            for alias in variants:\n                fields.append(\n                    ClassField(alias.upper(), default=repr(alias))\n                )\n\n        schemas.append(Class(name, [], fields, inherits=(\"str\", \"Enum\")))\n\n    # Telegram types generation\n    for ty_name, ty in spec.types.items():\n        desc = \" \".join(ty.description)\n        desc = f'\"\"\"{desc}\"\"\"'\n\n        tp_fields: List[ClassField] = []\n        for field in ty.fields:\n            tp = parse_multiple_types(field.types)\n            field_name = escape_hard_keywords(field.name)\n            absolute_path = AbsolutePath(f\"{ty_name}.{field_name}\")\n\n            if absolute_path in config.renames:\n                field_name = config.renames[absolute_path]\n\n            if absolute_path in config.enums.overrides:\n                override_tp = config.enums.overrides[absolute_path]\n                tp = override_tp\n\n            if field.required:\n                tp_fields.append(ClassField(field_name, tp))\n            else:\n                tp_fields.append(\n                    ClassField(\n                        escape_hard_keywords(field_name),\n                        f\"Optional[{tp}]\",\n                        \"None\",\n                    )\n                )\n        class_ = Class(ty_name, [], tp_fields)\n        schemas.append(\n            Decorate(\n                \"dataclass(slots=True)\",\n                class_,\n            )\n        )\n\n    return generate(*schemas)", ""]}
{"filename": "misc/code_generator/__init__.py", "chunked_list": [""]}
{"filename": "misc/code_generator/helpers.py", "chunked_list": ["from dataclasses import dataclass, field\nfrom typing import Sequence, Optional, Protocol, TypeVar\n\nT = TypeVar(\"T\")\n\n\nclass GenerationHelper(Protocol):\n    def generate(self, indent: int, /) -> str:\n        raise NotImplementedError\n", "\n\n@dataclass\nclass SelfArg:\n    def generate(self, level: int, /) -> str:\n        return f\"{gen_indent(level)}self\"\n\n\n@dataclass\nclass FunctionArgument:\n    name: str\n    hint: str\n    default: Optional[str] = None\n\n    def generate(self, level: int, /) -> str:\n        default = f\" = {self.default}\" if self.default is not None else \"\"\n        return f\"{gen_indent(level)}{self.name}: {self.hint}{default}\"", "@dataclass\nclass FunctionArgument:\n    name: str\n    hint: str\n    default: Optional[str] = None\n\n    def generate(self, level: int, /) -> str:\n        default = f\" = {self.default}\" if self.default is not None else \"\"\n        return f\"{gen_indent(level)}{self.name}: {self.hint}{default}\"\n", "\n\n@dataclass\nclass ClassField:\n    name: str\n    hint: Optional[str] = None\n    default: Optional[str] = None\n\n    def generate(self, level: int, /) -> str:\n        base = f\"{gen_indent(level)}{self.name}\"\n        if self.hint is not None:\n            base += f\": {self.hint}\"\n        if self.default is not None:\n            return base + f\" = {self.default}\"\n        return base", "\n\n@dataclass\nclass Pass:\n    def generate(self, level: int, /) -> str:\n        return f\"{gen_indent(level)}pass\"\n\n\n@dataclass\nclass Function:\n    name: str\n    args: Sequence[FunctionArgument | SelfArg]\n    body: GenerationHelper\n    return_hint: str\n\n    async_: bool = False\n\n    def generate(self, level: int, /) -> str:\n        indent = gen_indent(level)\n        asyncness = \"async \" if self.async_ else \"\"\n        args = \", \".join(arg.generate(0) for arg in self.args)\n        lines = [\n            f\"{indent}{asyncness}def {self.name}({args}) \"\n            f\"-> {self.return_hint}:\",\n            self.body.generate(level + 1),\n        ]\n\n        return \"\\n\".join(lines)", "@dataclass\nclass Function:\n    name: str\n    args: Sequence[FunctionArgument | SelfArg]\n    body: GenerationHelper\n    return_hint: str\n\n    async_: bool = False\n\n    def generate(self, level: int, /) -> str:\n        indent = gen_indent(level)\n        asyncness = \"async \" if self.async_ else \"\"\n        args = \", \".join(arg.generate(0) for arg in self.args)\n        lines = [\n            f\"{indent}{asyncness}def {self.name}({args}) \"\n            f\"-> {self.return_hint}:\",\n            self.body.generate(level + 1),\n        ]\n\n        return \"\\n\".join(lines)", "\n\n@dataclass\nclass Decorate:\n    expr: str\n    body: GenerationHelper\n\n    def generate(self, level: int, /) -> str:\n        return f\"{gen_indent(level)}@{self.expr}\\n\" + self.body.generate(\n            level\n        )", "\n\n@dataclass\nclass Class:\n    name: str\n\n    methods: Sequence[Function]\n    fields: Sequence[ClassField] = field(default_factory=list)\n\n    inherits: Optional[Sequence[str]] = None\n\n    def generate(self, level: int, /) -> str:\n        body_level = level + 1\n        base_ind = gen_indent(level)\n        indent = gen_indent(body_level)\n\n        if self.inherits is not None:\n            inherits = f\"({', '.join(self.inherits)})\"\n        else:\n            inherits = \"\"\n        out = [f\"{base_ind}class {self.name}{inherits}:\"]\n        out.extend(\n            f.generate(body_level)\n            for f in sorted(\n                self.fields, key=lambda f: f.default is not None\n            )\n        )\n        out.extend(m.generate(body_level) for m in self.methods)\n\n        if len(out) == 1:\n            out.append(f\"{indent}pass\")\n\n        return \"\\n\".join(out)", "\n\n@dataclass\nclass IndentedLines:\n    lines: Sequence[str]\n\n    def generate(self, level: int, /) -> str:\n        indent = gen_indent(level)\n        return \"\\n\".join(indent + line for line in self.lines)\n", "\n\n@dataclass\nclass Import:\n    package: str\n    only: Optional[str | Sequence[str]] = None\n\n    def generate(self, level: int, /) -> str:\n        indent = gen_indent(level)\n        if self.only is not None:\n            if isinstance(self.only, str):\n                return f\"{indent}from {self.package} import {self.only}\"\n            return (\n                f\"{indent}from {self.package} \"\n                f\"import ({', '.join(self.only)})\"\n            )\n        return f\"{indent}import {self.package}\"", "\n\ndef generate(*helpers: GenerationHelper, use_black: bool = True) -> str:\n    result = \"\\n\".join(helper.generate(0) for helper in helpers)\n    if use_black:\n        import black\n        from black.report import NothingChanged\n\n        mode = black.FileMode(line_length=75)\n        try:\n            result = black.format_file_contents(\n                result, fast=True, mode=mode\n            )\n        except NothingChanged:\n            pass\n    return result", "\n\ndef gen_indent(level: int) -> str:\n    return \"    \" * level\n"]}
