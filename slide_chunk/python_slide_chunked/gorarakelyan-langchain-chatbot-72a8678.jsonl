{"filename": "chatbot/setup.py", "chunked_list": ["import os\nfrom setuptools import setup, find_packages\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\n# Version\nversion_file = os.path.join(here, 'src', 'chatbot', 'VERSION')\nwith open(version_file) as vf:\n    __version__ = vf.read().strip()\n", "\n# Requirements\nwith open(os.path.join(here, 'requirements.txt'), 'r') as f:\n    requirements = f.read().splitlines()\n\n# Package info\nNAME = 'chatbot'\nDESCRIPTION = 'LangChain-based ChatBot'\nVERSION = __version__\nREQUIRES_PYTHON = '>=3.7.0'", "VERSION = __version__\nREQUIRES_PYTHON = '>=3.7.0'\n\nsetup(\n    name=NAME,\n    version=VERSION,\n    description=DESCRIPTION,\n    python_requires=REQUIRES_PYTHON,\n    install_requires=requirements,\n    packages=find_packages(\"src\"),", "    install_requires=requirements,\n    packages=find_packages(\"src\"),\n    package_dir={\"\": \"src\"},\n    zip_safe=False,\n    entry_points={\n        'console_scripts': [\n            'chatbot=chatbot.cli.cli:entrypoint',\n        ],\n    },\n)", "    },\n)\n"]}
{"filename": "chatbot/src/chatbot/__init__.py", "chunked_list": [""]}
{"filename": "chatbot/src/chatbot/chatbot/chatbot.py", "chunked_list": ["import time\n\nfrom langchain.agents import Tool\nfrom langchain.agents import AgentType\nfrom langchain.memory import ConversationBufferMemory\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.utilities import SerpAPIWrapper\nfrom langchain.agents import initialize_agent\n\nfrom aim import Repo", "\nfrom aim import Repo\nfrom chatbot.chatbot.callback import AimCallbackHandler\nfrom chatbot_logger import Experiment, Release\nfrom chatbot.chatbot.utils import (\n    get_version,\n    get_user,\n)\n\n\ndef chatbot(serpapi_key, openai_key, dev_mode):\n    # Configs\n    model_name = 'gpt-3.5-turbo'\n    username = get_user()\n    version = get_version()\n\n    # Init experiment and release\n    repo = Repo.default()\n    try:\n        release = repo.containers(f'c.version == \"{version}\"', Release).first()\n    except:\n        release = Release()\n        release[...] = {\n            'version': version,\n            'time': time.time(),\n        }\n\n    experiment = None\n    if dev_mode:\n        experiment = Experiment()\n        experiment['release'] = release.hash\n        experiment['version'] = version\n        experiment['started'] = time.time()\n\n    # ChatBot implementation\n    memory = ConversationBufferMemory(memory_key=\"chat_history\")\n    if experiment is not None:\n        experiment['memory'] = memory.__dict__\n\n    search = SerpAPIWrapper(serpapi_api_key=serpapi_key)\n    tools = [\n        Tool(\n            name = \"Search\",\n            func=search.run,\n            description=\"useful for when you need to answer questions about current events or the current state of the world\"\n        ),\n    ]\n    if experiment is not None:\n        experiment['tools'] = [tool.__dict__ for tool in tools]\n\n    llm = ChatOpenAI(temperature=0, openai_api_key=openai_key, model_name=model_name)\n    if experiment is not None:\n        experiment['llm'] = llm.__dict__\n\n    agent_chain = initialize_agent(\n        tools, llm,\n        agent=AgentType.CONVERSATIONAL_REACT_DESCRIPTION,\n        verbose=True,\n        memory=memory,\n        handle_parsing_errors=\"Check your output and make sure it conforms!\"\n    )\n    if experiment is not None:\n        experiment['agent'] = agent_chain.__dict__\n\n    # Init the callback\n    aim_cb = AimCallbackHandler(username, dev_mode, experiment)\n    aim_cb.session[...] = {\n        'chatbot_version': version,\n        'model': model_name,\n        'username': username,\n        'started': time.time(),\n        'available_tools': [{ 'name': tool.name, 'description': tool.description } for tool in tools],\n        'experiment': experiment.hash if experiment else None,\n        'release': release.hash,\n    }\n\n    # Run the bot\n    while True:\n        msg = input('Message:\\n')\n        response = agent_chain.run(input=msg, callbacks=[aim_cb])", "\n\ndef chatbot(serpapi_key, openai_key, dev_mode):\n    # Configs\n    model_name = 'gpt-3.5-turbo'\n    username = get_user()\n    version = get_version()\n\n    # Init experiment and release\n    repo = Repo.default()\n    try:\n        release = repo.containers(f'c.version == \"{version}\"', Release).first()\n    except:\n        release = Release()\n        release[...] = {\n            'version': version,\n            'time': time.time(),\n        }\n\n    experiment = None\n    if dev_mode:\n        experiment = Experiment()\n        experiment['release'] = release.hash\n        experiment['version'] = version\n        experiment['started'] = time.time()\n\n    # ChatBot implementation\n    memory = ConversationBufferMemory(memory_key=\"chat_history\")\n    if experiment is not None:\n        experiment['memory'] = memory.__dict__\n\n    search = SerpAPIWrapper(serpapi_api_key=serpapi_key)\n    tools = [\n        Tool(\n            name = \"Search\",\n            func=search.run,\n            description=\"useful for when you need to answer questions about current events or the current state of the world\"\n        ),\n    ]\n    if experiment is not None:\n        experiment['tools'] = [tool.__dict__ for tool in tools]\n\n    llm = ChatOpenAI(temperature=0, openai_api_key=openai_key, model_name=model_name)\n    if experiment is not None:\n        experiment['llm'] = llm.__dict__\n\n    agent_chain = initialize_agent(\n        tools, llm,\n        agent=AgentType.CONVERSATIONAL_REACT_DESCRIPTION,\n        verbose=True,\n        memory=memory,\n        handle_parsing_errors=\"Check your output and make sure it conforms!\"\n    )\n    if experiment is not None:\n        experiment['agent'] = agent_chain.__dict__\n\n    # Init the callback\n    aim_cb = AimCallbackHandler(username, dev_mode, experiment)\n    aim_cb.session[...] = {\n        'chatbot_version': version,\n        'model': model_name,\n        'username': username,\n        'started': time.time(),\n        'available_tools': [{ 'name': tool.name, 'description': tool.description } for tool in tools],\n        'experiment': experiment.hash if experiment else None,\n        'release': release.hash,\n    }\n\n    # Run the bot\n    while True:\n        msg = input('Message:\\n')\n        response = agent_chain.run(input=msg, callbacks=[aim_cb])", "        # try:\n        #     response = agent_chain.run(input=msg, callbacks=[aim_cb])\n        # except ValueError as e:\n        #     response = str(e)\n        #     if not response.startswith(\"Could not parse LLM output: `\"):\n        #         raise e\n        # response = response.removeprefix(\"Could not parse LLM output: `\").removesuffix(\"`\")\n"]}
{"filename": "chatbot/src/chatbot/chatbot/__init__.py", "chunked_list": ["from chatbot.chatbot.chatbot import chatbot\n"]}
{"filename": "chatbot/src/chatbot/chatbot/utils.py", "chunked_list": ["import os\nimport random\n\n\ndef get_version():\n    here = os.path.abspath(os.path.dirname(__file__))\n    version_file = os.path.join(here, '..', 'VERSION')\n    with open(version_file) as vf:\n        __version__ = vf.read().strip()\n    return __version__", "\n\ndef get_user():\n    usernames = ['JamesThompson', 'LisaHamilton', 'RobertFitzgerald', 'MariaGonzalez', 'DavidMorrison']\n    username = random.choice(usernames)\n    return username\n"]}
{"filename": "chatbot/src/chatbot/chatbot/callback.py", "chunked_list": ["from copy import deepcopy\nfrom typing import Any, Dict, List\n\nfrom langchain.callbacks.base import BaseCallbackHandler\nfrom langchain.schema import AgentAction, AgentFinish, LLMResult\n\nfrom aim import Repo\nfrom chatbot_logger import (\n    Session, SessionDev, SessionProd,\n    MessagesSequence, Message,", "    Session, SessionDev, SessionProd,\n    MessagesSequence, Message,\n    UserActivity, UserActions, UserAction,\n)\nfrom aimstack.asp import Metric\n\n\nclass AimCallbackHandler(BaseCallbackHandler):\n    def __init__(\n            self,\n            username,\n            dev_mode,\n            experiment,\n    ) -> None:\n        \"\"\"Initialize callback handler.\"\"\"\n\n        super().__init__()\n\n        self.repo = Repo.default()\n        self.session = None\n        self.messages = None\n        self.user_activity = None\n        self.user_actions = None\n        self.experiment = experiment\n        self.username = username\n        self.dev_mode = dev_mode\n\n        self.tokens_usage_metric = None\n        self.tokens_usage_input = None\n        self.tokens_usage_output = None\n        self.tokens_usage = None\n        self.used_tools = set()\n\n        self.start_inp = None\n        self.end_out = None\n        self.agent_actions = []\n\n        self.setup()\n\n    def setup(self, **kwargs: Any) -> None:\n        if self.session is not None:\n            return\n\n        if self.dev_mode:\n            self.session = SessionDev()\n        else:\n            self.session = SessionProd()\n\n        self.messages = MessagesSequence(self.session, name='messages', context={})\n        self.tokens_usage_input = Metric(self.session, name='token-usage-input', context={})\n        self.tokens_usage_output = Metric(self.session, name='token-usage-output', context={})\n        self.tokens_usage = Metric(self.session, name='token-usage', context={})\n\n        for cont in self.repo.containers(None, UserActivity):\n            if cont['username'] == self.username:\n                ua = cont\n                for seq in ua.sequences:\n                    user_actions = seq\n                    break\n                else:\n                    user_actions = UserActions(ua, name='user-actions', context={})\n                break\n        else:\n            ua = UserActivity()\n            ua['username'] = self.username\n            user_actions = UserActions(ua, name='user-actions', context={})\n\n        self.user_activity = ua\n        self.user_actions = user_actions\n\n    def on_llm_start(\n            self, serialized: Dict[str, Any], prompts: List[str], **kwargs: Any\n    ) -> None:\n        \"\"\"Run when LLM starts.\"\"\"\n        # print('LLM START')\n        res = deepcopy(prompts)\n        # print(res)\n\n    def on_llm_end(self, response: LLMResult, **kwargs: Any) -> None:\n        # print('LLM END')\n        result = deepcopy(response)\n        # print(result)\n        self.tokens_usage_input.track(result.llm_output['token_usage']['prompt_tokens'])\n        self.tokens_usage_output.track(result.llm_output['token_usage']['completion_tokens'])\n        self.tokens_usage.track(result.llm_output['token_usage']['total_tokens'])\n\n        # generated = [\n        #     aim.Text(generation.text)\n        #     for generations in result.generations\n        #     for generation in generations\n        # ]\n\n    def on_chain_start(\n            self, serialized: Dict[str, Any], inputs: Dict[str, Any], **kwargs: Any\n    ) -> None:\n        # print('CHAIN START')\n        inputs_res = deepcopy(inputs)\n        self.start_inp = inputs_res['input']\n        # print(inputs_res)\n\n    def on_chain_end(self, outputs: Dict[str, Any], **kwargs: Any) -> None:\n        # print('CHAIN END')\n        outputs_res = deepcopy(outputs)\n        # print(outputs_res)\n\n    def on_tool_start(\n            self, serialized: Dict[str, Any], input_str: str, **kwargs: Any\n    ) -> None:\n        # print('TOOL START', kwargs)\n        # print(input_str)\n        self.agent_actions.append({\n            'type': 'tool-start',\n            'input': input_str,\n        })\n\n    def on_tool_end(self, output: str, **kwargs: Any) -> None:\n        # print('TOOL END', kwargs)\n        # print(output)\n        self.agent_actions.append({\n            'type': 'tool-end',\n            'input': output,\n        })\n        self.used_tools.add(kwargs.get('name'))\n        self.session.used_tools = list(self.used_tools)\n\n\n    def on_agent_action(self, action: AgentAction, **kwargs: Any) -> Any:\n        # print('AGENT ACTION')\n        # print(action)\n        self.agent_actions.append({\n            'type': 'agent-action',\n            'tool': action.tool,\n            'tool_input': action.tool_input,\n        })\n\n    def on_agent_finish(\n            self,\n            finish: AgentFinish,\n            **kwargs: Any,\n    ) -> Any:\n        \"\"\"Run on agent end.\"\"\"\n        # print('AGENT FINISH')\n        # print(finish)\n        self.end_out = finish.return_values['output']\n        self.messages.track(Message(self.start_inp, self.end_out, self.agent_actions))\n        self.start_inp = None\n        self.end_out = None\n        self.agent_actions = []", ""]}
{"filename": "chatbot/src/chatbot/cli/__init__.py", "chunked_list": [""]}
{"filename": "chatbot/src/chatbot/cli/cli.py", "chunked_list": ["import click\nimport os\nfrom dotenv import dotenv_values\n\nfrom chatbot.chatbot import chatbot\n\n\n@click.group()\ndef entrypoint():\n    pass", "def entrypoint():\n    pass\n\n\n@entrypoint.command\n@click.option('--dev', is_flag=True, default=False)\ndef run(dev):\n    # Load config\n    here = os.path.abspath(os.path.dirname(__file__))\n    config_file_path = os.path.abspath(os.path.join(here, '..', '..', '..', '.env'))\n    config = dotenv_values(config_file_path)\n\n    # Run the bot\n    chatbot(\n        serpapi_key=config['serpapi_key'],\n        openai_key=config['openai_key'],\n        dev_mode=dev\n    )", ""]}
{"filename": "chatbot_logger/setup.py", "chunked_list": ["import os\nfrom setuptools import setup, find_packages\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\n# Requirements\nwith open(os.path.join(here, 'requirements.txt'), 'r') as f:\n    requirements = f.read().splitlines()\n\n# Package info", "\n# Package info\nNAME = 'chatbot_logger'\nDESCRIPTION = 'A generic logger for chatbots'\nVERSION = '0.1.0'\nREQUIRES_PYTHON = '>=3.7.0'\n\nsetup(\n    name=NAME,\n    version=VERSION,", "    name=NAME,\n    version=VERSION,\n    description=DESCRIPTION,\n    python_requires=REQUIRES_PYTHON,\n    install_requires=requirements,\n    packages=find_packages(\"src\"),\n    package_dir={\"\": \"src\"},\n    zip_safe=False\n)\n", ")\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/__init__.py", "chunked_list": ["__aim_boards__ = 'boards'\n\nfrom chatbot_logger.logging.chat import *\nfrom chatbot_logger.logging.analytics import *\n\n__all__ = [\n    'Session', 'SessionProd', 'SessionDev',\n    'Experiment', 'Release',\n    'MessagesSequence', 'UserActivity', 'UserActions',\n]", "    'MessagesSequence', 'UserActivity', 'UserActions',\n]\n\n__aim_types__ = [\n    Session, SessionProd, SessionDev,\n    Experiment, Release,\n    MessagesSequence, UserActivity, UserActions,\n]\n\nfor aim_type in __aim_types__:\n    setattr(aim_type, '__aim_package__', 'chatbot_logger')", "\nfor aim_type in __aim_types__:\n    setattr(aim_type, '__aim_package__', 'chatbot_logger')\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/boards/analytics.py", "chunked_list": ["from datetime import datetime\nfrom collections import Counter\n\nfrom chatbot_logger import UserActivity, SessionProd, UserActions\n\n\n##################\n# Utils\n##################\n\ndef get_user(username):\n    sessions = UserActivity.filter(f'c.username == \"{username}\"')\n    if sessions and len(sessions):\n        return sessions[0]\n    return None", "##################\n\ndef get_user(username):\n    sessions = UserActivity.filter(f'c.username == \"{username}\"')\n    if sessions and len(sessions):\n        return sessions[0]\n    return None\n\ndef get_users(query = '', param = None):\n    sessions = UserActivity.filter(query)\n    sessions = sorted(sessions, key=lambda sess: sess['params'].get('username') or '', reverse=False)\n    if param is not None:\n        return [session.get(param) or session['params'].get(param) for session in sessions]\n    return sessions", "def get_users(query = '', param = None):\n    sessions = UserActivity.filter(query)\n    sessions = sorted(sessions, key=lambda sess: sess['params'].get('username') or '', reverse=False)\n    if param is not None:\n        return [session.get(param) or session['params'].get(param) for session in sessions]\n    return sessions\n\ndef daily_count(unix_time_array):\n    # Convert the array to datetime\n    datetime_array = [datetime.fromtimestamp(unix_time).date() for unix_time in unix_time_array]\n\n    # Count occurrences per day\n    counter = Counter(datetime_array)\n\n    # Build list of tuples for output\n    return {\n        'date': [date.strftime(\"%Y-%m-%d %H:%M:%S\") for date, count in sorted(counter.items())],\n        'count': [count for date, count in sorted(counter.items())],\n    }", "\ndef hourly_count(unix_time_array):\n    # Convert the array to datetime\n    datetime_array = [datetime.fromtimestamp(unix_time).replace(minute=0, second=0) for unix_time in unix_time_array]\n\n    # Count occurrences per hour\n    counter = Counter(datetime_array)\n\n    # Build list of tuples for output\n    return {\n        'date': [date.strftime(\"%Y-%m-%d %H:%M:%S\") for date, count in sorted(counter.items())],\n        'count': [count for date, count in sorted(counter.items())],\n    }", "\n##################\n\ndef overview(username):\n    if not username:\n        ui.text('Pick a user')\n        return\n\n    user = get_user(username)\n    if not user:\n        ui.text('User not found')\n        return\n\n    ui.header(f'User Activity: \"{user[\"params\"].get(\"username\")}\"')", "    # ui.json(user)\n\ndef user_sessions(username):\n    user = get_user(username)\n    if not user:\n        return\n\n    all_user_sessions = SessionProd.filter(f'c.username == \"{username}\"')\n    ui.text(f'Sessions count: {len(all_user_sessions)}')\n\n    # ui.json(all_user_sessions)\n    timestamps = [session['params'].get('started') or 0 for session in all_user_sessions]\n    if not timestamps:\n        return\n\n    ui.text('Breakdown by:')\n    breakdown_type = ui.toggle_button(left_value='Days', right_value='Hours')\n\n    if breakdown_type == 'Hours':\n        data = hourly_count(timestamps)\n    else:\n        data = daily_count(timestamps)\n\n    ui.text('Visualize via:')\n    vis_tye = ui.toggle_button(left_value='Table', right_value='Chart')\n\n    if vis_tye == 'Table':\n        ui.table(data)\n    else:\n        d = []\n        for i in zip(data['date'], data['count']):\n            d.append({\n                'date': i[0],\n                'count': i[1],\n                'name': str(i[0]),\n            })\n        ui.bar_chart(data=d, x='date', y='count', color=['name'])", "\n##################\n# Page\n##################\n\ntry:\n    username = state['analytics.py']['username']\nexcept:\n    username = ''\n", "\nusername = ui.select(options=get_users('', 'username'), value=username)\n\noverview(username)\nuser_sessions(username)\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/boards/production.py", "chunked_list": ["from datetime import datetime\nimport json\n\nfrom chatbot_logger import SessionProd, MessagesSequence\n\n\n##################\n# Utils\n##################\n\ndef get_sessions(query = '', param = None):\n    sessions = SessionProd.filter(query)\n    sessions = sorted(sessions, key=lambda sess: sess['params'].get('started') or 0, reverse=True)\n    if param is not None:\n        return [session.get(param) for session in sessions]\n    return sessions", "##################\n\ndef get_sessions(query = '', param = None):\n    sessions = SessionProd.filter(query)\n    sessions = sorted(sessions, key=lambda sess: sess['params'].get('started') or 0, reverse=True)\n    if param is not None:\n        return [session.get(param) for session in sessions]\n    return sessions\n\n##################", "\n##################\n\ndef sessions_overview():\n    search = ui.form('Search')\n    version = search.text_input('')\n    query = ''\n    if version:\n        query = f'str(c.chatbot_version).startswith(\"{version}\")'\n\n    sessions = get_sessions(query)\n\n    table = ui.table({\n        'session': [sess['hash'] for sess in sessions],\n        'version': [sess['params'].get('chatbot_version') for sess in sessions],\n        'model_name': [sess['params'].get('model') for sess in sessions],\n        'available_tools': [(str([tool['name'] for tool in sess['params']['available_tools']])) if sess['params'].get('available_tools') else '-' for sess in sessions],\n        'username': [sess['params'].get('username') for sess in sessions],\n        'time': [sess['params'].get('started') for sess in sessions],\n        'open': [sess['hash'] for sess in sessions],\n        'release': [sess['params'].get('chatbot_version') for sess in sessions],\n    }, {\n        'username': lambda x: x if x is not None else '-',\n        'time': lambda x: ui.text(datetime.fromtimestamp(x).strftime(\"%Y-%m-%d %H:%M:%S\") if x is not None else '-'),\n        'open': lambda x: ui.board_link('sessions.py', 'Open', state={'session_hash': x}),\n        'release': lambda x: ui.board_link('development/release.py', 'Release Page', state={'version': x}),\n    })\n\n    if table.focused_row:\n        history(table.focused_row['session'], table.focused_row['version'])", "\ndef history(session_hash, version):\n    if not session_hash:\n        return\n\n    ui.subheader(f'Session \"{session_hash}\"')\n\n    qa_sequences = MessagesSequence.filter(f's.name == \"messages\" and c.hash == \"{session_hash}\"')\n    qa_sequence = None\n    if qa_sequences and len(qa_sequences):\n        qa_sequence = qa_sequences[0]\n\n    if qa_sequence is not None:\n        ui.text(f'Session history:')\n        values = qa_sequence['values']\n        history_table = ui.table({\n            'question': [r['question'] for r in values],\n            'answer': [r['answer'] for r in values],\n            'index': [step for (step, _) in enumerate(values)],\n        })\n\n        if history_table.focused_row:\n            ui.text('Agent actions:')\n            step = history_table.focused_row['index']\n            ui.json(values[step])\n    else:\n        ui.text('No message history')", "\n##################\n# Page\n##################\n\nui.header('Production Monitoring')\n\nsessions_overview()\n", ""]}
{"filename": "chatbot_logger/src/chatbot_logger/boards/sessions.py", "chunked_list": ["import json\n\nfrom chatbot_logger import Session, MessagesSequence\nfrom asp import Metric\n\n\n##################\n# Utils\n##################\n\ndef get_session(session_hash):\n    sessions = Session.filter(f'c.hash == \"{session_hash}\"')\n    if sessions and len(sessions):\n        return sessions[0]\n    return None", "##################\n\ndef get_session(session_hash):\n    sessions = Session.filter(f'c.hash == \"{session_hash}\"')\n    if sessions and len(sessions):\n        return sessions[0]\n    return None\n\ndef get_sessions(query = '', param = None):\n    sessions = Session.filter(query)\n    sessions = sorted(sessions, key=lambda sess: sess['params'].get('started') or 0, reverse=True)\n    if param is not None:\n        return [session.get(param) for session in sessions]\n    return sessions", "def get_sessions(query = '', param = None):\n    sessions = Session.filter(query)\n    sessions = sorted(sessions, key=lambda sess: sess['params'].get('started') or 0, reverse=True)\n    if param is not None:\n        return [session.get(param) for session in sessions]\n    return sessions\n\n##################\n\ndef overview(session_hash):\n    if not session_hash:\n        ui.text('Pick a session')\n        return\n\n    session = get_session(session_hash)\n    if session is None:\n        ui.text('Session not found')\n        return\n\n    ui.header(f'Session \"{session_hash}\"')\n    ui.subheader('Overview')\n\n    ui.table({\n        'Params': [\n            'Model',\n            'Used tools',\n        ],\n        'Values': [\n            session['params'].get('model'),\n            json.dumps(session['params'].get('used_tools')),\n        ],\n    })", "\ndef overview(session_hash):\n    if not session_hash:\n        ui.text('Pick a session')\n        return\n\n    session = get_session(session_hash)\n    if session is None:\n        ui.text('Session not found')\n        return\n\n    ui.header(f'Session \"{session_hash}\"')\n    ui.subheader('Overview')\n\n    ui.table({\n        'Params': [\n            'Model',\n            'Used tools',\n        ],\n        'Values': [\n            session['params'].get('model'),\n            json.dumps(session['params'].get('used_tools')),\n        ],\n    })", "\ndef history(session_hash):\n    if not session_hash:\n        return\n\n    ui.subheader('History')\n\n    qa_sequences = MessagesSequence.filter(f's.name == \"messages\" and c.hash == \"{session_hash}\"')\n    qa_sequence = None\n    if qa_sequences and len(qa_sequences):\n        qa_sequence = qa_sequences[0]\n\n    if qa_sequence is not None:\n        values = qa_sequence['values']\n        history_table = ui.table({\n            'question': [r['question'] for r in values],\n            'answer': [r['answer'] for r in values],\n            'index': [step for (step, _) in enumerate(values)],\n        })\n\n        if history_table.focused_row:\n            ui.subheader('Agent actions')\n            step = history_table.focused_row['index']\n            ui.json(values[step])\n    else:\n        ui.text('No message history')", "\ndef session_cost(session_hash):\n    if not session_hash:\n        return\n\n    ui.subheader('Tokens usage')\n\n    # Calculate cost\n    metrics = Metric.filter(f'c.hash == \"{session_hash}\"')\n\n    input_tokens = 0\n    output_tokens = 0\n    for metric in metrics:\n        if metric['name'] == 'token-usage-input':\n            input_tokens = sum(metric['values'])\n        if metric['name'] == 'token-usage-output':\n            output_tokens = sum(metric['values'])\n\n    input_price = input_tokens * 0.002 / 1000\n    output_price = output_tokens * 0.002 / 1000\n    total_price = input_price + output_price\n\n    ui.text(f'Total price: ${total_price}, input tokens: ${input_price}, output tokens: ${output_price}')\n    ui.text(f'Total count: {input_tokens+output_tokens}, input count: {input_tokens}, output count: {output_tokens}')\n\n    line_chart = ui.line_chart(metrics, x='steps', y='values')\n    line_chart.group('column', ['name'])", "\ndef user_info(session_hash):\n    if not session_hash:\n        return\n\n    session = get_session(session_hash)\n    if session is None:\n        return\n\n    ui.subheader('User')\n\n    username = session['params'].get('username')\n    if not username:\n        ui.text('No associated user')\n        return\n\n    ui.text(f'User: {username}')\n    ui.board_link('analytics.py', 'User page', state={\n        'username': username,\n    })", "\n##################\n# Page\n##################\n\ntry:\n    session_hash = state['sessions.py']['session_hash']\nexcept:\n    session_hash = ''\n", "\nsession_hash = ui.select(options=get_sessions('', 'hash'), value=session_hash)\n\noverview(session_hash)\nhistory(session_hash)\nsession_cost(session_hash)\nuser_info(session_hash)\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/boards/_main.py", "chunked_list": ["ui.header('ChatBot Logger')\n\nui.subheader('Production')\nui.board_link('production.py', 'Overview')\nui.board_link('analytics.py', 'User Page')\n\nui.subheader('Chat')\nui.board_link('sessions.py', 'Individual Session')\n\nui.subheader('Development')", "\nui.subheader('Development')\nui.board_link('development/_main.py', 'Overview')\nui.board_link('development/experiment.py', 'Experiments')\nui.board_link('development/release.py', 'Releases')\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/boards/development/experiment.py", "chunked_list": ["from datetime import datetime\nfrom chatbot_logger import Experiment\n\n\n##################\n# Utils\n##################\n\ndef get_experiments(query = '', param = None):\n    sessions = Experiment.filter(query)\n    sessions = sorted(sessions, key=lambda sess: sess['params'].get('started') or 0, reverse=True)\n    if param is not None:\n        return [session.get(param) for session in sessions]\n    return sessions", "def get_experiments(query = '', param = None):\n    sessions = Experiment.filter(query)\n    sessions = sorted(sessions, key=lambda sess: sess['params'].get('started') or 0, reverse=True)\n    if param is not None:\n        return [session.get(param) for session in sessions]\n    return sessions\n\ndef get_experiment(session_hash):\n    sessions = Experiment.filter(f'c.hash == \"{session_hash}\"')\n    if sessions and len(sessions):\n        return sessions[0]\n    return None", "\n##################\n\ndef experiment(exp_hash):\n    exp = get_experiment(exp_hash)\n    if not exp:\n        ui.text('Pick an experiment')\n        return\n\n    ui.header(f'Experiment \"{exp_hash}\"')\n\n    overview, memory, llm, tools, agent = ui.tabs(['Overview', 'Memory', 'LLM', 'Tools', 'Agent'])\n\n    overview.json({\n        'release': exp['params'].get('release'),\n        'version': exp['params'].get('version'),\n        'started': datetime.fromtimestamp(exp['params'].get('started')).strftime(\"%Y-%m-%d %H:%M:%S\") if exp['params'].get('started') else '-',\n    })\n\n    memory.json(exp['params'].get('memory'))\n    llm.json(exp['params'].get('llm'))\n    tools.json(exp['params'].get('tools'))\n    agent.json(exp['params'].get('agent'))", "\n##################\n# Page\n##################\n\ntry:\n    exp_hash = state['development/experiment.py']['experiment_hash']\nexcept:\n    exp_hash = ''\n", "\nexp_hash = ui.select(options=get_experiments('', 'hash'), value=exp_hash)\n\nexperiment(exp_hash)\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/boards/development/release.py", "chunked_list": ["from datetime import datetime\nfrom chatbot_logger import Release, Experiment\n\n\n##################\n# Utils\n##################\n\ndef get_releases(query = '', param = None):\n    sessions = Release.filter(query)\n    sessions = sorted(sessions, key=lambda sess: (sess['params'].get('version') or '0.0.0').split('.'), reverse=True)\n    if param is not None:\n        return [session.get(param) or session['params'].get(param) for session in sessions]\n    return sessions", "def get_releases(query = '', param = None):\n    sessions = Release.filter(query)\n    sessions = sorted(sessions, key=lambda sess: (sess['params'].get('version') or '0.0.0').split('.'), reverse=True)\n    if param is not None:\n        return [session.get(param) or session['params'].get(param) for session in sessions]\n    return sessions\n\ndef get_release(release_version):\n    sessions = Release.filter(f'c.version == \"{release_version}\"')\n    if sessions and len(sessions):\n        return sessions[0]\n    return None", "\ndef get_last_experiment(release_version):\n    experiments = Experiment.filter(f'c.version == \"{release_version}\"')\n    last = None\n    for experiment in experiments:\n        if last is None or not last['params'].get('started'):\n            last = experiment\n            continue\n        if experiment['params'].get('started') and last['params']['started'] < experiment['params']['started']:\n            last = experiment\n    return last", "\n##################\n\ndef experiment(release_version):\n    if not release_version:\n        return\n\n    exp = get_last_experiment(release_version)\n    if not exp:\n        ui.text('No experiment')\n        return\n\n    ui.subheader('Experiment')\n\n    overview, memory, llm, tools, agent = ui.tabs(['Overview', 'Memory', 'LLM', 'Tools', 'Agent'])\n\n    overview.json({\n        'release': exp['params'].get('release'),\n        'version': exp['params'].get('version'),\n        'started': datetime.fromtimestamp(exp['params'].get('started')).strftime(\"%Y-%m-%d %H:%M:%S\") if exp['params'].get('started') else '-',\n    })\n\n    memory.json(exp['params'].get('memory'))\n    llm.json(exp['params'].get('llm'))\n    tools.json(exp['params'].get('tools'))\n    agent.json(exp['params'].get('agent'))", "\ndef release(release_version):\n    release = get_release(release_version)\n    if not release:\n        ui.text('Pick a release')\n        return\n\n    ui.subheader('Release')\n    ui.json(release)\n", "\n##################\n# Page\n##################\n\ntry:\n    release_version = state['development/release.py']['version']\nexcept:\n    release_version = ''\n", "\nrelease_version = ui.select(options=get_releases('', 'version'), value=release_version)\n\nrelease(release_version)\nexperiment(release_version)\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/boards/development/_overview.py", "chunked_list": ["import json\nfrom datetime import datetime\nfrom chatbot_logger import Experiment, SessionDev, Release\n\n\n##################\n# Utils\n##################\n\ndef get_experiment(session_hash):\n    sessions = Experiment.filter(f'c.hash == \"{session_hash}\"')\n    if sessions and len(sessions):\n        return sessions[0]\n    return None", "\ndef get_experiment(session_hash):\n    sessions = Experiment.filter(f'c.hash == \"{session_hash}\"')\n    if sessions and len(sessions):\n        return sessions[0]\n    return None\n\ndef get_experiments(query = '', param = None):\n    sessions = Experiment.filter(query)\n    sessions = sorted(sessions, key=lambda sess: sess['params'].get('started') or 0, reverse=True)\n    if param is not None:\n        return [session.get(param) for session in sessions]\n    return sessions", "\ndef get_sessions(query = '', param = None):\n    sessions = SessionDev.filter(query)\n    sessions = sorted(sessions, key=lambda sess: sess['params'].get('started') or 0, reverse=True)\n    if param is not None:\n        return [session.get(param) for session in sessions]\n    return sessions\n\ndef get_releases(query = '', param = None):\n    sessions = Release.filter(query)\n    sessions = sorted(sessions, key=lambda sess: (sess['params'].get('version') or '0.0.0').split('.'), reverse=True)\n    if param is not None:\n        return [session.get(param) for session in sessions]\n    return sessions", "def get_releases(query = '', param = None):\n    sessions = Release.filter(query)\n    sessions = sorted(sessions, key=lambda sess: (sess['params'].get('version') or '0.0.0').split('.'), reverse=True)\n    if param is not None:\n        return [session.get(param) for session in sessions]\n    return sessions\n\n##################\n\ndef experiments():\n    ui.subheader('Experiments')\n    experiments = get_experiments()\n    if not experiments or not len(experiments):\n        ui.text('No experiments yet')\n        return\n\n    table = ui.table({\n        'experiment': [sess['hash'] for sess in experiments],\n        'version': [sess['params'].get('version') for sess in experiments],\n        'time': [sess['params'].get('started') for sess in experiments],\n        'open': [sess['hash'] for sess in experiments],\n    }, {\n        'time': lambda x: ui.text(datetime.fromtimestamp(x).strftime(\"%Y-%m-%d %H:%M:%S\") if x is not None else '-'),\n        'open': lambda x: ui.board_link('development/experiment.py', 'Experiment Page', state={'experiment_hash': x}),\n    })", "\ndef experiments():\n    ui.subheader('Experiments')\n    experiments = get_experiments()\n    if not experiments or not len(experiments):\n        ui.text('No experiments yet')\n        return\n\n    table = ui.table({\n        'experiment': [sess['hash'] for sess in experiments],\n        'version': [sess['params'].get('version') for sess in experiments],\n        'time': [sess['params'].get('started') for sess in experiments],\n        'open': [sess['hash'] for sess in experiments],\n    }, {\n        'time': lambda x: ui.text(datetime.fromtimestamp(x).strftime(\"%Y-%m-%d %H:%M:%S\") if x is not None else '-'),\n        'open': lambda x: ui.board_link('development/experiment.py', 'Experiment Page', state={'experiment_hash': x}),\n    })", "\ndef sessions_overview():\n    sessions = get_sessions()\n\n    if not sessions or not len(sessions):\n        return\n\n    ui.subheader('Dev Sessions')\n\n    table = ui.table({\n        'session': [sess['hash'] for sess in sessions],\n        'experiment': [sess['params'].get('experiment') for sess in sessions],\n        'version': [sess['params'].get('chatbot_version') for sess in sessions],\n        'model_name': [sess['params'].get('model') for sess in sessions],\n        'available_tools': [(str([tool['name'] for tool in sess['params']['available_tools']])) if sess['params'].get('available_tools') else '-' for sess in sessions],\n        'time': [sess['params'].get('started') for sess in sessions],\n        'open': [sess['hash'] for sess in sessions],\n        'release': [sess['params'].get('chatbot_version') for sess in sessions],\n    }, {\n        'time': lambda x: ui.text(datetime.fromtimestamp(x).strftime(\"%Y-%m-%d %H:%M:%S\") if x is not None else '-'),\n        'open': lambda x: ui.board_link('sessions.py', 'Open', state={'session_hash': x}),\n        'release': lambda x: ui.board_link('development/release.py', 'Release Page', state={'version': x}),\n    })", "\ndef releases():\n    releases = get_releases()\n\n    if not releases or not len(releases):\n        ui.text('No releases')\n        return\n\n    ui.subheader('Releases')\n\n    table = ui.table({\n        'release': [sess['hash'] for sess in releases],\n        'version': [sess['params'].get('version') for sess in releases],\n        'time': [sess['params'].get('started') for sess in releases],\n        'open': [sess['params'].get('version') for sess in releases],\n    }, {\n        'time': lambda x: ui.text(datetime.fromtimestamp(x).strftime(\"%Y-%m-%d %H:%M:%S\") if x is not None else '-'),\n        'open': lambda x: ui.board_link('development/release.py', 'Open', state={'version': x}),\n    })", "\n##################\n# Page\n##################\n\nui.header('Development')\n\nreleases()\nexperiments()\nsessions_overview()", "experiments()\nsessions_overview()\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/logging/analytics.py", "chunked_list": ["from aim import Container, Sequence, Object\n\n\n@Object.alias('aim_qa_logger.UserAction')\nclass UserAction(Object):\n    AIM_NAME = 'aim_qa_logger.UserAction'\n\n    def __init__(self, action_type: str):\n        super().__init__()\n\n        self.storage['action_type'] = action_type\n\n    @property\n    def action_type(self):\n        return self.storage['action_type']", "\n\nclass UserActions(Sequence[UserAction]):\n    pass\n\n\nclass UserActivity(Container):\n    pass\n", ""]}
{"filename": "chatbot_logger/src/chatbot_logger/logging/__init__.py", "chunked_list": [""]}
{"filename": "chatbot_logger/src/chatbot_logger/logging/chat.py", "chunked_list": ["from aim import Container, Sequence, Object\n\n\n@Object.alias('chatbot_logger.Message')\nclass Message(Object):\n    AIM_NAME = 'chatbot_logger.Message'\n\n    def __init__(self, question: str, answer: str, steps: list):\n        super().__init__()\n\n        self.storage['question'] = question\n        self.storage['answer'] = answer\n        self.storage['steps'] = steps\n\n    @property\n    def question(self):\n        return self.storage['question']\n\n    @property\n    def answer(self):\n        return self.storage['answer']\n\n    @property\n    def steps(self):\n        return self.storage['steps']\n\n    def __repr__(self):\n        return f'Q: \"{self.question}\" \\n A: \"{self.answer}\"'", "\n\nclass MessagesSequence(Sequence[Message]):\n    pass\n\n\nclass Session(Container):\n    pass\n\n\nclass SessionProd(Session):\n    pass", "\n\nclass SessionProd(Session):\n    pass\n\n\nclass SessionDev(Session):\n    pass\n\n\nclass Experiment(Container):\n    pass", "\n\nclass Experiment(Container):\n    pass\n\n\nclass Release(Container):\n    pass\n\n", "\n"]}
