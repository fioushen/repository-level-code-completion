{"filename": "tests/test_workers.py", "chunked_list": ["# Standard Library Imports\nfrom threading import Event\n\nfrom dramatiq.brokers.stub import StubBroker\n\n# Local Application Imports\nfrom async_dramatiq.worker import AsyncWorker\n\n\ndef test_async_worker(broker: StubBroker) -> None:\n    startup_event = Event()\n    async_worker = AsyncWorker(startup_event, broker)\n    async_worker.start()\n    startup_event.wait()  # Asyncio IO loop has started\n\n    assert async_worker.event_loop.is_running()\n\n    async_worker.stop()\n    async_worker.join()\n\n    assert not async_worker.event_loop.is_running()\n\n    async_worker.pause()\n    async_worker.resume()", "\ndef test_async_worker(broker: StubBroker) -> None:\n    startup_event = Event()\n    async_worker = AsyncWorker(startup_event, broker)\n    async_worker.start()\n    startup_event.wait()  # Asyncio IO loop has started\n\n    assert async_worker.event_loop.is_running()\n\n    async_worker.stop()\n    async_worker.join()\n\n    assert not async_worker.event_loop.is_running()\n\n    async_worker.pause()\n    async_worker.resume()", ""]}
{"filename": "tests/test_backends.py", "chunked_list": ["# Standard Library Imports\nimport os\nimport time\nfrom threading import Thread\n\nimport pytest\nfrom dramatiq import Message\nfrom dramatiq.actor import actor\nfrom dramatiq.results.backend import ResultMissing, ResultTimeout\n", "from dramatiq.results.backend import ResultMissing, ResultTimeout\n\n# Local Application Imports\nfrom async_dramatiq.backends import AsyncRedisBackend, AsyncStubBackend, set_backend\n\nREDIS_HOST = os.getenv(\"REDIS_HOST\", \"localhost\")\nREDIS_PORT = os.getenv(\"REDIS_PORT\", 6379)\n\n\ndef get_message() -> Message:\n    @actor(queue_name=\"test_queue\", store_results=True)\n    def my_func():\n        pass\n\n    return my_func.message()", "\ndef get_message() -> Message:\n    @actor(queue_name=\"test_queue\", store_results=True)\n    def my_func():\n        pass\n\n    return my_func.message()\n\n\nasync def assert_result(", "\nasync def assert_result(\n    backend: AsyncRedisBackend | AsyncStubBackend,\n    msg: Message,\n    result: str,\n    timeout: int = 3000,\n) -> None:\n    returned_result = await backend.get_result(msg, block=True, timeout=timeout)\n    assert returned_result == result\n", "    assert returned_result == result\n\n\ndef delayed_store(\n    backend: AsyncRedisBackend | AsyncStubBackend, msg: Message, result: str, ttl: int\n) -> None:\n    time.sleep(0.1)\n    backend.store_result(message=msg, result=result, ttl=ttl)\n\n", "\n\n@pytest.mark.parametrize(\n    \"backend\", [AsyncRedisBackend(host=REDIS_HOST, port=REDIS_PORT), AsyncStubBackend()]\n)\nasync def test_get_result_happy_path(\n    backend: AsyncRedisBackend | AsyncStubBackend,\n) -> None:\n    set_backend(backend)\n", "    set_backend(backend)\n\n    msg = get_message()\n    result = \"this is a result\"\n    backend.store_result(message=msg, result=result, ttl=100000)\n    returned_result = await backend.get_result(msg)\n    assert returned_result == result\n\n\n@pytest.mark.parametrize(", "\n@pytest.mark.parametrize(\n    \"backend\", [AsyncRedisBackend(host=REDIS_HOST, port=REDIS_PORT), AsyncStubBackend()]\n)\nasync def test_get_result_result_missing(\n    backend: AsyncRedisBackend | AsyncStubBackend,\n) -> None:\n    set_backend(backend)\n\n    msg = get_message()", "\n    msg = get_message()\n\n    with pytest.raises(ResultMissing):\n        await backend.get_result(msg)\n\n\n@pytest.mark.parametrize(\n    \"backend\", [AsyncRedisBackend(host=REDIS_HOST, port=REDIS_PORT), AsyncStubBackend()]\n)", "    \"backend\", [AsyncRedisBackend(host=REDIS_HOST, port=REDIS_PORT), AsyncStubBackend()]\n)\nasync def test_get_result_blocking_happy_path(\n    backend: AsyncRedisBackend | AsyncStubBackend,\n) -> None:\n    set_backend(backend)\n\n    msg = get_message()\n    result = \"this is a result\"\n", "    result = \"this is a result\"\n\n    t1 = Thread(target=delayed_store, args=[backend, msg, result, 5000])\n    t1.start()\n\n    await assert_result(backend, msg, result)\n\n    t1.join()\n\n", "\n\n@pytest.mark.parametrize(\n    \"backend\", [AsyncRedisBackend(host=REDIS_HOST, port=REDIS_PORT), AsyncStubBackend()]\n)\nasync def test_get_result_blocking_timeout(\n    backend: AsyncRedisBackend | AsyncStubBackend,\n) -> None:\n    set_backend(backend)\n", "    set_backend(backend)\n\n    msg = get_message()\n    result = \"this is a result\"\n\n    t1 = Thread(target=delayed_store, args=[backend, msg, result, 10000])\n    t1.start()\n\n    with pytest.raises(ResultTimeout):\n        await assert_result(backend, msg, result, 0)", "    with pytest.raises(ResultTimeout):\n        await assert_result(backend, msg, result, 0)\n\n    t1.join()\n"]}
{"filename": "tests/test_scheduler.py", "chunked_list": ["# Standard Library Imports\nfrom datetime import timedelta\n\nfrom apscheduler.triggers.cron import CronTrigger\nfrom apscheduler.triggers.interval import IntervalTrigger\n\n# Local Application Imports\nfrom async_dramatiq.scheduler import register_cron, register_interval\nfrom async_dramatiq.scheduler import scheduled_jobs\n", "from async_dramatiq.scheduler import scheduled_jobs\n\n\ndef test_register_jobs() -> None:\n    def test_func() -> None:\n        return None\n\n    crontab = \"* * * * *\"\n    register_cron(test_func, crontab)\n    assert isinstance(scheduled_jobs[-1].trigger, CronTrigger)\n    assert scheduled_jobs[-1].module_path == test_func.__module__\n    assert scheduled_jobs[-1].func_name == test_func.__name__", "\n\ndef test_register_interval() -> None:\n    def test_func() -> None:\n        return None\n\n    interval = timedelta(seconds=60)\n    register_interval(test_func, interval)\n    assert isinstance(scheduled_jobs[-1].trigger, IntervalTrigger)\n    assert scheduled_jobs[-1].module_path == test_func.__module__\n    assert scheduled_jobs[-1].func_name == test_func.__name__", ""]}
{"filename": "tests/test_actors.py", "chunked_list": ["# Standard Library Imports\nimport asyncio\nfrom datetime import timedelta\nfrom typing import Any, Callable, TypeVar\n\nimport pytest\nfrom apscheduler.triggers.cron import CronTrigger\nfrom apscheduler.triggers.interval import IntervalTrigger\nfrom dramatiq import Worker\n", "from dramatiq import Worker\n\n# Local Application Imports\nfrom async_dramatiq.actor import async_actor\nfrom async_dramatiq.backends import AsyncStubBackend, get_backend\nfrom async_dramatiq.scheduler import scheduled_jobs\n\nF = TypeVar(\"F\", bound=Callable[..., Any])\n\n\ndef test_async_actor() -> None:\n    scheduled_jobs_len = len(scheduled_jobs)\n\n    @async_actor(interval=timedelta(seconds=5))\n    def test_interval():\n        return None\n\n    @async_actor(crontab=\"* * * * *\")\n    def test_cron():\n        return None\n\n    @async_actor()\n    async def test_async():\n        return None\n\n    assert len(scheduled_jobs) == scheduled_jobs_len + 2\n    assert isinstance(scheduled_jobs[-1].trigger, CronTrigger)\n    assert scheduled_jobs[-1].module_path, test_cron.__module__\n    assert scheduled_jobs[-1].func_name, test_cron.__name__\n\n    assert isinstance(scheduled_jobs[-2].trigger, IntervalTrigger)\n    assert scheduled_jobs[-2].module_path, test_interval.__module__\n    assert scheduled_jobs[-2].func_name, test_interval.__name__", "\n\ndef test_async_actor() -> None:\n    scheduled_jobs_len = len(scheduled_jobs)\n\n    @async_actor(interval=timedelta(seconds=5))\n    def test_interval():\n        return None\n\n    @async_actor(crontab=\"* * * * *\")\n    def test_cron():\n        return None\n\n    @async_actor()\n    async def test_async():\n        return None\n\n    assert len(scheduled_jobs) == scheduled_jobs_len + 2\n    assert isinstance(scheduled_jobs[-1].trigger, CronTrigger)\n    assert scheduled_jobs[-1].module_path, test_cron.__module__\n    assert scheduled_jobs[-1].func_name, test_cron.__name__\n\n    assert isinstance(scheduled_jobs[-2].trigger, IntervalTrigger)\n    assert scheduled_jobs[-2].module_path, test_interval.__module__\n    assert scheduled_jobs[-2].func_name, test_interval.__name__", "\n\nasync def test_async_actor_func(event_loop: asyncio.BaseEventLoop) -> None:\n    result = \"generic result\"\n\n    @async_actor()\n    async def test_async():\n        return result\n\n    # Test generic run", "\n    # Test generic run\n    assert result == await test_async()\n\n\ndef test_async_actor_func_no_loop() -> None:\n    result = \"generic result\"\n\n    @async_actor()\n    async def test_async():\n        return result\n\n    # Test generic run\n    with pytest.raises(RuntimeError):\n        test_async()", "\n\nasync def test_async_actor_func_in_thread(\n    worker: Worker, async_stub_backend: AsyncStubBackend\n) -> None:\n    result = \"generic result\"\n\n    @async_actor(store_results=True)\n    async def test_async():\n        return result", "    async def test_async():\n        return result\n\n    # Setup actor event loop\n    loop = (w.event_loop for w in worker.workers if hasattr(w, \"event_loop\"))\n    test_async.event_loop = next(loop, None)\n\n    # Send actor to worker\n    msg = test_async.send()\n    worker.join()", "    msg = test_async.send()\n    worker.join()\n\n    return_result = await get_backend().get_result(msg, block=True)\n    assert return_result == result\n\n\nasync def test_sync_actor_func() -> None:\n    result = \"generic result\"\n", "    result = \"generic result\"\n\n    @async_actor()\n    def test_sync():\n        return result\n\n    assert result == test_sync()\n\n\ndef test_sync_actor_func_no_loop() -> None:\n    result = \"generic result\"\n\n    @async_actor()\n    def test_sync():\n        return result\n\n    assert result == test_sync()", "\ndef test_sync_actor_func_no_loop() -> None:\n    result = \"generic result\"\n\n    @async_actor()\n    def test_sync():\n        return result\n\n    assert result == test_sync()\n", "\n\nasync def test_sync_actor_func_in_thread(\n    worker: Worker, async_stub_backend: AsyncStubBackend\n) -> None:\n    result = \"generic result\"\n\n    @async_actor(store_results=True)\n    def test_async():\n        return result", "    def test_async():\n        return result\n\n    # Send actor to worker\n    msg = test_async.send()\n    worker.join()\n\n    return_result = await get_backend().get_result(msg, block=True)\n\n    assert return_result == result", "\n    assert return_result == result\n\n\nasync def test_async_request(\n    worker: Worker, async_stub_backend: AsyncStubBackend\n) -> None:\n    @async_actor(store_results=True)\n    async def test_async():\n        await asyncio.sleep(0.25)", "    async def test_async():\n        await asyncio.sleep(0.25)\n        return True\n\n    # Setup actor event loop\n    loop = (w.event_loop for w in worker.workers if hasattr(w, \"event_loop\"))\n    test_async.event_loop = next(loop, None)\n\n    # Send actor to worker\n    msg = test_async.send()", "    # Send actor to worker\n    msg = test_async.send()\n    worker.join()\n\n    assert await get_backend().get_result(msg, block=True) is True\n\n    # Send actor to worker\n    msg = test_async.send()\n    worker.join()\n", "    worker.join()\n\n    assert await get_backend().get_result(msg, block=True) is True\n"]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/conftest.py", "chunked_list": ["# Standard Library Imports\nimport asyncio\nfrom typing import Generator\n\nimport pytest\nimport redis\nfrom dramatiq import Worker\nfrom dramatiq.brokers.stub import StubBroker\n\n# Local Application Imports", "\n# Local Application Imports\nfrom async_dramatiq import set_broker\nfrom async_dramatiq.backends import AsyncRedisBackend, AsyncStubBackend, set_backend\nfrom async_dramatiq.middleware import AsyncMiddleware\n\n\ndef check_redis(client: redis.Redis) -> None:\n    try:\n        client.ping()\n    except redis.ConnectionError as e:\n        raise e", "\n\n@pytest.fixture\ndef event_loop() -> Generator[asyncio.BaseEventLoop, None, None]:\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n\n@pytest.fixture\ndef broker() -> Generator[StubBroker, None, None]:\n    broker = StubBroker()\n    set_broker(broker)\n    yield broker", "\n@pytest.fixture\ndef broker() -> Generator[StubBroker, None, None]:\n    broker = StubBroker()\n    set_broker(broker)\n    yield broker\n\n\n@pytest.fixture\ndef async_stub_backend() -> Generator[AsyncStubBackend, None, None]:\n    backend = AsyncStubBackend()\n    set_backend(backend)\n    yield backend", "@pytest.fixture\ndef async_stub_backend() -> Generator[AsyncStubBackend, None, None]:\n    backend = AsyncStubBackend()\n    set_backend(backend)\n    yield backend\n\n\n@pytest.fixture\ndef async_redis_result_backend() -> Generator[AsyncRedisBackend, None, None]:\n    backend = AsyncRedisBackend()\n    check_redis(backend.client)\n    backend.client.flushall()\n    yield backend\n    backend.client.flushall()", "def async_redis_result_backend() -> Generator[AsyncRedisBackend, None, None]:\n    backend = AsyncRedisBackend()\n    check_redis(backend.client)\n    backend.client.flushall()\n    yield backend\n    backend.client.flushall()\n\n\n@pytest.fixture\ndef worker(broker: StubBroker) -> Worker:\n    broker.add_middleware(AsyncMiddleware())\n    worker = Worker(broker, worker_timeout=100, worker_threads=2)\n    worker.start()\n\n    yield worker\n\n    worker.stop()\n    worker.join()", "@pytest.fixture\ndef worker(broker: StubBroker) -> Worker:\n    broker.add_middleware(AsyncMiddleware())\n    worker = Worker(broker, worker_timeout=100, worker_threads=2)\n    worker.start()\n\n    yield worker\n\n    worker.stop()\n    worker.join()", ""]}
{"filename": "examples/worker_heartbeat/run_scheduler.py", "chunked_list": ["# Standard Library Imports\nimport signal\nimport sys\n\nfrom apscheduler.schedulers.blocking import BlockingScheduler\nfrom worker_heartbeat import tasks  # noqa : F401\n\n# Local Application Imports\nfrom async_dramatiq import scheduler as tasks_scheduler\n", "from async_dramatiq import scheduler as tasks_scheduler\n\n\ndef main() -> None:\n    \"\"\"Run the apscheduler in a seperate process.\"\"\"\n\n    scheduler = BlockingScheduler()\n    for job in tasks_scheduler.scheduled_jobs:\n        job_path = f\"{job.module_path}:{job.func_name}.send\"\n        job_name = f\"{job.module_path}.{job.func_name}\"\n        scheduler.add_job(job_path, trigger=job.trigger, name=job_name)\n\n    def shutdown(signum, frame):\n        scheduler.shutdown()\n\n    signal.signal(signal.SIGINT, shutdown)\n    signal.signal(signal.SIGTERM, shutdown)\n\n    scheduler.start()\n    return 0", "\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n"]}
{"filename": "examples/worker_heartbeat/cli.py", "chunked_list": ["# Standard Library Imports\nimport asyncio\n\nimport click\nfrom worker_heartbeat.tasks import async_worker_sleep, worker_heartbeat\n\n# Local Application Imports\nimport async_dramatiq as adtq\n\n", "\n\nasync def heartbeat() -> None:\n    msg = worker_heartbeat.send()\n    print(f\"Sending heartbeat task {msg}...\")\n    result = await adtq.get_backend().get_result(msg, block=True)\n    print(f\"Worker heartbeat @ {result}\")\n\n\nasync def sleep(sleep_for: float) -> None:", "\nasync def sleep(sleep_for: float) -> None:\n    msg = async_worker_sleep.send(sleep_for)\n    print(f\"Sending sleep task {msg}...\")\n    result = await adtq.get_backend().get_result(msg, block=True)\n    print(f\"Worker slept for {result} seconds\")\n\n\n@click.command()\n@click.option(\"--send_heartbeat\", is_flag=True, help=\"Send a heartbeat\")", "@click.command()\n@click.option(\"--send_heartbeat\", is_flag=True, help=\"Send a heartbeat\")\n@click.option(\"--sleep_for\", default=0, type=float, help=\"Sleep for N seconds\")\ndef run(send_heartbeat: bool, sleep_for: float) -> None:\n    \"\"\"Test Async Dramatiq Functionality\"\"\"\n    loop = asyncio.get_event_loop()\n    if send_heartbeat:\n        loop.run_until_complete(heartbeat())\n    elif sleep_for > 0:\n        loop.run_until_complete(sleep(sleep_for))\n    loop.close()", "\n\nif __name__ == \"__main__\":\n    run()\n"]}
{"filename": "examples/worker_heartbeat/worker_heartbeat/tasks.py", "chunked_list": ["# Standard Library Imports\nimport asyncio\nimport logging\nimport time\nfrom datetime import timedelta\n\nfrom .worker import bg_task, lr_task\n\n\n@bg_task(store_results=True, interval=timedelta(seconds=5))\ndef worker_heartbeat() -> float:\n    t = time.time()\n    logging.info(f\"Worker Heartbeat @ {t}\")\n\n    return t", "\n@bg_task(store_results=True, interval=timedelta(seconds=5))\ndef worker_heartbeat() -> float:\n    t = time.time()\n    logging.info(f\"Worker Heartbeat @ {t}\")\n\n    return t\n\n\n@lr_task(store_results=True)", "\n@lr_task(store_results=True)\nasync def async_worker_sleep(sleep_for: float) -> float:\n    logging.info(f\"Worker Sleeping for {sleep_for} seconds\")\n    await asyncio.sleep(sleep_for)\n    logging.info(\"Worker is awake\")\n\n    return sleep_for\n", ""]}
{"filename": "examples/worker_heartbeat/worker_heartbeat/config.py", "chunked_list": ["# Standard Library Imports\nimport logging\nimport os\nfrom distutils.util import strtobool\n\nimport pika\n\n# Environment Variables\ntesting: bool = strtobool(os.getenv(\"TESTING\", \"false\"))\nbroker_host: str = os.getenv(\"BROKER_HOST\", \"localhost\")", "testing: bool = strtobool(os.getenv(\"TESTING\", \"false\"))\nbroker_host: str = os.getenv(\"BROKER_HOST\", \"localhost\")\nbroker_port: int = os.getenv(\"BROKER_PORT\", 5672)\nbroker_credentials: pika.PlainCredentials = pika.PlainCredentials(\n    os.getenv(\"BROKER_USER\", \"guest\"), os.getenv(\"BROKER_PASSWORD\", \"guest\")\n)\nredis_host: str = os.getenv(\"REDIS_HOST\", \"localhost\")\nredis_port: int = os.getenv(\"REDIS_PORT\", 6379)\n\n# Setup", "\n# Setup\nlogging.basicConfig(level=logging.DEBUG if testing else logging.WARNING)\n"]}
{"filename": "examples/worker_heartbeat/worker_heartbeat/__init__.py", "chunked_list": [""]}
{"filename": "examples/worker_heartbeat/worker_heartbeat/worker.py", "chunked_list": ["# Standard Library Imports\nimport logging\nfrom functools import partial\nfrom typing import Any\n\nimport worker_heartbeat.config as config\nfrom dramatiq.brokers.rabbitmq import RabbitmqBroker\nfrom dramatiq.brokers.stub import StubBroker\n\n# Local Application Imports", "\n# Local Application Imports\nimport async_dramatiq as adtq\nfrom async_dramatiq.actor import async_actor\nfrom async_dramatiq.backends import AsyncRedisBackend, AsyncStubBackend\nfrom async_dramatiq.middleware import AsyncMiddleware, StubAsyncMiddleware\nfrom async_dramatiq.types import DramatiqWorkerPriority, TaskQueue\nfrom async_dramatiq.worker import AsyncWorker\n\n# Declare the queues", "\n# Declare the queues\nbg_queue = TaskQueue(queue=\"background_tasks\")\nlr_queue = TaskQueue(queue=\"long_running_tasks\")\n\nqueues = {bg_queue.queue: bg_queue, lr_queue.queue: lr_queue}\n\n# Decorator for background tasks\nbg_task = partial(\n    async_actor, priority=DramatiqWorkerPriority.HIGH, queue_name=bg_queue.queue", "bg_task = partial(\n    async_actor, priority=DramatiqWorkerPriority.HIGH, queue_name=bg_queue.queue\n)\nlr_task = partial(\n    async_actor, priority=DramatiqWorkerPriority.MEDIUM, queue_name=lr_queue.queue\n)\n\n\nasync def startup() -> None:\n    \"\"\"This function should contain your resource initialization code.\"\"\"", "async def startup() -> None:\n    \"\"\"This function should contain your resource initialization code.\"\"\"\n    logging.info(\"Starting up\")\n\n\nasync def shutdown() -> None:\n    \"\"\"This function should contain your resource teardown code.\"\"\"\n    logging.info(\"Shutting down\")\n\n\nclass MyAsyncMiddleware(AsyncMiddleware):\n    \"\"\"Middleware to run the startup/shutdown functions on worker start/stop.\"\"\"\n\n    def before_async_worker_thread_startup(\n        self, _: RabbitmqBroker, thread: AsyncWorker, **kwargs: dict[str, Any]\n    ) -> None:\n        thread.event_loop.run_until_complete(startup())\n\n    def after_async_worker_thread_shutdown(\n        self, _: RabbitmqBroker, thread: AsyncWorker, **kwargs: dict[str, Any]\n    ) -> None:\n        thread.event_loop.run_until_complete(shutdown())\n        thread.event_loop.close()", "\n\nclass MyAsyncMiddleware(AsyncMiddleware):\n    \"\"\"Middleware to run the startup/shutdown functions on worker start/stop.\"\"\"\n\n    def before_async_worker_thread_startup(\n        self, _: RabbitmqBroker, thread: AsyncWorker, **kwargs: dict[str, Any]\n    ) -> None:\n        thread.event_loop.run_until_complete(startup())\n\n    def after_async_worker_thread_shutdown(\n        self, _: RabbitmqBroker, thread: AsyncWorker, **kwargs: dict[str, Any]\n    ) -> None:\n        thread.event_loop.run_until_complete(shutdown())\n        thread.event_loop.close()", "\n\ndef configure() -> None:\n    # Configure Backend and Broker\n    if config.testing:\n        broker = StubBroker()\n        backend = AsyncStubBackend()\n        logging.info(\"Testing\")\n    else:\n        broker = RabbitmqBroker(\n            host=config.broker_host,\n            port=config.broker_port,\n            credentials=config.broker_credentials,\n        )\n        backend = AsyncRedisBackend(host=config.redis_host, port=config.redis_port)\n        logging.info(f\"Broker: {config.broker_host}:{config.broker_port}\")\n        logging.info(f\"Backend: {config.redis_host}:{config.redis_port}\")\n\n    adtq.set_broker(broker)\n    adtq.set_backend(backend)\n\n    # Setup Middleware\n    if config.testing:\n        adtq.get_broker().add_middleware(StubAsyncMiddleware())\n    else:\n        adtq.get_broker().add_middleware(MyAsyncMiddleware())\n\n    # Setup Queues\n    for queue_name in queues.keys():\n        kwargs = {\"ensure\": True} if not config.testing else {}\n        adtq.get_broker().declare_queue(queue_name, **kwargs)\n        logging.info(f\"Declared queue: {queue_name}\")\n\n    logging.info(\"Configured Dramatiq\")", "\n\nconfigure()\n"]}
{"filename": "src/async_dramatiq/types.py", "chunked_list": ["# Standard Library Imports\nimport sys\nfrom dataclasses import dataclass\n\n# Use IntEnum if Python version is greater than 3.11\nif sys.version_info < (3, 11):\n    from enum import Enum as IntEnum\nelse:\n    from enum import IntEnum\n", "\n\nclass DramatiqWorkerPriority(IntEnum):\n    CRITICAL = 0\n    VERY_HIGH = 1\n    HIGH = 3\n    MEDIUM = 4\n    LOW = 5\n    VERY_LOW = 6\n", "\n\n@dataclass\nclass TaskQueue:\n    queue: str\n    message_ttl: int | None = 60 * 60  # Max time a task can sit in the queue\n"]}
{"filename": "src/async_dramatiq/scheduler.py", "chunked_list": ["# Standard Library Imports\nfrom dataclasses import dataclass\nfrom datetime import timedelta\nfrom typing import Any, Callable\n\nfrom apscheduler.triggers.cron import CronTrigger\nfrom apscheduler.triggers.interval import IntervalTrigger\n\n\n@dataclass\nclass ScheduledFunction:\n    trigger: CronTrigger | IntervalTrigger\n    module_path: str\n    func_name: str", "\n@dataclass\nclass ScheduledFunction:\n    trigger: CronTrigger | IntervalTrigger\n    module_path: str\n    func_name: str\n\n\n# Global list of scheduled jobs\nscheduled_jobs: list[ScheduledFunction] = []", "# Global list of scheduled jobs\nscheduled_jobs: list[ScheduledFunction] = []\n\n\ndef _add_trigger(\n    trigger: CronTrigger | IntervalTrigger, func: Callable[..., Any]\n) -> None:\n    global scheduled_jobs\n    scheduled_jobs.append(\n        ScheduledFunction(\n            trigger=trigger, module_path=func.__module__, func_name=func.__name__\n        )\n    )", "\n\ndef register_cron(func: Callable[..., Any], crontab: str) -> None:\n    \"\"\"Register a function to be called on a cron schedule.\n\n    :param func: The function to call.\n    :param crontab: The cron schedule at which to call the function at.\n        Check out https://crontab.guru/ for help.\n    \"\"\"\n    _add_trigger(CronTrigger.from_crontab(crontab), func)", "\n\ndef register_interval(func: Callable[..., Any], interval: timedelta) -> None:\n    \"\"\"Register a function to be called on an interval.\n\n    :param func: The function to call.\n    :param interval: The interval at which to call the function at. This is a timedelta.\n    \"\"\"\n    _add_trigger(IntervalTrigger(seconds=interval.total_seconds()), func)\n", ""]}
{"filename": "src/async_dramatiq/actor.py", "chunked_list": ["# Standard Library Imports\nimport asyncio\nimport inspect\nfrom datetime import timedelta\nfrom typing import Any, Callable\n\nimport dramatiq as dq\n\nfrom .scheduler import register_cron, register_interval\nfrom .types import DramatiqWorkerPriority", "from .scheduler import register_cron, register_interval\nfrom .types import DramatiqWorkerPriority\n\n\nclass AsyncActor(dq.Actor):\n    def __init__(self, *args: Any, **kwargs: dict[str, Any]) -> None:\n        super().__init__(*args, **kwargs)\n        self.event_loop: asyncio.BaseEventLoop | None = None\n\n    def __call__(self, *args: Any, **kwargs: dict[str, Any]) -> Any:\n        \"\"\"Call this function apropriately depending on its type.\n\n        :param *args: Positional arguments to send to the actor.\n        :param **kwargs: Keyword arguments to send to the actor.\n\n        :return: Whatever the underlying function backing this actor returns.\n        \"\"\"\n        try:\n            running_event_loop = asyncio.get_running_loop()\n        except RuntimeError:\n            running_event_loop = None\n\n        if inspect.iscoroutinefunction(self.fn):\n            if running_event_loop:  # Call function directly on running event loop\n                result = self.fn(*args, **kwargs)\n            elif (  # Run function async worker thread event loop\n                self.event_loop and self.event_loop.is_running()\n            ):\n                future = asyncio.run_coroutine_threadsafe(\n                    self.fn(*args, **kwargs), self.event_loop\n                )\n                result = future.result()\n            else:  # This should not happen\n                raise RuntimeError(\"No event\")\n        else:  # Call function directly\n            result = self.fn(*args, **kwargs)\n\n        return result\n\n    def set_event_loop(self, loop: asyncio.BaseEventLoop | None) -> None:\n        self.event_loop = loop", "\n\ndef async_actor(\n    *,\n    interval: timedelta | None = None,\n    crontab: str | None = None,\n    priority: DramatiqWorkerPriority = DramatiqWorkerPriority.MEDIUM,\n    actor_class: type[AsyncActor] = AsyncActor,\n    queue_name: str = \"default\",\n    **kwargs: Any,\n) -> Any:\n    \"\"\"Thin wrapper which turns a function into a dramatiq actor.\n\n    :param interval: Run this function at a defined interval\n    :param crontab: Run this function as a cron job. See https://crontab.guru/.\n    :param priority: The actor's global priority.  If two tasks have\n        been pulled on a worker concurrently and one has a higher\n        priority than the other then it will be processed first.\n        Lower numbers represent higher priorities.\n    :param actor_class: The actor class to use\n    :param queue_name: The name of the queue to send messages to\n    :param kwargs: Input parameters for the dramatiq actor\n\n    Dramatiq Actor: https://dramatiq.io/_modules/dramatiq/actor.html\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -> dq.Actor:\n        actor = dq.actor(\n            func,\n            actor_class=actor_class,\n            priority=priority,\n            queue_name=queue_name,\n            **kwargs,\n        )\n        if crontab:\n            register_cron(actor.fn, crontab)\n        if interval:\n            register_interval(actor.fn, interval)\n\n        return actor\n\n    return decorator", ""]}
{"filename": "src/async_dramatiq/__init__.py", "chunked_list": ["from dramatiq import get_broker, set_broker  # noqa: F401\n\nfrom .actor import AsyncActor, async_actor  # noqa: F401\nfrom .backends import get_backend, set_backend  # noqa: F401\nfrom .types import DramatiqWorkerPriority, TaskQueue  # noqa: F401\n"]}
{"filename": "src/async_dramatiq/worker.py", "chunked_list": ["# Standard Library Imports\nimport asyncio\nfrom threading import Event, Thread\n\nimport dramatiq as dq\n\n\nclass AsyncWorker(Thread):\n    \"\"\"Worker thread that runs and manages the Asyncio Event Loop.\"\"\"\n\n    def __init__(self, startup_event: Event, broker: dq.broker.Broker) -> None:\n        Thread.__init__(self)\n        self.startup_event = startup_event\n        self.broker = broker\n\n    def run(self) -> None:\n        self.event_loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self.event_loop)\n\n        self.broker.emit_before(\"async_worker_thread_startup\", self)\n\n        for actor in [  # Set event loop of actors to this loop\n            self.broker.get_actor(a) for a in self.broker.get_declared_actors()\n        ]:\n            actor.set_event_loop(self.event_loop)\n\n        # Signal that the event loop has started\n        self.event_loop.call_soon_threadsafe(self.startup_event.set)\n        self.event_loop.run_forever()\n\n        self.broker.emit_after(\"async_worker_thread_shutdown\", self)\n\n    def stop(self) -> None:\n        self.event_loop.call_soon_threadsafe(self.event_loop.stop)\n\n    def pause(self) -> None:\n        pass\n\n    def resume(self) -> None:\n        pass", ""]}
{"filename": "src/async_dramatiq/backends/async_stub.py", "chunked_list": ["# Standard Library Imports\nimport asyncio\nimport time\n\nimport dramatiq as dq\nfrom dramatiq.results.backend import (\n    BACKOFF_FACTOR,\n    DEFAULT_TIMEOUT,\n    Missing,\n    Result,", "    Missing,\n    Result,\n    ResultMissing,\n    ResultTimeout,\n    compute_backoff,\n)\nfrom dramatiq.results.backends import StubBackend\n\n\nclass AsyncStubBackend(StubBackend):\n    async def get_result(\n        self, message: dq.Message, *, block: bool = False, timeout: int | None = None\n    ) -> Result:\n        \"\"\"Get a result from the backend.\n        Sub-second timeouts are not respected by this backend.\n\n        :param message: The dramatiq message object\n        :param block: Whether or not to block until a result is set.\n        :param timeout: The maximum amount of time, in ms, to wait for\n          a result when block is True.  Defaults to 10 seconds.\n\n        :raise ResultMissing: When block is False and the result isn't set.\n        :raise ResultTimeout: When waiting for a result times out.\n\n        :return: The result object.\n        \"\"\"\n        if timeout is None:\n            timeout = DEFAULT_TIMEOUT\n\n        end_time = time.monotonic() + timeout / 1000\n        message_key = self.build_message_key(message)\n\n        attempts = 0\n        while True:\n            result = self._get(message_key)\n            if result is Missing and block:\n                attempts, delay = compute_backoff(attempts, factor=BACKOFF_FACTOR)\n                delay /= 1000\n                if time.monotonic() + delay > end_time:\n                    raise ResultTimeout(message)\n\n                await asyncio.sleep(delay)\n                continue\n\n            elif result is Missing:\n                raise ResultMissing(message)\n\n            else:\n                return self.unwrap_result(result)", "\nclass AsyncStubBackend(StubBackend):\n    async def get_result(\n        self, message: dq.Message, *, block: bool = False, timeout: int | None = None\n    ) -> Result:\n        \"\"\"Get a result from the backend.\n        Sub-second timeouts are not respected by this backend.\n\n        :param message: The dramatiq message object\n        :param block: Whether or not to block until a result is set.\n        :param timeout: The maximum amount of time, in ms, to wait for\n          a result when block is True.  Defaults to 10 seconds.\n\n        :raise ResultMissing: When block is False and the result isn't set.\n        :raise ResultTimeout: When waiting for a result times out.\n\n        :return: The result object.\n        \"\"\"\n        if timeout is None:\n            timeout = DEFAULT_TIMEOUT\n\n        end_time = time.monotonic() + timeout / 1000\n        message_key = self.build_message_key(message)\n\n        attempts = 0\n        while True:\n            result = self._get(message_key)\n            if result is Missing and block:\n                attempts, delay = compute_backoff(attempts, factor=BACKOFF_FACTOR)\n                delay /= 1000\n                if time.monotonic() + delay > end_time:\n                    raise ResultTimeout(message)\n\n                await asyncio.sleep(delay)\n                continue\n\n            elif result is Missing:\n                raise ResultMissing(message)\n\n            else:\n                return self.unwrap_result(result)", ""]}
{"filename": "src/async_dramatiq/backends/async_redis.py", "chunked_list": ["import dramatiq as dq\nfrom dramatiq.results.backend import (\n    DEFAULT_TIMEOUT,\n    Result,\n    ResultMissing,\n    ResultTimeout,\n)\nfrom dramatiq.results.backends.redis import RedisBackend\n\n\nclass AsyncRedisBackend(RedisBackend):\n    \"\"\"A Redis backend that supports async redis client.\n\n    TODO: Use async redis client instead of sync client\n    \"\"\"\n\n    async def get_result(\n        self, message: dq.Message, *, block: bool = False, timeout: int | None = None\n    ) -> Result:\n        \"\"\"Get a result from the backend. Sub-second timeouts are not respected by\n        this backend.\n\n        :param message: The dramatiq message object\n        :param block: Whether or not to block until a result is set.\n        :param timeout: The maximum amount of time, in ms, to wait for\n          a result when block is True.  Defaults to 10 seconds.\n\n        :raise ResultMissing: When block is False and the result isn't set.\n        :raise ResultTimeout: When waiting for a result times out.\n\n        :return: The result object.\n        \"\"\"\n\n        if timeout is None:\n            timeout = DEFAULT_TIMEOUT\n\n        message_key = self.build_message_key(message)\n        if block:\n            timeout = int(timeout / 1000)\n            if timeout == 0:\n                data = self.client.rpoplpush(message_key, message_key)\n            else:\n                data = self.client.brpoplpush(message_key, message_key, timeout)\n\n            if data is None:\n                raise ResultTimeout(message)\n\n        else:\n            data = self.client.lindex(message_key, 0)\n            if data is None:\n                raise ResultMissing(message)\n\n        return self.unwrap_result(self.encoder.decode(data))", "\n\nclass AsyncRedisBackend(RedisBackend):\n    \"\"\"A Redis backend that supports async redis client.\n\n    TODO: Use async redis client instead of sync client\n    \"\"\"\n\n    async def get_result(\n        self, message: dq.Message, *, block: bool = False, timeout: int | None = None\n    ) -> Result:\n        \"\"\"Get a result from the backend. Sub-second timeouts are not respected by\n        this backend.\n\n        :param message: The dramatiq message object\n        :param block: Whether or not to block until a result is set.\n        :param timeout: The maximum amount of time, in ms, to wait for\n          a result when block is True.  Defaults to 10 seconds.\n\n        :raise ResultMissing: When block is False and the result isn't set.\n        :raise ResultTimeout: When waiting for a result times out.\n\n        :return: The result object.\n        \"\"\"\n\n        if timeout is None:\n            timeout = DEFAULT_TIMEOUT\n\n        message_key = self.build_message_key(message)\n        if block:\n            timeout = int(timeout / 1000)\n            if timeout == 0:\n                data = self.client.rpoplpush(message_key, message_key)\n            else:\n                data = self.client.brpoplpush(message_key, message_key, timeout)\n\n            if data is None:\n                raise ResultTimeout(message)\n\n        else:\n            data = self.client.lindex(message_key, 0)\n            if data is None:\n                raise ResultMissing(message)\n\n        return self.unwrap_result(self.encoder.decode(data))", ""]}
{"filename": "src/async_dramatiq/backends/__init__.py", "chunked_list": ["from dramatiq import get_broker\nfrom dramatiq.results import Results\nfrom dramatiq.results.backend import ResultBackend\n\nfrom .async_redis import AsyncRedisBackend  # noqa: F401\nfrom .async_stub import AsyncStubBackend  # noqa: F401\n\nbackend: ResultBackend | None = None\n\n\ndef get_backend() -> ResultBackend:\n    global backend\n    return backend", "\n\ndef get_backend() -> ResultBackend:\n    global backend\n    return backend\n\n\ndef set_backend(input: ResultBackend) -> None:\n    global backend\n    backend = input\n    get_broker().add_middleware(Results(backend=input))", ""]}
{"filename": "src/async_dramatiq/middleware/async_base.py", "chunked_list": ["# Standard Library Imports\nfrom threading import Event\nfrom typing import Any\n\nimport dramatiq as dq\n\n# Local Application Imports\nfrom async_dramatiq.worker import AsyncWorker\n\n\nclass AsyncMiddleware(dq.Middleware):\n    \"\"\"Middleware that runs the Asyncio Event Loop in a separate worker.\"\"\"\n\n    def before_worker_boot(self, broker: dq.Broker, worker: dq.Worker) -> None:\n        startup_event = Event()\n        async_worker = AsyncWorker(startup_event, broker)\n        async_worker.start()\n        startup_event.wait()  # Wait until the Asyncio Event Loop has started\n        worker.workers.append(async_worker)\n\n    def before_async_worker_thread_startup(\n        self, broker: dq.Broker, thread: AsyncWorker, **kwargs: dict[str, Any]  # noqa\n    ) -> None:\n        pass\n\n    def after_async_worker_thread_shutdown(\n        self, broker: dq.Broker, thread: AsyncWorker, **kwargs: dict[str, Any]  # noqa\n    ) -> None:\n        pass", "\n\nclass AsyncMiddleware(dq.Middleware):\n    \"\"\"Middleware that runs the Asyncio Event Loop in a separate worker.\"\"\"\n\n    def before_worker_boot(self, broker: dq.Broker, worker: dq.Worker) -> None:\n        startup_event = Event()\n        async_worker = AsyncWorker(startup_event, broker)\n        async_worker.start()\n        startup_event.wait()  # Wait until the Asyncio Event Loop has started\n        worker.workers.append(async_worker)\n\n    def before_async_worker_thread_startup(\n        self, broker: dq.Broker, thread: AsyncWorker, **kwargs: dict[str, Any]  # noqa\n    ) -> None:\n        pass\n\n    def after_async_worker_thread_shutdown(\n        self, broker: dq.Broker, thread: AsyncWorker, **kwargs: dict[str, Any]  # noqa\n    ) -> None:\n        pass", ""]}
{"filename": "src/async_dramatiq/middleware/async_stub.py", "chunked_list": ["# Standard Library Imports\nimport asyncio\n\nimport dramatiq as dq\n\n\nclass StubAsyncMiddleware(dq.Middleware):\n    \"\"\"Stub middleware that sets the event loop of actors to the current loop.\n    This is used for testing. Standard use case would be to add the following\n    fixture in your conftest.py:\n\n        @pytest.fixture(scope=\"session\")\n        def event_loop() -> Generator[asyncio.BaseEventLoop, None, None]:\n            loop = asyncio.get_event_loop_policy().new_event_loop()\n            yield loop\n            loop.close()\n    \"\"\"\n\n    event_loop: asyncio.BaseEventLoop\n\n    def before_worker_boot(self, broker: dq.Broker, worker: dq.Worker) -> None:\n        event_loop = asyncio.get_event_loop()\n        for actor in [  # Set event loop of actors to this loop\n            broker.get_actor(a) for a in broker.get_declared_actors()\n        ]:\n            actor.set_event_loop(event_loop)\n\n    def before_worker_shutdown(self, broker: dq.Broker, _: dq.Worker) -> None:\n        for actor in [  # Set event loop of actors to this loop\n            broker.get_actor(a) for a in broker.get_declared_actors()\n        ]:\n            actor.set_event_loop(None)", ""]}
{"filename": "src/async_dramatiq/middleware/__init__.py", "chunked_list": ["from .async_base import AsyncMiddleware  # noqa: F401\nfrom .async_stub import StubAsyncMiddleware  # noqa: F401\n"]}
