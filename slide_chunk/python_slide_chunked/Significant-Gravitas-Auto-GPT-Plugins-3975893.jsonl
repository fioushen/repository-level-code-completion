{"filename": "run_pylint.py", "chunked_list": ["\"\"\"\n    https://stackoverflow.com/questions/49100806/\n    pylint-and-subprocess-run-returning-exit-status-28\n\"\"\"\nimport subprocess\n\ncmd = \" pylint src\\\\**\\\\*\"\ntry:\n    subprocComplete = subprocess.run(\n        cmd, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE\n    )\n    print(subprocComplete.stdout.decode(\"utf-8\"))\nexcept subprocess.CalledProcessError as err:\n    print(err.output.decode(\"utf-8\"))", ""]}
{"filename": "src/autogpt_plugins/__init__.py", "chunked_list": [""]}
{"filename": "src/autogpt_plugins/wikipedia_search/__init__.py", "chunked_list": ["\"\"\"Wikipedia search integrations.\"\"\"\nfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\nfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\nfrom .wikipedia_search import _wikipedia_search\n\nPromptGenerator = TypeVar(\"PromptGenerator\")\n\n\nclass Message(TypedDict):\n    role: str\n    content: str", "\n\nclass Message(TypedDict):\n    role: str\n    content: str\n\n\nclass AutoGPTWikipediaSearch(AutoGPTPluginTemplate):\n    \"\"\"\n    Wikipedia search integrations\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._name = \"autogpt-wikipedia-search\"\n        self._version = \"0.1.0\"\n        self._description = \"Wikipedia search integrations.\"\n\n    def can_handle_on_response(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_response method.\n        Returns:\n            bool: True if the plugin can handle the on_response method.\"\"\"\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        \"\"\"This method is called when a response is received from the model.\"\"\"\n        pass\n\n    def can_handle_post_prompt(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_prompt method.\n        Returns:\n            bool: True if the plugin can handle the post_prompt method.\"\"\"\n        return True\n\n    def can_handle_on_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_planning method.\n        Returns:\n            bool: True if the plugin can handle the on_planning method.\"\"\"\n        return False\n\n    def on_planning(\n        self, prompt: PromptGenerator, messages: List[str]\n    ) -> Optional[str]:\n        \"\"\"This method is called before the planning chat completeion is done.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n            messages (List[str]): The list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_planning method.\n        Returns:\n            bool: True if the plugin can handle the post_planning method.\"\"\"\n        return False\n\n    def post_planning(self, response: str) -> str:\n        \"\"\"This method is called after the planning chat completeion is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_instruction method.\n        Returns:\n            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n        return False\n\n    def pre_instruction(self, messages: List[str]) -> List[str]:\n        \"\"\"This method is called before the instruction chat is done.\n        Args:\n            messages (List[str]): The list of context messages.\n        Returns:\n            List[str]: The resulting list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_instruction method.\n        Returns:\n            bool: True if the plugin can handle the on_instruction method.\"\"\"\n        return False\n\n    def on_instruction(self, messages: List[str]) -> Optional[str]:\n        \"\"\"This method is called when the instruction chat is done.\n        Args:\n            messages (List[str]): The list of context messages.\n        Returns:\n            Optional[str]: The resulting message.\n        \"\"\"\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_instruction method.\n        Returns:\n            bool: True if the plugin can handle the post_instruction method.\"\"\"\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        \"\"\"This method is called after the instruction chat is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_command method.\n        Returns:\n            bool: True if the plugin can handle the pre_command method.\"\"\"\n        return False\n\n    def pre_command(\n        self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"This method is called before the command is executed.\n        Args:\n            command_name (str): The command name.\n            arguments (Dict[str, Any]): The arguments.\n        Returns:\n            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n        \"\"\"\n        pass\n\n    def can_handle_post_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_command method.\n        Returns:\n            bool: True if the plugin can handle the post_command method.\"\"\"\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        \"\"\"This method is called after the command is executed.\n        Args:\n            command_name (str): The command name.\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_chat_completion(\n        self,\n        messages: list[Dict[Any, Any]],\n        model: str,\n        temperature: float,\n        max_tokens: int,\n    ) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the chat_completion method.\n        Args:\n            messages (Dict[Any, Any]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            bool: True if the plugin can handle the chat_completion method.\"\"\"\n        return False\n\n    def handle_chat_completion(\n        self,\n        messages: list[Dict[Any, Any]],\n        model: str,\n        temperature: float,\n        max_tokens: int,\n    ) -> str:\n        \"\"\"This method is called when the chat completion is done.\n        Args:\n            messages (Dict[Any, Any]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return None\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        \"\"\"This method is called just after the generate_prompt is called,\n            but actually before the prompt is generated.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n        Returns:\n            PromptGenerator: The prompt generator.\n        \"\"\"\n\n        prompt.add_command(\n            \"wikipedia_search\",\n            \"Wikipedia search\",\n            {\"query\": \"<query>\"},\n            _wikipedia_search,\n        )\n        return prompt\n\n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass"]}
{"filename": "src/autogpt_plugins/wikipedia_search/wikipedia_search.py", "chunked_list": ["\"\"\"Wikipedia search command for Autogpt.\"\"\"\nfrom __future__ import annotations\n\nimport json\nimport re\nfrom urllib.parse import quote\n\nimport requests\n\nHTML_TAG_CLEANER = re.compile(\"<.*?>|&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-f]{1,6});\")", "\nHTML_TAG_CLEANER = re.compile(\"<.*?>|&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-f]{1,6});\")\n\n\ndef _wikipedia_search(query: str, num_results: int = 5) -> str | list[str]:\n    \"\"\"Return the results of a Wikipedia search\n    Args:\n        query (str): The search query.\n        num_results (int): The number of results to return.\n    Returns:\n        str: The results of the search. The resulting string is a `json.dumps`\n             of a list of len `num_results` containing dictionaries with the\n             following structure: `{'title': <title>, 'summary': <summary>,\n             'url': <url to relevant page>}`\n    \"\"\"\n    search_url = (\n        \"https://en.wikipedia.org/w/api.php?action=query&\"\n        \"format=json&list=search&utf8=1&formatversion=2&\"\n        f\"srsearch={quote(query)}\"\n    )\n    with requests.Session() as session:\n        session.headers.update(\n            {\n                \"User-Agent\": (\n                    \"Mozilla/5.0 (Windows NT 10.0; \"\n                    \"Win64; x64) AppleWebKit/537.36 \"\n                    \"(KHTML, like Gecko) Chrome/\"\n                    \"112.0.5615.49 Safari/537.36\"\n                )\n            }\n        )\n        session.headers.update({\"Accept\": \"application/json\"})\n        results = session.get(search_url)\n        items = []\n        try:\n            results = results.json()\n            for item in results[\"query\"][\"search\"]:\n                summary = re.sub(HTML_TAG_CLEANER, \"\", item[\"snippet\"])\n                items.append(\n                    {\n                        \"title\": item[\"title\"],\n                        \"summary\": summary,\n                        \"url\": f\"http://en.wikipedia.org/?curid={item['pageid']}\",\n                    }\n                )\n                if len(items) == num_results:\n                    break\n        except Exception as e:\n            return f\"'wikipedia_search' on query: '{query}' raised exception: '{e}'\"\n\n    return json.dumps(items, ensure_ascii=False, indent=4)", ""]}
{"filename": "src/autogpt_plugins/bing_search/test_auto_gpt_bing.py", "chunked_list": ["import os\nimport unittest\nfrom typing import List\n\nimport requests\n\nfrom . import AutoGPTBingSearch\nfrom .bing_search import _bing_search\n\n\nclass TestAutoGPTBingSearch(unittest.TestCase):\n    def setUp(self):\n        os.environ[\"BING_API_KEY\"] = \"test_key\"\n        os.environ[\"SEARCH_ENGINE\"] = \"bing\"\n        self.plugin = AutoGPTBingSearch()\n\n    def tearDown(self):\n        os.environ.pop(\"SEARCH_ENGINE\", None)\n        os.environ.pop(\"BING_API_KEY\", None)\n\n    def test_bing_search(self):\n        query = \"test query\"\n        try:\n            _bing_search(query)\n        except requests.exceptions.HTTPError as e:\n            self.assertEqual(e.response.status_code, 401)\n\n    def test_pre_command(self):\n        os.environ[\"SEARCH_ENGINE\"] = \"bing\"\n        self.plugin = AutoGPTBingSearch()\n\n        command_name, arguments = self.plugin.pre_command(\n            \"google\", {\"query\": \"test query\"}\n        )\n        self.assertEqual(command_name, \"bing_search\")\n        self.assertEqual(arguments, {\"query\": \"test query\"})\n\n    def test_can_handle_pre_command(self):\n        self.assertTrue(self.plugin.can_handle_pre_command())\n\n    def test_can_handle_post_prompt(self):\n        self.assertTrue(self.plugin.can_handle_post_prompt())", "\n\nclass TestAutoGPTBingSearch(unittest.TestCase):\n    def setUp(self):\n        os.environ[\"BING_API_KEY\"] = \"test_key\"\n        os.environ[\"SEARCH_ENGINE\"] = \"bing\"\n        self.plugin = AutoGPTBingSearch()\n\n    def tearDown(self):\n        os.environ.pop(\"SEARCH_ENGINE\", None)\n        os.environ.pop(\"BING_API_KEY\", None)\n\n    def test_bing_search(self):\n        query = \"test query\"\n        try:\n            _bing_search(query)\n        except requests.exceptions.HTTPError as e:\n            self.assertEqual(e.response.status_code, 401)\n\n    def test_pre_command(self):\n        os.environ[\"SEARCH_ENGINE\"] = \"bing\"\n        self.plugin = AutoGPTBingSearch()\n\n        command_name, arguments = self.plugin.pre_command(\n            \"google\", {\"query\": \"test query\"}\n        )\n        self.assertEqual(command_name, \"bing_search\")\n        self.assertEqual(arguments, {\"query\": \"test query\"})\n\n    def test_can_handle_pre_command(self):\n        self.assertTrue(self.plugin.can_handle_pre_command())\n\n    def test_can_handle_post_prompt(self):\n        self.assertTrue(self.plugin.can_handle_post_prompt())", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "src/autogpt_plugins/bing_search/__init__.py", "chunked_list": ["\"\"\"This is the Bing search engines plugin for Auto-GPT.\"\"\"\nimport os\nfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\nfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\nfrom .bing_search import _bing_search\n\nPromptGenerator = TypeVar(\"PromptGenerator\")\n", "PromptGenerator = TypeVar(\"PromptGenerator\")\n\n\nclass Message(TypedDict):\n    role: str\n    content: str\n\n\nclass AutoGPTBingSearch(AutoGPTPluginTemplate):\n    def __init__(self):\n        super().__init__()\n        self._name = \"Bing-Search-Plugin\"\n        self._version = \"0.1.0\"\n        self._description = (\n            \"This plugin performs Bing searches using the provided query.\"\n        )\n        self.load_commands = (\n            os.getenv(\"SEARCH_ENGINE\")\n            and os.getenv(\"SEARCH_ENGINE\").lower() == \"bing\"\n            and os.getenv(\"BING_API_KEY\")\n        )\n\n    def can_handle_post_prompt(self) -> bool:\n        return True\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        if self.load_commands:\n            # Add Bing Search command\n            prompt.add_command(\n                \"Bing Search\",\n                \"bing_search\",\n                {\"query\": \"<query>\"},\n                _bing_search,\n            )\n        else:\n            print(\n                \"Warning: Bing-Search-Plugin is not fully functional. \"\n                \"Please set the SEARCH_ENGINE and BING_API_KEY environment variables.\"\n            )\n        return prompt\n\n    def can_handle_pre_command(self) -> bool:\n        return True\n\n    def pre_command(\n        self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        if command_name == \"google\" and self.load_commands:\n            # this command does nothing but it is required to continue performing the post_command function\n            return \"bing_search\", {\"query\": arguments[\"query\"]}\n        else:\n            return command_name, arguments\n\n    def can_handle_post_command(self) -> bool:\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        pass\n\n    def can_handle_on_planning(self) -> bool:\n        return False\n\n    def on_planning(\n        self, prompt: PromptGenerator, messages: List[Message]\n    ) -> Optional[str]:\n        pass\n\n    def can_handle_on_response(self) -> bool:\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        return False\n\n    def post_planning(self, response: str) -> str:\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        return False\n\n    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        return False\n\n    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        pass\n\n    def can_handle_pre_command(self) -> bool:\n        return True\n\n    def can_handle_chat_completion(\n        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n    ) -> bool:\n        return False\n\n    def handle_chat_completion(\n        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n    ) -> str:\n        pass\n\n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass", "class AutoGPTBingSearch(AutoGPTPluginTemplate):\n    def __init__(self):\n        super().__init__()\n        self._name = \"Bing-Search-Plugin\"\n        self._version = \"0.1.0\"\n        self._description = (\n            \"This plugin performs Bing searches using the provided query.\"\n        )\n        self.load_commands = (\n            os.getenv(\"SEARCH_ENGINE\")\n            and os.getenv(\"SEARCH_ENGINE\").lower() == \"bing\"\n            and os.getenv(\"BING_API_KEY\")\n        )\n\n    def can_handle_post_prompt(self) -> bool:\n        return True\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        if self.load_commands:\n            # Add Bing Search command\n            prompt.add_command(\n                \"Bing Search\",\n                \"bing_search\",\n                {\"query\": \"<query>\"},\n                _bing_search,\n            )\n        else:\n            print(\n                \"Warning: Bing-Search-Plugin is not fully functional. \"\n                \"Please set the SEARCH_ENGINE and BING_API_KEY environment variables.\"\n            )\n        return prompt\n\n    def can_handle_pre_command(self) -> bool:\n        return True\n\n    def pre_command(\n        self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        if command_name == \"google\" and self.load_commands:\n            # this command does nothing but it is required to continue performing the post_command function\n            return \"bing_search\", {\"query\": arguments[\"query\"]}\n        else:\n            return command_name, arguments\n\n    def can_handle_post_command(self) -> bool:\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        pass\n\n    def can_handle_on_planning(self) -> bool:\n        return False\n\n    def on_planning(\n        self, prompt: PromptGenerator, messages: List[Message]\n    ) -> Optional[str]:\n        pass\n\n    def can_handle_on_response(self) -> bool:\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        return False\n\n    def post_planning(self, response: str) -> str:\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        return False\n\n    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        return False\n\n    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        pass\n\n    def can_handle_pre_command(self) -> bool:\n        return True\n\n    def can_handle_chat_completion(\n        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n    ) -> bool:\n        return False\n\n    def handle_chat_completion(\n        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n    ) -> str:\n        pass\n\n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass"]}
{"filename": "src/autogpt_plugins/bing_search/bing_search.py", "chunked_list": ["import json\nimport os\nimport re\n\nimport requests\n\n\ndef clean_text(text: str) -> str:\n    cleaned_text = re.sub(\"<[^>]*>\", \"\", text)  # Remove HTML tags\n    cleaned_text = cleaned_text.replace(\n        \"\\\\n\", \" \"\n    )  # Replace newline characters with spaces\n    return cleaned_text", "\n\ndef _bing_search(query: str, num_results=8) -> str:\n    \"\"\"\n    Perform a Bing search and return the results as a JSON string.\n    \"\"\"\n    subscription_key = os.getenv(\"BING_API_KEY\")\n\n    # Bing Search API endpoint\n    search_url = \"https://api.bing.microsoft.com/v7.0/search\"\n\n    headers = {\"Ocp-Apim-Subscription-Key\": subscription_key}\n    params = {\n        \"q\": query,\n        \"count\": num_results,\n        \"textDecorations\": True,\n        \"textFormat\": \"HTML\",\n    }\n    response = requests.get(search_url, headers=headers, params=params)\n    response.raise_for_status()\n    search_results = response.json()\n\n    # Extract the search result items from the response\n    web_pages = search_results.get(\"webPages\", {})\n    search_results = web_pages.get(\"value\", [])\n\n    # Create a list of search result dictionaries with 'title', 'href', and 'body' keys\n    search_results_list = [\n        {\n            \"title\": clean_text(item[\"name\"]),\n            \"href\": item[\"url\"],\n            \"body\": clean_text(item[\"snippet\"]),\n        }\n        for item in search_results\n    ]\n\n    # Return the search results as a JSON string\n    return json.dumps(search_results_list, ensure_ascii=False, indent=4)", ""]}
{"filename": "src/autogpt_plugins/bluesky/__init__.py", "chunked_list": ["\"\"\"This is a Bluesky plugin for AutoGPT using atprototools.\"\"\"\nfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\nfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\nPromptGenerator = TypeVar(\"PromptGenerator\")\n\n\nclass Message(TypedDict):\n    role: str\n    content: str", "class Message(TypedDict):\n    role: str\n    content: str\n\n\nclass AutoGPTBluesky(AutoGPTPluginTemplate):\n    \"\"\"\n    Bluesky plugin for AutoGPT using atprototools.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._name = \"autogpt-bluesky\"\n        self._version = \"0.1.0\"\n        self._description = \"Bluesky integration using atprototools.\"\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        \"\"\"This method is called just after the generate_prompt is called,\n            but actually before the prompt is generated.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n        Returns:\n            PromptGenerator: The prompt generator.\n        \"\"\"\n        from .bluesky_plugin.bluesky_plugin import (\n            get_latest_posts,\n            post_message,\n            username_and_pwd_set,\n        )\n\n        if not username_and_pwd_set():\n            return prompt\n\n        prompt.add_command(\n            \"post_to_bluesky\", \"Post to Bluesky\", {\n                \"text\": \"<text>\"}, post_message\n        )\n        prompt.add_command(\n            \"get_bluesky_posts\", \"Get Blueskey Posts\", {\n                \"username\": \"<username>\",\n                \"number_of_posts\": \"<number_of_posts>\"}, get_latest_posts)\n\n        return prompt\n\n    def can_handle_on_response(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_response method.\n        Returns:\n            bool: True if the plugin can handle the on_response method.\"\"\"\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        \"\"\"This method is called when a response is received from the model.\"\"\"\n        pass\n\n    def can_handle_post_prompt(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_prompt method.\n        Returns:\n            bool: True if the plugin can handle the post_prompt method.\"\"\"\n        return True\n\n    def can_handle_on_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_planning method.\n        Returns:\n            bool: True if the plugin can handle the on_planning method.\"\"\"\n        return False\n\n    def on_planning(\n        self, prompt: PromptGenerator, messages: List[str]\n    ) -> Optional[str]:\n        \"\"\"This method is called before the planning chat completeion is done.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n            messages (List[str]): The list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_planning method.\n        Returns:\n            bool: True if the plugin can handle the post_planning method.\"\"\"\n        return False\n\n    def post_planning(self, response: str) -> str:\n        \"\"\"This method is called after the planning chat completeion is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_instruction method.\n        Returns:\n            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n        return False\n\n    def pre_instruction(self, messages: List[str]) -> List[str]:\n        \"\"\"This method is called before the instruction chat is done.\n        Args:\n            messages (List[str]): The list of context messages.\n        Returns:\n            List[str]: The resulting list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_instruction method.\n        Returns:\n            bool: True if the plugin can handle the on_instruction method.\"\"\"\n        return False\n\n    def on_instruction(self, messages: List[str]) -> Optional[str]:\n        \"\"\"This method is called when the instruction chat is done.\n        Args:\n            messages (List[str]): The list of context messages.\n        Returns:\n            Optional[str]: The resulting message.\n        \"\"\"\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_instruction method.\n        Returns:\n            bool: True if the plugin can handle the post_instruction method.\"\"\"\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        \"\"\"This method is called after the instruction chat is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_command method.\n        Returns:\n            bool: True if the plugin can handle the pre_command method.\"\"\"\n        return False\n\n    def pre_command(\n        self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"This method is called before the command is executed.\n        Args:\n            command_name (str): The command name.\n            arguments (Dict[str, Any]): The arguments.\n        Returns:\n            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n        \"\"\"\n        pass\n\n    def can_handle_post_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_command method.\n        Returns:\n            bool: True if the plugin can handle the post_command method.\"\"\"\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        \"\"\"This method is called after the command is executed.\n        Args:\n            command_name (str): The command name.\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_chat_completion(\n        self,\n        messages: list[Dict[Any, Any]],\n        model: str,\n        temperature: float,\n        max_tokens: int,\n    ) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the chat_completion method.\n        Args:\n            messages (Dict[Any, Any]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            bool: True if the plugin can handle the chat_completion method.\"\"\"\n        return False\n\n    def handle_chat_completion(\n        self,\n        messages: list[Dict[Any, Any]],\n        model: str,\n        temperature: float,\n        max_tokens: int,\n    ) -> str:\n        \"\"\"This method is called when the chat completion is done.\n        Args:\n            messages (Dict[Any, Any]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return None\n\n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass"]}
{"filename": "src/autogpt_plugins/bluesky/bluesky_plugin/bluesky_plugin.py", "chunked_list": ["\"\"\"This module contains functions for interacting with the Bluesky API via atprototools.\"\"\"\nimport os\n\nimport pandas as pd\nfrom atproto import Client\n\n\ndef username_and_pwd_set() -> bool:\n    return True if os.getenv(\"BLUESKY_USERNAME\") and os.getenv(\"BLUESKY_APP_PASSWORD\") else False\n", "\n\ndef post_message(text: str) -> str:\n    \"\"\"Posts a message to Bluesky.\n\n    Args:\n        text (str): The message to post.\n\n    Returns:\n        str: The message that was posted.\n    \"\"\"\n\n    bluesky_username = os.getenv(\"BLUESKY_USERNAME\")\n    bluesky_app_password = os.getenv(\"BLUESKY_APP_PASSWORD\")\n\n    client = Client()\n\n    try:\n        client.login(bluesky_username, bluesky_app_password)\n        client.send_post(text=text)\n    except Exception as e:\n        return f\"Error! Message: {e}\"\n\n    return f\"Success! Message: {text}\"", "\n\ndef get_latest_posts(username: str, number_of_posts=5) -> str | None:\n    \"\"\"Gets the latest posts from a user.\n\n    Args:\n        username (str): The username to get the messages from.\n        number_of_posts (int): The number of posts to get.\n\n    Returns:\n        str | None: The latest posts.\n    \"\"\"\n\n    bluesky_username = os.getenv(\"BLUESKY_USERNAME\")\n    bluesky_app_password = os.getenv(\"BLUESKY_APP_PASSWORD\")\n\n    client = Client()\n\n    try:\n        client.login(bluesky_username, bluesky_app_password)\n        profile_feed = client.bsky.feed.get_author_feed(\n            {'actor': username, 'limit': number_of_posts})\n    except Exception as e:\n        return f\"Error! Message: {e}\"\n\n    columns = [\"URI\", \"Text\", \"Date\", \"User\", \"Likes\", \"Replies\"]\n    posts = []\n\n    for feed in profile_feed.feed:\n        posts.append([feed.post.uri, feed.post.record.text, feed.post.record.createdAt,\n                      feed.post.author.handle, feed.post.likeCount, feed.post.replyCount])\n\n    df = str(pd.DataFrame(posts, columns=columns))\n\n    print(df)\n\n    return df", ""]}
{"filename": "src/autogpt_plugins/bluesky/bluesky_plugin/__init__.py", "chunked_list": [""]}
{"filename": "src/autogpt_plugins/bluesky/bluesky_plugin/test_bluesky_plugin.py", "chunked_list": ["import os\nimport unittest\n\nfrom .bluesky_plugin import get_latest_posts, post_message, username_and_pwd_set\n\nMOCK_USERNAME = \"example.bsky.social\"\nMOCK_MESSAGE = \"Hello, World!\"\n\n\nclass TestBlueskyPlugin(unittest.TestCase):\n    def setUp(self):\n        os.environ[\"BLUESKY_USERNAME\"] = \"example.bsky.social\"\n        os.environ[\"BLUESKY_APP_PASSWORD\"] = \"bsky-social-app-password\"\n\n    def tearDown(self):\n        os.environ.pop(\"BLUESKY_USERNAME\", None)\n        os.environ.pop(\"BLUESKY_APP_PASSWORD\", None)\n\n    def test_username_and_pwd_set(self):\n        self.assertTrue(username_and_pwd_set())\n\n    def test_post_message(self):\n        self.assertIsInstance(post_message(MOCK_MESSAGE), str)\n\n    def test_get_latest_posts(self):\n        self.assertIsInstance(get_latest_posts(MOCK_USERNAME, 5), str)", "\nclass TestBlueskyPlugin(unittest.TestCase):\n    def setUp(self):\n        os.environ[\"BLUESKY_USERNAME\"] = \"example.bsky.social\"\n        os.environ[\"BLUESKY_APP_PASSWORD\"] = \"bsky-social-app-password\"\n\n    def tearDown(self):\n        os.environ.pop(\"BLUESKY_USERNAME\", None)\n        os.environ.pop(\"BLUESKY_APP_PASSWORD\", None)\n\n    def test_username_and_pwd_set(self):\n        self.assertTrue(username_and_pwd_set())\n\n    def test_post_message(self):\n        self.assertIsInstance(post_message(MOCK_MESSAGE), str)\n\n    def test_get_latest_posts(self):\n        self.assertIsInstance(get_latest_posts(MOCK_USERNAME, 5), str)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "src/autogpt_plugins/twitter/twitter.py", "chunked_list": ["\"\"\"This module contains functions for interacting with the Twitter API.\"\"\"\nfrom __future__ import annotations\n\nimport pandas as pd\nimport tweepy\n\nfrom . import AutoGPTTwitter\n\nplugin = AutoGPTTwitter()\n", "plugin = AutoGPTTwitter()\n\n\ndef post_tweet(tweet_text: str) -> str:\n    \"\"\"Posts a tweet to twitter.\n\n    Args:\n        tweet (str): The tweet to post.\n\n    Returns:\n        str: The tweet that was posted.\n    \"\"\"\n\n    _tweetID = plugin.api.update_status(status=tweet_text)\n\n    return f\"Success! Tweet: {_tweetID.text}\"", "\n\ndef post_reply(tweet_text: str, tweet_id: int) -> str:\n    \"\"\"Posts a reply to a tweet.\n\n    Args:\n        tweet (str): The tweet to post.\n        tweet_id (int): The ID of the tweet to reply to.\n\n    Returns:\n        str: The tweet that was posted.\n    \"\"\"\n\n    replyID = plugin.api.update_status(\n        status=tweet_text,\n        in_reply_to_status_id=tweet_id,\n        auto_populate_reply_metadata=True,\n    )\n\n    return f\"Success! Tweet: {replyID.text}\"", "\n\ndef get_mentions() -> str | None:\n    \"\"\"Gets the most recent mention.\n\n    Args:\n        api (tweepy.API): The tweepy API object.\n\n    Returns:\n        str | None: The most recent mention.\n    \"\"\"\n\n    _tweets = plugin.api.mentions_timeline(tweet_mode=\"extended\")\n\n    for tweet in _tweets:\n        return (\n            f\"@{tweet.user.screen_name} Replied: {tweet.full_text}\"\n            f\" Tweet ID: {tweet.id}\"\n        )  # Returns most recent mention", "\n\ndef search_twitter_user(target_user: str, number_of_tweets: int) -> str:\n    \"\"\"Searches a user's tweets given a number of items to retrive and\n      returns a dataframe.\n\n    Args:\n        target_user (str): The user to search.\n        num_of_items (int): The number of items to retrieve.\n        api (tweepy.API): The tweepy API object.\n\n    Returns:\n        str: The dataframe containing the tweets.\n    \"\"\"\n\n    tweets = tweepy.Cursor(\n        plugin.api.user_timeline, screen_name=target_user, tweet_mode=\"extended\"\n    ).items(number_of_tweets)\n\n    columns = [\"Time\", \"User\", \"ID\", \"Tweet\"]\n    data = []\n\n    for tweet in tweets:\n        data.append(\n            [tweet.created_at, tweet.user.screen_name, tweet.id, tweet.full_text]\n        )\n\n    df = str(pd.DataFrame(data, columns=columns))\n\n    print(df)\n\n    return df  # Prints a dataframe object containing the Time, User, ID, and Tweet", ""]}
{"filename": "src/autogpt_plugins/twitter/__init__.py", "chunked_list": ["\"\"\"Twitter API integrations using Tweepy.\"\"\"\nimport os\nfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\nimport tweepy\nfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\nPromptGenerator = TypeVar(\"PromptGenerator\")\n\n\nclass Message(TypedDict):\n    role: str\n    content: str", "\n\nclass Message(TypedDict):\n    role: str\n    content: str\n\n\nclass AutoGPTTwitter(AutoGPTPluginTemplate):\n    \"\"\"\n    Twitter API integrations using Tweepy\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._name = \"autogpt-twitter\"\n        self._version = \"0.1.0\"\n        self._description = \"Twitter API integrations using Tweepy.\"\n        self.twitter_consumer_key = os.getenv(\"TW_CONSUMER_KEY\")\n        self.twitter_consumer_secret = os.getenv(\"TW_CONSUMER_SECRET\")\n        self.twitter_access_token = os.getenv(\"TW_ACCESS_TOKEN\")\n        self.twitter_access_token_secret = os.getenv(\"TW_ACCESS_TOKEN_SECRET\")\n        self.tweet_id = []\n        self.tweets = []\n\n        self.api = None\n\n        if (\n            self.twitter_consumer_key\n            and self.twitter_consumer_secret\n            and self.twitter_access_token\n            and self.twitter_access_token_secret\n        ) is not None:\n            # Authenticating to twitter\n            self.auth = tweepy.OAuth1UserHandler(\n                self.twitter_consumer_key,\n                self.twitter_consumer_secret,\n                self.twitter_access_token,\n                self.twitter_access_token_secret,\n            )\n            self.api = tweepy.API(self.auth)\n            self.stream = tweepy.Stream(\n                self.twitter_consumer_key,\n                self.twitter_consumer_secret,\n                self.twitter_access_token,\n                self.twitter_access_token_secret,\n            )\n        else:\n            print(\"Twitter credentials not found in .env file.\")\n\n    def can_handle_on_response(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_response method.\n        Returns:\n            bool: True if the plugin can handle the on_response method.\"\"\"\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        \"\"\"This method is called when a response is received from the model.\"\"\"\n        pass\n\n    def can_handle_post_prompt(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_prompt method.\n        Returns:\n            bool: True if the plugin can handle the post_prompt method.\"\"\"\n        return True\n\n    def can_handle_on_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_planning method.\n        Returns:\n            bool: True if the plugin can handle the on_planning method.\"\"\"\n        return False\n\n    def on_planning(\n        self, prompt: PromptGenerator, messages: List[str]\n    ) -> Optional[str]:\n        \"\"\"This method is called before the planning chat completeion is done.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n            messages (List[str]): The list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_planning method.\n        Returns:\n            bool: True if the plugin can handle the post_planning method.\"\"\"\n        return False\n\n    def post_planning(self, response: str) -> str:\n        \"\"\"This method is called after the planning chat completeion is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_instruction method.\n        Returns:\n            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n        return False\n\n    def pre_instruction(self, messages: List[str]) -> List[str]:\n        \"\"\"This method is called before the instruction chat is done.\n        Args:\n            messages (List[str]): The list of context messages.\n        Returns:\n            List[str]: The resulting list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_instruction method.\n        Returns:\n            bool: True if the plugin can handle the on_instruction method.\"\"\"\n        return False\n\n    def on_instruction(self, messages: List[str]) -> Optional[str]:\n        \"\"\"This method is called when the instruction chat is done.\n        Args:\n            messages (List[str]): The list of context messages.\n        Returns:\n            Optional[str]: The resulting message.\n        \"\"\"\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_instruction method.\n        Returns:\n            bool: True if the plugin can handle the post_instruction method.\"\"\"\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        \"\"\"This method is called after the instruction chat is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_command method.\n        Returns:\n            bool: True if the plugin can handle the pre_command method.\"\"\"\n        return False\n\n    def pre_command(\n        self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"This method is called before the command is executed.\n        Args:\n            command_name (str): The command name.\n            arguments (Dict[str, Any]): The arguments.\n        Returns:\n            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n        \"\"\"\n        pass\n\n    def can_handle_post_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_command method.\n        Returns:\n            bool: True if the plugin can handle the post_command method.\"\"\"\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        \"\"\"This method is called after the command is executed.\n        Args:\n            command_name (str): The command name.\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_chat_completion(\n        self,\n        messages: list[Dict[Any, Any]],\n        model: str,\n        temperature: float,\n        max_tokens: int,\n    ) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the chat_completion method.\n        Args:\n            messages (Dict[Any, Any]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            bool: True if the plugin can handle the chat_completion method.\"\"\"\n        return False\n\n    def handle_chat_completion(\n        self,\n        messages: list[Dict[Any, Any]],\n        model: str,\n        temperature: float,\n        max_tokens: int,\n    ) -> str:\n        \"\"\"This method is called when the chat completion is done.\n        Args:\n            messages (Dict[Any, Any]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return None\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        \"\"\"This method is called just after the generate_prompt is called,\n            but actually before the prompt is generated.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n        Returns:\n            PromptGenerator: The prompt generator.\n        \"\"\"\n        if self.api:\n            from .twitter import (\n                get_mentions,\n                post_reply,\n                post_tweet,\n                search_twitter_user,\n            )\n\n            prompt.add_command(\n                \"post_tweet\", \"Post Tweet\", {\"tweet_text\": \"<tweet_text>\"}, post_tweet\n            )\n            prompt.add_command(\n                \"post_reply\",\n                \"Post Twitter Reply\",\n                {\"tweet_text\": \"<tweet_text>\", \"tweet_id\": \"<tweet_id>\"},\n                post_reply,\n            )\n            prompt.add_command(\"get_mentions\", \"Get Twitter Mentions\", {}, get_mentions)\n            prompt.add_command(\n                \"search_twitter_user\",\n                \"Search Twitter\",\n                {\n                    \"target_user\": \"<target_user>\",\n                    \"number_of_tweets\": \"<number_of_tweets\",\n                },\n                search_twitter_user,\n            )\n\n        return prompt\n\n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass"]}
{"filename": "src/autogpt_plugins/planner/planner.py", "chunked_list": ["import json\nimport os\n\n\ndef check_plan():\n    \"\"\"this function checks if the file plan.md exists, if it doesn't exist it gets created\"\"\"\n\n    current_working_directory = os.getcwd()\n    workdir = os.path.join(\n        current_working_directory, \"autogpt\", \"auto_gpt_workspace\", \"plan.md\"\n    )\n\n    file_name = workdir\n\n    if not os.path.exists(file_name):\n        with open(file_name, \"w\") as file:\n            file.write(\n                \"\"\"\n                # Task List and status:\n                - [ ] Create a detailed checklist for the current plan and goals\n                - [ ] Finally, review that every new task is completed\n                \n                ## Notes:\n                - Use the run_planning_cycle command frequently to keep this plan up to date.\n                        \"\"\"\n            )\n        print(f\"{file_name} created.\")\n\n    with open(file_name, \"r\") as file:\n        return file.read()", "\n\ndef update_plan():\n    \"\"\"this function checks if the file plan.md exists, if it doesn't exist it gets created\"\"\"\n\n    current_working_directory = os.getcwd()\n    workdir = os.path.join(current_working_directory, 'autogpt', 'auto_gpt_workspace', 'plan.md')\n\n    file_name = workdir\n\n    with open(file_name, 'r') as file:\n        data = file.read()\n\n    response = generate_improved_plan(data)\n\n    with open(file_name, \"w\") as file:\n        file.write(response)\n    print(f\"{file_name} updated.\")\n\n    return response", "\n\ndef generate_improved_plan(prompt: str) -> str:\n    \"\"\"Generate an improved plan using OpenAI's ChatCompletion functionality\"\"\"\n\n    import openai\n\n    tasks = load_tasks()\n\n    model = os.getenv('PLANNER_MODEL', os.getenv('FAST_LLM_MODEL', 'gpt-3.5-turbo'))\n    max_tokens = os.getenv('PLANNER_TOKEN_LIMIT', os.getenv('FAST_TOKEN_LIMIT', 1500))\n    temperature = os.getenv('PLANNER_TEMPERATURE', os.getenv('TEMPERATURE', 0.5))\n\n    # Call the OpenAI API for chat completion\n    response = openai.ChatCompletion.create(\n        model=model,\n        messages=[\n            {\n                \"role\": \"system\",\n                \"content\": \"You are an assistant that improves and adds crucial points to plans in .md format.\",\n            },\n            {\n                \"role\": \"user\",\n                \"content\": f\"Update the following plan given the task status below, keep the .md format:\\n{prompt}\\n\"\n                           f\"Include the current tasks in the improved plan, keep mind of their status and track them \"\n                           f\"with a checklist:\\n{tasks}\\n Revised version should comply with the contents of the \"\n                           f\"tasks at hand:\",\n            },\n        ],\n        max_tokens=int(max_tokens),\n        n=1,\n        temperature=float(temperature),\n    )\n\n    # Extract the improved plan from the response\n    improved_plan = response.choices[0].message.content.strip()\n    return improved_plan", "\n\ndef create_task(task_id=None, task_description: str = None, status=False):\n    task = {\"description\": task_description, \"completed\": status}\n    tasks = load_tasks()\n    tasks[str(task_id)] = task\n\n    current_working_directory = os.getcwd()\n    workdir = os.path.join(\n        current_working_directory, \"autogpt\", \"auto_gpt_workspace\", \"tasks.json\"\n    )\n    file_name = workdir\n\n    with open(file_name, \"w\") as f:\n        json.dump(tasks, f)\n\n    return tasks", "\n\ndef load_tasks() -> dict:\n    current_working_directory = os.getcwd()\n    workdir = os.path.join(\n        current_working_directory, \"autogpt\", \"auto_gpt_workspace\", \"tasks.json\"\n    )\n    file_name = workdir\n\n    if not os.path.exists(file_name):\n        with open(file_name, \"w\") as f:\n            f.write(\"{}\")\n\n    with open(file_name) as f:\n        try:\n            tasks = json.load(f)\n            if isinstance(tasks, list):\n                tasks = {}\n        except json.JSONDecodeError:\n            tasks = {}\n\n    return tasks", "\n\ndef update_task_status(task_id):\n    tasks = load_tasks()\n\n    if str(task_id) not in tasks:\n        print(f\"Task with ID {task_id} not found.\")\n        return\n\n    tasks[str(task_id)][\"completed\"] = True\n\n    current_working_directory = os.getcwd()\n    workdir = os.path.join(\n        current_working_directory, \"autogpt\", \"auto_gpt_workspace\", \"tasks.json\"\n    )\n    file_name = workdir\n\n    with open(file_name, \"w\") as f:\n        json.dump(tasks, f)\n\n    return f\"Task with ID {task_id} has been marked as completed.\"", ""]}
{"filename": "src/autogpt_plugins/planner/__init__.py", "chunked_list": ["\"\"\"This is a task planning system plugin for Auto-GPT. It is able to create tasks, elaborate a plan, improve upon it\nand check it again to keep on track.\n\nbuilt by @rihp on github\"\"\"\n\nfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\nfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\nfrom .planner import (", "\nfrom .planner import (\n    check_plan,\n    create_task,\n    load_tasks,\n    update_plan,\n    update_task_status,\n)\n\nPromptGenerator = TypeVar(\"PromptGenerator\")", "\nPromptGenerator = TypeVar(\"PromptGenerator\")\n\n\nclass Message(TypedDict):\n    role: str\n    content: str\n\n\nclass PlannerPlugin(AutoGPTPluginTemplate):\n    \"\"\"\n    This is a task planner system plugin for Auto-GPT which \n    adds the task planning commands to the prompt.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._name = \"AutoGPT-Planner-Plugin\"\n        self._version = \"0.1.1\"\n        self._description = \"This is a simple task planner module for Auto-GPT. It adds the run_planning_cycle \" \\\n                            \"command along with other task related commands. Creates a plan.md file and tasks.json \" \\\n                            \"to manage the workloads. For help and discussion: \" \\\n                            \"https://discord.com/channels/1092243196446249134/1098737397094694922/threads/1102780261604790393\"\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        \"\"\"This method is called just after the generate_prompt is called,\n        but actually before the prompt is generated.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n        Returns:\n            PromptGenerator: The prompt generator.\n        \"\"\"\n\n        prompt.add_command(\n            \"check_plan\",\n            \"Read the plan.md with the next goals to achieve\",\n            {},\n            check_plan,\n        )\n\n        prompt.add_command(\n            \"run_planning_cycle\",\n            \"Improves the current plan.md and updates it with progress\",\n            {},\n            update_plan,\n        )\n\n        prompt.add_command(\n            \"create_task\",\n            \"creates a task with a task id, description and a completed status of False \",\n            {\n                \"task_id\": \"<int>\",\n                \"task_description\": \"<The task that must be performed>\",\n            },\n            create_task,\n        )\n\n        prompt.add_command(\n            \"load_tasks\",\n            \"Checks out the task ids, their descriptionsand a completed status\",\n            {},\n            load_tasks,\n        )\n\n        prompt.add_command(\n            \"mark_task_completed\",\n            \"Updates the status of a task and marks it as completed\",\n            {\"task_id\": \"<int>\"},\n            update_task_status,\n        )\n\n        return prompt\n\n    def can_handle_post_prompt(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_prompt method.\n        Returns:\n            bool: True if the plugin can handle the post_prompt method.\"\"\"\n        return True\n\n    def can_handle_on_response(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_response method.\n        Returns:\n            bool: True if the plugin can handle the on_response method.\"\"\"\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        \"\"\"This method is called when a response is received from the model.\"\"\"\n        pass\n\n    def can_handle_on_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_planning method.\n        Returns:\n            bool: True if the plugin can handle the on_planning method.\"\"\"\n        return False\n\n    def on_planning(\n            self, prompt: PromptGenerator, messages: List[Message]\n    ) -> Optional[str]:\n        \"\"\"This method is called before the planning chat completion is done.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n            messages (List[str]): The list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_planning method.\n        Returns:\n            bool: True if the plugin can handle the post_planning method.\"\"\"\n        return False\n\n    def post_planning(self, response: str) -> str:\n        \"\"\"This method is called after the planning chat completion is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_instruction method.\n        Returns:\n            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n        return False\n\n    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n        \"\"\"This method is called before the instruction chat is done.\n        Args:\n            messages (List[Message]): The list of context messages.\n        Returns:\n            List[Message]: The resulting list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_instruction method.\n        Returns:\n            bool: True if the plugin can handle the on_instruction method.\"\"\"\n        return False\n\n    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n        \"\"\"This method is called when the instruction chat is done.\n        Args:\n            messages (List[Message]): The list of context messages.\n        Returns:\n            Optional[str]: The resulting message.\n        \"\"\"\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_instruction method.\n        Returns:\n            bool: True if the plugin can handle the post_instruction method.\"\"\"\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        \"\"\"This method is called after the instruction chat is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_command method.\n        Returns:\n            bool: True if the plugin can handle the pre_command method.\"\"\"\n        return False\n\n    def pre_command(\n            self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"This method is called before the command is executed.\n        Args:\n            command_name (str): The command name.\n            arguments (Dict[str, Any]): The arguments.\n        Returns:\n            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n        \"\"\"\n        pass\n\n    def can_handle_post_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_command method.\n        Returns:\n            bool: True if the plugin can handle the post_command method.\"\"\"\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        \"\"\"This method is called after the command is executed.\n        Args:\n            command_name (str): The command name.\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_chat_completion(\n            self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n    ) -> bool:\n        \"\"\"This method is called to check that the plugin can\n          handle the chat_completion method.\n        Args:\n            messages (List[Message]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n          Returns:\n              bool: True if the plugin can handle the chat_completion method.\"\"\"\n        return False\n\n    def handle_chat_completion(\n            self, messages: List[Message], model: str, temperature: float, max_tokens: int\n    ) -> str:\n        \"\"\"This method is called when the chat completion is done.\n        Args:\n            messages (List[Message]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass", "\nclass PlannerPlugin(AutoGPTPluginTemplate):\n    \"\"\"\n    This is a task planner system plugin for Auto-GPT which \n    adds the task planning commands to the prompt.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._name = \"AutoGPT-Planner-Plugin\"\n        self._version = \"0.1.1\"\n        self._description = \"This is a simple task planner module for Auto-GPT. It adds the run_planning_cycle \" \\\n                            \"command along with other task related commands. Creates a plan.md file and tasks.json \" \\\n                            \"to manage the workloads. For help and discussion: \" \\\n                            \"https://discord.com/channels/1092243196446249134/1098737397094694922/threads/1102780261604790393\"\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        \"\"\"This method is called just after the generate_prompt is called,\n        but actually before the prompt is generated.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n        Returns:\n            PromptGenerator: The prompt generator.\n        \"\"\"\n\n        prompt.add_command(\n            \"check_plan\",\n            \"Read the plan.md with the next goals to achieve\",\n            {},\n            check_plan,\n        )\n\n        prompt.add_command(\n            \"run_planning_cycle\",\n            \"Improves the current plan.md and updates it with progress\",\n            {},\n            update_plan,\n        )\n\n        prompt.add_command(\n            \"create_task\",\n            \"creates a task with a task id, description and a completed status of False \",\n            {\n                \"task_id\": \"<int>\",\n                \"task_description\": \"<The task that must be performed>\",\n            },\n            create_task,\n        )\n\n        prompt.add_command(\n            \"load_tasks\",\n            \"Checks out the task ids, their descriptionsand a completed status\",\n            {},\n            load_tasks,\n        )\n\n        prompt.add_command(\n            \"mark_task_completed\",\n            \"Updates the status of a task and marks it as completed\",\n            {\"task_id\": \"<int>\"},\n            update_task_status,\n        )\n\n        return prompt\n\n    def can_handle_post_prompt(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_prompt method.\n        Returns:\n            bool: True if the plugin can handle the post_prompt method.\"\"\"\n        return True\n\n    def can_handle_on_response(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_response method.\n        Returns:\n            bool: True if the plugin can handle the on_response method.\"\"\"\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        \"\"\"This method is called when a response is received from the model.\"\"\"\n        pass\n\n    def can_handle_on_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_planning method.\n        Returns:\n            bool: True if the plugin can handle the on_planning method.\"\"\"\n        return False\n\n    def on_planning(\n            self, prompt: PromptGenerator, messages: List[Message]\n    ) -> Optional[str]:\n        \"\"\"This method is called before the planning chat completion is done.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n            messages (List[str]): The list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_planning method.\n        Returns:\n            bool: True if the plugin can handle the post_planning method.\"\"\"\n        return False\n\n    def post_planning(self, response: str) -> str:\n        \"\"\"This method is called after the planning chat completion is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_instruction method.\n        Returns:\n            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n        return False\n\n    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n        \"\"\"This method is called before the instruction chat is done.\n        Args:\n            messages (List[Message]): The list of context messages.\n        Returns:\n            List[Message]: The resulting list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_instruction method.\n        Returns:\n            bool: True if the plugin can handle the on_instruction method.\"\"\"\n        return False\n\n    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n        \"\"\"This method is called when the instruction chat is done.\n        Args:\n            messages (List[Message]): The list of context messages.\n        Returns:\n            Optional[str]: The resulting message.\n        \"\"\"\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_instruction method.\n        Returns:\n            bool: True if the plugin can handle the post_instruction method.\"\"\"\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        \"\"\"This method is called after the instruction chat is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_command method.\n        Returns:\n            bool: True if the plugin can handle the pre_command method.\"\"\"\n        return False\n\n    def pre_command(\n            self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"This method is called before the command is executed.\n        Args:\n            command_name (str): The command name.\n            arguments (Dict[str, Any]): The arguments.\n        Returns:\n            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n        \"\"\"\n        pass\n\n    def can_handle_post_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_command method.\n        Returns:\n            bool: True if the plugin can handle the post_command method.\"\"\"\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        \"\"\"This method is called after the command is executed.\n        Args:\n            command_name (str): The command name.\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_chat_completion(\n            self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n    ) -> bool:\n        \"\"\"This method is called to check that the plugin can\n          handle the chat_completion method.\n        Args:\n            messages (List[Message]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n          Returns:\n              bool: True if the plugin can handle the chat_completion method.\"\"\"\n        return False\n\n    def handle_chat_completion(\n            self, messages: List[Message], model: str, temperature: float, max_tokens: int\n    ) -> str:\n        \"\"\"This method is called when the chat completion is done.\n        Args:\n            messages (List[Message]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass"]}
{"filename": "src/autogpt_plugins/api_tools/api_tools.py", "chunked_list": ["\"\"\"API Call command for Autogpt.\"\"\"\n\nimport json\nimport re\nimport requests\nfrom typing import Dict, Optional\nfrom urllib.parse import urljoin, urlparse\nfrom urllib.parse import urljoin\nfrom validators import url as is_valid_url\n\nclass ApiCallCommand:\n    \"\"\"\n    A class used to make API calls.\n    \"\"\"\n\n    def sanitize_string(self, input_string: str) -> str:\n        \"\"\"\n        Remove potentially harmful characters from the string.\n\n        Args:\n            input_string (str): The string to sanitize.\n\n        Returns:\n            str: The sanitized string.\n        \"\"\"\n\n        return re.sub(r'[^a-zA-Z0-9_: -{}[\\],\"]', '', input_string)\n    \n    # End of sanitize_string()\n\n\n    def sanitize_json(self, input_string: str) -> str:\n        \"\"\"\n        Sanitize all the values in a JSON string.\n        \n        Args:\n            input_string (str): The JSON string to sanitize.\n            \n        Returns:\n            str: The sanitized JSON string.\n        \"\"\"\n\n        data = json.loads(input_string)\n        sanitized_data = {self.sanitize_string(k): self.sanitize_string(str(v)) for k, v in data.items()}\n        return json.dumps(sanitized_data)\n    \n    # End of sanitize_json()\n\n\n    def sanitize(self, input_string: str) -> str:\n        \"\"\"\n        Remove potentially harmful characters from the input string.\n        \n        Args:\n            input_string (str): The string to sanitize.\n            \n        Returns:\n            str: The sanitized string.\n        \"\"\"\n\n        try:\n            sanitized_string = self.sanitize_json(input_string)\n        except json.JSONDecodeError:\n            sanitized_string = self.sanitize_string(input_string)\n        return sanitized_string\n\n    # End of sanitize()\n\n\n    def make_api_call(self, host = \"\", endpoint = \"\", mthd = \"GET\", params = {}, body = \"\", \n                      hdrs = {\"Content-Type\": \"application/json\"}, timeout = 60) -> str:\n        \"\"\"\n        Return the results of an API call\n        \n        Args:\n            host (str): The host to call.\n            endpoint (str): The endpoint to call.\n            mthd (str): The HTTP method to use.\n            params (dict): The query parameters to use.\n            body (str): The body to use.\n            hdrs (dict): The headers to use.\n            timeout (int): The timeout to use.\n\n        Returns:\n            str: A JSON string containing the results of the API \n                call in the format\n                {\"status\": \"success|error\", \"status_code\": int, \"response\": str, \"response\": str}\n        \"\"\"\n\n        # Initialize variables  \n        response = {}\n\n        # Type-check inputs - host\n        if not isinstance(host, str):\n            raise ValueError(\"host must be a string\")\n        \n        # Type-check inputs - endpoint\n        if not isinstance(endpoint, str):\n            raise ValueError(\"endpoint must be a string\")\n        \n        # Type-check inputs - method\n        if not isinstance(mthd, str):\n            raise ValueError(\"method must be a string\")\n        \n        # Type-check inputs - query_params\n        if not params:\n            params = {}\n        elif isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except json.JSONDecodeError:\n                raise ValueError(\"query_params must be a dictionary\")\n        elif isinstance(params, dict):\n            new_query_params = {}\n            for k, v in params.items():\n                if k is None:\n                    raise ValueError(\"query_params cannot contain None keys\")\n                if not isinstance(k, str):\n                    k = str(k)\n                if v is not None and not isinstance(v, str):\n                    v = str(v)\n                new_query_params[k] = v\n            params = new_query_params\n        else:\n            raise ValueError(\"query_params must be a dictionary or a JSON string\")\n\n        # Type-check inputs - body\n        if not isinstance(body, str):\n            try:\n                body = str(body)\n            except ValueError:\n                raise ValueError(\"body must be a string\")\n            \n        # Type-check inputs - headers\n        if not hdrs:\n            hdrs = {}\n        elif isinstance(hdrs, str):\n            try:\n                hdrs = json.loads(hdrs)\n            except json.JSONDecodeError:\n                raise ValueError(\"headers must be a dictionary\")\n        elif isinstance(hdrs, dict):\n            new_headers = {}\n            for k, v in hdrs.items():\n                if k is None:\n                    raise ValueError(\"headers cannot contain None keys\")\n                if not isinstance(k, str):\n                    k = str(k)\n                if v is not None and not isinstance(v, str):\n                    v = str(v)\n                new_headers[k] = v\n            hdrs = new_headers\n        else:\n            raise ValueError(\"headers must be a dictionary or a JSON string\")\n            \n        # Type-check inputs - timeout_secs\n        if timeout is None:\n            raise ValueError(\"timeout_secs must be an integer\")\n        elif not isinstance(timeout, int):\n            try:\n                timeout = int(timeout)\n            except ValueError:\n                raise ValueError(\"timeout_secs must be an integer\")\n\n        # Validate URL\n        if '?' in host or '&' in host:\n            raise ValueError(\"Invalid URL: Host must not contain query parameters\")\n        sanitized_host = self.sanitize(host)\n        sanitized_endpoint = self.sanitize(endpoint)\n        if not sanitized_host.startswith((\"http://\", \"https://\")):\n            sanitized_host = f\"https://{sanitized_host}\"\n        url = urljoin(sanitized_host, sanitized_endpoint)\n        if not is_valid_url(url): # type: ignore\n            raise ValueError(\"Invalid URL: \" + url)\n        \n        # Validate method\n        allowed_methods = [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"HEAD\", \"OPTIONS\"]\n        sanitized_method = self.sanitize(mthd).upper()    \n        if sanitized_method not in allowed_methods:\n            raise ValueError(\"Invalid method: \" + sanitized_method)\n\n        # Validate timeout_secs\n        if not timeout > 0:\n            raise ValueError(\"timeout_secs must be a positive integer\")\n        \n        # Make the request\n        try:\n            if sanitized_method == \"GET\":\n                response = requests.get(url, params=params, headers=hdrs, timeout=timeout)\n            elif sanitized_method == \"HEAD\":\n                response = requests.head(url, params=params, headers=hdrs, timeout=timeout)\n            elif sanitized_method == \"OPTIONS\":\n                response = requests.options(url, params=params, headers=hdrs, timeout=timeout)\n            elif sanitized_method == \"POST\":\n                response = requests.post(url, params=params, json=body, headers=hdrs, timeout=timeout)\n            elif sanitized_method == \"PUT\":\n                response = requests.put(url, params=params, json=body, headers=hdrs, timeout=timeout)\n            elif sanitized_method == \"DELETE\":\n                response = requests.delete(url, params=params, json=body, headers=hdrs, timeout=timeout)\n            elif sanitized_method == \"PATCH\":\n                response = requests.patch(url, params=params, json=body, headers=hdrs, timeout=timeout)\n            else:\n                raise ValueError(\"Invalid method: \" + mthd)\n            \n            response_text = response.text\n            response = {\n                \"status\": \"success\",\n                \"status_code\": response.status_code,\n                \"response\": response_text\n            }\n\n        except requests.exceptions.RequestException as e:\n            response = {\n                \"status\": \"error\",\n                \"status_code\": None,\n                \"response\": str(e)\n            }\n\n        return json.dumps(response)", "from validators import url as is_valid_url\n\nclass ApiCallCommand:\n    \"\"\"\n    A class used to make API calls.\n    \"\"\"\n\n    def sanitize_string(self, input_string: str) -> str:\n        \"\"\"\n        Remove potentially harmful characters from the string.\n\n        Args:\n            input_string (str): The string to sanitize.\n\n        Returns:\n            str: The sanitized string.\n        \"\"\"\n\n        return re.sub(r'[^a-zA-Z0-9_: -{}[\\],\"]', '', input_string)\n    \n    # End of sanitize_string()\n\n\n    def sanitize_json(self, input_string: str) -> str:\n        \"\"\"\n        Sanitize all the values in a JSON string.\n        \n        Args:\n            input_string (str): The JSON string to sanitize.\n            \n        Returns:\n            str: The sanitized JSON string.\n        \"\"\"\n\n        data = json.loads(input_string)\n        sanitized_data = {self.sanitize_string(k): self.sanitize_string(str(v)) for k, v in data.items()}\n        return json.dumps(sanitized_data)\n    \n    # End of sanitize_json()\n\n\n    def sanitize(self, input_string: str) -> str:\n        \"\"\"\n        Remove potentially harmful characters from the input string.\n        \n        Args:\n            input_string (str): The string to sanitize.\n            \n        Returns:\n            str: The sanitized string.\n        \"\"\"\n\n        try:\n            sanitized_string = self.sanitize_json(input_string)\n        except json.JSONDecodeError:\n            sanitized_string = self.sanitize_string(input_string)\n        return sanitized_string\n\n    # End of sanitize()\n\n\n    def make_api_call(self, host = \"\", endpoint = \"\", mthd = \"GET\", params = {}, body = \"\", \n                      hdrs = {\"Content-Type\": \"application/json\"}, timeout = 60) -> str:\n        \"\"\"\n        Return the results of an API call\n        \n        Args:\n            host (str): The host to call.\n            endpoint (str): The endpoint to call.\n            mthd (str): The HTTP method to use.\n            params (dict): The query parameters to use.\n            body (str): The body to use.\n            hdrs (dict): The headers to use.\n            timeout (int): The timeout to use.\n\n        Returns:\n            str: A JSON string containing the results of the API \n                call in the format\n                {\"status\": \"success|error\", \"status_code\": int, \"response\": str, \"response\": str}\n        \"\"\"\n\n        # Initialize variables  \n        response = {}\n\n        # Type-check inputs - host\n        if not isinstance(host, str):\n            raise ValueError(\"host must be a string\")\n        \n        # Type-check inputs - endpoint\n        if not isinstance(endpoint, str):\n            raise ValueError(\"endpoint must be a string\")\n        \n        # Type-check inputs - method\n        if not isinstance(mthd, str):\n            raise ValueError(\"method must be a string\")\n        \n        # Type-check inputs - query_params\n        if not params:\n            params = {}\n        elif isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except json.JSONDecodeError:\n                raise ValueError(\"query_params must be a dictionary\")\n        elif isinstance(params, dict):\n            new_query_params = {}\n            for k, v in params.items():\n                if k is None:\n                    raise ValueError(\"query_params cannot contain None keys\")\n                if not isinstance(k, str):\n                    k = str(k)\n                if v is not None and not isinstance(v, str):\n                    v = str(v)\n                new_query_params[k] = v\n            params = new_query_params\n        else:\n            raise ValueError(\"query_params must be a dictionary or a JSON string\")\n\n        # Type-check inputs - body\n        if not isinstance(body, str):\n            try:\n                body = str(body)\n            except ValueError:\n                raise ValueError(\"body must be a string\")\n            \n        # Type-check inputs - headers\n        if not hdrs:\n            hdrs = {}\n        elif isinstance(hdrs, str):\n            try:\n                hdrs = json.loads(hdrs)\n            except json.JSONDecodeError:\n                raise ValueError(\"headers must be a dictionary\")\n        elif isinstance(hdrs, dict):\n            new_headers = {}\n            for k, v in hdrs.items():\n                if k is None:\n                    raise ValueError(\"headers cannot contain None keys\")\n                if not isinstance(k, str):\n                    k = str(k)\n                if v is not None and not isinstance(v, str):\n                    v = str(v)\n                new_headers[k] = v\n            hdrs = new_headers\n        else:\n            raise ValueError(\"headers must be a dictionary or a JSON string\")\n            \n        # Type-check inputs - timeout_secs\n        if timeout is None:\n            raise ValueError(\"timeout_secs must be an integer\")\n        elif not isinstance(timeout, int):\n            try:\n                timeout = int(timeout)\n            except ValueError:\n                raise ValueError(\"timeout_secs must be an integer\")\n\n        # Validate URL\n        if '?' in host or '&' in host:\n            raise ValueError(\"Invalid URL: Host must not contain query parameters\")\n        sanitized_host = self.sanitize(host)\n        sanitized_endpoint = self.sanitize(endpoint)\n        if not sanitized_host.startswith((\"http://\", \"https://\")):\n            sanitized_host = f\"https://{sanitized_host}\"\n        url = urljoin(sanitized_host, sanitized_endpoint)\n        if not is_valid_url(url): # type: ignore\n            raise ValueError(\"Invalid URL: \" + url)\n        \n        # Validate method\n        allowed_methods = [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"HEAD\", \"OPTIONS\"]\n        sanitized_method = self.sanitize(mthd).upper()    \n        if sanitized_method not in allowed_methods:\n            raise ValueError(\"Invalid method: \" + sanitized_method)\n\n        # Validate timeout_secs\n        if not timeout > 0:\n            raise ValueError(\"timeout_secs must be a positive integer\")\n        \n        # Make the request\n        try:\n            if sanitized_method == \"GET\":\n                response = requests.get(url, params=params, headers=hdrs, timeout=timeout)\n            elif sanitized_method == \"HEAD\":\n                response = requests.head(url, params=params, headers=hdrs, timeout=timeout)\n            elif sanitized_method == \"OPTIONS\":\n                response = requests.options(url, params=params, headers=hdrs, timeout=timeout)\n            elif sanitized_method == \"POST\":\n                response = requests.post(url, params=params, json=body, headers=hdrs, timeout=timeout)\n            elif sanitized_method == \"PUT\":\n                response = requests.put(url, params=params, json=body, headers=hdrs, timeout=timeout)\n            elif sanitized_method == \"DELETE\":\n                response = requests.delete(url, params=params, json=body, headers=hdrs, timeout=timeout)\n            elif sanitized_method == \"PATCH\":\n                response = requests.patch(url, params=params, json=body, headers=hdrs, timeout=timeout)\n            else:\n                raise ValueError(\"Invalid method: \" + mthd)\n            \n            response_text = response.text\n            response = {\n                \"status\": \"success\",\n                \"status_code\": response.status_code,\n                \"response\": response_text\n            }\n\n        except requests.exceptions.RequestException as e:\n            response = {\n                \"status\": \"error\",\n                \"status_code\": None,\n                \"response\": str(e)\n            }\n\n        return json.dumps(response)", "    \n    # End of call_api()\n\n# End of class ApiCallCommand\n"]}
{"filename": "src/autogpt_plugins/api_tools/test_api_tools.py", "chunked_list": ["import json\nimport random\nimport requests_mock\nimport unittest\ntry:\n    from .api_tools import ApiCallCommand\nexcept ImportError:\n    from api_tools import ApiCallCommand\n\nclass TestAutoGPTAPITools(unittest.TestCase):\n\n    def setUp(self):\n        self.plugin_class = ApiCallCommand()\n\n    def test_api_call_get(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a GET request.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_post(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a POST request.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_put(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a PUT request.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.put('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='PUT')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_delete(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a DELETE request.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.delete('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='DELETE')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_patch(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a PATCH request.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.patch('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='PATCH')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_head(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a HEAD request.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.head('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='HEAD')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_options(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a OPTIONS request.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.options('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='OPTIONS')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    # Test host errors\n\n    def test_api_call_valid_host(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a valid host.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_valid_host_https(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a valid host using HTTPS.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('https://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('https://example.com', '/endpoint')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_host_without_protocol(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a host without a protocol.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('https://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('example.com', '/endpoint')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_host_garbage(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a garbage host.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('garbage', '/endpoint')\n        self.assertIn(\"Invalid URL\", str(excinfo.exception))\n\n    def test_api_call_host_empty(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an empty host.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('', '/endpoint')\n        self.assertIn(\"Invalid URL\", str(excinfo.exception))\n\n    def test_api_call_host_number(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a host that is a number.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call(123, '/endpoint') # type: ignore\n        self.assertIn(\"host must be a string\", str(excinfo.exception))\n\n    def test_api_call_host_none(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with no host.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call(None, '/endpoint') # type: ignore\n        self.assertIn(\"host must be a string\", str(excinfo.exception))\n\n    def test_api_call_host_invalid_protocol(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an invalid protocol.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('ftp://example.com', '/endpoint')\n        self.assertIn(\"Invalid URL\", str(excinfo.exception))\n\n    def test_api_call_host_query_marker(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with dangerous characters.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com?test=1', '/endpoint')\n        self.assertIn(\"Invalid URL\", str(excinfo.exception))\n\n    def test_api_call_host_query_param_marker(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with dangerous characters.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com?test=1', '/endpoint')\n        self.assertIn(\"Invalid URL\", str(excinfo.exception))\n\n    # Test endpoint errors\n\n    def test_api_call_valid_endpoint(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a valid endpoint.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_valid_endpoint_with_query(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a valid endpoint.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint?test=1', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint?test=1')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_endpoint_empty(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an empty endpoint.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_endpoint_number(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an endpoint that is a number.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', 123) # type: ignore\n        self.assertIn(\"endpoint must be a string\", str(excinfo.exception))\n\n    def test_api_call_endpoint_none(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with no endpoint.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', None) # type: ignore\n        self.assertIn(\"endpoint must be a string\", str(excinfo.exception))\n\n    # Test method errors    \n\n    def test_api_call_invalid_method(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an invalid method.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='INVALID')\n        self.assertIn(\"Invalid method: INVALID\", str(excinfo.exception))\n\n    def test_api_call_none_method(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with no method.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd=None) # type: ignore\n        self.assertIn(\"method must be a string\", str(excinfo.exception))\n\n    def test_api_call_empty_method(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an empty method.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='')\n        self.assertIn(\"Invalid method\", str(excinfo.exception))\n\n    def test_api_call_number_method(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a number as a method.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd=123) # type: ignore\n        self.assertIn(\"method must be a string\", str(excinfo.exception))\n\n    def test_api_call_lowercase_method(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a lowercase method.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='get')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    # Test query_params errors\n\n    def test_api_call_valid_query_params_with_number_as_dict_value(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid query_params.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params={'test': 1})\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_query_params_array(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is an array.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', params=['test'])\n        self.assertIn(\"query_params must be a dictionary\", str(excinfo.exception))\n\n    def test_api_call_query_params_string(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is a string.\"\"\"\n        # This is interpreted as JSON and converted to a dictionary\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params='{\"test\": 1}')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_query_params_invalid_json_string(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is an invalid JSON string.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', params='{test\": 1')\n        self.assertIn(\"query_params must be a dictionary\", str(excinfo.exception))\n\n    def test_api_call_query_params_empty_string(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is an empty string.\"\"\"\n        # This should be converted to an empty dictionary\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params='')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_query_params_none(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with no query_params.\"\"\"\n        # This should be converted to an empty dictionary\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params=None)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_query_params_empty_dict(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an empty query_params.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params={})\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_query_params_number(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is a number.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', params=123)\n        self.assertIn(\"query_params must be a dictionary\", str(excinfo.exception))\n\n    def test_api_call_query_params_dict_has_key_none_value(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that has a None value.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params={'test': None})\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_query_params_dict_malformed(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is a malformed dictionary.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', params={None: 'test'})\n        self.assertIn(\"query_params cannot contain None keys\", str(excinfo.exception))\n\n    # Test body errors\n\n    def test_api_call_valid_body_with_24k_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body='a' * 24000)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_valid_body_with_random_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            body_length = random.randint(1, 24000)\n            body = 'a' * body_length\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_valid_body_with_control_code_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body='\\x00')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_valid_body_with_unicode_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=u'\\u2713')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_valid_body_with_utf8_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            body = u'\\u2713'.encode('utf-8')\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body) # type: ignore\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_valid_body_with_utf16_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            body = u'\\u2713'.encode('utf-16')\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body) # type: ignore\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_body_empty(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an empty body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body='')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_body_none(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a None body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=None) # type: ignore\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_body_not_string(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a body that is not a string.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=1) # type: ignore\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_body_json(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a body that is json.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            body = json.dumps({'test': 'test'})\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_body_json_invalid(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a body that is invalid json.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            body = '{\"test\": \"test\"]'\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_body_xml(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a body that is xml.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            body = '<test>test</test>'\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_body_xml_invalid(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a body that is invalid xml.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body='<test>test</test>')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    # Test headers errors\n\n    def test_api_call_valid_headers(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid headers.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs={'test': 'test'})\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_valid_headers_with_random_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid headers.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            headers = {'test': 'a' * random.randint(1, 24000)}\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=headers)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_valid_headers_with_control_code_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid headers.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            headers = {'test': '\\x00'}\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=headers)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_valid_headers_with_unicode_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid headers.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            headers = {'test': u'\\u2713'}\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=headers)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_headers_with_array(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with headers that are an array.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            headers = ['test']\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=headers)\n        self.assertIn(\"headers must be a dictionary\", str(excinfo.exception))\n\n    def test_api_call_headers_with_empty_dict(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with headers that are an empty dict.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs={})\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_headers_with_none(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with headers that are None.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=None)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_headers_with_not_dict(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with headers that are not a dict.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=1)\n        self.assertIn(\"headers must be a dictionary\", str(excinfo.exception))\n\n    def test_api_call_headers_with_invalid_key(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with headers that have an invalid key.\"\"\"\n        headers = {'test': 'test'}\n        headers[1] = 'test' # type: ignore\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200, headers={'test': 'test', '1': 'test'})\n            result = self.plugin_class.make_api_call(host='http://example.com', endpoint='/endpoint', hdrs=headers)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_headers_with_invalid_value(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with headers that have an invalid value.\"\"\"\n        headers = {'test': 'test'}\n        headers['test'] = 1 # type: ignore\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200, headers={'test': '1'})\n            result = self.plugin_class.make_api_call(host='http://example.com', endpoint='/endpoint', hdrs=headers)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    # Test timeout_secs errors\n\n    def test_api_call_valid_timeout_secs(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid timeout_secs.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout=1)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_timeout_secs_with_string(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is a string.\"\"\"\n        # The string will be converted to an integer, so no error will be thrown\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout='1') # type: ignore\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_timeout_secs_with_float(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is a float.\"\"\"\n        # The float will be converted to an integer, so no error will be thrown\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout=1.0) # type: ignore\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_timeout_secs_with_negative_number(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is a negative number.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout=-1)\n        self.assertIn(\"timeout_secs must be a positive integer\", str(excinfo.exception))\n\n    def test_api_call_timeout_secs_with_zero(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is zero.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout=0)\n        self.assertIn(\"timeout_secs must be a positive integer\", str(excinfo.exception))\n\n    def test_api_call_timeout_secs_with_empty_string(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is an empty string.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout='') # type: ignore\n        self.assertIn(\"timeout_secs must be an integer\", str(excinfo.exception))\n\n    def test_api_call_timeout_secs_with_none_value(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is None.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout=None) # type: ignore\n        self.assertIn(\"timeout_secs must be an integer\", str(excinfo.exception))\n\n    def test_api_call_timeout_secs_with_random_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is random text.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout='test') # type: ignore\n        self.assertIn(\"timeout_secs must be an integer\", str(excinfo.exception))\n\n    def test_api_call_timeout_secs_with_control_code_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is a control code.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout='\\x00') # type: ignore\n        self.assertIn(\"timeout_secs must be an integer\", str(excinfo.exception))", "\nclass TestAutoGPTAPITools(unittest.TestCase):\n\n    def setUp(self):\n        self.plugin_class = ApiCallCommand()\n\n    def test_api_call_get(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a GET request.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_post(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a POST request.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_put(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a PUT request.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.put('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='PUT')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_delete(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a DELETE request.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.delete('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='DELETE')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_patch(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a PATCH request.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.patch('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='PATCH')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_head(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a HEAD request.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.head('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='HEAD')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_options(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a OPTIONS request.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.options('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='OPTIONS')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    # Test host errors\n\n    def test_api_call_valid_host(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a valid host.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_valid_host_https(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a valid host using HTTPS.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('https://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('https://example.com', '/endpoint')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_host_without_protocol(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a host without a protocol.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('https://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('example.com', '/endpoint')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_host_garbage(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a garbage host.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('garbage', '/endpoint')\n        self.assertIn(\"Invalid URL\", str(excinfo.exception))\n\n    def test_api_call_host_empty(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an empty host.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('', '/endpoint')\n        self.assertIn(\"Invalid URL\", str(excinfo.exception))\n\n    def test_api_call_host_number(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a host that is a number.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call(123, '/endpoint') # type: ignore\n        self.assertIn(\"host must be a string\", str(excinfo.exception))\n\n    def test_api_call_host_none(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with no host.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call(None, '/endpoint') # type: ignore\n        self.assertIn(\"host must be a string\", str(excinfo.exception))\n\n    def test_api_call_host_invalid_protocol(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an invalid protocol.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('ftp://example.com', '/endpoint')\n        self.assertIn(\"Invalid URL\", str(excinfo.exception))\n\n    def test_api_call_host_query_marker(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with dangerous characters.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com?test=1', '/endpoint')\n        self.assertIn(\"Invalid URL\", str(excinfo.exception))\n\n    def test_api_call_host_query_param_marker(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with dangerous characters.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com?test=1', '/endpoint')\n        self.assertIn(\"Invalid URL\", str(excinfo.exception))\n\n    # Test endpoint errors\n\n    def test_api_call_valid_endpoint(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a valid endpoint.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_valid_endpoint_with_query(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a valid endpoint.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint?test=1', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint?test=1')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_endpoint_empty(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an empty endpoint.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_endpoint_number(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an endpoint that is a number.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', 123) # type: ignore\n        self.assertIn(\"endpoint must be a string\", str(excinfo.exception))\n\n    def test_api_call_endpoint_none(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with no endpoint.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', None) # type: ignore\n        self.assertIn(\"endpoint must be a string\", str(excinfo.exception))\n\n    # Test method errors    \n\n    def test_api_call_invalid_method(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an invalid method.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='INVALID')\n        self.assertIn(\"Invalid method: INVALID\", str(excinfo.exception))\n\n    def test_api_call_none_method(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with no method.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd=None) # type: ignore\n        self.assertIn(\"method must be a string\", str(excinfo.exception))\n\n    def test_api_call_empty_method(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an empty method.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='')\n        self.assertIn(\"Invalid method\", str(excinfo.exception))\n\n    def test_api_call_number_method(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a number as a method.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd=123) # type: ignore\n        self.assertIn(\"method must be a string\", str(excinfo.exception))\n\n    def test_api_call_lowercase_method(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a lowercase method.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='get')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    # Test query_params errors\n\n    def test_api_call_valid_query_params_with_number_as_dict_value(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid query_params.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params={'test': 1})\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_query_params_array(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is an array.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', params=['test'])\n        self.assertIn(\"query_params must be a dictionary\", str(excinfo.exception))\n\n    def test_api_call_query_params_string(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is a string.\"\"\"\n        # This is interpreted as JSON and converted to a dictionary\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params='{\"test\": 1}')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_query_params_invalid_json_string(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is an invalid JSON string.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', params='{test\": 1')\n        self.assertIn(\"query_params must be a dictionary\", str(excinfo.exception))\n\n    def test_api_call_query_params_empty_string(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is an empty string.\"\"\"\n        # This should be converted to an empty dictionary\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params='')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_query_params_none(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with no query_params.\"\"\"\n        # This should be converted to an empty dictionary\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params=None)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_query_params_empty_dict(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an empty query_params.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params={})\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_query_params_number(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is a number.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', params=123)\n        self.assertIn(\"query_params must be a dictionary\", str(excinfo.exception))\n\n    def test_api_call_query_params_dict_has_key_none_value(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that has a None value.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', params={'test': None})\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_query_params_dict_malformed(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with query_params that is a malformed dictionary.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', params={None: 'test'})\n        self.assertIn(\"query_params cannot contain None keys\", str(excinfo.exception))\n\n    # Test body errors\n\n    def test_api_call_valid_body_with_24k_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body='a' * 24000)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_valid_body_with_random_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            body_length = random.randint(1, 24000)\n            body = 'a' * body_length\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_valid_body_with_control_code_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body='\\x00')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_valid_body_with_unicode_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=u'\\u2713')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_valid_body_with_utf8_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            body = u'\\u2713'.encode('utf-8')\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body) # type: ignore\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_valid_body_with_utf16_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            body = u'\\u2713'.encode('utf-16')\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body) # type: ignore\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_body_empty(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with an empty body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body='')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_body_none(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a None body.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=None) # type: ignore\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_body_not_string(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a body that is not a string.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=1) # type: ignore\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_body_json(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a body that is json.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            body = json.dumps({'test': 'test'})\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_body_json_invalid(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a body that is invalid json.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            body = '{\"test\": \"test\"]'\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_body_xml(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a body that is xml.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            body = '<test>test</test>'\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body=body)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_body_xml_invalid(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with a body that is invalid xml.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.post('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', mthd='POST', body='<test>test</test>')\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    # Test headers errors\n\n    def test_api_call_valid_headers(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid headers.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs={'test': 'test'})\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_valid_headers_with_random_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid headers.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            headers = {'test': 'a' * random.randint(1, 24000)}\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=headers)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_valid_headers_with_control_code_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid headers.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            headers = {'test': '\\x00'}\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=headers)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_valid_headers_with_unicode_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid headers.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            headers = {'test': u'\\u2713'}\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=headers)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_headers_with_array(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with headers that are an array.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            headers = ['test']\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=headers)\n        self.assertIn(\"headers must be a dictionary\", str(excinfo.exception))\n\n    def test_api_call_headers_with_empty_dict(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with headers that are an empty dict.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs={})\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_headers_with_none(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with headers that are None.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=None)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_headers_with_not_dict(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with headers that are not a dict.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', hdrs=1)\n        self.assertIn(\"headers must be a dictionary\", str(excinfo.exception))\n\n    def test_api_call_headers_with_invalid_key(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with headers that have an invalid key.\"\"\"\n        headers = {'test': 'test'}\n        headers[1] = 'test' # type: ignore\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200, headers={'test': 'test', '1': 'test'})\n            result = self.plugin_class.make_api_call(host='http://example.com', endpoint='/endpoint', hdrs=headers)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    def test_api_call_headers_with_invalid_value(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with headers that have an invalid value.\"\"\"\n        headers = {'test': 'test'}\n        headers['test'] = 1 # type: ignore\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200, headers={'test': '1'})\n            result = self.plugin_class.make_api_call(host='http://example.com', endpoint='/endpoint', hdrs=headers)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n            self.assertEqual(response['response'], 'success')\n\n    # Test timeout_secs errors\n\n    def test_api_call_valid_timeout_secs(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with valid timeout_secs.\"\"\"\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout=1)\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_timeout_secs_with_string(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is a string.\"\"\"\n        # The string will be converted to an integer, so no error will be thrown\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout='1') # type: ignore\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_timeout_secs_with_float(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is a float.\"\"\"\n        # The float will be converted to an integer, so no error will be thrown\n        with requests_mock.Mocker() as m:\n            m.get('http://example.com/endpoint', text='success', status_code=200)\n            result = self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout=1.0) # type: ignore\n            response = json.loads(result)\n\n            self.assertEqual(response['status'], 'success')\n            self.assertEqual(response['status_code'], 200)\n\n    def test_api_call_timeout_secs_with_negative_number(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is a negative number.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout=-1)\n        self.assertIn(\"timeout_secs must be a positive integer\", str(excinfo.exception))\n\n    def test_api_call_timeout_secs_with_zero(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is zero.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout=0)\n        self.assertIn(\"timeout_secs must be a positive integer\", str(excinfo.exception))\n\n    def test_api_call_timeout_secs_with_empty_string(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is an empty string.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout='') # type: ignore\n        self.assertIn(\"timeout_secs must be an integer\", str(excinfo.exception))\n\n    def test_api_call_timeout_secs_with_none_value(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is None.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout=None) # type: ignore\n        self.assertIn(\"timeout_secs must be an integer\", str(excinfo.exception))\n\n    def test_api_call_timeout_secs_with_random_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is random text.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout='test') # type: ignore\n        self.assertIn(\"timeout_secs must be an integer\", str(excinfo.exception))\n\n    def test_api_call_timeout_secs_with_control_code_text(self):\n        \"\"\"Test the self.plugin_class.make_api_call() function with timeout_secs that is a control code.\"\"\"\n        with self.assertRaises(ValueError) as excinfo:\n            self.plugin_class.make_api_call('http://example.com', '/endpoint', timeout='\\x00') # type: ignore\n        self.assertIn(\"timeout_secs must be an integer\", str(excinfo.exception))", ""]}
{"filename": "src/autogpt_plugins/api_tools/__init__.py", "chunked_list": ["\"\"\"API Tools for Autogpt.\"\"\"\n\nfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\nfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\ntry:\n    from .api_tools import ApiCallCommand\nexcept ImportError:\n    from api_tools import ApiCallCommand\n", "\n\nPromptGenerator = TypeVar(\"PromptGenerator\")\n\nclass Message(TypedDict):\n    \"\"\"Message type.\"\"\"\n    role: str\n    content: str\n\nclass AutoGPTApiTools(AutoGPTPluginTemplate):\n    \"\"\"\n    API Tools plugin for Autogpt.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._name = \"AutoGPTApiTools\"\n        self._version = \"0.1.2\"\n        self._description = \"Allow AutoGPT to make API calls to outside services.\"\n\n        self.plugin_class = ApiCallCommand()\n\n    def can_handle_on_response(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_response method.\n        Returns:\n            bool: True if the plugin can handle the on_response method.\"\"\"\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        \"\"\"This method is called when a response is received from the model.\"\"\"\n        return response\n\n    def can_handle_post_prompt(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_prompt method.\n        Returns:\n            bool: True if the plugin can handle the post_prompt method.\"\"\"\n        return True\n\n    def can_handle_on_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_planning method.\n        Returns:\n            bool: True if the plugin can handle the on_planning method.\"\"\"\n        return False\n\n    def on_planning(\n            self, prompt: PromptGenerator, messages: List[str]\n    ) -> Optional[str]:\n        \"\"\"This method is called before the planning chat completeion is done.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n            messages (List[str]): The list of messages.\n        \"\"\"\n\n    def can_handle_post_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_planning method.\n        Returns:\n            bool: True if the plugin can handle the post_planning method.\"\"\"\n        return False\n\n    def post_planning(self, response: str) -> str:\n        \"\"\"This method is called after the planning chat completeion is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return response\n\n    def can_handle_pre_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_instruction method.\n        Returns:\n            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n        return False\n\n    def pre_instruction(self, messages: List[str]) -> List[str]:\n        \"\"\"This method is called before the instruction chat is done.\n        Args:\n            messages (List[str]): The list of context messages.\n        Returns:\n            List[str]: The resulting list of messages.\n        \"\"\"\n        return messages\n\n    def can_handle_on_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_instruction method.\n        Returns:\n            bool: True if the plugin can handle the on_instruction method.\"\"\"\n        return False\n\n    def on_instruction(self, messages: List[str]) -> Optional[str]:\n        \"\"\"This method is called when the instruction chat is done.\n        Args:\n            messages (List[str]): The list of context messages.\n        Returns:\n            Optional[str]: The resulting message.\n        \"\"\"\n\n    def can_handle_post_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_instruction method.\n        Returns:\n            bool: True if the plugin can handle the post_instruction method.\"\"\"\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        \"\"\"This method is called after the instruction chat is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return response\n\n    def can_handle_pre_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_command method.\n        Returns:\n            bool: True if the plugin can handle the pre_command method.\"\"\"\n        return False\n\n    def pre_command(\n            self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"This method is called before the command is executed.\n        Args:\n            command_name (str): The command name.\n            arguments (Dict[str, Any]): The arguments.\n        Returns:\n            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n        \"\"\"\n        return command_name, arguments\n\n    def can_handle_post_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_command method.\n        Returns:\n            bool: True if the plugin can handle the post_command method.\"\"\"\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        \"\"\"This method is called after the command is executed.\n        Args:\n            command_name (str): The command name.\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return ''\n\n    def can_handle_chat_completion(\n            self,\n            messages: list[Dict[Any, Any]],\n            model: str,\n            temperature: float,\n            max_tokens: int,\n    ) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the chat_completion method.\n        Args:\n            messages (Dict[Any, Any]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            bool: True if the plugin can handle the chat_completion method.\"\"\"\n        return False\n\n    def handle_chat_completion(\n            self,\n            messages: list[Dict[Any, Any]],\n            model: str,\n            temperature: float,\n            max_tokens: int,\n    ) -> str:\n        \"\"\"This method is called when the chat completion is done.\n        Args:\n            messages (Dict[Any, Any]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return ''\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        \"\"\"This method is called just after the generate_prompt is called,\n            but actually before the prompt is generated.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n        Returns:\n            PromptGenerator: The prompt generator.\n        \"\"\"\n\n        prompt.add_command( # type: ignore\n            \"api\",\n            \"API Call\",\n            {\"host\": \"<str>\", \"endpoint\": \"<str>\", \"mthd\": \"<str>\", \"params\": \"<dict>\", \"body\": \"<str>\", \"hdrs\": \"<dict>\", \"timeout\": \"<int>\"},\n            self.plugin_class.make_api_call\n        )\n        return prompt\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n    \n    def user_input(self, user_input: str) -> str:\n        return user_input\n    \n    def can_handle_report(self) -> bool:\n        return False\n    \n    def report(self, message: str) -> None:\n        pass\n\n    def can_handle_text_embedding(self, text: str) -> bool:\n        return False\n    \n    def handle_text_embedding(self, text: str) -> list:  # type: ignore\n        pass", "\nclass AutoGPTApiTools(AutoGPTPluginTemplate):\n    \"\"\"\n    API Tools plugin for Autogpt.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._name = \"AutoGPTApiTools\"\n        self._version = \"0.1.2\"\n        self._description = \"Allow AutoGPT to make API calls to outside services.\"\n\n        self.plugin_class = ApiCallCommand()\n\n    def can_handle_on_response(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_response method.\n        Returns:\n            bool: True if the plugin can handle the on_response method.\"\"\"\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        \"\"\"This method is called when a response is received from the model.\"\"\"\n        return response\n\n    def can_handle_post_prompt(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_prompt method.\n        Returns:\n            bool: True if the plugin can handle the post_prompt method.\"\"\"\n        return True\n\n    def can_handle_on_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_planning method.\n        Returns:\n            bool: True if the plugin can handle the on_planning method.\"\"\"\n        return False\n\n    def on_planning(\n            self, prompt: PromptGenerator, messages: List[str]\n    ) -> Optional[str]:\n        \"\"\"This method is called before the planning chat completeion is done.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n            messages (List[str]): The list of messages.\n        \"\"\"\n\n    def can_handle_post_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_planning method.\n        Returns:\n            bool: True if the plugin can handle the post_planning method.\"\"\"\n        return False\n\n    def post_planning(self, response: str) -> str:\n        \"\"\"This method is called after the planning chat completeion is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return response\n\n    def can_handle_pre_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_instruction method.\n        Returns:\n            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n        return False\n\n    def pre_instruction(self, messages: List[str]) -> List[str]:\n        \"\"\"This method is called before the instruction chat is done.\n        Args:\n            messages (List[str]): The list of context messages.\n        Returns:\n            List[str]: The resulting list of messages.\n        \"\"\"\n        return messages\n\n    def can_handle_on_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_instruction method.\n        Returns:\n            bool: True if the plugin can handle the on_instruction method.\"\"\"\n        return False\n\n    def on_instruction(self, messages: List[str]) -> Optional[str]:\n        \"\"\"This method is called when the instruction chat is done.\n        Args:\n            messages (List[str]): The list of context messages.\n        Returns:\n            Optional[str]: The resulting message.\n        \"\"\"\n\n    def can_handle_post_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_instruction method.\n        Returns:\n            bool: True if the plugin can handle the post_instruction method.\"\"\"\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        \"\"\"This method is called after the instruction chat is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return response\n\n    def can_handle_pre_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_command method.\n        Returns:\n            bool: True if the plugin can handle the pre_command method.\"\"\"\n        return False\n\n    def pre_command(\n            self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"This method is called before the command is executed.\n        Args:\n            command_name (str): The command name.\n            arguments (Dict[str, Any]): The arguments.\n        Returns:\n            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n        \"\"\"\n        return command_name, arguments\n\n    def can_handle_post_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_command method.\n        Returns:\n            bool: True if the plugin can handle the post_command method.\"\"\"\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        \"\"\"This method is called after the command is executed.\n        Args:\n            command_name (str): The command name.\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return ''\n\n    def can_handle_chat_completion(\n            self,\n            messages: list[Dict[Any, Any]],\n            model: str,\n            temperature: float,\n            max_tokens: int,\n    ) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the chat_completion method.\n        Args:\n            messages (Dict[Any, Any]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            bool: True if the plugin can handle the chat_completion method.\"\"\"\n        return False\n\n    def handle_chat_completion(\n            self,\n            messages: list[Dict[Any, Any]],\n            model: str,\n            temperature: float,\n            max_tokens: int,\n    ) -> str:\n        \"\"\"This method is called when the chat completion is done.\n        Args:\n            messages (Dict[Any, Any]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return ''\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        \"\"\"This method is called just after the generate_prompt is called,\n            but actually before the prompt is generated.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n        Returns:\n            PromptGenerator: The prompt generator.\n        \"\"\"\n\n        prompt.add_command( # type: ignore\n            \"api\",\n            \"API Call\",\n            {\"host\": \"<str>\", \"endpoint\": \"<str>\", \"mthd\": \"<str>\", \"params\": \"<dict>\", \"body\": \"<str>\", \"hdrs\": \"<dict>\", \"timeout\": \"<int>\"},\n            self.plugin_class.make_api_call\n        )\n        return prompt\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n    \n    def user_input(self, user_input: str) -> str:\n        return user_input\n    \n    def can_handle_report(self) -> bool:\n        return False\n    \n    def report(self, message: str) -> None:\n        pass\n\n    def can_handle_text_embedding(self, text: str) -> bool:\n        return False\n    \n    def handle_text_embedding(self, text: str) -> list:  # type: ignore\n        pass"]}
{"filename": "src/autogpt_plugins/wolframalpha_search/__init__.py", "chunked_list": ["\"\"\"WolframAlpha search integrations.\"\"\"\nimport os\nfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\nfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\nfrom wolframalpha import Client\n\nPromptGenerator = TypeVar(\"PromptGenerator\")\n\n\nclass Message(TypedDict):\n    role: str\n    content: str", "\n\nclass Message(TypedDict):\n    role: str\n    content: str\n\n\nclass AutoGPTWolframAlphaSearch(AutoGPTPluginTemplate):\n    \"\"\"\n    WolframAlpha search integrations\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._name = \"autogpt-wolframalpha-search\"\n        self._version = \"0.1.0\"\n        self._description = (\"WolframAlpha is an answer engine, it answers \"\n                             \"factual queries by computing answers from \"\n                             \"externally sourced data. It can provide answers \"\n                             \"to math, data and science queries.\")\n        self.wolframalpha_appid = os.getenv(\"WOLFRAMALPHA_APPID\")\n\n        self.api = None\n        if self.wolframalpha_appid is not None:\n            self.api = Client(self.wolframalpha_appid)\n        else:\n            print(\"WolframAlpha AppID not found in .env file.\")\n\n    def can_handle_on_response(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_response method.\n        Returns:\n            bool: True if the plugin can handle the on_response method.\"\"\"\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        \"\"\"This method is called when a response is received from the model.\"\"\"\n        pass\n\n    def can_handle_post_prompt(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_prompt method.\n        Returns:\n            bool: True if the plugin can handle the post_prompt method.\"\"\"\n        return True\n\n    def can_handle_on_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_planning method.\n        Returns:\n            bool: True if the plugin can handle the on_planning method.\"\"\"\n        return False\n\n    def on_planning(\n            self, prompt: PromptGenerator, messages: List[str]\n    ) -> Optional[str]:\n        \"\"\"This method is called before the planning chat completeion is done.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n            messages (List[str]): The list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_planning method.\n        Returns:\n            bool: True if the plugin can handle the post_planning method.\"\"\"\n        return False\n\n    def post_planning(self, response: str) -> str:\n        \"\"\"This method is called after the planning chat completeion is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_instruction method.\n        Returns:\n            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n        return False\n\n    def pre_instruction(self, messages: List[str]) -> List[str]:\n        \"\"\"This method is called before the instruction chat is done.\n        Args:\n            messages (List[str]): The list of context messages.\n        Returns:\n            List[str]: The resulting list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_instruction method.\n        Returns:\n            bool: True if the plugin can handle the on_instruction method.\"\"\"\n        return False\n\n    def on_instruction(self, messages: List[str]) -> Optional[str]:\n        \"\"\"This method is called when the instruction chat is done.\n        Args:\n            messages (List[str]): The list of context messages.\n        Returns:\n            Optional[str]: The resulting message.\n        \"\"\"\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_instruction method.\n        Returns:\n            bool: True if the plugin can handle the post_instruction method.\"\"\"\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        \"\"\"This method is called after the instruction chat is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_command method.\n        Returns:\n            bool: True if the plugin can handle the pre_command method.\"\"\"\n        return False\n\n    def pre_command(\n            self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"This method is called before the command is executed.\n        Args:\n            command_name (str): The command name.\n            arguments (Dict[str, Any]): The arguments.\n        Returns:\n            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n        \"\"\"\n        pass\n\n    def can_handle_post_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_command method.\n        Returns:\n            bool: True if the plugin can handle the post_command method.\"\"\"\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        \"\"\"This method is called after the command is executed.\n        Args:\n            command_name (str): The command name.\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_chat_completion(\n            self,\n            messages: list[Dict[Any, Any]],\n            model: str,\n            temperature: float,\n            max_tokens: int,\n    ) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the chat_completion method.\n        Args:\n            messages (Dict[Any, Any]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            bool: True if the plugin can handle the chat_completion method.\"\"\"\n        return False\n\n    def handle_chat_completion(\n            self,\n            messages: list[Dict[Any, Any]],\n            model: str,\n            temperature: float,\n            max_tokens: int,\n    ) -> str:\n        \"\"\"This method is called when the chat completion is done.\n        Args:\n            messages (Dict[Any, Any]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return None\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        \"\"\"This method is called just after the generate_prompt is called,\n            but actually before the prompt is generated.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n        Returns:\n            PromptGenerator: The prompt generator.\n        \"\"\"\n        if self.api:\n            from .wolframalpha_search import _wolframalpha_search\n            prompt.add_command(\n                \"wolframalpha_search\",\n                self._description,\n                {\"query\": \"<query>\"},\n                _wolframalpha_search,\n            )\n        return prompt\n\n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass"]}
{"filename": "src/autogpt_plugins/wolframalpha_search/test_wolframalpha_search.py", "chunked_list": ["import os\nimport unittest\n\nimport requests\n\nfrom . import AutoGPTWolframAlphaSearch\n\n\nclass TestAutoGPTWolframAlphaSearch(unittest.TestCase):\n    def setUp(self):\n        os.environ[\"WOLFRAMALPHA_APPID\"] = \"test_appid\"\n        self.plugin = AutoGPTWolframAlphaSearch()\n\n    def tearDown(self):\n        os.environ.pop(\"WOLFRAMALPHA_APPID\", None)\n\n    def test_wolframalpha_search(self):\n        query = \"2+2\"\n        try:\n            from .wolframalpha_search import _wolframalpha_search\n            _wolframalpha_search(query)\n        except requests.exceptions.HTTPError as e:\n            self.assertEqual(e.response.status_code, 401)", "class TestAutoGPTWolframAlphaSearch(unittest.TestCase):\n    def setUp(self):\n        os.environ[\"WOLFRAMALPHA_APPID\"] = \"test_appid\"\n        self.plugin = AutoGPTWolframAlphaSearch()\n\n    def tearDown(self):\n        os.environ.pop(\"WOLFRAMALPHA_APPID\", None)\n\n    def test_wolframalpha_search(self):\n        query = \"2+2\"\n        try:\n            from .wolframalpha_search import _wolframalpha_search\n            _wolframalpha_search(query)\n        except requests.exceptions.HTTPError as e:\n            self.assertEqual(e.response.status_code, 401)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "src/autogpt_plugins/wolframalpha_search/wolframalpha_search.py", "chunked_list": ["from . import AutoGPTWolframAlphaSearch\n\nplugin = AutoGPTWolframAlphaSearch()\n\n\ndef _wolframalpha_search(query: str) -> str | list[str]:\n    res = \"\"\n    try:\n        ans = plugin.api.query(query)\n        res = next(ans.results).text\n    except Exception as e:\n        return f\"'_wolframalpha_search' on query: '{query}' raised exception: '{e}'\"\n    return res", ""]}
{"filename": "src/autogpt_plugins/scenex/test_scenex_plugin.py", "chunked_list": ["from .scenex_plugin import SceneXplain\n\nMOCK_API_KEY = \"secret\"\nMOCK_IMAGE = \"https://example.com/image.png\"\nMOCK_DESCRIPTION = \"example description\"\n\n\ndef test_describe_image(requests_mock):\n    requests_mock.post(\n        SceneXplain.API_ENDPOINT,\n        json={\n            \"result\": [\n                {\n                    \"image\": MOCK_IMAGE,\n                    \"text\": MOCK_DESCRIPTION,\n                }\n            ]\n        },\n    )\n\n    scenex = SceneXplain(MOCK_API_KEY)\n    result = scenex.describe_image(\n        image=MOCK_IMAGE,\n        algorithm=\"Dune\",\n        features=[],\n        languages=[],\n    )\n\n    # Check the results\n    assert result == {\n        \"image\": MOCK_IMAGE,\n        \"description\": MOCK_DESCRIPTION,\n    }\n\n    # Check that the mocked functions were called with the correct arguments\n    requests_mock.request_history[0].json() == {\n        \"data\": [\n            {\n                \"image\": MOCK_IMAGE,\n                \"algorithm\": \"Dune\",\n                \"features\": [],\n                \"languages\": [],\n            }\n        ]\n    }", ""]}
{"filename": "src/autogpt_plugins/scenex/__init__.py", "chunked_list": ["\"\"\"This is a SceneX plugin for describing images for Auto-GPT.\"\"\"\nimport os\nfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\nfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\nfrom colorama import Fore\n\nfrom .scenex_plugin import SceneXplain\n\nPromptGenerator = TypeVar(\"PromptGenerator\")", "\nPromptGenerator = TypeVar(\"PromptGenerator\")\n\n\nclass Message(TypedDict):\n    role: str\n    content: str\n\n\nclass AutoGPTSceneXPlugin(AutoGPTPluginTemplate):\n    \"\"\"\n    This is the Auto-GPT SceneX plugin.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._name = \"ImageExplainer\"\n        self._version = \"0.0.1\"\n        self._description = (\n            \"An Image Captioning Tool: Use this tool to generate a detailed caption for an image. \"\n            \"The input can be an image file of any format, and \"\n            \"the output will be a text description that covers every detail of the image.\"\n        )\n        self._api_key = os.getenv(\"SCENEX_API_KEY\")\n        self.scenexplain = SceneXplain(self._api_key)\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        if self._api_key:\n            prompt.add_command(\n                self._description,\n                \"describe_image\",\n                {\n                    \"image\": \"<image>\",\n                },\n                self.scenexplain.describe_image,\n            )\n        else:\n            print(\n                Fore.RED\n                + f\"{self._name} - {self._version} - SceneX plugin not loaded, because SCENEX_API_KEY was not set in env.\"\n            )\n\n        return prompt\n\n    def can_handle_post_prompt(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_prompt method.\n\n        Returns:\n            bool: True if the plugin can handle the post_prompt method.\"\"\"\n        return True\n\n    def can_handle_on_response(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_response method.\n\n        Returns:\n            bool: True if the plugin can handle the on_response method.\"\"\"\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        \"\"\"This method is called when a response is received from the model.\"\"\"\n        pass\n\n    def can_handle_on_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_planning method.\n\n        Returns:\n            bool: True if the plugin can handle the on_planning method.\"\"\"\n        return False\n\n    def on_planning(\n        self, prompt: PromptGenerator, messages: List[Message]\n    ) -> Optional[str]:\n        \"\"\"This method is called before the planning chat completion is done.\n\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n            messages (List[str]): The list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_planning method.\n\n        Returns:\n            bool: True if the plugin can handle the post_planning method.\"\"\"\n        return False\n\n    def post_planning(self, response: str) -> str:\n        \"\"\"This method is called after the planning chat completion is done.\n\n        Args:\n            response (str): The response.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_instruction method.\n\n        Returns:\n            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n        return False\n\n    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n        \"\"\"This method is called before the instruction chat is done.\n\n        Args:\n            messages (List[Message]): The list of context messages.\n\n        Returns:\n            List[Message]: The resulting list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_instruction method.\n\n        Returns:\n            bool: True if the plugin can handle the on_instruction method.\"\"\"\n        return False\n\n    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n        \"\"\"This method is called when the instruction chat is done.\n\n        Args:\n            messages (List[Message]): The list of context messages.\n\n        Returns:\n            Optional[str]: The resulting message.\n        \"\"\"\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_instruction method.\n\n        Returns:\n            bool: True if the plugin can handle the post_instruction method.\"\"\"\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        \"\"\"This method is called after the instruction chat is done.\n\n        Args:\n            response (str): The response.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_command method.\n\n        Returns:\n            bool: True if the plugin can handle the pre_command method.\"\"\"\n        return False\n\n    def pre_command(\n        self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"This method is called before the command is executed.\n\n        Args:\n            command_name (str): The command name.\n            arguments (Dict[str, Any]): The arguments.\n\n        Returns:\n            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n        \"\"\"\n        pass\n\n    def can_handle_post_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_command method.\n\n        Returns:\n            bool: True if the plugin can handle the post_command method.\"\"\"\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        \"\"\"This method is called after the command is executed.\n\n        Args:\n            command_name (str): The command name.\n            response (str): The response.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_chat_completion(\n        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n    ) -> bool:\n        \"\"\"This method is called to check that the plugin can\n          handle the chat_completion method.\n\n        Args:\n            messages (List[Message]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n\n          Returns:\n              bool: True if the plugin can handle the chat_completion method.\"\"\"\n        return False\n\n    def handle_chat_completion(\n        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n    ) -> str:\n        \"\"\"This method is called when the chat completion is done.\n\n        Args:\n            messages (List[Message]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass", "\nclass AutoGPTSceneXPlugin(AutoGPTPluginTemplate):\n    \"\"\"\n    This is the Auto-GPT SceneX plugin.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._name = \"ImageExplainer\"\n        self._version = \"0.0.1\"\n        self._description = (\n            \"An Image Captioning Tool: Use this tool to generate a detailed caption for an image. \"\n            \"The input can be an image file of any format, and \"\n            \"the output will be a text description that covers every detail of the image.\"\n        )\n        self._api_key = os.getenv(\"SCENEX_API_KEY\")\n        self.scenexplain = SceneXplain(self._api_key)\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        if self._api_key:\n            prompt.add_command(\n                self._description,\n                \"describe_image\",\n                {\n                    \"image\": \"<image>\",\n                },\n                self.scenexplain.describe_image,\n            )\n        else:\n            print(\n                Fore.RED\n                + f\"{self._name} - {self._version} - SceneX plugin not loaded, because SCENEX_API_KEY was not set in env.\"\n            )\n\n        return prompt\n\n    def can_handle_post_prompt(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_prompt method.\n\n        Returns:\n            bool: True if the plugin can handle the post_prompt method.\"\"\"\n        return True\n\n    def can_handle_on_response(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_response method.\n\n        Returns:\n            bool: True if the plugin can handle the on_response method.\"\"\"\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        \"\"\"This method is called when a response is received from the model.\"\"\"\n        pass\n\n    def can_handle_on_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_planning method.\n\n        Returns:\n            bool: True if the plugin can handle the on_planning method.\"\"\"\n        return False\n\n    def on_planning(\n        self, prompt: PromptGenerator, messages: List[Message]\n    ) -> Optional[str]:\n        \"\"\"This method is called before the planning chat completion is done.\n\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n            messages (List[str]): The list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_planning method.\n\n        Returns:\n            bool: True if the plugin can handle the post_planning method.\"\"\"\n        return False\n\n    def post_planning(self, response: str) -> str:\n        \"\"\"This method is called after the planning chat completion is done.\n\n        Args:\n            response (str): The response.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_instruction method.\n\n        Returns:\n            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n        return False\n\n    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n        \"\"\"This method is called before the instruction chat is done.\n\n        Args:\n            messages (List[Message]): The list of context messages.\n\n        Returns:\n            List[Message]: The resulting list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_instruction method.\n\n        Returns:\n            bool: True if the plugin can handle the on_instruction method.\"\"\"\n        return False\n\n    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n        \"\"\"This method is called when the instruction chat is done.\n\n        Args:\n            messages (List[Message]): The list of context messages.\n\n        Returns:\n            Optional[str]: The resulting message.\n        \"\"\"\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_instruction method.\n\n        Returns:\n            bool: True if the plugin can handle the post_instruction method.\"\"\"\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        \"\"\"This method is called after the instruction chat is done.\n\n        Args:\n            response (str): The response.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_command method.\n\n        Returns:\n            bool: True if the plugin can handle the pre_command method.\"\"\"\n        return False\n\n    def pre_command(\n        self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"This method is called before the command is executed.\n\n        Args:\n            command_name (str): The command name.\n            arguments (Dict[str, Any]): The arguments.\n\n        Returns:\n            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n        \"\"\"\n        pass\n\n    def can_handle_post_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_command method.\n\n        Returns:\n            bool: True if the plugin can handle the post_command method.\"\"\"\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        \"\"\"This method is called after the command is executed.\n\n        Args:\n            command_name (str): The command name.\n            response (str): The response.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_chat_completion(\n        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n    ) -> bool:\n        \"\"\"This method is called to check that the plugin can\n          handle the chat_completion method.\n\n        Args:\n            messages (List[Message]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n\n          Returns:\n              bool: True if the plugin can handle the chat_completion method.\"\"\"\n        return False\n\n    def handle_chat_completion(\n        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n    ) -> str:\n        \"\"\"This method is called when the chat completion is done.\n\n        Args:\n            messages (List[Message]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass"]}
{"filename": "src/autogpt_plugins/scenex/scenex_plugin.py", "chunked_list": ["from typing import List, Union\n\nimport requests\n\nAlgorithm = Union[\"Aqua\", \"Bolt\", \"Comet\", \"Dune\", \"Ember\", \"Flash\"]\n\n\nclass SceneXplain:\n    API_ENDPOINT = \"https://us-central1-causal-diffusion.cloudfunctions.net/describe\"\n\n    def __init__(self, api_key):\n        self._api_key = api_key\n\n    def describe_image(\n        self,\n        image: str,\n        algorithm: Algorithm = \"Dune\",\n        features: List[str] = [],\n        languages: List[str] = [],\n    ) -> str:\n        headers = {\n            \"x-api-key\": f\"token {self._api_key}\",\n            \"content-type\": \"application/json\",\n        }\n\n        payload = {\n            \"data\": [\n                {\n                    \"image\": image,\n                    \"algorithm\": algorithm,\n                    \"features\": features,\n                    \"languages\": languages,\n                }\n            ]\n        }\n\n        response = requests.post(self.API_ENDPOINT, headers=headers, json=payload)\n        result = response.json().get(\"result\", [])\n        img = result[0] if result else {}\n\n        return {\"image\": image, \"description\": img.get(\"text\", \"\")}", ""]}
{"filename": "src/autogpt_plugins/astro/test_astro_plugin.py", "chunked_list": ["from .astronauts import get_num_astronauts\n\n\ndef test_astro():\n    assert type(get_num_astronauts())==int"]}
{"filename": "src/autogpt_plugins/astro/__init__.py", "chunked_list": ["\"\"\"This is the email plugin for Auto-GPT.\"\"\"\nimport os\nfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\nfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\nPromptGenerator = TypeVar(\"PromptGenerator\")\n\n\nclass Message(TypedDict):\n    role: str\n    content: str", "\nclass Message(TypedDict):\n    role: str\n    content: str\n\n\nclass AutoGPTSpacePlugin(AutoGPTPluginTemplate):\n    \"\"\"\n    This is the Auto-GPT space plugin.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._name = \"Auto-GPT-Space-Plugin\"\n        self._version = \"0.1.3\"\n        self._description = \"Auto-GPT Space Plugin: Get the number of astronauts in space in real-time..\"\n        self.load_commands = True\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        if self.load_commands:\n            from .astronauts import get_num_astronauts\n\n            prompt.add_command(\n                \"Get number of astronauts\",\n                \"get_num_astronauts\",\n                {},\n                get_num_astronauts,\n            )\n\n        return prompt\n\n    def can_handle_post_prompt(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_prompt method.\n\n        Returns:\n            bool: True if the plugin can handle the post_prompt method.\"\"\"\n        return True\n\n    def can_handle_on_response(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_response method.\n\n        Returns:\n            bool: True if the plugin can handle the on_response method.\"\"\"\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        \"\"\"This method is called when a response is received from the model.\"\"\"\n        pass\n\n    def can_handle_on_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_planning method.\n\n        Returns:\n            bool: True if the plugin can handle the on_planning method.\"\"\"\n        return False\n\n    def on_planning(\n        self, prompt: PromptGenerator, messages: List[Message]\n    ) -> Optional[str]:\n        \"\"\"This method is called before the planning chat completion is done.\n\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n            messages (List[str]): The list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_planning method.\n\n        Returns:\n            bool: True if the plugin can handle the post_planning method.\"\"\"\n        return False\n\n    def post_planning(self, response: str) -> str:\n        \"\"\"This method is called after the planning chat completion is done.\n\n        Args:\n            response (str): The response.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_instruction method.\n\n        Returns:\n            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n        return False\n\n    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n        \"\"\"This method is called before the instruction chat is done.\n\n        Args:\n            messages (List[Message]): The list of context messages.\n\n        Returns:\n            List[Message]: The resulting list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_instruction method.\n\n        Returns:\n            bool: True if the plugin can handle the on_instruction method.\"\"\"\n        return False\n\n    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n        \"\"\"This method is called when the instruction chat is done.\n\n        Args:\n            messages (List[Message]): The list of context messages.\n\n        Returns:\n            Optional[str]: The resulting message.\n        \"\"\"\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_instruction method.\n\n        Returns:\n            bool: True if the plugin can handle the post_instruction method.\"\"\"\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        \"\"\"This method is called after the instruction chat is done.\n\n        Args:\n            response (str): The response.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_command method.\n\n        Returns:\n            bool: True if the plugin can handle the pre_command method.\"\"\"\n        return False\n\n    def pre_command(\n        self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"This method is called before the command is executed.\n\n        Args:\n            command_name (str): The command name.\n            arguments (Dict[str, Any]): The arguments.\n\n        Returns:\n            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n        \"\"\"\n        pass\n\n    def can_handle_post_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_command method.\n\n        Returns:\n            bool: True if the plugin can handle the post_command method.\"\"\"\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        \"\"\"This method is called after the command is executed.\n\n        Args:\n            command_name (str): The command name.\n            response (str): The response.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_chat_completion(\n        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n    ) -> bool:\n        \"\"\"This method is called to check that the plugin can\n          handle the chat_completion method.\n\n        Args:\n            messages (List[Message]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n\n          Returns:\n              bool: True if the plugin can handle the chat_completion method.\"\"\"\n        return False\n\n    def handle_chat_completion(\n        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n    ) -> str:\n        \"\"\"This method is called when the chat completion is done.\n\n        Args:\n            messages (List[Message]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n\n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass"]}
{"filename": "src/autogpt_plugins/astro/astronauts.py", "chunked_list": ["import requests\n\n\ndef get_num_astronauts():\n    \"\"\"Get the number of astronauts in space.\n\n    Args:\n        None\n\n    Returns:\n        int: The number of astronauts in space.\n    \"\"\"\n    #Get the data\n    response = requests.get(\"http://api.open-notify.org/astros.json\")\n    #Convert it to JSON\n    data = response.json()\n    #Extract the number and return it\n    return data[\"number\"]", ""]}
{"filename": "src/autogpt_plugins/telegram/telegram_chat.py", "chunked_list": ["import asyncio\nimport os\nimport random\nimport traceback\n\nfrom telegram import Bot, Update\nfrom telegram.error import TimedOut\nfrom telegram.ext import CallbackContext\n\nresponse_queue = \"\"", "\nresponse_queue = \"\"\n\n\nclass TelegramUtils:\n    def __init__(self, api_key: str = None, chat_id: str = None):\n        if not api_key:\n            print(\n                \"No api key provided. Please set the TELEGRAM_API_KEY environment variable.\"\n            )\n            print(\"You can get your api key by talking to @BotFather on Telegram.\")\n            print(\n                \"For more information, please visit: https://core.telegram.org/bots/tutorial#6-botfather\"\n            )\n            return\n\n        self.api_key = api_key\n\n        if not chat_id:\n            print(\n                \"TELEGRAM PLUGIN: No chat id provided. Please set the TELEGRAM_CHAT_ID environment variable.\"\n            )\n            user_input = input(\n                \"Would you like to send a test message to your bot to get the id? (y/n): \"\n            )\n            if user_input == \"y\":\n                try:\n                    print(\"Please send a message to your telegram bot now.\")\n                    update = self.poll_anyMessage()\n                    print(\"Message received! Getting chat id...\")\n                    chat_id = update.message.chat.id\n                    print(\"Your chat id is: \" + str(chat_id))\n                    print(\"And the message is: \" + update.message.text)\n                    confirmation = random.randint(1000, 9999)\n                    print(\"Sending confirmation message: \" + str(confirmation))\n                    text = f\"Hello! Your chat id is: {chat_id} and the confirmation code is: {confirmation}\"\n                    self.chat_id = chat_id\n                    self.send_message(text)  # Send confirmation message\n                    print(\n                        \"Please set the TELEGRAM_CHAT_ID environment variable to this value.\"\n                    )\n                except TimedOut:\n                    print(\n                        \"Error while sending test message. Please check your Telegram bot.\"\n                    )\n            return\n        self.chat_id = chat_id\n\n    def poll_anyMessage(self):\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        return loop.run_until_complete(self.poll_anyMessage_async())\n\n    async def poll_anyMessage_async(self):\n        bot = Bot(token=self.api_key)\n        last_update = await bot.get_updates(timeout=30)\n        if len(last_update) > 0:\n            last_update_id = last_update[-1].update_id\n        else:\n            last_update_id = -1\n\n        while True:\n            try:\n                print(\"Waiting for first message...\")\n                updates = await bot.get_updates(offset=last_update_id + 1, timeout=30)\n                for update in updates:\n                    if update.message:\n                        return update\n            except Exception as e:\n                print(f\"Error while polling updates: {e}\")\n\n            await asyncio.sleep(1)\n\n    def is_authorized_user(self, update: Update):\n        return update.effective_user.id == int(self.chat_id)\n\n    def handle_response(self, update: Update, context: CallbackContext):\n        try:\n            print(\"Received response: \" + update.message.text)\n\n            if self.is_authorized_user(update):\n                response_queue.put(update.message.text)\n        except Exception as e:\n            print(e)\n\n    async def delete_old_messages(self):\n        bot = await self.get_bot()\n        updates = await bot.get_updates(offset=0)\n        count = 0\n        for update in updates:\n            try:\n                print(\n                    \"Deleting message: \"\n                    + update.message.text\n                    + \" \"\n                    + str(update.message.message_id)\n                )\n                await bot.delete_message(\n                    chat_id=update.message.chat.id, message_id=update.message.message_id\n                )\n            except Exception as e:\n                print(\n                    f\"Error while deleting message: {e} \\n\"\n                    + f\" update: {update} \\n {traceback.format_exc()}\"\n                )\n            count += 1\n        if count > 0:\n            print(\"Cleaned up old messages.\")\n\n    async def get_bot(self):\n        bot_token = self.api_key\n        bot = Bot(token=bot_token)\n        commands = await bot.get_my_commands()\n        if len(commands) == 0:\n            await self.set_commands(bot)\n        commands = await bot.get_my_commands()\n        return bot\n\n    async def set_commands(self, bot):\n        await bot.set_my_commands(\n            [\n                (\"start\", \"Start Auto-GPT\"),\n                (\"stop\", \"Stop Auto-GPT\"),\n                (\"help\", \"Show help\"),\n                (\"yes\", \"Confirm\"),\n                (\"no\", \"Deny\"),\n                (\"auto\", \"Let an Agent decide\"),\n            ]\n        )\n\n    def send_message(self, message):\n        try:\n            loop = asyncio.get_running_loop()\n        except RuntimeError as e:  # 'RuntimeError: There is no current event loop...'\n            loop = None\n\n        try:\n            if loop and loop.is_running():\n                print(\n                    \"Sending message async, if this fials its due to rununtil complete task\"\n                )\n                loop.create_task(self._send_message(message=message))\n            else:\n                eventloop = asyncio.get_event_loop\n                if hasattr(eventloop, \"run_until_complete\") and eventloop.is_running():\n                    print(\"Event loop is running\")\n                    eventloop.run_until_complete(self._send_message(message=message))\n                else:\n                    asyncio.run(self._send_message(message=message))\n        except RuntimeError as e:\n            print(traceback.format_exc())\n            print(\"Error while sending message\")\n            print(e)\n\n    def send_voice(self, voice_file):\n        try:\n            self.get_bot().send_voice(\n                chat_id=self.chat_id, voice=open(voice_file, \"rb\")\n            )\n        except RuntimeError:\n            print(\"Error while sending voice message\")\n\n    async def _send_message(self, message):\n        print(\"Sending message to Telegram.. \")\n        recipient_chat_id = self.chat_id\n        bot = await self.get_bot()\n\n        # properly handle messages with more than 2000 characters by chunking them\n        if len(message) > 2000:\n            message_chunks = [\n                message[i : i + 2000] for i in range(0, len(message), 2000)\n            ]\n            for message_chunk in message_chunks:\n                await bot.send_message(chat_id=recipient_chat_id, text=message_chunk)\n        else:\n            await bot.send_message(chat_id=recipient_chat_id, text=message)\n\n    async def ask_user_async(self, prompt):\n        global response_queue\n\n        # only display confirm if the prompt doesnt have the string \"\"Continue (y/n):\"\" inside\n        if \"Continue (y/n):\" in prompt or \"Waiting for your response...\" in prompt:\n            question = (\n                prompt\n                + \" \\n Confirm: /yes     Decline: /no \\n Or type your answer. \\n or press /auto to let an Agent decide.\"\n            )\n        elif \"I want Auto-GPT to:\" in prompt:\n            question = prompt\n        else:\n            question = (\n                prompt + \" \\n Type your answer or press /auto to let an Agent decide.\"\n            )\n\n        response_queue = \"\"\n        # await delete_old_messages()\n\n        print(\"Asking user: \" + question)\n        await self._send_message(message=question)\n\n        print(\"Waiting for response on Telegram chat...\")\n        await self._poll_updates()\n\n        if response_queue == \"/start\":\n            response_queue = await self.ask_user(\n                self,\n                prompt=\"I am already here... \\n Please use /stop to stop me first.\",\n            )\n        if response_queue == \"/help\":\n            response_queue = await self.ask_user(\n                self,\n                prompt=\"You can use /stop to stop me \\n and /start to start me again.\",\n            )\n        if response_queue == \"/auto\":\n            return \"s\"\n        if response_queue == \"/stop\":\n            await self._send_message(\"Stopping Auto-GPT now!\")\n            exit(0)\n        elif response_queue == \"/yes\":\n            response_text = \"yes\"\n            response_queue = \"yes\"\n        elif response_queue == \"/no\":\n            response_text = \"no\"\n            response_queue = \"no\"\n        if response_queue.capitalize() in [\n            \"Yes\",\n            \"Okay\",\n            \"Ok\",\n            \"Sure\",\n            \"Yeah\",\n            \"Yup\",\n            \"Yep\",\n        ]:\n            response_text = \"y\"\n        elif response_queue.capitalize() in [\"No\", \"Nope\", \"Nah\", \"N\"]:\n            response_text = \"n\"\n        else:\n            response_text = response_queue\n\n        print(\"Response received from Telegram: \" + response_text)\n        return response_text\n\n    async def _poll_updates(self):\n        global response_queue\n        bot = await self.get_bot()\n        print(\"getting updates...\")\n        try:\n            last_update = await bot.get_updates(timeout=1)\n            if len(last_update) > 0:\n                last_update_id = last_update[-1].update_id\n            else:\n                last_update_id = -1\n\n            print(\"last update id: \" + str(last_update_id))\n            while True:\n                try:\n                    print(\"Polling updates...\")\n                    updates = await bot.get_updates(\n                        offset=last_update_id + 1, timeout=30\n                    )\n                    for update in updates:\n                        if update.message and update.message.text:\n                            if self.is_authorized_user(update):\n                                response_queue = update.message.text\n                                return\n                        last_update_id = max(last_update_id, update.update_id)\n                except Exception as e:\n                    print(f\"Error while polling updates: {e}\")\n\n                await asyncio.sleep(1)\n        except RuntimeError:\n            print(\"Error while polling updates\")\n\n    def ask_user(self, prompt):\n        print(\"Asking user: \" + prompt)\n        try:\n            loop = asyncio.get_running_loop()\n        except RuntimeError:  # 'RuntimeError: There is no current event loop...'\n            loop = None\n        try:\n            if loop and loop.is_running():\n                return loop.create_task(self.ask_user_async(prompt=prompt))\n            else:\n                return asyncio.run(self.ask_user_async(prompt=prompt))\n        except TimedOut:\n            print(\"Telegram timeout error, trying again...\")\n            return self.ask_user(prompt=prompt)", "\n\nif __name__ == \"__main__\":\n    telegram_api_key = os.getenv(\"TELEGRAM_API_KEY\")\n    telegram_chat_id = os.getenv(\"TELEGRAM_CHAT_ID\")\n    telegram_utils = TelegramUtils(chat_id=telegram_chat_id, api_key=telegram_api_key)\n    telegram_utils.send_message(\"Hello World!\")\n"]}
{"filename": "src/autogpt_plugins/telegram/__init__.py", "chunked_list": ["\"\"\"Telegram controller bot integration using python-telegram-bot.\"\"\"\nimport os\nimport re\nfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\nfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\nfrom .telegram_chat import TelegramUtils\n\nPromptGenerator = TypeVar(\"PromptGenerator\")", "\nPromptGenerator = TypeVar(\"PromptGenerator\")\n\n\nclass Message(TypedDict):\n    role: str\n    content: str\n\n\ndef remove_color_codes(s: str) -> str:\n    ansi_escape = re.compile(r\"\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])\")\n    return ansi_escape.sub(\"\", s)", "\ndef remove_color_codes(s: str) -> str:\n    ansi_escape = re.compile(r\"\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])\")\n    return ansi_escape.sub(\"\", s)\n\n\nclass AutoGPTTelegram(AutoGPTPluginTemplate):\n    \"\"\"\n    Telegram controller bot integration using python-telegram-bot.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._name = \"Auto-GPT-Telegram\"\n        self._version = \"0.2.0\"\n        self._description = (\n            \"This integrates a Telegram chat bot with your autogpt instance.\"\n        )\n        self.telegram_api_key = os.getenv(\"TELEGRAM_API_KEY\", None)\n        self.telegram_chat_id = os.getenv(\"TELEGRAM_CHAT_ID\", None)\n        self.telegram_utils = TelegramUtils(\n            chat_id=self.telegram_chat_id, api_key=self.telegram_api_key\n        )\n\n    def can_handle_on_response(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_response method.\n\n        Returns:\n            bool: True if the plugin can handle the on_response method.\"\"\"\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        \"\"\"This method is called when a response is received from the model.\"\"\"\n        pass\n\n    def can_handle_post_prompt(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_prompt method.\n\n        Returns:\n            bool: True if the plugin can handle the post_prompt method.\"\"\"\n        return False\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        \"\"\"This method is called just after the generate_prompt is called,\n            but actually before the prompt is generated.\n\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n\n        Returns:\n            PromptGenerator: The prompt generator.\n        \"\"\"\n        pass\n\n    def can_handle_on_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_planning method.\n\n        Returns:\n            bool: True if the plugin can handle the on_planning method.\"\"\"\n        return False\n\n    def on_planning(\n        self, prompt: PromptGenerator, messages: List[Message]\n    ) -> Optional[str]:\n        \"\"\"This method is called before the planning chat completion is done.\n\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n            messages (List[str]): The list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_planning method.\n\n        Returns:\n            bool: True if the plugin can handle the post_planning method.\"\"\"\n        return False\n\n    def post_planning(self, response: str) -> str:\n        \"\"\"This method is called after the planning chat completion is done.\n\n        Args:\n            response (str): The response.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_instruction method.\n\n        Returns:\n            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n        return False\n\n    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n        \"\"\"This method is called before the instruction chat is done.\n\n        Args:\n            messages (List[Message]): The list of context messages.\n\n        Returns:\n            List[Message]: The resulting list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_instruction method.\n\n        Returns:\n            bool: True if the plugin can handle the on_instruction method.\"\"\"\n        return False\n\n    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n        \"\"\"This method is called when the instruction chat is done.\n\n        Args:\n            messages (List[Message]): The list of context messages.\n\n        Returns:\n            Optional[str]: The resulting message.\n        \"\"\"\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_instruction method.\n\n        Returns:\n            bool: True if the plugin can handle the post_instruction method.\"\"\"\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        \"\"\"This method is called after the instruction chat is done.\n\n        Args:\n            response (str): The response.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_command method.\n\n        Returns:\n            bool: True if the plugin can handle the pre_command method.\"\"\"\n        return False\n\n    def pre_command(\n        self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"This method is called before the command is executed.\n\n        Args:\n            command_name (str): The command name.\n            arguments (Dict[str, Any]): The arguments.\n\n        Returns:\n            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n        \"\"\"\n        pass\n\n    def can_handle_post_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_command method.\n\n        Returns:\n            bool: True if the plugin can handle the post_command method.\"\"\"\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        \"\"\"This method is called after the command is executed.\n\n        Args:\n            command_name (str): The command name.\n            response (str): The response.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_chat_completion(\n        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n    ) -> bool:\n        \"\"\"This method is called to check that the plugin can\n          handle the chat_completion method.\n\n        Args:\n            messages (List[Message]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n\n          Returns:\n              bool: True if the plugin can handle the chat_completion method.\"\"\"\n        return False\n\n    def handle_chat_completion(\n        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n    ) -> str:\n        \"\"\"This method is called when the chat completion is done.\n\n        Args:\n            messages (List[Message]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_text_embedding(self, text: str) -> bool:\n        return False\n    \n    def handle_text_embedding(self, text: str) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return True\n\n    def user_input(self, user_input: str) -> str:\n        user_input = remove_color_codes(user_input)\n        # if the user_input is too long, shorten it\n        try:\n            return self.telegram_utils.ask_user(prompt=user_input)\n        except Exception as e:\n            print(e)\n            print(\"Error sending message to telegram\")\n            return \"s\"\n        \n    def can_handle_report(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the report method.\n\n        Returns:\n            bool: True if the plugin can handle the report method.\"\"\"\n        return True\n\n    def report(self, message: str) -> None:\n        message = remove_color_codes(message)\n        # if the message is too long, shorten it\n        try :\n            self.telegram_utils.send_message(message=message)\n        except Exception as e:\n            print(e)\n            print(\"Error sending message to telegram\")\n            \n\n    def can_handle_text_embedding(self, text: str) -> bool:\n        return False\n\n    def handle_text_embedding(self, text: str) -> list:\n        pass", ""]}
{"filename": "src/autogpt_plugins/baidu_search/baidu_search.py", "chunked_list": ["import json\nimport os\nimport re\n\nimport requests\nfrom bs4 import BeautifulSoup\n\n\ndef _baidu_search(query: str, num_results=8):\n    '''\n    Perform a Baidu search and return the results as a JSON string.\n    '''\n\n    headers = {\n        'Cookie': os.getenv(\"BAIDU_COOKIE\"),\n        'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:112.0) Gecko/20100101 Firefox/112.0\"\n    }\n    url = f'https://www.baidu.com/s?wd={query}&rn={num_results}'\n    response = requests.get(url, headers=headers)\n    response.encoding = 'utf-8'\n    soup = BeautifulSoup(response.text, 'html.parser')\n    search_results = []\n\n    for result in soup.find_all('div', class_=re.compile('^result c-container ')):\n        title = result.find('h3', class_='t').get_text()\n        link = result.find('a', href=True)['href']\n        snippet = result.find('span', class_=re.compile('^content-right_8Zs40'))\n        if snippet:\n            snippet = snippet.get_text()\n        else:\n            snippet = ''\n        search_results.append({\n            'title': title,\n            'href': link,\n            'snippet': snippet\n        })\n\n    return json.dumps(search_results, ensure_ascii=False, indent=4)", "def _baidu_search(query: str, num_results=8):\n    '''\n    Perform a Baidu search and return the results as a JSON string.\n    '''\n\n    headers = {\n        'Cookie': os.getenv(\"BAIDU_COOKIE\"),\n        'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:112.0) Gecko/20100101 Firefox/112.0\"\n    }\n    url = f'https://www.baidu.com/s?wd={query}&rn={num_results}'\n    response = requests.get(url, headers=headers)\n    response.encoding = 'utf-8'\n    soup = BeautifulSoup(response.text, 'html.parser')\n    search_results = []\n\n    for result in soup.find_all('div', class_=re.compile('^result c-container ')):\n        title = result.find('h3', class_='t').get_text()\n        link = result.find('a', href=True)['href']\n        snippet = result.find('span', class_=re.compile('^content-right_8Zs40'))\n        if snippet:\n            snippet = snippet.get_text()\n        else:\n            snippet = ''\n        search_results.append({\n            'title': title,\n            'href': link,\n            'snippet': snippet\n        })\n\n    return json.dumps(search_results, ensure_ascii=False, indent=4)"]}
{"filename": "src/autogpt_plugins/baidu_search/__init__.py", "chunked_list": ["\"\"\"This is the Baidu search engines plugin for Auto-GPT.\"\"\"\nimport os\nfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\nfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\nfrom .baidu_search import _baidu_search\n\nPromptGenerator = TypeVar(\"PromptGenerator\")\n", "PromptGenerator = TypeVar(\"PromptGenerator\")\n\n\nclass Message(TypedDict):\n    role: str\n    content: str\n\n\nclass AutoGPTBaiduSearch(AutoGPTPluginTemplate):\n    def __init__(self):\n        super().__init__()\n        self._name = \"Baidu-Search-Plugin\"\n        self._version = \"0.1.0\"\n        self._description = (\n            \"This plugin performs Baidu searches using the provided query.\"\n        )\n        self.load_commands = (\n            os.getenv(\"SEARCH_ENGINE\")\n            and os.getenv(\"SEARCH_ENGINE\").lower() == \"baidu\"\n            and os.getenv(\"BAIDU_COOKIE\")\n        )\n\n    def can_handle_post_prompt(self) -> bool:\n        return True\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        if self.load_commands:\n            # Add Baidu Search command\n            prompt.add_command(\n                \"Baidu Search\",\n                \"baidu_search\",\n                {\"query\": \"<query>\"},\n                _baidu_search,\n            )\n        else:\n            print(\n                \"Warning: Baidu-Search-Plugin is not fully functional. \"\n                \"Please set the SEARCH_ENGINE and BAIDU_COOKIE environment variables.\"\n            )\n        return prompt\n\n    def can_handle_pre_command(self) -> bool:\n        return True\n\n    def pre_command(\n        self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        if command_name == \"google\" and self.load_commands:\n            return \"baidu_search\", {\"query\": arguments[\"query\"]}\n        else:\n            return command_name, arguments\n\n    def can_handle_post_command(self) -> bool:\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        pass\n\n    def can_handle_on_planning(self) -> bool:\n        return False\n\n    def on_planning(\n        self, prompt: PromptGenerator, messages: List[Message]\n    ) -> Optional[str]:\n        pass\n\n    def can_handle_on_response(self) -> bool:\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        return False\n\n    def post_planning(self, response: str) -> str:\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        return False\n\n    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        return False\n\n    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        pass\n    \n    def can_handle_chat_completion(\n        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n    ) -> bool:\n        return False\n\n    def handle_chat_completion(\n        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n    ) -> str:\n        pass\n    \n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass", "class AutoGPTBaiduSearch(AutoGPTPluginTemplate):\n    def __init__(self):\n        super().__init__()\n        self._name = \"Baidu-Search-Plugin\"\n        self._version = \"0.1.0\"\n        self._description = (\n            \"This plugin performs Baidu searches using the provided query.\"\n        )\n        self.load_commands = (\n            os.getenv(\"SEARCH_ENGINE\")\n            and os.getenv(\"SEARCH_ENGINE\").lower() == \"baidu\"\n            and os.getenv(\"BAIDU_COOKIE\")\n        )\n\n    def can_handle_post_prompt(self) -> bool:\n        return True\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        if self.load_commands:\n            # Add Baidu Search command\n            prompt.add_command(\n                \"Baidu Search\",\n                \"baidu_search\",\n                {\"query\": \"<query>\"},\n                _baidu_search,\n            )\n        else:\n            print(\n                \"Warning: Baidu-Search-Plugin is not fully functional. \"\n                \"Please set the SEARCH_ENGINE and BAIDU_COOKIE environment variables.\"\n            )\n        return prompt\n\n    def can_handle_pre_command(self) -> bool:\n        return True\n\n    def pre_command(\n        self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        if command_name == \"google\" and self.load_commands:\n            return \"baidu_search\", {\"query\": arguments[\"query\"]}\n        else:\n            return command_name, arguments\n\n    def can_handle_post_command(self) -> bool:\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        pass\n\n    def can_handle_on_planning(self) -> bool:\n        return False\n\n    def on_planning(\n        self, prompt: PromptGenerator, messages: List[Message]\n    ) -> Optional[str]:\n        pass\n\n    def can_handle_on_response(self) -> bool:\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        return False\n\n    def post_planning(self, response: str) -> str:\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        return False\n\n    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        return False\n\n    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        pass\n    \n    def can_handle_chat_completion(\n        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n    ) -> bool:\n        return False\n\n    def handle_chat_completion(\n        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n    ) -> str:\n        pass\n    \n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass", ""]}
{"filename": "src/autogpt_plugins/baidu_search/test_auto_gpt_baidu_plugin.py", "chunked_list": ["import os\nimport unittest\nfrom typing import List\n\nimport requests\n\nfrom . import AutoGPTBaiduSearch\nfrom .baidu_search import _baidu_search\n\n\nclass TestAutoGPTBaiduSearch(unittest.TestCase):\n    def setUp(self):\n        os.environ[\"BAIDU_COOKIE\"] = \"test_cookie\"\n        os.environ[\"SEARCH_ENGINE\"] = \"baidu\"\n        self.plugin = AutoGPTBaiduSearch()\n\n    def tearDown(self):\n        os.environ.pop(\"SEARCH_ENGINE\", None)\n        os.environ.pop(\"BAIDU_COOKIE\", None)\n\n    def test_baidu_search(self):\n        query = \"test query\"\n        try:\n            _baidu_search(query)\n        except requests.exceptions.HTTPError as e:\n            self.assertEqual(e.response.status_code, 401)\n\n    def test_pre_command(self):\n        os.environ[\"SEARCH_ENGINE\"] = \"baidu\"\n        self.plugin = AutoGPTBaiduSearch()\n\n        command_name, arguments = self.plugin.pre_command(\n            \"google\", {\"query\": \"test query\"}\n        )\n        self.assertEqual(command_name, \"baidu_search\")\n        self.assertEqual(arguments, {\"query\": \"test query\"})\n\n    def test_can_handle_pre_command(self):\n        self.assertTrue(self.plugin.can_handle_pre_command())\n\n    def test_can_handle_post_prompt(self):\n        self.assertTrue(self.plugin.can_handle_post_prompt())", "\n\nclass TestAutoGPTBaiduSearch(unittest.TestCase):\n    def setUp(self):\n        os.environ[\"BAIDU_COOKIE\"] = \"test_cookie\"\n        os.environ[\"SEARCH_ENGINE\"] = \"baidu\"\n        self.plugin = AutoGPTBaiduSearch()\n\n    def tearDown(self):\n        os.environ.pop(\"SEARCH_ENGINE\", None)\n        os.environ.pop(\"BAIDU_COOKIE\", None)\n\n    def test_baidu_search(self):\n        query = \"test query\"\n        try:\n            _baidu_search(query)\n        except requests.exceptions.HTTPError as e:\n            self.assertEqual(e.response.status_code, 401)\n\n    def test_pre_command(self):\n        os.environ[\"SEARCH_ENGINE\"] = \"baidu\"\n        self.plugin = AutoGPTBaiduSearch()\n\n        command_name, arguments = self.plugin.pre_command(\n            \"google\", {\"query\": \"test query\"}\n        )\n        self.assertEqual(command_name, \"baidu_search\")\n        self.assertEqual(arguments, {\"query\": \"test query\"})\n\n    def test_can_handle_pre_command(self):\n        self.assertTrue(self.plugin.can_handle_pre_command())\n\n    def test_can_handle_post_prompt(self):\n        self.assertTrue(self.plugin.can_handle_post_prompt())", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "src/autogpt_plugins/email/__init__.py", "chunked_list": ["\"\"\"This is the email plugin for Auto-GPT.\"\"\"\nfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\nfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\nfrom colorama import Fore\n\nPromptGenerator = TypeVar(\"PromptGenerator\")\n\n\nclass Message(TypedDict):\n    role: str\n    content: str", "\nclass Message(TypedDict):\n    role: str\n    content: str\n\n\nclass AutoGPTEmailPlugin(AutoGPTPluginTemplate):\n    \"\"\"\n    This is the Auto-GPT email plugin.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._name = \"Auto-GPT-Email-Plugin\"\n        self._version = \"0.2.0\"\n        self._description = \"This plugin reads and send emails.\"\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        from .email_plugin.email_plugin import (\n            bothEmailAndPwdSet,\n            read_emails,\n            send_email,\n            send_email_with_attachment,\n        )\n\n        if bothEmailAndPwdSet():\n            prompt.add_command(\n                \"Read Emails\",\n                \"read_emails\",\n                {\n                    \"imap_folder\": \"<imap_folder>\",\n                    \"imap_search_command\": \"<imap_search_criteria_command>\",\n                    \"limit\": \"<email_count_return_limit>\",\n                    \"page\": \"<number_of_email_results_page>\",\n                },\n                read_emails,\n            )\n            prompt.add_command(\n                \"Send Email\",\n                \"send_email\",\n                {\"to\": \"<to>\", \"subject\": \"<subject>\", \"body\": \"<body>\"},\n                send_email,\n            )\n            prompt.add_command(\n                \"Send Email\",\n                \"send_email_with_attachment\",\n                {\n                    \"to\": \"<to>\",\n                    \"subject\": \"<subject>\",\n                    \"body\": \"<body>\",\n                    \"filename\": \"<attachment filename>\",\n                },\n                send_email_with_attachment,\n            )\n        else:\n            print(\n                Fore.RED\n                + f\"{self._name} - {self._version} - Email plugin not loaded, because EMAIL_PASSWORD or EMAIL_ADDRESS were not set in env.\"\n            )\n\n        return prompt\n\n    def can_handle_post_prompt(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_prompt method.\n\n        Returns:\n            bool: True if the plugin can handle the post_prompt method.\"\"\"\n        return True\n\n    def can_handle_on_response(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_response method.\n\n        Returns:\n            bool: True if the plugin can handle the on_response method.\"\"\"\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        \"\"\"This method is called when a response is received from the model.\"\"\"\n        pass\n\n    def can_handle_on_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_planning method.\n\n        Returns:\n            bool: True if the plugin can handle the on_planning method.\"\"\"\n        return False\n\n    def on_planning(\n        self, prompt: PromptGenerator, messages: List[Message]\n    ) -> Optional[str]:\n        \"\"\"This method is called before the planning chat completion is done.\n\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n            messages (List[str]): The list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_planning method.\n\n        Returns:\n            bool: True if the plugin can handle the post_planning method.\"\"\"\n        return False\n\n    def post_planning(self, response: str) -> str:\n        \"\"\"This method is called after the planning chat completion is done.\n\n        Args:\n            response (str): The response.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_instruction method.\n\n        Returns:\n            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n        return False\n\n    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n        \"\"\"This method is called before the instruction chat is done.\n\n        Args:\n            messages (List[Message]): The list of context messages.\n\n        Returns:\n            List[Message]: The resulting list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_instruction method.\n\n        Returns:\n            bool: True if the plugin can handle the on_instruction method.\"\"\"\n        return False\n\n    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n        \"\"\"This method is called when the instruction chat is done.\n\n        Args:\n            messages (List[Message]): The list of context messages.\n\n        Returns:\n            Optional[str]: The resulting message.\n        \"\"\"\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_instruction method.\n\n        Returns:\n            bool: True if the plugin can handle the post_instruction method.\"\"\"\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        \"\"\"This method is called after the instruction chat is done.\n\n        Args:\n            response (str): The response.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_pre_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_command method.\n\n        Returns:\n            bool: True if the plugin can handle the pre_command method.\"\"\"\n        return False\n\n    def pre_command(\n        self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"This method is called before the command is executed.\n\n        Args:\n            command_name (str): The command name.\n            arguments (Dict[str, Any]): The arguments.\n\n        Returns:\n            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n        \"\"\"\n        pass\n\n    def can_handle_post_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_command method.\n\n        Returns:\n            bool: True if the plugin can handle the post_command method.\"\"\"\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        \"\"\"This method is called after the command is executed.\n\n        Args:\n            command_name (str): The command name.\n            response (str): The response.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_chat_completion(\n        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n    ) -> bool:\n        \"\"\"This method is called to check that the plugin can\n          handle the chat_completion method.\n\n        Args:\n            messages (List[Message]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n\n          Returns:\n              bool: True if the plugin can handle the chat_completion method.\"\"\"\n        return False\n\n    def handle_chat_completion(\n        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n    ) -> str:\n        \"\"\"This method is called when the chat completion is done.\n\n        Args:\n            messages (List[Message]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        pass\n\n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass"]}
{"filename": "src/autogpt_plugins/email/email_plugin/test_email_plugin.py", "chunked_list": ["import os\nimport unittest\nfrom email.message import EmailMessage\nfrom functools import partial\nfrom unittest.mock import mock_open, patch\n\nfrom email_plugin import (\n    adjust_imap_folder_for_gmail,\n    bothEmailAndPwdSet,\n    enclose_with_quotes,", "    bothEmailAndPwdSet,\n    enclose_with_quotes,\n    imap_open,\n    read_emails,\n    send_email,\n    send_email_with_attachment_internal,\n    split_imap_search_command,\n)\n\nMOCK_FROM = \"sender@example.com\"", "\nMOCK_FROM = \"sender@example.com\"\nMOCK_PWD = \"secret\"\nMOCK_TO = \"test@example.com\"\nMOCK_DATE = \"Fri, 21 Apr 2023 10:00:00 -0000\"\nMOCK_CONTENT = \"Test message\"\nMOCK_CONTENT_DIRTY = \"\"\"\n                        <html>\n                            <head>\n                                <title> Email Title </title>", "                            <head>\n                                <title> Email Title </title>\n                            </head>\n                            <body>\n                                This is an\n                                <div>email template</div>\n                                with a \\n return character\n                                and a link at the end</a>\n                            </body>\n                        </html>", "                            </body>\n                        </html>\n                         (https://e.com) \n                    \"\"\"\nMOCK_SUBJECT = \"Test Subject\"\nMOCK_IMAP_SERVER = \"imap.example.com\"\nMOCK_SMTP_SERVER = \"smtp.example.com\"\nMOCK_SMTP_PORT = \"587\"\n\nMOCK_DRAFT_FOLDER = \"Example/Drafts\"", "\nMOCK_DRAFT_FOLDER = \"Example/Drafts\"\nMOCK_ATTACHMENT_PATH = \"example/file.txt\"\nMOCK_ATTACHMENT_NAME = \"file.txt\"\n\n\nclass TestEmailPlugin(unittest.TestCase):\n    @patch.dict(\n        os.environ,\n        {\n            \"EMAIL_ADDRESS\": \"test@example.com\",\n            \"EMAIL_PASSWORD\": \"test_password\",\n        },\n    )\n    def test_both_email_and_pwd_set(self):\n        self.assertTrue(bothEmailAndPwdSet())\n\n    @patch.dict(\n        os.environ,\n        {\n            \"EMAIL_PASSWORD\": \"test_password\",\n        },\n        clear=True,\n    )\n    def test_email_not_set(self):\n        self.assertFalse(bothEmailAndPwdSet())\n\n    @patch.dict(\n        os.environ,\n        {\n            \"EMAIL_ADDRESS\": \"\",\n            \"EMAIL_PASSWORD\": \"test_password\",\n        },\n        clear=True,\n    )\n    def test_email_not_set_2(self):\n        self.assertFalse(bothEmailAndPwdSet())\n\n    @patch.dict(\n        os.environ,\n        {\n            \"EMAIL_ADDRESS\": \"test@example.com\",\n        },\n        clear=True,\n    )\n    def test_pwd_not_set(self):\n        self.assertFalse(bothEmailAndPwdSet())\n\n    @patch.dict(os.environ, {}, clear=True)\n    def test_both_email_and_pwd_not_set(self):\n        self.assertFalse(bothEmailAndPwdSet())\n\n    def test_adjust_imap_folder_for_gmail_normal_cases(self):\n        self.assertEqual(\n            adjust_imap_folder_for_gmail(\"Sent\", \"user@gmail.com\"),\n            '\"[Gmail]/Sent Mail\"',\n        )\n        self.assertEqual(\n            adjust_imap_folder_for_gmail(\"Drafts\", \"user@googlemail.com\"),\n            \"[Gmail]/Drafts\",\n        )\n        self.assertEqual(\n            adjust_imap_folder_for_gmail(\"Inbox\", \"user@gmail.com\"), \"Inbox\"\n        )\n\n    def test_adjust_imap_folder_for_gmail_case_insensitivity(self):\n        self.assertEqual(\n            adjust_imap_folder_for_gmail(\"SeNT\", \"user@GMail.com\"),\n            '\"[Gmail]/Sent Mail\"',\n        )\n        self.assertEqual(\n            adjust_imap_folder_for_gmail(\"DRAFTS\", \"user@gOogLemail.com\"),\n            \"[Gmail]/Drafts\",\n        )\n        self.assertEqual(\n            adjust_imap_folder_for_gmail(\"InbOx\", \"user@gmail.com\"), \"InbOx\"\n        )\n\n    def test_adjust_imap_folder_for_gmail_non_gmail_sender(self):\n        self.assertEqual(adjust_imap_folder_for_gmail(\"Sent\", \"user@yahoo.com\"), \"Sent\")\n        self.assertEqual(\n            adjust_imap_folder_for_gmail(\"Drafts\", \"user@hotmail.com\"), \"Drafts\"\n        )\n        self.assertEqual(\n            adjust_imap_folder_for_gmail(\"SENT\", \"gmail@hotmail.com\"), \"SENT\"\n        )\n\n    def test_adjust_imap_folder_for_gmail_edge_cases(self):\n        self.assertEqual(adjust_imap_folder_for_gmail(\"\", \"user@gmail.com\"), \"\")\n        self.assertEqual(adjust_imap_folder_for_gmail(\"Inbox\", \"\"), \"Inbox\")\n        self.assertEqual(adjust_imap_folder_for_gmail(\"\", \"\"), \"\")\n\n    def test_enclose_with_quotes(self):\n        assert enclose_with_quotes(\"REVERSE DATE\") == '\"REVERSE DATE\"'\n        assert enclose_with_quotes('\"My Search\"') == '\"My Search\"'\n        assert enclose_with_quotes(\"'test me'\") == \"'test me'\"\n        assert enclose_with_quotes(\"ALL\") == \"ALL\"\n        assert enclose_with_quotes(\"quotes needed\") == '\"quotes needed\"'\n        assert enclose_with_quotes(\"   whitespace  \") == '\"   whitespace  \"'\n        assert enclose_with_quotes(\"whitespace\\te\") == '\"whitespace\\te\"'\n        assert enclose_with_quotes(\"\\\"mixed quotes'\") == \"\\\"mixed quotes'\"\n        assert enclose_with_quotes(\"'mixed quotes\\\"\") == \"'mixed quotes\\\"\"\n\n    def test_split_imap_search_command(self):\n        self.assertEqual(split_imap_search_command(\"SEARCH\"), [\"SEARCH\"])\n        self.assertEqual(\n            split_imap_search_command(\"SEARCH UNSEEN\"), [\"SEARCH\", \"UNSEEN\"]\n        )\n        self.assertEqual(\n            split_imap_search_command(\"  SEARCH   UNSEEN  \"), [\"SEARCH\", \"UNSEEN\"]\n        )\n        self.assertEqual(\n            split_imap_search_command(\n                \"FROM speixoto@caicm.ca SINCE 01-JAN-2022 BEFORE 01-FEB-2023 HAS attachment xls OR HAS attachment xlsx\"\n            ),\n            [\n                \"FROM\",\n                \"speixoto@caicm.ca SINCE 01-JAN-2022 BEFORE 01-FEB-2023 HAS attachment xls OR HAS attachment xlsx\",\n            ],\n        )\n        self.assertEqual(\n            split_imap_search_command(\"BODY here is my long body\"),\n            [\"BODY\", \"here is my long body\"],\n        )\n        self.assertEqual(split_imap_search_command(\"\"), [])\n\n    @patch(\"imaplib.IMAP4_SSL\")\n    @patch.dict(\n        os.environ,\n        {\n            \"EMAIL_ADDRESS\": MOCK_FROM,\n            \"EMAIL_PASSWORD\": MOCK_PWD,\n            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n        },\n    )\n    def test_imap_open(self, mock_imap):\n        # Test imapOpen function\n        imap_folder = \"inbox\"\n        imap_open(imap_folder, MOCK_FROM, MOCK_PWD)\n\n        # Check if the IMAP object was created and used correctly\n        mock_imap.assert_called_once_with(MOCK_IMAP_SERVER)\n        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n        mock_imap.return_value.select.assert_called_once_with(imap_folder)\n\n    # Test for successful email sending without attachment\n    @patch(\"smtplib.SMTP\", autospec=True)\n    @patch.dict(\n        os.environ,\n        {\n            \"EMAIL_ADDRESS\": MOCK_FROM,\n            \"EMAIL_PASSWORD\": MOCK_PWD,\n            \"EMAIL_SMTP_HOST\": MOCK_SMTP_SERVER,\n            \"EMAIL_SMTP_PORT\": MOCK_SMTP_PORT,\n        },\n    )\n    def test_send_email_no_attachment(self, mock_smtp):\n        result = send_email(MOCK_TO, MOCK_SUBJECT, MOCK_CONTENT)\n        assert result == f\"Email was sent to {MOCK_TO}!\"\n\n        mock_smtp.assert_called_once_with(MOCK_SMTP_SERVER, MOCK_SMTP_PORT)\n\n        # Check if the SMTP object was created and used correctly\n        context = mock_smtp.return_value.__enter__.return_value\n        context.ehlo.assert_called()\n        context.starttls.assert_called_once()\n        context.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n        context.send_message.assert_called_once()\n        context.quit.assert_called_once()\n\n    # Test for reading emails in a specific folder with a specific search command and pagination\n    @patch(\"imaplib.IMAP4_SSL\")\n    @patch.dict(\n        os.environ,\n        {\n            \"EMAIL_ADDRESS\": MOCK_FROM,\n            \"EMAIL_PASSWORD\": MOCK_PWD,\n            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n        },\n    )\n    def test_read_emails(self, mock_imap):\n        assert os.getenv(\"EMAIL_ADDRESS\") == MOCK_FROM\n\n        # Create a mock email message\n        message = EmailMessage()\n        message[\"From\"] = MOCK_FROM\n        message[\"To\"] = MOCK_TO\n        message[\"Date\"] = MOCK_DATE\n        message[\"Subject\"] = MOCK_SUBJECT\n        message.set_content(MOCK_CONTENT)\n\n        # Set up mock IMAP server behavior\n        mock_imap.return_value.search.return_value = (None, [b\"1\"])\n        mock_imap.return_value.fetch.return_value = (None, [(b\"1\", message.as_bytes())])\n\n        # Test read_emails function\n        result = read_emails(\"inbox\", \"UNSEEN\", 1, 1)\n        expected_result = [\n            {\n                \"From\": MOCK_FROM,\n                \"To\": MOCK_TO,\n                \"Date\": MOCK_DATE,\n                \"CC\": \"\",\n                \"Subject\": MOCK_SUBJECT,\n                \"Message Body\": MOCK_CONTENT,\n            }\n        ]\n        assert result == expected_result\n\n        # Check if the IMAP object was created and used correctly\n        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n        mock_imap.return_value.select.assert_called_once_with(\"inbox\")\n        mock_imap.return_value.search.assert_called_once_with(None, \"UNSEEN\")\n        mock_imap.return_value.fetch.assert_called_once_with(b\"1\", \"(BODY.PEEK[])\")\n\n    # Test for reading empty emails\n    @patch(\"imaplib.IMAP4_SSL\")\n    @patch.dict(\n        os.environ,\n        {\n            \"EMAIL_ADDRESS\": MOCK_FROM,\n            \"EMAIL_PASSWORD\": MOCK_PWD,\n            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n        },\n    )\n    def test_read_empty_emails(self, mock_imap):\n        assert os.getenv(\"EMAIL_ADDRESS\") == MOCK_FROM\n\n        # Set up mock IMAP server behavior\n        mock_imap.return_value.search.return_value = (None, [b\"0\"])\n        mock_imap.return_value.fetch.return_value = (None, [])\n\n        # Test read_emails function\n        result = read_emails(\"inbox\", \"UNSEEN\", 1, 1)\n        expected = \"There are no Emails in your folder `inbox` \"\n        expected += \"when searching with imap command `UNSEEN`\"\n        assert result == expected\n\n        # Check if the IMAP object was created and used correctly\n        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n        mock_imap.return_value.select.assert_called_once_with(\"inbox\")\n        mock_imap.return_value.search.assert_called_once_with(None, \"UNSEEN\")\n        mock_imap.return_value.fetch.assert_called_once_with(b\"0\", \"(BODY.PEEK[])\")\n\n    # Test for reading emails in a specific folder\n    # with a specific search command with EMAIL_MARK_AS_SEEN=True\n    @patch(\"imaplib.IMAP4_SSL\")\n    @patch.dict(\n        os.environ,\n        {\n            \"EMAIL_ADDRESS\": MOCK_FROM,\n            \"EMAIL_PASSWORD\": MOCK_PWD,\n            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n            \"EMAIL_MARK_AS_SEEN\": \"True\",\n        },\n    )\n    def test_read_emails_mark_as_read_true(self, mock_imap):\n        assert os.getenv(\"EMAIL_ADDRESS\") == MOCK_FROM\n\n        # Create a mock email message\n        message = EmailMessage()\n        message[\"From\"] = MOCK_FROM\n        message[\"To\"] = MOCK_TO\n        message[\"Date\"] = MOCK_DATE\n        message[\"Subject\"] = MOCK_SUBJECT\n        message.set_content(MOCK_CONTENT)\n\n        # Set up mock IMAP server behavior\n        mock_imap.return_value.search.return_value = (None, [b\"1\"])\n        mock_imap.return_value.fetch.return_value = (None, [(b\"1\", message.as_bytes())])\n\n        # Test read_emails function\n        result = read_emails(\"inbox\", \"UNSEEN\", 1, 1)\n        expected_result = [\n            {\n                \"From\": MOCK_FROM,\n                \"To\": MOCK_TO,\n                \"Date\": MOCK_DATE,\n                \"CC\": \"\",\n                \"Subject\": MOCK_SUBJECT,\n                \"Message Body\": MOCK_CONTENT,\n            }\n        ]\n        assert result == expected_result\n\n        # Check if the IMAP object was created and used correctly\n        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n        mock_imap.return_value.select.assert_called_once_with(\"inbox\")\n        mock_imap.return_value.search.assert_called_once_with(None, \"UNSEEN\")\n        mock_imap.return_value.fetch.assert_called_once_with(b\"1\", \"(RFC822)\")\n\n    # Test for reading emails in a specific folder\n    # with a specific search command with EMAIL_MARK_AS_SEEN=False\n    @patch(\"imaplib.IMAP4_SSL\")\n    @patch.dict(\n        os.environ,\n        {\n            \"EMAIL_ADDRESS\": MOCK_FROM,\n            \"EMAIL_PASSWORD\": MOCK_PWD,\n            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n            \"EMAIL_MARK_AS_SEEN\": \"False\",\n        },\n    )\n    def test_read_emails_mark_as_seen_false(self, mock_imap):\n        assert os.getenv(\"EMAIL_ADDRESS\") == MOCK_FROM\n\n        # Create a mock email message\n        message = EmailMessage()\n        message[\"From\"] = MOCK_FROM\n        message[\"To\"] = MOCK_TO\n        message[\"Date\"] = MOCK_DATE\n        message[\"Subject\"] = MOCK_SUBJECT\n        message.set_content(MOCK_CONTENT)\n\n        # Set up mock IMAP server behavior\n        mock_imap.return_value.search.return_value = (None, [b\"1\"])\n        mock_imap.return_value.fetch.return_value = (None, [(b\"1\", message.as_bytes())])\n\n        # Test read_emails function\n        result = read_emails(\"inbox\", \"UNSEEN\", 1, 1)\n        expected_result = [\n            {\n                \"From\": MOCK_FROM,\n                \"To\": MOCK_TO,\n                \"Date\": MOCK_DATE,\n                \"CC\": \"\",\n                \"Subject\": MOCK_SUBJECT,\n                \"Message Body\": MOCK_CONTENT,\n            }\n        ]\n        assert result == expected_result\n\n        # Check if the IMAP object was created and used correctly\n        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n        mock_imap.return_value.select.assert_called_once_with(\"inbox\")\n        mock_imap.return_value.search.assert_called_once_with(None, \"UNSEEN\")\n        mock_imap.return_value.fetch.assert_called_once_with(b\"1\", \"(BODY.PEEK[])\")\n\n    def side_effect_for_open(original_open, file_path, *args, **kwargs):\n        if file_path == MOCK_ATTACHMENT_PATH:\n            return mock_open(read_data=b\"file_content\").return_value\n        return original_open(file_path, *args, **kwargs)\n\n    original_open = open\n    side_effect_with_original_open = partial(side_effect_for_open, original_open)\n\n    # Test for sending emails with EMAIL_DRAFT_MODE_WITH_FOLDER\n    @patch(\"imaplib.IMAP4_SSL\")\n    @patch.dict(\n        os.environ,\n        {\n            \"EMAIL_ADDRESS\": MOCK_FROM,\n            \"EMAIL_PASSWORD\": MOCK_PWD,\n            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n            \"EMAIL_DRAFT_MODE_WITH_FOLDER\": MOCK_DRAFT_FOLDER,\n        },\n    )\n    @patch(f\"{__name__}.imap_open\")\n    @patch(\"builtins.open\", side_effect=side_effect_with_original_open)\n    def test_send_emails_with_draft_mode(self, mock_file, mock_imap_open, mock_imap):\n        mock_imap_conn = mock_imap_open.return_value\n        mock_imap_conn.select.return_value = (\"OK\", [b\"0\"])\n        mock_imap_conn.append.return_value = (\"OK\", [b\"1\"])\n\n        result = send_email_with_attachment_internal(\n            MOCK_TO,\n            MOCK_SUBJECT,\n            MOCK_CONTENT,\n            MOCK_ATTACHMENT_PATH,\n            MOCK_ATTACHMENT_NAME,\n        )\n        assert result == f\"Email went to {MOCK_DRAFT_FOLDER}!\"\n        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n        mock_imap.return_value.select.assert_called_once_with(MOCK_DRAFT_FOLDER)\n\n        # Get the actual MIME message appended\n        mock_imap.return_value.append.assert_called_once()\n\n        append_args, _ = mock_imap.return_value.append.call_args\n        actual_mime_msg = append_args[3].decode(\"utf-8\")\n\n        # Check for the presence of relevant information in the MIME message\n        assert MOCK_FROM in actual_mime_msg\n        assert MOCK_TO in actual_mime_msg\n        assert MOCK_SUBJECT in actual_mime_msg\n        assert MOCK_CONTENT in actual_mime_msg\n        assert MOCK_ATTACHMENT_NAME in actual_mime_msg\n\n    # Test for reading an email where the subject has enconding issues or is null\n    @patch(\"imaplib.IMAP4_SSL\")\n    @patch.dict(\n        os.environ,\n        {\n            \"EMAIL_ADDRESS\": MOCK_FROM,\n            \"EMAIL_PASSWORD\": MOCK_PWD,\n            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n        },\n    )\n    def test_read_emails_subject_unknown_encoding(self, mock_imap):\n        assert os.getenv(\"EMAIL_ADDRESS\") == MOCK_FROM\n\n        # Create a mock email message\n        message = EmailMessage()\n        message[\"From\"] = MOCK_FROM\n        message[\"To\"] = MOCK_TO\n        message[\"Date\"] = MOCK_DATE\n        message[\"Subject\"] = None\n        message.set_content(MOCK_CONTENT)\n\n        # Set up mock IMAP server behavior\n        mock_imap.return_value.search.return_value = (None, [b\"1\"])\n        mock_imap.return_value.fetch.return_value = (None, [(b\"1\", message.as_bytes())])\n\n        # Test read_emails function\n        result = read_emails(\"inbox\", \"UNSEEN\", 1, 1)\n        expected_result = [\n            {\n                \"From\": MOCK_FROM,\n                \"To\": MOCK_TO,\n                \"Date\": MOCK_DATE,\n                \"CC\": \"\",\n                \"Subject\": \"\",\n                \"Message Body\": MOCK_CONTENT,\n            }\n        ]\n        assert result == expected_result\n\n        # Check if the IMAP object was created and used correctly\n        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n        mock_imap.return_value.select.assert_called_once_with(\"inbox\")\n        mock_imap.return_value.search.assert_called_once_with(None, \"UNSEEN\")\n        mock_imap.return_value.fetch.assert_called_once_with(b\"1\", \"(BODY.PEEK[])\")\n\n    # Test for reading an email where the body has enconding issues or is null\n    @patch(\"imaplib.IMAP4_SSL\")\n    @patch.dict(\n        os.environ,\n        {\n            \"EMAIL_ADDRESS\": MOCK_FROM,\n            \"EMAIL_PASSWORD\": MOCK_PWD,\n            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n        },\n    )\n    def test_read_emails_body_unknown_encoding(self, mock_imap):\n        assert os.getenv(\"EMAIL_ADDRESS\") == MOCK_FROM\n\n        # Create a mock email message\n        message = EmailMessage()\n        message[\"From\"] = MOCK_FROM\n        message[\"To\"] = MOCK_TO\n        message[\"Date\"] = MOCK_DATE\n        message[\"Subject\"] = MOCK_SUBJECT\n        message.set_content(\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\\n\")\n\n        # Set up mock IMAP server behavior\n        mock_imap.return_value.search.return_value = (None, [b\"1\"])\n        mock_imap.return_value.fetch.return_value = (None, [(b\"1\", message.as_bytes())])\n\n        # Test read_emails function\n        result = read_emails(\"inbox\", \"UNSEEN\", 1, 1)\n        expected_result = [\n            {\n                \"From\": MOCK_FROM,\n                \"To\": MOCK_TO,\n                \"Date\": MOCK_DATE,\n                \"CC\": \"\",\n                \"Subject\": MOCK_SUBJECT,\n                \"Message Body\": \"\",\n            }\n        ]\n        assert result == expected_result\n\n        # Check if the IMAP object was created and used correctly\n        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n        mock_imap.return_value.select.assert_called_once_with(\"inbox\")\n        mock_imap.return_value.search.assert_called_once_with(None, \"UNSEEN\")\n        mock_imap.return_value.fetch.assert_called_once_with(b\"1\", \"(BODY.PEEK[])\")\n\n    # Test for cleaning an email's bodies\n    @patch(\"imaplib.IMAP4_SSL\")\n    @patch.dict(\n        os.environ,\n        {\n            \"EMAIL_ADDRESS\": MOCK_FROM,\n            \"EMAIL_PASSWORD\": MOCK_PWD,\n            \"EMAIL_IMAP_SERVER\": MOCK_IMAP_SERVER,\n        },\n    )\n    def test_clean_email_body(self, mock_imap):\n        assert os.getenv(\"EMAIL_ADDRESS\") == MOCK_FROM\n\n        # Create a mock email message\n        message = EmailMessage()\n        message[\"From\"] = MOCK_FROM\n        message[\"To\"] = MOCK_TO\n        message[\"Date\"] = MOCK_DATE\n        message[\"Subject\"] = MOCK_SUBJECT\n        message.set_content(MOCK_CONTENT_DIRTY)\n\n        # Set up mock IMAP server behavior\n        mock_imap.return_value.search.return_value = (None, [b\"1\"])\n        mock_imap.return_value.fetch.return_value = (None, [(b\"1\", message.as_bytes())])\n\n        # Test read_emails with paginationfunction\n        result = read_emails(\"inbox\", \"UNSEEN\", 1, 1)\n        expected_result = [\n            {\n                \"From\": MOCK_FROM,\n                \"To\": MOCK_TO,\n                \"Date\": MOCK_DATE,\n                \"CC\": \"\",\n                \"Subject\": MOCK_SUBJECT,\n                \"Message Body\": \"Email Title This is an email template with a return character and a link at the end (\",\n            }\n        ]\n        assert result == expected_result\n\n        # Check if the IMAP object was created and used correctly\n        mock_imap.return_value.login.assert_called_once_with(MOCK_FROM, MOCK_PWD)\n        mock_imap.return_value.select.assert_called_once_with(\"inbox\")\n        mock_imap.return_value.search.assert_called_once_with(None, \"UNSEEN\")\n        mock_imap.return_value.fetch.assert_called_once_with(b\"1\", \"(BODY.PEEK[])\")", "\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "src/autogpt_plugins/email/email_plugin/email_plugin.py", "chunked_list": ["import email\nimport imaplib\nimport json\nimport mimetypes\nimport os\nimport re\nimport smtplib\nimport time\nfrom email.header import decode_header\nfrom email.message import EmailMessage", "from email.header import decode_header\nfrom email.message import EmailMessage\n\nfrom bs4 import BeautifulSoup\n\n\ndef bothEmailAndPwdSet() -> bool:\n    return True if os.getenv(\"EMAIL_ADDRESS\") and os.getenv(\"EMAIL_PASSWORD\") else False\n\n\ndef getSender():\n    email_sender = os.getenv(\"EMAIL_ADDRESS\")\n    if not email_sender:\n        return \"Error: email not sent. EMAIL_ADDRESS not set in environment.\"\n    return email_sender", "\n\ndef getSender():\n    email_sender = os.getenv(\"EMAIL_ADDRESS\")\n    if not email_sender:\n        return \"Error: email not sent. EMAIL_ADDRESS not set in environment.\"\n    return email_sender\n\n\ndef getPwd():\n    email_password = os.getenv(\"EMAIL_PASSWORD\")\n    if not email_password:\n        return \"Error: email not sent. EMAIL_PASSWORD not set in environment.\"\n    return email_password", "\ndef getPwd():\n    email_password = os.getenv(\"EMAIL_PASSWORD\")\n    if not email_password:\n        return \"Error: email not sent. EMAIL_PASSWORD not set in environment.\"\n    return email_password\n\n\ndef send_email(to: str, subject: str, body: str) -> str:\n    return send_email_with_attachment_internal(to, subject, body, None, None)", "def send_email(to: str, subject: str, body: str) -> str:\n    return send_email_with_attachment_internal(to, subject, body, None, None)\n\n\ndef send_email_with_attachment(to: str, subject: str, body: str, filename: str) -> str:\n    attachment_path = filename\n    attachment = os.path.basename(filename)\n    return send_email_with_attachment_internal(\n        to, subject, body, attachment_path, attachment\n    )", "\n\ndef send_email_with_attachment_internal(\n    to: str, title: str, message: str, attachment_path: str, attachment: str\n) -> str:\n    \"\"\"Send an email\n\n    Args:\n        to (str): The email of the recipient\n        title (str): The title of the email\n        message (str): The message content of the email\n\n    Returns:\n        str: Any error messages\n    \"\"\"\n    email_sender = getSender()\n    email_password = getPwd()\n\n    msg = EmailMessage()\n    msg[\"Subject\"] = title\n    msg[\"From\"] = email_sender\n    msg[\"To\"] = to\n\n    signature = os.getenv(\"EMAIL_SIGNATURE\")\n    if signature:\n        message += f\"\\n{signature}\"\n\n    msg.set_content(message)\n\n    if attachment_path:\n        ctype, encoding = mimetypes.guess_type(attachment_path)\n        if ctype is None or encoding is not None:\n            # No guess could be made, or the file is encoded (compressed)\n            ctype = \"application/octet-stream\"\n        maintype, subtype = ctype.split(\"/\", 1)\n        with open(attachment_path, \"rb\") as fp:\n            msg.add_attachment(\n                fp.read(), maintype=maintype, subtype=subtype, filename=attachment\n            )\n\n    draft_folder = os.getenv(\"EMAIL_DRAFT_MODE_WITH_FOLDER\")\n\n    if not draft_folder:\n        smtp_host = os.getenv(\"EMAIL_SMTP_HOST\")\n        smtp_port = os.getenv(\"EMAIL_SMTP_PORT\")\n        # send email\n        with smtplib.SMTP(smtp_host, smtp_port) as smtp:\n            smtp.ehlo()\n            smtp.starttls()\n            smtp.login(email_sender, email_password)\n            smtp.send_message(msg)\n            smtp.quit()\n        return f\"Email was sent to {to}!\"\n    else:\n        conn = imap_open(draft_folder, email_sender, email_password)\n        conn.append(\n            draft_folder,\n            \"\",\n            imaplib.Time2Internaldate(time.time()),\n            str(msg).encode(\"UTF-8\"),\n        )\n        return f\"Email went to {draft_folder}!\"", "\n\ndef read_emails(\n        imap_folder: str = \"inbox\", imap_search_command: str = \"UNSEEN\", limit: int = 5,\n        page: int = 1) -> str:\n    \"\"\"Read emails from an IMAP mailbox.\n\n    This function reads emails from a specified IMAP folder, using a given IMAP search command, limits, and page numbers.\n    It returns a list of emails with their details, including the sender, recipient, date, CC, subject, and message body.\n\n    Args:\n        imap_folder (str, optional): The name of the IMAP folder to read emails from. Defaults to \"inbox\".\n        imap_search_command (str, optional): The IMAP search command to filter emails. Defaults to \"UNSEEN\".\n        limit (int, optional): Number of email's the function should return. Defaults to 5 emails.\n        page (int, optional): The index of the page result the function should resturn. Defaults to 0, the first page.\n\n    Returns:\n        str: A list of dictionaries containing email details if there are any matching emails. Otherwise, returns\n             a string indicating that no matching emails were found.\n    \"\"\"\n    email_sender = getSender()\n    imap_folder = adjust_imap_folder_for_gmail(imap_folder, email_sender)\n    imap_folder = enclose_with_quotes(imap_folder)\n    imap_search_ar = split_imap_search_command(imap_search_command)\n    email_password = getPwd()\n\n    mark_as_seen = os.getenv(\"EMAIL_MARK_AS_SEEN\")\n    if isinstance(mark_as_seen, str):\n        mark_as_seen = json.loads(mark_as_seen.lower())\n\n    conn = imap_open(imap_folder, email_sender, email_password)\n\n    imap_keyword = imap_search_ar[0]\n    if len(imap_search_ar) == 1:\n        _, search_data = conn.search(None, imap_keyword)\n    else:\n        argument = enclose_with_quotes(imap_search_ar[1])\n        _, search_data = conn.search(None, imap_keyword, argument)\n\n    messages = []\n    for num in search_data[0].split():\n        if mark_as_seen:\n            message_parts = \"(RFC822)\"\n        else:\n            message_parts = \"(BODY.PEEK[])\"\n        _, msg_data = conn.fetch(num, message_parts)\n        for response_part in msg_data:\n            if isinstance(response_part, tuple):\n                msg = email.message_from_bytes(response_part[1])\n                \n                # If the subject has unknown encoding, return blank\n                if msg[\"Subject\"] is not None:\n                    subject, encoding = decode_header(msg[\"Subject\"])[0]\n                else:\n                    subject = \"\"\n                    encoding = \"\"\n\n\n                if isinstance(subject, bytes):\n                    try:\n                        # If the subject has unknown encoding, return blank\n                        if encoding is not None:\n                            subject = subject.decode(encoding)\n                        else:\n                            subject = \"\"\n                    except [LookupError] as e:\n                        pass\n\n                body = get_email_body(msg)\n                # Clean email body\n                body = clean_email_body(body)\n\n                from_address = msg[\"From\"]\n                to_address = msg[\"To\"]\n                date = msg[\"Date\"]\n                cc = msg[\"CC\"] if msg[\"CC\"] else \"\"\n\n                messages.append(\n                    {\n                        \"From\": from_address,\n                        \"To\": to_address,\n                        \"Date\": date,\n                        \"CC\": cc,\n                        \"Subject\": subject,\n                        \"Message Body\": body,\n                    }\n                )\n\n    conn.logout()\n    if not messages:\n        return (\n            f\"There are no Emails in your folder `{imap_folder}` \"\n            f\"when searching with imap command `{imap_search_command}`\"\n        )\n\n    # Confirm that integer parameters are the right type\n    limit = int(limit)\n    page = int(page)\n\n    # Validate parameter values\n    if limit < 1:\n        raise ValueError(\"Error: The message limit should be 1 or greater\")\n\n    page_count = len(messages) // limit + (len(messages) % limit > 0)\n\n    if page < 1 or page > page_count:\n        raise ValueError(\"Error: The page value references a page that is not part of the results\")\n\n    # Calculate paginated indexes\n    start_index = len(messages) - (page * limit + 1)\n    end_index = start_index + limit\n    start_index = max(start_index, 0)\n\n    # Return paginated indexes\n    if start_index == end_index:\n        return [messages[start_index]]\n    else:\n        return messages[start_index:end_index]", "\n\ndef adjust_imap_folder_for_gmail(imap_folder: str, email_sender: str) -> str:\n    if \"@gmail\" in email_sender.lower() or \"@googlemail\" in email_sender.lower():\n        if \"sent\" in imap_folder.lower():\n            return '\"[Gmail]/Sent Mail\"'\n        if \"draft\" in imap_folder.lower():\n            return \"[Gmail]/Drafts\"\n    return imap_folder\n", "\n\ndef imap_open(\n    imap_folder: str, email_sender: str, email_password: str\n) -> imaplib.IMAP4_SSL:\n    imap_server = os.getenv(\"EMAIL_IMAP_SERVER\")\n    conn = imaplib.IMAP4_SSL(imap_server)\n    conn.login(email_sender, email_password)\n    conn.select(imap_folder)\n    return conn", "\n\ndef get_email_body(msg: email.message.Message) -> str:\n    if msg.is_multipart():\n        for part in msg.walk():\n            content_type = part.get_content_type()\n            content_disposition = str(part.get(\"Content-Disposition\"))\n            if content_type == \"text/plain\" and \"attachment\" not in content_disposition:\n                # If the email body has unknown encoding, return null\n                try:\n                    return part.get_payload(decode=True).decode()\n                except UnicodeDecodeError as e:\n                    pass\n    else:\n        try:\n            # If the email body has unknown encoding, return null\n            return msg.get_payload(decode=True).decode()\n        except UnicodeDecodeError as e:\n            pass", "\ndef enclose_with_quotes(s):\n    # Check if string contains whitespace\n    has_whitespace = bool(re.search(r\"\\s\", s))\n\n    # Check if string is already enclosed by quotes\n    is_enclosed = s.startswith((\"'\", '\"')) and s.endswith((\"'\", '\"'))\n\n    # If string has whitespace and is not enclosed by quotes, enclose it with double quotes\n    if has_whitespace and not is_enclosed:\n        return f'\"{s}\"'\n    else:\n        return s", "\n\ndef split_imap_search_command(input_string):\n    input_string = input_string.strip()\n    parts = input_string.split(maxsplit=1)\n    parts = [part.strip() for part in parts]\n\n    return parts\n\ndef clean_email_body(email_body):\n    \"\"\"Remove formating and URL's from an email's body\n\n    Args:\n        email_body (str, optional): The email's body\n\n    Returns:\n        str: The email's body without any formating or URL's\n    \"\"\"\n\n    # If body is None, return an empty string\n    if email_body is None: email_body = \"\"\n\n    # Remove any HTML tags\n    email_body = BeautifulSoup(email_body, \"html.parser\")\n    email_body = email_body.get_text()\n\n    # Remove return characters\n    email_body = \"\".join(email_body.splitlines())\n\n    # Remove extra spaces\n    email_body = \" \".join(email_body.split())\n\n    # Remove unicode characters\n    email_body = email_body.encode(\"ascii\", \"ignore\")\n    email_body = email_body.decode(\"utf-8\", \"ignore\")\n\n    # Remove any remaining URL's\n    email_body = re.sub(r\"http\\S+\", \"\", email_body)\n\n    return email_body", "\ndef clean_email_body(email_body):\n    \"\"\"Remove formating and URL's from an email's body\n\n    Args:\n        email_body (str, optional): The email's body\n\n    Returns:\n        str: The email's body without any formating or URL's\n    \"\"\"\n\n    # If body is None, return an empty string\n    if email_body is None: email_body = \"\"\n\n    # Remove any HTML tags\n    email_body = BeautifulSoup(email_body, \"html.parser\")\n    email_body = email_body.get_text()\n\n    # Remove return characters\n    email_body = \"\".join(email_body.splitlines())\n\n    # Remove extra spaces\n    email_body = \" \".join(email_body.split())\n\n    # Remove unicode characters\n    email_body = email_body.encode(\"ascii\", \"ignore\")\n    email_body = email_body.decode(\"utf-8\", \"ignore\")\n\n    # Remove any remaining URL's\n    email_body = re.sub(r\"http\\S+\", \"\", email_body)\n\n    return email_body", ""]}
{"filename": "src/autogpt_plugins/news_search/__init__.py", "chunked_list": ["\"\"\"This is the News search engine plugin for Auto-GPT.\"\"\"\nimport os\nfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\nfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\n\nfrom .news_search import NewsSearch\n\nPromptGenerator = TypeVar(\"PromptGenerator\")\n", "PromptGenerator = TypeVar(\"PromptGenerator\")\n\n\nclass Message(TypedDict):\n    role: str\n    content: str\n\n\nclass AutoGPTNewsSearch(AutoGPTPluginTemplate):\n    def __init__(self):\n        super().__init__()\n        self._name = \"News-Search-Plugin\"\n        self._version = \"0.1.0\"\n        self._description = \"This plugin searches the latest news using the provided query and the newsapi aggregator\"\n        self.load_commands = os.getenv(\n            \"NEWSAPI_API_KEY\"\n        )  # Wrapper, if more variables are needed in future\n        self.news_search = NewsSearch(os.getenv(\"NEWSAPI_API_KEY\"))\n\n    def can_handle_post_prompt(self) -> bool:\n        return True\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        if self.load_commands:\n            # Add News Search command\n            prompt.add_command(\n                \"News Search\",\n                \"news_search\",\n                {\"query\": \"<query>\"},\n                self.news_search.news_everything_search,\n            )\n        else:\n            print(\n                \"Warning: News-Search-Plugin is not fully functional. \"\n                \"Please set the NEWSAPI_API_KEY environment variable.\"\n            )\n        return prompt\n\n    def can_handle_pre_command(self) -> bool:\n        return False\n\n    def pre_command(\n        self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        pass\n\n    def can_handle_post_command(self) -> bool:\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        pass\n\n    def can_handle_on_planning(self) -> bool:\n        return False\n\n    def on_planning(\n        self, prompt: PromptGenerator, messages: List[Message]\n    ) -> Optional[str]:\n        pass\n\n    def can_handle_on_response(self) -> bool:\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        return False\n\n    def post_planning(self, response: str) -> str:\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        return False\n\n    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        return False\n\n    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        pass\n\n    def can_handle_pre_command(self) -> bool:\n        return False\n\n    def can_handle_chat_completion(\n        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n    ) -> bool:\n        return False\n\n    def handle_chat_completion(\n        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n    ) -> str:\n        pass\n\n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass", "class AutoGPTNewsSearch(AutoGPTPluginTemplate):\n    def __init__(self):\n        super().__init__()\n        self._name = \"News-Search-Plugin\"\n        self._version = \"0.1.0\"\n        self._description = \"This plugin searches the latest news using the provided query and the newsapi aggregator\"\n        self.load_commands = os.getenv(\n            \"NEWSAPI_API_KEY\"\n        )  # Wrapper, if more variables are needed in future\n        self.news_search = NewsSearch(os.getenv(\"NEWSAPI_API_KEY\"))\n\n    def can_handle_post_prompt(self) -> bool:\n        return True\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        if self.load_commands:\n            # Add News Search command\n            prompt.add_command(\n                \"News Search\",\n                \"news_search\",\n                {\"query\": \"<query>\"},\n                self.news_search.news_everything_search,\n            )\n        else:\n            print(\n                \"Warning: News-Search-Plugin is not fully functional. \"\n                \"Please set the NEWSAPI_API_KEY environment variable.\"\n            )\n        return prompt\n\n    def can_handle_pre_command(self) -> bool:\n        return False\n\n    def pre_command(\n        self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        pass\n\n    def can_handle_post_command(self) -> bool:\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        pass\n\n    def can_handle_on_planning(self) -> bool:\n        return False\n\n    def on_planning(\n        self, prompt: PromptGenerator, messages: List[Message]\n    ) -> Optional[str]:\n        pass\n\n    def can_handle_on_response(self) -> bool:\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        return False\n\n    def post_planning(self, response: str) -> str:\n        pass\n\n    def can_handle_pre_instruction(self) -> bool:\n        return False\n\n    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n        pass\n\n    def can_handle_on_instruction(self) -> bool:\n        return False\n\n    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        pass\n\n    def can_handle_pre_command(self) -> bool:\n        return False\n\n    def can_handle_chat_completion(\n        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n    ) -> bool:\n        return False\n\n    def handle_chat_completion(\n        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n    ) -> str:\n        pass\n\n    def can_handle_text_embedding(\n        self, text: str\n    ) -> bool:\n        return False\n    \n    def handle_text_embedding(\n        self, text: str\n    ) -> list:\n        pass\n    \n    def can_handle_user_input(self, user_input: str) -> bool:\n        return False\n\n    def user_input(self, user_input: str) -> str:\n        return user_input\n\n    def can_handle_report(self) -> bool:\n        return False\n\n    def report(self, message: str) -> None:\n        pass"]}
{"filename": "src/autogpt_plugins/news_search/news_search.py", "chunked_list": ["import concurrent.futures\nfrom typing import List\n\nfrom newsapi import NewsApiClient\n\ncategories = [\"technology\", \"business\", \"entertainment\", \"health\", \"sports\", \"science\"]\n\n\nclass NewsSearch(object):\n    def __init__(self, api_key):\n        self.news_api_client = NewsApiClient(api_key)\n\n    def news_headlines_search(self, category: str, query: str) -> List[str]:\n        \"\"\"\n        Get top news headlines for category specified.\n        Args:\n            category (str) : The category specified. Must be one of technology, business, entertainment, health, sports or science.\n        Returns:\n            list(str): A list of top news headlines for the specified category.\n        \"\"\"\n        result = self.news_api_client.get_top_headlines(\n            category=category, language=\"en\", country=\"us\", page=1, q=query\n        )\n        return [article[\"title\"] for article in result[\"articles\"][:3]]\n\n    def news_everything_search(self, query: str) -> List[str]:\n        \"\"\"\n        Get all news for query specified.\n        Args:\n            query (str) : The query specified.\n        Returns:\n            list(str): A list of news for the specified category, sorted by relevant.\n        \"\"\"\n        result = self.news_api_client.get_everything(\n            language=\"en\", page=1, q=query, sort_by=\"relevancy\"\n        )\n        return [article[\"title\"] for article in result[\"articles\"]]\n\n    def news_headlines_search_wrapper(self, query: str) -> List[str]:\n        \"\"\"\n        Aggregates top news headlines from the categories.\n        Returns:\n            list(str): A list of top news headlines aggregated from all categories.\n        \"\"\"\n        with concurrent.futures.ThreadPoolExecutor() as tp:\n            futures = []\n            for cat in categories:\n                futures.append(\n                    tp.submit(self.news_headlines_search, category=cat, query=query)\n                )\n\n            aggregated_headlines = []\n            for fut in concurrent.futures.wait(futures)[0]:\n                aggregated_headlines.append(fut.result())\n\n            return aggregated_headlines", "class NewsSearch(object):\n    def __init__(self, api_key):\n        self.news_api_client = NewsApiClient(api_key)\n\n    def news_headlines_search(self, category: str, query: str) -> List[str]:\n        \"\"\"\n        Get top news headlines for category specified.\n        Args:\n            category (str) : The category specified. Must be one of technology, business, entertainment, health, sports or science.\n        Returns:\n            list(str): A list of top news headlines for the specified category.\n        \"\"\"\n        result = self.news_api_client.get_top_headlines(\n            category=category, language=\"en\", country=\"us\", page=1, q=query\n        )\n        return [article[\"title\"] for article in result[\"articles\"][:3]]\n\n    def news_everything_search(self, query: str) -> List[str]:\n        \"\"\"\n        Get all news for query specified.\n        Args:\n            query (str) : The query specified.\n        Returns:\n            list(str): A list of news for the specified category, sorted by relevant.\n        \"\"\"\n        result = self.news_api_client.get_everything(\n            language=\"en\", page=1, q=query, sort_by=\"relevancy\"\n        )\n        return [article[\"title\"] for article in result[\"articles\"]]\n\n    def news_headlines_search_wrapper(self, query: str) -> List[str]:\n        \"\"\"\n        Aggregates top news headlines from the categories.\n        Returns:\n            list(str): A list of top news headlines aggregated from all categories.\n        \"\"\"\n        with concurrent.futures.ThreadPoolExecutor() as tp:\n            futures = []\n            for cat in categories:\n                futures.append(\n                    tp.submit(self.news_headlines_search, category=cat, query=query)\n                )\n\n            aggregated_headlines = []\n            for fut in concurrent.futures.wait(futures)[0]:\n                aggregated_headlines.append(fut.result())\n\n            return aggregated_headlines", ""]}
{"filename": "src/autogpt_plugins/news_search/test_auto_gpt_news_search.py", "chunked_list": ["import json\nfrom unittest.mock import Mock\n\nimport pytest\n\nfrom .news_search import NewsSearch\n\n\nclass TestNewsSearch:\n    def mock_response(self, *args, **kwargs):\n        # Mock Response of NewsAPI. We have result for AutoGPT in technology but not others,\n        # whereas Cricket is present in Sports/Entertainment but not others\n        if kwargs[\"q\"] == \"AI\" and kwargs[\"category\"] == \"technology\":\n            return json.loads(\n                \"\"\"{\"status\":\"ok\",\"totalResults\":1,\"articles\": [{\"title\": \"AutoGPT\"}]}\"\"\"\n            )\n        elif kwargs[\"q\"] == \"Cricket\" and kwargs[\"category\"] in [\n            \"entertainment\",\n            \"sports\",\n        ]:\n            return json.loads(\n                \"\"\"{\"status\":\"ok\",\"totalResults\":1,\"articles\": [{\"title\": \"World Cup\"}]}\"\"\"\n            )\n        elif kwargs[\"q\"] == \"Taylor Swift\":\n            return json.loads(\n                \"\"\"{\"status\": \"ok\",\"totalResults\": 1,\"articles\": [{\"title\": \"The National enlist Taylor Swift for new song \u201cThe Alcott\u201d\"}]}\"\"\"\n            )\n        else:\n            return json.loads(\"\"\"{\"status\":\"ok\",\"totalResults\":0,\"articles\":[]}\"\"\")\n\n    @pytest.fixture(autouse=True)\n    def setUp(self):\n        self.NewsSearch = NewsSearch(\"testKey\")\n        self.NewsSearch.news_api_client.get_top_headlines = Mock(\n            side_effect=self.mock_response\n        )\n        self.NewsSearch.news_api_client.get_everything = Mock(\n            side_effect=self.mock_response\n        )\n\n    def test_news_search(self):\n        # For AI, only technology should be populated. However, we can't rely on ordering,\n        # so we'll assert one actual answer and 5 empty answers\n        actual_output_autogpt = self.NewsSearch.news_headlines_search_wrapper(\"AI\")\n        assert actual_output_autogpt.count([\"AutoGPT\"]) == 1\n        assert actual_output_autogpt.count([]) == 5\n\n        # For Cricket, we should have sports/entertainment\n        actual_output_cricket = self.NewsSearch.news_headlines_search_wrapper(\"Cricket\")\n        assert actual_output_cricket.count([\"World Cup\"]) == 2\n        assert actual_output_cricket.count([]) == 4\n\n        actual_output_taylor = self.NewsSearch.news_everything_search(\"Taylor Swift\")\n        assert actual_output_taylor.count([\"Taylor Swift\"]) == 0\n        assert actual_output_taylor.count([]) == 0", "class TestNewsSearch:\n    def mock_response(self, *args, **kwargs):\n        # Mock Response of NewsAPI. We have result for AutoGPT in technology but not others,\n        # whereas Cricket is present in Sports/Entertainment but not others\n        if kwargs[\"q\"] == \"AI\" and kwargs[\"category\"] == \"technology\":\n            return json.loads(\n                \"\"\"{\"status\":\"ok\",\"totalResults\":1,\"articles\": [{\"title\": \"AutoGPT\"}]}\"\"\"\n            )\n        elif kwargs[\"q\"] == \"Cricket\" and kwargs[\"category\"] in [\n            \"entertainment\",\n            \"sports\",\n        ]:\n            return json.loads(\n                \"\"\"{\"status\":\"ok\",\"totalResults\":1,\"articles\": [{\"title\": \"World Cup\"}]}\"\"\"\n            )\n        elif kwargs[\"q\"] == \"Taylor Swift\":\n            return json.loads(\n                \"\"\"{\"status\": \"ok\",\"totalResults\": 1,\"articles\": [{\"title\": \"The National enlist Taylor Swift for new song \u201cThe Alcott\u201d\"}]}\"\"\"\n            )\n        else:\n            return json.loads(\"\"\"{\"status\":\"ok\",\"totalResults\":0,\"articles\":[]}\"\"\")\n\n    @pytest.fixture(autouse=True)\n    def setUp(self):\n        self.NewsSearch = NewsSearch(\"testKey\")\n        self.NewsSearch.news_api_client.get_top_headlines = Mock(\n            side_effect=self.mock_response\n        )\n        self.NewsSearch.news_api_client.get_everything = Mock(\n            side_effect=self.mock_response\n        )\n\n    def test_news_search(self):\n        # For AI, only technology should be populated. However, we can't rely on ordering,\n        # so we'll assert one actual answer and 5 empty answers\n        actual_output_autogpt = self.NewsSearch.news_headlines_search_wrapper(\"AI\")\n        assert actual_output_autogpt.count([\"AutoGPT\"]) == 1\n        assert actual_output_autogpt.count([]) == 5\n\n        # For Cricket, we should have sports/entertainment\n        actual_output_cricket = self.NewsSearch.news_headlines_search_wrapper(\"Cricket\")\n        assert actual_output_cricket.count([\"World Cup\"]) == 2\n        assert actual_output_cricket.count([]) == 4\n\n        actual_output_taylor = self.NewsSearch.news_everything_search(\"Taylor Swift\")\n        assert actual_output_taylor.count([\"Taylor Swift\"]) == 0\n        assert actual_output_taylor.count([]) == 0", ""]}
{"filename": "src/autogpt_plugins/random_values/__init__.py", "chunked_list": ["\"\"\"Random Values commands.\"\"\"\nfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\nfrom auto_gpt_plugin_template import AutoGPTPluginTemplate\ntry:\n    from .random_values import RandomValues\nexcept ImportError:\n    from random_values import RandomValues\n\nPromptGenerator = TypeVar(\"PromptGenerator\")\n\nclass Message(TypedDict):\n    role: str\n    content: str", "PromptGenerator = TypeVar(\"PromptGenerator\")\n\nclass Message(TypedDict):\n    role: str\n    content: str\n\n\nclass AutoGPTRandomValues(AutoGPTPluginTemplate):\n    \"\"\"\n    Random Values plugin for Auto-GPT.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._name = \"AutoGPTRandomValues\"\n        self._version = \"0.1.2\"\n        self._description = \"Enable Auto-GPT with the power of random values.\"\n        self.plugin_class = RandomValues(self)\n\n    def can_handle_on_response(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_response method.\n        Returns:\n            bool: True if the plugin can handle the on_response method.\"\"\"\n        return False\n\n    def on_response(self, response: str, *args, **kwargs) -> str:\n        \"\"\"This method is called when a response is received from the model.\"\"\"\n        return response\n\n    def can_handle_post_prompt(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_prompt method.\n        Returns:\n            bool: True if the plugin can handle the post_prompt method.\"\"\"\n        return True\n\n    def can_handle_on_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_planning method.\n        Returns:\n            bool: True if the plugin can handle the on_planning method.\"\"\"\n        return False\n\n    def on_planning(\n        self, prompt: PromptGenerator, messages: List[str]\n    ) -> Optional[str]:\n        \"\"\"This method is called before the planning chat completeion is done.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n            messages (List[str]): The list of messages.\n        \"\"\"\n        pass\n\n    def can_handle_post_planning(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_planning method.\n        Returns:\n            bool: True if the plugin can handle the post_planning method.\"\"\"\n        return False\n\n    def post_planning(self, response: str) -> str:\n        \"\"\"This method is called after the planning chat completeion is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return response\n\n    def can_handle_pre_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_instruction method.\n        Returns:\n            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n        return False\n\n    def pre_instruction(self, messages: List[str]) -> List[str]:\n        \"\"\"This method is called before the instruction chat is done.\n        Args:\n            messages (List[str]): The list of context messages.\n        Returns:\n            List[str]: The resulting list of messages.\n        \"\"\"\n        return messages\n\n    def can_handle_on_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the on_instruction method.\n        Returns:\n            bool: True if the plugin can handle the on_instruction method.\"\"\"\n        return False\n\n    def on_instruction(self, messages: List[str]) -> Optional[str]:\n        \"\"\"This method is called when the instruction chat is done.\n        Args:\n            messages (List[str]): The list of context messages.\n        Returns:\n            Optional[str]: The resulting message.\n        \"\"\"\n        pass\n\n    def can_handle_post_instruction(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_instruction method.\n        Returns:\n            bool: True if the plugin can handle the post_instruction method.\"\"\"\n        return False\n\n    def post_instruction(self, response: str) -> str:\n        \"\"\"This method is called after the instruction chat is done.\n        Args:\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return response\n\n    def can_handle_pre_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the pre_command method.\n        Returns:\n            bool: True if the plugin can handle the pre_command method.\"\"\"\n        return False\n\n    def pre_command(\n        self, command_name: str, arguments: Dict[str, Any]\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"This method is called before the command is executed.\n        Args:\n            command_name (str): The command name.\n            arguments (Dict[str, Any]): The arguments.\n        Returns:\n            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n        \"\"\"\n        return command_name, arguments\n\n    def can_handle_post_command(self) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the post_command method.\n        Returns:\n            bool: True if the plugin can handle the post_command method.\"\"\"\n        return False\n\n    def post_command(self, command_name: str, response: str) -> str:\n        \"\"\"This method is called after the command is executed.\n        Args:\n            command_name (str): The command name.\n            response (str): The response.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return response\n\n    def can_handle_chat_completion(\n        self,\n        messages: list[Dict[Any, Any]],\n        model: str,\n        temperature: float,\n        max_tokens: int,\n    ) -> bool:\n        \"\"\"This method is called to check that the plugin can\n        handle the chat_completion method.\n        Args:\n            messages (Dict[Any, Any]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            bool: True if the plugin can handle the chat_completion method.\"\"\"\n        return False\n\n    def handle_chat_completion(\n        self,\n        messages: list[Dict[Any, Any]],\n        model: str,\n        temperature: float,\n        max_tokens: int,\n    ) -> str:\n        \"\"\"This method is called when the chat completion is done.\n        Args:\n            messages (Dict[Any, Any]): The messages.\n            model (str): The model name.\n            temperature (float): The temperature.\n            max_tokens (int): The max tokens.\n        Returns:\n            str: The resulting response.\n        \"\"\"\n        return ''\n\n    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n        \"\"\"This method is called just after the generate_prompt is called,\n            but actually before the prompt is generated.\n        Args:\n            prompt (PromptGenerator): The prompt generator.\n        Returns:\n            PromptGenerator: The prompt generator.\n        \"\"\"\n\n        prompt.add_command(  # type: ignore\n            \"rnd_num\",\n            \"Random Numbers\",\n            {\"min\": \"<int>\", \"max\": \"<int>\", \"cnt\": \"<int>\"},\n            self.plugin_class.random_number,\n        )\n        prompt.add_command(  # type: ignore\n            \"uuids\", \n            \"Make UUIDs\", \n            {\"cnt\": \"<int>\"}, \n            self.plugin_class.make_uuids\n        )\n        prompt.add_command(  # type: ignore\n            \"make_str\",\n            \"Generate Strings\",\n            {\"len\": \"<int>\", \"cnt\": \"<int>\"},\n            self.plugin_class.generate_string,\n        )\n        prompt.add_command( # type: ignore\n            \"pwds\",\n            \"Create Passwords\",\n            {\"len\": \"<int>\", \"cnt\": \"<int>\"},\n            self.plugin_class.generate_password,\n        )\n        prompt.add_command( # type: ignore\n            \"lorem_ipsum\",\n            \"Create Lorem Sentences\",\n            {\"cnt\": \"<int>\"},\n            self.plugin_class.generate_placeholder_text,\n        )\n        return prompt\n     \n    def can_handle_text_embedding(self, text: str) -> bool:  # type: ignore\n        return False\n    \n    def handle_text_embedding(self, text: str) -> list:  # type: ignore\n        pass\n\n    def can_handle_user_input(self, user_input: str) -> bool:\n            return False\n    \n    def user_input(self, user_input: str) -> str:\n        return user_input\n    \n    def can_handle_report(self) -> bool:\n        return False\n    \n    def report(self, message: str) -> None:\n        pass", ""]}
{"filename": "src/autogpt_plugins/random_values/test_random_valaues.py", "chunked_list": ["import json\nimport string\nfrom unittest.mock import Mock\nfrom unittest import TestCase\ntry:\n    from .random_values import RandomValues\nexcept ImportError:\n    from random_values import RandomValues\n\nclass TestRandomValueCommands(TestCase):\n    # _random_number Tests\n\n    def setUp(self):\n        self.random_values = RandomValues(Mock())\n\n    def test_random_number(self):\n        result = json.loads(self.random_values.random_number(min=10, max=20, cnt=5))\n        self.assertEqual(len(result), 5)\n        for num in result:\n            self.assertTrue(10 <= num <= 20)\n\n    def test_random_number_using_strings(self):\n        result = json.loads(self.random_values.random_number(min=\"10\", max=\"20\", cnt=\"5\"))\n        self.assertEqual(len(result), 5)\n        for num in result:\n            self.assertTrue(10 <= num <= 20)\n\n    def test_random_number_using_missing_min(self):\n        result = json.loads(self.random_values.random_number(max=20, cnt=5))\n        self.assertEqual(len(result), 5)\n        for num in result:\n            self.assertTrue(0 <= num <= 20)\n\n    def test_random_number_using_missing_max(self):\n        result = json.loads(self.random_values.random_number(min=10, cnt=5))\n        self.assertEqual(len(result), 5)\n        for num in result:\n            self.assertTrue(10 <= num <= 65535)\n\n    def test_random_number_using_missing_count(self):\n        result = json.loads(self.random_values.random_number(min=10, max=20))\n        self.assertEqual(len(result), 1)\n        for num in result:\n            self.assertTrue(10 <= num <= 20)\n\n    def test_random_number_min_using_garbage(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.random_number(min=\"foo\", max=\"20\", cnt=\"5\")\n        self.assertEqual(str(e.exception), \"min must be an integer\")\n\n    def test_random_number_max_using_garbage(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.random_number(min=\"10\", max=\"bar\", cnt=\"5\")\n        self.assertEqual(str(e.exception), \"max must be an integer\")\n\n    def test_random_number_count_using_garbage(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.random_number(min=\"10\", max=\"20\", cnt=\"baz\")\n        self.assertEqual(str(e.exception), \"cnt must be an integer\")\n\n    def test_make_uuids(self):\n        result = json.loads(self.random_values.make_uuids(cnt=5))\n        self.assertEqual(len(result), 5)\n        for uid in result:\n            self.assertIsInstance(uid, str)\n            self.assertEqual(len(uid), 36)  # UUIDs have 36 characters\n\n    def test_make_uuids_using_strings(self):\n        result = json.loads(self.random_values.make_uuids(cnt=\"5\"))\n        self.assertEqual(len(result), 5)\n        for uid in result:\n            self.assertIsInstance(uid, str)\n            self.assertEqual(len(uid), 36)\n\n    def test_make_uuids_using_missing_count(self):\n        # If missing, count defaults to 1\n        result = json.loads(self.random_values.make_uuids())\n        self.assertEqual(len(result), 1)\n        for uid in result:\n            self.assertIsInstance(uid, str)\n            self.assertEqual(len(uid), 36)\n\n    def test_make_uuids_using_garbage(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.make_uuids(cnt=\"foo\")\n        self.assertEqual(str(e.exception), \"cnt must be an integer\")\n\n    # _generate_string Tests\n\n    def test_generate_string(self):\n        result = json.loads(self.random_values.generate_string(len=10, cnt=5))\n        self.assertEqual(len(result), 5)\n        for string in result:\n            self.assertEqual(len(string), 10)\n            # Strings should only contain letters and numbers\n            self.assertTrue(string.isalnum())\n\n    def test_generate_string_using_strings(self):\n        result = json.loads(self.random_values.generate_string(len=\"10\", cnt=\"5\"))\n        self.assertEqual(len(result), 5)\n        for string in result:\n            self.assertEqual(len(string), 10)\n            # Strings should only contain letters and numbers\n            self.assertTrue(string.isalnum())\n\n    def test_generate_string_using_missing_length(self):\n        # If missing, length defaults to 10\n        result = json.loads(self.random_values.generate_string(cnt=5))\n        self.assertEqual(len(result), 5)\n        for string in result:\n            self.assertEqual(len(string), 10)\n            # Strings should only contain letters and numbers\n            self.assertTrue(string.isalnum())\n\n    def test_generate_string_using_missing_count(self):\n        # If missing, count defaults to 1\n        result = json.loads(self.random_values.generate_string(len=10))\n        self.assertEqual(len(result), 1)\n        for string in result:\n            self.assertEqual(len(string), 10)\n            # Strings should only contain letters and numbers\n            self.assertTrue(string.isalnum())\n\n    def test_generate_string_using_garbage(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.generate_string(len=\"foo\", cnt=\"bar\")\n        self.assertEqual(str(e.exception), \"len must be an integer\")\n\n    # _generate_password Tests\n\n    def test_generate_password(self):\n        result = json.loads(self.random_values.generate_password(len=10, cnt=5))\n        self.assertEqual(len(result), 5)\n        for password in result:\n            self.assertEqual(len(password), 10)\n            # Passwords should contain letters, numbers, and symbols\n            self.assertTrue(self.is_password(password))\n\n    def test_generate_password_using_strings(self):\n        result = json.loads(self.random_values.generate_password(len=\"10\", cnt=\"5\"))\n        self.assertEqual(len(result), 5)\n        for password in result:\n            self.assertEqual(len(password), 10)\n            # Passwords should contain letters, numbers, and symbols\n            self.assertTrue(self.is_password(password))\n\n    def test_generate_password_using_missing_length(self):\n        # If missing, length defaults to 10\n        result = json.loads(self.random_values.generate_password(cnt=5))\n        self.assertEqual(len(result), 5)\n        for password in result:\n            self.assertEqual(len(password), 16)\n            # Passwords should contain letters, numbers, and symbols\n            self.assertTrue(self.is_password(password))\n\n    def test_generate_password_using_missing_count(self):\n        # If missing, count defaults to 1\n        result = json.loads(self.random_values.generate_password(len=10))\n        self.assertEqual(len(result), 1)\n        for password in result:\n            self.assertEqual(len(password), 10)\n            # Passwords should contain letters, numbers, and symbols\n            self.assertTrue(self.is_password(password))\n\n    def test_generate_password_using_garbage(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.generate_password(len=\"foo\", cnt=\"bar\")\n        self.assertEqual(str(e.exception), \"len must be an integer\")\n\n    # _generate_placeholder_text Tests\n\n    def test_generate_placeholder_text(self):\n        result = json.loads(self.random_values.generate_placeholder_text(cnt=5))\n        self.assertEqual(len(result), 5)\n        for text in result:\n            self.assertGreater(len(text), 3)\n\n    def test_generate_placeholder_text_using_strings(self):\n        result = json.loads(self.random_values.generate_placeholder_text(cnt=\"5\"))\n        self.assertEqual(len(result), 5)\n        for text in result:\n            self.assertGreater(len(text), 3)\n\n    def test_generate_placeholder_text_using_empty_string(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.generate_placeholder_text(cnt=\"\")\n        self.assertEqual(str(e.exception), \"cnt must be an integer\")\n\n    def test_generate_placeholder_text_using_garbage(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.generate_placeholder_text(cnt=\"foo\")\n        self.assertEqual(str(e.exception), \"cnt must be an integer\")\n\n    # checks that the given string only contains ascii letters, digits & punctuation\n    def is_password(self, input_str):\n        characters = string.ascii_letters + string.digits + string.punctuation\n        for character in input_str:\n            if character not in characters:\n                return False\n        return True", "\nclass TestRandomValueCommands(TestCase):\n    # _random_number Tests\n\n    def setUp(self):\n        self.random_values = RandomValues(Mock())\n\n    def test_random_number(self):\n        result = json.loads(self.random_values.random_number(min=10, max=20, cnt=5))\n        self.assertEqual(len(result), 5)\n        for num in result:\n            self.assertTrue(10 <= num <= 20)\n\n    def test_random_number_using_strings(self):\n        result = json.loads(self.random_values.random_number(min=\"10\", max=\"20\", cnt=\"5\"))\n        self.assertEqual(len(result), 5)\n        for num in result:\n            self.assertTrue(10 <= num <= 20)\n\n    def test_random_number_using_missing_min(self):\n        result = json.loads(self.random_values.random_number(max=20, cnt=5))\n        self.assertEqual(len(result), 5)\n        for num in result:\n            self.assertTrue(0 <= num <= 20)\n\n    def test_random_number_using_missing_max(self):\n        result = json.loads(self.random_values.random_number(min=10, cnt=5))\n        self.assertEqual(len(result), 5)\n        for num in result:\n            self.assertTrue(10 <= num <= 65535)\n\n    def test_random_number_using_missing_count(self):\n        result = json.loads(self.random_values.random_number(min=10, max=20))\n        self.assertEqual(len(result), 1)\n        for num in result:\n            self.assertTrue(10 <= num <= 20)\n\n    def test_random_number_min_using_garbage(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.random_number(min=\"foo\", max=\"20\", cnt=\"5\")\n        self.assertEqual(str(e.exception), \"min must be an integer\")\n\n    def test_random_number_max_using_garbage(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.random_number(min=\"10\", max=\"bar\", cnt=\"5\")\n        self.assertEqual(str(e.exception), \"max must be an integer\")\n\n    def test_random_number_count_using_garbage(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.random_number(min=\"10\", max=\"20\", cnt=\"baz\")\n        self.assertEqual(str(e.exception), \"cnt must be an integer\")\n\n    def test_make_uuids(self):\n        result = json.loads(self.random_values.make_uuids(cnt=5))\n        self.assertEqual(len(result), 5)\n        for uid in result:\n            self.assertIsInstance(uid, str)\n            self.assertEqual(len(uid), 36)  # UUIDs have 36 characters\n\n    def test_make_uuids_using_strings(self):\n        result = json.loads(self.random_values.make_uuids(cnt=\"5\"))\n        self.assertEqual(len(result), 5)\n        for uid in result:\n            self.assertIsInstance(uid, str)\n            self.assertEqual(len(uid), 36)\n\n    def test_make_uuids_using_missing_count(self):\n        # If missing, count defaults to 1\n        result = json.loads(self.random_values.make_uuids())\n        self.assertEqual(len(result), 1)\n        for uid in result:\n            self.assertIsInstance(uid, str)\n            self.assertEqual(len(uid), 36)\n\n    def test_make_uuids_using_garbage(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.make_uuids(cnt=\"foo\")\n        self.assertEqual(str(e.exception), \"cnt must be an integer\")\n\n    # _generate_string Tests\n\n    def test_generate_string(self):\n        result = json.loads(self.random_values.generate_string(len=10, cnt=5))\n        self.assertEqual(len(result), 5)\n        for string in result:\n            self.assertEqual(len(string), 10)\n            # Strings should only contain letters and numbers\n            self.assertTrue(string.isalnum())\n\n    def test_generate_string_using_strings(self):\n        result = json.loads(self.random_values.generate_string(len=\"10\", cnt=\"5\"))\n        self.assertEqual(len(result), 5)\n        for string in result:\n            self.assertEqual(len(string), 10)\n            # Strings should only contain letters and numbers\n            self.assertTrue(string.isalnum())\n\n    def test_generate_string_using_missing_length(self):\n        # If missing, length defaults to 10\n        result = json.loads(self.random_values.generate_string(cnt=5))\n        self.assertEqual(len(result), 5)\n        for string in result:\n            self.assertEqual(len(string), 10)\n            # Strings should only contain letters and numbers\n            self.assertTrue(string.isalnum())\n\n    def test_generate_string_using_missing_count(self):\n        # If missing, count defaults to 1\n        result = json.loads(self.random_values.generate_string(len=10))\n        self.assertEqual(len(result), 1)\n        for string in result:\n            self.assertEqual(len(string), 10)\n            # Strings should only contain letters and numbers\n            self.assertTrue(string.isalnum())\n\n    def test_generate_string_using_garbage(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.generate_string(len=\"foo\", cnt=\"bar\")\n        self.assertEqual(str(e.exception), \"len must be an integer\")\n\n    # _generate_password Tests\n\n    def test_generate_password(self):\n        result = json.loads(self.random_values.generate_password(len=10, cnt=5))\n        self.assertEqual(len(result), 5)\n        for password in result:\n            self.assertEqual(len(password), 10)\n            # Passwords should contain letters, numbers, and symbols\n            self.assertTrue(self.is_password(password))\n\n    def test_generate_password_using_strings(self):\n        result = json.loads(self.random_values.generate_password(len=\"10\", cnt=\"5\"))\n        self.assertEqual(len(result), 5)\n        for password in result:\n            self.assertEqual(len(password), 10)\n            # Passwords should contain letters, numbers, and symbols\n            self.assertTrue(self.is_password(password))\n\n    def test_generate_password_using_missing_length(self):\n        # If missing, length defaults to 10\n        result = json.loads(self.random_values.generate_password(cnt=5))\n        self.assertEqual(len(result), 5)\n        for password in result:\n            self.assertEqual(len(password), 16)\n            # Passwords should contain letters, numbers, and symbols\n            self.assertTrue(self.is_password(password))\n\n    def test_generate_password_using_missing_count(self):\n        # If missing, count defaults to 1\n        result = json.loads(self.random_values.generate_password(len=10))\n        self.assertEqual(len(result), 1)\n        for password in result:\n            self.assertEqual(len(password), 10)\n            # Passwords should contain letters, numbers, and symbols\n            self.assertTrue(self.is_password(password))\n\n    def test_generate_password_using_garbage(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.generate_password(len=\"foo\", cnt=\"bar\")\n        self.assertEqual(str(e.exception), \"len must be an integer\")\n\n    # _generate_placeholder_text Tests\n\n    def test_generate_placeholder_text(self):\n        result = json.loads(self.random_values.generate_placeholder_text(cnt=5))\n        self.assertEqual(len(result), 5)\n        for text in result:\n            self.assertGreater(len(text), 3)\n\n    def test_generate_placeholder_text_using_strings(self):\n        result = json.loads(self.random_values.generate_placeholder_text(cnt=\"5\"))\n        self.assertEqual(len(result), 5)\n        for text in result:\n            self.assertGreater(len(text), 3)\n\n    def test_generate_placeholder_text_using_empty_string(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.generate_placeholder_text(cnt=\"\")\n        self.assertEqual(str(e.exception), \"cnt must be an integer\")\n\n    def test_generate_placeholder_text_using_garbage(self):\n        with self.assertRaises(ValueError) as e:\n            self.random_values.generate_placeholder_text(cnt=\"foo\")\n        self.assertEqual(str(e.exception), \"cnt must be an integer\")\n\n    # checks that the given string only contains ascii letters, digits & punctuation\n    def is_password(self, input_str):\n        characters = string.ascii_letters + string.digits + string.punctuation\n        for character in input_str:\n            if character not in characters:\n                return False\n        return True", ""]}
{"filename": "src/autogpt_plugins/random_values/random_values.py", "chunked_list": ["\"\"\"Random Values classes for Autogpt.\"\"\"\n\nimport json\nimport random\nimport string\nimport uuid\n\nimport lorem\n\n\"\"\"Random Number function for Autogpt.\"\"\"", "\n\"\"\"Random Number function for Autogpt.\"\"\"\n\nclass RandomValues:\n    \"\"\"Random Values plugin for Auto-GPT.\"\"\"\n\n    def __init__(self, plugin):\n        self.plugin = plugin\n\n\n    def random_number(self, min:int|str = 0, max:int|str = 65535, cnt:int|str = 1) -> str:\n        \"\"\"\n        Return a random integer between min and max\n\n        Args:\n            min (int): The minimum value\n            max (int): The maximum value\n            cnt (int): The number of random numbers to return\n\n        Returns:\n            str: a json array with 1 to \"count\" random numbers in the format\n            [\"<random_number>\"]\n        \"\"\"\n\n        # Type-check the arguments\n        try:\n            min = int(min)\n        except ValueError:\n            raise ValueError(\"min must be an integer\")\n        try:\n            max = int(max)\n        except ValueError:\n            raise ValueError(\"max must be an integer\")\n        try:\n            cnt = int(cnt)\n        except ValueError:\n            raise ValueError(\"cnt must be an integer\")\n\n        # Ensure min is less than max\n        if min > max:\n            min, max = max, min\n        \n        # Test ranges\n        if not (1 <= cnt <= 65535):\n            raise ValueError(\"cnt must be between 1 and 65535\")\n        if not (0 <= min <= 65535):\n            raise ValueError(\"min must be between 0 and 65535\")\n        if not (0 <= max <= 65535):\n            raise ValueError(\"max must be between 0 and 65535\")\n        \n        # Make random numbers\n        random_numbers = []\n        if isinstance(min, int) and isinstance(max, int):\n            for _ in range(cnt):\n                random_numbers.append(random.randint(min, max))\n        else:\n            for _ in range(cnt):\n                random_numbers.append(random.uniform(min, max))\n\n        return json.dumps(random_numbers)\n\n    # End of random_number()\n\n\n    def make_uuids(self, cnt:int|str = 1) -> str:\n        \"\"\"\n        Return a UUID\n\n        Args:\n            cnt (int): The number of UUIDs to return\n\n        Returns:\n            str: a json array with 1 to \"count\" UUIDs\n            [\"<UUID>\"]\n        \"\"\"\n\n        # Type-check the arguments\n        if not isinstance(cnt, int):\n            try:\n                cnt = int(cnt)\n            except ValueError:\n                raise ValueError(\"cnt must be an integer\")\n\n        # Make values sane\n        if not (1 <= cnt <= 65535):\n            raise ValueError(\"cnt must be between 1 and 65535\")\n\n        # Do the thing\n        uuids = []\n        for _ in range(cnt):\n            uuids.append(str(uuid.uuid4()))\n\n        return json.dumps(uuids)\n\n    # End of make_uuids()\n\n\n    def generate_string(self, len:int|str = 10, cnt:int|str = 1) -> str:\n        \"\"\"\n        Return a random string\n\n        Args:\n            len (int): The length of the string\n            cnt (int): The number of strings to return\n            \n        Returns:\n            str: a json array with 1 to \"count\" strings of \"length\" length\n            [\"<string>\"]\n        \"\"\"\n\n        # Type-check the arguments\n        if not isinstance(len, int):\n            try:\n                len = int(len)\n            except ValueError:\n                raise ValueError(\"len must be an integer\")\n        if not isinstance(cnt, int):\n            try:\n                cnt = int(cnt)\n            except ValueError:\n                raise ValueError(\"cnt must be an integer\")\n\n        # Range checks\n        if not (1 <= cnt <= 65535):\n            raise ValueError(\"cnt must be between 1 and 65535\")\n        if not (1 <= len <= 65535):\n            raise ValueError(\"len must be between 1 and 65535\")\n\n        # Do the thing\n        strings = []\n        for _ in range(cnt):\n            strings.append(\n                \"\".join(random.choice(string.ascii_letters) for i in range(len))\n            )\n\n        return json.dumps(strings)\n\n\n    def generate_password(self, len:int|str = 16, cnt:int|str = 1) -> str:\n        \"\"\"\n        Return a random password of letters, numbers, and punctuation\n\n        Args:\n            len (int): The length of the password\n            cnt (int): The number of passwords to return\n                    \n        Returns:\n            str: a json array with 1 to \"count\" passwords of \"length\" length\n            [\"<password>\"]\n        \"\"\"\n\n        # Type-check the arguments\n        if not isinstance(len, int):\n            try:\n                len = int(len)\n            except ValueError:\n                raise ValueError(\"len must be an integer\")\n        if not isinstance(cnt, int):\n            try:\n                cnt = int(cnt)\n            except ValueError:\n                raise ValueError(\"cnt must be an integer\")\n\n        # Make values sane\n        if not (6 <= len <= 65535):\n            raise ValueError(\"len must be between 6 and 65535\")\n        if not (1 <= cnt <= 65535):\n            raise ValueError(\"cnt must be between 1 and 65535\")\n\n        # Do the thing\n        passwords = []\n        for _ in range(cnt):\n            passwords.append(\n                \"\".join(\n                    random.choice(string.ascii_letters + string.digits + string.punctuation)\n                    for i in range(len)\n                )\n            )\n\n        return json.dumps(passwords)\n\n\n    def generate_placeholder_text(self, cnt:int|str = 1) -> str:\n        \"\"\"\n        Return a random sentence of lorem ipsum text\n\n        Args:\n            cnt (int): The number of sentences to return\n\n        Returns:\n            str: a json array with 1 to \"sentences\" strings of lorem ipsum\n            [\"<string>\"]\n        \"\"\"\n\n        # Type-check the arguments\n        if not isinstance(cnt, int):\n            try:\n                cnt = int(cnt)\n            except ValueError:\n                raise ValueError(\"cnt must be an integer\")\n\n        # Make values sane\n        if not (1 <= cnt <= 65535):\n            raise ValueError(\"cnt must be between 1 and 65535\")\n\n        # Do the thing\n        strings = []\n        for _ in range(cnt):\n            strings.append(lorem.get_sentence())\n\n        return json.dumps(strings)", ""]}
