{"filename": "manage.py", "chunked_list": ["#!/usr/bin/env python\n\"\"\"Django's command-line utility for administrative tasks.\"\"\"\nimport os\nimport sys\n\n\ndef main():\n    \"\"\"Run administrative tasks.\"\"\"\n    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"sandbox.settings\")\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            \"Couldn't import Django. Are you sure it's installed and \"\n            \"available on your PYTHONPATH environment variable? Did you \"\n            \"forget to activate a virtual environment?\"\n        ) from exc\n    execute_from_command_line(sys.argv)", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/conftest.py", "chunked_list": ["import pytest\n\nfrom django_crispy_tableselect import TableSelectHelper\nfrom sandbox import factories, models, tables\n\n\n@pytest.fixture\ndef book_factory():\n    return factories.BookFactory\n", "\n\n@pytest.fixture\ndef author_factory():\n    return factories.AuthorFactory\n\n\n@pytest.fixture\ndef books_tableselecthelper(book_factory):\n    \"\"\"Return an instance of TableSelectHelper that is operating on a collection of 10 books.\n\n    Accepts an `table_data` argument to pass your own data.\n    All other kwargs are passed as-is to TableSelectHelper.__init__()\n    \"\"\"\n\n    def inner_func(**extra_args):\n        qs = models.Book.objects.none()\n        if \"table_data\" not in extra_args:\n            book_factory.create_batch(10)\n            qs = models.Book.objects.all()\n\n        kwargs = {\n            \"column_name\": \"selected_books\",\n            \"table_class\": tables.BookTable,\n            \"table_data\": extra_args.pop(\"table_data\", qs),\n            \"label\": \"title\",\n            **extra_args,\n        }\n        return TableSelectHelper(**kwargs)\n\n    return inner_func", "def books_tableselecthelper(book_factory):\n    \"\"\"Return an instance of TableSelectHelper that is operating on a collection of 10 books.\n\n    Accepts an `table_data` argument to pass your own data.\n    All other kwargs are passed as-is to TableSelectHelper.__init__()\n    \"\"\"\n\n    def inner_func(**extra_args):\n        qs = models.Book.objects.none()\n        if \"table_data\" not in extra_args:\n            book_factory.create_batch(10)\n            qs = models.Book.objects.all()\n\n        kwargs = {\n            \"column_name\": \"selected_books\",\n            \"table_class\": tables.BookTable,\n            \"table_data\": extra_args.pop(\"table_data\", qs),\n            \"label\": \"title\",\n            **extra_args,\n        }\n        return TableSelectHelper(**kwargs)\n\n    return inner_func", ""]}
{"filename": "tests/functional/test_column_html.py", "chunked_list": ["import django_tables2 as tables\nimport pytest\nfrom bs4 import BeautifulSoup\n\nfrom django_crispy_tableselect.columns import CheckBoxColumn\n\n\nclass MyTable(tables.Table):\n    pass\n", "\n\nclass MockHelper:\n    allow_select_all = True\n\n    def get_accessible_label(self, *args, **kwargs):\n        return \"mock_label\"\n\n    def get_select_all_checkbox_attrs(self, *args, **kwargs):\n        return {}", "\n\n@pytest.mark.parametrize(\"allow_select_all\", (True, False))\ndef test_render_column_header_allow_select_all(allow_select_all):\n    \"\"\"Check that the column header renders a select-all checkbox when needed.\"\"\"\n\n    helper = MockHelper()\n    helper.allow_select_all = allow_select_all\n\n    table = MyTable(\n        data=[],\n        extra_columns=[\n            (\n                \"foo\",\n                CheckBoxColumn(\n                    verbose_name=\"\",\n                    input_name=\"test_input_name\",\n                    helper=helper,\n                    selected_values=[],\n                ),\n            )\n        ],\n    )\n\n    soup = BeautifulSoup(table.columns[\"foo\"].header, \"html.parser\")\n\n    if allow_select_all:\n        assert soup.select('input[type=\"checkbox\"]')\n    else:\n        assert not soup.select('input[type=\"checkbox\"]')", "\n\n@pytest.mark.parametrize(\"allow_select_all\", (True, False))\ndef test_render_column_header_always_has_narrator_element(allow_select_all):\n    \"\"\"Check that the column header renders always renders an invisible element used by the frontend for accessibility purposes.\"\"\"\n\n    helper = MockHelper()\n    helper.allow_select_all = allow_select_all\n\n    table = MyTable(\n        data=[],\n        extra_columns=[\n            (\n                \"foo\",\n                CheckBoxColumn(\n                    verbose_name=\"\",\n                    input_name=\"test_input_name\",\n                    helper=helper,\n                    selected_values=[],\n                ),\n            )\n        ],\n    )\n\n    soup = BeautifulSoup(table.columns[\"foo\"].header, \"html.parser\")\n\n    assert soup.select(\"[data-tableselect-narrator]\")", ""]}
{"filename": "tests/functional/__init__.py", "chunked_list": [""]}
{"filename": "tests/functional/test_views.py", "chunked_list": [""]}
{"filename": "tests/unit/test_layout.py", "chunked_list": ["from uuid import uuid4\n\nimport pytest\n\nfrom django_crispy_tableselect.helpers import TableSelectHelper\nfrom django_crispy_tableselect.layout import TableSelect\nfrom sandbox.tables import BookTable\n\n\nclass MockHelper:\n    allow_select_all = True\n\n    def get_accessible_label(self, *args, **kwargs):\n        return \"mock_label\"\n\n    def get_select_all_checkbox_attrs(self, *args, **kwargs):\n        return {}", "\nclass MockHelper:\n    allow_select_all = True\n\n    def get_accessible_label(self, *args, **kwargs):\n        return \"mock_label\"\n\n    def get_select_all_checkbox_attrs(self, *args, **kwargs):\n        return {}\n", "\n\n@pytest.mark.django_db\ndef test_tableselect_media():\n    \"\"\"Check that the helper media is made available through the layout object.\"\"\"\n    helper = TableSelectHelper(\"foo\", BookTable, [], \"foo\")\n    assert helper.media is not None\n\n    # Create layout object and pass it the helper\n    layout = TableSelect(\"foo\", helper)\n    assert layout.media is not None\n\n    js_path = helper.media._js[0]\n\n    # Path the same static file is available\n    assert js_path in layout.media._js", "\n\ndef test_tableselect_format_value():\n    layout = TableSelect(\"foo\", helper=MockHelper())\n    # Check it removes None values\n    assert layout.format_value(None) == []\n    # Check it keeps empty strings\n    assert layout.format_value(\"\") == [\"\"]\n    # Check it casts primitives to a list with a string\n    assert layout.format_value(0) == [\"0\"]\n\n    # Check it casts a list of primitives to a list of strings\n    assert layout.format_value([1, 2]) == [\"1\", \"2\"]\n\n    # Check it casts objects to their string representation\n    uuid = uuid4()\n    assert layout.format_value([uuid]) == [str(uuid)]", ""]}
{"filename": "tests/unit/__init__.py", "chunked_list": [""]}
{"filename": "tests/unit/test_columns.py", "chunked_list": ["import django_tables2 as tables\n\nfrom django_crispy_tableselect.columns import CheckBoxColumn\n\n\nclass MyTable(tables.Table):\n    pass\n\n\nclass MockHelper:\n    allow_select_all = True\n\n    def get_accessible_label(self, *args, **kwargs):\n        return \"mock_label\"\n\n    def get_select_all_checkbox_attrs(self, *args, **kwargs):\n        return {}", "\nclass MockHelper:\n    allow_select_all = True\n\n    def get_accessible_label(self, *args, **kwargs):\n        return \"mock_label\"\n\n    def get_select_all_checkbox_attrs(self, *args, **kwargs):\n        return {}\n", "\n\ndef test_td_name_attr_present():\n    \"\"\"Check that the correct name attribute is applied\"\"\"\n    data = [{\"id\": 1, \"label\": \"One\"}, {\"id\": 2, \"label\": \"Two\"}]\n    selected_values = [\"1\"]\n\n    table = MyTable(\n        data=data,\n        extra_columns=[\n            (\n                \"foo\",\n                CheckBoxColumn(\n                    verbose_name=\"\",\n                    input_name=\"test_input_name\",\n                    helper=MockHelper(),\n                    selected_values=selected_values,\n                ),\n            )\n        ],\n    )\n\n    bound_column = table.columns[\"foo\"]\n    assert \"td__input\" in bound_column.attrs\n    assert \"name\" in bound_column.attrs[\"td__input\"]\n    assert \"test_input_name\" in bound_column.attrs[\"td__input\"][\"name\"]", "\n\ndef test_custom_td_attrs():\n    \"\"\"Check that custom td__input attrs can be passed to the CheckboxColumn.\"\"\"\n    data = [{\"id\": 1, \"label\": \"One\"}, {\"id\": 2, \"label\": \"Two\"}]\n    selected_values = [\"1\"]\n\n    table = MyTable(\n        data=data,\n        extra_columns=[\n            (\n                \"foo\",\n                CheckBoxColumn(\n                    verbose_name=\"\",\n                    input_name=\"test\",\n                    helper=MockHelper(),\n                    selected_values=selected_values,\n                    attrs={\"td__input\": {\"injected-as-column-attr\": \"\"}},\n                ),\n            )\n        ],\n    )\n\n    bound_column = table.columns[\"foo\"]\n    assert \"td__input\" in bound_column.attrs\n    assert \"injected-as-column-attr\" in bound_column.attrs[\"td__input\"]\n    # name should not have been overridden\n    assert \"name\" in bound_column.attrs[\"td__input\"]", "\n\ndef test_custom_th_attrs():\n    \"\"\"Check that custom th__input attrs can be passed to the CheckboxColumn.\"\"\"\n\n    class MockHelperWithCustomSelectAllAttrs(MockHelper):\n        def get_select_all_checkbox_attrs(self, *args):\n            return {\"injected-by-helper\": \"\"}\n\n    data = [{\"id\": 1, \"label\": \"One\"}, {\"id\": 2, \"label\": \"Two\"}]\n    selected_values = [\"1\"]\n\n    table = MyTable(\n        data=data,\n        extra_columns=[\n            (\n                \"foo\",\n                CheckBoxColumn(\n                    verbose_name=\"\",\n                    input_name=\"test\",\n                    helper=MockHelperWithCustomSelectAllAttrs(),\n                    selected_values=selected_values,\n                    attrs={\"th__input\": {\"injected-as-column-attr\": \"\"}},\n                ),\n            )\n        ],\n    )\n\n    bound_column = table.columns[\"foo\"]\n    assert \"th__input\" in bound_column.attrs\n    assert \"injected-as-column-attr\" in bound_column.attrs[\"th__input\"]\n    assert \"injected-by-helper\" in bound_column.attrs[\"th__input\"]", "\n\ndef test_correct_value_attribute_used():\n    \"\"\"Check that the correct value attribute is applied to the right cell.\"\"\"\n    data = [{\"id\": 1, \"label\": \"One\"}, {\"id\": 2, \"label\": \"Two\"}]\n    selected_values = [\"1\"]\n\n    table = MyTable(\n        data=data,\n        extra_columns=[\n            (\n                \"id\",\n                CheckBoxColumn(\n                    verbose_name=\"\",\n                    input_name=\"test_input_name\",\n                    helper=MockHelper(),\n                    selected_values=selected_values,\n                ),\n            )\n        ],\n    )\n\n    cell_html = table.rows[0].get_cell(\"id\")\n    assert 'value=\"1\"' in cell_html\n\n    cell_html = table.rows[1].get_cell(\"id\")\n    assert 'value=\"2\"' in cell_html", ""]}
{"filename": "tests/unit/test_helper.py", "chunked_list": ["import django_tables2 as tables\nimport pytest\nfrom django.contrib.staticfiles.finders import find\nfrom django.core import exceptions\n\nfrom django_crispy_tableselect import TableSelectHelper\nfrom django_crispy_tableselect.columns import CheckBoxColumn\nfrom sandbox.models import Book\nfrom sandbox.tables import BookTable\n", "from sandbox.tables import BookTable\n\nBOOKS_DICT = [\n    {\"title\": \"Sans Famille\", \"id\": 123, \"author\": \"Hector Malot\"},\n    {\"title\": \"How to Become King\", \"id\": 456, \"author\": \"Jan Terlouw\"},\n]\n\n\ndef test_select_all_defaults_to_false():\n    \"\"\"Check that - when not specified - the ``allow_select_all`` option defaults to False.\"\"\"\n    helper = TableSelectHelper(\"foo\", table_class=BookTable, table_data=[], label=\"foo\")\n    assert not helper.allow_select_all", "def test_select_all_defaults_to_false():\n    \"\"\"Check that - when not specified - the ``allow_select_all`` option defaults to False.\"\"\"\n    helper = TableSelectHelper(\"foo\", table_class=BookTable, table_data=[], label=\"foo\")\n    assert not helper.allow_select_all\n\n\ndef test_helper_always_disables_orderable_option():\n    \"\"\"Check that the helper always returns a table with the orderable option disabled.\"\"\"\n\n    class OrderableTable(BookTable):\n        class Meta:\n            orderable = True\n\n    helper = TableSelectHelper(\n        \"foo\", table_class=OrderableTable, table_data=[], label=\"foo\"\n    )\n\n    table = helper.get_table(\"foo\", [])\n\n    # Table class enabled ordering, but the helper should have forcefully disabled it\n    assert not table.orderable", "\n\n@pytest.mark.django_db\ndef test_accessible_label__callable_str(books_tableselecthelper, book_factory):\n    \"\"\"Check that the default implementation of get_accessible_label includes the value of ``label``.\"\"\"\n    helper = books_tableselecthelper(table_data=BOOKS_DICT, label=str)\n    book = book_factory(title=\"The Witches by Roahl Dahl\")\n    qs = Book.objects.all()\n\n    helper = books_tableselecthelper(table_data=qs)\n    assert str(book) in helper.get_accessible_label(book)", "\n\n@pytest.mark.django_db\ndef test_accessible_label__callable_lambda(books_tableselecthelper, book_factory):\n    \"\"\"Check that the default implementation of get_accessible_label includes the value of ``label``.\"\"\"\n    helper = books_tableselecthelper(table_data=BOOKS_DICT, label=lambda x: x.title)\n    book = book_factory(title=\"The Witches by Roahl Dahl\")\n    qs = Book.objects.all()\n\n    helper = books_tableselecthelper(table_data=qs)\n    assert book.title in helper.get_accessible_label(book)", "\n\ndef test_accessible_label__dictionary(books_tableselecthelper):\n    \"\"\"Check that the default implementation of get_accessible_label includes the value of ``label``.\"\"\"\n    helper = books_tableselecthelper(table_data=BOOKS_DICT, label=\"title\")\n\n    assert BOOKS_DICT[0][\"title\"] in helper.get_accessible_label(BOOKS_DICT[0])\n    assert BOOKS_DICT[1][\"title\"] in helper.get_accessible_label(BOOKS_DICT[1])\n\n", "\n\n@pytest.mark.django_db\ndef test_accessible_label__queryset(books_tableselecthelper, book_factory):\n    \"\"\"Check that the default implementation of get_accessible_label includes the value of .\"\"\"\n    book = book_factory(title=\"The Witches by Roahl Dahl\")\n    qs = Book.objects.all()\n\n    helper = books_tableselecthelper(table_data=qs)\n    assert str(book) in helper.get_accessible_label(book)", "\n\ndef test_table_class_derived_from_table():\n    \"\"\"Check that an exception is raised when the given table class is not actually a table.\"\"\"\n\n    class NotDerivedFromTableClass:\n        pass\n\n    class DerivedFromTableClass(tables.Table):\n        pass\n\n    with pytest.raises(exceptions.ImproperlyConfigured):\n        TableSelectHelper(\n            \"foo\",\n            table_class=NotDerivedFromTableClass,\n            table_data=[],\n            label=\"foo\",\n        )\n\n    TableSelectHelper(\n        \"foo\", table_class=DerivedFromTableClass, table_data=[], label=\"foo\"\n    )", "\n\ndef test_media():\n    \"\"\"Check that the media attribute is present on the helper and that it contains a valid reference to a javascript file.\"\"\"\n    helper = TableSelectHelper(\"foo\", table_class=BookTable, table_data=[], label=\"foo\")\n    assert helper.media\n    assert helper.media._js\n\n    # Check that Django's staticfiles app can find the javascript file\n    assert find(helper.media._js[0])", "\n\n@pytest.mark.django_db\ndef test_checkbox_column(books_tableselecthelper):\n    \"\"\"Check that the checkbox column is added and added at the start of the table.\"\"\"\n    helper = books_tableselecthelper()\n\n    table = helper.get_table(\"foo\", [])\n    # Checkbox column is present\n    assert \"selected_books\" in table.columns\n    bound_column = table.columns[\"selected_books\"]\n    assert isinstance(bound_column.column, CheckBoxColumn)\n    # Checkbox column is first column in sequence\n    assert table.sequence[0] == \"selected_books\"", "\n\ndef test_prepare_table_data__dict(books_tableselecthelper):\n    \"\"\"Check that the helper prepares the table data with values necessary for the checkbox column to function.\"\"\"\n\n    data = [{\"id\": 1, \"title\": \"One\"}, {\"id\": 2, \"title\": \"Two\"}]\n    helper = books_tableselecthelper(\n        column_name=\"foo\", table_data=data, value_field=\"id\", label=\"label\"\n    )\n    prepared_data = helper.prepare_table_data(data)\n\n    assert len(prepared_data) > 0\n    for row in prepared_data:\n        assert \"foo\" in row\n        assert row[\"foo\"] in [1, 2]", "\n\n@pytest.mark.django_db\ndef test_prepare_table_data__queryset(books_tableselecthelper):\n    \"\"\"Check that the helper prepares the table data with values necessary for the checkbox column to function.\"\"\"\n\n    helper = books_tableselecthelper(column_name=\"foo\", value_field=\"id\", label=\"label\")\n    prepared_data = helper.prepare_table_data(helper.table_data)\n\n    assert len(prepared_data) > 0\n    for row in prepared_data:\n        assert hasattr(row, \"foo\")\n        assert getattr(row, \"foo\") in [x.id for x in helper.table_data]", "\n\n@pytest.mark.django_db\ndef test_choices__queryset(books_tableselecthelper):\n    \"\"\"Check that the helper generates the expected choices tuple in the right order when given a QuerySet.\"\"\"\n    helper = books_tableselecthelper()\n\n    assert len(helper.choices) == len(\n        helper.table_data\n    ), \"No all table data presented as choices\"\n\n    choices = helper.choices\n\n    # The choices should follow the same ordering as the table data. Hence index-based iteration.\n    for idx, book in enumerate(helper.table_data):\n        assert choices[idx][0] == book.pk\n        assert choices[idx][1] == book.title", "\n\ndef test_choices__dictionaries(books_tableselecthelper):\n    \"\"\"Check that the helper generates the expected choices tuple in the right order when given a dictionary.\"\"\"\n    helper = books_tableselecthelper(table_data=BOOKS_DICT)\n\n    assert len(helper.choices) == len(\n        helper.table_data\n    ), \"No all table data presented as choices\"\n\n    choices = helper.choices\n\n    # The choices should follow the same ordering as the table data. Hence index-based iteration.\n    for idx, book in enumerate(helper.table_data):\n        assert choices[idx][0] == book[\"id\"]\n        assert choices[idx][1] == book[\"title\"]", "\n\ndef test_get_table_extra_columns_respected(books_tableselecthelper):\n    \"\"\"Check that the get_table method respects the extra_columns argument.\"\"\"\n    helper = books_tableselecthelper(\n        table_data=BOOKS_DICT,\n        table_kwargs={\"extra_columns\": [(\"date_created\", tables.DateColumn())]},\n    )\n    table = helper.get_table(input_name=\"foo\", selected_values=[])\n\n    assert \"date_created\" in table.columns\n    # It is an extra column, not a base one\n    assert \"date_created\" not in table.base_columns", "\n\ndef test_get_table_kwarg_attrs_respected(books_tableselecthelper):\n    \"\"\"Check that the get_table method respects the ``attrs`` key passed to table_kwargs.\"\"\"\n    helper = books_tableselecthelper(\n        table_data=BOOKS_DICT,\n        table_kwargs={\"attrs\": {\"needle\": \"\"}},\n    )\n    table = helper.get_table(input_name=\"foo\", selected_values=[])\n\n    assert \"needle\" in table.attrs", "\n\ndef test_get_table_meta_attrs_respected(books_tableselecthelper):\n    \"\"\"Check that the get_table method respects the attrs Meta attribute.\"\"\"\n\n    class BookTableWithAttrs(BookTable):\n        class Meta:\n            attrs = {\"needle\": \"\"}\n\n    helper = books_tableselecthelper(\n        table_class=BookTableWithAttrs,\n        table_data=BOOKS_DICT,\n    )\n    table = helper.get_table(input_name=\"foo\", selected_values=[])\n\n    assert \"needle\" in table.attrs", "\n\ndef test_get_table__no_rows_selected(books_tableselecthelper):\n    \"\"\"Check that the get_table method returns a table with no checkboxes selected by default.\"\"\"\n    helper = books_tableselecthelper(table_data=BOOKS_DICT)\n\n    table = helper.get_table(input_name=\"foo\", selected_values=[])\n\n    for idx in range(len(helper.table_data)):\n        # Get the html for the cell\n        cell_html = table.rows[idx].get_cell(\"selected_books\")\n        # Should NOT contain checked attribute\n        assert \"checked\" not in cell_html", "\n\ndef test_get_table__single_row_checked(books_tableselecthelper):\n    \"\"\"Check that the get_table method returns a table with the right rows checked when ``selected_values`` is set.\"\"\"\n    helper = books_tableselecthelper(table_data=BOOKS_DICT)\n\n    # Select the first row\n    selected_values = [str(BOOKS_DICT[0][\"id\"])]\n    table = helper.get_table(input_name=\"foo\", selected_values=selected_values)\n\n    cell_html = table.rows[0].get_cell(\"selected_books\")\n    # This is the first row and it should be checked.\n    # Its value is present in selected_values argument.\n    assert \"checked\" in cell_html\n\n    cell_html = table.rows[1].get_cell(\"selected_books\")\n    # This is the second row and it should NOT be checked.\n    # Its value is NOT present in selected_values argument.\n    assert \"checked\" not in cell_html", "\n\ndef test_table_class_meta_sequence_respected():\n    \"\"\"Check that the table class' Meta.sequence property is respected.\"\"\"\n\n    class SequencedBookTable(BookTable):\n        class Meta:\n            sequence = (\"author\", \"...\")\n\n    expected_sequence = (\"selected_books\", \"author\", \"...\")\n    helper = TableSelectHelper(\n        column_name=\"selected_books\",\n        table_class=SequencedBookTable,\n        table_data=[],\n        label=\"title\",\n    )\n\n    assert expected_sequence == helper._construct_sequence()", "\n\ndef test_table_class_kwarg_sequence_respected():\n    \"\"\"Check that the table class' Meta.sequence property is respected.\"\"\"\n    expected_sequence = (\"selected_books\", \"author\", \"...\")\n    helper = TableSelectHelper(\n        column_name=\"selected_books\",\n        table_class=BookTable,\n        table_data=[],\n        label=\"title\",\n        table_kwargs={\"sequence\": (\"author\", \"...\")},\n    )\n\n    assert expected_sequence == helper._construct_sequence()", "\n\n@pytest.mark.parametrize(\n    \"selected_values,expect_checked\", [([], False), ([\"1\"], False), ([\"1\", \"2\"], True)]\n)\ndef test_table_select_all_checkbox_attrs(\n    books_tableselecthelper, selected_values, expect_checked\n):\n    \"\"\"Check that the select_all_checkbox_attrs method only returns 'checked' when all rows are selected.\"\"\"\n\n    data = [{\"id\": 1, \"title\": \"ABC\"}, {\"id\": 2, \"title\": \"DEF\"}]\n    helper = books_tableselecthelper(table_data=data, allow_select_all=False)\n    # Never return attributes when allow_select_all is False\n    helper.get_select_all_checkbox_attrs(selected_values) == {}\n\n    helper = books_tableselecthelper(table_data=data, allow_select_all=True)\n    attrs = helper.get_select_all_checkbox_attrs(selected_values)\n\n    # Checked attribute should only be present when we expect it\n    assert expect_checked == bool(\"checked\" in attrs)", ""]}
{"filename": "sandbox/settings.py", "chunked_list": ["\"\"\"\nDjango settings for sandbox project.\n\nGenerated by 'django-admin startproject' using Django 3.2.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/3.2/topics/settings/\n\nFor the full list of settings and their values, see\nhttps://docs.djangoproject.com/en/3.2/ref/settings/", "For the full list of settings and their values, see\nhttps://docs.djangoproject.com/en/3.2/ref/settings/\n\"\"\"\n\nfrom pathlib import Path\n\n# Build paths inside the project like this: BASE_DIR / 'subdir'.\nBASE_DIR = Path(__file__).resolve().parent.parent\n\n", "\n\n# Quick-start development settings - unsuitable for production\n# See https://docs.djangoproject.com/en/3.2/howto/deployment/checklist/\n\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = \"django-insecure-lbe!z1hp#*_)0z*x!^^sm7&rznn((^2@pko#z6suoq4(1h#zj=\"\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = True", "# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = True\n\nALLOWED_HOSTS = []\n\n\n# Application definition\n\nINSTALLED_APPS = [\n    \"django.contrib.admin\",", "INSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n    \"django_tables2\",\n    \"crispy_forms\",\n    \"crispy_bootstrap5\",", "    \"crispy_forms\",\n    \"crispy_bootstrap5\",\n    \"django_crispy_tableselect\",\n    \"sandbox\",\n]\n\nCRISPY_ALLOWED_TEMPLATE_PACKS = \"bootstrap5\"\nCRISPY_TEMPLATE_PACK = \"bootstrap5\"\n\nMIDDLEWARE = [", "\nMIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",\n    \"django.middleware.csrf.CsrfViewMiddleware\",\n    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n    \"django.contrib.messages.middleware.MessageMiddleware\",\n    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n]", "    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n]\n\nROOT_URLCONF = \"sandbox.urls\"\n\nTEMPLATES = [\n    {\n        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n        \"DIRS\": [BASE_DIR / \"sandbox\" / \"templates\"],\n        \"APP_DIRS\": True,", "        \"DIRS\": [BASE_DIR / \"sandbox\" / \"templates\"],\n        \"APP_DIRS\": True,\n        \"OPTIONS\": {\n            \"context_processors\": [\n                \"django.template.context_processors.debug\",\n                \"django.template.context_processors.request\",\n                \"django.contrib.auth.context_processors.auth\",\n                \"django.contrib.messages.context_processors.messages\",\n            ],\n        },", "            ],\n        },\n    },\n]\n\nWSGI_APPLICATION = \"sandbox.wsgi.application\"\n\n\n# Database\n# https://docs.djangoproject.com/en/3.2/ref/settings/#databases", "# Database\n# https://docs.djangoproject.com/en/3.2/ref/settings/#databases\n\nDATABASES = {\n    \"default\": {\n        \"ENGINE\": \"django.db.backends.sqlite3\",\n        \"NAME\": BASE_DIR / \"db.sqlite3\",\n    }\n}\n", "}\n\n\n# Password validation\n# https://docs.djangoproject.com/en/3.2/ref/settings/#auth-password-validators\n\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.UserAttributeSimilarityValidator\",\n    },", "        \"NAME\": \"django.contrib.auth.password_validation.UserAttributeSimilarityValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.MinimumLengthValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.CommonPasswordValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.NumericPasswordValidator\",", "    {\n        \"NAME\": \"django.contrib.auth.password_validation.NumericPasswordValidator\",\n    },\n]\n\n\n# Internationalization\n# https://docs.djangoproject.com/en/3.2/topics/i18n/\n\nLANGUAGE_CODE = \"en-us\"", "\nLANGUAGE_CODE = \"en-us\"\n\nTIME_ZONE = \"Europe/Amsterdam\"\n\nUSE_I18N = True\n\nUSE_TZ = True\n\n", "\n\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/3.2/howto/static-files/\n\nSTATIC_URL = \"/static/\"\nSTATICFILES_DIRS = [\n    BASE_DIR / \"sandbox\" / \"static\",\n]\n", "]\n\n# Default primary key field type\n# https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field\n\nDEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"\n"]}
{"filename": "sandbox/models.py", "chunked_list": ["from django.db import models\n\n\nclass Task(models.Model):\n    name = models.CharField(\"name\", max_length=50)\n    date_added = models.DateTimeField(\"date added\", auto_now_add=True)\n    date_completed = models.DateTimeField(\n        \"date completed\", null=True, default=None, blank=True\n    )\n\n    def __str__(self):\n        return self.name", "\n\nclass Book(models.Model):\n    title = models.CharField(max_length=192)\n    date_published = models.DateField()\n    datetime_created = models.DateTimeField(auto_now_add=True)\n    author = models.ForeignKey(\n        \"sandbox.Author\", on_delete=models.CASCADE, related_name=\"books\"\n    )\n\n    def __str__(self) -> str:\n        return self.title", "\nclass Author(models.Model):\n    name = models.CharField(max_length=192)\n\n    def __str__(self) -> str:\n        return self.name\n"]}
{"filename": "sandbox/forms.py", "chunked_list": ["import datetime\n\nfrom django import forms\nfrom django.utils import timezone\nfrom django.core.exceptions import ValidationError\n\nfrom crispy_forms.helper import FormHelper\nfrom crispy_forms.layout import Layout, Field, Submit\nfrom django_crispy_tableselect import TableSelect, TableSelectHelper, CrispyMediaMixin\n", "from django_crispy_tableselect import TableSelect, TableSelectHelper, CrispyMediaMixin\n\n\nfrom .tables import TaskTable\n\n\nclass BulkCompleteTaskForm(CrispyMediaMixin, forms.Form):\n    date_completed = forms.DateField(\n        required=True,\n        initial=timezone.now(),\n        help_text=\"Must be a date in the future\",\n        widget=forms.widgets.SelectDateWidget()\n    )\n    select_tasks = forms.fields.MultipleChoiceField(required=True)\n\n    def __init__(self, tasks, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        table_helper = TableSelectHelper(\n            column_name=\"select_tasks\",\n            table_class=TaskTable,\n            table_data=tasks,\n            allow_select_all=True,\n            label=\"name\"\n        )\n        self.fields[\"select_tasks\"].choices = table_helper.choices\n\n        self.helper = FormHelper()\n        self.helper.form_tag = False\n        self.helper.layout = Layout(\n            Field(\"date_completed\"),\n            TableSelect(\"select_tasks\", helper=table_helper),\n            Submit(\"submit\", \"Submit\")\n        )\n\n    def clean_date_completed(self):\n        date_completed = self.cleaned_data.get(\"date_completed\")\n\n        if date_completed < datetime.date.today():\n            raise ValidationError(\"Date must be in the future\")\n        return date_completed", ""]}
{"filename": "sandbox/factories.py", "chunked_list": ["import factory\n\nfrom . import models\n\n\nclass AuthorFactory(factory.django.DjangoModelFactory):\n    class Meta:\n        model = models.Author\n\n    name = factory.Faker(\"name\")", "\n\nclass BookFactory(factory.django.DjangoModelFactory):\n    class Meta:\n        model = models.Book\n\n    title = factory.Faker(\"sentence\", nb_words=4)\n    date_published = factory.Faker(\"date_this_century\")\n    author = factory.SubFactory(AuthorFactory)\n", ""]}
{"filename": "sandbox/urls.py", "chunked_list": ["from django.conf import settings\nfrom django.conf.urls.static import static\nfrom django.contrib import admin\nfrom django.urls import include, path\nfrom django.views.generic import TemplateView\n\nfrom sandbox import views\n\ntasks_urls = ([path(\"table/\", views.TaskTableView.as_view(), name=\"table\"), path(\"bulk/\", views.BulkCompleteTaskView.as_view(), name=\"bulk-complete\")], \"tasks\")\n", "tasks_urls = ([path(\"table/\", views.TaskTableView.as_view(), name=\"table\"), path(\"bulk/\", views.BulkCompleteTaskView.as_view(), name=\"bulk-complete\")], \"tasks\")\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"tasks/\", include(tasks_urls, namespace=\"tasks\")),\n    # path(\"books/\", include(books_urls, namespace=\"books\")),\n    path(\"\", TemplateView.as_view(template_name=\"index.html\"), name=\"index\"),\n] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)\n", ""]}
{"filename": "sandbox/views.py", "chunked_list": ["from django_tables2 import SingleTableView\nfrom django.urls import reverse_lazy\nfrom django.views.generic.list import MultipleObjectMixin\nfrom django.http import HttpResponseRedirect\n\nfrom formtools.wizard.views import SessionWizardView\nfrom sandbox.models import Task\nfrom sandbox.tables import TaskTable\nfrom sandbox.forms import BulkCompleteTaskForm\n", "from sandbox.forms import BulkCompleteTaskForm\n\n\nclass TaskTableView(SingleTableView):\n    model = Task\n    table_class = TaskTable\n    template_name = \"task_table_page.html\"\n\n\nclass BulkCompleteTaskView(MultipleObjectMixin, SessionWizardView):\n    form_list = [\n        (\"tasks\", BulkCompleteTaskForm)\n    ]\n    model = Task\n    template_name = \"task_bulk_complete_page.html\"\n    success_url = reverse_lazy(\"tasks:bulk-complete\")\n\n    def get_form_kwargs(self, step=None):\n        kwargs = super().get_form_kwargs()\n        kwargs[\"tasks\"] = self.get_queryset()\n\n        return kwargs\n\n    def done(self, form_list, **kwargs):\n        data = self.get_all_cleaned_data()\n        task_ids = data.get('select_tasks')\n        date_completed = data.get('date_completed')\n\n        Task.objects.filter(id__in=task_ids).update(date_completed=date_completed)\n\n        return HttpResponseRedirect(reverse_lazy(\"tasks:bulk-complete\"))\n       \n    def dispatch(self, request, *args, **kwargs):\n        self.object_list = self.get_queryset()\n        return super().dispatch(request, *args, **kwargs)", "\nclass BulkCompleteTaskView(MultipleObjectMixin, SessionWizardView):\n    form_list = [\n        (\"tasks\", BulkCompleteTaskForm)\n    ]\n    model = Task\n    template_name = \"task_bulk_complete_page.html\"\n    success_url = reverse_lazy(\"tasks:bulk-complete\")\n\n    def get_form_kwargs(self, step=None):\n        kwargs = super().get_form_kwargs()\n        kwargs[\"tasks\"] = self.get_queryset()\n\n        return kwargs\n\n    def done(self, form_list, **kwargs):\n        data = self.get_all_cleaned_data()\n        task_ids = data.get('select_tasks')\n        date_completed = data.get('date_completed')\n\n        Task.objects.filter(id__in=task_ids).update(date_completed=date_completed)\n\n        return HttpResponseRedirect(reverse_lazy(\"tasks:bulk-complete\"))\n       \n    def dispatch(self, request, *args, **kwargs):\n        self.object_list = self.get_queryset()\n        return super().dispatch(request, *args, **kwargs)", ""]}
{"filename": "sandbox/__init__.py", "chunked_list": [""]}
{"filename": "sandbox/tables.py", "chunked_list": ["import django_tables2 as tables\nfrom sandbox.models import Task, Book\n\n\nclass TaskTable(tables.Table):\n    date_added = tables.DateColumn(format=\"M d, Y\")\n    date_completed = tables.DateColumn(format=\"M d, Y\")\n\n    class Meta:\n        model = Task\n        fields = (\n            \"name\",\n            \"date_added\",\n        )\n        attrs = {\n            \"class\": \"my-table\",\n        }", "\n\nclass BookTable(tables.Table):\n    class Meta:\n        model = Book\n        fields = (\"title\", \"author\", \"date_published\")\n"]}
{"filename": "sandbox/asgi.py", "chunked_list": ["\"\"\"\nASGI config for sandbox project.\n\nIt exposes the ASGI callable as a module-level variable named ``application``.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/3.2/howto/deployment/asgi/\n\"\"\"\n\nimport os", "\nimport os\n\nfrom django.core.asgi import get_asgi_application\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"settings\")\n\napplication = get_asgi_application()\n", ""]}
{"filename": "sandbox/admin.py", "chunked_list": ["from django.contrib import admin\nfrom sandbox.models import Task\n\n\nclass TaskAdmin(admin.ModelAdmin):\n    list_display = (\"name\", \"date_added\")\n\n\nadmin.site.register(Task, TaskAdmin)\n", "admin.site.register(Task, TaskAdmin)\n"]}
{"filename": "sandbox/wsgi.py", "chunked_list": ["\"\"\"\nWSGI config for sandbox project.\n\nIt exposes the WSGI callable as a module-level variable named ``application``.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/3.2/howto/deployment/wsgi/\n\"\"\"\n\nimport os", "\nimport os\n\nfrom django.core.wsgi import get_wsgi_application\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"sandbox.settings\")\n\napplication = get_wsgi_application()\n", ""]}
{"filename": "sandbox/migrations/0001_initial.py", "chunked_list": ["# Generated by Django 4.2.1 on 2023-06-05 12:28\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n    initial = True\n\n    dependencies = []\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Author\",\n            fields=[\n                (\n                    \"id\",\n                    models.BigAutoField(\n                        auto_created=True,\n                        primary_key=True,\n                        serialize=False,\n                        verbose_name=\"ID\",\n                    ),\n                ),\n                (\"name\", models.CharField(max_length=192)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Task\",\n            fields=[\n                (\n                    \"id\",\n                    models.BigAutoField(\n                        auto_created=True,\n                        primary_key=True,\n                        serialize=False,\n                        verbose_name=\"ID\",\n                    ),\n                ),\n                (\"name\", models.CharField(max_length=50, verbose_name=\"name\")),\n                (\n                    \"date_added\",\n                    models.DateTimeField(auto_now_add=True, verbose_name=\"date added\"),\n                ),\n                (\n                    \"date_completed\",\n                    models.DateTimeField(\n                        blank=True,\n                        default=None,\n                        null=True,\n                        verbose_name=\"date completed\",\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Book\",\n            fields=[\n                (\n                    \"id\",\n                    models.BigAutoField(\n                        auto_created=True,\n                        primary_key=True,\n                        serialize=False,\n                        verbose_name=\"ID\",\n                    ),\n                ),\n                (\"title\", models.CharField(max_length=192)),\n                (\"date_published\", models.DateField()),\n                (\"datetime_created\", models.DateTimeField(auto_now_add=True)),\n                (\n                    \"author\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"books\",\n                        to=\"sandbox.author\",\n                    ),\n                ),\n            ],\n        ),\n    ]", ""]}
{"filename": "sandbox/migrations/__init__.py", "chunked_list": [""]}
{"filename": "src/django_crispy_tableselect/columns.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom django.template.loader import get_template\nfrom django_tables2 import CheckBoxColumn as BaseCheckBoxColumn\n\nif TYPE_CHECKING:\n    from .helpers import TableSelectHelper\n", "\n__all__ = [\n    \"CheckBoxColumn\",\n]\n\n\nclass CheckBoxColumn(BaseCheckBoxColumn):\n    header_template = \"django_crispy_tableselect/checkbox_column_header.html\"\n\n    def __init__(\n        self,\n        helper: TableSelectHelper,\n        attrs={},\n        input_name=\"\",\n        selected_values=[],\n        **extra,\n    ):\n        self.helper = helper\n        self.input_name = input_name\n        self.selected_values = selected_values\n\n        update_attrs = attrs.copy()\n\n        td_input_attrs = attrs.get(\"td__input\", {})\n        th_input_attrs = attrs.get(\"th__input\", {})\n        update_attrs[\"td__input\"] = {\n            \"name\": input_name,\n            \"aria-label\": lambda **kwargs: helper.get_accessible_label(\n                kwargs.get(\"record\")\n            ),\n            **td_input_attrs,\n        }\n        update_attrs[\"th__input\"] = {\n            **self.helper.get_select_all_checkbox_attrs(selected_values),\n            **th_input_attrs,\n        }\n\n        super().__init__(update_attrs, **extra)\n\n    def is_checked(self, value, record):\n        return str(value) in self.selected_values\n\n    @property\n    def header(self):\n        default = {\"type\": \"checkbox\"}\n        general = self.attrs.get(\"input\")\n        specific = self.attrs.get(\"th__input\")\n        attrs = dict(default, **(specific or general or {}))\n\n        template = get_template(self.header_template)\n        return template.render(\n            {\"attrs\": attrs, \"enable_select_all\": self.helper.allow_select_all}\n        )", ""]}
{"filename": "src/django_crispy_tableselect/mixins.py", "chunked_list": ["class CrispyMediaMixin:\n    \"\"\"Mixin that gathers Media objects from Crispy layout objects and includes them in ``self.media``.\"\"\"\n\n    @property\n    def media(self):\n        media = super().media\n        # FIXME: gather media from nested layout objects too!\n        for field in self.helper.layout.fields:\n            if hasattr(field, \"media\"):\n                media += field.media\n        return media", ""]}
{"filename": "src/django_crispy_tableselect/__init__.py", "chunked_list": ["from .helpers import TableSelectHelper\nfrom .layout import TableSelect\nfrom .mixins import CrispyMediaMixin\n\n__all__ = (\"TableSelect\", \"TableSelectHelper\", \"CrispyMediaMixin\")\n"]}
{"filename": "src/django_crispy_tableselect/layout.py", "chunked_list": ["from crispy_forms import layout\nfrom crispy_forms.utils import TEMPLATE_PACK\nfrom django.template.loader import render_to_string\n\n\nclass TableSelect(layout.TemplateNameMixin):\n    template = \"django_crispy_tableselect/table_select.html\"\n\n    def __init__(\n        self,\n        name,\n        helper,\n        **kwargs,\n    ):\n        self.name = name\n        self.helper = helper\n\n    @property\n    def media(self):\n        # Make the helper media easily available to the form\n        return self.helper.media\n\n    def format_value(self, value):\n        \"\"\"Return selected values as a list.\"\"\"\n        if value is None:\n            return []\n        if not isinstance(value, (tuple, list)):\n            value = [value]\n        return [str(v) if v is not None else \"\" for v in value]\n\n    def render(self, form, context, template_pack=TEMPLATE_PACK, **kwargs):\n        template = self.get_template_name(template_pack)\n        bound_field = form[self.name]\n\n        selected_values = self.format_value(bound_field.value())\n\n        html_name = bound_field.html_name\n        context.update(\n            {\n                \"table\": self.helper.get_table(\n                    input_name=html_name, selected_values=selected_values\n                )\n            }\n        )\n        return render_to_string(template, context.flatten())", ""]}
{"filename": "src/django_crispy_tableselect/helpers.py", "chunked_list": ["from django.core.exceptions import ImproperlyConfigured\nfrom django.db import models\nfrom django.forms.widgets import Media\nfrom django.utils.translation import gettext_lazy as _\nfrom django_tables2 import Table\n\nfrom .columns import CheckBoxColumn\n\n\nclass TableSelectHelper:\n    \"\"\"Helper that houses various features related to TableSelect.\"\"\"\n\n    # Path to javascript static file\n    js_path = \"django_crispy_tableselect/tableselect.js\"\n\n    def __init__(\n        self,\n        column_name,\n        table_class,\n        table_data,\n        label,\n        value_field=\"id\",\n        *,\n        table_kwargs={},\n        allow_select_all=False,\n    ):\n        \"\"\"\n        Arguments:\n        - column_name: str -- The name of the form field. The checkbox column is added to the table using this name.\n        - table_class: Table -- Your table class, must inherit from ``django_tables2.Table``.\n        - table_data: QuerySet|Iterable -- Data to use to populate the table. Can be a django QuerySet or an iterable of objects/dictionaries.\n        - label: str | callable -- Field (or key in case of dict) to use from table data record to label the checkbox. If callable, it receives the object / dict and should return a string to label to checkbox with.\n        - value_field: str -- Field (or key in case of dict) to use from table data record as checkbox value. Defaults to 'id'.\n\n        Keyword arguments:\n        - table_kwargs: dict -- Any extra keyword arguments to instantiate the table class with.\n        - allow_select_all: bool -- Whether or not to show a 'select all' checkbox in the column header. Defaults to False.\n        \"\"\"\n        if not issubclass(table_class, Table):\n            msg = f\"{repr(table_class)} must be a subclass of {repr(Table)}\"\n            raise ImproperlyConfigured(msg)\n\n        self.column_name = column_name\n        self.table_class = table_class\n        self.table_data = table_data\n        self.label = label\n        self.value_field = value_field\n        self.table_kwargs = table_kwargs\n        self.allow_select_all = allow_select_all\n\n    @property\n    def choices(self):\n        if callable(self.label):\n            return [(x[self.value_field], self.label(x)) for x in self.table_data]\n\n        if (\n            isinstance(self.table_data, models.query.QuerySet)\n            and type(self.label) == str\n        ):\n            return self.table_data.values_list(self.value_field, self.label)\n\n        return [(x[self.value_field], x[self.label]) for x in self.table_data]\n\n    def get_select_all_checkbox_attrs(self, selected_values):\n        \"\"\"Attributes to add to the select all checkbox.\"\"\"\n        if not self.allow_select_all:\n            return {}\n\n        attrs = {}\n\n        if selected_values:\n            if len(selected_values) >= len(self.table_data):\n                # All rows are selected, checkbox should display as checked\n                attrs[\"checked\"] = \"\"\n        return attrs\n\n    def get_accessible_label(self, record):\n        \"\"\"Return the accessible label to associate with the form checkbox.\n\n        Uses the value specified by ``label`` as key for dictionaries or as attribute for objects.\n        This benefits users of assistive technology like screenreaders.\"\"\"\n\n        if isinstance(record, dict):\n            obj_name = record.get(self.label)\n        else:\n            obj_name = getattr(record, self.label)\n\n        return _(\"Select %(obj_name)s\") % {\"obj_name\": obj_name}\n\n    def get_value(self, record):\n        \"\"\"Value to use for the form checkbox.\"\"\"\n\n        if isinstance(record, dict):\n            return record.get(self.value_field)\n\n        return vars(record).get(self.value_field)\n\n    def prepare_table_data(self, table_data):\n        \"\"\"Prepare table data with values necessary for the select checkbox.\"\"\"\n\n        for row in table_data:\n            key = self.column_name\n            value = self.get_value(row)\n\n            if isinstance(row, dict):\n                row[key] = value\n            else:\n                setattr(row, key, value)\n\n        return table_data\n\n    def _construct_sequence(self):\n        \"\"\"Reconstructs the ``sequence`` argument for the table with the checkbox column in front.\"\"\"\n        table_kwargs = self.table_kwargs.copy()\n        kwarg_sequence = table_kwargs.pop(\"sequence\", ())\n        meta_sequence = ()\n        if hasattr(self.table_class, \"Meta\") and hasattr(\n            self.table_class.Meta, \"sequence\"\n        ):\n            meta_sequence = getattr(self.table_class.Meta, \"sequence\")\n\n        original_sequence = kwarg_sequence or meta_sequence\n\n        # Reconstruct the sequence with the checkbox column at the start\n        return (self.column_name, *original_sequence)\n\n    def get_attrs(self, kwarg_attrs):\n        \"\"\"Get ``attrs`` keyword argument to pass to the table class.\"\"\"\n        meta_attrs = ()\n        if hasattr(self.table_class, \"Meta\") and hasattr(\n            self.table_class.Meta, \"attrs\"\n        ):\n            meta_attrs = getattr(self.table_class.Meta, \"attrs\")\n\n        original_attrs = kwarg_attrs or meta_attrs\n        attrs = {\"data-tableselect\": \"\"}\n        attrs.update(original_attrs)\n\n        return attrs\n\n    def get_table(self, input_name, selected_values):\n        \"\"\"Return instance of the table class with checkbox column.\"\"\"\n        table_kwargs = self.table_kwargs.copy()\n        extra_columns = [\n            (\n                self.column_name,\n                CheckBoxColumn(\n                    verbose_name=\"\",\n                    input_name=input_name,\n                    helper=self,\n                    selected_values=selected_values,\n                ),\n            )\n        ]\n        extra_columns.extend(table_kwargs.pop(\"extra_columns\", []))\n        sequence = self._construct_sequence()\n        attrs = self.get_attrs(table_kwargs.pop(\"attrs\", {}))\n\n        return self.table_class(\n            # This table may never be ordered.\n            # We cannot guarantee ordering to work properly while still remembering what checkboxes are checked.\n            orderable=False,\n            data=self.prepare_table_data(self.table_data),\n            sequence=sequence,\n            extra_columns=extra_columns,\n            attrs=attrs,\n            **table_kwargs,\n        )\n\n    def _get_media(self):\n        return Media(js=[self.js_path])\n\n    media = property(_get_media)", "\nclass TableSelectHelper:\n    \"\"\"Helper that houses various features related to TableSelect.\"\"\"\n\n    # Path to javascript static file\n    js_path = \"django_crispy_tableselect/tableselect.js\"\n\n    def __init__(\n        self,\n        column_name,\n        table_class,\n        table_data,\n        label,\n        value_field=\"id\",\n        *,\n        table_kwargs={},\n        allow_select_all=False,\n    ):\n        \"\"\"\n        Arguments:\n        - column_name: str -- The name of the form field. The checkbox column is added to the table using this name.\n        - table_class: Table -- Your table class, must inherit from ``django_tables2.Table``.\n        - table_data: QuerySet|Iterable -- Data to use to populate the table. Can be a django QuerySet or an iterable of objects/dictionaries.\n        - label: str | callable -- Field (or key in case of dict) to use from table data record to label the checkbox. If callable, it receives the object / dict and should return a string to label to checkbox with.\n        - value_field: str -- Field (or key in case of dict) to use from table data record as checkbox value. Defaults to 'id'.\n\n        Keyword arguments:\n        - table_kwargs: dict -- Any extra keyword arguments to instantiate the table class with.\n        - allow_select_all: bool -- Whether or not to show a 'select all' checkbox in the column header. Defaults to False.\n        \"\"\"\n        if not issubclass(table_class, Table):\n            msg = f\"{repr(table_class)} must be a subclass of {repr(Table)}\"\n            raise ImproperlyConfigured(msg)\n\n        self.column_name = column_name\n        self.table_class = table_class\n        self.table_data = table_data\n        self.label = label\n        self.value_field = value_field\n        self.table_kwargs = table_kwargs\n        self.allow_select_all = allow_select_all\n\n    @property\n    def choices(self):\n        if callable(self.label):\n            return [(x[self.value_field], self.label(x)) for x in self.table_data]\n\n        if (\n            isinstance(self.table_data, models.query.QuerySet)\n            and type(self.label) == str\n        ):\n            return self.table_data.values_list(self.value_field, self.label)\n\n        return [(x[self.value_field], x[self.label]) for x in self.table_data]\n\n    def get_select_all_checkbox_attrs(self, selected_values):\n        \"\"\"Attributes to add to the select all checkbox.\"\"\"\n        if not self.allow_select_all:\n            return {}\n\n        attrs = {}\n\n        if selected_values:\n            if len(selected_values) >= len(self.table_data):\n                # All rows are selected, checkbox should display as checked\n                attrs[\"checked\"] = \"\"\n        return attrs\n\n    def get_accessible_label(self, record):\n        \"\"\"Return the accessible label to associate with the form checkbox.\n\n        Uses the value specified by ``label`` as key for dictionaries or as attribute for objects.\n        This benefits users of assistive technology like screenreaders.\"\"\"\n\n        if isinstance(record, dict):\n            obj_name = record.get(self.label)\n        else:\n            obj_name = getattr(record, self.label)\n\n        return _(\"Select %(obj_name)s\") % {\"obj_name\": obj_name}\n\n    def get_value(self, record):\n        \"\"\"Value to use for the form checkbox.\"\"\"\n\n        if isinstance(record, dict):\n            return record.get(self.value_field)\n\n        return vars(record).get(self.value_field)\n\n    def prepare_table_data(self, table_data):\n        \"\"\"Prepare table data with values necessary for the select checkbox.\"\"\"\n\n        for row in table_data:\n            key = self.column_name\n            value = self.get_value(row)\n\n            if isinstance(row, dict):\n                row[key] = value\n            else:\n                setattr(row, key, value)\n\n        return table_data\n\n    def _construct_sequence(self):\n        \"\"\"Reconstructs the ``sequence`` argument for the table with the checkbox column in front.\"\"\"\n        table_kwargs = self.table_kwargs.copy()\n        kwarg_sequence = table_kwargs.pop(\"sequence\", ())\n        meta_sequence = ()\n        if hasattr(self.table_class, \"Meta\") and hasattr(\n            self.table_class.Meta, \"sequence\"\n        ):\n            meta_sequence = getattr(self.table_class.Meta, \"sequence\")\n\n        original_sequence = kwarg_sequence or meta_sequence\n\n        # Reconstruct the sequence with the checkbox column at the start\n        return (self.column_name, *original_sequence)\n\n    def get_attrs(self, kwarg_attrs):\n        \"\"\"Get ``attrs`` keyword argument to pass to the table class.\"\"\"\n        meta_attrs = ()\n        if hasattr(self.table_class, \"Meta\") and hasattr(\n            self.table_class.Meta, \"attrs\"\n        ):\n            meta_attrs = getattr(self.table_class.Meta, \"attrs\")\n\n        original_attrs = kwarg_attrs or meta_attrs\n        attrs = {\"data-tableselect\": \"\"}\n        attrs.update(original_attrs)\n\n        return attrs\n\n    def get_table(self, input_name, selected_values):\n        \"\"\"Return instance of the table class with checkbox column.\"\"\"\n        table_kwargs = self.table_kwargs.copy()\n        extra_columns = [\n            (\n                self.column_name,\n                CheckBoxColumn(\n                    verbose_name=\"\",\n                    input_name=input_name,\n                    helper=self,\n                    selected_values=selected_values,\n                ),\n            )\n        ]\n        extra_columns.extend(table_kwargs.pop(\"extra_columns\", []))\n        sequence = self._construct_sequence()\n        attrs = self.get_attrs(table_kwargs.pop(\"attrs\", {}))\n\n        return self.table_class(\n            # This table may never be ordered.\n            # We cannot guarantee ordering to work properly while still remembering what checkboxes are checked.\n            orderable=False,\n            data=self.prepare_table_data(self.table_data),\n            sequence=sequence,\n            extra_columns=extra_columns,\n            attrs=attrs,\n            **table_kwargs,\n        )\n\n    def _get_media(self):\n        return Media(js=[self.js_path])\n\n    media = property(_get_media)", ""]}
