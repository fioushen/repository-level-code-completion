{"filename": "conftest.py", "chunked_list": ["from __future__ import annotations\n\nimport logging\nimport os\nimport platform\nimport tempfile\n\nimport pytest\n\nfrom appsignal.agent import agent", "\nfrom appsignal.agent import agent\n\n\n@pytest.fixture(scope=\"function\", autouse=True)\ndef reset_environment_between_tests():\n    old_environ = dict(os.environ)\n\n    yield\n\n    os.environ.clear()\n    os.environ.update(old_environ)", "\n\n@pytest.fixture(scope=\"function\", autouse=True)\ndef remove_logging_handlers_after_tests():\n    yield\n\n    logger = logging.getLogger(\"appsignal\")\n    for handler in logger.handlers:\n        logger.removeHandler(handler)\n", "\n\n@pytest.fixture(scope=\"function\", autouse=True)\ndef reset_agent_active_state():\n    agent.active = False\n\n\n@pytest.fixture(scope=\"function\", autouse=True)\ndef stop_agent():\n    tmp_path = \"/tmp\" if platform.system() == \"Darwin\" else tempfile.gettempdir()\n    working_dir = os.path.join(tmp_path, \"appsignal\")\n    if os.path.isdir(working_dir):\n        os.system(f\"rm -rf {working_dir}\")\n\n    yield", "def stop_agent():\n    tmp_path = \"/tmp\" if platform.system() == \"Darwin\" else tempfile.gettempdir()\n    working_dir = os.path.join(tmp_path, \"appsignal\")\n    if os.path.isdir(working_dir):\n        os.system(f\"rm -rf {working_dir}\")\n\n    yield\n"]}
{"filename": "tests/test_push_api_key_validator.py", "chunked_list": ["from unittest.mock import MagicMock\n\nfrom appsignal.config import Config, Options\nfrom appsignal.push_api_key_validator import PushApiKeyValidator\n\n\ndef test_push_api_key_validator_valid(mocker):\n    mock_request = mocker.patch(\"requests.post\")\n    mock_request.return_value = MagicMock(status_code=200)\n\n    assert (\n        PushApiKeyValidator.validate(Config(Options(push_api_key=\"valid\"))) == \"valid\"\n    )", "\n\ndef test_push_api_key_validator_invalid(mocker):\n    mock_request = mocker.patch(\"requests.post\")\n    mock_request.return_value = MagicMock(status_code=401)\n\n    assert (\n        PushApiKeyValidator.validate(Config(Options(push_api_key=\"invalid\")))\n        == \"invalid\"\n    )", "\n\ndef test_push_api_key_validator_error(mocker):\n    mock_request = mocker.patch(\"requests.post\")\n    mock_request.return_value = MagicMock(status_code=500)\n\n    assert PushApiKeyValidator.validate(Config(Options(push_api_key=\"500\"))) == \"500\"\n"]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/test_config.py", "chunked_list": ["from __future__ import annotations\n\nimport os\n\nfrom appsignal.__about__ import __version__\nfrom appsignal.config import Config, Options\n\n\ndef test_option():\n    config = Config(Options(active=False, enable_host_metrics=True))\n\n    assert config.option(\"active\") is False\n    assert config.option(\"enable_host_metrics\") is True\n    assert config.option(\"nonsense\") is None", "def test_option():\n    config = Config(Options(active=False, enable_host_metrics=True))\n\n    assert config.option(\"active\") is False\n    assert config.option(\"enable_host_metrics\") is True\n    assert config.option(\"nonsense\") is None\n\n\ndef test_source_order():\n    # Read only from default\n    config = Config()\n    assert config.sources[\"default\"][\"enable_host_metrics\"] is True\n    assert config.option(\"enable_host_metrics\") is True\n\n    # Read from environment\n    os.environ[\"APPSIGNAL_ENABLE_HOST_METRICS\"] = \"false\"\n    config = Config()\n    assert config.sources[\"default\"][\"enable_host_metrics\"] is True\n    assert config.sources[\"environment\"][\"enable_host_metrics\"] is False\n    assert config.option(\"enable_host_metrics\") is False\n\n    # Read from config initializer last\n    os.environ[\"APPSIGNAL_HOSTNAME\"] = \"env name\"\n    config = Config(Options(hostname=\"initial name\"))\n    assert config.sources[\"environment\"][\"hostname\"] == \"env name\"\n    assert config.sources[\"initial\"][\"hostname\"] == \"initial name\"\n    assert config.option(\"hostname\") == \"initial name\"", "def test_source_order():\n    # Read only from default\n    config = Config()\n    assert config.sources[\"default\"][\"enable_host_metrics\"] is True\n    assert config.option(\"enable_host_metrics\") is True\n\n    # Read from environment\n    os.environ[\"APPSIGNAL_ENABLE_HOST_METRICS\"] = \"false\"\n    config = Config()\n    assert config.sources[\"default\"][\"enable_host_metrics\"] is True\n    assert config.sources[\"environment\"][\"enable_host_metrics\"] is False\n    assert config.option(\"enable_host_metrics\") is False\n\n    # Read from config initializer last\n    os.environ[\"APPSIGNAL_HOSTNAME\"] = \"env name\"\n    config = Config(Options(hostname=\"initial name\"))\n    assert config.sources[\"environment\"][\"hostname\"] == \"env name\"\n    assert config.sources[\"initial\"][\"hostname\"] == \"initial name\"\n    assert config.option(\"hostname\") == \"initial name\"", "\n\ndef test_system_source():\n    config = Config()\n\n    assert list(config.sources[\"system\"].keys()) == [\"app_path\"]\n    assert \"app_path\" in list(config.options.keys())\n\n\ndef test_environ_source():\n    os.environ[\"APPSIGNAL_ACTIVE\"] = \"true\"\n    os.environ[\"APPSIGNAL_APP_ENV\"] = \"development\"\n    os.environ[\"APPSIGNAL_APP_NAME\"] = \"MyApp\"\n    os.environ[\"APPSIGNAL_BIND_ADDRESS\"] = \"0.0.0.0\"\n    os.environ[\"APPSIGNAL_CA_FILE_PATH\"] = \"/path/to/cacert.pem\"\n    os.environ[\"APPSIGNAL_DNS_SERVERS\"] = \"8.8.8.8,8.8.4.4\"\n    os.environ[\"APPSIGNAL_ENABLE_HOST_METRICS\"] = \"true\"\n    os.environ[\"APPSIGNAL_ENABLE_NGINX_METRICS\"] = \"false\"\n    os.environ[\"APPSIGNAL_ENABLE_STATSD\"] = \"false\"\n    os.environ[\"APPSIGNAL_FILES_WORLD_ACCESSIBLE\"] = \"true\"\n    os.environ[\"APPSIGNAL_FILTER_PARAMETERS\"] = \"password,secret\"\n    os.environ[\"APPSIGNAL_FILTER_SESSION_DATA\"] = \"key1,key2\"\n    os.environ[\"APPSIGNAL_HOSTNAME\"] = \"Test hostname\"\n    os.environ[\"APPSIGNAL_HTTP_PROXY\"] = \"http://proxy.local:9999\"\n    os.environ[\"APPSIGNAL_IGNORE_ACTIONS\"] = \"action1,action2\"\n    os.environ[\"APPSIGNAL_IGNORE_ERRORS\"] = \"error1,error2\"\n    os.environ[\"APPSIGNAL_IGNORE_NAMESPACES\"] = \"namespace1,namespace2\"\n    os.environ[\"APPSIGNAL_LOG_LEVEL\"] = \"trace\"\n    os.environ[\"APPSIGNAL_LOG_PATH\"] = \"/path/to/log_dir\"\n    os.environ[\"APPSIGNAL_PUSH_API_KEY\"] = \"some-api-key\"\n    os.environ[\"APPSIGNAL_PUSH_API_ENDPOINT\"] = \"https://push.appsignal.com\"\n    os.environ[\"APPSIGNAL_REQUEST_HEADERS\"] = \"accept,x-custom-header\"\n    os.environ[\"APPSIGNAL_RUNNING_IN_CONTAINER\"] = \"true\"\n    os.environ[\"APPSIGNAL_SEND_ENVIRONMENT_METADATA\"] = \"true\"\n    os.environ[\"APPSIGNAL_SEND_PARAMS\"] = \"true\"\n    os.environ[\"APPSIGNAL_SEND_SESSION_DATA\"] = \"true\"\n    os.environ[\"APPSIGNAL_WORKING_DIRECTORY_PATH\"] = \"/path/to/working/dir\"\n    os.environ[\"APP_REVISION\"] = \"abc123\"\n\n    config = Config()\n\n    env_options = Options(\n        active=True,\n        bind_address=\"0.0.0.0\",\n        ca_file_path=\"/path/to/cacert.pem\",\n        dns_servers=[\"8.8.8.8\", \"8.8.4.4\"],\n        enable_host_metrics=True,\n        enable_nginx_metrics=False,\n        enable_statsd=False,\n        endpoint=\"https://push.appsignal.com\",\n        environment=\"development\",\n        files_world_accessible=True,\n        filter_parameters=[\"password\", \"secret\"],\n        filter_session_data=[\"key1\", \"key2\"],\n        hostname=\"Test hostname\",\n        http_proxy=\"http://proxy.local:9999\",\n        ignore_actions=[\"action1\", \"action2\"],\n        ignore_errors=[\"error1\", \"error2\"],\n        ignore_namespaces=[\"namespace1\", \"namespace2\"],\n        log_level=\"trace\",\n        log_path=\"/path/to/log_dir\",\n        name=\"MyApp\",\n        push_api_key=\"some-api-key\",\n        revision=\"abc123\",\n        request_headers=[\"accept\", \"x-custom-header\"],\n        running_in_container=True,\n        send_environment_metadata=True,\n        send_params=True,\n        send_session_data=True,\n        working_directory_path=\"/path/to/working/dir\",\n    )\n    assert config.sources[\"environment\"] == env_options\n    final_options = Options()\n    final_options.update(config.sources[\"default\"])\n    final_options.update(config.sources[\"system\"])\n    final_options.update(env_options)\n    assert config.options == final_options", "\ndef test_environ_source():\n    os.environ[\"APPSIGNAL_ACTIVE\"] = \"true\"\n    os.environ[\"APPSIGNAL_APP_ENV\"] = \"development\"\n    os.environ[\"APPSIGNAL_APP_NAME\"] = \"MyApp\"\n    os.environ[\"APPSIGNAL_BIND_ADDRESS\"] = \"0.0.0.0\"\n    os.environ[\"APPSIGNAL_CA_FILE_PATH\"] = \"/path/to/cacert.pem\"\n    os.environ[\"APPSIGNAL_DNS_SERVERS\"] = \"8.8.8.8,8.8.4.4\"\n    os.environ[\"APPSIGNAL_ENABLE_HOST_METRICS\"] = \"true\"\n    os.environ[\"APPSIGNAL_ENABLE_NGINX_METRICS\"] = \"false\"\n    os.environ[\"APPSIGNAL_ENABLE_STATSD\"] = \"false\"\n    os.environ[\"APPSIGNAL_FILES_WORLD_ACCESSIBLE\"] = \"true\"\n    os.environ[\"APPSIGNAL_FILTER_PARAMETERS\"] = \"password,secret\"\n    os.environ[\"APPSIGNAL_FILTER_SESSION_DATA\"] = \"key1,key2\"\n    os.environ[\"APPSIGNAL_HOSTNAME\"] = \"Test hostname\"\n    os.environ[\"APPSIGNAL_HTTP_PROXY\"] = \"http://proxy.local:9999\"\n    os.environ[\"APPSIGNAL_IGNORE_ACTIONS\"] = \"action1,action2\"\n    os.environ[\"APPSIGNAL_IGNORE_ERRORS\"] = \"error1,error2\"\n    os.environ[\"APPSIGNAL_IGNORE_NAMESPACES\"] = \"namespace1,namespace2\"\n    os.environ[\"APPSIGNAL_LOG_LEVEL\"] = \"trace\"\n    os.environ[\"APPSIGNAL_LOG_PATH\"] = \"/path/to/log_dir\"\n    os.environ[\"APPSIGNAL_PUSH_API_KEY\"] = \"some-api-key\"\n    os.environ[\"APPSIGNAL_PUSH_API_ENDPOINT\"] = \"https://push.appsignal.com\"\n    os.environ[\"APPSIGNAL_REQUEST_HEADERS\"] = \"accept,x-custom-header\"\n    os.environ[\"APPSIGNAL_RUNNING_IN_CONTAINER\"] = \"true\"\n    os.environ[\"APPSIGNAL_SEND_ENVIRONMENT_METADATA\"] = \"true\"\n    os.environ[\"APPSIGNAL_SEND_PARAMS\"] = \"true\"\n    os.environ[\"APPSIGNAL_SEND_SESSION_DATA\"] = \"true\"\n    os.environ[\"APPSIGNAL_WORKING_DIRECTORY_PATH\"] = \"/path/to/working/dir\"\n    os.environ[\"APP_REVISION\"] = \"abc123\"\n\n    config = Config()\n\n    env_options = Options(\n        active=True,\n        bind_address=\"0.0.0.0\",\n        ca_file_path=\"/path/to/cacert.pem\",\n        dns_servers=[\"8.8.8.8\", \"8.8.4.4\"],\n        enable_host_metrics=True,\n        enable_nginx_metrics=False,\n        enable_statsd=False,\n        endpoint=\"https://push.appsignal.com\",\n        environment=\"development\",\n        files_world_accessible=True,\n        filter_parameters=[\"password\", \"secret\"],\n        filter_session_data=[\"key1\", \"key2\"],\n        hostname=\"Test hostname\",\n        http_proxy=\"http://proxy.local:9999\",\n        ignore_actions=[\"action1\", \"action2\"],\n        ignore_errors=[\"error1\", \"error2\"],\n        ignore_namespaces=[\"namespace1\", \"namespace2\"],\n        log_level=\"trace\",\n        log_path=\"/path/to/log_dir\",\n        name=\"MyApp\",\n        push_api_key=\"some-api-key\",\n        revision=\"abc123\",\n        request_headers=[\"accept\", \"x-custom-header\"],\n        running_in_container=True,\n        send_environment_metadata=True,\n        send_params=True,\n        send_session_data=True,\n        working_directory_path=\"/path/to/working/dir\",\n    )\n    assert config.sources[\"environment\"] == env_options\n    final_options = Options()\n    final_options.update(config.sources[\"default\"])\n    final_options.update(config.sources[\"system\"])\n    final_options.update(env_options)\n    assert config.options == final_options", "\n\ndef test_environ_source_bool_is_unset():\n    config = Config()\n\n    assert config.sources[\"environment\"].get(\"active\") is None\n    assert config.option(\"active\") is None\n\n\ndef test_environ_source_bool_is_empty_string():\n    os.environ[\"APPSIGNAL_ACTIVE\"] = \"\"\n\n    config = Config()\n\n    assert config.sources[\"environment\"].get(\"active\") is None\n    assert config.option(\"active\") is None", "\ndef test_environ_source_bool_is_empty_string():\n    os.environ[\"APPSIGNAL_ACTIVE\"] = \"\"\n\n    config = Config()\n\n    assert config.sources[\"environment\"].get(\"active\") is None\n    assert config.option(\"active\") is None\n\n\ndef test_environ_source_bool_is_invalid():\n    os.environ[\"APPSIGNAL_ACTIVE\"] = \"invalid\"\n\n    config = Config()\n\n    assert config.sources[\"environment\"].get(\"active\") is None\n    assert config.option(\"active\") is None", "\n\ndef test_environ_source_bool_is_invalid():\n    os.environ[\"APPSIGNAL_ACTIVE\"] = \"invalid\"\n\n    config = Config()\n\n    assert config.sources[\"environment\"].get(\"active\") is None\n    assert config.option(\"active\") is None\n", "\n\ndef test_environ_source_disable_default_instrumentations_list():\n    os.environ[\"APPSIGNAL_DISABLE_DEFAULT_INSTRUMENTATIONS\"] = \",\".join(\n        [\"opentelemetry.instrumentation.celery\", \"something.else\"]\n    )\n\n    config = Config()\n\n    assert config.sources[\"environment\"][\"disable_default_instrumentations\"] == [\n        \"opentelemetry.instrumentation.celery\"\n    ]\n    assert config.options[\"disable_default_instrumentations\"] == [\n        \"opentelemetry.instrumentation.celery\"\n    ]", "\n\ndef test_environ_source_disable_default_instrumentations_bool():\n    for value, expected in [\n        (\"True\", True),\n        (\"true\", True),\n        (\"False\", False),\n        (\"false\", False),\n    ]:\n        os.environ[\"APPSIGNAL_DISABLE_DEFAULT_INSTRUMENTATIONS\"] = value\n        config = Config()\n        assert config.options[\"disable_default_instrumentations\"] is expected", "\n\ndef test_set_private_environ():\n    cwdir = os.getcwd()\n    config = Config(\n        Options(\n            active=True,\n            app_path=\"/path/to/app\",\n            bind_address=\"0.0.0.0\",\n            ca_file_path=\"/path/to/cacert.pem\",\n            dns_servers=[\"8.8.8.8\", \"8.8.4.4\"],\n            enable_host_metrics=True,\n            enable_nginx_metrics=False,\n            enable_statsd=False,\n            endpoint=\"https://push.appsignal.com\",\n            environment=\"development\",\n            files_world_accessible=True,\n            filter_parameters=[\"password\", \"secret\"],\n            filter_session_data=[\"key1\", \"key2\"],\n            hostname=\"Test hostname\",\n            http_proxy=\"http://proxy.local:9999\",\n            ignore_actions=[\"action1\", \"action2\"],\n            ignore_errors=[\"error1\", \"error2\"],\n            ignore_namespaces=[\"namespace1\", \"namespace2\"],\n            log_level=\"trace\",\n            log_path=cwdir,\n            name=\"MyApp\",\n            push_api_key=\"some-api-key\",\n            revision=\"abc123\",\n            running_in_container=True,\n            send_environment_metadata=True,\n            send_params=True,\n            send_session_data=True,\n            working_directory_path=\"/path/to/working/dir\",\n        )\n    )\n\n    config.set_private_environ()\n\n    assert os.environ[\"_APPSIGNAL_ACTIVE\"] == \"true\"\n    assert os.environ[\"_APPSIGNAL_APP_ENV\"] == \"development\"\n    assert os.environ[\"_APPSIGNAL_APP_NAME\"] == \"MyApp\"\n    assert os.environ[\"_APPSIGNAL_APP_PATH\"] == \"/path/to/app\"\n    assert os.environ[\"_APPSIGNAL_BIND_ADDRESS\"] == \"0.0.0.0\"\n    assert os.environ[\"_APPSIGNAL_CA_FILE_PATH\"] == \"/path/to/cacert.pem\"\n    assert os.environ[\"_APPSIGNAL_DNS_SERVERS\"] == \"8.8.8.8,8.8.4.4\"\n    assert os.environ[\"_APPSIGNAL_ENABLE_HOST_METRICS\"] == \"true\"\n    assert os.environ[\"_APPSIGNAL_ENABLE_NGINX_METRICS\"] == \"false\"\n    assert os.environ[\"_APPSIGNAL_ENABLE_STATSD\"] == \"false\"\n    assert os.environ[\"_APPSIGNAL_FILES_WORLD_ACCESSIBLE\"] == \"true\"\n    assert os.environ[\"_APPSIGNAL_FILTER_PARAMETERS\"] == \"password,secret\"\n    assert os.environ[\"_APPSIGNAL_FILTER_SESSION_DATA\"] == \"key1,key2\"\n    assert os.environ[\"_APPSIGNAL_HOSTNAME\"] == \"Test hostname\"\n    assert os.environ[\"_APPSIGNAL_HTTP_PROXY\"] == \"http://proxy.local:9999\"\n    assert os.environ[\"_APPSIGNAL_IGNORE_ACTIONS\"] == \"action1,action2\"\n    assert os.environ[\"_APPSIGNAL_IGNORE_ERRORS\"] == \"error1,error2\"\n    assert os.environ[\"_APPSIGNAL_IGNORE_NAMESPACES\"] == \"namespace1,namespace2\"\n    assert os.environ[\"_APPSIGNAL_LOG_LEVEL\"] == \"trace\"\n    assert os.environ[\"_APPSIGNAL_LOG_FILE_PATH\"] == f\"{cwdir}/appsignal.log\"\n    assert os.environ[\"_APPSIGNAL_PUSH_API_KEY\"] == \"some-api-key\"\n    assert os.environ[\"_APPSIGNAL_PUSH_API_ENDPOINT\"] == \"https://push.appsignal.com\"\n    assert (\n        os.environ[\"_APPSIGNAL_LANGUAGE_INTEGRATION_VERSION\"] == f\"python-{__version__}\"\n    )\n    assert os.environ[\"_APPSIGNAL_RUNNING_IN_CONTAINER\"] == \"true\"\n    assert os.environ[\"_APPSIGNAL_SEND_ENVIRONMENT_METADATA\"] == \"true\"\n    assert os.environ[\"_APPSIGNAL_SEND_PARAMS\"] == \"true\"\n    assert os.environ[\"_APPSIGNAL_SEND_SESSION_DATA\"] == \"true\"\n    assert os.environ[\"_APPSIGNAL_WORKING_DIRECTORY_PATH\"] == \"/path/to/working/dir\"\n    assert os.environ[\"_APP_REVISION\"] == \"abc123\"", "\n\ndef test_set_private_environ_valid_log_path():\n    cwdir = os.getcwd()\n    config = Config(Options(log_path=cwdir))\n    config.set_private_environ()\n\n    assert os.environ[\"_APPSIGNAL_LOG_FILE_PATH\"] == f\"{cwdir}/appsignal.log\"\n\n\ndef test_set_private_environ_remove_filename_from_log_path():\n    cwdir = os.getcwd()\n    log_path = os.path.join(cwdir, \"test.log\")\n    config = Config(Options(log_path=log_path))\n    config.set_private_environ()\n\n    assert os.environ[\"_APPSIGNAL_LOG_FILE_PATH\"] == f\"{cwdir}/appsignal.log\"", "\n\ndef test_set_private_environ_remove_filename_from_log_path():\n    cwdir = os.getcwd()\n    log_path = os.path.join(cwdir, \"test.log\")\n    config = Config(Options(log_path=log_path))\n    config.set_private_environ()\n\n    assert os.environ[\"_APPSIGNAL_LOG_FILE_PATH\"] == f\"{cwdir}/appsignal.log\"\n", "\n\ndef test_set_private_environ_invalid_log_path():\n    config = Config(Options(log_path=\"/i_dont_exist\"))\n    config.set_private_environ()\n\n    assert os.environ[\"_APPSIGNAL_LOG_FILE_PATH\"] == \"/tmp/appsignal.log\"\n\n\ndef test_set_private_environ_bool_is_none():\n    config = Config(Options(active=None))\n\n    config.set_private_environ()\n\n    assert os.environ.get(\"_APPSIGNAL_ACTIVE\") is None", "\ndef test_set_private_environ_bool_is_none():\n    config = Config(Options(active=None))\n\n    config.set_private_environ()\n\n    assert os.environ.get(\"_APPSIGNAL_ACTIVE\") is None\n\n\ndef test_set_private_environ_list_is_none():\n    config = Config(Options(dns_servers=None))\n\n    config.set_private_environ()\n\n    assert os.environ.get(\"_APPSIGNAL_DNS_SERVERS\") is None", "\ndef test_set_private_environ_list_is_none():\n    config = Config(Options(dns_servers=None))\n\n    config.set_private_environ()\n\n    assert os.environ.get(\"_APPSIGNAL_DNS_SERVERS\") is None\n"]}
{"filename": "tests/test_cli.py", "chunked_list": ["from __future__ import annotations\n\nfrom contextlib import contextmanager\nfrom unittest.mock import MagicMock\n\nfrom appsignal.cli.base import main\n\n\nEXPECTED_FILE_CONTENTS = \"\"\"from appsignal import Appsignal\n", "EXPECTED_FILE_CONTENTS = \"\"\"from appsignal import Appsignal\n\nappsignal = Appsignal(\n    active=True,\n    name=\"My app name\",\n    push_api_key=\"My push API key\",\n)\n\"\"\"\n\n", "\n\n@contextmanager\ndef mock_input(mocker, *pairs: tuple[str, str]):\n    prompt_calls = [mocker.call(prompt) for (prompt, _) in pairs]\n    answers = [answer for (_, answer) in pairs]\n    mock = mocker.patch(\"builtins.input\", side_effect=answers)\n    yield\n    assert prompt_calls == mock.mock_calls\n", "\n\ndef mock_file_operations(mocker, file_exists: bool = False):\n    mocker.patch(\"os.path.exists\", return_value=file_exists)\n    mocker.patch(\"appsignal.cli.install.open\")\n\n\ndef assert_wrote_file_contents(mocker):\n    from appsignal.cli import install\n\n    builtins_open: MagicMock = install.open  # type: ignore[attr-defined]\n    assert mocker.call(\"__appsignal__.py\", \"w\") in builtins_open.mock_calls\n    assert (\n        mocker.call().__enter__().write(EXPECTED_FILE_CONTENTS)\n        in builtins_open.mock_calls\n    )", "\n\ndef mock_validate_push_api_key_request(mocker, status_code=200):\n    mock_request = mocker.patch(\"requests.get\")\n    mock_request.return_value = MagicMock(status_code=status_code)\n\n\ndef test_install_command_run(mocker):\n    mock_file_operations(mocker)\n    mock_validate_push_api_key_request(mocker)\n\n    with mock_input(\n        mocker,\n        (\"Please enter the name of your application: \", \"My app name\"),\n        (\"Please enter your Push API key: \", \"My push API key\"),\n    ):\n        main([\"install\"])\n\n    assert_wrote_file_contents(mocker)", "\n\ndef test_install_command_when_empty_value_ask_again(mocker):\n    mock_file_operations(mocker)\n    mock_validate_push_api_key_request(mocker)\n\n    with mock_input(\n        mocker,\n        (\"Please enter the name of your application: \", \"\"),\n        (\"Please enter the name of your application: \", \"My app name\"),\n        (\"Please enter your Push API key: \", \"\"),\n        (\"Please enter your Push API key: \", \"My push API key\"),\n    ):\n        main([\"install\"])\n\n    assert_wrote_file_contents(mocker)", "\n\ndef test_install_command_when_push_api_key_given(mocker):\n    mock_file_operations(mocker)\n    mock_validate_push_api_key_request(mocker)\n\n    with mock_input(\n        mocker,\n        (\"Please enter the name of your application: \", \"My app name\"),\n    ):\n        main([\"install\", \"--push-api-key\", \"My push API key\"])\n\n    assert_wrote_file_contents(mocker)", "\n\ndef test_install_command_when_file_exists_overwrite(mocker):\n    mock_file_operations(mocker, file_exists=True)\n    mock_validate_push_api_key_request(mocker)\n\n    with mock_input(\n        mocker,\n        (\"Please enter the name of your application: \", \"My app name\"),\n        (\"Please enter your Push API key: \", \"My push API key\"),\n        (\n            \"The __appsignal__.py file already exists.\"\n            \" Should it be overwritten? (y/N): \",\n            \"y\",\n        ),\n    ):\n        main([\"install\"])\n\n    assert_wrote_file_contents(mocker)", "\n\ndef test_install_command_when_file_exists_no_overwrite(mocker):\n    mock_file_operations(mocker, file_exists=True)\n    mock_validate_push_api_key_request(mocker)\n\n    with mock_input(\n        mocker,\n        (\"Please enter the name of your application: \", \"My app name\"),\n        (\"Please enter your Push API key: \", \"My push API key\"),\n        (\n            \"The __appsignal__.py file already exists.\"\n            \" Should it be overwritten? (y/N): \",\n            \"n\",\n        ),\n    ):\n        main([\"install\"])\n\n    from appsignal.cli import install\n\n    assert install.open.mock_calls == []  # type: ignore[attr-defined]", "\n\ndef test_install_comand_when_api_key_is_not_valid(mocker):\n    mock_validate_push_api_key_request(mocker, status_code=401)\n\n    with mock_input(\n        mocker,\n        (\"Please enter the name of your application: \", \"My app name\"),\n    ):\n        assert main([\"install\", \"--push-api-key=bad-push-api-key\"]) == 1", ""]}
{"filename": "tests/test_opentelemetry.py", "chunked_list": ["from __future__ import annotations\n\nfrom unittest.mock import Mock\n\nfrom appsignal.config import Config, Options\nfrom appsignal.opentelemetry import add_instrumentations\n\n\ndef raise_module_not_found_error():\n    raise ModuleNotFoundError", "def raise_module_not_found_error():\n    raise ModuleNotFoundError\n\n\ndef mock_adders() -> dict[Config.DefaultInstrumentation, Mock]:\n    return {\n        \"opentelemetry.instrumentation.celery\": Mock(),\n        \"opentelemetry.instrumentation.jinja2\": Mock(\n            side_effect=raise_module_not_found_error\n        ),\n    }", "\n\ndef test_add_instrumentations():\n    adders = mock_adders()\n    config = Config()\n\n    add_instrumentations(config, _adders=adders)\n\n    for adder in adders.values():\n        adder.assert_called_once()", "\n\ndef test_add_instrumentations_disable_some_default_instrumentations():\n    adders = mock_adders()\n    config = Config(\n        Options(\n            disable_default_instrumentations=[\"opentelemetry.instrumentation.celery\"]\n        )\n    )\n\n    add_instrumentations(config, _adders=adders)\n\n    adders[\"opentelemetry.instrumentation.celery\"].assert_not_called()\n    adders[\"opentelemetry.instrumentation.jinja2\"].assert_called_once()", "\n\ndef test_add_instrumentations_disable_all_default_instrumentations():\n    adders = mock_adders()\n    config = Config(Options(disable_default_instrumentations=True))\n\n    add_instrumentations(config, _adders=adders)\n\n    for adder in adders.values():\n        adder.assert_not_called()", ""]}
{"filename": "tests/test_client.py", "chunked_list": ["from __future__ import annotations\n\nimport os\nimport re\nfrom logging import DEBUG, ERROR, INFO, WARNING\n\nfrom appsignal.agent import agent\nfrom appsignal.client import Client\n\n\ndef test_client_options_merge_sources():\n    os.environ[\"APPSIGNAL_PUSH_API_KEY\"] = \"some_key\"\n    client = Client(name=\"MyApp\")\n    assert client._config.options[\"name\"] == \"MyApp\"\n    assert client._config.options[\"push_api_key\"] == \"some_key\"\n    assert \"app_path\" in client._config.options", "\n\ndef test_client_options_merge_sources():\n    os.environ[\"APPSIGNAL_PUSH_API_KEY\"] = \"some_key\"\n    client = Client(name=\"MyApp\")\n    assert client._config.options[\"name\"] == \"MyApp\"\n    assert client._config.options[\"push_api_key\"] == \"some_key\"\n    assert \"app_path\" in client._config.options\n\n\ndef test_client_agent_inactive():\n    client = Client(active=True, name=\"MyApp\")\n    assert client._config.options[\"active\"] is True\n    client.start()\n\n    assert os.environ.get(\"_APPSIGNAL_ACTIVE\") == \"true\"\n    assert agent.active is False", "\n\ndef test_client_agent_inactive():\n    client = Client(active=True, name=\"MyApp\")\n    assert client._config.options[\"active\"] is True\n    client.start()\n\n    assert os.environ.get(\"_APPSIGNAL_ACTIVE\") == \"true\"\n    assert agent.active is False\n", "\n\ndef test_client_agent_active():\n    client = Client(active=True, name=\"MyApp\", push_api_key=\"000\")\n    assert client._config.options[\"active\"] is True\n    client.start()\n\n    assert os.environ.get(\"_APPSIGNAL_ACTIVE\") == \"true\"\n    assert agent.active is True\n", "\n\ndef test_client_active():\n    client = Client(\n        active=True,\n        name=\"MyApp\",\n        request_headers=[\"accept\", \"x-custom-header\"],\n        push_api_key=\"0000-0000-0000-0000\",\n    )\n    assert client._config.options[\"active\"] is True\n    assert client._config.options[\"name\"] == \"MyApp\"\n    assert client._config.options[\"request_headers\"] == [\"accept\", \"x-custom-header\"]\n    assert client._config.options[\"push_api_key\"] == \"0000-0000-0000-0000\"\n    client.start()\n\n    # Sets the private config environment variables\n    assert os.environ.get(\"_APPSIGNAL_ACTIVE\") == \"true\"\n    assert os.environ.get(\"_APPSIGNAL_APP_NAME\") == \"MyApp\"\n    assert os.environ.get(\"_APPSIGNAL_PUSH_API_KEY\") == \"0000-0000-0000-0000\"\n    assert (\n        os.environ.get(\"OTEL_INSTRUMENTATION_HTTP_CAPTURE_HEADERS_SERVER_REQUEST\")\n        == \"accept,x-custom-header\"\n    )\n    assert agent.active", "\n\ndef test_client_active_without_request_headers():\n    client = Client(active=True, name=\"MyApp\", request_headers=None)\n    assert client._config.options[\"active\"] is True\n    assert client._config.options[\"name\"] == \"MyApp\"\n    assert client._config.options[\"request_headers\"] is None\n    client.start()\n\n    # Sets the private config environment variables\n    assert os.environ.get(\"_APPSIGNAL_ACTIVE\") == \"true\"\n    assert os.environ.get(\"_APPSIGNAL_APP_NAME\") == \"MyApp\"\n    assert (\n        os.environ.get(\"OTEL_INSTRUMENTATION_HTTP_CAPTURE_HEADERS_SERVER_REQUEST\")\n        is None\n    )", "\n\ndef test_client_inactive():\n    client = Client(active=False, name=\"MyApp\")\n    assert client._config.options[\"active\"] is False\n    assert client._config.options[\"name\"] == \"MyApp\"\n    client.start()\n\n    # Does not set the private config environment variables\n    assert os.environ.get(\"_APPSIGNAL_ACTIVE\") is None\n    assert os.environ.get(\"_APPSIGNAL_APP_NAME\") is None\n    assert (\n        os.environ.get(\"OTEL_INSTRUMENTATION_HTTP_CAPTURE_HEADERS_SERVER_REQUEST\")\n        is None\n    )", "\n\ndef test_logger_default_level():\n    client = Client()\n    assert client._logger.getEffectiveLevel() == INFO\n\n    client = Client(log_level=\"info\")\n    assert client._logger.getEffectiveLevel() == INFO\n\n\ndef test_logger_error_level():\n    client = Client(log_level=\"error\")\n    assert client._logger.getEffectiveLevel() == ERROR", "\n\ndef test_logger_error_level():\n    client = Client(log_level=\"error\")\n    assert client._logger.getEffectiveLevel() == ERROR\n\n\ndef test_logger_warning_level():\n    client = Client(log_level=\"warning\")\n    assert client._logger.getEffectiveLevel() == WARNING", "\n\ndef test_logger_debug_level():\n    client = Client(log_level=\"debug\")\n    assert client._logger.getEffectiveLevel() == DEBUG\n\n\ndef test_logger_trace_level():\n    client = Client(log_level=\"trace\")\n    assert client._logger.getEffectiveLevel() == DEBUG", "\n\ndef test_logger_file(tmp_path):\n    log_path = tmp_path\n    log_file_path = os.path.join(log_path, \"appsignal.log\")\n\n    client = Client(log_path=log_path)\n    logger = client._logger\n    logger.info(\"test me\")\n\n    with open(log_file_path) as file:\n        contents = file.read()\n\n    log_line_regex = re.compile(\n        r\"\\[\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2} \\(process\\) #\\d+\\]\\[INFO\\] test me\"\n    )\n    assert log_line_regex.search(contents)", "\n\ndef test_logger_stdout(capsys):\n    client = Client(log=\"stdout\")\n    logger = client._logger\n    logger.info(\"test me\")\n\n    captured = capsys.readouterr()\n    log_line_regex = re.compile(\n        r\"\\[\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2} \\(process\\) #\\d+\\]\\[appsignal\\]\"\n        r\"\\[INFO\\] test me\"\n    )\n    assert log_line_regex.search(captured.out)", "\n\ndef test_logger_stdout_fallback(capsys, mocker):\n    # Make any path appear unwritable so it will fall back to the STDOUT logger\n    mocker.patch(\"os.access\", return_value=False)\n\n    client = Client(log=\"file\", log_path=None)\n    logger = client._logger\n    logger.info(\"test me\")\n\n    captured = capsys.readouterr()\n    log_line_regex = re.compile(\n        r\"\\[\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2} \\(process\\) #\\d+\\]\\[appsignal\\]\"\n        r\"\\[INFO\\] test me\"\n    )\n    assert log_line_regex.search(captured.out)", ""]}
{"filename": "src/scripts/sdist_hook.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import Any\n\nfrom hatchling.builders.hooks.plugin.interface import BuildHookInterface\n\n\nclass CustomBuildHook(BuildHookInterface):\n    def initialize(self, version: str, build_data: dict[str, Any]) -> None:\n        \"\"\"\n        This occurs immediately before each build.\n\n        Any modifications to the build data will be seen by the build target.\n        \"\"\"\n        print(\n            \"It is not possible to build a source distribution package for \"\n            \"this project, as it requires a platform-dependent binary.\"\n        )\n        print(\"Hint: you may wish to run `hatch run build:me` instead?\")\n        exit(1)", ""]}
{"filename": "src/scripts/platform.py", "chunked_list": ["from __future__ import annotations\n\n\nTRIPLE_PLATFORM_TAG = {\n    # MacOS builds\n    \"x86_64-darwin\": \"macosx_10_9_x86_64\",\n    # Apple Silicon (and Apple Silicon w/ Intel emulation)\n    \"arm64-darwin\": \"macosx_10_9_universal2.macosx_12_3_arm64\",\n    # Glibc Linux builds\n    # manylinux2014 is a legacy tag defined as glibc >= 2.17,", "    # Glibc Linux builds\n    # manylinux2014 is a legacy tag defined as glibc >= 2.17,\n    # we actually support glibc >= 2.15\n    # https://peps.python.org/pep-0600/#legacy-manylinux-tags\n    \"aarch64-linux\": \"manylinux2014_aarch64.manylinux_2_15_aarch64\",\n    \"x86_64-linux\": \"manylinux2014_x86_64.manylinux_2_15_x86_64\",\n    \"i686-linux\": \"manylinux2014_i686.manylinux_2_15_i686\",\n    # MUSL Linux builds\n    # our docs say we support v1.1.16 or above, but we can't\n    # specify the patch", "    # our docs say we support v1.1.16 or above, but we can't\n    # specify the patch\n    # https://peps.python.org/pep-0656/\n    \"aarch64-linux-musl\": \"musllinux_1_1_aarch64\",\n    \"x86_64-linux-musl\": \"musllinux_1_1_x86_64\",\n}\n"]}
{"filename": "src/scripts/agent.py", "chunked_list": ["# DO NOT EDIT\n# This is a generated file by the `rake ship` family of tasks in the\n# appsignal-agent repository.\n# Modifications to this file will be overwritten with the next agent release.\n\nAPPSIGNAL_AGENT_CONFIG = {\n    \"version\": \"d789895\",\n    \"mirrors\": [\n        \"https://appsignal-agent-releases.global.ssl.fastly.net\",\n        \"https://d135dj0rjqvssy.cloudfront.net\",", "        \"https://appsignal-agent-releases.global.ssl.fastly.net\",\n        \"https://d135dj0rjqvssy.cloudfront.net\",\n    ],\n    \"triples\": {\n        \"x86_64-darwin\": {\n            \"static\": {\n                \"checksum\": \"8ea76b7d011c728b7988d017a39fc3a432d9c86392e6e46767ecc931e583777a\",\n                \"filename\": \"appsignal-x86_64-darwin-all-static.tar.gz\",\n            },\n            \"dynamic\": {", "            },\n            \"dynamic\": {\n                \"checksum\": \"beacdcd579bcc06a69da279dbca2f363395ea4b1846fa4b6e49de612beb07a8a\",\n                \"filename\": \"appsignal-x86_64-darwin-all-dynamic.tar.gz\",\n            },\n        },\n        \"universal-darwin\": {\n            \"static\": {\n                \"checksum\": \"8ea76b7d011c728b7988d017a39fc3a432d9c86392e6e46767ecc931e583777a\",\n                \"filename\": \"appsignal-x86_64-darwin-all-static.tar.gz\",", "                \"checksum\": \"8ea76b7d011c728b7988d017a39fc3a432d9c86392e6e46767ecc931e583777a\",\n                \"filename\": \"appsignal-x86_64-darwin-all-static.tar.gz\",\n            },\n            \"dynamic\": {\n                \"checksum\": \"beacdcd579bcc06a69da279dbca2f363395ea4b1846fa4b6e49de612beb07a8a\",\n                \"filename\": \"appsignal-x86_64-darwin-all-dynamic.tar.gz\",\n            },\n        },\n        \"aarch64-darwin\": {\n            \"static\": {", "        \"aarch64-darwin\": {\n            \"static\": {\n                \"checksum\": \"535fed60ac1484e40bbfe77cd4fe9131c67f25e6362a2fe31d987c36ec82ba08\",\n                \"filename\": \"appsignal-aarch64-darwin-all-static.tar.gz\",\n            },\n            \"dynamic\": {\n                \"checksum\": \"6c984f53a07788ebb469ede014ac8732d9db1ef43736825690492e7c12e3fb83\",\n                \"filename\": \"appsignal-aarch64-darwin-all-dynamic.tar.gz\",\n            },\n        },", "            },\n        },\n        \"arm64-darwin\": {\n            \"static\": {\n                \"checksum\": \"535fed60ac1484e40bbfe77cd4fe9131c67f25e6362a2fe31d987c36ec82ba08\",\n                \"filename\": \"appsignal-aarch64-darwin-all-static.tar.gz\",\n            },\n            \"dynamic\": {\n                \"checksum\": \"6c984f53a07788ebb469ede014ac8732d9db1ef43736825690492e7c12e3fb83\",\n                \"filename\": \"appsignal-aarch64-darwin-all-dynamic.tar.gz\",", "                \"checksum\": \"6c984f53a07788ebb469ede014ac8732d9db1ef43736825690492e7c12e3fb83\",\n                \"filename\": \"appsignal-aarch64-darwin-all-dynamic.tar.gz\",\n            },\n        },\n        \"arm-darwin\": {\n            \"static\": {\n                \"checksum\": \"535fed60ac1484e40bbfe77cd4fe9131c67f25e6362a2fe31d987c36ec82ba08\",\n                \"filename\": \"appsignal-aarch64-darwin-all-static.tar.gz\",\n            },\n            \"dynamic\": {", "            },\n            \"dynamic\": {\n                \"checksum\": \"6c984f53a07788ebb469ede014ac8732d9db1ef43736825690492e7c12e3fb83\",\n                \"filename\": \"appsignal-aarch64-darwin-all-dynamic.tar.gz\",\n            },\n        },\n        \"aarch64-linux\": {\n            \"static\": {\n                \"checksum\": \"35f96e0adf408fd8ac3e89c6cb3c5506eb4250643199aad3ba298ab131d773c8\",\n                \"filename\": \"appsignal-aarch64-linux-all-static.tar.gz\",", "                \"checksum\": \"35f96e0adf408fd8ac3e89c6cb3c5506eb4250643199aad3ba298ab131d773c8\",\n                \"filename\": \"appsignal-aarch64-linux-all-static.tar.gz\",\n            },\n            \"dynamic\": {\n                \"checksum\": \"6f4e5431c50c947f9fdeb92b7536780277bebb75327cfa5ee9c27659a9d20b5e\",\n                \"filename\": \"appsignal-aarch64-linux-all-dynamic.tar.gz\",\n            },\n        },\n        \"i686-linux\": {\n            \"static\": {", "        \"i686-linux\": {\n            \"static\": {\n                \"checksum\": \"f4a1c9a67a0a4cde7e13ef555a6782e5d4f15bfbce9277c2aaf8e248a0fb858e\",\n                \"filename\": \"appsignal-i686-linux-all-static.tar.gz\",\n            },\n            \"dynamic\": {\n                \"checksum\": \"26a3fa059874d76897e6a4c709048789f531d7e84e6b8ae4e7fbcdfb26cdef40\",\n                \"filename\": \"appsignal-i686-linux-all-dynamic.tar.gz\",\n            },\n        },", "            },\n        },\n        \"x86-linux\": {\n            \"static\": {\n                \"checksum\": \"f4a1c9a67a0a4cde7e13ef555a6782e5d4f15bfbce9277c2aaf8e248a0fb858e\",\n                \"filename\": \"appsignal-i686-linux-all-static.tar.gz\",\n            },\n            \"dynamic\": {\n                \"checksum\": \"26a3fa059874d76897e6a4c709048789f531d7e84e6b8ae4e7fbcdfb26cdef40\",\n                \"filename\": \"appsignal-i686-linux-all-dynamic.tar.gz\",", "                \"checksum\": \"26a3fa059874d76897e6a4c709048789f531d7e84e6b8ae4e7fbcdfb26cdef40\",\n                \"filename\": \"appsignal-i686-linux-all-dynamic.tar.gz\",\n            },\n        },\n        \"x86_64-linux\": {\n            \"static\": {\n                \"checksum\": \"016c962727e31a07eee7a221944ff9c4bbb054eada7e87bbe4602233364f380c\",\n                \"filename\": \"appsignal-x86_64-linux-all-static.tar.gz\",\n            },\n            \"dynamic\": {", "            },\n            \"dynamic\": {\n                \"checksum\": \"d286a8bcc4a876057a14a90cc6ceecdc75230e1c4d721ea3f3138c58c748e602\",\n                \"filename\": \"appsignal-x86_64-linux-all-dynamic.tar.gz\",\n            },\n        },\n        \"x86_64-linux-musl\": {\n            \"static\": {\n                \"checksum\": \"2ce9e34b283c76c6b25028d3a770a942f4975cd071c586438a8765948237ca42\",\n                \"filename\": \"appsignal-x86_64-linux-musl-all-static.tar.gz\",", "                \"checksum\": \"2ce9e34b283c76c6b25028d3a770a942f4975cd071c586438a8765948237ca42\",\n                \"filename\": \"appsignal-x86_64-linux-musl-all-static.tar.gz\",\n            },\n            \"dynamic\": {\n                \"checksum\": \"0eebe8cd448bce5386cdce1039e7f74c60208408108af9537a80e8e8737f7aec\",\n                \"filename\": \"appsignal-x86_64-linux-musl-all-dynamic.tar.gz\",\n            },\n        },\n        \"aarch64-linux-musl\": {\n            \"static\": {", "        \"aarch64-linux-musl\": {\n            \"static\": {\n                \"checksum\": \"017da79e62a2875c0384898c9160cd83acd712faba05154fd8a0627fec1b5ba4\",\n                \"filename\": \"appsignal-aarch64-linux-musl-all-static.tar.gz\",\n            },\n            \"dynamic\": {\n                \"checksum\": \"507d4fa0f3d6168f905404b4b36fe494c5479606d77f50d2d2d3d27b6c645ea1\",\n                \"filename\": \"appsignal-aarch64-linux-musl-all-dynamic.tar.gz\",\n            },\n        },", "            },\n        },\n        \"x86_64-freebsd\": {\n            \"static\": {\n                \"checksum\": \"13d27afcb68aff5e164e05fc4fd8874e73f14c0154301f2e6e6e75f67fa9182c\",\n                \"filename\": \"appsignal-x86_64-freebsd-all-static.tar.gz\",\n            },\n            \"dynamic\": {\n                \"checksum\": \"dafa25a73cd79e269466d5129dd7b61ac88e09d87c3f253fc9705e1d9469fa2b\",\n                \"filename\": \"appsignal-x86_64-freebsd-all-dynamic.tar.gz\",", "                \"checksum\": \"dafa25a73cd79e269466d5129dd7b61ac88e09d87c3f253fc9705e1d9469fa2b\",\n                \"filename\": \"appsignal-x86_64-freebsd-all-dynamic.tar.gz\",\n            },\n        },\n        \"amd64-freebsd\": {\n            \"static\": {\n                \"checksum\": \"13d27afcb68aff5e164e05fc4fd8874e73f14c0154301f2e6e6e75f67fa9182c\",\n                \"filename\": \"appsignal-x86_64-freebsd-all-static.tar.gz\",\n            },\n            \"dynamic\": {", "            },\n            \"dynamic\": {\n                \"checksum\": \"dafa25a73cd79e269466d5129dd7b61ac88e09d87c3f253fc9705e1d9469fa2b\",\n                \"filename\": \"appsignal-x86_64-freebsd-all-dynamic.tar.gz\",\n            },\n        },\n    },\n}\n", ""]}
{"filename": "src/scripts/build_hook.py", "chunked_list": ["from __future__ import annotations\n\nimport hashlib\nimport os\nimport shutil\nimport stat\nimport subprocess\nimport sysconfig\nimport tarfile\nfrom runpy import run_path", "import tarfile\nfrom runpy import run_path\nfrom typing import Any\n\nimport requests\nfrom hatchling.builders.hooks.plugin.interface import BuildHookInterface\n\n\ndef run_relative(filename: str) -> dict[str, Any]:\n    return run_path(os.path.join(os.path.dirname(os.path.abspath(__file__)), filename))", "def run_relative(filename: str) -> dict[str, Any]:\n    return run_path(os.path.join(os.path.dirname(os.path.abspath(__file__)), filename))\n\n\nAPPSIGNAL_AGENT_CONFIG = run_relative(\"agent.py\")[\"APPSIGNAL_AGENT_CONFIG\"]\nTRIPLE_PLATFORM_TAG = run_relative(\"platform.py\")[\"TRIPLE_PLATFORM_TAG\"]\n\n\ndef triple_filename(triple: str) -> str:\n    return APPSIGNAL_AGENT_CONFIG[\"triples\"][triple][\"static\"][\"filename\"]", "def triple_filename(triple: str) -> str:\n    return APPSIGNAL_AGENT_CONFIG[\"triples\"][triple][\"static\"][\"filename\"]\n\n\ndef triple_checksum(triple: str) -> str:\n    return APPSIGNAL_AGENT_CONFIG[\"triples\"][triple][\"static\"][\"checksum\"]\n\n\ndef triple_urls(triple: str) -> list[str]:\n    mirrors = APPSIGNAL_AGENT_CONFIG[\"mirrors\"]\n    version = APPSIGNAL_AGENT_CONFIG[\"version\"]\n    filename = triple_filename(triple)\n\n    return [f\"{mirror}/{version}/{filename}\" for mirror in mirrors]", "def triple_urls(triple: str) -> list[str]:\n    mirrors = APPSIGNAL_AGENT_CONFIG[\"mirrors\"]\n    version = APPSIGNAL_AGENT_CONFIG[\"version\"]\n    filename = triple_filename(triple)\n\n    return [f\"{mirror}/{version}/{filename}\" for mirror in mirrors]\n\n\ndef rm(path: str) -> None:\n    try:\n        os.remove(path)\n    except FileNotFoundError:\n        pass", "def rm(path: str) -> None:\n    try:\n        os.remove(path)\n    except FileNotFoundError:\n        pass\n\n\ndef should_download(agent_path: str, version_path: str) -> bool:\n    if not os.path.exists(agent_path):\n        return True\n\n    if not os.path.exists(version_path):\n        return True\n\n    with open(version_path) as version:\n        return version.read() != APPSIGNAL_AGENT_CONFIG[\"version\"]", "\n\ndef this_triple() -> str:\n    platform = sysconfig.get_platform()\n    [os, *_, arch] = platform.split(\"-\")\n\n    if os == \"macosx\":\n        os = \"darwin\"\n\n    if arch == \"universal2\":\n        arch = \"arm64\"\n\n    if os == \"linux\":\n        ldd_run = subprocess.run([\"ldd\", \"--version\"], capture_output=True)\n        if b\"musl\" in ldd_run.stderr:\n            os = \"linux-musl\"\n\n    return f\"{arch}-{os}\"", "\n\nclass DownloadError(Exception):\n    pass\n\n\nclass CustomBuildHook(BuildHookInterface):\n    def initialize(self, _version: str, build_data: dict[str, Any]) -> None:\n        \"\"\"\n        This occurs immediately before each build.\n\n        Any modifications to the build data will be seen by the build target.\n        \"\"\"\n\n        triple = None\n\n        if \"_APPSIGNAL_BUILD_TRIPLE\" in os.environ:\n            triple = os.environ[\"_APPSIGNAL_BUILD_TRIPLE\"]\n        else:\n            triple = this_triple()\n            print(\n                f\"_APPSIGNAL_BUILD_TRIPLE not set; building for local triple ({triple})\"\n            )\n\n        platform_tag = TRIPLE_PLATFORM_TAG[triple]\n\n        build_data[\"tag\"] = f\"py3-none-{platform_tag}\"\n        build_data[\"pure_python\"] = False\n\n        agent_path = os.path.join(self.root, \"src\", \"appsignal\", \"appsignal-agent\")\n\n        if os.environ.get(\n            \"_APPSIGNAL_BUILD_AGENT_PATH\", \"\"\n        ).strip() == \"--keep-agent\" and os.path.isfile(agent_path):\n            print(f\"Using existing agent binary at {agent_path}\")\n            return\n\n        rm(agent_path)\n\n        tempdir_path = os.path.join(self.root, \"tmp\", triple)\n        os.makedirs(tempdir_path, exist_ok=True)\n\n        tempagent_path = os.path.join(tempdir_path, \"appsignal_agent\")\n        tempversion_path = os.path.join(tempdir_path, \"version\")\n\n        if os.environ.get(\"_APPSIGNAL_BUILD_AGENT_PATH\", \"\").strip() != \"\":\n            tempagent_path = os.path.abspath(\n                os.environ[\"_APPSIGNAL_BUILD_AGENT_PATH\"].strip()\n            )\n\n            if not os.path.isfile(tempagent_path):\n                print(\n                    f\"Custom agent binary at {tempagent_path} is not a file; exiting...\"\n                )\n                exit(1)\n\n            print(f\"Using custom agent binary at {tempagent_path}\")\n        elif should_download(tempagent_path, tempversion_path):\n            temptar_path = os.path.join(tempdir_path, triple_filename(triple))\n\n            rm(tempagent_path)\n            rm(tempversion_path)\n            rm(temptar_path)\n\n            with open(temptar_path, \"wb\") as temptar:\n                for url in triple_urls(triple):\n                    try:\n                        r = requests.get(url, allow_redirects=True)\n                        if r.status_code != 200:\n                            raise DownloadError(\"Status code is not 200\")\n\n                        if hashlib.sha256(r.content).hexdigest() != triple_checksum(\n                            triple\n                        ):\n                            raise DownloadError(\"Checksum does not match\")\n\n                        temptar.write(r.content)\n                    except DownloadError as e:\n                        print(f\"Something went wrong downloading from `{url}`: {e}\")\n                    else:\n                        break\n                else:\n                    print(\"Failed to download from any mirrors; exiting...\")\n                    exit(1)\n\n            print(f\"Downloaded agent tarball for {triple}\")\n\n            with tarfile.open(temptar_path, \"r:*\") as tar:\n                with open(tempagent_path, \"wb\") as agent:\n                    tar_agent = tar.extractfile(\"appsignal-agent\")\n                    if tar_agent is not None:\n                        agent.write(tar_agent.read())\n                    else:\n                        print(\"Failed to extract agent binary; exiting...\")\n                        exit(1)\n\n            with open(tempversion_path, \"w\") as version:\n                version.write(APPSIGNAL_AGENT_CONFIG[\"version\"])\n\n            print(f\"Extracted agent binary to {tempagent_path}\")\n            rm(temptar_path)\n        else:\n            print(f\"Using cached agent binary at {tempagent_path}\")\n\n        shutil.copy(tempagent_path, agent_path)\n        os.chmod(agent_path, stat.S_IEXEC | stat.S_IREAD | stat.S_IWRITE)\n\n        print(f\"Copied agent binary to {agent_path}\")", ""]}
{"filename": "src/scripts/__init__.py", "chunked_list": [""]}
{"filename": "src/scripts/build_all.py", "chunked_list": ["from __future__ import annotations\n\nimport os\nfrom runpy import run_path\nfrom typing import Any\n\n\ndef run_relative(filename: str) -> dict[str, Any]:\n    return run_path(os.path.join(os.path.dirname(os.path.abspath(__file__)), filename))\n", "\n\nTRIPLE_PLATFORM_TAG = run_relative(\"platform.py\")[\"TRIPLE_PLATFORM_TAG\"]\n\nfor triple in TRIPLE_PLATFORM_TAG:\n    result = os.system(f\"_APPSIGNAL_BUILD_TRIPLE={triple} hatch build -t wheel\")\n    if result != 0:\n        break\n", ""]}
{"filename": "src/appsignal/__main__.py", "chunked_list": ["from .cli.base import run\n\n\nrun()\n"]}
{"filename": "src/appsignal/opentelemetry.py", "chunked_list": ["from __future__ import annotations\n\nimport logging\nimport os\nfrom typing import TYPE_CHECKING, Callable, Mapping\n\nfrom opentelemetry import trace\nfrom opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter\nfrom opentelemetry.sdk.trace import TracerProvider\nfrom opentelemetry.sdk.trace.export import BatchSpanProcessor", "from opentelemetry.sdk.trace import TracerProvider\nfrom opentelemetry.sdk.trace.export import BatchSpanProcessor\n\nfrom .config import Config, list_to_env_str\n\n\nif TYPE_CHECKING:\n    from opentelemetry.trace.span import Span\n\n\ndef add_celery_instrumentation() -> None:\n    from opentelemetry.instrumentation.celery import CeleryInstrumentor\n\n    CeleryInstrumentor().instrument()", "\n\ndef add_celery_instrumentation() -> None:\n    from opentelemetry.instrumentation.celery import CeleryInstrumentor\n\n    CeleryInstrumentor().instrument()\n\n\ndef add_django_instrumentation() -> None:\n    import json\n\n    from django.http.request import HttpRequest\n    from django.http.response import HttpResponse\n    from opentelemetry.instrumentation.django import DjangoInstrumentor\n\n    def response_hook(span: Span, request: HttpRequest, response: HttpResponse) -> None:\n        span.set_attribute(\n            \"appsignal.request.parameters\",\n            json.dumps({\"GET\": request.GET, \"POST\": request.POST}),\n        )\n\n    DjangoInstrumentor().instrument(response_hook=response_hook)", "def add_django_instrumentation() -> None:\n    import json\n\n    from django.http.request import HttpRequest\n    from django.http.response import HttpResponse\n    from opentelemetry.instrumentation.django import DjangoInstrumentor\n\n    def response_hook(span: Span, request: HttpRequest, response: HttpResponse) -> None:\n        span.set_attribute(\n            \"appsignal.request.parameters\",\n            json.dumps({\"GET\": request.GET, \"POST\": request.POST}),\n        )\n\n    DjangoInstrumentor().instrument(response_hook=response_hook)", "\n\ndef add_flask_instrumentation() -> None:\n    import json\n    from urllib.parse import parse_qs\n\n    from opentelemetry.instrumentation.flask import FlaskInstrumentor\n\n    def request_hook(span: Span, environ: dict[str, str]) -> None:\n        if span and span.is_recording():\n            query_params = parse_qs(environ.get(\"QUERY_STRING\", \"\"))\n            span.set_attribute(\n                \"appsignal.request.parameters\", json.dumps({\"args\": query_params})\n            )\n\n    FlaskInstrumentor().instrument(request_hook=request_hook)", "\n\ndef add_jinja2_instrumentation() -> None:\n    from opentelemetry.instrumentation.jinja2 import Jinja2Instrumentor\n\n    Jinja2Instrumentor().instrument()\n\n\ndef add_psycopg2_instrumentation() -> None:\n    from opentelemetry.instrumentation.psycopg2 import Psycopg2Instrumentor\n\n    Psycopg2Instrumentor().instrument(enable_commenter=True, commenter_options={})", "def add_psycopg2_instrumentation() -> None:\n    from opentelemetry.instrumentation.psycopg2 import Psycopg2Instrumentor\n\n    Psycopg2Instrumentor().instrument(enable_commenter=True, commenter_options={})\n\n\ndef add_redis_instrumentation() -> None:\n    from opentelemetry.instrumentation.redis import RedisInstrumentor\n\n    RedisInstrumentor().instrument(sanitize_query=True)", "\n\ndef add_requests_instrumentation() -> None:\n    from opentelemetry.instrumentation.requests import RequestsInstrumentor\n\n    RequestsInstrumentor().instrument()\n\n\nDefaultInstrumentationAdder = Callable[[], None]\n", "DefaultInstrumentationAdder = Callable[[], None]\n\nDEFAULT_INSTRUMENTATION_ADDERS: Mapping[\n    Config.DefaultInstrumentation, DefaultInstrumentationAdder\n] = {\n    \"opentelemetry.instrumentation.celery\": add_celery_instrumentation,\n    \"opentelemetry.instrumentation.django\": add_django_instrumentation,\n    \"opentelemetry.instrumentation.flask\": add_flask_instrumentation,\n    \"opentelemetry.instrumentation.jinja2\": add_jinja2_instrumentation,\n    \"opentelemetry.instrumentation.psycopg2\": add_psycopg2_instrumentation,", "    \"opentelemetry.instrumentation.jinja2\": add_jinja2_instrumentation,\n    \"opentelemetry.instrumentation.psycopg2\": add_psycopg2_instrumentation,\n    \"opentelemetry.instrumentation.redis\": add_redis_instrumentation,\n    \"opentelemetry.instrumentation.requests\": add_requests_instrumentation,\n}\n\n\ndef start_opentelemetry(config: Config) -> None:\n    # Configure OpenTelemetry request headers config\n    request_headers = list_to_env_str(config.option(\"request_headers\"))\n    if request_headers:\n        os.environ[\n            \"OTEL_INSTRUMENTATION_HTTP_CAPTURE_HEADERS_SERVER_REQUEST\"\n        ] = request_headers\n\n    provider = TracerProvider()\n\n    otlp_exporter = OTLPSpanExporter(endpoint=\"http://localhost:8099/v1/traces\")\n    exporter_processor = BatchSpanProcessor(otlp_exporter)\n    provider.add_span_processor(exporter_processor)\n    trace.set_tracer_provider(provider)\n\n    add_instrumentations(config)", "\n\ndef add_instrumentations(\n    config: Config,\n    _adders: Mapping[\n        Config.DefaultInstrumentation, DefaultInstrumentationAdder\n    ] = DEFAULT_INSTRUMENTATION_ADDERS,\n) -> None:\n    logger = logging.getLogger(\"appsignal\")\n    disable_list = config.options.get(\"disable_default_instrumentations\") or []\n\n    if disable_list is True:\n        return\n\n    for name, adder in _adders.items():\n        if name not in disable_list:\n            try:\n                logger.info(f\"Instrumenting {name}\")\n                adder()\n            except ModuleNotFoundError:\n                pass", ""]}
{"filename": "src/appsignal/agent.py", "chunked_list": ["from __future__ import annotations\n\nimport subprocess\nfrom dataclasses import dataclass\nfrom pathlib import Path\n\nfrom .config import Config\n\n\n@dataclass\nclass Agent:\n    path: Path = Path(__file__).parent / \"appsignal-agent\"\n    active: bool = False\n\n    def start(self, config: Config) -> None:\n        config.set_private_environ()\n        p = subprocess.Popen(\n            [self.path, \"start\", \"--private\"],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        p.wait(timeout=1)\n        returncode = p.returncode\n        if returncode == 0:\n            self.active = True\n        else:\n            output, _ = p.communicate()\n            out = output.decode(\"utf-8\")\n            print(f\"AppSignal agent is unable to start ({returncode}): \", out)\n\n    def diagnose(self) -> bytes:\n        return subprocess.run([self.path, \"diagnose\"], capture_output=True).stdout\n\n    def version(self) -> bytes:\n        return subprocess.run(\n            [self.path, \"--version\"], capture_output=True\n        ).stdout.split()[-1]", "\n@dataclass\nclass Agent:\n    path: Path = Path(__file__).parent / \"appsignal-agent\"\n    active: bool = False\n\n    def start(self, config: Config) -> None:\n        config.set_private_environ()\n        p = subprocess.Popen(\n            [self.path, \"start\", \"--private\"],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        p.wait(timeout=1)\n        returncode = p.returncode\n        if returncode == 0:\n            self.active = True\n        else:\n            output, _ = p.communicate()\n            out = output.decode(\"utf-8\")\n            print(f\"AppSignal agent is unable to start ({returncode}): \", out)\n\n    def diagnose(self) -> bytes:\n        return subprocess.run([self.path, \"diagnose\"], capture_output=True).stdout\n\n    def version(self) -> bytes:\n        return subprocess.run(\n            [self.path, \"--version\"], capture_output=True\n        ).stdout.split()[-1]", "\n\nagent = Agent()\n"]}
{"filename": "src/appsignal/config.py", "chunked_list": ["from __future__ import annotations\n\nimport os\nimport platform\nimport tempfile\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    ClassVar,\n    List,", "    ClassVar,\n    List,\n    Literal,\n    TypedDict,\n    cast,\n    get_args,\n)\n\nfrom .__about__ import __version__\n", "from .__about__ import __version__\n\n\nif TYPE_CHECKING:\n    pass\n\n\nclass Options(TypedDict, total=False):\n    active: bool | None\n    app_path: str | None\n    bind_address: str | None\n    ca_file_path: str | None\n    diagnose_endpoint: str | None\n    disable_default_instrumentations: None | (\n        list[Config.DefaultInstrumentation] | bool\n    )\n    dns_servers: list[str] | None\n    enable_host_metrics: bool | None\n    enable_nginx_metrics: bool | None\n    enable_statsd: bool | None\n    endpoint: str | None\n    environment: str | None\n    files_world_accessible: bool | None\n    filter_parameters: list[str] | None\n    filter_session_data: list[str] | None\n    hostname: str | None\n    http_proxy: str | None\n    ignore_actions: list[str] | None\n    ignore_errors: list[str] | None\n    ignore_namespaces: list[str] | None\n    log: str | None\n    log_level: str | None\n    log_path: str | None\n    name: str | None\n    push_api_key: str | None\n    revision: str | None\n    request_headers: list[str] | None\n    running_in_container: bool | None\n    send_environment_metadata: bool | None\n    send_params: bool | None\n    send_session_data: bool | None\n    working_directory_path: str | None", "\n\nclass Sources(TypedDict):\n    default: Options\n    system: Options\n    initial: Options\n    environment: Options\n\n\nclass Config:\n    sources: Sources\n\n    CA_FILE_PATH = os.path.join(\n        os.path.dirname(os.path.abspath(__file__)), \"resources\", \"cacert.pem\"\n    )\n    DEFAULT_CONFIG = Options(\n        ca_file_path=CA_FILE_PATH,\n        diagnose_endpoint=\"https://appsignal.com/diag\",\n        enable_host_metrics=True,\n        enable_nginx_metrics=False,\n        enable_statsd=False,\n        environment=\"development\",\n        endpoint=\"https://push.appsignal.com\",\n        files_world_accessible=True,\n        log=\"file\",\n        log_level=\"info\",\n        send_environment_metadata=True,\n        send_params=True,\n        send_session_data=True,\n        request_headers=[\n            \"accept\",\n            \"accept-charset\",\n            \"accept-encoding\",\n            \"accept-language\",\n            \"cache-control\",\n            \"connection\",\n            \"content-length\",\n            \"range\",\n        ],\n    )\n\n    DefaultInstrumentation = Literal[\n        \"opentelemetry.instrumentation.celery\",\n        \"opentelemetry.instrumentation.django\",\n        \"opentelemetry.instrumentation.flask\",\n        \"opentelemetry.instrumentation.jinja2\",\n        \"opentelemetry.instrumentation.psycopg2\",\n        \"opentelemetry.instrumentation.redis\",\n        \"opentelemetry.instrumentation.requests\",\n    ]\n    DEFAULT_INSTRUMENTATIONS = cast(\n        List[DefaultInstrumentation], list(get_args(DefaultInstrumentation))\n    )\n\n    def __init__(self, options: Options | None = None) -> None:\n        self.sources = Sources(\n            default=self.DEFAULT_CONFIG,\n            system=Config.load_from_system(),\n            initial=options or Options(),\n            environment=Config.load_from_environment(),\n        )\n        final_options = Options()\n        final_options.update(self.sources[\"default\"])\n        final_options.update(self.sources[\"system\"])\n        final_options.update(self.sources[\"environment\"])\n        final_options.update(self.sources[\"initial\"])\n        self.options = final_options\n\n    def option(self, option: str) -> Any:\n        return self.options.get(option)\n\n    @staticmethod\n    def load_from_system() -> Options:\n        return Options(app_path=os.getcwd())\n\n    @staticmethod\n    def load_from_environment() -> Options:\n        options = Options(\n            active=parse_bool(os.environ.get(\"APPSIGNAL_ACTIVE\")),\n            bind_address=os.environ.get(\"APPSIGNAL_BIND_ADDRESS\"),\n            ca_file_path=os.environ.get(\"APPSIGNAL_CA_FILE_PATH\"),\n            diagnose_endpoint=os.environ.get(\"APPSIGNAL_DIAGNOSE_ENDPOINT\"),\n            disable_default_instrumentations=parse_disable_default_instrumentations(\n                os.environ.get(\"APPSIGNAL_DISABLE_DEFAULT_INSTRUMENTATIONS\")\n            ),\n            dns_servers=parse_list(os.environ.get(\"APPSIGNAL_DNS_SERVERS\")),\n            enable_host_metrics=parse_bool(\n                os.environ.get(\"APPSIGNAL_ENABLE_HOST_METRICS\")\n            ),\n            enable_nginx_metrics=parse_bool(\n                os.environ.get(\"APPSIGNAL_ENABLE_NGINX_METRICS\")\n            ),\n            enable_statsd=parse_bool(os.environ.get(\"APPSIGNAL_ENABLE_STATSD\")),\n            endpoint=os.environ.get(\"APPSIGNAL_PUSH_API_ENDPOINT\"),\n            environment=os.environ.get(\"APPSIGNAL_APP_ENV\"),\n            files_world_accessible=parse_bool(\n                os.environ.get(\"APPSIGNAL_FILES_WORLD_ACCESSIBLE\")\n            ),\n            filter_parameters=parse_list(os.environ.get(\"APPSIGNAL_FILTER_PARAMETERS\")),\n            filter_session_data=parse_list(\n                os.environ.get(\"APPSIGNAL_FILTER_SESSION_DATA\")\n            ),\n            hostname=os.environ.get(\"APPSIGNAL_HOSTNAME\"),\n            http_proxy=os.environ.get(\"APPSIGNAL_HTTP_PROXY\"),\n            ignore_actions=parse_list(os.environ.get(\"APPSIGNAL_IGNORE_ACTIONS\")),\n            ignore_errors=parse_list(os.environ.get(\"APPSIGNAL_IGNORE_ERRORS\")),\n            ignore_namespaces=parse_list(os.environ.get(\"APPSIGNAL_IGNORE_NAMESPACES\")),\n            log=os.environ.get(\"APPSIGNAL_LOG\"),\n            log_level=os.environ.get(\"APPSIGNAL_LOG_LEVEL\"),\n            log_path=os.environ.get(\"APPSIGNAL_LOG_PATH\"),\n            name=os.environ.get(\"APPSIGNAL_APP_NAME\"),\n            push_api_key=os.environ.get(\"APPSIGNAL_PUSH_API_KEY\"),\n            revision=os.environ.get(\"APP_REVISION\"),\n            request_headers=parse_list(os.environ.get(\"APPSIGNAL_REQUEST_HEADERS\")),\n            running_in_container=parse_bool(\n                os.environ.get(\"APPSIGNAL_RUNNING_IN_CONTAINER\")\n            ),\n            send_environment_metadata=parse_bool(\n                os.environ.get(\"APPSIGNAL_SEND_ENVIRONMENT_METADATA\")\n            ),\n            send_params=parse_bool(os.environ.get(\"APPSIGNAL_SEND_PARAMS\")),\n            send_session_data=parse_bool(os.environ.get(\"APPSIGNAL_SEND_SESSION_DATA\")),\n            working_directory_path=os.environ.get(\"APPSIGNAL_WORKING_DIRECTORY_PATH\"),\n        )\n\n        for key, value in list(options.items()):\n            if value is None:\n                del cast(dict, options)[key]\n\n        return options\n\n    CONSTANT_PRIVATE_ENVIRON: ClassVar[dict[str, str]] = {\n        \"_APPSIGNAL_LANGUAGE_INTEGRATION_VERSION\": f\"python-{__version__}\",\n        \"_APPSIGNAL_ENABLE_OPENTELEMETRY_HTTP\": \"true\",\n    }\n\n    def set_private_environ(self) -> None:\n        options = self.options\n        private_environ = {\n            \"_APPSIGNAL_ACTIVE\": bool_to_env_str(options.get(\"active\")),\n            \"_APPSIGNAL_APP_ENV\": options.get(\"environment\"),\n            \"_APPSIGNAL_APP_NAME\": options.get(\"name\"),\n            \"_APPSIGNAL_APP_PATH\": options.get(\"app_path\"),\n            \"_APPSIGNAL_BIND_ADDRESS\": options.get(\"bind_address\"),\n            \"_APPSIGNAL_CA_FILE_PATH\": options.get(\"ca_file_path\"),\n            \"_APPSIGNAL_DNS_SERVERS\": list_to_env_str(options.get(\"dns_servers\")),\n            \"_APPSIGNAL_DIAGNOSE_ENDPOINT\": options.get(\"diagnose_endpoint\"),\n            \"_APPSIGNAL_ENABLE_HOST_METRICS\": bool_to_env_str(\n                options.get(\"enable_host_metrics\")\n            ),\n            \"_APPSIGNAL_ENABLE_NGINX_METRICS\": bool_to_env_str(\n                options.get(\"enable_nginx_metrics\")\n            ),\n            \"_APPSIGNAL_ENABLE_STATSD\": bool_to_env_str(options.get(\"enable_statsd\")),\n            \"_APPSIGNAL_FILES_WORLD_ACCESSIBLE\": bool_to_env_str(\n                options.get(\"files_world_accessible\")\n            ),\n            \"_APPSIGNAL_FILTER_PARAMETERS\": list_to_env_str(\n                options.get(\"filter_parameters\")\n            ),\n            \"_APPSIGNAL_FILTER_SESSION_DATA\": list_to_env_str(\n                options.get(\"filter_session_data\")\n            ),\n            \"_APPSIGNAL_HOSTNAME\": options.get(\"hostname\"),\n            \"_APPSIGNAL_HTTP_PROXY\": options.get(\"http_proxy\"),\n            \"_APPSIGNAL_IGNORE_ACTIONS\": list_to_env_str(options.get(\"ignore_actions\")),\n            \"_APPSIGNAL_IGNORE_ERRORS\": list_to_env_str(options.get(\"ignore_errors\")),\n            \"_APPSIGNAL_IGNORE_NAMESPACES\": list_to_env_str(\n                options.get(\"ignore_namespaces\")\n            ),\n            \"_APPSIGNAL_LOG\": options.get(\"log\"),\n            \"_APPSIGNAL_LOG_LEVEL\": options.get(\"log_level\"),\n            \"_APPSIGNAL_LOG_FILE_PATH\": self.log_file_path(),\n            \"_APPSIGNAL_PUSH_API_KEY\": options.get(\"push_api_key\"),\n            \"_APPSIGNAL_PUSH_API_ENDPOINT\": options.get(\"endpoint\"),\n            \"_APPSIGNAL_RUNNING_IN_CONTAINER\": bool_to_env_str(\n                options.get(\"running_in_container\")\n            ),\n            \"_APPSIGNAL_SEND_ENVIRONMENT_METADATA\": bool_to_env_str(\n                options.get(\"send_environment_metadata\")\n            ),\n            \"_APPSIGNAL_SEND_PARAMS\": bool_to_env_str(options.get(\"send_params\")),\n            \"_APPSIGNAL_SEND_SESSION_DATA\": bool_to_env_str(\n                options.get(\"send_session_data\")\n            ),\n            \"_APPSIGNAL_WORKING_DIRECTORY_PATH\": options.get(\"working_directory_path\"),\n            \"_APP_REVISION\": options.get(\"revision\"),\n        }\n        private_environ.update(self.CONSTANT_PRIVATE_ENVIRON)\n\n        for var, value in private_environ.items():\n            if value is not None:\n                os.environ[var] = str(value)\n\n    def log_file_path(self) -> str | None:\n        path = self.options.get(\"log_path\")\n\n        if path:\n            _, ext = os.path.splitext(path)\n            if ext:\n                path = os.path.dirname(path)\n\n            if not os.access(path, os.W_OK):\n                print(\n                    f\"appsignal: Unable to write to configured '{path}'. Please \"\n                    \"check the permissions of the 'log_path' directory.\"\n                )\n                path = None\n\n        if not path:\n            path = \"/tmp\" if platform.system() == \"Darwin\" else tempfile.gettempdir()\n\n        if not os.access(path, os.W_OK):\n            print(\n                f\"appsignal: Unable to write to '{path}'. Please check the \"\n                \"permissions of the 'log_path' directory.\"\n            )\n            return None\n        return os.path.join(path, \"appsignal.log\")", "\nclass Config:\n    sources: Sources\n\n    CA_FILE_PATH = os.path.join(\n        os.path.dirname(os.path.abspath(__file__)), \"resources\", \"cacert.pem\"\n    )\n    DEFAULT_CONFIG = Options(\n        ca_file_path=CA_FILE_PATH,\n        diagnose_endpoint=\"https://appsignal.com/diag\",\n        enable_host_metrics=True,\n        enable_nginx_metrics=False,\n        enable_statsd=False,\n        environment=\"development\",\n        endpoint=\"https://push.appsignal.com\",\n        files_world_accessible=True,\n        log=\"file\",\n        log_level=\"info\",\n        send_environment_metadata=True,\n        send_params=True,\n        send_session_data=True,\n        request_headers=[\n            \"accept\",\n            \"accept-charset\",\n            \"accept-encoding\",\n            \"accept-language\",\n            \"cache-control\",\n            \"connection\",\n            \"content-length\",\n            \"range\",\n        ],\n    )\n\n    DefaultInstrumentation = Literal[\n        \"opentelemetry.instrumentation.celery\",\n        \"opentelemetry.instrumentation.django\",\n        \"opentelemetry.instrumentation.flask\",\n        \"opentelemetry.instrumentation.jinja2\",\n        \"opentelemetry.instrumentation.psycopg2\",\n        \"opentelemetry.instrumentation.redis\",\n        \"opentelemetry.instrumentation.requests\",\n    ]\n    DEFAULT_INSTRUMENTATIONS = cast(\n        List[DefaultInstrumentation], list(get_args(DefaultInstrumentation))\n    )\n\n    def __init__(self, options: Options | None = None) -> None:\n        self.sources = Sources(\n            default=self.DEFAULT_CONFIG,\n            system=Config.load_from_system(),\n            initial=options or Options(),\n            environment=Config.load_from_environment(),\n        )\n        final_options = Options()\n        final_options.update(self.sources[\"default\"])\n        final_options.update(self.sources[\"system\"])\n        final_options.update(self.sources[\"environment\"])\n        final_options.update(self.sources[\"initial\"])\n        self.options = final_options\n\n    def option(self, option: str) -> Any:\n        return self.options.get(option)\n\n    @staticmethod\n    def load_from_system() -> Options:\n        return Options(app_path=os.getcwd())\n\n    @staticmethod\n    def load_from_environment() -> Options:\n        options = Options(\n            active=parse_bool(os.environ.get(\"APPSIGNAL_ACTIVE\")),\n            bind_address=os.environ.get(\"APPSIGNAL_BIND_ADDRESS\"),\n            ca_file_path=os.environ.get(\"APPSIGNAL_CA_FILE_PATH\"),\n            diagnose_endpoint=os.environ.get(\"APPSIGNAL_DIAGNOSE_ENDPOINT\"),\n            disable_default_instrumentations=parse_disable_default_instrumentations(\n                os.environ.get(\"APPSIGNAL_DISABLE_DEFAULT_INSTRUMENTATIONS\")\n            ),\n            dns_servers=parse_list(os.environ.get(\"APPSIGNAL_DNS_SERVERS\")),\n            enable_host_metrics=parse_bool(\n                os.environ.get(\"APPSIGNAL_ENABLE_HOST_METRICS\")\n            ),\n            enable_nginx_metrics=parse_bool(\n                os.environ.get(\"APPSIGNAL_ENABLE_NGINX_METRICS\")\n            ),\n            enable_statsd=parse_bool(os.environ.get(\"APPSIGNAL_ENABLE_STATSD\")),\n            endpoint=os.environ.get(\"APPSIGNAL_PUSH_API_ENDPOINT\"),\n            environment=os.environ.get(\"APPSIGNAL_APP_ENV\"),\n            files_world_accessible=parse_bool(\n                os.environ.get(\"APPSIGNAL_FILES_WORLD_ACCESSIBLE\")\n            ),\n            filter_parameters=parse_list(os.environ.get(\"APPSIGNAL_FILTER_PARAMETERS\")),\n            filter_session_data=parse_list(\n                os.environ.get(\"APPSIGNAL_FILTER_SESSION_DATA\")\n            ),\n            hostname=os.environ.get(\"APPSIGNAL_HOSTNAME\"),\n            http_proxy=os.environ.get(\"APPSIGNAL_HTTP_PROXY\"),\n            ignore_actions=parse_list(os.environ.get(\"APPSIGNAL_IGNORE_ACTIONS\")),\n            ignore_errors=parse_list(os.environ.get(\"APPSIGNAL_IGNORE_ERRORS\")),\n            ignore_namespaces=parse_list(os.environ.get(\"APPSIGNAL_IGNORE_NAMESPACES\")),\n            log=os.environ.get(\"APPSIGNAL_LOG\"),\n            log_level=os.environ.get(\"APPSIGNAL_LOG_LEVEL\"),\n            log_path=os.environ.get(\"APPSIGNAL_LOG_PATH\"),\n            name=os.environ.get(\"APPSIGNAL_APP_NAME\"),\n            push_api_key=os.environ.get(\"APPSIGNAL_PUSH_API_KEY\"),\n            revision=os.environ.get(\"APP_REVISION\"),\n            request_headers=parse_list(os.environ.get(\"APPSIGNAL_REQUEST_HEADERS\")),\n            running_in_container=parse_bool(\n                os.environ.get(\"APPSIGNAL_RUNNING_IN_CONTAINER\")\n            ),\n            send_environment_metadata=parse_bool(\n                os.environ.get(\"APPSIGNAL_SEND_ENVIRONMENT_METADATA\")\n            ),\n            send_params=parse_bool(os.environ.get(\"APPSIGNAL_SEND_PARAMS\")),\n            send_session_data=parse_bool(os.environ.get(\"APPSIGNAL_SEND_SESSION_DATA\")),\n            working_directory_path=os.environ.get(\"APPSIGNAL_WORKING_DIRECTORY_PATH\"),\n        )\n\n        for key, value in list(options.items()):\n            if value is None:\n                del cast(dict, options)[key]\n\n        return options\n\n    CONSTANT_PRIVATE_ENVIRON: ClassVar[dict[str, str]] = {\n        \"_APPSIGNAL_LANGUAGE_INTEGRATION_VERSION\": f\"python-{__version__}\",\n        \"_APPSIGNAL_ENABLE_OPENTELEMETRY_HTTP\": \"true\",\n    }\n\n    def set_private_environ(self) -> None:\n        options = self.options\n        private_environ = {\n            \"_APPSIGNAL_ACTIVE\": bool_to_env_str(options.get(\"active\")),\n            \"_APPSIGNAL_APP_ENV\": options.get(\"environment\"),\n            \"_APPSIGNAL_APP_NAME\": options.get(\"name\"),\n            \"_APPSIGNAL_APP_PATH\": options.get(\"app_path\"),\n            \"_APPSIGNAL_BIND_ADDRESS\": options.get(\"bind_address\"),\n            \"_APPSIGNAL_CA_FILE_PATH\": options.get(\"ca_file_path\"),\n            \"_APPSIGNAL_DNS_SERVERS\": list_to_env_str(options.get(\"dns_servers\")),\n            \"_APPSIGNAL_DIAGNOSE_ENDPOINT\": options.get(\"diagnose_endpoint\"),\n            \"_APPSIGNAL_ENABLE_HOST_METRICS\": bool_to_env_str(\n                options.get(\"enable_host_metrics\")\n            ),\n            \"_APPSIGNAL_ENABLE_NGINX_METRICS\": bool_to_env_str(\n                options.get(\"enable_nginx_metrics\")\n            ),\n            \"_APPSIGNAL_ENABLE_STATSD\": bool_to_env_str(options.get(\"enable_statsd\")),\n            \"_APPSIGNAL_FILES_WORLD_ACCESSIBLE\": bool_to_env_str(\n                options.get(\"files_world_accessible\")\n            ),\n            \"_APPSIGNAL_FILTER_PARAMETERS\": list_to_env_str(\n                options.get(\"filter_parameters\")\n            ),\n            \"_APPSIGNAL_FILTER_SESSION_DATA\": list_to_env_str(\n                options.get(\"filter_session_data\")\n            ),\n            \"_APPSIGNAL_HOSTNAME\": options.get(\"hostname\"),\n            \"_APPSIGNAL_HTTP_PROXY\": options.get(\"http_proxy\"),\n            \"_APPSIGNAL_IGNORE_ACTIONS\": list_to_env_str(options.get(\"ignore_actions\")),\n            \"_APPSIGNAL_IGNORE_ERRORS\": list_to_env_str(options.get(\"ignore_errors\")),\n            \"_APPSIGNAL_IGNORE_NAMESPACES\": list_to_env_str(\n                options.get(\"ignore_namespaces\")\n            ),\n            \"_APPSIGNAL_LOG\": options.get(\"log\"),\n            \"_APPSIGNAL_LOG_LEVEL\": options.get(\"log_level\"),\n            \"_APPSIGNAL_LOG_FILE_PATH\": self.log_file_path(),\n            \"_APPSIGNAL_PUSH_API_KEY\": options.get(\"push_api_key\"),\n            \"_APPSIGNAL_PUSH_API_ENDPOINT\": options.get(\"endpoint\"),\n            \"_APPSIGNAL_RUNNING_IN_CONTAINER\": bool_to_env_str(\n                options.get(\"running_in_container\")\n            ),\n            \"_APPSIGNAL_SEND_ENVIRONMENT_METADATA\": bool_to_env_str(\n                options.get(\"send_environment_metadata\")\n            ),\n            \"_APPSIGNAL_SEND_PARAMS\": bool_to_env_str(options.get(\"send_params\")),\n            \"_APPSIGNAL_SEND_SESSION_DATA\": bool_to_env_str(\n                options.get(\"send_session_data\")\n            ),\n            \"_APPSIGNAL_WORKING_DIRECTORY_PATH\": options.get(\"working_directory_path\"),\n            \"_APP_REVISION\": options.get(\"revision\"),\n        }\n        private_environ.update(self.CONSTANT_PRIVATE_ENVIRON)\n\n        for var, value in private_environ.items():\n            if value is not None:\n                os.environ[var] = str(value)\n\n    def log_file_path(self) -> str | None:\n        path = self.options.get(\"log_path\")\n\n        if path:\n            _, ext = os.path.splitext(path)\n            if ext:\n                path = os.path.dirname(path)\n\n            if not os.access(path, os.W_OK):\n                print(\n                    f\"appsignal: Unable to write to configured '{path}'. Please \"\n                    \"check the permissions of the 'log_path' directory.\"\n                )\n                path = None\n\n        if not path:\n            path = \"/tmp\" if platform.system() == \"Darwin\" else tempfile.gettempdir()\n\n        if not os.access(path, os.W_OK):\n            print(\n                f\"appsignal: Unable to write to '{path}'. Please check the \"\n                \"permissions of the 'log_path' directory.\"\n            )\n            return None\n        return os.path.join(path, \"appsignal.log\")", "\n\ndef parse_bool(value: str | None) -> bool | None:\n    if value is None:\n        return None\n\n    val = value.lower()\n    if val == \"true\":\n        return True\n    if val == \"false\":\n        return False\n\n    return None", "\n\ndef parse_list(value: str | None) -> list[str] | None:\n    if value is None:\n        return None\n\n    return value.split(\",\")\n\n\ndef parse_disable_default_instrumentations(\n    value: str | None,\n) -> list[Config.DefaultInstrumentation] | bool | None:\n    if value is None:\n        return None\n\n    if value.lower() == \"true\":\n        return True\n    if value.lower() == \"false\":\n        return False\n\n    return cast(\n        List[Config.DefaultInstrumentation],\n        [x for x in value.split(\",\") if x in Config.DEFAULT_INSTRUMENTATIONS],\n    )", "\ndef parse_disable_default_instrumentations(\n    value: str | None,\n) -> list[Config.DefaultInstrumentation] | bool | None:\n    if value is None:\n        return None\n\n    if value.lower() == \"true\":\n        return True\n    if value.lower() == \"false\":\n        return False\n\n    return cast(\n        List[Config.DefaultInstrumentation],\n        [x for x in value.split(\",\") if x in Config.DEFAULT_INSTRUMENTATIONS],\n    )", "\n\ndef bool_to_env_str(value: bool | None) -> str | None:\n    if value is None:\n        return None\n\n    return str(value).lower()\n\n\ndef list_to_env_str(value: list[str] | None) -> str | None:\n    if value is None:\n        return None\n\n    return \",\".join(value)", "\ndef list_to_env_str(value: list[str] | None) -> str | None:\n    if value is None:\n        return None\n\n    return \",\".join(value)\n"]}
{"filename": "src/appsignal/client.py", "chunked_list": ["from __future__ import annotations\n\nimport logging\nimport sys\nfrom logging import DEBUG, ERROR, INFO, WARNING, Logger\nfrom typing import TYPE_CHECKING, ClassVar\n\nfrom .agent import agent\nfrom .config import Config, Options\nfrom .opentelemetry import start_opentelemetry", "from .config import Config, Options\nfrom .opentelemetry import start_opentelemetry\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Unpack\n\n\nclass Client:\n    _logger: Logger\n    _config: Config\n\n    LOG_LEVELS: ClassVar[dict[str, int]] = {\n        \"error\": ERROR,\n        \"warning\": WARNING,\n        \"info\": INFO,\n        \"debug\": DEBUG,\n        \"trace\": DEBUG,\n    }\n\n    def __init__(self, **options: Unpack[Options]) -> None:\n        self._config = Config(options)\n        self.start_logger()\n\n        if not self._config.option(\"active\"):\n            self._logger.info(\"AppSignal not starting: no active config found\")\n\n    def start(self) -> None:\n        if self._config.option(\"active\"):\n            self._logger.info(\"Starting AppSignal\")\n            agent.start(self._config)\n            start_opentelemetry(self._config)\n\n    def start_logger(self) -> None:\n        self._logger = logging.getLogger(\"appsignal\")\n        self._logger.setLevel(self.LOG_LEVELS[self._config.option(\"log_level\")])\n\n        if self._config.option(\"log\") == \"file\":\n            log_file_path = self._config.log_file_path()\n            if log_file_path:\n                handler = logging.FileHandler(log_file_path)\n                handler.setFormatter(\n                    logging.Formatter(\n                        \"[%(asctime)s (process) #%(process)d][%(levelname)s] \"\n                        \"%(message)s\",\n                        \"%Y-%m-%dT%H:%M:%S\",\n                    )\n                )\n                self._logger.addHandler(handler)\n            else:\n                self._start_stdout_logger()\n        else:\n            self._start_stdout_logger()\n\n    def _start_stdout_logger(self) -> None:\n        handler = logging.StreamHandler(sys.stdout)\n        handler.setFormatter(\n            logging.Formatter(\n                \"[%(asctime)s (process) #%(process)d][appsignal][%(levelname)s] \"\n                \"%(message)s\",\n                \"%Y-%m-%dT%H:%M:%S\",\n            )\n        )\n        self._logger.addHandler(handler)", "class Client:\n    _logger: Logger\n    _config: Config\n\n    LOG_LEVELS: ClassVar[dict[str, int]] = {\n        \"error\": ERROR,\n        \"warning\": WARNING,\n        \"info\": INFO,\n        \"debug\": DEBUG,\n        \"trace\": DEBUG,\n    }\n\n    def __init__(self, **options: Unpack[Options]) -> None:\n        self._config = Config(options)\n        self.start_logger()\n\n        if not self._config.option(\"active\"):\n            self._logger.info(\"AppSignal not starting: no active config found\")\n\n    def start(self) -> None:\n        if self._config.option(\"active\"):\n            self._logger.info(\"Starting AppSignal\")\n            agent.start(self._config)\n            start_opentelemetry(self._config)\n\n    def start_logger(self) -> None:\n        self._logger = logging.getLogger(\"appsignal\")\n        self._logger.setLevel(self.LOG_LEVELS[self._config.option(\"log_level\")])\n\n        if self._config.option(\"log\") == \"file\":\n            log_file_path = self._config.log_file_path()\n            if log_file_path:\n                handler = logging.FileHandler(log_file_path)\n                handler.setFormatter(\n                    logging.Formatter(\n                        \"[%(asctime)s (process) #%(process)d][%(levelname)s] \"\n                        \"%(message)s\",\n                        \"%Y-%m-%dT%H:%M:%S\",\n                    )\n                )\n                self._logger.addHandler(handler)\n            else:\n                self._start_stdout_logger()\n        else:\n            self._start_stdout_logger()\n\n    def _start_stdout_logger(self) -> None:\n        handler = logging.StreamHandler(sys.stdout)\n        handler.setFormatter(\n            logging.Formatter(\n                \"[%(asctime)s (process) #%(process)d][appsignal][%(levelname)s] \"\n                \"%(message)s\",\n                \"%Y-%m-%dT%H:%M:%S\",\n            )\n        )\n        self._logger.addHandler(handler)", ""]}
{"filename": "src/appsignal/__init__.py", "chunked_list": ["from .client import Client as Appsignal\n\n\n__all__ = [\"Appsignal\"]\n\n# Try and load the appsignal-beta package. If it's present and imported, it\n# will print a message about switching to the `appsignal` package.\ntry:\n    import appsignal_beta  # type:ignore # noqa: F401\nexcept ImportError:\n    pass", ""]}
{"filename": "src/appsignal/push_api_key_validator.py", "chunked_list": ["import urllib\n\nimport requests\n\nfrom appsignal.config import Config\n\n\nclass PushApiKeyValidator:\n    @staticmethod\n    def validate(config: Config) -> str:\n        endpoint = config.option(\"endpoint\")\n        params = urllib.parse.urlencode(\n            {\n                \"api_key\": config.option(\"push_api_key\"),\n                \"name\": config.option(\"name\"),\n                \"environment\": config.option(\"environment\"),\n                \"hostname\": config.option(\"hostname\") or \"\",\n            }\n        )\n\n        url = f\"{endpoint}/1/auth?{params}\"\n        proxies = {}\n        if config.option(\"http_proxy\"):\n            proxies[\"http\"] = config.option(\"http_proxy\")\n            proxies[\"https\"] = config.option(\"http_proxy\")\n\n        cert = config.option(\"ca_file_path\")\n        response = requests.post(url, proxies=proxies, verify=cert)\n\n        if response.status_code == 200:\n            return \"valid\"\n        if response.status_code == 401:\n            return \"invalid\"\n        return str(response.status_code)", ""]}
{"filename": "src/appsignal/__about__.py", "chunked_list": ["from __future__ import annotations\n\n\n__version__ = \"0.2.1\"\n"]}
{"filename": "src/appsignal/cli/version.py", "chunked_list": ["from __future__ import annotations\n\nfrom argparse import ArgumentParser\n\nfrom ..__about__ import __version__\nfrom .command import AppsignalCLICommand\n\n\nclass VersionCommand(AppsignalCLICommand):\n    \"\"\"Show the SDK version and exit.\"\"\"\n\n    @staticmethod\n    def init_parser(parser: ArgumentParser) -> None:\n        pass\n\n    def run(self) -> int:\n        print(__version__)\n        return 0", "class VersionCommand(AppsignalCLICommand):\n    \"\"\"Show the SDK version and exit.\"\"\"\n\n    @staticmethod\n    def init_parser(parser: ArgumentParser) -> None:\n        pass\n\n    def run(self) -> int:\n        print(__version__)\n        return 0", ""]}
{"filename": "src/appsignal/cli/base.py", "chunked_list": ["from __future__ import annotations\n\nimport sys\nfrom argparse import ArgumentParser\nfrom typing import Mapping, NoReturn\n\nfrom .command import AppsignalCLICommand\nfrom .demo import DemoCommand\nfrom .diagnose import DiagnoseCommand\nfrom .install import InstallCommand", "from .diagnose import DiagnoseCommand\nfrom .install import InstallCommand\nfrom .version import VersionCommand\n\n\nCOMMANDS: Mapping[str, type[AppsignalCLICommand]] = {\n    \"demo\": DemoCommand,\n    \"install\": InstallCommand,\n    \"version\": VersionCommand,\n    \"diagnose\": DiagnoseCommand,", "    \"version\": VersionCommand,\n    \"diagnose\": DiagnoseCommand,\n}\n\n\ndef run() -> NoReturn:\n    \"\"\"The entry point for CLI.\"\"\"\n    sys.exit(main(sys.argv[1:]))\n\n\ndef main(argv: list[str]) -> int:\n    parser = ArgumentParser(\"appsignal\", description=\"AppSignal for Python CLI.\")\n    _register_commands(parser)\n    args = parser.parse_args(argv)\n    cmd_class: type[AppsignalCLICommand] | None\n    cmd_class = args.cmd\n    if cmd_class is None:\n        parser.print_help()\n        return 1\n    cmd = cmd_class(args=args)\n    try:\n        return cmd.run()\n    except KeyboardInterrupt:\n        return 0", "\n\ndef main(argv: list[str]) -> int:\n    parser = ArgumentParser(\"appsignal\", description=\"AppSignal for Python CLI.\")\n    _register_commands(parser)\n    args = parser.parse_args(argv)\n    cmd_class: type[AppsignalCLICommand] | None\n    cmd_class = args.cmd\n    if cmd_class is None:\n        parser.print_help()\n        return 1\n    cmd = cmd_class(args=args)\n    try:\n        return cmd.run()\n    except KeyboardInterrupt:\n        return 0", "\n\ndef _register_commands(parser: ArgumentParser) -> None:\n    subparsers = parser.add_subparsers()\n    parser.set_defaults(cmd=None)\n    cmd_class: type[AppsignalCLICommand]\n    for name, cmd_class in COMMANDS.items():\n        subparser = subparsers.add_parser(name=name, help=cmd_class.__doc__)\n        subparser.set_defaults(cmd=cmd_class)\n        cmd_class.init_parser(subparser)", ""]}
{"filename": "src/appsignal/cli/diagnose.py", "chunked_list": ["# ruff: noqa: E501\n\nfrom __future__ import annotations\n\nimport json\nimport os\nimport platform\nimport urllib\nfrom argparse import ArgumentParser\nfrom typing import Any", "from argparse import ArgumentParser\nfrom typing import Any\n\nimport requests\n\nfrom appsignal.agent import Agent\nfrom appsignal.config import Config\nfrom appsignal.push_api_key_validator import PushApiKeyValidator\n\nfrom ..__about__ import __version__", "\nfrom ..__about__ import __version__\nfrom .command import AppsignalCLICommand\n\n\nclass AgentReport:\n    def __init__(self, report: dict) -> None:\n        self.report = report\n\n    def configuration_valid(self) -> str:\n        if self.report[\"config\"][\"valid\"][\"result\"]:\n            return \"valid\"\n        return \"invalid\"\n\n    def configuration_error(self) -> str | None:\n        if self.configuration_valid() == \"invalid\":\n            return self.report[\"config\"][\"valid\"][\"error\"]\n        return None\n\n    def started(self) -> str:\n        if self.report[\"boot\"][\"started\"][\"result\"]:\n            return \"started\"\n        return \"not started\"\n\n    def user_id(self) -> str:\n        return self.report[\"host\"][\"uid\"][\"result\"]\n\n    def group_id(self) -> str:\n        return self.report[\"host\"][\"gid\"][\"result\"]\n\n    def logger_started(self) -> str:\n        if \"logger\" in self.report:\n            if self.report[\"logger\"][\"started\"][\"result\"]:\n                return \"started\"\n            return \"not started\"\n        return \"-\"\n\n    def working_directory_user_id(self) -> str:\n        if \"working_directory_stat\" in self.report:\n            return self.report[\"working_directory_stat\"][\"uid\"][\"result\"]\n        return \"-\"\n\n    def working_directory_group_id(self) -> str:\n        if \"working_directory_stat\" in self.report:\n            return self.report[\"working_directory_stat\"][\"gid\"][\"result\"]\n        return \"-\"\n\n    def working_directory_permissions(self) -> str:\n        if \"working_directory_stat\" in self.report:\n            return self.report[\"working_directory_stat\"][\"mode\"][\"result\"]\n        return \"-\"\n\n    def lock_path(self) -> str:\n        if \"lock_path\" in self.report:\n            if self.report[\"lock_path\"][\"created\"][\"result\"]:\n                return \"writable\"\n            return \"not writable\"\n        return \"-\"", "\n\nclass DiagnoseCommand(AppsignalCLICommand):\n    @staticmethod\n    def init_parser(parser: ArgumentParser) -> None:\n        parser.add_argument(\n            \"--send-report\",\n            action=\"store_true\",\n            help=\"Send the report to AppSignal\",\n        )\n        parser.add_argument(\n            \"--no-send-report\",\n            action=\"store_true\",\n            help=\"Do not send the report to AppSignal\",\n        )\n\n    def run(self) -> int:\n        self.send_report = self.args.send_report\n        self.no_send_report = self.args.no_send_report\n\n        if self.send_report and self.no_send_report:\n            print(\"Error: Cannot use --send-report and --no-send-report together.\")\n            return 1\n\n        agent = Agent()\n        agent_json = json.loads(agent.diagnose())\n        self.config = Config()\n        self.agent_report = AgentReport(agent_json)\n\n        self.report = {\n            \"agent\": {\n                \"agent\": {\n                    \"boot\": agent_json[\"boot\"],\n                    \"config\": {\n                        \"valid\": agent_json[\"config\"][\"valid\"],\n                    },\n                    \"host\": agent_json[\"host\"],\n                    \"lock_path\": agent_json.get(\"lock_path\"),\n                    \"logger\": agent_json.get(\"logger\"),\n                    \"working_directory_stat\": agent_json.get(\"working_directory_stat\"),\n                }\n            },\n            \"config\": {\n                \"options\": self.config.options,\n                \"sources\": self.config.sources,\n            },\n            \"host\": {\n                \"architecture\": platform.machine(),\n                \"heroku\": os.environ.get(\"DYNO\") is not None,\n                \"language_version\": platform.python_version(),\n                \"os\": platform.system().lower(),\n                \"os_distribution\": self._os_distribution(),\n                \"root\": os.getuid() == 0,\n            },\n            \"library\": {\n                \"language\": \"python\",\n                \"package_version\": __version__,\n                \"agent_version\": str(agent.version(), \"utf-8\"),\n            },\n            \"paths\": self._paths_data(),\n            \"process\": {\n                \"uid\": os.getuid(),\n            },\n            \"validation\": {\"push_api_key\": self._validate_push_api_key()},\n        }\n\n        self._header()\n        print()\n\n        self._library_information()\n        print()\n\n        self._host_information()\n        print()\n\n        self._agent_information()\n        print()\n\n        self._configuration_information()\n        print()\n\n        self._validation_information()\n        print()\n\n        self._paths_information()\n        print()\n\n        self._report_information()\n\n        if self.send_report or (not self.no_send_report and self._report_prompt()):\n            self._send_diagnose_report()\n        elif self.no_send_report:\n            print(\"Not sending report. (Specified with the --no-send-report option.)\")\n\n        return 0\n\n    def _header(self) -> None:\n        print(\"AppSignal diagnose\")\n        print(\"=\" * 80)\n        print(\"Use this information to debug your configuration.\")\n        print(\"More information is available on the documentation site.\")\n        print(\"https://docs.appsignal.com/\")\n        print(\"Send this output to support@appsignal.com if you need help.\")\n        print(\"=\" * 80)\n\n    def _library_information(self) -> None:\n        library_report: Any = self.report[\"library\"]\n        print(\"AppSignal library\")\n        print(\"  Language: Python\")\n        print(f'  Package version: \"{library_report[\"package_version\"]}\"')\n        print(f'  Agent version: \"{library_report[\"agent_version\"]}\"')\n\n    def _host_information(self) -> None:\n        host_report: Any = self.report[\"host\"]\n        print(\"Host information\")\n        print(f'  Architecture: \"{host_report[\"architecture\"]}\"')\n        print(f'  Operating System: \"{host_report[\"os\"]}\"')\n        print(f'  Python version: \"{host_report[\"language_version\"]}\"')\n        print(f'  Root user: {host_report[\"root\"]}')\n\n    def _agent_information(self) -> None:\n        print(\"Agent diagnostics\")\n        print(\"  Agent tests\")\n        print(f\"    Started: {self.agent_report.started()}\")\n        print(f\"    Process user id: {self.agent_report.user_id()}\")\n        print(f\"    Process user group id: {self.agent_report.group_id()}\")\n        print(f\"    Configuration: {self.agent_report.configuration_valid()}\")\n        if self.agent_report.configuration_error():\n            print(f\"        Error: {self.agent_report.configuration_error()}\")\n        print(f\"    Logger: {self.agent_report.logger_started()}\")\n        print(\n            f\"    Working directory user id: {self.agent_report.working_directory_user_id()}\"\n        )\n        print(\n            f\"    Working directory user group id: {self.agent_report.working_directory_group_id()}\"\n        )\n        print(\n            f\"    Working directory permissions: {self.agent_report.working_directory_permissions()}\"\n        )\n        print(f\"    Lock path: {self.agent_report.lock_path()}\")\n\n    def _configuration_information(self) -> None:\n        print(\"Configuration\")\n\n        for key in self.config.options:\n            print(f\"  {key}: {self.config.options[key]!r}\")  # type: ignore\n\n        print()\n        print(\"Read more about how the diagnose config output is rendered\")\n        print(\"https://docs.appsignal.com/python/command-line/diagnose.html\")\n\n    def _validation_information(self) -> None:\n        validation_report: Any = self.report[\"validation\"]\n        print(\"Validation\")\n        print(f'  Validating Push API key: {validation_report[\"push_api_key\"]}')\n\n    def _paths_information(self) -> None:\n        log_file_path = self.config.log_file_path() or \"\"\n        log_path = self.config.option(\"log_path\") or os.path.dirname(log_file_path)\n        log_file_lines = self._last_ten_lines(log_file_path)\n\n        print(\"Paths\")\n        print(\"  Current working directory\")\n        print(f\"    Path: '{os.getcwd()}'\")\n        print()\n        print(\"  Log directory\")\n        print(f\"    Path: '{log_path}'\")\n        print()\n        print(\"  AppSignal log\")\n        print(f\"    Path: '{log_file_path}'\")\n\n        print(\"    Contents (last 10 lines):\")\n        for line in log_file_lines:\n            print(line.strip())\n\n    def _report_information(self) -> None:\n        print(\"Diagnostics report\")\n\n    def _report_prompt(self) -> bool | None:\n        print(\"  Do you want to send this diagnostics report to AppSignal?\")\n        print(\"  If you share this report you will be given a link to\")\n        print(\"  AppSignal.com to validate the report.\")\n        print(\"  You can also contact us at support@appsignal.com\")\n        print(\"  with your support token.\")\n        print()\n\n        send_report = input(\"  Send diagnostics report to AppSignal? (Y/n):   \").lower()\n\n        if send_report in [\"y\", \"yes\", \"\"]:\n            print(\"Transmitting diagnostics report\")\n            return True\n        if send_report in [\"n\", \"no\"]:\n            print(\"Not sending diagnostics information to AppSignal.\")\n            return False\n        self._report_prompt()\n        return None\n\n    def _send_diagnose_report(self) -> None:\n        params = urllib.parse.urlencode(\n            {\n                \"api_key\": self.config.option(\"push_api_key\"),\n                \"name\": self.config.option(\"name\"),\n                \"environment\": self.config.option(\"environment\"),\n                \"hostname\": self.config.option(\"hostname\") or \"\",\n            }\n        )\n\n        endpoint = self.config.option(\"diagnose_endpoint\")\n        url = f\"{endpoint}?{params}\"\n\n        response = requests.post(url, json={\"diagnose\": self.report})\n\n        status = response.status_code\n        if status == 200:\n            token = response.json()[\"token\"]\n            print()\n            print(f\"  Your support token: {token}\")\n            print(f\"  View this report:   https://appsignal.com/diagnose/{token}\")\n        else:\n            print(\n                \"  Error: Something went wrong while submitting the report to AppSignal.\"\n            )\n            print(f\"  Response code: {status}\")\n            print(f\"  Response body: {response.text}\")\n\n    def _paths_data(self) -> dict:\n        working_dir = os.getcwd() or \"\"\n        log_file_path = self.config.log_file_path() or \"\"\n        log_path = self.config.option(\"log_path\") or os.path.dirname(log_file_path)\n        log_file_lines = self._read_last_two_mib(log_file_path)\n\n        return {\n            \"appsignal.log\": {\n                \"content\": log_file_lines,\n                \"exists\": os.path.exists(log_file_path),\n                \"mode\": self._file_stat(log_file_path).get(\"mode\"),\n                \"ownership\": self._file_stat(log_file_path).get(\"ownership\"),\n                \"path\": log_file_path,\n                \"type\": self._file_type(log_file_path),\n                \"writable\": self._file_is_writable(log_file_path),\n            },\n            \"log_dir_path\": {\n                \"exists\": os.path.exists(log_path),\n                \"mode\": self._file_stat(log_path).get(\"mode\"),\n                \"ownership\": self._file_stat(log_path).get(\"ownership\"),\n                \"path\": log_path,\n                \"type\": self._file_type(log_path),\n                \"writable\": self._file_is_writable(log_path),\n            },\n            \"working_dir\": {\n                \"exists\": os.path.exists(working_dir),\n                \"mode\": self._file_stat(working_dir).get(\"mode\"),\n                \"ownership\": self._file_stat(working_dir).get(\"ownership\"),\n                \"path\": working_dir,\n                \"type\": self._file_type(working_dir),\n                \"writable\": self._file_is_writable(working_dir),\n            },\n        }\n\n    def _file_stat(self, path: str) -> dict:\n        try:\n            file_stat = os.stat(path)\n            return {\n                \"mode\": str(file_stat.st_mode),\n                \"ownership\": {\n                    \"gid\": file_stat.st_gid,\n                    \"uid\": file_stat.st_uid,\n                },\n            }\n        except FileNotFoundError:\n            return {}\n\n    def _file_type(self, path: str) -> str:\n        if os.path.exists(path):\n            if os.path.isfile(path):\n                return \"file\"\n            if os.path.isdir(path):\n                return \"directory\"\n        return \"\"\n\n    def _file_is_writable(self, path: str) -> bool:\n        return os.access(path, os.W_OK)\n\n    def _os_distribution(self) -> str:\n        try:\n            return platform.freedesktop_os_release()[\"NAME\"]\n        # The platform.freedesktop_os_release is not available in all Python\n        # versions that we support. That's why we catch AttributeError along with\n        # OSError which is thrown when the host OS doesn't comply with freedesktop.\n        except (OSError, AttributeError):\n            return \"\"\n\n    def _validate_push_api_key(self) -> str:\n        api_key_validation = PushApiKeyValidator.validate(self.config)\n\n        if api_key_validation == \"valid\":\n            return \"valid\"\n        if api_key_validation == \"invalid\":\n            return \"invalid\"\n        return f\"Failed to validate: {api_key_validation}\"\n\n    def _last_ten_lines(self, file_path: str) -> list[str]:\n        try:\n            file_contents = self._read_last_two_mib(file_path)\n            lines = file_contents.splitlines()\n            file_lines = lines[-10:] if len(lines) > 10 else lines\n            file_lines = [line.strip() for line in file_lines]\n        except FileNotFoundError:\n            file_lines = [\"\"]\n        return file_lines\n\n    def _read_last_two_mib(self, path: str) -> str:\n        two_mib = 2 * 1024 * 1024\n        file_size = os.path.getsize(path)\n        with open(path, \"rb\") as file:\n            bytes_to_read = two_mib if two_mib < file_size else file_size\n            file.seek(-bytes_to_read, os.SEEK_END)\n            return file.read().decode(\"utf-8\")", ""]}
{"filename": "src/appsignal/cli/__init__.py", "chunked_list": [""]}
{"filename": "src/appsignal/cli/demo.py", "chunked_list": ["from __future__ import annotations\n\nimport json\n\nfrom opentelemetry import trace\n\nfrom appsignal.client import Client\n\nfrom .command import AppsignalCLICommand\n", "from .command import AppsignalCLICommand\n\n\nclass DemoCommand(AppsignalCLICommand):\n    \"\"\"Run demo application.\"\"\"\n\n    def run(self) -> int:\n        print()\n\n        client = Client(\n            active=True,\n            name=self._name,\n            push_api_key=self._push_api_key,\n            log_level=\"trace\",\n        )\n\n        print(\"Sending example data to AppSignal...\")\n        print(f\"Starting AppSignal client for {self._name}...\")\n        client.start()\n\n        tracer = trace.get_tracer(__name__)\n\n        # Performance sample\n        with tracer.start_as_current_span(\"GET /demo\") as span:\n            span.set_attribute(\"http.method\", \"GET\")\n            span.set_attribute(\n                \"appsignal.request.parameters\",\n                json.dumps({\"GET\": {\"id\": 1}, \"POST\": {}}),\n            )\n            span.set_attribute(\n                \"otel.instrumentation_library.name\",\n                \"opentelemetry.instrumentation.wsgi\",\n            )\n            span.set_attribute(\n                \"demo_sample\",\n                True,\n            )\n\n        # Error sample\n        with tracer.start_as_current_span(\"GET /demo\") as span:\n            span.set_attribute(\"http.method\", \"GET\")\n            span.set_attribute(\n                \"appsignal.request.parameters\",\n                json.dumps({\"GET\": {\"id\": 1}, \"POST\": {}}),\n            )\n            span.set_attribute(\n                \"demo_sample\",\n                True,\n            )\n            try:\n                raise ValueError(\"Something went wrong\")\n            except ValueError as e:\n                span.record_exception(e)\n\n        return 0", ""]}
{"filename": "src/appsignal/cli/install.py", "chunked_list": ["from __future__ import annotations\n\nimport os\n\nimport requests\n\nfrom .command import AppsignalCLICommand\nfrom .demo import DemoCommand\n\n", "\n\nINSTALL_FILE_TEMPLATE = \"\"\"from appsignal import Appsignal\n\nappsignal = Appsignal(\n    active=True,\n    name=\"{name}\",\n    push_api_key=\"{push_api_key}\",\n)\n\"\"\"", ")\n\"\"\"\n\nINSTALL_FILE_NAME = \"__appsignal__.py\"\n\n\nclass InstallCommand(AppsignalCLICommand):\n    \"\"\"Generate Appsignal client integration code.\"\"\"\n\n    def run(self) -> int:\n        # Make sure to show input prompts before the welcome text.\n        self._name  # noqa: B018\n        self._push_api_key  # noqa: B018\n\n        print(\"\ud83d\udc4b Welcome to the AppSignal for Python installer!\")\n        print()\n        print(\"Reach us at support@appsignal.com for support\")\n        print(\"Documentation available at https://docs.appsignal.com/python\")\n        print()\n\n        print()\n\n        print(\"Validating API key\")\n        print()\n        if self._validate_push_api_key():\n            print(\"API key is valid!\")\n        else:\n            print(f\"API key {self._push_api_key} is not valid \")\n            print(\"please get a new one on https://appsignal.com\")\n            return 1\n\n        if self._should_write_file():\n            print(f\"Writing the {INSTALL_FILE_NAME} configuration file...\")\n            self._write_file()\n            print()\n\n            demo = DemoCommand(args=self.args)\n            demo._name = self._name\n            demo._push_api_key = self._push_api_key\n            demo.run()\n\n            if self._search_dependency(\"django\"):\n                self._django_installation()\n            elif self._search_dependency(\"flask\"):\n                self._flask_installation()\n            else:\n                self._generic_installation()\n        else:\n            print(\"Nothing to do. Exiting...\")\n\n        return 0\n\n    def _should_write_file(self) -> bool:\n        if os.path.exists(INSTALL_FILE_NAME):\n            return self._input_should_overwrite_file()\n        return True\n\n    def _input_should_overwrite_file(self) -> bool:\n        response = input(\n            f\"The {INSTALL_FILE_NAME} file already exists.\"\n            \" Should it be overwritten? (y/N): \"\n        )\n        if len(response) == 0 or response[0].lower() == \"n\":\n            return False\n        if response[0].lower() == \"y\":\n            return True\n        print('Please answer \"y\" (yes) or \"n\" (no)')\n        return self._input_should_overwrite_file()\n\n    def _write_file(self) -> None:\n        with open(INSTALL_FILE_NAME, \"w\") as f:\n            file_contents = INSTALL_FILE_TEMPLATE.format(\n                name=self._name,\n                push_api_key=self._push_api_key,\n            )\n\n            f.write(file_contents)\n\n    def _requirements_file(self) -> str | None:\n        current_dir = os.getcwd()\n        for _root, _dirs, files in os.walk(current_dir):\n            for file in files:\n                if file.endswith(\"requirements.txt\"):\n                    return file\n        return None\n\n    def _search_dependency(self, dependency_name: str) -> bool:\n        requirement_file = self._requirements_file()\n        if requirement_file:\n            with open(requirement_file) as f:\n                for line in f.readlines():\n                    return line.startswith(dependency_name)\n\n        return False\n\n    def _django_installation(self) -> None:\n        print(\"We've detected that you're using Django.\")\n        print()\n\n        if not self._search_dependency(\"opentelemetry-instrumentation-django\"):\n            print(\"Adding the Django instrumentation to your requirements.txt file\")\n            print()\n            self._add_dependency(\"opentelemetry-instrumentation-django\")\n\n        print(\"Django requires some manual configuration.\")\n        print(\"The __appsignal__ module needs to be imported in the manage.py file\")\n        print(\"and the appsignal.start() method needs to be called in the main method.\")\n        print()\n        print(\"Please refer to the documentation for more information:\")\n        print(\"https://docs.appsignal.com/python/instrumentations/django.html\")\n\n    def _flask_installation(self) -> None:\n        print(\"We've detected that you're using Flask.\")\n        print()\n\n        if not self._search_dependency(\"opentelemetry-instrumentation-flask\"):\n            print(\"Adding the Flask instrumentation to your requirements.txt file\")\n            print()\n            self._add_dependency(\"opentelemetry-instrumentation-flask\")\n\n        print(\"Flask requires some manual configuration.\")\n        print(\"The __appsignal__ module needs to be imported before Flask is imported\")\n        print(\"and the appsignal.start() method needs to be called right after.\")\n        print()\n        print(\"Please refer to the documentation for more information:\")\n        print(\"https://docs.appsignal.com/python/instrumentations/flask.html\")\n\n    def _generic_installation(self) -> None:\n        print(\"\u2705 Done! AppSignal for Python has now been installed.\")\n        print()\n        print(\"To start AppSignal in your application, add the following code to your\")\n        print(\"application's entrypoint:\")\n        print()\n        print(\"    from __appsignal__ import appsignal\")\n        print(\"    appsignal.start()\")\n        print()\n        print(\"You can check a list of the supported integrations here:\")\n        print(\"https://docs.appsignal.com/python/instrumentations\")\n\n    def _add_dependency(self, dependency_name: str) -> None:\n        requirement_file = self._requirements_file()\n        if requirement_file:\n            with open(requirement_file, \"a\") as f:\n                f.write(f\"{dependency_name}\\n\")\n\n    def _validate_push_api_key(self) -> bool:\n        endpoint = self._config.option(\"endpoint\")\n        url = f\"{endpoint}/1/auth?api_key={self._push_api_key}\"\n        proxies = {}\n        if self._config.option(\"http_proxy\"):\n            proxies[\"http\"] = self._config.option(\"http_proxy\")\n            proxies[\"https\"] = self._config.option(\"http_proxy\")\n\n        cert = self._config.option(\"ca_file_path\")\n\n        response = requests.get(url, proxies=proxies, verify=cert)\n        return response.status_code == 200", ""]}
{"filename": "src/appsignal/cli/command.py", "chunked_list": ["from __future__ import annotations\n\nimport os\nfrom abc import ABC, abstractmethod\nfrom argparse import ArgumentParser, Namespace\nfrom dataclasses import dataclass\nfrom functools import cached_property\n\nfrom appsignal.config import Config\n", "from appsignal.config import Config\n\n\n@dataclass(frozen=True)\nclass AppsignalCLICommand(ABC):\n    args: Namespace\n\n    @staticmethod\n    def init_parser(parser: ArgumentParser) -> None:\n        parser.add_argument(\n            \"--push-api-key\",\n            default=os.environ.get(\"APPSIGNAL_PUSH_API_KEY\"),\n            help=\"Push API Key\",\n        )\n        parser.add_argument(\n            \"--application\",\n            default=os.environ.get(\"APPSIGNAL_APP_NAME\"),\n            help=\"Application name\",\n        )\n\n    @abstractmethod\n    def run(self) -> int:\n        raise NotImplementedError\n\n    @cached_property\n    def _push_api_key(self) -> str | None:\n        key = self.args.push_api_key\n        while not key:\n            key = input(\"Please enter your Push API key: \")\n        return key\n\n    @cached_property\n    def _name(self) -> str | None:\n        name = self.args.application\n        while not name:\n            name = input(\"Please enter the name of your application: \")\n        return name\n\n    @cached_property\n    def _config(self) -> Config:\n        return Config()", ""]}
