{"filename": "tests/test_asn1.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport enum\nimport re\n\nimport pytest\n", "import pytest\n\nimport dpapi_ng._asn1 as asn1\n\n\nclass EnumeratedEnum(enum.IntEnum):\n    ENUM0 = 0\n    ENUM1 = 1\n    ENUM2 = 2\n    ENUM3 = 3", "\n\nASN1_TAG_TESTS = [\n    # Simple universal\n    (asn1.TagClass.UNIVERSAL, False, asn1.TypeTagNumber.OCTET_STRING, b\"\\x00\", b\"\\x04\\x01\\x00\"),\n    # Constructed value\n    (asn1.TagClass.UNIVERSAL, True, asn1.TypeTagNumber.OCTET_STRING, b\"\\x00\\x00\", b\"\\x24\\x02\\x00\\x00\"),\n    # Large tag number\n    (asn1.TagClass.APPLICATION, True, 1024, b\"\\x00\\x00\", b\"\\x7F\\x88\\x00\\x02\\x00\\x00\"),\n    (asn1.TagClass.APPLICATION, True, 1048576, b\"\\x00\\x00\", b\"\\x7F\\xC0\\x80\\x00\\x02\\x00\\x00\"),", "    (asn1.TagClass.APPLICATION, True, 1024, b\"\\x00\\x00\", b\"\\x7F\\x88\\x00\\x02\\x00\\x00\"),\n    (asn1.TagClass.APPLICATION, True, 1048576, b\"\\x00\\x00\", b\"\\x7F\\xC0\\x80\\x00\\x02\\x00\\x00\"),\n    # Long length\n    (asn1.TagClass.UNIVERSAL, False, asn1.TypeTagNumber.OCTET_STRING, b\"\\x00\" * 127, b\"\\x04\\x7F\" + (b\"\\x00\" * 127)),\n    (asn1.TagClass.UNIVERSAL, False, asn1.TypeTagNumber.OCTET_STRING, b\"\\x00\" * 128, b\"\\x04\\x81\\x80\" + (b\"\\x00\" * 128)),\n    (\n        asn1.TagClass.UNIVERSAL,\n        False,\n        asn1.TypeTagNumber.OCTET_STRING,\n        b\"\\x00\" * 1024,", "        asn1.TypeTagNumber.OCTET_STRING,\n        b\"\\x00\" * 1024,\n        b\"\\x04\\x82\\x04\\x00\" + (b\"\\x00\" * 1024),\n    ),\n]\n\n# openssl asn1parse -genstr 'INTEGER:<val>' -out test && hexdump -C test && rm test\nINTEGER_TESTS = [  # INTEGER has weird rules that I don't fully understand, use a test of test cases.\n    (-748591, b\"\\x02\\x03\\xF4\\x93\\xD1\"),\n    (-32769, b\"\\x02\\x03\\xFF\\x7F\\xFF\"),", "    (-748591, b\"\\x02\\x03\\xF4\\x93\\xD1\"),\n    (-32769, b\"\\x02\\x03\\xFF\\x7F\\xFF\"),\n    (-32768, b\"\\x02\\x02\\x80\\x00\"),\n    (-32767, b\"\\x02\\x02\\x80\\x01\"),\n    (-257, b\"\\x02\\x02\\xFE\\xFF\"),\n    (-256, b\"\\x02\\x02\\xFF\\x00\"),\n    (-255, b\"\\x02\\x02\\xFF\\x01\"),\n    (-129, b\"\\x02\\x02\\xFF\\x7F\"),\n    (-128, b\"\\x02\\x01\\x80\"),\n    (-127, b\"\\x02\\x01\\x81\"),", "    (-128, b\"\\x02\\x01\\x80\"),\n    (-127, b\"\\x02\\x01\\x81\"),\n    (-17, b\"\\x02\\x01\\xEF\"),\n    (-16, b\"\\x02\\x01\\xF0\"),\n    (-10, b\"\\x02\\x01\\xF6\"),\n    (-1, b\"\\x02\\x01\\xFF\"),\n    (0, b\"\\x02\\x01\\x00\"),\n    (1, b\"\\x02\\x01\\x01\"),\n    (10, b\"\\x02\\x01\\x0A\"),\n    (16, b\"\\x02\\x01\\x10\"),", "    (10, b\"\\x02\\x01\\x0A\"),\n    (16, b\"\\x02\\x01\\x10\"),\n    (17, b\"\\x02\\x01\\x11\"),\n    (127, b\"\\x02\\x01\\x7F\"),\n    (128, b\"\\x02\\x02\\x00\\x80\"),\n    (129, b\"\\x02\\x02\\x00\\x81\"),\n    (255, b\"\\x02\\x02\\x00\\xFF\"),\n    (256, b\"\\x02\\x02\\x01\\x00\"),\n    (257, b\"\\x02\\x02\\x01\\x01\"),\n    (32767, b\"\\x02\\x02\\x7F\\xFF\"),", "    (257, b\"\\x02\\x02\\x01\\x01\"),\n    (32767, b\"\\x02\\x02\\x7F\\xFF\"),\n    (32768, b\"\\x02\\x03\\x00\\x80\\x00\"),\n    (32769, b\"\\x02\\x03\\x00\\x80\\x01\"),\n    (748591, b\"\\x02\\x03\\x0B\\x6C\\x2F\"),\n]\n\n\n@pytest.mark.parametrize(\"tag_class, constructed, tag_number, data, expected\", ASN1_TAG_TESTS)\ndef test_pack_asn1_tlv(\n    tag_class: asn1.TagClass,\n    constructed: bool,\n    tag_number: int,\n    data: bytes,\n    expected: bytes,\n) -> None:\n    actual = asn1._pack_asn1(tag_class, constructed, tag_number, data)\n    assert actual == expected", "@pytest.mark.parametrize(\"tag_class, constructed, tag_number, data, expected\", ASN1_TAG_TESTS)\ndef test_pack_asn1_tlv(\n    tag_class: asn1.TagClass,\n    constructed: bool,\n    tag_number: int,\n    data: bytes,\n    expected: bytes,\n) -> None:\n    actual = asn1._pack_asn1(tag_class, constructed, tag_number, data)\n    assert actual == expected", "\n\n@pytest.mark.parametrize(\"tag_class, constructed, tag_number, data, value\", ASN1_TAG_TESTS)\ndef test_unpack_asn1_tlv(\n    tag_class: asn1.TagClass,\n    constructed: bool,\n    tag_number: int,\n    data: bytes,\n    value: bytes,\n) -> None:\n    actual = asn1._read_asn1_header(value)\n\n    assert actual.tag.tag_class == tag_class\n    assert actual.tag.is_constructed == constructed\n    assert actual.tag.tag_number == tag_number\n    assert actual.tag_length == len(value) - len(data)\n    assert actual.length == len(data)", "\n\n@pytest.mark.parametrize(\"value, expected\", INTEGER_TESTS)\ndef test_pack_asn1_integer(value: int, expected: bytes) -> None:\n    actual = asn1._pack_asn1_integer(value)\n    assert actual == expected\n\n\n@pytest.mark.parametrize(\"expected, value\", INTEGER_TESTS)\ndef test_unpack_asn1_integer(expected: int, value: bytes) -> None:\n    actual, consumed = asn1._read_asn1_integer(value)\n    assert actual == expected\n    assert consumed == len(value)", "@pytest.mark.parametrize(\"expected, value\", INTEGER_TESTS)\ndef test_unpack_asn1_integer(expected: int, value: bytes) -> None:\n    actual, consumed = asn1._read_asn1_integer(value)\n    assert actual == expected\n    assert consumed == len(value)\n\n\n@pytest.mark.parametrize(\n    \"expected, value\",\n    [", "    \"expected, value\",\n    [\n        (True, b\"\\x01\\x01\\x01\"),\n        (True, b\"\\x01\\x01\\x02\"),\n        (True, b\"\\x01\\x01\\xFF\"),\n        (True, b\"\\x01\\x02\\x00\\x01\"),\n        (True, b\"\\x01\\x02\\x01\\x00\"),\n        (False, b\"\\x01\\x01\\x00\"),\n        (False, b\"\\x01\\x02\\x00\\x00\"),\n    ],", "        (False, b\"\\x01\\x02\\x00\\x00\"),\n    ],\n)\ndef test_unpack_asn1_boolean(expected: bool, value: bytes) -> None:\n    actual = asn1.ASN1Reader(value).read_boolean()\n    assert actual == expected\n\n\n@pytest.mark.parametrize(\n    \"expected, value\",", "@pytest.mark.parametrize(\n    \"expected, value\",\n    [\n        (EnumeratedEnum.ENUM0, b\"\\x0a\\x01\\x00\"),\n        (EnumeratedEnum.ENUM1, b\"\\x0a\\x01\\x01\"),\n        (EnumeratedEnum.ENUM2, b\"\\x0a\\x01\\x02\"),\n    ],\n)\ndef test_unpack_asn1_enumerator(expected: EnumeratedEnum, value: bytes) -> None:\n    actual = asn1.ASN1Reader(value).read_enumerated(EnumeratedEnum)\n    assert actual == expected", "def test_unpack_asn1_enumerator(expected: EnumeratedEnum, value: bytes) -> None:\n    actual = asn1.ASN1Reader(value).read_enumerated(EnumeratedEnum)\n    assert actual == expected\n\n\n@pytest.mark.parametrize(\n    \"expected, value\",\n    [\n        (\"19851106210627.3\", b\"\\x18\\x1019851106210627.3\"),\n        (\"19851106210627.3Z\", b\"\\x18\\x1119851106210627.3Z\"),", "        (\"19851106210627.3\", b\"\\x18\\x1019851106210627.3\"),\n        (\"19851106210627.3Z\", b\"\\x18\\x1119851106210627.3Z\"),\n        (\"19851106210627.3-0500\", b\"\\x18\\x1519851106210627.3-0500\"),\n    ],\n)\ndef test_unpack_asn1_generalized_time(expected: str, value: bytes) -> None:\n    actual = asn1.ASN1Reader(value).read_generalized_time()\n    assert actual == expected\n\n\ndef test_reader_skip_value() -> None:\n    with asn1.ASN1Writer() as writer:\n        with writer.push_set_of() as w:\n            w.write_octet_string(b\"value 1\")\n            w.write_octet_string(b\"value 2\")\n\n    reader = asn1.ASN1Reader(writer.get_data())\n    set_reader = reader.read_set_of()\n\n    next_header = set_reader.peek_header()\n    set_reader.skip_value(next_header)\n    assert set_reader.read_octet_string() == b\"value 2\"\n    assert set_reader.get_remaining_data() == b\"\"", "\n\ndef test_reader_skip_value() -> None:\n    with asn1.ASN1Writer() as writer:\n        with writer.push_set_of() as w:\n            w.write_octet_string(b\"value 1\")\n            w.write_octet_string(b\"value 2\")\n\n    reader = asn1.ASN1Reader(writer.get_data())\n    set_reader = reader.read_set_of()\n\n    next_header = set_reader.peek_header()\n    set_reader.skip_value(next_header)\n    assert set_reader.read_octet_string() == b\"value 2\"\n    assert set_reader.get_remaining_data() == b\"\"", "\n\ndef test_reader_get_remaining() -> None:\n    with asn1.ASN1Writer() as writer:\n        with writer.push_set_of() as w:\n            w.write_octet_string(b\"value 1\")\n            w.write_octet_string(b\"value 2\")\n\n    reader = asn1.ASN1Reader(writer.get_data())\n    set_reader = reader.read_set_of()\n    assert reader.get_remaining_data() == b\"\"\n\n    assert set_reader.read_octet_string() == b\"value 1\"\n    assert set_reader.get_remaining_data() == b\"\\x04\\x07value 2\"", "\n\ndef test_writer_push_sequence() -> None:\n    expected = b\"\\x30\\x0A\\x02\\x01\\x01\\x04\\x05\\x76\\x61\\x6C\\x75\\x65\"\n    with asn1.ASN1Writer() as writer:\n        with writer.push_sequence() as w:\n            w.write_integer(1)\n            w.write_octet_string(b\"value\")\n\n    actual = writer.get_data()\n    assert actual == expected", "\n\ndef test_writer_push_sequence_with_tag() -> None:\n    expected = b\"\\xA0\\x0A\\x02\\x01\\x01\\x04\\x05\\x76\\x61\\x6C\\x75\\x65\"\n    with asn1.ASN1Writer() as writer:\n        with writer.push_sequence(asn1.ASN1Tag(asn1.TagClass.CONTEXT_SPECIFIC, 0, True)) as w:\n            w.write_integer(1)\n            w.write_octet_string(b\"value\")\n\n    actual = writer.get_data()\n    assert actual == expected", "\n\ndef test_writer_push_set() -> None:\n    expected = b\"\\x31\\x06\\x01\\x01\\x00\\x01\\x01\\xFF\"\n    with asn1.ASN1Writer() as writer:\n        with writer.push_set() as w:\n            w.write_boolean(False)\n            w.write_boolean(True)\n\n    actual = writer.get_data()\n    assert actual == expected", "\n\ndef test_writer_push_set_with_tag() -> None:\n    expected = b\"\\xA0\\x06\\x01\\x01\\x00\\x01\\x01\\xFF\"\n    with asn1.ASN1Writer() as writer:\n        with writer.push_set(asn1.ASN1Tag(asn1.TagClass.CONTEXT_SPECIFIC, 0, True)) as w:\n            w.write_boolean(False)\n            w.write_boolean(True)\n\n    actual = writer.get_data()\n    assert actual == expected", "\n\ndef test_writer_write_bool() -> None:\n    expected = b\"\\x01\\x01\\xFF\"\n    with asn1.ASN1Writer() as writer:\n        writer.write_boolean(True)\n\n    actual = writer.get_data()\n    assert actual == expected\n", "\n\ndef test_writer_write_bool_with_tag() -> None:\n    expected = b\"\\xA0\\x01\\xFF\"\n    with asn1.ASN1Writer() as writer:\n        writer.write_boolean(True, asn1.ASN1Tag(asn1.TagClass.CONTEXT_SPECIFIC, 0, True))\n\n    actual = writer.get_data()\n    assert actual == expected\n", "\n\ndef test_writer_write_octet_string() -> None:\n    expected = b\"\\x04\\x01\\xFF\"\n    with asn1.ASN1Writer() as writer:\n        writer.write_octet_string(b\"\\xFF\")\n\n    actual = writer.get_data()\n    assert actual == expected\n", "\n\ndef test_writer_write_octet_with_tag() -> None:\n    expected = b\"\\xA0\\x01\\xFF\"\n    with asn1.ASN1Writer() as writer:\n        writer.write_octet_string(b\"\\xFF\", asn1.ASN1Tag(asn1.TagClass.CONTEXT_SPECIFIC, 0, True))\n\n    actual = writer.get_data()\n    assert actual == expected\n", "\n\ndef test_writer_write_object_identifier() -> None:\n    expected = b\"\\x06\\t*\\x86H\\x86\\xf7\\r\\x01\\x07\\x03\"\n    with asn1.ASN1Writer() as writer:\n        writer.write_object_identifier(\"1.2.840.113549.1.7.3\")\n\n    actual = writer.get_data()\n    assert actual == expected\n", "\n\ndef test_fail_pack_invalid_object_identifier() -> None:\n    with pytest.raises(ValueError, match=\"Illegal object identifier\"):\n        asn1._encode_object_identifier(\"40.50.1.2.3\")\n\n\ndef test_writer_write_enumerated() -> None:\n    expected = b\"\\x0A\\x01\\x01\"\n    with asn1.ASN1Writer() as writer:\n        writer.write_enumerated(EnumeratedEnum.ENUM1)\n\n    actual = writer.get_data()\n    assert actual == expected", "\n\ndef test_writer_write_enumerated_with_tag() -> None:\n    expected = b\"\\xA0\\x01\\x01\"\n    with asn1.ASN1Writer() as writer:\n        writer.write_enumerated(EnumeratedEnum.ENUM1, asn1.ASN1Tag(asn1.TagClass.CONTEXT_SPECIFIC, 0, True))\n\n    actual = writer.get_data()\n    assert actual == expected\n", "\n\ndef test_fail_get_data_on_inner_writer() -> None:\n    with asn1.ASN1Writer() as writer:\n        with writer.push_set_of() as w:\n            with pytest.raises(TypeError, match=\"Cannot get_data\\\\(\\\\) on child ASN1 writer\"):\n                w.get_data()\n\n\ndef test_fail_pack_invalid_class() -> None:\n    with pytest.raises(ValueError, match=\"tag_class must be between 0 and 3\"):\n        asn1._pack_asn1(4, True, 0, b\"\")  # type: ignore[arg-type]  # For test", "\ndef test_fail_pack_invalid_class() -> None:\n    with pytest.raises(ValueError, match=\"tag_class must be between 0 and 3\"):\n        asn1._pack_asn1(4, True, 0, b\"\")  # type: ignore[arg-type]  # For test\n\n\ndef test_fail_read_header_not_enough_for_tag_class() -> None:\n    with pytest.raises(asn1.NotEnougData):\n        asn1._read_asn1_header(b\"\")\n", "\n\ndef test_fail_read_header_not_enough_for_tag_length() -> None:\n    with pytest.raises(asn1.NotEnougData):\n        asn1._read_asn1_header(b\"\\xFF\")\n\n\ndef test_fail_read_header_not_enough_for_length() -> None:\n    with pytest.raises(asn1.NotEnougData):\n        asn1._read_asn1_header(b\"\\x01\")", "\n\ndef test_fail_read_header_with_indefinite_length() -> None:\n    expected = \"Received BER indefinite encoded value which is unsupported by LDAP messages\"\n\n    with pytest.raises(ValueError, match=expected):\n        asn1._read_asn1_header(b\"\\x01\\x80\")\n\n\ndef test_fail_read_header_not_enough_for_length_octets() -> None:\n    with pytest.raises(asn1.NotEnougData):\n        asn1._read_asn1_header(b\"\\x04\\x81\")", "\ndef test_fail_read_header_not_enough_for_length_octets() -> None:\n    with pytest.raises(asn1.NotEnougData):\n        asn1._read_asn1_header(b\"\\x04\\x81\")\n\n\ndef test_fail_unpack_not_enough_for_value() -> None:\n    with pytest.raises(asn1.NotEnougData):\n        asn1._read_asn1_boolean(b\"\\x01\\x01\")\n", "\n\ndef test_fail_invalid_tag() -> None:\n    expected = \"Expected tag ASN1Tag(tag_class=<TagClass.UNIVERSAL: 0>, tag_number=<TypeTagNumber.BOOLEAN: 1>, is_constructed=False) but got ASN1Tag(tag_class=<TagClass.CONTEXT_SPECIFIC: 2>, tag_number=0, is_constructed=False)\"\n\n    with pytest.raises(ValueError, match=re.escape(expected)):\n        asn1._read_asn1_boolean(b\"\\x80\\x01\\x00\")\n\n\n@pytest.mark.parametrize(", "\n@pytest.mark.parametrize(\n    \"expected, value\",\n    [\n        (False, b\"\\x01\\x01\\x00\"),\n        (True, b\"\\x01\\x01\\xFF\"),\n    ],\n)\ndef test_read_asn1_boolean(expected: bool, value: bytes) -> None:\n    actual, consumed = asn1._read_asn1_boolean(value)\n    assert actual == expected\n    assert consumed == 3", "def test_read_asn1_boolean(expected: bool, value: bytes) -> None:\n    actual, consumed = asn1._read_asn1_boolean(value)\n    assert actual == expected\n    assert consumed == 3\n\n\n@pytest.mark.parametrize(\n    \"expected, value\",\n    [\n        (False, b\"\\x80\\x01\\x00\"),", "    [\n        (False, b\"\\x80\\x01\\x00\"),\n        (True, b\"\\x80\\x01\\xFF\"),\n    ],\n)\ndef test_read_asn1_boolean_with_tag(expected: bool, value: bytes) -> None:\n    actual, consumed = asn1._read_asn1_boolean(\n        value,\n        tag=asn1.ASN1Tag(asn1.TagClass.CONTEXT_SPECIFIC, 0, False),\n    )\n    assert actual == expected\n    assert consumed == 3", "\n\n@pytest.mark.parametrize(\n    \"expected, value\",\n    [\n        (0, b\"\\x0A\\x01\\x00\"),\n        (1, b\"\\x0A\\x01\\x01\"),\n    ],\n)\ndef test_read_asn1_enumerated(expected: int, value: bytes) -> None:\n    actual, consumed = asn1._read_asn1_enumerated(value)\n    assert actual == expected\n    assert consumed == 3", ")\ndef test_read_asn1_enumerated(expected: int, value: bytes) -> None:\n    actual, consumed = asn1._read_asn1_enumerated(value)\n    assert actual == expected\n    assert consumed == 3\n\n\n@pytest.mark.parametrize(\n    \"expected, value\",\n    [", "    \"expected, value\",\n    [\n        (0, b\"\\x80\\x01\\x00\"),\n        (1, b\"\\x80\\x01\\x01\"),\n    ],\n)\ndef test_read_asn1_enumerated_with_tag(expected: int, value: bytes) -> None:\n    actual, consumed = asn1._read_asn1_enumerated(\n        value,\n        tag=asn1.ASN1Tag(asn1.TagClass.CONTEXT_SPECIFIC, 0, False),\n    )\n    assert actual == expected\n    assert consumed == 3", ""]}
{"filename": "tests/test_security_descriptor.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport re\nimport typing as t\nimport uuid\n\nimport pytest", "\nimport pytest\n\nfrom dpapi_ng import _security_descriptor as security_descriptor\n\nfrom .conftest import get_test_data\n\n\ndef test_sid_to_bytes() -> None:\n    expected = (\n        b\"\\x01\\x05\\x00\\x00\\x00\\x00\\x00\\x05\"\n        b\"\\x15\\x00\\x00\\x00\\x1D\\x93\\x77\\xF7\"\n        b\"\\x44\\x35\\x7A\\xCC\\x8C\\xD3\\x7B\\xA9\"\n        b\"\\x50\\x04\\x00\\x00\"\n    )\n    actual = security_descriptor.sid_to_bytes(\"S-1-5-21-4151808797-3430561092-2843464588-1104\")\n\n    assert actual == expected", "def test_sid_to_bytes() -> None:\n    expected = (\n        b\"\\x01\\x05\\x00\\x00\\x00\\x00\\x00\\x05\"\n        b\"\\x15\\x00\\x00\\x00\\x1D\\x93\\x77\\xF7\"\n        b\"\\x44\\x35\\x7A\\xCC\\x8C\\xD3\\x7B\\xA9\"\n        b\"\\x50\\x04\\x00\\x00\"\n    )\n    actual = security_descriptor.sid_to_bytes(\"S-1-5-21-4151808797-3430561092-2843464588-1104\")\n\n    assert actual == expected", "\n\n@pytest.mark.parametrize(\n    \"value\",\n    [\n        \"S-1-5\",\n        \"S-1-51\",\n        \"S-1-5-\",\n        \"Z-1-5-1\",\n        \"S-1-5-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16\",", "        \"Z-1-5-1\",\n        \"S-1-5-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16\",\n    ],\n)\ndef test_sid_to_bytes_invalid(value: str) -> None:\n    expected = re.escape(f\"Input string '{value}' is not a valid SID string\")\n    with pytest.raises(ValueError, match=expected):\n        security_descriptor.sid_to_bytes(value)\n\n\ndef test_sd_to_bytes_no_sacl() -> None:\n    expected = (\n        b\"\\x01\\x00\\x04\\x80\\x30\\x00\\x00\\x00\"\n        b\"\\x3C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x14\\x00\\x00\\x00\\x02\\x00\\x1C\\x00\"\n        b\"\\x01\\x00\\x00\\x00\\x00\\x00\\x14\\x00\"\n        b\"\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x05\\x12\\x00\\x00\\x00\"\n        b\"\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x05\"\n        b\"\\x12\\x00\\x00\\x00\\x01\\x01\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x05\\x12\\x00\\x00\\x00\"\n    )\n    actual = security_descriptor.sd_to_bytes(\n        \"S-1-5-18\",\n        \"S-1-5-18\",\n        dacl=[security_descriptor.ace_to_bytes(\"S-1-5-18\", 1)],\n    )\n    assert actual == expected", "\n\ndef test_sd_to_bytes_no_sacl() -> None:\n    expected = (\n        b\"\\x01\\x00\\x04\\x80\\x30\\x00\\x00\\x00\"\n        b\"\\x3C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x14\\x00\\x00\\x00\\x02\\x00\\x1C\\x00\"\n        b\"\\x01\\x00\\x00\\x00\\x00\\x00\\x14\\x00\"\n        b\"\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x05\\x12\\x00\\x00\\x00\"\n        b\"\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x05\"\n        b\"\\x12\\x00\\x00\\x00\\x01\\x01\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x05\\x12\\x00\\x00\\x00\"\n    )\n    actual = security_descriptor.sd_to_bytes(\n        \"S-1-5-18\",\n        \"S-1-5-18\",\n        dacl=[security_descriptor.ace_to_bytes(\"S-1-5-18\", 1)],\n    )\n    assert actual == expected", "\n\ndef test_sd_to_bytes_no_dacl() -> None:\n    expected = (\n        b\"\\x01\\x00\\x10\\x80\\x30\\x00\\x00\\x00\"\n        b\"\\x3C\\x00\\x00\\x00\\x14\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x02\\x00\\x1C\\x00\"\n        b\"\\x01\\x00\\x00\\x00\\x00\\x00\\x14\\x00\"\n        b\"\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x05\\x12\\x00\\x00\\x00\"\n        b\"\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x05\"\n        b\"\\x12\\x00\\x00\\x00\\x01\\x01\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x05\\x12\\x00\\x00\\x00\"\n    )\n    actual = security_descriptor.sd_to_bytes(\n        \"S-1-5-18\",\n        \"S-1-5-18\",\n        sacl=[security_descriptor.ace_to_bytes(\"S-1-5-18\", 1)],\n    )\n    assert actual == expected", ""]}
{"filename": "tests/test_crypto.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport typing as t\nimport uuid\n\nimport pytest\nfrom cryptography.hazmat.primitives import hashes", "import pytest\nfrom cryptography.hazmat.primitives import hashes\n\nfrom dpapi_ng import _crypto as crypto\n\n\ndef test_cek_decrypt_invalid_algorithm() -> None:\n    with pytest.raises(NotImplementedError, match=\"Unknown cek encryption algorithm OID '1.2'\"):\n        crypto.cek_decrypt(\"1.2\", None, b\"\", b\"\")\n", "\n\ndef test_content_decrypt_aes256_gcm_no_parameters() -> None:\n    with pytest.raises(ValueError, match=\"Expecting parameters for AES256 GCM decryption but received none\"):\n        crypto.content_decrypt(\"2.16.840.1.101.3.4.1.46\", None, b\"\", b\"\")\n\n\ndef test_content_decrypt_invalid_algorithm() -> None:\n    with pytest.raises(NotImplementedError, match=\"Unknown content encryption algorithm OID '1.2'\"):\n        crypto.content_decrypt(\"1.2\", None, b\"\", b\"\")", "\n\ndef test_cek_encrypt_invalid_algorithm() -> None:\n    with pytest.raises(NotImplementedError, match=\"Unknown cek encryption algorithm OID '1.2'\"):\n        crypto.cek_encrypt(\"1.2\", None, b\"\", b\"\")\n\n\ndef test_content_encrypt_aes256_gcm_no_parameters() -> None:\n    with pytest.raises(ValueError, match=\"Expecting parameters for AES256 GCM encryption but received none\"):\n        crypto.content_encrypt(\"2.16.840.1.101.3.4.1.46\", None, b\"\", b\"\")", "\n\ndef test_content_encrypt_invalid_algorithm() -> None:\n    with pytest.raises(NotImplementedError, match=\"Unknown content encryption algorithm OID '1.2'\"):\n        crypto.content_encrypt(\"1.2\", None, b\"\", b\"\")\n\n\ndef test_cek_generate_invalid_algorithm() -> None:\n    with pytest.raises(NotImplementedError, match=\"Unknown cek encryption algorithm OID '1.2'\"):\n        crypto.cek_generate(\"1.2\")", ""]}
{"filename": "tests/test_epm.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport uuid\n\nimport dpapi_ng._rpc as rpc\nfrom dpapi_ng import _epm as epm\n", "from dpapi_ng import _epm as epm\n\n\ndef test_ept_map_pack() -> None:\n    expected = (\n        b\"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n        b\"\\x00\\x07\\x02\\x00\\x00\\x87\\x01\\x00\"\n        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\"\n    )\n    service = rpc.SyntaxId(uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\"), 1, 0)\n    data_rep = rpc.SyntaxId(uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\"), 2, 0)\n\n    msg = epm.EptMap(\n        obj=None,\n        tower=epm.build_tcpip_tower(service, data_rep, 135, 0),\n        entry_handle=None,\n        max_towers=4,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_ept_map_unpack() -> None:\n    data = (\n        b\"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n        b\"\\x00\\x07\\x02\\x00\\x00\\x87\\x01\\x00\"\n        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\"\n    )\n    resp = epm.EptMap.unpack(data)\n    assert isinstance(resp, epm.EptMap)\n    assert resp.obj is None\n    assert len(resp.tower) == 5\n    assert isinstance(resp.tower[0], epm.UUIDFloor)\n    assert resp.tower[0].uuid == uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\")\n    assert resp.tower[0].version == 1\n    assert resp.tower[0].version_minor == 0\n    assert resp.tower[0].protocol == epm.FloorProtocol.UUID_ID\n    assert resp.tower[0].lhs\n    assert resp.tower[0].rhs\n    assert isinstance(resp.tower[1], epm.UUIDFloor)\n    assert resp.tower[1].uuid == uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\")\n    assert resp.tower[1].version == 2\n    assert resp.tower[1].version_minor == 0\n    assert resp.tower[1].protocol == epm.FloorProtocol.UUID_ID\n    assert resp.tower[1].lhs\n    assert resp.tower[1].rhs\n    assert isinstance(resp.tower[2], epm.RPCConnectionOrientedFloor)\n    assert resp.tower[2].version_minor == 0\n    assert resp.tower[2].protocol == epm.FloorProtocol.RPC_CONNECTION_ORIENTED\n    assert resp.tower[2].lhs == b\"\"\n    assert resp.tower[2].rhs\n    assert isinstance(resp.tower[3], epm.TCPFloor)\n    assert resp.tower[3].port == 135\n    assert resp.tower[3].protocol == epm.FloorProtocol.TCP\n    assert resp.tower[3].lhs == b\"\"\n    assert resp.tower[3].rhs\n    assert isinstance(resp.tower[4], epm.IPFloor)\n    assert resp.tower[4].addr == 0\n    assert resp.tower[4].protocol == epm.FloorProtocol.IP\n    assert resp.tower[4].lhs == b\"\"\n    assert resp.tower[4].rhs\n    assert resp.entry_handle is None\n    assert resp.max_towers == 4", "\n\ndef test_ept_map_pack_obj_and_entry_handle() -> None:\n    expected = (\n        b\"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x33\\x05\\x90\\x80\\x92\\xbc\\x6f\\x40\"\n        b\"\\xbf\\xbb\\xb2\\xdc\\xd4\\xa7\\x26\\xee\"\n        b\"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x09\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x09\\x00\\x00\\x00\\x01\\x00\\x01\\x00\"\n        b\"\\x0b\\x02\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x50\\x62\\x62\\xea\"\n        b\"\\x2f\\x27\\xb2\\x4a\\x88\\xa7\\x8a\\xbe\"\n        b\"\\x11\\x40\\x37\\x24\\x01\\x00\\x00\\x00\"\n    )\n\n    msg = epm.EptMap(\n        obj=uuid.UUID(\"80900533-bc92-406f-bfbb-b2dcd4a726ee\"),\n        tower=[epm.RPCConnectionOrientedFloor(0)],\n        entry_handle=(0, uuid.UUID(\"ea626250-272f-4ab2-88a7-8abe11403724\")),\n        max_towers=1,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_ept_map_unpack_obj_and_entry_handle() -> None:\n    data = (\n        b\"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x33\\x05\\x90\\x80\\x92\\xbc\\x6f\\x40\"\n        b\"\\xbf\\xbb\\xb2\\xdc\\xd4\\xa7\\x26\\xee\"\n        b\"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x09\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x09\\x00\\x00\\x00\\x01\\x00\\x01\\x00\"\n        b\"\\x0b\\x02\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x50\\x62\\x62\\xea\"\n        b\"\\x2f\\x27\\xb2\\x4a\\x88\\xa7\\x8a\\xbe\"\n        b\"\\x11\\x40\\x37\\x24\\x01\\x00\\x00\\x00\"\n    )\n    resp = epm.EptMap.unpack(data)\n    assert isinstance(resp, epm.EptMap)\n    assert resp.obj == uuid.UUID(\"80900533-bc92-406f-bfbb-b2dcd4a726ee\")\n    assert len(resp.tower) == 1\n    assert isinstance(resp.tower[0], epm.RPCConnectionOrientedFloor)\n    assert resp.tower[0].version_minor == 0\n    assert resp.tower[0].protocol == epm.FloorProtocol.RPC_CONNECTION_ORIENTED\n    assert resp.tower[0].lhs == b\"\"\n    assert resp.tower[0].rhs\n    assert resp.entry_handle == (0, uuid.UUID(\"ea626250-272f-4ab2-88a7-8abe11403724\"))\n    assert resp.max_towers == 1", "\n\ndef test_ept_map_result_pack() -> None:\n    expected = (\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\"\n        b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n        b\"\\x00\\x07\\x02\\x00\\xc2\\x08\\x01\\x00\"\n        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n        b\"\\x00\\x07\\x02\\x00\\xc2\\x06\\x01\\x00\"\n        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n        b\"\\x00\\x07\\x02\\x00\\xc2\\x03\\x01\\x00\"\n        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\"\n    )\n    service = rpc.SyntaxId(uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\"), 1, 0)\n    data_rep = rpc.SyntaxId(uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\"), 2, 0)\n\n    msg = epm.EptMapResult(\n        entry_handle=None,\n        towers=[\n            epm.build_tcpip_tower(service, data_rep, 49672, 0),\n            epm.build_tcpip_tower(service, data_rep, 49670, 0),\n            epm.build_tcpip_tower(service, data_rep, 49667, 0),\n        ],\n        status=0,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_ept_map_result_unpack() -> None:\n    data = (\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\"\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n        b\"\\x00\\x07\\x02\\x00\\xc2\\x08\\x01\\x00\"\n        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n        b\"\\x00\\x07\\x02\\x00\\xc2\\x06\\x01\\x00\"\n        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x4b\\x00\\x00\\x00\\x05\\x00\\x13\\x00\"\n        b\"\\x0d\\x60\\x59\\x78\\xb9\\x4f\\x52\\xdf\"\n        b\"\\x11\\x8b\\x6d\\x83\\xdc\\xde\\xd7\\x20\"\n        b\"\\x85\\x01\\x00\\x02\\x00\\x00\\x00\\x13\"\n        b\"\\x00\\x0d\\x04\\x5d\\x88\\x8a\\xeb\\x1c\"\n        b\"\\xc9\\x11\\x9f\\xe8\\x08\\x00\\x2b\\x10\"\n        b\"\\x48\\x60\\x02\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x01\\x00\\x0b\\x02\\x00\\x00\\x00\\x01\"\n        b\"\\x00\\x07\\x02\\x00\\xc2\\x03\\x01\\x00\"\n        b\"\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\"\n    )\n    resp = epm.EptMapResult.unpack(data)\n    assert isinstance(resp, epm.EptMapResult)\n    assert resp.entry_handle is None\n    assert len(resp.towers) == 3\n\n    for idx, port in enumerate([49672, 49670, 49667]):\n        floors = resp.towers[idx]\n\n        assert len(floors) == 5\n        assert isinstance(floors[0], epm.UUIDFloor)\n        assert floors[0].uuid == uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\")\n        assert floors[0].version == 1\n        assert floors[0].version_minor == 0\n        assert floors[0].protocol == epm.FloorProtocol.UUID_ID\n        assert floors[0].lhs\n        assert floors[0].rhs\n        assert isinstance(floors[1], epm.UUIDFloor)\n        assert floors[1].uuid == uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\")\n        assert floors[1].version == 2\n        assert floors[1].version_minor == 0\n        assert floors[1].protocol == epm.FloorProtocol.UUID_ID\n        assert floors[1].lhs\n        assert floors[1].rhs\n        assert isinstance(floors[2], epm.RPCConnectionOrientedFloor)\n        assert floors[2].version_minor == 0\n        assert floors[2].protocol == epm.FloorProtocol.RPC_CONNECTION_ORIENTED\n        assert floors[2].lhs == b\"\"\n        assert floors[2].rhs\n        assert isinstance(floors[3], epm.TCPFloor)\n        assert floors[3].port == port\n        assert floors[3].protocol == epm.FloorProtocol.TCP\n        assert floors[3].lhs == b\"\"\n        assert floors[3].rhs\n        assert isinstance(floors[4], epm.IPFloor)\n        assert floors[4].addr == 0\n        assert floors[4].protocol == epm.FloorProtocol.IP\n        assert floors[4].lhs == b\"\"\n        assert floors[4].rhs", "\n\ndef test_ept_map_result_pack_handle() -> None:\n    expected = (\n        b\"\\x00\\x00\\x00\\x00\\xc9\\x53\\xc3\\x6b\"\n        b\"\\xe9\\x11\\xaa\\x47\\xb6\\xfd\\x13\\x8d\"\n        b\"\\x04\\xda\\x08\\x9d\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\"\n    )\n\n    msg = epm.EptMapResult(\n        entry_handle=(0, uuid.UUID(\"6bc353c9-11e9-47aa-b6fd-138d04da089d\")),\n        towers=[],\n        status=0,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_ept_map_result_unpack_handle() -> None:\n    data = (\n        b\"\\x00\\x00\\x00\\x00\\xc9\\x53\\xc3\\x6b\"\n        b\"\\xe9\\x11\\xaa\\x47\\xb6\\xfd\\x13\\x8d\"\n        b\"\\x04\\xda\\x08\\x9d\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\"\n    )\n\n    resp = epm.EptMapResult.unpack(data)\n    assert isinstance(resp, epm.EptMapResult)\n    assert resp.entry_handle == (0, uuid.UUID(\"6bc353c9-11e9-47aa-b6fd-138d04da089d\"))\n    assert len(resp.towers) == 0", "\n\ndef test_unpack_unknown_floor() -> None:\n    data = b\"\\x02\\x00\\xFF\\x00\\x01\\x00\\x00\"\n\n    msg = epm.Floor.unpack(data)\n\n    assert msg.protocol == epm.FloorProtocol(0xFF)\n    assert msg.lhs == b\"\\x00\"\n    assert msg.rhs == b\"\\x00\"", ""]}
{"filename": "tests/__init__.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n"]}
{"filename": "tests/test_gkdi.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport typing as t\nimport uuid\n\nimport pytest\nfrom cryptography.hazmat.primitives import hashes", "import pytest\nfrom cryptography.hazmat.primitives import hashes\n\nfrom dpapi_ng import _blob as blob\nfrom dpapi_ng import _gkdi as gkdi\n\nfrom .conftest import get_test_data\n\n\ndef test_get_key_pack() -> None:\n    expected = (\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x01\\x02\\x03\\x04\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x20\\x44\\x29\\x73\\x7f\\x91\\x6a\\x41\"\n        b\"\\x9e\\xc3\\x86\\x08\\x2a\\xfa\\xfb\\x9e\"\n        b\"\\xff\\xff\\xff\\xff\\x01\\x00\\x00\\x00\"\n        b\"\\x1f\\x00\\x00\\x00\"\n    )\n\n    msg = gkdi.GetKey(\n        target_sd=b\"\\x01\\x02\\x03\\x04\",\n        root_key_id=uuid.UUID(\"73294420-917f-416a-9ec3-86082afafb9e\"),\n        l0_key_id=-1,\n        l1_key_id=1,\n        l2_key_id=31,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\ndef test_get_key_pack() -> None:\n    expected = (\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x01\\x02\\x03\\x04\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x20\\x44\\x29\\x73\\x7f\\x91\\x6a\\x41\"\n        b\"\\x9e\\xc3\\x86\\x08\\x2a\\xfa\\xfb\\x9e\"\n        b\"\\xff\\xff\\xff\\xff\\x01\\x00\\x00\\x00\"\n        b\"\\x1f\\x00\\x00\\x00\"\n    )\n\n    msg = gkdi.GetKey(\n        target_sd=b\"\\x01\\x02\\x03\\x04\",\n        root_key_id=uuid.UUID(\"73294420-917f-416a-9ec3-86082afafb9e\"),\n        l0_key_id=-1,\n        l1_key_id=1,\n        l2_key_id=31,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_get_key_unpack() -> None:\n    data = (\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x01\\x02\\x03\\x04\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x20\\x44\\x29\\x73\\x7f\\x91\\x6a\\x41\"\n        b\"\\x9e\\xc3\\x86\\x08\\x2a\\xfa\\xfb\\x9e\"\n        b\"\\xff\\xff\\xff\\xff\\x01\\x00\\x00\\x00\"\n        b\"\\x1f\\x00\\x00\\x00\"\n    )\n    resp = gkdi.GetKey.unpack(data)\n    assert isinstance(resp, gkdi.GetKey)\n    assert resp.target_sd == b\"\\x01\\x02\\x03\\x04\"\n    assert resp.root_key_id == uuid.UUID(\"73294420-917f-416a-9ec3-86082afafb9e\")\n    assert resp.l0_key_id == -1\n    assert resp.l1_key_id == 1\n    assert resp.l2_key_id == 31", "\n\ndef test_get_key_pack_no_root_key() -> None:\n    expected = (\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x01\\x02\\x03\\x04\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\xff\\xff\\xff\\xff\\x01\\x00\\x00\\x00\"\n        b\"\\x1f\\x00\\x00\\x00\"\n    )\n\n    msg = gkdi.GetKey(\n        target_sd=b\"\\x01\\x02\\x03\\x04\",\n        root_key_id=None,\n        l0_key_id=-1,\n        l1_key_id=1,\n        l2_key_id=31,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_get_key_unpack_no_root_key() -> None:\n    data = (\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x01\\x02\\x03\\x04\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\xff\\xff\\xff\\xff\\x01\\x00\\x00\\x00\"\n        b\"\\x1f\\x00\\x00\\x00\"\n    )\n    resp = gkdi.GetKey.unpack(data)\n    assert isinstance(resp, gkdi.GetKey)\n    assert resp.target_sd == b\"\\x01\\x02\\x03\\x04\"\n    assert resp.root_key_id is None\n    assert resp.l0_key_id == -1\n    assert resp.l1_key_id == 1\n    assert resp.l2_key_id == 31", "\n\ndef test_get_key_unpack_response() -> None:\n    expected = gkdi.GroupKeyEnvelope(1, 0, 0, 0, 0, uuid.UUID(int=0), \"\", b\"\", \"\", b\"\", 0, 0, \"\", \"\", b\"\", b\"\")\n    b_expected = expected.pack()\n    data = (\n        len(b_expected).to_bytes(4, byteorder=\"little\")\n        + (b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\")\n        + b_expected\n        + b\"\\x00\\x00\\x00\\x00\"\n    )\n\n    actual = gkdi.GetKey.unpack_response(data)\n    assert isinstance(actual, gkdi.GroupKeyEnvelope)\n    assert actual == expected", "\n\ndef test_get_key_unpack_response_fail() -> None:\n    data = b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x57\\x00\\x07\\x80\"\n\n    with pytest.raises(Exception, match=\"GetKey failed 0x80070057\"):\n        gkdi.GetKey.unpack_response(data)\n\n\ndef test_kdf_parameters_pack() -> None:\n    expected = (\n        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x53\\x00\\x48\\x00\\x41\\x00\\x35\\x00\"\n        b\"\\x31\\x00\\x32\\x00\\x00\\x00\"\n    )\n\n    msg = gkdi.KDFParameters(\"SHA512\")\n    actual = msg.pack()\n    assert actual == expected", "\ndef test_kdf_parameters_pack() -> None:\n    expected = (\n        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x53\\x00\\x48\\x00\\x41\\x00\\x35\\x00\"\n        b\"\\x31\\x00\\x32\\x00\\x00\\x00\"\n    )\n\n    msg = gkdi.KDFParameters(\"SHA512\")\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_kdf_parameters_unpack() -> None:\n    data = (\n        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x53\\x00\\x48\\x00\\x41\\x00\\x35\\x00\"\n        b\"\\x31\\x00\\x32\\x00\\x00\\x00\"\n    )\n\n    msg = gkdi.KDFParameters.unpack(data)\n    assert msg.hash_name == \"SHA512\"", "\n\n@pytest.mark.parametrize(\n    \"name, expected\",\n    [\n        (\"SHA1\", hashes.SHA1),\n        (\"SHA256\", hashes.SHA256),\n        (\"SHA384\", hashes.SHA384),\n        (\"SHA512\", hashes.SHA512),\n    ],", "        (\"SHA512\", hashes.SHA512),\n    ],\n)\ndef test_kdf_parameter_hash_algo(\n    name: str,\n    expected: t.Type[hashes.HashAlgorithm],\n) -> None:\n    msg = gkdi.KDFParameters(name)\n    assert isinstance(msg.hash_algorithm, expected)\n", "\n\ndef test_kdf_parameters_invalid_hash() -> None:\n    with pytest.raises(NotImplementedError, match=\"Unsupported hash algorithm MD5\"):\n        gkdi.KDFParameters(\"MD5\").hash_algorithm\n\n\ndef test_kdf_parameters_invalid_magic() -> None:\n    data = b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x01\"\n\n    with pytest.raises(ValueError, match=\"Failed to unpack KDFParameters as magic identifier is invalid\"):\n        gkdi.KDFParameters.unpack(data)", "\n\ndef test_ffc_dh_parameters_pack() -> None:\n    expected = get_test_data(\"ffc_dh_parameters\")\n\n    msg = gkdi.FFCDHParameters(\n        key_length=256,\n        field_order=17125458317614137930196041979257577826408832324037508573393292981642667139747621778802438775238728592968344613589379932348475613503476932163166973813218698343816463289144185362912602522540494983090531497232965829536524507269848825658311420299335922295709743267508322525966773950394919257576842038771632742044142471053509850123605883815857162666917775193496157372656195558305727009891276006514000409365877218171388319923896309377791762590614311849642961380224851940460421710449368927252974870395873936387909672274883295377481008150475878590270591798350563488168080923804611822387520198054002990623911454389104774092183,\n        generator=8041367327046189302693984665026706374844608289874374425728797669509435881459140662650215832833471328470334064628508692231999401840332046192569287351991689963279656892562484773278584208040987631569628520464069532361274047374444344996651832979378318849943741662110395995778429270819222431610927356005913836932462099770076239554042855287138026806960470277326229482818003962004453764400995790974042663675692120758726145869061236443893509136147942414445551848162391468541444355707785697825741856849161233887307017428371823608125699892904960841221593344499088996021883972185241854777608212592397013510086894908468466292313,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_ffc_dh_parameters_pack_small_int() -> None:\n    expected = b\"\\x0C\\x02\\x00\\x00\\x44\\x48\\x50\\x4D\\x00\\x01\\x00\\x00\" + (b\"\\x00\" * 512)\n\n    msg = gkdi.FFCDHParameters(\n        key_length=256,\n        field_order=0,\n        generator=0,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_ffc_dh_parameters_unpack() -> None:\n    data = get_test_data(\"ffc_dh_parameters\")\n\n    msg = gkdi.FFCDHParameters.unpack(data)\n    assert msg.key_length == 256\n    assert (\n        msg.field_order\n        == 17125458317614137930196041979257577826408832324037508573393292981642667139747621778802438775238728592968344613589379932348475613503476932163166973813218698343816463289144185362912602522540494983090531497232965829536524507269848825658311420299335922295709743267508322525966773950394919257576842038771632742044142471053509850123605883815857162666917775193496157372656195558305727009891276006514000409365877218171388319923896309377791762590614311849642961380224851940460421710449368927252974870395873936387909672274883295377481008150475878590270591798350563488168080923804611822387520198054002990623911454389104774092183\n    )\n    assert (\n        msg.generator\n        == 8041367327046189302693984665026706374844608289874374425728797669509435881459140662650215832833471328470334064628508692231999401840332046192569287351991689963279656892562484773278584208040987631569628520464069532361274047374444344996651832979378318849943741662110395995778429270819222431610927356005913836932462099770076239554042855287138026806960470277326229482818003962004453764400995790974042663675692120758726145869061236443893509136147942414445551848162391468541444355707785697825741856849161233887307017428371823608125699892904960841221593344499088996021883972185241854777608212592397013510086894908468466292313\n    )", "\n\ndef test_ffc_dh_parameters_invalid_magic() -> None:\n    data = b\"\\x00\\x00\\x00\\x00\\x44\\x48\\x50\\x00\"\n\n    with pytest.raises(ValueError, match=\"Failed to unpack FFCDHParameters as magic identifier is invalid\"):\n        gkdi.FFCDHParameters.unpack(data)\n\n\ndef test_ffc_dh_key_pack() -> None:\n    expected = get_test_data(\"ffc_dh_key\")\n\n    msg = gkdi.FFCDHKey(\n        key_length=256,\n        field_order=17125458317614137930196041979257577826408832324037508573393292981642667139747621778802438775238728592968344613589379932348475613503476932163166973813218698343816463289144185362912602522540494983090531497232965829536524507269848825658311420299335922295709743267508322525966773950394919257576842038771632742044142471053509850123605883815857162666917775193496157372656195558305727009891276006514000409365877218171388319923896309377791762590614311849642961380224851940460421710449368927252974870395873936387909672274883295377481008150475878590270591798350563488168080923804611822387520198054002990623911454389104774092183,\n        generator=8041367327046189302693984665026706374844608289874374425728797669509435881459140662650215832833471328470334064628508692231999401840332046192569287351991689963279656892562484773278584208040987631569628520464069532361274047374444344996651832979378318849943741662110395995778429270819222431610927356005913836932462099770076239554042855287138026806960470277326229482818003962004453764400995790974042663675692120758726145869061236443893509136147942414445551848162391468541444355707785697825741856849161233887307017428371823608125699892904960841221593344499088996021883972185241854777608212592397013510086894908468466292313,\n        public_key=5704885921161305204062286453104607919457992927353423073733430775789858496179130688612797173128744245915638749285001365389666398628213879947801588663753164579318944467717026038784117675067248922438216443819787917524104523712708262452393840096093436355765031795113819575193160867788883459494877281145141827767886732955150877747794489653818702322115914625862335942729341854451475767409522001908542192343439374586040439834199899031631166319847176777504380608639274486108367307182844033431414378380156678122207936287391923825983630503829617043562049870198440347689535112361024113575576761204481698354807673154816364980520,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\ndef test_ffc_dh_key_pack() -> None:\n    expected = get_test_data(\"ffc_dh_key\")\n\n    msg = gkdi.FFCDHKey(\n        key_length=256,\n        field_order=17125458317614137930196041979257577826408832324037508573393292981642667139747621778802438775238728592968344613589379932348475613503476932163166973813218698343816463289144185362912602522540494983090531497232965829536524507269848825658311420299335922295709743267508322525966773950394919257576842038771632742044142471053509850123605883815857162666917775193496157372656195558305727009891276006514000409365877218171388319923896309377791762590614311849642961380224851940460421710449368927252974870395873936387909672274883295377481008150475878590270591798350563488168080923804611822387520198054002990623911454389104774092183,\n        generator=8041367327046189302693984665026706374844608289874374425728797669509435881459140662650215832833471328470334064628508692231999401840332046192569287351991689963279656892562484773278584208040987631569628520464069532361274047374444344996651832979378318849943741662110395995778429270819222431610927356005913836932462099770076239554042855287138026806960470277326229482818003962004453764400995790974042663675692120758726145869061236443893509136147942414445551848162391468541444355707785697825741856849161233887307017428371823608125699892904960841221593344499088996021883972185241854777608212592397013510086894908468466292313,\n        public_key=5704885921161305204062286453104607919457992927353423073733430775789858496179130688612797173128744245915638749285001365389666398628213879947801588663753164579318944467717026038784117675067248922438216443819787917524104523712708262452393840096093436355765031795113819575193160867788883459494877281145141827767886732955150877747794489653818702322115914625862335942729341854451475767409522001908542192343439374586040439834199899031631166319847176777504380608639274486108367307182844033431414378380156678122207936287391923825983630503829617043562049870198440347689535112361024113575576761204481698354807673154816364980520,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_ffc_dh_key_pack_small_int() -> None:\n    expected = b\"\\x44\\x48\\x50\\x42\\x00\\x01\\x00\\x00\" + (b\"\\x00\" * 768)\n\n    msg = gkdi.FFCDHKey(\n        key_length=256,\n        field_order=0,\n        generator=0,\n        public_key=0,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_ffc_dh_key_unpack() -> None:\n    data = get_test_data(\"ffc_dh_key\")\n\n    msg = gkdi.FFCDHKey.unpack(data)\n    assert msg.key_length == 256\n    assert (\n        msg.field_order\n        == 17125458317614137930196041979257577826408832324037508573393292981642667139747621778802438775238728592968344613589379932348475613503476932163166973813218698343816463289144185362912602522540494983090531497232965829536524507269848825658311420299335922295709743267508322525966773950394919257576842038771632742044142471053509850123605883815857162666917775193496157372656195558305727009891276006514000409365877218171388319923896309377791762590614311849642961380224851940460421710449368927252974870395873936387909672274883295377481008150475878590270591798350563488168080923804611822387520198054002990623911454389104774092183\n    )\n    assert (\n        msg.generator\n        == 8041367327046189302693984665026706374844608289874374425728797669509435881459140662650215832833471328470334064628508692231999401840332046192569287351991689963279656892562484773278584208040987631569628520464069532361274047374444344996651832979378318849943741662110395995778429270819222431610927356005913836932462099770076239554042855287138026806960470277326229482818003962004453764400995790974042663675692120758726145869061236443893509136147942414445551848162391468541444355707785697825741856849161233887307017428371823608125699892904960841221593344499088996021883972185241854777608212592397013510086894908468466292313\n    )\n    assert (\n        msg.public_key\n        == 5704885921161305204062286453104607919457992927353423073733430775789858496179130688612797173128744245915638749285001365389666398628213879947801588663753164579318944467717026038784117675067248922438216443819787917524104523712708262452393840096093436355765031795113819575193160867788883459494877281145141827767886732955150877747794489653818702322115914625862335942729341854451475767409522001908542192343439374586040439834199899031631166319847176777504380608639274486108367307182844033431414378380156678122207936287391923825983630503829617043562049870198440347689535112361024113575576761204481698354807673154816364980520\n    )", "\n\ndef test_ffc_dh_key_invalid_magic() -> None:\n    data = b\"\\x00\\x00\\x00\\x00\"\n\n    with pytest.raises(ValueError, match=\"Failed to unpack FFCDHKey as magic identifier is invalid\"):\n        gkdi.FFCDHKey.unpack(data)\n\n\ndef test_ecdh_key_pack() -> None:\n    expected = get_test_data(\"ecdh_key\")\n\n    msg = gkdi.ECDHKey(\n        curve_name=\"P256\",\n        key_length=32,\n        x=25243830316603712129559807215192800963817053918117758232684283953073092162706,\n        y=5597696687659389228845157203945777531845995814681629604081047981407116394432,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\ndef test_ecdh_key_pack() -> None:\n    expected = get_test_data(\"ecdh_key\")\n\n    msg = gkdi.ECDHKey(\n        curve_name=\"P256\",\n        key_length=32,\n        x=25243830316603712129559807215192800963817053918117758232684283953073092162706,\n        y=5597696687659389228845157203945777531845995814681629604081047981407116394432,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_ecdh_key_pack_small_int() -> None:\n    expected = b\"\\x45\\x43\\x4B\\x31\\x20\\x00\\x00\\x00\" + (b\"\\x00\" * 64)\n    msg = gkdi.ECDHKey(\n        curve_name=\"P256\",\n        key_length=32,\n        x=0,\n        y=0,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_ecdh_key_pack_invalid_curve() -> None:\n    with pytest.raises(ValueError, match=\"Unknown curve 'test', cannot pack\"):\n        gkdi.ECDHKey(curve_name=\"test\", key_length=0, x=0, y=0).pack()\n\n\ndef test_ecdh_key_unpack() -> None:\n    data = get_test_data(\"ecdh_key\")\n\n    msg = gkdi.ECDHKey.unpack(data)\n    assert msg.key_length == 32\n    assert msg.curve_name == \"P256\"\n    assert msg.curve_and_hash\n    assert msg.x == 25243830316603712129559807215192800963817053918117758232684283953073092162706\n    assert msg.y == 5597696687659389228845157203945777531845995814681629604081047981407116394432", "\n\ndef test_ecdh_key_unpack_invalid_curve() -> None:\n    data = b\"\\x00\\x00\\x00\\x00\"\n\n    with pytest.raises(ValueError, match=\"Failed to unpack ECDHKey with unknown curve 0x00000000\"):\n        gkdi.ECDHKey.unpack(data)\n\n\ndef test_group_key_envelope_pack() -> None:\n    expected = get_test_data(\"group_key_envelope\")\n    l1 = (\n        b\"\\x9C\\x8F\\x03\\x85\\xD7\\x46\\x06\\x2A\"\n        b\"\\xFB\\x90\\xBA\\x9D\\x02\\x3A\\x3A\\x5C\"\n        b\"\\x24\\x2E\\xB5\\x33\\x43\\x41\\xBE\\xFA\"\n        b\"\\xDC\\x49\\xE2\\x7A\\x90\\x8F\\xC3\\x39\"\n        b\"\\x3B\\xAC\\x40\\x14\\x56\\xA8\\x65\\x61\"\n        b\"\\x04\\xC8\\x72\\xD0\\xC9\\x96\\xAA\\x25\"\n        b\"\\x9A\\x95\\x4B\\xF5\\xA3\\x8B\\x8D\\x6E\"\n        b\"\\xC7\\xCD\\xBA\\xC1\\x35\\x9E\\x5A\\x09\"\n    )\n    l2 = (\n        b\"\\x1B\\xAC\\x68\\xA1\\xA7\\xC8\\xB9\\xAC\"\n        b\"\\x94\\x4C\\x8E\\xB1\\xEA\\x39\\x6C\\xC3\"\n        b\"\\x66\\x68\\x5E\\x17\\xA4\\x11\\x0A\\x1F\"\n        b\"\\xB5\\x5E\\x7C\\x44\\x11\\xA6\\xFA\\xA5\"\n        b\"\\x8F\\x8E\\x5B\\xE1\\x25\\x24\\xFA\\xBB\"\n        b\"\\xC3\\x44\\xC5\\x9B\\xEA\\xF9\\xB3\\xEC\"\n        b\"\\xE2\\x18\\xEA\\x8E\\x4F\\x81\\x1B\\x6C\"\n        b\"\\xAF\\xEA\\x4B\\x77\\xE7\\xEF\\x0A\\xED\"\n    )\n\n    msg = gkdi.GroupKeyEnvelope(\n        version=1,\n        flags=2,\n        l0=361,\n        l1=17,\n        l2=8,\n        root_key_identifier=uuid.UUID(\"d778c271-9025-9a82-f6dc-b8960b8ad8c5\"),\n        kdf_algorithm=\"SP800_108_CTR_HMAC\",\n        kdf_parameters=(\n            b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n            b\"\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n            b\"\\x53\\x00\\x48\\x00\\x41\\x00\\x35\\x00\"\n            b\"\\x31\\x00\\x32\\x00\\x00\\x00\"\n        ),\n        secret_algorithm=\"DH\",\n        secret_parameters=get_test_data(\"ffc_dh_parameters\"),\n        private_key_length=512,\n        public_key_length=2048,\n        domain_name=\"domain.test\",\n        forest_name=\"domain.test\",\n        l1_key=l1,\n        l2_key=l2,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\ndef test_group_key_envelope_pack() -> None:\n    expected = get_test_data(\"group_key_envelope\")\n    l1 = (\n        b\"\\x9C\\x8F\\x03\\x85\\xD7\\x46\\x06\\x2A\"\n        b\"\\xFB\\x90\\xBA\\x9D\\x02\\x3A\\x3A\\x5C\"\n        b\"\\x24\\x2E\\xB5\\x33\\x43\\x41\\xBE\\xFA\"\n        b\"\\xDC\\x49\\xE2\\x7A\\x90\\x8F\\xC3\\x39\"\n        b\"\\x3B\\xAC\\x40\\x14\\x56\\xA8\\x65\\x61\"\n        b\"\\x04\\xC8\\x72\\xD0\\xC9\\x96\\xAA\\x25\"\n        b\"\\x9A\\x95\\x4B\\xF5\\xA3\\x8B\\x8D\\x6E\"\n        b\"\\xC7\\xCD\\xBA\\xC1\\x35\\x9E\\x5A\\x09\"\n    )\n    l2 = (\n        b\"\\x1B\\xAC\\x68\\xA1\\xA7\\xC8\\xB9\\xAC\"\n        b\"\\x94\\x4C\\x8E\\xB1\\xEA\\x39\\x6C\\xC3\"\n        b\"\\x66\\x68\\x5E\\x17\\xA4\\x11\\x0A\\x1F\"\n        b\"\\xB5\\x5E\\x7C\\x44\\x11\\xA6\\xFA\\xA5\"\n        b\"\\x8F\\x8E\\x5B\\xE1\\x25\\x24\\xFA\\xBB\"\n        b\"\\xC3\\x44\\xC5\\x9B\\xEA\\xF9\\xB3\\xEC\"\n        b\"\\xE2\\x18\\xEA\\x8E\\x4F\\x81\\x1B\\x6C\"\n        b\"\\xAF\\xEA\\x4B\\x77\\xE7\\xEF\\x0A\\xED\"\n    )\n\n    msg = gkdi.GroupKeyEnvelope(\n        version=1,\n        flags=2,\n        l0=361,\n        l1=17,\n        l2=8,\n        root_key_identifier=uuid.UUID(\"d778c271-9025-9a82-f6dc-b8960b8ad8c5\"),\n        kdf_algorithm=\"SP800_108_CTR_HMAC\",\n        kdf_parameters=(\n            b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n            b\"\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n            b\"\\x53\\x00\\x48\\x00\\x41\\x00\\x35\\x00\"\n            b\"\\x31\\x00\\x32\\x00\\x00\\x00\"\n        ),\n        secret_algorithm=\"DH\",\n        secret_parameters=get_test_data(\"ffc_dh_parameters\"),\n        private_key_length=512,\n        public_key_length=2048,\n        domain_name=\"domain.test\",\n        forest_name=\"domain.test\",\n        l1_key=l1,\n        l2_key=l2,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_group_key_envelope_unpack() -> None:\n    data = get_test_data(\"group_key_envelope\")\n    expected_l1 = (\n        b\"\\x9C\\x8F\\x03\\x85\\xD7\\x46\\x06\\x2A\"\n        b\"\\xFB\\x90\\xBA\\x9D\\x02\\x3A\\x3A\\x5C\"\n        b\"\\x24\\x2E\\xB5\\x33\\x43\\x41\\xBE\\xFA\"\n        b\"\\xDC\\x49\\xE2\\x7A\\x90\\x8F\\xC3\\x39\"\n        b\"\\x3B\\xAC\\x40\\x14\\x56\\xA8\\x65\\x61\"\n        b\"\\x04\\xC8\\x72\\xD0\\xC9\\x96\\xAA\\x25\"\n        b\"\\x9A\\x95\\x4B\\xF5\\xA3\\x8B\\x8D\\x6E\"\n        b\"\\xC7\\xCD\\xBA\\xC1\\x35\\x9E\\x5A\\x09\"\n    )\n    expected_l2 = (\n        b\"\\x1B\\xAC\\x68\\xA1\\xA7\\xC8\\xB9\\xAC\"\n        b\"\\x94\\x4C\\x8E\\xB1\\xEA\\x39\\x6C\\xC3\"\n        b\"\\x66\\x68\\x5E\\x17\\xA4\\x11\\x0A\\x1F\"\n        b\"\\xB5\\x5E\\x7C\\x44\\x11\\xA6\\xFA\\xA5\"\n        b\"\\x8F\\x8E\\x5B\\xE1\\x25\\x24\\xFA\\xBB\"\n        b\"\\xC3\\x44\\xC5\\x9B\\xEA\\xF9\\xB3\\xEC\"\n        b\"\\xE2\\x18\\xEA\\x8E\\x4F\\x81\\x1B\\x6C\"\n        b\"\\xAF\\xEA\\x4B\\x77\\xE7\\xEF\\x0A\\xED\"\n    )\n\n    msg = gkdi.GroupKeyEnvelope.unpack(data)\n    assert msg.version == 1\n    assert msg.flags == 2\n    assert msg.is_public_key is False\n    assert msg.l0 == 361\n    assert msg.l1 == 17\n    assert msg.l2 == 8\n    assert msg.root_key_identifier == uuid.UUID(\"d778c271-9025-9a82-f6dc-b8960b8ad8c5\")\n    assert msg.kdf_algorithm == \"SP800_108_CTR_HMAC\"\n    assert msg.kdf_parameters == (\n        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x53\\x00\\x48\\x00\\x41\\x00\\x35\\x00\"\n        b\"\\x31\\x00\\x32\\x00\\x00\\x00\"\n    )\n    assert msg.secret_algorithm == \"DH\"\n    assert msg.secret_parameters == get_test_data(\"ffc_dh_parameters\")\n    assert msg.private_key_length == 512\n    assert msg.public_key_length == 2048\n    assert msg.domain_name == \"domain.test\"\n    assert msg.forest_name == \"domain.test\"\n    assert msg.l1_key == expected_l1\n    assert msg.l2_key == expected_l2", "\n\ndef test_group_key_envelope_invalid_magic() -> None:\n    data = b\"\\x00\\x00\\x00\\x00\"\n\n    with pytest.raises(ValueError, match=\"Failed to unpack GroupKeyEnvelope as magic identifier is invalid\"):\n        gkdi.GroupKeyEnvelope.unpack(data)\n\n\ndef test_group_key_envelope_get_kek_is_public() -> None:\n    envelope = gkdi.GroupKeyEnvelope(\n        version=1,\n        flags=1,\n        l0=0,\n        l1=0,\n        l2=0,\n        root_key_identifier=uuid.UUID(int=0),\n        kdf_algorithm=\"\",\n        kdf_parameters=b\"\",\n        secret_algorithm=\"\",\n        secret_parameters=b\"\",\n        private_key_length=0,\n        public_key_length=0,\n        domain_name=\"\",\n        forest_name=\"\",\n        l1_key=b\"\",\n        l2_key=b\"\",\n    )\n\n    with pytest.raises(ValueError, match=\"Current user is not authorized to retrieve the KEK information\"):\n        envelope.get_kek(blob.KeyIdentifier(1, 1, 0, 0, 0, uuid.UUID(int=0), b\"\", \"\", \"\"))", "\ndef test_group_key_envelope_get_kek_is_public() -> None:\n    envelope = gkdi.GroupKeyEnvelope(\n        version=1,\n        flags=1,\n        l0=0,\n        l1=0,\n        l2=0,\n        root_key_identifier=uuid.UUID(int=0),\n        kdf_algorithm=\"\",\n        kdf_parameters=b\"\",\n        secret_algorithm=\"\",\n        secret_parameters=b\"\",\n        private_key_length=0,\n        public_key_length=0,\n        domain_name=\"\",\n        forest_name=\"\",\n        l1_key=b\"\",\n        l2_key=b\"\",\n    )\n\n    with pytest.raises(ValueError, match=\"Current user is not authorized to retrieve the KEK information\"):\n        envelope.get_kek(blob.KeyIdentifier(1, 1, 0, 0, 0, uuid.UUID(int=0), b\"\", \"\", \"\"))", "\n\ndef test_group_key_envelope_get_kek_l0_mismatch() -> None:\n    envelope = gkdi.GroupKeyEnvelope(\n        version=1,\n        flags=0,\n        l0=1,\n        l1=0,\n        l2=0,\n        root_key_identifier=uuid.UUID(int=0),\n        kdf_algorithm=\"test\",\n        kdf_parameters=b\"\",\n        secret_algorithm=\"\",\n        secret_parameters=b\"\",\n        private_key_length=0,\n        public_key_length=0,\n        domain_name=\"\",\n        forest_name=\"\",\n        l1_key=b\"\",\n        l2_key=b\"\",\n    )\n\n    with pytest.raises(ValueError, match=\"L0 index 1 does not match the requested L0 index 0\"):\n        envelope.get_kek(blob.KeyIdentifier(1, 1, 0, 0, 0, uuid.UUID(int=0), b\"\", \"\", \"\"))", "\n\ndef test_group_key_envelope_get_kek_invalid_kdf() -> None:\n    envelope = gkdi.GroupKeyEnvelope(\n        version=1,\n        flags=0,\n        l0=0,\n        l1=0,\n        l2=0,\n        root_key_identifier=uuid.UUID(int=0),\n        kdf_algorithm=\"test\",\n        kdf_parameters=b\"\",\n        secret_algorithm=\"\",\n        secret_parameters=b\"\",\n        private_key_length=0,\n        public_key_length=0,\n        domain_name=\"\",\n        forest_name=\"\",\n        l1_key=b\"\",\n        l2_key=b\"\",\n    )\n\n    with pytest.raises(NotImplementedError, match=\"Unknown KDF algorithm 'test'\"):\n        envelope.get_kek(blob.KeyIdentifier(1, 1, 0, 0, 0, uuid.UUID(int=0), b\"\", \"\", \"\"))", "\n\n# See tests/integration/files/generate_seed_keys.py on how to generate the\n# known values from the L1 seed key.\n@pytest.mark.parametrize(\n    \"l1, l2, l1_key, l2_key\",\n    [\n        (\n            0,\n            0,", "            0,\n            0,\n            b\"\",\n            (\n                b\"\\x1B\\x0F\\x11\\x3F\\x01\\x93\\x10\\xE5\"\n                b\"\\xA8\\x4E\\xA3\\x0B\\x3A\\xCB\\xC6\\x58\"\n                b\"\\x21\\x79\\xC9\\xB0\\x49\\x2B\\xA8\\x4A\"\n                b\"\\xF6\\xA2\\x5D\\xE3\\xCA\\x42\\x82\\xC9\"\n                b\"\\x1B\\x50\\x3B\\x7E\\x01\\x15\\x1E\\x29\"\n                b\"\\x27\\x72\\x93\\x07\\xDA\\x8E\\x60\\xC6\"", "                b\"\\x1B\\x50\\x3B\\x7E\\x01\\x15\\x1E\\x29\"\n                b\"\\x27\\x72\\x93\\x07\\xDA\\x8E\\x60\\xC6\"\n                b\"\\x4E\\x3D\\x3A\\xFB\\x66\\x80\\x06\\xE2\"\n                b\"\\x2F\\x2B\\xFF\\x7F\\x7C\\x14\\xAA\\x18\"\n            ),\n        ),\n        (\n            0,\n            31,\n            (", "            31,\n            (\n                b\"\\xC7\\xA2\\x2B\\x5B\\x09\\x70\\x53\\x80\"\n                b\"\\xB4\\x5C\\xDD\\x29\\x33\\xE0\\xFA\\xA6\"\n                b\"\\x8E\\xA2\\xC9\\x8A\\x3E\\x50\\x47\\x27\"\n                b\"\\x5D\\xD3\\xB2\\xE2\\xDC\\xCF\\x55\\x86\"\n                b\"\\xD7\\x2A\\x58\\xA0\\x76\\x2D\\x2E\\x5A\"\n                b\"\\x53\\x42\\x99\\xF5\\x40\\x5E\\x31\\xEE\"\n                b\"\\x51\\x4B\\xD4\\xE1\\x3A\\xA2\\xF5\\x4A\"\n                b\"\\xF0\\xC3\\x0C\\xDB\\xC9\\xCC\\x03\\x01\"", "                b\"\\x51\\x4B\\xD4\\xE1\\x3A\\xA2\\xF5\\x4A\"\n                b\"\\xF0\\xC3\\x0C\\xDB\\xC9\\xCC\\x03\\x01\"\n            ),\n            b\"\",\n        ),\n        (\n            31,\n            31,\n            (\n                b\"\\x60\\xE0\\xA8\\x1F\\x93\\x16\\x4F\\x5D\"", "            (\n                b\"\\x60\\xE0\\xA8\\x1F\\x93\\x16\\x4F\\x5D\"\n                b\"\\xC3\\xAB\\xE9\\x81\\xE1\\xEE\\x54\\xC1\"\n                b\"\\xA6\\xB9\\xB0\\xED\\xB6\\xFF\\x82\\x74\"\n                b\"\\x64\\x27\\x58\\xD2\\x9B\\xBC\\x66\\x55\"\n                b\"\\x9D\\x11\\xF1\\x87\\x1A\\x82\\xA6\\xE3\"\n                b\"\\xF2\\x32\\xC4\\x24\\x90\\xD7\\xC4\\x1C\"\n                b\"\\x6A\\xD2\\xB8\\xB1\\x89\\xFE\\x27\\x52\"\n                b\"\\xA8\\x8C\\xEC\\x2E\\xA4\\xB2\\x02\\x1C\"\n            ),", "                b\"\\xA8\\x8C\\xEC\\x2E\\xA4\\xB2\\x02\\x1C\"\n            ),\n            b\"\",\n        ),\n        (\n            2,\n            6,\n            (\n                b\"\\x58\\xC8\\xE7\\xF9\\xC2\\xB7\\x26\\x0B\"\n                b\"\\xE8\\x8F\\xB1\\x88\\xEB\\x62\\x1A\\x60\"", "                b\"\\x58\\xC8\\xE7\\xF9\\xC2\\xB7\\x26\\x0B\"\n                b\"\\xE8\\x8F\\xB1\\x88\\xEB\\x62\\x1A\\x60\"\n                b\"\\x91\\x97\\x74\\xB9\\x30\\x6F\\xCF\\xE4\"\n                b\"\\x5B\\x6C\\x17\\xD0\\x49\\x4A\\x43\\xD5\"\n                b\"\\x55\\xA2\\x74\\xE6\\xDD\\x79\\x5C\\xF0\"\n                b\"\\xA6\\x81\\x92\\x63\\xDD\\x3E\\xC9\\x12\"\n                b\"\\x5E\\xB9\\xC5\\xB6\\x2F\\xBE\\x04\\x1A\"\n                b\"\\x51\\x33\\xC1\\xA2\\xCB\\x0A\\x58\\x92\"\n            ),\n            b\"\",", "            ),\n            b\"\",\n        ),\n    ],\n    ids=[\n        \"ExactValue\",\n        \"FromL1Seed\",\n        \"FromRootSeed\",\n        \"L1AndL2Different\",\n    ],", "        \"L1AndL2Different\",\n    ],\n)\ndef test_compute_l2_key(\n    l1: int,\n    l2: int,\n    l1_key: bytes,\n    l2_key: bytes,\n) -> None:\n    expected = (\n        b\"\\x1B\\x0F\\x11\\x3F\\x01\\x93\\x10\\xE5\"\n        b\"\\xA8\\x4E\\xA3\\x0B\\x3A\\xCB\\xC6\\x58\"\n        b\"\\x21\\x79\\xC9\\xB0\\x49\\x2B\\xA8\\x4A\"\n        b\"\\xF6\\xA2\\x5D\\xE3\\xCA\\x42\\x82\\xC9\"\n        b\"\\x1B\\x50\\x3B\\x7E\\x01\\x15\\x1E\\x29\"\n        b\"\\x27\\x72\\x93\\x07\\xDA\\x8E\\x60\\xC6\"\n        b\"\\x4E\\x3D\\x3A\\xFB\\x66\\x80\\x06\\xE2\"\n        b\"\\x2F\\x2B\\xFF\\x7F\\x7C\\x14\\xAA\\x18\"\n    )\n    l0 = 361\n    key_id = uuid.UUID(\"2e1b932a-4e21-ced3-0b7b-8815aff8335d\")\n\n    actual = gkdi.compute_l2_key(\n        hashes.SHA512(),\n        0,\n        0,\n        gkdi.GroupKeyEnvelope(\n            version=1,\n            flags=0,\n            l0=l0,\n            l1=l1,\n            l2=l2,\n            root_key_identifier=key_id,\n            kdf_algorithm=\"\",\n            kdf_parameters=b\"\",\n            secret_algorithm=\"\",\n            secret_parameters=b\"\",\n            private_key_length=0,\n            public_key_length=0,\n            domain_name=\"\",\n            forest_name=\"\",\n            l1_key=l1_key,\n            l2_key=l2_key,\n        ),\n    )\n    assert actual == expected", "\n\ndef test_compute_kek_invalid_algorithm() -> None:\n    with pytest.raises(NotImplementedError, match=\"Unknown secret agreement algorithm 'test'\"):\n        gkdi.compute_kek_from_public_key(hashes.SHA256(), b\"\", \"test\", None, b\"\", 0)\n"]}
{"filename": "tests/test_client.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport base64\nimport json\nimport os\nimport typing as t\nimport uuid", "import typing as t\nimport uuid\n\nimport pytest\nfrom cryptography.hazmat.primitives.asymmetric import ec\n\nimport dpapi_ng\nimport dpapi_ng._client as client\nimport dpapi_ng._gkdi as gkdi\n", "import dpapi_ng._gkdi as gkdi\n\nfrom .conftest import get_test_data\n\n# These scenarios were created with tests/integration/files/New-KdsRootKey.ps1\n# and tests/integration/files/ConvertTo-DpapiNgBlob.ps1\n\n\ndef _load_root_key(scenario: str) -> tuple[bytes, dpapi_ng.KeyCache]:\n    data = json.loads(get_test_data(f\"{scenario}.json\"))\n\n    cache = dpapi_ng.KeyCache()\n    cache.load_key(\n        key=base64.b16decode(data[\"RootKeyData\"]),\n        root_key_id=uuid.UUID(data[\"RootKeyId\"]),\n        version=data[\"Version\"],\n        kdf_algorithm=data[\"KdfAlgorithm\"],\n        kdf_parameters=base64.b16decode(data[\"KdfParameters\"]),\n        secret_algorithm=data[\"SecretAgreementAlgorithm\"],\n        secret_parameters=base64.b16decode(data[\"SecretAgreementParameters\"]),\n        private_key_length=data[\"PrivateKeyLength\"],\n        public_key_length=data[\"PublicKeyLength\"],\n    )\n\n    return base64.b16decode(data[\"Data\"]), cache", "def _load_root_key(scenario: str) -> tuple[bytes, dpapi_ng.KeyCache]:\n    data = json.loads(get_test_data(f\"{scenario}.json\"))\n\n    cache = dpapi_ng.KeyCache()\n    cache.load_key(\n        key=base64.b16decode(data[\"RootKeyData\"]),\n        root_key_id=uuid.UUID(data[\"RootKeyId\"]),\n        version=data[\"Version\"],\n        kdf_algorithm=data[\"KdfAlgorithm\"],\n        kdf_parameters=base64.b16decode(data[\"KdfParameters\"]),\n        secret_algorithm=data[\"SecretAgreementAlgorithm\"],\n        secret_parameters=base64.b16decode(data[\"SecretAgreementParameters\"]),\n        private_key_length=data[\"PrivateKeyLength\"],\n        public_key_length=data[\"PublicKeyLength\"],\n    )\n\n    return base64.b16decode(data[\"Data\"]), cache", "\n\n@pytest.mark.parametrize(\n    \"scenario\",\n    [\n        \"kdf_sha1_nonce\",\n        \"kdf_sha256_nonce\",\n        \"kdf_sha384_nonce\",\n        \"kdf_sha512_nonce\",\n    ],", "        \"kdf_sha512_nonce\",\n    ],\n)\ndef test_protect_secret(scenario: str) -> None:\n    test_data = b\"schorschii\"\n    test_protection_descriptor = \"S-1-5-21-2185496602-3367037166-1388177638-1103\"\n\n    key_cache = _load_root_key(scenario)[1]\n    test_root_key_identifier = list(key_cache._root_keys.keys())[0]\n\n    encrypted = dpapi_ng.ncrypt_protect_secret(\n        test_data,\n        test_protection_descriptor,\n        root_key_identifier=test_root_key_identifier,\n        cache=key_cache,\n    )\n    decrypted = dpapi_ng.ncrypt_unprotect_secret(encrypted, cache=key_cache)\n    assert test_data == decrypted", "\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\n    \"scenario\",\n    [\n        \"kdf_sha1_nonce\",\n        \"kdf_sha256_nonce\",\n        \"kdf_sha384_nonce\",\n        \"kdf_sha512_nonce\",", "        \"kdf_sha384_nonce\",\n        \"kdf_sha512_nonce\",\n    ],\n)\nasync def test_async_protect_secret(scenario: str) -> None:\n    test_data = b\"schorschii\"\n    test_protection_descriptor = \"S-1-5-21-2185496602-3367037166-1388177638-1103\"\n\n    key_cache = _load_root_key(scenario)[1]\n    test_root_key_identifier = list(key_cache._root_keys.keys())[0]", "    key_cache = _load_root_key(scenario)[1]\n    test_root_key_identifier = list(key_cache._root_keys.keys())[0]\n\n    encrypted = await dpapi_ng.async_ncrypt_protect_secret(\n        test_data,\n        test_protection_descriptor,\n        root_key_identifier=test_root_key_identifier,\n        cache=key_cache,\n    )\n    decrypted = await dpapi_ng.async_ncrypt_unprotect_secret(encrypted, cache=key_cache)", "    )\n    decrypted = await dpapi_ng.async_ncrypt_unprotect_secret(encrypted, cache=key_cache)\n    assert test_data == decrypted\n\n\n@pytest.mark.parametrize(\n    \"kdf_algo, secret_algo\",\n    [\n        (\"SHA1\", \"DH\"),\n        (\"SHA1\", \"ECDH_P256\"),", "        (\"SHA1\", \"DH\"),\n        (\"SHA1\", \"ECDH_P256\"),\n        (\"SHA1\", \"ECDH_P384\"),\n        (\"SHA256\", \"DH\"),\n        (\"SHA256\", \"ECDH_P256\"),\n        (\"SHA256\", \"ECDH_P384\"),\n        (\"SHA384\", \"DH\"),\n        (\"SHA384\", \"ECDH_P256\"),\n        (\"SHA384\", \"ECDH_P384\"),\n        (\"SHA512\", \"DH\"),", "        (\"SHA384\", \"ECDH_P384\"),\n        (\"SHA512\", \"DH\"),\n        (\"SHA512\", \"ECDH_P256\"),\n        (\"SHA512\", \"ECDH_P384\"),\n    ],\n)\ndef test_protect_secret_public_key(\n    kdf_algo: str,\n    secret_algo: str,\n    monkeypatch: pytest.MonkeyPatch,\n) -> None:\n    test_data = b\"schorschii\"\n    test_protection_descriptor = \"S-1-5-21-2185496602-3367037166-1388177638-1103\"\n\n    private_key_length, public_key_length = {\n        \"DH\": (512, 2048),\n        \"ECDH_P256\": (256, 256),\n        \"ECDH_P384\": (384, 384),\n        \"ECDH_P521\": (521, 521),\n    }[secret_algo]\n\n    root_key_id = uuid.uuid4()\n    key_cache = dpapi_ng.KeyCache()\n    key_cache.load_key(\n        os.urandom(64),\n        root_key_id=root_key_id,\n        version=1,\n        kdf_parameters=gkdi.KDFParameters(kdf_algo).pack(),\n        secret_algorithm=secret_algo,\n        private_key_length=private_key_length,\n        public_key_length=public_key_length,\n    )\n\n    original_get_gke = client._get_protection_gke_from_cache\n\n    def get_protection_gke(\n        root_key_identifier: t.Optional[uuid.UUID],\n        target_sd: bytes,\n        cache: client.KeyCache,\n    ) -> gkdi.GroupKeyEnvelope:\n        gke = original_get_gke(root_key_identifier, target_sd, cache)\n        assert gke\n\n        private_key = gkdi.kdf(\n            gkdi.KDFParameters.unpack(gke.kdf_parameters).hash_algorithm,\n            gke.l2_key,\n            gkdi.KDS_SERVICE_LABEL,\n            (gke.secret_algorithm + \"\\0\").encode(\"utf-16-le\"),\n            (gke.private_key_length // 8),\n        )\n\n        if gke.secret_algorithm == \"DH\":\n            secret_params = gkdi.FFCDHParameters.unpack(gke.secret_parameters)\n            public_key = pow(\n                secret_params.generator,\n                int.from_bytes(private_key, byteorder=\"big\"),\n                secret_params.field_order,\n            )\n\n            pub_key = gkdi.FFCDHKey(\n                key_length=secret_params.key_length,\n                field_order=secret_params.field_order,\n                generator=secret_params.generator,\n                public_key=public_key,\n            ).pack()\n        else:\n            curve, curve_name = {\n                \"ECDH_P256\": (ec.SECP256R1(), \"P256\"),\n                \"ECDH_P384\": (ec.SECP384R1(), \"P384\"),\n                \"ECDH_P521\": (ec.SECP521R1(), \"P521\"),\n            }[gke.secret_algorithm]\n\n            ecdh_private = ec.derive_private_key(\n                int.from_bytes(private_key, byteorder=\"big\"),\n                curve,\n            )\n            key_numbers = ecdh_private.public_key().public_numbers()\n\n            pub_key = gkdi.ECDHKey(\n                curve_name=curve_name,\n                key_length=ecdh_private.key_size // 8,\n                x=key_numbers.x,\n                y=key_numbers.y,\n            ).pack()\n\n        object.__setattr__(gke, \"flags\", 1)\n        object.__setattr__(gke, \"l2_key\", pub_key)\n\n        return gke\n\n    monkeypatch.setattr(client, \"_get_protection_gke_from_cache\", get_protection_gke)\n\n    encrypted = dpapi_ng.ncrypt_protect_secret(\n        test_data,\n        test_protection_descriptor,\n        root_key_identifier=root_key_id,\n        cache=key_cache,\n    )\n    decrypted = dpapi_ng.ncrypt_unprotect_secret(encrypted, cache=key_cache)\n    assert test_data == decrypted", "\n\n@pytest.mark.parametrize(\n    \"scenario\",\n    [\n        \"kdf_sha1_nonce\",\n        \"kdf_sha256_nonce\",\n        \"kdf_sha384_nonce\",\n        \"kdf_sha512_nonce\",\n        \"kdf_sha1_dh\",", "        \"kdf_sha512_nonce\",\n        \"kdf_sha1_dh\",\n        \"kdf_sha256_dh\",\n        \"kdf_sha384_dh\",\n        \"kdf_sha512_dh\",\n        \"kdf_sha1_ecdh_p256\",\n        \"kdf_sha256_ecdh_p256\",\n        \"kdf_sha384_ecdh_p256\",\n        \"kdf_sha512_ecdh_p256\",\n        \"kdf_sha1_ecdh_p384\",", "        \"kdf_sha512_ecdh_p256\",\n        \"kdf_sha1_ecdh_p384\",\n        \"kdf_sha256_ecdh_p384\",\n        \"kdf_sha384_ecdh_p384\",\n        \"kdf_sha512_ecdh_p384\",\n    ],\n)\ndef test_unprotect_secret(\n    scenario: str,\n) -> None:\n    expected = b\"\\x00\"\n\n    data, key_cache = _load_root_key(scenario)\n\n    actual = dpapi_ng.ncrypt_unprotect_secret(data, cache=key_cache)\n    assert actual == expected", "\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\n    \"scenario\",\n    [\n        \"kdf_sha1_nonce\",\n        \"kdf_sha256_nonce\",\n        \"kdf_sha384_nonce\",\n        \"kdf_sha512_nonce\",", "        \"kdf_sha384_nonce\",\n        \"kdf_sha512_nonce\",\n        \"kdf_sha1_dh\",\n        \"kdf_sha256_dh\",\n        \"kdf_sha384_dh\",\n        \"kdf_sha512_dh\",\n        \"kdf_sha1_ecdh_p256\",\n        \"kdf_sha256_ecdh_p256\",\n        \"kdf_sha384_ecdh_p256\",\n        \"kdf_sha512_ecdh_p256\",", "        \"kdf_sha384_ecdh_p256\",\n        \"kdf_sha512_ecdh_p256\",\n        \"kdf_sha1_ecdh_p384\",\n        \"kdf_sha256_ecdh_p384\",\n        \"kdf_sha384_ecdh_p384\",\n        \"kdf_sha512_ecdh_p384\",\n    ],\n)\nasync def test_async_unprotect_secret(\n    scenario: str,", "async def test_async_unprotect_secret(\n    scenario: str,\n) -> None:\n    expected = b\"\\x00\"\n\n    data, key_cache = _load_root_key(scenario)\n\n    actual = await dpapi_ng.async_ncrypt_unprotect_secret(data, cache=key_cache)\n    assert actual == expected\n", "    assert actual == expected\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport pathlib\n\n\ndef get_test_data(name: str) -> bytes:\n    test_path = pathlib.Path(__file__).parent / \"data\" / name\n    return test_path.read_bytes()", "def get_test_data(name: str) -> bytes:\n    test_path = pathlib.Path(__file__).parent / \"data\" / name\n    return test_path.read_bytes()\n"]}
{"filename": "tests/test_blob.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport uuid\n\nfrom dpapi_ng import _blob as blob\n\nfrom .conftest import get_test_data", "\nfrom .conftest import get_test_data\n\n\ndef test_blob_unpack() -> None:\n    data = get_test_data(\"dpapi_ng_blob\")\n\n    msg = blob.DPAPINGBlob.unpack(data)\n    assert msg.key_identifier.version == 1\n    assert msg.key_identifier.flags == 3\n    assert msg.key_identifier.is_public_key\n    assert msg.key_identifier.l0 == 361\n    assert msg.key_identifier.l1 == 16\n    assert msg.key_identifier.l2 == 3\n    assert msg.key_identifier.root_key_identifier == uuid.UUID(\"d778c271-9025-9a82-f6dc-b8960b8ad8c5\")\n    assert msg.key_identifier.key_info == get_test_data(\"ffc_dh_key\")\n    assert msg.key_identifier.domain_name == \"domain.test\"\n    assert msg.key_identifier.forest_name == \"domain.test\"\n    assert isinstance(msg.protection_descriptor, blob.SIDDescriptor)\n    assert msg.protection_descriptor.value == \"S-1-5-21-3337337973-3297078028-437386066-512\"\n    assert msg.enc_cek == (\n        b\"\\x89\\x7F\\xC4\\x3F\\x74\\x8E\\xFD\\x09\"\n        b\"\\x57\\x27\\xDD\\xE9\\x8F\\x4E\\x1A\\x6F\"\n        b\"\\xFB\\x9D\\x41\\x63\\xD3\\x9F\\xB3\\x74\"\n        b\"\\xD0\\x49\\xC7\\x3D\\x89\\x69\\x0C\\x7E\"\n        b\"\\xFA\\x45\\xE6\\xBE\\x11\\x9E\\x0D\\x6B\"\n    )\n    assert msg.enc_cek_algorithm == \"2.16.840.1.101.3.4.1.45\"\n    assert msg.enc_cek_parameters is None\n    assert msg.enc_content == (\n        b\"\\xE4\\xCD\\xF6\\x54\\x72\\x2A\\x49\\xD5\"\n        b\"\\x5F\\x53\\x08\\x55\\x0E\\xC4\\xE8\\xAA\"\n        b\"\\xC6\\xD0\\xBE\\x49\\x51\\x16\\xF6\\x13\"\n        b\"\\x2A\\x4D\\x59\\x17\\x9F\\xD7\\x13\\x8E\"\n        b\"\\xC9\\x4B\\x53\\x6E\\x25\\x11\\xD5\\xCA\"\n        b\"\\x0D\\x37\\x8D\\xEC\\x3C\\x42\\x3D\\x55\"\n        b\"\\xC5\\x0A\\x60\\xDC\\x41\\x8F\\x90\\x17\"\n        b\"\\x82\\x48\\x46\\xE0\\x2B\\x62\\x04\\xC8\"\n        b\"\\xB3\\x27\\x3C\\x9F\\xC4\\x43\\x37\\x63\"\n        b\"\\x94\\x47\\x3B\\xF9\\x7B\\xDC\\x55\\x80\"\n        b\"\\x09\\x51\\xAD\\xF9\\x23\\x8D\\x8A\\x02\"\n        b\"\\xFF\\xE0\\x38\\xCD\\x4D\\x7B\\x16\\x01\"\n        b\"\\x2F\\x7A\\xE8\\xB8\\x79\\x03\\xE0\\x50\"\n        b\"\\x00\\xD8\\xE3\\x10\\xDE\\x1B\\x2D\\x1C\"\n        b\"\\xA3\\x44\\xB2\\xF2\\x67\\x3A\\x3D\\x5A\"\n        b\"\\x5C\\x4D\\xE4\\x63\\x26\\x4B\\x95\\x64\"\n        b\"\\xEB\\x9E\\xB0\\x4C\\x52\\x71\\x1C\\x33\"\n        b\"\\xC5\\xA7\\xA9\\x74\\x0D\\x66\\x54\\x88\"\n        b\"\\x55\\xB6\"\n    )\n    assert msg.enc_content_algorithm == \"2.16.840.1.101.3.4.1.46\"\n    assert msg.enc_content_parameters == b\"\\x30\\x11\\x04\\x0C\\x9E\\x5B\\x2E\\x17\\xC2\\x3F\\x04\\xFC\\x35\\x25\\xE1\\x18\\x02\\x01\\x10\"", ""]}
{"filename": "tests/_rpc/test_verification.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport uuid\n\nimport pytest\n\nfrom dpapi_ng._rpc import _bind as bind", "\nfrom dpapi_ng._rpc import _bind as bind\nfrom dpapi_ng._rpc import _pdu as pdu\nfrom dpapi_ng._rpc import _verification as verification\n\n\ndef test_verification_trailer_pack() -> None:\n    expected = (\n        b\"\\x8a\\xe3\\x13\\x71\\x02\\xf4\\x36\\x71\"\n        b\"\\x02\\x40\\x28\\x00\\x60\\x59\\x78\\xb9\"\n        b\"\\x4f\\x52\\xdf\\x11\\x8b\\x6d\\x83\\xdc\"\n        b\"\\xde\\xd7\\x20\\x85\\x01\\x00\\x00\\x00\"\n        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n        b\"\\x01\\x00\\x00\\x00\"\n    )\n\n    msg = verification.VerificationTrailer(\n        [\n            verification.CommandPContext(\n                verification.CommandFlags.SEC_VT_COMMAND_END,\n                bind.SyntaxId(uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\"), 1, 0),\n                bind.SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0),\n            )\n        ]\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_verification_trailer_unpack() -> None:\n    data = (\n        b\"\\x8a\\xe3\\x13\\x71\\x02\\xf4\\x36\\x71\"\n        b\"\\x02\\x40\\x28\\x00\\x60\\x59\\x78\\xb9\"\n        b\"\\x4f\\x52\\xdf\\x11\\x8b\\x6d\\x83\\xdc\"\n        b\"\\xde\\xd7\\x20\\x85\\x01\\x00\\x00\\x00\"\n        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n        b\"\\x01\\x00\\x00\\x00\"\n    )\n\n    msg = verification.VerificationTrailer.unpack(data)\n    assert len(msg.commands) == 1\n    assert isinstance(msg.commands[0], verification.CommandPContext)\n    assert msg.commands[0].command == verification.CommandType.SEC_VT_COMMAND_PCONTEXT\n    assert msg.commands[0].flags == verification.CommandFlags.SEC_VT_COMMAND_END\n    assert msg.commands[0].value\n    assert msg.commands[0].interface_id == bind.SyntaxId(uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\"), 1, 0)\n    assert msg.commands[0].transfer_syntax == bind.SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0)", "\n\ndef test_verification_trailer_unpack_invalid_signature() -> None:\n    with pytest.raises(ValueError, match=\"Failed to unpack VerificationTrailer as signature header is invalid\"):\n        verification.VerificationTrailer.unpack(b\"\\x00\")\n\n\ndef test_verification_trailer_unpack_multiple_commands() -> None:\n    data = b\"\\x8a\\xe3\\x13\\x71\\x02\\xf4\\x36\\x71\\x01\\x00\\x04\\x00\\x01\\x00\\x00\\x00\\x00\\x60\\x01\\x00\\x00\"\n\n    msg = verification.VerificationTrailer.unpack(data)\n    assert len(msg.commands) == 2\n    assert isinstance(msg.commands[0], verification.CommandBitmask)\n    assert msg.commands[0].command == verification.CommandType.SEC_VT_COMMAND_BITMASK_1\n    assert msg.commands[0].flags == verification.CommandFlags.NONE\n    assert msg.commands[0].value == b\"\\x01\\x00\\x00\\x00\"\n    assert msg.commands[0].bits == 1\n\n    assert isinstance(msg.commands[1], verification.Command)\n    assert msg.commands[1].command == verification.CommandType(0x2000)\n    assert msg.commands[1].flags == verification.CommandFlags.SEC_VT_COMMAND_END\n    assert msg.commands[1].value == b\"\\x00\"", "\n\ndef test_command_bitmask_pack() -> None:\n    expected = b\"\\x01\\x00\\x04\\x00\\x01\\x00\\x00\\x00\"\n\n    msg = verification.CommandBitmask(flags=verification.CommandFlags.NONE, bits=1)\n    actual = msg.pack()\n    assert actual == expected\n\n\ndef test_command_bitmask_unpack() -> None:\n    data = b\"\\x01\\x00\\x04\\x00\\x01\\x00\\x00\\x00\"\n\n    msg = verification.Command.unpack(data)\n    assert isinstance(msg, verification.CommandBitmask)\n    assert msg.command == verification.CommandType.SEC_VT_COMMAND_BITMASK_1\n    assert msg.flags == verification.CommandFlags.NONE\n    assert msg.value == b\"\\x01\\x00\\x00\\x00\"\n    assert msg.bits == 1", "\n\ndef test_command_bitmask_unpack() -> None:\n    data = b\"\\x01\\x00\\x04\\x00\\x01\\x00\\x00\\x00\"\n\n    msg = verification.Command.unpack(data)\n    assert isinstance(msg, verification.CommandBitmask)\n    assert msg.command == verification.CommandType.SEC_VT_COMMAND_BITMASK_1\n    assert msg.flags == verification.CommandFlags.NONE\n    assert msg.value == b\"\\x01\\x00\\x00\\x00\"\n    assert msg.bits == 1", "\n\ndef test_command_pcontext_pack() -> None:\n    expected = (\n        b\"\\x02\\x40\\x28\\x00\\x60\\x59\\x78\\xb9\"\n        b\"\\x4f\\x52\\xdf\\x11\\x8b\\x6d\\x83\\xdc\"\n        b\"\\xde\\xd7\\x20\\x85\\x01\\x00\\x00\\x00\"\n        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n        b\"\\x01\\x00\\x00\\x00\"\n    )\n\n    msg = verification.CommandPContext(\n        verification.CommandFlags.SEC_VT_COMMAND_END,\n        bind.SyntaxId(uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\"), 1, 0),\n        bind.SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0),\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_command_pcontext_unpack() -> None:\n    data = (\n        b\"\\x02\\x40\\x28\\x00\\x60\\x59\\x78\\xb9\"\n        b\"\\x4f\\x52\\xdf\\x11\\x8b\\x6d\\x83\\xdc\"\n        b\"\\xde\\xd7\\x20\\x85\\x01\\x00\\x00\\x00\"\n        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n        b\"\\x01\\x00\\x00\\x00\"\n    )\n\n    msg = verification.Command.unpack(data)\n    assert isinstance(msg, verification.CommandPContext)\n    assert msg.command == verification.CommandType.SEC_VT_COMMAND_PCONTEXT\n    assert msg.flags == verification.CommandFlags.SEC_VT_COMMAND_END\n    assert msg.value\n    assert msg.interface_id == bind.SyntaxId(uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\"), 1, 0)\n    assert msg.transfer_syntax == bind.SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0)", "\n\ndef test_command_header2_pack() -> None:\n    expected = b\"\\x03\\x80\\x10\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x03\\x00\"\n\n    msg = verification.CommandHeader2(\n        verification.CommandFlags.SEC_VT_MUST_PROCESS_COMMAND,\n        pdu.PacketType.REQUEST,\n        pdu.DataRep(),\n        1,\n        2,\n        3,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_command_header2_unpack() -> None:\n    data = b\"\\x03\\x80\\x10\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x03\\x00\"\n\n    msg = verification.Command.unpack(data)\n    assert isinstance(msg, verification.CommandHeader2)\n    assert msg.command == verification.CommandType.SEC_VT_COMMAND_HEADER2\n    assert msg.flags == verification.CommandFlags.SEC_VT_MUST_PROCESS_COMMAND\n    assert msg.value == b\"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x03\\x00\"\n    assert msg.packet_type == pdu.PacketType.REQUEST\n    assert msg.data_rep == pdu.DataRep()\n    assert msg.call_id == 1\n    assert msg.context_id == 2\n    assert msg.opnum == 3", "\n\ndef test_unknown_command_unpack() -> None:\n    data = b\"\\x00\\xA0\\x02\\x00\\x00\\x01\"\n\n    msg = verification.Command.unpack(data)\n    assert isinstance(msg, verification.Command)\n    assert msg.command == verification.CommandType(0x2000)\n    assert msg.flags == verification.CommandFlags.SEC_VT_MUST_PROCESS_COMMAND\n    assert msg.value == b\"\\x00\\x01\"", ""]}
{"filename": "tests/_rpc/test_request.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport uuid\n\nfrom dpapi_ng._rpc import _pdu as pdu\nfrom dpapi_ng._rpc import _request as request\n", "from dpapi_ng._rpc import _request as request\n\n\ndef test_request_pack() -> None:\n    expected = (\n        b\"\\x05\\x00\\x00\\x03\\x10\\x00\\x00\\x00\"\n        b\"\\x1c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x90\\x00\\x00\\x00\\x01\\x00\\x03\\x00\"\n        b\"\\x01\\x00\\x00\\x00\"\n    )\n\n    msg = request.Request(\n        header=pdu.PDUHeader(\n            version=5,\n            version_minor=0,\n            packet_type=pdu.PacketType.REQUEST,\n            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n            data_rep=pdu.DataRep(),\n            frag_len=28,\n            auth_len=0,\n            call_id=2,\n        ),\n        sec_trailer=None,\n        alloc_hint=144,\n        context_id=1,\n        opnum=3,\n        obj=None,\n        stub_data=b\"\\x01\\x00\\x00\\x00\",\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_request_unpack() -> None:\n    data = (\n        b\"\\x05\\x00\\x00\\x03\\x10\\x00\\x00\\x00\"\n        b\"\\x1c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x90\\x00\\x00\\x00\\x01\\x00\\x03\\x00\"\n        b\"\\x01\\x00\\x00\\x00\"\n    )\n\n    msg = pdu.PDU.unpack(data)\n    assert isinstance(msg, request.Request)\n    assert msg.header.version == 5\n    assert msg.header.version_minor == 0\n    assert msg.header.packet_type == pdu.PacketType.REQUEST\n    assert msg.header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n    assert msg.header.frag_len == 28\n    assert msg.header.auth_len == 0\n    assert msg.header.call_id == 2\n    assert msg.alloc_hint == 144\n    assert msg.context_id == 1\n    assert msg.opnum == 3\n    assert msg.obj is None\n    assert msg.stub_data == b\"\\x01\\x00\\x00\\x00\"\n    assert msg.sec_trailer is None", "\n\ndef test_request_pack_with_obj() -> None:\n    expected = (\n        b\"\\x05\\x00\\x00\\x83\\x10\\x00\\x00\\x00\"\n        b\"\\x2c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x90\\x00\\x00\\x00\\x01\\x00\\x03\\x00\"\n        b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\n        b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\n        b\"\\x01\\x00\\x00\\x00\"\n    )\n\n    msg = request.Request(\n        header=pdu.PDUHeader(\n            version=5,\n            version_minor=0,\n            packet_type=pdu.PacketType.REQUEST,\n            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG\n            | pdu.PacketFlags.PFC_LAST_FRAG\n            | pdu.PacketFlags.PFC_OBJECT_UUID,\n            data_rep=pdu.DataRep(),\n            frag_len=44,\n            auth_len=0,\n            call_id=2,\n        ),\n        sec_trailer=None,\n        alloc_hint=144,\n        context_id=1,\n        opnum=3,\n        obj=uuid.UUID(bytes_le=b\"\\xff\" * 16),\n        stub_data=b\"\\x01\\x00\\x00\\x00\",\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_request_unpack_with_obj() -> None:\n    data = (\n        b\"\\x05\\x00\\x00\\x83\\x10\\x00\\x00\\x00\"\n        b\"\\x2c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x90\\x00\\x00\\x00\\x01\\x00\\x03\\x00\"\n        b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\n        b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\n        b\"\\x01\\x00\\x00\\x00\"\n    )\n\n    msg = pdu.PDU.unpack(data)\n    assert isinstance(msg, request.Request)\n    assert msg.header.version == 5\n    assert msg.header.version_minor == 0\n    assert msg.header.packet_type == pdu.PacketType.REQUEST\n    assert (\n        msg.header.packet_flags\n        == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG | pdu.PacketFlags.PFC_OBJECT_UUID\n    )\n    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n    assert msg.header.frag_len == 44\n    assert msg.header.auth_len == 0\n    assert msg.header.call_id == 2\n    assert msg.alloc_hint == 144\n    assert msg.context_id == 1\n    assert msg.opnum == 3\n    assert msg.obj == uuid.UUID(bytes_le=b\"\\xff\" * 16)\n    assert msg.stub_data == b\"\\x01\\x00\\x00\\x00\"\n    assert msg.sec_trailer is None", "\n\ndef test_request_pack_sec_trailer() -> None:\n    expected = (\n        b\"\\x05\\x00\\x00\\x03\\x10\\x00\\x00\\x00\"\n        b\"\\x38\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x94\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\xba\\x8b\\xff\\xf4\\x6c\\x22\\x7f\\x25\"\n        b\"\\xce\\x5c\\xd2\\x57\\x3f\\x9c\\xd7\\xba\"\n        b\"\\x09\\x06\\x0c\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x05\\x04\\x06\\xff\"\n    )\n\n    msg = request.Request(\n        header=pdu.PDUHeader(\n            version=5,\n            version_minor=0,\n            packet_type=pdu.PacketType.REQUEST,\n            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n            data_rep=pdu.DataRep(),\n            frag_len=56,\n            auth_len=4,\n            call_id=2,\n        ),\n        sec_trailer=pdu.SecTrailer(\n            type=pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n            level=pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n            pad_length=12,\n            context_id=0,\n            auth_value=b\"\\x05\\x04\\x06\\xff\",\n        ),\n        alloc_hint=148,\n        context_id=1,\n        opnum=0,\n        obj=None,\n        stub_data=b\"\\xba\\x8b\\xff\\xf4\\x6c\\x22\\x7f\\x25\\xce\\x5c\\xd2\\x57\\x3f\\x9c\\xd7\\xba\",\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_request_unpack_sec_trailer() -> None:\n    data = (\n        b\"\\x05\\x00\\x00\\x03\\x10\\x00\\x00\\x00\"\n        b\"\\x38\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x94\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\xba\\x8b\\xff\\xf4\\x6c\\x22\\x7f\\x25\"\n        b\"\\xce\\x5c\\xd2\\x57\\x3f\\x9c\\xd7\\xba\"\n        b\"\\x09\\x06\\x0c\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x05\\x04\\x06\\xff\"\n    )\n\n    msg = pdu.PDU.unpack(data)\n    assert isinstance(msg, request.Request)\n    assert msg.header.version == 5\n    assert msg.header.version_minor == 0\n    assert msg.header.packet_type == pdu.PacketType.REQUEST\n    assert msg.header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n    assert msg.header.frag_len == 56\n    assert msg.header.auth_len == 4\n    assert msg.header.call_id == 2\n    assert msg.alloc_hint == 148\n    assert msg.context_id == 1\n    assert msg.opnum == 0\n    assert msg.obj is None\n    assert msg.stub_data == b\"\\xba\\x8b\\xff\\xf4\\x6c\\x22\\x7f\\x25\\xce\\x5c\\xd2\\x57\\x3f\\x9c\\xd7\\xba\"\n    assert isinstance(msg.sec_trailer, pdu.SecTrailer)\n    assert msg.sec_trailer.type == pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE\n    assert msg.sec_trailer.level == pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n    assert msg.sec_trailer.pad_length == 12\n    assert msg.sec_trailer.context_id == 0\n    assert msg.sec_trailer.auth_value == b\"\\x05\\x04\\x06\\xff\"", "\n\ndef test_response_pack() -> None:\n    expected = (\n        b\"\\x05\\x00\\x02\\x03\\x10\\x00\\x00\\x00\"\n        b\"\\x1c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x94\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\"\n    )\n\n    msg = request.Response(\n        header=pdu.PDUHeader(\n            version=5,\n            version_minor=0,\n            packet_type=pdu.PacketType.RESPONSE,\n            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n            data_rep=pdu.DataRep(),\n            frag_len=28,\n            auth_len=0,\n            call_id=2,\n        ),\n        sec_trailer=None,\n        alloc_hint=148,\n        context_id=1,\n        cancel_count=0,\n        stub_data=b\"\\x00\\x00\\x00\\x00\",\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_response_unpack() -> None:\n    data = (\n        b\"\\x05\\x00\\x02\\x03\\x10\\x00\\x00\\x00\"\n        b\"\\x1c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x94\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\"\n    )\n\n    msg = pdu.PDU.unpack(data)\n    assert isinstance(msg, request.Response)\n    assert msg.header.version == 5\n    assert msg.header.version_minor == 0\n    assert msg.header.packet_type == pdu.PacketType.RESPONSE\n    assert msg.header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n    assert msg.header.frag_len == 28\n    assert msg.header.auth_len == 0\n    assert msg.header.call_id == 2\n    assert msg.alloc_hint == 148\n    assert msg.context_id == 1\n    assert msg.cancel_count == 0\n    assert msg.stub_data == b\"\\x00\\x00\\x00\\x00\"\n    assert msg.sec_trailer is None", "\n\ndef test_response_pack_sec_trailer() -> None:\n    expected = (\n        b\"\\x05\\x00\\x02\\x03\\x10\\x00\\x00\\x00\"\n        b\"\\x28\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x60\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\x9d\\x08\\xd7\\x07\\x09\\x06\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x05\\x04\\x07\\xff\"\n    )\n\n    msg = request.Response(\n        header=pdu.PDUHeader(\n            version=5,\n            version_minor=0,\n            packet_type=pdu.PacketType.RESPONSE,\n            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n            data_rep=pdu.DataRep(),\n            frag_len=40,\n            auth_len=4,\n            call_id=2,\n        ),\n        sec_trailer=pdu.SecTrailer(\n            type=pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n            level=pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n            pad_length=0,\n            context_id=0,\n            auth_value=b\"\\x05\\x04\\x07\\xff\",\n        ),\n        alloc_hint=96,\n        context_id=1,\n        cancel_count=0,\n        stub_data=b\"\\x9d\\x08\\xd7\\x07\",\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_response_unpack_sec_trailer() -> None:\n    data = (\n        b\"\\x05\\x00\\x02\\x03\\x10\\x00\\x00\\x00\"\n        b\"\\x28\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\x60\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\x9d\\x08\\xd7\\x07\\x09\\x06\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x05\\x04\\x07\\xff\"\n    )\n\n    msg = pdu.PDU.unpack(data)\n    assert isinstance(msg, request.Response)\n    assert msg.header.version == 5\n    assert msg.header.version_minor == 0\n    assert msg.header.packet_type == pdu.PacketType.RESPONSE\n    assert msg.header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n    assert msg.header.frag_len == 40\n    assert msg.header.auth_len == 4\n    assert msg.header.call_id == 2\n    assert msg.alloc_hint == 96\n    assert msg.context_id == 1\n    assert msg.cancel_count == 0\n    assert msg.stub_data == b\"\\x9d\\x08\\xd7\\x07\"\n    assert isinstance(msg.sec_trailer, pdu.SecTrailer)\n    assert msg.sec_trailer.type == pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE\n    assert msg.sec_trailer.level == pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n    assert msg.sec_trailer.pad_length == 0\n    assert msg.sec_trailer.context_id == 0\n    assert msg.sec_trailer.auth_value == b\"\\x05\\x04\\x07\\xff\"", ""]}
{"filename": "tests/_rpc/__init__.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n"]}
{"filename": "tests/_rpc/test_pdu.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nfrom dpapi_ng._rpc import _pdu as pdu\n\n\ndef test_pdu_header_pack() -> None:\n    expected = b\"\\x05\\x00\\x0b\\x03\\x10\\x00\\x00\\x00\\xa0\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\n    msg = pdu.PDUHeader(\n        version=5,\n        version_minor=0,\n        packet_type=pdu.PacketType.BIND,\n        packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n        data_rep=pdu.DataRep(),\n        frag_len=160,\n        auth_len=0,\n        call_id=1,\n    )\n    actual = msg.pack()\n    assert actual == expected", "def test_pdu_header_pack() -> None:\n    expected = b\"\\x05\\x00\\x0b\\x03\\x10\\x00\\x00\\x00\\xa0\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\n    msg = pdu.PDUHeader(\n        version=5,\n        version_minor=0,\n        packet_type=pdu.PacketType.BIND,\n        packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n        data_rep=pdu.DataRep(),\n        frag_len=160,\n        auth_len=0,\n        call_id=1,\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_pdu_header_unpack() -> None:\n    data = b\"\\x05\\x00\\x0b\\x03\\x10\\x00\\x00\\x00\\xa0\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n\n    header = pdu.PDUHeader.unpack(data)\n    assert header.version == 5\n    assert header.version_minor == 0\n    assert header.packet_type == pdu.PacketType.BIND\n    assert header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n    assert header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n    assert header.data_rep.character == pdu.CharacterRep.ASCII\n    assert header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n    assert header.frag_len == 160\n    assert header.auth_len == 0\n    assert header.call_id == 1", "\n\ndef test_sec_trailer_pack() -> None:\n    expected = b\"\\x09\\x06\\x08\\x00\\x01\\x00\\x00\\x00\\x01\"\n\n    msg = pdu.SecTrailer(\n        type=pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n        level=pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n        pad_length=8,\n        context_id=1,\n        auth_value=b\"\\x01\",\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_sec_trailer_unpack() -> None:\n    data = b\"\\x09\\x06\\x08\\x00\\x01\\x00\\x00\\x00\\x01\"\n\n    sec_trailer = pdu.SecTrailer.unpack(data)\n    assert sec_trailer.type == pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE\n    assert sec_trailer.level == pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n    assert sec_trailer.pad_length == 8\n    assert sec_trailer.context_id == 1\n    assert sec_trailer.auth_value == b\"\\x01\"", "\n\ndef test_fault_pack() -> None:\n    expected = b\"\\x05\\x00\\x03\\x23\\x10\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x01\\x1c\\x00\\x00\\x00\\x00\"\n\n    msg = pdu.Fault(\n        header=pdu.PDUHeader(\n            version=5,\n            version_minor=0,\n            packet_type=pdu.PacketType.FAULT,\n            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG\n            | pdu.PacketFlags.PFC_LAST_FRAG\n            | pdu.PacketFlags.PFC_DID_NOT_EXECUTE,\n            data_rep=pdu.DataRep(),\n            frag_len=32,\n            auth_len=0,\n            call_id=1,\n        ),\n        sec_trailer=None,\n        alloc_hint=32,\n        context_id=0,\n        cancel_count=0,\n        status=0x1C010003,\n        flags=pdu.FaultFlags.NONE,\n        stub_data=b\"\",\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_fault_unpack() -> None:\n    data = b\"\\x05\\x00\\x03\\x23\\x10\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x01\\x1c\\x00\\x00\\x00\\x00\"\n\n    msg = pdu.PDU.unpack(data)\n    assert isinstance(msg, pdu.Fault)\n    assert msg.header.version == 5\n    assert msg.header.version_minor == 0\n    assert msg.header.packet_type == pdu.PacketType.FAULT\n    assert (\n        msg.header.packet_flags\n        == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG | pdu.PacketFlags.PFC_DID_NOT_EXECUTE\n    )\n    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n    assert msg.header.frag_len == 32\n    assert msg.header.auth_len == 0\n    assert msg.header.call_id == 1\n    assert msg.alloc_hint == 32\n    assert msg.context_id == 0\n    assert msg.cancel_count == 0\n    assert msg.flags == pdu.FaultFlags.NONE\n    assert msg.status == 0x1C010003\n    assert msg.stub_data == b\"\"\n    assert msg.sec_trailer is None", ""]}
{"filename": "tests/_rpc/test_bind.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport uuid\n\nimport pytest\n\nfrom dpapi_ng._rpc import _bind as bind", "\nfrom dpapi_ng._rpc import _bind as bind\nfrom dpapi_ng._rpc import _pdu as pdu\n\n\ndef test_bind_pack() -> None:\n    expected = (\n        b\"\\x05\\x00\\x0b\\x03\\x10\\x00\\x00\\x00\"\n        b\"\\xa0\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\xd0\\x16\\xd0\\x16\\x00\\x00\\x00\\x00\"\n        b\"\\x03\\x00\\x00\\x00\\x01\\x00\\x01\\x00\"\n        b\"\\x08\\x83\\xaf\\xe1\\x1f\\x5d\\xc9\\x11\"\n        b\"\\x91\\xa4\\x08\\x00\\x2b\\x14\\xa0\\xfa\"\n        b\"\\x03\\x00\\x00\\x00\\x04\\x5d\\x88\\x8a\"\n        b\"\\xeb\\x1c\\xc9\\x11\\x9f\\xe8\\x08\\x00\"\n        b\"\\x2b\\x10\\x48\\x60\\x02\\x00\\x00\\x00\"\n        b\"\\x02\\x00\\x01\\x00\\x08\\x83\\xaf\\xe1\"\n        b\"\\x1f\\x5d\\xc9\\x11\\x91\\xa4\\x08\\x00\"\n        b\"\\x2b\\x14\\xa0\\xfa\\x03\\x00\\x00\\x00\"\n        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n        b\"\\x01\\x00\\x00\\x00\\x03\\x00\\x01\\x00\"\n        b\"\\x08\\x83\\xaf\\xe1\\x1f\\x5d\\xc9\\x11\"\n        b\"\\x91\\xa4\\x08\\x00\\x2b\\x14\\xa0\\xfa\"\n        b\"\\x03\\x00\\x00\\x00\\x2c\\x1c\\xb7\\x6c\"\n        b\"\\x12\\x98\\x40\\x45\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n    )\n    syntax_id = bind.SyntaxId(uuid.UUID(\"e1af8308-5d1f-11c9-91a4-08002b14a0fa\"), 3, 0)\n\n    msg = bind.Bind(\n        header=pdu.PDUHeader(\n            version=5,\n            version_minor=0,\n            packet_type=pdu.PacketType.BIND,\n            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n            data_rep=pdu.DataRep(),\n            frag_len=160,\n            auth_len=0,\n            call_id=1,\n        ),\n        sec_trailer=None,\n        max_xmit_frag=5840,\n        max_recv_frag=5840,\n        assoc_group=0,\n        contexts=[\n            bind.ContextElement(\n                context_id=1,\n                abstract_syntax=syntax_id,\n                transfer_syntaxes=[bind.SyntaxId(uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\"), 2, 0)],\n            ),\n            bind.ContextElement(\n                context_id=2,\n                abstract_syntax=syntax_id,\n                transfer_syntaxes=[bind.SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0)],\n            ),\n            bind.ContextElement(\n                context_id=3,\n                abstract_syntax=syntax_id,\n                transfer_syntaxes=[bind.SyntaxId(uuid.UUID(\"6cb71c2c-9812-4540-0000-000000000000\"), 1, 0)],\n            ),\n        ],\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_bind_unpack() -> None:\n    data = (\n        b\"\\x05\\x00\\x0b\\x03\\x10\\x00\\x00\\x00\"\n        b\"\\xa0\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\xd0\\x16\\xd0\\x16\\x00\\x00\\x00\\x00\"\n        b\"\\x03\\x00\\x00\\x00\\x01\\x00\\x01\\x00\"\n        b\"\\x08\\x83\\xaf\\xe1\\x1f\\x5d\\xc9\\x11\"\n        b\"\\x91\\xa4\\x08\\x00\\x2b\\x14\\xa0\\xfa\"\n        b\"\\x03\\x00\\x00\\x00\\x04\\x5d\\x88\\x8a\"\n        b\"\\xeb\\x1c\\xc9\\x11\\x9f\\xe8\\x08\\x00\"\n        b\"\\x2b\\x10\\x48\\x60\\x02\\x00\\x00\\x00\"\n        b\"\\x02\\x00\\x01\\x00\\x08\\x83\\xaf\\xe1\"\n        b\"\\x1f\\x5d\\xc9\\x11\\x91\\xa4\\x08\\x00\"\n        b\"\\x2b\\x14\\xa0\\xfa\\x03\\x00\\x00\\x00\"\n        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n        b\"\\x01\\x00\\x00\\x00\\x03\\x00\\x01\\x00\"\n        b\"\\x08\\x83\\xaf\\xe1\\x1f\\x5d\\xc9\\x11\"\n        b\"\\x91\\xa4\\x08\\x00\\x2b\\x14\\xa0\\xfa\"\n        b\"\\x03\\x00\\x00\\x00\\x2c\\x1c\\xb7\\x6c\"\n        b\"\\x12\\x98\\x40\\x45\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n    )\n    syntax_id = bind.SyntaxId(uuid.UUID(\"e1af8308-5d1f-11c9-91a4-08002b14a0fa\"), 3, 0)\n\n    msg = pdu.PDU.unpack(data)\n    assert isinstance(msg, bind.Bind)\n    assert msg.header.version == 5\n    assert msg.header.version_minor == 0\n    assert msg.header.packet_type == pdu.PacketType.BIND\n    assert msg.header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n    assert msg.header.frag_len == 160\n    assert msg.header.auth_len == 0\n    assert msg.header.call_id == 1\n    assert msg.max_xmit_frag == 5840\n    assert msg.max_recv_frag == 5840\n    assert msg.assoc_group == 0\n    assert len(msg.contexts) == 3\n\n    assert msg.contexts[0].context_id == 1\n    assert msg.contexts[0].abstract_syntax == syntax_id\n    assert len(msg.contexts[0].transfer_syntaxes) == 1\n    assert msg.contexts[0].transfer_syntaxes[0] == bind.SyntaxId(\n        uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\"), 2, 0\n    )\n\n    assert msg.contexts[1].context_id == 2\n    assert msg.contexts[1].abstract_syntax == syntax_id\n    assert len(msg.contexts[1].transfer_syntaxes) == 1\n    assert msg.contexts[1].transfer_syntaxes[0] == bind.SyntaxId(\n        uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0\n    )\n\n    assert msg.contexts[2].context_id == 3\n    assert msg.contexts[2].abstract_syntax == syntax_id\n    assert len(msg.contexts[2].transfer_syntaxes) == 1\n    assert msg.contexts[2].transfer_syntaxes[0] == bind.SyntaxId(\n        uuid.UUID(\"6cb71c2c-9812-4540-0000-000000000000\"), 1, 0\n    )\n\n    assert msg.sec_trailer is None", "\n\ndef test_bind_pack_sec_trailer() -> None:\n    expected = (\n        b\"\\x05\\x00\\x0b\\x07\\x10\\x00\\x00\\x00\"\n        b\"\\xac\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\xd0\\x16\\xd0\\x16\\x00\\x00\\x00\\x00\"\n        b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x01\\x00\"\n        b\"\\x35\\x42\\x51\\xe3\\x06\\x4b\\xd1\\x11\"\n        b\"\\xab\\x04\\x00\\xc0\\x4f\\xc2\\xdc\\xd2\"\n        b\"\\x04\\x00\\x00\\x00\\x04\\x5d\\x88\\x8a\"\n        b\"\\xeb\\x1c\\xc9\\x11\\x9f\\xe8\\x08\\x00\"\n        b\"\\x2b\\x10\\x48\\x60\\x02\\x00\\x00\\x00\"\n        b\"\\x01\\x00\\x01\\x00\\x35\\x42\\x51\\xe3\"\n        b\"\\x06\\x4b\\xd1\\x11\\xab\\x04\\x00\\xc0\"\n        b\"\\x4f\\xc2\\xdc\\xd2\\x04\\x00\\x00\\x00\"\n        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n        b\"\\x01\\x00\\x00\\x00\\x02\\x00\\x01\\x00\"\n        b\"\\x35\\x42\\x51\\xe3\\x06\\x4b\\xd1\\x11\"\n        b\"\\xab\\x04\\x00\\xc0\\x4f\\xc2\\xdc\\xd2\"\n        b\"\\x04\\x00\\x00\\x00\\x2c\\x1c\\xb7\\x6c\"\n        b\"\\x12\\x98\\x40\\x45\\x03\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\x09\\x06\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x60\\x82\\x07\\x3c\"\n    )\n    syntax_id = bind.SyntaxId(uuid.UUID(\"e3514235-4b06-11d1-ab04-00c04fc2dcd2\"), 4, 0)\n\n    msg = bind.Bind(\n        header=pdu.PDUHeader(\n            version=5,\n            version_minor=0,\n            packet_type=pdu.PacketType.BIND,\n            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG\n            | pdu.PacketFlags.PFC_LAST_FRAG\n            | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN,\n            data_rep=pdu.DataRep(),\n            frag_len=172,\n            auth_len=4,\n            call_id=2,\n        ),\n        sec_trailer=pdu.SecTrailer(\n            type=pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n            level=pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n            pad_length=0,\n            context_id=0,\n            auth_value=b\"\\x60\\x82\\x07\\x3c\",\n        ),\n        max_xmit_frag=5840,\n        max_recv_frag=5840,\n        assoc_group=0,\n        contexts=[\n            bind.ContextElement(\n                context_id=0,\n                abstract_syntax=syntax_id,\n                transfer_syntaxes=[bind.SyntaxId(uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\"), 2, 0)],\n            ),\n            bind.ContextElement(\n                context_id=1,\n                abstract_syntax=syntax_id,\n                transfer_syntaxes=[bind.SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0)],\n            ),\n            bind.ContextElement(\n                context_id=2,\n                abstract_syntax=syntax_id,\n                transfer_syntaxes=[bind.SyntaxId(uuid.UUID(\"6cb71c2c-9812-4540-0300-000000000000\"), 1, 0)],\n            ),\n        ],\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_bind_unpack_sec_trailer() -> None:\n    data = (\n        b\"\\x05\\x00\\x0b\\x07\\x10\\x00\\x00\\x00\"\n        b\"\\xac\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\xd0\\x16\\xd0\\x16\\x00\\x00\\x00\\x00\"\n        b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x01\\x00\"\n        b\"\\x35\\x42\\x51\\xe3\\x06\\x4b\\xd1\\x11\"\n        b\"\\xab\\x04\\x00\\xc0\\x4f\\xc2\\xdc\\xd2\"\n        b\"\\x04\\x00\\x00\\x00\\x04\\x5d\\x88\\x8a\"\n        b\"\\xeb\\x1c\\xc9\\x11\\x9f\\xe8\\x08\\x00\"\n        b\"\\x2b\\x10\\x48\\x60\\x02\\x00\\x00\\x00\"\n        b\"\\x01\\x00\\x01\\x00\\x35\\x42\\x51\\xe3\"\n        b\"\\x06\\x4b\\xd1\\x11\\xab\\x04\\x00\\xc0\"\n        b\"\\x4f\\xc2\\xdc\\xd2\\x04\\x00\\x00\\x00\"\n        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n        b\"\\x01\\x00\\x00\\x00\\x02\\x00\\x01\\x00\"\n        b\"\\x35\\x42\\x51\\xe3\\x06\\x4b\\xd1\\x11\"\n        b\"\\xab\\x04\\x00\\xc0\\x4f\\xc2\\xdc\\xd2\"\n        b\"\\x04\\x00\\x00\\x00\\x2c\\x1c\\xb7\\x6c\"\n        b\"\\x12\\x98\\x40\\x45\\x03\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\x09\\x06\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x60\\x82\\x07\\x3c\"\n    )\n    syntax_id = bind.SyntaxId(uuid.UUID(\"e3514235-4b06-11d1-ab04-00c04fc2dcd2\"), 4, 0)\n\n    msg = pdu.PDU.unpack(data)\n    assert isinstance(msg, bind.Bind)\n    assert msg.header.version == 5\n    assert msg.header.version_minor == 0\n    assert msg.header.packet_type == pdu.PacketType.BIND\n    assert (\n        msg.header.packet_flags\n        == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN\n    )\n    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n    assert msg.header.frag_len == 172\n    assert msg.header.auth_len == 4\n    assert msg.header.call_id == 2\n    assert msg.max_xmit_frag == 5840\n    assert msg.max_recv_frag == 5840\n    assert msg.assoc_group == 0\n    assert len(msg.contexts) == 3\n\n    assert msg.contexts[0].context_id == 0\n    assert msg.contexts[0].abstract_syntax == syntax_id\n    assert len(msg.contexts[0].transfer_syntaxes) == 1\n    assert msg.contexts[0].transfer_syntaxes[0] == bind.SyntaxId(\n        uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\"), 2, 0\n    )\n\n    assert msg.contexts[1].context_id == 1\n    assert msg.contexts[1].abstract_syntax == syntax_id\n    assert len(msg.contexts[1].transfer_syntaxes) == 1\n    assert msg.contexts[1].transfer_syntaxes[0] == bind.SyntaxId(\n        uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0\n    )\n\n    assert msg.contexts[2].context_id == 2\n    assert msg.contexts[2].abstract_syntax == syntax_id\n    assert len(msg.contexts[2].transfer_syntaxes) == 1\n    assert msg.contexts[2].transfer_syntaxes[0] == bind.SyntaxId(\n        uuid.UUID(\"6cb71c2c-9812-4540-0300-000000000000\"), 1, 0\n    )\n\n    assert isinstance(msg.sec_trailer, pdu.SecTrailer)\n    assert msg.sec_trailer.type == pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE\n    assert msg.sec_trailer.level == pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n    assert msg.sec_trailer.pad_length == 0\n    assert msg.sec_trailer.context_id == 0\n    assert msg.sec_trailer.auth_value == b\"\\x60\\x82\\x07\\x3c\"", "\n\ndef test_bind_ack_pack() -> None:\n    expected = (\n        b\"\\x05\\x00\\x0c\\x03\\x10\\x00\\x00\\x00\"\n        b\"\\x6c\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\xd0\\x16\\xd0\\x16\\x04\\x14\\x00\\x00\"\n        b\"\\x04\\x00\\x31\\x33\\x35\\x00\\x00\\x00\"\n        b\"\\x03\\x00\\x00\\x00\\x02\\x00\\x02\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n        b\"\\x01\\x00\\x00\\x00\\x03\\x00\\x03\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\"\n    )\n\n    msg = bind.BindAck(\n        header=pdu.PDUHeader(\n            version=5,\n            version_minor=0,\n            packet_type=pdu.PacketType.BIND_ACK,\n            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n            data_rep=pdu.DataRep(),\n            frag_len=108,\n            auth_len=0,\n            call_id=1,\n        ),\n        sec_trailer=None,\n        max_xmit_frag=5840,\n        max_recv_frag=5840,\n        assoc_group=5124,\n        sec_addr=\"135\",\n        results=[\n            bind.ContextResult(\n                result=bind.ContextResultCode.PROVIDER_REJECTION,\n                reason=2,\n                syntax=uuid.UUID(int=0),\n                syntax_version=0,\n            ),\n            bind.ContextResult(\n                result=bind.ContextResultCode.ACCEPTANCE,\n                reason=0,\n                syntax=uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"),\n                syntax_version=1,\n            ),\n            bind.ContextResult(\n                result=bind.ContextResultCode.NEGOTIATE_ACK,\n                reason=3,\n                syntax=uuid.UUID(int=0),\n                syntax_version=0,\n            ),\n        ],\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_bind_ack_unpack() -> None:\n    data = (\n        b\"\\x05\\x00\\x0c\\x03\\x10\\x00\\x00\\x00\"\n        b\"\\x6c\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\xd0\\x16\\xd0\\x16\\x04\\x14\\x00\\x00\"\n        b\"\\x04\\x00\\x31\\x33\\x35\\x00\\x00\\x00\"\n        b\"\\x03\\x00\\x00\\x00\\x02\\x00\\x02\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n        b\"\\x01\\x00\\x00\\x00\\x03\\x00\\x03\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\"\n    )\n\n    msg = pdu.PDU.unpack(data)\n    assert isinstance(msg, bind.BindAck)\n    assert msg.header.version == 5\n    assert msg.header.version_minor == 0\n    assert msg.header.packet_type == pdu.PacketType.BIND_ACK\n    assert msg.header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n    assert msg.header.frag_len == 108\n    assert msg.header.auth_len == 0\n    assert msg.header.call_id == 1\n    assert msg.max_xmit_frag == 5840\n    assert msg.max_recv_frag == 5840\n    assert msg.assoc_group == 5124\n    assert msg.sec_addr == \"135\"\n    assert len(msg.results) == 3\n    assert msg.results[0].result == bind.ContextResultCode.PROVIDER_REJECTION\n    assert msg.results[0].reason == 2\n    assert msg.results[0].syntax == uuid.UUID(int=0)\n    assert msg.results[0].syntax_version == 0\n    assert msg.results[1].result == bind.ContextResultCode.ACCEPTANCE\n    assert msg.results[1].reason == 0\n    assert msg.results[1].syntax == uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\")\n    assert msg.results[1].syntax_version == 1\n    assert msg.results[2].result == bind.ContextResultCode.NEGOTIATE_ACK\n    assert msg.results[2].reason == 3\n    assert msg.results[2].syntax == uuid.UUID(int=0)\n    assert msg.results[2].syntax_version == 0\n    assert msg.sec_trailer is None", "\n\ndef test_bind_ack_pack_sec_trailer() -> None:\n    expected = (\n        b\"\\x05\\x00\\x0c\\x07\\x10\\x00\\x00\\x00\"\n        b\"\\x78\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\xd0\\x16\\xd0\\x16\\xc4\\x0f\\x00\\x00\"\n        b\"\\x06\\x00\\x34\\x39\\x36\\x36\\x37\\x00\"\n        b\"\\x03\\x00\\x00\\x00\\x02\\x00\\x02\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n        b\"\\x01\\x00\\x00\\x00\\x03\\x00\\x03\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x09\\x06\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\xa1\\x81\\xa6\\x30\"\n    )\n\n    msg = bind.BindAck(\n        header=pdu.PDUHeader(\n            version=5,\n            version_minor=0,\n            packet_type=pdu.PacketType.BIND_ACK,\n            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG\n            | pdu.PacketFlags.PFC_LAST_FRAG\n            | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN,\n            data_rep=pdu.DataRep(),\n            frag_len=120,\n            auth_len=4,\n            call_id=2,\n        ),\n        sec_trailer=pdu.SecTrailer(\n            type=pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n            level=pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n            pad_length=0,\n            context_id=0,\n            auth_value=b\"\\xa1\\x81\\xa6\\x30\",\n        ),\n        max_xmit_frag=5840,\n        max_recv_frag=5840,\n        assoc_group=4036,\n        sec_addr=\"49667\",\n        results=[\n            bind.ContextResult(\n                result=bind.ContextResultCode.PROVIDER_REJECTION,\n                reason=2,\n                syntax=uuid.UUID(int=0),\n                syntax_version=0,\n            ),\n            bind.ContextResult(\n                result=bind.ContextResultCode.ACCEPTANCE,\n                reason=0,\n                syntax=uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"),\n                syntax_version=1,\n            ),\n            bind.ContextResult(\n                result=bind.ContextResultCode.NEGOTIATE_ACK,\n                reason=3,\n                syntax=uuid.UUID(int=0),\n                syntax_version=0,\n            ),\n        ],\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_bind_ack_unpack_sec_trailer() -> None:\n    data = (\n        b\"\\x05\\x00\\x0c\\x07\\x10\\x00\\x00\\x00\"\n        b\"\\x78\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\xd0\\x16\\xd0\\x16\\xc4\\x0f\\x00\\x00\"\n        b\"\\x06\\x00\\x34\\x39\\x36\\x36\\x37\\x00\"\n        b\"\\x03\\x00\\x00\\x00\\x02\\x00\\x02\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x33\\x05\\x71\\x71\\xba\\xbe\\x37\\x49\"\n        b\"\\x83\\x19\\xb5\\xdb\\xef\\x9c\\xcc\\x36\"\n        b\"\\x01\\x00\\x00\\x00\\x03\\x00\\x03\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x09\\x06\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\xa1\\x81\\xa6\\x30\"\n    )\n\n    msg = pdu.PDU.unpack(data)\n    assert isinstance(msg, bind.BindAck)\n    assert msg.header.version == 5\n    assert msg.header.version_minor == 0\n    assert msg.header.packet_type == pdu.PacketType.BIND_ACK\n    assert (\n        msg.header.packet_flags\n        == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN\n    )\n    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n    assert msg.header.frag_len == 120\n    assert msg.header.auth_len == 4\n    assert msg.header.call_id == 2\n    assert msg.max_xmit_frag == 5840\n    assert msg.max_recv_frag == 5840\n    assert msg.assoc_group == 4036\n    assert msg.sec_addr == \"49667\"\n    assert len(msg.results) == 3\n    assert msg.results[0].result == bind.ContextResultCode.PROVIDER_REJECTION\n    assert msg.results[0].reason == 2\n    assert msg.results[0].syntax == uuid.UUID(int=0)\n    assert msg.results[0].syntax_version == 0\n    assert msg.results[1].result == bind.ContextResultCode.ACCEPTANCE\n    assert msg.results[1].reason == 0\n    assert msg.results[1].syntax == uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\")\n    assert msg.results[1].syntax_version == 1\n    assert msg.results[2].result == bind.ContextResultCode.NEGOTIATE_ACK\n    assert msg.results[2].reason == 3\n    assert msg.results[2].syntax == uuid.UUID(int=0)\n    assert msg.results[2].syntax_version == 0\n    assert isinstance(msg.sec_trailer, pdu.SecTrailer)\n    assert msg.sec_trailer.type == pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE\n    assert msg.sec_trailer.level == pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n    assert msg.sec_trailer.pad_length == 0\n    assert msg.sec_trailer.context_id == 0\n    assert msg.sec_trailer.auth_value == b\"\\xa1\\x81\\xa6\\x30\"", "\n\ndef test_bind_nak_pack() -> None:\n    expected = b\"\\x05\\x00\\x0d\\x03\\x10\\x00\\x00\\x00\\x18\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x01\\x05\\x00\\x00\\x00\\x00\"\n\n    msg = bind.BindNak(\n        header=pdu.PDUHeader(\n            version=5,\n            version_minor=0,\n            packet_type=pdu.PacketType.BIND_NAK,\n            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG,\n            data_rep=pdu.DataRep(),\n            frag_len=24,\n            auth_len=0,\n            call_id=1,\n        ),\n        sec_trailer=None,\n        reject_reason=0,\n        versions=[(5, 0)],\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_bind_nak_unpack() -> None:\n    data = b\"\\x05\\x00\\x0d\\x03\\x10\\x00\\x00\\x00\\x18\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x01\\x05\\x00\\x00\\x00\\x00\"\n\n    msg = pdu.PDU.unpack(data)\n    assert isinstance(msg, bind.BindNak)\n    assert msg.header.version == 5\n    assert msg.header.version_minor == 0\n    assert msg.header.packet_type == pdu.PacketType.BIND_NAK\n    assert msg.header.packet_flags == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG\n    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n    assert msg.header.frag_len == 24\n    assert msg.header.auth_len == 0\n    assert msg.header.call_id == 1\n    assert msg.reject_reason == 0\n    assert msg.versions == [(5, 0)]\n    assert msg.sec_trailer is None", "\n\ndef test_alter_context_pack() -> None:\n    expected = (\n        b\"\\x05\\x00\\x0e\\x07\\x10\\x00\\x00\\x00\"\n        b\"\\x54\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\xd0\\x16\\xd0\\x16\\x00\\x00\\x00\\x00\"\n        b\"\\x01\\x00\\x00\\x00\\x01\\x00\\x01\\x00\"\n        b\"\\x35\\x42\\x51\\xe3\\x06\\x4b\\xd1\\x11\"\n        b\"\\xab\\x04\\x00\\xc0\\x4f\\xc2\\xdc\\xd2\"\n        b\"\\x04\\x00\\x00\\x00\\x33\\x05\\x71\\x71\"\n        b\"\\xba\\xbe\\x37\\x49\\x83\\x19\\xb5\\xdb\"\n        b\"\\xef\\x9c\\xcc\\x36\\x01\\x00\\x00\\x00\"\n        b\"\\x09\\x06\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\xa1\\x81\\x89\\x30\"\n    )\n    syntax_id = bind.SyntaxId(uuid.UUID(\"e3514235-4b06-11d1-ab04-00c04fc2dcd2\"), 4, 0)\n\n    msg = bind.Bind(\n        header=pdu.PDUHeader(\n            version=5,\n            version_minor=0,\n            packet_type=pdu.PacketType.ALTER_CONTEXT,\n            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG\n            | pdu.PacketFlags.PFC_LAST_FRAG\n            | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN,\n            data_rep=pdu.DataRep(),\n            frag_len=84,\n            auth_len=4,\n            call_id=2,\n        ),\n        sec_trailer=pdu.SecTrailer(\n            type=pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n            level=pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n            pad_length=0,\n            context_id=0,\n            auth_value=b\"\\xa1\\x81\\x89\\x30\",\n        ),\n        max_xmit_frag=5840,\n        max_recv_frag=5840,\n        assoc_group=0,\n        contexts=[\n            bind.ContextElement(\n                context_id=1,\n                abstract_syntax=syntax_id,\n                transfer_syntaxes=[bind.SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0)],\n            ),\n        ],\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_alter_context_unpack() -> None:\n    data = (\n        b\"\\x05\\x00\\x0e\\x07\\x10\\x00\\x00\\x00\"\n        b\"\\x54\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\xd0\\x16\\xd0\\x16\\x00\\x00\\x00\\x00\"\n        b\"\\x01\\x00\\x00\\x00\\x01\\x00\\x01\\x00\"\n        b\"\\x35\\x42\\x51\\xe3\\x06\\x4b\\xd1\\x11\"\n        b\"\\xab\\x04\\x00\\xc0\\x4f\\xc2\\xdc\\xd2\"\n        b\"\\x04\\x00\\x00\\x00\\x33\\x05\\x71\\x71\"\n        b\"\\xba\\xbe\\x37\\x49\\x83\\x19\\xb5\\xdb\"\n        b\"\\xef\\x9c\\xcc\\x36\\x01\\x00\\x00\\x00\"\n        b\"\\x09\\x06\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\xa1\\x81\\x89\\x30\"\n    )\n    syntax_id = bind.SyntaxId(uuid.UUID(\"e3514235-4b06-11d1-ab04-00c04fc2dcd2\"), 4, 0)\n\n    msg = pdu.PDU.unpack(data)\n    assert isinstance(msg, bind.AlterContext)\n    assert msg.header.version == 5\n    assert msg.header.version_minor == 0\n    assert msg.header.packet_type == pdu.PacketType.ALTER_CONTEXT\n    assert (\n        msg.header.packet_flags\n        == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN\n    )\n    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n    assert msg.header.frag_len == 84\n    assert msg.header.auth_len == 4\n    assert msg.header.call_id == 2\n    assert msg.max_xmit_frag == 5840\n    assert msg.max_recv_frag == 5840\n    assert msg.assoc_group == 0\n    assert len(msg.contexts) == 1\n\n    assert msg.contexts[0].context_id == 1\n    assert msg.contexts[0].abstract_syntax == syntax_id\n    assert len(msg.contexts[0].transfer_syntaxes) == 1\n    assert msg.contexts[0].transfer_syntaxes[0] == bind.SyntaxId(\n        uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0\n    )\n\n    assert isinstance(msg.sec_trailer, pdu.SecTrailer)\n    assert msg.sec_trailer.type == pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE\n    assert msg.sec_trailer.level == pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n    assert msg.sec_trailer.pad_length == 0\n    assert msg.sec_trailer.context_id == 0\n    assert msg.sec_trailer.auth_value == b\"\\xa1\\x81\\x89\\x30\"", "\n\ndef test_alter_context_resp_pack() -> None:\n    expected = (\n        b\"\\x05\\x00\\x0f\\x07\\x10\\x00\\x00\\x00\"\n        b\"\\x44\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\xd0\\x16\\xd0\\x16\\xc4\\x0f\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x33\\x05\\x71\\x71\"\n        b\"\\xba\\xbe\\x37\\x49\\x83\\x19\\xb5\\xdb\"\n        b\"\\xef\\x9c\\xcc\\x36\\x01\\x00\\x00\\x00\"\n        b\"\\x09\\x06\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\xa1\\x27\\x30\\x25\"\n    )\n\n    msg = bind.AlterContextResponse(\n        header=pdu.PDUHeader(\n            version=5,\n            version_minor=0,\n            packet_type=pdu.PacketType.ALTER_CONTEXT_RESP,\n            packet_flags=pdu.PacketFlags.PFC_FIRST_FRAG\n            | pdu.PacketFlags.PFC_LAST_FRAG\n            | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN,\n            data_rep=pdu.DataRep(),\n            frag_len=68,\n            auth_len=4,\n            call_id=2,\n        ),\n        sec_trailer=pdu.SecTrailer(\n            type=pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n            level=pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n            pad_length=0,\n            context_id=0,\n            auth_value=b\"\\xa1\\x27\\x30\\x25\",\n        ),\n        max_xmit_frag=5840,\n        max_recv_frag=5840,\n        assoc_group=4036,\n        sec_addr=\"\",\n        results=[\n            bind.ContextResult(\n                result=bind.ContextResultCode.ACCEPTANCE,\n                reason=0,\n                syntax=uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"),\n                syntax_version=1,\n            ),\n        ],\n    )\n    actual = msg.pack()\n    assert actual == expected", "\n\ndef test_alter_context_resp_unpack() -> None:\n    data = (\n        b\"\\x05\\x00\\x0f\\x07\\x10\\x00\\x00\\x00\"\n        b\"\\x44\\x00\\x04\\x00\\x02\\x00\\x00\\x00\"\n        b\"\\xd0\\x16\\xd0\\x16\\xc4\\x0f\\x00\\x00\"\n        b\"\\x00\\x00\\x34\\x39\\x01\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x33\\x05\\x71\\x71\"\n        b\"\\xba\\xbe\\x37\\x49\\x83\\x19\\xb5\\xdb\"\n        b\"\\xef\\x9c\\xcc\\x36\\x01\\x00\\x00\\x00\"\n        b\"\\x09\\x06\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\xa1\\x27\\x30\\x25\"\n    )\n\n    msg = pdu.PDU.unpack(data)\n    assert isinstance(msg, bind.AlterContextResponse)\n    assert msg.header.version == 5\n    assert msg.header.version_minor == 0\n    assert msg.header.packet_type == pdu.PacketType.ALTER_CONTEXT_RESP\n    assert (\n        msg.header.packet_flags\n        == pdu.PacketFlags.PFC_FIRST_FRAG | pdu.PacketFlags.PFC_LAST_FRAG | pdu.PacketFlags.PFC_SUPPORT_HEADER_SIGN\n    )\n    assert msg.header.data_rep.byte_order == pdu.IntegerRep.LITTLE_ENDIAN\n    assert msg.header.data_rep.character == pdu.CharacterRep.ASCII\n    assert msg.header.data_rep.floating_point == pdu.FloatingPointRep.IEEE\n    assert msg.header.frag_len == 68\n    assert msg.header.auth_len == 4\n    assert msg.header.call_id == 2\n    assert msg.max_xmit_frag == 5840\n    assert msg.max_recv_frag == 5840\n    assert msg.assoc_group == 4036\n    assert msg.sec_addr == \"\"\n    assert len(msg.results) == 1\n    assert msg.results[0].result == bind.ContextResultCode.ACCEPTANCE\n    assert msg.results[0].reason == 0\n    assert msg.results[0].syntax == uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\")\n    assert msg.results[0].syntax_version == 1\n\n    assert isinstance(msg.sec_trailer, pdu.SecTrailer)\n    assert msg.sec_trailer.type == pdu.SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE\n    assert msg.sec_trailer.level == pdu.AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n    assert msg.sec_trailer.pad_length == 0\n    assert msg.sec_trailer.context_id == 0\n    assert msg.sec_trailer.auth_value == b\"\\xa1\\x27\\x30\\x25\"", "\n\n@pytest.mark.parametrize(\n    \"flags, expected\",\n    [\n        (bind.BindTimeFeatureNegotiation.NONE, \"6cb71c2c-9812-4540-0000-000000000000\"),\n        (bind.BindTimeFeatureNegotiation.SECURITY_CONTEXT_MULTIPLEXING, \"6cb71c2c-9812-4540-0100-000000000000\"),\n        (bind.BindTimeFeatureNegotiation.KEEP_CONNECTION_ON_ORPHAN, \"6cb71c2c-9812-4540-0200-000000000000\"),\n        (\n            bind.BindTimeFeatureNegotiation.SECURITY_CONTEXT_MULTIPLEXING", "        (\n            bind.BindTimeFeatureNegotiation.SECURITY_CONTEXT_MULTIPLEXING\n            | bind.BindTimeFeatureNegotiation.KEEP_CONNECTION_ON_ORPHAN,\n            \"6cb71c2c-9812-4540-0300-000000000000\",\n        ),\n    ],\n    ids=[\n        \"NONE\",\n        \"SECURITY_CONTEXT_MULTIPLEXING\",\n        \"KEEP_CONNECTION_ON_ORPHAN\",", "        \"SECURITY_CONTEXT_MULTIPLEXING\",\n        \"KEEP_CONNECTION_ON_ORPHAN\",\n        \"SECURITY_CONTEXT_MULTIPLEXING|KEEP_CONNECTION_ON_ORPHAN\",\n    ],\n)\ndef test_bind_time_feature_negotiation(\n    flags: bind.BindTimeFeatureNegotiation,\n    expected: str,\n) -> None:\n    actual = bind.bind_time_feature_negotiation(flags)\n\n    assert actual.uuid == uuid.UUID(expected)\n    assert actual.version == 1\n    assert actual.version_minor == 0", ""]}
{"filename": "tests/integration/templates/test_integration.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nimport os\nimport socket\nimport typing as t\n\nimport psrp\nimport pytest\n", "import pytest\n\nimport dpapi_ng\n\nDOMAIN_REALM = \"{{ domain_name }}\"\nDC_FQDN = f\"dc01.{DOMAIN_REALM}\"\nDC_IP = socket.gethostbyname(DC_FQDN)\nUSERNAME1 = \"{{ domain_username | lower }}\"\nUSERNAME2 = \"{{ domain_username2 | lower }}\"\nPASSWORD = \"{{ domain_password }}\"", "USERNAME2 = \"{{ domain_username2 | lower }}\"\nPASSWORD = \"{{ domain_password }}\"\nUSER_UPN = f\"{USERNAME1}@{DOMAIN_REALM.upper()}\"\n\nGET_SID_SCRIPT = r\"\"\"[CmdletBinding()]\nparam (\n    [Parameter(Mandatory)]\n    [string]\n    $UserName\n)", "    $UserName\n)\n\n([System.Security.Principal.NTAccount]$UserName).Translate([System.Security.Principal.SecurityIdentifier]).Value\n\"\"\"\n\nENCRYPT_SCRIPT = r\"\"\"[CmdletBinding()]\nparam (\n    [Parameter(Mandatory)]\n    [string]", "    [Parameter(Mandatory)]\n    [string]\n    $ProtectionDescriptor,\n\n    [Parameter(Mandatory)]\n    [byte[]]\n    $InputObject\n)\n\n$ErrorActionPreference = 'Stop'", "\n$ErrorActionPreference = 'Stop'\n\n# Ensure we remove any cached key so the latest KDS root is selected\n$cryptoKeysPath = \"$env:LOCALAPPDATA\\Microsoft\\Crypto\\KdsKey\"\nif (Test-Path -LiteralPath $cryptoKeysPath) {\n    Get-ChildItem -LiteralPath $cryptoKeysPath | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue\n}\n\n[byte[]]$res = . \"C:\\temp\\ConvertTo-DpapiNgBlob.ps1\" -ProtectionDescriptor $ProtectionDescriptor -InputObject $InputObject", "\n[byte[]]$res = . \"C:\\temp\\ConvertTo-DpapiNgBlob.ps1\" -ProtectionDescriptor $ProtectionDescriptor -InputObject $InputObject\n, $res\n\"\"\"\n\nDECRYPT_SCRIPT = r\"\"\"[CmdletBinding()]\nparam (\n    [Parameter(Mandatory)]\n    [byte[]]\n    $InputObject", "    [byte[]]\n    $InputObject\n)\n\n$ErrorActionPreference = 'Stop'\n\n[byte[]]$res = . \"C:\\temp\\ConvertFrom-DpapiNgBlob.ps1\" -InputObject $InputObject\n, $res\n\"\"\"\n", "\"\"\"\n\nwsman = psrp.WSManInfo(DC_FQDN)\nwith psrp.SyncRunspacePool(wsman) as rp:\n    ps = psrp.SyncPowerShell(rp)\n    ps.add_script(GET_SID_SCRIPT).add_parameter(\"UserName\", USERNAME1)\n    USERNAME1_SID = ps.invoke()[0]\n\n    ps = psrp.SyncPowerShell(rp)\n    ps.add_script(GET_SID_SCRIPT).add_parameter(\"UserName\", USERNAME2)\n    USERNAME2_SID = ps.invoke()[0]", "\n\ndef test_decrypt_sync_with_nonce() -> None:\n    data = os.urandom(64)\n\n    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME1, password=PASSWORD)\n    with psrp.SyncRunspacePool(wsman) as rp:\n        ps = psrp.SyncPowerShell(rp)\n        ps.add_script(ENCRYPT_SCRIPT).add_parameters(\n            ProtectionDescriptor=f\"SID={USERNAME1_SID}\",\n            InputObject=data,\n        )\n        enc_blob = ps.invoke()[0]\n\n    actual = dpapi_ng.ncrypt_unprotect_secret(enc_blob)\n    assert actual == data", "\n\n@pytest.mark.asyncio\nasync def test_decrypt_async_with_nonce() -> None:\n    data = os.urandom(64)\n\n    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME1, password=PASSWORD)\n    async with psrp.AsyncRunspacePool(wsman) as rp:\n        ps = psrp.AsyncPowerShell(rp)\n        ps.add_script(ENCRYPT_SCRIPT).add_parameters(", "        ps = psrp.AsyncPowerShell(rp)\n        ps.add_script(ENCRYPT_SCRIPT).add_parameters(\n            ProtectionDescriptor=f\"SID={USERNAME1_SID}\",\n            InputObject=data,\n        )\n        enc_blob = (await ps.invoke())[0]\n\n    actual = await dpapi_ng.async_ncrypt_unprotect_secret(enc_blob)\n    assert actual == data\n", "    assert actual == data\n\n\ndef test_decrypt_sync_with_public_key() -> None:\n    data = os.urandom(64)\n\n    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME2, password=PASSWORD)\n    with psrp.SyncRunspacePool(wsman) as rp:\n        ps = psrp.SyncPowerShell(rp)\n        ps.add_script(ENCRYPT_SCRIPT).add_parameters(\n            ProtectionDescriptor=f\"SID={USERNAME1_SID}\",\n            InputObject=data,\n        )\n        enc_blob = ps.invoke()[0]\n\n    actual = dpapi_ng.ncrypt_unprotect_secret(enc_blob)\n    assert actual == data", "\n\n@pytest.mark.asyncio\nasync def test_decrypt_async_with_public_key() -> None:\n    data = os.urandom(64)\n\n    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME2, password=PASSWORD)\n    async with psrp.AsyncRunspacePool(wsman) as rp:\n        ps = psrp.AsyncPowerShell(rp)\n        ps.add_script(ENCRYPT_SCRIPT).add_parameters(", "        ps = psrp.AsyncPowerShell(rp)\n        ps.add_script(ENCRYPT_SCRIPT).add_parameters(\n            ProtectionDescriptor=f\"SID={USERNAME1_SID}\",\n            InputObject=data,\n        )\n        enc_blob = (await ps.invoke())[0]\n\n    actual = dpapi_ng.ncrypt_unprotect_secret(enc_blob)\n    assert actual == data\n", "    assert actual == data\n\n\ndef test_encrypt_sync_as_authorised_user() -> None:\n    data = os.urandom(64)\n\n    kwargs: t.Dict[str, t.Any] = {}\n    if os.name != \"nt\":\n        kwargs[\"domain_name\"] = DOMAIN_REALM\n\n    blob = dpapi_ng.ncrypt_protect_secret(data, USERNAME1_SID, **kwargs)\n\n    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME1, password=PASSWORD)\n    with psrp.SyncRunspacePool(wsman) as rp:\n        ps = psrp.SyncPowerShell(rp)\n        ps.add_script(DECRYPT_SCRIPT).add_argument(blob)\n        actual = ps.invoke()\n\n        assert not ps.had_errors\n        assert actual == [data]", "\n\n@pytest.mark.asyncio\nasync def test_encrypt_async_as_authorised_user() -> None:\n    data = os.urandom(64)\n\n    kwargs: t.Dict[str, t.Any] = {}\n    if os.name != \"nt\":\n        kwargs[\"domain_name\"] = DOMAIN_REALM\n", "\n    blob = dpapi_ng.ncrypt_protect_secret(data, USERNAME1_SID, **kwargs)\n\n    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME1, password=PASSWORD)\n    async with psrp.AsyncRunspacePool(wsman) as rp:\n        ps = psrp.AsyncPowerShell(rp)\n        ps.add_script(DECRYPT_SCRIPT).add_argument(blob)\n        actual = await ps.invoke()\n\n        assert not ps.had_errors", "\n        assert not ps.had_errors\n        assert actual == [data]\n\n\ndef test_encrypt_sync_as_unauthorised_user() -> None:\n    data = os.urandom(64)\n\n    kwargs: t.Dict[str, t.Any] = {}\n    if os.name != \"nt\":\n        kwargs[\"domain_name\"] = DOMAIN_REALM\n\n    blob = dpapi_ng.ncrypt_protect_secret(data, USERNAME2_SID, **kwargs)\n\n    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME2, password=PASSWORD)\n    with psrp.SyncRunspacePool(wsman) as rp:\n        ps = psrp.SyncPowerShell(rp)\n        ps.add_script(DECRYPT_SCRIPT).add_argument(blob)\n        actual = ps.invoke()\n\n        assert not ps.had_errors\n        assert actual == [data]", "\n\n@pytest.mark.asyncio\nasync def test_encrypt_async_as_unauthorised_user() -> None:\n    data = os.urandom(64)\n\n    kwargs: t.Dict[str, t.Any] = {}\n    if os.name != \"nt\":\n        kwargs[\"domain_name\"] = DOMAIN_REALM\n", "\n    blob = dpapi_ng.ncrypt_protect_secret(data, USERNAME2_SID, **kwargs)\n\n    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME2, password=PASSWORD)\n    async with psrp.AsyncRunspacePool(wsman) as rp:\n        ps = psrp.AsyncPowerShell(rp)\n        ps.add_script(DECRYPT_SCRIPT).add_argument(blob)\n        actual = await ps.invoke()\n\n        assert not ps.had_errors", "\n        assert not ps.had_errors\n        assert actual == [data]\n\n\n@pytest.mark.parametrize(\"protocol\", [\"negotiate\", \"negotiate-ntlm\", \"kerberos\", \"ntlm\"])\ndef test_rpc_auth(protocol: str) -> None:\n    data = os.urandom(64)\n\n    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME1, password=PASSWORD)\n    with psrp.SyncRunspacePool(wsman) as rp:\n        ps = psrp.SyncPowerShell(rp)\n        ps.add_script(ENCRYPT_SCRIPT).add_parameters(\n            ProtectionDescriptor=f\"SID={USERNAME1_SID}\",\n            InputObject=data,\n        )\n        enc_blob = ps.invoke()[0]\n\n    server = None\n    username = None\n    password = None\n    is_ntlm = protocol in [\"negotiate-ntlm\", \"ntlm\"]\n    if protocol == \"negotiate-ntlm\":\n        server = DC_IP\n        protocol = \"negotiate\"\n\n    if os.name != \"nt\" and is_ntlm:\n        username = USER_UPN\n        password = PASSWORD\n\n    actual = dpapi_ng.ncrypt_unprotect_secret(\n        enc_blob,\n        server,\n        username=username,\n        password=password,\n        auth_protocol=protocol,\n    )\n    assert actual == data", "\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\"protocol\", [\"negotiate\", \"negotiate-ntlm\", \"kerberos\", \"ntlm\"])\nasync def test_rpc_auth_async(protocol: str) -> None:\n    data = os.urandom(64)\n\n    wsman = psrp.WSManInfo(DC_FQDN, auth=\"credssp\", username=USERNAME1, password=PASSWORD)\n    async with psrp.AsyncRunspacePool(wsman) as rp:\n        ps = psrp.AsyncPowerShell(rp)", "    async with psrp.AsyncRunspacePool(wsman) as rp:\n        ps = psrp.AsyncPowerShell(rp)\n        ps.add_script(ENCRYPT_SCRIPT).add_parameters(\n            ProtectionDescriptor=f\"SID={USERNAME1_SID}\",\n            InputObject=data,\n        )\n        enc_blob = (await ps.invoke())[0]\n\n    server = None\n    username = None", "    server = None\n    username = None\n    password = None\n    is_ntlm = protocol in [\"negotiate-ntlm\", \"ntlm\"]\n    if protocol == \"negotiate-ntlm\":\n        server = DC_IP\n        protocol = \"negotiate\"\n\n    if os.name != \"nt\" and is_ntlm:\n        username = USER_UPN\n        password = PASSWORD", "    if os.name != \"nt\" and is_ntlm:\n        username = USER_UPN\n        password = PASSWORD\n\n    actual = await dpapi_ng.async_ncrypt_unprotect_secret(\n        enc_blob,\n        server,\n        username=username,\n        password=password,\n        auth_protocol=protocol,", "        password=password,\n        auth_protocol=protocol,\n    )\n    assert actual == data\n"]}
{"filename": "tests/integration/files/generate_seed_keys.py", "chunked_list": ["import base64\nimport uuid\n\nfrom cryptography.hazmat.primitives import hashes\n\nfrom dpapi_ng import _crypto as crypto\nfrom dpapi_ng import _gkdi as gkdi\n\nalgorithm = hashes.SHA512()\nkey_id = uuid.UUID(\"2e1b932a-4e21-ced3-0b7b-8815aff8335d\")", "algorithm = hashes.SHA512()\nkey_id = uuid.UUID(\"2e1b932a-4e21-ced3-0b7b-8815aff8335d\")\n\n# This should be the L1 seed key for (L0, 31, -1)\nl1_key = base64.b16decode(\n    \"60E0A81F93164F5DC3ABE981E1EE54C1A6B9B0EDB6FF8274642758D29BBC66559D11F1871A82A6E3F232C42490D7C41C6AD2B8B189FE2752A88CEC2EA4B2021C\"\n)\nl0 = 361\nl1 = 31\nl2 = 31", "l1 = 31\nl2 = 31\nl2_key = b\"\"\n\nwhile l1 >= 0:\n    print(f\"({l0}, {l1:<2}, -1) {base64.b16encode(l1_key).decode()}\")\n\n    while l2 >= 0:\n        if l2 == 31:\n            l2_key = crypto.kdf(\n                algorithm,\n                l1_key,\n                gkdi.KDS_SERVICE_LABEL,\n                gkdi.compute_kdf_context(key_id, l0, l1, l2),\n                64,\n            )\n\n        else:\n            l2_key = crypto.kdf(\n                algorithm,\n                l2_key,\n                gkdi.KDS_SERVICE_LABEL,\n                gkdi.compute_kdf_context(key_id, l0, l1, l2),\n                64,\n            )", "        if l2 == 31:\n            l2_key = crypto.kdf(\n                algorithm,\n                l1_key,\n                gkdi.KDS_SERVICE_LABEL,\n                gkdi.compute_kdf_context(key_id, l0, l1, l2),\n                64,\n            )\n\n        else:\n            l2_key = crypto.kdf(\n                algorithm,\n                l2_key,\n                gkdi.KDS_SERVICE_LABEL,\n                gkdi.compute_kdf_context(key_id, l0, l1, l2),\n                64,\n            )", "\n        print(f\"({l0}, {l1:<2}, {l2:<2}) {base64.b16encode(l2_key).decode()}\")\n        l2 -= 1\n\n    l2 = 31\n    l1 -= 1\n    l1_key = crypto.kdf(\n        algorithm,\n        l1_key,\n        gkdi.KDS_SERVICE_LABEL,", "        l1_key,\n        gkdi.KDS_SERVICE_LABEL,\n        gkdi.compute_kdf_context(key_id, l0, l1, -1),\n        64,\n    )\n"]}
{"filename": "tests/integration/files/sp800_56a_concat.py", "chunked_list": ["import base64\nimport dataclasses\nimport hashlib\nimport sys\nimport typing as t\n\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.kdf.concatkdf import ConcatKDFHash\n", "from cryptography.hazmat.primitives.kdf.concatkdf import ConcatKDFHash\n\n\n@dataclasses.dataclass(frozen=True)\nclass FFCDHKey:\n    # MS-GKDI 2.2.3.1 FFC DH Key:\n    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/f8770f01-036d-4bf6-a4cf-1bd0e3913404\n\n    magic: bytes = dataclasses.field(init=False, repr=False, default=b\"\\x44\\x48\\x50\\x42\")\n    key_length: int\n    field_order: int\n    generator: int\n    public_key: int\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> \"FFCDHKey\":\n        view = memoryview(data)\n\n        if view[:4].tobytes() != cls.magic:\n            raise ValueError(f\"Failed to unpack {cls.__name__} as magic identifier is invalid\")\n\n        key_length = int.from_bytes(view[4:8], byteorder=\"little\")\n\n        field_order = view[8 : 8 + key_length].tobytes()\n        view = view[8 + key_length :]\n\n        generator = view[:key_length].tobytes()\n        view = view[key_length:]\n\n        public_key = view[:key_length].tobytes()\n\n        return FFCDHKey(\n            key_length=key_length,\n            field_order=int.from_bytes(field_order, byteorder=\"big\"),\n            generator=int.from_bytes(generator, byteorder=\"big\"),\n            public_key=int.from_bytes(public_key, byteorder=\"big\"),\n        )", "\n\n@dataclasses.dataclass(frozen=True)\nclass ECDHKey:\n    # MS-GKDI 2.2.3.2 ECDH Key:\n    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/24876a37-9a92-4187-9052-222bb6f85d4a\n\n    curve_name: str\n    key_length: int\n    x: int\n    y: int\n\n    @property\n    def curve_and_hash(self) -> tuple[ec.EllipticCurve, hashes.HashAlgorithm]:\n        return {\n            \"P256\": (ec.SECP256R1(), hashes.SHA256()),\n            \"P384\": (ec.SECP384R1(), hashes.SHA384()),\n            \"P521\": (ec.SECP521R1(), hashes.SHA512()),\n        }[self.curve_name]\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> \"ECDHKey\":\n        view = memoryview(data)\n\n        curve_id = int.from_bytes(view[:4], byteorder=\"little\")\n        curve = {\n            0x314B4345: \"P256\",\n            0x334B4345: \"P384\",\n            0x354B4345: \"P521\",\n        }.get(curve_id, None)\n        if not curve:\n            raise ValueError(f\"Failed to unpack {cls.__name__} with unknown curve 0x{curve_id:08X}\")\n\n        length = int.from_bytes(view[4:8], byteorder=\"little\")\n\n        x = view[8 : 8 + length].tobytes()\n        view = view[8 + length :]\n\n        y = view[:length].tobytes()\n\n        return ECDHKey(\n            curve_name=curve,\n            key_length=length,\n            x=int.from_bytes(x, byteorder=\"big\"),\n            y=int.from_bytes(y, byteorder=\"big\"),\n        )", "\n\nscenarios = {\n    \"DH\": {\n        \"KeyLength\": 2048,\n        \"SecretParams\": \"0C0200004448504D0001000087A8E61DB4B6663CFFBBD19C651959998CEEF608660DD0F25D2CEED4435E3B00E00DF8F1D61957D4FAF7DF4561B2AA3016C3D91134096FAA3BF4296D830E9A7C209E0C6497517ABD5A8A9D306BCF67ED91F9E6725B4758C022E0B1EF4275BF7B6C5BFC11D45F9088B941F54EB1E59BB8BC39A0BF12307F5C4FDB70C581B23F76B63ACAE1CAA6B7902D52526735488A0EF13C6D9A51BFA4AB3AD8347796524D8EF6A167B5A41825D967E144E5140564251CCACB83E6B486F6B3CA3F7971506026C0B857F689962856DED4010ABD0BE621C3A3960A54E710C375F26375D7014103A4B54330C198AF126116D2276E11715F693877FAD7EF09CADB094AE91E1A15973FB32C9B73134D0B2E77506660EDBD484CA7B18F21EF205407F4793A1A0BA12510DBC15077BE463FFF4FED4AAC0BB555BE3A6C1B0C6B47B1BC3773BF7E8C6F62901228F8C28CBB18A55AE31341000A650196F931C77A57F2DDF463E5E9EC144B777DE62AAAB8A8628AC376D282D6ED3864E67982428EBC831D14348F6F2F9193B5045AF2767164E1DFC967C1FB3F2E55A4BD1BFFE83B9C80D052B985D182EA0ADB2A3B7313D3FE14C8484B1E052588B9B7D2BBD2DF016199ECD06E1557CD0915B3353BBB64E0EC377FD028370DF92B52C7891428CDC67EB6184B523D1DB246C32F63078490F00EF8D647D148D47954515E2327CFEF98C582664B4C0F6CC41659\",\n        \"PublicKey\": \"444850420001000087A8E61DB4B6663CFFBBD19C651959998CEEF608660DD0F25D2CEED4435E3B00E00DF8F1D61957D4FAF7DF4561B2AA3016C3D91134096FAA3BF4296D830E9A7C209E0C6497517ABD5A8A9D306BCF67ED91F9E6725B4758C022E0B1EF4275BF7B6C5BFC11D45F9088B941F54EB1E59BB8BC39A0BF12307F5C4FDB70C581B23F76B63ACAE1CAA6B7902D52526735488A0EF13C6D9A51BFA4AB3AD8347796524D8EF6A167B5A41825D967E144E5140564251CCACB83E6B486F6B3CA3F7971506026C0B857F689962856DED4010ABD0BE621C3A3960A54E710C375F26375D7014103A4B54330C198AF126116D2276E11715F693877FAD7EF09CADB094AE91E1A15973FB32C9B73134D0B2E77506660EDBD484CA7B18F21EF205407F4793A1A0BA12510DBC15077BE463FFF4FED4AAC0BB555BE3A6C1B0C6B47B1BC3773BF7E8C6F62901228F8C28CBB18A55AE31341000A650196F931C77A57F2DDF463E5E9EC144B777DE62AAAB8A8628AC376D282D6ED3864E67982428EBC831D14348F6F2F9193B5045AF2767164E1DFC967C1FB3F2E55A4BD1BFFE83B9C80D052B985D182EA0ADB2A3B7313D3FE14C8484B1E052588B9B7D2BBD2DF016199ECD06E1557CD0915B3353BBB64E0EC377FD028370DF92B52C7891428CDC67EB6184B523D1DB246C32F63078490F00EF8D647D148D47954515E2327CFEF98C582664B4C0F6CC41659535CC9DB0F3BE1D18BA5D691DCBD7ADFC2A3F331E8875264BDB99B71F0DD0715ED1002DFFDC00BEA4A252738BFD027B283C0A61C3BA7A060732B2DBEC520BCA23941810CBC555A4C69F45F35C05EE02E71E3ACB6ED5B9B55F0DC408E13640CDC58A04900E73018ADBD7D5840DD29CB6482AF75483C22AF35A48AD0D166FADED4C1C58F749CD130BDB4726938FC6A90E17726D75B2284592AA292B52A97807B80355705794340702333C9558EC671DD206D9C796BC26953D7F7261776E69A2DA8496E3AD04877D645571BBCCE655CD57C53BFE3406B457B807BB497B79C99D0766DD3D19B594E98D5B685302171A02313DA5BE5F5F6D1B98BC6B9BF5B68992C1C\",\n        \"PrivateKey\": \"8844C8622AF1CC0D2ACF6581CD4F03DBDA3C97C08E37C97CA6E8C30C0B4E27926C6726FF6EF74EFA6D7F9AF818564A73D511A661E37CB41D07098B0F4D0D5B80\",\n        \"ExpectedSecretAgreement\": \"2F3ED6CECAFBDF3E386240FCFB5B499310015243651BC97AEFF9EE23E760100E3A825814CCBD7B064339B9105512CEA22D6E9C0FEFBBDADCC26E01BD8F286BD9993F0068B3CFEF9113311BBAA7B37D05462E2B740259CC211E75260708706A98B3FB967C45109FDABF6589312490B6F03AA65F0E4C882317865C55708916D82B962912909F6ED6E85EDEB7CB2CC1AC8C812A390A23B4E2DB645D17BF7417BF9F176CE807366A46A5797E7F5828B64389ADAEDDED099A9BC634C037315D0389B008C5D3CB966AF458FC524F8C7FBF814DD93117979F5410952510BED6B5BA4A7DBCA10FFDC4B7A5709C223C9A1AF9C9B36BF92883333417A3606CC59A200B12D1\",\n        \"ExpectedSecret\": \"CAF41BA47887FB04AC7B80B6FF1BD15C5135500372B889A143C3AAC7D695955E\",", "        \"ExpectedSecretAgreement\": \"2F3ED6CECAFBDF3E386240FCFB5B499310015243651BC97AEFF9EE23E760100E3A825814CCBD7B064339B9105512CEA22D6E9C0FEFBBDADCC26E01BD8F286BD9993F0068B3CFEF9113311BBAA7B37D05462E2B740259CC211E75260708706A98B3FB967C45109FDABF6589312490B6F03AA65F0E4C882317865C55708916D82B962912909F6ED6E85EDEB7CB2CC1AC8C812A390A23B4E2DB645D17BF7417BF9F176CE807366A46A5797E7F5828B64389ADAEDDED099A9BC634C037315D0389B008C5D3CB966AF458FC524F8C7FBF814DD93117979F5410952510BED6B5BA4A7DBCA10FFDC4B7A5709C223C9A1AF9C9B36BF92883333417A3606CC59A200B12D1\",\n        \"ExpectedSecret\": \"CAF41BA47887FB04AC7B80B6FF1BD15C5135500372B889A143C3AAC7D695955E\",\n    },\n    \"ECDH_P256\": {\n        \"KeyLength\": 256,\n        \"SecretParams\": \"\",\n        \"PublicKey\": \"45434B31200000005AFBDDBB412E39B367302AEDF04A8F8D184D9801FA4A560BF35AB0FD83E5C93CB5EE98D8B938672442C1CFCDFAADADA31A014776F9B72C2CA9F06E5B6DDA2218\",\n        \"PrivateKey\": \"B65D20E0916BE7C6A9F865826432C4F3B5347FAA07271D675C065EE2BA34AA13\",\n        \"ExpectedSecretAgreement\": \"98E13228F67F865CB9A699679F37C394BCA0DF718AF71C9F9E97B7108C16D74B\",\n        \"ExpectedSecret\": \"37208B86DC931C2F5FB4E5A0295B877D0AE98B8F4CE79F6B407B5926B519AF6C\",", "        \"ExpectedSecretAgreement\": \"98E13228F67F865CB9A699679F37C394BCA0DF718AF71C9F9E97B7108C16D74B\",\n        \"ExpectedSecret\": \"37208B86DC931C2F5FB4E5A0295B877D0AE98B8F4CE79F6B407B5926B519AF6C\",\n    },\n    \"ECDH_P384\": {\n        \"KeyLength\": 384,\n        \"SecretParams\": \"\",\n        \"PublicKey\": \"45434B3330000000519FB25DB5692BADEE44DE4044EC0F0AAF4BD86F9D3F1967031AD2E7B7A656EEE7E114EFFCF0D83E682C246F3E04119FED903CE810FC060F6DCA3E4901E20DFA5EE82AE9DCB237102892E8A2997BFF0CC9C755541F066E83550FD200B3D4B50E\",\n        \"PrivateKey\": \"1D94E9DE911B17981356E4464B691FDAB12AE822ECC152C2D786CD060CA32255ACE7B1EB0F3644AAE19AF5F75D03FFC3\",\n        \"ExpectedSecretAgreement\": \"2441392B082A8A8AD52BE6707517DA5CF19A629B4AF177B19FF03D13BF6CBA2D0A06A98259C16F6A3CDDD29EE50B72FC\",\n        \"ExpectedSecret\": \"8A10120B4DD74F21DA5C79917E993DBC5DE1A8346112A33300C8F30CCC77E5F1DEAD404BBDA472E6CB42D6A448872425\",", "        \"ExpectedSecretAgreement\": \"2441392B082A8A8AD52BE6707517DA5CF19A629B4AF177B19FF03D13BF6CBA2D0A06A98259C16F6A3CDDD29EE50B72FC\",\n        \"ExpectedSecret\": \"8A10120B4DD74F21DA5C79917E993DBC5DE1A8346112A33300C8F30CCC77E5F1DEAD404BBDA472E6CB42D6A448872425\",\n    },\n}\n\nscenario = sys.argv[1]\nkey_length = scenarios[scenario][\"KeyLength\"]\nsecret_params = base64.b16decode(str(scenarios[scenario][\"SecretParams\"]))\npublic_key = base64.b16decode(str(scenarios[scenario][\"PublicKey\"]))\nprivate_key = base64.b16decode(str(scenarios[scenario][\"PrivateKey\"]))", "public_key = base64.b16decode(str(scenarios[scenario][\"PublicKey\"]))\nprivate_key = base64.b16decode(str(scenarios[scenario][\"PrivateKey\"]))\nexpected_secret_agreement = base64.b16decode(str(scenarios[scenario][\"ExpectedSecretAgreement\"]))\nexpected_secret = base64.b16decode(str(scenarios[scenario][\"ExpectedSecret\"]))\n\nsecret_hash_algorithm: hashes.HashAlgorithm\nif scenario == \"DH\":\n    dh_pub_key = FFCDHKey.unpack(public_key)\n    shared_secret_int = pow(\n        dh_pub_key.public_key,\n        int.from_bytes(private_key, byteorder=\"big\"),\n        dh_pub_key.field_order,\n    )\n    shared_secret = shared_secret_int.to_bytes(dh_pub_key.key_length, byteorder=\"big\")\n    secret_hash_algorithm = hashes.SHA256()\n\nelse:\n    ecdh_pub_key_info = ECDHKey.unpack(public_key)\n    curve, secret_hash_algorithm = ecdh_pub_key_info.curve_and_hash\n\n    ecdh_pub_key = ec.EllipticCurvePublicNumbers(ecdh_pub_key_info.x, ecdh_pub_key_info.y, curve).public_key()\n    ecdh_private = ec.derive_private_key(\n        int.from_bytes(private_key, byteorder=\"big\"),\n        curve,\n    )\n    shared_secret = ecdh_private.exchange(ec.ECDH(), ecdh_pub_key)", "\n\nshared_secret1 = hashlib.sha256(shared_secret).digest()\nprint(f\"Actual Secret Agreement  : {base64.b16encode(shared_secret).decode()}\")\nprint(f\"Expected Secret Agreement: {base64.b16encode(expected_secret_agreement).decode()}\")\n\nalgorithm_id = \"SHA512\\0\"\nparty_uinfo = \"KDS public key\\0\"\nparty_vinfo = \"KDS service\\0\"\n", "party_vinfo = \"KDS service\\0\"\n\notherinfo = f\"{algorithm_id}{party_uinfo}{party_vinfo}\".encode(\"utf-16-le\")\nactual = ConcatKDFHash(\n    secret_hash_algorithm,\n    length=secret_hash_algorithm.digest_size,\n    otherinfo=otherinfo,\n).derive(shared_secret)\n\nprint(f\"Actual Secret  : {base64.b16encode(actual).decode()}\")", "\nprint(f\"Actual Secret  : {base64.b16encode(actual).decode()}\")\nprint(f\"Expected Secret: {base64.b16encode(expected_secret).decode()}\")\n"]}
{"filename": "src/dpapi_ng/_epm.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport dataclasses\nimport enum\nimport typing as t\nimport uuid\n", "import uuid\n\nfrom ._rpc import SyntaxId\n\nEPM = SyntaxId(uuid.UUID(\"e1af8308-5d1f-11c9-91a4-08002b14a0fa\"), 3, 0)\n\n# https://pubs.opengroup.org/onlinepubs/9629399/apdxl.htm\n# https://pubs.opengroup.org/onlinepubs/9629399/apdxi.htm#tagcjh_28\n\n\nclass FloorProtocol(enum.IntEnum):\n    OSI = 0x00\n    DNA_SESSION_CONTROL = 0x02\n    DNA_SESSION_CONTROL_V3 = 0x03\n    DNA_NSP_TRANSPORT = 0x04\n    TP4 = 0x05\n    CLNS = 0x06\n    TCP = 0x07\n    UDP = 0x08\n    IP = 0x09\n    RPC_CONNECTIONLESS = 0x0A\n    RPC_CONNECTION_ORIENTED = 0x0B\n    UUID_ID = 0x0D\n    NAMED_PIPES = 0x10\n    NETBIOS = 0x11\n    NETBEUI = 0x12\n    NETWARE_SPX = 0x13\n    NETWARE_IPX = 0x14\n    APPLETALK_STREAM = 0x16\n    APPLETALK_DATARAM = 0x17\n    APPLETALK = 0x18\n    NETBIOS2 = 0x19\n    VINES_SPP = 0x1A\n    VINES_IPC = 0x1B\n    STREET_TALK = 0x1C\n    UNIX_DOMAIN_SOCKET = 0x20\n    NULL = 0x21\n    NETBIOS3 = 0x22\n\n    @classmethod\n    def _missing_(cls, value: object) -> t.Optional[enum.Enum]:\n        new_member = int.__new__(cls)\n        new_member._name_ = f\"FloorProtocol Unknown 0x{value:04X}\"\n        new_member._value_ = value  # type: ignore[assignment]\n        return cls._value2member_map_.setdefault(value, new_member)", "\n\nclass FloorProtocol(enum.IntEnum):\n    OSI = 0x00\n    DNA_SESSION_CONTROL = 0x02\n    DNA_SESSION_CONTROL_V3 = 0x03\n    DNA_NSP_TRANSPORT = 0x04\n    TP4 = 0x05\n    CLNS = 0x06\n    TCP = 0x07\n    UDP = 0x08\n    IP = 0x09\n    RPC_CONNECTIONLESS = 0x0A\n    RPC_CONNECTION_ORIENTED = 0x0B\n    UUID_ID = 0x0D\n    NAMED_PIPES = 0x10\n    NETBIOS = 0x11\n    NETBEUI = 0x12\n    NETWARE_SPX = 0x13\n    NETWARE_IPX = 0x14\n    APPLETALK_STREAM = 0x16\n    APPLETALK_DATARAM = 0x17\n    APPLETALK = 0x18\n    NETBIOS2 = 0x19\n    VINES_SPP = 0x1A\n    VINES_IPC = 0x1B\n    STREET_TALK = 0x1C\n    UNIX_DOMAIN_SOCKET = 0x20\n    NULL = 0x21\n    NETBIOS3 = 0x22\n\n    @classmethod\n    def _missing_(cls, value: object) -> t.Optional[enum.Enum]:\n        new_member = int.__new__(cls)\n        new_member._name_ = f\"FloorProtocol Unknown 0x{value:04X}\"\n        new_member._value_ = value  # type: ignore[assignment]\n        return cls._value2member_map_.setdefault(value, new_member)", "\n\n@dataclasses.dataclass(frozen=True)\nclass Floor:\n    protocol: FloorProtocol\n    lhs: bytes\n    rhs: bytes\n\n    def pack(self) -> bytes:\n        return b\"\".join(\n            [\n                (len(self.lhs) + 1).to_bytes(2, byteorder=\"little\"),\n                self.protocol.to_bytes(1, byteorder=\"little\"),\n                self.lhs,\n                len(self.rhs).to_bytes(2, byteorder=\"little\"),\n                self.rhs,\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> Floor:\n        view = memoryview(data)\n\n        lhs_len = int.from_bytes(view[:2], byteorder=\"little\")\n        proto = FloorProtocol(view[2])\n        lhs = view[3 : lhs_len + 2].tobytes()\n        offset = lhs_len + 2\n\n        rhs_len = int.from_bytes(view[offset : offset + 2], byteorder=\"little\")\n        rhs = view[offset + 2 : offset + rhs_len + 2].tobytes()\n\n        unpack_func = _FLOOR_TYPE_REGISTRY.get(proto, None)\n        if unpack_func:\n            floor = unpack_func(lhs, rhs)\n            object.__setattr__(floor, \"lhs\", lhs)\n            object.__setattr__(floor, \"rhs\", rhs)\n            return floor\n\n        else:\n            return cls(protocol=proto, lhs=lhs, rhs=rhs)", "\n\nT = t.TypeVar(\"T\")\n_FLOOR_TYPE_REGISTRY: t.Dict[FloorProtocol, t.Callable[[bytes, bytes], Floor]] = {}\n\n\ndef register_floor(cls: T) -> T:\n    _FLOOR_TYPE_REGISTRY[getattr(cls, \"protocol\").default] = getattr(cls, \"_unpack\")\n    return cls\n", "\n\n@dataclasses.dataclass(frozen=True)\nclass _KnownFloor(Floor):\n    lhs: bytes = dataclasses.field(init=False, repr=False, default=b\"\")\n    rhs: bytes = dataclasses.field(init=False, repr=False, default=b\"\")\n\n\n@dataclasses.dataclass(frozen=True)\n@register_floor\nclass TCPFloor(_KnownFloor):\n    protocol: FloorProtocol = dataclasses.field(init=False, default=FloorProtocol.TCP)\n    port: int\n\n    def pack(self) -> bytes:\n        return Floor(self.protocol, b\"\", self.port.to_bytes(2, byteorder=\"big\")).pack()\n\n    @classmethod\n    def _unpack(\n        cls,\n        lhs: bytes,\n        rhs: bytes,\n    ) -> TCPFloor:\n        return TCPFloor(int.from_bytes(rhs, byteorder=\"big\"))", "@dataclasses.dataclass(frozen=True)\n@register_floor\nclass TCPFloor(_KnownFloor):\n    protocol: FloorProtocol = dataclasses.field(init=False, default=FloorProtocol.TCP)\n    port: int\n\n    def pack(self) -> bytes:\n        return Floor(self.protocol, b\"\", self.port.to_bytes(2, byteorder=\"big\")).pack()\n\n    @classmethod\n    def _unpack(\n        cls,\n        lhs: bytes,\n        rhs: bytes,\n    ) -> TCPFloor:\n        return TCPFloor(int.from_bytes(rhs, byteorder=\"big\"))", "\n\n@dataclasses.dataclass(frozen=True)\n@register_floor\nclass IPFloor(_KnownFloor):\n    protocol: FloorProtocol = dataclasses.field(init=False, default=FloorProtocol.IP)\n    addr: int\n\n    def pack(self) -> bytes:\n        return Floor(self.protocol, b\"\", self.addr.to_bytes(4, byteorder=\"big\")).pack()\n\n    @classmethod\n    def _unpack(\n        cls,\n        lhs: bytes,\n        rhs: bytes,\n    ) -> IPFloor:\n        return IPFloor(int.from_bytes(rhs, byteorder=\"big\"))", "\n\n@dataclasses.dataclass(frozen=True)\n@register_floor\nclass RPCConnectionOrientedFloor(_KnownFloor):\n    protocol: FloorProtocol = dataclasses.field(init=False, default=FloorProtocol.RPC_CONNECTION_ORIENTED)\n    version_minor: int\n\n    def pack(self) -> bytes:\n        return Floor(self.protocol, b\"\", self.version_minor.to_bytes(2, byteorder=\"little\")).pack()\n\n    @classmethod\n    def _unpack(\n        cls,\n        lhs: bytes,\n        rhs: bytes,\n    ) -> RPCConnectionOrientedFloor:\n        return RPCConnectionOrientedFloor(int.from_bytes(rhs, byteorder=\"little\"))", "\n\n@dataclasses.dataclass(frozen=True)\n@register_floor\nclass UUIDFloor(_KnownFloor):\n    protocol: FloorProtocol = dataclasses.field(init=False, default=FloorProtocol.UUID_ID)\n    uuid: uuid.UUID\n    version: int\n    version_minor: int\n\n    def pack(self) -> bytes:\n        return Floor(\n            protocol=self.protocol,\n            lhs=self.uuid.bytes_le + self.version.to_bytes(2, byteorder=\"little\"),\n            rhs=self.version_minor.to_bytes(2, byteorder=\"little\"),\n        ).pack()\n\n    @classmethod\n    def _unpack(\n        cls,\n        lhs: bytes,\n        rhs: bytes,\n    ) -> UUIDFloor:\n        object_uuid = uuid.UUID(bytes_le=lhs[:16])\n        version = int.from_bytes(lhs[16:18], byteorder=\"little\")\n        version_minor = int.from_bytes(rhs, byteorder=\"little\")\n\n        return UUIDFloor(object_uuid, version, version_minor)", "\n\ndef build_tcpip_tower(\n    service: SyntaxId,\n    data_rep: SyntaxId,\n    port: int,\n    addr: int,\n) -> t.List[Floor]:\n    return [\n        UUIDFloor(service.uuid, service.version, service.version_minor),\n        UUIDFloor(data_rep.uuid, data_rep.version, data_rep.version_minor),\n        RPCConnectionOrientedFloor(0),\n        TCPFloor(port),\n        IPFloor(addr),\n    ]", "\n\n@dataclasses.dataclass(frozen=True)\nclass EptMap:\n    opnum: int = dataclasses.field(init=False, repr=False, default=3)\n\n    obj: t.Optional[uuid.UUID]\n    tower: t.List[Floor]\n    entry_handle: t.Optional[tuple[int, uuid.UUID]]\n    max_towers: int\n\n    # MS-RPCE 2.2.1.2.5 ept_map Method\n    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/ab744583-430e-4055-8901-3c6bc007e791\n    # void ept_map(\n    #     [in] handle_t hEpMapper,\n    #     [in, ptr] UUID* obj,\n    #     [in, ptr] twr_p_t map_tower,\n    #     [in, out] ept_lookup_handle_t* entry_handle,\n    #     [in, range(0,500)] unsigned long max_towers,\n    #     [out] unsigned long* num_towers,\n    #     [out, ptr, size_is(max_towers), length_is(*num_towers)]\n    #         twr_p_t* ITowers,\n    #     [out] error_status* status\n    # );\n\n    def pack(self) -> bytes:\n        b_tower = b\"\".join(\n            [\n                len(self.tower).to_bytes(2, byteorder=\"little\"),\n                b\"\".join(f.pack() for f in self.tower),\n            ]\n        )\n        tower_padding = -(len(b_tower) + 4) % 8\n\n        if self.entry_handle:\n            b_entry_handle = self.entry_handle[0].to_bytes(4, byteorder=\"little\") + self.entry_handle[1].bytes_le\n        else:\n            b_entry_handle = b\"\\x00\" * 20\n\n        return b\"\".join(\n            [\n                # obj with a referent id of 1\n                b\"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n                self.obj.bytes_le if self.obj else b\"\\x00\" * 16,\n                # Tower referent id 2\n                b\"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n                len(b_tower).to_bytes(8, byteorder=\"little\"),\n                len(b_tower).to_bytes(4, byteorder=\"little\"),\n                b_tower,\n                b\"\\x00\" * tower_padding,\n                b_entry_handle,\n                self.max_towers.to_bytes(4, byteorder=\"little\"),\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> EptMap:\n        view = memoryview(data)\n\n        b_obj = view[8:24].tobytes()\n        if b_obj == b\"\\x00\" * 16:\n            obj = None\n        else:\n            obj = uuid.UUID(bytes_le=b_obj)\n\n        view = view[32:]\n\n        tower_length = int.from_bytes(view[:8], byteorder=\"little\")\n        padding = -(tower_length + 4) % 8\n\n        floor_len = int.from_bytes(view[12:14], byteorder=\"little\")\n        view = view[14:]\n\n        tower = []\n        for _ in range(floor_len):\n            floor = Floor.unpack(view)\n            view = view[len(floor.lhs) + len(floor.rhs) + 5 :]\n            tower.append(floor)\n\n        view = view[padding:]\n\n        b_entry_handle = view[:20].tobytes()\n        if b_entry_handle == b\"\\x00\" * 20:\n            entry_handle = None\n        else:\n            entry_handle = (\n                int.from_bytes(view[:4], byteorder=\"little\"),\n                uuid.UUID(bytes_le=view[4:20].tobytes()),\n            )\n\n        max_towers = int.from_bytes(view[20:24], byteorder=\"little\")\n\n        return cls(\n            obj=obj,\n            tower=tower,\n            entry_handle=entry_handle,\n            max_towers=max_towers,\n        )", "\n\n@dataclasses.dataclass(frozen=True)\nclass EptMapResult:\n    entry_handle: t.Optional[tuple[int, uuid.UUID]]\n    towers: t.List[t.List[Floor]]\n    status: int\n\n    def pack(self) -> bytes:\n        if self.entry_handle:\n            b_entry_handle = self.entry_handle[0].to_bytes(4, byteorder=\"little\") + self.entry_handle[1].bytes_le\n        else:\n            b_entry_handle = b\"\\x00\" * 20\n\n        b_tower_referents = bytearray()\n        b_tower = bytearray()\n        for idx, t in enumerate(self.towers):\n            b_tower_referents += (idx + 3).to_bytes(8, byteorder=\"little\")\n\n            b_t = b\"\".join(\n                [\n                    len(t).to_bytes(2, byteorder=\"little\"),\n                    b\"\".join(f.pack() for f in t),\n                ]\n            )\n            padding = -(len(b_t)) % 4\n            b_tower += b\"\".join(\n                [\n                    len(b_t).to_bytes(8, byteorder=\"little\"),\n                    len(b_t).to_bytes(4, byteorder=\"little\"),\n                    b_t,\n                    b\"\\x00\" * padding,\n                ]\n            )\n\n        return b\"\".join(\n            [\n                b_entry_handle,\n                len(self.towers).to_bytes(4, byteorder=\"little\"),\n                len(self.towers).to_bytes(8, byteorder=\"little\"),\n                b\"\\x00\" * 8,  # Tower pointer offset\n                len(self.towers).to_bytes(8, byteorder=\"little\"),\n                b_tower_referents,\n                b_tower,\n                self.status.to_bytes(4, byteorder=\"little\"),\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> EptMapResult:\n        view = memoryview(data)\n\n        status = int.from_bytes(view[-4:], byteorder=\"little\")\n        b_entry_handle = view[:20].tobytes()\n        if b_entry_handle == b\"\\x00\" * 20:\n            entry_handle = None\n        else:\n            entry_handle = (\n                int.from_bytes(view[:4], byteorder=\"little\"),\n                uuid.UUID(bytes_le=view[4:20].tobytes()),\n            )\n\n        # num_towers = int.from_bytes(view[20:24], byteorder=\"little\")\n        # max_tower_count = int.from_bytes(view[24:32], byteorder=\"little\")\n        # tower_offset = int.from_bytes(view[32:40], byteorder=\"little\")\n        tower_count = int.from_bytes(view[40:48], byteorder=\"little\")\n        tower_data_offset = 8 * tower_count  # Ignore referent ids\n        view = view[48 + tower_data_offset :]\n\n        towers: t.List[t.List[Floor]] = []\n        for _ in range(tower_count):\n            tower_length = int.from_bytes(view[:8], byteorder=\"little\")\n            padding = -(tower_length + 4) % 8\n\n            floor_len = int.from_bytes(view[12:14], byteorder=\"little\")\n            view = view[14:]\n\n            tower = []\n            for _ in range(floor_len):\n                floor = Floor.unpack(view)\n                view = view[len(floor.lhs) + len(floor.rhs) + 5 :]\n                tower.append(floor)\n\n            towers.append(tower)\n            view = view[padding:]\n\n        return cls(\n            entry_handle=entry_handle,\n            towers=towers,\n            status=status,\n        )", ""]}
{"filename": "src/dpapi_ng/_version.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\n__version__ = \"0.2.0\"\n"]}
{"filename": "src/dpapi_ng/__init__.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nfrom ._client import (\n    KeyCache,\n    async_ncrypt_protect_secret,\n    async_ncrypt_unprotect_secret,\n    ncrypt_protect_secret,", "    async_ncrypt_unprotect_secret,\n    ncrypt_protect_secret,\n    ncrypt_unprotect_secret,\n)\n\n__all__ = [\n    \"KeyCache\",\n    \"async_ncrypt_protect_secret\",\n    \"async_ncrypt_unprotect_secret\",\n    \"ncrypt_protect_secret\",", "    \"async_ncrypt_unprotect_secret\",\n    \"ncrypt_protect_secret\",\n    \"ncrypt_unprotect_secret\",\n]\n"]}
{"filename": "src/dpapi_ng/_asn1.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport enum\nimport struct\nimport typing as t\nfrom types import TracebackType\n", "from types import TracebackType\n\nT = t.TypeVar(\"T\", bound=int)\n\n\nclass NotEnougData(Exception):\n    \"There is not enough data available to unpack ASN.1 value\"\n\n\nclass TagClass(enum.IntEnum):\n    \"\"\"The ASN.1 tag class types.\"\"\"\n\n    UNIVERSAL = 0\n    APPLICATION = 1\n    CONTEXT_SPECIFIC = 2\n    PRIVATE = 3", "\nclass TagClass(enum.IntEnum):\n    \"\"\"The ASN.1 tag class types.\"\"\"\n\n    UNIVERSAL = 0\n    APPLICATION = 1\n    CONTEXT_SPECIFIC = 2\n    PRIVATE = 3\n\n\nclass TypeTagNumber(enum.IntEnum):\n    \"\"\"The ASN.1 tag numbers for universal classes.\"\"\"\n\n    END_OF_CONTENT = 0\n    BOOLEAN = 1\n    INTEGER = 2\n    BIT_STRING = 3\n    OCTET_STRING = 4\n    NULL = 5\n    OBJECT_IDENTIFIER = 6\n    OBJECT_DESCRIPTOR = 7\n    EXTERNAL = 8\n    REAL = 9\n    ENUMERATED = 10\n    EMBEDDED_PDV = 11\n    UTF8_STRING = 12\n    RELATIVE_OID = 13\n    TIME = 14\n    RESERVED = 15\n    SEQUENCE = 16\n    SEQUENCE_OF = 16\n    SET = 17\n    SET_OF = 17\n    NUMERIC_STRING = 18\n    PRINTABLE_STRING = 19\n    T61_STRING = 20\n    VIDEOTEX_STRING = 21\n    IA5_STRING = 22\n    UTC_TIME = 23\n    GENERALIZED_TIME = 24\n    GRAPHIC_STRING = 25\n    VISIBLE_STRING = 26\n    GENERAL_STRING = 27\n    UNIVERSAL_STRING = 28\n    CHARACTER_STRING = 29\n    BMP_STRING = 30\n    DATE = 31\n    TIME_OF_DAY = 32\n    DATE_TIME = 33\n    DURATION = 34\n    OID_IRL = 35\n    RELATIVE_OID_IRL = 36", "\n\nclass TypeTagNumber(enum.IntEnum):\n    \"\"\"The ASN.1 tag numbers for universal classes.\"\"\"\n\n    END_OF_CONTENT = 0\n    BOOLEAN = 1\n    INTEGER = 2\n    BIT_STRING = 3\n    OCTET_STRING = 4\n    NULL = 5\n    OBJECT_IDENTIFIER = 6\n    OBJECT_DESCRIPTOR = 7\n    EXTERNAL = 8\n    REAL = 9\n    ENUMERATED = 10\n    EMBEDDED_PDV = 11\n    UTF8_STRING = 12\n    RELATIVE_OID = 13\n    TIME = 14\n    RESERVED = 15\n    SEQUENCE = 16\n    SEQUENCE_OF = 16\n    SET = 17\n    SET_OF = 17\n    NUMERIC_STRING = 18\n    PRINTABLE_STRING = 19\n    T61_STRING = 20\n    VIDEOTEX_STRING = 21\n    IA5_STRING = 22\n    UTC_TIME = 23\n    GENERALIZED_TIME = 24\n    GRAPHIC_STRING = 25\n    VISIBLE_STRING = 26\n    GENERAL_STRING = 27\n    UNIVERSAL_STRING = 28\n    CHARACTER_STRING = 29\n    BMP_STRING = 30\n    DATE = 31\n    TIME_OF_DAY = 32\n    DATE_TIME = 33\n    DURATION = 34\n    OID_IRL = 35\n    RELATIVE_OID_IRL = 36", "\n\nclass ASN1Tag(t.NamedTuple):\n    \"\"\"ASN.1 tag information.\n\n    Defines the explicit ASN.1 tag used in a value which includes the tag class,\n    tag number, and whether it is a constructed or primitive value.\n\n    Args:\n        tag_class: The tag class the value represents.\n        tag_number: The tag number of the value.\n        is_constructed: Whether the value is constructed (True) or primitive\n            (False).\n    \"\"\"\n\n    tag_class: TagClass\n    \"The tag class.\"\n\n    tag_number: t.Union[int, TypeTagNumber]\n    \"The tag number, will be TypeTagNumber if the tag_class is UNIVERSAL.\"\n\n    is_constructed: bool\n    \"Whether the value is marked as constructed or primitive.\"\n\n    @classmethod\n    def universal_tag(\n        cls,\n        number: TypeTagNumber,\n        is_constructed: bool = False,\n    ) -> ASN1Tag:\n        \"\"\"Generates a universal tag with the type specified.\"\"\"\n        return ASN1Tag(\n            tag_class=TagClass.UNIVERSAL,\n            tag_number=number,\n            is_constructed=is_constructed,\n        )", "\n\nclass ASN1Header(t.NamedTuple):\n    \"\"\"A representation of an ASN.1 TLV as a tuple.\n\n    Defines the ASN.1 Type Length Value (TLV) values as separate objects for\n    easier parsing. This is returned by :func:`ASN1Reader.peek_header`.\n\n    Args:\n        tag: The tag details, including the class and tag number.\n        tag_length: The length of the encoded tag.\n        length: The length of the value the tag represents.\n    \"\"\"\n\n    tag: ASN1Tag\n    \"The ASN.1 tag details for the current entry.\"\n\n    tag_length: int\n    \"The length of the tag/length ASN.1 octets.\"\n\n    length: int\n    \"The length of the ASN.1 value.\"", "\n\nclass ASN1Reader:\n    \"\"\"ASN.1 value reader.\n\n    Class used to read ASN.1 data that is passed in. It provides a an easy way\n    to stream through the data as well as peek as the subsequent entries.\n\n    Args:\n        data: The data to read from.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> None:\n        self._data = data\n        self._view = memoryview(self._data)\n\n    def __bool__(self) -> bool:\n        return bool(self._view)\n\n    def peek_header(self) -> ASN1Header:\n        \"\"\"Get the next value header.\n\n        Gets the header for the next value. This will not read the value so it\n        will still be at the same position once run.\n\n        Returns:\n            ASN1Header: The header information including the tag information as\n            well as the length of the next value.\n        \"\"\"\n        return _read_asn1_header(self._view)\n\n    def skip_value(\n        self,\n        header: ASN1Header,\n    ) -> None:\n        \"\"\"Skips the next value.\n\n        Skips the next value as indicated by the header.\n\n        Args:\n            header: The header which contains the metadata of the next value to\n                skip.\n        \"\"\"\n        self._view = self._view[header.tag_length + header.length :]\n\n    def get_remaining_data(self) -> bytes:\n        \"\"\"Gets the remaining data in the reader.\"\"\"\n        data = self._view.tobytes()\n        self._view = memoryview(b\"\")\n        return data\n\n    def read_boolean(\n        self,\n        tag: t.Optional[ASN1Tag] = None,\n        header: t.Optional[ASN1Header] = None,\n        hint: t.Optional[str] = None,\n    ) -> bool:\n        \"\"\"Reads an ASN.1 BOOLEAN value.\n\n        Args:\n            tag: The tag to validate with, defaults to the BOOLEAN universal\n                tag.\n            header: Optional header from :func:`peek_header` to make the\n                extraction more efficient.\n            hint: A hint used in error messages to display what this step was\n                used for.\n\n        Returns:\n            bool: The bool value.\n        \"\"\"\n        val, consumed = _read_asn1_boolean(\n            self._view,\n            tag=tag,\n            header=header,\n            hint=hint,\n        )\n        self._view = self._view[consumed:]\n\n        return val\n\n    def read_enumerated(\n        self,\n        enum_type: t.Type[T],\n        tag: t.Optional[ASN1Tag] = None,\n        header: t.Optional[ASN1Header] = None,\n        hint: t.Optional[str] = None,\n    ) -> T:\n        \"\"\"Reads an ASN.1 ENUMERATED value.\n\n        Args:\n            enum_type: The enum.IntEnum type to cast the integer value to.\n            tag: The tag to validate with, defaults to the ENUMERATED universal\n                tag.\n            header: Optional header from :func:`peek_header` to make the\n                extraction more efficient.\n            hint: A hint used in error messages to display what this step was\n                used for.\n\n        Returns:\n            T: The instance of enum_type that the value represents.\n        \"\"\"\n        val, consumed = _read_asn1_enumerated(\n            self._view,\n            tag=tag,\n            header=header,\n            hint=hint,\n        )\n        self._view = self._view[consumed:]\n\n        return enum_type(val)\n\n    def read_generalized_time(\n        self,\n        tag: t.Optional[ASN1Tag] = None,\n        header: t.Optional[ASN1Header] = None,\n        hint: t.Optional[str] = None,\n    ) -> str:\n        val, consumed = _read_asn1_generalized_time(\n            self._view,\n            tag=tag,\n            header=header,\n            hint=hint,\n        )\n        self._view = self._view[consumed:]\n\n        return val\n\n    def read_integer(\n        self,\n        tag: t.Optional[ASN1Tag] = None,\n        header: t.Optional[ASN1Header] = None,\n        hint: t.Optional[str] = None,\n    ) -> int:\n        \"\"\"Reads an ASN.1 INTEGER value.\n\n        Args:\n            tag: The tag to validate with, defaults to the INTEGER universal\n                tag.\n            header: Optional header from :func:`peek_header` to make the\n                extraction more efficient.\n            hint: A hint used in error messages to display what this step was\n                used for.\n\n        Returns:\n            int: The int value.\n        \"\"\"\n        val, consumed = _read_asn1_integer(\n            self._view,\n            tag=tag,\n            header=header,\n            hint=hint,\n        )\n        self._view = self._view[consumed:]\n\n        return val\n\n    def read_object_identifier(\n        self,\n        tag: t.Optional[ASN1Tag] = None,\n        header: t.Optional[ASN1Header] = None,\n        hint: t.Optional[str] = None,\n    ) -> str:\n        val, consumed = _read_asn1_object_identifier(\n            self._view,\n            tag=tag,\n            header=header,\n            hint=hint,\n        )\n        self._view = self._view[consumed:]\n\n        return val\n\n    def read_octet_string(\n        self,\n        tag: t.Optional[ASN1Tag] = None,\n        header: t.Optional[ASN1Header] = None,\n        hint: t.Optional[str] = None,\n    ) -> bytes:\n        \"\"\"Reads an ASN.1 OCTET_STRING value.\n\n        As this returns a bytes string, it is useful to extract the raw ASN.1\n        value as long as the correct tag or header is provided.\n\n        Args:\n            tag: The tag to validate with, defaults to the OCTET_STRING\n                universal tag (primitive).\n            header: Optional header from :func:`peek_header` to make the\n                extraction more efficient.\n            hint: A hint used in error messages to display what this step was\n                used for.\n\n        Returns:\n            bytes: The octet string bytes.\n        \"\"\"\n        val, consumed = _read_asn1_octet_string(\n            self._view,\n            tag=tag,\n            header=header,\n            hint=hint,\n        )\n        self._view = self._view[consumed:]\n\n        return val.tobytes()\n\n    def read_set(\n        self,\n        tag: t.Optional[ASN1Tag] = None,\n        header: t.Optional[ASN1Header] = None,\n        hint: t.Optional[str] = None,\n    ) -> ASN1Reader:\n        \"\"\"Reads an ASN.1 SET or SET_OF value.\n\n        The returned reader can be used to then read the values inside the set.\n\n        Args:\n            tag: The tag to validate with, defaults to the SET/SET_OF universal\n                tag.\n            header: Optional header from :func:`peek_header` to make the\n                extraction more efficient.\n            hint: A hint used in error messages to display what this step was\n                used for.\n\n        Returns:\n            ASN1Reader: The ASN.1 reader object that can be used to read the\n                set elements.\n        \"\"\"\n        new_view, consumed = _read_asn1_set(\n            self._view,\n            tag=tag,\n            header=header,\n            hint=hint,\n        )\n        self._view = self._view[consumed:]\n\n        return ASN1Reader(new_view)\n\n    read_set_of = read_set\n\n    def read_sequence(\n        self,\n        tag: t.Optional[ASN1Tag] = None,\n        header: t.Optional[ASN1Header] = None,\n        hint: t.Optional[str] = None,\n    ) -> ASN1Reader:\n        \"\"\"Reads an ASN.1 SEQUENCE or SEQUENCE_OF value.\n\n        The returned reader can be used to then read the values inside the\n        sequence.\n\n        Args:\n            tag: The tag to validate with, defaults to the SEQUENCE/SEQUENCE_OF\n                universal tag.\n            header: Optional header from :func:`peek_header` to make the\n                extraction more efficient.\n            hint: A hint used in error messages to display what this step was\n                used for.\n\n        Returns:\n            ASN1Reader: The ASN.1 reader object that can be used to read the\n                sequence elements.\n        \"\"\"\n        new_view, consumed = _read_asn1_sequence(\n            self._view,\n            tag=tag,\n            header=header,\n            hint=hint,\n        )\n        self._view = self._view[consumed:]\n\n        return ASN1Reader(new_view)\n\n    read_sequence_of = read_sequence\n\n    def read_utf8_string(\n        self,\n        tag: t.Optional[ASN1Tag] = None,\n        header: t.Optional[ASN1Header] = None,\n        hint: t.Optional[str] = None,\n    ) -> str:\n        val, consumed = _read_asn1_utf8_string(\n            self._view,\n            tag=tag,\n            header=header,\n            hint=hint,\n        )\n        self._view = self._view[consumed:]\n\n        return val", "\n\nclass ASN1Writer:\n    \"\"\"ASN.1 value writer.\n\n    Class used to write ASN.1 data into an internal buffer. This data can then\n    be retrieved using :func:`get_data`. It provides a nice helper to easily\n    accumulate multiple values in one object.\n\n    Args:\n        tag: Optional tag to used when in a sequence/set writer.\n        parent: The parent writer used when in a sequence/set writer.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        tag: t.Optional[ASN1Tag] = None,\n        parent: t.Optional[ASN1Writer] = None,\n    ) -> None:\n        self._data = bytearray()\n        self._tag = tag\n        self._parent = parent\n\n    def __enter__(self) -> ASN1Writer:\n        return self\n\n    def __exit__(\n        self,\n        exc_type: t.Optional[t.Type[BaseException]] = None,\n        exc_val: t.Optional[BaseException] = None,\n        exc_tb: t.Optional[TracebackType] = None,\n    ) -> None:\n        if not self._parent or not self._tag:\n            return\n\n        data = _pack_asn1(\n            self._tag.tag_class,\n            self._tag.is_constructed,\n            self._tag.tag_number,\n            self._data,\n        )\n        self._parent._data.extend(data)\n\n    def push_sequence(\n        self,\n        tag: t.Optional[ASN1Tag] = None,\n    ) -> ASN1Writer:\n        \"\"\"Get new writer for a SEQUENCE or SEQUENCE_OF value.\n\n        Gets a new writer to start writing values inside a sequence or sequence\n        of object. Make sure to wrap the writer in a with statement to ensure\n        the sequence is closed and written back to the parent writer.\n\n        Examples:\n            .. code-block:: python\n\n                with writer.push_sequence() as seq_writer:\n                    seq_writer.write_octet_string(b\"foo\")\n\n        Args:\n            tag: Optional tag to mark the sequence/sequence_of with.\n\n        Returns:\n            ASN1Writer: The writer object that can be used to write the\n            sequence elements.\n        \"\"\"\n        if not tag:\n            tag = ASN1Tag.universal_tag(TypeTagNumber.SEQUENCE, is_constructed=True)\n        return ASN1Writer(tag=tag, parent=self)\n\n    push_sequence_of = push_sequence\n\n    def push_set(\n        self,\n        tag: t.Optional[ASN1Tag] = None,\n    ) -> ASN1Writer:\n        \"\"\"Get new writer for a SET or SET_OF value.\n\n        Gets a new writer to start writing values inside a set or set of\n        object. Make sure to wrap the writer in a with statement to ensure\n        the sequence is closed and written back to the parent writer.\n\n        Examples:\n            .. code-block:: python\n\n                with writer.push_set() as seq_writer:\n                    seq_writer.write_octet_string(b\"foo\")\n\n        Args:\n            tag: Optional tag to mark the sequence/sequence_of with.\n\n        Returns:\n            ASN1Writer: The writer object that can be used to write the\n            set elements.\n        \"\"\"\n        if not tag:\n            tag = ASN1Tag.universal_tag(TypeTagNumber.SET, is_constructed=True)\n        return ASN1Writer(tag=tag, parent=self)\n\n    push_set_of = push_set\n\n    def write_boolean(\n        self,\n        value: bool,\n        tag: t.Optional[ASN1Tag] = None,\n    ) -> None:\n        \"\"\"Write an ASN.1 BOOLEAN value.\n\n        Writes a boolean value to the current writer.\n\n        Args:\n            value: The bool to write.\n            tag: Optional tag to use with the value, defaults to the BOOLEAN\n                universal tag.\n        \"\"\"\n        self._data.extend(_pack_asn1_boolean(value, tag=tag))\n\n    def write_enumerated(\n        self,\n        value: int,\n        tag: t.Optional[ASN1Tag] = None,\n    ) -> None:\n        \"\"\"Write an ASN.1 ENUMERATED value.\n\n        Writes a enumerated value to the current writer.\n\n        Args:\n            value: The enumerated/int to write.\n            tag: Optional tag to use with the value, defaults to the ENUMERATED\n                universal tag.\n        \"\"\"\n        self._data.extend(_pack_asn1_enumerated(value, tag=tag))\n\n    def write_generalized_time(\n        self,\n        value: str,\n        tag: t.Optional[ASN1Tag] = None,\n    ) -> None:\n        \"\"\"Write an ASN.1 GENERALIZED_TIME value.\n\n        Writes a generalized time string to the current writer.\n\n        Args:\n            value: The generalized time to write.\n            tag: Optional tag to use with the value, defaults to the\n                GENERALIZED_TIME universal tag.\n        \"\"\"\n        self._data.extend(_pack_asn1_generalized_time(value, tag=tag))\n\n    def write_integer(\n        self,\n        value: int,\n        tag: t.Optional[ASN1Tag] = None,\n    ) -> None:\n        \"\"\"Write an ASN.1 INTEGER value.\n\n        Writes an int value to the current writer.\n\n        Args:\n            value: The int to write.\n            tag: Optional tag to use with the value, defaults to the INTEGER\n                universal tag.\n        \"\"\"\n        self._data.extend(_pack_asn1_integer(value, tag=tag))\n\n    def write_octet_string(\n        self,\n        value: bytes,\n        tag: t.Optional[ASN1Tag] = None,\n    ) -> None:\n        \"\"\"Write an ASN.1 OCTET_STRING value.\n\n        Writes a bytes string value to the current writer.\n\n        Args:\n            value: The bytes to write.\n            tag: Optional tag to use with the value, defaults to the\n                OCTET_STRING universal tag.\n        \"\"\"\n        self._data.extend(_pack_asn1_octet_string(value, tag=tag))\n\n    def write_object_identifier(\n        self,\n        value: str,\n        tag: t.Optional[ASN1Tag] = None,\n    ) -> None:\n        \"\"\"Write an ASN.1 OBJECT_IDENTIFIER value.\n\n        Writes a bytes string value to the current writer.\n\n        Args:\n            value: The object identifier (string representation) to write.\n            tag: Optional tag to use with the value, defaults to the\n                OBJECT_IDENTIFIER universal tag.\n        \"\"\"\n        self._data.extend(_pack_asn1_object_identifier(value, tag=tag))\n\n    def write_utf8_string(\n        self,\n        value: str,\n        tag: t.Optional[ASN1Tag] = None,\n    ) -> None:\n        \"\"\"Write an ASN.1 UTF8_STRING value.\n\n        Writes a UTF-8 string value to the current writer.\n\n        Args:\n            value: The string to write.\n            tag: Optional tag to use with the value, defaults to the\n                UTF8_STRING universal tag.\n        \"\"\"\n        self._data.extend(_pack_asn1_utf8_string(value, tag=tag))\n\n    def write_raw(\n        self,\n        value: bytes,\n    ) -> None:\n        \"\"\"Appends raw values onto the ASN1 writer.\"\"\"\n        self._data.extend(value)\n\n    def get_data(self) -> bytearray:\n        \"\"\"Gets the data written to the writer.\n\n        This is used to get the final ASN.1 value after all the values have\n        been written to it. It cannot be called on a child writer returned by\n        push_sequence or push_set.\n\n        Returns:\n            bytearray: The data that has been written.\n        \"\"\"\n        if self._parent or self._tag:\n            raise TypeError(\"Cannot get_data() on child ASN1 writer\")\n\n        return self._data", "\n\ndef _pack_asn1(\n    tag_class: TagClass,\n    constructed: bool,\n    tag_number: t.Union[TypeTagNumber, int],\n    data: t.Union[bytes, bytearray, memoryview],\n) -> bytes:\n    \"\"\"Pack the ASN.1 value into the ASN.1 bytes.\n\n    Will pack the raw bytes into an ASN.1 Type Length Value (TLV) value. A TLV\n    is in the form:\n\n    | Identifier Octet(s) | Length Octet(s) | Data Octet(s) |\n\n    Args:\n        tag_class: The tag class of the data.\n        constructed: Whether the data is constructed (True), i.e. contains 0,\n            1, or more element encodings, or is primitive (False).\n        tag_number: The type tag number if tag_class is universal else the\n            explicit tag number of the TLV.\n        b_data: The encoded value to pack into the ASN.1 TLV.\n\n    Returns:\n        bytes: The ASN.1 value as raw bytes.\n    \"\"\"\n    b_asn1_data = bytearray()\n\n    # ASN.1 Identifier octet is\n    #\n    # |             Octet 1             |  |              Octet 2              |\n    # | 8 | 7 |  6  | 5 | 4 | 3 | 2 | 1 |  |   8   | 7 | 6 | 5 | 4 | 3 | 2 | 1 |\n    # | Class | P/C | Tag Number (0-30) |  | More  | Tag number                |\n    #\n    # If Tag Number is >= 31 the first 5 bits are 1 and the 2nd octet is used\n    # to encode the length.\n    if tag_class < 0 or tag_class > 3:\n        raise ValueError(\"tag_class must be between 0 and 3\")\n\n    identifier_octets = tag_class << 6\n    identifier_octets |= (1 if constructed else 0) << 5\n\n    if tag_number < 31:\n        identifier_octets |= tag_number\n        b_asn1_data.append(identifier_octets)\n    else:\n        # Set the first 5 bits of the first octet to 1 and encode the tag\n        # number in subsequent octets.\n        identifier_octets |= 31\n        b_asn1_data.append(identifier_octets)\n        b_asn1_data.extend(_pack_asn1_octet_number(tag_number))\n\n    # ASN.1 Length octet for DER encoding is always in the definite form. This\n    # form packs the lengths in the following octet structure:\n    #\n    # |                       Octet 1                       |  |            Octet n            |\n    # |     8     |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |\n    # | Long form | Short = length, Long = num octets       |  | Big endian length for long    |\n    #\n    # Basically if the length < 127 it's encoded in the first octet, otherwise\n    # the first octet 7 bits indicates how many subsequent octets were used to\n    # encode the length.\n    length = len(data)\n    if length < 128:\n        b_asn1_data.append(length)\n    else:\n        length_octets = bytearray()\n        while length:\n            length_octets.append(length & 0b11111111)\n            length >>= 8\n\n        # Reverse the octets so the higher octets are first, add the initial\n        # length octet with the MSB set and add them all to the main ASN.1 byte\n        # array.\n        length_octets.reverse()\n        b_asn1_data.append(len(length_octets) | 0b10000000)\n        b_asn1_data.extend(length_octets)\n\n    return bytes(b_asn1_data) + bytes(data)", "\n\ndef _pack_asn1_boolean(\n    value: bool,\n    tag: t.Optional[ASN1Tag] = None,\n) -> bytes:\n    \"\"\"Packs an int into an ASN.1 BOOLEAN byte value with optional universal tagging.\"\"\"\n    if not tag:\n        tag = ASN1Tag.universal_tag(TypeTagNumber.BOOLEAN)\n\n    return _pack_asn1(tag.tag_class, tag.is_constructed, tag.tag_number, b\"\\xFF\" if value else b\"\\x00\")", "\n\ndef _pack_asn1_enumerated(\n    value: int,\n    tag: t.Optional[ASN1Tag] = None,\n) -> bytes:\n    \"\"\"Packs an int into an ASN.1 ENUMERATED byte value with optional universal tagging.\"\"\"\n    return _pack_asn1_integer(value, tag=tag or ASN1Tag.universal_tag(TypeTagNumber.ENUMERATED))\n\n\ndef _pack_asn1_generalized_time(\n    value: str,\n    tag: t.Optional[ASN1Tag] = None,\n) -> bytes:\n    \"\"\"Packs an int into an ASN.1 GENERALIZED_TIME byte value with optional universal tagging.\"\"\"\n    if not tag:\n        tag = ASN1Tag.universal_tag(TypeTagNumber.GENERALIZED_TIME)\n\n    return _pack_asn1(tag.tag_class, tag.is_constructed, tag.tag_number, value.encode(\"utf-8\"))", "\n\ndef _pack_asn1_generalized_time(\n    value: str,\n    tag: t.Optional[ASN1Tag] = None,\n) -> bytes:\n    \"\"\"Packs an int into an ASN.1 GENERALIZED_TIME byte value with optional universal tagging.\"\"\"\n    if not tag:\n        tag = ASN1Tag.universal_tag(TypeTagNumber.GENERALIZED_TIME)\n\n    return _pack_asn1(tag.tag_class, tag.is_constructed, tag.tag_number, value.encode(\"utf-8\"))", "\n\ndef _pack_asn1_integer(\n    value: int,\n    tag: t.Optional[ASN1Tag] = None,\n) -> bytes:\n    \"\"\"Packs an int value into an ASN.1 INTEGER byte value with optional universal tagging.\"\"\"\n    if not tag:\n        tag = ASN1Tag.universal_tag(TypeTagNumber.INTEGER)\n\n    # Thanks to https://github.com/andrivet/python-asn1 for help with the negative value logic.\n    is_negative = False\n    limit = 0x7F\n    if value < 0:\n        value = -value\n        is_negative = True\n        limit = 0x80\n\n    b_int = bytearray()\n    while value > limit:\n        val = value & 0xFF\n\n        if is_negative:\n            val = 0xFF - val\n\n        b_int.append(val)\n        value >>= 8\n\n    b_int.append(((0xFF - value) if is_negative else value) & 0xFF)\n\n    if is_negative:\n        # The nocover is here because it's reporting no coverage for the no\n        # enumerate branch. We don't care about that.\n        for idx, val in enumerate(b_int):  # pragma: nocover\n            if val < 0xFF:\n                b_int[idx] += 1\n                break\n\n            b_int[idx] = 0\n\n    if is_negative and b_int[-1] == 0x7F:  # Two's complement corner case\n        b_int.append(0xFF)\n\n    b_int.reverse()\n\n    return _pack_asn1(tag.tag_class, tag.is_constructed, tag.tag_number, b_int)", "\n\ndef _pack_asn1_octet_string(\n    b_data: t.Union[bytes, bytearray, memoryview],\n    tag: t.Optional[ASN1Tag] = None,\n) -> bytes:\n    \"\"\"Packs an bytes value into an ASN.1 OCTET STRING byte value with optional universal tagging.\"\"\"\n    if not tag:\n        tag = ASN1Tag.universal_tag(TypeTagNumber.OCTET_STRING)\n\n    return _pack_asn1(tag.tag_class, tag.is_constructed, tag.tag_number, b_data)", "\n\ndef _pack_asn1_object_identifier(\n    value: str,\n    tag: t.Optional[ASN1Tag] = None,\n) -> bytes:\n    \"\"\"Packs an object identifier value represented as string into an\n    ASN.1 OBJECT IDENTIFIER value with optional universal tagging.\"\"\"\n    if not tag:\n        tag = ASN1Tag.universal_tag(TypeTagNumber.OBJECT_IDENTIFIER)\n\n    return _pack_asn1(tag.tag_class, tag.is_constructed, tag.tag_number, _encode_object_identifier(value))", "\n\ndef _pack_asn1_utf8_string(\n    value: str,\n    tag: t.Optional[ASN1Tag] = None,\n) -> bytes:\n    \"\"\"Packs an object identifier value represented as string into an\n    ASN.1 UTF8 STRING byte value with optional universal tagging.\"\"\"\n    if not tag:\n        tag = ASN1Tag.universal_tag(TypeTagNumber.UTF8_STRING)\n\n    return _pack_asn1(tag.tag_class, tag.is_constructed, tag.tag_number, value.encode(\"utf-8\"))", "\n\ndef _encode_object_identifier(oid: str) -> bytes:\n    \"\"\"Encode an object identifier.\"\"\"\n    cmps = list(map(int, oid.split(\".\")))\n    if cmps[0] > 39 or cmps[1] > 39:\n        raise ValueError(\"Illegal object identifier\")\n    cmps = [40 * cmps[0] + cmps[1]] + cmps[2:]\n    cmps.reverse()\n    result = []\n    for cmp_data in cmps:\n        result.append(cmp_data & 0x7F)\n        while cmp_data > 0x7F:\n            cmp_data >>= 7\n            result.append(0x80 | (cmp_data & 0x7F))\n    result.reverse()\n    return bytes(result)", "\n\ndef _read_asn1_header(\n    data: t.Union[bytes, bytearray, memoryview],\n) -> ASN1Header:\n    \"\"\"Reads the ASN.1 Tag and Length octets\n\n    Reads the raw ASN.1 value to retrieve the tag and length values.\n\n    Args:\n      data: The raw bytes to read.\n\n    Returns:\n        ASN1Value: A tuple containing the tag and length information.\n    \"\"\"\n    view = memoryview(data)\n\n    if not view:\n        raise NotEnougData()\n\n    octet1 = struct.unpack(\"B\", view[:1])[0]\n    tag_class = TagClass((octet1 & 0b11000000) >> 6)\n    constructed = bool(octet1 & 0b00100000)\n    tag_number = octet1 & 0b00011111\n\n    tag_octets = 1\n    if tag_number == 31:\n        tag_number, octet_count = _unpack_asn1_octet_number(view[1:])\n        tag_octets += octet_count\n\n    if tag_class == TagClass.UNIVERSAL:\n        tag_number = TypeTagNumber(tag_number)\n\n    view = view[tag_octets:]\n\n    if not view:\n        raise NotEnougData()\n\n    length = struct.unpack(\"B\", view[:1])[0]\n    length_octets = 1\n\n    if length == 0b10000000:\n        # Indefinite length, the length is not known and will be marked by two\n        # NULL octets known as end-of-content octets later in the stream. It is\n        # not meant to be sent in LDAP so fail here.\n        # https://www.rfc-editor.org/rfc/rfc4511#section-5.1\n        raise ValueError(\"Received BER indefinite encoded value which is unsupported by LDAP messages\")\n\n    elif length & 0b10000000:\n        # If the MSB is set then the length octet just contains the number of\n        # octets that encodes the actual length.\n        length_octets += length & 0b01111111\n        length = 0\n\n        for idx in range(1, length_octets):\n            if len(view) < (idx + 1):\n                raise NotEnougData()\n\n            octet_val = struct.unpack(\"B\", view[idx : idx + 1])[0]\n            length += octet_val << (8 * (length_octets - 1 - idx))\n\n    return ASN1Header(\n        tag=ASN1Tag(\n            tag_class=tag_class,\n            tag_number=tag_number,\n            is_constructed=constructed,\n        ),\n        tag_length=tag_octets + length_octets,\n        length=length,\n    )", "\n\ndef _read_asn1_boolean(\n    data: t.Union[bytes, bytearray, memoryview],\n    tag: t.Optional[ASN1Tag] = None,\n    header: t.Optional[ASN1Header] = None,\n    hint: t.Optional[str] = None,\n) -> t.Tuple[bool, int]:\n    \"\"\"Unpacks an ASN.1 BOOLEAN value.\"\"\"\n    raw_bool, consumed = _validate_tag(\n        data,\n        tag,\n        ASN1Tag.universal_tag(TypeTagNumber.BOOLEAN, False),\n        header=header,\n        hint=hint,\n    )\n\n    return raw_bool.tobytes().replace(b\"\\x00\", b\"\") != b\"\", consumed", "\n\ndef _read_asn1_enumerated(\n    data: t.Union[bytes, bytearray, memoryview],\n    tag: t.Optional[ASN1Tag] = None,\n    header: t.Optional[ASN1Header] = None,\n    hint: t.Optional[str] = None,\n) -> t.Tuple[int, int]:\n    \"\"\"Unpacks an ASN.1 ENUMERATED value.\"\"\"\n    if not tag:\n        tag = header.tag if header else ASN1Tag.universal_tag(TypeTagNumber.ENUMERATED, False)\n    return _read_asn1_integer(data, tag, header=header, hint=hint)", "\n\ndef _read_asn1_generalized_time(\n    data: t.Union[bytes, bytearray, memoryview],\n    tag: t.Optional[ASN1Tag] = None,\n    header: t.Optional[ASN1Header] = None,\n    hint: t.Optional[str] = None,\n) -> t.Tuple[str, int]:\n    \"\"\"Unpacks an ASN.1 GENERALIZED_TIME value.\"\"\"\n    raw_time, consumed = _validate_tag(\n        data,\n        tag,\n        ASN1Tag.universal_tag(TypeTagNumber.GENERALIZED_TIME, False),\n        header=header,\n        hint=hint,\n    )\n    return raw_time.tobytes().decode(\"utf-8\"), consumed", "\n\ndef _read_asn1_integer(\n    data: t.Union[bytes, bytearray, memoryview],\n    tag: t.Optional[ASN1Tag] = None,\n    header: t.Optional[ASN1Header] = None,\n    hint: t.Optional[str] = None,\n) -> t.Tuple[int, int]:\n    \"\"\"Unpacks an ASN.1 INTEGER value.\"\"\"\n    raw_int, consumed = _validate_tag(\n        data,\n        tag,\n        ASN1Tag.universal_tag(TypeTagNumber.INTEGER, False),\n        header=header,\n        hint=hint,\n    )\n    b_int = bytearray(raw_int)\n\n    is_negative = b_int[0] & 0b10000000\n    if is_negative:\n        # Get the two's compliment.\n        for i in range(len(b_int)):\n            b_int[i] = 0xFF - b_int[i]\n\n        # Coverage is skipped because branch will not occur with no loop\n        for i in range(len(b_int) - 1, -1, -1):  # pragma: nocover\n            if b_int[i] == 0xFF:\n                b_int[i - 1] += 1\n                b_int[i] = 0\n                break\n\n            else:\n                b_int[i] += 1\n                break\n\n    int_value = 0\n    for val in b_int:\n        int_value = (int_value << 8) | val\n\n    if is_negative:\n        int_value *= -1\n\n    return int_value, consumed", "\n\ndef _read_asn1_object_identifier(\n    data: t.Union[bytes, bytearray, memoryview],\n    tag: t.Optional[ASN1Tag] = None,\n    header: t.Optional[ASN1Header] = None,\n    hint: t.Optional[str] = None,\n) -> t.Tuple[str, int]:\n    \"\"\"Unpacks an ASN.1 OBJECT_IDENTIFIER value.\"\"\"\n    raw_oid, consumed = _validate_tag(\n        data,\n        tag,\n        ASN1Tag.universal_tag(TypeTagNumber.OBJECT_IDENTIFIER, False),\n        header=header,\n        hint=hint,\n    )\n\n    first_element = struct.unpack(\"B\", raw_oid[:1])[0]\n    second_element = first_element % 40\n    ids = [(first_element - second_element) // 40, second_element]\n\n    idx = 1\n    while idx != len(raw_oid):\n        oid, octet_len = _unpack_asn1_octet_number(raw_oid[idx:])\n        ids.append(oid)\n        idx += octet_len\n\n    return \".\".join([str(i) for i in ids]), consumed", "\n\ndef _read_asn1_octet_string(\n    data: t.Union[bytes, bytearray, memoryview],\n    tag: t.Optional[ASN1Tag] = None,\n    header: t.Optional[ASN1Header] = None,\n    hint: t.Optional[str] = None,\n) -> t.Tuple[memoryview, int]:\n    \"\"\"Unpacks an ASN.1 OCTET_STRING value.\"\"\"\n    return _validate_tag(\n        data,\n        tag,\n        ASN1Tag.universal_tag(TypeTagNumber.OCTET_STRING, False),\n        header=header,\n        hint=hint,\n    )", "\n\ndef _read_asn1_sequence(\n    data: t.Union[bytes, bytearray, memoryview],\n    tag: t.Optional[ASN1Tag] = None,\n    header: t.Optional[ASN1Header] = None,\n    hint: t.Optional[str] = None,\n) -> t.Tuple[memoryview, int]:\n    \"\"\"Unpacks an ASN.1 SEQUENCE value.\"\"\"\n    return _validate_tag(\n        data,\n        tag,\n        ASN1Tag.universal_tag(TypeTagNumber.SEQUENCE, True),\n        header=header,\n        hint=hint,\n    )", "\n\ndef _read_asn1_set(\n    data: t.Union[bytes, bytearray, memoryview],\n    tag: t.Optional[ASN1Tag] = None,\n    header: t.Optional[ASN1Header] = None,\n    hint: t.Optional[str] = None,\n) -> t.Tuple[memoryview, int]:\n    \"\"\"Unpacks an ASN.1 SET value.\"\"\"\n    return _validate_tag(\n        data,\n        tag,\n        ASN1Tag.universal_tag(TypeTagNumber.SET, True),\n        header=header,\n        hint=hint,\n    )", "\n\ndef _read_asn1_utf8_string(\n    data: t.Union[bytes, bytearray, memoryview],\n    tag: t.Optional[ASN1Tag] = None,\n    header: t.Optional[ASN1Header] = None,\n    hint: t.Optional[str] = None,\n) -> t.Tuple[str, int]:\n    \"\"\"Unpacks an ASN.1 UTF8_STRING value.\"\"\"\n    raw_str, consumed = _validate_tag(\n        data,\n        tag,\n        ASN1Tag.universal_tag(TypeTagNumber.UTF8_STRING, False),\n        header=header,\n        hint=hint,\n    )\n    return raw_str.tobytes().decode(\"utf-8\"), consumed", "\n\ndef _validate_tag(\n    data: t.Union[bytes, bytearray, memoryview],\n    expected_tag: t.Optional[ASN1Tag],\n    type_tag: ASN1Tag,\n    header: t.Optional[ASN1Header] = None,\n    hint: t.Optional[str] = None,\n) -> t.Tuple[memoryview, int]:\n    view = memoryview(data)\n\n    if header:\n        actual_tag, tag_length, data_length = header\n    else:\n        actual_tag, tag_length, data_length = _read_asn1_header(view)\n\n    hint_str = f\" for {hint}\" if hint else \"\"\n\n    if not expected_tag:\n        expected_tag = header.tag if header else type_tag\n\n    if actual_tag != expected_tag:\n        raise ValueError(f\"Expected tag {expected_tag}{hint_str} but got {actual_tag}\")\n\n    view = view[tag_length:]\n    if len(view) < data_length:\n        raise NotEnougData(f\"Not enough data{hint_str}: expecting {data_length} but got {len(view)}\")\n\n    return view[:data_length], tag_length + data_length", "\n\ndef _unpack_asn1_octet_number(\n    data: memoryview,\n) -> t.Tuple[int, int]:\n    \"\"\"Unpacks an ASN.1 INTEGER value that can span across multiple octets.\"\"\"\n    i = 0\n    idx = 0\n    while True:\n        if len(data) < (idx + 1):\n            raise NotEnougData()\n\n        element = struct.unpack(\"B\", data[idx : idx + 1])[0]\n        idx += 1\n\n        i = (i << 7) + (element & 0b01111111)\n        if not element & 0b10000000:\n            break\n\n    return i, idx  # int value and the number of octets used.", "\n\ndef _pack_asn1_octet_number(\n    num: int,\n) -> bytes:\n    \"\"\"Packs an int number into an ASN.1 integer value that spans multiple octets.\"\"\"\n    num_octets = bytearray()\n\n    while num:\n        # Get the 7 bit value of the number.\n        octet_value = num & 0b01111111\n\n        # Set the MSB if this isn't the first octet we are processing (overall last octet)\n        if len(num_octets):\n            octet_value |= 0b10000000\n\n        num_octets.append(octet_value)\n\n        # Shift the number by 7 bits as we've just processed them.\n        num >>= 7\n\n    # Finally we reverse the order so the higher octets are first.\n    num_octets.reverse()\n\n    return num_octets", "\n\n__all__ = [\n    \"ASN1Reader\",\n    \"ASN1Writer\",\n    \"ASN1Header\",\n    \"ASN1Tag\",\n    \"NotEnougData\",\n    \"TagClass\",\n    \"TypeTagNumber\",", "    \"TagClass\",\n    \"TypeTagNumber\",\n]\n"]}
{"filename": "src/dpapi_ng/_security_descriptor.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport re\nimport typing as t\n\n\ndef sid_to_bytes(sid: str) -> bytes:\n    sid_pattern = re.compile(r\"^S-(\\d)-(\\d+)(?:-\\d+){1,15}$\")\n    sid_match = sid_pattern.match(sid)\n    if not sid_match:\n        raise ValueError(f\"Input string '{sid}' is not a valid SID string\")\n\n    sid_split = sid.split(\"-\")\n    revision = int(sid_split[1])\n    authority = int(sid_split[2])\n\n    data = bytearray(authority.to_bytes(8, byteorder=\"big\"))\n    data[0] = revision\n    data[1] = len(sid_split) - 3\n\n    for idx in range(3, len(sid_split)):\n        sub_auth = int(sid_split[idx])\n        data += sub_auth.to_bytes(4, byteorder=\"little\")\n\n    return bytes(data)", "\ndef sid_to_bytes(sid: str) -> bytes:\n    sid_pattern = re.compile(r\"^S-(\\d)-(\\d+)(?:-\\d+){1,15}$\")\n    sid_match = sid_pattern.match(sid)\n    if not sid_match:\n        raise ValueError(f\"Input string '{sid}' is not a valid SID string\")\n\n    sid_split = sid.split(\"-\")\n    revision = int(sid_split[1])\n    authority = int(sid_split[2])\n\n    data = bytearray(authority.to_bytes(8, byteorder=\"big\"))\n    data[0] = revision\n    data[1] = len(sid_split) - 3\n\n    for idx in range(3, len(sid_split)):\n        sub_auth = int(sid_split[idx])\n        data += sub_auth.to_bytes(4, byteorder=\"little\")\n\n    return bytes(data)", "\n\ndef ace_to_bytes(sid: str, access_mask: int) -> bytes:\n    b_sid = sid_to_bytes(sid)\n\n    return b\"\".join(\n        [\n            b\"\\x00\\x00\",  # AceType, AceFlags - ACCESS_ALLOWED_ACE_TYPE\n            (8 + len(b_sid)).to_bytes(2, byteorder=\"little\"),\n            access_mask.to_bytes(4, byteorder=\"little\"),\n            b_sid,\n        ]\n    )", "\n\ndef acl_to_bytes(aces: t.List[bytes]) -> bytes:\n    ace_data = b\"\".join(aces)\n\n    return b\"\".join(\n        [\n            b\"\\x02\\x00\",  # AclRevision, Sbz1 - ACL_REVISION\n            (8 + len(ace_data)).to_bytes(2, byteorder=\"little\"),\n            len(aces).to_bytes(2, byteorder=\"little\"),\n            b\"\\x00\\x00\",  # Sbz1\n            ace_data,\n        ]\n    )", "\n\ndef sd_to_bytes(\n    owner: str,\n    group: str,\n    sacl: t.Optional[t.List[bytes]] = None,\n    dacl: t.Optional[t.List[bytes]] = None,\n) -> bytes:\n    control = 0b10000000 << 8  # Self-Relative\n\n    # While MS-DTYP state there is no required order for the dynamic data, it\n    # is important that the raw bytes are exactly what Microsoft uses on the\n    # server side when it computes the seed key values. Luckily the footnote\n    # give the correct order the MS-GKDI expects: Sacl, Dacl, Owner, Group\n    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/11e1608c-6169-4fbc-9c33-373fc9b224f4#Appendix_A_72\n    dynamic_data = bytearray()\n    current_offset = 20  # Length of the SD header bytes\n\n    sacl_offset = 0\n    if sacl:\n        sacl_bytes = acl_to_bytes(sacl)\n        sacl_offset = current_offset\n        current_offset += len(sacl_bytes)\n\n        control |= 0b00010000  # SACL Present\n        dynamic_data += sacl_bytes\n\n    dacl_offset = 0\n    if dacl:\n        dacl_bytes = acl_to_bytes(dacl)\n        dacl_offset = current_offset\n        current_offset += len(dacl_bytes)\n\n        control |= 0b00000100  # DACL Present\n        dynamic_data += dacl_bytes\n\n    owner_bytes = sid_to_bytes(owner)\n    owner_offset = current_offset\n    current_offset += len(owner_bytes)\n    dynamic_data += owner_bytes\n\n    group_bytes = sid_to_bytes(group)\n    group_offset = current_offset\n    dynamic_data += group_bytes\n\n    return b\"\".join(\n        [\n            b\"\\x01\\x00\",  # Revision and Sbz1\n            control.to_bytes(2, byteorder=\"little\"),\n            owner_offset.to_bytes(4, byteorder=\"little\"),\n            group_offset.to_bytes(4, byteorder=\"little\"),\n            sacl_offset.to_bytes(4, byteorder=\"little\"),\n            dacl_offset.to_bytes(4, byteorder=\"little\"),\n            dynamic_data,\n        ]\n    )", ""]}
{"filename": "src/dpapi_ng/_crypto.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport enum\nimport os\nimport typing as t\n\nfrom cryptography.hazmat.primitives import hashes, keywrap", "\nfrom cryptography.hazmat.primitives import hashes, keywrap\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.ciphers.aead import AESGCM\nfrom cryptography.hazmat.primitives.kdf.concatkdf import ConcatKDFHash\nfrom cryptography.hazmat.primitives.kdf.kbkdf import KBKDFHMAC, CounterLocation, Mode\n\nfrom ._asn1 import ASN1Reader\n\n\nclass AlgorithmOID(str, enum.Enum):\n    \"\"\"OIDs for cryptographic algorithms.\"\"\"\n\n    AES256_WRAP = \"2.16.840.1.101.3.4.1.45\"\n    AES256_GCM = \"2.16.840.1.101.3.4.1.46\"", "\n\nclass AlgorithmOID(str, enum.Enum):\n    \"\"\"OIDs for cryptographic algorithms.\"\"\"\n\n    AES256_WRAP = \"2.16.840.1.101.3.4.1.45\"\n    AES256_GCM = \"2.16.840.1.101.3.4.1.46\"\n\n\ndef cek_decrypt(\n    algorithm: str,\n    parameters: t.Optional[bytes],\n    kek: bytes,\n    value: bytes,\n) -> bytes:\n    if algorithm == AlgorithmOID.AES256_WRAP:\n        return keywrap.aes_key_unwrap(kek, value)\n\n    else:\n        raise NotImplementedError(f\"Unknown cek encryption algorithm OID '{algorithm}'\")", "\ndef cek_decrypt(\n    algorithm: str,\n    parameters: t.Optional[bytes],\n    kek: bytes,\n    value: bytes,\n) -> bytes:\n    if algorithm == AlgorithmOID.AES256_WRAP:\n        return keywrap.aes_key_unwrap(kek, value)\n\n    else:\n        raise NotImplementedError(f\"Unknown cek encryption algorithm OID '{algorithm}'\")", "\n\ndef cek_encrypt(\n    algorithm: str,\n    parameters: t.Optional[bytes],\n    kek: bytes,\n    value: bytes,\n) -> bytes:\n    if algorithm == AlgorithmOID.AES256_WRAP:\n        return keywrap.aes_key_wrap(kek, value)\n\n    else:\n        raise NotImplementedError(f\"Unknown cek encryption algorithm OID '{algorithm}'\")", "\n\ndef cek_generate(\n    algorithm: str,\n) -> t.Tuple[bytes, bytes]:\n    if algorithm == AlgorithmOID.AES256_WRAP:\n        cek = AESGCM.generate_key(bit_length=256)\n        cek_iv = os.urandom(12)\n        return cek, cek_iv\n\n    else:\n        raise NotImplementedError(f\"Unknown cek encryption algorithm OID '{algorithm}'\")", "\n\ndef content_decrypt(\n    algorithm: str,\n    parameters: t.Optional[bytes],\n    cek: bytes,\n    value: bytes,\n) -> bytes:\n    if algorithm == AlgorithmOID.AES256_GCM:\n        if not parameters:\n            raise ValueError(\"Expecting parameters for AES256 GCM decryption but received none.\")\n\n        reader = ASN1Reader(parameters).read_sequence()\n        iv = reader.read_octet_string()\n\n        cipher = AESGCM(cek)\n        return cipher.decrypt(iv, value, None)\n\n    else:\n        raise NotImplementedError(f\"Unknown content encryption algorithm OID '{algorithm}'\")", "\n\ndef content_encrypt(\n    algorithm: str,\n    parameters: t.Optional[bytes],\n    cek: bytes,\n    value: bytes,\n) -> bytes:\n    if algorithm == AlgorithmOID.AES256_GCM:\n        if not parameters:\n            raise ValueError(\"Expecting parameters for AES256 GCM encryption but received none.\")\n\n        reader = ASN1Reader(parameters).read_sequence()\n        iv = reader.read_octet_string()\n\n        cipher = AESGCM(cek)\n        return cipher.encrypt(iv, value, None)\n\n    else:\n        raise NotImplementedError(f\"Unknown content encryption algorithm OID '{algorithm}'\")", "\n\ndef kdf(\n    algorithm: hashes.HashAlgorithm,\n    secret: bytes,\n    label: bytes,\n    context: bytes,\n    length: int,\n) -> bytes:\n    # KDF(HashAlg, KI, Label, Context, L)\n    # where KDF is SP800-108 in counter mode.\n    kdf = KBKDFHMAC(\n        algorithm=algorithm,\n        mode=Mode.CounterMode,\n        length=length,\n        label=label,\n        context=context,\n        # MS-SMB2 uses the same KDF function and my implementation that\n        # sets a value of 4 seems to work so assume that's the case here.\n        rlen=4,\n        llen=4,\n        location=CounterLocation.BeforeFixed,\n        fixed=None,\n    )\n    return kdf.derive(secret)", "\n\ndef kdf_concat(\n    algorithm: hashes.HashAlgorithm,\n    shared_secret: bytes,\n    algorithm_id: bytes,\n    party_uinfo: bytes,\n    party_vinfo: bytes,\n    length: int,\n) -> bytes:\n    otherinfo = b\"\".join([algorithm_id, party_uinfo, party_vinfo])\n    return ConcatKDFHash(\n        algorithm,\n        length=length,\n        otherinfo=otherinfo,\n    ).derive(shared_secret)", ""]}
{"filename": "src/dpapi_ng/_blob.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport dataclasses\nimport enum\nimport typing as t\nimport uuid\n", "import uuid\n\nfrom ._asn1 import ASN1Reader, ASN1Writer\nfrom ._pkcs7 import (\n    AlgorithmIdentifier,\n    ContentInfo,\n    EncryptedContentInfo,\n    EnvelopedData,\n    KEKIdentifier,\n    KEKRecipientInfo,", "    KEKIdentifier,\n    KEKRecipientInfo,\n    OtherKeyAttribute,\n)\nfrom ._security_descriptor import ace_to_bytes, sd_to_bytes\n\n\n@dataclasses.dataclass(frozen=True)\nclass KeyIdentifier:\n    \"\"\"Key Identifier.\n\n    This contains the key identifier info that can be used by MS-GKDI GetKey\n    to retrieve the group key seed values. This structure is not defined\n    publicly by Microsoft but it closely matches the :class:`GroupKeyEnvelope`\n    structure.\n\n    Args:\n        version: The version of the structure, should be 1\n        flags: Flags describing the values inside the structure\n        l0: The L0 index of the key\n        l1: The L1 index of the key\n        l2: The L2 index of the key\n        root_key_identifier: The key identifier\n        key_info: If is_public_key this is the public key, else it is the key\n            KDF context value.\n        domain_name: The domain name of the server in DNS format.\n        forest_name: The forest name of the server in DNS format.\n    \"\"\"\n\n    version: int\n    magic: bytes = dataclasses.field(init=False, repr=False, default=b\"\\x4B\\x44\\x53\\x4B\")\n    flags: int\n    l0: int\n    l1: int\n    l2: int\n    root_key_identifier: uuid.UUID\n    key_info: bytes\n    domain_name: str\n    forest_name: str\n\n    @property\n    def is_public_key(self) -> bool:\n        return bool(self.flags & 1)\n\n    def pack(self) -> bytes:\n        b_domain_name = (self.domain_name + \"\\00\").encode(\"utf-16-le\")\n        b_forest_name = (self.forest_name + \"\\00\").encode(\"utf-16-le\")\n\n        return b\"\".join(\n            [\n                self.version.to_bytes(4, byteorder=\"little\"),\n                self.magic,\n                self.flags.to_bytes(4, byteorder=\"little\"),\n                self.l0.to_bytes(4, byteorder=\"little\"),\n                self.l1.to_bytes(4, byteorder=\"little\"),\n                self.l2.to_bytes(4, byteorder=\"little\"),\n                self.root_key_identifier.bytes_le,\n                len(self.key_info).to_bytes(4, byteorder=\"little\"),\n                len(b_domain_name).to_bytes(4, byteorder=\"little\"),\n                len(b_forest_name).to_bytes(4, byteorder=\"little\"),\n                self.key_info,\n                b_domain_name,\n                b_forest_name,\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> KeyIdentifier:\n        view = memoryview(data)\n\n        version = int.from_bytes(view[:4], byteorder=\"little\")\n\n        if view[4:8].tobytes() != cls.magic:\n            raise ValueError(f\"Failed to unpack {cls.__name__} as magic identifier is invalid\")\n\n        flags = int.from_bytes(view[8:12], byteorder=\"little\")\n        l0_index = int.from_bytes(view[12:16], byteorder=\"little\")\n        l1_index = int.from_bytes(view[16:20], byteorder=\"little\")\n        l2_index = int.from_bytes(view[20:24], byteorder=\"little\")\n        root_key_identifier = uuid.UUID(bytes_le=view[24:40].tobytes())\n        key_info_len = int.from_bytes(view[40:44], byteorder=\"little\")\n        domain_len = int.from_bytes(view[44:48], byteorder=\"little\")\n        forest_len = int.from_bytes(view[48:52], byteorder=\"little\")\n        view = view[52:]\n\n        key_info = view[:key_info_len].tobytes()\n        view = view[key_info_len:]\n\n        # Take away 2 for the final null padding\n        domain = view[: domain_len - 2].tobytes().decode(\"utf-16-le\")\n        view = view[domain_len:]\n\n        forest = view[: forest_len - 2].tobytes().decode(\"utf-16-le\")\n        view = view[forest_len:]\n\n        return KeyIdentifier(\n            version=version,\n            flags=flags,\n            l0=l0_index,\n            l1=l1_index,\n            l2=l2_index,\n            root_key_identifier=root_key_identifier,\n            key_info=key_info,\n            domain_name=domain,\n            forest_name=forest,\n        )", "class KeyIdentifier:\n    \"\"\"Key Identifier.\n\n    This contains the key identifier info that can be used by MS-GKDI GetKey\n    to retrieve the group key seed values. This structure is not defined\n    publicly by Microsoft but it closely matches the :class:`GroupKeyEnvelope`\n    structure.\n\n    Args:\n        version: The version of the structure, should be 1\n        flags: Flags describing the values inside the structure\n        l0: The L0 index of the key\n        l1: The L1 index of the key\n        l2: The L2 index of the key\n        root_key_identifier: The key identifier\n        key_info: If is_public_key this is the public key, else it is the key\n            KDF context value.\n        domain_name: The domain name of the server in DNS format.\n        forest_name: The forest name of the server in DNS format.\n    \"\"\"\n\n    version: int\n    magic: bytes = dataclasses.field(init=False, repr=False, default=b\"\\x4B\\x44\\x53\\x4B\")\n    flags: int\n    l0: int\n    l1: int\n    l2: int\n    root_key_identifier: uuid.UUID\n    key_info: bytes\n    domain_name: str\n    forest_name: str\n\n    @property\n    def is_public_key(self) -> bool:\n        return bool(self.flags & 1)\n\n    def pack(self) -> bytes:\n        b_domain_name = (self.domain_name + \"\\00\").encode(\"utf-16-le\")\n        b_forest_name = (self.forest_name + \"\\00\").encode(\"utf-16-le\")\n\n        return b\"\".join(\n            [\n                self.version.to_bytes(4, byteorder=\"little\"),\n                self.magic,\n                self.flags.to_bytes(4, byteorder=\"little\"),\n                self.l0.to_bytes(4, byteorder=\"little\"),\n                self.l1.to_bytes(4, byteorder=\"little\"),\n                self.l2.to_bytes(4, byteorder=\"little\"),\n                self.root_key_identifier.bytes_le,\n                len(self.key_info).to_bytes(4, byteorder=\"little\"),\n                len(b_domain_name).to_bytes(4, byteorder=\"little\"),\n                len(b_forest_name).to_bytes(4, byteorder=\"little\"),\n                self.key_info,\n                b_domain_name,\n                b_forest_name,\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> KeyIdentifier:\n        view = memoryview(data)\n\n        version = int.from_bytes(view[:4], byteorder=\"little\")\n\n        if view[4:8].tobytes() != cls.magic:\n            raise ValueError(f\"Failed to unpack {cls.__name__} as magic identifier is invalid\")\n\n        flags = int.from_bytes(view[8:12], byteorder=\"little\")\n        l0_index = int.from_bytes(view[12:16], byteorder=\"little\")\n        l1_index = int.from_bytes(view[16:20], byteorder=\"little\")\n        l2_index = int.from_bytes(view[20:24], byteorder=\"little\")\n        root_key_identifier = uuid.UUID(bytes_le=view[24:40].tobytes())\n        key_info_len = int.from_bytes(view[40:44], byteorder=\"little\")\n        domain_len = int.from_bytes(view[44:48], byteorder=\"little\")\n        forest_len = int.from_bytes(view[48:52], byteorder=\"little\")\n        view = view[52:]\n\n        key_info = view[:key_info_len].tobytes()\n        view = view[key_info_len:]\n\n        # Take away 2 for the final null padding\n        domain = view[: domain_len - 2].tobytes().decode(\"utf-16-le\")\n        view = view[domain_len:]\n\n        forest = view[: forest_len - 2].tobytes().decode(\"utf-16-le\")\n        view = view[forest_len:]\n\n        return KeyIdentifier(\n            version=version,\n            flags=flags,\n            l0=l0_index,\n            l1=l1_index,\n            l2=l2_index,\n            root_key_identifier=root_key_identifier,\n            key_info=key_info,\n            domain_name=domain,\n            forest_name=forest,\n        )", "\n\nclass ProtectionDescriptorType(enum.Enum):\n    SID = \"1.3.6.1.4.1.311.74.1.1\"\n    KEY_FILE = \"1.3.6.1.4.1.311.74.1.2\"  # KeyFile in UF8String type\n    SDDL = \"1.3.6.1.4.1.311.74.1.5\"\n    LOCAL = \"1.3.6.1.4.1.311.74.1.8\"\n\n\n@dataclasses.dataclass(frozen=True)\nclass ProtectionDescriptor:\n    type: ProtectionDescriptorType\n    value: str\n\n    def get_target_sd(self) -> bytes:\n        raise NotImplementedError()  # pragma: nocover\n\n    def pack(self) -> bytes:\n        writer = ASN1Writer()\n\n        with writer.push_sequence() as w:\n            w.write_object_identifier(self.type.value)\n\n            with w.push_sequence() as w1:\n                with w1.push_sequence() as w2:\n                    with w2.push_sequence() as w3:\n                        w3.write_utf8_string(self.type.name)\n                        w3.write_utf8_string(self.value)\n\n        return writer.get_data()\n\n    @classmethod\n    def parse(\n        cls,\n        value: str,\n    ) -> ProtectionDescriptor:\n        # Currently only the SID type is supported\n        return SIDDescriptor(value)\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> ProtectionDescriptor:\n        reader = ASN1Reader(data).read_sequence()\n        content_type = reader.read_object_identifier()\n\n        reader = reader.read_sequence().read_sequence().read_sequence()\n        value_type = reader.read_utf8_string()\n        value = reader.read_utf8_string()\n\n        if content_type == ProtectionDescriptorType.SID.value and value_type == \"SID\":\n            return SIDDescriptor(value)\n\n        else:\n            raise ValueError(f\"DPAPI-NG protection descriptor type {content_type} '{value_type}' is unsupported\")", "\n@dataclasses.dataclass(frozen=True)\nclass ProtectionDescriptor:\n    type: ProtectionDescriptorType\n    value: str\n\n    def get_target_sd(self) -> bytes:\n        raise NotImplementedError()  # pragma: nocover\n\n    def pack(self) -> bytes:\n        writer = ASN1Writer()\n\n        with writer.push_sequence() as w:\n            w.write_object_identifier(self.type.value)\n\n            with w.push_sequence() as w1:\n                with w1.push_sequence() as w2:\n                    with w2.push_sequence() as w3:\n                        w3.write_utf8_string(self.type.name)\n                        w3.write_utf8_string(self.value)\n\n        return writer.get_data()\n\n    @classmethod\n    def parse(\n        cls,\n        value: str,\n    ) -> ProtectionDescriptor:\n        # Currently only the SID type is supported\n        return SIDDescriptor(value)\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> ProtectionDescriptor:\n        reader = ASN1Reader(data).read_sequence()\n        content_type = reader.read_object_identifier()\n\n        reader = reader.read_sequence().read_sequence().read_sequence()\n        value_type = reader.read_utf8_string()\n        value = reader.read_utf8_string()\n\n        if content_type == ProtectionDescriptorType.SID.value and value_type == \"SID\":\n            return SIDDescriptor(value)\n\n        else:\n            raise ValueError(f\"DPAPI-NG protection descriptor type {content_type} '{value_type}' is unsupported\")", "\n\n@dataclasses.dataclass(frozen=True)\nclass SIDDescriptor(ProtectionDescriptor):\n    type: ProtectionDescriptorType = dataclasses.field(init=False, default=ProtectionDescriptorType.SID)\n\n    def get_target_sd(self) -> bytes:\n        # Build the target security descriptor from the SID passed in. This SD\n        # contains an ACE per target user with a mask of 0x3 and a final ACE of\n        # the current user with a mask of 0x2. When viewing this over the wire\n        # the current user is set as S-1-1-0 (World) and the owner/group is\n        # S-1-5-18 (SYSTEM).\n        return sd_to_bytes(\n            owner=\"S-1-5-18\",\n            group=\"S-1-5-18\",\n            dacl=[ace_to_bytes(self.value, 3), ace_to_bytes(\"S-1-1-0\", 2)],\n        )", "\n\n@dataclasses.dataclass\nclass DPAPINGBlob:\n    MICROSOFT_SOFTWARE_OID = \"1.3.6.1.4.1.311.74.1\"\n\n    \"\"\"DPAPI NG Blob.\n\n    The unpacked DPAPI NG blob that contains the information needed to decrypt\n    the encrypted content. The key identifier and protection descriptor can be\n    used to generate the KEK. The KEK is used to decrypt the encrypted CEK. The\n    CEK can be used to decrypt the encrypted contents.\n\n    Args:\n        key_identifier: The key identifier for the KEK.\n        protection_descriptor: The protection descriptor that protects the key.\n        enc_cek: The encrypted CEK.\n        enc_cek_algorithm: The encrypted CEK algorithm OID.\n        enc_cek_parameters: The encrypted CEK algorithm parameters.\n        enc_content: The encrypted content.\n        enc_content_algorithm: The encrypted content algorithm OID.\n        enc_content_parameters: The encrypted content parameters.\n    \"\"\"\n\n    key_identifier: KeyIdentifier\n    protection_descriptor: ProtectionDescriptor\n    enc_cek: bytes\n    enc_cek_algorithm: str\n    enc_cek_parameters: t.Optional[bytes]\n    enc_content: bytes\n    enc_content_algorithm: str\n    enc_content_parameters: t.Optional[bytes]\n\n    def pack(\n        self,\n        blob_in_envelope: bool = True,\n    ) -> bytes:\n        \"\"\"Pack the DPAPI-NG Blob\n\n        Packs the DPAPI-NG blob into a byte string.\n\n        Args:\n            blob_in_envelope: True to store the encrypted blob in the\n                EnvelopedData structure (NCryptProtectSecret general), False to\n                append the encrypted blob after the EnvelopedData structure\n                (LAPS style).\n\n        Returns:\n            bytes: The DPAPI NG Blob data.\n        \"\"\"\n        writer = ASN1Writer()\n\n        recipient_info = KEKRecipientInfo(\n            version=4,\n            kekid=KEKIdentifier(\n                key_identifier=self.key_identifier.pack(),\n                other=OtherKeyAttribute(\n                    key_attr_id=DPAPINGBlob.MICROSOFT_SOFTWARE_OID,\n                    key_attr=self.protection_descriptor.pack(),\n                ),\n            ),\n            key_encryption_algorithm=AlgorithmIdentifier(\n                self.enc_cek_algorithm,\n                self.enc_cek_parameters,\n            ),\n            encrypted_key=self.enc_cek,\n        )\n\n        enveloped_data = EnvelopedData(\n            version=2,\n            recipient_infos=[recipient_info],\n            encrypted_content_info=EncryptedContentInfo(\n                content_type=EnvelopedData.CONTENT_TYPE_DATA_OID,\n                algorithm=AlgorithmIdentifier(\n                    algorithm=self.enc_content_algorithm,\n                    parameters=self.enc_content_parameters,\n                ),\n                content=self.enc_content if blob_in_envelope else b\"\",\n            ),\n        )\n        writer = ASN1Writer()\n        enveloped_data.pack(writer)\n\n        content_info = ContentInfo(\n            content_type=EnvelopedData.CONTENT_TYPE_ENVELOPED_DATA_OID,\n            content=writer.get_data(),\n        )\n        writer = ASN1Writer()\n        content_info.pack(writer)\n\n        return b\"\".join(\n            [\n                writer.get_data(),\n                b\"\" if blob_in_envelope else self.enc_content,\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> DPAPINGBlob:\n        view = memoryview(data)\n        header = ASN1Reader(view).peek_header()\n        content_info = ContentInfo.unpack(view[: header.tag_length + header.length], header=header)\n        remaining_data = view[header.tag_length + header.length :]\n\n        if content_info.content_type != EnvelopedData.CONTENT_TYPE_ENVELOPED_DATA_OID:\n            raise ValueError(f\"DPAPI-NG blob content type '{content_info.content_type}' is unsupported\")\n        enveloped_data = EnvelopedData.unpack(content_info.content)\n\n        if (\n            enveloped_data.version != 2\n            or len(enveloped_data.recipient_infos) != 1\n            or not isinstance(enveloped_data.recipient_infos[0], KEKRecipientInfo)\n            or enveloped_data.recipient_infos[0].version != 4\n        ):\n            raise ValueError(f\"DPAPI-NG blob is not in the expected format\")\n\n        kek_info = enveloped_data.recipient_infos[0]\n        key_identifier = KeyIdentifier.unpack(kek_info.kekid.key_identifier)\n\n        if not kek_info.kekid.other or kek_info.kekid.other.key_attr_id != DPAPINGBlob.MICROSOFT_SOFTWARE_OID:\n            raise ValueError(\"DPAPI-NG KEK Id is not in the expected format\")\n\n        protection_descriptor = ProtectionDescriptor.unpack(kek_info.kekid.other.key_attr or b\"\")\n\n        # Some DPAPI blobs don't include the content in the PKCS7 payload but\n        # just append after the blob.\n        enc_content = enveloped_data.encrypted_content_info.content or remaining_data.tobytes()\n\n        return DPAPINGBlob(\n            key_identifier=key_identifier,\n            protection_descriptor=protection_descriptor,\n            enc_cek=kek_info.encrypted_key,\n            enc_cek_algorithm=kek_info.key_encryption_algorithm.algorithm,\n            enc_cek_parameters=kek_info.key_encryption_algorithm.parameters,\n            enc_content=enc_content,\n            enc_content_algorithm=enveloped_data.encrypted_content_info.algorithm.algorithm,\n            enc_content_parameters=enveloped_data.encrypted_content_info.algorithm.parameters,\n        )", ""]}
{"filename": "src/dpapi_ng/_gkdi.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport dataclasses\nimport math\nimport os\nimport typing as t\nimport uuid", "import typing as t\nimport uuid\n\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import ec\n\nfrom ._blob import KeyIdentifier\nfrom ._crypto import kdf, kdf_concat\nfrom ._rpc import SyntaxId\n", "from ._rpc import SyntaxId\n\nKDS_SERVICE_LABEL = \"KDS service\\0\".encode(\"utf-16-le\")\n\nISD_KEY = SyntaxId(uuid.UUID(\"b9785960-524f-11df-8b6d-83dcded72085\"), 1, 0)\n\n\n@dataclasses.dataclass\nclass GetKey:\n    \"\"\"GetKey RPC Request\n\n    This can be used to build the stub data for the GetKey RPC request. The\n    syntax for this function is defined in `MS-GKDI 3.1.4.1 GetKey (Opnum 0)`_.\n\n    Args:\n        target_sd: The security descriptor to derive the key for.\n        root_key_id: The optional key identifier.\n        l0_key_id: The L0 index of the requested key.\n        l1_key_id: The L1 index of the requested key.\n        l2_key_id: THe L2 index of the requested key.\n\n    .. _MS-GKDI 3.1.4.1 GetKey (Opnum 0):\n        https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/4cac87a3-521e-4918-a272-240f8fabed39\n    \"\"\"\n\n    opnum: int = dataclasses.field(init=False, repr=False, default=0)\n\n    target_sd: bytes\n    root_key_id: t.Optional[uuid.UUID] = None\n    l0_key_id: int = -1\n    l1_key_id: int = -1\n    l2_key_id: int = -1\n\n    # HRESULT GetKey(\n    #     [in] handle_t hBinding,\n    #     [in] ULONG cbTargetSD,\n    #     [in] [size_is(cbTargetSD)] [ref] char* pbTargetSD,\n    #     [in] [unique] GUID* pRootKeyID,\n    #     [in] LONG L0KeyID,\n    #     [in] LONG L1KeyID,\n    #     [in] LONG L2KeyID,\n    #     [out] unsigned long* pcbOut,\n    #     [out] [size_is(, *pcbOut)] byte** ppbOut);\n\n    def pack(self) -> bytes:\n        # Strictly speaking it is only 4 bytes but NDR64 needs 8 byte alignment\n        # on the field after.\n        target_sd_len = len(self.target_sd).to_bytes(8, byteorder=\"little\")\n        if self.root_key_id:\n            b_root_key = b\"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\" + self.root_key_id.bytes_le\n        else:\n            b_root_key = b\"\\x00\" * 8\n\n        return b\"\".join(\n            [\n                # cbTargetSD\n                target_sd_len,\n                # pbTargetSD - pointer header includes the length + padding\n                target_sd_len,\n                self.target_sd,\n                b\"\\x00\" * (-len(self.target_sd) % 8),\n                # pRootKeyID - includes referent id\n                b_root_key,\n                # L0KeyID\n                self.l0_key_id.to_bytes(4, byteorder=\"little\", signed=True),\n                # L1KeyID\n                self.l1_key_id.to_bytes(4, byteorder=\"little\", signed=True),\n                # L2KeyID\n                self.l2_key_id.to_bytes(4, byteorder=\"little\", signed=True),\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> GetKey:\n        view = memoryview(data)\n\n        target_sd_len = int.from_bytes(view[:4], byteorder=\"little\")\n        target_sd = view[16 : 16 + target_sd_len].tobytes()\n        padding = -target_sd_len % 8\n\n        view = view[16 + target_sd_len + padding :]\n\n        root_key_referent = view[:8].tobytes()\n        if root_key_referent == b\"\\x00\" * 8:\n            root_key_id = None\n            view = view[8:]\n        else:\n            root_key_id = uuid.UUID(bytes_le=view[8:24].tobytes())\n            view = view[24:]\n\n        l0_key_id = int.from_bytes(view[:4], byteorder=\"little\", signed=True)\n        l1_key_id = int.from_bytes(view[4:8], byteorder=\"little\", signed=True)\n        l2_key_id = int.from_bytes(view[8:12], byteorder=\"little\", signed=True)\n\n        return GetKey(\n            target_sd=target_sd,\n            root_key_id=root_key_id,\n            l0_key_id=l0_key_id,\n            l1_key_id=l1_key_id,\n            l2_key_id=l2_key_id,\n        )\n\n    @classmethod\n    def unpack_response(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> GroupKeyEnvelope:\n        view = memoryview(data)\n\n        hresult = int.from_bytes(view[-4:], byteorder=\"little\")\n        view = view[:-4]\n        if hresult != 0:\n            raise ValueError(f\"GetKey failed 0x{hresult:08X}\")\n\n        key_length = int.from_bytes(view[:4], byteorder=\"little\")\n        view = view[8:]  # Skip padding as well\n        # Skip the referent id and double up on pointer size\n        return GroupKeyEnvelope.unpack(view[16 : 16 + key_length])", "class GetKey:\n    \"\"\"GetKey RPC Request\n\n    This can be used to build the stub data for the GetKey RPC request. The\n    syntax for this function is defined in `MS-GKDI 3.1.4.1 GetKey (Opnum 0)`_.\n\n    Args:\n        target_sd: The security descriptor to derive the key for.\n        root_key_id: The optional key identifier.\n        l0_key_id: The L0 index of the requested key.\n        l1_key_id: The L1 index of the requested key.\n        l2_key_id: THe L2 index of the requested key.\n\n    .. _MS-GKDI 3.1.4.1 GetKey (Opnum 0):\n        https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/4cac87a3-521e-4918-a272-240f8fabed39\n    \"\"\"\n\n    opnum: int = dataclasses.field(init=False, repr=False, default=0)\n\n    target_sd: bytes\n    root_key_id: t.Optional[uuid.UUID] = None\n    l0_key_id: int = -1\n    l1_key_id: int = -1\n    l2_key_id: int = -1\n\n    # HRESULT GetKey(\n    #     [in] handle_t hBinding,\n    #     [in] ULONG cbTargetSD,\n    #     [in] [size_is(cbTargetSD)] [ref] char* pbTargetSD,\n    #     [in] [unique] GUID* pRootKeyID,\n    #     [in] LONG L0KeyID,\n    #     [in] LONG L1KeyID,\n    #     [in] LONG L2KeyID,\n    #     [out] unsigned long* pcbOut,\n    #     [out] [size_is(, *pcbOut)] byte** ppbOut);\n\n    def pack(self) -> bytes:\n        # Strictly speaking it is only 4 bytes but NDR64 needs 8 byte alignment\n        # on the field after.\n        target_sd_len = len(self.target_sd).to_bytes(8, byteorder=\"little\")\n        if self.root_key_id:\n            b_root_key = b\"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\" + self.root_key_id.bytes_le\n        else:\n            b_root_key = b\"\\x00\" * 8\n\n        return b\"\".join(\n            [\n                # cbTargetSD\n                target_sd_len,\n                # pbTargetSD - pointer header includes the length + padding\n                target_sd_len,\n                self.target_sd,\n                b\"\\x00\" * (-len(self.target_sd) % 8),\n                # pRootKeyID - includes referent id\n                b_root_key,\n                # L0KeyID\n                self.l0_key_id.to_bytes(4, byteorder=\"little\", signed=True),\n                # L1KeyID\n                self.l1_key_id.to_bytes(4, byteorder=\"little\", signed=True),\n                # L2KeyID\n                self.l2_key_id.to_bytes(4, byteorder=\"little\", signed=True),\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> GetKey:\n        view = memoryview(data)\n\n        target_sd_len = int.from_bytes(view[:4], byteorder=\"little\")\n        target_sd = view[16 : 16 + target_sd_len].tobytes()\n        padding = -target_sd_len % 8\n\n        view = view[16 + target_sd_len + padding :]\n\n        root_key_referent = view[:8].tobytes()\n        if root_key_referent == b\"\\x00\" * 8:\n            root_key_id = None\n            view = view[8:]\n        else:\n            root_key_id = uuid.UUID(bytes_le=view[8:24].tobytes())\n            view = view[24:]\n\n        l0_key_id = int.from_bytes(view[:4], byteorder=\"little\", signed=True)\n        l1_key_id = int.from_bytes(view[4:8], byteorder=\"little\", signed=True)\n        l2_key_id = int.from_bytes(view[8:12], byteorder=\"little\", signed=True)\n\n        return GetKey(\n            target_sd=target_sd,\n            root_key_id=root_key_id,\n            l0_key_id=l0_key_id,\n            l1_key_id=l1_key_id,\n            l2_key_id=l2_key_id,\n        )\n\n    @classmethod\n    def unpack_response(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> GroupKeyEnvelope:\n        view = memoryview(data)\n\n        hresult = int.from_bytes(view[-4:], byteorder=\"little\")\n        view = view[:-4]\n        if hresult != 0:\n            raise ValueError(f\"GetKey failed 0x{hresult:08X}\")\n\n        key_length = int.from_bytes(view[:4], byteorder=\"little\")\n        view = view[8:]  # Skip padding as well\n        # Skip the referent id and double up on pointer size\n        return GroupKeyEnvelope.unpack(view[16 : 16 + key_length])", "\n\n@dataclasses.dataclass(frozen=True)\nclass KDFParameters:\n    \"\"\"KDF Parameters\n\n    The format and field descriptions for the key derivation function (KDF)\n    parameters. The format of this struct is defined in\n    `MS-GKDI 2.2.1 KDF Parameters`_.\n\n    Args:\n        hash_name: The name of the hash algorithm.\n\n    .. _MS-GKDI 2.2.1 KDF Parameters:\n        https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/9946aeff-a914-45e9-b9e5-6cb5b4059187\n    \"\"\"\n\n    hash_name: str\n\n    @property\n    def hash_algorithm(self) -> hashes.HashAlgorithm:\n        \"\"\"The hash algorithm object.\"\"\"\n        if self.hash_name == \"SHA1\":\n            return hashes.SHA1()\n        elif self.hash_name == \"SHA256\":\n            return hashes.SHA256()\n        elif self.hash_name == \"SHA384\":\n            return hashes.SHA384()\n        elif self.hash_name == \"SHA512\":\n            return hashes.SHA512()\n        else:\n            raise NotImplementedError(f\"Unsupported hash algorithm {self.hash_name}\")\n\n    def pack(self) -> bytes:\n        b_hash_name = (self.hash_name + \"\\00\").encode(\"utf-16-le\")\n        return b\"\".join(\n            [\n                b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\",\n                len(b_hash_name).to_bytes(4, byteorder=\"little\"),\n                b\"\\x00\\x00\\x00\\x00\",\n                b_hash_name,\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> KDFParameters:\n        view = memoryview(data)\n\n        if view[:8].tobytes() != b\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\" or view[12:16].tobytes() != b\"\\x00\\x00\\x00\\x00\":\n            raise ValueError(f\"Failed to unpack {cls.__name__} as magic identifier is invalid\")\n\n        hash_length = int.from_bytes(view[8:12], byteorder=\"little\")\n        hash_name = view[16 : 16 + hash_length - 2].tobytes().decode(\"utf-16-le\")\n\n        return KDFParameters(hash_name=hash_name)", "\n\n@dataclasses.dataclass(frozen=True)\nclass FFCDHParameters:\n    \"\"\"FFC DH Parameters\n\n    The field parameters for use in deriving finite field cryptography (FFC)\n    Diffie-Hellman (DH) keys. The format of this struct is defined in\n    `MS-GKDI 2.2.2 FFC DH Parameters`_.\n\n    Args:\n        key_length: The length of the public key.\n        field_order: The large prime field order, otherwise known as p.\n        generator: The generator of the subgroup, otherwise known as g.\n\n    .. _MS-GKDI 2.2.2 FFC DH Parameters:\n        https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/e15ae269-ee21-446a-a480-de3ea243db5f\n    \"\"\"\n\n    key_length: int\n    magic: bytes = dataclasses.field(init=False, repr=False, default=b\"\\x44\\x48\\x50\\x4D\")\n    field_order: int\n    generator: int\n\n    def pack(self) -> bytes:\n        b_field_order = self.field_order.to_bytes(self.key_length, byteorder=\"big\")\n        b_generator = self.generator.to_bytes(self.key_length, byteorder=\"big\")\n\n        return b\"\".join(\n            [\n                (12 + len(b_field_order) + len(b_generator)).to_bytes(4, byteorder=\"little\"),\n                self.magic,\n                self.key_length.to_bytes(4, byteorder=\"little\"),\n                b_field_order,\n                b_generator,\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> FFCDHParameters:\n        view = memoryview(data)\n\n        # length = int.from_bytes(view[:4], byteorder=\"little\")\n        if view[4:8].tobytes() != cls.magic:\n            raise ValueError(f\"Failed to unpack {cls.__name__} as magic identifier is invalid\")\n\n        key_length = int.from_bytes(view[8:12], byteorder=\"little\")\n        field_order = view[12 : 12 + key_length].tobytes()\n        generator = view[12 + key_length : 12 + key_length + key_length].tobytes()\n\n        return FFCDHParameters(\n            key_length=key_length,\n            field_order=int.from_bytes(field_order, byteorder=\"big\"),\n            generator=int.from_bytes(generator, byteorder=\"big\"),\n        )", "\n\n@dataclasses.dataclass(frozen=True)\nclass FFCDHKey:\n    \"\"\"FFC DH Key\n\n    The finite field cryptography (FFC) Diffie-Hellman (DH) public key info.\n    The format of this struct is defined in `MS-GKDI 2.2.3.1 FFC DH Key`_.\n\n    Args:\n        key_length: The length of the public key.\n        field_order: The large prime field order, otherwise known as p.\n        generator: The generator of the subgroup, otherwise known as g.\n        public_key: The public key of the peer, otherwise known as y.\n\n    .. _MS-GKDI 2.2.3.1 FFC DH Key:\n        https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/f8770f01-036d-4bf6-a4cf-1bd0e3913404\n    \"\"\"\n\n    magic: bytes = dataclasses.field(init=False, repr=False, default=b\"\\x44\\x48\\x50\\x42\")\n    key_length: int\n    field_order: int\n    generator: int\n    public_key: int\n\n    def pack(self) -> bytes:\n        b_field_order = self.field_order.to_bytes(self.key_length, byteorder=\"big\")\n        b_generator = self.generator.to_bytes(self.key_length, byteorder=\"big\")\n        b_pub_key = self.public_key.to_bytes(self.key_length, byteorder=\"big\")\n\n        return b\"\".join(\n            [\n                self.magic,\n                self.key_length.to_bytes(4, byteorder=\"little\"),\n                b_field_order,\n                b_generator,\n                b_pub_key,\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> FFCDHKey:\n        view = memoryview(data)\n\n        if view[:4].tobytes() != cls.magic:\n            raise ValueError(f\"Failed to unpack {cls.__name__} as magic identifier is invalid\")\n\n        key_length = int.from_bytes(view[4:8], byteorder=\"little\")\n\n        field_order = view[8 : 8 + key_length].tobytes()\n        view = view[8 + key_length :]\n\n        generator = view[:key_length].tobytes()\n        view = view[key_length:]\n\n        public_key = view[:key_length].tobytes()\n\n        return FFCDHKey(\n            key_length=key_length,\n            field_order=int.from_bytes(field_order, byteorder=\"big\"),\n            generator=int.from_bytes(generator, byteorder=\"big\"),\n            public_key=int.from_bytes(public_key, byteorder=\"big\"),\n        )", "\n\n@dataclasses.dataclass(frozen=True)\nclass ECDHKey:\n    \"\"\"ECDH Key\n\n    The elliptic curve Diffie-Hellman (ECDH) public key info. The format of\n    this struct is defined in `MS-GKDI 2.2.3.2 ECDH Key`_.\n\n    Args:\n        curve_name: The curve name used, currently only the curves P256, P384,\n            P521 are supported.\n        key_length: The length of the public key.\n        x: The X coordinate of the point P.\n        y: The Y coordinate of the point P.\n\n    .. _MS-GKDI 2.2.3.2 ECDH Key:\n        https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/24876a37-9a92-4187-9052-222bb6f85d4a\n    \"\"\"\n\n    magic: bytes = dataclasses.field(init=False, repr=False, default=b\"\\x45\\x43\\x4B\")\n    curve_name: str\n    key_length: int\n    x: int\n    y: int\n\n    @property\n    def curve_and_hash(self) -> tuple[ec.EllipticCurve, hashes.HashAlgorithm]:\n        return {\n            \"P256\": (ec.SECP256R1(), hashes.SHA256()),\n            \"P384\": (ec.SECP384R1(), hashes.SHA384()),\n            \"P521\": (ec.SECP521R1(), hashes.SHA512()),\n        }[self.curve_name]\n\n    def pack(self) -> bytes:\n        b_x = self.x.to_bytes(self.key_length, byteorder=\"big\")\n        b_y = self.y.to_bytes(self.key_length, byteorder=\"big\")\n\n        b_curve = {\n            \"P256\": b\"\\x45\\x43\\x4B\\x31\",\n            \"P384\": b\"\\x45\\x43\\x4B\\x33\",\n            \"P521\": b\"\\x45\\x43\\x4B\\x35\",\n        }.get(self.curve_name, None)\n        if not b_curve:\n            raise ValueError(f\"Unknown curve '{self.curve_name}', cannot pack.\")\n\n        return b\"\".join(\n            [\n                b_curve,\n                self.key_length.to_bytes(4, byteorder=\"little\"),\n                b_x,\n                b_y,\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> ECDHKey:\n        view = memoryview(data)\n\n        curve_id = int.from_bytes(view[:4], byteorder=\"little\")\n        curve = {\n            0x314B4345: \"P256\",\n            0x334B4345: \"P384\",\n            0x354B4345: \"P521\",\n        }.get(curve_id, None)\n        if not curve:\n            raise ValueError(f\"Failed to unpack {cls.__name__} with unknown curve 0x{curve_id:08X}\")\n\n        length = int.from_bytes(view[4:8], byteorder=\"little\")\n\n        x = view[8 : 8 + length].tobytes()\n        view = view[8 + length :]\n\n        y = view[:length].tobytes()\n\n        return ECDHKey(\n            curve_name=curve,\n            key_length=length,\n            x=int.from_bytes(x, byteorder=\"big\"),\n            y=int.from_bytes(y, byteorder=\"big\"),\n        )", "\n\n@dataclasses.dataclass(frozen=True)\nclass GroupKeyEnvelope:\n    \"\"\"Group Key Envelope\n\n    The group key envelope structure that describes the group key information\n    returned by a GetKey RPC request. The format of this struct is defined in\n    `MS-GKDI 2.2.4 Group Key Envelope`_.\n\n    Args:\n        version: The version of the structure, should be 1\n        flags: Flags describing the values inside the structure\n        l0: The L0 index of the key\n        l1: The L1 index of the key\n        l2: The L2 index of the key\n        root_key_identifier: The key identifier\n        kdf_algorithm: The KDF algorithm name.\n        kdf_parameters: The KDF algorithm parameters\n        secret_algorithm: The secret agreement algorithm name.\n        secret_parameters: The secret agreement algorithm parameters.\n        private_key_length: The private key length associated with the root key.\n        public_key_length: The public key length associated with the root key.\n        domain_name: The domain name of the server in DNS format.\n        forest_name: The forest name of the server in DNS format.\n        l1_key: The L1 seed key.\n        l2_key: If is_public_key this is the public key, else this is the L2\n            seed key.\n\n    .. _MS-GKDI 2.2.4 Group Key Envelope\n        https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/192c061c-e740-4aa0-ab1d-6954fb3e58f7\n    \"\"\"\n\n    version: int\n    magic: bytes = dataclasses.field(init=False, repr=False, default=b\"\\x4B\\x44\\x53\\x4B\")\n    flags: int\n    l0: int\n    l1: int\n    l2: int\n    root_key_identifier: uuid.UUID\n    kdf_algorithm: str\n    kdf_parameters: bytes\n    secret_algorithm: str\n    secret_parameters: bytes\n    private_key_length: int\n    public_key_length: int\n    domain_name: str\n    forest_name: str\n    l1_key: bytes\n    l2_key: bytes\n\n    @property\n    def is_public_key(self) -> bool:\n        \"\"\"If True, the value of l2_key is the public key.\"\"\"\n        return bool(self.flags & 1)\n\n    def pack(self) -> bytes:\n        b_kdf_algorithm = (self.kdf_algorithm + \"\\00\").encode(\"utf-16-le\")\n        b_secret_algorithm = (self.secret_algorithm + \"\\00\").encode(\"utf-16-le\")\n        b_domain_name = (self.domain_name + \"\\00\").encode(\"utf-16-le\")\n        b_forest_name = (self.forest_name + \"\\00\").encode(\"utf-16-le\")\n\n        return b\"\".join(\n            [\n                self.version.to_bytes(4, byteorder=\"little\"),\n                self.magic,\n                self.flags.to_bytes(4, byteorder=\"little\"),\n                self.l0.to_bytes(4, byteorder=\"little\"),\n                self.l1.to_bytes(4, byteorder=\"little\"),\n                self.l2.to_bytes(4, byteorder=\"little\"),\n                self.root_key_identifier.bytes_le,\n                len(b_kdf_algorithm).to_bytes(4, byteorder=\"little\"),\n                len(self.kdf_parameters).to_bytes(4, byteorder=\"little\"),\n                len(b_secret_algorithm).to_bytes(4, byteorder=\"little\"),\n                len(self.secret_parameters).to_bytes(4, byteorder=\"little\"),\n                self.private_key_length.to_bytes(4, byteorder=\"little\"),\n                self.public_key_length.to_bytes(4, byteorder=\"little\"),\n                len(self.l1_key).to_bytes(4, byteorder=\"little\"),\n                len(self.l2_key).to_bytes(4, byteorder=\"little\"),\n                len(b_domain_name).to_bytes(4, byteorder=\"little\"),\n                len(b_forest_name).to_bytes(4, byteorder=\"little\"),\n                b_kdf_algorithm,\n                self.kdf_parameters,\n                b_secret_algorithm,\n                self.secret_parameters,\n                b_domain_name,\n                b_forest_name,\n                self.l1_key,\n                self.l2_key,\n            ]\n        )\n\n    def get_kek(\n        self,\n        key_id: KeyIdentifier,\n    ) -> bytes:\n        if self.is_public_key:\n            raise ValueError(\"Current user is not authorized to retrieve the KEK information\")\n        if self.l0 != key_id.l0:\n            raise ValueError(f\"L0 index {self.l0} does not match the requested L0 index {key_id.l0}\")\n\n        if self.kdf_algorithm != \"SP800_108_CTR_HMAC\":\n            raise NotImplementedError(f\"Unknown KDF algorithm '{self.kdf_algorithm}'\")\n\n        kdf_parameters = KDFParameters.unpack(self.kdf_parameters)\n        hash_algo = kdf_parameters.hash_algorithm\n        l2_key = compute_l2_key(hash_algo, key_id.l1, key_id.l2, self)\n\n        if key_id.is_public_key:\n            return compute_kek_from_public_key(\n                algorithm=hash_algo,\n                seed=l2_key,\n                secret_algorithm=self.secret_algorithm,\n                secret_parameters=self.secret_parameters,\n                public_key=key_id.key_info,\n                private_key_length=math.ceil(self.private_key_length / 8),\n            )\n\n        else:\n            return kdf(\n                hash_algo,\n                l2_key,\n                KDS_SERVICE_LABEL,\n                key_id.key_info,\n                32,\n            )\n\n    def new_kek(\n        self,\n    ) -> tuple[bytes, KeyIdentifier]:\n        if self.kdf_algorithm != \"SP800_108_CTR_HMAC\":\n            raise NotImplementedError(f\"Unknown KDF algorithm '{self.kdf_algorithm}'\")\n\n        kdf_parameters = KDFParameters.unpack(self.kdf_parameters)\n        hash_algo = kdf_parameters.hash_algorithm\n\n        if self.is_public_key:\n            # If is_public_key flag is set, the L2 key is the peer's public key\n            private_key = os.urandom(math.ceil(self.private_key_length / 8))\n            kek = compute_kek(\n                algorithm=hash_algo,\n                secret_algorithm=self.secret_algorithm,\n                secret_parameters=self.secret_parameters,\n                private_key=private_key,\n                public_key=self.l2_key,\n            )\n\n            key_info = compute_public_key(\n                secret_algorithm=self.secret_algorithm,\n                secret_parameters=self.secret_parameters,\n                private_key=private_key,\n                peer_public_key=self.l2_key,\n            )\n        else:\n            key_info = os.urandom(32)\n            kek = kdf(\n                hash_algo,\n                self.l2_key,\n                KDS_SERVICE_LABEL,\n                key_info,\n                32,\n            )\n\n        key_identifier = KeyIdentifier(\n            version=1,\n            flags=self.flags,\n            l0=self.l0,\n            l1=self.l1,\n            l2=self.l2,\n            root_key_identifier=self.root_key_identifier,\n            key_info=key_info,\n            domain_name=self.domain_name,\n            forest_name=self.forest_name,\n        )\n        return kek, key_identifier\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> GroupKeyEnvelope:\n        view = memoryview(data)\n\n        version = int.from_bytes(view[:4], byteorder=\"little\")\n\n        if view[4:8].tobytes() != cls.magic:\n            raise ValueError(f\"Failed to unpack {cls.__name__} as magic identifier is invalid\")\n\n        flags = int.from_bytes(view[8:12], byteorder=\"little\")\n        l0_index = int.from_bytes(view[12:16], byteorder=\"little\")\n        l1_index = int.from_bytes(view[16:20], byteorder=\"little\")\n        l2_index = int.from_bytes(view[20:24], byteorder=\"little\")\n        root_key_identifier = uuid.UUID(bytes_le=view[24:40].tobytes())\n        kdf_algo_len = int.from_bytes(view[40:44], byteorder=\"little\")\n        kdf_para_len = int.from_bytes(view[44:48], byteorder=\"little\")\n        sec_algo_len = int.from_bytes(view[48:52], byteorder=\"little\")\n        sec_para_len = int.from_bytes(view[52:56], byteorder=\"little\")\n        priv_key_len = int.from_bytes(view[56:60], byteorder=\"little\")\n        publ_key_len = int.from_bytes(view[60:64], byteorder=\"little\")\n        l1_key_len = int.from_bytes(view[64:68], byteorder=\"little\")\n        l2_key_len = int.from_bytes(view[68:72], byteorder=\"little\")\n        domain_len = int.from_bytes(view[72:76], byteorder=\"little\")\n        forest_len = int.from_bytes(view[76:80], byteorder=\"little\")\n        view = view[80:]\n\n        kdf_algo = view[: kdf_algo_len - 2].tobytes().decode(\"utf-16-le\")\n        view = view[kdf_algo_len:]\n\n        kdf_param = view[:kdf_para_len].tobytes()\n        view = view[kdf_para_len:]\n\n        secret_algo = view[: sec_algo_len - 2].tobytes().decode(\"utf-16-le\")\n        view = view[sec_algo_len:]\n\n        secret_param = view[:sec_para_len].tobytes()\n        view = view[sec_para_len:]\n\n        domain = view[: domain_len - 2].tobytes().decode(\"utf-16-le\")\n        view = view[domain_len:]\n\n        forest = view[: forest_len - 2].tobytes().decode(\"utf-16-le\")\n        view = view[forest_len:]\n\n        l1_key = view[:l1_key_len].tobytes()\n        view = view[l1_key_len:]\n\n        l2_key = view[:l2_key_len].tobytes()\n        view = view[l2_key_len:]\n\n        return GroupKeyEnvelope(\n            version=version,\n            flags=flags,\n            l0=l0_index,\n            l1=l1_index,\n            l2=l2_index,\n            root_key_identifier=root_key_identifier,\n            kdf_algorithm=kdf_algo,\n            kdf_parameters=kdf_param,\n            secret_algorithm=secret_algo,\n            secret_parameters=secret_param,\n            private_key_length=priv_key_len,\n            public_key_length=publ_key_len,\n            domain_name=domain,\n            forest_name=forest,\n            l1_key=l1_key,\n            l2_key=l2_key,\n        )", "\n\ndef compute_l1_key(\n    target_sd: bytes,\n    root_key_id: uuid.UUID,\n    l0: int,\n    root_key: bytes,\n    algorithm: hashes.HashAlgorithm,\n) -> bytes:\n    # Note: 512 is number of bits, we use byte length here\n    # Key(SD, RK, L0, -1, -1) = KDF(\n    #   HashAlg,\n    #   RK.msKds-RootKeyData,\n    #   \"KDS service\",\n    #   RKID || L0 || 0xffffffff || 0xffffffff,\n    #   512\n    # )\n    l0_seed = kdf(\n        algorithm,\n        root_key,\n        KDS_SERVICE_LABEL,\n        compute_kdf_context(root_key_id, l0, -1, -1),\n        64,\n    )\n\n    # Key(SD, RK, L0, 31, -1) = KDF(\n    #   HashAlg,\n    #   Key(SD, RK, L0, -1, -1),\n    #   \"KDS service\",\n    #   RKID || L0 || 31 || 0xffffffff || SD,\n    #   512\n    # )\n    return kdf(\n        algorithm,\n        l0_seed,\n        KDS_SERVICE_LABEL,\n        compute_kdf_context(root_key_id, l0, 31, -1) + target_sd,\n        64,\n    )", "\n\ndef compute_l2_key(\n    algorithm: hashes.HashAlgorithm,\n    request_l1: int,\n    request_l2: int,\n    rk: GroupKeyEnvelope,\n) -> bytes:\n    l1 = rk.l1\n    l1_key = rk.l1_key\n    l2 = rk.l2\n    l2_key = rk.l2_key\n    reseed_l2 = l2 == 31 or rk.l1 != request_l1\n\n    # MS-GKDI 2.2.4 Group key Envelope\n    # If the value in the L2 index field is equal to 31, this contains the\n    # L1 key with group key identifier (L0 index, L1 index, -1). In all\n    # other cases, this field contains the L1 key with group key identifier\n    # (L0 index, L1 index - 1, -1). If this field is present, its length\n    # MUST be equal to 64 bytes.\n    if l2 != 31 and l1 != request_l1:\n        l1 -= 1\n\n    while l1 != request_l1:\n        reseed_l2 = True\n        l1 -= 1\n\n        l1_key = kdf(\n            algorithm,\n            l1_key,\n            KDS_SERVICE_LABEL,\n            compute_kdf_context(\n                rk.root_key_identifier,\n                rk.l0,\n                l1,\n                -1,\n            ),\n            64,\n        )\n\n    if reseed_l2:\n        l2 = 31\n        l2_key = kdf(\n            algorithm,\n            l1_key,\n            KDS_SERVICE_LABEL,\n            compute_kdf_context(\n                rk.root_key_identifier,\n                rk.l0,\n                l1,\n                l2,\n            ),\n            64,\n        )\n\n    while l2 != request_l2:\n        l2 -= 1\n\n        l2_key = kdf(\n            algorithm,\n            l2_key,\n            KDS_SERVICE_LABEL,\n            compute_kdf_context(\n                rk.root_key_identifier,\n                rk.l0,\n                l1,\n                l2,\n            ),\n            64,\n        )\n\n    return l2_key", "\n\ndef compute_kdf_context(\n    key_guid: uuid.UUID,\n    l0: int,\n    l1: int,\n    l2: int,\n) -> bytes:\n    return b\"\".join(\n        [\n            key_guid.bytes_le,\n            l0.to_bytes(4, byteorder=\"little\", signed=True),\n            l1.to_bytes(4, byteorder=\"little\", signed=True),\n            l2.to_bytes(4, byteorder=\"little\", signed=True),\n        ]\n    )", "\n\ndef compute_kek_from_public_key(\n    algorithm: hashes.HashAlgorithm,\n    seed: bytes,\n    secret_algorithm: str,\n    secret_parameters: t.Optional[bytes],\n    public_key: bytes,\n    private_key_length: int,\n) -> bytes:\n    private_key = kdf(\n        algorithm,\n        seed,\n        KDS_SERVICE_LABEL,\n        (secret_algorithm + \"\\0\").encode(\"utf-16-le\"),\n        private_key_length,\n    )\n\n    return compute_kek(\n        algorithm,\n        secret_algorithm=secret_algorithm,\n        secret_parameters=secret_parameters,\n        private_key=private_key,\n        public_key=public_key,\n    )", "\n\ndef compute_kek(\n    algorithm: hashes.HashAlgorithm,\n    secret_algorithm: str,\n    secret_parameters: t.Optional[bytes],\n    private_key: bytes,\n    public_key: bytes,\n) -> bytes:\n    # Special thanks for Grzegorz Tworek (@0gtweet) and Micha\u0142 Grzegorzewski\n    # for providing access to CQDPAPINGPFXDecrypter.exe which contains the\n    # BCrypt* APIs Microsoft use to derive the KEK.\n\n    secret_hash_algorithm: hashes.HashAlgorithm\n    if secret_algorithm == \"DH\":\n        # p = FFCDHParameters.unpack(secret_parameters or b\"\")\n        # We can derive the shared secret based on the DH formula.\n        # s = y**x mod p\n        dh_pub_key = FFCDHKey.unpack(public_key)\n        shared_secret_int = pow(\n            dh_pub_key.public_key,\n            int.from_bytes(private_key, byteorder=\"big\"),\n            dh_pub_key.field_order,\n        )\n        shared_secret = shared_secret_int.to_bytes(dh_pub_key.key_length, byteorder=\"big\")\n        secret_hash_algorithm = hashes.SHA256()\n\n    elif secret_algorithm.startswith(\"ECDH_P\"):\n        ecdh_pub_key_info = ECDHKey.unpack(public_key)\n        curve, secret_hash_algorithm = ecdh_pub_key_info.curve_and_hash\n\n        ecdh_pub_key = ec.EllipticCurvePublicNumbers(ecdh_pub_key_info.x, ecdh_pub_key_info.y, curve).public_key()\n        ecdh_private = ec.derive_private_key(\n            int.from_bytes(private_key, byteorder=\"big\"),\n            curve,\n        )\n        shared_secret = ecdh_private.exchange(ec.ECDH(), ecdh_pub_key)\n\n    else:\n        raise NotImplementedError(f\"Unknown secret agreement algorithm '{secret_algorithm}'\")\n\n    # This part isn't documented but we use the key derivation algorithm\n    # SP 800-56A to derive the kek secret input value. On Windows this uses\n    # BCryptDeriveKey with the following parameters.\n    #   KDF_ALGORITHMID - SHA512\n    #   KDF_PARTYUINFO  - KDS public key\n    #   KDF_PARTYVINFO  - KDS service\n    # Each of these is just appended to the otherinfo value used in\n    # cryptography as the UTF-16-LE NULL terminated strings.\n    kek_context = \"KDS public key\\0\".encode(\"utf-16-le\")\n    secret = kdf_concat(\n        secret_hash_algorithm,\n        shared_secret,\n        algorithm_id=\"SHA512\\0\".encode(\"utf-16-le\"),\n        party_uinfo=kek_context,\n        party_vinfo=KDS_SERVICE_LABEL,\n        length=secret_hash_algorithm.digest_size,\n    )\n\n    return kdf(\n        algorithm,\n        secret,\n        KDS_SERVICE_LABEL,\n        kek_context,\n        32,\n    )", "\n\ndef compute_public_key(\n    secret_algorithm: str,\n    secret_parameters: t.Optional[bytes],\n    private_key: bytes,\n    peer_public_key: bytes,\n) -> bytes:\n    if secret_algorithm == \"DH\":\n        dh_pub_key = FFCDHKey.unpack(peer_public_key)\n\n        # We can derive our public key based on the DH formula.\n        # X = G**x mod p\n        my_pub_key = pow(\n            dh_pub_key.generator,\n            int.from_bytes(private_key, byteorder=\"big\"),\n            dh_pub_key.field_order,\n        )\n        return FFCDHKey(\n            dh_pub_key.key_length,\n            dh_pub_key.field_order,\n            dh_pub_key.generator,\n            my_pub_key,\n        ).pack()\n\n    elif secret_algorithm.startswith(\"ECDH_P\"):\n        ecdh_pub_key = ECDHKey.unpack(peer_public_key)\n        curve = ecdh_pub_key.curve_and_hash[0]\n\n        ecdh_private = ec.derive_private_key(\n            int.from_bytes(private_key, byteorder=\"big\"),\n            curve,\n        )\n        my_ecdh_pub_key = ecdh_private.public_key().public_numbers()\n\n        return ECDHKey(\n            ecdh_pub_key.curve_name,\n            ecdh_pub_key.key_length,\n            my_ecdh_pub_key.x,\n            my_ecdh_pub_key.y,\n        ).pack()\n\n    else:\n        raise NotImplementedError(f\"Unknown secret agreement algorithm '{secret_algorithm}'\")", ""]}
{"filename": "src/dpapi_ng/_dns.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport typing as t\n\nimport dns.asyncresolver\nimport dns.resolver\n", "import dns.resolver\n\n\nclass SrvRecord(t.NamedTuple):\n    target: str\n    port: int\n    weight: int\n    priority: int\n\n\ndef _get_highest_answer(\n    answer: dns.resolver.Answer,\n) -> SrvRecord:\n    answers: t.List[SrvRecord] = []\n    for a in answer:\n        answers.append(\n            SrvRecord(\n                # The trailing . causes errors on Windows and the SPN lookup.\n                target=str(a.target).rstrip(\".\"),\n                port=a.port,\n                weight=a.weight,\n                priority=a.priority,\n            )\n        )\n\n    # Sorts the array by lowest priority then highest weight.\n    return sorted(answers, key=lambda a: (a.priority, -a.weight))[0]", "\n\ndef _get_highest_answer(\n    answer: dns.resolver.Answer,\n) -> SrvRecord:\n    answers: t.List[SrvRecord] = []\n    for a in answer:\n        answers.append(\n            SrvRecord(\n                # The trailing . causes errors on Windows and the SPN lookup.\n                target=str(a.target).rstrip(\".\"),\n                port=a.port,\n                weight=a.weight,\n                priority=a.priority,\n            )\n        )\n\n    # Sorts the array by lowest priority then highest weight.\n    return sorted(answers, key=lambda a: (a.priority, -a.weight))[0]", "\n\nasync def async_lookup_dc(\n    domain_name: t.Optional[str] = None,\n) -> SrvRecord:\n    \"\"\"Lookup DC for domain name\n\n    Attempts to lookup LDAP server based on the domain name specified or the\n    system's search domain if available. This is done through an SRV lookup for\n    '_ldap._tcp.dc._msdcs.{domain_name}'.", "    system's search domain if available. This is done through an SRV lookup for\n    '_ldap._tcp.dc._msdcs.{domain_name}'.\n\n    Args:\n        domain_name: The domain to lookup the DC for.\n\n    Returns:\n        SrvRecord: The SRV record result.\n\n    Raises:", "\n    Raises:\n        dns.exception.DNSException: DNS lookup error.\n    \"\"\"\n\n    if domain_name:\n        record = f\"_ldap._tcp.dc._msdcs.{domain_name}\"\n    else:\n        record = f\"_ldap._tcp.dc._msdcs\"\n", "\n    answers = await dns.asyncresolver.resolve(record, \"SRV\", search=True)\n    return _get_highest_answer(answers)\n\n\ndef lookup_dc(\n    domain_name: t.Optional[str] = None,\n) -> SrvRecord:\n    \"\"\"Lookup DC for domain name\n\n    Attempts to lookup LDAP server based on the domain name specified or the\n    system's search domain if available. This is done through an SRV lookup for\n    '_ldap._tcp.dc._msdcs.{domain_name}'.\n\n    Args:\n        domain_name: The domain to lookup the DC for.\n\n    Returns:\n        SrvRecord: The SRV record result.\n\n    Raises:\n        dns.exception.DNSException: DNS lookup error.\n    \"\"\"\n\n    if domain_name:\n        record = f\"_ldap._tcp.dc._msdcs.{domain_name}\"\n    else:\n        record = f\"_ldap._tcp.dc._msdcs\"\n\n    answers = dns.resolver.resolve(record, \"SRV\", search=True)\n    return _get_highest_answer(answers)", ""]}
{"filename": "src/dpapi_ng/_client.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport time\nimport typing as t\nimport uuid\n\nfrom ._asn1 import ASN1Writer", "\nfrom ._asn1 import ASN1Writer\nfrom ._blob import DPAPINGBlob, ProtectionDescriptor\nfrom ._crypto import (\n    AlgorithmOID,\n    cek_decrypt,\n    cek_encrypt,\n    cek_generate,\n    content_decrypt,\n    content_encrypt,", "    content_decrypt,\n    content_encrypt,\n)\nfrom ._dns import async_lookup_dc, lookup_dc\nfrom ._epm import EPM, EptMap, EptMapResult, TCPFloor, build_tcpip_tower\nfrom ._gkdi import (\n    ISD_KEY,\n    FFCDHParameters,\n    GetKey,\n    GroupKeyEnvelope,", "    GetKey,\n    GroupKeyEnvelope,\n    KDFParameters,\n    compute_l1_key,\n    compute_l2_key,\n)\nfrom ._rpc import (\n    NDR,\n    NDR64,\n    BindAck,", "    NDR64,\n    BindAck,\n    CommandFlags,\n    CommandPContext,\n    ContextElement,\n    ContextResultCode,\n    Response,\n    VerificationTrailer,\n    async_create_rpc_connection,\n    bind_time_feature_negotiation,", "    async_create_rpc_connection,\n    bind_time_feature_negotiation,\n    create_rpc_connection,\n)\n\n_EPOCH_FILETIME = 116444736000000000  # 1970-01-01 as FILETIME\n\n_EPM_CONTEXTS = [\n    ContextElement(\n        context_id=0,", "    ContextElement(\n        context_id=0,\n        abstract_syntax=EPM,\n        transfer_syntaxes=[NDR64],\n    )\n]\n\n_ISD_KEY_CONTEXTS = [\n    ContextElement(\n        context_id=0,", "    ContextElement(\n        context_id=0,\n        abstract_syntax=ISD_KEY,\n        transfer_syntaxes=[NDR64],\n    ),\n    ContextElement(\n        context_id=1,\n        abstract_syntax=ISD_KEY,\n        transfer_syntaxes=[bind_time_feature_negotiation()],\n    ),", "        transfer_syntaxes=[bind_time_feature_negotiation()],\n    ),\n]\n\n_EPT_MAP_ISD_KEY = EptMap(\n    obj=None,\n    tower=build_tcpip_tower(\n        service=ISD_KEY,\n        data_rep=NDR,\n        port=135,", "        data_rep=NDR,\n        port=135,\n        addr=0,\n    ),\n    entry_handle=None,\n    max_towers=4,\n)\n\n_VERIFICATION_TRAILER = VerificationTrailer(\n    [", "_VERIFICATION_TRAILER = VerificationTrailer(\n    [\n        CommandPContext(\n            flags=CommandFlags.SEC_VT_COMMAND_END,\n            interface_id=ISD_KEY,\n            transfer_syntax=NDR64,\n        ),\n    ]\n)\n", ")\n\n\ndef _process_bind_result(\n    requested_contexts: t.List[ContextElement],\n    bind_ack: BindAck,\n    desired_context: int,\n) -> None:\n    accepted_ids = []\n    for idx, c in enumerate(bind_ack.results):\n        if c.result == ContextResultCode.ACCEPTANCE:\n            ctx = requested_contexts[idx]\n            accepted_ids.append(ctx.context_id)\n\n    if desired_context not in accepted_ids:\n        raise ValueError(\"Failed to bind to desired context\")\n\n    return", "\n\ndef _process_ept_map_result(\n    response: Response,\n) -> int:\n    map_response = EptMapResult.unpack(response.stub_data)\n    if map_response.status != 0:\n        raise ValueError(f\"Receive error during ept_map call 0x{map_response.status:08X}\")\n\n    for tower in map_response.towers:\n        for floor in tower:\n            if isinstance(floor, TCPFloor):\n                return floor.port\n\n    raise ValueError(\"Did not find expected TCP Port in ept_map response\")", "\n\ndef _process_get_key_result(\n    response: Response,\n) -> GroupKeyEnvelope:\n    pad_length = len(response.stub_data)\n    if response.sec_trailer and response.sec_trailer.pad_length:\n        pad_length -= response.sec_trailer.pad_length\n    raw_resp = response.stub_data[:pad_length]\n    return GetKey.unpack_response(raw_resp)", "\n\nasync def _async_get_key(\n    server: str,\n    target_sd: bytes,\n    root_key_id: t.Optional[uuid.UUID],\n    l0: int = -1,\n    l1: int = -1,\n    l2: int = -1,\n    username: t.Optional[str] = None,", "    l2: int = -1,\n    username: t.Optional[str] = None,\n    password: t.Optional[str] = None,\n    auth_protocol: str = \"negotiate\",\n) -> GroupKeyEnvelope:\n    rpc = await async_create_rpc_connection(server)\n    async with rpc:\n        context_id = _EPM_CONTEXTS[0].context_id\n        ack = await rpc.bind(contexts=_EPM_CONTEXTS)\n        _process_bind_result(_EPM_CONTEXTS, ack, context_id)", "        ack = await rpc.bind(contexts=_EPM_CONTEXTS)\n        _process_bind_result(_EPM_CONTEXTS, ack, context_id)\n\n        ept_map = _EPT_MAP_ISD_KEY\n        resp = await rpc.request(context_id, ept_map.opnum, ept_map.pack())\n        isd_key_port = _process_ept_map_result(resp)\n\n    rpc = await async_create_rpc_connection(\n        server,\n        isd_key_port,", "        server,\n        isd_key_port,\n        username=username,\n        password=password,\n        auth_protocol=auth_protocol,\n    )\n    async with rpc:\n        context_id = _ISD_KEY_CONTEXTS[0].context_id\n        ack = await rpc.bind(contexts=_ISD_KEY_CONTEXTS)\n        _process_bind_result(_ISD_KEY_CONTEXTS, ack, context_id)", "        ack = await rpc.bind(contexts=_ISD_KEY_CONTEXTS)\n        _process_bind_result(_ISD_KEY_CONTEXTS, ack, context_id)\n\n        get_key = GetKey(target_sd, root_key_id, l0, l1, l2)\n        resp = await rpc.request(\n            context_id,\n            get_key.opnum,\n            get_key.pack(),\n            verification_trailer=_VERIFICATION_TRAILER,\n        )", "            verification_trailer=_VERIFICATION_TRAILER,\n        )\n        return _process_get_key_result(resp)\n\n\ndef _sync_get_key(\n    server: str,\n    target_sd: bytes,\n    root_key_id: t.Optional[uuid.UUID] = None,\n    l0: int = -1,\n    l1: int = -1,\n    l2: int = -1,\n    username: t.Optional[str] = None,\n    password: t.Optional[str] = None,\n    auth_protocol: str = \"negotiate\",\n) -> GroupKeyEnvelope:\n    with create_rpc_connection(server) as rpc:\n        context_id = _EPM_CONTEXTS[0].context_id\n        ack = rpc.bind(contexts=_EPM_CONTEXTS)\n        _process_bind_result(_EPM_CONTEXTS, ack, context_id)\n\n        ept_map = _EPT_MAP_ISD_KEY\n        resp = rpc.request(0, ept_map.opnum, ept_map.pack())\n        isd_key_port = _process_ept_map_result(resp)\n\n    with create_rpc_connection(\n        server,\n        isd_key_port,\n        username=username,\n        password=password,\n        auth_protocol=auth_protocol,\n    ) as rpc:\n        context_id = _ISD_KEY_CONTEXTS[0].context_id\n        ack = rpc.bind(contexts=_ISD_KEY_CONTEXTS)\n        _process_bind_result(_ISD_KEY_CONTEXTS, ack, context_id)\n\n        get_key = GetKey(target_sd, root_key_id, l0, l1, l2)\n        resp = rpc.request(\n            context_id,\n            get_key.opnum,\n            get_key.pack(),\n            verification_trailer=_VERIFICATION_TRAILER,\n        )\n        return _process_get_key_result(resp)", "\n\ndef _decrypt_blob(\n    blob: DPAPINGBlob,\n    key: GroupKeyEnvelope,\n) -> bytes:\n    kek = key.get_kek(blob.key_identifier)\n\n    # With the kek we can unwrap the encrypted cek in the LAPS payload.\n    cek = cek_decrypt(\n        blob.enc_cek_algorithm,\n        blob.enc_cek_parameters,\n        kek,\n        blob.enc_cek,\n    )\n\n    # With the cek we can decrypt the encrypted content in the LAPS payload.\n    return content_decrypt(\n        blob.enc_content_algorithm,\n        blob.enc_content_parameters,\n        cek,\n        blob.enc_content,\n    )", "\n\ndef _encrypt_blob(\n    blob: bytes,\n    key: GroupKeyEnvelope,\n    protection_descriptor: ProtectionDescriptor,\n) -> bytes:\n    # Generate cek and encrypt our payload.\n    enc_cek_algorithm = AlgorithmOID.AES256_WRAP\n    cek, cek_iv = cek_generate(enc_cek_algorithm)\n\n    parameters_writer = ASN1Writer()\n    with parameters_writer.push_sequence() as parameters:\n        parameters.write_octet_string(cek_iv)\n        parameters.write_integer(16)\n\n    enc_content_algorithm = AlgorithmOID.AES256_GCM\n    enc_content_parameters = parameters_writer.get_data()\n    enc_content = content_encrypt(\n        enc_content_algorithm,\n        enc_content_parameters,\n        cek,\n        blob,\n    )\n\n    kek, key_identifier = key.new_kek()\n    enc_cek_parameters = None\n    enc_cek = cek_encrypt(\n        enc_cek_algorithm,\n        enc_cek_parameters,\n        kek,\n        cek,\n    )\n\n    return DPAPINGBlob(\n        key_identifier=key_identifier,\n        protection_descriptor=protection_descriptor,\n        enc_cek=enc_cek,\n        enc_cek_algorithm=enc_cek_algorithm,\n        enc_cek_parameters=enc_cek_parameters,\n        enc_content=enc_content,\n        enc_content_algorithm=enc_content_algorithm,\n        enc_content_parameters=enc_content_parameters,\n    ).pack()", "\n\ndef _get_protection_gke_from_cache(\n    root_key_identifier: t.Optional[uuid.UUID],\n    target_sd: bytes,\n    cache: KeyCache,\n) -> t.Optional[GroupKeyEnvelope]:\n    if not root_key_identifier:\n        return None\n\n    # MS-GKDI 3.1.4.1 GetKey rules on how to generate the group key identifier\n    # values from the current time\n    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/4cac87a3-521e-4918-a272-240f8fabed39\n    current_time = (time.time_ns() // 100) + _EPOCH_FILETIME\n    base = 360000000000  # 3.6 * 10**11\n    l0 = int(current_time / (32 * 32 * base))\n    l1 = int((current_time % (32 * 32 * base)) / (32 * base))\n    l2 = int((current_time % (32 * base)) / base)\n\n    rk = cache._get_key(\n        target_sd,\n        root_key_identifier,\n        l0,\n        l1,\n        l2,\n    )\n    if not rk:\n        return None\n\n    kdf_parameters = KDFParameters.unpack(rk.kdf_parameters)\n    l2_key = compute_l2_key(\n        kdf_parameters.hash_algorithm,\n        l1,\n        l2,\n        rk,\n    )\n\n    return GroupKeyEnvelope(\n        version=rk.version,\n        flags=rk.flags,\n        l0=l0,\n        l1=l1,\n        l2=l2,\n        root_key_identifier=root_key_identifier,\n        kdf_algorithm=rk.kdf_algorithm,\n        kdf_parameters=rk.kdf_parameters,\n        secret_algorithm=rk.secret_algorithm,\n        secret_parameters=rk.secret_parameters,\n        private_key_length=rk.private_key_length,\n        public_key_length=rk.public_key_length,\n        domain_name=rk.domain_name,\n        forest_name=rk.forest_name,\n        l1_key=b\"\",\n        l2_key=l2_key,\n    )", "\n\nclass RootKey(t.NamedTuple):\n    \"\"\"The KDS Root Key.\"\"\"\n\n    key: bytes\n    version: int\n    kdf_algorithm: str\n    kdf_parameters: bytes\n    secret_algorithm: str\n    secret_parameters: t.Optional[bytes]\n    private_key_length: int\n    public_key_length: int", "\n\nclass KeyCache:\n    \"\"\"Key Cache.\n\n    This is a cache used to store the KDS keys. It can be used with\n    :meth:`async_ncrypt_unprotect_secret` and :meth:`ncrypt_unprotect_secret`\n    to avoid any extra RPC calls if the data was already retrieved.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._root_keys: t.Dict[uuid.UUID, RootKey] = {}\n        self._seed_keys: t.Dict[uuid.UUID, t.Dict[bytes, t.Dict[int, GroupKeyEnvelope]]] = {}\n\n    def load_key(\n        self,\n        key: bytes,\n        root_key_id: uuid.UUID,\n        version: int = 1,\n        kdf_algorithm: str = \"SP800_108_CTR_HMAC\",\n        kdf_parameters: t.Optional[bytes] = None,\n        secret_algorithm: str = \"DH\",\n        secret_parameters: t.Optional[bytes] = None,\n        private_key_length: int = 512,\n        public_key_length: int = 2048,\n    ) -> None:\n        \"\"\"Load a KDS root key into the cache.\n\n        This loads the KDS root key provided into the cache for use in future\n        operations.\n\n        A domain administrator can retrieve the required information from a DC\n        using this PowerShell code.\n\n        .. code-block:: powershell\n\n            $configurationContext = (Get-ADRootDSE).configurationNamingContext\n            $getParams = @{\n                LDAPFilter = '(objectClass=msKds-ProvRootKey)'\n                SearchBase = \"CN=Master Root Keys,CN=Group Key Distribution Service,CN=Services,$configurationContext\"\n                SearchScope = 'OneLevel'\n                Properties = @(\n                    'cn'\n                    'msKds-KDFAlgorithmID'\n                    'msKds-KDFParam'\n                    'msKds-SecretAgreementAlgorithmID'\n                    'msKds-SecretAgreementParam'\n                    'msKds-PrivateKeyLength'\n                    'msKds-PublicKeyLength'\n                    'msKds-RootKeyData'\n                )\n            }\n            Get-ADObject @getParams | ForEach-Object {\n                [PSCustomObject]@{\n                    Version = 1\n                    RootKeyId = [Guid]::new($_.cn)\n                    KdfAlgorithm = $_.'msKds-KDFAlgorithmID'\n                    KdfParameters = [System.Convert]::ToBase64String($_.'msKds-KDFParam')\n                    SecretAgreementAlgorithm = $_.'msKds-SecretAgreementAlgorithmID'\n                    SecretAgreementParameters = [System.Convert]::ToBase64String($_.'msKds-SecretAgreementParam')\n                    PrivateKeyLength = $_.'msKds-PrivateKeyLength'\n                    PublicKeyLength = $_.'msKds-PublicKeyLength'\n                    RootKeyData = [System.Convert]::ToBase64String($_.'msKds-RootKeyData')\n                }\n            }\n\n        It can also be retrieved using this OpenLDAP command:\n\n        .. code-block:: bash\n\n            ldapsearch \\\n                -b 'CN=Master Root Keys,CN=Group Key Distribution Service,CN=Services,CN=Configuration,DC=domain,DC=test' \\\n                -s one \\\n                '(objectClass=msKds-ProvRootKey)' \\\n                cn \\\n                msKds-KDFAlgorithmID \\\n                msKds-KDFParam \\\n                msKds-SecretAgreementAlgorithmID \\\n                msKds-SecretAgreementParam \\\n                msKds-PrivateKeyLength \\\n                msKds-PublicKeyLength \\\n                msKds-RootKeyData\n\n        Args:\n            key: The root key bytes stored in ``msKds-RootKeyData``.\n            root_key_id: The root key id as stored in ``cn``.\n            version: The key version number.\n            kdf_algorithm: The KDF algorithm name stored in\n                ``msKds-KDFAlgorithmID``.\n            kdf_parameters: The KDF parameters stored in ``msKds-KDFParam`.\n            secret_algorithm: The secret agreement algorithm stored in\n                ``msKds-SecretAgreementAlgorithmID``.\n            secret_parameters: The secret agreement parameters stored in\n                ``msKds-SecretAgreementParam``.\n            private_key_length: The private key length stored in\n                ``msKds-PrivateKeyLength``.\n            public_key_length: The public key length stored in\n                ``msKds-PublicKeyLength``.\n        \"\"\"\n        if not kdf_parameters:\n            kdf_parameters = KDFParameters(\"SHA512\").pack()\n\n        if secret_algorithm == \"DH\" and not secret_parameters:\n            # RFC 5114 - 2.3. 2048-bit MODP Group with 256-bit Prime Order Subgroup\n            # https://www.rfc-editor.org/rfc/rfc5114#section-2.3\n            secret_parameters = FFCDHParameters(\n                key_length=256,\n                field_order=17125458317614137930196041979257577826408832324037508573393292981642667139747621778802438775238728592968344613589379932348475613503476932163166973813218698343816463289144185362912602522540494983090531497232965829536524507269848825658311420299335922295709743267508322525966773950394919257576842038771632742044142471053509850123605883815857162666917775193496157372656195558305727009891276006514000409365877218171388319923896309377791762590614311849642961380224851940460421710449368927252974870395873936387909672274883295377481008150475878590270591798350563488168080923804611822387520198054002990623911454389104774092183,\n                generator=8041367327046189302693984665026706374844608289874374425728797669509435881459140662650215832833471328470334064628508692231999401840332046192569287351991689963279656892562484773278584208040987631569628520464069532361274047374444344996651832979378318849943741662110395995778429270819222431610927356005913836932462099770076239554042855287138026806960470277326229482818003962004453764400995790974042663675692120758726145869061236443893509136147942414445551848162391468541444355707785697825741856849161233887307017428371823608125699892904960841221593344499088996021883972185241854777608212592397013510086894908468466292313,\n            ).pack()\n\n        self._root_keys[root_key_id] = RootKey(\n            key=key,\n            version=version,\n            kdf_algorithm=kdf_algorithm,\n            kdf_parameters=kdf_parameters,\n            secret_algorithm=secret_algorithm,\n            secret_parameters=secret_parameters,\n            private_key_length=private_key_length,\n            public_key_length=public_key_length,\n        )\n\n    def _get_key(\n        self,\n        target_sd: bytes,\n        root_key_id: uuid.UUID,\n        l0: int,\n        l1: int,\n        l2: int,\n    ) -> t.Optional[GroupKeyEnvelope]:\n        \"\"\"Get key from the cache.\n\n        Attempts to get the key from a cache if it's available. A key is cached\n        either from the root key stored in :meth:`load_key` or from a previous\n        RPC call for the same target sd and root key id.\n\n        Args:\n            target_sd: The target security descriptor the key is for.\n            root_key_id: The root key id requested.\n            l0: The L0 index needed.\n            l1: The L1 index needed.\n            l2: The L2 index needed.\n\n        Returns:\n            Optional[GroupKeyEnvelope]: The cached key if one was available.\n        \"\"\"\n        seed_key = self._seed_keys.setdefault(root_key_id, {}).setdefault(target_sd, {}).get(l0, None)\n        if seed_key and (seed_key.l1 > l1 or (seed_key.l1 == l1 and seed_key.l2 >= l2)):\n            return seed_key\n\n        root_key = self._root_keys.get(root_key_id, None)\n        if root_key:\n            l1_seed = compute_l1_key(\n                target_sd,\n                root_key_id,\n                l0,\n                root_key.key,\n                KDFParameters.unpack(root_key.kdf_parameters).hash_algorithm,\n            )\n\n            gke = GroupKeyEnvelope(\n                version=root_key.version,\n                flags=2,\n                l0=l0,\n                l1=31,\n                l2=31,\n                root_key_identifier=root_key_id,\n                kdf_algorithm=root_key.kdf_algorithm,\n                kdf_parameters=root_key.kdf_parameters,\n                secret_algorithm=root_key.secret_algorithm,\n                secret_parameters=root_key.secret_parameters or b\"\",\n                private_key_length=root_key.private_key_length,\n                public_key_length=root_key.public_key_length,\n                domain_name=\"\",\n                forest_name=\"\",\n                l1_key=l1_seed,\n                l2_key=b\"\",\n            )\n            return self._seed_keys.setdefault(root_key_id, {}).setdefault(target_sd, {}).setdefault(l0, gke)\n\n        return None\n\n    def _store_key(\n        self,\n        target_sd: bytes,\n        key: GroupKeyEnvelope,\n    ) -> None:\n        seed_key = self._seed_keys.setdefault(key.root_key_identifier, {}).setdefault(target_sd, {})\n\n        existing = seed_key.get(key.l0, None)\n        if not existing or key.l1 > existing.l1 or (key.l1 == existing.l1 and key.l2 > existing.l2):\n            seed_key[key.l0] = key", "\n\ndef ncrypt_unprotect_secret(\n    data: bytes,\n    server: t.Optional[str] = None,\n    username: t.Optional[str] = None,\n    password: t.Optional[str] = None,\n    auth_protocol: str = \"negotiate\",\n    cache: t.Optional[KeyCache] = None,\n) -> bytes:\n    \"\"\"Decrypt DPAPI-NG Blob.\n\n    Decrypts the DPAPI-NG blob provided. This is meant to replicate the Win32\n    API `NCryptUnprotectSecret`_.\n\n    Decrypting the DPAPI-NG blob requires making an RPC call to the domain\n    controller for the domain the blob was created in. It will attempt this\n    by looking up the DC through an SRV lookup but ``server`` can be specified\n    to avoid this SRV lookup.\n\n    The RPC call requires the caller to authenticate before the key information\n    is provided. This user must be one who is authorized to decrypt the secret.\n    Explicit credentials can be specified, if none are the current Kerberos\n    ticket retrieved by ``kinit`` will be used instead. Make sure to install\n    the Kerberos extras package ``dpapi-ng[kerberos]`` to ensure Kerberos auth\n    can be used.\n\n    Args:\n        data: The DPAPI-NG blob to decrypt.\n        server: The domain controller to lookup the root key info.\n        username: The username to decrypt the DPAPI-NG blob as.\n        password: The password for the user.\n        auth_protocol: The authentication protocol to use, defaults to\n            ``negotiate`` but can be ``kerberos`` or ``ntlm``.\n        cache: Optional cache that is used as the key source to avoid making\n            the RPC call.\n\n    Returns:\n        bytes: The decrypt DPAPI-NG data.\n\n    Raises:\n        ValueError: An invalid data structure was found.\n        NotImplementedError: An unknown value was found and has not been\n            implemented yet.\n\n    _NCryptUnprotectSecret:\n        https://learn.microsoft.com/en-us/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptunprotectsecret\n    \"\"\"\n    blob = DPAPINGBlob.unpack(data)\n    target_sd = blob.protection_descriptor.get_target_sd()\n\n    cache = cache or KeyCache()\n    rk = cache._get_key(\n        target_sd,\n        blob.key_identifier.root_key_identifier,\n        blob.key_identifier.l0,\n        blob.key_identifier.l1,\n        blob.key_identifier.l2,\n    )\n\n    if not rk:\n        if not server:\n            srv = lookup_dc(blob.key_identifier.domain_name)\n            server = srv.target\n\n        rk = _sync_get_key(\n            server,\n            target_sd,\n            blob.key_identifier.root_key_identifier,\n            blob.key_identifier.l0,\n            blob.key_identifier.l1,\n            blob.key_identifier.l2,\n            username=username,\n            password=password,\n            auth_protocol=auth_protocol,\n        )\n\n    if not rk.is_public_key:\n        cache._store_key(target_sd, rk)\n\n    return _decrypt_blob(blob, rk)", "\n\ndef ncrypt_protect_secret(\n    data: bytes,\n    protection_descriptor: str,\n    root_key_identifier: t.Optional[uuid.UUID] = None,\n    server: t.Optional[str] = None,\n    domain_name: t.Optional[str] = None,\n    username: t.Optional[str] = None,\n    password: t.Optional[str] = None,\n    auth_protocol: str = \"negotiate\",\n    cache: t.Optional[KeyCache] = None,\n) -> bytes:\n    \"\"\"Encrypt DPAPI-NG Blob.\n\n    Encrypts the blob provided as DPAPI-NG Blob. This is meant to\n    replicate the Win32 API `NCryptProtectSecret`_. While NCryptProtectSecret\n    supports multiple protection descriptor values, currently only the SID type\n    is supported.\n\n    Encrypting the DPAPI-NG blob requires making an RPC call to the domain\n    controller for the domain the blob was created in. It will attempt this\n    by looking up the DC through an SRV lookup but ``server`` can be specified\n    to avoid this SRV lookup.\n\n    The RPC call requires the caller to authenticate before the key information\n    is provided. Explicit credentials can be specified, if none are then the\n    current Kerberos ticket retrieved by ``kinit`` will be used instead. Make\n    sure to install the Kerberos extras package ``dpapi-ng[kerberos]`` to ensure\n    Kerberos auth can be used.\n\n    Args:\n        data: The bytes blob to encrypt.\n        protection_descriptor: The security identifier to protect the secret\n            with.\n        root_key_identifier: Use the root key identified by this id, if not set,\n            the root key id returned by the server will be used.\n        server: The domain controller to lookup the root key info.\n        domain_name: The domain name to query the domain controller hostname\n            via DNS.\n        username: The username to encrypt the DPAPI-NG blob as.\n        password: The password for the user.\n        auth_protocol: The authentication protocol to use, defaults to\n            ``negotiate`` but can be ``kerberos`` or ``ntlm``.\n        cache: Optional cache that is used as the key source to avoid making\n            the RPC call. This only works if root_key_identifier is also\n            specified.\n\n    Returns:\n        bytes: The encrypted DPAPI-NG data.\n\n    Raises:\n        ValueError: An invalid data structure was found.\n        NotImplementedError: An unknown value was found and has not been\n            implemented yet.\n\n    _NCryptProtectSecret:\n        https://learn.microsoft.com/en-us/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptprotectsecret\n    \"\"\"\n    l0 = -1\n    l1 = -1\n    l2 = -1\n\n    descriptor = ProtectionDescriptor.parse(protection_descriptor)\n    sd = descriptor.get_target_sd()\n\n    cache = cache or KeyCache()\n    rk = _get_protection_gke_from_cache(root_key_identifier, sd, cache)\n\n    if not rk:\n        if not server:\n            srv = lookup_dc(domain_name)\n            server = srv.target\n\n        rk = _sync_get_key(\n            server,\n            sd,\n            root_key_identifier,\n            l0,\n            l1,\n            l2,\n            username=username,\n            password=password,\n            auth_protocol=auth_protocol,\n        )\n\n    if not rk.is_public_key:\n        cache._store_key(sd, rk)\n\n    return _encrypt_blob(data, rk, descriptor)", "\n\nasync def async_ncrypt_unprotect_secret(\n    data: bytes,\n    server: t.Optional[str] = None,\n    username: t.Optional[str] = None,\n    password: t.Optional[str] = None,\n    auth_protocol: str = \"negotiate\",\n    cache: t.Optional[KeyCache] = None,\n) -> bytes:", "    cache: t.Optional[KeyCache] = None,\n) -> bytes:\n    \"\"\"Decrypt DPAPI-NG Blob.\n\n    Decrypts the DPAPI-NG blob provided. This is meant to replicate the Win32\n    API `NCryptUnprotectSecret`_.\n\n    Decrypting the DPAPI-NG blob requires making an RPC call to the domain\n    controller for the domain the blob was created in. It will attempt this\n    by looking up the DC through an SRV lookup but ``server`` can be specified", "    controller for the domain the blob was created in. It will attempt this\n    by looking up the DC through an SRV lookup but ``server`` can be specified\n    to avoid this SRV lookup.\n\n    The RPC call requires the caller to authenticate before the key information\n    is provided. This user must be one who is authorized to decrypt the secret.\n    Explicit credentials can be specified, if none are the current Kerberos\n    ticket retrieved by ``kinit`` will be used instead. Make sure to install\n    the Kerberos extras package ``dpapi-ng[kerberos]`` to ensure Kerberos auth\n    can be used.", "    the Kerberos extras package ``dpapi-ng[kerberos]`` to ensure Kerberos auth\n    can be used.\n\n    Args:\n        data: The DPAPI-NG blob to decrypt.\n        server: The domain controller to lookup the root key info.\n        username: The username to decrypt the DPAPI-NG blob as.\n        password: The password for the user.\n        auth_protocol: The authentication protocol to use, defaults to\n            ``negotiate`` but can be ``kerberos`` or ``ntlm``.", "        auth_protocol: The authentication protocol to use, defaults to\n            ``negotiate`` but can be ``kerberos`` or ``ntlm``.\n        cache: Optional cache that is used as the key source to avoid making\n            the RPC call.\n\n    Returns:\n        bytes: The decrypt DPAPI-NG data.\n\n    Raises:\n        ValueError: An invalid data structure was found.", "    Raises:\n        ValueError: An invalid data structure was found.\n        NotImplementedError: An unknown value was found and has not been\n            implemented yet.\n\n    _NCryptUnprotectSecret:\n        https://learn.microsoft.com/en-us/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptunprotectsecret\n    \"\"\"\n    blob = DPAPINGBlob.unpack(data)\n    target_sd = blob.protection_descriptor.get_target_sd()", "    blob = DPAPINGBlob.unpack(data)\n    target_sd = blob.protection_descriptor.get_target_sd()\n\n    cache = cache or KeyCache()\n    rk = cache._get_key(\n        target_sd,\n        blob.key_identifier.root_key_identifier,\n        blob.key_identifier.l0,\n        blob.key_identifier.l1,\n        blob.key_identifier.l2,", "        blob.key_identifier.l1,\n        blob.key_identifier.l2,\n    )\n    if not rk:\n        if not server:\n            srv = await async_lookup_dc(blob.key_identifier.domain_name)\n            server = srv.target\n\n        rk = await _async_get_key(\n            server,\n            target_sd,\n            blob.key_identifier.root_key_identifier,\n            blob.key_identifier.l0,\n            blob.key_identifier.l1,\n            blob.key_identifier.l2,\n            username=username,\n            password=password,\n            auth_protocol=auth_protocol,\n        )", "\n    if not rk.is_public_key:\n        cache._store_key(target_sd, rk)\n\n    return _decrypt_blob(blob, rk)\n\n\nasync def async_ncrypt_protect_secret(\n    data: bytes,\n    protection_descriptor: str,", "    data: bytes,\n    protection_descriptor: str,\n    root_key_identifier: t.Optional[uuid.UUID] = None,\n    server: t.Optional[str] = None,\n    domain_name: t.Optional[str] = None,\n    username: t.Optional[str] = None,\n    password: t.Optional[str] = None,\n    auth_protocol: str = \"negotiate\",\n    cache: t.Optional[KeyCache] = None,\n) -> bytes:", "    cache: t.Optional[KeyCache] = None,\n) -> bytes:\n    \"\"\"Encrypt DPAPI-NG Blob.\n\n    Encrypts the blob provided as DPAPI-NG Blob. This is meant to\n    replicate the Win32 API `NCryptProtectSecret`_. While NCryptProtectSecret\n    supports multiple protection descriptor values, currently only the SID type\n    is supported.\n\n    Encrypting the DPAPI-NG blob requires making an RPC call to the domain", "\n    Encrypting the DPAPI-NG blob requires making an RPC call to the domain\n    controller for the domain the blob was created in. It will attempt this\n    by looking up the DC through an SRV lookup but ``server`` can be specified\n    to avoid this SRV lookup.\n\n    The RPC call requires the caller to authenticate before the key information\n    is provided. Explicit credentials can be specified, if none are then the\n    current Kerberos ticket retrieved by ``kinit`` will be used instead. Make\n    sure to install the Kerberos extras package ``dpapi-ng[kerberos]`` to ensure", "    current Kerberos ticket retrieved by ``kinit`` will be used instead. Make\n    sure to install the Kerberos extras package ``dpapi-ng[kerberos]`` to ensure\n    Kerberos auth can be used.\n\n    Args:\n        data: The bytes blob to encrypt.\n        protection_descriptor: The security identifier to protect the secret\n            with.\n        root_key_identifier: Use the root key identified by this id, if not set,\n            the root key id returned by the server will be used.", "        root_key_identifier: Use the root key identified by this id, if not set,\n            the root key id returned by the server will be used.\n        server: The domain controller to lookup the root key info.\n        domain_name: The domain name to query the domain controller hostname\n            via DNS.\n        username: The username to encrypt the DPAPI-NG blob as.\n        password: The password for the user.\n        auth_protocol: The authentication protocol to use, defaults to\n            ``negotiate`` but can be ``kerberos`` or ``ntlm``.\n        cache: Optional cache that is used as the key source to avoid making", "            ``negotiate`` but can be ``kerberos`` or ``ntlm``.\n        cache: Optional cache that is used as the key source to avoid making\n            the RPC call. This only works if root_key_identifier is also\n            specified.\n\n    Returns:\n        bytes: The encrypted DPAPI-NG data.\n\n    Raises:\n        ValueError: An invalid data structure was found.", "    Raises:\n        ValueError: An invalid data structure was found.\n        NotImplementedError: An unknown value was found and has not been\n            implemented yet.\n\n    _NCryptProtectSecret:\n        https://learn.microsoft.com/en-us/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptprotectsecret\n    \"\"\"\n    l0 = -1\n    l1 = -1", "    l0 = -1\n    l1 = -1\n    l2 = -1\n\n    descriptor = ProtectionDescriptor.parse(protection_descriptor)\n    sd = descriptor.get_target_sd()\n\n    cache = cache or KeyCache()\n    rk = _get_protection_gke_from_cache(root_key_identifier, sd, cache)\n\n    if not rk:\n        if not server:\n            srv = await async_lookup_dc(domain_name)\n            server = srv.target\n\n        rk = await _async_get_key(\n            server,\n            sd,\n            root_key_identifier,\n            l0,\n            l1,\n            l2,\n            username=username,\n            password=password,\n            auth_protocol=auth_protocol,\n        )", "    rk = _get_protection_gke_from_cache(root_key_identifier, sd, cache)\n\n    if not rk:\n        if not server:\n            srv = await async_lookup_dc(domain_name)\n            server = srv.target\n\n        rk = await _async_get_key(\n            server,\n            sd,\n            root_key_identifier,\n            l0,\n            l1,\n            l2,\n            username=username,\n            password=password,\n            auth_protocol=auth_protocol,\n        )", "\n    if not rk.is_public_key:\n        cache._store_key(sd, rk)\n\n    return _encrypt_blob(data, rk, descriptor)\n"]}
{"filename": "src/dpapi_ng/_pkcs7.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport dataclasses\nimport typing as t\n\nfrom ._asn1 import ASN1Header, ASN1Reader, ASN1Tag, ASN1Writer, TagClass, TypeTagNumber\n", "from ._asn1 import ASN1Header, ASN1Reader, ASN1Tag, ASN1Writer, TagClass, TypeTagNumber\n\n\n@dataclasses.dataclass\nclass ContentInfo:\n    content_type: str\n    content: bytes\n\n    # https://www.rfc-editor.org/rfc/rfc5652#section-3\n    #   ContentInfo ::= SEQUENCE {\n    #     contentType ContentType,\n    #     content [0] EXPLICIT ANY DEFINED BY contentType }\n\n    #   ContentType ::= OBJECT IDENTIFIER\n\n    def pack(\n        self,\n        writer: ASN1Writer,\n    ) -> None:\n        with writer.push_sequence() as ci_sequence:\n            ci_sequence.write_object_identifier(self.content_type)\n            ci_sequence.write_octet_string(\n                self.content,\n                ASN1Tag(\n                    tag_class=TagClass.CONTEXT_SPECIFIC,\n                    tag_number=0,\n                    is_constructed=True,\n                ),\n            )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n        header: t.Optional[ASN1Header] = None,\n    ) -> ContentInfo:\n        reader = ASN1Reader(data).read_sequence(header=header)\n        content_type = reader.read_object_identifier(\n            hint=\"ContentInfo.contentType\",\n        )\n\n        content_tag = ASN1Tag(\n            tag_class=TagClass.CONTEXT_SPECIFIC,\n            tag_number=0,\n            is_constructed=True,\n        )\n        content = reader.read_octet_string(\n            tag=content_tag,\n            hint=\"ContentInfo.content\",\n        )\n\n        return ContentInfo(content_type, content)", "\n\n@dataclasses.dataclass\nclass EnvelopedData:\n    CONTENT_TYPE_ENVELOPED_DATA_OID = \"1.2.840.113549.1.7.3\"\n    CONTENT_TYPE_DATA_OID = \"1.2.840.113549.1.7.1\"\n\n    version: int\n    recipient_infos: t.List[RecipientInfo]\n    encrypted_content_info: EncryptedContentInfo\n\n    # https://www.rfc-editor.org/rfc/rfc5652#section-6.1\n    #   EnvelopedData ::= SEQUENCE {\n    #     version CMSVersion,\n    #     originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,\n    #     recipientInfos RecipientInfos,\n    #     encryptedContentInfo EncryptedContentInfo,\n    #     unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }\n\n    #   OriginatorInfo ::= SEQUENCE {\n    #     certs [0] IMPLICIT CertificateSet OPTIONAL,\n    #     crls [1] IMPLICIT RevocationInfoChoices OPTIONAL }\n\n    #   RecipientInfos ::= SET SIZE (1..MAX) OF RecipientInfo\n\n    #   EncryptedContentInfo ::= SEQUENCE {\n    #     contentType ContentType,\n    #     contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,\n    #     encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL }\n\n    #   EncryptedContent ::= OCTET STRING\n\n    #   UnprotectedAttributes ::= SET SIZE (1..MAX) OF Attribute\n\n    def pack(\n        self,\n        writer: ASN1Writer,\n    ) -> None:\n        with writer.push_sequence() as w:\n            w.write_integer(self.version)\n\n            with w.push_set_of() as recipient_writer:\n                for ri in self.recipient_infos:\n                    ri.pack(recipient_writer)\n\n            self.encrypted_content_info.pack(w)\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> EnvelopedData:\n        reader = ASN1Reader(data).read_sequence()\n\n        version = reader.read_integer(hint=\"EnvelopedData.version\")\n        if version != 2:\n            raise NotImplementedError(\"Cannot unpack EnvelopedData that is not version 2\")\n\n        recipient_infos: t.List[RecipientInfo] = []\n        recipient_infos_reader = reader.read_set_of(hint=\"EnvelopedData.recipientInfos\")\n        while recipient_infos_reader:\n            info = RecipientInfo.unpack(recipient_infos_reader)\n            recipient_infos.append(info)\n\n        enc_content = EncryptedContentInfo.unpack(reader)\n\n        return EnvelopedData(\n            version=version,\n            recipient_infos=recipient_infos,\n            encrypted_content_info=enc_content,\n        )", "\n\n@dataclasses.dataclass\nclass RecipientInfo:\n    choice: int\n\n    # https://www.rfc-editor.org/rfc/rfc5652#section-6.2\n    # RecipientInfo ::= CHOICE {\n    #     ktri KeyTransRecipientInfo,\n    #     kari [1] KeyAgreeRecipientInfo,\n    #     kekri [2] KEKRecipientInfo,\n    #     pwri [3] PasswordRecipientinfo,\n    #     ori [4] OtherRecipientInfo }\n\n    def pack(\n        self,\n        writer: ASN1Writer,\n    ) -> None:\n        raise NotImplementedError()  # pragma: nocover\n\n    @classmethod\n    def unpack(\n        cls,\n        reader: ASN1Reader,\n    ) -> RecipientInfo:\n        header = reader.peek_header()\n        tag = header.tag\n\n        if tag.tag_class == TagClass.CONTEXT_SPECIFIC and tag.tag_number == KEKRecipientInfo.choice:\n            return KEKRecipientInfo.unpack(reader, header=header)\n\n        raise NotImplementedError(f\"Unimplemented RecipientInfo choice {tag}\")", "\n\n@dataclasses.dataclass\nclass KEKRecipientInfo(RecipientInfo):\n    choice: int = dataclasses.field(init=False, repr=False, default=2)\n\n    version: int\n    kekid: KEKIdentifier\n    key_encryption_algorithm: AlgorithmIdentifier\n    encrypted_key: bytes\n\n    # https://www.rfc-editor.org/rfc/rfc5652#section-6.2.3\n    # KEKRecipientInfo ::= SEQUENCE {\n    #     version CMSVersion,  -- always set to 4\n    #     kekid KEKIdentifier,\n    #     keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,\n    #     encryptedKey EncryptedKey }\n\n    def pack(\n        self,\n        writer: ASN1Writer,\n    ) -> None:\n        with writer.push_sequence(\n            tag=ASN1Tag(\n                tag_class=TagClass.CONTEXT_SPECIFIC,\n                tag_number=self.choice,\n                is_constructed=True,\n            )\n        ) as w:\n            w.write_integer(self.version)\n            self.kekid.pack(w)\n            self.key_encryption_algorithm.pack(w)\n            w.write_octet_string(self.encrypted_key)\n\n    @classmethod\n    def unpack(\n        cls,\n        reader: ASN1Reader,\n        header: t.Optional[ASN1Header] = None,\n    ) -> KEKRecipientInfo:\n        reader = reader.read_sequence(header=header)\n\n        version = reader.read_integer(hint=\"KEKRecipientInfo.version\")\n        kekid = KEKIdentifier.unpack(reader)\n        key_encryption_algorithm = AlgorithmIdentifier.unpack(reader)\n        encrypted_key = reader.read_octet_string(hint=\"KEKRecipientInfo.encryptedKey\")\n\n        return KEKRecipientInfo(\n            version=version,\n            kekid=kekid,\n            key_encryption_algorithm=key_encryption_algorithm,\n            encrypted_key=encrypted_key,\n        )", "\n\n@dataclasses.dataclass\nclass KEKIdentifier:\n    key_identifier: bytes\n    date: t.Optional[str] = None\n    other: t.Optional[OtherKeyAttribute] = None\n\n    # https://www.rfc-editor.org/rfc/rfc5652#section-6.2.3\n    # KEKIdentifier ::= SEQUENCE {\n    #     keyIdentifier OCTET STRING,\n    #     date GeneralizedTime OPTIONAL,\n    #     other OtherKeyAttribute OPTIONAL }\n\n    def pack(\n        self,\n        writer: ASN1Writer,\n    ) -> None:\n        with writer.push_sequence() as w:\n            w.write_octet_string(self.key_identifier)\n\n            if self.date:\n                w.write_generalized_time(self.date)\n\n            if self.other:\n                self.other.pack(w)\n\n    @classmethod\n    def unpack(\n        cls,\n        reader: ASN1Reader,\n    ) -> KEKIdentifier:\n        reader = reader.read_sequence()\n\n        key_identifier = reader.read_octet_string(hint=\"KEKIdentifier.keyIdentifier\")\n        header = reader.peek_header()\n\n        date = None\n        if header.tag.tag_class == TagClass.UNIVERSAL and header.tag.tag_number == TypeTagNumber.GENERALIZED_TIME:\n            date = reader.read_generalized_time(header=header, hint=\"KEKIdentifier.date\")\n            header = reader.peek_header()\n\n        other = None\n        if header.tag.tag_class == TagClass.UNIVERSAL and header.tag.tag_number == TypeTagNumber.SEQUENCE:\n            other = OtherKeyAttribute.unpack(reader, header=header)\n\n        return KEKIdentifier(\n            key_identifier=key_identifier,\n            date=date,\n            other=other,\n        )", "\n\n@dataclasses.dataclass\nclass OtherKeyAttribute:\n    key_attr_id: str\n    key_attr: t.Optional[bytes]\n\n    # https://www.rfc-editor.org/rfc/rfc5652#section-10.2.7\n    # OtherKeyAttribute ::= SEQUENCE {\n    #     keyAttrId OBJECT IDENTIFIER,\n    #     keyAttr ANY DEFINED BY keyAttrId OPTIONAL }\n\n    def pack(\n        self,\n        writer: ASN1Writer,\n    ) -> None:\n        with writer.push_sequence() as w:\n            w.write_object_identifier(self.key_attr_id)\n            if self.key_attr:\n                w.write_raw(self.key_attr)\n\n    @classmethod\n    def unpack(\n        cls,\n        reader: ASN1Reader,\n        header: t.Optional[ASN1Header] = None,\n    ) -> OtherKeyAttribute:\n        reader = reader.read_sequence(header=header)\n\n        key_attr_id = reader.read_object_identifier(hint=\"OtherKeyAttribute.keyAttrId\")\n        key_attr = None\n        if reader:\n            key_attr = reader.get_remaining_data()\n\n        return OtherKeyAttribute(\n            key_attr_id=key_attr_id,\n            key_attr=key_attr,\n        )", "\n\n@dataclasses.dataclass\nclass EncryptedContentInfo:\n    content_type: str\n    algorithm: AlgorithmIdentifier\n    content: t.Optional[bytes]\n\n    # EncryptedContentInfo ::= SEQUENCE {\n    #     contentType ContentType,\n    #     contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,\n    #     encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL }\n\n    # ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\n\n    def pack(\n        self,\n        writer: ASN1Writer,\n    ) -> None:\n        with writer.push_sequence() as w:\n            w.write_object_identifier(self.content_type)\n            self.algorithm.pack(w)\n\n            if self.content:\n                w.write_octet_string(\n                    self.content,\n                    ASN1Tag(\n                        tag_class=TagClass.CONTEXT_SPECIFIC,\n                        tag_number=0,\n                        is_constructed=False,\n                    ),\n                )\n\n    @classmethod\n    def unpack(\n        cls,\n        reader: ASN1Reader,\n    ) -> EncryptedContentInfo:\n        reader = reader.read_sequence()\n\n        content_type = reader.read_object_identifier(hint=\"EncryptedContentInfo.contentType\")\n        content_encryption_algorithm = AlgorithmIdentifier.unpack(reader)\n        enc_content = None\n        if reader:\n            enc_tag = ASN1Tag(\n                tag_class=TagClass.CONTEXT_SPECIFIC,\n                tag_number=0,\n                is_constructed=False,\n            )\n            enc_content = reader.read_octet_string(\n                enc_tag,\n                hint=\"EncryptedContentInfo.encryptedContent\",\n            )\n\n        return EncryptedContentInfo(\n            content_type=content_type,\n            algorithm=content_encryption_algorithm,\n            content=enc_content,\n        )", "\n\n@dataclasses.dataclass\nclass AlgorithmIdentifier:\n    algorithm: str\n    parameters: t.Optional[bytes] = None\n\n    # AlgorithmIdentifier ::= SEQUENCE {\n    #   algorithm       OBJECT IDENTIFIER,\n    #   parameters      ANY DEFINED BY algorithm OPTIONAL\n    # }\n\n    def pack(\n        self,\n        writer: ASN1Writer,\n    ) -> None:\n        with writer.push_sequence() as w:\n            w.write_object_identifier(self.algorithm)\n            if self.parameters:\n                w.write_raw(self.parameters)\n\n    @classmethod\n    def unpack(\n        cls,\n        reader: ASN1Reader,\n    ) -> AlgorithmIdentifier:\n        reader = reader.read_sequence()\n\n        algorithm = reader.read_object_identifier()\n        parameters = None\n        if reader:\n            parameters = reader.get_remaining_data()\n\n        return AlgorithmIdentifier(\n            algorithm=algorithm,\n            parameters=parameters,\n        )", ""]}
{"filename": "src/dpapi_ng/_rpc/_verification.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport dataclasses\nimport enum\nimport typing as t\n\nfrom ._bind import SyntaxId", "\nfrom ._bind import SyntaxId\nfrom ._pdu import DataRep, PacketType\n\n# https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/0e9fea61-1bff-4478-9bfe-a3b6d8b64ac3\n\n\nclass CommandType(enum.IntEnum):\n    SEC_VT_COMMAND_BITMASK_1 = 0x0001\n    SEC_VT_COMMAND_PCONTEXT = 0x0002\n    SEC_VT_COMMAND_HEADER2 = 0x0003\n\n    @classmethod\n    def _missing_(cls, value: object) -> t.Optional[enum.Enum]:\n        new_member = int.__new__(cls)\n        new_member._name_ = f\"CommandType Unknown 0x{value:04X}\"\n        new_member._value_ = value  # type: ignore[assignment]\n        return cls._value2member_map_.setdefault(value, new_member)", "\n\nclass CommandFlags(enum.IntFlag):\n    NONE = 0x0000\n    SEC_VT_COMMAND_END = 0x4000\n    SEC_VT_MUST_PROCESS_COMMAND = 0x8000\n\n\n@dataclasses.dataclass(frozen=True)\nclass Command:\n    command: CommandType\n    flags: CommandFlags\n    value: bytes\n\n    def pack(self) -> bytes:\n        return b\"\".join(\n            [\n                (self.command.value | self.flags.value).to_bytes(2, byteorder=\"little\"),\n                len(self.value).to_bytes(2, byteorder=\"little\"),\n                self.value,\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> Command:\n        view = memoryview(data)\n\n        cmd_field = int.from_bytes(view[:2], byteorder=\"little\")\n        command_type = CommandType(cmd_field & 0x3FFF)\n        command_flags = CommandFlags(cmd_field & 0xC000)\n        command_length = int.from_bytes(view[2:4], byteorder=\"little\")\n        value = view[4 : 4 + command_length].tobytes()\n\n        unpack_func = _COMMAND_TYPE_REGISTRY.get(command_type, None)\n        if unpack_func:\n            cmd = unpack_func(command_flags, value)\n            object.__setattr__(cmd, \"value\", value)\n            return cmd\n\n        else:\n            return cls(command_type, command_flags, value)", "@dataclasses.dataclass(frozen=True)\nclass Command:\n    command: CommandType\n    flags: CommandFlags\n    value: bytes\n\n    def pack(self) -> bytes:\n        return b\"\".join(\n            [\n                (self.command.value | self.flags.value).to_bytes(2, byteorder=\"little\"),\n                len(self.value).to_bytes(2, byteorder=\"little\"),\n                self.value,\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> Command:\n        view = memoryview(data)\n\n        cmd_field = int.from_bytes(view[:2], byteorder=\"little\")\n        command_type = CommandType(cmd_field & 0x3FFF)\n        command_flags = CommandFlags(cmd_field & 0xC000)\n        command_length = int.from_bytes(view[2:4], byteorder=\"little\")\n        value = view[4 : 4 + command_length].tobytes()\n\n        unpack_func = _COMMAND_TYPE_REGISTRY.get(command_type, None)\n        if unpack_func:\n            cmd = unpack_func(command_flags, value)\n            object.__setattr__(cmd, \"value\", value)\n            return cmd\n\n        else:\n            return cls(command_type, command_flags, value)", "\n\nT = t.TypeVar(\"T\")\n_COMMAND_TYPE_REGISTRY: t.Dict[CommandType, t.Callable[[CommandFlags, bytes], Command]] = {}\n\n\ndef register_cmd(cls: T) -> T:\n    _COMMAND_TYPE_REGISTRY[getattr(cls, \"command\").default] = getattr(cls, \"_unpack\")\n    return cls\n", "\n\n@dataclasses.dataclass(frozen=True)\nclass _KnownCommand(Command):\n    value: bytes = dataclasses.field(init=False, repr=False, default=b\"\")\n\n\n@dataclasses.dataclass(frozen=True)\n@register_cmd\nclass CommandBitmask(_KnownCommand):\n    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/35d7781d-6c5b-46b2-9083-3d53f98bef0d\n    CLIENT_SUPPORT_HEADER_SIGNING: int = dataclasses.field(init=False, repr=False, default=0x00000001)\n\n    command: CommandType = dataclasses.field(init=False, default=CommandType.SEC_VT_COMMAND_BITMASK_1)\n    bits: int\n\n    def pack(self) -> bytes:\n        return Command(self.command, self.flags, self.bits.to_bytes(4, byteorder=\"little\")).pack()\n\n    @classmethod\n    def _unpack(\n        cls,\n        flags: CommandFlags,\n        value: bytes,\n    ) -> CommandBitmask:\n        return cls(\n            flags=flags,\n            bits=int.from_bytes(value, byteorder=\"little\"),\n        )", "@register_cmd\nclass CommandBitmask(_KnownCommand):\n    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/35d7781d-6c5b-46b2-9083-3d53f98bef0d\n    CLIENT_SUPPORT_HEADER_SIGNING: int = dataclasses.field(init=False, repr=False, default=0x00000001)\n\n    command: CommandType = dataclasses.field(init=False, default=CommandType.SEC_VT_COMMAND_BITMASK_1)\n    bits: int\n\n    def pack(self) -> bytes:\n        return Command(self.command, self.flags, self.bits.to_bytes(4, byteorder=\"little\")).pack()\n\n    @classmethod\n    def _unpack(\n        cls,\n        flags: CommandFlags,\n        value: bytes,\n    ) -> CommandBitmask:\n        return cls(\n            flags=flags,\n            bits=int.from_bytes(value, byteorder=\"little\"),\n        )", "\n\n@dataclasses.dataclass(frozen=True)\n@register_cmd\nclass CommandPContext(_KnownCommand):\n    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/41e3cf7a-3b42-470c-9d27-c4e047ac6445\n    command: CommandType = dataclasses.field(init=False, default=CommandType.SEC_VT_COMMAND_PCONTEXT)\n    interface_id: SyntaxId\n    transfer_syntax: SyntaxId\n\n    def pack(self) -> bytes:\n        value = self.interface_id.pack() + self.transfer_syntax.pack()\n        return Command(self.command, self.flags, value).pack()\n\n    @classmethod\n    def _unpack(\n        cls,\n        flags: CommandFlags,\n        value: bytes,\n    ) -> CommandPContext:\n        interface_id = SyntaxId.unpack(value)\n        transfer_syntax = SyntaxId.unpack(value[20:])\n        return cls(\n            flags=flags,\n            interface_id=interface_id,\n            transfer_syntax=transfer_syntax,\n        )", "\n\n@dataclasses.dataclass(frozen=True)\n@register_cmd\nclass CommandHeader2(_KnownCommand):\n    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/0a108fbd-c848-4755-9e15-6c4df1c35134\n    command: CommandType = dataclasses.field(init=False, default=CommandType.SEC_VT_COMMAND_HEADER2)\n    packet_type: PacketType\n    data_rep: DataRep\n    call_id: int\n    context_id: int\n    opnum: int\n\n    def pack(self) -> bytes:\n        value = b\"\".join(\n            [\n                self.packet_type.to_bytes(1, byteorder=\"little\"),\n                b\"\\x00\\x00\\x00\",  # Reserved\n                self.data_rep.pack(),\n                self.call_id.to_bytes(4, byteorder=\"little\"),\n                self.context_id.to_bytes(2, byteorder=\"little\"),\n                self.opnum.to_bytes(2, byteorder=\"little\"),\n            ]\n        )\n        return Command(self.command, self.flags, value).pack()\n\n    @classmethod\n    def _unpack(\n        cls,\n        flags: CommandFlags,\n        value: bytes,\n    ) -> CommandHeader2:\n        view = memoryview(value)\n\n        return cls(\n            flags=flags,\n            packet_type=PacketType(view[0]),\n            data_rep=DataRep.unpack(view[4:8]),\n            call_id=int.from_bytes(view[8:12], byteorder=\"little\"),\n            context_id=int.from_bytes(view[12:14], byteorder=\"little\"),\n            opnum=int.from_bytes(view[14:16], byteorder=\"little\"),\n        )", "\n\n@dataclasses.dataclass(frozen=True)\nclass VerificationTrailer:\n    signature: bytes = dataclasses.field(init=False, default=b\"\\x8A\\xE3\\x13\\x71\\x02\\xF4\\x36\\x71\")\n    commands: t.List[Command]\n\n    def pack(self) -> bytes:\n        return b\"\".join(\n            [\n                self.signature,\n                b\"\".join(c.pack() for c in self.commands),\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> VerificationTrailer:\n        view = memoryview(data)\n\n        if view[:8].tobytes() != cls.signature:\n            raise ValueError(f\"Failed to unpack {cls.__name__} as signature header is invalid\")\n\n        view = view[8:]\n        commands = []\n        while True:\n            cmd = Command.unpack(view)\n            commands.append(cmd)\n            view = view[4 + len(cmd.value) :]\n            if cmd.flags & CommandFlags.SEC_VT_COMMAND_END:\n                break\n\n        return cls(commands=commands)", ""]}
{"filename": "src/dpapi_ng/_rpc/_pdu.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport dataclasses\nimport enum\nimport typing as t\n\n\nclass IntegerRep(enum.IntEnum):\n    BIG_ENDIAN = 0\n    LITTLE_ENDIAN = 1", "\n\nclass IntegerRep(enum.IntEnum):\n    BIG_ENDIAN = 0\n    LITTLE_ENDIAN = 1\n\n\nclass CharacterRep(enum.IntEnum):\n    ASCII = 0\n    EBCDIC = 1", "\n\nclass FloatingPointRep(enum.IntEnum):\n    IEEE = 0\n    VAX = 1\n    CRAY = 2\n    IBM = 3\n\n\nclass PacketType(enum.IntEnum):\n    REQUEST = 0\n    PING = 1\n    RESPONSE = 2\n    FAULT = 3\n    WORKING = 4\n    NOCALL = 5\n    REJECT = 6\n    ACK = 7\n    CL_CANCEL = 8\n    FACK = 9\n    CANCEL_ACK = 10\n    BIND = 11\n    BIND_ACK = 12\n    BIND_NAK = 13\n    ALTER_CONTEXT = 14\n    ALTER_CONTEXT_RESP = 15\n    SHUTDOWN = 17\n    CO_CANCEL = 18\n    ORPHANED = 19", "\nclass PacketType(enum.IntEnum):\n    REQUEST = 0\n    PING = 1\n    RESPONSE = 2\n    FAULT = 3\n    WORKING = 4\n    NOCALL = 5\n    REJECT = 6\n    ACK = 7\n    CL_CANCEL = 8\n    FACK = 9\n    CANCEL_ACK = 10\n    BIND = 11\n    BIND_ACK = 12\n    BIND_NAK = 13\n    ALTER_CONTEXT = 14\n    ALTER_CONTEXT_RESP = 15\n    SHUTDOWN = 17\n    CO_CANCEL = 18\n    ORPHANED = 19", "\n\nclass PacketFlags(enum.IntFlag):\n    NONE = 0x00\n    PFC_FIRST_FRAG = 0x01\n    PFC_LAST_FRAG = 0x02\n    PFC_PENDING_CANCEL = 0x04\n    PFC_SUPPORT_HEADER_SIGN = 0x04  # MS-RPCE extension used in Bind/AlterContext\n    PFC_RESERVED_1 = 0x08\n    PFC_CONC_MPX = 0x10\n    PFC_DID_NOT_EXECUTE = 0x20\n    PFC_MAYBE = 0x40\n    PFC_OBJECT_UUID = 0x80", "\n\n@dataclasses.dataclass(frozen=True)\nclass DataRep:\n    # https://pubs.opengroup.org/onlinepubs/9629399/chap14.htm\n    byte_order: IntegerRep = IntegerRep.LITTLE_ENDIAN\n    character: CharacterRep = CharacterRep.ASCII\n    floating_point: FloatingPointRep = FloatingPointRep.IEEE\n\n    def pack(self) -> bytes:\n        first_octet = self.byte_order << 4 | self.character\n        return b\"\".join(\n            [\n                first_octet.to_bytes(1, byteorder=\"little\"),\n                self.floating_point.to_bytes(1, byteorder=\"little\"),\n                b\"\\x00\\x00\",\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> DataRep:\n        view = memoryview(data)\n\n        return cls(\n            byte_order=IntegerRep((view[0] & 0b11110000) >> 4),\n            character=CharacterRep(view[0] & 0b00001111),\n            floating_point=FloatingPointRep(view[1]),\n        )", "\n\n@dataclasses.dataclass(frozen=True)\nclass PDUHeader:\n    # https://pubs.opengroup.org/onlinepubs/9629399/chap12.htm\n    version: int\n    version_minor: int\n    packet_type: PacketType\n    packet_flags: PacketFlags\n    data_rep: DataRep\n    frag_len: int\n    auth_len: int\n    call_id: int\n\n    def pack(self) -> bytes:\n        return b\"\".join(\n            [\n                self.version.to_bytes(1, byteorder=\"little\"),\n                self.version_minor.to_bytes(1, byteorder=\"little\"),\n                self.packet_type.to_bytes(1, byteorder=\"little\"),\n                self.packet_flags.to_bytes(1, byteorder=\"little\"),\n                self.data_rep.pack(),\n                self.frag_len.to_bytes(2, byteorder=\"little\"),\n                self.auth_len.to_bytes(2, byteorder=\"little\"),\n                self.call_id.to_bytes(4, byteorder=\"little\"),\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> PDUHeader:\n        view = memoryview(data)\n\n        return cls(\n            version=view[0],\n            version_minor=view[1],\n            packet_type=PacketType(view[2]),\n            packet_flags=PacketFlags(view[3]),\n            data_rep=DataRep.unpack(view[4:8]),\n            frag_len=int.from_bytes(view[8:10], byteorder=\"little\"),\n            auth_len=int.from_bytes(view[10:12], byteorder=\"little\"),\n            call_id=int.from_bytes(view[12:16], byteorder=\"little\"),\n        )", "\n\nclass SecurityProvider(enum.IntEnum):\n    RPC_C_AUTHN_NONE = 0x00\n    RPC_C_AUTHN_GSS_NEGOTIATE = 0x09\n    RPC_C_AUTHN_WINNT = 0x0A\n    RPC_C_AUTHN_GSS_SCHANNEL = 0x0E\n    RPC_C_AUTHN_GSS_KERBEROS = 0x10\n    RPC_C_AUTHN_NETLOGON = 0x44\n    RPC_C_AUTHN_DEFAULT = 0xFF", "\n\nclass AuthenticationLevel(enum.IntEnum):\n    RPC_C_AUTHN_LEVEL_DEFAULT = 0x00\n    RPC_C_AUTHN_LEVEL_NONE = 0x01\n    RPC_C_AUTHN_LEVEL_CONNECT = 0x02\n    RPC_C_AUTHN_LEVEL_CALL = 0x03\n    RPC_C_AUTHN_LEVEL_PKT = 0x04\n    RPC_C_AUTHN_LEVEL_PKT_INTEGRITY = 0x05\n    RPC_C_AUTHN_LEVEL_PKT_PRIVACY = 0x06", "\n\n@dataclasses.dataclass(frozen=True)\nclass SecTrailer:\n    # https://pubs.opengroup.org/onlinepubs/9629399/chap13.htm\n    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/ab45c6a5-951a-4096-b805-7347674dc6ab\n    type: SecurityProvider\n    level: AuthenticationLevel\n    pad_length: int\n    context_id: int\n    auth_value: bytes\n\n    def pack(self) -> bytes:\n        return b\"\".join(\n            [\n                self.type.to_bytes(1, byteorder=\"little\"),\n                self.level.to_bytes(1, byteorder=\"little\"),\n                self.pad_length.to_bytes(1, byteorder=\"little\"),\n                b\"\\x00\",  # Auth-Rsrvd\n                self.context_id.to_bytes(4, byteorder=\"little\"),\n                self.auth_value,\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> SecTrailer:\n        view = memoryview(data)\n\n        return cls(\n            type=SecurityProvider(view[0]),\n            level=AuthenticationLevel(view[1]),\n            pad_length=view[2],\n            context_id=int.from_bytes(view[4:8], byteorder=\"little\"),\n            auth_value=view[8:].tobytes(),\n        )", "\n\nT = t.TypeVar(\"T\")\n\n_PACKET_TYPE_REGISTRY: t.Dict[PacketType, t.Callable[[memoryview, PDUHeader, t.Optional[SecTrailer]], PDU]] = {}\n\n\n@dataclasses.dataclass(frozen=True)\nclass PDU:\n    header: PDUHeader\n    sec_trailer: t.Optional[SecTrailer]\n\n    def pack(self) -> bytes:\n        raise NotImplementedError()  # pragma: nocover\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> PDU:\n        view = memoryview(data)\n\n        header = PDUHeader.unpack(view)\n        view = view[16 : header.frag_len]\n\n        sec_trailer = None\n        if header.auth_len:\n            sec_trailer = SecTrailer.unpack(view[-(header.auth_len + 8) :])\n            view = view[: -(header.auth_len + 8)]\n\n        return _PACKET_TYPE_REGISTRY[header.packet_type](\n            view,\n            header,\n            sec_trailer,\n        )", "class PDU:\n    header: PDUHeader\n    sec_trailer: t.Optional[SecTrailer]\n\n    def pack(self) -> bytes:\n        raise NotImplementedError()  # pragma: nocover\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> PDU:\n        view = memoryview(data)\n\n        header = PDUHeader.unpack(view)\n        view = view[16 : header.frag_len]\n\n        sec_trailer = None\n        if header.auth_len:\n            sec_trailer = SecTrailer.unpack(view[-(header.auth_len + 8) :])\n            view = view[: -(header.auth_len + 8)]\n\n        return _PACKET_TYPE_REGISTRY[header.packet_type](\n            view,\n            header,\n            sec_trailer,\n        )", "\n\ndef register_pdu(packet_type: PacketType) -> t.Callable[[T], T]:\n    def wrap(cls: T) -> T:\n        _PACKET_TYPE_REGISTRY[packet_type] = getattr(cls, \"_unpack\")\n        return cls\n\n    return wrap\n\n\nclass FaultFlags(enum.IntFlag):\n    NONE = 0x00\n    EXTENDED_ERROR_PRESENT = 0x01", "\n\nclass FaultFlags(enum.IntFlag):\n    NONE = 0x00\n    EXTENDED_ERROR_PRESENT = 0x01\n\n\n@dataclasses.dataclass(frozen=True)\n@register_pdu(PacketType.FAULT)\nclass Fault(PDU):\n    # https://pubs.opengroup.org/onlinepubs/9629399/chap12.htm\n    alloc_hint: int\n    context_id: int\n    cancel_count: int\n    status: int\n    flags: FaultFlags  # Extension of MS-RPCE\n    stub_data: bytes\n\n    def pack(self) -> bytes:\n        return b\"\".join(\n            [\n                self.header.pack(),\n                self.alloc_hint.to_bytes(4, byteorder=\"little\"),\n                self.context_id.to_bytes(2, byteorder=\"little\"),\n                self.cancel_count.to_bytes(1, byteorder=\"little\"),\n                self.flags.to_bytes(1, byteorder=\"little\"),\n                self.status.to_bytes(4, byteorder=\"little\"),\n                b\"\\x00\\x00\\x00\\x00\",  # alignment padding\n                self.stub_data,\n                self.sec_trailer.pack() if self.sec_trailer else b\"\",\n            ]\n        )\n\n    @classmethod\n    def _unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n        header: PDUHeader,\n        sec_trailer: t.Optional[SecTrailer],\n    ) -> Fault:\n        view = memoryview(data)\n\n        return cls(\n            header=header,\n            sec_trailer=sec_trailer,\n            alloc_hint=int.from_bytes(view[:4], byteorder=\"little\"),\n            context_id=int.from_bytes(view[4:6], byteorder=\"little\"),\n            cancel_count=view[6],\n            flags=FaultFlags(view[7]),\n            status=int.from_bytes(view[8:12], byteorder=\"little\"),\n            stub_data=view[16:].tobytes(),\n        )", "@register_pdu(PacketType.FAULT)\nclass Fault(PDU):\n    # https://pubs.opengroup.org/onlinepubs/9629399/chap12.htm\n    alloc_hint: int\n    context_id: int\n    cancel_count: int\n    status: int\n    flags: FaultFlags  # Extension of MS-RPCE\n    stub_data: bytes\n\n    def pack(self) -> bytes:\n        return b\"\".join(\n            [\n                self.header.pack(),\n                self.alloc_hint.to_bytes(4, byteorder=\"little\"),\n                self.context_id.to_bytes(2, byteorder=\"little\"),\n                self.cancel_count.to_bytes(1, byteorder=\"little\"),\n                self.flags.to_bytes(1, byteorder=\"little\"),\n                self.status.to_bytes(4, byteorder=\"little\"),\n                b\"\\x00\\x00\\x00\\x00\",  # alignment padding\n                self.stub_data,\n                self.sec_trailer.pack() if self.sec_trailer else b\"\",\n            ]\n        )\n\n    @classmethod\n    def _unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n        header: PDUHeader,\n        sec_trailer: t.Optional[SecTrailer],\n    ) -> Fault:\n        view = memoryview(data)\n\n        return cls(\n            header=header,\n            sec_trailer=sec_trailer,\n            alloc_hint=int.from_bytes(view[:4], byteorder=\"little\"),\n            context_id=int.from_bytes(view[4:6], byteorder=\"little\"),\n            cancel_count=view[6],\n            flags=FaultFlags(view[7]),\n            status=int.from_bytes(view[8:12], byteorder=\"little\"),\n            stub_data=view[16:].tobytes(),\n        )", ""]}
{"filename": "src/dpapi_ng/_rpc/__init__.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nfrom ._bind import (\n    AlterContext,\n    AlterContextResponse,\n    Bind,\n    BindAck,", "    Bind,\n    BindAck,\n    BindNak,\n    BindTimeFeatureNegotiation,\n    ContextElement,\n    ContextResult,\n    ContextResultCode,\n    SyntaxId,\n    bind_time_feature_negotiation,\n)", "    bind_time_feature_negotiation,\n)\nfrom ._client import (\n    NDR,\n    NDR64,\n    AsyncRpcClient,\n    SyncRpcClient,\n    async_create_rpc_connection,\n    create_rpc_connection,\n)", "    create_rpc_connection,\n)\nfrom ._pdu import (\n    AuthenticationLevel,\n    CharacterRep,\n    DataRep,\n    Fault,\n    FaultFlags,\n    FloatingPointRep,\n    IntegerRep,", "    FloatingPointRep,\n    IntegerRep,\n    PacketFlags,\n    PacketType,\n    PDUHeader,\n    SecTrailer,\n    SecurityProvider,\n)\nfrom ._request import Request, Response\nfrom ._verification import (", "from ._request import Request, Response\nfrom ._verification import (\n    Command,\n    CommandBitmask,\n    CommandFlags,\n    CommandHeader2,\n    CommandPContext,\n    CommandType,\n    VerificationTrailer,\n)", "    VerificationTrailer,\n)\n\n__all__ = [\n    \"NDR\",\n    \"NDR64\",\n    \"AlterContext\",\n    \"AlterContextResponse\",\n    \"AsyncRpcClient\",\n    \"AuthenticationLevel\",", "    \"AsyncRpcClient\",\n    \"AuthenticationLevel\",\n    \"Bind\",\n    \"BindAck\",\n    \"BindNak\",\n    \"BindTimeFeatureNegotiation\",\n    \"CharacterRep\",\n    \"Command\",\n    \"CommandBitmask\",\n    \"CommandFlags\",", "    \"CommandBitmask\",\n    \"CommandFlags\",\n    \"CommandHeader2\",\n    \"CommandPContext\",\n    \"CommandType\",\n    \"ContextElement\",\n    \"ContextResult\",\n    \"ContextResultCode\",\n    \"DataRep\",\n    \"Fault\",", "    \"DataRep\",\n    \"Fault\",\n    \"FaultFlags\",\n    \"FloatingPointRep\",\n    \"IntegerRep\",\n    \"PacketFlags\",\n    \"PacketType\",\n    \"PDUHeader\",\n    \"SecTrailer\",\n    \"SecurityProvider\",", "    \"SecTrailer\",\n    \"SecurityProvider\",\n    \"SyncRpcClient\",\n    \"SyntaxId\",\n    \"Request\",\n    \"Response\",\n    \"VerificationTrailer\",\n    \"async_create_rpc_connection\",\n    \"bind_time_feature_negotiation\",\n    \"create_rpc_connection\",", "    \"bind_time_feature_negotiation\",\n    \"create_rpc_connection\",\n]\n"]}
{"filename": "src/dpapi_ng/_rpc/_bind.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport dataclasses\nimport enum\nimport typing as t\nimport uuid\n", "import uuid\n\nfrom ._pdu import PDU, PacketType, PDUHeader, SecTrailer, register_pdu\n\n\nclass BindTimeFeatureNegotiation(enum.IntFlag):\n    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/cef529cc-77b5-4794-85dc-91e1467e80f0\n    NONE = 0x00\n    SECURITY_CONTEXT_MULTIPLEXING = 0x01\n    KEEP_CONNECTION_ON_ORPHAN = 0x02", "\n\n@dataclasses.dataclass(frozen=True)\nclass SyntaxId:\n    uuid: uuid.UUID\n    version: int\n    version_minor: int\n\n    def pack(self) -> bytes:\n        return b\"\".join(\n            [\n                self.uuid.bytes_le,\n                self.version.to_bytes(2, byteorder=\"little\"),\n                self.version_minor.to_bytes(2, byteorder=\"little\"),\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> SyntaxId:\n        view = memoryview(data)\n\n        return cls(\n            uuid=uuid.UUID(bytes_le=view[:16].tobytes()),\n            version=int.from_bytes(view[16:18], byteorder=\"little\"),\n            version_minor=int.from_bytes(view[18:20], byteorder=\"little\"),\n        )", "\n\n@dataclasses.dataclass(frozen=True)\nclass ContextElement:\n    # https://pubs.opengroup.org/onlinepubs/9629399/chap12.htm\n    context_id: int\n    abstract_syntax: SyntaxId\n    transfer_syntaxes: t.List[SyntaxId]\n\n    def pack(self) -> bytes:\n        return b\"\".join(\n            [\n                self.context_id.to_bytes(2, byteorder=\"little\"),\n                len(self.transfer_syntaxes).to_bytes(2, byteorder=\"little\"),\n                self.abstract_syntax.pack(),\n                b\"\".join([t.pack() for t in self.transfer_syntaxes]),\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> ContextElement:\n        view = memoryview(data)\n\n        context_id = int.from_bytes(view[:2], byteorder=\"little\")\n        num_transfers = int.from_bytes(view[2:4], byteorder=\"little\")\n        abstract_syntax = SyntaxId.unpack(view[4:])\n        view = view[24:]\n        transfer_syntaxes = []\n        for _ in range(num_transfers):\n            transfer_syntaxes.append(SyntaxId.unpack(view))\n            view = view[20:]\n\n        return cls(\n            context_id=context_id,\n            abstract_syntax=abstract_syntax,\n            transfer_syntaxes=transfer_syntaxes,\n        )", "\n\nclass ContextResultCode(enum.IntEnum):\n    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/8df5c4d4-364d-468c-81fe-ec94c1b40917\n    ACCEPTANCE = 0\n    USER_REJECTION = 1\n    PROVIDER_REJECTION = 2\n    NEGOTIATE_ACK = 3  # MS-RPCE extension\n\n", "\n\n@dataclasses.dataclass(frozen=True)\nclass ContextResult:\n    # https://pubs.opengroup.org/onlinepubs/9629399/chap12.htm\n    result: ContextResultCode\n    reason: int\n    syntax: uuid.UUID\n    syntax_version: int\n\n    def pack(self) -> bytes:\n        return b\"\".join(\n            [\n                self.result.to_bytes(2, byteorder=\"little\"),\n                self.reason.to_bytes(2, byteorder=\"little\"),\n                self.syntax.bytes_le,\n                self.syntax_version.to_bytes(4, byteorder=\"little\"),\n            ]\n        )\n\n    @classmethod\n    def unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n    ) -> ContextResult:\n        view = memoryview(data)\n\n        return cls(\n            result=ContextResultCode(int.from_bytes(view[:2], byteorder=\"little\")),\n            reason=int.from_bytes(view[2:4], byteorder=\"little\"),\n            syntax=uuid.UUID(bytes_le=view[4:20].tobytes()),\n            syntax_version=int.from_bytes(view[20:24], byteorder=\"little\"),\n        )", "\n\n@dataclasses.dataclass(frozen=True)\n@register_pdu(PacketType.BIND)\nclass Bind(PDU):\n    # https://pubs.opengroup.org/onlinepubs/9629399/chap12.htm\n    max_xmit_frag: int\n    max_recv_frag: int\n    assoc_group: int\n    contexts: t.List[ContextElement]\n\n    def pack(self) -> bytes:\n        return b\"\".join(\n            [\n                self.header.pack(),\n                self.max_xmit_frag.to_bytes(2, byteorder=\"little\"),\n                self.max_recv_frag.to_bytes(2, byteorder=\"little\"),\n                self.assoc_group.to_bytes(4, byteorder=\"little\"),\n                len(self.contexts).to_bytes(4, byteorder=\"little\"),\n                b\"\".join(c.pack() for c in self.contexts),\n                self.sec_trailer.pack() if self.sec_trailer else b\"\",\n            ]\n        )\n\n    @classmethod\n    def _unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n        header: PDUHeader,\n        sec_trailer: t.Optional[SecTrailer],\n    ) -> Bind:\n        view = memoryview(data)\n\n        max_xmit_frag = int.from_bytes(view[:2], byteorder=\"little\")\n        max_recv_frag = int.from_bytes(view[2:4], byteorder=\"little\")\n        assoc_group = int.from_bytes(view[4:8], byteorder=\"little\")\n\n        num_contexts = view[8]\n        view = view[12:]\n        contexts = []\n        for _ in range(num_contexts):\n            c = ContextElement.unpack(view)\n            contexts.append(c)\n            view = view[24 + (len(c.transfer_syntaxes) * 20) :]\n\n        return cls(\n            header=header,\n            sec_trailer=sec_trailer,\n            max_xmit_frag=max_xmit_frag,\n            max_recv_frag=max_recv_frag,\n            assoc_group=assoc_group,\n            contexts=contexts,\n        )", "\n\n@dataclasses.dataclass(frozen=True)\n@register_pdu(PacketType.BIND_ACK)\nclass BindAck(PDU):\n    # https://pubs.opengroup.org/onlinepubs/9629399/chap12.htm\n    max_xmit_frag: int\n    max_recv_frag: int\n    assoc_group: int\n    sec_addr: str\n    results: t.List[ContextResult]\n\n    def pack(self) -> bytes:\n        b_sec_addr = b\"\"\n        if self.sec_addr:\n            b_sec_addr = self.sec_addr.encode(\"utf-8\") + b\"\\x00\"\n        sec_addr_len = len(b_sec_addr)\n        padding = -(2 + sec_addr_len) % 4\n        b_result = b\"\".join([r.pack() for r in self.results])\n\n        return b\"\".join(\n            [\n                self.header.pack(),\n                self.max_xmit_frag.to_bytes(2, byteorder=\"little\"),\n                self.max_recv_frag.to_bytes(2, byteorder=\"little\"),\n                self.assoc_group.to_bytes(4, byteorder=\"little\"),\n                sec_addr_len.to_bytes(2, byteorder=\"little\"),\n                b_sec_addr,\n                b\"\\x00\" * padding,\n                len(self.results).to_bytes(4, byteorder=\"little\"),\n                b_result,\n                self.sec_trailer.pack() if self.sec_trailer else b\"\",\n            ]\n        )\n\n    @classmethod\n    def _unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n        header: PDUHeader,\n        sec_trailer: t.Optional[SecTrailer],\n    ) -> BindAck:\n        view = memoryview(data)\n\n        max_xmit_frag = int.from_bytes(view[:2], byteorder=\"little\")\n        max_recv_frag = int.from_bytes(view[2:4], byteorder=\"little\")\n        assoc_group = int.from_bytes(view[4:8], byteorder=\"little\")\n        sec_addr_len = int.from_bytes(view[8:10], byteorder=\"little\")\n        sec_addr = view[10 : 10 + sec_addr_len - 1].tobytes().decode(\"utf-8\")\n        padding = -(2 + sec_addr_len) % 4\n        view = view[10 + sec_addr_len + padding :]\n\n        num_result = view[0]\n        view = view[4:]\n        results = []\n        for _ in range(num_result):\n            results.append(ContextResult.unpack(view))\n            view = view[24:]\n\n        return cls(\n            header=header,\n            sec_trailer=sec_trailer,\n            max_xmit_frag=max_xmit_frag,\n            max_recv_frag=max_recv_frag,\n            assoc_group=assoc_group,\n            sec_addr=sec_addr,\n            results=results,\n        )", "\n\n@dataclasses.dataclass(frozen=True)\n@register_pdu(PacketType.BIND_NAK)\nclass BindNak(PDU):\n    # https://pubs.opengroup.org/onlinepubs/9629399/chap12.htm\n    reject_reason: int\n    versions: t.List[tuple[int, int]]\n\n    def pack(self) -> bytes:\n        protocols = [v[0].to_bytes(1, byteorder=\"little\") + v[1].to_bytes(1, byteorder=\"little\") for v in self.versions]\n        b_versions = b\"\".join(\n            [\n                len(protocols).to_bytes(1, byteorder=\"little\"),\n                b\"\".join(protocols),\n            ]\n        )\n        padding = -(2 + len(b_versions)) % 4\n\n        return b\"\".join(\n            [\n                self.header.pack(),\n                self.reject_reason.to_bytes(2, byteorder=\"little\"),\n                b_versions,\n                b\"\\x00\" * padding,\n            ]\n        )\n\n    @classmethod\n    def _unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n        header: PDUHeader,\n        sec_trailer: t.Optional[SecTrailer],\n    ) -> BindNak:\n        view = memoryview(data)\n\n        reject_reason = int.from_bytes(view[:2], byteorder=\"little\")\n        versions = []\n        num_versions = view[2]\n\n        view = view[3:]\n        for _ in range(num_versions):\n            versions.append((view[0], view[1]))\n            view = view[2:]\n\n        return cls(\n            header=header,\n            sec_trailer=None,\n            reject_reason=reject_reason,\n            versions=versions,\n        )", "\n\n@dataclasses.dataclass(frozen=True)\n@register_pdu(PacketType.ALTER_CONTEXT)\nclass AlterContext(Bind):\n    @classmethod\n    def _unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n        header: PDUHeader,\n        sec_trailer: t.Optional[SecTrailer],\n    ) -> AlterContext:\n        return Bind._unpack.__func__(cls, data, header, sec_trailer)  # type: ignore[attr-defined]", "\n\n@dataclasses.dataclass(frozen=True)\n@register_pdu(PacketType.ALTER_CONTEXT_RESP)\nclass AlterContextResponse(BindAck):\n    @classmethod\n    def _unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n        header: PDUHeader,\n        sec_trailer: t.Optional[SecTrailer],\n    ) -> AlterContextResponse:\n        return BindAck._unpack.__func__(cls, data, header, sec_trailer)  # type: ignore[attr-defined]", "\n\ndef bind_time_feature_negotiation(\n    flags: BindTimeFeatureNegotiation = BindTimeFeatureNegotiation.NONE,\n) -> SyntaxId:\n    \"\"\"Creates the Bind Time Feature Negotiation Syntax value from the flags specified.\"\"\"\n    return SyntaxId(\n        uuid=uuid.UUID(fields=(0x6CB71C2C, 0x9812, 0x4540, flags, 0, 0)),\n        version=1,\n        version_minor=0,\n    )", ""]}
{"filename": "src/dpapi_ng/_rpc/_auth.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport typing as t\n\nimport spnego\nimport spnego.iov\n", "import spnego.iov\n\nfrom ._pdu import AuthenticationLevel, SecTrailer, SecurityProvider\n\n\nclass AuthenticationProvider:\n    def __init__(\n        self,\n        username: t.Optional[str] = None,\n        password: t.Optional[str] = None,\n        hostname: str = \"unspecified\",\n        protocol: str = \"negotiate\",\n    ) -> None:\n        self.ctx = spnego.client(\n            username,\n            password,\n            hostname=hostname,\n            service=\"host\",\n            protocol=protocol,\n            context_req=spnego.ContextReq.default | spnego.ContextReq.dce_style,\n        )\n        self.provider = {\n            \"negotiate\": SecurityProvider.RPC_C_AUTHN_GSS_NEGOTIATE,\n            \"ntlm\": SecurityProvider.RPC_C_AUTHN_WINNT,\n            \"kerberos\": SecurityProvider.RPC_C_AUTHN_GSS_KERBEROS,\n        }[protocol]\n        self._header_length = 0\n\n    @property\n    def complete(self) -> bool:\n        return self.ctx.complete\n\n    def step(\n        self,\n        in_token: t.Optional[bytes] = None,\n    ) -> SecTrailer:\n        out_token = self.ctx.step(in_token) or b\"\"\n        return SecTrailer(\n            type=self.provider,\n            level=AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n            pad_length=0,\n            context_id=0,\n            auth_value=out_token,\n        )\n\n    def get_empty_trailer(self, pad_length: int) -> SecTrailer:\n        header_length = self._header_length = self._header_length or self.ctx.query_message_sizes().header\n        return SecTrailer(\n            type=self.provider,\n            level=AuthenticationLevel.RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n            pad_length=pad_length,\n            context_id=0,\n            auth_value=b\"\\x00\" * header_length,\n        )\n\n    def wrap(\n        self,\n        header: bytes,\n        body: bytes,\n        trailer: bytes,\n        sign_header: bool,\n    ) -> bytes:\n        sign_buffer_type = spnego.iov.BufferType.sign_only if sign_header else spnego.iov.BufferType.data_readonly\n        res = self.ctx.wrap_iov(\n            [\n                (sign_buffer_type, header),\n                body,\n                (sign_buffer_type, trailer),\n                spnego.iov.BufferType.header,\n            ],\n            encrypt=True,\n            qop=None,\n        )\n\n        return b\"\".join(\n            [\n                header,\n                res.buffers[1].data or b\"\",\n                trailer,\n                res.buffers[3].data or b\"\",\n            ]\n        )\n\n    def unwrap(\n        self,\n        header: bytes,\n        body: bytes,\n        trailer: bytes,\n        signature: bytes,\n        sign_header: bool,\n    ) -> bytes:\n        sign_buffer_type = spnego.iov.BufferType.sign_only if sign_header else spnego.iov.BufferType.data_readonly\n        res = self.ctx.unwrap_iov(\n            [\n                (sign_buffer_type, header),\n                body,\n                (sign_buffer_type, trailer),\n                (spnego.iov.BufferType.header, signature),\n            ],\n        )\n\n        return res.buffers[1].data or b\"\"", ""]}
{"filename": "src/dpapi_ng/_rpc/_client.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport asyncio\nimport concurrent.futures\nimport socket\nimport typing as t\nimport uuid", "import typing as t\nimport uuid\n\nfrom ._auth import AuthenticationProvider\nfrom ._bind import (\n    AlterContext,\n    AlterContextResponse,\n    Bind,\n    BindAck,\n    BindNak,", "    BindAck,\n    BindNak,\n    ContextElement,\n    ContextResultCode,\n    SyntaxId,\n)\nfrom ._pdu import PDU, DataRep, Fault, PacketFlags, PacketType, PDUHeader, SecTrailer\nfrom ._request import Request, Response\nfrom ._verification import VerificationTrailer\n", "from ._verification import VerificationTrailer\n\nNDR = SyntaxId(uuid.UUID(\"8a885d04-1ceb-11c9-9fe8-08002b104860\"), 2, 0)\nNDR64 = SyntaxId(uuid.UUID(\"71710533-beba-4937-8319-b5dbef9ccc36\"), 1, 0)\n\nT = t.TypeVar(\"T\")\n\n\nasync def async_create_rpc_connection(\n    server: str,", "async def async_create_rpc_connection(\n    server: str,\n    port: int = 135,\n    connection_timeout: int = 5,\n    username: t.Optional[str] = None,\n    password: t.Optional[str] = None,\n    auth_protocol: t.Optional[str] = None,\n) -> AsyncRpcClient:\n    auth_provider = None\n    if auth_protocol:\n        auth_provider = AuthenticationProvider(username, password, server, auth_protocol)", "    auth_provider = None\n    if auth_protocol:\n        auth_provider = AuthenticationProvider(username, password, server, auth_protocol)\n\n    conn_future = asyncio.open_connection(server, port=port)\n    reader, writer = await asyncio.wait_for(conn_future, connection_timeout)\n\n    return AsyncRpcClient(reader, writer, auth_provider)\n\n\ndef create_rpc_connection(\n    server: str,\n    port: int = 135,\n    connection_timeout: int = 5,\n    username: t.Optional[str] = None,\n    password: t.Optional[str] = None,\n    auth_protocol: t.Optional[str] = None,\n) -> SyncRpcClient:\n    auth_provider = None\n    if auth_protocol:\n        auth_provider = AuthenticationProvider(username, password, server, auth_protocol)\n\n    sock = socket.create_connection(\n        (server, port),\n        timeout=connection_timeout,\n    )\n    sock.settimeout(None)\n\n    return SyncRpcClient(sock, auth_provider)", "\n\ndef create_rpc_connection(\n    server: str,\n    port: int = 135,\n    connection_timeout: int = 5,\n    username: t.Optional[str] = None,\n    password: t.Optional[str] = None,\n    auth_protocol: t.Optional[str] = None,\n) -> SyncRpcClient:\n    auth_provider = None\n    if auth_protocol:\n        auth_provider = AuthenticationProvider(username, password, server, auth_protocol)\n\n    sock = socket.create_connection(\n        (server, port),\n        timeout=connection_timeout,\n    )\n    sock.settimeout(None)\n\n    return SyncRpcClient(sock, auth_provider)", "\n\nclass RpcClient:\n    def __init__(\n        self,\n        auth: t.Optional[AuthenticationProvider] = None,\n    ) -> None:\n        self._auth = auth\n        self._sign_header = False\n\n    def _create_pdu_header(\n        self,\n        packet_type: PacketType,\n        auth_len: int,\n        call_id: int,\n        *,\n        flags: PacketFlags = PacketFlags.NONE,\n    ) -> PDUHeader:\n        return PDUHeader(\n            version=5,\n            version_minor=0,\n            packet_type=packet_type,\n            packet_flags=flags | PacketFlags.PFC_FIRST_FRAG | PacketFlags.PFC_LAST_FRAG,\n            data_rep=DataRep(),\n            frag_len=0,  # Set after building the PDU\n            auth_len=auth_len,\n            call_id=call_id,\n        )\n\n    def _create_bind(\n        self,\n        contexts: t.List[ContextElement],\n        sec_trailer: t.Optional[SecTrailer] = None,\n    ) -> Bind:\n        flags = PacketFlags.NONE\n\n        auth_len = 0\n        if sec_trailer:\n            self._sign_header = True\n            flags |= PacketFlags.PFC_SUPPORT_HEADER_SIGN\n            auth_len = len(sec_trailer.auth_value)\n\n        return Bind(\n            header=self._create_pdu_header(\n                PacketType.BIND,\n                auth_len,\n                1,\n                flags=flags,\n            ),\n            sec_trailer=sec_trailer,\n            max_xmit_frag=5840,\n            max_recv_frag=5840,\n            assoc_group=0,\n            contexts=contexts,\n        )\n\n    def _create_alter_context(\n        self,\n        contexts: t.List[ContextElement],\n        sec_trailer: SecTrailer,\n    ) -> AlterContext:\n        flags = PacketFlags.PFC_SUPPORT_HEADER_SIGN if self._sign_header else PacketFlags.NONE\n\n        return AlterContext(\n            header=self._create_pdu_header(\n                PacketType.ALTER_CONTEXT,\n                len(sec_trailer.auth_value),\n                1,\n                flags=flags,\n            ),\n            sec_trailer=sec_trailer,\n            max_xmit_frag=5840,\n            max_recv_frag=5840,\n            assoc_group=0,\n            contexts=contexts,\n        )\n\n    def _create_request(\n        self,\n        context_id: int,\n        opnum: int,\n        stub_data: bytes,\n        *,\n        verification_trailer: t.Optional[VerificationTrailer] = None,\n    ) -> tuple[Request, t.Optional[tuple[int, int]]]:\n        if verification_trailer:\n            # The verification trailer needs to be aligned to the next 4 byte\n            # boundary.\n            padding = -len(stub_data) % 4\n            stub_data += (b\"\\x00\" * padding) + verification_trailer.pack()\n\n        auth_len = 0\n        sec_trailer = None\n        encrypt_offsets = None\n        if self._auth:\n            # If the security trailer is present it must be aligned to the\n            # next 16 byte boundary after the stub data. This padding is\n            # included as part of the stub data to be encrypted.\n            pad_length = -len(stub_data) % 16\n            stub_data += b\"\\x00\" * pad_length\n            sec_trailer = self._auth.get_empty_trailer(pad_length)\n            auth_len = len(sec_trailer.auth_value)\n            encrypt_offsets = (24, 24 + len(stub_data))\n\n        return (\n            Request(\n                header=self._create_pdu_header(\n                    PacketType.REQUEST,\n                    auth_len,\n                    1,\n                ),\n                sec_trailer=sec_trailer,\n                alloc_hint=len(stub_data),\n                context_id=context_id,\n                opnum=opnum,\n                obj=None,\n                stub_data=stub_data,\n            ),\n            encrypt_offsets,\n        )\n\n    def _prepare_pdu(\n        self,\n        pdu: PDU,\n        encrypt_offsets: t.Optional[tuple[int, int]] = None,\n    ) -> t.Union[bytes, bytearray]:\n        b_pdu: t.Union[bytes, bytearray] = bytearray(pdu.pack())\n        view = memoryview(b_pdu)\n        view[8:10] = len(b_pdu).to_bytes(2, byteorder=\"little\")\n\n        if self._auth and encrypt_offsets:\n            view = memoryview(b_pdu)\n            header = view[: encrypt_offsets[0]].tobytes()\n            body = view[encrypt_offsets[0] : encrypt_offsets[1]].tobytes()\n            sec_trailer = view[encrypt_offsets[1] : encrypt_offsets[1] + 8].tobytes()\n            b_pdu = self._auth.wrap(header, body, sec_trailer, self._sign_header)\n\n        return b_pdu\n\n    def _process_bind_ack(\n        self,\n        ack: t.Union[BindAck, AlterContextResponse],\n        contexts: t.List[ContextElement],\n    ) -> tuple[t.List[ContextElement], t.Optional[bytes]]:\n        alter_contexts = []\n        for idx, c in enumerate(contexts):\n            context_res = ack.results[idx]\n            if context_res.result == ContextResultCode.ACCEPTANCE:\n                alter_contexts.append(c)\n\n        if not ack.header.packet_flags & PacketFlags.PFC_SUPPORT_HEADER_SIGN:\n            self._sign_header = False\n\n        auth_value = None\n        if ack.sec_trailer:\n            auth_value = ack.sec_trailer.auth_value\n\n        return alter_contexts, auth_value\n\n    def _process_response(\n        self,\n        response: bytearray,\n        pdu_header: PDUHeader,\n        resp_type: t.Type[T],\n        encrypt_offsets: t.Optional[tuple[int, int]] = None,\n    ) -> T:\n        if self._auth and encrypt_offsets and pdu_header.auth_len:\n            view = memoryview(response)\n\n            sec_trailer_offset = pdu_header.frag_len - (pdu_header.auth_len + 8)\n            header = view[: encrypt_offsets[0]].tobytes()\n            body = view[encrypt_offsets[0] : sec_trailer_offset].tobytes()\n            sec_trailer = view[sec_trailer_offset : sec_trailer_offset + 8].tobytes()\n            signature = view[sec_trailer_offset + 8 :].tobytes()\n            dec_stub = self._auth.unwrap(header, body, sec_trailer, signature, self._sign_header)\n            response[encrypt_offsets[0] : sec_trailer_offset] = dec_stub\n\n        pdu_resp = PDU.unpack(response)\n        if isinstance(pdu_resp, BindNak):\n            raise ValueError(f\"Received BindNack with reason 0x{pdu_resp.reject_reason:08X}\")\n        elif isinstance(pdu_resp, Fault):\n            raise ValueError(f\"Receive Fault with status 0x{pdu_resp.status:08X}\")\n        elif not isinstance(pdu_resp, resp_type):\n            raise ValueError(\n                f\"Received unexpected PDU response of {type(pdu_resp).__name__} when expecting {resp_type.__name__}\"\n            )\n\n        return pdu_resp", "\n\nclass AsyncRpcClient(RpcClient):\n    def __init__(\n        self,\n        reader: asyncio.StreamReader,\n        writer: asyncio.StreamWriter,\n        auth: t.Optional[AuthenticationProvider] = None,\n    ) -> None:\n        super().__init__(auth)\n        self._reader = reader\n        self._writer = writer\n\n    async def __aenter__(self) -> AsyncRpcClient:\n        return self\n\n    async def __aexit__(\n        self,\n        *args: t.Any,\n        **kwargs: t.Any,\n    ) -> None:\n        await self.close()\n\n    async def close(self) -> None:\n        self._writer.close()\n        await self._writer.wait_closed()\n\n    async def bind(\n        self,\n        contexts: t.List[ContextElement],\n    ) -> BindAck:\n        sec_trailer = None\n        if self._auth:\n            sec_trailer = await self._wrap_sync(self._auth.step)\n\n        bind = self._create_bind(contexts, sec_trailer)\n        bind_ack = await self._send_pdu(bind, BindAck)\n\n        if not self._auth:\n            return bind_ack\n\n        final_contexts, in_token = self._process_bind_ack(bind_ack, contexts)\n\n        while not self._auth.complete:\n            sec_trailer = await self._wrap_sync(self._auth.step, (in_token or b\"\"))\n            if not sec_trailer.auth_value:\n                break\n\n            alter_context = self._create_alter_context(final_contexts, sec_trailer)\n            alter_resp = await self._send_pdu(alter_context, AlterContextResponse)\n            _, in_token = self._process_bind_ack(alter_resp, final_contexts)\n\n        return bind_ack\n\n    async def request(\n        self,\n        context_id: int,\n        opnum: int,\n        stub_data: bytes,\n        *,\n        verification_trailer: t.Optional[VerificationTrailer] = None,\n    ) -> Response:\n        req, encrypt_offsets = self._create_request(\n            context_id,\n            opnum,\n            stub_data,\n            verification_trailer=verification_trailer,\n        )\n        return await self._send_pdu(req, Response, encrypt_offsets=encrypt_offsets)\n\n    async def _send_pdu(\n        self,\n        pdu: PDU,\n        resp_type: t.Type[T],\n        *,\n        encrypt_offsets: t.Optional[tuple[int, int]] = None,\n    ) -> T:\n        b_pdu = self._prepare_pdu(pdu, encrypt_offsets)\n\n        self._writer.write(b_pdu)\n        await self._writer.drain()\n\n        header = await self._reader.readexactly(16)\n        resp_header = PDUHeader.unpack(header)\n\n        resp = bytearray(resp_header.frag_len)\n        view = memoryview(resp)\n        view[:16] = header\n        view[16:] = await self._reader.readexactly(len(resp) - 16)\n\n        return self._process_response(resp, resp_header, resp_type, encrypt_offsets)\n\n    async def _wrap_sync(\n        self,\n        func: t.Callable[..., T],\n        *args: t.Any,\n    ) -> T:\n        exec = concurrent.futures.ThreadPoolExecutor()\n        return await asyncio.get_event_loop().run_in_executor(exec, func, *args)", "\n\nclass SyncRpcClient(RpcClient):\n    def __init__(\n        self,\n        sock: socket.socket,\n        auth: t.Optional[AuthenticationProvider] = None,\n    ) -> None:\n        super().__init__(auth)\n        self._sock = sock\n\n    def __enter__(self) -> SyncRpcClient:\n        return self\n\n    def __exit__(self, *args: t.Any, **kwargs: t.Any) -> None:\n        self.close()\n\n    def close(self) -> None:\n        try:\n            self._sock.shutdown(socket.SHUT_RDWR)\n        except OSError:\n            # The socket has already been shutdown for some other reason\n            pass\n        self._sock.close()\n\n    def bind(\n        self,\n        contexts: t.List[ContextElement],\n    ) -> BindAck:\n        sec_trailer = None\n        if self._auth:\n            sec_trailer = self._auth.step()\n\n        bind = self._create_bind(contexts, sec_trailer)\n        bind_ack = self._send_pdu(bind, BindAck)\n\n        if not self._auth:\n            return bind_ack\n\n        final_contexts, in_token = self._process_bind_ack(bind_ack, contexts)\n\n        while not self._auth.complete:\n            sec_trailer = self._auth.step(in_token or b\"\")\n            if not sec_trailer.auth_value:\n                break\n\n            alter_context = self._create_alter_context(final_contexts, sec_trailer)\n            alter_resp = self._send_pdu(alter_context, AlterContextResponse)\n            _, in_token = self._process_bind_ack(alter_resp, final_contexts)\n\n        return bind_ack\n\n    def request(\n        self,\n        context_id: int,\n        opnum: int,\n        stub_data: bytes,\n        *,\n        verification_trailer: t.Optional[VerificationTrailer] = None,\n    ) -> Response:\n        req, encrypt_offsets = self._create_request(\n            context_id,\n            opnum,\n            stub_data,\n            verification_trailer=verification_trailer,\n        )\n        return self._send_pdu(req, Response, encrypt_offsets=encrypt_offsets)\n\n    def _send_pdu(\n        self,\n        pdu: PDU,\n        resp_type: t.Type[T],\n        *,\n        encrypt_offsets: t.Optional[tuple[int, int]] = None,\n    ) -> T:\n        b_pdu = self._prepare_pdu(pdu, encrypt_offsets)\n        self._sock.sendall(b_pdu)\n\n        header = self._sock.recv(16)\n        resp_header = PDUHeader.unpack(header)\n\n        resp = bytearray(resp_header.frag_len)\n        view = memoryview(resp)\n        view[:16] = header\n        view = view[16:]\n\n        while view:\n            read = self._sock.recv_into(view)\n            view = view[read:]\n\n        return self._process_response(resp, resp_header, resp_type, encrypt_offsets)", ""]}
{"filename": "src/dpapi_ng/_rpc/_request.py", "chunked_list": ["# Copyright: (c) 2023, Jordan Borean (@jborean93) <jborean93@gmail.com>\n# MIT License (see LICENSE or https://opensource.org/licenses/MIT)\n\nfrom __future__ import annotations\n\nimport dataclasses\nimport typing as t\nimport uuid\n\nfrom ._pdu import PDU, PacketFlags, PacketType, PDUHeader, SecTrailer, register_pdu", "\nfrom ._pdu import PDU, PacketFlags, PacketType, PDUHeader, SecTrailer, register_pdu\n\n\n@dataclasses.dataclass(frozen=True)\n@register_pdu(PacketType.REQUEST)\nclass Request(PDU):\n    alloc_hint: int\n    context_id: int\n    opnum: int\n    obj: t.Optional[uuid.UUID]\n    stub_data: bytes\n\n    def pack(self) -> bytes:\n        return b\"\".join(\n            [\n                self.header.pack(),\n                self.alloc_hint.to_bytes(4, byteorder=\"little\"),\n                self.context_id.to_bytes(2, byteorder=\"little\"),\n                self.opnum.to_bytes(2, byteorder=\"little\"),\n                self.obj.bytes_le if self.obj else b\"\",\n                self.stub_data,\n                self.sec_trailer.pack() if self.sec_trailer else b\"\",\n            ]\n        )\n\n    @classmethod\n    def _unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n        header: PDUHeader,\n        sec_trailer: t.Optional[SecTrailer],\n    ) -> Request:\n        view = memoryview(data)\n\n        alloc_hint = int.from_bytes(view[:4], byteorder=\"little\")\n        context_id = int.from_bytes(view[4:6], byteorder=\"little\")\n        opnum = int.from_bytes(view[6:8], byteorder=\"little\")\n\n        view = view[8:]\n        obj = None\n        if header.packet_flags & PacketFlags.PFC_OBJECT_UUID:\n            obj = uuid.UUID(bytes_le=view[:16].tobytes())\n            view = view[16:]\n\n        return cls(\n            header=header,\n            sec_trailer=sec_trailer,\n            alloc_hint=alloc_hint,\n            context_id=context_id,\n            opnum=opnum,\n            obj=obj,\n            stub_data=view.tobytes(),\n        )", "\n\n@dataclasses.dataclass(frozen=True)\n@register_pdu(PacketType.RESPONSE)\nclass Response(PDU):\n    alloc_hint: int\n    context_id: int\n    cancel_count: int\n    stub_data: bytes\n\n    def pack(self) -> bytes:\n        return b\"\".join(\n            [\n                self.header.pack(),\n                self.alloc_hint.to_bytes(4, byteorder=\"little\"),\n                self.context_id.to_bytes(2, byteorder=\"little\"),\n                self.cancel_count.to_bytes(1, byteorder=\"little\"),\n                b\"\\x00\",  # reserved\n                self.stub_data,\n                self.sec_trailer.pack() if self.sec_trailer else b\"\",\n            ]\n        )\n\n    @classmethod\n    def _unpack(\n        cls,\n        data: t.Union[bytes, bytearray, memoryview],\n        header: PDUHeader,\n        sec_trailer: t.Optional[SecTrailer],\n    ) -> Response:\n        view = memoryview(data)\n\n        return cls(\n            header=header,\n            sec_trailer=sec_trailer,\n            alloc_hint=int.from_bytes(view[:4], byteorder=\"little\"),\n            context_id=int.from_bytes(view[4:6], byteorder=\"little\"),\n            cancel_count=view[6],\n            stub_data=view[8:].tobytes(),\n        )", ""]}
