{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/validation_test.py", "chunked_list": ["import pytest\n\nfrom checkr import validate\nfrom tests.fixtures import (\n    SampleRequestUsingArrayRules,\n    SampleRequest,\n    SampleRequestWithIncorrectRule,\n    SampleRejectedRequest,\n    SampleFailingRequest,\n)", "    SampleFailingRequest,\n)\nfrom checkr.exceptions import (\n    InvalidRuleException,\n    UnauthorizedRequestException,\n    ValidationError,\n)\n\n\ndef test_reject_request_if_unauthorized():\n    request = {}\n    validation_class = SampleRejectedRequest()\n    with pytest.raises(UnauthorizedRequestException):\n        validate(validation_class=validation_class, request_data=request)", "\ndef test_reject_request_if_unauthorized():\n    request = {}\n    validation_class = SampleRejectedRequest()\n    with pytest.raises(UnauthorizedRequestException):\n        validate(validation_class=validation_class, request_data=request)\n\n\ndef test_can_validate_array_of_rules():\n    request = {\"foo\": \"bar\"}\n    validation_class = SampleRequestUsingArrayRules()\n    assert validate(validation_class=validation_class, request_data=request) is True", "def test_can_validate_array_of_rules():\n    request = {\"foo\": \"bar\"}\n    validation_class = SampleRequestUsingArrayRules()\n    assert validate(validation_class=validation_class, request_data=request) is True\n\n\ndef test_can_validate_string_of_rules():\n    request = {\"foo\": \"bar\"}\n    validation_class = SampleRequest()\n    assert validate(validation_class=validation_class, request_data=request) is True", "\n\ndef test_throws_correct_exception_when_rule_is_incorrect():\n    request = {}\n    validation_class = SampleRequestWithIncorrectRule()\n    with pytest.raises(InvalidRuleException):\n        validate(validation_class=validation_class, request_data=request)\n\n\ndef test_throws_correct_exception_when_validation_fails():\n    request = {}\n    validation_class = SampleFailingRequest()\n    with pytest.raises(ValidationError):\n        validate(validation_class=validation_class, request_data=request)", "\ndef test_throws_correct_exception_when_validation_fails():\n    request = {}\n    validation_class = SampleFailingRequest()\n    with pytest.raises(ValidationError):\n        validate(validation_class=validation_class, request_data=request)\n"]}
{"filename": "tests/fixtures.py", "chunked_list": ["from typing import Dict\n\nfrom checkr.BaseRequest import BaseRequest\n\n\nclass SampleRequest(BaseRequest):\n    @staticmethod\n    def authorize() -> bool:\n        return True\n\n    @staticmethod\n    def rules() -> Dict:\n        return {\n            \"foo\": \"required\",\n        }", "\n\nclass SampleFailingRequest(BaseRequest):\n    @staticmethod\n    def authorize() -> bool:\n        return True\n\n    @staticmethod\n    def rules() -> Dict:\n        return {\n            \"foo\": \"required\",\n        }", "\n\nclass SampleRequestUsingArrayRules(BaseRequest):\n    @staticmethod\n    def authorize() -> bool:\n        return True\n\n    @staticmethod\n    def rules() -> Dict:\n        return {\n            \"foo\": [\"required\", \"string\"],\n        }", "\n\nclass SampleRequestWithIncorrectRule(BaseRequest):\n    @staticmethod\n    def authorize() -> bool:\n        return True\n\n    @staticmethod\n    def rules() -> Dict:\n        return {\n            \"foo\": \"bar\",\n        }", "\n\nclass SampleRejectedRequest(BaseRequest):\n    @staticmethod\n    def authorize() -> bool:\n        return False\n\n    @staticmethod\n    def rules() -> Dict:\n        return {\n            \"foo\": \"bar\",\n        }", ""]}
{"filename": "tests/base_requests_test.py", "chunked_list": ["from tests.fixtures import SampleRequest\n\n\ndef test_set_data():\n    validation_class = SampleRequest()\n    validation_class.set_data(data={\"foo\": \"bar\"})\n    assert {\"foo\": \"bar\"} == validation_class.get_data()\n\n\ndef test_merge_data():\n    validation_class = SampleRequest()\n    validation_class.set_data(data={\"foo\": \"bar\"})\n    validation_class.merge(data_to_add={\"bar\": \"baz\"})\n    assert validation_class.get_data() == {\"foo\": \"bar\", \"bar\": \"baz\"}", "\ndef test_merge_data():\n    validation_class = SampleRequest()\n    validation_class.set_data(data={\"foo\": \"bar\"})\n    validation_class.merge(data_to_add={\"bar\": \"baz\"})\n    assert validation_class.get_data() == {\"foo\": \"bar\", \"bar\": \"baz\"}\n\n\ndef test_extract_simple_rule_data():\n    validation_class = SampleRequest()\n    rule_data = validation_class.extract_rule_data(\"foo\")\n    assert rule_data[\"rule_name\"] == \"foo\"\n    assert rule_data[\"rule_payload\"] is None", "def test_extract_simple_rule_data():\n    validation_class = SampleRequest()\n    rule_data = validation_class.extract_rule_data(\"foo\")\n    assert rule_data[\"rule_name\"] == \"foo\"\n    assert rule_data[\"rule_payload\"] is None\n\n\ndef test_extract_compound_rule_data():\n    validation_class = SampleRequest()\n    first_rule_data = validation_class.extract_rule_data(\"foo:bar\")\n    second_rule_data = validation_class.extract_rule_data(\"eggs:bar,baz\")\n    assert first_rule_data[\"rule_name\"] == \"foo\"\n    assert first_rule_data[\"rule_payload\"] == \"bar\"\n    assert second_rule_data[\"rule_name\"] == \"eggs\"\n    assert len(second_rule_data[\"rule_payload\"]) == 2\n    assert second_rule_data[\"rule_payload\"] == [\"bar\", \"baz\"]", ""]}
{"filename": "checkr/BaseRequest.py", "chunked_list": ["from abc import ABCMeta\nfrom typing import Dict, Union, List, Any\n\nfrom .ErrorBag import ErrorBag\nfrom .exceptions import (\n    InvalidRuleException,\n    UnauthorizedRequestException,\n)\n\nfrom .rules_map import rules_to_objects_map", "\nfrom .rules_map import rules_to_objects_map\n\n\nclass BaseRequest(metaclass=ABCMeta):\n    __is_valid = False\n    __data = {}\n    __errors = {}\n    __rules_map = rules_to_objects_map\n    __user_provided_validation_messages = {}\n    __error_bag = ErrorBag()\n\n    @staticmethod\n    def authorize() -> bool:\n        raise NotImplementedError(\"Method `authorize` not implemented\")\n\n    @staticmethod\n    def rules() -> Dict:\n        \"\"\"Returns a dictionary of checkr rules for the request.\n\n        :raises NotImplementedError: The method is not implemented.\n        :return: A dictionary of checkr rules.\n        :rtype: dict\n        \"\"\"\n        raise NotImplementedError(\"Method `rules` not implemented\")\n\n    @classmethod\n    def prepare_for_validation(cls) -> None:\n        \"\"\"A hook that executes before starting the checkr process.\n\n        :return: Nothing\n        :rtype: None\n        \"\"\"\n        pass\n\n    @classmethod\n    def passed_validation(cls) -> None:\n        \"\"\"A hook that executes after the checkr succeeds and the data is valid.\n\n        :return: None\n        :rtype: None\n        \"\"\"\n        pass\n\n    @classmethod\n    def messages(cls) -> Dict:\n        pass\n\n    @classmethod\n    def set_data(cls, data: Dict) -> None:\n        \"\"\"Sets the request data for the class.\n\n        :param data: The data to set for the request.\n        :type data: dict\n        :return: None\n        :rtype: None\n        \"\"\"\n        cls.__data = data\n\n    @classmethod\n    def handle(cls) -> Union[bool, Dict]:\n        \"\"\"Handles checkr for the given rules and returns checkr result.\n\n        :return: A boolean value indicating whether the data passes the checkr or a dictionary containing error\n        messages.\n        :rtype: bool or dict\n        \"\"\"\n        cls.__user_provided_validation_messages = cls.messages() or {}\n        if cls.authorize():\n            fields = cls.rules()\n            for field in fields:\n                cls.__error_bag.set_current_field(field=field)\n                cls.__validate_field(\n                    rules_map=cls.__rules_map,\n                    attribute=field,\n                    rules=fields[field],\n                    value=cls.__data.get(field.split(\".\")[0]),\n                )\n            if cls.__error_bag.has_errors():\n                cls.__is_valid = False\n                return False\n            cls.__is_valid = True\n            return True\n        raise UnauthorizedRequestException(\"Request is not authorized.\")\n\n    @classmethod\n    def passes(cls) -> bool:\n        return cls.__is_valid\n\n    @classmethod\n    def merge(cls, data_to_add: Dict) -> None:\n        \"\"\"Merges the given dictionary of data into the existing request data.\n\n        :param data_to_add: The dictionary of data to merge.\n        :type data_to_add: dict\n        :return: None\n        :rtype: None\n        \"\"\"\n        cls.__data = {**cls.__data, **data_to_add}\n\n    @classmethod\n    def __validate_field(\n        cls, rules_map: Dict, attribute: str, rules: Union[str, List], value: Any\n    ) -> ErrorBag:\n        \"\"\"Validates a single field against the given rules.\n\n        :param attribute: The attribute being validated.\n        :type attribute: str\n        :param rules: The rules to validate against, as a list or a pipe-separated string.\n        :type rules: Union[list, str]\n        :param value: The value of the attribute being validated.\n        :type value: Any\n        :return: List\n        :rtype: List\n        \"\"\"\n        attribute = attribute.split(\".\")\n        cls.__error_bag.set_current_field(field=attribute)\n        validation_errors = cls.__validate_nested_field(\n            rules_map=rules_map,\n            attribute=attribute,\n            rules=rules,\n            value=value,\n        )\n        cls.__error_bag.reset_current_field()\n        return validation_errors\n\n    @classmethod\n    def __validate_single_field(\n        cls, rules_map: Dict, attribute: str, rules: Union[str, List], value: Any\n    ):\n        is_custom_rule = False\n        if isinstance(rules, str):\n            rules = rules.split(\"|\")\n        field_errors = []\n        extracted_rule_with_data = None\n        for rule in rules:\n            if isinstance(rule, str):\n                try:\n                    extracted_rule_with_data = cls.extract_rule_data(rule=rule)\n                    rule_object = rules_map[extracted_rule_with_data[\"rule_name\"]]()\n                    rule_object.set_validation_payload(\n                        payload=extracted_rule_with_data[\"rule_payload\"]\n                    )\n                except KeyError:\n                    raise InvalidRuleException(\n                        f\"Invalid validation rule: {extracted_rule_with_data['rule_name']}. \"\n                        f\"Check the provided rules dictionary.\"\n                    )\n            else:\n                rule_object = rule\n                is_custom_rule = True\n            try:\n                if not rule_object.validate(attribute=attribute, value=value):\n                    custom_validation_message = cls.__user_provided_validation_messages.get(\n                        f'{cls.__error_bag.get_current_field()[0]}.{extracted_rule_with_data[\"rule_name\"]}'\n                    )\n                    cls.__error_bag.add_error(\n                        rule_name=extracted_rule_with_data[\"rule_name\"]\n                        if not is_custom_rule\n                        else str(rule),\n                        error=custom_validation_message\n                        or rule_object.message(attribute=attribute[0]),\n                    )\n            except (ValueError, AttributeError):\n                raise InvalidRuleException(\n                    f\"Invalid validation rule: {extracted_rule_with_data['rule_name']}. \"\n                    f\"Check the provided rules dictionary.\"\n                )\n        return field_errors\n\n    @classmethod\n    def __validate_nested_field(\n        cls,\n        rules_map: Dict,\n        attribute: Union[str, List],\n        rules: Union[str, List],\n        value: Any,\n    ):\n        if len(attribute) == 1:\n            if attribute[0] == \"*\":\n                for key, single_value in enumerate(value):\n                    cls.__validate_single_field(\n                        rules_map=rules_map,\n                        attribute=attribute,\n                        rules=rules,\n                        value=single_value,\n                    )\n            else:\n                cls.__validate_single_field(\n                    rules_map=rules_map,\n                    attribute=attribute,\n                    rules=rules,\n                    value=value[attribute[0]] if isinstance(value, Dict) else value,\n                )\n        else:\n            if attribute[0] == \"*\":\n                try:\n                    for key, single_value in enumerate(value):\n                        cls.__validate_nested_field(\n                            rules_map=rules_map,\n                            attribute=attribute[1:],\n                            rules=rules,\n                            value=single_value.get(attribute[1]),\n                        )\n                except TypeError:\n                    custom_rule = cls.__user_provided_validation_messages.get(\n                        f\"{cls.__error_bag.get_current_field()[0]}.required\"\n                    )\n                    cls.__error_bag.add_error(\n                        rule_name=\"required\", error=custom_rule or \"Field is required\"\n                    )\n            else:\n                cls.__validate_nested_field(\n                    rules_map=rules_map,\n                    attribute=attribute[1:],\n                    rules=rules,\n                    value=value,\n                )\n        return cls.__error_bag\n\n    @classmethod\n    def get_errors(cls) -> ErrorBag:\n        \"\"\"Returns the checkr errors stored in the class.\n\n        :return: A dictionary containing errors resulting from the checkr process.\n        :rtype: dict\n        \"\"\"\n        return cls.__error_bag\n\n    @classmethod\n    def extract_rule_data(cls, rule: str) -> Dict:\n        rule_parts = rule.split(\":\", 1)\n        rule_name = rule_parts[0]\n        rule_payload = rule_parts[-1] if rule_parts[0] != rule_parts[-1] else None\n        return {\n            \"rule_name\": rule_name,\n            \"rule_payload\": (\n                cls.extract_rule_payload(rule_payload) if rule_payload else rule_payload\n            ),\n        }\n\n    @classmethod\n    def extract_rule_payload(cls, payload: str) -> Union[List, str]:\n        payload = payload.split(\",\")\n        return payload[0] if len(payload) == 1 else payload\n\n    def get_data(self) -> Dict:\n        return self.__data", ""]}
{"filename": "checkr/rules_map.py", "chunked_list": ["from .rules.Boolean import Boolean\nfrom .rules.Endswith import Endswith\nfrom .rules.Email import Email\nfrom .rules.NotInArray import NotInArray\nfrom .rules.Startswith import Startswith\nfrom .rules.Url import Url\nfrom .rules.Uuid import Uuid\nfrom .rules.Ulid import Ulid\nfrom .rules.Gte import Gte\nfrom .rules.Gt import Gt", "from .rules.Gte import Gte\nfrom .rules.Gt import Gt\nfrom .rules.DateAfter import DateAfter\nfrom .rules.DateAfterOrEqual import DateAfterOrEqual\nfrom .rules.ArrayOf import ArrayOf\nfrom .rules.DateBefore import DateBefore\nfrom .rules.DateBeforeOrEqual import DateBeforeOrEqual\nfrom .rules.Decimal import Decimal\nfrom .rules.InArray import InArray\nfrom .rules.Array import Array", "from .rules.InArray import InArray\nfrom .rules.Array import Array\nfrom .rules.Integer import Integer\nfrom .rules.Ip import Ip\nfrom .rules.Ipv4 import Ipv4\nfrom .rules.Ipv6 import Ipv6\nfrom .rules.Json import Json\nfrom .rules.Lowercase import Lowercase\nfrom .rules.Lt import Lt\nfrom .rules.Lte import Lte", "from .rules.Lt import Lt\nfrom .rules.Lte import Lte\nfrom .rules.MacAddress import MacAdress\nfrom .rules.Max import Max\nfrom .rules.MaxDigits import MaxDigits\nfrom .rules.Min import Min\nfrom .rules.MinDigits import MinDigits\nfrom .rules.Nullable import Nullable\nfrom .rules.String import String\nfrom .rules.Required import Required", "from .rules.String import String\nfrom .rules.Required import Required\nfrom .rules.Numeric import Numeric\nfrom .rules.Between import Between\nfrom .rules.Uppercase import Uppercase\n\nrules_to_objects_map = {\n    \"between\": Between,\n    \"string\": String,\n    \"int\": Integer,", "    \"string\": String,\n    \"int\": Integer,\n    \"required\": Required,\n    \"numeric\": Numeric,\n    \"in_array\": InArray,\n    \"array\": Array,\n    \"array_of\": ArrayOf,\n    \"date_after\": DateAfter,\n    \"date_after_or_equal\": DateAfterOrEqual,\n    \"date_before\": DateBefore,", "    \"date_after_or_equal\": DateAfterOrEqual,\n    \"date_before\": DateBefore,\n    \"date_before_or_equal\": DateBeforeOrEqual,\n    \"min\": Min,\n    \"max\": Max,\n    \"max_digits\": MaxDigits,\n    \"min_digits\": MinDigits,\n    \"json\": Json,\n    \"nullable\": Nullable,\n    \"decimal\": Decimal,", "    \"nullable\": Nullable,\n    \"decimal\": Decimal,\n    \"gt\": Gt,\n    \"gte\": Gte,\n    \"lt\": Lt,\n    \"lte\": Lte,\n    \"ip\": Ip,\n    \"ipv4\": Ipv4,\n    \"ipv6\": Ipv6,\n    \"lowercase\": Lowercase,", "    \"ipv6\": Ipv6,\n    \"lowercase\": Lowercase,\n    \"uppercase\": Uppercase,\n    \"mac_address\": MacAdress,\n    \"uuid\": Uuid,\n    \"ulid\": Ulid,\n    \"url\": Url,\n    \"startswith\": Startswith,\n    \"endswith\": Endswith,\n    \"email\": Email,", "    \"endswith\": Endswith,\n    \"email\": Email,\n    \"not_in_array\": NotInArray,\n    \"bool\": Boolean,\n}\n"]}
{"filename": "checkr/__init__.py", "chunked_list": ["from typing import Dict\n\nfrom .exceptions import ValidationError\n\n\ndef validate(validation_class, request_data: Dict):\n    validation_class.set_data(data=request_data)\n    validation_class.prepare_for_validation()\n    validation_class.handle()\n    if not validation_class.passes():\n        raise ValidationError(\"Invalid data\", errors=validation_class.get_errors())\n    validation_class.passed_validation()\n    return True", ""]}
{"filename": "checkr/ErrorBag.py", "chunked_list": ["import json\nfrom typing import Union, List, Dict\n\n\nclass ErrorBag:\n    def __init__(self):\n        self.__cursor = 0\n        self.__errors: Dict = {}\n        self.__field: str = \"\"\n        self.__level: int = 0\n\n    def __str__(self):\n        return json.dumps(self.__errors)\n\n    def add_error(self, rule_name: str, error: Union[List, Dict, str]) -> None:\n        if len(error) > 0:\n            current_field = self.get_current_field()[0]\n            current_field_errors = self.__errors.get(current_field)\n            if current_field_errors:\n                self.__errors[current_field] = {\n                    **current_field_errors,\n                    **{rule_name: error},\n                }\n            else:\n                self.__errors[current_field] = {rule_name: error}\n\n    def has_errors(self) -> bool:\n        return len(self.__errors.values()) > 0\n\n    def get_current_field(self) -> str:\n        return self.__field\n\n    def set_current_field(self, field: Union[List, str]) -> None:\n        self.__field = field\n\n    def reset_current_field(self) -> None:\n        self.set_current_field(field=\"\")", ""]}
{"filename": "checkr/exceptions.py", "chunked_list": ["class InvalidRuleException(Exception):\n    pass\n\n\nclass ValidationError(Exception):\n    def __init__(self, message, errors):\n        super().__init__(message)\n        self.errors = errors\n\n\nclass UnauthorizedRequestException(Exception):\n    pass", "\n\nclass UnauthorizedRequestException(Exception):\n    pass\n"]}
{"filename": "checkr/rules/Numeric.py", "chunked_list": ["from typing import Union, Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Numeric(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            float(value)\n        except (ValueError, TypeError):\n            return False\n        return True\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} is non-numeric\"", ""]}
{"filename": "checkr/rules/Accepted.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Accepted(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        return value in [\"yes\", \"on\", 1, True]\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} is not accepted\"", ""]}
{"filename": "checkr/rules/DateAfter.py", "chunked_list": ["from datetime import datetime\nfrom typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass DateAfter(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        specified_date = datetime.strptime(self.payload, \"%Y-%m-%d\")\n        given_date = datetime.strptime(value, \"%Y-%m-%d\")\n        return given_date > specified_date\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} is not after {self.payload}\"", ""]}
{"filename": "checkr/rules/Max.py", "chunked_list": ["from typing import Any, Union\n\nfrom .BaseRule import BaseRule\n\n\nclass Max(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        if isinstance(value, Union[int, float]):\n            return value <= float(self.payload)\n        return len(value) <= float(self.payload)\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} length is bigger than {self.payload}\"", ""]}
{"filename": "checkr/rules/Lowercase.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Lowercase(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        return str(value).lower() == str(value)\n\n    def message(self, attribute: str) -> str:\n        return f\"'{attribute}' is not lowercased\"", ""]}
{"filename": "checkr/rules/Decimal.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Decimal(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        if self.payload:\n            return isinstance(value, float) and int(self.payload[0]) <= str(value)[\n                ::-1\n            ].find(\".\") <= int(self.payload[-1])\n        else:\n            return isinstance(value, float)\n\n    def message(self, attribute: str) -> str:\n        if self.payload:\n            return f\"{attribute} does not have the correct number of decimal places\"\n        return f\"'{attribute}' is not a decimal number.\"", ""]}
{"filename": "checkr/rules/Boolean.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Boolean(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        return isinstance(value, bool)\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} is not a boolean\"", ""]}
{"filename": "checkr/rules/MacAddress.py", "chunked_list": ["import re\nfrom typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass MacAdress(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        is_valid_mac = re.match(\n            r\"([0-9A-F]{2}[:]){5}[0-9A-F]{2}|([0-9A-F]{2}[-]){5}[0-9A-F]{2}\",\n            string=value or \"\",\n            flags=re.IGNORECASE,\n        )\n        try:\n            return bool(is_valid_mac.group())\n        except AttributeError:\n            return False\n\n    def message(self, attribute: str) -> str:\n        return f\"'{attribute}' is not a valid MAC address\"", ""]}
{"filename": "checkr/rules/MinDigits.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass MinDigits(BaseRule):\n    __message = None\n\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            return float(self.payload) <= len(str(value).replace(\".\", \"\"))\n        except ValueError:\n            self.__message = f\"{attribute[0]} value is not a valid float or int\"\n            return False\n\n    def message(self, attribute: str) -> str:\n        return (\n            f\"{attribute} number of digits is less than {self.payload}\"\n            if not self.__message\n            else self.__message\n        )", ""]}
{"filename": "checkr/rules/DateBefore.py", "chunked_list": ["from datetime import datetime\nfrom typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass DateBefore(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            specified_date = datetime.strptime(self.payload, \"%Y-%m-%d\")\n            given_date = datetime.strptime(value, \"%Y-%m-%d\")\n            return given_date < specified_date\n        except (TypeError, ValueError):\n            return False\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} is not before {self.payload}\"", ""]}
{"filename": "checkr/rules/DateBeforeOrEqual.py", "chunked_list": ["from datetime import datetime\nfrom typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass DateBeforeOrEqual(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            specified_date = datetime.strptime(self.payload, \"%Y-%m-%d\")\n            given_date = datetime.strptime(value, \"%Y-%m-%d\")\n            return given_date <= specified_date\n        except TypeError:\n            return False\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} is not at {self.payload} or before\"", ""]}
{"filename": "checkr/rules/Nullable.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Nullable(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        return value is None\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} is not nullable\"", ""]}
{"filename": "checkr/rules/Gt.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Gt(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            return float(value) > float(self.payload)\n        except (TypeError, ValueError):\n            return False\n\n    def message(self, attribute: str) -> str:\n        try:\n            return f\"'{attribute}' is not greater than {self.payload}\"\n        except TypeError:\n            return \"You haven't specified any value for comparison\"", ""]}
{"filename": "checkr/rules/Declined.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Declined(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        return value in [\"no\", \"off\", 0, False]\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} is not declined\"", ""]}
{"filename": "checkr/rules/Min.py", "chunked_list": ["from typing import Any, Union\n\nfrom .BaseRule import BaseRule\n\n\nclass Min(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        if isinstance(value, Union[int, float]):\n            return value >= float(self.payload)\n        return len(value) >= float(self.payload)\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} length is smaller than {self.payload}\"", ""]}
{"filename": "checkr/rules/Lt.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Lt(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            return float(value) < float(self.payload)\n        except (TypeError, ValueError):\n            return False\n\n    def message(self, attribute: str) -> str:\n        try:\n            return f\"'{attribute}' is not less than {self.payload}\"\n        except TypeError:\n            return \"You haven't specified any value for comparison\"", ""]}
{"filename": "checkr/rules/Startswith.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Startswith(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        return isinstance(value, str) and value.startswith(self.payload)\n\n    def message(self, attribute: str) -> str:\n        return f\"`{attribute}` does not start with the `{self.payload}`\"", ""]}
{"filename": "checkr/rules/__init__.py", "chunked_list": [""]}
{"filename": "checkr/rules/Url.py", "chunked_list": ["import validators\nfrom typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Url(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        return validators.url(value or \"\")\n\n    def message(self, attribute: str) -> str:\n        return f\"'{attribute}' is not a valid URL\"", ""]}
{"filename": "checkr/rules/Ip.py", "chunked_list": ["import ipaddress\nfrom typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Ip(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            ipaddress.ip_address(value)\n            return True\n        except ValueError:\n            return False\n\n    def message(self, attribute: str) -> str:\n        return f\"'{attribute}' is not a valid IP address\"", ""]}
{"filename": "checkr/rules/Uuid.py", "chunked_list": ["from uuid import UUID\nfrom typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Uuid(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        version = self.payload or 4\n        try:\n            uuid_object = UUID(value, version=version)\n        except ValueError:\n            return False\n        return str(uuid_object) == value\n\n    def message(self, attribute: str) -> str:\n        return f\"'{attribute}' is not a valid UUID\"", ""]}
{"filename": "checkr/rules/String.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass String(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        return isinstance(value, str)\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} is not a string\"", ""]}
{"filename": "checkr/rules/MaxDigits.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass MaxDigits(BaseRule):\n    __message = None\n\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            return float(self.payload) >= len(str(value).replace(\".\", \"\"))\n        except ValueError:\n            self.__message = f\"{attribute[0]} value is not a valid float or int\"\n            return False\n\n    def message(self, attribute: str) -> str:\n        return (\n            f\"{attribute} number of digits is more than {self.payload}\"\n            if not self.__message\n            else self.__message\n        )", ""]}
{"filename": "checkr/rules/Lte.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Lte(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            return float(value) <= float(self.payload)\n        except (TypeError, ValueError):\n            return False\n\n    def message(self, attribute: str) -> str:\n        try:\n            return f\"'{attribute}' is not less than or equal to {self.payload}\"\n        except TypeError:\n            return \"You haven't specified any value for comparison\"", ""]}
{"filename": "checkr/rules/DateAfterOrEqual.py", "chunked_list": ["from datetime import datetime\nfrom typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass DateAfterOrEqual(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        specified_date = datetime.strptime(self.payload, \"%Y-%m-%d\")\n        given_date = datetime.strptime(value, \"%Y-%m-%d\")\n        return given_date >= specified_date\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} is not at {self.payload} or after\"", ""]}
{"filename": "checkr/rules/Required.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Required(BaseRule):\n    def validate(self, attribute: str, value: Any = None) -> bool:\n        return value is not None\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} field is required\"", ""]}
{"filename": "checkr/rules/Email.py", "chunked_list": ["from typing import Any\nimport validators\nfrom validators import ValidationFailure\n\nfrom .BaseRule import BaseRule\n\n\nclass Email(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            return validators.email(value)\n        except ValidationFailure:\n            return False\n\n    def message(self, attribute: str) -> str:\n        return f\"`{attribute}` does not start with the `{self.payload}`\"", ""]}
{"filename": "checkr/rules/Ulid.py", "chunked_list": ["import ulid\nfrom typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Ulid(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            ulid.parse(value)\n        except ValueError:\n            return False\n        return True\n\n    def message(self, attribute: str) -> str:\n        return f\"'{attribute}' is not a valid ULID\"", ""]}
{"filename": "checkr/rules/Endswith.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Endswith(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        return isinstance(value, str) and value.endswith(self.payload)\n\n    def message(self, attribute: str) -> str:\n        return f\"`{attribute}` does not end with the `{self.payload}`\"", ""]}
{"filename": "checkr/rules/Uppercase.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Uppercase(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        return str(value).upper() == str(value)\n\n    def message(self, attribute: str) -> str:\n        return f\"'{attribute}' is not uppercased\"", ""]}
{"filename": "checkr/rules/ArrayOf.py", "chunked_list": ["from typing import Any, List, Dict, Tuple, Union\n\nfrom checkr.exceptions import InvalidRuleException\nfrom .BaseRule import BaseRule\n\n\nclass ArrayOf(BaseRule):\n    def __get_type_from_string(self, type_string):\n        types = {\n            \"int\": int,\n            \"float\": float,\n            \"complex\": complex,\n            \"string\": str,\n            \"bool\": bool,\n            \"dict\": Dict,\n            \"set\": set,\n            \"frozenset\": frozenset,\n            \"list\": List,\n            \"tuple\": Tuple,\n            \"range\": range,\n        }\n        return types[type_string]\n\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            requested_types = [\n                self.__get_type_from_string(type_string=type_string)\n                for type_string in self.payload\n            ]\n            return all(isinstance(v, Union[tuple(requested_types)]) for v in value)\n        except KeyError as e:\n            raise InvalidRuleException(\n                f\"Payload {e} is not allowed on current rule. check the payload name.\"\n            )\n\n    def message(self, attribute: str) -> str:\n        return f\"'{attribute}' is not fully composed of one of these type: `{self.payload}`\"", ""]}
{"filename": "checkr/rules/BaseRule.py", "chunked_list": ["from abc import ABCMeta\nfrom typing import Any\n\n\nclass BaseRule(metaclass=ABCMeta):\n    payload = None\n\n    def __str__(self):\n        return __class__\n\n    def validate(self, attribute: str, value: Any) -> bool:\n        raise NotImplementedError\n\n    def message(self, attribute: str) -> str:\n        pass\n\n    def set_validation_payload(self, payload):\n        self.payload = payload", ""]}
{"filename": "checkr/rules/NotInArray.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass NotInArray(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        if value:\n            return value not in self.payload\n        return True\n\n    def message(self, attribute: str) -> str:\n        return f\"`{attribute}` is in `{self.payload}`\"", ""]}
{"filename": "checkr/rules/Json.py", "chunked_list": ["import json\nfrom typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Json(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            json.loads(value)\n        except (ValueError, TypeError):\n            return False\n        return True\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} is not a valid JSON\"", ""]}
{"filename": "checkr/rules/Gte.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Gte(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            return float(value) >= float(self.payload)\n        except (TypeError, ValueError):\n            return False\n\n    def message(self, attribute: str) -> str:\n        try:\n            return f\"'{attribute}' is not greater than or equal to {self.payload}\"\n        except TypeError:\n            return \"You haven't specified any value for comparison\"", ""]}
{"filename": "checkr/rules/InArray.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass InArray(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        return value in self.payload\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} is not in the given list\"", ""]}
{"filename": "checkr/rules/Ipv6.py", "chunked_list": ["import ipaddress\nfrom typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Ipv6(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            ip = ipaddress.ip_address(value)\n            return True if ip.version == 6 else False\n        except ValueError:\n            return False\n\n    def message(self, attribute: str) -> str:\n        return f\"'{attribute}' is not a valid IPv6 address\"", ""]}
{"filename": "checkr/rules/Between.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Between(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        self.payload.sort()\n        try:\n            return (\n                float(self.payload[0]) <= float(value) <= float(self.payload[-1])\n                if value\n                else False\n            )\n        except ValueError:\n            return False\n\n    def message(self, attribute: str) -> str:\n        return f\"`{attribute}` is not in the specified range\"", ""]}
{"filename": "checkr/rules/Ipv4.py", "chunked_list": ["import ipaddress\nfrom typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Ipv4(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        try:\n            ip = ipaddress.ip_address(value)\n            return True if ip.version == 4 else False\n        except ValueError:\n            return False\n\n    def message(self, attribute: str) -> str:\n        return f\"'{attribute}' is not a valid IPv4 address\"", ""]}
{"filename": "checkr/rules/Array.py", "chunked_list": ["from typing import Any, List\n\nfrom .BaseRule import BaseRule\n\n\nclass Array(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        return isinstance(value, List)\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} is not an array\"", ""]}
{"filename": "checkr/rules/Integer.py", "chunked_list": ["from typing import Any\n\nfrom .BaseRule import BaseRule\n\n\nclass Integer(BaseRule):\n    def validate(self, attribute: str, value: Any) -> bool:\n        return isinstance(value, int)\n\n    def message(self, attribute: str) -> str:\n        return f\"{attribute} is not an integer\"", ""]}
