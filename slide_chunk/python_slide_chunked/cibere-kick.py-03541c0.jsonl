{"filename": "setup.py", "chunked_list": ["import re\n\nimport setuptools\n\nwith open(\"README.md\", \"r\") as f:\n    LONG_DESCRIPTION = f.read()\n\nwith open(\"requirements.txt\", \"r\") as f:\n    REQUIREMENTS = f.read().splitlines()\n", "\nversion = \"\"\nwith open(\"kick/__init__.py\") as f:\n    version = re.search(\n        r'^__version__\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]', f.read(), re.MULTILINE\n    ).group(  # type: ignore\n        1\n    )\n\nif not version:\n    raise RuntimeError(\"version is not set\")", "\nif not version:\n    raise RuntimeError(\"version is not set\")\n\n\nif version.endswith((\"a\", \"b\", \"rc\")):\n    # append version identifier based on commit count\n    try:\n        import subprocess\n\n        p = subprocess.Popen(\n            [\"git\", \"rev-list\", \"--count\", \"HEAD\"],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        out, err = p.communicate()\n        if out:\n            version += out.decode(\"utf-8\").strip()\n        p = subprocess.Popen(\n            [\"git\", \"rev-parse\", \"--short\", \"HEAD\"],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        out, err = p.communicate()\n        if out:\n            version += \"+g\" + out.decode(\"utf-8\").strip()\n    except Exception:\n        pass", "\n\nsetuptools.setup(\n    name=\"kick.py\",\n    author=\"cibere\",\n    author_email=\"contact@cibere.dev\",\n    url=\"https://github.com/cibere/kick.py\",\n    project_urls={\n        \"Code\": \"https://github.com/cibere/kick.py\",\n        \"Issue tracker\": \"https://github.com/cibere/kick.py/issues\",", "        \"Code\": \"https://github.com/cibere/kick.py\",\n        \"Issue tracker\": \"https://github.com/cibere/kick.py/issues\",\n    },\n    version=\"0.0.1\",\n    python_requires=\">=3.11\",\n    install_requires=REQUIREMENTS,\n    packages=[\"kick\"],\n    description=\"\",\n    long_description=LONG_DESCRIPTION,\n    long_description_content_type=\"text/markdown\",", "    long_description=LONG_DESCRIPTION,\n    long_description_content_type=\"text/markdown\",\n    license=\"MIT\",\n)\n"]}
{"filename": "build_docs.py", "chunked_list": ["import glob\nimport re\nimport textwrap\nfrom copy import copy\nfrom typing import Callable, Type\n\nimport kick\n\nDOC_STRING_REGEX = re.compile(r\"\\[\\[(?P<what>[^\\]]*)]]\")\nDISPLAY_REGEX = re.compile(r\"{{(?P<item>[^}]*)}}\")", "DOC_STRING_REGEX = re.compile(r\"\\[\\[(?P<what>[^\\]]*)]]\")\nDISPLAY_REGEX = re.compile(r\"{{(?P<item>[^}]*)}}\")\nSHOW_ALL_REGEX = re.compile(r\"|\\[(?P<item>[^|]*)]|\")\nH3_REGEX = re.compile(r\"(?P<text>[a-zA-Z0-9_-]*)<br>\\n-----------\")\nCODEBLOCK_REGEX = re.compile(r\"`(?P<code>[^`]*)`\")\n\n\nHEADER = \"\"\"\n<head>\n    <link rel=\"stylesheet\" href=\"style.css\">", "<head>\n    <link rel=\"stylesheet\" href=\"style.css\">\n</head>\"\"\"\nRAW_DOCS_DIR = \"raw_docs\"\nFINAL_DOCS_DIR = \"docs\"\nIGNORE_FORMAT_TEXT = \"!IGNORE-FORMAT\"\n\n\ndef convert_file(fp: str) -> None:\n    before_fp = fp\n    after_fp = fp.replace(RAW_DOCS_DIR, FINAL_DOCS_DIR)\n\n    with open(before_fp, \"r\", encoding=\"utf-8\") as f:\n        text = f.read()\n\n    if text.splitlines()[0] != IGNORE_FORMAT_TEXT:\n        for find in SHOW_ALL_REGEX.findall(text):\n            after = \"{{x}}\".replace(\"x\", find) + f\"[[{find}]]\"\n            text = text.replace(f\"|[{find}]|\", after)\n\n        # Docstring\n        for find in DOC_STRING_REGEX.findall(text):\n            try:\n                item = eval(f\"kick.{find}\")\n                doc = item.__doc__ or \"\"\n            except Exception as e:\n                pass\n            else:\n                doc = textwrap.dedent(copy(doc))\n\n                if doc and doc.splitlines()[1].strip() == \"|coro|\":\n                    temp = doc.splitlines()\n                    temp.pop(0)\n                    temp.pop(0)\n                    doc = \"\\n\".join(temp)\n                ret = []\n\n                for line in doc.splitlines():\n                    if line.startswith(\"    \"):\n                        line = f'<span style=\"margin-left: 30px\">{line}</span>'\n                    line += \"<br>\"\n                    ret.append(line)\n\n                text = text.replace(f\"[[{find}]]\", \"\\n\".join(ret))\n\n        for find in DISPLAY_REGEX.findall(text):\n            try:\n                item = eval(f\"kick.{find}\")\n            except Exception as e:\n                pass\n            else:\n                doc = copy(item.__doc__ or \"\")\n                class_ = \"\"\n                tag = 3\n\n                if doc and doc.splitlines()[1].strip() == \"|coro|\":\n                    prefix = \"async def \"\n                    temp = doc.splitlines()\n                    temp.pop(0)\n                    temp.pop(0)\n                    doc = \"\\n\".join(temp)\n                elif getattr(item, \"__is_decorator__\", False) is True:\n                    prefix = \"@\"\n                    class_ = \"at\"\n                elif isinstance(item, Type):\n                    prefix = \"class \"\n                    tag = 2\n                elif isinstance(item, Callable):\n                    prefix = \"def \"\n                else:\n                    prefix = \"\"\n\n                if prefix and not class_:\n                    class_ = prefix.split(\" \")[0]\n\n                after = f\"\"\"\n                <a href=\"#{find}\" class=\"h{tag} hidden\" id=\"{find}\">\n                    <span class=\"{class_}\">\n                        {prefix}\n                    </span>\n                    {find}\n                </a>\n                \"\"\"\n                text = text.replace(\"{{x}}\".replace(\"x\", find), textwrap.dedent(after))\n\n        for find in H3_REGEX.findall(text):\n            item = f\"{find}<br>\\n-----------\"\n            text = text.replace(item, f'<span class=\"h4\">{find}</span>')\n\n        # Codeblock hyperlinks\n        for find in CODEBLOCK_REGEX.findall(text):\n            after = f'<a href=\"#{find}\" class=\"hidden\">`{find}`</a>'\n            text = text.replace(f\"`{find}`\", after)\n\n    with open(after_fp, \"w\", encoding=\"utf-8\") as f:\n        f.write(f\"{HEADER}\\n{text}\")", "def convert_file(fp: str) -> None:\n    before_fp = fp\n    after_fp = fp.replace(RAW_DOCS_DIR, FINAL_DOCS_DIR)\n\n    with open(before_fp, \"r\", encoding=\"utf-8\") as f:\n        text = f.read()\n\n    if text.splitlines()[0] != IGNORE_FORMAT_TEXT:\n        for find in SHOW_ALL_REGEX.findall(text):\n            after = \"{{x}}\".replace(\"x\", find) + f\"[[{find}]]\"\n            text = text.replace(f\"|[{find}]|\", after)\n\n        # Docstring\n        for find in DOC_STRING_REGEX.findall(text):\n            try:\n                item = eval(f\"kick.{find}\")\n                doc = item.__doc__ or \"\"\n            except Exception as e:\n                pass\n            else:\n                doc = textwrap.dedent(copy(doc))\n\n                if doc and doc.splitlines()[1].strip() == \"|coro|\":\n                    temp = doc.splitlines()\n                    temp.pop(0)\n                    temp.pop(0)\n                    doc = \"\\n\".join(temp)\n                ret = []\n\n                for line in doc.splitlines():\n                    if line.startswith(\"    \"):\n                        line = f'<span style=\"margin-left: 30px\">{line}</span>'\n                    line += \"<br>\"\n                    ret.append(line)\n\n                text = text.replace(f\"[[{find}]]\", \"\\n\".join(ret))\n\n        for find in DISPLAY_REGEX.findall(text):\n            try:\n                item = eval(f\"kick.{find}\")\n            except Exception as e:\n                pass\n            else:\n                doc = copy(item.__doc__ or \"\")\n                class_ = \"\"\n                tag = 3\n\n                if doc and doc.splitlines()[1].strip() == \"|coro|\":\n                    prefix = \"async def \"\n                    temp = doc.splitlines()\n                    temp.pop(0)\n                    temp.pop(0)\n                    doc = \"\\n\".join(temp)\n                elif getattr(item, \"__is_decorator__\", False) is True:\n                    prefix = \"@\"\n                    class_ = \"at\"\n                elif isinstance(item, Type):\n                    prefix = \"class \"\n                    tag = 2\n                elif isinstance(item, Callable):\n                    prefix = \"def \"\n                else:\n                    prefix = \"\"\n\n                if prefix and not class_:\n                    class_ = prefix.split(\" \")[0]\n\n                after = f\"\"\"\n                <a href=\"#{find}\" class=\"h{tag} hidden\" id=\"{find}\">\n                    <span class=\"{class_}\">\n                        {prefix}\n                    </span>\n                    {find}\n                </a>\n                \"\"\"\n                text = text.replace(\"{{x}}\".replace(\"x\", find), textwrap.dedent(after))\n\n        for find in H3_REGEX.findall(text):\n            item = f\"{find}<br>\\n-----------\"\n            text = text.replace(item, f'<span class=\"h4\">{find}</span>')\n\n        # Codeblock hyperlinks\n        for find in CODEBLOCK_REGEX.findall(text):\n            after = f'<a href=\"#{find}\" class=\"hidden\">`{find}`</a>'\n            text = text.replace(f\"`{find}`\", after)\n\n    with open(after_fp, \"w\", encoding=\"utf-8\") as f:\n        f.write(f\"{HEADER}\\n{text}\")", "\n\nfiles = glob.glob(f\"{RAW_DOCS_DIR}/*.md\")\n\nfor file in files:\n    print(f\"Starting on {file}...\")\n    convert_file(file)\n    print(f\"Finished {file}\")\n", ""]}
{"filename": "kick/emotes.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom .assets import Asset\nfrom .object import HTTPDataclass\nfrom .utils import cached_property\n\nif TYPE_CHECKING:\n    from .types.emotes import EmotePayload", "if TYPE_CHECKING:\n    from .types.emotes import EmotePayload\n\n__all__ = (\"Emote\",)\n\n\nclass Emote(HTTPDataclass[\"EmotePayload\"]):\n    \"\"\"\n    A dataclass which represents an emote on kick.\n\n    Attributes\n    -----------\n    id: int\n        The emote's id\n    is_global: bool\n        If the emote is a global emote, or from a channel\n    channel_id: int | None\n        returns the channel_id the emote is from, or None if global\n    name: str\n        The emote's name\n    subscribers_only: bool\n        If you have to be a subscriber of the channel to use it. False for global emotes\n    source: `Asset`\n        An asset which contains the emote's source.\n    \"\"\"\n\n    @property\n    def id(self) -> int:\n        \"\"\"\n        The emote's id\n        \"\"\"\n\n        return self._data[\"id\"]\n\n    @cached_property\n    def is_global(self) -> bool:\n        \"\"\"\n        If the emote is a global emote, or from a channel\n        \"\"\"\n\n        return bool(self._data[\"channel_id\"])\n\n    @property\n    def channel_id(self) -> int | None:\n        \"\"\"\n        returns the channel_id the emote is from, or None if global\n        \"\"\"\n\n        return self._data[\"channel_id\"]\n\n    @property\n    def name(self) -> str:\n        \"\"\"\n        The emote's name\n        \"\"\"\n\n        return self._data[\"name\"]\n\n    @property\n    def subscribers_only(self) -> bool:\n        \"\"\"\n        If you have to be a subscriber of the channel to use it. False for global emotes\n        \"\"\"\n\n        return self._data[\"subscribers_only\"]\n\n    @cached_property\n    def source(self) -> Asset:\n        \"\"\"\n        An asset which contains the emote's source.\n        \"\"\"\n\n        return Asset._from_emote(self.id, http=self.http)\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__) and other.id == self.id\n\n    def __str__(self) -> str:\n        return self.name\n\n    def __repr__(self) -> str:\n        return (\n            f\"<Emote id={self.id!r} channel_id={self.channel_id!r} name={self.name!r}>\"\n        )", ""]}
{"filename": "kick/videos.py", "chunked_list": ["from __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING, Any\n\nfrom kick.assets import Asset\n\nfrom .categories import Category\nfrom .object import HTTPDataclass\nfrom .utils import cached_property", "from .object import HTTPDataclass\nfrom .utils import cached_property\n\nif TYPE_CHECKING:\n    from .types.videos import VideoPayload\n\n__all__ = (\"Video\",)\n\n\nclass Video(HTTPDataclass[\"VideoPayload\"]):\n    \"\"\"\n    This dataclass represents a video on kick\n\n    Attributes\n    -----------\n    id: int\n        The video's id\n    slug: str\n        the video's slug\n    channel_id: int\n        Probably the id of the channel the video is from\n    created_at: datetime.datetime\n        When the video was created\n    updated_at: datetime.datetime\n        When the video was last updated\n    title: str\n        The video's title\n    live_stream_id: int\n        The id of the live stream the video is from\n    thumbnail: `Asset` | None\n        The video's thumbnail\n    duration: int\n        How long the video is in seconds\n    language: str\n        The language the video is in\n    is_mature: bool\n        If the video is marked as 18+\n    viewer_count: int\n        How many people have seen the video\n    categories: list[`Category`]\n        The categories the video is in\n    \"\"\"\n\n    @property\n    def id(self) -> int:\n        \"\"\"\n        The video's id\n        \"\"\"\n\n        return self._data[\"id\"]\n\n    @property\n    def slug(self) -> str:\n        \"\"\"\n        the video's slug\n        \"\"\"\n\n        return self._data[\"slug\"]\n\n    @property\n    def channel_id(self) -> int:\n        \"\"\"\n        Probably the id of the channel the video is from\n        \"\"\"\n\n        return self._data[\"channel_id\"]\n\n    @cached_property\n    def created_at(self) -> datetime:\n        \"\"\"\n        When the video was created\n        \"\"\"\n\n        return datetime.fromisoformat(self._data[\"created_at\"])\n\n    @cached_property\n    def updated_at(self) -> datetime:\n        \"\"\"\n        When the video was last updated\n        \"\"\"\n\n        return datetime.fromisoformat(self._data[\"video\"][\"updated_at\"])\n\n    @property\n    def title(self) -> str:\n        \"\"\"\n        The video's title\n        \"\"\"\n\n        return self._data[\"session_title\"]\n\n    @property\n    def live_stream_id(self) -> int:\n        \"\"\"\n        The id of the live stream the video is from\n        \"\"\"\n\n        return self._data[\"video\"][\"live_stream_id\"]\n\n    @property\n    def thumbnail(self) -> Asset | None:\n        \"\"\"\n        The video's thumbnail\n        \"\"\"\n\n        return (\n            None\n            if self._data[\"thumbnail\"] is None\n            else Asset._from_asset_src(data=self._data[\"thumbnail\"], http=self.http)\n        )\n\n    @property\n    def duration(self) -> int:\n        \"\"\"\n        How long the video is in seconds\n        \"\"\"\n\n        return self._data[\"duration\"]\n\n    @property\n    def language(self) -> str:\n        \"\"\"\n        The language the video is in\n        \"\"\"\n\n        return self._data[\"language\"]\n\n    @property\n    def is_mature(self) -> bool:\n        \"\"\"\n        If the video is marked as 18+\n        \"\"\"\n\n        return self._data[\"is_mature\"]\n\n    @property\n    def viewer_count(self) -> int:\n        \"\"\"\n        How many people have seen the video\n        \"\"\"\n\n        return self._data[\"viewer_count\"]\n\n    @cached_property\n    def categories(self) -> list[Category]:\n        \"\"\"\n        The categories the video is in\n        \"\"\"\n\n        return [Category(data=c, http=self.http) for c in self._data[\"categories\"]]\n\n    def __repr__(self) -> str:\n        return (\n            f\"<Video id={self.id!r} slug={self.slug!r} channel_id={self.channel_id!r}>\"\n        )", "\nclass Video(HTTPDataclass[\"VideoPayload\"]):\n    \"\"\"\n    This dataclass represents a video on kick\n\n    Attributes\n    -----------\n    id: int\n        The video's id\n    slug: str\n        the video's slug\n    channel_id: int\n        Probably the id of the channel the video is from\n    created_at: datetime.datetime\n        When the video was created\n    updated_at: datetime.datetime\n        When the video was last updated\n    title: str\n        The video's title\n    live_stream_id: int\n        The id of the live stream the video is from\n    thumbnail: `Asset` | None\n        The video's thumbnail\n    duration: int\n        How long the video is in seconds\n    language: str\n        The language the video is in\n    is_mature: bool\n        If the video is marked as 18+\n    viewer_count: int\n        How many people have seen the video\n    categories: list[`Category`]\n        The categories the video is in\n    \"\"\"\n\n    @property\n    def id(self) -> int:\n        \"\"\"\n        The video's id\n        \"\"\"\n\n        return self._data[\"id\"]\n\n    @property\n    def slug(self) -> str:\n        \"\"\"\n        the video's slug\n        \"\"\"\n\n        return self._data[\"slug\"]\n\n    @property\n    def channel_id(self) -> int:\n        \"\"\"\n        Probably the id of the channel the video is from\n        \"\"\"\n\n        return self._data[\"channel_id\"]\n\n    @cached_property\n    def created_at(self) -> datetime:\n        \"\"\"\n        When the video was created\n        \"\"\"\n\n        return datetime.fromisoformat(self._data[\"created_at\"])\n\n    @cached_property\n    def updated_at(self) -> datetime:\n        \"\"\"\n        When the video was last updated\n        \"\"\"\n\n        return datetime.fromisoformat(self._data[\"video\"][\"updated_at\"])\n\n    @property\n    def title(self) -> str:\n        \"\"\"\n        The video's title\n        \"\"\"\n\n        return self._data[\"session_title\"]\n\n    @property\n    def live_stream_id(self) -> int:\n        \"\"\"\n        The id of the live stream the video is from\n        \"\"\"\n\n        return self._data[\"video\"][\"live_stream_id\"]\n\n    @property\n    def thumbnail(self) -> Asset | None:\n        \"\"\"\n        The video's thumbnail\n        \"\"\"\n\n        return (\n            None\n            if self._data[\"thumbnail\"] is None\n            else Asset._from_asset_src(data=self._data[\"thumbnail\"], http=self.http)\n        )\n\n    @property\n    def duration(self) -> int:\n        \"\"\"\n        How long the video is in seconds\n        \"\"\"\n\n        return self._data[\"duration\"]\n\n    @property\n    def language(self) -> str:\n        \"\"\"\n        The language the video is in\n        \"\"\"\n\n        return self._data[\"language\"]\n\n    @property\n    def is_mature(self) -> bool:\n        \"\"\"\n        If the video is marked as 18+\n        \"\"\"\n\n        return self._data[\"is_mature\"]\n\n    @property\n    def viewer_count(self) -> int:\n        \"\"\"\n        How many people have seen the video\n        \"\"\"\n\n        return self._data[\"viewer_count\"]\n\n    @cached_property\n    def categories(self) -> list[Category]:\n        \"\"\"\n        The categories the video is in\n        \"\"\"\n\n        return [Category(data=c, http=self.http) for c in self._data[\"categories\"]]\n\n    def __repr__(self) -> str:\n        return (\n            f\"<Video id={self.id!r} slug={self.slug!r} channel_id={self.channel_id!r}>\"\n        )", ""]}
{"filename": "kick/chatroom.py", "chunked_list": ["from __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING, AsyncIterator, Optional\n\nfrom kick.http import HTTPClient\n\nfrom .emotes import Emote\nfrom .enums import ChatroomChatMode\nfrom .object import HTTPDataclass", "from .enums import ChatroomChatMode\nfrom .object import HTTPDataclass\nfrom .polls import Poll\nfrom .users import PartialUser\nfrom .utils import cached_property\n\nif TYPE_CHECKING:\n    from .chatter import Chatter\n    from .types.chatroom import BanEntryPayload\n    from .types.user import ChatroomPayload\n    from .users import User", "\n__all__ = (\"Chatroom\", \"BanEntry\", \"PartialChatroom\")\n\n\nclass BanEntry(HTTPDataclass[\"BanEntryPayload\"]):\n    \"\"\"\n    A dataclass which represents a ban entry on kick.\n    This includes timeouts.\n\n    Attributes\n    -----------\n    reason: str\n        The reason for the ban/timeout\n    is_permanent: bool\n        Whether the ban is permanent. True == ban, false == timeout\n    user: `PartialUser`\n        The user the action was towards\n    banned_by: `PartialUser`\n        The responsible mod\n    expires_at: datetime.datetime | None\n        when the timeout expires at. None for a ban\n    banned_at: datetime.datetime\n        When the action happened\n    chatroom: Chatroom\n        The chatroom the action happened in\n    \"\"\"\n\n    chatroom: Chatroom | PartialChatroom\n\n    @property\n    def reason(self) -> str:\n        \"\"\"\n        The reason for the ban/timeout\n        \"\"\"\n\n        return self._data[\"ban\"][\"reason\"]\n\n    @property\n    def is_permanent(self) -> bool:\n        \"\"\"\n        Whether the ban is permanent. True == ban, false == timeout\n        \"\"\"\n\n        return self._data[\"ban\"][\"permanent\"]\n\n    @cached_property\n    def user(self) -> PartialUser:\n        \"\"\"\n        The user the action was towards\n        \"\"\"\n\n        return PartialUser(\n            id=self._data[\"banned_user\"][\"id\"],\n            username=self._data[\"banned_user\"][\"username\"],\n            http=self.http,\n        )\n\n    @cached_property\n    def banned_by(self) -> PartialUser:\n        \"\"\"\n        The responsible mod\n        \"\"\"\n\n        return PartialUser(\n            id=self._data[\"banned_by\"][\"id\"],\n            username=self._data[\"banned_by\"][\"username\"],\n            http=self.http,\n        )\n\n    @cached_property\n    def banned_at(self) -> datetime:\n        \"\"\"\n        When the action happened\n        \"\"\"\n\n        return datetime.fromisoformat(self._data[\"ban\"][\"banned_at\"])\n\n    @cached_property\n    def expires_at(self) -> datetime | None:\n        \"\"\"\n        When the timeout expires at. None for a ban\n        \"\"\"\n\n        return (\n            None\n            if self.is_permanent is True\n            else datetime.fromisoformat(self._data[\"ban\"][\"expires_at\"])\n        )\n\n    async def unban(self) -> None:\n        \"\"\"\n        |coro|\n\n        Unbans the chatter from the chatroom.\n\n        Raises\n        -----------\n        NotFound\n            Streamer or chatter not found\n        HTTPException\n            Unbanning the chatter failed\n        Forbidden\n            You are unauthorized from unbanning the chatter\n        \"\"\"\n\n        await self.http.unban_user(self.chatroom.streamer_name, self.user.username)", "\n\nclass PartialChatroom:\n    \"\"\"\n    A dataclass that represents a kick chatroom.\n\n    Attributes\n    -----------\n    id: int\n        The chatroom's id\n    streamer: `User`\n        The user who this chatroom belongs to\n    \"\"\"\n\n    def __init__(self, *, id: int, streamer_name: str, http: HTTPClient) -> None:\n        self.id = id\n        self.streamer_name = streamer_name\n        self.http = http\n\n    async def connect(self) -> None:\n        \"\"\"\n        |coro|\n\n        Connects to the chatroom, making it so you can now listen for the messages.\n        \"\"\"\n\n        await self.http.ws.subscribe_to_chatroom(self.id)\n        self.http.client._chatrooms[self.id] = self\n\n    async def disconnect(self) -> None:\n        \"\"\"\n        |coro|\n\n        Disconnects to the chatroom, making it so you can no longer listen for the messages.\n        \"\"\"\n\n        await self.http.ws.unsubscribe_to_chatroom(self.id)\n        self.http.client._chatrooms.pop(self.id)\n\n    async def send(self, content: str, /) -> None:\n        \"\"\"\n        |coro|\n\n        Sends a message in the chatroom\n\n        Parameters\n        -----------\n        content: str\n            The message's content\n\n        Raises\n        -----------\n        NotFound\n            Streamer or chatter not found\n        HTTPException\n            Sending the message failed\n        Forbidden\n            You are unauthorized from sending the message\n        \"\"\"\n\n        await self.http.send_message(self.id, content)\n\n    async def fetch_chatter(self, chatter_name: str, /) -> Chatter:\n        \"\"\"\n        |coro|\n\n        Fetches a chatroom's chatter\n\n        Parameters\n        -----------\n        chatter_name: str\n            The chatter's username\n\n        Raises\n        -----------\n        NotFound\n            Streamer or chatter not found\n        HTTPException\n            Fetching the chatter failed\n\n        Returns\n        -----------\n        Chatter\n            The chatter\n        \"\"\"\n\n        from .chatter import Chatter\n\n        data = await self.http.get_chatter(self.streamer_name, chatter_name)\n        chatter = Chatter(data=data, http=self.http, chatroom=self)\n        return chatter\n\n    async def fetch_rules(self) -> str:\n        \"\"\"\n        |coro|\n\n        Fetches the chatroom's rules\n\n        Raises\n        -----------\n        NotFound\n            Streamer Not Found\n        HTTPException\n            Fetching the rules failed\n\n        Returns\n        -----------\n        str\n            The rules\n        \"\"\"\n\n        data = await self.http.get_chatroom_rules(self.streamer_name)\n        return data[\"data\"][\"rules\"]\n\n    async def fetch_banned_words(self) -> list[str]:\n        \"\"\"\n        |coro|\n\n        Fetches the chatroom's banned words\n\n        Raises\n        -----------\n        NotFound\n            Streamer Not Found\n        HTTPException\n            Fetching the words failed\n\n        Returns\n        -----------\n        list[str]\n            A list of the banned words\n        \"\"\"\n\n        data = await self.http.get_channels_banned_words(self.streamer_name)\n        return data[\"data\"][\"words\"]\n\n    async def fetch_bans(self) -> AsyncIterator[BanEntry]:\n        \"\"\"\n        |coro|\n\n        Fetches the chatroom's bans\n\n        Raises\n        -----------\n        NotFound\n            Streamer Not Found\n        HTTPException\n            Fetching the bans failed\n\n        Returns\n        -----------\n        AsyncIterator[BanEntry]\n            Yields all of the ban entries\n        \"\"\"\n\n        data = await self.http.get_channel_bans(self.streamer_name)\n        for entry_data in data:\n            entry = BanEntry(data=entry_data, http=self.http)\n            entry.chatroom = self\n            yield entry\n\n    async def fetch_poll(self) -> Poll:\n        \"\"\"\n        |coro|\n\n        Gets a poll from the chatroom\n\n        Raises\n        -----------\n        NotFound\n            There is no poll in the current chatroom or Streamer Not Found\n        HTTPException\n            Fetching the poll failed\n\n        Returns\n        -----------\n        Poll\n            The poll\n        \"\"\"\n\n        data = await self.http.get_poll(self.streamer_name)\n        poll = Poll(data=data, http=self.http)\n        poll.chatroom = self\n        return poll\n\n    async def fetch_emotes(\n        self, *, include_global: bool = False\n    ) -> AsyncIterator[Emote]:\n        \"\"\"\n        |coro|\n\n        Fetches the emotes from the current chatroom.\n\n        Parameters\n        -----------\n        include_global: bool = False\n            Whether to include global emotes or not\n\n        Raises\n        -----------\n        NotFound\n            Streamer Not Found\n        HTTPException\n            Fetching the bans failed\n\n        Returns\n        -----------\n        AsyncIterator[Emote]\n            Yields each emote. Starting with from the chatroom, then global\n        \"\"\"\n\n        data = await self.http.get_emotes(self.streamer_name)\n        for emote in data[2][\"emotes\"]:\n            yield Emote(data=emote, http=self.http)\n        if include_global is True:\n            for emote in data[1][\"emotes\"]:\n                yield Emote(data=emote, http=self.http)", "\n\nclass Chatroom(PartialChatroom):\n    \"\"\"\n    A dataclass that represents a kick chatroom.\n\n    Attributes\n    -----------\n    id: int\n        The chatroom's id\n    chatable_type: str\n        The chatroom's type\n    created_at: datetime.datetime\n        When the chatroom was created\n    updated_at: datetime.datetime\n        When the chatroom was last updated\n    chat_mode: ChatroomChatMode\n        The mode the chatroom is in\n    slowmode: bool\n        Whether slowmode is enabled\n    followers_mode: bool\n        Whether followers_mode is enabled\n    subscribers_mode: bool\n        Whether subscribers_mode is enabled\n    emotes_mode: bool\n        Whether emotes_mode is enabled\n    slow_mode: bool\n        Whether slow_mode is enabled\n    message_interval: int\n        Interval at which messages can be sent when slow_mode is enabled\n    following_min_duration: int\n        Unknown on what this is\n    streamer: `User`\n        The user who this chatroom belongs to\n    \"\"\"\n\n    def __init__(self, *, data: ChatroomPayload, streamer: User, http: HTTPClient):\n        super().__init__(id=data[\"id\"], streamer_name=streamer.username, http=http)\n        self._data = data\n        self.streamer = streamer\n\n    @property\n    def chatable_type(self) -> str:\n        \"\"\"\n        The chatroom's type\n        \"\"\"\n\n        return self._data[\"chatable_type\"]\n\n    @cached_property\n    def created_at(self) -> datetime:\n        \"\"\"\n        When the chatroom was created\n        \"\"\"\n\n        return datetime.fromisoformat(self._data[\"created_at\"])\n\n    @cached_property\n    def updated_at(self) -> datetime:\n        \"\"\"\n        When the chatroom was last updated\n        \"\"\"\n\n        return datetime.fromisoformat(self._data[\"updated_at\"])\n\n    @property\n    def chat_mode(self) -> ChatroomChatMode:\n        \"\"\"\n        The mode the chatroom is in\n        \"\"\"\n\n        return ChatroomChatMode(self._data[\"chat_mode\"])\n\n    @property\n    def slowmode(self) -> bool:\n        \"\"\"\n        Whether slowmode is enabled\n        \"\"\"\n\n        return self._data[\"slow_mode\"]\n\n    @property\n    def followers_mode(self) -> bool:\n        \"\"\"\n        Whether followers_mode is enabled\n        \"\"\"\n\n        return self._data[\"followers_mode\"]\n\n    @property\n    def subscribers_mode(self) -> bool:\n        \"\"\"\n        Whether subscribers_mode is enabled\n        \"\"\"\n\n        return self._data[\"subscribers_mode\"]\n\n    @property\n    def emotes_mode(self) -> bool:\n        \"\"\"\n        Whether emotes_mode is enabled\n        \"\"\"\n\n        return self._data[\"emotes_mode\"]\n\n    @property\n    def slow_mode(self) -> bool:\n        \"\"\"\n        Whether slow_mode is enabled\n        \"\"\"\n\n        return self._data[\"slow_mode\"]\n\n    @property\n    def message_interval(self) -> int:\n        \"\"\"\n        Interval at which messages can be sent when slow_mode is enabled\n        \"\"\"\n\n        return self._data[\"message_interval\"]\n\n    @property\n    def following_min_duration(self) -> int:\n        \"\"\"\n        Unknown on what this is\n        \"\"\"\n\n        return self._data[\"following_min_duration\"]\n\n    async def edit(\n        self,\n        *,\n        followers_only_mode: Optional[bool] = None,\n        emotes_only_mode: Optional[bool] = None,\n        subscribers_only_mode: Optional[bool] = None,\n        slow_mode_enabled: Optional[bool] = None,\n        slow_mode_interval: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        |coro|\n\n        Edits the chatroom's settings\n\n        Parameters\n        -----------\n        followers_only_mode: Optional[bool] = None\n            Lets you enable/disable followers only mode.\n        emotes_only_mode: Optional[bool] = None\n            Lets you enable/disable emotes only mode.\n        subscribers_only_mode: Optional[bool] = None\n            Lets you enable/disable subscribers only mode.\n        slow_mode_enabled: Optional[bool] = None\n            Lets you enable/disable slow_mode only mode.\n        slow_mode_interval: Optional[int] = None\n            Lets you set the slow mode interval\n\n        Raises\n        -----------\n        `NotFound`\n            Streamer not found\n        `HTTPException`\n            Editing the chatroom failed\n        `Forbidden`\n            You are unauthorized from editing the chatroom.\n        \"\"\"\n\n        streamer_name = self.streamer_name\n\n        payload = {}\n        if self.followers_mode is not None:\n            payload[\"followers_mode\"] = self.followers_mode\n\n        if self.emotes_mode is not None:\n            payload[\"emotes_mode\"] = self.emotes_mode\n\n        if self.subscribers_mode is not None:\n            payload[\"subscribers_mode\"] = self.subscribers_mode\n\n        if self.slow_mode is not None:\n            payload[\"slow_mode\"] = self.slow_mode\n            if self.slow_mode and self.message_interval is not None:\n                payload[\"message_interval\"] = self.message_interval\n\n        if not payload:\n            raise ValueError(\"No valid parameters provided for chatroom editing.\")\n\n        await self.http.edit_chatroom(streamer_name, payload)\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__) and other.id == self.id\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__} id={self.id!r} streamer={self.streamer_name!r}>\"", ""]}
{"filename": "kick/users.py", "chunked_list": ["from __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING\n\nfrom kick.categories import Category\n\nfrom .assets import Asset\nfrom .badges import SubscriberBadge\nfrom .leaderboard import GiftLeaderboard", "from .badges import SubscriberBadge\nfrom .leaderboard import GiftLeaderboard\nfrom .livestream import Livestream\nfrom .object import BaseDataclass\nfrom .utils import cached_property\nfrom .videos import Video\n\nif TYPE_CHECKING:\n    from .chatroom import Chatroom\n    from .http import HTTPClient\n    from .types.user import ClientUserPayload, InnerUser, UserPayload", "\n__all__ = (\"User\", \"Socials\", \"PartialUser\", \"ClientUser\")\n\n\nclass Socials(BaseDataclass[\"InnerUser | ClientUserPayload\"]):\n    \"\"\"\n    The socials a user on kick has added to their profile\n\n    Attributes\n    -----------\n    instagram: str\n        Their instagram\n    youtube: str\n        Their youtube\n    twitter: str\n        Their twitter\n    discord: str\n        Their discord\n    tiktok: str\n        Their tiktok\n    facebook: str\n        Their facebook\n    \"\"\"\n\n    @property\n    def instagram(self) -> str:\n        \"\"\"\n        Their instagram\n        \"\"\"\n\n        return self._data[\"instagram\"] or \"\"\n\n    @property\n    def youtube(self) -> str:\n        \"\"\"\n        Their youtube\n        \"\"\"\n\n        return self._data[\"youtube\"] or \"\"\n\n    @property\n    def twitter(self) -> str:\n        \"\"\"\n        Their twitter\n        \"\"\"\n\n        return self._data[\"twitter\"] or \"\"\n\n    @property\n    def discord(self) -> str:\n        \"\"\"\n        Their discord\n        \"\"\"\n\n        return self._data[\"discord\"] or \"\"\n\n    @property\n    def tiktok(self) -> str:\n        \"\"\"\n        Their tiktok\n        \"\"\"\n\n        return self._data[\"tiktok\"] or \"\"\n\n    @property\n    def facebook(self) -> str:\n        \"\"\"\n        Their facebook\n        \"\"\"\n\n        return self._data[\"facebook\"] or \"\"", "\n\nclass BaseUser:\n    def __init__(self, *, id: int, username: str, http: HTTPClient) -> None:\n        self.id = id\n        self.username = username\n        self.http = http\n\n    async def fetch_videos(self) -> list[Video]:\n        data = await self.http.get_streamer_videos(self.username)\n        return [Video(data=v, http=self.http) for v in data]\n\n    async def fetch_gift_leaderboard(self) -> GiftLeaderboard:\n        data = await self.http.get_channel_gift_leaderboard(self.username)\n        leaderboard = GiftLeaderboard(data=data)\n        leaderboard.streamer = self\n        return leaderboard\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__) and other.id == self.id\n\n    def __str__(self) -> str:\n        return self.username\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__} id={self.id!r} username={self.username!r}>\"", "\n\nclass PartialUser(BaseUser):\n    \"\"\"\n    This dataclass represents a partial user on kick\n\n    Attributes\n    -----------\n    id: int\n        The user's id\n    username: str\n        The user's name\n    \"\"\"\n\n    async def fetch(self) -> User:\n        \"\"\"\n        |coro|\n\n        Fetches a full user object\n\n        Raises\n        -----------\n        `HTTPException`\n            Fetching the user failed\n        `NotFound`\n            User not found\n\n        Returns\n        -----------\n        `User`\n            The full user object\n        \"\"\"\n\n        data = await self.http.get_user(self.username)\n        return User(data=data, http=self.http)", "\n\nclass User:\n    \"\"\"\n    A dataclass which represents a User on kick\n\n    Attributes\n    -----------\n    id: int\n        The user's id\n    channel_id: int\n        The user's channel id\n    username: str\n        The user's name\n    state: str\n        The state the user has said they live in\n    socials: `Socials`\n        The socials the user has said they have\n    country: str\n        The country the user has said they live in\n    playback_url: str\n        The user's playback url\n    slug: str\n        The user's slug\n    vod_enabled: bool\n        If the user has vods enabled\n    is_banned: bool\n        If the user is banned\n    subscription_enabled: bool\n        If the user has subscriptions enabled\n    follower_count: int\n        The amount of followers the user has\n    subscriber_badges: list[`SubscriberBadge`]\n        A list of subscriber badges the user has\n    online_banner: `Asset` | None\n        the banner that gets displayed when the user is live\n    offline_banner: `Asset` | None\n        the banner that gets displayed when the user is offline\n    is_muted: bool\n        If the user is muted\n    is_verified: bool\n        If the user is verified\n    avatar: `Asset`\n        The user's avatar\n    can_host: bool\n        If the user can host\n    bio: str\n        The user's bio\n    agreed_to_terms: bool\n        if the user has agreed to kick's TOS\n    email_verified_at: datetime.datetime\n        When the user verified their user\n    livestream: `Livestream` | None\n        The user's livestream\n    chatroom: `Chatroom`\n        The user's chatroom\n    recent_categories: list[`Category`]\n        The categories the user has recently gone live in\n    \"\"\"\n\n    def __init__(self, *, data: UserPayload, http: HTTPClient) -> None:\n        self._data = data\n        self.http = http\n\n    @property\n    def id(self) -> int:\n        return self._data[\"user_id\"]\n\n    @property\n    def channel_id(self) -> int:\n        return self._data[\"id\"]\n\n    @property\n    def playback_url(self) -> str:\n        return self._data[\"playback_url\"]\n\n    @property\n    def slug(self) -> str:\n        return self._data[\"slug\"]\n\n    @property\n    def vod_enabled(self) -> bool:\n        return self._data[\"vod_enabled\"]\n\n    @property\n    def is_banned(self) -> bool:\n        return self._data[\"is_banned\"]\n\n    @property\n    def subscription_enabled(self) -> bool:\n        return self._data[\"subscription_enabled\"]\n\n    @property\n    def follower_count(self) -> int:\n        return self._data[\"followers_count\"]\n\n    @property\n    def subscriber_badges(self) -> list[SubscriberBadge]:\n        return [\n            SubscriberBadge(data=c, http=self.http)\n            for c in self._data[\"subscriber_badges\"]\n        ]\n\n    @property\n    def follower_badges(self) -> list:\n        \"\"\"THIS IS RAW DATA\"\"\"\n        return self._data[\"follower_badges\"]\n\n    @cached_property\n    def online_banner(self) -> Asset | None:\n        return (\n            Asset(url=self._data[\"banner_image\"][\"url\"], http=self.http)  # type: ignore\n            if self._data.get(\"banner_image\", None)\n            else None\n        )\n\n    @cached_property\n    def offline_banner(self) -> Asset | None:\n        return (\n            Asset._from_asset_src(\n                data=self._data[\"offline_banner_image\"], http=self.http\n            )\n            if self._data[\"offline_banner_image\"]\n            else None\n        )\n\n    @property\n    def is_muted(self) -> bool:\n        return self._data[\"muted\"]\n\n    @property\n    def is_verified(self) -> bool:\n        return self._data[\"verified\"]\n\n    @cached_property\n    def avatar(self) -> Asset:\n        return Asset(url=self._data[\"user\"][\"profile_pic\"], http=self.http)\n\n    @property\n    def can_host(self) -> bool:\n        return self._data[\"can_host\"]\n\n    @property\n    def bio(self) -> str:\n        return self._data[\"user\"][\"bio\"]\n\n    @property\n    def agreed_to_terms(self) -> bool:\n        return self._data[\"user\"][\"agreed_to_terms\"]\n\n    @cached_property\n    def email_verified_at(self) -> datetime:\n        return datetime.fromisoformat(self._data[\"user\"][\"email_verified_at\"])\n\n    @property\n    def username(self) -> str:\n        return self._data[\"user\"][\"username\"]\n\n    @property\n    def country(self) -> str:\n        return self._data[\"user\"][\"country\"]\n\n    @property\n    def state(self) -> str:\n        return self._data[\"user\"][\"state\"]\n\n    @cached_property\n    def socials(self) -> Socials:\n        return Socials(data=self._data[\"user\"])\n\n    @cached_property\n    def livestream(self) -> Livestream | None:\n        livestream = self._data[\"livestream\"]\n        if not livestream:\n            return\n        return Livestream(data=livestream, http=self.http)\n\n    @cached_property\n    def chatroom(self) -> Chatroom:\n        from .chatroom import Chatroom\n\n        chatroom = Chatroom(data=self._data[\"chatroom\"], http=self.http, streamer=self)\n        return chatroom\n\n    @cached_property\n    def recent_categories(self) -> list[Category]:\n        return [\n            Category(data=c, http=self.http) for c in self._data[\"recent_categories\"]\n        ]\n\n    async def start_watch(self) -> None:\n        \"\"\"\n        |coro|\n\n        Watches a user to see if they go online.\n        \"\"\"\n\n        await self.http.ws.watch_channel(self.channel_id)\n        self.http.client._watched_users[self.channel_id] = self\n\n    async def stop_watching(self) -> None:\n        \"\"\"\n        |coro|\n\n        Stops watching the user\n        \"\"\"\n\n        await self.http.ws.unwatch_channel(self.channel_id)\n        self.http.client._watched_users.pop(self.channel_id)", "\n\nclass ClientUser(BaseUser):\n    def __init__(self, *, data: ClientUserPayload, http: HTTPClient) -> None:\n        self._data = data\n        self.http = http\n\n    @property\n    def id(self) -> int:\n        return self._data[\"id\"]\n\n    @property\n    def username(self) -> str:\n        return self._data[\"username\"]\n\n    @property\n    def slug(self) -> str:\n        return self._data[\"username\"].lower().replace(\"_\", \"-\")\n\n    @property\n    def bio(self) -> str:\n        return self._data[\"bio\"] or \"\"\n\n    @property\n    def agreed_to_terms(self) -> bool:\n        return self._data[\"agreed_to_terms\"]\n\n    @cached_property\n    def email_verified_at(self) -> datetime:\n        return datetime.fromisoformat(self._data[\"email_verified_at\"])\n\n    @property\n    def country(self) -> str | None:\n        return self._data[\"country\"]\n\n    @property\n    def city(self) -> str | None:\n        return self._data[\"city\"]\n\n    @property\n    def state(self) -> str | None:\n        return self._data[\"state\"]\n\n    @cached_property\n    def socials(self) -> Socials:\n        return Socials(data=self._data)\n\n    @cached_property\n    def avatar(self) -> Asset | None:\n        url = self._data[\"profilepic\"]\n        if url is None:\n            return\n        return Asset(url=url, http=self.http)", "\n\nAnyUser = ClientUser | BaseUser | User | PartialUser\n"]}
{"filename": "kick/categories.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any\n\nfrom .assets import Asset\nfrom .object import HTTPDataclass\nfrom .utils import cached_property\n\nif TYPE_CHECKING:\n    from .types.categories import Category as CategoryPayload\n    from .types.categories import InnerCategory as ParentCategoryPayload", "if TYPE_CHECKING:\n    from .types.categories import Category as CategoryPayload\n    from .types.categories import InnerCategory as ParentCategoryPayload\n\n__all__ = (\"Category\", \"ParentCategory\")\n\n\nclass ParentCategory(HTTPDataclass[\"ParentCategoryPayload\"]):\n    \"\"\"\n    A dataclass which represents one of kick's main categories\n\n    Attributes\n    -----------\n    id: int\n        The categorie's ID\n    name: str\n        The categorie's name\n    slug: str\n        The categorie's slug\n    icon: `Asset`\n        The categorie's icon\n    \"\"\"\n\n    @property\n    def id(self) -> int:\n        \"\"\"\n        The categorie's ID\n        \"\"\"\n\n        return self._data[\"id\"]\n\n    @property\n    def name(self) -> str:\n        \"\"\"\n        The categorie's name\n        \"\"\"\n\n        return self._data[\"name\"]\n\n    @property\n    def slug(self) -> str:\n        \"\"\"\n        The categorie's slug\n        \"\"\"\n\n        return self._data[\"slug\"]\n\n    @cached_property\n    def icon(self) -> Asset:\n        \"\"\"\n        The categorie's icon\n        \"\"\"\n\n        return Asset(url=self._data[\"icon\"], http=self.http)\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__) and other.id == self.id\n\n    def __repr__(self) -> str:\n        return f\"<ParentCategory id={self.id!r} name={self.name!r} icon={self.icon!r}>\"", "\n\nclass Category(HTTPDataclass[\"CategoryPayload\"]):\n    \"\"\"\n    A dataclass which represents one of kick's sub categories\n\n    Attributes\n    -----------\n    id: int\n        The categorie's ID?\n    category_id: str\n        The categorie's ID?\n    slug: str\n        The categorie's slug\n    name: str\n        The categorie's name\n    tags: list[str]\n        A list of the categorie's tags\n    description: str | None\n        The categorie's description, if any\n    parent: `ParentCategory`\n        The categorie's parent category.\n    \"\"\"\n\n    @property\n    def id(self) -> int:\n        \"\"\"\n        The categorie's ID?\n\n        Unknown on the difference between this and `Category.category_id`\n        \"\"\"\n\n        return self._data[\"id\"]\n\n    @property\n    def category_id(self) -> int:\n        \"\"\"\n        The categorie's ID?\n\n        Unknown on the difference between this and `Category.id`\n        \"\"\"\n\n        return self._data[\"category_id\"]\n\n    @property\n    def name(self) -> str:\n        \"\"\"\n        The categorie's name\n        \"\"\"\n\n        return self._data[\"name\"]\n\n    @property\n    def slug(self) -> str:\n        \"\"\"\n        The categorie's slug\n        \"\"\"\n\n        return self._data[\"slug\"]\n\n    @property\n    def tags(self) -> list[str]:\n        \"\"\"\n        A list of the categorie's tags\n        \"\"\"\n\n        return self._data[\"tags\"]\n\n    @property\n    def description(self) -> str | None:\n        \"\"\"\n        The categorie's description, if any\n        \"\"\"\n\n        return self._data[\"description\"]\n\n    @cached_property\n    def parent(self) -> ParentCategory:\n        \"\"\"\n        The categorie's parent category.\n        \"\"\"\n\n        return ParentCategory(data=self._data[\"category\"], http=self.http)\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__) and other.id == self.id\n\n    def __repr__(self) -> str:\n        return f\"<Category id={self.id!r} name={self.name!r} category_id={self.category_id!r}> tags={self.tags!r} description={self.description!r} parent={self.parent!r}\"", ""]}
{"filename": "kick/__main__.py", "chunked_list": ["import subprocess\n\nimport click\n\n\n@click.group\ndef cli():\n    ...\n\n", "\n\n@cli.group(name=\"bypass\", help=\"Stuff regarding the cloudflare bypass script\")\ndef bypass():\n    ...\n\n\nBYPASS_CODE = \"\"\"\n\npackage main", "\npackage main\n\nimport (\n    \"log\"\n    \"strings\"\n\t\"bytes\"\n\n    \"github.com/Danny-Dasilva/CycleTLS/cycletls\"\n    \"github.com/gin-gonic/gin\"", "    \"github.com/Danny-Dasilva/CycleTLS/cycletls\"\n    \"github.com/gin-gonic/gin\"\n)\n\nfunc sendKickMessage(context *gin.Context) cycletls.Response {\n    client := cycletls.Init()\n\theaders := make(map[string]string)\n\tfor key, values := range context.Request.Header {\n\theaders[key] = strings.Join(values, \",\")\n\t}", "\theaders[key] = strings.Join(values, \",\")\n\t}\n\n\tbuf := new(bytes.Buffer)\n\tbuf.ReadFrom(context.Request.Body)\n\tbodyStr := buf.String()\n\n\n\turl := context.Query(\"url\")\n    response, err := client.Do(url, cycletls.Options{", "\turl := context.Query(\"url\")\n    response, err := client.Do(url, cycletls.Options{\n        Body:      bodyStr,\n\t\tHeaders:   headers,\n        Ja3:       \"771,4865-4867-4866-49195-49199-52393-52392-49196-49200-49162-49161-49171-49172-51-57-47-53-10,0-23-65281-10-11-35-16-5-51-43-13-45-28-21,29-23-24-25-256-257,0\",\n        UserAgent: \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:87.0) Gecko/20100101 Firefox/87.0\",\n        // PROXY_HERE\n    }, context.Request.Method)\n    if err != nil {\n        log.Print(\"Request Failed: \" + err.Error())", "    if err != nil {\n        log.Print(\"Request Failed: \" + err.Error())\n    }\n    return response\n}\n\nfunc queryRespone(context *gin.Context) {\n    response := sendKickMessage(context)\n    context.String(response.Status, response.Body)\n}", "    context.String(response.Status, response.Body)\n}\n\n\nfunc main() {\n\tlog.Print(\"starting\")\n \tgin.SetMode(gin.ReleaseMode)\n    router := gin.Default()\n\n    router.Any(\"/request\", queryRespone)", "\n    router.Any(\"/request\", queryRespone)\n\n    router.Run(\"localhost:9090\")\n}\n\n\"\"\"\n\n\n@bypass.command(help=\"Creates the bypass file\", name=\"create\")", "\n@bypass.command(help=\"Creates the bypass file\", name=\"create\")\n@click.option(\n    \"--port\",\n    default=9090,\n    help=\"The port for the bypass script to run the webserver on\",\n)\n@click.option(\"--fp\", default=\"bypass.go\", help=\"The filepath for the file to go to\")\n@click.option(\n    \"--proxy\",", "@click.option(\n    \"--proxy\",\n    help=\"A proxy url in the format of: http://username:password@hostname.tld:port. Rotating proxy not supported\",\n    default=None,\n)\ndef create_file(port: int, fp: str, proxy: str | None) -> None:\n    code = BYPASS_CODE.replace(\"{port}\", f\"{port}\")\n    if proxy:\n        code = code.replace(f\"// PROXY_HERE\", f'Proxy: \"{proxy}\",')\n    with open(fp, \"w\", encoding=\"utf-8\") as f:\n        f.write(code)\n\n    print(f\"Done writing to {fp}.\\nMake sure to install the dependencys.\")", "\n\n@bypass.command(help=\"installs the script's dependencys\", name=\"install\")\ndef install_dependencys() -> None:\n    print(\"Running go init...\")\n    subprocess.run(\"go mod init example/project-name\")\n    print(\"Installing CycleTLS...\")\n    subprocess.run(\"go get github.com/Danny-Dasilva/CycleTLS/cycletls\")\n    print(\"Installing gin...\")\n    subprocess.run(\"go get github.com/gin-gonic/gin\")\n    print(\"\\n\\nAll done. Run `go run filepath` to run the file.\")", "\n\nif __name__ == \"__main__\":\n    cli()\n"]}
{"filename": "kick/assets.py", "chunked_list": ["from __future__ import annotations\n\nimport os\nfrom io import BufferedIOBase\nfrom typing import TYPE_CHECKING, Any\n\nif TYPE_CHECKING:\n    from typing_extensions import Self\n\n    from .http import HTTPClient\n    from .types.assets import AssetOnlySrc, AssetSrcset", "\n__all__ = (\"Asset\",)\n\n\nclass Asset:\n    \"\"\"\n    A class which repersents a kick asset.\n\n    Attributes\n    -----------\n    url: str\n        The asset's url\n    \"\"\"\n\n    def __init__(self, *, url: str, http: HTTPClient) -> None:\n        self.http = http\n        self.url = url\n\n    async def read(self) -> bytes:\n        \"\"\"\n        |coro|\n\n        Fetches the asset from kick\n\n        Raises\n        -----------\n        HTTPException\n            Fetching the asset failed\n        NotFound\n            Asset no longer exists\n\n        Returns\n        -----------\n        bytes\n            The asset's bytes\n        \"\"\"\n\n        return await self.http.get_asset(self.url)\n\n    async def save(\n        self,\n        fp: str | bytes | os.PathLike[Any] | BufferedIOBase,\n        *,\n        seek_begin: bool = True,\n    ) -> int:\n        \"\"\"\n        |coro|\n\n        Saves the asset into a file-like object\n\n        Parameters\n        -----------\n        fp: str | bytes | os.PathLike[Any] | BufferedIOBase\n            The file-like object for the asset to be written to.\n            If a filepath is given, then a file will be created instead.\n        seek_begin: bool\n            Whether to seek to the beginning of the file after saving is\n            successfully done.\n\n        Raises\n        -----------\n        HTTPException\n            Fetching the asset failed\n        NotFound\n            Asset no longer exists\n\n        Returns\n        -----------\n        int\n            The amount of bytes written\n        \"\"\"\n\n        data = await self.read()\n        if isinstance(fp, BufferedIOBase):\n            written = fp.write(data)\n            if seek_begin:\n                fp.seek(0)\n            return written\n        else:\n            with open(fp, \"wb\") as f:\n                return f.write(data)\n\n    def __str__(self) -> str:\n        return self.url\n\n    def __len__(self) -> int:\n        return len(self.url)\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__) and other.url == self.url\n\n    @classmethod\n    def _from_asset_src(\n        cls, *, data: AssetSrcset | AssetOnlySrc, http: HTTPClient\n    ) -> Self:\n        return cls(url=data[\"src\"], http=http)\n\n    @classmethod\n    def _from_emote(cls, emote_id: int, /, *, http: HTTPClient) -> Self:\n        return cls(url=f\"https://files.kick.com/emotes/{emote_id}/fullsize\", http=http)\n\n    def __repr__(self) -> str:\n        return f\"<Asset url={self.url}>\"", ""]}
{"filename": "kick/badges.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom .assets import Asset\nfrom .object import BaseDataclass, HTTPDataclass\nfrom .utils import cached_property\n\nif TYPE_CHECKING:\n    from .types.badges import ChatBadgePayload, SubscriberBadgePayload", "if TYPE_CHECKING:\n    from .types.badges import ChatBadgePayload, SubscriberBadgePayload\n\n__all__ = (\"ChatBadge\", \"SubscriberBadge\")\n\n\nclass ChatBadge(BaseDataclass[\"ChatBadgePayload\"]):\n    \"\"\"\n    A dataclass which represents a badge from a chatroon.\n\n    Attributes\n    -----------\n    type: str\n        The type of badge\n    text: str\n        The badge's text\n    count: int\n        How many of that badge they have\n    active: bool\n        If the chatter actively has the badge\n    \"\"\"\n\n    @property\n    def type(self) -> str:\n        \"\"\"\n        The type of badge\n        \"\"\"\n\n        return self._data[\"type\"]\n\n    @property\n    def text(self) -> str:\n        \"\"\"\n        The badge's text\n        \"\"\"\n\n        return self._data[\"text\"]\n\n    @property\n    def count(self) -> int:\n        \"\"\"\n        How many of that badge they have\n        \"\"\"\n\n        return self._data[\"count\"]\n\n    @property\n    def active(self) -> bool:\n        \"\"\"\n        If the chatter actively has the badge\n        \"\"\"\n\n        return self._data[\"active\"]\n\n    def __repr__(self) -> str:\n        return f\"<ChatBadge type={self.type!r} text={self.text!r} count={self.count!r} active={self.active!r}>\"", "\n\nclass SubscriberBadge(HTTPDataclass[\"SubscriberBadgePayload\"]):\n    \"\"\"\n    A dataclass which represents a subscriber badge from a channel.\n\n    Attributes\n    -----------\n    id: int\n        The badge's id\n    channel_id: int\n        The id of the channel the chatter is subscribed too\n    months: int\n        How many months they have been subscribed to the chatter\n    image: `Asset`\n        The badge's image\n    \"\"\"\n\n    @property\n    def id(self) -> int:\n        return self._data[\"id\"]\n\n    @property\n    def channel_id(self) -> int:\n        return self._data[\"channel_id\"]\n\n    @property\n    def months(self) -> int:\n        return self._data[\"months\"]\n\n    @cached_property\n    def image(self) -> Asset:\n        return Asset._from_asset_src(data=self._data[\"badge_image\"], http=self.http)\n\n    def __repr__(self) -> str:\n        return f\"<SubscriberBadge id={self.id!r} channel_id={self.channel_id!r} months={self.months!r} image={self.image!r}>\"", ""]}
{"filename": "kick/livestream.py", "chunked_list": ["from __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING\n\nfrom .assets import Asset\nfrom .categories import Category\nfrom .object import HTTPDataclass\nfrom .utils import cached_property\n\nif TYPE_CHECKING:\n    from .http import HTTPClient\n    from .types.videos import LivestreamPayload\n    from .types.ws import PartialLivestreamPayload\n    from .users import User", "from .utils import cached_property\n\nif TYPE_CHECKING:\n    from .http import HTTPClient\n    from .types.videos import LivestreamPayload\n    from .types.ws import PartialLivestreamPayload\n    from .users import User\n\n__all__ = (\"Livestream\", \"PartialLivestream\")\n", "__all__ = (\"Livestream\", \"PartialLivestream\")\n\n\nclass PartialLivestream:\n    \"\"\"\n    A dataclass which represents a partial livestream on kick.\n\n    Attributes\n    -----------\n    id: int\n        The livestream's id\n    channel_id: int\n        The livestream's channel id\n    title: str\n        The livestream's title\n    created_at: datetime.datetime\n        When the livestream started\n    streamer: `User` | None\n        The livestream's streaner\n    \"\"\"\n\n    def __init__(self, *, data: PartialLivestreamPayload, http: HTTPClient) -> None:\n        self._data = data\n        self.http = http\n\n        self.id: int = data[\"id\"]\n        self.channel_id: int = data[\"channel_id\"]\n        self.title: str = data[\"session_title\"]\n\n    @cached_property\n    def created_at(self) -> datetime:\n        return datetime.fromisoformat(self._data[\"created_at\"])\n\n    @property\n    def streamer(self) -> User | None:\n        return self.http.client._watched_users.get(self.channel_id)", "\n\nclass Livestream(HTTPDataclass[\"LivestreamPayload\"]):\n    \"\"\"\n    A dataclass which represents a livestream on kick.\n\n    Attributes\n    -----------\n    id: int\n        probably the livestream's id\n    slug: str\n        The streamer's slug\n    channel_id: int\n        probably the streamer's id or the chatroom id\n    created_at: datetime.datetime\n        When the livestream started\n    title: str\n        The livestream's title\n    is_live: bool\n        If the livestream is currently live\n    thumbnail: `Asset` | None\n        Returns the livestream's thumbnail if it has one\n    duration: int\n        Probably how long the livestream is/was in seconds\n    language: str\n        The language the livestream is in\n    is_mature: bool\n        If the livestream is marked as 18+\n    viewer_count: int\n        The amount of people currently watching\n    tags: list[str]\n        Tags applied to the livestream\n    url: str\n        The livestream's url\n    embed_url: str\n        The livestream's player/embed url\n    categories: list[`Category`]\n        The categories the livestream is in\n    \"\"\"\n\n    @property\n    def id(self) -> int:\n        \"\"\"\n        probably the livestream's id\n        \"\"\"\n\n        return self._data[\"id\"]\n\n    @property\n    def slug(self) -> str:\n        \"\"\"\n        The streamer's slug\n        \"\"\"\n\n        return self._data[\"slug\"]\n\n    @property\n    def channel_id(self) -> int:\n        \"\"\"\n        probably the streamer's id or the chatroom id\n        \"\"\"\n\n        return self._data[\"channel_id\"]\n\n    @cached_property\n    def created_at(self) -> datetime:\n        \"\"\"\n        When the livestream started\n        \"\"\"\n\n        return datetime.fromisoformat(self._data[\"created_at\"])\n\n    @property\n    def title(self) -> str:\n        \"\"\"\n        The livestream's title\n        \"\"\"\n\n        return self._data[\"session_title\"]\n\n    @property\n    def is_live(self) -> bool:\n        \"\"\"\n        If the livestream is currently live\n        \"\"\"\n\n        return self._data[\"is_live\"]\n\n    @cached_property\n    def thumbnail(self) -> Asset | None:\n        \"\"\"\n        Returns the livestream's thumbnail if it has one\n        \"\"\"\n\n        return (\n            None\n            if self._data[\"thumbnail\"] is None\n            else Asset(url=self._data[\"thumbnail\"][\"url\"], http=self.http)\n        )\n\n    @property\n    def duration(self) -> int:\n        \"\"\"\n        Probably how long the livestream is/was in seconds\n        \"\"\"\n\n        return self._data[\"duration\"]\n\n    @property\n    def language(self) -> str:\n        \"\"\"\n        The language the livestream is in\n        \"\"\"\n\n        return self._data[\"language\"]\n\n    @property\n    def is_mature(self) -> bool:\n        \"\"\"\n        If the livestream is marked as 18+\n        \"\"\"\n\n        return self._data[\"is_mature\"]\n\n    @property\n    def viewer_count(self) -> int:\n        \"\"\"\n        The amount of people currently watching\n        \"\"\"\n\n        return self._data[\"viewer_count\"]\n\n    @property\n    def tags(self) -> list[str]:\n        \"\"\"\n        Tags applied to the livestream\n        \"\"\"\n\n        return self._data[\"tags\"]\n\n    @cached_property\n    def url(self) -> str:\n        \"\"\"\n        The livestream's url\n        \"\"\"\n\n        return f\"https://kick.com/{self.slug}\"\n\n    @cached_property\n    def embed_url(self) -> str:\n        \"\"\"\n        The livestream's player/embed url\n        \"\"\"\n\n        return f\"https://player.kick.com/{self.slug}\"\n\n    @cached_property\n    def categories(self) -> list[Category]:\n        \"\"\"\n        The categories the livestream is in\n        \"\"\"\n\n        return [Category(data=c, http=self.http) for c in self._data[\"categories\"]]\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__) and other.id == self.id\n\n    def __repr__(self) -> str:\n        return f\"<Livestream id={self.id} title={self.title} streamer={self.slug}>\"", ""]}
{"filename": "kick/errors.py", "chunked_list": ["__all__ = (\n    \"KickException\",\n    \"HTTPException\",\n    \"Forbidden\",\n    \"NotFound\",\n    \"InternalKickException\",\n    \"LoginFailure\",\n    \"CloudflareBypassException\",\n)\n", ")\n\n\nclass CloudflareBypassException(Exception):\n    \"\"\"\n    This error is used when there is an error with the bypass script.\n    \"\"\"\n\n\nclass KickException(Exception):\n    \"\"\"\n    This error is used when there is an error with kick.\n    \"\"\"", "\nclass KickException(Exception):\n    \"\"\"\n    This error is used when there is an error with kick.\n    \"\"\"\n\n\nclass LoginFailure(KickException):\n    \"\"\"\n    This error is used when there is an error with logging in.\n    \"\"\"", "\n\nclass HTTPException(KickException):\n    \"\"\"\n    This error is used when an error is ran into when making a request to kick.\n\n    Attributes\n    -----------\n    status_code: int\n        The HTTP code\n    \"\"\"\n\n    def __init__(self, txt: str, status_code: int) -> None:\n        super().__init__(txt)\n        self.status_code = status_code", "\n\nclass Forbidden(HTTPException):\n    \"\"\"\n    This error is used when kick returns a 403 status code.\n\n    Attributes\n    -----------\n    status_code: int = 403\n        The HTTP code\n    \"\"\"\n\n    def __init__(self, txt: str = \"\") -> None:\n        super().__init__(txt, 403)", "\n\nclass NotFound(HTTPException):\n    \"\"\"\n    This error is used when kick returns a 404 status code.\n\n    Attributes\n    -----------\n    status_code: int = 404\n        The HTTP code\n    \"\"\"\n\n    def __init__(self, txt: str) -> None:\n        super().__init__(txt, 404)", "\n\nclass InternalKickException(HTTPException):\n    \"\"\"\n    This error is used when kick returns a a 500 status code, or doesn't connect.\n\n    Attributes\n    -----------\n    status_code: int = 500\n        The HTTP code\n    \"\"\"\n\n    def __init__(self, txt: str) -> None:\n        super().__init__(txt, 500)", ""]}
{"filename": "kick/client.py", "chunked_list": ["from __future__ import annotations\n\nimport asyncio\nimport logging\nfrom logging import getLogger\nfrom typing import TYPE_CHECKING, Any, Callable, Coroutine, TypeVar\n\nfrom .chatroom import Chatroom, PartialChatroom\nfrom .chatter import PartialChatter\nfrom .http import HTTPClient", "from .chatter import PartialChatter\nfrom .http import HTTPClient\nfrom .livestream import PartialLivestream\nfrom .message import Message\nfrom .users import ClientUser, PartialUser, User\nfrom .utils import MISSING, decorator, setup_logging\n\nif TYPE_CHECKING:\n    from typing_extensions import Self\n", "\nEventT = TypeVar(\"EventT\", bound=Callable[..., Coroutine[Any, Any, None]])\nLOGGER = getLogger(__name__)\n\n__all__ = (\"Credentials\", \"Client\")\n\n\nclass Credentials:\n    \"\"\"\n    This holds credentials that can be used to authenticate yourself with kick.\n\n    Parameters\n    -----------\n    username: Optional[str]\n        The username to login with. Can not be used with the `email` arg\n    email: Optional[str]\n        The email to login with. Can not be used with the `username` arg\n    password: str\n        The account's password\n    one_time_password: Optional[str]\n        The 2FA code to login with\n\n    Attributes\n    -----------\n    username: Optional[str]\n        The username to login with. Can not be used with the `email` arg\n    email: Optional[str]\n        The email to login with. Can not be used with the `username` arg\n    password: str\n        The account's password\n    one_time_password: Optional[str]\n        The 2FA code to login with\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        username: str = MISSING,\n        email: str = MISSING,\n        password: str,\n        one_time_password: str | None = None,\n    ) -> None:\n        if username is MISSING and email is MISSING:\n            raise ValueError(\"Provide either a `username` or `email` arg\")\n        elif username is not MISSING and email is not MISSING:\n            raise ValueError(\"Provide `username` or `email`, not both.\")\n\n        self.email: str = username or email\n        self.username_was_provided: bool = username is not MISSING\n        self.password: str = password\n        self.one_time_password: str | None = one_time_password", "\n\nclass Client:\n    \"\"\"\n    This repersents the Client you can use to interact with kick.\n\n    Parameters\n    -----------\n    **options: Any\n        Options that can be passed\n\n    Options\n    -----------\n    whitelisted: bool = False\n        If you have been api whitelisted. If set to True, the bypass script will not be used.\n    bypass_port: int = 9090\n        The port the bypass script is running on. Defaults to 9090\n    bypass_host: str = \"http://localhost\"\n        The host of the bypass script.\n\n    Attributes\n    -----------\n    user: ClientUser | None\n        The user you are logged in as. It is `None` until `Client.login` is called.\n    \"\"\"\n\n    def __init__(self, **options: Any) -> None:\n        self._options = options\n        self.http = HTTPClient(self)\n        self._chatrooms: dict[int, Chatroom | PartialChatroom] = {}\n        self._watched_users: dict[int, User] = {}\n        self.user: ClientUser | None = None\n\n        LOGGER.warning(\n            \"Kick's api is undocumented, possible unstable, and can change at any time without warning\"\n        )\n\n    def get_partial_chatroom(\n        self, chatroom_id: int, streamer_name: str\n    ) -> PartialChatroom:\n        \"\"\"\n        Gets a partial chatroom.\n\n        Parameters\n        -----------\n        chatroom_id: int\n            The id of the chatroom you want to connect to\n        streamer_name: str\n            The name of the streamer who's chatroom it is\n\n        Returns\n        -----------\n        `PartialChatroom`\n            The partial chatroom\n        \"\"\"\n\n        return PartialChatroom(\n            id=chatroom_id, streamer_name=streamer_name, http=self.http\n        )\n\n    def get_chatroom(self, chatroom_id: int, /) -> PartialChatroom | Chatroom | None:\n        \"\"\"\n        Gets a chatroom out of a cache that contains chatrooms that you are connected to.\n\n        Parameters\n        -----------\n        chatroom_id: int\n            The chatroom's id\n\n        Returns\n        -----------\n        Chatroom | None\n            Either the chatroom, or None\n        \"\"\"\n\n        return self._chatrooms.get(chatroom_id)\n\n    def get_partial_user(self, *, username: str, id: int) -> PartialUser:\n        \"\"\"\n        Gets a partial user instance by the username and id provided.\n\n        Parameters\n        -----------\n        username: str\n            The user's name\n        id: int\n            The user's id\n\n        Returns\n        -----------\n        `PartialUser`\n            The partial user\n        \"\"\"\n\n        return PartialUser(username=username, id=id, http=self.http)\n\n    def get_partial_chatter(\n        self, *, streamer_name: str, chatter_name: str\n    ) -> PartialChatter:\n        \"\"\"\n        Gets a partial chatter instance by the streamer and chatter names provided.\n\n        Parameters\n        -----------\n        streamer_name: str\n            The streamer's username or slug\n        chatter_name: str\n            The chatter's username or slug\n\n        Returns\n        -----------\n        `PartialChatter`\n            The partial chatter\n        \"\"\"\n\n        return PartialChatter(\n            streamer_name=streamer_name, chatter_name=chatter_name, http=self.http\n        )\n\n    async def fetch_user(self, name: str, /) -> User:\n        \"\"\"\n        |coro|\n\n        Fetches a user from the API.\n\n        Parameters\n        -----------\n        name: str\n            The user's slug or username\n\n        Raises\n        -----------\n        HTTPException\n            Fetching Failed\n        NotFound\n            No user with the username/slug exists\n\n        Returns\n        -----------\n        User\n            The user object associated with the streamer\n        \"\"\"\n\n        data = await self.http.get_user(name)\n        user = User(data=data, http=self.http)\n        return user\n\n    def dispatch(self, event_name: str, *args, **kwargs) -> None:\n        event_name = f\"on_{event_name}\"\n\n        event = getattr(self, event_name, None)\n        if event is not None:\n            asyncio.create_task(\n                event(*args, **kwargs), name=f\"event-dispatch: {event_name}\"\n            )\n\n    @decorator\n    def event(self, coro: EventT) -> EventT:\n        \"\"\"\n        Lets you set an event outside of a subclass.\n        \"\"\"\n\n        setattr(self, coro.__name__, coro)\n        return coro\n\n    async def login(self, credentials: Credentials) -> None:\n        \"\"\"\n        |coro|\n\n        Authenticates yourself, and fills `Client.user`\n        Unlike `Client.start`, this does not start the websocket\n\n        Parameters\n        -----------\n        credentials: Credentials\n            The credentials to authenticate yourself with\n        \"\"\"\n\n        await self.http.login(credentials)\n\n        data = await self.http.get_me()\n        self.user = ClientUser(data=data, http=self.http)\n\n    async def start(self, credentials: Credentials | None = None) -> None:\n        \"\"\"\n        |coro|\n\n        Starts the websocket so you can receive events\n        And authenticate yourself if credentials are provided.\n\n        Parameters\n        -----------\n        credentials: Optional[Credentials]\n            The credentials to authenticate yourself with, if any\n        \"\"\"\n\n        if credentials is not None:\n            await self.login(credentials)\n        await self.http.start()\n\n    async def close(self) -> None:\n        \"\"\"\n        |coro|\n\n        Closes the HTTPClient, no requests can be made after this.\n        \"\"\"\n\n        await self.http.close()\n\n    async def __aenter__(self) -> Self:\n        return self\n\n    async def __aexit__(self, exc_type, exc, tb) -> None:\n        await self.close()\n\n    async def on_ready(self) -> None:\n        \"\"\"\n        |coro|\n\n        on_ready is an event that can be overriden with the `Client.event` decorator or with a subclass.\n        This is called after the client has started the websocket and is receiving events.\n        \"\"\"\n\n    async def on_message(self, message: Message) -> None:\n        \"\"\"\n        |coro|\n\n        on_ready is an event that can be overriden with the `Client.event` decorator or with a subclass.\n        This is called when a message is received over the websocket\n\n        Parameters\n        -----------\n        message: `Message`\n            The message that was received\n        \"\"\"\n\n    async def on_payload_receive(self, event: str, payload: dict) -> None:\n        \"\"\"\n        |coro|\n\n        on_payload_receive is an event that can be overriden with the `Client.event` decorator or with a subclass.\n        This is called when an event is received from the websocket.\n\n        Parameters\n        -----------\n        event: str\n            The payload's event\n        payload: dict\n            The payload\n        \"\"\"\n\n    async def on_livestream_start(self, livestream: PartialLivestream) -> None:\n        \"\"\"\n        |coro|\n\n        on_livestream_start is an event that can be overriden with the `Client.event` decorator or with a subclass.\n        This is called when a user that is being watched starts streaming\n\n        Parameters\n        -----------\n        livestream: `PartialLivestream`\n            The livestream\n        \"\"\"\n\n    async def on_follow(self, streamer: User) -> None:\n        \"\"\"\n        |coro|\n\n        on_livestream_start is an event that can be overriden with the `Client.event` decorator or with a subclass.\n        This is called when someone starts following a streamer that is being watched.\n\n        Parameters\n        -----------\n        streamer: `User`\n            The streamer\n        \"\"\"\n\n    async def on_unfollow(self, streamer: User) -> None:\n        \"\"\"\n        |coro|\n\n        on_livestream_start is an event that can be overriden with the `Client.event` decorator or with a subclass.\n        This is called when someone stops following a streamer that is being watched.\n\n        Parameters\n        -----------\n        streamer: `PartialLivestream`\n            The streamer\n        \"\"\"\n\n    def run(\n        self,\n        credentials: Credentials | None = None,\n        *,\n        handler: logging.Handler = MISSING,\n        formatter: logging.Formatter = MISSING,\n        level: int = MISSING,\n        root: bool = True,\n        stream_supports_colour: bool = False,\n    ) -> None:\n        \"\"\"\n        Starts the websocket so you can receive events\n        And authenticate yourself if credentials are provided.\n\n        `Client.run` automatically calls `utils.setup_logging` with the provided kwargs, and calls `Client.start`.\n\n        Parameters\n        -----------\n        credentials: Optional[Credentials]\n            The credentials to authenticate yourself with, if any\n        \"\"\"\n\n        setup_logging(\n            handler=handler,\n            formatter=formatter,\n            level=level,\n            root=root,\n            stream_supports_colour=stream_supports_colour,\n        )\n        asyncio.run(self.start(credentials))", ""]}
{"filename": "kick/message.py", "chunked_list": ["from __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING\n\nfrom .object import HTTPDataclass\nfrom .users import PartialUser, User\nfrom .utils import cached_property\n\nif TYPE_CHECKING:\n    from .chatroom import Chatroom, PartialChatroom\n    from .types.message import AuthorPayload, MessagePayload, ReplyMetaData", "\nif TYPE_CHECKING:\n    from .chatroom import Chatroom, PartialChatroom\n    from .types.message import AuthorPayload, MessagePayload, ReplyMetaData\n\n__all__ = (\"Author\", \"Message\", \"PartialMessage\")\n\n\nclass Author(HTTPDataclass[\"AuthorPayload\"]):\n    \"\"\"\n    Represents the author of a message on kick\n\n    Attributes\n    -----------\n    id: int\n        The author's id\n    slug: str\n        The author's slug\n    color: str\n        The authors... color?\n    badges: list\n        Unknown\n    \"\"\"\n\n    @property\n    def id(self) -> int:\n        \"\"\"\n        The author's id\n        \"\"\"\n\n        return self._data[\"id\"]\n\n    @property\n    def slug(self) -> str:\n        \"\"\"\n        The author's slug\n        \"\"\"\n\n        return self._data[\"slug\"]\n\n    @property\n    def color(self) -> str:\n        \"\"\"\n        The authors... color?\n        \"\"\"\n\n        return self._data[\"identity\"][\"color\"]\n\n    @property\n    def badges(self) -> list:\n        \"\"\"THIS IS RAW DATA\"\"\"\n        return self._data[\"identity\"][\"badges\"]\n\n    async def to_user(self) -> User:\n        \"\"\"\n        |coro|\n\n        Fetches a user object for the author\n\n        Raises\n        -----------\n        `HTTPException`\n            Fetching the user failed\n        `NotFound`\n            User Not Found\n\n        Returns\n        -----------\n        `User`\n            The user\n        \"\"\"\n\n        return await self.http.client.fetch_user(self.slug)\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__) and other.id == self.id\n\n    def __str__(self) -> str:\n        return self.slug\n\n    def __repr__(self) -> str:\n        return f\"<Author id={self.id!r} slug={self.slug!r}>\"", "class Author(HTTPDataclass[\"AuthorPayload\"]):\n    \"\"\"\n    Represents the author of a message on kick\n\n    Attributes\n    -----------\n    id: int\n        The author's id\n    slug: str\n        The author's slug\n    color: str\n        The authors... color?\n    badges: list\n        Unknown\n    \"\"\"\n\n    @property\n    def id(self) -> int:\n        \"\"\"\n        The author's id\n        \"\"\"\n\n        return self._data[\"id\"]\n\n    @property\n    def slug(self) -> str:\n        \"\"\"\n        The author's slug\n        \"\"\"\n\n        return self._data[\"slug\"]\n\n    @property\n    def color(self) -> str:\n        \"\"\"\n        The authors... color?\n        \"\"\"\n\n        return self._data[\"identity\"][\"color\"]\n\n    @property\n    def badges(self) -> list:\n        \"\"\"THIS IS RAW DATA\"\"\"\n        return self._data[\"identity\"][\"badges\"]\n\n    async def to_user(self) -> User:\n        \"\"\"\n        |coro|\n\n        Fetches a user object for the author\n\n        Raises\n        -----------\n        `HTTPException`\n            Fetching the user failed\n        `NotFound`\n            User Not Found\n\n        Returns\n        -----------\n        `User`\n            The user\n        \"\"\"\n\n        return await self.http.client.fetch_user(self.slug)\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__) and other.id == self.id\n\n    def __str__(self) -> str:\n        return self.slug\n\n    def __repr__(self) -> str:\n        return f\"<Author id={self.id!r} slug={self.slug!r}>\"", "\n\nclass PartialMessage(HTTPDataclass[\"ReplyMetaData\"]):\n    \"\"\"\n    This represents a partial message. Mainly used as the message someone is replying too.\n\n    Attributes\n    -----------\n    id: str\n        The message's id\n    content: str\n        The message's content\n    author: `PartialUser`\n        The message's author\n    \"\"\"\n\n    @property\n    def id(self) -> str:\n        \"\"\"\n        The message's id\n        \"\"\"\n\n        return self._data[\"original_message\"][\"id\"]\n\n    @property\n    def content(self) -> str:\n        \"\"\"\n        The message's content\n        \"\"\"\n\n        return self._data[\"original_message\"][\"content\"]\n\n    @cached_property\n    def author(self) -> PartialUser:\n        \"\"\"\n        The message's author\n        \"\"\"\n\n        return PartialUser(\n            id=int(self._data[\"original_sender\"][\"id\"]),\n            username=self._data[\"original_sender\"][\"username\"],\n            http=self.http,\n        )\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__) and other.id == self.id\n\n    def __repr__(self) -> str:\n        return f\"<Message id={self.id!r} author={self.author!r}>\"", "\n\nclass Message(HTTPDataclass[\"MessagePayload\"]):\n    \"\"\"\n    Represents a message sent on kick\n\n    Attributes\n    -----------\n    id: str\n        the message's id\n    is_reply: bool\n        If the message is replying to any message\n    references: `PartialMessage` | None\n        If the message is replying to a message, a `PartialMessage` object is returned. Otherwise None\n    chatroom_id: int\n        The id of the chatroom the message was sent in\n    chatroom: `Chatroom` | None\n        The chatroom the message was sent in.\n    content: str\n        The message's content\n    created_at: datetime.datetime\n        When the message was sent\n    author: `Author`\n        The message's author\n    \"\"\"\n\n    @property\n    def id(self) -> str:\n        \"\"\"\n        the message's id\n        \"\"\"\n\n        return self._data[\"id\"]\n\n    @cached_property\n    def is_reply(self) -> bool:\n        \"\"\"\n        If the message is replying to any message\n        \"\"\"\n\n        return bool(self._data.get(\"metadata\"))\n\n    @cached_property\n    def references(self) -> PartialMessage | None:\n        \"\"\"\n        If the message is replying to a message, a `PartialMessage` object is returned. Otherwise None\n        \"\"\"\n\n        data = self._data.get(\"metadata\")\n        if not data:\n            return\n        return PartialMessage(data=data, http=self.http)\n\n    @property\n    def chatroom_id(self) -> int:\n        \"\"\"\n        The id of the chatroom the message was sent in\n        \"\"\"\n\n        return self._data[\"chatroom_id\"]\n\n    @property\n    def chatroom(self) -> Chatroom | PartialChatroom | None:\n        \"\"\"\n        The chatroom the message was sent in.\n        \"\"\"\n\n        return self.http.client.get_chatroom(self.chatroom_id)\n\n    @property\n    def content(self) -> str:\n        \"\"\"\n        The message's content\n        \"\"\"\n\n        return self._data[\"content\"]\n\n    @cached_property\n    def created_at(self) -> datetime:\n        \"\"\"\n        When the message was sent\n        \"\"\"\n\n        return datetime.fromisoformat(self._data[\"created_at\"])\n\n    @cached_property\n    def author(self) -> Author:\n        \"\"\"\n        The message's author\n        \"\"\"\n\n        return Author(data=self._data[\"sender\"], http=self.http)\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__) and other.id == self.id\n\n    def __repr__(self) -> str:\n        return f\"<Message id={self.id!r} chatroom={self.chatroom_id!r} author={self.author!r}>\"", ""]}
{"filename": "kick/leaderboard.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom .object import BaseDataclass\nfrom .utils import cached_property\n\nif TYPE_CHECKING:\n    from .types.leaderboard import GiftEntryPayload, LeaderboardPayload\n    from .users import AnyUser", "\n__all__ = (\"GiftLeaderboard\", \"GiftLeaderboardEntry\")\n\n\nclass GiftLeaderboardEntry(BaseDataclass[\"GiftEntryPayload\"]):\n    \"\"\"\n    This dataclass represents a gift leaderboard entry.\n\n    Attributes\n    -----------\n    user_id: int\n        The id of the user with this entry\n    quantity: int\n        The amount of subs this person has gifted\n    username: str\n        The user's username\n    \"\"\"\n\n    @property\n    def user_id(self) -> int:\n        \"\"\"\n        The id of the user with this entry\n        \"\"\"\n\n        return self._data[\"user_id\"]\n\n    @property\n    def quantity(self) -> int:\n        \"\"\"\n        The amount of subs this person has gifted\n        \"\"\"\n\n        return self._data[\"quantity\"]\n\n    @property\n    def username(self) -> str:\n        \"\"\"\n        The user's username\n        \"\"\"\n\n        return self._data[\"username\"]\n\n    def __repr__(self) -> str:\n        return f\"<GiftLeaderboardEntry uid={self.user_id!r} quantity={self.quantity!r} username={self.username!r}>\"", "\n\nclass GiftLeaderboard(BaseDataclass[\"LeaderboardPayload\"]):\n    \"\"\"\n    This is a dataclass which reprsents the gift leaderboard for a kick streamer.\n\n    Attributes\n    -----------\n    streamer: `User`\n        The streamer that the leaderboard is for\n    this_week: list[`GiftLeaderboardEntry`]\n        The gift leaderboard for the current week\n    this_month: list[`GiftLeaderboardEntry`]\n        The gift leaderboard for the current month\n    all_time: list[`GiftLeaderboardEntry`]\n        The gift leaderboard for all time\n    \"\"\"\n\n    streamer: AnyUser\n\n    @cached_property\n    def this_week(self) -> list[GiftLeaderboardEntry]:\n        return [GiftLeaderboardEntry(data=c) for c in self._data[\"gifts_week\"]]\n\n    @cached_property\n    def this_month(self) -> list[GiftLeaderboardEntry]:\n        return [GiftLeaderboardEntry(data=c) for c in self._data[\"gifts_month\"]]\n\n    @cached_property\n    def all_time(self) -> list[GiftLeaderboardEntry]:\n        return [GiftLeaderboardEntry(data=c) for c in self._data[\"gifts\"]]\n\n    def __repr__(self) -> str:\n        return f\"<GiftLeaderboard streamer={self.streamer.username!r} weekly_entries={len(self.this_week)} monthly_entries={len(self.this_month)} all_time_etries={len(self.all_time)}>\"", ""]}
{"filename": "kick/object.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Generic, TypeVar\n\nDataT = TypeVar(\"DataT\")\n\nif TYPE_CHECKING:\n    from .http import HTTPClient\n\n", "\n\n__all__ = (\"BaseDataclass\", \"HTTPDataclass\")\n\n\nclass BaseDataclass(Generic[DataT]):\n    def __init__(self, *, data: DataT) -> None:\n        self._data = data\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__}>\"", "\n\nclass HTTPDataclass(Generic[DataT]):\n    def __init__(self, *, data: DataT, http: HTTPClient) -> None:\n        self._data = data\n        self.http = http\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__}>\"\n", ""]}
{"filename": "kick/enums.py", "chunked_list": ["from enum import Enum\n\n__all__ = (\"ChatroomChatMode\",)\n\n\nclass ChatroomChatMode(Enum):\n    \"\"\"\n    An enum containing possble chatroom chat mode values.\n\n    Attributes\n    -----------\n    public: `ChatroomChatMode`\n        The public value\n    privet: `ChatroomChatMode`\n        The privet value\n    \"\"\"\n\n    public = \"public\"\n    privet = \"privet\"", ""]}
{"filename": "kick/__init__.py", "chunked_list": ["\"\"\"\nKick API Wrapper\n~~~~~~~~~~~~~~~~~~~\nA basic wrapper for the Kick API.\n\"\"\"\n\n__version__ = \"0.0.2a\"\n\nfrom typing import Any, Literal, NamedTuple\n", "from typing import Any, Literal, NamedTuple\n\nfrom .assets import *\nfrom .badges import *\nfrom .categories import *\nfrom .chatroom import *\nfrom .chatter import *\nfrom .client import *\nfrom .emotes import *\nfrom .enums import *", "from .emotes import *\nfrom .enums import *\nfrom .errors import *\nfrom .leaderboard import *\nfrom .livestream import *\nfrom .message import *\nfrom .object import *\nfrom .polls import *\nfrom .users import *\nfrom .videos import *", "from .users import *\nfrom .videos import *\n\n\nclass VersionInfo(NamedTuple):\n    major: int\n    minor: int\n    micro: int\n    releaselevel: Literal[\"alpha\", \"beta\", \"candidate\", \"final\"]\n    serial: int\n\n    @classmethod\n    def from_version(cls, ver: str):\n        major, minor, micro = ver.split(\".\")\n        releaselevel: Any = \"f\"\n        if not micro.isdigit():\n            releaselevel = micro[-1]\n            micro = micro.removesuffix(releaselevel)\n        self = cls(\n            major=int(major),\n            minor=int(minor),\n            micro=int(micro),\n            releaselevel={\n                \"a\": \"alpha\",\n                \"b\": \"beta\",\n                \"c\": \"candidate\",\n                \"f\": \"final\",\n            }.get(\n                releaselevel, \"final\"\n            ),  # type: ignore\n            serial=0,\n        )\n        return self", "\n\nversion_info: VersionInfo = VersionInfo.from_version(__version__)\n\ndel NamedTuple, Literal, VersionInfo, Any\n"]}
{"filename": "kick/utils.py", "chunked_list": ["from __future__ import annotations\n\nimport logging\nfrom functools import wraps\nfrom typing import TYPE_CHECKING, Any, Callable, Type\n\n\ndef _cached_property(func: Callable):\n    @wraps(func)\n    def getter(parent: Type):\n        cache = getattr(parent, \"__cached_properties\", {})\n        if func.__name__ not in cache.keys():\n            cache[func.__name__] = func(parent)\n            parent.__cached_properties = cache\n        return parent.__cached_properties[func.__name__]\n\n    return property(getter)", "\n\nif TYPE_CHECKING:\n    from functools import cached_property as cached_property\n    from typing import TypeVar\n\n    FuncT = TypeVar(\"FuncT\", bound=Callable)\nelse:\n    cached_property = _cached_property\n", "\n__all__ = (\"MISSING\", \"cached_property\", \"setup_logging\")\n\n\nclass _MissingSentinel:\n    __slots__ = ()\n\n    def __eq__(self, other) -> bool:\n        return False\n\n    def __bool__(self) -> bool:\n        return False\n\n    def __hash__(self) -> int:\n        return 0\n\n    def __repr__(self):\n        return \"...\"", "\n\nMISSING: Any = _MissingSentinel()\n\n\ndef decorator(func: FuncT) -> FuncT:\n    func.__is_decorator__ = True\n    return func\n\n\nclass _ColourFormatter(logging.Formatter):\n    # ANSI codes are a bit weird to decipher if you're unfamiliar with them, so here's a refresher\n    # It starts off with a format like \\x1b[XXXm where XXX is a semicolon separated list of commands\n    # The important ones here relate to colour.\n    # 30-37 are black, red, green, yellow, blue, magenta, cyan and white in that order\n    # 40-47 are the same except for the background\n    # 90-97 are the same but \"bright\" foreground\n    # 100-107 are the same as the bright ones but for the background.\n    # 1 means bold, 2 means dim, 0 means reset, and 4 means underline.\n\n    LEVEL_COLOURS = [\n        (logging.DEBUG, \"\\x1b[40;1m\"),\n        (logging.INFO, \"\\x1b[34;1m\"),\n        (logging.WARNING, \"\\x1b[33;1m\"),\n        (logging.ERROR, \"\\x1b[31m\"),\n        (logging.CRITICAL, \"\\x1b[41m\"),\n    ]\n\n    FORMATS = {\n        level: logging.Formatter(\n            f\"\\x1b[30;1m%(asctime)s\\x1b[0m {colour}%(levelname)-8s\\x1b[0m \\x1b[35m%(name)s\\x1b[0m %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\",\n        )\n        for level, colour in LEVEL_COLOURS\n    }\n\n    def format(self, record):\n        formatter = self.FORMATS.get(record.levelno)\n        if formatter is None:\n            formatter = self.FORMATS[logging.DEBUG]\n\n        # Override the traceback to always print in red\n        if record.exc_info:\n            text = formatter.formatException(record.exc_info)\n            record.exc_text = f\"\\x1b[31m{text}\\x1b[0m\"\n\n        output = formatter.format(record)\n\n        # Remove the cache layer\n        record.exc_text = None\n        return output", "\n\nclass _ColourFormatter(logging.Formatter):\n    # ANSI codes are a bit weird to decipher if you're unfamiliar with them, so here's a refresher\n    # It starts off with a format like \\x1b[XXXm where XXX is a semicolon separated list of commands\n    # The important ones here relate to colour.\n    # 30-37 are black, red, green, yellow, blue, magenta, cyan and white in that order\n    # 40-47 are the same except for the background\n    # 90-97 are the same but \"bright\" foreground\n    # 100-107 are the same as the bright ones but for the background.\n    # 1 means bold, 2 means dim, 0 means reset, and 4 means underline.\n\n    LEVEL_COLOURS = [\n        (logging.DEBUG, \"\\x1b[40;1m\"),\n        (logging.INFO, \"\\x1b[34;1m\"),\n        (logging.WARNING, \"\\x1b[33;1m\"),\n        (logging.ERROR, \"\\x1b[31m\"),\n        (logging.CRITICAL, \"\\x1b[41m\"),\n    ]\n\n    FORMATS = {\n        level: logging.Formatter(\n            f\"\\x1b[30;1m%(asctime)s\\x1b[0m {colour}%(levelname)-8s\\x1b[0m \\x1b[35m%(name)s\\x1b[0m %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\",\n        )\n        for level, colour in LEVEL_COLOURS\n    }\n\n    def format(self, record):\n        formatter = self.FORMATS.get(record.levelno)\n        if formatter is None:\n            formatter = self.FORMATS[logging.DEBUG]\n\n        # Override the traceback to always print in red\n        if record.exc_info:\n            text = formatter.formatException(record.exc_info)\n            record.exc_text = f\"\\x1b[31m{text}\\x1b[0m\"\n\n        output = formatter.format(record)\n\n        # Remove the cache layer\n        record.exc_text = None\n        return output", "\n\ndef setup_logging(\n    *,\n    handler: logging.Handler = MISSING,\n    formatter: logging.Formatter = MISSING,\n    level: int = MISSING,\n    root: bool = True,\n    stream_supports_colour: bool = False,\n) -> None:\n    if level is MISSING:\n        level = logging.INFO\n\n    if handler is MISSING:\n        handler = logging.StreamHandler()\n\n    if formatter is MISSING:\n        if (\n            isinstance(handler, logging.StreamHandler)\n            and stream_supports_colour is True\n        ):\n            formatter = _ColourFormatter()\n        else:\n            dt_fmt = \"%Y-%m-%d %H:%M:%S\"\n            formatter = logging.Formatter(\n                \"[{asctime}] [{levelname:<8}] {name}: {message}\", dt_fmt, style=\"{\"\n            )\n\n    if root:\n        logger = logging.getLogger()\n    else:\n        library, _, _ = __name__.partition(\".\")\n        logger = logging.getLogger(library)\n\n    handler.setFormatter(formatter)\n    logger.setLevel(level)\n    logger.addHandler(handler)", ""]}
{"filename": "kick/chatter.py", "chunked_list": ["from __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING\n\nfrom .assets import Asset\nfrom .badges import ChatBadge\nfrom .users import User\nfrom .utils import cached_property\n\nif TYPE_CHECKING:\n    from .chatroom import Chatroom, PartialChatroom\n    from .http import HTTPClient\n    from .types.user import ChatterPayload", "from .utils import cached_property\n\nif TYPE_CHECKING:\n    from .chatroom import Chatroom, PartialChatroom\n    from .http import HTTPClient\n    from .types.user import ChatterPayload\n\n__all__ = (\"Chatter\", \"PartialChatter\")\n\n\nclass PartialChatter:\n    \"\"\"\n    This represents a partial user.\n\n    Attributes\n    -----------\n    streamer_name: str\n        The streamer's name\n    username: str\n        The chatter's username\n    \"\"\"\n\n    def __init__(\n        self, *, streamer_name: str, chatter_name: str, http: HTTPClient\n    ) -> None:\n        self.streamer_name = streamer_name\n        self.username = chatter_name\n        self.http = http\n\n    async def to_user(self) -> User:\n        \"\"\"\n        |coro|\n\n        Fetches a user object for the chatter\n\n        Raises\n        -----------\n        `HTTPException`\n            Fetching the user failed\n        `NotFound`\n            User not found\n\n        Returns\n        -----------\n        `User`\n            The user\n        \"\"\"\n        data = await self.http.get_user(self.username)\n        user = User(data=data, http=self.http)\n        return user\n\n    async def ban(self, reason: str) -> None:\n        \"\"\"\n        |coro|\n\n        Permanently bans a user from a chatroom.\n\n        Parameters\n        -----------\n        reason: str\n            The reason for the ban\n\n        Raises\n        -----------\n        `HTTPException`\n            Banning the user failed\n        `Forbidden`\n            You are unauthorized from banning the user\n        `NotFound`\n            Streamer or user not found\n        \"\"\"\n\n        await self.http.ban_chatter(self.streamer_name, self.username, reason)\n\n    async def timeout(self, duration: int, *, reason: str) -> None:\n        \"\"\"\n        |coro|\n\n        Times out a user for a given amount of time.\n\n        Parameters\n        -----------\n        duration: int\n            The amount of seconds for the timeout to be\n        reason: str\n            The reason for the timeout\n\n        Raises\n        -----------\n        `HTTPException`\n            timing out the user failed\n        `Forbidden`\n            You are unauthorized from timing out the user\n        `NotFound`\n            Streamer or user not found\n        \"\"\"\n\n        await self.http.timeout_chatter(\n            self.streamer_name, self.username, reason, duration\n        )\n\n    async def unban(self) -> None:\n        \"\"\"\n        |coro|\n\n        Unbans the chatter from the chatroom\n\n        Raises\n        -----------\n        `HTTPException`\n            Unbanning the user failed\n        `Forbidden`\n            You are unauthorized from unbanning the user\n        `NotFound`\n            Streamer or user not found\n        \"\"\"\n\n        await self.http.unban_user(self.streamer_name, self.username)\n\n    async def untimeout(self) -> None:\n        \"\"\"\n        |coro|\n\n        untimeout's the chatter\n\n        Raises\n        -----------\n        `HTTPException`\n            untimeouting the user failed\n        `Forbidden`\n            You are unauthorized from untimeouting the user\n        `NotFound`\n            Streamer or user not found\n        \"\"\"\n\n        await self.http.unban_user(self.streamer_name, self.username)\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__) and other.username == self.username\n\n    def __str__(self) -> str:\n        return self.username\n\n    def __repr__(self) -> str:\n        return f\"<PartialChatter username={self.username!r} streamer_name={self.streamer_name!r}>\"", "\n\nclass PartialChatter:\n    \"\"\"\n    This represents a partial user.\n\n    Attributes\n    -----------\n    streamer_name: str\n        The streamer's name\n    username: str\n        The chatter's username\n    \"\"\"\n\n    def __init__(\n        self, *, streamer_name: str, chatter_name: str, http: HTTPClient\n    ) -> None:\n        self.streamer_name = streamer_name\n        self.username = chatter_name\n        self.http = http\n\n    async def to_user(self) -> User:\n        \"\"\"\n        |coro|\n\n        Fetches a user object for the chatter\n\n        Raises\n        -----------\n        `HTTPException`\n            Fetching the user failed\n        `NotFound`\n            User not found\n\n        Returns\n        -----------\n        `User`\n            The user\n        \"\"\"\n        data = await self.http.get_user(self.username)\n        user = User(data=data, http=self.http)\n        return user\n\n    async def ban(self, reason: str) -> None:\n        \"\"\"\n        |coro|\n\n        Permanently bans a user from a chatroom.\n\n        Parameters\n        -----------\n        reason: str\n            The reason for the ban\n\n        Raises\n        -----------\n        `HTTPException`\n            Banning the user failed\n        `Forbidden`\n            You are unauthorized from banning the user\n        `NotFound`\n            Streamer or user not found\n        \"\"\"\n\n        await self.http.ban_chatter(self.streamer_name, self.username, reason)\n\n    async def timeout(self, duration: int, *, reason: str) -> None:\n        \"\"\"\n        |coro|\n\n        Times out a user for a given amount of time.\n\n        Parameters\n        -----------\n        duration: int\n            The amount of seconds for the timeout to be\n        reason: str\n            The reason for the timeout\n\n        Raises\n        -----------\n        `HTTPException`\n            timing out the user failed\n        `Forbidden`\n            You are unauthorized from timing out the user\n        `NotFound`\n            Streamer or user not found\n        \"\"\"\n\n        await self.http.timeout_chatter(\n            self.streamer_name, self.username, reason, duration\n        )\n\n    async def unban(self) -> None:\n        \"\"\"\n        |coro|\n\n        Unbans the chatter from the chatroom\n\n        Raises\n        -----------\n        `HTTPException`\n            Unbanning the user failed\n        `Forbidden`\n            You are unauthorized from unbanning the user\n        `NotFound`\n            Streamer or user not found\n        \"\"\"\n\n        await self.http.unban_user(self.streamer_name, self.username)\n\n    async def untimeout(self) -> None:\n        \"\"\"\n        |coro|\n\n        untimeout's the chatter\n\n        Raises\n        -----------\n        `HTTPException`\n            untimeouting the user failed\n        `Forbidden`\n            You are unauthorized from untimeouting the user\n        `NotFound`\n            Streamer or user not found\n        \"\"\"\n\n        await self.http.unban_user(self.streamer_name, self.username)\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__) and other.username == self.username\n\n    def __str__(self) -> str:\n        return self.username\n\n    def __repr__(self) -> str:\n        return f\"<PartialChatter username={self.username!r} streamer_name={self.streamer_name!r}>\"", "\n\nclass Chatter(PartialChatter):\n    \"\"\"\n    A dataclass which respresents a chatter on kick\n\n    Attributes\n    -----------\n    chatroom: Chatroom\n        The chatroom the chatter is in\n    id: int\n        The chatter's id\n    username: str\n        The chatter's username\n    slug: str\n        The chatter' slug\n    avatar: `Asset` | None\n        The chatter's avatar, if any\n    is_staff: bool\n        If the chatter is a staff member in the chatroom\n    is_owner: bool\n        If the chatter is the chatroom owner\n    is_mod: bool\n        If the chatter is a mod in the chatroom\n    badges: list[`ChatBadge`]\n        The chat badges the chatter has\n    following_since: datetime.datetime | None\n        when the chatter started following the streamer\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        data: ChatterPayload,\n        http: HTTPClient,\n        chatroom: Chatroom | PartialChatroom,\n    ) -> None:\n        self._data = data\n        self.chatroom: Chatroom | PartialChatroom = chatroom\n\n        super().__init__(\n            streamer_name=chatroom.streamer_name,\n            chatter_name=data[\"username\"],\n            http=http,\n        )\n\n    @property\n    def id(self) -> int:\n        \"\"\"\n        The chatter's id\n        \"\"\"\n\n        return self._data[\"id\"]\n\n    @property\n    def slug(self) -> str:\n        \"\"\"\n        The chatter' slug\n        \"\"\"\n\n        return self._data[\"slug\"]\n\n    @cached_property\n    def avatar(self) -> Asset | None:\n        \"\"\"\n        The chatter's avatar, if any\n        \"\"\"\n\n        return (\n            None\n            if self._data[\"profile_pic\"] is None\n            else Asset(url=self._data[\"profile_pic\"], http=self.http)\n        )\n\n    @property\n    def is_staff(self) -> bool:\n        \"\"\"\n        If the chatter is a staff member in the chatroom\n        \"\"\"\n\n        return self._data[\"is_staff\"]\n\n    @property\n    def is_owner(self) -> bool:\n        \"\"\"\n        If the chatter is the chatroom owner\n        \"\"\"\n\n        return self._data[\"is_channel_owner\"]\n\n    @property\n    def is_mod(self) -> bool:\n        \"\"\"\n        If the chatter is a mod in the chatroom\n        \"\"\"\n\n        return self._data[\"is_moderator\"]\n\n    @cached_property\n    def badges(self) -> list[ChatBadge]:\n        \"\"\"\n        The chat badges the chatter has\n        \"\"\"\n\n        return [ChatBadge(data=c) for c in self._data[\"badges\"]]\n\n    @cached_property\n    def following_since(self) -> datetime | None:\n        \"\"\"\n        when the chatter started following the streamer\n        \"\"\"\n\n        raw = self._data[\"following_since\"]\n        if raw is None:\n            return\n        else:\n            return datetime.fromisoformat(raw)\n\n    @property\n    def subscribed_for(self) -> int:\n        \"\"\"\n        The amount of months the user has been subscribed for\n        \"\"\"\n\n        return self._data[\"subscribed_for\"]\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__) and other.id == self.id\n\n    def __repr__(self) -> str:\n        return f\"<Chatter id={self.id!r} username={self.username!r} avatar={self.avatar!r} is_staff={self.is_staff!r} is_owner={self.is_owner!r} is_mod={self.is_mod!r}>\"", ""]}
{"filename": "kick/ws.py", "chunked_list": ["from __future__ import annotations\n\nimport json\nfrom typing import TYPE_CHECKING\n\nfrom aiohttp import ClientWebSocketResponse as WebSocketResponse\n\nfrom .livestream import PartialLivestream\nfrom .message import Message\n", "from .message import Message\n\nif TYPE_CHECKING:\n    from .http import HTTPClient\n\n__all__ = ()\n\n\nclass PusherWebSocket:\n    def __init__(self, ws: WebSocketResponse, *, http: HTTPClient):", "class PusherWebSocket:\n    def __init__(self, ws: WebSocketResponse, *, http: HTTPClient):\n        self.ws = ws\n        self.http = http\n        self.send_json = ws.send_json\n        self.close = ws.close\n\n    async def poll_event(self) -> None:\n        raw_msg = await self.ws.receive()\n        raw_data = raw_msg.json()", "        raw_msg = await self.ws.receive()\n        raw_data = raw_msg.json()\n        data = json.loads(raw_data[\"data\"])\n\n        self.http.client.dispatch(\"payload_receive\", raw_data[\"event\"], data)\n        self.http.client.dispatch(\"raw_payload_receive\", raw_data)\n\n        match raw_data[\"event\"]:\n            case \"App\\\\Events\\\\ChatMessageEvent\":\n                msg = Message(data=data, http=self.http)", "            case \"App\\\\Events\\\\ChatMessageEvent\":\n                msg = Message(data=data, http=self.http)\n                self.http.client.dispatch(\"message\", msg)\n            case \"App\\\\Events\\\\StreamerIsLive\":\n                livestream = PartialLivestream(data=data, http=self.http)\n                self.http.client.dispatch(\"livestream_start\", livestream)\n            case \"App\\\\Events\\\\FollowersUpdated\":\n                user = self.http.client._watched_users[data[\"channel_id\"]]\n                if data[\"followed\"] is True:\n                    event = \"follow\"", "                if data[\"followed\"] is True:\n                    event = \"follow\"\n                    user._data[\"followers_count\"] += 1\n                else:\n                    event = \"unfollow\"\n                    user._data[\"followers_count\"] -= 1\n\n                self.http.client.dispatch(event, user)\n\n    async def start(self) -> None:", "\n    async def start(self) -> None:\n        while not self.ws.closed:\n            await self.poll_event()\n\n    async def subscribe_to_chatroom(self, chatroom_id: int) -> None:\n        await self.send_json(\n            {\n                \"event\": \"pusher:subscribe\",\n                \"data\": {\"auth\": \"\", \"channel\": f\"chatrooms.{chatroom_id}.v2\"},", "                \"event\": \"pusher:subscribe\",\n                \"data\": {\"auth\": \"\", \"channel\": f\"chatrooms.{chatroom_id}.v2\"},\n            }\n        )\n\n    async def unsubscribe_to_chatroom(self, chatroom_id: int) -> None:\n        await self.send_json(\n            {\n                \"event\": \"pusher:unsubscribe\",\n                \"data\": {\"auth\": \"\", \"channel\": f\"chatrooms.{chatroom_id}.v2\"},", "                \"event\": \"pusher:unsubscribe\",\n                \"data\": {\"auth\": \"\", \"channel\": f\"chatrooms.{chatroom_id}.v2\"},\n            }\n        )\n\n    async def watch_channel(self, channel_id: int) -> None:\n        await self.send_json(\n            {\n                \"event\": \"pusher:subscribe\",\n                \"data\": {\"auth\": \"\", \"channel\": f\"channel.{channel_id}\"},", "                \"event\": \"pusher:subscribe\",\n                \"data\": {\"auth\": \"\", \"channel\": f\"channel.{channel_id}\"},\n            }\n        )\n\n    async def unwatch_channel(self, channel_id: int) -> None:\n        await self.send_json(\n            {\n                \"event\": \"pusher:subscribe\",\n                \"data\": {\"auth\": \"\", \"channel\": f\"channel.{channel_id}\"},", "                \"event\": \"pusher:subscribe\",\n                \"data\": {\"auth\": \"\", \"channel\": f\"channel.{channel_id}\"},\n            }\n        )\n"]}
{"filename": "kick/polls.py", "chunked_list": ["from __future__ import annotations\n\nimport datetime\nfrom typing import TYPE_CHECKING, Iterator\n\nfrom .object import HTTPDataclass\nfrom .utils import cached_property\n\nif TYPE_CHECKING:\n    from .chatroom import Chatroom, PartialChatroom\n    from .types.chatroom import CreatePollPayload, PollOptionPayload", "if TYPE_CHECKING:\n    from .chatroom import Chatroom, PartialChatroom\n    from .types.chatroom import CreatePollPayload, PollOptionPayload\n\n__all__ = (\"PollOption\", \"Poll\")\n\n\nclass PollOption(HTTPDataclass[\"PollOptionPayload\"]):\n    \"\"\"\n    This dataclass represents a chatroom `Poll`'s option on kick.\n\n    Attributes\n    -----------\n    chatroom: `Chatroom`\n        The chatroom the poll is in\n    id: int\n        The option's id\n    label: str\n        The option's label\n    votes: int\n        The amount of votes the option has\n    \"\"\"\n\n    chatroom: Chatroom | PartialChatroom\n\n    @property\n    def id(self) -> int:\n        \"\"\"\n        The option's id\n        \"\"\"\n\n        return self._data[\"id\"]\n\n    @property\n    def label(self) -> str:\n        \"\"\"\n        The option's label\n        \"\"\"\n\n        return self._data[\"label\"]\n\n    @property\n    def votes(self) -> int:\n        \"\"\"\n        The amount of votes the option has\n        \"\"\"\n\n        return self._data[\"votes\"]\n\n    async def vote(self) -> None:\n        \"\"\"\n        |coro|\n\n        Votes for this option in the poll\n\n        Raises\n        -----------\n        NotFound\n            There is no poll in the current chatroom\n        HTTPException\n            Deleting the poll failed\n        \"\"\"\n\n        await self.http.vote_for_poll(self.chatroom.streamer_name, self.id)", "\n\nclass Poll(HTTPDataclass[\"CreatePollPayload\"]):\n    \"\"\"\n    This dataclass represents a poll in a chatroom on kick.\n\n    Attributes\n    -----------\n    chatroom: `Chatroom`\n        The chatroom the poll is in\n    title: str\n        The poll's title\n    options: list[`PollOption`]\n        The poll's options\n    duration: int\n        How long the poll will last in seconds\n    result_display_duration: int\n        How long the poll will display the results in seconds\n    has_voted: bool\n        if you've voted yet\n    ends_at: datetime.datetime\n        When the poll ends at\n    \"\"\"\n\n    chatroom: Chatroom | PartialChatroom\n\n    @property\n    def title(self) -> str:\n        \"\"\"\n        Gives you the poll's title\n        \"\"\"\n\n        return self._data[\"data\"][\"poll\"][\"title\"]\n\n    def _get_options(self) -> Iterator[PollOption]:\n        for entry in self._data[\"data\"][\"poll\"][\"options\"]:\n            option = PollOption(data=entry, http=self.http)\n            option.chatroom = self.chatroom\n            yield option\n\n    @cached_property\n    def options(self) -> list[PollOption]:\n        \"\"\"\n        The poll's options\n        \"\"\"\n\n        return list(self._get_options())\n\n    @property\n    def duration(self) -> int:\n        \"\"\"\n        How long the poll is set to last in seconds\n        \"\"\"\n\n        return self._data[\"data\"][\"poll\"][\"duration\"]\n\n    @property\n    def result_display_duration(self) -> int:\n        \"\"\"\n        How long the poll will be displayed after it ends, in seconds\n        \"\"\"\n\n        return self._data[\"data\"][\"poll\"][\"result_display_duration\"]\n\n    @property\n    def has_voted(self) -> bool:\n        \"\"\"\n        Returns if you've voted yet\n        \"\"\"\n\n        return self._data[\"data\"][\"poll\"][\"has_voted\"]\n\n    @cached_property\n    def ends_at(self) -> datetime.datetime:\n        \"\"\"\n        How long the poll is set to last in seconds\n        \"\"\"\n\n        now = datetime.datetime.now(datetime.UTC)\n        return now + datetime.timedelta(seconds=self._data[\"data\"][\"poll\"][\"remaining\"])\n\n    async def delete(self) -> None:\n        \"\"\"\n        |coro|\n\n        Deletes the current poll from the chatroom\n\n        Raises\n        -----------\n        Forbidden\n            You are unauthorized to delete the poll\n        NotFound\n            There is no poll in the current chatroom\n        HTTPException\n            Deleting the poll failed\n        \"\"\"\n\n        await self.http.delete_poll(self.chatroom.streamer_name)", ""]}
{"filename": "kick/http.py", "chunked_list": ["from __future__ import annotations\n\nimport asyncio\nimport json\nimport logging\nfrom typing import TYPE_CHECKING, Any, Coroutine, Optional, TypeVar, Union\n\nfrom aiohttp import ClientConnectionError, ClientResponse, ClientSession\n\nfrom . import __version__", "\nfrom . import __version__\nfrom .errors import (\n    CloudflareBypassException,\n    Forbidden,\n    HTTPException,\n    InternalKickException,\n    LoginFailure,\n    NotFound,\n)", "    NotFound,\n)\nfrom .utils import MISSING\nfrom .ws import PusherWebSocket\n\nif TYPE_CHECKING:\n    from types.emotes import EmotesPayload\n\n    from typing_extensions import Self\n", "    from typing_extensions import Self\n\n    from .client import Client, Credentials\n    from .types.chatroom import (\n        BanChatterPayload,\n        ChatroomBannedWordsPayload,\n        ChatroomRulesPayload,\n        CreatePollPayload,\n        DeletePollPayload,\n        EditChatroomSettingsPayload,", "        DeletePollPayload,\n        EditChatroomSettingsPayload,\n        GetBannedUsersPayload,\n        UnbanChatterPayload,\n    )\n    from .types.leaderboard import LeaderboardPayload\n    from .types.message import (\n        FetchMessagesPayload,\n        MessagePayload,\n        ReplyOriginalMessage,", "        MessagePayload,\n        ReplyOriginalMessage,\n        ReplyOriginalSender,\n        V1MessageSentPayload,\n    )\n    from .types.user import ChatterPayload, ClientUserPayload, UserPayload\n    from .types.videos import GetVideosPayload\n\n    T = TypeVar(\"T\")\n    Response = Coroutine[Any, Any, T]", "    T = TypeVar(\"T\")\n    Response = Coroutine[Any, Any, T]\n\n\nLOGGER = logging.getLogger(__name__)\n\nNOTFOUND_SIGNATURE = \"\"\"\nclass=\"w-64 lg:w-[526px]\"\n\"\"\".strip()\n", "\"\"\".strip()\n\n\nasync def json_or_text(response: ClientResponse, /) -> Union[dict[str, Any], str]:\n    text = await response.text()\n    try:\n        try:\n            return json.loads(text)\n        except json.JSONDecodeError:\n            pass", "        except json.JSONDecodeError:\n            pass\n    except KeyError:\n        pass\n\n    return text\n\n\nasync def error_or_text(data: Union[dict, str]) -> str:\n    if isinstance(data, dict):", "async def error_or_text(data: Union[dict, str]) -> str:\n    if isinstance(data, dict):\n        if \"status\" in data:\n            return data[\"status\"][\"message\"]\n        elif \"error\" in data:\n            return data[\"error\"]\n        elif \"message\" in data:\n            return data[\"message\"]\n    return f\"{data}\"\n", "    return f\"{data}\"\n\n\nasync def error_or_nothing(data: Union[dict, str]) -> str:\n    if isinstance(data, dict):\n        return await error_or_text(data)\n    else:\n        return \"\"\n\n", "\n\nclass Route:\n    DOMAIN: str = \"https://kick.com\"\n    BASE: str = f\"{DOMAIN}/api/v2\"\n\n    def __init__(self, method: str, path: str) -> None:\n        self.path: str = path\n        self.method: str = method\n        self.url = self.BASE + self.path", "        self.method: str = method\n        self.url = self.BASE + self.path\n\n    @classmethod\n    def root(cls, method: str, path: str) -> Self:\n        self = cls.__new__(cls)\n        self.path = path\n        self.method = method\n        self.url = self.DOMAIN + path\n        return self", "        self.url = self.DOMAIN + path\n        return self\n\n\nclass HTTPClient:\n    def __init__(self, client: Client):\n        self.__session: ClientSession = MISSING\n        self.ws: PusherWebSocket = MISSING\n        self.client = client\n", "        self.client = client\n\n        self.token: str = MISSING\n        self.xsrf_token: str = MISSING\n        self.globally_locked: bool = False\n        self.__regex_token_task: asyncio.Task | None = None\n        self._credentials: Credentials | None = None\n\n        self.user_agent = f\"Kick.py V{__version__} (github.com/cibere/kick.py)\"\n", "        self.user_agent = f\"Kick.py V{__version__} (github.com/cibere/kick.py)\"\n\n        self.bypass_port = client._options.get(\"bypass_port\", 9090)\n        self.bypass_host = client._options.get(\"bypass_host\", \"http://localhost\")\n        self.whitelisted = client._options.get(\"whitelisted\", False)\n\n    async def regen_token_coro(self) -> None:\n        await asyncio.sleep(2419200)  # 28 days just to be safe\n        if self._credentials:\n            LOGGER.info(\"Attempting to renew token\")", "        if self._credentials:\n            LOGGER.info(\"Attempting to renew token\")\n            await self.client.login(self._credentials)\n\n    async def close(self) -> None:\n        LOGGER.info(\"Closing HTTP Client...\")\n        if self.__session is not MISSING:\n            await self.__session.close()\n        if self.ws is not MISSING:\n            await self.ws.close()", "        if self.ws is not MISSING:\n            await self.ws.close()\n\n    async def login(self, credentials: Credentials) -> None:\n        self._credentials = credentials\n\n        LOGGER.info(\n            f\"Logging in using {'username' if credentials.username_was_provided else 'email'} and password\"\n        )\n", "        )\n\n        # Mobile login method is used here since more is known about\n        # how that works compared to the desktop version.\n        # As for compatibility, there is no known endpoints that\n        # a mobile token can not authorize at.\n\n        token_route = Route.root(\"GET\", \"/kick-token-provider\")\n        token_provider = await self.request(token_route)\n", "        token_provider = await self.request(token_route)\n\n        route = Route.root(\"POST\", \"/mobile/login\")\n\n        data = {\n            \"email\": credentials.email,\n            \"password\": credentials.password,\n            \"isMobileRequest\": True,\n            token_provider[\"nameFieldName\"]: \"\",\n            token_provider[\"validFromFieldName\"]: token_provider[\"encryptedValidFrom\"],", "            token_provider[\"nameFieldName\"]: \"\",\n            token_provider[\"validFromFieldName\"]: token_provider[\"encryptedValidFrom\"],\n        }\n        if credentials.one_time_password is not None:\n            data[\"one_time_password\"] = credentials.one_time_password\n\n        res = await self.request(route, json=data)\n\n        if isinstance(res, str):\n            raise NotFound(\"Kick 404'd on login page\")", "        if isinstance(res, str):\n            raise NotFound(\"Kick 404'd on login page\")\n\n        if res[\"2fa_required\"] is True:\n            two_fa_code = input(\n                \"[WARNING] 2FA is enabled. Either disable it or give a 2fa code.\\n> \"\n            )\n            if not two_fa_code:\n                raise LoginFailure(\"2FA is enabled.\")\n            else:", "                raise LoginFailure(\"2FA is enabled.\")\n            else:\n                data[\"one_time_password\"] = two_fa_code\n                res = await self.request(route, json=data)\n                if res[\"2fa_required\"] is True:\n                    raise LoginFailure(\"2FA is enabled.\")\n\n        if \"message\" in res.keys():\n            raise LoginFailure(res[\"message\"])\n", "            raise LoginFailure(res[\"message\"])\n\n        self.token = res[\"token\"]\n        LOGGER.info(\"Successfully logged in\")\n        self.__regex_token_task = asyncio.create_task(\n            self.regen_token_coro(), name=\"Regen-Token\"\n        )\n\n    async def start(self) -> None:\n        LOGGER.debug(", "    async def start(self) -> None:\n        LOGGER.debug(\n            f\"Starting HTTP client. Whitelisted: {self.whitelisted}, Bypass Port: {self.bypass_port}\"\n        )\n        if self.__session is MISSING:\n            self.__session = ClientSession()\n\n        actual_ws = await self.__session.ws_connect(\n            f\"wss://ws-us2.pusher.com/app/eb1d5f283081a78b932c?protocol=7&client=js&version=7.6.0&flash=false\"\n        )", "            f\"wss://ws-us2.pusher.com/app/eb1d5f283081a78b932c?protocol=7&client=js&version=7.6.0&flash=false\"\n        )\n        self.ws = PusherWebSocket(actual_ws, http=self)\n        self.client.dispatch(\"ready\")\n        await self.ws.start()\n\n    async def request(self, route: Route, **kwargs) -> Any:\n        if self.__session is MISSING:\n            self.__session = ClientSession()\n", "            self.__session = ClientSession()\n\n        headers = kwargs.pop(\"headers\", {})\n        headers[\"User-Agent\"] = self.user_agent\n        headers[\"Accepts\"] = \"application/json\"\n\n        cookies = kwargs.pop(\"cookies\", {})\n\n        if self.xsrf_token:\n            headers[\"X-XSRF-TOKEN\"] = self.xsrf_token", "        if self.xsrf_token:\n            headers[\"X-XSRF-TOKEN\"] = self.xsrf_token\n            cookies[\"XSRF-TOKEN\"] = self.xsrf_token\n        if self.token:\n            headers[\"Authorization\"] = f\"Bearer {self.token}\"\n\n        url = route.url\n\n        if \"json\" in kwargs:\n            headers[\"Content-Type\"] = \"application/json\"", "        if \"json\" in kwargs:\n            headers[\"Content-Type\"] = \"application/json\"\n\n        res: ClientResponse | None = None\n        data: str | dict | None = None\n\n        for current_try in range(3):\n            while self.globally_locked is True:\n                await asyncio.sleep(2)\n", "                await asyncio.sleep(2)\n\n            LOGGER.debug(\n                f\"Making request to {route.method} {url}. headers: {headers}, params: {kwargs.get('params', None)}, json: {kwargs.get('json', None)}\"\n            )\n            try:\n                res = await self.__session.request(\n                    route.method,\n                    url\n                    if self.whitelisted is True", "                    url\n                    if self.whitelisted is True\n                    else f\"{self.bypass_host}:{self.bypass_port}/request?url={url}\",\n                    headers=headers,\n                    cookies=cookies,\n                    **kwargs,\n                )\n            except ClientConnectionError:\n                if self.whitelisted is True:\n                    raise InternalKickException(\"Could Not Connect To Kick\") from None", "                if self.whitelisted is True:\n                    raise InternalKickException(\"Could Not Connect To Kick\") from None\n                else:\n                    raise CloudflareBypassException(\n                        \"Could Not Connect To Bypass Script\"\n                    ) from None\n\n            if res is not None:\n                self.xsrf_token = str(\n                    getattr(res.cookies.get(\"XSRF-TOKEN\", MISSING), \"value\", MISSING)", "                self.xsrf_token = str(\n                    getattr(res.cookies.get(\"XSRF-TOKEN\", MISSING), \"value\", MISSING)\n                )\n\n                data = await json_or_text(res)\n\n                if res.status == 429:\n                    self.globally_locked = True\n                    LOGGER.warning(\n                        f\"We have been ratelimited at {route.method} {route.url}. Waiting five seconds before trying again...\",", "                    LOGGER.warning(\n                        f\"We have been ratelimited at {route.method} {route.url}. Waiting five seconds before trying again...\",\n                    )\n\n                    await asyncio.sleep(5)\n                    return await self.request(route)\n                else:\n                    self.globally_locked = False\n\n                if 300 > res.status >= 200:", "\n                if 300 > res.status >= 200:\n                    return data\n\n                match res.status:\n                    case 400:\n                        error = await error_or_text(data)\n                        raise HTTPException(error, res.status)\n                    case 403:\n                        raise Forbidden(await error_or_nothing(data))", "                    case 403:\n                        raise Forbidden(await error_or_nothing(data))\n                    case 404:\n                        error = await error_or_nothing(data)\n                        raise NotFound(error or \"Not Found\")\n                    case 500:\n                        time = 2 * current_try\n\n                        LOGGER.warning(\n                            f\"API returned a 500 status code at {route.method} {route.url}. Retrying in {time} seconds\",", "                        LOGGER.warning(\n                            f\"API returned a 500 status code at {route.method} {route.url}. Retrying in {time} seconds\",\n                        )\n                        await asyncio.sleep(time)\n                        continue\n                    case 502:\n                        txt = await error_or_text(data)\n                        raise InternalKickException(txt)\n                    case other:\n                        raise RuntimeError(f\"Unknown status reached: {other}\")", "                    case other:\n                        raise RuntimeError(f\"Unknown status reached: {other}\")\n\n        if res is not None and data is not None:\n            txt = await error_or_text(data)\n\n            if res.status >= 500:\n                raise InternalKickException(txt)\n\n            raise HTTPException(txt, res.status)", "\n            raise HTTPException(txt, res.status)\n\n        raise RuntimeError(\"Unreachable situation occured in http handling\")\n\n    def send_message(\n        self, chatroom: int, content: str\n    ) -> Response[V1MessageSentPayload]:\n        # We use the V1 api here since I havn't gotten it to work with V2.\n        # Unfortunatly V1 only returns a confirmation, and not the message (unlike V2)", "        # We use the V1 api here since I havn't gotten it to work with V2.\n        # Unfortunatly V1 only returns a confirmation, and not the message (unlike V2)\n\n        route = Route.root(\"POST\", \"/api/v1/chat-messages\")\n        return self.request(\n            route,\n            data={\"message\": content, \"chatroom_id\": chatroom},\n        )\n\n    def delete_message(self, chatroom: int, message_id: str) -> Response[Any]:", "\n    def delete_message(self, chatroom: int, message_id: str) -> Response[Any]:\n        # Kick keeps 500ing on this, so not sure what to expect from it\n        return self.request(\n            Route(\"DELETE\", f\"/chatrooms/{chatroom}/messages/{message_id}\")\n        )\n\n    def get_user(self, streamer: str) -> Response[UserPayload]:\n        return self.request(Route(method=\"GET\", path=f\"/channels/{streamer}\"))\n", "        return self.request(Route(method=\"GET\", path=f\"/channels/{streamer}\"))\n\n    def get_chatter(self, streamer: str, chatter: str) -> Response[ChatterPayload]:\n        return self.request(\n            Route(\n                method=\"GET\",\n                path=f\"/channels/{streamer}/users/{chatter}\",\n            )\n        )\n", "        )\n\n    def get_messages(self, chatroom: int) -> Response[FetchMessagesPayload]:\n        return self.request(Route(\"GET\", f\"/channels/{chatroom}/messages\"))\n\n    def get_chatroom_rules(self, streamer: str) -> Response[ChatroomRulesPayload]:\n        return self.request(Route(\"GET\", f\"/channels/{streamer}/chatroom/rules\"))\n\n    def get_streamer_videos(self, streamer: str) -> Response[GetVideosPayload]:\n        return self.request(Route(\"GET\", f\"/channels/{streamer}/videos\"))", "    def get_streamer_videos(self, streamer: str) -> Response[GetVideosPayload]:\n        return self.request(Route(\"GET\", f\"/channels/{streamer}/videos\"))\n\n    def get_emotes(self, streamer: str) -> Response[EmotesPayload]:\n        return self.request(Route.root(\"GET\", f\"/emotes/{streamer}\"))\n\n    def get_channels_banned_words(\n        self, streamer: str\n    ) -> Response[ChatroomBannedWordsPayload]:\n        return self.request(Route(\"GET\", f\"/channels/{streamer}/chatroom/banned-words\"))", "    ) -> Response[ChatroomBannedWordsPayload]:\n        return self.request(Route(\"GET\", f\"/channels/{streamer}/chatroom/banned-words\"))\n\n    def get_channel_gift_leaderboard(\n        self, streamer: str\n    ) -> Response[LeaderboardPayload]:\n        return self.request(Route.root(\"GET\", f\"/channels/{streamer}/leaderboards\"))\n\n    def get_channel_bans(self, streamer: str) -> Response[GetBannedUsersPayload]:\n        \"\"\"", "    def get_channel_bans(self, streamer: str) -> Response[GetBannedUsersPayload]:\n        \"\"\"\n        Requires Mod\n        \"\"\"\n\n        return self.request(Route(\"GET\", f\"/channels/{streamer}/bans\"))\n\n    def unban_user(self, streamer: str, chatter: str) -> Response[UnbanChatterPayload]:\n        return self.request(Route(\"DELETE\", f\"/channels/{streamer}/bans/{chatter}\"))\n", "        return self.request(Route(\"DELETE\", f\"/channels/{streamer}/bans/{chatter}\"))\n\n    def timeout_chatter(\n        self, streamer: str, chatter: str, reason: str, duration: int\n    ) -> Response[BanChatterPayload]:\n        return self.request(\n            Route(\"POST\", f\"/channels/{streamer}/bans\"),\n            json={\n                \"banned_username\": chatter,\n                \"permanent\": False,", "                \"banned_username\": chatter,\n                \"permanent\": False,\n                \"reason\": reason,\n                \"duration\": duration,\n            },\n        )\n\n    def ban_chatter(\n        self, streamer: str, chatter: str, reason: str\n    ) -> Response[BanChatterPayload]:", "        self, streamer: str, chatter: str, reason: str\n    ) -> Response[BanChatterPayload]:\n        return self.request(\n            Route(\"POST\", f\"/channels/{streamer}/bans\"),\n            json={\n                \"banned_username\": chatter,\n                \"permanent\": True,\n                \"reason\": reason,\n            },\n        )", "            },\n        )\n\n    def create_poll(\n        self,\n        streamer: str,\n        duration: int,\n        options: list[str],\n        result_display_duration: int,\n        title: str,", "        result_display_duration: int,\n        title: str,\n    ) -> Response[CreatePollPayload]:\n        \"\"\"\n        Durations are in seconds\n        \"\"\"\n\n        return self.request(\n            Route(\"POST\", f\"/channels/{streamer}/polls\"),\n            json={", "            Route(\"POST\", f\"/channels/{streamer}/polls\"),\n            json={\n                \"duration\": duration,\n                \"options\": options,\n                \"result_display_duration\": result_display_duration,\n                \"title\": title,\n            },\n        )\n\n    def delete_poll(self, streamer: str) -> Response[DeletePollPayload]:", "\n    def delete_poll(self, streamer: str) -> Response[DeletePollPayload]:\n        return self.request(Route(\"DELETE\", f\"/channels/{streamer}/polls\"))\n\n    def vote_for_poll(self, streamer: str, option: int) -> Response[CreatePollPayload]:\n        return self.request(\n            Route(\"POST\", f\"/channels/{streamer}/polls/vote\"),\n            json={\"id\": option},\n        )\n", "        )\n\n    def get_poll(self, streamer: str) -> Response[CreatePollPayload]:\n        return self.request(\n            Route(\"GET\", f\"/channels/{streamer}/polls\"),\n        )\n\n    def edit_chatroom(\n        self,\n        streamer: str,", "        self,\n        streamer: str,\n        followers_only_mode: Optional[bool] = None,\n        emotes_only_mode: Optional[bool] = None,\n        subscribers_only_mode: Optional[bool] = None,\n        slow_mode_enabled: Optional[bool] = None,\n        slow_mode_interval: Optional[int] = None,\n        following_min_duration: Optional[int] = None,\n    ) -> Response[EditChatroomSettingsPayload]:\n        payload = {}", "    ) -> Response[EditChatroomSettingsPayload]:\n        payload = {}\n\n        if followers_only_mode is not None:\n            payload[\"followers_mode\"] = followers_only_mode\n\n        if emotes_only_mode is not None:\n            payload[\"emotes_mode\"] = emotes_only_mode\n\n        if subscribers_only_mode is not None:", "\n        if subscribers_only_mode is not None:\n            payload[\"subscribers_mode\"] = subscribers_only_mode\n\n        if slow_mode_enabled is not None:\n            payload[\"slow_mode\"] = slow_mode_enabled\n            if slow_mode_enabled and slow_mode_interval is not None:\n                payload[\"message_interval\"] = slow_mode_interval\n\n        if following_min_duration is not None:", "\n        if following_min_duration is not None:\n            payload[\"following_min_duration \"] = following_min_duration\n\n        if not payload:\n            raise ValueError(\"No valid parameters provided for chatroom editing.\")\n\n        return self.request(\n            Route(\"PUT\", f\"/channels/{streamer}/chatroom\"),\n            json=payload,", "            Route(\"PUT\", f\"/channels/{streamer}/chatroom\"),\n            json=payload,\n        )\n\n    def reply_to_message(\n        self,\n        chatroom: int,\n        content: str,\n        original_message: ReplyOriginalMessage,\n        original_sender: ReplyOriginalSender,", "        original_message: ReplyOriginalMessage,\n        original_sender: ReplyOriginalSender,\n    ) -> Response[MessagePayload]:\n        return self.request(\n            Route(\"POST\", f\"/messages/send/{chatroom}\"),\n            json={\n                \"content\": content,\n                \"metadata\": {\n                    \"original_message\": original_message,\n                    \"original_sender\": original_sender,", "                    \"original_message\": original_message,\n                    \"original_sender\": original_sender,\n                },\n                \"type\": \"reply\",\n            },\n        )\n\n    def get_me(self) -> Response[ClientUserPayload]:\n        return self.request(Route.root(\"GET\", \"/api/v1/user\"))\n", "        return self.request(Route.root(\"GET\", \"/api/v1/user\"))\n\n    async def get_asset(self, url: str) -> bytes:\n        if self.__session is MISSING:\n            self.__session = ClientSession()\n\n        res = await self.__session.request(\"GET\", url)\n        match res.status:\n            case 200:\n                return await res.read()", "            case 200:\n                return await res.read()\n            case 403:\n                raise Forbidden()\n            case 404:\n                raise NotFound(\"Asset Not Found\")\n            case 500:\n                data = await json_or_text(res)\n                error = await error_or_text(data)\n                raise InternalKickException(error)", "                error = await error_or_text(data)\n                raise InternalKickException(error)\n            case other:\n                raise HTTPException(await res.text(), other)\n"]}
{"filename": "kick/types/emotes.py", "chunked_list": ["from typing import Literal\n\nfrom typing_extensions import TypedDict\n\nfrom .user import InnerUser\n\n\nclass EmotePayload(TypedDict):\n    id: int\n    channel_id: int\n    name: str\n    subscribers_only: bool", "\n\nclass EmojiUserPayload(TypedDict):\n    id: int\n    user_id: int\n    slug: str\n    is_banned: bool\n    playback_url: str\n    name_updated_at: None  # NEED TO FIGURE THIS OUT\n    vod_enabled: bool\n    subscription_enabled: bool\n    emotes: list[EmotePayload]\n    can_host: bool\n    user: InnerUser", "\n\nclass EmotesDataPayload(TypedDict):\n    emotes: list[EmotePayload]\n\n\nclass GlobalEmotesPayload(EmotesDataPayload):\n    name: Literal[\"Global\"]\n    id: Literal[\"Global\"]\n", "\n\nclass StreamerEmotesPayload(EmotesDataPayload):\n    name: Literal[\"Emojis\"]\n    id: Literal[\"Emoji\"]\n\n\nEmotesPayload = tuple[EmojiUserPayload, GlobalEmotesPayload, StreamerEmotesPayload]\n", ""]}
{"filename": "kick/types/videos.py", "chunked_list": ["from typing_extensions import TypedDict\n\nfrom .assets import AssetSrcset, AssetUrl\nfrom .categories import Category\n\n\nclass BaseVideoPayload(TypedDict):\n    id: int\n    slug: str\n    channel_id: int\n    created_at: str\n    session_title: str\n    is_live: bool\n    risk_level_id: None  # NEED TO FIGURE THIS OUT\n    source: None  # NEED TO FIGURE THIS OUT\n    twitch_channel: None  # NEED TO FIGURE THIS OUT\n    duration: int\n    language: str\n    is_mature: bool\n    viewer_count: int\n    categories: list[Category]", "\n\nclass LivestreamPayload(BaseVideoPayload):\n    tags: list  # NEED TO FIGURE THIS OUT\n    thumbnail: None | AssetUrl\n\n\nclass InnerVideoPayload(TypedDict):\n    id: int\n    live_stream_id: int\n    slug: str | None  # Assumed str\n    thumb: None  # NEED TO FIGURE THIS OUT\n    s3: None  # NEED TO FIGURE THIS OUT\n    trading_platform_id: None  # NEED TO FIGURE THIS OUT\n    created_at: str\n    updated_at: str\n    views: int\n    deleted_at: None  # NEED TO FIGURE THIS OUT", "\n\nclass VideoPayload(BaseVideoPayload):\n    video: InnerVideoPayload\n    thumbnail: AssetSrcset\n\n\nGetVideosPayload = list[VideoPayload]\n", ""]}
{"filename": "kick/types/chatroom.py", "chunked_list": ["from codecs import StreamWriter\n\nfrom typing_extensions import TypedDict\n\nfrom .all import StatusPayload\n\n\nclass ChatroomRulesDataPayload(TypedDict):\n    rules: str\n", "\n\nclass ChatroomRulesPayload(TypedDict):\n    status: StatusPayload\n    data: ChatroomRulesDataPayload\n\n\nclass DeletePollPayload(TypedDict):\n    status: StatusPayload\n    data: None", "\n\nclass ChatroomBannedWordsDataPayload(TypedDict):\n    words: list[str]\n\n\nclass ChatroomBannedWordsPayload(TypedDict):\n    status: StatusPayload\n    data: ChatroomBannedWordsDataPayload\n", "\n\nclass BanEntryUserPayload(TypedDict):\n    id: int\n    username: str\n\n\nclass BanEntryDataPayload(TypedDict):\n    reason: str\n    banned_at: str\n    permanent: bool\n    expires_at: str", "\n\nclass BanEntryPayload(TypedDict):\n    banned_user: BanEntryUserPayload\n    banned_by: BanEntryUserPayload\n    ban: BanEntryDataPayload\n\n\nGetBannedUsersPayload = list[BanEntryPayload]\n", "GetBannedUsersPayload = list[BanEntryPayload]\n\n\nclass UnbanChatterPayload(TypedDict):\n    status: bool\n    message: str\n\n\nclass BanChatterDataPayload(TypedDict):\n    id: str\n    chat_id: int\n    banned_id: int\n    banner_id: int\n    reason: str\n    type: str\n    permanent: bool\n    created_at: str\n    expires_at: str", "class BanChatterDataPayload(TypedDict):\n    id: str\n    chat_id: int\n    banned_id: int\n    banner_id: int\n    reason: str\n    type: str\n    permanent: bool\n    created_at: str\n    expires_at: str", "\n\nclass BanChatterPayload(TypedDict):\n    status: StatusPayload\n    data: BanChatterDataPayload\n\n\nclass PollOptionPayload(TypedDict):\n    id: int\n    label: str\n    votes: int", "\n\nclass PollPayload(TypedDict):\n    title: str\n    options: list[PollOptionPayload]\n    duration: int\n    remaining: int\n    result_display_duration: int\n    has_voted: bool\n", "\n\nclass CreatePollDataPayload(TypedDict):\n    poll: PollPayload\n\n\nclass CreatePollPayload(TypedDict):\n    status: StatusPayload\n    data: CreatePollDataPayload\n", "\n\nclass ChatroomSettingPayload(TypedDict):\n    enabled: bool\n\n\nclass FollowersModeStatusPayload(ChatroomSettingPayload):\n    min_duration: int\n\n\nclass SlowModeStatusPayload(ChatroomSettingPayload):\n    message_interval: int", "\n\nclass SlowModeStatusPayload(ChatroomSettingPayload):\n    message_interval: int\n\n\nclass EditChatroomSettingsPayload(TypedDict):\n    id: int\n    slow_mode: SlowModeStatusPayload\n    subscribers_mode: ChatroomSettingPayload\n    followers_mode: FollowersModeStatusPayload\n    emotes_mode: ChatroomSettingPayload", ""]}
{"filename": "kick/types/categories.py", "chunked_list": ["from typing_extensions import TypedDict\n\n\nclass InnerCategory(TypedDict):\n    id: int\n    name: str\n    slug: str\n    icon: str\n\n\nclass Category(TypedDict):\n    id: int\n    category_id: int\n    name: str\n    slug: str\n    tags: list[str]\n    description: str | None\n    deleted_at: None  # NEED TO FIGURE THIS OUT\n    category: InnerCategory", "\n\nclass Category(TypedDict):\n    id: int\n    category_id: int\n    name: str\n    slug: str\n    tags: list[str]\n    description: str | None\n    deleted_at: None  # NEED TO FIGURE THIS OUT\n    category: InnerCategory", ""]}
{"filename": "kick/types/assets.py", "chunked_list": ["from typing_extensions import TypedDict\n\n\nclass AssetUrl(TypedDict):\n    url: str\n\n\nclass AssetSrcset(TypedDict):\n    src: str\n    srcset: str", "\n\nclass AssetOnlySrc(TypedDict):\n    src: str\n\n\nAnyAsset = AssetUrl | AssetOnlySrc | AssetSrcset\nAssetPayload: bytes\n", ""]}
{"filename": "kick/types/badges.py", "chunked_list": ["from typing_extensions import TypedDict\n\nfrom .assets import AssetSrcset\n\n\nclass ChatBadgePayload(TypedDict):\n    type: str\n    text: str\n    count: int\n    active: bool", "\n\nclass SubscriberBadgePayload(TypedDict):\n    id: int\n    channel_id: int\n    months: int\n    badge_image: AssetSrcset\n"]}
{"filename": "kick/types/all.py", "chunked_list": ["from typing_extensions import TypedDict\n\n\nclass StatusPayload(TypedDict):\n    error: bool\n    code: int\n    message: str\n"]}
{"filename": "kick/types/message.py", "chunked_list": ["from typing import Literal\n\nfrom typing_extensions import TypedDict\n\nfrom .all import StatusPayload\n\n\nclass AuthorIdentity(TypedDict):\n    color: str\n    badges: list  # NEED TO FIGURE THIS OUT", "\n\nclass AuthorPayload(TypedDict):\n    id: int\n    username: str\n    slug: str\n    identity: AuthorIdentity\n\n\nclass BaseMessagePayload(TypedDict):\n    id: str\n    chatroom_id: int\n    content: str\n    created_at: str\n    sender: AuthorPayload", "\nclass BaseMessagePayload(TypedDict):\n    id: str\n    chatroom_id: int\n    content: str\n    created_at: str\n    sender: AuthorPayload\n\n\nclass NormalMessagePayload(BaseMessagePayload):\n    type: Literal[\"message\"]", "\nclass NormalMessagePayload(BaseMessagePayload):\n    type: Literal[\"message\"]\n\n\nclass ReplyOriginalSender(TypedDict):\n    id: str | int\n    username: str\n\n\nclass ReplyOriginalMessage(TypedDict):\n    id: str\n    content: str", "\n\nclass ReplyOriginalMessage(TypedDict):\n    id: str\n    content: str\n\n\nclass ReplyMetaData(TypedDict):\n    original_sender: ReplyOriginalSender\n    original_message: ReplyOriginalMessage", "\n\nclass ReplyMessagePayload(BaseMessagePayload):\n    type: Literal[\"reply\"]\n    metadata: ReplyMetaData\n\n\nMessagePayload = NormalMessagePayload | ReplyMessagePayload\n\n\nclass MessageSentPayload(TypedDict):\n    status: StatusPayload\n    data: MessagePayload", "\n\nclass MessageSentPayload(TypedDict):\n    status: StatusPayload\n    data: MessagePayload\n\n\nclass FetchMessagesDataPayload(TypedDict):\n    messages: list[MessagePayload]\n    cursor: str", "\n\nclass FetchMessagesPayload(TypedDict):\n    status: StatusPayload\n    data: FetchMessagesDataPayload\n\n\nclass V1MessageSentPayload(StatusPayload):\n    ...\n", ""]}
{"filename": "kick/types/leaderboard.py", "chunked_list": ["from typing_extensions import TypedDict\n\n\nclass GiftEntryPayload(TypedDict):\n    user_id: int\n    username: str\n    quantity: int\n\n\nclass LeaderboardPayload(TypedDict):\n    gifts: list[GiftEntryPayload]\n    gifts_week: list[GiftEntryPayload]\n    gifts_month: list[GiftEntryPayload]", "\nclass LeaderboardPayload(TypedDict):\n    gifts: list[GiftEntryPayload]\n    gifts_week: list[GiftEntryPayload]\n    gifts_month: list[GiftEntryPayload]\n"]}
{"filename": "kick/types/ws.py", "chunked_list": ["from typing_extensions import TypedDict\n\nfrom .assets import AssetSrcset, AssetUrl\nfrom .categories import Category\n\n\nclass PartialLivestreamPayload(TypedDict):\n    id: int\n    channel_id: int\n    session_title: str\n    source: None  # Unknown\n    created_at: str", "\n\nclass FollowersUpdatePayload(TypedDict):\n    followersCount: str\n    channel_id: int\n    username: None | str\n    created_at: int\n    followed: bool\n", ""]}
{"filename": "kick/types/user.py", "chunked_list": ["from typing_extensions import Any, TypedDict\n\nfrom .assets import AssetSrcset, AssetUrl\nfrom .badges import ChatBadgePayload, SubscriberBadgePayload\nfrom .categories import Category\nfrom .videos import LivestreamPayload\n\n\nclass InnerUser(TypedDict):\n    id: int\n    username: str\n    agreed_to_terms: bool\n    email_verified_at: str\n    bio: str\n    country: str\n    state: str\n    city: str\n    instagram: str\n    twitter: str\n    youtube: str\n    discord: str\n    tiktok: str\n    facebook: str\n    profile_pic: str", "class InnerUser(TypedDict):\n    id: int\n    username: str\n    agreed_to_terms: bool\n    email_verified_at: str\n    bio: str\n    country: str\n    state: str\n    city: str\n    instagram: str\n    twitter: str\n    youtube: str\n    discord: str\n    tiktok: str\n    facebook: str\n    profile_pic: str", "\n\nclass ChatroomPayload(TypedDict):\n    id: int\n    chatable_type: str\n    channel_id: int\n    created_at: str\n    updated_at: str\n    chat_mode_old: str\n    chat_mode: str\n    slow_mode: bool\n    chatable_id: int\n    followers_mode: bool\n    subscribers_mode: bool\n    emotes_mode: bool\n    message_interval: int\n    following_min_duration: int", "\n\nclass UserPayload(TypedDict):\n    id: int\n    user_id: int\n    slug: str\n    is_banned: bool\n    playback_url: str\n    vod_enabled: bool\n    subscription_enabled: bool\n    followers_count: int\n    subscriber_badges: list[SubscriberBadgePayload]\n    banner_image: AssetUrl | None\n    role: None  # Unknown\n    muted: bool\n    follower_badges: list  # Unknown\n    offline_banner_image: AssetSrcset | None\n    verified: bool\n    can_host: bool\n    user: InnerUser\n    chatroom: ChatroomPayload\n    livestream: LivestreamPayload | None\n    recent_categories: list[Category]", "\n\nclass ChatterPayload(TypedDict):\n    id: int\n    username: str\n    slug: str\n    profile_pic: None | str\n    is_staff: bool\n    is_channel_owner: bool\n    is_moderator: bool\n    badges: list[ChatBadgePayload]\n    following_since: None | str\n    subscribed_for: int  # in months\n    banned: None  # Unknown", "\n\nclass ClientChatterPayload(TypedDict):\n    subscription: None  # Unknown\n    is_super_admin: bool\n    is_following: bool\n    following_since: None | str\n    is_broadcaster: bool\n    is_moderator: bool\n    leaderboards: Any  # Unknown\n    banned: None  # Unknown", "\n\nclass PartialUserPayload(TypedDict):\n    id: str | int\n    username: str\n\n\nclass ClientUserStreamerChannelsPayload(TypedDict):\n    id: int\n    user_id: int\n    slug: str\n    is_banned: bool\n    playback_url: None | str\n    name_updated_at: None  # Unknown\n    vod_enabled: bool\n    subscription_enabled: bool\n    can_host: bool\n    verified: None  # Unknown", "\n\nclass ClientUserPayload(TypedDict):\n    id: int\n    email: str\n    username: str\n    google_id: None  # Unknown\n    agreed_to_terms: bool\n    email_verified_at: str\n    bio: None | str\n    country: None | str\n    state: None | str\n    city: None | str\n    enable_live_notifications: bool\n    youtube: None | str\n    instagram: None | str\n    twitter: None | str\n    discord: None | str\n    tiktok: None | str\n    facebook: None | str\n    enable_onscreen_live_notifications: bool\n    apple_id: None  # Unknown\n    phone: None | int\n    email_updated_at: None  # Unknown\n    newsletter_subscribed: bool\n    enable_sms_promo: bool\n    enable_sms_security: bool\n    is_2fa_setup: bool\n    redirect: None  # Unknown\n    channel_can_be_updated: bool\n    is_live: bool\n    intercom_hash: None  # Unknown\n    streamer_channel: ClientUserStreamerChannelsPayload\n    roles: list  # Unknown\n    profilepic: str | None", ""]}
{"filename": "examples/voting_on_poll.py", "chunked_list": ["from kick import Client\n\nclient = Client()\n\n\n@client.event\nasync def on_ready():\n    print(\"I have successfully logged in\")\n\n    username = (", "\n    username = (\n        \"xqc\"  # The username/slug of the user's chat you want to send the message in\n    )\n    user = await client.fetch_user(username)\n    chatroom = user.chatroom\n\n    # Fetching the chatroom's poll\n    poll = await chatroom.fetch_poll()\n", "    poll = await chatroom.fetch_poll()\n\n    # Getting the first option\n    option = poll.options[0]\n\n    # Voting for the first option\n    await option.vote()\n\n    # Refetching the poll to get an updated votes count\n    new_poll = await chatroom.fetch_poll()", "    # Refetching the poll to get an updated votes count\n    new_poll = await chatroom.fetch_poll()\n\n    # Getting the new first option\n    new_option = new_poll.options[0]\n\n    # Printing the updated vote count\n    print(f\"The first option now has {new_option.votes} votes.\")\n\n", "\n\n# You can also pass the `credentials` arg to authenticate yourself\n# Authentication is not required for listening to messages\nclient.run()\n"]}
{"filename": "examples/receive_message.py", "chunked_list": ["from kick import Client, Message\n\nclient = Client()\n\n\n@client.event\nasync def on_message(msg: Message):\n    print(f\"Received message by {msg.author.slug} saying {msg.content}\")\n\n", "\n\n@client.event\nasync def on_ready():\n    print(\"I have successfully logged in\")\n\n    username = \"xqc\"  # The username/slug of the user's chat you want to listen to\n    user = await client.fetch_user(username)\n    await user.chatroom.connect()\n", "    await user.chatroom.connect()\n\n\n# You can also pass the `credentials` arg to authenticate yourself\n# Authentication is not required for listening to messages\nclient.run()\n"]}
{"filename": "examples/send_message.py", "chunked_list": ["from kick import Client, Credentials\n\nclient = Client()\n\n\n@client.event\nasync def on_ready():\n    print(\"I have successfully logged in\")\n\n    username = (", "\n    username = (\n        \"xqc\"  # The username/slug of the user's chat you want to send the message in\n    )\n    user = await client.fetch_user(username)\n    chatroom = user.chatroom\n\n    await chatroom.send(\"Hello!\")\n\n", "\n\n# You have to authenticate yourself in order to send mesages\ncredentials = Credentials(\n    username=\"...\",  # you can also use the email kwarg, but not both\n    password=\"...\",\n)\nclient.run(credentials)\n", ""]}
