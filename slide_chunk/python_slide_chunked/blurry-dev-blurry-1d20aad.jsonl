{"filename": "noxfile.py", "chunked_list": ["import nox\n\n\n@nox.session(python=[\"3.11\", \"3.10\"])\ndef tests(session):\n    session.install(\"pytest\", \".\")\n    session.run(\"pytest\")\n\n\n@nox.session(python=[\"3.11\", \"3.10\"])\ndef lint(session):\n    session.install(\"flake8\", \".\")\n    session.run(\"flake8\", \"blurry\", \"tests\")", "\n@nox.session(python=[\"3.11\", \"3.10\"])\ndef lint(session):\n    session.install(\"flake8\", \".\")\n    session.run(\"flake8\", \"blurry\", \"tests\")\n\n\n@nox.session(python=[\"3.11\", \"3.10\"])\ndef typecheck(session):\n    session.install(\"pyright\", \".\")\n    session.run(\"pyright\")", "def typecheck(session):\n    session.install(\"pyright\", \".\")\n    session.run(\"pyright\")\n"]}
{"filename": "blurry/sitemap.py", "chunked_list": ["from pathlib import Path\n\nfrom blurry.settings import get_build_directory\nfrom blurry.types import MarkdownFileData\n\n\nSITEMAP_TEMPLATE = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.sitemaps.org/schemas/sitemap/0.9", "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.sitemaps.org/schemas/sitemap/0.9\n    http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd\"\n    xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n>\n{urls}\n</urlset>\n\"\"\".strip()\nURL_TEMPLATE = \"    <url><loc>{url}</loc><lastmod>{lastmod}</lastmod></url>\"\n", "URL_TEMPLATE = \"    <url><loc>{url}</loc><lastmod>{lastmod}</lastmod></url>\"\n\n\ndef generate_sitemap_for_file_data_list(file_data_list: list[MarkdownFileData]) -> str:\n    sitemap_url_data = []\n    for file_data in file_data_list:\n        lastmod = file_data.front_matter.get(\n            \"dateModified\"\n        ) or file_data.front_matter.get(\"datePublished\")\n        url = file_data.front_matter.get(\"url\")\n        sitemap_url_data.append({\"lastmod\": lastmod, \"url\": url})\n\n    sitemap_url_content = \"\\n\".join(\n        URL_TEMPLATE.format(url=data[\"url\"], lastmod=data[\"lastmod\"])\n        for data in sitemap_url_data\n    )\n    return SITEMAP_TEMPLATE.format(urls=sitemap_url_content)", "\n\nasync def write_sitemap_file(\n    file_data_by_directory: dict[Path, list[MarkdownFileData]]\n):\n    BUILD_DIR = get_build_directory()\n    file_data = []\n    for file_data_list in file_data_by_directory.values():\n        file_data.extend(file_data_list)\n", "\n    sitemap = generate_sitemap_for_file_data_list(file_data)\n    sitemap_path = BUILD_DIR / \"sitemap.xml\"\n    sitemap_path.write_text(sitemap)\n"]}
{"filename": "blurry/images.py", "chunked_list": ["import asyncio\nfrom pathlib import Path\nfrom typing import Coroutine\nfrom typing import Optional\n\nfrom wand.image import Image\n\nfrom blurry.settings import get_build_directory\nfrom blurry.settings import get_content_directory\nfrom blurry.settings import SETTINGS", "from blurry.settings import get_content_directory\nfrom blurry.settings import SETTINGS\n\nCONTENT_DIR = get_content_directory()\n\nAVIF_COMPRESSION_QUALITY = SETTINGS[\"AVIF_COMPRESSION_QUALITY\"]\nIMAGE_WIDTHS = SETTINGS[\"IMAGE_WIDTHS\"]\nMAXIMUM_IMAGE_WIDTH = int(SETTINGS[\"MAXIMUM_IMAGE_WIDTH\"])\nTHUMBNAIL_WIDTH = int(SETTINGS[\"THUMBNAIL_WIDTH\"])\n", "THUMBNAIL_WIDTH = int(SETTINGS[\"THUMBNAIL_WIDTH\"])\n\nTARGET_IMAGE_WIDTHS = [w for w in IMAGE_WIDTHS if w < MAXIMUM_IMAGE_WIDTH]\nTARGET_IMAGE_WIDTHS.append(MAXIMUM_IMAGE_WIDTH)\nif THUMBNAIL_WIDTH not in TARGET_IMAGE_WIDTHS:\n    TARGET_IMAGE_WIDTHS.append(THUMBNAIL_WIDTH)\n\nTARGET_IMAGE_WIDTHS.sort()\n\n\ndef add_image_width_to_path(image_path: Path, width: int) -> Path:\n    new_filename = str(image_path).replace(\n        image_path.suffix, f\"-{width}{image_path.suffix}\"\n    )\n    return Path(new_filename)", "\n\ndef add_image_width_to_path(image_path: Path, width: int) -> Path:\n    new_filename = str(image_path).replace(\n        image_path.suffix, f\"-{width}{image_path.suffix}\"\n    )\n    return Path(new_filename)\n\n\nasync def convert_image_to_avif(image_path: Path, target_path: Optional[Path] = None):", "\nasync def convert_image_to_avif(image_path: Path, target_path: Optional[Path] = None):\n    image_suffix = image_path.suffix\n    if image_suffix in [\".webp\", \".gif\"]:\n        return\n    avif_filepath = str(target_path or image_path).replace(image_suffix, \".avif\")\n    if Path(avif_filepath).exists():\n        return\n    with Image(filename=str(image_path)) as image:\n        image.format = \"avif\"\n        image.compression_quality = AVIF_COMPRESSION_QUALITY\n        image.save(filename=avif_filepath)", "    with Image(filename=str(image_path)) as image:\n        image.format = \"avif\"\n        image.compression_quality = AVIF_COMPRESSION_QUALITY\n        image.save(filename=avif_filepath)\n\n\nasync def generate_images_for_srcset(image_path: Path):\n    BUILD_DIR = get_build_directory()\n    tasks: list[Coroutine] = []\n    if image_path.suffix in [\".webp\", \".gif\"]:\n        return", "    tasks: list[Coroutine] = []\n    if image_path.suffix in [\".webp\", \".gif\"]:\n        return\n    with Image(filename=str(image_path)) as img:\n        width = img.width\n        # Convert original image\n        build_path = BUILD_DIR / image_path.resolve().relative_to(CONTENT_DIR)\n        await convert_image_to_avif(image_path=image_path, target_path=build_path)\n\n        for target_width in get_widths_for_image_width(width):\n            new_filepath = add_image_width_to_path(image_path, target_width)\n            relative_filepath = new_filepath.resolve().relative_to(CONTENT_DIR)\n            build_filepath = BUILD_DIR / relative_filepath\n            if build_filepath.exists():\n                continue\n            with img.clone() as resized:\n                resized.transform(resize=str(target_width))\n                resized.save(filename=build_filepath)\n                tasks.append(convert_image_to_avif(build_filepath))\n        await asyncio.gather(*tasks)", "\n\ndef get_widths_for_image_width(image_width: int) -> list[int]:\n    widths = [tw for tw in TARGET_IMAGE_WIDTHS if tw < image_width]\n    if image_width < TARGET_IMAGE_WIDTHS[-1]:\n        widths.append(image_width)\n    return widths\n\n\ndef generate_srcset_string(image_path: str, image_widths: list[int]) -> str:\n    srcset_entries = [\n        f\"{add_image_width_to_path(Path(image_path), w)} {w}w\" for w in image_widths\n    ]\n    return \", \".join(srcset_entries)", "\ndef generate_srcset_string(image_path: str, image_widths: list[int]) -> str:\n    srcset_entries = [\n        f\"{add_image_width_to_path(Path(image_path), w)} {w}w\" for w in image_widths\n    ]\n    return \", \".join(srcset_entries)\n\n\ndef generate_sizes_string(image_widths: list[int]) -> str:\n    if not image_widths:\n        return \"\"\n    # Ensure widths are in ascending order\n    image_widths.sort()\n    size_strings = []\n\n    for width in image_widths[0:-1]:\n        size_strings.append(f\"(max-width: {width}px) {width}px\")\n    largest_width = image_widths[-1]\n    size_strings.append(f\"{largest_width}px\")\n    return \", \".join(size_strings)", "def generate_sizes_string(image_widths: list[int]) -> str:\n    if not image_widths:\n        return \"\"\n    # Ensure widths are in ascending order\n    image_widths.sort()\n    size_strings = []\n\n    for width in image_widths[0:-1]:\n        size_strings.append(f\"(max-width: {width}px) {width}px\")\n    largest_width = image_widths[-1]\n    size_strings.append(f\"{largest_width}px\")\n    return \", \".join(size_strings)", ""]}
{"filename": "blurry/settings.py", "chunked_list": ["from os import environ\nfrom typing import TypedDict\n\nimport toml\n\nfrom blurry.constants import CURR_DIR\nfrom blurry.constants import ENV_VAR_PREFIX\n\n\nclass Settings(TypedDict):\n    AVIF_COMPRESSION_QUALITY: int\n    BUILD_DIRECTORY_NAME: str\n    CONTENT_DIRECTORY_NAME: str\n    TEMPLATES_DIRECTORY_NAME: str\n    TEMPLATE_SCHEMA_TYPES: dict[str, str]\n\n    DEV_HOST: str\n    DEV_PORT: int\n    DOMAIN: str\n    IMAGE_WIDTHS: list[int]\n    MAXIMUM_IMAGE_WIDTH: int\n    THUMBNAIL_WIDTH: int\n    VIDEO_EXTENSIONS: list[str]\n    USE_HTTP: bool\n    RUNSERVER: bool\n    FRONTMATTER_NON_SCHEMA_VARIABLE_PREFIX: str", "\nclass Settings(TypedDict):\n    AVIF_COMPRESSION_QUALITY: int\n    BUILD_DIRECTORY_NAME: str\n    CONTENT_DIRECTORY_NAME: str\n    TEMPLATES_DIRECTORY_NAME: str\n    TEMPLATE_SCHEMA_TYPES: dict[str, str]\n\n    DEV_HOST: str\n    DEV_PORT: int\n    DOMAIN: str\n    IMAGE_WIDTHS: list[int]\n    MAXIMUM_IMAGE_WIDTH: int\n    THUMBNAIL_WIDTH: int\n    VIDEO_EXTENSIONS: list[str]\n    USE_HTTP: bool\n    RUNSERVER: bool\n    FRONTMATTER_NON_SCHEMA_VARIABLE_PREFIX: str", "\n\nSETTINGS: Settings = {\n    \"AVIF_COMPRESSION_QUALITY\": 90,\n    \"BUILD_DIRECTORY_NAME\": \"dist\",\n    \"CONTENT_DIRECTORY_NAME\": \"content\",\n    \"TEMPLATES_DIRECTORY_NAME\": \"templates\",\n    \"DEV_HOST\": \"127.0.0.1\",\n    \"DEV_PORT\": 8000,\n    \"DOMAIN\": \"example.com\",", "    \"DEV_PORT\": 8000,\n    \"DOMAIN\": \"example.com\",\n    # Sizes adapted from: https://link.medium.com/UqzDeLKwyeb\n    \"IMAGE_WIDTHS\": [360, 640, 768, 1024, 1366, 1600, 1920],\n    \"MAXIMUM_IMAGE_WIDTH\": 1920,\n    \"THUMBNAIL_WIDTH\": 250,\n    \"VIDEO_EXTENSIONS\": [\"mp4\", \"webm\", \"mkv\"],\n    \"USE_HTTP\": False,\n    \"RUNSERVER\": False,\n    \"FRONTMATTER_NON_SCHEMA_VARIABLE_PREFIX\": \"~\",", "    \"RUNSERVER\": False,\n    \"FRONTMATTER_NON_SCHEMA_VARIABLE_PREFIX\": \"~\",\n    \"TEMPLATE_SCHEMA_TYPES\": {},\n}\n\ntry:\n    blurry_config = toml.load(open(\"blurry.toml\"))\n    user_settings = blurry_config[\"blurry\"]\n    for setting, value in user_settings.items():\n        SETTINGS[setting.upper()] = value\nexcept FileNotFoundError:\n    pass", "\n\nfor key, value in environ.items():\n    if not key.startswith(ENV_VAR_PREFIX):\n        continue\n    setting_name_start_index = len(ENV_VAR_PREFIX) - 1\n    settings_key = key[setting_name_start_index:]\n    SETTINGS[settings_key] = value\n\n\ndef get_build_directory():\n    is_dev_build = environ.get(f\"{ENV_VAR_PREFIX}BUILD_MODE\") == \"dev\"\n    if is_dev_build:\n        return CURR_DIR / \".blurry\" / SETTINGS[\"BUILD_DIRECTORY_NAME\"]\n    return CURR_DIR / SETTINGS[\"BUILD_DIRECTORY_NAME\"]", "\n\ndef get_build_directory():\n    is_dev_build = environ.get(f\"{ENV_VAR_PREFIX}BUILD_MODE\") == \"dev\"\n    if is_dev_build:\n        return CURR_DIR / \".blurry\" / SETTINGS[\"BUILD_DIRECTORY_NAME\"]\n    return CURR_DIR / SETTINGS[\"BUILD_DIRECTORY_NAME\"]\n\n\ndef get_content_directory():\n    return CURR_DIR / SETTINGS[\"CONTENT_DIRECTORY_NAME\"]", "\ndef get_content_directory():\n    return CURR_DIR / SETTINGS[\"CONTENT_DIRECTORY_NAME\"]\n\n\ndef get_templates_directory():\n    return CURR_DIR / SETTINGS[\"TEMPLATES_DIRECTORY_NAME\"]\n"]}
{"filename": "blurry/__main__.py", "chunked_list": ["from __future__ import absolute_import\n\nfrom blurry import main\n\nmain()\n"]}
{"filename": "blurry/types.py", "chunked_list": ["from dataclasses import dataclass\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import TypeGuard\n\n\n@dataclass\nclass MarkdownFileData:\n    body: str\n    front_matter: dict[str, Any]\n    path: Path", "class MarkdownFileData:\n    body: str\n    front_matter: dict[str, Any]\n    path: Path\n\n\nclass SchemaType(Enum):\n    ARTICLE = \"Article\"\n    BLOG_POSTING = \"BlogPosting\"\n    NEWS_ARTICLE = \"NewsArticle\"\n    TECH_ARTICLE = \"TechArticle\"\n    BOOK = \"Book\"\n    AUDIOBOOK = \"Audiobook\"\n    LOCAL_BUSINESS = \"LocalBusiness\"\n    NEWS_MEDIA_ORGANIZATION = \"NewsMediaOrganization\"\n    ORGANIZATION = \"Organization\"\n    PERSON = \"Person\"", "\n\nDirectoryFileData = dict[Path, list[MarkdownFileData]]\n\nTemplateContext = dict[str, Any]\n\n\ndef is_str(value: Any) -> TypeGuard[str]:\n    if isinstance(value, str):\n        return True\n    return False", ""]}
{"filename": "blurry/async_typer.py", "chunked_list": ["import asyncio\nfrom functools import wraps\n\nfrom typer import Typer\n\n\nclass AsyncTyper(Typer):\n    def async_command(self, *args, **kwargs):\n        def decorator(async_func):\n            # Convert async function to synchronous\n            @wraps(async_func)\n            def sync_func(*_args, **_kwargs):\n                return asyncio.run(async_func(*_args, **_kwargs))\n\n            # Register synchronous function\n            self.command(*args, **kwargs)(sync_func)\n\n            return async_func\n\n        return decorator", ""]}
{"filename": "blurry/__init__.py", "chunked_list": ["import asyncio\nimport dataclasses\nimport json\nimport os\nimport shutil\nfrom datetime import datetime\nfrom mimetypes import guess_type\nfrom mimetypes import types_map\nfrom pathlib import Path\nfrom typing import Any", "from pathlib import Path\nfrom typing import Any\nfrom typing import Coroutine\n\nfrom jinja2 import Environment\nfrom jinja2 import FileSystemLoader\nfrom jinja2 import select_autoescape\nfrom livereload import Server\nfrom rich import print\n", "from rich import print\n\nfrom blurry.async_typer import AsyncTyper\nfrom blurry.constants import ENV_VAR_PREFIX\nfrom blurry.images import generate_images_for_srcset\nfrom blurry.markdown import convert_markdown_file_to_html\nfrom blurry.open_graph import open_graph_meta_tags\nfrom blurry.plugins import discovered_html_plugins\nfrom blurry.plugins import discovered_markdown_plugins\nfrom blurry.settings import get_build_directory", "from blurry.plugins import discovered_markdown_plugins\nfrom blurry.settings import get_build_directory\nfrom blurry.settings import get_content_directory\nfrom blurry.settings import get_templates_directory\nfrom blurry.settings import SETTINGS\nfrom blurry.sitemap import write_sitemap_file\nfrom blurry.types import DirectoryFileData\nfrom blurry.types import MarkdownFileData\nfrom blurry.types import TemplateContext\nfrom blurry.utils import content_path_to_url", "from blurry.types import TemplateContext\nfrom blurry.utils import content_path_to_url\nfrom blurry.utils import convert_content_path_to_directory_in_build\nfrom blurry.utils import format_schema_data\nfrom blurry.utils import sort_directory_file_data_by_date\nfrom blurry.utils import write_index_file_creating_path\n\n\ndef json_converter_with_dates(item: Any) -> None | str:\n    if isinstance(item, datetime):\n        return item.strftime(\"%Y-%M-%D\")", "def json_converter_with_dates(item: Any) -> None | str:\n    if isinstance(item, datetime):\n        return item.strftime(\"%Y-%M-%D\")\n\n\nprint(\"Markdown plugins:\", [p.name for p in discovered_markdown_plugins])\nprint(\"HTML plugins:\", [p.name for p in discovered_html_plugins])\n\n\nCONTENT_DIR = get_content_directory()", "\nCONTENT_DIR = get_content_directory()\nTEMPLATE_DIR = get_templates_directory()\n\napp = AsyncTyper()\n\njinja_env = Environment(\n    loader=FileSystemLoader(TEMPLATE_DIR), autoescape=select_autoescape([\"html\", \"xml\"])\n)\n", ")\n\n\nasync def process_non_markdown_file(filepath: Path):\n    mimetype, _ = guess_type(filepath, strict=False)\n    relative_filepath = filepath.relative_to(CONTENT_DIR)\n    build_filepath = get_build_directory() / relative_filepath\n    output_file = Path(build_filepath)\n    output_file.parent.mkdir(exist_ok=True, parents=True)\n", "    output_file.parent.mkdir(exist_ok=True, parents=True)\n\n    # Copy file to build directory\n    shutil.copyfile(filepath, build_filepath)\n\n    # Create srcset images\n    if mimetype in [types_map[\".jpg\"], types_map[\".png\"]]:\n        await generate_images_for_srcset(filepath)\n\n", "\n\nasync def write_html_file(\n    file_data: MarkdownFileData,\n    file_data_list: list[MarkdownFileData],\n    file_data_by_directory: dict[Path, list[MarkdownFileData]],\n    release: bool,\n):\n    extra_context: TemplateContext = {}\n    # Gather data from other files in this directory if this is an index file\n    if file_data.path.name == \"index.md\":\n        sibling_pages = [\n            {\n                \"url\": content_path_to_url(f.path),\n                **f.front_matter,\n            }\n            for f in file_data_list\n            if f.path != file_data.path\n        ]\n        extra_context[\"sibling_pages\"] = sibling_pages", "    extra_context: TemplateContext = {}\n    # Gather data from other files in this directory if this is an index file\n    if file_data.path.name == \"index.md\":\n        sibling_pages = [\n            {\n                \"url\": content_path_to_url(f.path),\n                **f.front_matter,\n            }\n            for f in file_data_list\n            if f.path != file_data.path\n        ]\n        extra_context[\"sibling_pages\"] = sibling_pages", "    folder_in_build = convert_content_path_to_directory_in_build(file_data.path)\n\n    schema_type = file_data.front_matter.get(\"@type\")\n    if not schema_type:\n        raise ValueError(\n            f\"Required @type value missing in file or TOML front matter invalid: \"\n            f\"{file_data.path}\"\n        )\n    template = jinja_env.get_template(f\"{schema_type}.html\")\n", "    template = jinja_env.get_template(f\"{schema_type}.html\")\n\n    # Map custom template name to Schema.org type\n    if mapped_schema_type := SETTINGS[\"TEMPLATE_SCHEMA_TYPES\"].get(schema_type):\n        file_data.front_matter[\"@type\"] = mapped_schema_type\n\n    # Include non-schema variables as top-level context values, removing them from\n    # front_matter\n    front_matter = file_data.front_matter\n    schema_variables: TemplateContext = {}", "    front_matter = file_data.front_matter\n    schema_variables: TemplateContext = {}\n    template_context: TemplateContext = {}\n    non_schema_variable_prefix = SETTINGS[\"FRONTMATTER_NON_SCHEMA_VARIABLE_PREFIX\"]\n    for key, value in front_matter.items():\n        if key.startswith(non_schema_variable_prefix):\n            template_context[key.replace(non_schema_variable_prefix, \"\", 1)] = value\n            continue\n        schema_variables[key] = value\n", "\n    schema_data = json.dumps(\n        format_schema_data(schema_variables),\n        default=json_converter_with_dates,\n    )\n    schema_type_tag = f'<script type=\"application/ld+json\">{schema_data}</script>'\n\n    template_context = {\n        \"body\": file_data.body,\n        \"schema_data\": schema_data,", "        \"body\": file_data.body,\n        \"schema_data\": schema_data,\n        \"schema_type_tag\": schema_type_tag,\n        \"open_graph_tags\": open_graph_meta_tags(file_data.front_matter),\n        \"build_path\": folder_in_build,\n        \"file_data_by_directory\": {\n            str(path): data for path, data in file_data_by_directory.items()\n        },\n        \"settings\": SETTINGS,\n        **schema_variables,", "        \"settings\": SETTINGS,\n        **schema_variables,\n        **extra_context,\n        **template_context,\n    }\n\n    html = template.render(dataclasses=dataclasses, **template_context)\n    for html_plugin in discovered_html_plugins:\n        try:\n            html = html_plugin.load()(html, template_context, release)\n        except Exception as err:\n            print(f\"Error initializing plugin {html_plugin}: {err}\")", "\n    # Write file\n    write_index_file_creating_path(folder_in_build, html)\n\n\n@app.async_command()\nasync def build(release=True):\n    \"\"\"Generates HTML content from Markdown files.\"\"\"\n    os.environ.setdefault(f\"{ENV_VAR_PREFIX}BUILD_MODE\", \"prod\" if release else \"dev\")\n    build_dir = get_build_directory()", "    os.environ.setdefault(f\"{ENV_VAR_PREFIX}BUILD_MODE\", \"prod\" if release else \"dev\")\n    build_dir = get_build_directory()\n    start = datetime.now()\n    path = Path(CONTENT_DIR)\n    file_data_by_directory: DirectoryFileData = {}\n    if not build_dir.exists():\n        build_dir.mkdir(parents=True)\n\n    markdown_tasks: list[Coroutine] = []\n    non_markdown_tasks: list[Coroutine] = []", "    markdown_tasks: list[Coroutine] = []\n    non_markdown_tasks: list[Coroutine] = []\n\n    for filepath in path.glob(\"**/*.*\"):\n        # Handle images and other files\n        if filepath.suffix != \".md\":\n            non_markdown_tasks.append(process_non_markdown_file(filepath))\n            continue\n\n        # Handle Markdown files\n\n        # Extract filepath for storing context data and writing out\n        relative_filepath = filepath.relative_to(CONTENT_DIR)\n        directory = relative_filepath.parent\n        if directory not in file_data_by_directory:\n            file_data_by_directory[directory] = []\n\n        # Convert Markdown file to HTML\n        body, front_matter = convert_markdown_file_to_html(filepath)\n        file_data = MarkdownFileData(\n            body=body,\n            front_matter=front_matter,\n            path=relative_filepath,\n        )\n        file_data_by_directory[directory].append(file_data)", "\n    non_markdown_tasks.append(write_sitemap_file(file_data_by_directory))\n\n    # Sort file data by publishedDate/createdDate, descending, if present\n    file_data_by_directory = sort_directory_file_data_by_date(file_data_by_directory)\n\n    for file_data_list in file_data_by_directory.values():\n        for file_data in file_data_list:\n            markdown_tasks.append(\n                write_html_file(\n                    file_data, file_data_list, file_data_by_directory, release\n                )\n            )", "\n    task_count = len(markdown_tasks) + len(non_markdown_tasks)\n    print(f\"Gathered {task_count} tasks\")\n\n    await asyncio.gather(*markdown_tasks)\n    await asyncio.gather(*non_markdown_tasks)\n    end = datetime.now()\n\n    difference = end - start\n    print(f\"Built site in {difference.total_seconds()} seconds\")", "    difference = end - start\n    print(f\"Built site in {difference.total_seconds()} seconds\")\n\n\nasync def build_development():\n    await build(release=False)\n\n\n@app.command()\ndef runserver():\n    \"\"\"Starts HTTP server with live reloading.\"\"\"\n    os.environ.setdefault(f\"{ENV_VAR_PREFIX}BUILD_MODE\", \"dev\")\n\n    SETTINGS[\"RUNSERVER\"] = True\n\n    event_loop = asyncio.get_event_loop()\n    event_loop.create_task(build_development())\n\n    livereload_server = Server()\n    livereload_server.watch(\n        \"content/**/*\", lambda: event_loop.create_task(build_development())\n    )\n    livereload_server.watch(\n        \"templates/**/*\", lambda: event_loop.create_task(build_development())\n    )\n    livereload_server.serve(\n        host=SETTINGS[\"DEV_HOST\"], port=SETTINGS[\"DEV_PORT\"], root=get_build_directory()\n    )", "@app.command()\ndef runserver():\n    \"\"\"Starts HTTP server with live reloading.\"\"\"\n    os.environ.setdefault(f\"{ENV_VAR_PREFIX}BUILD_MODE\", \"dev\")\n\n    SETTINGS[\"RUNSERVER\"] = True\n\n    event_loop = asyncio.get_event_loop()\n    event_loop.create_task(build_development())\n\n    livereload_server = Server()\n    livereload_server.watch(\n        \"content/**/*\", lambda: event_loop.create_task(build_development())\n    )\n    livereload_server.watch(\n        \"templates/**/*\", lambda: event_loop.create_task(build_development())\n    )\n    livereload_server.serve(\n        host=SETTINGS[\"DEV_HOST\"], port=SETTINGS[\"DEV_PORT\"], root=get_build_directory()\n    )", "\n\ndef main():\n    app()\n"]}
{"filename": "blurry/utils.py", "chunked_list": ["from pathlib import Path\n\nfrom selectolax.parser import HTMLParser\n\nfrom blurry.settings import get_build_directory\nfrom blurry.settings import get_content_directory\nfrom blurry.settings import SETTINGS\nfrom blurry.types import DirectoryFileData\n\nCONTENT_DIR = get_content_directory()", "\nCONTENT_DIR = get_content_directory()\n\n\ndef get_domain_with_scheme():\n    if SETTINGS.get(\"RUNSERVER\"):\n        host = SETTINGS[\"DEV_HOST\"]\n        port = SETTINGS[\"DEV_PORT\"]\n        return f\"http://{host}:{port}\"\n    domain = SETTINGS[\"DOMAIN\"]\n    protocol = \"http\" if SETTINGS.get(\"USE_HTTP\") else \"https\"\n    return f\"{protocol}://{domain}\"", "\n\ndef convert_content_path_to_directory_in_build(path: Path) -> Path:\n    BUILD_DIR = get_build_directory()\n    if path.name == \"index.md\":\n        path = path.parent\n    else:\n        path = path.with_suffix(\"\")\n    return BUILD_DIR.joinpath(path)\n", "\n\ndef convert_relative_path_in_markdown_to_relative_build_path(relative_path: str) -> str:\n    if relative_path.startswith(\"./\"):\n        relative_path = relative_path[2:]\n    if relative_path.endswith(\"index.md\"):\n        relative_path = relative_path.replace(\"index.md\", \"\")\n    elif relative_path.endswith(\".md\"):\n        relative_path = relative_path.replace(\".md\", \"\") + \"/\"\n    return f\"../{relative_path}\"", "\n\ndef resolve_relative_path_in_markdown(relative_path: str, markdown_file: Path) -> Path:\n    \"\"\"Converts a relative path in Markdown to an absolute path.\"\"\"\n    parent = markdown_file.parent\n    path = parent / Path(relative_path)\n    return path.resolve()\n\n\ndef path_to_url_pathname(path: Path) -> str:\n    url_pathname = \"/\" + str(path.relative_to(CONTENT_DIR))\n    return url_pathname", "\ndef path_to_url_pathname(path: Path) -> str:\n    url_pathname = \"/\" + str(path.relative_to(CONTENT_DIR))\n    return url_pathname\n\n\ndef write_index_file_creating_path(directory_path: Path, content: str):\n    directory_path.mkdir(parents=True, exist_ok=True)\n    filepath = directory_path.joinpath(\"index.html\")\n    filepath.write_text(content)", "\n\ndef content_path_to_url(path: Path) -> str:\n    BUILD_DIR = get_build_directory()\n    if path.suffix == \".md\":\n        build_directory = convert_content_path_to_directory_in_build(path)\n        relative_directory = build_directory.relative_to(BUILD_DIR)\n        # Handle root page\n        if str(relative_directory) == \".\":\n            return f\"{get_domain_with_scheme()}/\"\n        return f\"{get_domain_with_scheme()}/{relative_directory}/\"\n\n    return f\"{get_domain_with_scheme()}{path_to_url_pathname(path)}\"", "\n\ndef build_path_to_url(path: Path) -> str:\n    BUILD_DIR = get_build_directory()\n    pathname = \"/\" + str(path.relative_to(BUILD_DIR))\n    return f\"{get_domain_with_scheme()}{pathname}\"\n\n\ndef sort_directory_file_data_by_date(\n    directory_file_data: DirectoryFileData,\n) -> DirectoryFileData:\n    for path, file_data in directory_file_data.items():\n        file_data.sort(\n            key=lambda page: str(page.front_matter.get(\"datePublished\", \"\"))\n            or str(page.front_matter.get(\"dateCreated\", \"\"))\n            or \"0000-00-00\",\n            reverse=True,\n        )\n        directory_file_data[path] = file_data\n\n    return directory_file_data", "def sort_directory_file_data_by_date(\n    directory_file_data: DirectoryFileData,\n) -> DirectoryFileData:\n    for path, file_data in directory_file_data.items():\n        file_data.sort(\n            key=lambda page: str(page.front_matter.get(\"datePublished\", \"\"))\n            or str(page.front_matter.get(\"dateCreated\", \"\"))\n            or \"0000-00-00\",\n            reverse=True,\n        )\n        directory_file_data[path] = file_data\n\n    return directory_file_data", "\n\ndef format_schema_data(schema_data: dict) -> dict:\n    formatted_schema_data = {\"@context\": \"https://schema.org\"}\n    formatted_schema_data.update(schema_data)\n    return formatted_schema_data\n\n\ndef remove_lazy_loading_from_first_image(html: str) -> str:\n    parser = HTMLParser(html, use_meta_tags=False)\n    first_img_tag = parser.css_first(\"img\")\n    if not first_img_tag:\n        return html\n    updated_tag = first_img_tag\n    del updated_tag.attrs[\"loading\"]  # type: ignore\n    first_img_tag.replace_with(HTMLParser(updated_tag.html).body.child)  # type: ignore\n    if not parser.body or not parser.body.html:\n        raise Exception(\"Could not parse HTML\")\n    return parser.body.html", "def remove_lazy_loading_from_first_image(html: str) -> str:\n    parser = HTMLParser(html, use_meta_tags=False)\n    first_img_tag = parser.css_first(\"img\")\n    if not first_img_tag:\n        return html\n    updated_tag = first_img_tag\n    del updated_tag.attrs[\"loading\"]  # type: ignore\n    first_img_tag.replace_with(HTMLParser(updated_tag.html).body.child)  # type: ignore\n    if not parser.body or not parser.body.html:\n        raise Exception(\"Could not parse HTML\")\n    return parser.body.html", ""]}
{"filename": "blurry/constants.py", "chunked_list": ["from pathlib import Path\n\nENV_VAR_PREFIX = \"BLURRY_\"\n\nCURR_DIR = Path.cwd()\n"]}
{"filename": "blurry/open_graph.py", "chunked_list": ["from typing import Any\nfrom typing import Literal\n\nfrom blurry.types import SchemaType\n\n\nMETA_TAG_TEMPLATE = '<meta property=\"og:{property}\" content=\"{content}\" />'\n\nOpenGraphType = Literal[\"article\", \"book\", \"profile\", \"website\"]\n", "OpenGraphType = Literal[\"article\", \"book\", \"profile\", \"website\"]\n\n\nschema_type_to_open_graph_type: dict[SchemaType, OpenGraphType] = {\n    SchemaType.ARTICLE: \"article\",\n    SchemaType.BLOG_POSTING: \"article\",\n    SchemaType.NEWS_ARTICLE: \"article\",\n    SchemaType.TECH_ARTICLE: \"article\",\n    SchemaType.BOOK: \"book\",\n    SchemaType.AUDIOBOOK: \"book\",", "    SchemaType.BOOK: \"book\",\n    SchemaType.AUDIOBOOK: \"book\",\n    SchemaType.LOCAL_BUSINESS: \"profile\",\n    SchemaType.NEWS_MEDIA_ORGANIZATION: \"profile\",\n    SchemaType.ORGANIZATION: \"profile\",\n    SchemaType.PERSON: \"profile\",\n}\n\n\ndef open_graph_type_from_schema_type(schema_type_str: str) -> OpenGraphType:\n    try:\n        return schema_type_to_open_graph_type[SchemaType(schema_type_str)]\n    except ValueError:\n        return \"website\"", "\ndef open_graph_type_from_schema_type(schema_type_str: str) -> OpenGraphType:\n    try:\n        return schema_type_to_open_graph_type[SchemaType(schema_type_str)]\n    except ValueError:\n        return \"website\"\n\n\ndef open_graph_meta_tags(schema_data: dict[str, Any]) -> str:\n    open_graph_properties = {}\n    if type := schema_data.get(\"@type\"):\n        open_graph_properties[\"type\"] = open_graph_type_from_schema_type(type)\n    if headline := schema_data.get(\"headline\"):\n        open_graph_properties[\"title\"] = headline\n    if url := schema_data.get(\"url\"):\n        open_graph_properties[\"url\"] = url\n    if abstract := schema_data.get(\"abstract\"):\n        open_graph_properties[\"description\"] = abstract\n    if image := schema_data.get(\"image\"):\n        open_graph_properties[\"image\"] = image\n    if audio := schema_data.get(\"audio\"):\n        open_graph_properties[\"audio\"] = audio\n    if organization := schema_data.get(\"sourceOrganization\"):\n        if site_name := organization.get(\"name\"):\n            open_graph_properties[\"site_name\"] = site_name\n    if video := schema_data.get(\"video\"):\n        open_graph_properties[\"video\"] = video\n    return \"\\n\".join(\n        META_TAG_TEMPLATE.format(property=property, content=content)\n        for property, content in open_graph_properties.items()\n    )", "def open_graph_meta_tags(schema_data: dict[str, Any]) -> str:\n    open_graph_properties = {}\n    if type := schema_data.get(\"@type\"):\n        open_graph_properties[\"type\"] = open_graph_type_from_schema_type(type)\n    if headline := schema_data.get(\"headline\"):\n        open_graph_properties[\"title\"] = headline\n    if url := schema_data.get(\"url\"):\n        open_graph_properties[\"url\"] = url\n    if abstract := schema_data.get(\"abstract\"):\n        open_graph_properties[\"description\"] = abstract\n    if image := schema_data.get(\"image\"):\n        open_graph_properties[\"image\"] = image\n    if audio := schema_data.get(\"audio\"):\n        open_graph_properties[\"audio\"] = audio\n    if organization := schema_data.get(\"sourceOrganization\"):\n        if site_name := organization.get(\"name\"):\n            open_graph_properties[\"site_name\"] = site_name\n    if video := schema_data.get(\"video\"):\n        open_graph_properties[\"video\"] = video\n    return \"\\n\".join(\n        META_TAG_TEMPLATE.format(property=property, content=content)\n        for property, content in open_graph_properties.items()\n    )", ""]}
{"filename": "blurry/plugins/__init__.py", "chunked_list": ["from importlib.metadata import entry_points\n\ndiscovered_markdown_plugins = entry_points(group=\"blurry.markdown_plugins\")\ndiscovered_html_plugins = entry_points(group=\"blurry.html_plugins\")\n"]}
{"filename": "blurry/plugins/html_plugins/minify_html_plugin.py", "chunked_list": ["import re\n\nimport htmlmin\nfrom selectolax.parser import HTMLParser\n\nfrom blurry.types import TemplateContext\n\n\ndef minify_css(css: str) -> str:\n    minified_css = css.strip()\n    characters_around_which_to_remove_whitespace = [\"}\", \"{\", \":\", \";\", \",\"]\n    for character in characters_around_which_to_remove_whitespace:\n        minified_css = re.sub(\n            rf\"\\s*{character}\\s*\", character, minified_css, flags=re.M\n        )\n\n    return minified_css", "def minify_css(css: str) -> str:\n    minified_css = css.strip()\n    characters_around_which_to_remove_whitespace = [\"}\", \"{\", \":\", \";\", \",\"]\n    for character in characters_around_which_to_remove_whitespace:\n        minified_css = re.sub(\n            rf\"\\s*{character}\\s*\", character, minified_css, flags=re.M\n        )\n\n    return minified_css\n", "\n\ndef minify_style_tags(html: str) -> str:\n    parser = HTMLParser(html, use_meta_tags=False)\n    style_tags = parser.css(\"style\")\n    for style_tag in style_tags:\n        css = style_tag.text()\n        minified_css = minify_css(css)\n        minified_style_tag = HTMLParser(\n            f\"<style>{minified_css}</style>\"\n        ).head.child  # type: ignore\n        style_tag.replace_with(minified_style_tag)  # type: ignore\n\n    return parser.html or html", "\n\ndef minify_html(html: str, _: TemplateContext, release: bool) -> str:\n    if release:\n        # Minify HTML and CSS\n        html = htmlmin.minify(html, remove_empty_space=True)\n        html = minify_style_tags(html)\n    return html\n", ""]}
{"filename": "blurry/plugins/html_plugins/__init__.py", "chunked_list": [""]}
{"filename": "blurry/plugins/markdown_plugins/python_code_plugin.py", "chunked_list": ["import importlib\nimport inspect\nimport re\n\nfrom mistune import BlockParser\nfrom mistune import BlockState\nfrom mistune import Markdown\n\nPYTHON_CODE_PATTERN = r\"[\\s]*@(?P<language>[a-z]+)<(?P<path>.+)>\"\n", "PYTHON_CODE_PATTERN = r\"[\\s]*@(?P<language>[a-z]+)<(?P<path>.+)>\"\n\n\ndef parse_python_code(_: BlockParser, match: re.Match, state: BlockState):\n    language = match.group(\"language\")\n    path = match.group(\"path\")\n    state.append_token(\n        {\n            \"type\": \"python_code\",\n            \"attrs\": {\"language\": language, \"path\": path},\n        }\n    )\n    return match.end() + 1", "\n\ndef render_python_code(_, language: str, path: str):\n    module, _, reference_name = path.rpartition(\".\")\n    module = importlib.import_module(module)\n    try:\n        # If path references a variable within a module\n        reference = getattr(module, reference_name)\n    except AttributeError:\n        # If path references a module\n        reference = importlib.import_module(path)\n    reference_source = inspect.getsource(reference)\n\n    return f'<pre><code class=\"language-{language}\">{reference_source}</code></pre>'", "\n\ndef python_code(md: Markdown):\n    \"\"\"A mistune plugin to insert Python code.\"\"\"\n    md.block.register(\n        \"python_code\", PYTHON_CODE_PATTERN, parse_python_code, before=\"list\"\n    )\n    if md.renderer and md.renderer.NAME == \"html\":\n        md.renderer.register(\"python_code\", render_python_code)\n", "\n\ndef python_code_in_list(md: Markdown):\n    \"\"\"Enable Python code plugin in list.\"\"\"\n    md.block.insert_rule(md.block.list_rules, \"python_code\", before=\"list\")\n"]}
{"filename": "blurry/plugins/markdown_plugins/container_plugin.py", "chunked_list": ["from mistune.directives import Admonition\nfrom mistune.directives import FencedDirective\nfrom mistune.directives.admonition import render_admonition_content\n\n\nclass Container(Admonition):\n    \"\"\"Custom admonition directive using an <aside> HTML element\"\"\"\n\n    SUPPORTED_NAMES = {\n        \"attention\",\n        \"caution\",\n        \"danger\",\n        \"error\",\n        \"hint\",\n        \"important\",\n        \"info\",\n        \"note\",\n        \"tip\",\n        \"warning\",\n    }\n\n    def __call__(self, directive, md):\n        for name in self.SUPPORTED_NAMES:\n            directive.register(name, self.parse)\n\n        if md.renderer.NAME == \"html\":\n            md.renderer.register(\"admonition\", render_admonition)\n            md.renderer.register(\"admonition_title\", lambda plugin, text: \"\")\n            md.renderer.register(\"admonition_content\", render_admonition_content)", "\n\ndef render_admonition(self, text, name, **attrs):\n    _cls = attrs.get(\"class\", \"\")\n    class_attribute = f\"{name} {_cls}\".strip()\n    return f'<aside role=\"note\" class=\"{class_attribute}\">{text}</aside>'\n\n\ncontainer = FencedDirective([Container()], \":\")\n", "container = FencedDirective([Container()], \":\")\n"]}
{"filename": "blurry/plugins/markdown_plugins/__init__.py", "chunked_list": [""]}
{"filename": "blurry/plugins/markdown_plugins/punctuation_plugin.py", "chunked_list": ["from re import Match\n\nfrom mistune import InlineParser\nfrom mistune import InlineState\nfrom mistune import Markdown\n\nEM_DASH_PATTERN = r\"---\"\nEN_DASH_PATTERN = r\"--\"\n\n\ndef parse_em_dash(_: InlineParser, match: Match, state: InlineState):\n    pos = match.end()\n    state.append_token({\"type\": \"text\", \"raw\": \"\u2014\"})\n    return pos", "\n\ndef parse_em_dash(_: InlineParser, match: Match, state: InlineState):\n    pos = match.end()\n    state.append_token({\"type\": \"text\", \"raw\": \"\u2014\"})\n    return pos\n\n\ndef parse_en_dash(_: InlineParser, match: Match, state: InlineState):\n    pos = match.end()\n    state.append_token({\"type\": \"text\", \"raw\": \"\u2013\"})\n    return pos", "def parse_en_dash(_: InlineParser, match: Match, state: InlineState):\n    pos = match.end()\n    state.append_token({\"type\": \"text\", \"raw\": \"\u2013\"})\n    return pos\n\n\ndef punctuation(md: Markdown):\n    md.inline.register(\"punctuation_em_dash\", EM_DASH_PATTERN, parse_em_dash)\n    md.inline.register(\"punctuation_en_dash\", EN_DASH_PATTERN, parse_en_dash)\n", ""]}
{"filename": "blurry/markdown/__init__.py", "chunked_list": ["from pathlib import Path\nfrom typing import Any\nfrom typing import Type\nfrom typing import TypeGuard\n\nimport mistune\nfrom mistune import BlockState\nfrom mistune.plugins.abbr import abbr\nfrom mistune.plugins.def_list import def_list\nfrom mistune.plugins.footnotes import footnotes", "from mistune.plugins.def_list import def_list\nfrom mistune.plugins.footnotes import footnotes\nfrom mistune.plugins.formatting import strikethrough\nfrom mistune.plugins.table import table\nfrom mistune.plugins.task_lists import task_lists\nfrom mistune.plugins.url import url\nfrom mistune.util import escape\nfrom wand.image import Image\n\nfrom .front_matter import parse_front_matter", "\nfrom .front_matter import parse_front_matter\nfrom .renderer_functions.render_video import render_video\nfrom blurry.images import add_image_width_to_path\nfrom blurry.images import generate_sizes_string\nfrom blurry.images import generate_srcset_string\nfrom blurry.images import get_widths_for_image_width\nfrom blurry.plugins import discovered_markdown_plugins\nfrom blurry.settings import get_build_directory\nfrom blurry.settings import get_content_directory", "from blurry.settings import get_build_directory\nfrom blurry.settings import get_content_directory\nfrom blurry.settings import SETTINGS\nfrom blurry.types import is_str\nfrom blurry.utils import build_path_to_url\nfrom blurry.utils import content_path_to_url\nfrom blurry.utils import convert_relative_path_in_markdown_to_relative_build_path\nfrom blurry.utils import path_to_url_pathname\nfrom blurry.utils import remove_lazy_loading_from_first_image\nfrom blurry.utils import resolve_relative_path_in_markdown", "from blurry.utils import remove_lazy_loading_from_first_image\nfrom blurry.utils import resolve_relative_path_in_markdown\n\nCONTENT_DIR = get_content_directory()\nTHUMBNAIL_WIDTH = SETTINGS.get(\"THUMBNAIL_WIDTH\")\n\n\nclass BlurryRenderer(mistune.HTMLRenderer):\n    \"\"\"Renderer that converts relative content URLs to build URLs.\"\"\"\n\n    filepath: Path\n\n    def image(self, alt, url, title=None) -> str:\n        # Improve images:\n        # - Converts relative paths to web server paths\n        # - Convert to <picture> tag with AVIF <source>\n        # - Adds srcset & sizes attributes\n        # - Adds width & height attributes\n        src = self.safe_url(url)\n\n        attributes: dict[str, str] = {\n            \"alt\": alt,\n            \"src\": src,\n            \"loading\": \"lazy\",\n        }\n        source_tag = \"\"\n\n        # Make local images responsive\n        if src.startswith(\".\"):\n            # Convert relative path to URL pathname\n            absolute_path = resolve_relative_path_in_markdown(src, self.filepath)\n            extension = absolute_path.suffix.removeprefix(\".\")\n            src = path_to_url_pathname(absolute_path)\n            attributes[\"src\"] = src\n\n            if extension.lower() in SETTINGS.get(\"VIDEO_EXTENSIONS\"):\n                return render_video(src, absolute_path, extension, title=alt)\n\n            # Tailor srcset and sizes to image width\n            with Image(filename=str(absolute_path)) as img:\n                image_width = img.width\n                attributes[\"width\"] = image_width\n                attributes[\"height\"] = img.height\n\n            if extension in [\"webp\", \"gif\"]:\n                source_tag = \"\"\n            else:\n                image_widths = get_widths_for_image_width(image_width)\n\n                attributes[\"sizes\"] = generate_sizes_string(image_widths)\n                attributes[\"srcset\"] = generate_srcset_string(src, image_widths)\n                avif_srcset = generate_srcset_string(\n                    src.replace(extension, \"avif\"), image_widths\n                )\n                source_tag = '<source srcset=\"{}\" sizes=\"{}\" />'.format(\n                    avif_srcset, attributes[\"sizes\"]\n                )\n\n        attributes_str = \" \".join(\n            f'{name}=\"{value}\"' for name, value in attributes.items()\n        )\n\n        return (\n            f\"<figure>\"\n            f\"<picture>{source_tag}<img {attributes_str} /></picture>\"\n            f'<figcaption>{attributes[\"alt\"]}</figcaption>'\n            f\"</figure>\"\n        )\n\n    def link(self, text, url, title: str | None = None) -> str:\n        link_is_relative = url.startswith(\".\")\n        if link_is_relative:\n            url = convert_relative_path_in_markdown_to_relative_build_path(url)\n\n        if text is None:\n            text = url\n        attrs = {\n            \"href\": self.safe_url(url),\n        }\n        if title:\n            attrs[\"title\"] = escape(title)\n        if not link_is_relative:\n            attrs[\"target\"] = \"_blank\"\n            attrs[\"rel\"] = \"noopener\"\n\n        attrs_string = \" \".join(\n            f'{attribute}=\"{value}\"' for attribute, value in attrs.items()\n        )\n\n        return f\"<a {attrs_string}>{text}</a>\"", "\n\ndef is_blurry_renderer(\n    renderer: mistune.HTMLRenderer,\n) -> TypeGuard[Type[BlurryRenderer]]:\n    return isinstance(renderer, BlurryRenderer)\n\n\nrenderer = BlurryRenderer(escape=False)\nmarkdown = mistune.Markdown(", "renderer = BlurryRenderer(escape=False)\nmarkdown = mistune.Markdown(\n    renderer,\n    plugins=[\n        abbr,\n        def_list,\n        footnotes,\n        strikethrough,\n        table,\n        task_lists,", "        table,\n        task_lists,\n        url,\n    ]\n    + [plugin.load() for plugin in discovered_markdown_plugins],\n)\n\n\ndef convert_markdown_file_to_html(filepath: Path) -> tuple[str, dict[str, Any]]:\n    if not markdown.renderer:\n        raise Exception(\"Blurry markdown renderer not set on Mistune Markdown instance\")\n\n    BUILD_DIR = get_build_directory()\n    # Add filepath to the renderer to resolve relative paths\n    if not is_blurry_renderer(markdown.renderer):\n        raise Exception(\n            f\"Markdown renderer is not BlurryRenderer {repr(markdown.renderer)}\"\n        )\n    markdown.renderer.filepath = filepath\n    initial_state = BlockState()\n    initial_state.env[\"__file__\"] = str(filepath)  # type: ignore\n    markdown_text, state = parse_front_matter(markdown, state=initial_state)\n    html, state = markdown.parse(markdown_text, state=state)\n\n    if not is_str(html):\n        raise Exception(f\"Expected html to be a string but got: {type(html)}\")\n\n    # Post-process HTML\n    html = remove_lazy_loading_from_first_image(html)\n\n    # Seed front_matter with schema_data from config file\n    front_matter: dict[str, Any] = dict(SETTINGS.get(\"SCHEMA_DATA\", {}))\n    front_matter.update(state.env.get(\"front_matter\", {}))\n\n    # Add inferred/computed/relative values\n    front_matter.update({\"url\": content_path_to_url(filepath.relative_to(CONTENT_DIR))})\n    if image := front_matter.get(\"image\"):\n        image_path = filepath.parent / Path(image)\n        front_matter[\"image\"] = content_path_to_url(image_path)\n        # Add thumbnail URL, using the full image if the thumbnail doesn't exist\n        thumbnail_image_path = add_image_width_to_path(image_path, THUMBNAIL_WIDTH)\n        thumbnail_image_build_path = BUILD_DIR / thumbnail_image_path.relative_to(\n            CONTENT_DIR\n        )\n        if thumbnail_image_build_path.exists():\n            front_matter[\"thumbnailUrl\"] = build_path_to_url(thumbnail_image_build_path)\n        else:\n            front_matter[\"thumbnailUrl\"] = front_matter[\"image\"]\n    return html, front_matter", "def convert_markdown_file_to_html(filepath: Path) -> tuple[str, dict[str, Any]]:\n    if not markdown.renderer:\n        raise Exception(\"Blurry markdown renderer not set on Mistune Markdown instance\")\n\n    BUILD_DIR = get_build_directory()\n    # Add filepath to the renderer to resolve relative paths\n    if not is_blurry_renderer(markdown.renderer):\n        raise Exception(\n            f\"Markdown renderer is not BlurryRenderer {repr(markdown.renderer)}\"\n        )\n    markdown.renderer.filepath = filepath\n    initial_state = BlockState()\n    initial_state.env[\"__file__\"] = str(filepath)  # type: ignore\n    markdown_text, state = parse_front_matter(markdown, state=initial_state)\n    html, state = markdown.parse(markdown_text, state=state)\n\n    if not is_str(html):\n        raise Exception(f\"Expected html to be a string but got: {type(html)}\")\n\n    # Post-process HTML\n    html = remove_lazy_loading_from_first_image(html)\n\n    # Seed front_matter with schema_data from config file\n    front_matter: dict[str, Any] = dict(SETTINGS.get(\"SCHEMA_DATA\", {}))\n    front_matter.update(state.env.get(\"front_matter\", {}))\n\n    # Add inferred/computed/relative values\n    front_matter.update({\"url\": content_path_to_url(filepath.relative_to(CONTENT_DIR))})\n    if image := front_matter.get(\"image\"):\n        image_path = filepath.parent / Path(image)\n        front_matter[\"image\"] = content_path_to_url(image_path)\n        # Add thumbnail URL, using the full image if the thumbnail doesn't exist\n        thumbnail_image_path = add_image_width_to_path(image_path, THUMBNAIL_WIDTH)\n        thumbnail_image_build_path = BUILD_DIR / thumbnail_image_path.relative_to(\n            CONTENT_DIR\n        )\n        if thumbnail_image_build_path.exists():\n            front_matter[\"thumbnailUrl\"] = build_path_to_url(thumbnail_image_build_path)\n        else:\n            front_matter[\"thumbnailUrl\"] = front_matter[\"image\"]\n    return html, front_matter", ""]}
{"filename": "blurry/markdown/front_matter.py", "chunked_list": ["import re\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import MutableMapping\nfrom typing import TypeGuard\n\nimport toml\nfrom mistune import BlockState\nfrom mistune import Markdown\n", "from mistune import Markdown\n\nTOML_BLOCK_RE = re.compile(\n    r\"^\\+{3}[ \\t]*\\n(.*?\\n)(?:\\.{3}|\\+{3})[ \\t]*\\n\", re.UNICODE | re.DOTALL\n)\n\n\ndef is_mapping_with_str_keys(\n    val: MutableMapping,\n) -> TypeGuard[MutableMapping[str, Any]]:\n    return all(isinstance(x, str) for x in val)", "\n\ndef get_data(doc: str) -> tuple[str, MutableMapping]:\n    \"\"\"\n    Extract frontmatter from Markdown-style text.\n    Code adapted from docdata.yamldata:\n    https://github.com/waylan/docdata/blob/master/docdata/yamldata.py\n    \"\"\"\n    data: MutableMapping[str, Any] = {}\n    toml_block_match = TOML_BLOCK_RE.match(doc)\n    if toml_block_match:\n        try:\n            data = toml.loads(toml_block_match.group(1))\n            if not is_mapping_with_str_keys(data):\n                raise TypeError(\"data is the wrong type\")\n\n            if isinstance(data, dict):\n                doc = doc[toml_block_match.end() :].lstrip(\"\\n\")  # noqa: E203\n            else:\n                data: MutableMapping[str, Any] = {}\n        except Exception:\n            pass\n    return doc, data", "\n\ndef parse_front_matter(_: Markdown, state: BlockState) -> tuple[str, BlockState]:\n    filepath = state.env.get(\"__file__\")\n    if not isinstance(filepath, str):\n        raise Exception(f\"Count not find filepath {filepath}\")\n    file_contents = Path(filepath).read_text()\n    markdown_text, front_matter = get_data(file_contents)\n    state.env[\"front_matter\"] = front_matter  # type: ignore\n    return markdown_text, state", ""]}
{"filename": "blurry/markdown/renderer_functions/__init__.py", "chunked_list": [""]}
{"filename": "blurry/markdown/renderer_functions/render_video.py", "chunked_list": ["from pathlib import Path\n\nimport ffmpeg\nfrom mistune.util import escape\n\n\ndef render_video(src: str, absolute_path: Path, extension: str, title: str | None):\n    video_probe_output = ffmpeg.probe(absolute_path)\n    video_info = video_probe_output[\"streams\"][0]\n    video_width = video_info[\"width\"]\n    video_height = video_info[\"height\"]\n\n    video_attributes = {\n        \"height\": video_height,\n        \"width\": video_width,\n    }\n    if title:\n        video_attributes[\"title\"] = escape(title)\n\n    video_attributes_str = \" \".join(\n        f'{name}=\"{value}\"' for name, value in video_attributes.items()\n    )\n\n    mimetype = f\"video/{extension}\"\n    return (\n        f\"<video {video_attributes_str} controls>\"\n        f'<source src=\"{src}\" type=\"{mimetype}\"></source></video>'\n    )", ""]}
{"filename": "tests/test_minify_html_plugin.py", "chunked_list": ["from blurry.plugins.html_plugins.minify_html_plugin import minify_css\nfrom blurry.plugins.html_plugins.minify_html_plugin import minify_style_tags\n\n\ndef test_minify_css():\n    css = \"\"\"\nbody {\n  color: pink;\n}\ndocument {\n  background: blue;\n}\npre,\ncode {\n  font-family: monospace;\n  font-size: 0.9rem;\n}\n\"\"\".strip()\n    minified_css = minify_css(css)\n    assert minified_css == (\n        \"body{color:pink;}document{background:blue;}\"\n        \"pre,code{font-family:monospace;font-size:0.9rem;}\"\n    )", "\n\ndef test_minify_style_tags():\n    html = \"\"\"\n<html>\n<head>\n  <style>\n  body {\n    color: pink;\n  }\n  </style>\n</head>\n<body>\n  <style>\n  document {\n    background: blue;\n  }\n  </style>\n</body>\n</html>\n\"\"\".strip()\n    html_with_minified_style_tags = minify_style_tags(html)\n    assert (\n        html_with_minified_style_tags\n        == \"\"\"\n<html><head>\n  <style>body{color:pink;}</style>\n</head>\n<body>\n  <style>document{background:blue;}</style>\n\n</body></html>\n\"\"\".strip()\n    )", ""]}
{"filename": "tests/test_python_code_plugin.py", "chunked_list": ["from blurry.plugins.markdown_plugins.python_code_plugin import render_python_code\n\n\ndef test_render_python_code_within_module():\n    language = \"python\"\n    path = \"blurry.types.MarkdownFileData\"\n\n    fenced_code_block = render_python_code(None, language, path)\n    assert \"body: str\" in fenced_code_block\n    assert \"SchemaType\" not in fenced_code_block", "\n\ndef test_render_module_code():\n    language = \"python\"\n    path = \"blurry.plugins.html_plugins.minify_html_plugin\"\n\n    code = render_python_code(None, language, path)\n    assert \"import htmlmin\" in code\n    assert \"return html\" in code\n", ""]}
{"filename": "tests/test_images.py", "chunked_list": ["import pytest\n\nfrom blurry.images import generate_sizes_string\nfrom blurry.images import generate_srcset_string\nfrom blurry.images import get_widths_for_image_width\n\n\n@pytest.mark.parametrize(\n    \"image_path, image_widths, expected_output\",\n    [", "    \"image_path, image_widths, expected_output\",\n    [\n        (\n            \"dummy_image.png\",\n            [100, 200, 800],\n            (\n                \"dummy_image-100.png 100w, dummy_image-200.png 200w, \"\n                \"dummy_image-800.png 800w\"\n            ),\n        ),", "            ),\n        ),\n        (\n            \"dummy_image.avif\",\n            [240, 800],\n            \"dummy_image-240.avif 240w, dummy_image-800.avif 800w\",\n        ),\n    ],\n)\ndef test_generate_srcset_string(\n    image_path: str, image_widths: list[int], expected_output: str\n):\n    srcset_string = generate_srcset_string(image_path, image_widths)\n    assert srcset_string == expected_output", ")\ndef test_generate_srcset_string(\n    image_path: str, image_widths: list[int], expected_output: str\n):\n    srcset_string = generate_srcset_string(image_path, image_widths)\n    assert srcset_string == expected_output\n\n\n@pytest.mark.parametrize(\n    \"image_widths, expected_output\",", "@pytest.mark.parametrize(\n    \"image_widths, expected_output\",\n    [\n        (\n            [100, 200, 800],\n            \"(max-width: 100px) 100px, (max-width: 200px) 200px, 800px\",\n        ),\n        (\n            [200, 400],\n            \"(max-width: 200px) 200px, 400px\",", "            [200, 400],\n            \"(max-width: 200px) 200px, 400px\",\n        ),\n        ([240], \"240px\"),\n    ],\n)\ndef test_generate_sizes_string(image_widths: list[int], expected_output: str):\n    sizes_string = generate_sizes_string(image_widths)\n    assert sizes_string == expected_output\n", "\n\n@pytest.mark.parametrize(\n    \"image_width, expected_output\",\n    [\n        (900, [250, 360, 640, 768, 900]),\n        (700, [250, 360, 640, 700]),\n        (768, [250, 360, 640, 768]),\n        (249, [249]),\n    ],", "        (249, [249]),\n    ],\n)\ndef test_get_widths_for_image_width(image_width: int, expected_output: list[int]):\n    image_widths = get_widths_for_image_width(image_width)\n    assert image_widths == expected_output\n"]}
{"filename": "tests/test_front_matter.py", "chunked_list": ["from blurry.markdown.front_matter import get_data\n\nMARKDOWN_WITH_BASIC_TOML_FRONT_MATTER = \"\"\"\n+++\n\"@type\" = \"WebPage\"\nname = \"Introduction\"\nabstract = \"A Python-powered static site generator with a focus on page speed and SEO.\"\ndatePublished = 2023-04-09\n+++\n", "+++\n\n# Blurry: A Python-powered static site generator\n\n## What is Blurry?\n\nBlurry is a static site generator with a terrible pun of a name...\n\"\"\".strip()\n\n\ndef test_get_data():\n    doc, data = get_data(MARKDOWN_WITH_BASIC_TOML_FRONT_MATTER)\n    assert doc.startswith(\"# Blurry: \")\n    assert len(data) == 4\n    assert data.get(\"@type\") == \"WebPage\"", "\n\ndef test_get_data():\n    doc, data = get_data(MARKDOWN_WITH_BASIC_TOML_FRONT_MATTER)\n    assert doc.startswith(\"# Blurry: \")\n    assert len(data) == 4\n    assert data.get(\"@type\") == \"WebPage\"\n"]}
{"filename": "tests/test_sitemap.py", "chunked_list": ["from datetime import date\nfrom pathlib import Path\n\nfrom blurry.sitemap import generate_sitemap_for_file_data_list\nfrom blurry.types import MarkdownFileData\n\nblog_path = Path(\"blog\")\ndirectory_file_data = [\n    MarkdownFileData(\n        front_matter=dict(datePublished=date(2021, 1, 1), url=\"/blog/a-post-1/\"),", "    MarkdownFileData(\n        front_matter=dict(datePublished=date(2021, 1, 1), url=\"/blog/a-post-1/\"),\n        body=\"\",\n        path=blog_path / \"a-post-1\",\n    ),\n    MarkdownFileData(\n        front_matter=dict(datePublished=date(2021, 3, 1), url=\"/blog/b-post-3/\"),\n        body=\"\",\n        path=blog_path / \"b-post-3\",\n    ),", "        path=blog_path / \"b-post-3\",\n    ),\n    MarkdownFileData(\n        front_matter=dict(dateCreated=date(2021, 2, 1), url=\"/blog/c-post-2/\"),\n        body=\"\",\n        path=blog_path / \"c-post-2\",\n    ),\n    MarkdownFileData(\n        front_matter=dict(\n            dateCreated=date(2022, 1, 10),", "        front_matter=dict(\n            dateCreated=date(2022, 1, 10),\n            dateModified=date(2022, 1, 13),\n            url=\"/blog/c-post-4/\",\n        ),\n        body=\"\",\n        path=blog_path / \"c-post-4\",\n    ),\n]\n", "]\n\n\ndef test_generate_sitemap_for_file_data_list():\n    sitemap_content = generate_sitemap_for_file_data_list(\n        file_data_list=directory_file_data\n    )\n    assert sitemap_content.startswith('<?xml version=\"1.0\" encoding=\"UTF-8\"?>')\n    assert sitemap_content.endswith(\"</urlset>\")\n    assert (\n        \"<url><loc>/blog/c-post-4/</loc><lastmod>2022-01-13</lastmod></url>\"\n        in sitemap_content\n    )", ""]}
{"filename": "tests/test_open_graph.py", "chunked_list": ["import pytest\n\nfrom blurry.open_graph import open_graph_meta_tags\nfrom blurry.open_graph import open_graph_type_from_schema_type\nfrom blurry.types import SchemaType\n\n\n@pytest.mark.parametrize(\n    \"schema_type, open_graph_type\",\n    [", "    \"schema_type, open_graph_type\",\n    [\n        (SchemaType.BLOG_POSTING, \"article\"),\n        (SchemaType.NEWS_ARTICLE, \"article\"),\n        (\"banana\", \"website\"),\n    ],\n)\ndef test_open_graph_type_from_schema_type(schema_type, open_graph_type):\n    assert open_graph_type_from_schema_type(schema_type) == open_graph_type\n", "\n\nschema_data = {\"@type\": \"BlogPosting\", \"url\": \"/blog/article-one/\", \"image\": \"/hey.png\"}\nmeta_tag_content = \"\"\"\n<meta property=\"og:type\" content=\"article\" />\n<meta property=\"og:url\" content=\"/blog/article-one/\" />\n<meta property=\"og:image\" content=\"/hey.png\" />\n\"\"\".strip()\n\n\ndef test_open_graph_meta_tags():\n    assert open_graph_meta_tags(schema_data) == meta_tag_content", "\n\ndef test_open_graph_meta_tags():\n    assert open_graph_meta_tags(schema_data) == meta_tag_content\n"]}
{"filename": "tests/test_utils.py", "chunked_list": ["from datetime import date\nfrom pathlib import Path\nfrom unittest import mock\n\nimport pytest\nfrom selectolax.parser import HTMLParser\n\nfrom blurry.settings import get_build_directory\nfrom blurry.settings import get_content_directory\nfrom blurry.settings import SETTINGS", "from blurry.settings import get_content_directory\nfrom blurry.settings import SETTINGS\nfrom blurry.types import MarkdownFileData\nfrom blurry.utils import content_path_to_url\nfrom blurry.utils import convert_content_path_to_directory_in_build\nfrom blurry.utils import convert_relative_path_in_markdown_to_relative_build_path\nfrom blurry.utils import format_schema_data\nfrom blurry.utils import get_domain_with_scheme\nfrom blurry.utils import path_to_url_pathname\nfrom blurry.utils import remove_lazy_loading_from_first_image", "from blurry.utils import path_to_url_pathname\nfrom blurry.utils import remove_lazy_loading_from_first_image\nfrom blurry.utils import sort_directory_file_data_by_date\n\n\nBUILD_DIR = get_build_directory()\nCONTENT_DIR = get_content_directory()\n\n\n@pytest.mark.parametrize(", "\n@pytest.mark.parametrize(\n    \"path_in, expected_build_path\",\n    [\n        (\"cool-post.md\", \"cool-post\"),\n        (\"nested/post.md\", \"nested/post\"),\n        (\"index.md\", \"\"),\n    ],\n)\ndef test_convert_content_path_to_build_path(path_in, expected_build_path):\n    path = Path(path_in)\n    path_out = convert_content_path_to_directory_in_build(path)\n    assert path_out == (BUILD_DIR / Path(expected_build_path))", ")\ndef test_convert_content_path_to_build_path(path_in, expected_build_path):\n    path = Path(path_in)\n    path_out = convert_content_path_to_directory_in_build(path)\n    assert path_out == (BUILD_DIR / Path(expected_build_path))\n\n\n@pytest.mark.parametrize(\n    \"path_in, expected_html_path\",\n    [", "    \"path_in, expected_html_path\",\n    [\n        (\"./cool-post.md\", \"../cool-post/\"),\n        (\"../home.md\", \"../../home/\"),\n        (\"../index.md\", \"../../\"),\n        (\"./image.png\", \"../image.png\"),\n    ],\n)\ndef test_convert_content_path_to_html_path(path_in, expected_html_path):\n    html_path = convert_relative_path_in_markdown_to_relative_build_path(path_in)\n    assert html_path == expected_html_path", "def test_convert_content_path_to_html_path(path_in, expected_html_path):\n    html_path = convert_relative_path_in_markdown_to_relative_build_path(path_in)\n    assert html_path == expected_html_path\n\n\ndef test_sort_directory_file_data_by_date():\n    blog_path = Path(\"blog\")\n    directory_file_data = {\n        blog_path: [\n            MarkdownFileData(\n                front_matter=dict(datePublished=date(2021, 1, 1)),\n                body=\"\",\n                path=Path(\"a-post-1\"),\n            ),\n            MarkdownFileData(\n                front_matter=dict(datePublished=date(2021, 3, 1)),\n                body=\"\",\n                path=Path(\"b-post-3\"),\n            ),\n            MarkdownFileData(\n                front_matter=dict(dateCreated=date(2021, 2, 1)),\n                body=\"\",\n                path=Path(\"c-post-2\"),\n            ),\n            MarkdownFileData(\n                front_matter=dict(),\n                body=\"\",\n                path=Path(\"c-post-4\"),\n            ),\n        ]\n    }\n\n    sorted_directory_file_data = sort_directory_file_data_by_date(directory_file_data)\n    file_data = sorted_directory_file_data[blog_path]\n    assert \"post-3\" in str(file_data[0].path)\n    assert \"post-2\" in str(file_data[1].path)\n    assert \"post-1\" in str(file_data[2].path)\n    assert \"post-4\" in str(file_data[3].path)", "\n\n@pytest.mark.parametrize(\n    \"path, expected_url\",\n    [\n        (Path(\"index.md\"), \"https://a.com/\"),\n        (Path(\"contact.md\"), \"https://a.com/contact/\"),\n        (Path(\"blog/index.md\"), \"https://a.com/blog/\"),\n        (Path(\"blog/my-post.md\"), \"https://a.com/blog/my-post/\"),\n    ],", "        (Path(\"blog/my-post.md\"), \"https://a.com/blog/my-post/\"),\n    ],\n)\ndef test_content_path_to_url(path, expected_url):\n    with mock.patch.dict(SETTINGS, {\"DOMAIN\": \"a.com\"}):\n        assert content_path_to_url(path) == expected_url\n\n\n@pytest.mark.parametrize(\n    \"settings, expected_domain_with_scheme\",", "@pytest.mark.parametrize(\n    \"settings, expected_domain_with_scheme\",\n    [\n        ({\"RUNSERVER\": True}, \"http://127.0.0.1:8000\"),\n        ({\"RUNSERVER\": False}, \"https://example.com\"),\n        (\n            {\n                \"RUNSERVER\": True,\n                \"USE_HTTP\": True,\n                \"DEV_HOST\": \"localhost\",", "                \"USE_HTTP\": True,\n                \"DEV_HOST\": \"localhost\",\n                \"DEV_PORT\": 8001,\n            },\n            \"http://localhost:8001\",\n        ),\n        ({\"RUNSERVER\": False, \"DOMAIN\": \"banana.biz\"}, \"https://banana.biz\"),\n        (\n            {\"RUNSERVER\": False, \"USE_HTTP\": True, \"DOMAIN\": \"banana.biz\"},\n            \"http://banana.biz\",", "            {\"RUNSERVER\": False, \"USE_HTTP\": True, \"DOMAIN\": \"banana.biz\"},\n            \"http://banana.biz\",\n        ),\n    ],\n)\ndef test_get_domain_with_scheme(settings, expected_domain_with_scheme):\n    with mock.patch.dict(SETTINGS, settings):\n        assert get_domain_with_scheme() == expected_domain_with_scheme\n\n", "\n\n@pytest.mark.parametrize(\n    \"path, expected_url_pathname\",\n    [\n        (CONTENT_DIR / \"favicon.png\", \"/favicon.png\"),\n        (CONTENT_DIR / \"images\" / \"some-image.jpg\", \"/images/some-image.jpg\"),\n    ],\n)\ndef test_path_to_url_pathname(path, expected_url_pathname):\n    assert path_to_url_pathname(path) == expected_url_pathname", ")\ndef test_path_to_url_pathname(path, expected_url_pathname):\n    assert path_to_url_pathname(path) == expected_url_pathname\n\n\ndef test_format_schema_data():\n    assert format_schema_data({\"@type\": \"BlogPosting\"}) == {\n        \"@context\": \"https://schema.org\",\n        \"@type\": \"BlogPosting\",\n    }", "\n\ndef test_remove_lazy_loading_from_first_image():\n    html = \"\"\"\n    <body>\n    <picture class=\"one\">\n        <source src=\"one.avif\">\n        <img src=\"one.png\" loading=\"lazy\">\n    </picture>\n    <picture class=\"two\">\n        <source src=\"two.avif\">\n        <img src=\"two.png\" loading=\"lazy\">\n    </picture>\n    </body>\n    \"\"\"\n    updated_html = remove_lazy_loading_from_first_image(html)\n    parser = HTMLParser(updated_html)\n    assert parser.css_first(\"picture.one img\").attributes.get(\"loading\") is None\n    assert parser.css_first(\"picture.two img\").attributes.get(\"loading\") == \"lazy\"", ""]}
