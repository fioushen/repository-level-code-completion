{"filename": "test/sdf.py", "chunked_list": ["import pytest, sys\n\nsys.path.append('..')\n\nfrom sympy import Matrix\nfrom SymE3.core import PointH, LieGroup, LieAlgebra, SymbolicFunction, dehom, TotalFunction, exp\nfrom SymE3.detail import _MatrixSym\n\ndef test_sdf():\n    l_i = PointH(\"{l_i}\")\n    lhat_i = PointH(\"{\\\\hat{l}_i}\")\n    That_wl = LieGroup(\"{\\\\hat{T}_{wl}}\")\n    d = LieAlgebra(\"{\\\\delta}\")\n    psi = SymbolicFunction(\"{psi}\", 3, 1)\n\n    e = psi(dehom(exp(d) * That_wl * l_i))\n    e = e.subs(That_wl * l_i, lhat_i)\n    f = TotalFunction(e)\n\n    df_dd = f.diff(d)\n\n    # Compare against ground truth\n    lh = Matrix(_MatrixSym(lhat_i.name, 3, 1))\n    ps = psi.__explicit__()(lh[0], lh[1], lh[2])\n\n    fe = f.as_explicit()\n    c = ps\n    assert c.__str__() == fe.__str__()\n\n    dpsi_dlh = Matrix([ps.fdiff(1), ps.fdiff(2), ps.fdiff(3)]).transpose()\n    cp = lh.cross(dpsi_dlh).transpose()\n    jc = dpsi_dlh\n    jc = jc.col_insert(3, cp)\n    assert jc == df_dd", "def test_sdf():\n    l_i = PointH(\"{l_i}\")\n    lhat_i = PointH(\"{\\\\hat{l}_i}\")\n    That_wl = LieGroup(\"{\\\\hat{T}_{wl}}\")\n    d = LieAlgebra(\"{\\\\delta}\")\n    psi = SymbolicFunction(\"{psi}\", 3, 1)\n\n    e = psi(dehom(exp(d) * That_wl * l_i))\n    e = e.subs(That_wl * l_i, lhat_i)\n    f = TotalFunction(e)\n\n    df_dd = f.diff(d)\n\n    # Compare against ground truth\n    lh = Matrix(_MatrixSym(lhat_i.name, 3, 1))\n    ps = psi.__explicit__()(lh[0], lh[1], lh[2])\n\n    fe = f.as_explicit()\n    c = ps\n    assert c.__str__() == fe.__str__()\n\n    dpsi_dlh = Matrix([ps.fdiff(1), ps.fdiff(2), ps.fdiff(3)]).transpose()\n    cp = lh.cross(dpsi_dlh).transpose()\n    jc = dpsi_dlh\n    jc = jc.col_insert(3, cp)\n    assert jc == df_dd", "\n"]}
{"filename": "test/photo.py", "chunked_list": ["import pytest, sys\n\nsys.path.append('..')\n\nfrom sympy import expand, symbols, Matrix, tensorcontraction\nfrom SymE3.core import Pixel, PointH, LieGroup, LieAlgebra, CustomFunction, SymbolicFunction, dehom, TotalFunction, exp\nfrom SymE3.detail import _MatrixSym\n\ndef test_photometric_alignment():\n    x_i = Pixel(\"{x_i}\")\n    p_i = PointH(\"{p_i}\")\n    That_rl = LieGroup(\"{\\\\hat{T}_{rl}}\")\n    d = LieAlgebra(\"{\\\\delta}\")\n    phat_i = PointH(\"{\\\\hat{p}_i}\")\n\n    def proj(p):\n        p_ray = p / p[2, 0]\n        f_x, f_y, c_x, c_y = symbols(\"f_x f_y c_x c_y\")\n        \n        return Matrix([[f_x,   0, c_x],\n                        [  0, f_y, c_y]]) * p_ray\n\n    Pi = CustomFunction(\"Pi\", proj, 3, 2)\n    I_r = SymbolicFunction(\"I_r\", 2, 1)\n    I_l = SymbolicFunction(\"I_l\", 2, 1)\n\n    e = I_r(Pi(dehom(exp(d) * That_rl * p_i))) - I_l(x_i)\n    e = e.subs(That_rl * p_i, phat_i)\n    f = TotalFunction(e)\n    df_dd = f.diff(d)\n\n    # Compare against ground truth\n    ph = Matrix(_MatrixSym(phat_i.name, 3, 1))\n    x = Matrix(_MatrixSym(x_i.name, 2, 1))\n    pi = Pi.__explicit__()(ph).tomatrix()\n    il = I_l.__explicit__()(x[0], x[1])\n    ir = I_r.__explicit__()(pi[0], pi[1])\n\n    fe = f.as_explicit()\n    c = ir - il\n    assert c.__str__() == fe.__str__()\n\n    dpi_dph = tensorcontraction(pi.diff(ph), (1, 3)).transpose()\n    dir_dpi = Matrix([ir.fdiff(1), ir.fdiff(2)]).transpose()\n    gradpi = dir_dpi * dpi_dph\n    cp = ph.cross(gradpi).transpose()\n    jc = gradpi\n    jc = jc.col_insert(3, cp)\n    df_ddm = df_dd\n    for i in range(6):\n        jc[i] = expand(jc[i])\n        df_ddm[i] = expand(df_ddm[i])\n    assert jc == df_ddm", "def test_photometric_alignment():\n    x_i = Pixel(\"{x_i}\")\n    p_i = PointH(\"{p_i}\")\n    That_rl = LieGroup(\"{\\\\hat{T}_{rl}}\")\n    d = LieAlgebra(\"{\\\\delta}\")\n    phat_i = PointH(\"{\\\\hat{p}_i}\")\n\n    def proj(p):\n        p_ray = p / p[2, 0]\n        f_x, f_y, c_x, c_y = symbols(\"f_x f_y c_x c_y\")\n        \n        return Matrix([[f_x,   0, c_x],\n                        [  0, f_y, c_y]]) * p_ray\n\n    Pi = CustomFunction(\"Pi\", proj, 3, 2)\n    I_r = SymbolicFunction(\"I_r\", 2, 1)\n    I_l = SymbolicFunction(\"I_l\", 2, 1)\n\n    e = I_r(Pi(dehom(exp(d) * That_rl * p_i))) - I_l(x_i)\n    e = e.subs(That_rl * p_i, phat_i)\n    f = TotalFunction(e)\n    df_dd = f.diff(d)\n\n    # Compare against ground truth\n    ph = Matrix(_MatrixSym(phat_i.name, 3, 1))\n    x = Matrix(_MatrixSym(x_i.name, 2, 1))\n    pi = Pi.__explicit__()(ph).tomatrix()\n    il = I_l.__explicit__()(x[0], x[1])\n    ir = I_r.__explicit__()(pi[0], pi[1])\n\n    fe = f.as_explicit()\n    c = ir - il\n    assert c.__str__() == fe.__str__()\n\n    dpi_dph = tensorcontraction(pi.diff(ph), (1, 3)).transpose()\n    dir_dpi = Matrix([ir.fdiff(1), ir.fdiff(2)]).transpose()\n    gradpi = dir_dpi * dpi_dph\n    cp = ph.cross(gradpi).transpose()\n    jc = gradpi\n    jc = jc.col_insert(3, cp)\n    df_ddm = df_dd\n    for i in range(6):\n        jc[i] = expand(jc[i])\n        df_ddm[i] = expand(df_ddm[i])\n    assert jc == df_ddm", ""]}
{"filename": "test/icp.py", "chunked_list": ["import pytest, sys\n\nsys.path.append('..')\n\nfrom sympy import Matrix\nfrom SymE3.core import exp, LieAlgebra, NormalH, PointH, LieGroup, TotalFunction\nfrom SymE3.detail import _MatrixSym\n\ndef test_point_plane_icp():\n    n_ri = NormalH(\"{n_{r_i}}\")\n    r_i = PointH(\"{r_i}\")\n    l_i = PointH(\"{l_i}\")\n    rhat_i = PointH(\"{\\\\hat{r}_i}\")\n    That_rl = LieGroup(\"{\\\\hat{T}_{rl}}\")\n    d = LieAlgebra(\"{\\\\delta}\")\n\n    e = n_ri.transpose() * ((exp(d) * That_rl * l_i) - r_i)\n    e = e.subs(That_rl * l_i, rhat_i)\n\n    f = TotalFunction(e)\n    df_dd = f.diff(d)\n\n    # Compare against ground truth\n    nr = Matrix(_MatrixSym(n_ri.name, 3, 1))\n    r = Matrix(_MatrixSym(r_i.name, 3, 1))\n    rh = Matrix(_MatrixSym(rhat_i.name, 3, 1))\n\n    c = nr.transpose() * (rh - r)\n    fe = f.as_explicit()\n    assert c == fe.tomatrix()\n\n    cp = rh.cross(nr).transpose()\n    jc = nr.transpose()\n    jc = jc.col_insert(3, cp)\n    assert jc == df_dd", "def test_point_plane_icp():\n    n_ri = NormalH(\"{n_{r_i}}\")\n    r_i = PointH(\"{r_i}\")\n    l_i = PointH(\"{l_i}\")\n    rhat_i = PointH(\"{\\\\hat{r}_i}\")\n    That_rl = LieGroup(\"{\\\\hat{T}_{rl}}\")\n    d = LieAlgebra(\"{\\\\delta}\")\n\n    e = n_ri.transpose() * ((exp(d) * That_rl * l_i) - r_i)\n    e = e.subs(That_rl * l_i, rhat_i)\n\n    f = TotalFunction(e)\n    df_dd = f.diff(d)\n\n    # Compare against ground truth\n    nr = Matrix(_MatrixSym(n_ri.name, 3, 1))\n    r = Matrix(_MatrixSym(r_i.name, 3, 1))\n    rh = Matrix(_MatrixSym(rhat_i.name, 3, 1))\n\n    c = nr.transpose() * (rh - r)\n    fe = f.as_explicit()\n    assert c == fe.tomatrix()\n\n    cp = rh.cross(nr).transpose()\n    jc = nr.transpose()\n    jc = jc.col_insert(3, cp)\n    assert jc == df_dd", ""]}
{"filename": "test/homogeneous.py", "chunked_list": ["import pytest, sys\n\nsys.path.append('..')\n\nfrom SymE3.core import PointH, TotalFunction\n\ndef test_addition():\n    a = PointH(\"a\")\n    b = PointH(\"b\")\n    e = TotalFunction(a + b).as_explicit().tomatrix()\n    assert e[3] == 1", "\ndef test_subtraction():\n    a = PointH(\"a\")\n    b = PointH(\"b\")\n    e = TotalFunction(a - b).as_explicit().tomatrix()\n    assert e[3] == 1\n\ndef test_rmul():\n    a = PointH(\"a\")\n    e = TotalFunction(2 * a).as_explicit().tomatrix()\n    assert e[3] == 1", "\ndef test_mul():\n    a = PointH(\"a\")\n    e = TotalFunction(a * 2).as_explicit().tomatrix()\n    assert e[3] == 1\n"]}
{"filename": "test/log.py", "chunked_list": ["import pytest, sys\n\nsys.path.append('..')\n\nfrom SymE3.core import exp, LieAlgebra, LieGroup, log\n\ndef test_log():\n    T_i = LieGroup(\"{T_{i}}\")\n    deltaxi_i = LieAlgebra(\"{\\\\delta\\\\xi_{i}}\")\n\n    assert exp(log(T_i)) == T_i\n\n    assert log(exp(deltaxi_i)) == deltaxi_i", ""]}
{"filename": "test/bundle.py", "chunked_list": ["import pytest, sys\n\nsys.path.append('..')\n\nfrom sympy import symbols, Matrix\nfrom SymE3.core import PointH, Pixel, LieGroup, LieAlgebra, CustomFunction, TotalFunction, dehom, exp\n\ndef test_bundle_adjustment():\n    x_w = PointH(\"{x_w}\")\n    x_i = Pixel(\"{x_i}\")\n    That_cw = LieGroup(\"{\\\\hat{T}_{cw}}\")\n    d = LieAlgebra(\"{\\\\delta}\")\n    f_x, f_y, c_x, c_y = symbols(\"f_x f_y c_x c_y\")\n\n    def proj(p):\n        p_ray = p / p[2, 0]\n        return Matrix([[f_x,   0, c_x],\n                       [  0, f_y, c_y]]) * p_ray\n\n    Pi = CustomFunction(\"Pi\", proj, 3, 2)\n\n    e = x_i - Pi(dehom(exp(d) * That_cw * x_w))\n\n    f = TotalFunction(e)\n    fe = f.as_explicit()\n    df_dd = f.diff(d, dehom(x_w), f_x, f_y, c_x, c_y)", ""]}
{"filename": "test/exp.py", "chunked_list": ["import pytest, sys\n\nsys.path.append('..')\n\nfrom sympy import Array\nfrom SymE3.core import exp, LieAlgebra, TotalFunction\n\ndef test_exp():\n    d = LieAlgebra(\"{\\\\delta}\")\n    f = TotalFunction(exp(d))\n\n    expected = Array([[[[0, 0, 0, 1], \n                        [0, 0, 0, 0], \n                        [0, 0, 0, 0], \n                        [0, 0, 0, 0]]], \n                      [[[0, 0, 0, 0], \n                        [0, 0, 0, 1], \n                        [0, 0, 0, 0], \n                        [0, 0, 0, 0]]], \n                      [[[0, 0, 0, 0], \n                        [0, 0, 0, 0], \n                        [0, 0, 0, 1], \n                        [0, 0, 0, 0]]], \n                      [[[0, 0, 0, 0], \n                        [0, 0, -1, 0], \n                        [0, 1, 0, 0], \n                        [0, 0, 0, 0]]], \n                      [[[0, 0, 1, 0], \n                        [0, 0, 0, 0], \n                        [-1, 0, 0, 0], \n                        [0, 0, 0, 0]]], \n                      [[[0, -1, 0, 0], \n                        [1, 0, 0, 0], \n                        [0, 0, 0, 0], \n                        [0, 0, 0, 0]]]])\n\n    result = f.diff(d)\n\n    assert expected == result", ""]}
{"filename": "test/mirrors.py", "chunked_list": ["import pytest, sys\n\nsys.path.append('..')\n\nfrom sympy import symbols, eye, Matrix\nfrom SymE3.core import Plane, LieGroup, PointH, Pixel, LieAlgebra, CustomFunction, TotalFunction, dehom, exp\n\ndef test_mirrors():\n    T_cw = LieGroup(\"{T_{cw}}\")\n    T_ct = LieGroup(\"{\\hat{T}_{ct}}\")\n    p_t = PointH(\"{p_t}\")\n    phat_c = PointH(\"{\\hat{p}_{c}}\")\n    p_c = Pixel(\"{p_c}\")\n    N_w = Plane(\"{N_w}\")\n    d = LieAlgebra(\"{\\\\delta}\")\n\n    def proj(p):\n        p_ray = p / p[2, 0]\n        f_x, f_y, c_x, c_y = symbols(\"f_x f_y c_x c_y\")\n        \n        return Matrix([[f_x,   0, c_x],\n                       [  0, f_y, c_y]]) * p_ray\n\n    Pi = CustomFunction(\"Pi\", proj, 3, 2)\n\n    def sym(n):\n        n_hat = n[0:3, :]\n        S = eye(4)\n        S[0:3, 0:3] = eye(3) - (2 * (n_hat * n_hat.transpose()))\n        S[0:3, 3] = 2 * n[3] * n_hat\n        return S\n        \n    S = CustomFunction(\"S\", sym, 4, 4, 1, 4)\n\n    e = Pi(dehom(T_cw * S(N_w) * T_cw.inverse() * exp(d) * T_ct * p_t)) - p_c\n    e = e.subs(T_ct * p_t, phat_c)\n    f = TotalFunction(e)\n\n    fe = f.as_explicit()\n    df_dd = f.diff(d, N_w)", "\n\n"]}
{"filename": "test/embeddef.py", "chunked_list": ["import pytest, sys\n\nsys.path.append('..')\n\nfrom sympy import Matrix, symbols, zeros, eye\nfrom SymE3.core import Matrix3, Scalar, Point, CustomFunction, TotalFunction\nfrom SymE3.detail import _MatrixSym\n\ndef test_embedded_deformation():\n    t_z = Point(\"{t_z}\")\n    t_n = Point(\"{t_n}\")\n    g_z = Point(\"{g_z}\")\n    g_n = Point(\"{g_n}\")\n    v_s = Point(\"{v_s}\")\n    q_s = Point(\"{q_s}\")\n    w_nvs = Scalar(\"{w_{n_{(v_s)}}}\")\n    R_n = Matrix3(\"{R_n}\")\n    R_z = Matrix3(\"{R_z}\")\n\n    def rot(R):\n        return Matrix([[R[:, 0].dot(R[:, 1])], \n                       [R[:, 0].dot(R[:, 2])],\n                       [R[:, 1].dot(R[:, 2])],\n                       [R[:, 0].dot(R[:, 0]) - 1],\n                       [R[:, 1].dot(R[:, 1]) - 1],\n                       [R[:, 2].dot(R[:, 2]) - 1]])\n\n    Rot = CustomFunction(\"Rot\", rot, 3, 6, 3)\n\n    # Rotation cost\n    e = Rot(R_z)\n    f = TotalFunction(e)\n\n    # This jacobian is an element of the matrix per column in row major order\n    df_dRt = f.diff(R_z, t_z)\n\n    # Compare against ground truth\n    rz = Matrix(_MatrixSym(R_z.name, 3, 3))\n    rr = Rot.__explicit__()\n\n    fe = f.as_explicit()\n    c = rr(rz).tomatrix()\n    assert c == fe.tomatrix()\n    assert df_dRt[:, 0] == c.diff(rz[0, 0])\n    assert df_dRt[:, 1] == c.diff(rz[0, 1])\n    assert df_dRt[:, 2] == c.diff(rz[0, 2])\n    assert df_dRt[:, 3] == c.diff(rz[1, 0])\n    assert df_dRt[:, 4] == c.diff(rz[1, 1])\n    assert df_dRt[:, 5] == c.diff(rz[1, 2])\n    assert df_dRt[:, 6] == c.diff(rz[2, 0])\n    assert df_dRt[:, 7] == c.diff(rz[2, 1])\n    assert df_dRt[:, 8] == c.diff(rz[2, 2])\n    assert df_dRt[:, 9:] == zeros(6, 3)\n\n    # Regularization cost\n    e = R_z * (g_n - g_z) + g_z + t_z - (g_n + t_n)\n    f = TotalFunction(e)\n\n    # This jacobian is an element of the matrix per column in row major order\n    df_dRt = f.diff(R_z, t_z, t_n)\n\n    # Compare against ground truth\n    gn = Matrix(_MatrixSym(g_n.name, 3, 1))\n    gz = Matrix(_MatrixSym(g_z.name, 3, 1))\n    tn = Matrix(_MatrixSym(t_n.name, 3, 1))\n    tz = Matrix(_MatrixSym(t_z.name, 3, 1))\n\n    fe = f.as_explicit()\n    c = rz * (gn - gz) + gz + tz - (gn + tn)\n    assert c == fe.tomatrix()\n    assert df_dRt[0:3, 0:3] == Matrix([[(gn - gz).transpose()], [zeros(1, 3)], [zeros(1, 3)]])\n    assert df_dRt[0:3, 3:6] == Matrix([[zeros(1, 3)], [(gn - gz).transpose()], [zeros(1, 3)]])\n    assert df_dRt[0:3, 6:9] == Matrix([[zeros(1, 3)], [zeros(1, 3)], [(gn - gz).transpose()]])\n    assert df_dRt[0:3, 9:12] == eye(3, 3)\n    assert df_dRt[0:3, 12:15] == -eye(3, 3)\n\n    # Constraint cost\n    e = (w_nvs * (R_n * (v_s - g_n) + g_n + t_n)) - q_s\n    f = TotalFunction(e)\n\n    # This jacobian is an element of the matrix per column in row major order\n    df_dRt = f.diff(R_n, t_n)\n\n    # Compare against ground truth\n    vs = Matrix(_MatrixSym(v_s.name, 3, 1))\n    qs = Matrix(_MatrixSym(q_s.name, 3, 1))\n    rn = Matrix(_MatrixSym(R_n.name, 3, 3))\n    w = symbols(\"{w_{n_{(v_s)}}}\")\n\n    fe = f.as_explicit()\n    c = (w * (rn * (vs - gn) + gn + tn)) - qs\n    assert c == fe.tomatrix()\n    assert df_dRt[0:3, 0:3] == Matrix([[w * (vs - gn).transpose()], [zeros(1, 3)], [zeros(1, 3)]])\n    assert df_dRt[0:3, 3:6] == Matrix([[zeros(1, 3)], [w * (vs - gn).transpose()], [zeros(1, 3)]])\n    assert df_dRt[0:3, 6:9] == Matrix([[zeros(1, 3)], [zeros(1, 3)], [w * (vs - gn).transpose()]])\n    assert df_dRt[0:3, 9:12] == w * eye(3, 3)", "def test_embedded_deformation():\n    t_z = Point(\"{t_z}\")\n    t_n = Point(\"{t_n}\")\n    g_z = Point(\"{g_z}\")\n    g_n = Point(\"{g_n}\")\n    v_s = Point(\"{v_s}\")\n    q_s = Point(\"{q_s}\")\n    w_nvs = Scalar(\"{w_{n_{(v_s)}}}\")\n    R_n = Matrix3(\"{R_n}\")\n    R_z = Matrix3(\"{R_z}\")\n\n    def rot(R):\n        return Matrix([[R[:, 0].dot(R[:, 1])], \n                       [R[:, 0].dot(R[:, 2])],\n                       [R[:, 1].dot(R[:, 2])],\n                       [R[:, 0].dot(R[:, 0]) - 1],\n                       [R[:, 1].dot(R[:, 1]) - 1],\n                       [R[:, 2].dot(R[:, 2]) - 1]])\n\n    Rot = CustomFunction(\"Rot\", rot, 3, 6, 3)\n\n    # Rotation cost\n    e = Rot(R_z)\n    f = TotalFunction(e)\n\n    # This jacobian is an element of the matrix per column in row major order\n    df_dRt = f.diff(R_z, t_z)\n\n    # Compare against ground truth\n    rz = Matrix(_MatrixSym(R_z.name, 3, 3))\n    rr = Rot.__explicit__()\n\n    fe = f.as_explicit()\n    c = rr(rz).tomatrix()\n    assert c == fe.tomatrix()\n    assert df_dRt[:, 0] == c.diff(rz[0, 0])\n    assert df_dRt[:, 1] == c.diff(rz[0, 1])\n    assert df_dRt[:, 2] == c.diff(rz[0, 2])\n    assert df_dRt[:, 3] == c.diff(rz[1, 0])\n    assert df_dRt[:, 4] == c.diff(rz[1, 1])\n    assert df_dRt[:, 5] == c.diff(rz[1, 2])\n    assert df_dRt[:, 6] == c.diff(rz[2, 0])\n    assert df_dRt[:, 7] == c.diff(rz[2, 1])\n    assert df_dRt[:, 8] == c.diff(rz[2, 2])\n    assert df_dRt[:, 9:] == zeros(6, 3)\n\n    # Regularization cost\n    e = R_z * (g_n - g_z) + g_z + t_z - (g_n + t_n)\n    f = TotalFunction(e)\n\n    # This jacobian is an element of the matrix per column in row major order\n    df_dRt = f.diff(R_z, t_z, t_n)\n\n    # Compare against ground truth\n    gn = Matrix(_MatrixSym(g_n.name, 3, 1))\n    gz = Matrix(_MatrixSym(g_z.name, 3, 1))\n    tn = Matrix(_MatrixSym(t_n.name, 3, 1))\n    tz = Matrix(_MatrixSym(t_z.name, 3, 1))\n\n    fe = f.as_explicit()\n    c = rz * (gn - gz) + gz + tz - (gn + tn)\n    assert c == fe.tomatrix()\n    assert df_dRt[0:3, 0:3] == Matrix([[(gn - gz).transpose()], [zeros(1, 3)], [zeros(1, 3)]])\n    assert df_dRt[0:3, 3:6] == Matrix([[zeros(1, 3)], [(gn - gz).transpose()], [zeros(1, 3)]])\n    assert df_dRt[0:3, 6:9] == Matrix([[zeros(1, 3)], [zeros(1, 3)], [(gn - gz).transpose()]])\n    assert df_dRt[0:3, 9:12] == eye(3, 3)\n    assert df_dRt[0:3, 12:15] == -eye(3, 3)\n\n    # Constraint cost\n    e = (w_nvs * (R_n * (v_s - g_n) + g_n + t_n)) - q_s\n    f = TotalFunction(e)\n\n    # This jacobian is an element of the matrix per column in row major order\n    df_dRt = f.diff(R_n, t_n)\n\n    # Compare against ground truth\n    vs = Matrix(_MatrixSym(v_s.name, 3, 1))\n    qs = Matrix(_MatrixSym(q_s.name, 3, 1))\n    rn = Matrix(_MatrixSym(R_n.name, 3, 3))\n    w = symbols(\"{w_{n_{(v_s)}}}\")\n\n    fe = f.as_explicit()\n    c = (w * (rn * (vs - gn) + gn + tn)) - qs\n    assert c == fe.tomatrix()\n    assert df_dRt[0:3, 0:3] == Matrix([[w * (vs - gn).transpose()], [zeros(1, 3)], [zeros(1, 3)]])\n    assert df_dRt[0:3, 3:6] == Matrix([[zeros(1, 3)], [w * (vs - gn).transpose()], [zeros(1, 3)]])\n    assert df_dRt[0:3, 6:9] == Matrix([[zeros(1, 3)], [zeros(1, 3)], [w * (vs - gn).transpose()]])\n    assert df_dRt[0:3, 9:12] == w * eye(3, 3)", ""]}
{"filename": "SymE3/numerical.py", "chunked_list": ["import random\n\nfrom sympy import MutableDenseMatrix, Symbol, Matrix, Float, eye, sin, cos\nfrom sophus.se3 import Se3\nfrom .detail import _Explicit, _MatrixSym\n\nvalues = {}\n\ndef _resetValues():\n    if len(values) == 0:\n        random.seed(0)", "def _resetValues():\n    if len(values) == 0:\n        random.seed(0)\n\ndef _realVal(s):\n    if s in values:\n        return values[s]\n    else:\n        value = random.uniform(-1, 1)\n        values[s] = value\n        return value", "\ndef _getRealMatValue(sym, idx):\n    matrix = Matrix(_MatrixSym(sym.name, sym.rows, sym.cols))\n    row = int(idx) // int(sym.cols)\n    col = int(idx) % int(sym.cols)\n    return matrix[row, col], _realVal(matrix[row, col])\n\ndef _subAndEvalReal(expression):\n    if isinstance(expression, _Explicit):\n        expression = expression.tomatrix()\n\n    sub = {}\n\n    # Recursively substitute placeholder values\n    def recursiveSub(subExpr):\n        if isinstance(subExpr, Symbol):\n            sub[subExpr] = _realVal(subExpr)\n        elif isinstance(subExpr, Matrix):\n            for subSym in subExpr:\n                recursiveSub(subSym)\n        else:\n            for subSym in subExpr.args:\n                recursiveSub(subSym)\n\n    recursiveSub(expression)\n\n    # If we have symbols left, they are symbolic functions and we should store their derivatives. \n    substituted = expression.evalf(subs=sub)\n    substituted = substituted.subs(sub)\n\n    funcValues = {}\n\n    def recursiveEval(subExpr):\n        # We have found a symbolic function, manually evaluate a placeholder continuous function\n        # and set that as the value of this function at the numerical point\n        if isinstance(subExpr, Float):\n            return subExpr\n\n        if hasattr(subExpr, \"inRows\") and hasattr(subExpr, \"outRows\"):\n            assert subExpr.inRows == len(subExpr.args)\n\n            # Ensure all parameters have a value\n            arguments = list(subExpr.args)\n\n            for i in range(len(arguments)):\n                if not isinstance(arguments[i], Float):\n                    arguments[i] = recursiveEval(arguments[i])\n\n            value = Float(0)\n\n            for arg in arguments:\n                value = value + sin(arg)\n\n            # The partial derivative of the func w.r.t. any param is just cos(param), nice!\n            for i in range(subExpr.inRows):\n                partialSym = subExpr.fdiff(i + 1)\n                values[partialSym] = cos(arguments[i])\n\n            funcValues[subExpr] = value\n\n            return value\n        else:\n            for subSym in subExpr.args:\n                recursiveEval(subSym)\n\n    if isinstance(substituted, MutableDenseMatrix):\n        for elem in substituted:\n            recursiveEval(elem)\n    else:\n        recursiveEval(substituted)\n\n    substituted = substituted.subs(funcValues)\n\n    if isinstance(substituted, Float):\n        return Matrix([[substituted]])\n\n    return substituted", "\ndef _exp(v, perturb):\n    mat = Se3.exp(v.as_mutable()).matrix()\n\n    # Work around singularity\n    if perturb[3, 0] == 0 and perturb[4, 0] == 0 and perturb[5, 0] == 0:\n        mat = eye(4)\n        mat[0:3, 3] = perturb[0:3, 0]\n\n    assert v.rows == 6\n    assert v.shape == perturb.shape\n\n    sub = {}\n\n    for i in range(6):\n        sub[v[i, 0]] = perturb[i, 0]\n\n    return mat.evalf(subs=sub, strict=True)", ""]}
{"filename": "SymE3/__init__.py", "chunked_list": [""]}
{"filename": "SymE3/core.py", "chunked_list": ["from functools import reduce\n\nfrom typing import Tuple as tTuple\n\nfrom sympy import srepr, MatrixSymbol, Symbol, MatrixExpr, Expr, Matrix, Basic, Function, preorder_traversal, eye, symbols, zeros, oo\nfrom sympy.core.sympify import _sympify\n\nfrom .detail import _Type, _PointH, _Point, _NormalH, _Normal, _Pixel, _Plane, _Matrix3, _LieGroup, _LieAlgebra, _ExponentialMap, _Explicit\nfrom .parse import _parse\nfrom .numerical import _subAndEvalReal, _exp, _getRealMatValue, _realVal, _resetValues", "from .parse import _parse\nfrom .numerical import _subAndEvalReal, _exp, _getRealMatValue, _realVal, _resetValues\n\nclass TotalFunction:\n    def __init__(self, expression):\n        self.expression = expression\n        self.funcs = {}\n\n        for arg in preorder_traversal(expression):\n            if hasattr(arg, \"__explicit__\"):\n                self.funcs[type(arg).__name__] = type(arg).__explicit__()\n\n    def _repr_latex_(self):\n        return self.expression._repr_latex_()\n\n    def __str__(self):\n        return self.expression.__str__()\n\n    def __parseExpression__(self, substituteLieGroup):\n        exprTreeStr = srepr(self.expression)\n    \n        # Convert exp to a transformation matrix when showing explicitly\n        if substituteLieGroup:\n            exprTreeStr = exprTreeStr.replace(\"exp(\", \"LieGroupFromExp(\")\n\n        # Replace any custom functions with their explicit call versions\n        for name in self.funcs:\n            exprTreeStr = exprTreeStr.replace(f\"{name}(\", f\"self.funcs[\\\"{name}\\\"](\")\n\n        # Parse the expression tree so we can make more complicated alterations\n        parsed = _parse(exprTreeStr)\n\n        # Custom symbolic functions are evaluated with vector parameters expanded\n        # These can be detected as those with a default __new__ function\n        for name, func in self.funcs.items():\n            if func.__new__ == Function.__new__:\n                parsed.wrapChildrenOf(f\"self.funcs[\\\"{name}\\\"]\", \"*Expand\")\n        \n        # Remove superfluous parameters\n        parsed.removeChildrenFrom(\"Inverse\", \"Integer\")\n        parsed.removeChildrenFrom(\"_PixelExpr\", \"Integer\")\n        parsed.removeChildrenFrom(\"_PlaneExpr\", \"Integer\")\n        parsed.removeChildrenFrom(\"_Matrix3Expr\", \"Integer\")\n        parsed.removeChildrenFrom(\"_PointExpr\", \"Integer\")\n        parsed.removeChildrenFrom(\"_PointHExpr\", \"Integer\")\n        parsed.removeChildrenFrom(\"_NormalExpr\", \"Integer\")\n        parsed.removeChildrenFrom(\"_NormalHExpr\", \"Integer\")\n        parsed.removeChildrenFrom(\"_LieGroupExpr\", \"Integer\")\n        parsed.renameIdentifier(\"_PointExpr\", \"_Point\")\n        parsed.renameIdentifier(\"_NormalExpr\", \"_Normal\")\n        parsed.renameIdentifier(\"_PointHExpr\", \"_PointH\")\n        parsed.renameIdentifier(\"_NormalHExpr\", \"_NormalH\")\n        parsed.renameIdentifier(\"_PixelExpr\", \"_Pixel\")\n        parsed.renameIdentifier(\"_PlaneExpr\", \"_Plane\")\n        parsed.renameIdentifier(\"Symbol\", \"Scalar\")\n        parsed.renameIdentifier(\"_Matrix3Expr\", \"_Matrix3\")\n        parsed.removeIdentifierPromoteChildren(\"Str\")\n        parsed.removeIdentifierPromoteChildren(\"Integer\")\n\n        return parsed\n\n    def __explicit__(self, parsedExpression, expandLieGroupFromExp=False):\n        # Define wrapper functions that allow us to convert to non-expression quantities automatically\n        def _LieGroupExpr(name, *_):\n            return _LieGroup(name)\n\n        def LieGroupFromExp(name, *_):\n            if expandLieGroupFromExp:\n                return _LieGroup(name)\n            else:\n                return _Explicit(eye(4))\n\n        def MatMul(*args):\n            return reduce((lambda x, y: x * y), args)\n\n        def MatAdd(*args):\n            return reduce((lambda x, y: x + y), args)\n\n        def Transpose(a):\n            return a.transpose()\n\n        def Inverse(a):\n            return a.inverse()\n\n        def Rational(a, b):\n            return a / b\n\n        def Expand(a):\n            return ( a[i, 0] for i in range(a.shape[0]) )\n\n        def exp(name):\n            return _ExponentialMap(name)(_LieAlgebra(name))\n\n        def dehom(a):\n            if hasattr(a, \"type\"):\n                if a.type == _Type.POINTH or a.type == _Type.NORMALH:\n                    return _Explicit([[a[0, 0]], [a[1, 0]], [a[2, 0]]])\n            return a\n\n        return eval(parsedExpression.reconstruct())\n\n    def as_explicit(self):\n        return self.__explicit__(self.__parseExpression__(True))\n\n    def diff(self, *args):\n        combinedResult = None\n\n        parsedExpression = self.__parseExpression__(False)\n\n        # Substitute all exp() with the identity, assuming we're linearizing around 0.\n        lieAlgebras = []\n        lieAlgebras = parsedExpression.findIdentifiers(\"_LieAlgebraExpr\", lieAlgebras)\n\n        _resetValues()\n\n        for arg in args:\n            result = None\n\n            explicitExpr = self.__explicit__(parsedExpression)\n\n            if isinstance(arg, _LieAlgebraExpr):\n                result = explicitExpr.diff(_LieAlgebra(arg.name))\n            elif isinstance(arg, MatrixExpr):\n                result = explicitExpr.diff(TotalFunction(arg).as_explicit())\n            else:\n                result = explicitExpr.diff(arg)\n\n            for matches in lieAlgebras:\n                lieAlgebra =_LieAlgebra(matches.children[0].__str__().strip(\"'\").replace(\"\\\\\\\\\", \"\\\\\"))\n                for symbol in lieAlgebra:\n                    result = result.subs(symbol[0], 0)\n\n            if len(result.shape) == 4 and result != _ExponentialMap(\"\")(_LieAlgebra(\"\")).diff(_LieAlgebra(\"\")):\n                # This means a derivative was taken w.r.t. a matrix or vector, so we must reshape the output\n                # Everything is flatten using row-major ordering\n                rows = result.shape[0] * result.shape[1]\n                cols = result.shape[2] * result.shape[3]\n                result = result.reshape(rows, cols)\n\n            if isinstance(arg, Symbol):\n                result = result.transpose()\n\n            if combinedResult is not None or len(result.shape) == 2:\n                result = result.transpose().tomatrix()\n\n            # Perform numerical substitution and evaluation to compare to numerical jacobian\n            if len(result.shape) == 2:\n                # Evaluate the function at zero \n                # Bit of stateful nastiness here as this will populate the placeholder numerical \n                # derivatives of any supplied symbolic functions, meaning it has to be called before\n                # the real evaluation of the derived jacobian is called. \n                fx = _subAndEvalReal(self.as_explicit())\n\n                numericalJacobian = zeros(result.rows, result.cols)\n\n                # Now, perform the numerical jacobian estimation process\n                eps = 1e-8\n\n                for col in range(numericalJacobian.cols):\n                    explicitExpr = self.__explicit__(self.__parseExpression__(True),\\\n                            isinstance(arg, _LieAlgebraExpr))\n\n                    if isinstance(explicitExpr, _Explicit):\n                        explicitExpr = explicitExpr.tomatrix()\n\n                    if isinstance(arg, _LieAlgebraExpr):\n                        lieGroupMat = _LieGroup(arg.name).tomatrix()\n                        tangent = Matrix([0, 0, 0, 0, 0, 0]).transpose()\n\n                        tangent[0, col] = eps\n                        realValue = _exp(_LieAlgebra(arg.name).tomatrix(), tangent.transpose())\n                        tangent[0, col] = 0\n\n                        # Substitute the perturbed matrix values in\n                        for r in range(lieGroupMat.rows):\n                            for c in range(lieGroupMat.cols):\n                                explicitExpr = explicitExpr.subs(lieGroupMat[r, c], realValue[r, c])\n                    elif isinstance(arg, MatrixExpr):\n                        if isinstance(arg, dehom):\n                            arg = arg.args[0]\n                        sym, realValue = _getRealMatValue(arg, col)\n                        explicitExpr = explicitExpr.subs(sym, realValue + eps)\n                    elif isinstance(arg, Symbol):\n                        explicitExpr = explicitExpr.subs(arg, _realVal(arg) + eps)\n                    else:\n                        assert False\n\n                    numericalJacobian[:, col] = (_subAndEvalReal(explicitExpr) - fx) / eps\n\n                derivedJacobian = _subAndEvalReal(result)\n\n                difference = (derivedJacobian - numericalJacobian).norm(oo)\n\n                assert difference < 1e-6\n\n            if combinedResult is None:\n                combinedResult = result\n            else:\n                combinedResult = combinedResult.col_insert(combinedResult.cols, result)\n\n        return combinedResult", "\ndef SymbolicFunction(name, inRows, outRows):\n    @classmethod\n    def __explicit__(cls):\n        def fdiff(self, argindex):\n            paramLabel = argindex - 1\n\n            if inRows < 4:\n                paramLabel = [\"x\", \"y\", \"z\"][argindex - 1]\n\n            return symbols(f\"{{{{\\\\Delta}}{name}}}_{{{paramLabel}}}\")\n\n        def diff(self, *symbols, **assumptions):\n            if hasattr(symbols[0], \"shape\") and len(symbols[0].shape) == inRows:\n                return super(Function, self).diff(symbols[0].transpose(), **assumptions)\n            else:\n                return super(Function, self).diff(symbols[0], **assumptions)\n            \n        return type(f\"{cls.__name__}\", (Function, ), \\\n                {\"fdiff\": fdiff, \"diff\": diff, \"inRows\": inRows, \"outRows\": outRows});\n    \n    @property\n    def shape(self) -> tTuple[Expr, Expr]:\n        return (outRows, 1)\n\n    return type(f\"{name}\", (MatrixExpr, ), {\"shape\": shape, \"__explicit__\": __explicit__});", "\ndef CustomFunction(name, func, inRows, outRows, inCols = 1, outCols = 1):\n    @classmethod\n    def __explicit__(cls):\n        def new(self, p):\n            assert p.shape == (inRows, inCols)\n            if hasattr(p, \"tomatrix\"):\n                p = p.tomatrix()\n            return _Explicit(func(p))\n\n        return type(f\"{cls.__name__}\", (Function, ), {\"__new__\": new});\n    \n    @property\n    def shape(self) -> tTuple[Expr, Expr]:\n        return (outRows, outCols)\n\n    return type(f\"{name}\", (MatrixExpr, ), {\"shape\": shape, \"__explicit__\": __explicit__});", "\nclass exp(MatrixExpr):\n    def __new__(cls, *args, **kwargs):\n        if len(args) == 1 and isinstance(args[0], log):\n            return args[0].arguments[0]\n        \n        arguments = args\n        args = map(_sympify, args)\n        self = Basic.__new__(cls, *args, **kwargs)\n        self.arguments = arguments\n        return self\n    \n    @property\n    def shape(self) -> tTuple[Expr, Expr]:\n        return (4, 4)", "\nclass log(MatrixExpr):\n    def __new__(cls, *args, **kwargs):\n        if len(args) == 1 and isinstance(args[0], exp):\n            return args[0].arguments[0]\n\n        arguments = args\n        args = map(_sympify, args)\n        self = Basic.__new__(cls, *args, **kwargs)\n        self.arguments = arguments\n        return self\n    \n    @property\n    def shape(self) -> tTuple[Expr, Expr]:\n        return (6, 1)", "\nclass dehom(MatrixExpr):\n    @property\n    def shape(self) -> tTuple[Expr, Expr]:\n        return (3, 1)\n\ndef Point(name):\n    return _PointExpr(name, 3, 1)\n\ndef PointH(name):\n    return _PointHExpr(name, 4, 1)", "\ndef PointH(name):\n    return _PointHExpr(name, 4, 1)\n\ndef Normal(name):\n    return _NormalExpr(name, 3, 1)\n\ndef NormalH(name):\n    return _NormalHExpr(name, 4, 1)\n\ndef Pixel(name):\n    return _PixelExpr(name, 2, 1)", "\ndef Pixel(name):\n    return _PixelExpr(name, 2, 1)\n\ndef Plane(name):\n    return _PlaneExpr(name, 4, 1)\n\ndef Scalar(name):\n    return symbols(name)\n\ndef Matrix3(name):\n    return _Matrix3Expr(name, 3, 3)", "\ndef Matrix3(name):\n    return _Matrix3Expr(name, 3, 3)\n\ndef LieAlgebra(name):\n    return _LieAlgebraExpr(name, 6, 1)\n\ndef LieGroup(name):\n    return _LieGroupExpr(name, 4, 4)\n\nclass _PointExpr(MatrixSymbol):\n    pass", "\nclass _PointExpr(MatrixSymbol):\n    pass\n\nclass _PointHExpr(MatrixSymbol):\n    pass\n\nclass _NormalExpr(MatrixSymbol):\n    pass\n\nclass _NormalHExpr(MatrixSymbol):\n    pass", "\nclass _NormalHExpr(MatrixSymbol):\n    pass\n\nclass _PixelExpr(MatrixSymbol):\n    pass\n\nclass _PlaneExpr(MatrixSymbol):\n    pass\n\nclass _Matrix3Expr(MatrixSymbol):\n    pass", "\nclass _Matrix3Expr(MatrixSymbol):\n    pass\n\nclass _LieAlgebraExpr(MatrixSymbol):\n    pass\n\nclass _LieGroupExpr(MatrixSymbol):\n    pass\n", "\n"]}
{"filename": "SymE3/detail.py", "chunked_list": ["from enum import Enum\n\nfrom sympy import symbols, tensorproduct, tensorcontraction, transpose, Function\nfrom sympy.tensor.array.dense_ndim_array import ImmutableDenseNDimArray\n\nclass _Type(Enum):\n    POINTH, NORMALH = range(2)\n\ndef _MatrixSym(prefix, R, C):\n    M = []\n    for r in range (0, R):\n        Row = []\n        for c in range (0, C):\n            name = '{{{0}_{{{1}{2}}}}}'.format(prefix, r if (R > 1) else '', c if (C > 1) else '' )\n            Row.append(symbols(name))\n        M.append(Row)\n    return M", "def _MatrixSym(prefix, R, C):\n    M = []\n    for r in range (0, R):\n        Row = []\n        for c in range (0, C):\n            name = '{{{0}_{{{1}{2}}}}}'.format(prefix, r if (R > 1) else '', c if (C > 1) else '' )\n            Row.append(symbols(name))\n        M.append(Row)\n    return M\n\ndef _PointH(name):\n    vector = _MatrixSym(name, 3, 1)\n    vector.append([1])\n    result = _Explicit(vector)\n    result.type = _Type.POINTH\n    return result", "\ndef _PointH(name):\n    vector = _MatrixSym(name, 3, 1)\n    vector.append([1])\n    result = _Explicit(vector)\n    result.type = _Type.POINTH\n    return result\n\ndef _NormalH(name):\n    vector = _MatrixSym(name, 3, 1)\n    vector.append([0])\n    result = _Explicit(vector)\n    result.type = _Type.NORMALH\n    return result", "def _NormalH(name):\n    vector = _MatrixSym(name, 3, 1)\n    vector.append([0])\n    result = _Explicit(vector)\n    result.type = _Type.NORMALH\n    return result\n\ndef _Point(name):\n    return _Explicit(_MatrixSym(name, 3, 1))\n\ndef _Normal(name):\n    return _Explicit(_MatrixSym(name, 3, 1))", "\ndef _Normal(name):\n    return _Explicit(_MatrixSym(name, 3, 1))\n\ndef _Pixel(name):\n    return _Explicit(_MatrixSym(name, 2, 1))\n\ndef _Plane(name):\n    return _Explicit(_MatrixSym(name, 4, 1))\n\ndef _Matrix3(name):\n    return _Explicit(_MatrixSym(name, 3, 3))", "\ndef _Matrix3(name):\n    return _Explicit(_MatrixSym(name, 3, 3))\n\ndef _LieAlgebra(name):\n    return _Explicit(_MatrixSym(name, 6, 1))\n\ndef _LieGroup(name):\n    syms = _MatrixSym(name, 4, 4)\n    syms[3][0] = 0\n    syms[3][1] = 0\n    syms[3][2] = 0\n    syms[3][3] = 1\n    return _Explicit(syms)", "\ndef _ExponentialMap(name):\n    def new(self, d):\n        assert d.shape == (6, 1)\n        return _Explicit([[       1, -d[5, 0],  d[4, 0], d[0, 0]], \n                          [ d[5, 0],        1, -d[3, 0], d[1, 0]], \n                          [-d[4, 0],  d[3, 0],        1, d[2, 0]], \n                          [       0,        0,        0,      1]])\n\n    exp = type(f\"exp_{name}\", (Function, ), {\"__new__\": new})\n\n    return exp;", "\nclass _Explicit(ImmutableDenseNDimArray):\n    def diff(self, *args, **kwargs):\n\n        if isinstance(args[0], list):\n            for symbol in args[0]:\n                if (isinstance(symbol, list) and (symbol[0] == 0 or symbol[0] == 1)) \\\n                        or (symbol == 0 or symbol == 1):\n                    print(\"Scalar detected in diff input, did you forget to dehom?\")\n\n        result = super().diff(*args, **kwargs)\n\n        if hasattr(args[0], \"rank\"):\n            # Catch the edge case where matrix differentiation doesn't work for some reason\n            if result.rank() != 4 and args[0].rank() == 2 and self.rank() == 2:\n                result = self.tomatrix().diff(args[0].tomatrix())\n\n        if result.rank() == 4 and result.shape[1] == 1 and result.shape[3] == 1:\n            result = tensorcontraction(result, (1, 3))\n\n        return _Explicit(result)\n\n    def __new__(cls, iterable, shape=None, **kwargs):\n        self = super().__new__(cls, iterable, shape, **kwargs)\n        self.type = None\n        return self\n\n    def __mul__(self, other):\n        result = _Explicit(tensorcontraction(tensorproduct(self, other), (1, 2)))\n\n        if hasattr(other, \"type\") and result.shape == (4, 1):\n            result.type = other.type\n\n        return result\n\n    def __rmul__(self, other):\n        result = _Explicit(super().__rmul__(other))\n\n        if hasattr(self, \"type\"):\n            if self.type == _Type.POINTH and result.shape == (4, 1):\n                explicit = result.tomatrix()\n                explicit[3, 0] = 1\n                result = _Explicit(explicit)\n                result.type = _Type.POINTH\n\n        return result\n\n    def __add__(self, other):\n        result = _Explicit(super().__add__(other))\n\n        if hasattr(self, \"type\") and hasattr(other, \"type\"):\n            assert self.type == other.type\n            \n            if self.type == _Type.POINTH:\n                explicit = result.tomatrix()\n                explicit[3, 0] = 1\n                result = _Explicit(explicit)\n                result.type = _Type.POINTH\n\n        return result\n\n    def transpose(self):\n        return _Explicit(transpose(self))\n\n    def inverse(self):\n        return _Explicit(self.tomatrix().inv())", "\n"]}
{"filename": "SymE3/parse.py", "chunked_list": ["class _ParsedToken:\n    def __init__(self, identifier):\n        self.identifier = identifier\n        self.children = []\n        \n    def hasChildren(self):\n        return len(self.children) > 0\n    \n    def addChild(self, child):\n        self.children.append(child)\n        \n    def removeChildrenFrom(self, parentId, childId):\n        if self.identifier == parentId:\n            self.children = [child for child in self.children if child.identifier != childId]\n        \n        for child in self.children:\n            child.removeChildrenFrom(parentId, childId)\n\n    def wrapChildrenOf(self, parentId, wrapId):\n        if self.identifier == parentId:\n            existingChildren = self.children\n            self.children = []\n            for child in existingChildren:\n                token = _ParsedToken(wrapId)\n                token.addChild(child)\n                self.addChild(token)\n\n        for child in self.children:\n            child.wrapChildrenOf(parentId, wrapId)\n         \n    def removeIdentifierPromoteChildren(self, id):\n        prevChildren = self.children\n        self.children = []\n\n        for child in prevChildren:\n            if child.identifier == id:\n                for grandchild in child.children:\n                    self.addChild(grandchild)\n            else:\n                self.addChild(child)\n\n        for child in self.children:\n            child.removeIdentifierPromoteChildren(id)\n\n    def renameIdentifier(self, src, dest):\n        if self.identifier == src:\n            self.identifier = dest\n            \n        for child in self.children:\n            child.renameIdentifier(src, dest)\n\n    def findIdentifiers(self, id, matches):\n        if self.identifier == id:\n            matches.append(self)\n\n        for child in self.children:\n            matches = child.findIdentifiers(id, matches)\n\n        return matches\n        \n    def reconstruct(self):\n        result = self.identifier\n        \n        if len(self.children) > 0:\n            result += \"(\"\n        \n        for i in range(0, len(self.children)):\n            result += self.children[i].reconstruct()\n            if i != len(self.children) - 1:\n                result += \", \"\n            \n        if len(self.children) > 0:\n            result += \")\"\n        \n        return result\n\n    def __repr__(self):\n        if len(self.children) > 0:\n            return f\"{self.identifier}:{self.children}\"\n        else:\n            return f\"{self.identifier}\"\n\n        \n    def __str__(self):\n        return self.__repr__()", "\ndef _scanForOpeningParenthesis(input):\n    idx = 0\n    \n    while idx < len(input):\n        if input[idx] == \"(\":\n            return idx\n        idx = idx + 1\n    \n    return -1", "\ndef _scanForClosingParenthesis(input):\n    stack = []\n    \n    idx = 0\n    while idx < len(input):\n        if input[idx] == \"(\":\n            stack.append(\"(\")\n        elif input[idx] == \")\" and stack[-1] == \"(\":\n            stack.pop()\n        if len(stack) == 0:\n            return idx\n        idx = idx + 1\n    \n    return -1", "\ndef _splitOnCommas(input):\n    result = []\n    lastStart = 0\n    stack = []\n    \n    idx = 0\n    while idx < len(input):\n        if input[idx] == \"(\":\n            stack.append(\"(\")\n        elif input[idx] == \")\" and stack[-1] == \"(\":\n            stack.pop()\n        if len(stack) == 0 and input[idx] == \",\":\n            result.append(input[lastStart:idx])\n            lastStart = idx + 1\n        idx = idx + 1\n    \n    result.append(input[lastStart:len(input)])\n    \n    return result", "    \ndef _parse(expression):\n    openingParenthesisIdx = _scanForOpeningParenthesis(expression)\n    closingParenthesisIdx = _scanForClosingParenthesis(expression[openingParenthesisIdx:]) + openingParenthesisIdx\n    \n    if (openingParenthesisIdx == -1 and closingParenthesisIdx == -1) \\\n            or (expression.startswith(\"'\") and expression.endswith(\"'\") and expression.count(\"'\") == 2 \\\n            and expression.count('\"') == 0) \\\n            or (expression.startswith('\"') and expression.endswith('\"') and expression.count('\"') == 2 \\\n            and expression.count(\"'\") == 0):\n        return _ParsedToken(expression)\n    \n    identifier = expression[0:openingParenthesisIdx]\n    \n    params = _splitOnCommas(expression[openingParenthesisIdx + 1:closingParenthesisIdx])\n\n    token = _ParsedToken(identifier)\n    \n    for param in params:\n        token.addChild(_parse(param.strip()))\n\n    assert token.reconstruct() == expression\n    \n    return token", "\n"]}
{"filename": "sophus/cse_codegen.py", "chunked_list": ["import io\n\nimport sympy\n\n\ndef cse_codegen(symbols):\n    cse_results = sympy.cse(symbols, sympy.numbered_symbols(\"c\"))\n    output = io.StringIO()\n    for helper in cse_results[0]:\n        output.write(\"Scalar const \")\n        output.write(sympy.printing.ccode(helper[1], helper[0]))\n        output.write(\"\\n\")\n    assert len(cse_results[1]) == 1\n\n    output.write(sympy.printing.ccode(cse_results[1][0], \"result\"))\n    output.write(\"\\n\")\n    output.seek(0)\n    return output", ""]}
{"filename": "sophus/so3.py", "chunked_list": ["import functools\nimport unittest\n\nimport sympy\n\nfrom sophus.cse_codegen import cse_codegen\nfrom sophus.matrix import Vector3\nfrom sophus.matrix import ZeroVector3\nfrom sophus.matrix import squared_norm\nfrom sophus.quaternion import Quaternion", "from sophus.matrix import squared_norm\nfrom sophus.quaternion import Quaternion\n\n\nclass So3:\n    \"\"\" 3 dimensional group of orthogonal matrices with determinant 1 \"\"\"\n\n    def __init__(self, q):\n        \"\"\" internally represented by a unit quaternion q \"\"\"\n        self.q = q\n\n    @staticmethod\n    def exp(v):\n        \"\"\" exponential map \"\"\"\n        theta_sq = squared_norm(v)\n        theta = sympy.sqrt(theta_sq)\n        return So3(\n            Quaternion(\n                sympy.cos(0.5 * theta),\n                sympy.sin(0.5 * theta) / theta * v))\n\n    def log(self):\n        \"\"\" logarithmic map\"\"\"\n        n = sympy.sqrt(squared_norm(self.q.vec))\n        return 2 * sympy.atan(n / self.q.real) / n * self.q.vec\n\n    def calc_Dx_log_this(self):\n        return sympy.Matrix(3, 3, lambda r, c: sympy.diff(self.log()[r],\n                                                          self[c]))\n\n    def calc_Dx_log_exp_x_times_this_at_0(self, x):\n        return sympy.Matrix(3, 3, lambda r, c:\n                            sympy.diff((So3.exp(x)*self).log()[r], x[c])).subs(\n                            x[0], 0).subs(x[1], 0).limit(x[2], 0)\n\n    def __repr__(self):\n        return \"So3:\" + repr(self.q)\n\n    def inverse(self):\n        return So3(self.q.conj())\n\n    @staticmethod\n    def hat(o):\n        return sympy.Matrix([[0, -o[2], o[1]],\n                             [o[2], 0, -o[0]],\n                             [-o[1], o[0], 0]])\n\n    \"\"\"vee-operator\n\n    It takes the 3x3-matrix representation ``Omega`` and maps it to the\n    corresponding vector representation of Lie algebra.\n\n    This is the inverse of the hat-operator, see above.\n\n    Precondition: ``Omega`` must have the following structure:\n\n                   |  0 -c  b |\n                   |  c  0 -a |\n                   | -b  a  0 |\n    \"\"\"\n    @staticmethod\n    def vee(Omega):\n        v = Vector3(Omega.row(2).col(1),\n                    Omega.row(0).col(2),\n                    Omega.row(1).col(0))\n        return v\n\n    def matrix(self):\n        \"\"\" returns matrix representation \"\"\"\n        return sympy.Matrix([[\n            1 - 2 * self.q.vec[1]**2 - 2 * self.q.vec[2]**2,\n            2 * self.q.vec[0] * self.q.vec[1] -\n            2 * self.q.vec[2] * self.q[3],\n            2 * self.q.vec[0] * self.q.vec[2] +\n            2 * self.q.vec[1] * self.q[3]\n        ], [\n            2 * self.q.vec[0] * self.q.vec[1] +\n            2 * self.q.vec[2] * self.q[3],\n            1 - 2 * self.q.vec[0]**2 - 2 * self.q.vec[2]**2,\n            2 * self.q.vec[1] * self.q.vec[2] -\n            2 * self.q.vec[0] * self.q[3]\n        ], [\n            2 * self.q.vec[0] * self.q.vec[2] -\n            2 * self.q.vec[1] * self.q[3],\n            2 * self.q.vec[1] * self.q.vec[2] +\n            2 * self.q.vec[0] * self.q[3],\n            1 - 2 * self.q.vec[0]**2 - 2 * self.q.vec[1]**2\n        ]])\n\n    def __mul__(self, right):\n        \"\"\" left-multiplication\n            either rotation concatenation or point-transform \"\"\"\n        if isinstance(right, sympy.Matrix):\n            assert right.shape == (3, 1), right.shape\n            return (self.q * Quaternion(0, right) * self.q.conj()).vec\n        elif isinstance(right, So3):\n            return So3(self.q * right.q)\n        assert False, \"unsupported type: {0}\".format(type(right))\n\n    def __getitem__(self, key):\n        return self.q[key]\n\n    @staticmethod\n    def calc_Dx_exp_x(x):\n        return sympy.Matrix(4, 3, lambda r, c:\n                            sympy.diff(So3.exp(x)[r], x[c]))\n\n    @staticmethod\n    def Dx_exp_x_at_0():\n        return sympy.Matrix([[0.5, 0.0, 0.0],\n                             [0.0, 0.5, 0.0],\n                             [0.0, 0.0, 0.5],\n                             [0.0, 0.0, 0.0]])\n\n    @staticmethod\n    def calc_Dx_exp_x_at_0(x):\n        return So3.calc_Dx_exp_x(x).subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)\n\n    def calc_Dx_this_mul_exp_x_at_0(self, x):\n        return sympy.Matrix(4, 3, lambda r, c:\n                            sympy.diff((self * So3.exp(x))[r], x[c]))\\\n            .subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)\n\n    def calc_Dx_exp_x_mul_this_at_0(self, x):\n        return sympy.Matrix(3, 4, lambda r, c:\n                            sympy.diff((self * So3.exp(x))[c], x[r, 0]))\\\n            .subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)\n\n    @staticmethod\n    def Dxi_x_matrix(x, i):\n        if i == 0:\n            return sympy.Matrix([[0, 2 * x[1], 2 * x[2]],\n                                 [2 * x[1], -4 * x[0], -2 * x[3]],\n                                 [2 * x[2], 2 * x[3], -4 * x[0]]])\n        if i == 1:\n            return sympy.Matrix([[-4 * x[1], 2 * x[0], 2 * x[3]],\n                                 [2 * x[0], 0, 2 * x[2]],\n                                 [-2 * x[3], 2 * x[2], -4 * x[1]]])\n        if i == 2:\n            return sympy.Matrix([[-4 * x[2], -2 * x[3], 2 * x[0]],\n                                 [2 * x[3], -4 * x[2], 2 * x[1]],\n                                 [2 * x[0], 2 * x[1], 0]])\n        if i == 3:\n            return sympy.Matrix([[0, -2 * x[2], 2 * x[1]],\n                                 [2 * x[2], 0, -2 * x[0]],\n                                 [-2 * x[1], 2 * x[0], 0]])\n\n    @staticmethod\n    def calc_Dxi_x_matrix(x, i):\n        return sympy.Matrix(3, 3, lambda r, c:\n                            sympy.diff(x.matrix()[r, c], x[i]))\n\n    @staticmethod\n    def Dxi_exp_x_matrix(x, i):\n        R = So3.exp(x)\n        Dx_exp_x = So3.calc_Dx_exp_x(x)\n        list = [Dx_exp_x[j, i] * So3.Dxi_x_matrix(R, j) for j in [0, 1, 2, 3]]\n        return functools.reduce((lambda a, b: a + b), list)\n\n    @staticmethod\n    def calc_Dxi_exp_x_matrix(x, i):\n        return sympy.Matrix(3, 3, lambda r, c:\n                            sympy.diff(So3.exp(x).matrix()[r, c], x[i]))\n\n    @staticmethod\n    def Dxi_exp_x_matrix_at_0(i):\n        v = ZeroVector3()\n        v[i] = 1\n        return So3.hat(v)\n\n    @staticmethod\n    def calc_Dxi_exp_x_matrix_at_0(x, i):\n        return sympy.Matrix(3, 3, lambda r, c:\n                            sympy.diff(So3.exp(x).matrix()[r, c], x[i])\n                            ).subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)", "\n\nclass TestSo3(unittest.TestCase):\n    def setUp(self):\n        omega0, omega1, omega2 = sympy.symbols(\n            'omega[0], omega[1], omega[2]', real=True)\n        x, v0, v1, v2 = sympy.symbols('q.w() q.x() q.y() q.z()', real=True)\n        p0, p1, p2 = sympy.symbols('p0 p1 p2', real=True)\n        v = Vector3(v0, v1, v2)\n        self.omega = Vector3(omega0, omega1, omega2)\n        self.a = So3(Quaternion(x, v))\n        self.p = Vector3(p0, p1, p2)\n\n    def test_exp_log(self):\n        for o in [Vector3(0., 1, 0.5),\n                  Vector3(0.1, 0.1, 0.1),\n                  Vector3(0.01, 0.2, 0.03)]:\n            w = So3.exp(o).log()\n            for i in range(0, 3):\n                self.assertAlmostEqual(o[i], w[i])\n\n    def test_matrix(self):\n        R_foo_bar = So3.exp(self.omega)\n        Rmat_foo_bar = R_foo_bar.matrix()\n        point_bar = self.p\n        p1_foo = R_foo_bar * point_bar\n        p2_foo = Rmat_foo_bar * point_bar\n        self.assertEqual(sympy.simplify(p1_foo - p2_foo),\n                         ZeroVector3())\n\n    def test_derivatives(self):\n        self.assertEqual(sympy.simplify(So3.calc_Dx_exp_x_at_0(self.omega) -\n                                        So3.Dx_exp_x_at_0()),\n                         sympy.Matrix.zeros(4, 3))\n\n        for i in [0, 1, 2, 3]:\n            self.assertEqual(sympy.simplify(So3.calc_Dxi_x_matrix(self.a, i) -\n                                            So3.Dxi_x_matrix(self.a, i)),\n                             sympy.Matrix.zeros(3, 3))\n        for i in [0, 1, 2]:\n            self.assertEqual(sympy.simplify(\n                So3.Dxi_exp_x_matrix(self.omega, i) -\n                So3.calc_Dxi_exp_x_matrix(self.omega, i)),\n                sympy.Matrix.zeros(3, 3))\n            self.assertEqual(sympy.simplify(\n                So3.Dxi_exp_x_matrix_at_0(i) -\n                So3.calc_Dxi_exp_x_matrix_at_0(self.omega, i)),\n                sympy.Matrix.zeros(3, 3))\n\n    def test_codegen(self):\n        stream = cse_codegen(So3.calc_Dx_exp_x(self.omega))\n        filename = \"cpp_gencode/So3_Dx_exp_x.cpp\"\n        # set to true to generate codegen files\n        if False:\n            file = open(filename, \"w\")\n            for line in stream:\n                file.write(line)\n            file.close()\n        else:\n            file = open(filename, \"r\")\n            file_lines = file.readlines()\n            for i, line in enumerate(stream):\n                self.assertEqual(line, file_lines[i])\n            file.close()\n        stream.close\n\n        stream = cse_codegen(\n            self.a.calc_Dx_this_mul_exp_x_at_0(self.omega))\n        filename = \"cpp_gencode/So3_Dx_this_mul_exp_x_at_0.cpp\"\n        # set to true to generate codegen files\n        if False:\n            file = open(filename, \"w\")\n            for line in stream:\n                file.write(line)\n            file.close()\n        else:\n            file = open(filename, \"r\")\n            file_lines = file.readlines()\n            for i, line in enumerate(stream):\n                self.assertEqual(line, file_lines[i])\n            file.close()\n        stream.close\n\n        stream = cse_codegen(self.a.calc_Dx_log_this())\n        filename = \"cpp_gencode/So3_Dx_log_this.cpp\"\n\n        # set to true to generate codegen files\n        if False:\n            file = open(filename, \"w\")\n            for line in stream:\n                file.write(line)\n            file.close()\n        else:\n            file = open(filename, \"r\")\n            file_lines = file.readlines()\n            for i, line in enumerate(stream):\n                self.assertEqual(line, file_lines[i])\n            file.close()\n        stream.close\n\n        stream = cse_codegen(self.a.calc_Dx_log_exp_x_times_this_at_0(\n                               self.omega))\n        filename = \"cpp_gencode/So3_Dx_log_exp_x_times_this_at_0.cpp\"\n\n        # set to true to generate codegen files\n        if False:\n            file = open(filename, \"w\")\n            for line in stream:\n                file.write(line)\n            file.close()\n        else:\n            file = open(filename, \"r\")\n            file_lines = file.readlines()\n            for i, line in enumerate(stream):\n                self.assertEqual(line, file_lines[i])\n            file.close()\n        stream.close", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "sophus/__init__.py", "chunked_list": [""]}
{"filename": "sophus/se2.py", "chunked_list": ["import functools\nimport unittest\n\nimport sympy\n\nfrom sophus.complex import Complex\nfrom sophus.cse_codegen import cse_codegen\nfrom sophus.matrix import Vector2\nfrom sophus.matrix import Vector3\nfrom sophus.matrix import ZeroVector2", "from sophus.matrix import Vector3\nfrom sophus.matrix import ZeroVector2\nfrom sophus.matrix import ZeroVector3\nfrom sophus.matrix import proj\nfrom sophus.matrix import unproj\nfrom sophus.so2 import So2\n\n\nclass Se2:\n    \"\"\" 2 dimensional group of rigid body transformations \"\"\"\n\n    def __init__(self, so2, t):\n        \"\"\" internally represented by a unit complex number z and a translation\n            2-vector \"\"\"\n        self.so2 = so2\n        self.t = t\n\n    @staticmethod\n    def exp(v):\n        \"\"\" exponential map \"\"\"\n        theta = v[2]\n        so2 = So2.exp(theta)\n\n        a = so2.z.imag / theta\n        b = (1 - so2.z.real) / theta\n\n        t = Vector2(a * v[0] - b * v[1],\n                    b * v[0] + a * v[1])\n        return Se2(so2, t)\n\n    def log(self):\n        theta = self.so2.log()\n        halftheta = 0.5 * theta\n        a = -(halftheta * self.so2.z.imag) / (self.so2.z.real - 1)\n\n        V_inv = sympy.Matrix([[a, halftheta],\n                              [-halftheta, a]])\n        upsilon = V_inv * self.t\n        return Vector3(upsilon[0], upsilon[1], theta)\n\n    def calc_Dx_log_this(self):\n        return sympy.Matrix(3, 4, lambda r, c: sympy.diff(self.log()[r],\n                            self[c]))\n\n    def __repr__(self):\n        return \"Se2: [\" + repr(self.so2) + \" \" + repr(self.t)\n\n    @staticmethod\n    def hat(v):\n        upsilon = Vector2(v[0], v[1])\n        theta = v[2]\n        return So2.hat(theta).\\\n            row_join(upsilon).\\\n            col_join(sympy.Matrix.zeros(1, 3))\n\n    def matrix(self):\n        \"\"\" returns matrix representation \"\"\"\n        R = self.so2.matrix()\n        return (R.row_join(self.t)).col_join(sympy.Matrix(1, 3, [0, 0, 1]))\n\n    def __mul__(self, right):\n        \"\"\" left-multiplication\n            either rotation concatenation or point-transform \"\"\"\n        if isinstance(right, sympy.Matrix):\n            assert right.shape == (2, 1), right.shape\n            return self.so2 * right + self.t\n        elif isinstance(right, Se2):\n            return Se2(self.so2 * right.so2,\n                       self.t + self.so2 * right.t)\n        assert False, \"unsupported type: {0}\".format(type(right))\n\n    def __getitem__(self, key):\n        \"\"\" We use the following convention [q0, q1, q2, q3, t0, t1, t2] \"\"\"\n        assert (key >= 0 and key < 4)\n        if key < 2:\n            return self.so2[key]\n        else:\n            return self.t[key - 2]\n\n    @staticmethod\n    def calc_Dx_exp_x(x):\n        return sympy.Matrix(4, 3, lambda r, c:\n                            sympy.diff(Se2.exp(x)[r], x[c]))\n\n    @staticmethod\n    def Dx_exp_x_at_0():\n        return sympy.Matrix([[0, 0, 0],\n                             [0, 0, 1],\n                             [1, 0, 0],\n                             [0, 1, 0]])\n\n    def calc_Dx_this_mul_exp_x_at_0(self, x):\n        return sympy.Matrix(4, 3, lambda r, c:\n                            sympy.diff((self * Se2.exp(x))[r], x[c])). \\\n            subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)\n\n    @staticmethod\n    def calc_Dx_exp_x_at_0(x):\n        return Se2.calc_Dx_exp_x(x).subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)\n\n    @staticmethod\n    def Dxi_x_matrix(x, i):\n        if i < 2:\n            return So2.Dxi_x_matrix(x, i).\\\n                row_join(sympy.Matrix.zeros(2, 1)).\\\n                col_join(sympy.Matrix.zeros(1, 3))\n        M = sympy.Matrix.zeros(3, 3)\n        M[i - 2, 2] = 1\n        return M\n\n    @staticmethod\n    def calc_Dxi_x_matrix(x, i):\n        return sympy.Matrix(3, 3, lambda r, c:\n                            sympy.diff(x.matrix()[r, c], x[i]))\n\n    @staticmethod\n    def Dxi_exp_x_matrix(x, i):\n        T = Se2.exp(x)\n        Dx_exp_x = Se2.calc_Dx_exp_x(x)\n        list = [Dx_exp_x[j, i] * Se2.Dxi_x_matrix(T, j) for j in range(0, 4)]\n        return functools.reduce((lambda a, b: a + b), list)\n\n    @staticmethod\n    def calc_Dxi_exp_x_matrix(x, i):\n        return sympy.Matrix(3, 3, lambda r, c:\n                            sympy.diff(Se2.exp(x).matrix()[r, c], x[i]))\n\n    @staticmethod\n    def Dxi_exp_x_matrix_at_0(i):\n        v = ZeroVector3()\n        v[i] = 1\n        return Se2.hat(v)\n\n    @staticmethod\n    def calc_Dxi_exp_x_matrix_at_0(x, i):\n        return sympy.Matrix(3, 3, lambda r, c:\n                            sympy.diff(Se2.exp(x).matrix()[r, c], x[i])\n                            ).subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)", "class Se2:\n    \"\"\" 2 dimensional group of rigid body transformations \"\"\"\n\n    def __init__(self, so2, t):\n        \"\"\" internally represented by a unit complex number z and a translation\n            2-vector \"\"\"\n        self.so2 = so2\n        self.t = t\n\n    @staticmethod\n    def exp(v):\n        \"\"\" exponential map \"\"\"\n        theta = v[2]\n        so2 = So2.exp(theta)\n\n        a = so2.z.imag / theta\n        b = (1 - so2.z.real) / theta\n\n        t = Vector2(a * v[0] - b * v[1],\n                    b * v[0] + a * v[1])\n        return Se2(so2, t)\n\n    def log(self):\n        theta = self.so2.log()\n        halftheta = 0.5 * theta\n        a = -(halftheta * self.so2.z.imag) / (self.so2.z.real - 1)\n\n        V_inv = sympy.Matrix([[a, halftheta],\n                              [-halftheta, a]])\n        upsilon = V_inv * self.t\n        return Vector3(upsilon[0], upsilon[1], theta)\n\n    def calc_Dx_log_this(self):\n        return sympy.Matrix(3, 4, lambda r, c: sympy.diff(self.log()[r],\n                            self[c]))\n\n    def __repr__(self):\n        return \"Se2: [\" + repr(self.so2) + \" \" + repr(self.t)\n\n    @staticmethod\n    def hat(v):\n        upsilon = Vector2(v[0], v[1])\n        theta = v[2]\n        return So2.hat(theta).\\\n            row_join(upsilon).\\\n            col_join(sympy.Matrix.zeros(1, 3))\n\n    def matrix(self):\n        \"\"\" returns matrix representation \"\"\"\n        R = self.so2.matrix()\n        return (R.row_join(self.t)).col_join(sympy.Matrix(1, 3, [0, 0, 1]))\n\n    def __mul__(self, right):\n        \"\"\" left-multiplication\n            either rotation concatenation or point-transform \"\"\"\n        if isinstance(right, sympy.Matrix):\n            assert right.shape == (2, 1), right.shape\n            return self.so2 * right + self.t\n        elif isinstance(right, Se2):\n            return Se2(self.so2 * right.so2,\n                       self.t + self.so2 * right.t)\n        assert False, \"unsupported type: {0}\".format(type(right))\n\n    def __getitem__(self, key):\n        \"\"\" We use the following convention [q0, q1, q2, q3, t0, t1, t2] \"\"\"\n        assert (key >= 0 and key < 4)\n        if key < 2:\n            return self.so2[key]\n        else:\n            return self.t[key - 2]\n\n    @staticmethod\n    def calc_Dx_exp_x(x):\n        return sympy.Matrix(4, 3, lambda r, c:\n                            sympy.diff(Se2.exp(x)[r], x[c]))\n\n    @staticmethod\n    def Dx_exp_x_at_0():\n        return sympy.Matrix([[0, 0, 0],\n                             [0, 0, 1],\n                             [1, 0, 0],\n                             [0, 1, 0]])\n\n    def calc_Dx_this_mul_exp_x_at_0(self, x):\n        return sympy.Matrix(4, 3, lambda r, c:\n                            sympy.diff((self * Se2.exp(x))[r], x[c])). \\\n            subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)\n\n    @staticmethod\n    def calc_Dx_exp_x_at_0(x):\n        return Se2.calc_Dx_exp_x(x).subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)\n\n    @staticmethod\n    def Dxi_x_matrix(x, i):\n        if i < 2:\n            return So2.Dxi_x_matrix(x, i).\\\n                row_join(sympy.Matrix.zeros(2, 1)).\\\n                col_join(sympy.Matrix.zeros(1, 3))\n        M = sympy.Matrix.zeros(3, 3)\n        M[i - 2, 2] = 1\n        return M\n\n    @staticmethod\n    def calc_Dxi_x_matrix(x, i):\n        return sympy.Matrix(3, 3, lambda r, c:\n                            sympy.diff(x.matrix()[r, c], x[i]))\n\n    @staticmethod\n    def Dxi_exp_x_matrix(x, i):\n        T = Se2.exp(x)\n        Dx_exp_x = Se2.calc_Dx_exp_x(x)\n        list = [Dx_exp_x[j, i] * Se2.Dxi_x_matrix(T, j) for j in range(0, 4)]\n        return functools.reduce((lambda a, b: a + b), list)\n\n    @staticmethod\n    def calc_Dxi_exp_x_matrix(x, i):\n        return sympy.Matrix(3, 3, lambda r, c:\n                            sympy.diff(Se2.exp(x).matrix()[r, c], x[i]))\n\n    @staticmethod\n    def Dxi_exp_x_matrix_at_0(i):\n        v = ZeroVector3()\n        v[i] = 1\n        return Se2.hat(v)\n\n    @staticmethod\n    def calc_Dxi_exp_x_matrix_at_0(x, i):\n        return sympy.Matrix(3, 3, lambda r, c:\n                            sympy.diff(Se2.exp(x).matrix()[r, c], x[i])\n                            ).subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)", "\n\nclass TestSe2(unittest.TestCase):\n    def setUp(self):\n        upsilon0, upsilon1, theta = sympy.symbols(\n            'upsilon[0], upsilon[1], theta',\n            real=True)\n        x, y = sympy.symbols('c[0] c[1]', real=True)\n        p0, p1 = sympy.symbols('p0 p1', real=True)\n        t0, t1 = sympy.symbols('t[0] t[1]', real=True)\n        self.upsilon_theta = Vector3(\n            upsilon0, upsilon1, theta)\n        self.t = Vector2(t0, t1)\n        self.a = Se2(So2(Complex(x, y)), self.t)\n        self.p = Vector2(p0, p1)\n\n    def test_exp_log(self):\n        for v in [Vector3(0., 1, 0.5),\n                  Vector3(0.1, 0.1, 0.1),\n                  Vector3(0.01, 0.2, 0.03)]:\n            w = Se2.exp(v).log()\n            for i in range(0, 3):\n                self.assertAlmostEqual(v[i], w[i])\n\n    def test_matrix(self):\n        T_foo_bar = Se2.exp(self.upsilon_theta)\n        Tmat_foo_bar = T_foo_bar.matrix()\n        point_bar = self.p\n        p1_foo = T_foo_bar * point_bar\n        p2_foo = proj(Tmat_foo_bar * unproj(point_bar))\n        self.assertEqual(sympy.simplify(p1_foo - p2_foo),\n                         ZeroVector2())\n\n    def test_derivatives(self):\n        self.assertEqual(sympy.simplify(\n            Se2.calc_Dx_exp_x_at_0(self.upsilon_theta) -\n            Se2.Dx_exp_x_at_0()),\n            sympy.Matrix.zeros(4, 3))\n        for i in range(0, 4):\n            self.assertEqual(sympy.simplify(Se2.calc_Dxi_x_matrix(self.a, i) -\n                                            Se2.Dxi_x_matrix(self.a, i)),\n                             sympy.Matrix.zeros(3, 3))\n        for i in range(0, 3):\n            self.assertEqual(sympy.simplify(\n                Se2.Dxi_exp_x_matrix(self.upsilon_theta, i) -\n                Se2.calc_Dxi_exp_x_matrix(self.upsilon_theta, i)),\n                sympy.Matrix.zeros(3, 3))\n            self.assertEqual(sympy.simplify(\n                Se2.Dxi_exp_x_matrix_at_0(i) -\n                Se2.calc_Dxi_exp_x_matrix_at_0(self.upsilon_theta, i)),\n                sympy.Matrix.zeros(3, 3))\n\n    def test_codegen(self):\n        stream = cse_codegen(Se2.calc_Dx_exp_x(self.upsilon_theta))\n        filename = \"cpp_gencode/Se2_Dx_exp_x.cpp\"\n\n        # set to true to generate codegen files\n        if False:\n            file = open(filename, \"w\")\n            for line in stream:\n                file.write(line)\n            file.close()\n        else:\n            file = open(filename, \"r\")\n            file_lines = file.readlines()\n            for i, line in enumerate(stream):\n                self.assertEqual(line, file_lines[i])\n            file.close()\n        stream.close\n\n        stream = cse_codegen(self.a.calc_Dx_this_mul_exp_x_at_0(\n            self.upsilon_theta))\n        filename = \"cpp_gencode/Se2_Dx_this_mul_exp_x_at_0.cpp\"\n        # set to true to generate codegen files\n        if False:\n            file = open(filename, \"w\")\n            for line in stream:\n                file.write(line)\n            file.close()\n        else:\n            file = open(filename, \"r\")\n            file_lines = file.readlines()\n            for i, line in enumerate(stream):\n                self.assertEqual(line, file_lines[i])\n            file.close()\n        stream.close\n\n        stream = cse_codegen(self.a.calc_Dx_log_this())\n        filename = \"cpp_gencode/Se2_Dx_log_this.cpp\"\n\n        # set to true to generate codegen files\n        if False:\n            file = open(filename, \"w\")\n            for line in stream:\n                file.write(line)\n            file.close()\n        else:\n            file = open(filename, \"r\")\n            file_lines = file.readlines()\n            for i, line in enumerate(stream):\n                self.assertEqual(line, file_lines[i])\n            file.close()\n        stream.close", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "sophus/so2.py", "chunked_list": ["import functools\nimport unittest\n\nimport sympy\n\nfrom sophus.complex import Complex\nfrom sophus.cse_codegen import cse_codegen\nfrom sophus.matrix import Vector2\nfrom sophus.matrix import ZeroVector2\n", "from sophus.matrix import ZeroVector2\n\n\nclass So2:\n    \"\"\" 2 dimensional group of orthogonal matrices with determinant 1 \"\"\"\n\n    def __init__(self, z):\n        \"\"\" internally represented by a unit complex number z \"\"\"\n        self.z = z\n\n    @staticmethod\n    def exp(theta):\n        \"\"\" exponential map \"\"\"\n        return So2(\n            Complex(\n                sympy.cos(theta),\n                sympy.sin(theta)))\n\n    def log(self):\n        \"\"\" logarithmic map\"\"\"\n        return sympy.atan2(self.z.imag, self.z.real)\n\n    def calc_Dx_log_this(self):\n        return sympy.diff(self.log(), self[0])\n\n    def calc_Dx_log_exp_x_times_this_at_0(self, x):\n        return sympy.diff((So2.exp(x)*self).log(), x).limit(x, 0)\n\n    def __repr__(self):\n        return \"So2:\" + repr(self.z)\n\n    @staticmethod\n    def hat(theta):\n        return sympy.Matrix([[0, -theta],\n                             [theta, 0]])\n\n    def matrix(self):\n        \"\"\" returns matrix representation \"\"\"\n        return sympy.Matrix([\n            [self.z.real, -self.z.imag],\n            [self.z.imag,  self.z.real]])\n\n    def __mul__(self, right):\n        \"\"\" left-multiplication\n            either rotation concatenation or point-transform \"\"\"\n        if isinstance(right, sympy.Matrix):\n            assert right.shape == (2, 1), right.shape\n            return self.matrix() * right\n        elif isinstance(right, So2):\n            return So2(self.z * right.z)\n        assert False, \"unsupported type: {0}\".format(type(right))\n\n    def __getitem__(self, key):\n        return self.z[key]\n\n    @staticmethod\n    def calc_Dx_exp_x(x):\n        return sympy.Matrix(2, 1, lambda r, c:\n                            sympy.diff(So2.exp(x)[r], x))\n\n    @staticmethod\n    def Dx_exp_x_at_0():\n        return sympy.Matrix([0, 1])\n\n    @staticmethod\n    def calc_Dx_exp_x_at_0(x):\n        return So2.calc_Dx_exp_x(x).limit(x, 0)\n\n    def calc_Dx_this_mul_exp_x_at_0(self, x):\n        return sympy.Matrix(2, 1, lambda r, c:\n                            sympy.diff((self * So2.exp(x))[r], x))\\\n            .limit(x, 0)\n\n    @staticmethod\n    def Dxi_x_matrix(x, i):\n        if i == 0:\n            return sympy.Matrix([[1, 0],\n                                 [0, 1]])\n        if i == 1:\n            return sympy.Matrix([[0, -1],\n                                 [1, 0]])\n\n    @staticmethod\n    def calc_Dxi_x_matrix(x, i):\n        return sympy.Matrix(2, 2, lambda r, c:\n                            sympy.diff(x.matrix()[r, c], x[i]))\n\n    @staticmethod\n    def Dx_exp_x_matrix(x):\n        R = So2.exp(x)\n        Dx_exp_x = So2.calc_Dx_exp_x(x)\n        list = [Dx_exp_x[j] * So2.Dxi_x_matrix(R, j) for j in [0, 1]]\n        return functools.reduce((lambda a, b: a + b), list)\n\n    @staticmethod\n    def calc_Dx_exp_x_matrix(x):\n        return sympy.Matrix(2, 2, lambda r, c:\n                            sympy.diff(So2.exp(x).matrix()[r, c], x))\n\n    @staticmethod\n    def Dx_exp_x_matrix_at_0():\n        return So2.hat(1)\n\n    @staticmethod\n    def calc_Dx_exp_x_matrix_at_0(x):\n        return sympy.Matrix(2, 2, lambda r, c:\n                            sympy.diff(So2.exp(x).matrix()[r, c], x)\n                            ).limit(x, 0)", "\n\nclass TestSo2(unittest.TestCase):\n    def setUp(self):\n        self.theta = sympy.symbols(\n            'theta', real=True)\n        x, y = sympy.symbols('c[0] c[1]', real=True)\n        p0, p1 = sympy.symbols('p0 p1', real=True)\n        self.a = So2(Complex(x, y))\n        self.p = Vector2(p0, p1)\n\n    def test_exp_log(self):\n        for theta in [0.,  0.5, 0.1]:\n            w = So2.exp(theta).log()\n            self.assertAlmostEqual(theta, w)\n\n    def test_matrix(self):\n        R_foo_bar = So2.exp(self.theta)\n        Rmat_foo_bar = R_foo_bar.matrix()\n        point_bar = self.p\n        p1_foo = R_foo_bar * point_bar\n        p2_foo = Rmat_foo_bar * point_bar\n        self.assertEqual(sympy.simplify(p1_foo - p2_foo),\n                         ZeroVector2())\n\n    def test_derivatives(self):\n        self.assertEqual(sympy.simplify(So2.calc_Dx_exp_x_at_0(self.theta) -\n                                        So2.Dx_exp_x_at_0()),\n                         sympy.Matrix.zeros(2, 1))\n        for i in [0, 1]:\n            self.assertEqual(sympy.simplify(So2.calc_Dxi_x_matrix(self.a, i) -\n                                            So2.Dxi_x_matrix(self.a, i)),\n                             sympy.Matrix.zeros(2, 2))\n\n        self.assertEqual(sympy.simplify(\n            So2.Dx_exp_x_matrix(self.theta) -\n            So2.calc_Dx_exp_x_matrix(self.theta)),\n            sympy.Matrix.zeros(2, 2))\n        self.assertEqual(sympy.simplify(\n            So2.Dx_exp_x_matrix_at_0() -\n            So2.calc_Dx_exp_x_matrix_at_0(self.theta)),\n            sympy.Matrix.zeros(2, 2))\n\n    def test_codegen(self):\n        stream = cse_codegen(So2.calc_Dx_exp_x(self.theta))\n        filename = \"cpp_gencode/So2_Dx_exp_x.cpp\"\n        # set to true to generate codegen files\n        if False:\n            file = open(filename, \"w\")\n            for line in stream:\n                file.write(line)\n            file.close()\n        else:\n            file = open(filename, \"r\")\n            file_lines = file.readlines()\n            for i, line in enumerate(stream):\n                self.assertEqual(line, file_lines[i])\n            file.close()\n        stream.close\n\n        stream = cse_codegen(\n            self.a.calc_Dx_this_mul_exp_x_at_0(self.theta))\n        filename = \"cpp_gencode/So2_Dx_this_mul_exp_x_at_0.cpp\"\n        # set to true to generate codegen files\n        if False:\n            file = open(filename, \"w\")\n            for line in stream:\n                file.write(line)\n            file.close()\n        else:\n            file = open(filename, \"r\")\n            file_lines = file.readlines()\n            for i, line in enumerate(stream):\n                self.assertEqual(line, file_lines[i])\n            file.close()\n        stream.close\n\n        stream = cse_codegen(self.a.calc_Dx_log_this())\n        filename = \"cpp_gencode/So2_Dx_log_this.cpp\"\n\n        # set to true to generate codegen files\n        if False:\n            file = open(filename, \"w\")\n            for line in stream:\n                file.write(line)\n            file.close()\n        else:\n            file = open(filename, \"r\")\n            file_lines = file.readlines()\n            for i, line in enumerate(stream):\n                self.assertEqual(line, file_lines[i])\n            file.close()\n        stream.close\n\n        stream = cse_codegen(self.a.calc_Dx_log_exp_x_times_this_at_0(\n            self.theta))\n        filename = \"cpp_gencode/So2_Dx_log_exp_x_times_this_at_0.cpp\"\n\n        # set to true to generate codegen files\n        if False:\n            file = open(filename, \"w\")\n            for line in stream:\n                file.write(line)\n            file.close()\n        else:\n            file = open(filename, \"r\")\n            file_lines = file.readlines()\n            for i, line in enumerate(stream):\n                self.assertEqual(line, file_lines[i])\n            file.close()\n        stream.close", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "sophus/matrix.py", "chunked_list": ["import sys\n\nimport sympy\n\nassert sys.version_info >= (3, 5)\n\n\ndef dot(left, right):\n    assert(isinstance(left, sympy.Matrix))\n    assert(isinstance(right, sympy.Matrix))\n\n    sum = 0\n    for c in range(0, left.cols):\n        for r in range(0, left.rows):\n            sum += left[r, c] * right[r, c]\n    return sum", "\n\ndef squared_norm(m):\n    assert(isinstance(m, sympy.Matrix))\n    return dot(m, m)\n\n\ndef Vector2(x, y):\n    return sympy.Matrix([x, y])\n", "\n\ndef ZeroVector2():\n    return Vector2(0, 0)\n\n\ndef Vector3(x, y, z):\n    return sympy.Matrix([x, y, z])\n\n\ndef ZeroVector3():\n    return Vector3(0, 0, 0)", "\n\ndef ZeroVector3():\n    return Vector3(0, 0, 0)\n\n\ndef Vector4(a, b, c, d):\n    return sympy.Matrix([a, b, c, d])\n\n\ndef ZeroVector4():\n    return Vector4(0, 0, 0, 0)", "\n\ndef ZeroVector4():\n    return Vector4(0, 0, 0, 0)\n\n\ndef Vector5(a, b, c, d, e):\n    return sympy.Matrix([a, b, c, d, e])\n\n\ndef ZeroVector5():\n    return Vector5(0, 0, 0, 0, 0)", "\n\ndef ZeroVector5():\n    return Vector5(0, 0, 0, 0, 0)\n\n\ndef Vector6(a, b, c, d, e, f):\n    return sympy.Matrix([a, b, c, d, e, f])\n\n\ndef ZeroVector6():\n    return Vector6(0, 0, 0, 0, 0, 0)", "\n\ndef ZeroVector6():\n    return Vector6(0, 0, 0, 0, 0, 0)\n\n\ndef proj(v):\n    m, n = v.shape\n    assert m > 1\n    assert n == 1\n    list = [v[i] / v[m - 1] for i in range(0, m - 1)]\n    r = sympy.Matrix(m - 1, 1,  list)\n    return r", "\n\ndef unproj(v):\n    m, n = v.shape\n    assert m >= 1\n    assert n == 1\n    return v.col_join(sympy.Matrix.ones(1, 1))\n"]}
{"filename": "sophus/se3.py", "chunked_list": ["import functools\nimport unittest\n\nimport sympy\n\nfrom sophus.cse_codegen import cse_codegen\nfrom sophus.matrix import Vector3\nfrom sophus.matrix import Vector6\nfrom sophus.matrix import ZeroVector3\nfrom sophus.matrix import ZeroVector6", "from sophus.matrix import ZeroVector3\nfrom sophus.matrix import ZeroVector6\nfrom sophus.matrix import proj\nfrom sophus.matrix import squared_norm\nfrom sophus.matrix import unproj\nfrom sophus.quaternion import Quaternion\nfrom sophus.so3 import So3\n\n\nclass Se3:\n    \"\"\" 3 dimensional group of rigid body transformations \"\"\"\n\n    def __init__(self, so3, t):\n        \"\"\" internally represented by a unit quaternion q and a translation\n            3-vector \"\"\"\n        assert isinstance(so3, So3)\n        assert isinstance(t, sympy.Matrix)\n        assert t.shape == (3, 1), t.shape\n\n        self.so3 = so3\n        self.t = t\n\n    @staticmethod\n    def exp(v):\n        \"\"\" exponential map \"\"\"\n        upsilon = v[0:3, :]\n        omega = Vector3(v[3], v[4], v[5])\n        so3 = So3.exp(omega)\n        Omega = So3.hat(omega)\n        Omega_sq = Omega * Omega\n        theta = sympy.sqrt(squared_norm(omega))\n        V = (sympy.Matrix.eye(3) +\n             (1 - sympy.cos(theta)) / (theta**2) * Omega +\n             (theta - sympy.sin(theta)) / (theta**3) * Omega_sq)\n        return Se3(so3, V * upsilon)\n\n    def log(self):\n\n        omega = self.so3.log()\n        theta = sympy.sqrt(squared_norm(omega))\n        Omega = So3.hat(omega)\n\n        half_theta = 0.5 * theta\n\n        V_inv = sympy.Matrix.eye(3) - 0.5 * Omega + (1 - theta * sympy.cos(\n            half_theta) / (2 * sympy.sin(half_theta))) / (theta * theta) *\\\n            (Omega * Omega)\n        upsilon = V_inv * self.t\n        return upsilon.col_join(omega)\n\n    def calc_Dx_log_this(self):\n        return sympy.Matrix(6, 7, lambda r, c: sympy.diff(self.log()[r],\n                            self[c]))\n\n    def __repr__(self):\n        return \"Se3: [\" + repr(self.so3) + \" \" + repr(self.t)\n\n    def inverse(self):\n        invR = self.so3.inverse()\n        return Se3(invR, invR * (-1 * self.t))\n\n    @staticmethod\n    def hat(v):\n        \"\"\" R^6 => R^4x4  \"\"\"\n        \"\"\" returns 4x4-matrix representation ``Omega`` \"\"\"\n        upsilon = Vector3(v[0], v[1], v[2])\n        omega = Vector3(v[3], v[4], v[5])\n        return So3.hat(omega).\\\n            row_join(upsilon).\\\n            col_join(sympy.Matrix.zeros(1, 4))\n\n    @staticmethod\n    def vee(Omega):\n        \"\"\" R^4x4 => R^6 \"\"\"\n        \"\"\" returns 6-vector representation of Lie algebra \"\"\"\n        \"\"\" This is the inverse of the hat-operator \"\"\"\n\n        head = Vector3(Omega[0, 3], Omega[1, 3], Omega[2, 3])\n        tail = So3.vee(Omega[0:3, 0:3])\n        upsilon_omega = \\\n            Vector6(head[0], head[1], head[2], tail[0], tail[1], tail[2])\n        return upsilon_omega\n\n    def matrix(self):\n        \"\"\" returns matrix representation \"\"\"\n        R = self.so3.matrix()\n        return (R.row_join(self.t)).col_join(sympy.Matrix(1, 4, [0, 0, 0, 1]))\n\n    def __mul__(self, right):\n        \"\"\" left-multiplication\n            either rotation concatenation or point-transform \"\"\"\n        if isinstance(right, sympy.Matrix):\n            assert right.shape == (3, 1), right.shape\n            return self.so3 * right + self.t\n        elif isinstance(right, Se3):\n            r = self.so3 * right.so3\n            t = self.t + self.so3 * right.t\n            return Se3(r, t)\n        assert False, \"unsupported type: {0}\".format(type(right))\n\n    def __getitem__(self, key):\n        \"\"\" We use the following convention [q0, q1, q2, q3, t0, t1, t2] \"\"\"\n        assert (key >= 0 and key < 7)\n        if key < 4:\n            return self.so3[key]\n        else:\n            return self.t[key - 4]\n\n    @staticmethod\n    def calc_Dx_exp_x(x):\n        return sympy.Matrix(7, 6, lambda r, c:\n                            sympy.diff(Se3.exp(x)[r], x[c]))\n\n    @staticmethod\n    def Dx_exp_x_at_0():\n        return sympy.Matrix([[0.0, 0.0, 0.0, 0.5, 0.0, 0.0],\n                             [0.0, 0.0, 0.0, 0.0, 0.5, 0.0],\n                             [0.0, 0.0, 0.0, 0.0, 0.0, 0.5],\n                             [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                             [1.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                             [0.0, 1.0, 0.0, 0.0, 0.0, 0.0],\n                             [0.0, 0.0, 1.0, 0.0, 0.0, 0.0]])\n\n    def calc_Dx_this_mul_exp_x_at_0(self, x):\n        return sympy.Matrix(7, 6, lambda r, c:\n                            sympy.diff((self * Se3.exp(x))[r], x[c])). \\\n            subs(x[0], 0).subs(x[1], 0).subs(x[2], 0).\\\n            subs(x[3], 0).subs(x[4], 0).limit(x[5], 0)\n\n    @staticmethod\n    def calc_Dx_exp_x_at_0(x):\n        return Se3.calc_Dx_exp_x(x).subs(x[0], 0).subs(x[1], 0).subs(x[2], 0).\\\n            subs(x[3], 0).subs(x[4], 0).limit(x[5], 0)\n\n    @staticmethod\n    def Dxi_x_matrix(x, i):\n        if i < 4:\n            return So3.Dxi_x_matrix(x, i).\\\n                row_join(sympy.Matrix.zeros(3, 1)).\\\n                col_join(sympy.Matrix.zeros(1, 4))\n        M = sympy.Matrix.zeros(4, 4)\n        M[i - 4, 3] = 1\n        return M\n\n    @staticmethod\n    def calc_Dxi_x_matrix(x, i):\n        return sympy.Matrix(4, 4, lambda r, c:\n                            sympy.diff(x.matrix()[r, c], x[i]))\n\n    @staticmethod\n    def Dxi_exp_x_matrix(x, i):\n        T = Se3.exp(x)\n        Dx_exp_x = Se3.calc_Dx_exp_x(x)\n        list = [Dx_exp_x[j, i] * Se3.Dxi_x_matrix(T, j) for j in range(0, 7)]\n        return functools.reduce((lambda a, b: a + b), list)\n\n    @staticmethod\n    def calc_Dxi_exp_x_matrix(x, i):\n        return sympy.Matrix(4, 4, lambda r, c:\n                            sympy.diff(Se3.exp(x).matrix()[r, c], x[i]))\n\n    @staticmethod\n    def Dxi_exp_x_matrix_at_0(i):\n        v = ZeroVector6()\n        v[i] = 1\n        return Se3.hat(v)\n\n    @staticmethod\n    def calc_Dxi_exp_x_matrix_at_0(x, i):\n        return sympy.Matrix(4, 4, lambda r, c:\n                            sympy.diff(Se3.exp(x).matrix()[r, c], x[i])\n                            ).subs(x[0], 0).subs(x[1], 0).subs(x[2], 0).\\\n            subs(x[3], 0).subs(x[4], 0).limit(x[5], 0)", "\nclass Se3:\n    \"\"\" 3 dimensional group of rigid body transformations \"\"\"\n\n    def __init__(self, so3, t):\n        \"\"\" internally represented by a unit quaternion q and a translation\n            3-vector \"\"\"\n        assert isinstance(so3, So3)\n        assert isinstance(t, sympy.Matrix)\n        assert t.shape == (3, 1), t.shape\n\n        self.so3 = so3\n        self.t = t\n\n    @staticmethod\n    def exp(v):\n        \"\"\" exponential map \"\"\"\n        upsilon = v[0:3, :]\n        omega = Vector3(v[3], v[4], v[5])\n        so3 = So3.exp(omega)\n        Omega = So3.hat(omega)\n        Omega_sq = Omega * Omega\n        theta = sympy.sqrt(squared_norm(omega))\n        V = (sympy.Matrix.eye(3) +\n             (1 - sympy.cos(theta)) / (theta**2) * Omega +\n             (theta - sympy.sin(theta)) / (theta**3) * Omega_sq)\n        return Se3(so3, V * upsilon)\n\n    def log(self):\n\n        omega = self.so3.log()\n        theta = sympy.sqrt(squared_norm(omega))\n        Omega = So3.hat(omega)\n\n        half_theta = 0.5 * theta\n\n        V_inv = sympy.Matrix.eye(3) - 0.5 * Omega + (1 - theta * sympy.cos(\n            half_theta) / (2 * sympy.sin(half_theta))) / (theta * theta) *\\\n            (Omega * Omega)\n        upsilon = V_inv * self.t\n        return upsilon.col_join(omega)\n\n    def calc_Dx_log_this(self):\n        return sympy.Matrix(6, 7, lambda r, c: sympy.diff(self.log()[r],\n                            self[c]))\n\n    def __repr__(self):\n        return \"Se3: [\" + repr(self.so3) + \" \" + repr(self.t)\n\n    def inverse(self):\n        invR = self.so3.inverse()\n        return Se3(invR, invR * (-1 * self.t))\n\n    @staticmethod\n    def hat(v):\n        \"\"\" R^6 => R^4x4  \"\"\"\n        \"\"\" returns 4x4-matrix representation ``Omega`` \"\"\"\n        upsilon = Vector3(v[0], v[1], v[2])\n        omega = Vector3(v[3], v[4], v[5])\n        return So3.hat(omega).\\\n            row_join(upsilon).\\\n            col_join(sympy.Matrix.zeros(1, 4))\n\n    @staticmethod\n    def vee(Omega):\n        \"\"\" R^4x4 => R^6 \"\"\"\n        \"\"\" returns 6-vector representation of Lie algebra \"\"\"\n        \"\"\" This is the inverse of the hat-operator \"\"\"\n\n        head = Vector3(Omega[0, 3], Omega[1, 3], Omega[2, 3])\n        tail = So3.vee(Omega[0:3, 0:3])\n        upsilon_omega = \\\n            Vector6(head[0], head[1], head[2], tail[0], tail[1], tail[2])\n        return upsilon_omega\n\n    def matrix(self):\n        \"\"\" returns matrix representation \"\"\"\n        R = self.so3.matrix()\n        return (R.row_join(self.t)).col_join(sympy.Matrix(1, 4, [0, 0, 0, 1]))\n\n    def __mul__(self, right):\n        \"\"\" left-multiplication\n            either rotation concatenation or point-transform \"\"\"\n        if isinstance(right, sympy.Matrix):\n            assert right.shape == (3, 1), right.shape\n            return self.so3 * right + self.t\n        elif isinstance(right, Se3):\n            r = self.so3 * right.so3\n            t = self.t + self.so3 * right.t\n            return Se3(r, t)\n        assert False, \"unsupported type: {0}\".format(type(right))\n\n    def __getitem__(self, key):\n        \"\"\" We use the following convention [q0, q1, q2, q3, t0, t1, t2] \"\"\"\n        assert (key >= 0 and key < 7)\n        if key < 4:\n            return self.so3[key]\n        else:\n            return self.t[key - 4]\n\n    @staticmethod\n    def calc_Dx_exp_x(x):\n        return sympy.Matrix(7, 6, lambda r, c:\n                            sympy.diff(Se3.exp(x)[r], x[c]))\n\n    @staticmethod\n    def Dx_exp_x_at_0():\n        return sympy.Matrix([[0.0, 0.0, 0.0, 0.5, 0.0, 0.0],\n                             [0.0, 0.0, 0.0, 0.0, 0.5, 0.0],\n                             [0.0, 0.0, 0.0, 0.0, 0.0, 0.5],\n                             [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                             [1.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                             [0.0, 1.0, 0.0, 0.0, 0.0, 0.0],\n                             [0.0, 0.0, 1.0, 0.0, 0.0, 0.0]])\n\n    def calc_Dx_this_mul_exp_x_at_0(self, x):\n        return sympy.Matrix(7, 6, lambda r, c:\n                            sympy.diff((self * Se3.exp(x))[r], x[c])). \\\n            subs(x[0], 0).subs(x[1], 0).subs(x[2], 0).\\\n            subs(x[3], 0).subs(x[4], 0).limit(x[5], 0)\n\n    @staticmethod\n    def calc_Dx_exp_x_at_0(x):\n        return Se3.calc_Dx_exp_x(x).subs(x[0], 0).subs(x[1], 0).subs(x[2], 0).\\\n            subs(x[3], 0).subs(x[4], 0).limit(x[5], 0)\n\n    @staticmethod\n    def Dxi_x_matrix(x, i):\n        if i < 4:\n            return So3.Dxi_x_matrix(x, i).\\\n                row_join(sympy.Matrix.zeros(3, 1)).\\\n                col_join(sympy.Matrix.zeros(1, 4))\n        M = sympy.Matrix.zeros(4, 4)\n        M[i - 4, 3] = 1\n        return M\n\n    @staticmethod\n    def calc_Dxi_x_matrix(x, i):\n        return sympy.Matrix(4, 4, lambda r, c:\n                            sympy.diff(x.matrix()[r, c], x[i]))\n\n    @staticmethod\n    def Dxi_exp_x_matrix(x, i):\n        T = Se3.exp(x)\n        Dx_exp_x = Se3.calc_Dx_exp_x(x)\n        list = [Dx_exp_x[j, i] * Se3.Dxi_x_matrix(T, j) for j in range(0, 7)]\n        return functools.reduce((lambda a, b: a + b), list)\n\n    @staticmethod\n    def calc_Dxi_exp_x_matrix(x, i):\n        return sympy.Matrix(4, 4, lambda r, c:\n                            sympy.diff(Se3.exp(x).matrix()[r, c], x[i]))\n\n    @staticmethod\n    def Dxi_exp_x_matrix_at_0(i):\n        v = ZeroVector6()\n        v[i] = 1\n        return Se3.hat(v)\n\n    @staticmethod\n    def calc_Dxi_exp_x_matrix_at_0(x, i):\n        return sympy.Matrix(4, 4, lambda r, c:\n                            sympy.diff(Se3.exp(x).matrix()[r, c], x[i])\n                            ).subs(x[0], 0).subs(x[1], 0).subs(x[2], 0).\\\n            subs(x[3], 0).subs(x[4], 0).limit(x[5], 0)", "\n\nclass TestSe3(unittest.TestCase):\n    def setUp(self):\n        upsilon0, upsilon1, upsilon2, omega0, omega1, omega2 = sympy.symbols(\n            'upsilon[0], upsilon[1], upsilon[2], omega[0], omega[1], omega[2]',\n            real=True)\n        x, v0, v1, v2 = sympy.symbols('q.w() q.x() q.y() q.z()', real=True)\n        p0, p1, p2 = sympy.symbols('p0 p1 p2', real=True)\n        t0, t1, t2 = sympy.symbols('t[0] t[1] t[2]', real=True)\n        v = Vector3(v0, v1, v2)\n        self.upsilon_omega = Vector6(\n            upsilon0, upsilon1, upsilon2, omega0, omega1, omega2)\n        self.t = Vector3(t0, t1, t2)\n        self.a = Se3(So3(Quaternion(x, v)), self.t)\n        self.p = Vector3(p0, p1, p2)\n\n    def test_exp_log(self):\n        for v in [Vector6(0., 1, 0.5, 2., 1, 0.5),\n                  Vector6(0.1, 0.1, 0.1, 0., 1, 0.5),\n                  Vector6(0.01, 0.2, 0.03, 0.01, 0.2, 0.03)]:\n            w = Se3.exp(v).log()\n            for i in range(0, 3):\n                self.assertAlmostEqual(v[i], w[i])\n\n    def test_matrix(self):\n        T_foo_bar = Se3.exp(self.upsilon_omega)\n        Tmat_foo_bar = T_foo_bar.matrix()\n        point_bar = self.p\n        p1_foo = T_foo_bar * point_bar\n        p2_foo = proj(Tmat_foo_bar * unproj(point_bar))\n        self.assertEqual(sympy.simplify(p1_foo - p2_foo),\n                         ZeroVector3())\n\n    def test_derivatives(self):\n        self.assertEqual(sympy.simplify(\n            Se3.calc_Dx_exp_x_at_0(self.upsilon_omega) -\n            Se3.Dx_exp_x_at_0()),\n            sympy.Matrix.zeros(7, 6))\n\n        for i in range(0, 7):\n            self.assertEqual(sympy.simplify(Se3.calc_Dxi_x_matrix(self.a, i) -\n                                            Se3.Dxi_x_matrix(self.a, i)),\n                             sympy.Matrix.zeros(4, 4))\n        for i in range(0, 6):\n            self.assertEqual(sympy.simplify(\n                Se3.Dxi_exp_x_matrix(self.upsilon_omega, i) -\n                Se3.calc_Dxi_exp_x_matrix(self.upsilon_omega, i)),\n                sympy.Matrix.zeros(4, 4))\n            self.assertEqual(sympy.simplify(\n                Se3.Dxi_exp_x_matrix_at_0(i) -\n                Se3.calc_Dxi_exp_x_matrix_at_0(self.upsilon_omega, i)),\n                sympy.Matrix.zeros(4, 4))\n\n    def test_codegen(self):\n        stream = cse_codegen(self.a.calc_Dx_exp_x(self.upsilon_omega))\n        filename = \"cpp_gencode/Se3_Dx_exp_x.cpp\"\n        # set to true to generate codegen files\n        if False:\n            file = open(filename, \"w\")\n            for line in stream:\n                file.write(line)\n            file.close()\n        else:\n            file = open(filename, \"r\")\n            file_lines = file.readlines()\n            for i, line in enumerate(stream):\n                self.assertEqual(line, file_lines[i])\n            file.close()\n        stream.close\n\n        stream = cse_codegen(self.a.calc_Dx_this_mul_exp_x_at_0(\n            self.upsilon_omega))\n        filename = \"cpp_gencode/Se3_Dx_this_mul_exp_x_at_0.cpp\"\n        # set to true to generate codegen files\n        if False:\n            file = open(filename, \"w\")\n            for line in stream:\n                file.write(line)\n            file.close()\n        else:\n            file = open(filename, \"r\")\n            file_lines = file.readlines()\n            for i, line in enumerate(stream):\n                self.assertEqual(line, file_lines[i])\n            file.close()\n        stream.close\n\n        stream = cse_codegen(self.a.calc_Dx_log_this())\n        filename = \"cpp_gencode/Se3_Dx_log_this.cpp\"\n\n        # set to true to generate codegen files\n        if False:\n            file = open(filename, \"w\")\n            for line in stream:\n                file.write(line)\n            file.close()\n        else:\n            file = open(filename, \"r\")\n            file_lines = file.readlines()\n            for i, line in enumerate(stream):\n                self.assertEqual(line, file_lines[i])\n            file.close()\n        stream.close", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "sophus/dual_quaternion.py", "chunked_list": ["import unittest\n\nimport sympy\n\nfrom sophus.matrix import Vector3\nfrom sophus.quaternion import Quaternion\n\n\nclass DualQuaternion:\n    \"\"\" Dual quaternion class \"\"\"\n\n    def __init__(self, real_q, inf_q):\n        \"\"\" Dual quaternion consists of a real quaternion, and an infinitesimal\n            quaternion \"\"\"\n        self.real_q = real_q\n        self.inf_q = inf_q\n\n    def __mul__(self, right):\n        \"\"\" dual quaternion multiplication \"\"\"\n        return DualQuaternion(self.real_q * right.real_q,\n                              self.real_q * right.inf_q +\n                              self.inf_q * right.real_q)\n\n    def __truediv__(self, scalar):\n        \"\"\" scalar division \"\"\"\n        return DualQuaternion(self.real_q / scalar, self.inf_q / scalar)\n\n    def __repr__(self):\n        return \"( \" + repr(self.real_q) + \\\n               \" + \" + repr(self.inf_q) + \")\"\n\n    def __getitem__(self, key):\n        assert (key >= 0 and key < 8)\n        if key < 4:\n            return self.real_q[key]\n        else:\n            return self.inf_q[key - 4]\n\n    def squared_norm(self):\n        \"\"\" squared norm when considering the dual quaternion as 8-tuple \"\"\"\n        return self.real_q.squared_norm() + self.inf_q.squared_norm()\n\n    def conj(self):\n        \"\"\" dual quaternion conjugate \"\"\"\n        return DualQuaternion(self.real_q.conj(), self.inf_q.conj())\n\n    def inv(self):\n        \"\"\" dual quaternion inverse \"\"\"\n        return DualQuaternion(self.real_q.inv(),\n                              -self.real_q.inv() * self.inf_q *\n                              self.real_q.inv())\n\n    def simplify(self):\n        return DualQuaternion(self.real_q.simplify(),\n                              self.inf_q.simplify())\n\n    @staticmethod\n    def identity():\n        return DualQuaternion(Quaternion.identity(),\n                              Quaternion.zero())\n\n    def __eq__(self, other):\n        if isinstance(self, other.__class__):\n            return self.real_q == other.real_q and self.inf_q == other.inf_q\n        return False", "class DualQuaternion:\n    \"\"\" Dual quaternion class \"\"\"\n\n    def __init__(self, real_q, inf_q):\n        \"\"\" Dual quaternion consists of a real quaternion, and an infinitesimal\n            quaternion \"\"\"\n        self.real_q = real_q\n        self.inf_q = inf_q\n\n    def __mul__(self, right):\n        \"\"\" dual quaternion multiplication \"\"\"\n        return DualQuaternion(self.real_q * right.real_q,\n                              self.real_q * right.inf_q +\n                              self.inf_q * right.real_q)\n\n    def __truediv__(self, scalar):\n        \"\"\" scalar division \"\"\"\n        return DualQuaternion(self.real_q / scalar, self.inf_q / scalar)\n\n    def __repr__(self):\n        return \"( \" + repr(self.real_q) + \\\n               \" + \" + repr(self.inf_q) + \")\"\n\n    def __getitem__(self, key):\n        assert (key >= 0 and key < 8)\n        if key < 4:\n            return self.real_q[key]\n        else:\n            return self.inf_q[key - 4]\n\n    def squared_norm(self):\n        \"\"\" squared norm when considering the dual quaternion as 8-tuple \"\"\"\n        return self.real_q.squared_norm() + self.inf_q.squared_norm()\n\n    def conj(self):\n        \"\"\" dual quaternion conjugate \"\"\"\n        return DualQuaternion(self.real_q.conj(), self.inf_q.conj())\n\n    def inv(self):\n        \"\"\" dual quaternion inverse \"\"\"\n        return DualQuaternion(self.real_q.inv(),\n                              -self.real_q.inv() * self.inf_q *\n                              self.real_q.inv())\n\n    def simplify(self):\n        return DualQuaternion(self.real_q.simplify(),\n                              self.inf_q.simplify())\n\n    @staticmethod\n    def identity():\n        return DualQuaternion(Quaternion.identity(),\n                              Quaternion.zero())\n\n    def __eq__(self, other):\n        if isinstance(self, other.__class__):\n            return self.real_q == other.real_q and self.inf_q == other.inf_q\n        return False", "\n\nclass TestDualQuaternion(unittest.TestCase):\n    def setUp(self):\n        w, s0, s1, s2 = sympy.symbols('w s0 s1 s2', real=True)\n        x, t0, t1, t2 = sympy.symbols('x t0 t1 t2', real=True)\n        y, u0, u1, u2 = sympy.symbols('y u0 u1 u2', real=True)\n        z, v0, v1, v2 = sympy.symbols('z v0 v1 v2', real=True)\n\n        s = Vector3(s0, s1, s2)\n        t = Vector3(t0, t1, t2)\n        u = Vector3(u0, u1, u2)\n        v = Vector3(v0, v1, v2)\n        self.a = DualQuaternion(Quaternion(w, s),\n                                Quaternion(x, t))\n        self.b = DualQuaternion(Quaternion(y, u),\n                                Quaternion(z, v))\n\n    def test_muliplications(self):\n        product = self.a * self.a.inv()\n        self.assertEqual(product.simplify(),\n                         DualQuaternion.identity())\n        product = self.a.inv() * self.a\n        self.assertEqual(product.simplify(),\n                         DualQuaternion.identity())", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "sophus/quaternion.py", "chunked_list": ["\"\"\" run with: python3 -m sophus.quaternion \"\"\"\n\nimport unittest\n\nimport sympy\n\nfrom sophus.matrix import Vector3\nfrom sophus.matrix import squared_norm\n\n\nclass Quaternion:\n    \"\"\" Quaternion class \"\"\"\n\n    def __init__(self, real, vec):\n        \"\"\" Quaternion consists of a real scalar, and an imaginary 3-vector \"\"\"\n        assert isinstance(vec, sympy.Matrix)\n        assert vec.shape == (3, 1), vec.shape\n        self.real = real\n        self.vec = vec\n\n    def __mul__(self, right):\n        \"\"\" quaternion multiplication \"\"\"\n        return Quaternion(self[3] * right[3] - self.vec.dot(right.vec),\n                          self[3] * right.vec + right[3] * self.vec +\n                          self.vec.cross(right.vec))\n\n    def __add__(self, right):\n        \"\"\" quaternion multiplication \"\"\"\n        return Quaternion(self[3] + right[3], self.vec + right.vec)\n\n    def __neg__(self):\n        return Quaternion(-self[3], -self.vec)\n\n    def __truediv__(self, scalar):\n        \"\"\" scalar division \"\"\"\n        return Quaternion(self.real / scalar, self.vec / scalar)\n\n    def __repr__(self):\n        return \"( \" + repr(self[3]) + \" + \" + repr(self.vec) + \"i )\"\n\n    def __getitem__(self, key):\n        \"\"\" We use the following convention [vec0, vec1, vec2, real] \"\"\"\n        assert (key >= 0 and key < 4)\n        if key == 3:\n            return self.real\n        else:\n            return self.vec[key]\n\n    def squared_norm(self):\n        \"\"\" squared norm when considering the quaternion as 4-tuple \"\"\"\n        return squared_norm(self.vec) + self.real**2\n\n    def conj(self):\n        \"\"\" quaternion conjugate \"\"\"\n        return Quaternion(self.real, -self.vec)\n\n    def inv(self):\n        \"\"\" quaternion inverse \"\"\"\n        return self.conj() / self.squared_norm()\n\n    @staticmethod\n    def identity():\n        return Quaternion(1, Vector3(0, 0, 0))\n\n    @staticmethod\n    def zero():\n        return Quaternion(0, Vector3(0, 0, 0))\n\n    def subs(self, x, y):\n        return Quaternion(self.real.subs(x, y), self.vec.subs(x, y))\n\n    def simplify(self):\n        v = sympy.simplify(self.vec)\n        return Quaternion(sympy.simplify(self.real),\n                          Vector3(v[0], v[1], v[2]))\n\n    def __eq__(self, other):\n        if isinstance(self, other.__class__):\n            return self.real == other.real and self.vec == other.vec\n        return False\n\n    @staticmethod\n    def Da_a_mul_b(a, b):\n        \"\"\" derivatice of quaternion muliplication wrt left multiplier a \"\"\"\n        v0 = b.vec[0]\n        v1 = b.vec[1]\n        v2 = b.vec[2]\n        y = b.real\n        return sympy.Matrix([[y, v2, -v1, v0],\n                             [-v2, y, v0, v1],\n                             [v1, -v0, y, v2],\n                             [-v0, -v1, -v2, y]])\n\n    @staticmethod\n    def Db_a_mul_b(a, b):\n        \"\"\" derivatice of quaternion muliplication wrt right multiplicand b \"\"\"\n        u0 = a.vec[0]\n        u1 = a.vec[1]\n        u2 = a.vec[2]\n        x = a.real\n        return sympy.Matrix([[x, -u2, u1, u0],\n                             [u2, x, -u0, u1],\n                             [-u1, u0, x, u2],\n                             [-u0, -u1, -u2, x]])", "\n\nclass Quaternion:\n    \"\"\" Quaternion class \"\"\"\n\n    def __init__(self, real, vec):\n        \"\"\" Quaternion consists of a real scalar, and an imaginary 3-vector \"\"\"\n        assert isinstance(vec, sympy.Matrix)\n        assert vec.shape == (3, 1), vec.shape\n        self.real = real\n        self.vec = vec\n\n    def __mul__(self, right):\n        \"\"\" quaternion multiplication \"\"\"\n        return Quaternion(self[3] * right[3] - self.vec.dot(right.vec),\n                          self[3] * right.vec + right[3] * self.vec +\n                          self.vec.cross(right.vec))\n\n    def __add__(self, right):\n        \"\"\" quaternion multiplication \"\"\"\n        return Quaternion(self[3] + right[3], self.vec + right.vec)\n\n    def __neg__(self):\n        return Quaternion(-self[3], -self.vec)\n\n    def __truediv__(self, scalar):\n        \"\"\" scalar division \"\"\"\n        return Quaternion(self.real / scalar, self.vec / scalar)\n\n    def __repr__(self):\n        return \"( \" + repr(self[3]) + \" + \" + repr(self.vec) + \"i )\"\n\n    def __getitem__(self, key):\n        \"\"\" We use the following convention [vec0, vec1, vec2, real] \"\"\"\n        assert (key >= 0 and key < 4)\n        if key == 3:\n            return self.real\n        else:\n            return self.vec[key]\n\n    def squared_norm(self):\n        \"\"\" squared norm when considering the quaternion as 4-tuple \"\"\"\n        return squared_norm(self.vec) + self.real**2\n\n    def conj(self):\n        \"\"\" quaternion conjugate \"\"\"\n        return Quaternion(self.real, -self.vec)\n\n    def inv(self):\n        \"\"\" quaternion inverse \"\"\"\n        return self.conj() / self.squared_norm()\n\n    @staticmethod\n    def identity():\n        return Quaternion(1, Vector3(0, 0, 0))\n\n    @staticmethod\n    def zero():\n        return Quaternion(0, Vector3(0, 0, 0))\n\n    def subs(self, x, y):\n        return Quaternion(self.real.subs(x, y), self.vec.subs(x, y))\n\n    def simplify(self):\n        v = sympy.simplify(self.vec)\n        return Quaternion(sympy.simplify(self.real),\n                          Vector3(v[0], v[1], v[2]))\n\n    def __eq__(self, other):\n        if isinstance(self, other.__class__):\n            return self.real == other.real and self.vec == other.vec\n        return False\n\n    @staticmethod\n    def Da_a_mul_b(a, b):\n        \"\"\" derivatice of quaternion muliplication wrt left multiplier a \"\"\"\n        v0 = b.vec[0]\n        v1 = b.vec[1]\n        v2 = b.vec[2]\n        y = b.real\n        return sympy.Matrix([[y, v2, -v1, v0],\n                             [-v2, y, v0, v1],\n                             [v1, -v0, y, v2],\n                             [-v0, -v1, -v2, y]])\n\n    @staticmethod\n    def Db_a_mul_b(a, b):\n        \"\"\" derivatice of quaternion muliplication wrt right multiplicand b \"\"\"\n        u0 = a.vec[0]\n        u1 = a.vec[1]\n        u2 = a.vec[2]\n        x = a.real\n        return sympy.Matrix([[x, -u2, u1, u0],\n                             [u2, x, -u0, u1],\n                             [-u1, u0, x, u2],\n                             [-u0, -u1, -u2, x]])", "\n\nclass TestQuaternion(unittest.TestCase):\n    def setUp(self):\n        x, u0, u1, u2 = sympy.symbols('x u0 u1 u2', real=True)\n        y, v0, v1, v2 = sympy.symbols('y v0 v1 v2', real=True)\n        u = Vector3(u0, u1, u2)\n        v = Vector3(v0, v1, v2)\n        self.a = Quaternion(x, u)\n        self.b = Quaternion(y, v)\n\n    def test_muliplications(self):\n        product = self.a * self.a.inv()\n        self.assertEqual(product.simplify(),\n                         Quaternion.identity())\n        product = self.a.inv() * self.a\n        self.assertEqual(product.simplify(),\n                         Quaternion.identity())\n\n    def test_derivatives(self):\n        d = sympy.Matrix(4, 4, lambda r, c: sympy.diff(\n            (self.a * self.b)[r], self.a[c]))\n        self.assertEqual(d,\n                         Quaternion.Da_a_mul_b(self.a, self.b))\n        d = sympy.Matrix(4, 4, lambda r, c: sympy.diff(\n            (self.a * self.b)[r], self.b[c]))\n        self.assertEqual(d,\n                         Quaternion.Db_a_mul_b(self.a, self.b))", "\n\nif __name__ == '__main__':\n    unittest.main()\n    print('hello')\n"]}
{"filename": "sophus/complex.py", "chunked_list": ["import unittest\n\nimport sympy\n\n\nclass Complex:\n    \"\"\" Complex class \"\"\"\n\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n\n    def __mul__(self, right):\n        \"\"\" complex multiplication \"\"\"\n        return Complex(self.real * right.real - self.imag * right.imag,\n                       self.imag * right.real + self.real * right.imag)\n\n    def __add__(self, right):\n        return Complex(self.real + right.real, self.imag + right.imag)\n\n    def __neg__(self):\n        return Complex(-self.real, -self.image)\n\n    def __truediv__(self, scalar):\n        \"\"\" scalar division \"\"\"\n        return Complex(self.real / scalar, self.imag / scalar)\n\n    def __repr__(self):\n        return \"( \" + repr(self.real) + \" + \" + repr(self.imag) + \"i )\"\n\n    def __getitem__(self, key):\n        \"\"\" We use the following convention [real, imag] \"\"\"\n        if key == 0:\n            return self.real\n        else:\n            return self.imag\n\n    def squared_norm(self):\n        \"\"\" squared norm when considering the complex number as tuple \"\"\"\n        return self.real**2 + self.imag**2\n\n    def conj(self):\n        \"\"\" complex conjugate \"\"\"\n        return Complex(self.real, -self.imag)\n\n    def inv(self):\n        \"\"\" complex inverse \"\"\"\n        return self.conj() / self.squared_norm()\n\n    @staticmethod\n    def identity():\n        return Complex(1, 0)\n\n    @staticmethod\n    def zero():\n        return Complex(0, 0)\n\n    def __eq__(self, other):\n        if isinstance(self, other.__class__):\n            return self.real == other.real and self.imag == other.imag\n        return False\n\n    def subs(self, x, y):\n        return Complex(self.real.subs(x, y), self.imag.subs(x, y))\n\n    def simplify(self):\n        return Complex(sympy.simplify(self.real),\n                       sympy.simplify(self.imag))\n\n    @staticmethod\n    def Da_a_mul_b(a, b):\n        \"\"\" derivatice of complex muliplication wrt left multiplier a \"\"\"\n        return sympy.Matrix([[b.real, -b.imag],\n                             [b.imag, b.real]])\n\n    @staticmethod\n    def Db_a_mul_b(a, b):\n        \"\"\" derivatice of complex muliplication wrt right multiplicand b \"\"\"\n        return sympy.Matrix([[a.real, -a.imag],\n                             [a.imag, a.real]])", "\n\nclass TestComplex(unittest.TestCase):\n    def setUp(self):\n        x, y = sympy.symbols('x y', real=True)\n        u, v = sympy.symbols('u v', real=True)\n        self.a = Complex(x, y)\n        self.b = Complex(u, v)\n\n    def test_muliplications(self):\n        product = self.a * self.a.inv()\n        self.assertEqual(product.simplify(),\n                         Complex.identity())\n        product = self.a.inv() * self.a\n        self.assertEqual(product.simplify(),\n                         Complex.identity())\n\n    def test_derivatives(self):\n        d = sympy.Matrix(2, 2, lambda r, c: sympy.diff(\n            (self.a * self.b)[r], self.a[c]))\n        self.assertEqual(d,\n                         Complex.Da_a_mul_b(self.a, self.b))\n        d = sympy.Matrix(2, 2, lambda r, c: sympy.diff(\n            (self.a * self.b)[r], self.b[c]))\n        self.assertEqual(d,\n                         Complex.Db_a_mul_b(self.a, self.b))", "\n\nif __name__ == '__main__':\n    unittest.main()\n    print('hello')\n"]}
