{"filename": "thoughttree/History.py", "chunked_list": ["from tools import shorter, logarithmic_length\n\n\n# class ExtendedList(list):\n#     def __init__(self, initial_data):\n#         super().__init__(initial_data)  # call the parent class (list) constructor\n#\n# my_list = ExtendedList([1, 2, 3, 4, 5])\n\n\ndef log_history_compact(history):\n    for message in history:\n        text = message['content']\n        print(f\"{message['role']}: {shorter(text, 120)} {logarithmic_length(text, 120)}\")\n    print()", "\n\ndef log_history_compact(history):\n    for message in history:\n        text = message['content']\n        print(f\"{message['role']}: {shorter(text, 120)} {logarithmic_length(text, 120)}\")\n    print()\n\ndef history_from_args(system=\"\", message=\"\") :\n    history = [\n        {'role': 'system', 'content': system},\n        {'role': 'user', 'content': message}\n    ]\n    return history", "def history_from_args(system=\"\", message=\"\") :\n    history = [\n        {'role': 'system', 'content': system},\n        {'role': 'user', 'content': message}\n    ]\n    return history\n\n"]}
{"filename": "thoughttree/Ui.py", "chunked_list": ["import os\nimport tkinter as tk\nfrom os.path import join\nfrom tkinter import messagebox\n\n\nclass Ui(tk.Frame):\n    icon = None\n    WINDOW_ICON = None\n    current_open_uis = []\n\n    def __init__(self, name=\"\", icon_path=None):\n        if tk._default_root:\n            self.first_window = False\n            self.root = tk.Toplevel()\n        else:\n            self.first_window = True\n            self.root = tk.Tk()\n        tk.Frame.__init__(self, self.root)\n\n        self.is_root_destroyed = False\n        Ui.current_open_uis.append(self)\n        name = f\"{name} {len(Ui.current_open_uis)}\"\n        self.root.title(name)\n        self.root.wm_title(name)\n        self.root.protocol(\"WM_DELETE_WINDOW\", self.close)\n        try:\n            self.set_icon(icon_path)\n        except:\n            print(\"Error loading icon.\")\n\n        # def close(event):\n        #     self.root.destroy()\n        # self.root.bind(\"<Escape>\", close)\n\n\n    def toTop(self):\n        self.root.attributes(\"-topmost\", True)\n        self.root.attributes(\"-topmost\", False)\n\n    def close(self, event=None):\n        result = messagebox.askyesno(\"Quit\", \"Are you sure you want to quit?\", parent=self)\n        if result:\n            Ui.current_open_uis.remove(self)\n            self.is_root_destroyed = True\n            self.root.destroy()\n\n\n    def set_icon(self, window_icon):\n        if not window_icon:\n            return\n        def get_icon_file_name(icon_base_name):\n            return join(os.path.dirname(os.path.abspath(__file__)), icon_base_name)\n\n        if Ui.icon:\n            return\n        try:\n            abs_name = str(get_icon_file_name(window_icon))\n            photo_image = tk.PhotoImage(file=abs_name)\n            Ui.icon = photo_image\n            self.root.iconphoto(True, photo_image) # Note: has no effect when running in PyCharm IDE\n        except Exception as e:\n            print(\"Error loading icon:\", e)", ""]}
{"filename": "thoughttree/menu_help.py", "chunked_list": ["# The help text are generated by GPT-4, based on the source code of the menu (which does\n# not contain comments) and minimal prompting.\n\nmenu_help = {\n# # Main Menus\n#     \"File\": \"Contains options for creating new windows or tabs, saving chat content, and closing the application.\",\n#     \"Edit\": \"Provides options for manipulating text, such as cut, copy, paste, delete, and undo/redo actions.\",\n#     \"View\": \"Allows you to customize the display of the application, including font size and visibility of different panes.\",\n#     \"Navigate\": \"Provides options for moving through the chat, such as jumping to similar lines or moving between messages.\",\n#     \"Chat\": \"Contains options for managing and controlling the chat, including completing lines, forking conversations, and cancelling models.\",", "#     \"Navigate\": \"Provides options for moving through the chat, such as jumping to similar lines or moving between messages.\",\n#     \"Chat\": \"Contains options for managing and controlling the chat, including completing lines, forking conversations, and cancelling models.\",\n#     \"Query\": \"Allows you to adjust query parameters, such as max tokens and temperature.\",\n#     \"Models\": \"Provides options for managing the GPT models used in the application.\",\n#     \"Help\": \"Contains options for accessing application help, debug info, and about details.\",\n\n# File\n    \"New Window\": \"Opens a new Thoughttree window, allowing you to work on multiple chats simultaneously.\\nEach new window operates independently, enabling you to manage and organize your conversations more efficiently.\",\n    \"New Main Tab\": \"Opens a new main tab in the current window, providing a separate workspace within the same window.\\nThis allows you to keep multiple chats organized and accessible without opening additional windows.\",\n    \"Save Chat\": \"Saves the entire chat content to a file, allowing you to store and review conversations later.\\nThe saved file can be opened and edited in any text editor, making it easy to share or reference the chat content.\",", "    \"New Main Tab\": \"Opens a new main tab in the current window, providing a separate workspace within the same window.\\nThis allows you to keep multiple chats organized and accessible without opening additional windows.\",\n    \"Save Chat\": \"Saves the entire chat content to a file, allowing you to store and review conversations later.\\nThe saved file can be opened and edited in any text editor, making it easy to share or reference the chat content.\",\n    \"Save Message\": \"Saves a selected section of the chat to a file, useful for extracting specific parts of a conversation.\",\n    \"Save Selection\": \"Saves the selected text in the chat to a file, allowing you to save specific parts of the conversation for later reference or sharing.\",\n    \"Save Code Block\": \"Saves a selected code block to a file, enabling you to reuse or share code snippets.\\nThe saved code block can be imported into other projects or shared with collaborators, streamlining the development process.\",\n    \"Close Tab\": \"Closes the current tab in the Thoughttree window, removing it from the workspace.\",\n    \"Close Empty Tab\": \"Closes the current tab if it is empty, helping to declutter your workspace.\\nThis feature prevents the accumulation of unnecessary empty tabs, ensuring a clean and organized working environment.\",\n    \"Quit\": \"Closes the current Thoughttree window.\\n\\n\"\n            \"Before quitting, ensure that you have saved any important chat content to avoid losing your work.\",\n# Edit:", "            \"Before quitting, ensure that you have saved any important chat content to avoid losing your work.\",\n# Edit:\n    \"Cut\": \"Cuts the selected text and stores it in the clipboard, allowing you to move text within or between documents.\",\n    \"Copy\": \"Copies the selected text to the clipboard without removing it from the document, useful for duplicating content.\",\n    \"Paste\": \"Pastes the text from the clipboard at the cursor position, inserting copied or cut content.\",\n    \"Delete\": \"Deletes the selected text or the character at the cursor position without storing it in the clipboard.\",\n    \"Undo\": \"Reverts the last text edit, allowing you to correct mistakes or revert unwanted changes.\",\n    \"Redo\": \"Reapplies the previously undone text edit, restoring the text to its state before the undo action.\",\n    \"Select All\": \"Selects all the text in the current text widget, making it easy to copy, cut, or delete the entire content.\\nThis feature is useful for quickly selecting large amounts of text or when you want to replace the entire content of the text widget.\",\n    \"Search with Google\": \"Searches the selected text on Google, providing quick access to search results for the highlighted text.\",", "    \"Select All\": \"Selects all the text in the current text widget, making it easy to copy, cut, or delete the entire content.\\nThis feature is useful for quickly selecting large amounts of text or when you want to replace the entire content of the text widget.\",\n    \"Search with Google\": \"Searches the selected text on Google, providing quick access to search results for the highlighted text.\",\n    \"Insert Current Time\": \"Inserts the current date and time at the cursor position, useful for timestamping notes or messages.\\nThe inserted timestamp is formatted as 'YYYY-MM-DD HH:MM:SS', providing a clear and concise representation of the current date and time.\",\n    \"Include Date in System Prompt\": \"Includes the current date in the system prompt, providing a reference for when the prompt was generated.\\nThis feature is useful for tracking the date of specific prompts or for organizing your conversations based on the date.\",\n    \"Copy Title\": \"Copies the title of the current chat to the clipboard, allowing you to easily share or reference the chat title.\\nThis feature is useful for sharing chat titles with collaborators, referencing chat titles in other documents, or for organizing your chats based on their titles.\",\n# View:\n    \"Show Main Menu\": \"Toggles the visibility of the main menu. The main menu provides access to all the features and settings of the application. You can choose to hide it for a cleaner workspace or display it for easy access to the various options.\",\n    \"Show Status Bar\": \"Displays the status bar at the bottom of the application window. The status bar provides useful information about the current state of the application, such as the current model in use and other relevant parameters. You can hide it to maximize the chat area or display it to keep track of the application's status.\",\n    \"Show System Prompt\": \"Toggles the visibility of the system prompt, allowing you to hide or display the prompt as needed.\\nHiding the system prompt can help declutter your workspace, while displaying the prompt provides context and guidance for the conversation.\",\n    \"Show Tree\": \"Toggles the visibility of the tree view, enabling you to show or hide the tree structure of your chats.\\nThe tree view provides a visual representation of the chat hierarchy, making it easy to navigate and manage complex conversations.\",", "    \"Show System Prompt\": \"Toggles the visibility of the system prompt, allowing you to hide or display the prompt as needed.\\nHiding the system prompt can help declutter your workspace, while displaying the prompt provides context and guidance for the conversation.\",\n    \"Show Tree\": \"Toggles the visibility of the tree view, enabling you to show or hide the tree structure of your chats.\\nThe tree view provides a visual representation of the chat hierarchy, making it easy to navigate and manage complex conversations.\",\n    \"Show Console\": \"Displays the console pane in the Thoughttree window, allowing you to view and interact with the console output of the chatbot model.\",\n    \"Count Tokens\": \"Counts the tokens in the current text, providing an estimate of the text's complexity and cost for text generation.\\nToken count is an important factor when working with text generation services, as it can affect the cost and processing time for generating content.\",\n    \"Run Code Block\": \"Runs the selected code block, executing any embedded code within the chat.\\nThis feature is useful for testing and debugging code snippets, as well as for executing commands or scripts directly within the chat environment.\",\n    \"Update Window Title\": \"Updates the window title based on the current chat, providing a clear identifier for the active chat.\\nThis feature ensures that the window title accurately reflects the content of the chat, making it easier to manage and navigate multiple chats.\",\n    \"Increase Font Size\": \"Increases the font size of the text, making it easier to read.\\nThis feature is especially useful for users with visual impairments or for working with high-resolution displays where the default font size may be too small.\",\n    \"Decrease Font Size\": \"Decreases the font size of the text, allowing you to fit more content on the screen.\\nThis feature is useful for working with large documents or for users who prefer smaller font sizes for readability.\",\n    \"Reset Font Size\": \"Resets the font size to its default value, restoring the original text appearance.\",\n    \"Toggle Monospace\": \"Toggles between monospace and proportional fonts, allowing you to switch between fixed-width and variable-width characters.\\nMonospace fonts are useful for aligning text, especially when working with code or tabular data, while proportional fonts provide a more natural reading experience for general text.\",", "    \"Reset Font Size\": \"Resets the font size to its default value, restoring the original text appearance.\",\n    \"Toggle Monospace\": \"Toggles between monospace and proportional fonts, allowing you to switch between fixed-width and variable-width characters.\\nMonospace fonts are useful for aligning text, especially when working with code or tabular data, while proportional fonts provide a more natural reading experience for general text.\",\n    \"Toggle Scrolling Output\": \"Toggles automatic scrolling of the output, enabling you to control whether the output scrolls as new content is generated.\\nWhen enabled, the output will automatically scroll to show the latest generated content.\\nWhen disabled, the output will remain stationary, allowing you to review previous content without interruption.\",\n    \"Ring Bell When Finished\": \"Rings a bell when the text generation is completed, providing an audible notification of completion.\\nThis feature is helpful for multitasking, as it allows you to focus on other tasks while waiting for the text generation to finish.\",\n    \"Toggle Wrap Lines\": \"Toggles line wrapping in the text widget, allowing you to control whether long lines wrap to the next line or extend off-screen.\\nLine wrapping can improve readability by ensuring that text does not extend beyond the visible screen area, while disabling line wrapping can provide a more compact view of the text.\",\n    \"Generate Titles\": \"Generates titles for the current text, providing suggestions for descriptive headings.\\nThis feature is useful for organizing your chats or for creating meaningful titles for sections of text, making it easier to navigate and understand the content.\",\n    \"Calculate Cost\": \"Calculates the cost of generating the current text, estimating the resources required for text generation.\\nThis feature is useful for managing the cost and resource usage of text generation services, ensuring that you stay within your budget and resource limits.\",\n# Navigate:\n    \"Next Similar Line\": \"Jumps to the next line with similar content, allowing you to quickly navigate between related lines.\",\n    \"Previous Similar Line\": \"Jumps to the previous line with similar content, enabling you to move backward through related lines.\",", "    \"Next Similar Line\": \"Jumps to the next line with similar content, allowing you to quickly navigate between related lines.\",\n    \"Previous Similar Line\": \"Jumps to the previous line with similar content, enabling you to move backward through related lines.\",\n    \"Next Message\": \"Jumps to the next message in the chat, providing a quick way to navigate between messages.\\nThis feature is useful for reviewing previous conversations or for quickly moving through a chat to find specific messages or content.\",\n    \"Previous Message\": \"Jumps to the previous message in the chat, allowing you to move backward through messages.\\nThis feature is useful for reviewing earlier parts of a conversation or for finding specific messages or content that occurred earlier in the chat.\",\n# Chat:\n    \"Next Paragraph\": \"Completes the current text and starts a new paragraph, providing a clear separation between ideas.\",\n    \"Next Line\": \"Completes the current text and starts a new line, continuing the conversation on a new line.\",\n    \"Continue Directly\": \"Continues the current text without starting a new line or paragraph, generating a seamless continuation of the conversation.\",\n    \"Fork Conversation\": \"Forks the current conversation into a new branch, allowing you to explore alternative paths in the chat.\\nThis feature enables you to generate multiple responses or scenarios based on the current conversation, providing a way to test different ideas or approaches without affecting the main chat.\",\n    \"Complete in Branch\": \"Completes the current text in a new conversation branch, generating text that diverges from the main conversation.\\nThis feature allows you to explore alternative outcomes or responses without altering the original conversation, making it easy to compare and contrast different ideas.\",", "    \"Fork Conversation\": \"Forks the current conversation into a new branch, allowing you to explore alternative paths in the chat.\\nThis feature enables you to generate multiple responses or scenarios based on the current conversation, providing a way to test different ideas or approaches without affecting the main chat.\",\n    \"Complete in Branch\": \"Completes the current text in a new conversation branch, generating text that diverges from the main conversation.\\nThis feature allows you to explore alternative outcomes or responses without altering the original conversation, making it easy to compare and contrast different ideas.\",\n    \"Complete Alternatives\": \"Generates alternative completions for the current text, providing a variety of potential responses.\\nThis feature enables you to explore multiple ways to continue the conversation, giving you greater flexibility and control over the chat content.\",\n    \"Complete 3 Times\": \"Generates 3 completions for the current text, providing three unique options for continuing the conversation.\",\n    \"Complete Multiple...\": \"Prompts for the number of completions to generate, allowing you to specify the desired number of alternatives.\\nBy entering a custom number, you can generate a specific number of alternative completions, providing a tailored set of options for continuing the conversation.\",\n    \"Complete Multiple Again\": \"Generates the same number of completions as the last multiple completion, providing consistency in the number of alternatives.\\nThis feature is useful for generating a consistent set of options across multiple completions, ensuring a similar level of variety in each set of alternatives.\",\n    \"Cancel\": \"Cancels the current text generation, stopping the generation process and discarding the generated content.\",\n# Query:\n    \"Max Tokens...\": \"Configures the maximum number of tokens for text generation, allowing you to control the length and complexity of generated text.\\nBy setting a limit on tokens, you can ensure that the generated content stays within a specific length or complexity range, making it more manageable and easier to read.\",\n    \"Temperature...\": \"Configures the temperature for text generation, adjusting the randomness and creativity of the generated content.\\nA higher temperature results in more diverse and creative output, while a lower temperature produces more focused and conservative text.\\nThis setting allows you to fine-tune the balance between creativity and coherence in the generated content.\",", "    \"Max Tokens...\": \"Configures the maximum number of tokens for text generation, allowing you to control the length and complexity of generated text.\\nBy setting a limit on tokens, you can ensure that the generated content stays within a specific length or complexity range, making it more manageable and easier to read.\",\n    \"Temperature...\": \"Configures the temperature for text generation, adjusting the randomness and creativity of the generated content.\\nA higher temperature results in more diverse and creative output, while a lower temperature produces more focused and conservative text.\\nThis setting allows you to fine-tune the balance between creativity and coherence in the generated content.\",\n    \"Increase Temperature\": \"Increases the temperature for text generation, resulting in more random and creative output.\",\n    \"Decrease Temperature\": \"Decreases the temperature for text generation, producing more focused and conservative output.\",\n    \"Temperature 0.0\": \"Sets the temperature for text generation to 0.0, generating deterministic and highly focused output.\",\n    \"API Key...\": \"Configures the API key for the text generation service, enabling access to the text generation features.\\nBy entering a valid API key, you can connect to the text generation service and use its capabilities to generate content within the Thoughttree application.\",\n# Models:\n    \"gpt-3.5-turbo\": \"This is the default version of the ChatGPT (GPT-3.5) model.\\n\"\n                     \"\\n\"\n                     \"Most capable GPT-3.5 model and optimized for chat\\n\"", "                     \"\\n\"\n                     \"Most capable GPT-3.5 model and optimized for chat\\n\"\n                     \"at 1/10th the cost of text-davinci-003.\\n\"\n                     \"Will be updated with our latest model iteration\\n\"\n                     \"2 weeks after it is released.\\n\"\n                     \"\\n\"\n                     \"Max tokens: 4,096 tokens\\n\"\n                     \"Training data: Up to Sep 2021\",\n    \"gpt-3.5-turbo-0301\": \"This is a snapshot of the ChatGPT (GPT-3.5) model taken on March 1st.\\n\"\n                          \"\\n\"", "    \"gpt-3.5-turbo-0301\": \"This is a snapshot of the ChatGPT (GPT-3.5) model taken on March 1st.\\n\"\n                          \"\\n\"\n                          \"This model has the same capabilities as the default version\\n\"\n                          \"but will not receive updates.\\n\"\n                          \"\\n\"\n                          \"Max tokens: 4,096 tokens\\n\"\n                          \"Training data: Up to Sep 2021\",\n    \"gpt-3.5-turbo-0613\": \"This is a snapshot of the ChatGPT (GPT-3.5) model taken on June 13th.\\n\"\n                          \"\\n\"\n                          \"This model has the same capabilities as the default version\\n\"", "                          \"\\n\"\n                          \"This model has the same capabilities as the default version\\n\"\n                          \"but will not receive updates and will be deprecated 3 months after a new version is released.\\n\"\n                          \"\\n\"\n                          \"Max tokens: 4,096 tokens\\n\"\n                          \"Training data: Up to Sep 2021\",\n    \"gpt-3.5-turbo-16k\": \"This is a variant of ChatGPT (GPT-3.5) with 4 times the context.\\n\"\n                         \"\\n\"\n                         \"This model has the same capabilities as the standard gpt-3.5-turbo model\\n\"\n                         \"but can handle longer pieces of text.\\n\"", "                         \"This model has the same capabilities as the standard gpt-3.5-turbo model\\n\"\n                         \"but can handle longer pieces of text.\\n\"\n                         \"\\n\"\n                         \"Max tokens: 16,384 tokens\\n\"\n                         \"Training data: Up to Sep 2021\",\n    \"gpt-3.5-turbo-16k-0613\": \"This is a snapshot of the gpt-3.5-turbo-16k model taken on June 13th.\\n\"\n                              \"\\n\"\n                              \"This model has the same capabilities as the gpt-3.5-turbo-16k version\\n\"\n                              \"but will not receive updates and will be deprecated 3 months after a new version is released.\\n\"\n                              \"\\n\"", "                              \"but will not receive updates and will be deprecated 3 months after a new version is released.\\n\"\n                              \"\\n\"\n                              \"Max tokens: 16,384 tokens\\n\"\n                              \"Training data: Up to Sep 2021\",\n    \"gpt-4\": \"This is the default version of the GPT-4 model.\\n\"\n             \"\\n\"\n             \"More capable than any GPT-3.5 model, able to do more complex tasks, and optimized for chat.\\n\"\n             \"Will be updated with our latest model iteration 2 weeks after it is released.\\n\"\n             \"\\n\"\n             \"Max tokens: 8,192 tokens\\n\"", "             \"\\n\"\n             \"Max tokens: 8,192 tokens\\n\"\n             \"Training data: Up to Sep 2021\",\n    \"gpt-4-0314\": \"This is a snapshot of the GPT-4 model taken on March 14th.\\n\"\n                  \"\\n\"\n                  \"This model has the same capabilities as the default version\\n\"\n                  \"but will not receive updates.\\n\"\n                  \"\\n\"\n                  \"Max tokens: 8,192 tokens\\n\"\n                  \"Training data: Up to Sep 2021\",", "                  \"Max tokens: 8,192 tokens\\n\"\n                  \"Training data: Up to Sep 2021\",\n    \"gpt-4-0613\": \"This is a snapshot of the GPT-4 model taken on June 13th.\\n\"\n                  \"\\n\"\n                  \"This model has the same capabilities as the default version\\n\"\n                  \"but will not receive updates and will be deprecated 3 months after a new version is released.\\n\"\n                  \"\\n\"\n                  \"Max tokens: 8,192 tokens\\n\"\n                  \"Training data: Up to Sep 2021\",\n    \"gpt-4-32k\": \"This is a variant of GPT-4 with 4 times the context.\\n\"", "                  \"Training data: Up to Sep 2021\",\n    \"gpt-4-32k\": \"This is a variant of GPT-4 with 4 times the context.\\n\"\n                 \"\\n\"\n                 \"This model has the same capabilities as the base gpt-4 model\\n\"\n                 \"but can handle longer pieces of text.\\n\"\n                 \"Will be updated with our latest model iteration.\\n\"\n                 \"\\n\"\n                 \"Max tokens: 32,768 tokens\\n\"\n                 \"Training data: Up to Sep 2021\",\n    \"gpt-4-32k-0613\": \"This is a snapshot of the gpt-4-32k model taken on June 13th.\\n\"", "                 \"Training data: Up to Sep 2021\",\n    \"gpt-4-32k-0613\": \"This is a snapshot of the gpt-4-32k model taken on June 13th.\\n\"\n                      \"\\n\"\n                      \"This model has the same capabilities as the gpt-4-32k version\\n\"\n                      \"but will not receive updates and will be deprecated 3 months after a new version is released.\\n\"\n                      \"\\n\"\n                      \"Max tokens: 32,768 tokens\\n\"\n                      \"Training data: Up to Sep 2021\",\n    \"Reload Available Models\": \"Refreshes the list of available models for text generation.\"\n                               \"This is useful if it failed at program start.\",", "    \"Reload Available Models\": \"Refreshes the list of available models for text generation.\"\n                               \"This is useful if it failed at program start.\",\n# Help:\n    \"Test\": \"Runs a test function, useful for debugging and experimentation.\",\n    \"Debug Info\": \"Displays debug information, providing insights into the internal workings of the application.\",\n    \"About\": \"Displays information about the Thoughttree application, including version and developer details.\",\n}\n"]}
{"filename": "thoughttree/AboutDialog.py", "chunked_list": ["import tkinter as tk\nimport tkinter.commondialog\n\nfrom Sheet import Sheet\nfrom ThoughttreeConfig import conf\n\nclass AboutDialog(tk.Toplevel):\n    def __init__(self, parent=None):\n        super().__init__(parent)\n\n        self.focus_set()\n        self.grab_set()\n        self.transient(parent)\n        self.title(\"About Thoughttree\")\n\n        self.git_version = conf.git_describe_version\n\n        tk.Label(self, font=Sheet.FONT, text=\"About Thoughttree\").pack(padx=8, pady=12)\n        tk.Label(self, font=Sheet.FONT, text=self.git_version).pack(padx=16, pady=2)\n\n        tk.Button(self, text=\"OK\", command=self.destroy).pack(padx=8, pady=12)\n\n        def close_dialog(event):\n            self.destroy()\n        self.bind(\"<Escape>\", close_dialog)", "\n# testing the AboutDialog\nif __name__ == \"__main__\":\n    root = tk.Tk()\n    AboutDialog(root)\n    root.withdraw()\n    root.mainloop()\n"]}
{"filename": "thoughttree/FoldablePane.py", "chunked_list": ["import tkinter as tk\nfrom tkinter import HORIZONTAL\n\n\nclass FoldablePane(tk.PanedWindow):\n    SASH_WIDTH = 8\n    MIN_SIZE = 20\n    def __init__(self, parent=None, folded=False, fold_size=100, **kw):\n        super().__init__(parent, borderwidth=0, sashwidth=FoldablePane.SASH_WIDTH, sashrelief=tk.RIDGE, **kw)\n\n        self.fold_size = fold_size\n        self.foldable_child = None\n        self.fold_last = None\n        self.takefocus = None\n        self.previous_sash = -1\n        self.folded = folded\n\n        def on_double_click(event):\n            self.fold()\n        self.bind(\"<Double-Button-1>\", on_double_click)\n\n    def add(self, child, stretch=\"always\", **kw) -> None:\n        super().add(child, stretch=stretch, **kw)\n\n    def addFoldable(self, child, stretch=\"never\", **kw):\n        self.fold_last =  bool(self.panes())\n        self.add(child, stretch=stretch, **kw)\n        self.foldable_child = child\n\n\n    def fold(self, event=None, set_folded=None):\n        pane_size = self.size1d()\n        sash = max(*self.sash_coord(0))\n        size = self.fold_last and pane_size - sash or sash\n\n        if size < FoldablePane.MIN_SIZE:\n            self.folded = True\n\n        if set_folded is None:\n            self.folded = not self.folded\n        else:\n            self.folded = set_folded\n\n        if self.folded:\n            self.takefocus = self.foldable_child.cget(\"takefocus\")\n            self.foldable_child.configure(takefocus=False)\n            self.fold_size = size\n            size = 0\n        else:\n            self.foldable_child.configure(takefocus=self.takefocus)\n            size = self.fold_size\n\n        sash = self.fold_last and pane_size - size or size\n        self.sash_place(0, sash, sash)\n        return \"break\"\n\n\n    def size1d(self, widget=None):\n        widget = widget or self\n        if self['orient'] == HORIZONTAL:\n            return widget.winfo_width()\n        else:\n            return widget.winfo_height()", ""]}
{"filename": "thoughttree/Cursorline.py", "chunked_list": ["class Cursorline:\n    def __init__(self, sheet):\n        self.sheet = sheet\n        self.configure_cursorline()\n\n    def cursorline(self, e, add=True):\n        if not e.widget.winfo_exists():\n            return\n        takefocus = not e.widget.cget(\"takefocus\") == \"0\"\n        if not takefocus:\n            return\n        e.widget.tag_remove('cursorline', 1.0, \"end\")\n        if add:\n            e.widget.tag_add('cursorline', 'insert display linestart', 'insert display lineend+1c')\n\n    def cursorline_remove(self, e):\n        self.cursorline(e, add=False)\n\n    def configure_cursorline(self):\n        self.sheet.tag_configure('cursorline', background='#FCFAED', foreground=\"black\", selectbackground=\"#4682b4\",\n                           selectforeground=\"white\")\n        self.sheet.bindtags(self.sheet.bindtags() + (\"last\",))\n        self.sheet.bind_class(\"last\", '<KeyRelease>', self.cursorline)\n        self.sheet.bind_class(\"last\", '<Button-1>', self.cursorline)\n        self.sheet.bind_class(\"last\", \"<FocusIn>\", self.cursorline)\n        self.sheet.bind_class(\"last\", \"<FocusOut>\", self.cursorline_remove)", ""]}
{"filename": "thoughttree/thoughttree.py", "chunked_list": ["#!/usr/bin/env python\nimport sys\nimport tkinter as tk\nfrom tkinter import BOTH, END, HORIZONTAL, INSERT, LEFT, SUNKEN, TOP, VERTICAL, W, X, SEL_FIRST, \\\n    SEL_LAST, BOTTOM\nfrom tkinter import simpledialog\nfrom tkinter.messagebox import showinfo\n\nfrom configargparse import Namespace\n", "from configargparse import Namespace\n\nfrom Console import Console\nfrom FinishReasonIcon import FinishReasonIcon\nfrom FoldablePane import FoldablePane\nfrom GeneratedTitle import GeneratedTitle\nfrom HidableFrame import HidableFrame\nfrom Model import Model\nfrom MultiTextboxLabel import MultiTextboxLabel\nfrom PrimaryUi import PrimaryUi", "from MultiTextboxLabel import MultiTextboxLabel\nfrom PrimaryUi import PrimaryUi\nfrom StatusBar import StatusBar\nfrom Sheet import Sheet\nfrom MainMenu import MainMenu\nfrom Tree import Tree\nfrom WaitCursor import WaitCursor\nfrom finish_reasons import finish_reasons\n\nWINDOW_ICON = \"chatgpt-icon.png\"", "\nWINDOW_ICON = \"chatgpt-icon.png\"\n\nconf = Namespace()\nconf.show_finish_reason = True\nconf.update_title_after_completion = True\nconf.scroll_output = True\nconf.ring_bell_after_completion = False\nconf.blinking_caret = True\n", "conf.blinking_caret = True\n\n\nclass Thoughttree(PrimaryUi):\n    MIN_SIZE = (600, 300)\n    ROOT_GEOMETRY = \"1000x600\"\n    icon = None\n    multi_completions = 5\n\n    interactive_model_name = 'gpt-4'\n    # interactive_model_name = 'gpt-3.5-turbo'\n    generation_model_name = 'gpt-3.5-turbo'\n\n\n    def __init__(self):\n        PrimaryUi.__init__(self, \"Thoughttree\", WINDOW_ICON)\n        self.status_hider = None\n        self.status = None\n        self.console = None\n        self.tree = None\n        self.system = None\n        self.chat = None\n        self.model = None\n        self.console_pane = None\n        self.tree_pane = None\n        self.system_pane = None\n\n        self.root.geometry(Thoughttree.ROOT_GEOMETRY)\n        self.root.minsize(*Thoughttree.MIN_SIZE)\n        try:\n            self.set_icon(self.WINDOW_ICON)\n        except:\n            print(\"Error loading icon.\")\n\n        self.scroll_output = conf.scroll_output\n        self.ring_bell_after_completion = conf.ring_bell_after_completion\n        self.create_ui()\n\n        def new_window_callback():\n            Thoughttree()\n        self.models = {}\n        self.generation_model = Model(self.generation_model_name)\n        self.set_model(self.interactive_model_name)\n        menu = MainMenu(self, new_window_callback)\n\n        self.status.note = \"Loading available models...\"\n        self.update_idletasks()\n        menu.models_menu.load_available_models()\n        self.status.note = \"\"\n\n        self.pack(fill=BOTH, expand=True)\n        if self.first_window:\n            self.root.mainloop()\n\n\n    def set_model(self, model_name):\n        if not model_name in self.models:\n            self.models[model_name] = Model(model_name)\n        self.model = self.models[model_name]\n\n        self.status.model = model_name\n        self.status.set_max_token_var(self.model.max_tokens)\n        self.status.set_temperature_var(self.model.temperature)\n\n    def cancel_models(self, event=None):\n        for model in self.models.values():\n            model.cancel()\n\n    def create_ui(self):\n        self.configure_ui_options()\n\n        self.status_hider = HidableFrame(self)\n        self.status_hider.pack(side=BOTTOM, fill=X, expand=False)\n        self.status = StatusBar(self.status_hider)\n        self.status.pack(side=BOTTOM, fill=X, expand=True)\n\n        self.console_pane = FoldablePane(self, orient=VERTICAL)\n        self.tree_pane = FoldablePane(self.console_pane, orient=HORIZONTAL)\n        self.system_pane = FoldablePane(self.tree_pane, orient=VERTICAL)\n        self.console_pane.pack(side=TOP, fill=BOTH, expand=True)\n\n        self.console = Console(self.console_pane)\n        self.tree = Tree(self.tree_pane)\n        self.system = Sheet(self.system_pane, height=3)\n        self.chat = Sheet(self.system_pane)\n\n        self.console_pane.add(self.tree_pane, stretch=\"always\")\n        self.console_pane.addFoldable(self.console, stretch=\"never\")\n        self.tree_pane.addFoldable(self.tree, stretch=\"never\")\n        self.tree_pane.add(self.system_pane, stretch=\"always\")\n        self.system_pane.addFoldable(self.system, stretch=\"never\")\n        self.system_pane.add(self.chat, stretch=\"always\")\n\n        def on_first_configure(ev=None):\n            self.system_pane.fold(set_folded=True)\n            self.console_pane.fold(set_folded=True)\n            self.tree_pane.fold(set_folded=True)\n            self.console_pane.unbind(\"<Configure>\")\n        self.console_pane.bind(\"<Configure>\", on_first_configure)\n\n        sys.stdout = self.console\n        sys.stderr = self.console.err\n\n        self.chat.focus_set()\n\n\n    def configure_ui_options(self):\n        self.option_add('*Dialog*Font', (\"sans-serif\", 10))\n        self.option_add('*Menu*Font', (\"Arial\", 10))\n        self.option_add('*Font', (\"Arial\", 10))\n        if not conf.blinking_caret:\n            self.option_add('*Text*insertOffTime', '0')\n\n\n    def update_window_title(self, event=None):\n        progress_title = self.root.title() + \"...\"\n\n        def write_title(content):\n            if self.is_root_destroyed or self.model.is_canceled:\n                return\n            current_title = self.root.title()\n            if current_title == progress_title:\n                current_title = \"\"\n            self.root.title(current_title + content)\n            self.update()\n\n        self.root.title(progress_title)\n        self.update()\n        history = self.history_from_system_and_chat(GeneratedTitle.PROMPT, max_messages=5, max_size=1000) # todo limit, do not use system for title\n\n        self.generation_model.counter.go()\n        self.generation_model.chat_complete(history, write_title, max_tokens=30, temperature=0.3)\n        self.generation_model.counter.summarize(\"Title cost:\")\n\n\n    def configure_parameter(self, title, message, variable, minvalue, maxvalue):\n        askfunction = simpledialog.askinteger if isinstance(variable, tk.IntVar) else simpledialog.askfloat\n        value = askfunction(\n            title,\n            message,\n            initialvalue=variable.get(),\n            minvalue=minvalue,\n            maxvalue=maxvalue)\n        if value is not None:\n            variable.set(value)\n\n\n    def configure_max_tokens(self, event=None):\n        self.configure_parameter(\n            \"Max Tokens\",\n            \"What should be the model's maximum number of tokens to generate?\\n\"\n            \"(Query parameter 'max_tokens')\\n\",\n            self.model.max_tokens,\n            1,\n            100000)\n\n\n    def configure_temperature(self, event=None):\n        self.configure_parameter(\n            \"Query Temperature\",\n            \"What should be the level of creativity of the model?\\n\"\n            \"0.0 for deterministic, typically 0.5 or 0.7, maximal 2.0?\\n\"\n            \"(Query parameter 'temperature')\\n\",\n            self.model.temperature,\n            0,\n            2.0)\n\n\n    def count_text_tokens(self, event=None) :\n        sheet: Sheet = self.focus_get()\n        try :\n            text = sheet.get(SEL_FIRST, SEL_LAST)\n        except tk.TclError :\n            text = sheet.get(1.0, END)\n        old_status = self.status.message\n        self.status.message = \"Counting tokens (loading model)\"\n        self.status.update()\n        num_tokens = self.model.counter.count_tokens(text)\n        self.status.message = old_status\n        num_lines = text.count(\"\\n\")\n        num_words = len(text.split())\n        num_chars = len(text)\n        # todo: align numbers, using TextDialog or so\n        showinfo(\"Count Tokens\",\n                 f\"The length of the text is:\\n\"\n                 f\"{num_tokens:,} tokens\\n\"\n                 f\"{num_lines:,} lines\\n\"\n                 f\"{num_words:,} words\\n\"\n                 f\"{num_chars:,} characters\",\n                 master=sheet)\n        return \"break\"\n\n\n    def complete(self, n=1, prefix=\"\", postfix=\"\"):\n        self.model.is_canceled = False\n        sheet: Sheet = self.focus_get()\n        sheet.tag_remove('cursorline', 1.0, \"end\")\n\n        n = self.find_number_of_completions(n)\n        if n is None:\n            return\n\n        with WaitCursor(sheet):\n            sheet.undo_separator()\n            self._insert_prefix_and_scroll(sheet, prefix)\n\n            history = self.history_from_system_and_chat()\n            self.model.counter.go()\n\n            finish_reason, message = self._process_completions(sheet, n, history)\n\n            self._handle_completion_finish(sheet, finish_reason, message, postfix)\n            self._post_completion_tasks()\n        return \"break\"\n\n    def scroll(self, sheet):\n        if self.scroll_output:\n            sheet.see(END)\n        sheet.update()\n\n\n    def find_number_of_completions(self, n):\n        if not n:\n            n = simpledialog.askinteger(\n                \"Alternative completions\",\n                \"How many alternative results do you want?\",\n                initialvalue=Thoughttree.multi_completions,\n                minvalue=2, maxvalue=1000, parent=self)\n            if not n:\n                return\n        elif n == -1:  # repeat\n            n = Thoughttree.multi_completions\n        Thoughttree.multi_completions = n\n        return n\n\n\n    def _insert_prefix_and_scroll(self, sheet, prefix):\n        if prefix:\n            sheet.insert(END, prefix)\n            self.scroll(sheet)\n\n\n    def _process_completions(self, sheet, n, history):\n        finish_reason, message = 'unknown', ''\n        label_frame = None\n        if n == 1:\n            if self.model.is_canceled:\n                finish_reason = \"canceled\"\n            else:\n                def write_chat(text):\n                    if self.is_root_destroyed:\n                        return\n                    sheet.insert(END, text, \"assistant\")\n                    self.scroll(sheet)\n\n                finish_reason, message = self.model.chat_complete(history, write_chat)\n        else:\n            label_frame = tk.Frame(sheet, borderwidth=4)\n            sheet.window_create(END, window=label_frame)\n            sheet.insert(END, \"\\n\")\n            sheet.see(END)\n            finish_reason, message = 'unknown', ''\n\n            for i in range(n):\n                if self.model.is_canceled:\n                    finish_reason = \"canceled\"\n                    break\n                label = MultiTextboxLabel(label_frame, sheet)\n\n                def write_label(text):\n                    if self.is_root_destroyed:\n                        return\n                    label.config(text=label.cget(\"text\") + text)\n                    self.scroll(sheet)\n\n                finish_reason, message = self.model.chat_complete(history, write_label)\n        return finish_reason, message\n\n\n    def _handle_completion_finish(self, sheet, finish_reason, message, postfix):\n        if self.is_root_destroyed:\n            return\n        if conf.show_finish_reason:\n            self.show_finish_reason_icon(sheet, finish_reason, message)\n        if not self.model.is_canceled and not finish_reason == \"length\":\n            sheet.insert(END, postfix)\n        if self.scroll_output:\n            sheet.mark_set(INSERT, END)\n            sheet.see(END)\n        sheet.undo_separator()\n\n\n    def show_finish_reason_icon(self, sheet, finish_reason, message):\n        symbol = finish_reasons[finish_reason][\"symbol\"]\n        if finish_reason not in [\"stop\", \"length\", \"canceled\", \"error\"]:\n            print(f\"{finish_reason=}\")\n        if symbol:\n            tooltip = finish_reasons[finish_reason][\"tooltip\"]\n            if message:\n                tooltip += \"\\n\" + message\n\n            sheet.window_create(END, window=FinishReasonIcon(sheet, symbol, tooltip=tooltip))\n\n\n    def _post_completion_tasks(self):\n        if conf.ring_bell_after_completion:\n            self.bell()\n\n        self.model.counter.summarize(\"Completion cost:\")\n\n        if conf.update_title_after_completion and not self.model.is_canceled:\n            if self.model.counter.tokens_since_go() > GeneratedTitle.GEN_THRESHOLD:\n                self.update_window_title()\n\n\n    def history_from_system_and_chat(self, additional_message=None, max_messages=None, max_size=None) :\n        system = self.system.get(1.0, 'end - 1c').strip()\n        history = [{'role': 'system', 'content': system}]\n\n        sheet: Sheet = self.focus_get()\n        history = sheet.history_from_path(history)\n\n        if additional_message:\n            history += [{'role': 'user', 'content': additional_message}]\n\n        if max_messages:\n            history = history[-max_messages:]\n        return history", "\n\nif __name__ == \"__main__\":\n    Thoughttree()\n"]}
{"filename": "thoughttree/PrimaryUi.py", "chunked_list": ["import os\nimport tkinter as tk\nfrom os.path import join\nfrom tkinter import messagebox\n\nfrom Ui import Ui\n\n\nclass PrimaryUi(tk.Tk, Ui):\n    icon = None\n    WINDOW_ICON = None\n    current_open_uis = []\n\n    def __init__(self, name=\"\", icon_path=None):\n        if tk._default_root:\n            self.first_window = False\n            self.root = tk.Toplevel()\n        else:\n            self.first_window = True\n            self.root = tk.Tk()\n        tk.Frame.__init__(self, self.root)\n\n        self.is_root_destroyed = False\n        Ui.current_open_uis.append(self)\n        if len(Ui.current_open_uis) > 1:\n            name = f\"{name} ({len(Ui.current_open_uis)})\"\n        self.root.title(name)\n        self.root.wm_title(name)\n        self.root.protocol(\"WM_DELETE_WINDOW\", self.close)\n        try:\n            self.set_icon(icon_path)\n        except:\n            print(\"Error loading icon.\")\n\n    def toTop(self):\n        self.root.attributes(\"-topmost\", True)\n        self.root.attributes(\"-topmost\", False)\n\n    def close(self, event=None):\n        result = messagebox.askyesno(\"Quit\", \"Are you sure you want to quit?\", parent=self)\n        if result:\n            Ui.current_open_uis.remove(self)\n            self.is_root_destroyed = True\n            self.root.destroy()\n\n\n    def set_icon(self, window_icon):\n        if not window_icon:\n            return\n        def get_icon_file_name(icon_base_name):\n            return join(os.path.dirname(os.path.abspath(__file__)), icon_base_name)\n\n        if Ui.icon:\n            return\n        try:\n            abs_name = str(get_icon_file_name(window_icon))\n            photo_image = tk.PhotoImage(file=abs_name)\n            Ui.icon = photo_image\n            self.root.iconphoto(True, photo_image) # Note: has no effect when running in PyCharm IDE\n        except Exception as e:\n            print(\"Error loading icon:\", e)", "class PrimaryUi(tk.Tk, Ui):\n    icon = None\n    WINDOW_ICON = None\n    current_open_uis = []\n\n    def __init__(self, name=\"\", icon_path=None):\n        if tk._default_root:\n            self.first_window = False\n            self.root = tk.Toplevel()\n        else:\n            self.first_window = True\n            self.root = tk.Tk()\n        tk.Frame.__init__(self, self.root)\n\n        self.is_root_destroyed = False\n        Ui.current_open_uis.append(self)\n        if len(Ui.current_open_uis) > 1:\n            name = f\"{name} ({len(Ui.current_open_uis)})\"\n        self.root.title(name)\n        self.root.wm_title(name)\n        self.root.protocol(\"WM_DELETE_WINDOW\", self.close)\n        try:\n            self.set_icon(icon_path)\n        except:\n            print(\"Error loading icon.\")\n\n    def toTop(self):\n        self.root.attributes(\"-topmost\", True)\n        self.root.attributes(\"-topmost\", False)\n\n    def close(self, event=None):\n        result = messagebox.askyesno(\"Quit\", \"Are you sure you want to quit?\", parent=self)\n        if result:\n            Ui.current_open_uis.remove(self)\n            self.is_root_destroyed = True\n            self.root.destroy()\n\n\n    def set_icon(self, window_icon):\n        if not window_icon:\n            return\n        def get_icon_file_name(icon_base_name):\n            return join(os.path.dirname(os.path.abspath(__file__)), icon_base_name)\n\n        if Ui.icon:\n            return\n        try:\n            abs_name = str(get_icon_file_name(window_icon))\n            photo_image = tk.PhotoImage(file=abs_name)\n            Ui.icon = photo_image\n            self.root.iconphoto(True, photo_image) # Note: has no effect when running in PyCharm IDE\n        except Exception as e:\n            print(\"Error loading icon:\", e)", "\n"]}
{"filename": "thoughttree/__main__.py", "chunked_list": ["from thoughttree import Thoughttree\n\nif __name__ == \"__main__\":\n    Thoughttree.main()\n"]}
{"filename": "thoughttree/finish_reasons.py", "chunked_list": ["finish_reasons = {\n    \"stop\": {\"symbol\": \"\", \"tooltip\": \"\"},\n    \"length\": {\"symbol\": \"\u2026\", \"tooltip\": \"The completion reached max_tokens tokens. It can be continued.\"},\n    \"canceled\": {\"symbol\": \"\u2612\", \"tooltip\": \"The completion was canceled.\"},\n    \"error\": {\"symbol\": \"\u26a0\", \"tooltip\": \"An error occurred while processing the completion.\"},\n}\n"]}
{"filename": "thoughttree/Menu.py", "chunked_list": ["import re\nimport tkinter as tk\nfrom typing import Union\n\nfrom MenuHelpTooltip import MenuHelpTooltip\nfrom Ui import Ui\n\n\nclass Menu(tk.Menu):\n\n    def __init__(self, master: Union[tk.Tk, tk.Text, tk.Menu], label=None, menu_help=None, **kw) : #1\n        super().__init__(master, tearoff=False, borderwidth=3, **kw)\n        if menu_help:\n            self.menu_help = menu_help\n        elif hasattr(master, \"menu_help\"):\n            self.menu_help = master.menu_help\n        else:\n            self.menu_help = None\n\n        if isinstance(master, Ui):\n            master.root.config(menu=self)\n        else:\n            if self.menu_help:\n                MenuHelpTooltip(self, self.menu_help)\n            master.add_cascade(label=label, underline=0, menu=self)\n\n\n    def convert_key_string(self, keystroke) :\n\n        def fix_key_letter_case(keystroke):\n            m = re.search(r\"^((<.*-)|<)([a-zA-Z])>\", keystroke)\n            if m:\n                letter = m[3]\n                if keystroke.lower().count('shift-'):\n                    letter = letter.upper()\n                else:\n                    letter = letter.lower()\n                return m[1] + letter + \">\"\n            else:\n                return keystroke\n\n        if not keystroke:\n            return \"\"\n        s = fix_key_letter_case(keystroke)\n        s = s.replace(\"-Key-\", \"-\")\n        s = s.replace(\"-\", \"+\")\n        s = s.replace(\"Control\", \"Ctrl\")\n        s = s.replace(\"Escape\", \"Esc\")\n        s = s.replace(\"plus>\", \"+\")\n        s = s.replace(\"minus>\", \"-\")\n        s = s.replace(\"period>\", \".\")\n        s = s.lstrip(\"<\")\n        s = s.rstrip(\">\")\n        if s[-2] == \"+\":\n            s = s[:-1] + s[-1].upper()\n        return s\n\n\n    def item(self, label, keystroke, command, variable=None, add=False, index=tk.END):\n        if not label in self.menu_help:\n            print(\"Help text missing for menu item \\\"\" + label + \"\\\"\")\n\n        accelerator = self.convert_key_string(keystroke)\n        state = tk.NORMAL if command or variable else tk.DISABLED\n        if variable :\n            self.insert_radiobutton(index, label=label, accelerator=accelerator, state=state, variable=variable)\n        else:\n            self.insert_command(index, label=label, underline=0, accelerator=accelerator, state=state, command=command)\n        if keystroke:\n            # if not add:\n            #     self.master.unbind_class(\"Text\", keystroke)\n            self.master.bind_class(\"Text\", keystroke, command, add=add)", "class Menu(tk.Menu):\n\n    def __init__(self, master: Union[tk.Tk, tk.Text, tk.Menu], label=None, menu_help=None, **kw) : #1\n        super().__init__(master, tearoff=False, borderwidth=3, **kw)\n        if menu_help:\n            self.menu_help = menu_help\n        elif hasattr(master, \"menu_help\"):\n            self.menu_help = master.menu_help\n        else:\n            self.menu_help = None\n\n        if isinstance(master, Ui):\n            master.root.config(menu=self)\n        else:\n            if self.menu_help:\n                MenuHelpTooltip(self, self.menu_help)\n            master.add_cascade(label=label, underline=0, menu=self)\n\n\n    def convert_key_string(self, keystroke) :\n\n        def fix_key_letter_case(keystroke):\n            m = re.search(r\"^((<.*-)|<)([a-zA-Z])>\", keystroke)\n            if m:\n                letter = m[3]\n                if keystroke.lower().count('shift-'):\n                    letter = letter.upper()\n                else:\n                    letter = letter.lower()\n                return m[1] + letter + \">\"\n            else:\n                return keystroke\n\n        if not keystroke:\n            return \"\"\n        s = fix_key_letter_case(keystroke)\n        s = s.replace(\"-Key-\", \"-\")\n        s = s.replace(\"-\", \"+\")\n        s = s.replace(\"Control\", \"Ctrl\")\n        s = s.replace(\"Escape\", \"Esc\")\n        s = s.replace(\"plus>\", \"+\")\n        s = s.replace(\"minus>\", \"-\")\n        s = s.replace(\"period>\", \".\")\n        s = s.lstrip(\"<\")\n        s = s.rstrip(\">\")\n        if s[-2] == \"+\":\n            s = s[:-1] + s[-1].upper()\n        return s\n\n\n    def item(self, label, keystroke, command, variable=None, add=False, index=tk.END):\n        if not label in self.menu_help:\n            print(\"Help text missing for menu item \\\"\" + label + \"\\\"\")\n\n        accelerator = self.convert_key_string(keystroke)\n        state = tk.NORMAL if command or variable else tk.DISABLED\n        if variable :\n            self.insert_radiobutton(index, label=label, accelerator=accelerator, state=state, variable=variable)\n        else:\n            self.insert_command(index, label=label, underline=0, accelerator=accelerator, state=state, command=command)\n        if keystroke:\n            # if not add:\n            #     self.master.unbind_class(\"Text\", keystroke)\n            self.master.bind_class(\"Text\", keystroke, command, add=add)", "\n"]}
{"filename": "thoughttree/MODEL_DATA.py", "chunked_list": ["# Sources:\n# https://platform.openai.com/docs/models/gpt-4\n# https://platform.openai.com/docs/models/gpt-3-5\n# https://openai.com/pricing\n# as of 2023-06-09\n\nMODEL_DATA = {\n    'gpt-3.5-turbo': {\n        '1k_token_usd': {\n            'prompt': 0.0015,", "        '1k_token_usd': {\n            'prompt': 0.0015,\n            'completion': 0.002,\n        },\n        'max_tokens': 4096,\n    },\n    'gpt-3.5-turbo-16k': {\n        '1k_token_usd': {\n            'prompt': 0.003,\n            'completion': 0.004,", "            'prompt': 0.003,\n            'completion': 0.004,\n        },\n        'max_tokens': 16384,\n    },\n    'gpt-4': {\n        '1k_token_usd': {\n            'prompt': 0.03,\n            'completion': 0.06,\n        },", "            'completion': 0.06,\n        },\n        'max_tokens': 8192,\n    },\n    'gpt-4-32k': {\n        '1k_token_usd': {\n            'prompt': 0.06,\n            'completion': 0.12,\n        },\n        'max_tokens': 32768,", "        },\n        'max_tokens': 32768,\n    },\n}\n"]}
{"filename": "thoughttree/Tree.py", "chunked_list": ["import tkinter as tk\nfrom tkinter import BOTH, DISABLED, END, HORIZONTAL, INSERT, LEFT, NO, SUNKEN, TOP, VERTICAL, W, WORD, X, SEL_FIRST, \\\n    SEL_LAST\nfrom tkinter import font as tkfont\nfrom tkinter import ttk, simpledialog\n\nfrom Sheet import Sheet\n\n#NODE_OPEN = '\\u25B6'\n#NODE_CLOSED = '\\u25BC'", "#NODE_OPEN = '\\u25B6'\n#NODE_CLOSED = '\\u25BC'\nNODE_OPEN = '*'\nNODE_CLOSED = '|'\n\n\nclass Tree(ttk.Treeview):\n    def __init__(self, parent, *args, **kw):\n        super().__init__(parent, *args, **kw)\n\n        def on_treeview_click(event):\n            item = tree.identify('item', event.x, event.y)\n            if item:\n                if 'closed' in tree.item(item, 'tags'):\n                    replaced = tree.item(item, 'text').replace(NODE_CLOSED, NODE_OPEN, 1)\n                    tree.item(item, text=replaced)\n                    tree.item(item, tags='opened')\n                elif 'opened' in tree.item(item, 'tags'):\n                    tree.item(item, text=tree.item(item, 'text').replace(NODE_OPEN, NODE_CLOSED, 1))\n                    tree.item(item, tags='closed')\n\n        tree = ttk.Treeview(parent, columns=(\"C1\"), show=\"tree\")\n        self.tree = tree\n        tree.column(\"#0\", width=160, minwidth=60, anchor=W, stretch=NO)\n        tree.column(\"#1\", width=30, minwidth=60, anchor=W, stretch=NO)\n        tree.heading(\"C1\", text=\"\")\n        tree.bind('<Double-Button-1>', on_treeview_click)\n        tree.bind(\"<Double-Button-1>\", self.edit_tree_entry)\n        tree.bind(\"<Return>\", self.edit_tree_entry)\n\n        from tools import create_mock_data\n        create_mock_data(tree)\n\n\n    def edit_tree_entry(self, event):\n        row_id = self.focus()\n        if not row_id:\n            return\n        column = self.identify_column(event.x)\n        if column != \"#1\":  # Only allow editing the \"Messages\" column\n            return\n        x, y, width, height = self.bbox(row_id, column)\n        char_width = tkfont.Font(font=Sheet.FONT).measure('0')\n        line_height = tkfont.Font(font=Sheet.FONT).metrics(\"linespace\")\n        width = max(self.column(column)[\"width\"], width)\n        height = max(line_height, height)\n\n        cur_text = self.item(row_id, \"values\")[0]\n        w = width // char_width\n        h = height // line_height\n        cell_editor = tk.Text(self, wrap=WORD, width=w, height=h, font=Sheet.FONT,\n                      highlightthickness=0, highlightbackground=\"black\", padx=4, pady=0)\n        cell_editor.insert(END, cur_text)\n        cell_editor.place(x=x, y=y)\n        cell_editor.focus_set()\n\n        def save_text(event):\n            print(event.type)\n            if event.type == tk.EventType.FocusOut or int(event.state) & 0x4 == 0 :  # Check if Control key is not pressed\n                text = cell_editor.get(1.0, END).strip()\n                self.set(row_id, column, text)\n                cell_editor.destroy()\n\n        # cell_editor.bind(\"<FocusOut>\", save_text)\n        cell_editor.bind(\"<Return>\", lambda e: e.state & 0x4 == 0 and save_text(e) or self.focus_set())\n        cell_editor.bind(\"<Control-Return>\", lambda e: cell_editor.insert(INSERT, \"\\n\") or \"break\")", "        # cell_editor.bind(\"<Control-Key>\", lambda e : \"break\")\n        # cell_editor.bind(\"<Control_L>\", lambda e : \"break\")\n"]}
{"filename": "thoughttree/ThoughttreeConfig.py", "chunked_list": ["import sys\n\nfrom configargparse import Namespace, ArgumentParser\n\nimport tools\n\nconf = Namespace()\n\nconf.show_finish_reason = True\nconf.update_title_after_completion = True", "conf.show_finish_reason = True\nconf.update_title_after_completion = True\nconf.scroll_output = True\nconf.ring_bell_after_completion = False\nconf.blinking_caret = True\n\nconf.git_describe_version = tools.get_git_describe_version()\n\n\ndef main(argv):\n    parser = ArgumentParser(prog=\"thoughttree\",\n        description='Interact with a large language model in alternative ways',\n        exit_on_error=False)\n    add = parser.add_argument\n    add('prompt',                    nargs='?',              default=\"\",   type=str, help='Prompt for the model, text to be completed')\n    add('-p', '--prompt-file',       dest='promptFile',      default=\"\",   type=str, help='File containing the prompt')\n    add('-s', '--system-prompt',     dest='systemPrompt',    default=\"\",   type=str, help='System prompt for the model')\n    add('-f', '--system-prompt-file',dest='systemPromptFile',default=\"\",   type=str, help='File containing the system prompt')\n    add('-o', '--out-dir',           dest='outDir',          default=\"\",   type=str, help='Directory for output files')\n    add('-l', '--log-dir',           dest='logDir',          default=\"\",   type=str, help='Write log to files in this directory')\n    add('-t', '--temperature',       dest='temperature',     default=0.0,  type=float,choices=(0.0, 2.0),help='Temperature')\n    add('-m', '--max-tokens',        dest='max_tokens',      default=0,    type=int, help='Maximal number of tokens to use per query, 0 for inf')\n    add('-n', '--n-completions',     dest='number',          default=1,    type=int, help='Number of completions to request')\n    add('-z', '--add-temperature-0', dest='addTemp0Sample',  default=False,type=bool,help='Add additional completion')\n    add('-g', '--generate-titles',   dest='generateTitles',  default=False,type=bool,help='Generate titles')\n    add('-b', '--blinking-caret',    dest='blinkingCaret',   default=True, type=bool,help='Should the text input caret blink')\n    add('-a', '--autoscroll',        dest='autoscroll',      default=True, type=bool,help='Should the output scroll during completion')\n    add('-r', '--ring-on-completion',dest='ringOnCompletion',default=False,type=bool,help='Ring bell on completion long')\n    add('-d', '--display-reason',    dest='displayReason',   default=True, type=bool,help='Display finish reason as icon')\n    add('-k', '--api-key',           dest='apiKey',          default=\"\",   type=str, help='API key for the OpenAI API')\n\n    args = parser.parse_args(\"-h\")\n\n    print(args)", "\ndef main(argv):\n    parser = ArgumentParser(prog=\"thoughttree\",\n        description='Interact with a large language model in alternative ways',\n        exit_on_error=False)\n    add = parser.add_argument\n    add('prompt',                    nargs='?',              default=\"\",   type=str, help='Prompt for the model, text to be completed')\n    add('-p', '--prompt-file',       dest='promptFile',      default=\"\",   type=str, help='File containing the prompt')\n    add('-s', '--system-prompt',     dest='systemPrompt',    default=\"\",   type=str, help='System prompt for the model')\n    add('-f', '--system-prompt-file',dest='systemPromptFile',default=\"\",   type=str, help='File containing the system prompt')\n    add('-o', '--out-dir',           dest='outDir',          default=\"\",   type=str, help='Directory for output files')\n    add('-l', '--log-dir',           dest='logDir',          default=\"\",   type=str, help='Write log to files in this directory')\n    add('-t', '--temperature',       dest='temperature',     default=0.0,  type=float,choices=(0.0, 2.0),help='Temperature')\n    add('-m', '--max-tokens',        dest='max_tokens',      default=0,    type=int, help='Maximal number of tokens to use per query, 0 for inf')\n    add('-n', '--n-completions',     dest='number',          default=1,    type=int, help='Number of completions to request')\n    add('-z', '--add-temperature-0', dest='addTemp0Sample',  default=False,type=bool,help='Add additional completion')\n    add('-g', '--generate-titles',   dest='generateTitles',  default=False,type=bool,help='Generate titles')\n    add('-b', '--blinking-caret',    dest='blinkingCaret',   default=True, type=bool,help='Should the text input caret blink')\n    add('-a', '--autoscroll',        dest='autoscroll',      default=True, type=bool,help='Should the output scroll during completion')\n    add('-r', '--ring-on-completion',dest='ringOnCompletion',default=False,type=bool,help='Ring bell on completion long')\n    add('-d', '--display-reason',    dest='displayReason',   default=True, type=bool,help='Display finish reason as icon')\n    add('-k', '--api-key',           dest='apiKey',          default=\"\",   type=str, help='API key for the OpenAI API')\n\n    args = parser.parse_args(\"-h\")\n\n    print(args)", "\nif __name__ == \"__main__\":\n    main(sys.argv)\n"]}
{"filename": "thoughttree/Files.py", "chunked_list": ["import tkinter as tk\nfrom textwrap import dedent\nfrom tkinter import SEL_FIRST, SEL_LAST\nfrom tkinter.filedialog import asksaveasfilename\nfrom tkinter.messagebox import showerror\nimport re\n\nfrom TextSaver import TextSaver\n\n\nclass ChatLogSaver(TextSaver):\n\n    def find_text(self):\n        # Implement the method to find the chat log text from the widget\n        pass\n\n    def find_filename(self):\n        # Implement the method to find the filename for the chat log\n        return \"chat.txt\"", "\n\nclass ChatLogSaver(TextSaver):\n\n    def find_text(self):\n        # Implement the method to find the chat log text from the widget\n        pass\n\n    def find_filename(self):\n        # Implement the method to find the filename for the chat log\n        return \"chat.txt\"", "\nclass SectionSaver(TextSaver):\n\n    def find_text(self):\n        # Implement the method to find the section text from the widget\n        pass\n\n    def find_filename(self):\n        # Implement the method to find the filename for the section\n        return \"section.txt\"", "\nclass CodeBlockSaver(TextSaver):\n\n    def find_text(self):\n        # Implement the method to find the code block text from the widget\n        pass\n\n    def find_filename(self):\n        # Implement the method to find the filename for the code block\n        return \"code_block.py\"", "\n\nclass Files:\n    @staticmethod\n    def open_file(e=None):\n        pass\n\n\n    # @staticmethod\n    # def save_chat(e=None):\n    #     chat_log_saver = ChatLogSaver(e.widget)\n    #     chat_log_saver.save()\n    #\n    # @staticmethod\n    # def save_section_dialog(sheet):\n    #     section_saver = SectionSaver(sheet)\n    #     section_saver.save()\n    #\n    # @staticmethod\n    # def save_code_block_dialog(sheet):\n    #     code_block_saver = CodeBlockSaver(sheet)\n    #     code_block_saver.save()\n\n    @staticmethod\n    def save_chat(e=None):\n\n        def text_not_found_error():\n            pass\n\n        def find_text(sheet):\n            pass\n            return \"foo\"\n\n        def find_filename():\n            return \"bar\"\n\n        def ask_filename(initial_filename):\n            return \"\"\n\n        def write_text(text, filename):\n            pass\n\n        text = find_text(e.widget)\n        if not text:\n            text_not_found_error()\n            return\n        initial_filename = find_filename()\n        filename = ask_filename(initial_filename)\n        if not filename:\n            return\n        write_text(text, filename)\n\n\n\n        print(e)\n        print(e.widget)\n        print(type(e.widget))\n        # name = save(Files.save_chat_dialog, \"Chat saved to \")\n        # self.tt.title(name)\n\n\n        # def save(save_dialog, status_bar_label):\n        #     file_name = save_dialog(self.tt.chat)\n        #     if not file_name:\n        #         return\n        #     base_name = file_name.split(\"/\")[-1]\n        #     self.tt.status_bar.note = status_bar_label + base_name\n        #     return base_name\n\n\n    @staticmethod\n    def save_chat_dialog(sheet):\n\n        def write_chat(sheet, filename) :\n            try:\n                # ROLE_SYMBOLS = {\"user\":\"\u276f \", \"ai\":\"\u2699 \"}\n                ROLE_SYMBOLS = {\"user\" : \"\", \"ai\" : \"\"}\n                content = sheet.dump(1.0, tk.END, text=True, tag=True)\n                with open(filename, 'w') as f :\n                    drop_nl = False\n                    for item in content :\n                        if item[0] == \"tagon\" :\n                            if item[1] == \"assistant\" :\n                                f.write(ROLE_SYMBOLS[\"ai\"])\n                        elif item[0] == \"tagoff\" :\n                            if item[1] == \"assistant\" :\n                                f.write(\"\\n\" + ROLE_SYMBOLS[\"user\"])\n                                drop_nl = True\n                        elif item[0] == \"text\" :\n                            if drop_nl :\n                                drop_nl = False\n                                if item[1] == \"\\n\" :\n                                    continue\n                            f.write(item[1])\n            except Exception as e:\n                showerror(title=\"Error\", message=\"Cannot save chat\\n\" + str(e), master=sheet)\n\n        file = asksaveasfilename(defaultextension=\".txt\",\n                initialfile=\"chat.txt\", title=\"Save Chat\", parent=sheet)\n        if file:\n            write_chat(sheet, file)\n        return file\n\n\n    @staticmethod\n    def save_section_dialog(sheet):\n\n        def write_section(sheet: tk.Text, filename, index=tk.INSERT):\n            try:\n                text_range = sheet.tag_prevrange(\"assistant\", index)\n                if not text_range:\n                    raise Exception(\"No section found\")\n                section = sheet.get(*text_range)\n\n                with open(filename, 'w') as f:\n                    f.write(section)\n            except Exception as e:\n                showerror(title=\"Error\", message=\"Cannot save section\\n\" + str(e), master=sheet)\n\n        file = asksaveasfilename(\n            defaultextension=\".txt\", initialfile=\"section.txt\", title=\"Save Section\", parent=sheet)\n        if file:\n            write_section(sheet, file)\n        return file\n\n\n    @staticmethod\n    def save_selection_dialog(sheet):\n\n        def write_section(sheet: tk.Text, filename, index=tk.INSERT):\n            try:\n                string = sheet.get(SEL_FIRST, SEL_LAST)\n\n                with open(filename, 'w') as f:\n                    f.write(string)\n            except Exception as e:\n                showerror(title=\"Error\", message=\"Cannot save section\\n\" + str(e), master=sheet)\n\n        file = asksaveasfilename(\n            defaultextension=\".txt\", initialfile=\"selection.txt\", title=\"Save Selection\", parent=sheet)\n        if file:\n            write_section(sheet, file)\n        return file\n\n    @staticmethod\n    def save_code_block_dialog(sheet):\n\n        def extract_code_block(text):\n            code_blocks = re.findall(r'```(.*?)```', text, re.DOTALL)\n\n            if not code_blocks:\n                raise ValueError('No code blocks found')\n\n            if len(code_blocks) > 1:\n                raise ValueError('Multiple code blocks found')\n\n            if len(code_blocks) == 1:\n                block = code_blocks[0]\n                file_type = None\n                match = re.search(r'^([a-zA-Z0-9]+)\\n', block)\n                if match:\n                    file_type = match.group(1)\n                    block = re.sub(r'^[a-zA-Z0-9]+\\n', '', block)\n                block = dedent(block)\n                return block, file_type\n\n        def find_code_block(sheet: tk.Text, index=tk.INSERT):\n            text_range = sheet.tag_prevrange(\"assistant\", index)\n            if not text_range:\n                raise Exception(\"No code block found\")\n            code_block_section = sheet.get(*text_range)\n            code_block, file_type = extract_code_block(code_block_section)\n            return code_block #, file_type\n\n        try:\n            code_block = find_code_block(sheet)\n\n            filename = asksaveasfilename(\n                    defaultextension=\".py\", initialfile=\"code_block.py\", title=\"Save Code Block\", parent=sheet)\n            if filename:\n                with open(filename, 'w') as f:\n                    f.write(code_block)\n\n            return filename\n        except Exception as e:\n            showerror(title=\"Error\", message=\"Cannot save code block\\n\" + str(e), master=sheet)\n            return None", ""]}
{"filename": "thoughttree/MenuHelpTooltip.py", "chunked_list": ["from Tooltip import Tooltip\nfrom tools import text_block\n\n\nclass MenuHelpTooltip(Tooltip):\n    def __init__(self, widget, menu_help):\n        Tooltip.__init__(self, widget, None)\n        self.delay_ms = 750\n        self.menu_help = menu_help\n        self.previous_missing_item = None\n\n\n    def refresh_tooltip_text(self):\n        try:\n            menu_item = self.widget.entrycget(f'@{self.last_y}', 'label')\n            # print(f\"{menu_item=}\")\n            if menu_item in self.menu_help:\n                help_text = self.menu_help[menu_item]\n                text = text_block(help_text)\n            else:\n                text = menu_item\n                if menu_item and self.previous_missing_item != menu_item:\n                    self.previous_missing_item = menu_item\n            self.label.configure(text=text)\n        except Exception as ex: # Menu separators have no \"label\"\n            pass # leave text unchanged", "            # self.label.configure(text=\"-\")\n"]}
{"filename": "thoughttree/ModelsMenu.py", "chunked_list": ["import tkinter as tk\n\nfrom Menu import Menu\nfrom menu_help import menu_help\n\n\nclass ModelsMenu(Menu):\n    def __init__(self, parent, thoughttree, label):\n        super().__init__(parent, label, menu_help=menu_help)\n        self.ui = thoughttree\n\n        self.fixed_model_menu_items = -1\n        self.add_separator()\n        self.item(\"Reload Available Models\", None, self.load_available_models)\n        self.item(\"API Key...\", \"\", None)\n\n        self.selected_model = tk.StringVar()\n        def on_model_selected(name, index, mode):\n            self.ui.set_model(self.selected_model.get())\n        self.selected_model.trace_add(\"write\", on_model_selected)\n\n\n    def load_available_models(self, event=None):\n        def on_eventA(event):\n            print(\"A\" + str(event))\n\n        if self.fixed_model_menu_items == -1:\n            self.fixed_model_menu_items = self.index(tk.END) + 1\n        present_items = self.index(tk.END) + 1\n        if present_items > self.fixed_model_menu_items:\n            self.delete(0, present_items - self.fixed_model_menu_items - 1)\n        for i, model_name in enumerate(self.ui.model.get_available_models()):\n            key = None\n            if model_name == \"gpt-4\":\n                key = \"<Control-Alt-Key-4>\"\n            elif model_name == \"gpt-3.5-turbo\":\n                key = \"<Control-Alt-Key-3>\"\n\n            if key:\n                command = lambda e, model=model_name: self.selected_model.set(model)\n            else:\n                command = None\n            self.item(model_name, key, command, index=i, variable=self.selected_model)", ""]}
{"filename": "thoughttree/ForkableText.py", "chunked_list": ["import tkinter as tk\n\nfrom Notebook import Notebook\nfrom ResizingText import ResizingText\n\n\nclass ForkableText(tk.Frame):\n    def __init__(self, parent):\n        super().__init__(parent)\n        self.sheet = ResizingText(self)\n        self.sheet.insert(tk.END, \"This is a test\\n\" * 4)\n\n        self.notebook = Notebook(self)\n        self.sheet.bind(\"<Control-o>\", self.fork)\n\n        self.sheet.pack(fill=\"both\", expand=True)\n        self.notebook.pack(fill=\"both\", expand=True)\n\n\n    def fork(self, event=None):\n\n        def update_notebook_height(event):\n            current_tab = self.notebook.nametowidget(self.notebook.select())\n            current_tab.update_idletasks()\n            self.notebook.configure(height=current_tab.winfo_reqheight())\n\n        text_tab1 = ForkableText(self.notebook)\n        text_tab2 = ForkableText(self.notebook)\n        self.notebook.add(text_tab1, text=\"Tab 1\")\n        self.notebook.add(text_tab2, text=\"Tab 2\")\n        self.notebook.bind(\"<<NotebookTabChanged>>\", update_notebook_height)\n        return \"break\"", ""]}
{"filename": "thoughttree/SecondaryUi.py", "chunked_list": ["\nimport tkinter as tk\n\nfrom Ui import Ui\n\n\nclass SecondaryUi(tk.Toplevel, Ui):\n    pass\n\n", "\n"]}
{"filename": "thoughttree/TextSaver.py", "chunked_list": ["from abc import ABC, abstractmethod\n\nclass TextSaver(ABC):\n\n    def __init__(self, widget):\n        self.widget = widget\n\n    def text_not_found_error(self):\n        pass\n\n    @abstractmethod\n    def find_text(self):\n        pass\n\n    @abstractmethod\n    def find_filename(self):\n        pass\n\n    def ask_filename(self, initial_filename):\n        return \"\"\n\n    def write_text(self, text, filename):\n        pass\n\n    def save(self):\n        text = self.find_text()\n        if not text:\n            self.text_not_found_error()\n            return\n        initial_filename = self.find_filename()\n        filename = self.ask_filename(initial_filename)\n        if not filename:\n            return\n        self.write_text(text, filename)", ""]}
{"filename": "thoughttree/StatusBar.py", "chunked_list": ["import tkinter as tk\nfrom tkinter import IntVar, DoubleVar, W, E, X, LEFT, BOTTOM, SUNKEN\n\nfrom LabeledLabel import LabeledLabel\n\n\nclass StatusBar(tk.Frame):\n    def __init__(self, master, small_text=\"\", message_text=\"\", note_text=\"\", model_text=\"\", **kw):\n        super().__init__(master, bd=1, relief=SUNKEN, **kw)\n        self.master = master\n\n        def validate_max_tokens(entry_value):\n            if entry_value.isdigit() and 1 <= int(entry_value) <= 100000:\n                return True\n            else:\n                return False\n\n        # vcmd = (root.register(validate_max_tokens), '%P')\n        # entry = tk.Entry(root, validate=\"key\", validatecommand=vcmd)\n\n        def validate_temperature(entry_value):\n            try:\n                value = float(entry_value)\n                if 0 <= value <= 2:\n                    return True\n                else:\n                    return False\n            except ValueError:\n                return False\n\n        # vcmd = (root.register(validate_temperature), '%P')\n        # entry = tk.Entry(root, validate=\"key\", validatecommand=vcmd)\n\n\n\n        defaults = {\"bd\": 1, \"relief\": SUNKEN}\n\n        self.message_label = tk.Label(self, **defaults, width=20, text=message_text, anchor=W)\n        self.message_label.pack(side=LEFT, padx=(5, 0), fill=X, expand=True)\n\n        self.note_label = tk.Label(self, **defaults, width=10, text=note_text, anchor=W)\n        self.note_label.pack(side=LEFT, padx=(5, 0), fill=X, expand=True)\n\n        self.max_token_label = LabeledLabel(self, \"Max t.:\", entry_width=5, **defaults)\n        self.max_token_label.pack(side=LEFT, padx=(5, 0))\n\n        self.temperature_label = LabeledLabel(self, \"Temp.:\", entry_width=3, validatecommand=validate_temperature, **defaults)\n        self.temperature_label.pack(side=LEFT, padx=(5, 0))\n\n        self.model_label = tk.Label(self, **defaults, width=20, text=model_text, anchor=E)\n        self.model_label.pack(side=LEFT, padx=(5, 0))\n\n\n    def set_max_token_var(self, var: IntVar):\n        self.max_token_label.entry.config(textvariable=var)\n\n    def set_temperature_var(self, var: DoubleVar):\n        self.temperature_label.entry.config(textvariable=var)\n\n\n    @property\n    def message(self):\n        return self.message_label.cget('text')\n\n    @message.setter\n    def message(self, text):\n        self.message_label.config(text=text)\n\n    @property\n    def note(self):\n        return self.note_label.cget('text')\n\n    @note.setter\n    def note(self, text):\n        self.note_label.config(text=text)\n\n    @property\n    def model(self):\n        return self.model_label.cget('text')\n\n    @model.setter\n    def model(self, text):\n        self.model_label.config(text=text)", ""]}
{"filename": "thoughttree/TextDialog.py", "chunked_list": ["import tkinter as tk\nfrom tkinter import ACTIVE, LEFT, BOTH\nfrom tkinter.simpledialog import Dialog\n\n\nclass TextDialog(tk.simpledialog.Dialog):\n    def __init__(self, message=None, title=None, parent=None):\n        self.message = message\n        super().__init__(parent, title)\n        # todo: Control-A for select all.\n        # todo: context menu with \"Copy Message\"\n\n    def body(self, parent):\n        background = self.cget(\"background\")\n        text = tk.Text(parent, height=10, width=30, borderwidth=0,\n                       highlightthickness=0, background=background, font=(\"sans-serif\", 11))\n        text.insert(tk.END, self.message)\n        text.config(state=tk.DISABLED)\n        text.pack(fill=BOTH, expand=True)\n        return text\n\n    def buttonbox(self):\n\n        box = tk.Frame(self)\n\n        button = tk.Button(box, text=\"OK\", width=10, command=self.ok, default=ACTIVE)\n        button.pack(side=LEFT, padx=15, pady=15)\n        self.pack_slaves()[0].pack(fill=BOTH, expand=True, padx=15, pady=15) # hack to repack dialog content to expand\n\n        self.bind(\"<Return>\", self.ok)\n        self.bind(\"<Escape>\", self.cancel)\n\n        box.pack()", "\n"]}
{"filename": "thoughttree/TokenCounter.py", "chunked_list": ["import re\n\nimport tiktoken\n\nfrom MODEL_DATA import MODEL_DATA\n\n\nclass TokenCounter:\n    def __init__(self, model_name):\n        self.model_name = model_name\n\n        self.prompt_tokens_total = 0\n        self.prompt_tokens_at_go = 0\n        self.completion_tokens_total = 0\n        self.completion_tokens_at_go = 0\n\n    def go(self):\n        self.prompt_tokens_at_go = self.prompt_tokens_total\n        self.completion_tokens_at_go = self.completion_tokens_total\n\n\n    def prompt_tokens_since_go(self):\n        return self.prompt_tokens_total - self.prompt_tokens_at_go\n\n    def completion_tokens_since_go(self):\n        return self.completion_tokens_total - self.completion_tokens_at_go\n\n    def tokens_since_go(self):\n        return self.prompt_tokens_since_go() + self.completion_tokens_since_go()\n\n    def tokens_total(self):\n        return self.prompt_tokens_total + self.completion_tokens_total\n\n    def prompt_cost_since_go(self):\n        return self.prompt_cost(self.prompt_tokens_since_go())\n\n    def completion_cost_since_go(self):\n        return self.completion_cost(self.completion_tokens_since_go())\n\n    def prompt_cost_total(self):\n        return self.prompt_cost(self.prompt_tokens_total)\n\n    def completion_cost_total(self):\n        return self.completion_cost(self.completion_tokens_total)\n\n    def cost_since_go(self):\n        return self.prompt_cost_since_go() + self.completion_cost_since_go()\n\n    def cost_total(self):\n        return self.prompt_cost(self.prompt_tokens_total) + self.completion_cost(self.completion_tokens_total)\n\n\n    def count_tokens(self, text):\n        enc = tiktoken.encoding_for_model(self.model_name)\n        return len(enc.encode(text))\n\n    def observe_prompt(self, history):\n        for item in history:\n            text = item['content']\n            self.prompt_tokens_total += self.count_tokens(text)\n\n    def observe_completion(self, text):\n        self.completion_tokens_total += self.count_tokens(text)\n\n    def token_cost(self, tokens, direction):\n        model_name = self.model_name\n        if model_name not in MODEL_DATA:\n            match = re.match(r\"^(.*)(-[0-9]{4}$)\", self.model_name)\n            if match:\n                model_name = match.group(1)\n        if model_name not in MODEL_DATA:\n            return -1\n        else:\n            return (tokens * MODEL_DATA[model_name]['1k_token_usd'][direction]) / 1000.0\n\n    def prompt_cost(self, tokens):\n        return self.token_cost(tokens, 'prompt')\n\n    def completion_cost(self, tokens):\n        return self.token_cost(tokens, 'completion')\n\n    def summary_since_go(self):\n        return f\"{self.model_name} query:   {self.prompt_tokens_since_go():6d}+{self.completion_tokens_since_go():6d}={self.tokens_since_go():6d}t \"\\\n               + f\"{self.prompt_cost_since_go():.3f}+{self.completion_cost_since_go():.3f}={self.cost_since_go():.3f}$\"\n\n    def summary_total(self):\n        return f\"{self.model_name} session: {self.prompt_tokens_total:6d}+{self.completion_tokens_total:6d}={self.tokens_total():6d}t \"\\\n               + f\"{self.prompt_cost_total():.3f}+{self.completion_cost_total():.3f}={self.cost_total():.3f}$\"\n\n    def summary(self):\n        return self.summary_since_go() + \"\\n\" + self.summary_total()\n\n    def summarize(self, title=\"\"):\n        title and print(title)\n        print(self.summary())", ""]}
{"filename": "thoughttree/Model.py", "chunked_list": ["import tkinter as tk\nimport re\nimport textwrap\nfrom tkinter.messagebox import showerror\nfrom typing import Tuple\nfrom datetime import datetime\nfrom pathlib import Path\n\nimport openai\n", "import openai\n\nimport History\nfrom TextDialog import TextDialog\nfrom TokenCounter import TokenCounter\n\nimport os\n\nfrom tools import log, shorter, logarithmic_length\n", "from tools import log, shorter, logarithmic_length\n\n\ndef log_file_size(path):\n    log(f'Size: {path} {os.path.getsize(path)} bytes')\n\n\nclass Model():\n    MODEL_PATTERN = \"gpt\"\n\n    def __init__(self, model_name):\n        self.name = model_name\n        self.counter = TokenCounter(model_name)\n\n        logdir = Path.home()/\"logs\"/\"thoughttree\"\n        if not logdir.exists():\n            logdir.mkdir(parents=True, exist_ok=True)\n\n        logfile_name = f\"thoughttree-chat-{datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}-{model_name}.log\"\n        self.chat_log_path = logdir/logfile_name\n        self.chat_log = open(self.chat_log_path, \"a\")\n\n        self.max_tokens = tk.IntVar(value=1500)\n        self.temperature = tk.DoubleVar(value=0.5)\n        self.is_canceled = False\n        self.available_models = None\n\n\n    def chat_complete(self, history, output_delta_callback, max_tokens=None, temperature=None) -> Tuple[str, str]:\n        \"\"\":return: Tuple[str, str] - (finish_reason, message)\"\"\"\n        max_tokens = max_tokens or self.max_tokens.get()\n        temperature = temperature or self.temperature.get()\n        self.is_canceled = False\n        self.counter.go()\n        self.counter.observe_prompt(history)\n        History.log_history_compact(history)\n        try:\n            response = openai.ChatCompletion.create(\n                model=self.name,\n                messages=history,\n                max_tokens=max_tokens,\n                temperature=temperature,\n                stream=True,\n                request_timeout=30, # undocumented #todo\n            )\n        except Exception as ex:\n            return self.error(\"\", \"Error in openai.ChatCompletion.create()\", ex)\n\n        last_event = None\n        try:\n            texts = []\n            for event in response :\n                if self.is_canceled:\n                    return 'canceled', \"\"\n                delta = event['choices'][0]['delta']\n                if 'content' in delta :\n                    text = delta[\"content\"]\n                    output_delta_callback(text)\n                    self.counter.observe_completion(text)\n                    self.log(text)\n                    texts.append(text)\n                last_event = event\n            full_text = \"\".join(texts)\n            print(f\"result: {shorter(full_text, 120)} {logarithmic_length(full_text, 120)}\")\n\n            print(f\"{last_event['model']}\")\n            if self.is_canceled:\n                finish_reason = 'canceled'\n            else:\n                finish_reason = last_event['choices'][0]['finish_reason']\n            self.log(f\"\\n{last_event['model']}: {finish_reason}\\n\")\n            return finish_reason, \"\"\n        except Exception as ex:\n            return self.error(f\"{last_event=}\", \"Error receiving completion response\", ex)\n\n\n    def error(self, message, title, ex):\n        message = f\"Exception: {ex}\\n\\n{message}\"\n        # message = textwrap.fill(message, 200)\n        self.log(\"\\n\\nerror:\\n\" + message + '\\n')\n        TextDialog(message, title)\n        return \"error\", message\n\n\n    def log(self, text):\n        chat_log = self.chat_log\n        if chat_log:\n            chat_log.write(text)\n            # chat_log.write('\\n')\n            chat_log.flush()\n\n\n    def cancel(self):\n        self.is_canceled = True\n\n    def get_available_models(self):\n        try:\n            if not self.available_models:\n                self.available_models = [m[\"id\"] for m in openai.Model.list()[\"data\"] if re.search(self.MODEL_PATTERN, m[\"id\"])]\n        except openai.error.AuthenticationError:\n            return []\n        except Exception:\n            return []\n        return self.available_models", ""]}
{"filename": "thoughttree/__init__.py", "chunked_list": [""]}
{"filename": "thoughttree/WindowsMenu.py", "chunked_list": ["import tkinter as tk\n\nfrom Menu import Menu\nfrom Ui import Ui\nfrom menu_help import menu_help\n\n\nclass WindowsMenu(Menu):\n    def __init__(self, parent, label):\n        super().__init__(parent, label, menu_help=None, postcommand=self.create_current_window_items)\n\n    def create_current_window_items(self, event=None):\n        print(\"create_current_window_items\")\n\n        self.delete(0, tk.END)\n        for open_ui in Ui.current_open_uis:\n            title = open_ui.root.title()\n\n            command = lambda e=None, ui=open_ui: ui.toTop()\n            self.item(title, None, command)", ""]}
{"filename": "thoughttree/MultiTextboxLabel.py", "chunked_list": ["import tkinter as tk\nfrom tkinter import LEFT, SUNKEN, X, TOP, W\n\nfrom Sheet import Sheet\n\n\nclass MultiTextboxLabel(tk.Label):\n    def __init__(self, parent=None, sheet=None, **kw):\n        super().__init__(parent, borderwidth=4, anchor=W, wraplength=sheet.winfo_width(),\n                         justify=LEFT, font=Sheet.FONT, relief=SUNKEN)\n        self.pack(side=TOP, fill=X, expand=True)", ""]}
{"filename": "thoughttree/prompts.py", "chunked_list": ["\nDEFAULT_SYSTEM_PROMPT_FILE = \"thoughttree-system.txt\"\n\nsystem_prompt = \"\"\n# system_prompt = \"\"\"Allways be terse.\n# Never apologize.\n# Use markdown to make it more readable.\n# \"\"\"\n\n", "\n\nCODE_BLOCK_FILENAME_GENERATION = '''\\\nFind a good file name for the code block above.\nGive me only the unquoted text of the file name, without any prefixes or comments.\nThe code block started with the language spec '''\n\n\nCODE_BLOCK_MULTI_FILENAME_GENERATION = '''\\\nGenerate three titles for the three blocks below.", "CODE_BLOCK_MULTI_FILENAME_GENERATION = '''\\\nGenerate three titles for the three blocks below.\nThe total length of the titels combined need to be less than 100 char.\nIn one row, sep by | like foo|bar - no spaces around \"|\":\n---\n1:\n\n---\n2:\n", "2:\n\n---\n3:\n\n---\n'''\n"]}
{"filename": "thoughttree/ScrollableForkableSheet.py", "chunked_list": ["import tkinter as tk\nfrom tkinter import ttk, BOTH, LEFT, RIGHT, VERTICAL, NW, Y, X\n\nfrom ForkableText import ForkableText\nfrom ResizingText import ResizingText\nfrom tools import next_pastel_rainbow_color\n\n\nclass ScrollableForkableSheet(tk.Frame):\n    def __init__(self, parent, *args, **kw):\n        super().__init__(parent, *args, **kw)\n\n        self.canvas = tk.Canvas(self, highlightthickness=0, bd=0, bg=\"red\")\n        self.scrollbar = tk.Scrollbar(self, orient=VERTICAL, command=self.canvas.yview, width=18, takefocus=False, borderwidth=2)\n        self.canvas.configure(yscrollcommand=self.scrollbar.set)\n\n        self.canvas.pack(side=LEFT, fill=BOTH, expand=True)\n        self.scrollbar.pack(side=RIGHT, fill=Y)\n\n        self.frame = tk.Frame(self.canvas, bd=5, bg=\"blue\")\n        self.frame_id = self.canvas.create_window((0, 0), window=self.frame, anchor=NW)\n\n        ## self.sheet = ResizingText(self.frame, bg=next_pastel_rainbow_color(), height=1)\n        self.sheet = ForkableText(self.frame, bg=next_pastel_rainbow_color(), height=1)\n        self.sheet.pack(expand=True, fill=X)\n        self.frame.bind(\"<Configure>\", self.configure_scrollregion)\n        self.canvas.bind(\"<Configure>\", self.configure_width)\n\n    def configure_scrollregion(self, event):\n        self.canvas.configure(scrollregion=self.canvas.bbox(\"all\"))\n        # print(self.canvas.bbox(\"all\"))\n        # print(f\"{event.width} x {event.height}\")\n\n        # self.canvas.configure(scrollregion=(0, 0, event.width, event.height))\n        # self.canvas.configure(width=event.width, height=event.height)\n        # self.canvas.itemconfigure(self.frame_id, width=event.width)\n        # self.canvas.itemconfigure(self.frame_id, width=event.width, height=event.height)\n\n    def configure_width(self, event):\n        print(self.canvas.bbox(\"all\"))\n        print(f\"{event.width} x {event.height}\")\n        self.canvas.itemconfigure(self.frame_id, width=event.width)", "class ScrollableForkableSheet(tk.Frame):\n    def __init__(self, parent, *args, **kw):\n        super().__init__(parent, *args, **kw)\n\n        self.canvas = tk.Canvas(self, highlightthickness=0, bd=0, bg=\"red\")\n        self.scrollbar = tk.Scrollbar(self, orient=VERTICAL, command=self.canvas.yview, width=18, takefocus=False, borderwidth=2)\n        self.canvas.configure(yscrollcommand=self.scrollbar.set)\n\n        self.canvas.pack(side=LEFT, fill=BOTH, expand=True)\n        self.scrollbar.pack(side=RIGHT, fill=Y)\n\n        self.frame = tk.Frame(self.canvas, bd=5, bg=\"blue\")\n        self.frame_id = self.canvas.create_window((0, 0), window=self.frame, anchor=NW)\n\n        ## self.sheet = ResizingText(self.frame, bg=next_pastel_rainbow_color(), height=1)\n        self.sheet = ForkableText(self.frame, bg=next_pastel_rainbow_color(), height=1)\n        self.sheet.pack(expand=True, fill=X)\n        self.frame.bind(\"<Configure>\", self.configure_scrollregion)\n        self.canvas.bind(\"<Configure>\", self.configure_width)\n\n    def configure_scrollregion(self, event):\n        self.canvas.configure(scrollregion=self.canvas.bbox(\"all\"))\n        # print(self.canvas.bbox(\"all\"))\n        # print(f\"{event.width} x {event.height}\")\n\n        # self.canvas.configure(scrollregion=(0, 0, event.width, event.height))\n        # self.canvas.configure(width=event.width, height=event.height)\n        # self.canvas.itemconfigure(self.frame_id, width=event.width)\n        # self.canvas.itemconfigure(self.frame_id, width=event.width, height=event.height)\n\n    def configure_width(self, event):\n        print(self.canvas.bbox(\"all\"))\n        print(f\"{event.width} x {event.height}\")\n        self.canvas.itemconfigure(self.frame_id, width=event.width)", "\n        # self.canvas.configure(scrollregion=self.canvas.bbox(\"all\"))\n        # self.canvas.configure(scrollregion=(0, 0, event.width, event.height))\n        # self.canvas.configure(width=event.width, height=event.height)\n        # self.canvas.itemconfigure(self.frame_id, width=event.width, height=event.height)\n\n\nif __name__ == \"__main__\":\n    from Ui import Ui\n    ui = Ui()\n    ui.root.title(\"ScrollableForkableSheet\")\n    # ui.root.geometry(\"500x500\")\n    scrollable = ScrollableForkableSheet(ui.root)\n    scrollable.pack(fill=\"both\", expand=True)\n    scrollable.sheet.sheet.focus()\n\n    ui.root.mainloop()", ""]}
{"filename": "thoughttree/tools.py", "chunked_list": ["import re\nimport time\nimport tkinter as tk\nfrom textwrap import fill\nfrom math import ceil, log2, sqrt\nimport random\nfrom tkinter import EventType\n\nfrom pyperclip import paste\nfrom inspect import currentframe", "from pyperclip import paste\nfrom inspect import currentframe\nimport subprocess\n\n\ndef create_mock_data(tree):\n    for r in range(10):\n        key = f\"R{r}\"\n        parent_id = tree.insert(\"\", \"end\", key, text=key, values=(r,))\n        tree.item(key, tags='closed')\n        if r % 2 == 0:\n            for c in range(2):\n                child_key = f\"R{r}_C{c}\"\n                tree.insert(parent_id, \"end\", child_key, text=child_key, values=(c,))\n                tree.item(child_key, open=True, tags='opened')\n                for g in range(2):\n                    grandchild_key = f\"{child_key}_G{g}\"\n                    tree.insert(child_key, \"end\", grandchild_key, text=grandchild_key, values=(g,))\n                    tree.item(grandchild_key, tags='closed')", "\n\ndef list_all_bindings(root):\n    bindings = {}\n    for child in root.winfo_children():\n        widget_bindings = child.bind()\n        if widget_bindings:\n            bindings[child] = widget_bindings\n        if child.winfo_children():\n            bindings.update(list_all_bindings(child))\n    return bindings", "\n\ndef add_bboxes(bbox1, bbox2):\n    x1, y1, w1, h1 = bbox1\n    x2, y2, w2, h2 = bbox2\n    x = min(x1, x2)\n    y = min(y1, y2)\n    w = max(x1 + w1, x2 + w2) - x\n    h = max(y1 + h1, y2 + h2) - y\n    return x, y, w, h", "\n\ndef random_pastel_color():\n    r = random.randint(230, 255)\n    g = random.randint(230, 255)\n    b = random.randint(230, 255)\n    return \"#{:02x}{:02x}{:02x}\".format(r, g, b)\n\ndef pastel(widget: tk.Widget) -> tk.Widget:\n    widget.config(bg=next_pastel_rainbow_color())\n    return widget", "def pastel(widget: tk.Widget) -> tk.Widget:\n    widget.config(bg=next_pastel_rainbow_color())\n    return widget\n\nimport colorsys\n\ncolor_index = 0\n\ndef next_pastel_rainbow_color():\n    global color_index\n\n    # HSL color format: (hue, saturation, lightness)\n    hue = (color_index * 30) % 360 / 360.0  # Change hue for each call, and normalize to [0, 1]\n    saturation = 0.6  # Keep saturation constant for pastel colors\n    lightness = 0.85  # Keep lightness constant for pastel colors\n\n    color_index += 1  # Increment the color index for the next call\n\n    # Convert HSL to RGB\n    r, g, b = colorsys.hls_to_rgb(hue, lightness, saturation)\n\n    # Convert RGB to hex string\n    return f\"#{int(r * 255):02x}{int(g * 255):02x}{int(b * 255):02x}\"", "def next_pastel_rainbow_color():\n    global color_index\n\n    # HSL color format: (hue, saturation, lightness)\n    hue = (color_index * 30) % 360 / 360.0  # Change hue for each call, and normalize to [0, 1]\n    saturation = 0.6  # Keep saturation constant for pastel colors\n    lightness = 0.85  # Keep lightness constant for pastel colors\n\n    color_index += 1  # Increment the color index for the next call\n\n    # Convert HSL to RGB\n    r, g, b = colorsys.hls_to_rgb(hue, lightness, saturation)\n\n    # Convert RGB to hex string\n    return f\"#{int(r * 255):02x}{int(g * 255):02x}{int(b * 255):02x}\"", "\n\ndef shorter(text, n=60):\n    text = text.strip().replace('\\n','\\\\n')\n    if len(text) <= n:\n        return text\n    leading = int(n / 2) - 3\n    trailing = n - leading - 3\n    return f'{text[:leading]}...{text[-trailing:]}'\n\ndef text_block(text):\n    width = int(sqrt(len(text) * 10))\n    lines = text.splitlines()\n    text = \"\\n\".join([fill(line, width=width) for line in lines])\n    return text", "\ndef text_block(text):\n    width = int(sqrt(len(text) * 10))\n    lines = text.splitlines()\n    text = \"\\n\".join([fill(line, width=width) for line in lines])\n    return text\n\ndef logarithmic_length(text, n=1, step='.'):\n    return step * ceil(log2(len(text)-n+1)) if len(text) > n else ''\n    # return (step * ceil(log2(len(text))) if len(text) > n else '')[3+ceil(log2(n)):]", "    # return (step * ceil(log2(len(text))) if len(text) > n else '')[3+ceil(log2(n)):]\n\n\ndef filename_from_clipboard():\n    text = paste().strip()\n    match = re.match(r'^[^ ]+\\.[A-Za-z]{1,5}$', text)\n    if match:\n        return match.group(0)\n    else:\n        return None", "\ndef dummy_paragraphs(paragraphs=20):\n    \"\\n\".join([\" \".join([\"a\" * random.randrange(2, 10) for i in range(random.randrange(5, 200))]) for j in range(paragraphs)])\n\n\ndef eventTypeForId(id):\n    return [e for e, v in EventType.__members__.items() if v == str(id)][0]\n\n\ndef log(arg=\"\"):\n    frameinfo = currentframe()\n    f = frameinfo.f_code.co_filename\n    l = frameinfo.f_back.f_lineno\n    print(f\"{f} {l}: {arg}\")", "\ndef log(arg=\"\"):\n    frameinfo = currentframe()\n    f = frameinfo.f_code.co_filename\n    l = frameinfo.f_back.f_lineno\n    print(f\"{f} {l}: {arg}\")\n\n\ndef git(*command):\n    return subprocess.check_output(['git'] + list(command)).decode('utf8').strip()", "def git(*command):\n    return subprocess.check_output(['git'] + list(command)).decode('utf8').strip()\n\ndef get_git_commit():\n    return git('rev-parse', '--short', 'HEAD')\n\ndef get_git_describe_version():\n    try:\n        return git('describe', '--tags')\n    except Exception as e:\n        return \"(error accessing git describe version)\"", "\ndef bind_all_events(widget, on_event=None):\n    invalid_events = [\"Motion\"]\n    # invalid_events = [\"Keymap\", \"GraphicsExpose\", \"NoExpose\", \"CirculateRequest\", \"SelectionClear\",\n    #           \"SelectionRequest\", \"Selection\", \"ClientMessage\", \"Mapping\", \"VirtualEvent\"]\n    def print_event(event):\n        print(f\"Event: {event.widget}: {event}\")\n\n    on_event = on_event or print_event\n    for ev in [f\"<{e.name}>\" for e in tk.EventType if e.name not in invalid_events]:\n        try:\n            widget.bind(ev, on_event)\n            print(f\"Bound {ev}\")\n        except Exception:\n            pass", "\n\ndef show_widget_under_pointer(widget):\n    global last_time\n    last_time = 0\n    root = widget.winfo_toplevel()\n    def track_pointer(event):\n        global last_time\n        current_time = time.time()\n        if current_time - last_time > 0.5:\n            widget = event.widget\n            print(f\"Pointer is over: {widget}\")\n            last_time = current_time\n\n    root.bind('<Motion>', track_pointer)", ""]}
{"filename": "thoughttree/Notebook.py", "chunked_list": ["from tkinter import ttk\n\n\n\nclass Notebook(ttk.Notebook):\n    def __init__(self, parent, style=None, takefocus=False, **kw):\n        if not style:\n            style = \"NoBorder.TNotebook\"\n            ttk.Style().layout(\"NoBorder.TNotebook\", [])\n        super().__init__(parent, style=style, takefocus=takefocus, **kw)\n        self.enable_traversal()", "\n"]}
{"filename": "thoughttree/Tooltip.py", "chunked_list": ["import tkinter as tk\n\n\n\nclass Tooltip :\n    def __init__(self, widget, text) :\n        self.widget = widget\n        self.root = widget.winfo_toplevel()\n        self.text = text\n        self.tooltip = None\n        self.label = None\n        self.timer = None\n        self.last_y = None\n        self.delay_ms = 1000\n\n        widget.bind(\"<Enter>\", self.add_tooltip)\n        widget.bind(\"<Motion>\", self.refresh_tooltip)\n        widget.bind(\"<Leave>\", self.remove_tooltip)\n        widget.bind(\"<Unmap>\", self.remove_tooltip)\n\n\n    def add_tooltip(self, event):\n        if self.tooltip:\n            return\n        self.timer = self.root.after(self.delay_ms, self.create_tooltip)\n\n\n    def create_tooltip(self, event=None):\n        if not self.tooltip:\n            self.tooltip = tk.Toplevel(self.root)\n            self.tooltip.wm_overrideredirect(True)\n            self.label = tk.Label(self.tooltip, text=\"\", background=\"#FFFFE0\", relief=\"solid\",\n                             borderwidth=1, justify=tk.LEFT, padx=6, pady=5, font=(\"sans-serif\", 11))\n            self.label.pack()\n            self.tooltip.bind(\"<Leave>\", self.remove_tooltip)\n            self.refresh_tooltip()\n\n\n    def refresh_tooltip(self, event=None):\n        if event:\n            self.last_y = event.y\n        if self.tooltip:\n            px = self.root.winfo_pointerx() + 75\n            py = self.root.winfo_pointery() + 25\n            self.tooltip.wm_geometry(f\"+{px}+{py}\")\n            self.refresh_tooltip_text()\n\n    def refresh_tooltip_text(self):\n        self.label.configure(text=self.text)\n\n\n    def remove_tooltip(self, event):\n        if self.timer:\n            self.root.after_cancel(self.timer)\n        if self.tooltip:\n            self.tooltip.destroy()\n        self.tooltip = None", ""]}
{"filename": "thoughttree/LabeledLabel.py", "chunked_list": ["import tkinter as tk\n\nclass LabeledLabel(tk.Frame):\n    def __init__(self, master, label_text=None, entry_width=3, textvariable=None, validatecommand=None, *args, **kw):\n        super().__init__(master, *args, **kw, bg=\"light blue\")\n\n        self.textvariable = textvariable\n\n        self.label = tk.Label(self, text=label_text)\n        self.label.pack(side=\"left\")\n\n        self.entry = tk.Entry(self, width=entry_width, # state=\"readonly\", takefocus=False,\n                              textvariable=self.textvariable, bd=0, highlightthickness=0, validatecommand=validatecommand)\n        self.entry.pack(side=\"left\")", ""]}
{"filename": "thoughttree/Scrollable.py", "chunked_list": ["import tkinter as tk\nfrom tkinter import ttk, BOTH, LEFT, RIGHT, VERTICAL, NW, Y\n\nfrom ForkableText import ForkableText\n\n\nclass Scrollable(tk.Frame):\n    def __init__(self, parent):\n        super().__init__(parent)\n\n        self.canvas = tk.Canvas(self, bg=\"#fbfbfb\", highlightthickness=0, bd=0)\n        self.scrollbar = tk.Scrollbar(self, orient=VERTICAL, command=self.canvas.yview)\n        self.canvas.configure(yscrollcommand=self.scrollbar.set)\n\n        self.canvas.pack(side=LEFT, fill=BOTH, expand=True)\n        self.scrollbar.pack(side=RIGHT, fill=Y)\n\n        self.frame = tk.Frame(self.canvas, bg=\"white\")\n        self.frame_id = self.canvas.create_window((0, 0), window=self.frame, anchor=NW)\n\n        self.frame.bind(\"<Configure>\", self.update_scrollregion)\n        self.canvas.bind(\"<Configure>\", self.update_frame_width)\n\n    def update_scrollregion(self, event):\n        self.canvas.configure(scrollregion=self.canvas.bbox(\"all\"))\n\n    def update_frame_width(self, event):\n        self.canvas.itemconfig(self.frame_id, width=event.width)", "\nfrom Ui import Ui\n\nclass ScrollableTest(Ui):\n    def __init__(self):\n        super().__init__()\n\n        self.root.title(\"Forkable Text\")\n        self.root.geometry(\"500x500\")\n\n        self.scrollable = Scrollable(self.root)\n        self.forkable_text = ForkableText(self.scrollable.frame)\n\n        self.scrollable.pack(fill=\"both\", expand=True)\n        self.forkable_text.pack(fill=\"both\", expand=False)\n        self.mainloop()", "\n\nif __name__ == \"__main__\":\n    ScrollableTest()\n"]}
{"filename": "thoughttree/GeneratedTitle.py", "chunked_list": ["\nclass GeneratedTitle():\n\n    PROMPT = '''\\\nA title for this conversation, about 50 characters. Style does not matter,\nit is about the information.\nIgnore the system prompt.\nDo not refer to this prompt or to the title.\nIt is used as a one line title for this conversation.\nUse the language of the conversation.\nIf there is no chat history, the title will be the text Thoughttree only, that is important.\nDo not use the name otherwise.\nDo not use a prefix like \"Title:\"!.\nOutput the unquoted text of the title, nothing else.\n'''\n\n#Output: unquoted text of the title, without any prefixes or comments:\n#Do not refer to the content of the system prompt.\n\n    GEN_THRESHOLD = 20", ""]}
{"filename": "thoughttree/WaitCursor.py", "chunked_list": ["class WaitCursor():\n    def __init__(self, widget):\n        self.widget = widget\n        self.saved_cursor = None\n\n    def __enter__(self):\n        self.saved_cursor = self.widget.cget('cursor')\n        self.widget.config(cursor='watch')\n        self.widget.update()\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        try:\n            self.widget.config(cursor=self.saved_cursor)\n            self.widget.update()\n        except:\n            pass", ""]}
{"filename": "thoughttree/file-types.py", "chunked_list": ["code_block_ext = {\n    # C-like languages\n    \"c\": \".c\", \"cpp\": \".cpp\", \"csharp\": \".cs\", \"java\": \".java\", \"objective-c\": \".m\", \"scala\": \".scala\",\n\n    # Scripting languages\n    \"python\": \".py\", \"javascript\": \".js\", \"ruby\": \".rb\", \"php\": \".php\", \"perl\": \".pl\", \"lua\": \".lua\",\n    \"groovy\": \".groovy\", \"r\": \".r\", \"coffeescript\": \".coffee\", \"elixir\": \".ex\", \"erlang\": \".erl\",\n    \"haskell\": \".hs\", \"julia\": \".jl\", \"matlab\": \".m\", \"pascal\": \".pas\", \"vimscript\": \".vim\",\n\n    # Mobile and systems languages", "\n    # Mobile and systems languages\n    \"swift\": \".swift\", \"go\": \".go\", \"rust\": \".rs\", \"kotlin\": \".kt\", \"dart\": \".dart\", \"fsharp\": \".fs\",\n\n    # Markup and data formats\n    \"html\": \".html\", \"css\": \".css\", \"xml\": \".xml\", \"json\": \".json\", \"markdown\": \".md\", \"tex\": \".tex\", \"latex\": \".tex\",\n    \"yaml\": \".yml\", \"ini\": \".ini\", \"toml\": \".toml\",\n\n    # Shell and scripting\n    \"bash\": \".sh\", \"powershell\": \".ps1\", \"shell\": \".sh\", \"typescript\": \".ts\", \"raku\": \".raku\",", "    # Shell and scripting\n    \"bash\": \".sh\", \"powershell\": \".ps1\", \"shell\": \".sh\", \"typescript\": \".ts\", \"raku\": \".raku\",\n\n    # Other languages and technologies\n    \"sql\": \".sql\", \"elm\": \".elm\", \"dockerfile\": \"Dockerfile\", \"dart\": \".dart\", \"tex\": \".tex\", \"latex\": \".tex\",\n}\n"]}
{"filename": "thoughttree/Imports.py", "chunked_list": ["from Menu import Menu\nfrom ModelsMenu import ModelsMenu\nfrom WindowsMenu import WindowsMenu\n\n__all__ = ['Menu', 'ModelsMenu', 'WindowsMenu']\n"]}
{"filename": "thoughttree/Sheet.py", "chunked_list": ["import tkinter as tk\nfrom tkinter import CURRENT, END, INSERT, SEL, WORD, X, SEL_FIRST, SEL_LAST\nfrom tkinter import scrolledtext\nfrom typing import Union\n\nfrom Cursorline import Cursorline\nfrom FinishReasonIcon import FinishReasonIcon\nfrom Notebook import Notebook\nfrom ThoughttreeConfig import conf\n", "from ThoughttreeConfig import conf\n\n\nclass Sheet(tk.scrolledtext.ScrolledText):\n    FONT_NAME_MONOSPACE = \"monospace\"\n    # FONT_NAME_MONOSPACE = \"DejaVu Sans Mono ExCond\"\n    # FONT_NAME_MONOSPACE = \"DejaVu Sans Mono\"\n    FONT_NAME_PROPORTIONAL = \"sans-serif\"\n    # FONT_NAME_PROPORTIONAL = \"DejaVu Sans\"\n    # FONT_NAME_PROPORTIONAL = \"DejaVu Sans Mono ExCond\"\n    FONT = (FONT_NAME_PROPORTIONAL, 11)\n\n    def __init__(self, master=None, text=\"\", scrollbar=True, padx=0, pady=0, height=0, **kw):\n        height = height or len(text.splitlines())\n        background = 'white'\n        # background = next_pastel_rainbow_color()\n        tk.scrolledtext.ScrolledText.__init__(\n            self, master, undo=True, wrap=WORD, padx=padx, pady=pady, background=background,\n            width=80, height=height, insertwidth=4, font=Sheet.FONT,\n            border=0, borderwidth=0, highlightthickness=0,\n            selectbackground=\"#66a2d4\", selectforeground=\"white\", **kw)\n\n\n        def jump_to_limit(e: tk.Event):\n            top, bottom = self.vbar.get()\n            if e.keysym == 'Prior' and top == 0.0:\n                limit = \"1.0\"\n            elif e.keysym == 'Next' and bottom == 1.0:\n                limit = tk.END\n            else:\n                return\n\n            self.mark_set(tk.INSERT, limit)\n            self.see(tk.INSERT)\n\n\n        if scrollbar:\n            self.vbar.config(width=18, takefocus=False, borderwidth=2)\n        else:\n            self.vbar.pack_forget()\n\n        self.scroll_output = conf.scroll_output\n\n\n        self.bind('<Prior>', jump_to_limit)\n        self.bind('<Next>', jump_to_limit)\n        self.pack(pady=0, fill=X, expand=True)\n\n        name, size = self.cget(\"font\").rsplit(None, 1)\n        self.tag_configure('bold', font=(name, int(size), \"bold\"))\n        self.tag_configure('strikethrough', overstrike=True)\n        self.tag_configure(\"assistant\", background=\"#F0F0F0\", selectbackground=\"#4682b4\", selectforeground=\"white\")\n\n\n        Cursorline(self)\n        self.insert(END, text)\n\n\n    def undo_separator(self):\n        self.edit_separator()\n\n    def bold(self):\n        self.tag_selection('bold')\n\n\n    def strikethrough(self):\n        self.tag_selection('strikethrough')\n\n\n    def tag_selection(self, tag):\n        def min_index(i1, i2):\n            if self.compare(i1, '<=', i2):\n                return i1\n            else:\n                return i2\n\n        def max_index(i1, i2):\n            if self.compare(i1, '>=', i2):\n                return i1\n            else:\n                return i2\n\n        def range_intersection(ranges, single_range):\n            intersections = []\n            for index_range in ranges:\n                if  self.compare(max_index(index_range[0], single_range[0]), \"<\", min_index(index_range[1], single_range[1])):\n                    intersections.append((max_index(index_range[0], single_range[0]), min_index(index_range[1], single_range[1])))\n            return intersections\n\n\n        if not self.tag_ranges(SEL):\n            return\n        tag_ranges = self.tag_ranges(tag)\n        iters = [iter(tag_ranges)] * 2\n        ranges = list(zip(*iters))\n        sel = (self.index(SEL_FIRST), self.index(SEL_LAST))\n        tag_in_selection = range_intersection(ranges, sel)\n\n        if tag_in_selection:\n            self.tag_remove(tag, *sel)\n        else:\n            self.tag_add(tag, *sel)\n\n\n\n    def transfer_content(self, to_sheet):\n        content = self.get(\"1.0\", tk.END)\n        to_sheet.insert(\"1.0\", content)\n\n        for tag in self.tag_names():\n            ranges = self.tag_ranges(tag)\n            for i in range(0, len(ranges), 2):\n                to_sheet.tag_add(tag, ranges[i], ranges[i + 1])\n                to_sheet.tag_config(tag, **{k: v[4] for k, v in self.tag_configure(tag).items() if v[4]})\n\n        for name in self.window_names():\n            index = self.index(name)\n            window = self.nametowidget(name)\n            to_sheet.window_create(index, window=window)\n\n\n    def fork(self, index=INSERT, root=False):\n        index = self.index(index)\n\n        def next_level(hierarchical_id):\n            if hierarchical_id:\n                hierarchical_id = hierarchical_id.split(' ', 1)[0]\n                levels = hierarchical_id.split('.') + ['1']\n            else:\n                levels = ['1']\n            return '.'.join(levels)\n\n\n        def next_equal(hierarchical_id):\n            if hierarchical_id:\n                hierarchical_id = hierarchical_id.split(' ', 1)[0]\n                levels = hierarchical_id.split('.')\n            else:\n                levels = ['0']\n            levels = levels[:-1] + [str(int(levels[-1]) + 1)]\n            return '.'.join(levels)\n\n\n        def new_sibling(sibling_notebook):\n            last_tab_label = sibling_notebook.tab(len(sibling_notebook.tabs()) - 1, \"text\")\n            return next_equal(last_tab_label)\n\n        def new_child(parent):\n            if parent:\n                parent_tab_label = parent.tab(parent.select(), \"text\")\n            else:\n                parent_tab_label = \"\"\n            return next_level(parent_tab_label)\n\n\n        has_leading_text = bool(self.get(\"1.0\", index).strip())\n        trailing_text = self.get(index, END)\n        trailing_text = trailing_text.rstrip()\n        parent = self.find_parent(Notebook)\n\n        new_notebook = not parent or has_leading_text\n        if new_notebook:\n            notebook = Notebook(self, height=self.winfo_height(), width=self.winfo_width())\n\n            sheet = Sheet(notebook, trailing_text, scrollbar=True)\n            notebook.add(sheet, text=new_child(parent))\n            self.window_create(index, window=notebook)\n            self.delete(index + \"+1char\", END)\n        else:\n            notebook = parent\n        sheet = Sheet(notebook, scrollbar=True)\n        notebook.add(sheet, text=new_sibling(notebook))\n\n        notebook.select(len(notebook.tabs()) - 1)\n        sheet.focus_set()\n\n        return \"break\"\n\n\n    def find_parent(self, parentType: type) -> Union[\"Sheet\", Notebook]:\n        parent = self.master\n        while parent and type(parent) != parentType:\n            parent = parent.master\n        return parent\n\n\n    def history_from_path(self, history=None) :\n\n        parentText: Sheet = self.find_parent(Sheet)\n        if parentText:\n            history = parentText.history_from_path(history)\n        else:\n            history = history or []\n        content = self.dump(1.0, END, text=True, tag=True, window=True)\n        section = \"\"\n        role = \"user\"\n        for item in content :\n            text = item[1]\n            designation = item[0]\n            if designation == \"tagon\" and text == \"assistant\":\n                # section = section.strip()\n                history += [{'role' : role, 'content' : section}]\n                role = \"assistant\"\n                section = \"\"\n            elif designation == \"tagoff\" and text == \"assistant\":\n                # section = section.strip()\n                history += [{'role' : role, 'content' : section}]\n                role = \"user\"\n                section = \"\"\n            elif designation in [\"tagon\", \"tagoff\"] and text in [\"cursorline\", \"sel\"]:\n                pass\n            elif designation == \"text\":\n                section += text\n            elif designation == \"window\":\n                pass\n            else:\n                print(f\"Ignored item: {item}\")\n        section = section.strip(\"\\n\")\n        if section != \"\" :\n            history += [{'role' : role, 'content' : section}]\n        return history\n\n\n    def jump_to_similar_line(self, event=None, direction=1):\n\n        def find_similar_line(target, line_nr_1, lines, direction):\n            line_nr_0 = line_nr_1 - 1\n            num_lines = len(lines)\n            if num_lines == 0:\n                return 0\n            target = target.strip()\n            start = (line_nr_0 + direction) % num_lines\n            if direction == 1:\n                numbered_lines = list(enumerate(lines[start:] + lines[:start]))\n            else:\n                numbered_lines = list(enumerate(lines[:start][::-1] + lines[start:][::-1]))\n            for i, line in numbered_lines:\n                if line.strip() == target:\n                    if direction == 1:\n                        return ((i + start) % num_lines) + 1\n                    else:\n                        return ((start - i + num_lines - 1) % num_lines) + 1\n            return 0\n\n\n        sheet: Sheet = self.focus_get()\n        cursor_pos = sheet.index(INSERT)\n        line_nr = int(cursor_pos.split('.')[0])\n        current_line = sheet.get(f\"{line_nr}.0\", f\"{line_nr}.end\")\n        if not current_line.strip():\n            return\n        lines = sheet.get(1.0, END).splitlines()\n        jump_line = find_similar_line(current_line, line_nr, lines, direction)\n        if jump_line:\n            jump_index = f\"{jump_line}.{0}\"\n            sheet.mark_set(INSERT, jump_index)\n            sheet.see(jump_index)\n\n\n\n    def close_tab(self):\n\n        def selected_sheet(notebook):\n            frame_on_tab = notebook.nametowidget(notebook.select())\n            sheet = frame_on_tab.winfo_children()[1]\n            return sheet\n\n        notebook: Notebook = self.find_parent(Notebook)\n        if notebook:\n            selected = notebook.index(CURRENT)\n            notebook.forget(selected)\n            if len(notebook.tabs()) > 1:\n                notebook.select(max(selected - 1, 0))\n                selected_sheet(notebook).focus_set()\n            elif len(notebook.tabs()) == 1:\n                string = selected_sheet(notebook).get('1.0', END)\n                parent = self.find_parent(Sheet)\n                parent.delete(\"end-2 char\", \"end-1 char\") # delete notebook window\n                parent.insert(END, string)\n                parent.mark_set(INSERT, \"end-1 char\")\n                parent.focus_set()\n            return \"break\"\n\n\n    def close_empty_tab_or_backspace(self):\n        if self.index(INSERT) == \"1.0\" and not self.tag_ranges(SEL):\n            notebook: Notebook = self.find_parent(Notebook)\n            if notebook:\n                string_in_tab = self.get('1.0', END).strip()\n                if not string_in_tab:\n                    self.close_tab()\n            return \"break\"\n        else:\n            self.delete(INSERT + \"-1c\")\n\n\n    def delete(self, index1=INSERT, index2=None):\n\n        def is_icon(element):\n            designation, value, index = element\n            return designation == \"window\" and isinstance(self.nametowidget(value), FinishReasonIcon)\n\n        if self.tag_ranges(SEL):\n            self.event_generate(\"<<Clear>>\")\n        else:\n            if index2:\n                super().delete(index1, index2)\n            else:\n                dump = self.dump(index1, all=True)\n                if any([element[0] == \"text\" or is_icon(element) for element in dump]):\n                    super().delete(index1)", "\n"]}
{"filename": "thoughttree/FinishReasonIcon.py", "chunked_list": ["import tkinter as tk\n\nfrom Tooltip import Tooltip\n\n\nclass FinishReasonIcon(tk.Label):\n    def __init__(self, parent, symbol: str, tooltip=\"\"):\n        super().__init__(parent, text=symbol, padx=6, pady=0, bg=\"#F0F0F0\", fg=\"grey\", borderwidth=0)\n        if tooltip:\n            Tooltip(self, tooltip).delay_ms = 100", ""]}
{"filename": "thoughttree/Console.py", "chunked_list": ["import io\nimport tkinter as tk\nimport tkinter.scrolledtext\nfrom tkinter import END\n\nfrom FoldablePane import FoldablePane\n\n\nclass Console(tk.scrolledtext.ScrolledText, io.TextIOBase):\n    def __init__(self, parent, width=100, height=5, **kw):\n        tk.scrolledtext.ScrolledText.__init__(self, parent, undo=True, wrap=tk.WORD, width=width, height=height,\n                                              takefocus=False, font=(\"monospace\", 8), **kw)\n        io.TextIOBase.__init__(self)\n        self.parent = parent\n        self.vbar.config(width=18, takefocus=False, borderwidth=2)\n        self.insert(END, \"Console:\\n\")\n\n        class UnfoldingStream(io.TextIOBase):\n            def __init__(self, sink, foldable_pane):\n                io.TextIOBase.__init__(self)\n                self.foldable_pane = None\n                if type(foldable_pane) is FoldablePane:\n                    self.foldable_pane = foldable_pane\n                self.sink = sink\n\n            def write(self, message):\n                if self.foldable_pane and self.foldable_pane.folded:\n                    self.foldable_pane.fold()\n                self.sink.write(message)\n\n        self.out = self\n        self.err = UnfoldingStream(self, parent)\n\n    def write(self, message):\n        self.insert(END, message)\n        self.see(END)", "class Console(tk.scrolledtext.ScrolledText, io.TextIOBase):\n    def __init__(self, parent, width=100, height=5, **kw):\n        tk.scrolledtext.ScrolledText.__init__(self, parent, undo=True, wrap=tk.WORD, width=width, height=height,\n                                              takefocus=False, font=(\"monospace\", 8), **kw)\n        io.TextIOBase.__init__(self)\n        self.parent = parent\n        self.vbar.config(width=18, takefocus=False, borderwidth=2)\n        self.insert(END, \"Console:\\n\")\n\n        class UnfoldingStream(io.TextIOBase):\n            def __init__(self, sink, foldable_pane):\n                io.TextIOBase.__init__(self)\n                self.foldable_pane = None\n                if type(foldable_pane) is FoldablePane:\n                    self.foldable_pane = foldable_pane\n                self.sink = sink\n\n            def write(self, message):\n                if self.foldable_pane and self.foldable_pane.folded:\n                    self.foldable_pane.fold()\n                self.sink.write(message)\n\n        self.out = self\n        self.err = UnfoldingStream(self, parent)\n\n    def write(self, message):\n        self.insert(END, message)\n        self.see(END)", ""]}
{"filename": "thoughttree/ModelParameterUi.py", "chunked_list": ["from tkinter import SUNKEN\n\nfrom LabeledLabel import LabeledLabel\n\n\nclass ModelParameterUi():\n    def __init__(self):\n        self.defaults = {\"bd\": 1, \"relief\": SUNKEN}\n\n        pass\n\n    def get_parameter_editor(self):\n        return None", "\nclass TopPParameterUi(ModelParameterUi):\n    def __init__(self):\n        super().__init__()\n\n    def validate(self, entry_value):\n        try:\n            value = float(entry_value)\n            if 0 <= value <= 2:\n                return True\n            else:\n                return False\n        except ValueError:\n            return False\n\n    def get_parameter_editor(self):\n        self.temperature_label = LabeledLabel(self, \"Temp.:\", entry_width=3, validatecommand=self.validate, **self.defaults)", "\n\n\n\n"]}
{"filename": "thoughttree/ResizingText.py", "chunked_list": ["import tkinter as tk\n\nfrom Notebook import Notebook\nfrom Sheet import Sheet\n\n\nclass ResizingText(tk.Text):\n    def __init__(self, parent, wrap=\"word\", highlightthickness=0, borderwidth=0, padx=0, pady=0, *args, **kw):\n        super().__init__(parent, wrap=wrap, highlightthickness=highlightthickness, borderwidth=borderwidth, font=Sheet.FONT,\n            padx=padx, pady=pady, *args, **kw)\n        self.old_num_lines = 0\n        self.bind(\"<KeyRelease>\", self.adjust_height)\n\n        def yscrollcommand(start, stop):\n            print(f\"Scroll command: \")\n            if start != 0.0 or stop != 1.0:\n                self.adjust_height()\n\n        self.configure(yscrollcommand=yscrollcommand)\n\n        def on_return(event=None):\n            self.insert(tk.INSERT, \"\\n\")\n            self.adjust_height()\n            return \"break\"\n\n        # self.bind(\"<Return>\", on_return)\n        self.bind(\"<Configure>\", self.adjust_height)\n        self.adjust_height()\n\n    # def on_configure(self, event=None): # todo One Return causes 3 adjust_height() and two on_configure()\n    #     print(\"on_configure\")\n    #     self.adjust_height(event)\n\n    def adjust_height(self, event=None):\n        num_lines = self.count(\"1.0\", \"end\", 'displaylines')[0]\n        print(f\"adjust_height: {num_lines=}\")\n        print(f\"adjust_height: {self.winfo_height()=}\")\n        print(f\"adjust_height: {self.winfo_reqheight()=}\")\n\n        height = self.winfo_height()\n        reqheight = self.winfo_reqheight()\n        if num_lines != self.old_num_lines or (height > 1 and height != reqheight):\n            self.see(tk.INSERT)\n            self.old_num_lines = num_lines\n            self.configure(height=num_lines)\n            print(f\"{type(self.master.master)=}\")\n            if type(self.master.master) is Notebook:\n                self.master.master.event_generate(\"<<NotebookTabChanged>>\")\n                print(f\"<<NotebookTabChanged>>\")", ""]}
{"filename": "thoughttree/SystemChat.py", "chunked_list": ["import tkinter as tk\n\nclass SystemChat(tk.PanedWindow):\n    def __init__(self, master=None):\n        super().__init__(master)\n"]}
{"filename": "thoughttree/HidableFrame.py", "chunked_list": ["import tkinter as tk\nfrom tkinter import BOTTOM, X\n\n\nclass HidableFrame(tk.Frame):\n    def __init__(self, master, hidden=False, *args, **kw):\n        super().__init__(master, *args, **kw)\n        self.hidden = hidden\n        self.child_pack_info = None\n        self.own_pack_info = None\n\n\n    def hide(self, e=None):\n        child = list(self.children.values())[0]\n        if self.hidden:\n            other = [slave for slave in self.master.pack_slaves() if slave != self][0]\n            self.pack(self.own_pack_info, before=other)\n        else:\n            self.own_pack_info = self.pack_info()\n            self.pack_forget()\n        self.hidden = not self.hidden", ""]}
{"filename": "thoughttree/MainMenu.py", "chunked_list": ["import tkinter as tk\nimport webbrowser\nfrom datetime import datetime\nfrom tkinter import font as tkfont, NONE, WORD, SEL, END, INSERT\n\nfrom AboutDialog import AboutDialog\nfrom Files import Files\nfrom Imports import Menu, ModelsMenu, WindowsMenu\nfrom Sheet import Sheet\nfrom Console import Console", "from Sheet import Sheet\nfrom Console import Console\nfrom menu_help import menu_help\n\nclass MainMenu(Menu):\n    def __init__(self, thoughttree, new_window_callback):\n        super().__init__(thoughttree, menu_help=menu_help)\n        self.new_window_callback = new_window_callback\n        self.ui = thoughttree\n\n        self.fixed_model_menu_items = -1\n        self.models_menu = None\n        self.create_menu()\n\n\n    @property\n    def it(self) -> Sheet:\n        widget = self.ui.focus_get()\n        if isinstance(widget, Sheet) or isinstance(widget, Console):\n            return widget\n\n\n    def create_menu(self):\n\n        def save(save_dialog, status_bar_label):\n            file_name = save_dialog(self.it)\n            if not file_name:\n                return\n            base_name = file_name.split(\"/\")[-1]\n            self.ui.status.note = status_bar_label + base_name\n            return base_name\n\n        def save_chat(e=None):\n            name = save(Files.save_chat_dialog, \"Chat saved to \")\n            self.ui.root.title(name)\n\n        def save_section(e=None):\n            save(Files.save_section_dialog, \"Section saved to \")\n\n        def save_selection(e=None):\n            save(Files.save_selection_dialog, \"Selection saved to \")\n\n        def save_code_block(e=None):\n            save(Files.save_code_block_dialog, \"Code block saved to \")\n\n        def new_window(event=None) :\n            self.new_window_callback()\n\n        def show_context_menu(event, context_menu) :\n            widget = self.ui.winfo_containing(event.x_root, event.y_root)\n            if widget :\n                widget.focus_set()\n            context_menu.tk_popup(event.x_root, event.y_root)\n\n        def cut_text(event=None) :\n            self.it.event_generate(\"<<Cut>>\")\n\n        def copy_text(event=None) :\n            self.it.event_generate(\"<<Copy>>\")\n\n        def paste_text(event=None) :\n            sheet = self.it\n            sheet.event_generate(\"<<Clear>>\")\n            sheet.event_generate(\"<<Paste>>\")\n            sheet.see(INSERT)\n\n        def select_all(event=None):\n            sheet = self.it\n            if type(sheet) == Sheet:\n                sheet.tag_add(SEL, \"1.0\", END)\n                sheet.mark_set(INSERT, \"1.0\")\n                sheet.see(INSERT)\n\n        def edit_undo(event=None):\n            try:\n                self.it.edit_undo()\n            except tk.TclError:\n                pass # nothing to undo\n\n        def edit_redo(event=None):\n            try:\n                self.it.edit_redo()\n            except tk.TclError:\n                pass # nothing to redo\n\n        def font_size(delta):\n            sheet = self.it\n            if not sheet:\n                return\n            if delta == 0:\n                name, size = Sheet.FONT\n            else:\n                name, size = sheet.cget(\"font\").rsplit(None, 1)\n            sheet.config(font=(name, int(size) + delta))\n\n\n        def bold(event):\n            self.it.bold()\n\n\n        def strikethrough(event):\n            self.it.strikethrough()\n\n\n        def insert_current_time(event=None):\n            self.it.insert(INSERT, f\"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} \")\n\n        def debug_info(event=None):\n            print(f\"{self.focus_get()=}\")\n            return\n\n            dumped = self.it.dump(\"insert - 1 char\", window=True)\n            # print(f'{ dumped=}')\n            if dumped and dumped[0][1].endswith(\"label\"):\n                dumped_win = dumped[0][1]\n                dumped_win_pos = dumped[0][2]\n                print(f'{dumped_win=}')\n                print(f'{dumped_win_pos=}')\n                print(f'{type(self.it.window_configure(dumped_win_pos))=}')\n                # print(f'{self.focus.window_configure(dumped_win_pos)=}')\n                print(f\"{type(self.it.window_cget(dumped_win_pos, 'window'))=}\")\n            print()\n            dumped = self.it.dump(\"1.0\", INSERT, all=True)\n            for part in dumped:\n                print(f'{part=}')\n\n\n        def menu_test(event=None):\n            pass\n\n\n        def branch():\n            self.it.fork()\n            self.ui.update()\n            self.ui.complete()\n\n        def toggle_scroll_output(event=None):\n            if self.ui.scroll_output:\n                self.it.see(END)\n            self.ui.scroll_output = not self.ui.scroll_output\n\n        def toggle_ring_bell(event=None):\n            self.ui.ring_bell_after_completion = not self.ui.ring_bell_after_completion\n\n        def toggle_font_mono(event=None):\n            font = tkfont.Font(font=self.it.cget(\"font\"))\n            size = font.cget(\"size\")\n            if font.measure('I') != font.measure('M'):\n                family = Sheet.FONT_NAME_MONOSPACE\n            else:\n                family = Sheet.FONT_NAME_PROPORTIONAL\n            self.it.configure(font=(family, size))\n            return \"break\"\n\n        def close_tab(event=None):\n            it = self.it\n            if type(it) == Sheet:\n                it.close_tab()\n\n        def search_google(event=None):\n            selected_range = self.it.tag_ranges(SEL)\n            if selected_range:\n                selected_text = self.it.get(*selected_range)[:2000]\n                if selected_text:\n                    webbrowser.open_new_tab(\"https://www.google.com/search?q=\" + selected_text)\n\n\n        item = self.sub_item\n        ui = self.ui\n\n        self.menu = Menu(self, \"File\")\n        item(\"New Window\", \"<Control-n>\", new_window)\n        item(\"New Main Tab\", \"<Control-t>\", lambda e=None: self.it.fork(\"1.0\"))\n        item(\"Open File\", \"<Control-o>\", Files.open_file)\n        # item(\"Save Chat\", \"<Control-s>\", Files.save_chat)\n        item(\"Save Chat\", \"<Control-s>\", save_chat)\n        item(\"Save Message\", \"<Control-Shift-S>\", save_section)\n        item(\"Save Selection\", \"<Alt-S>\", save_selection)\n        item(\"Save Code Block\", \"<Control-Alt-s>\", save_code_block)\n        item(\"Run Code Block\", \"\", None)\n        self.menu.add_separator()\n        item(\"Close Tab\", \"<Control-w>\", close_tab, add=False)\n        item(\"Close Empty Tab\", \"<BackSpace>\", lambda e=None: self.it.close_empty_tab_or_backspace(), add=False)\n        item(\"Quit\", \"<Control-q>\", ui.close)\n\n        self.menu = Menu(self, \"Edit\")\n        edit_menu = self.menu\n        item(\"Cut\", \"<Control-x>\", cut_text)\n        item(\"Copy\", \"<Control-c>\", copy_text)\n        item(\"Paste\", \"<Control-v>\", paste_text)\n        item(\"Delete\", \"<Delete>\", lambda e=None: self.it.delete())\n        self.menu.add_separator()\n        item(\"Undo\", \"<Control-z>\", edit_undo)\n        item(\"Redo\", \"<Control-Shift-Z>\", edit_redo)\n        item(\"Select All\", \"<Control-a>\", select_all)\n        self.menu.add_separator()\n        item(\"Bold\", \"<Control-b>\", bold)\n        item(\"Strikethrough\", \"<Control-d>\", strikethrough)\n        item(\"Search with Google\", \"<Control-g>\", search_google)\n        item(\"Insert Current Time\", \"<Control-Shift-I>\", insert_current_time)\n        item(\"Include Date in System Prompt\", None, None)\n        item(\"Copy Title\", None, None)\n\n        self.menu = Menu(self, \"View\")\n        item(\"Show Main Menu\", \"<Alt-Shift-M>\", None)\n        item(\"Show System Prompt\", \"<Alt-Shift-S>\", ui.system_pane.fold)\n        item(\"Show Tree\", \"<Alt-Shift-T>\", ui.tree_pane.fold)\n        item(\"Show Console\", \"<Alt-Shift-C>\", ui.console_pane.fold)\n        item(\"Show Status Bar\", \"<Alt-Shift-I>\", ui.status_hider.hide)\n        self.menu.add_separator()\n        item(\"Count Tokens\", \"<Control-Alt-m>\", ui.count_text_tokens)\n        item(\"Update Window Title\", \"<Control-u>\", ui.update_window_title)\n        self.menu.add_separator()\n        item(\"Increase Font Size\", \"<Control-plus>\", lambda e=None: font_size(1))\n        item(\"Decrease Font Size\", \"<Control-minus>\", lambda e=None: font_size(-1))\n        item(\"Reset Font Size\", \"<Control-period>\", lambda e=None: font_size(0))\n        item(\"Toggle Monospace\", \"<Control-Shift-O>\", toggle_font_mono)\n        # self.menu.add_checkbutton(label=\"Show Cursor line\", variable=ui.show_cursor)\n        self.menu.add_separator()\n        item(\"Toggle Scrolling Output\", \"<Control-e>\", toggle_scroll_output)\n        item(\"Ring Bell When Finished\", \"<Control-Alt-o>\", toggle_ring_bell)\n        item(\"Toggle Wrap Lines\", \"<Control-l>\", lambda e=None: self.it.configure(wrap=(NONE if self.it.cget(\"wrap\") != NONE else WORD)))\n        item(\"Generate Titles\", \"\", None)\n        item(\"Calculate Cost\", \"\", None)\n\n        self.menu = Menu(self, \"Navigate\")\n        item(\"Next Similar Line\", \"<Control-j>\", lambda e=None: self.it.jump_to_similar_line(direction=1))\n        item(\"Previous Similar Line\", \"<Control-Shift-J>\", lambda e=None: self.it.jump_to_similar_line(direction=-1))\n        item(\"Next Message\", \"\", None)\n        item(\"Previous Message\", \"\", None)\n\n        self.menu = Menu(self, \"Chat\")\n        item(\"Next Paragraph\", \"<Control-Return>\", lambda e=None: ui.complete(1, \"\\n\\n\", \"\\n\\n\"))\n        item(\"Next Line\", \"<Shift-Return>\", lambda e=None: ui.complete(1, \"\\n\", \"\\n\"))\n        item(\"Continue Directly\", \"<Control-space>\", lambda e=None: ui.complete())\n        item(\"Fork Conversation\", \"<Alt-Return>\", lambda e=None: self.it.fork())\n        item(\"Complete in Branch\", \"<Control-Shift-Return>\", lambda e=None: branch())\n        item(\"Complete Alternatives\", \"<Alt-Shift-Return>\", lambda e=None: ui.complete(-1, \"\\n\"))\n        self.menu.add_separator()\n        item(\"Complete 3 Times\", \"<Control-Key-3>\", lambda e=None: ui.complete(3), add=False)\n        [self.bind_class(\"Text\", f\"<Control-Key-{i}>\", lambda e=None, i=i: ui.complete(i)) for i in [2,4,5,6,7,8,9]]\n\n        item(\"Complete Multiple...\", \"<Control-Shift-M>\", lambda e=None: ui.complete(0))\n        item(\"Complete Multiple Again\", \"<Control-m>\", lambda e=None: ui.complete(-1))\n        self.menu.add_separator()\n        # item(\"Mark assistant message\", \"<Control-Alt-a>\", mark_assistant_message)\n        item(\"Cancel\", \"<Escape>\", ui.cancel_models)\n\n        self.menu = Menu(self, \"Query\")\n        item(\"Max Tokens...\", \"<Control-Shift-L>\", ui.configure_max_tokens)\n        item(\"Temperature...\", \"<Control-Shift-T>\", ui.configure_temperature)\n        item(\"Increase Temperature\", \"<Alt-plus>\", None)\n        item(\"Decrease Temperature\", \"<Alt-minus>\", None)\n        item(\"Temperature 0.0\", \"<Control-Key-0>\", None)\n\n        self.models_menu = ModelsMenu(self, ui, \"Models\")\n\n        self.windows_menu = WindowsMenu(self, \"Windows\")\n\n        self.menu = Menu(self, \"Help\")\n        item(\"Test\", \"<Control-Alt-Shift-T>\", menu_test)\n        item(\"Debug Info\", \"<Control-i>\", debug_info)\n        item(\"About\", \"<Shift-Alt-F1>\", lambda e=None: AboutDialog(self.ui))\n\n        ui.bind_class(\"Text\", \"<Control-Button-4>\", lambda e=None: font_size(1))\n        ui.bind_class(\"Text\", \"<Control-Button-5>\", lambda e=None: font_size(-1))\n\n        ui.bind_class(\"Text\", \"<Button-3>\", lambda e=None: show_context_menu(e, edit_menu))\n\n\n    def sub_item(self, label, keystroke=None, command=None, variable=None, add=False):\n        self.menu.item(label, keystroke, command, variable, add)", "\n\n\n'''\n\"New Window\", 4,\n\"New Main Tab\", 4,\n\"Save Chat\", 5,\n\"Save Message\", 5,\n\"Save Selection\", 5,\n\"Save Code Block\", 5,", "\"Save Selection\", 5,\n\"Save Code Block\", 5,\n\"Run Code Block\", 4,\n\"Close Tab\", 6,\n\"Close Empty Tab\", 6,\n\"Quit\", 0,\n\n\"Cut\", 1,\n\"Copy\", 1,\n\"Paste\", 0,", "\"Copy\", 1,\n\"Paste\", 0,\n\"Delete\", 0,\n\"Undo\", 1,\n\"Redo\", 0,\n\"Select All\", 7,\n\"Search with Google\", 7,\n\"Insert Current Time\", 7,\n\"Include Date in System Prompt\", 8,\n\"Copy Title\", 5,", "\"Include Date in System Prompt\", 8,\n\"Copy Title\", 5,\n\n\"Show Main Menu\", 5,\n\"Show System Prompt\", 5,\n\"Show Tree\", 5,\n\"Show Console\", 5,\n\"Show Status Bar\", 5,\n\"Count Tokens\", 6,\n\"Update Window Title\", 7,", "\"Count Tokens\", 6,\n\"Update Window Title\", 7,\n\"Increase Font Size\", 9,\n\"Decrease Font Size\", 9,\n\"Reset Font Size\", 6,\n\"Toggle Monospace\", 7,\n\"Toggle Scrolling Output\", 7,\n\"Ring Bell When Finished\", 10,\n\"Toggle Wrap Lines\", 7,\n\"Generate Titles\", 9,", "\"Toggle Wrap Lines\", 7,\n\"Generate Titles\", 9,\n\"Calculate Cost\", 9,\n\n\"Next Similar Line\", 5,\n\"Previous Similar Line\", 9,\n\"Next Message\", 5,\n\"Previous Message\", 9,\n\n\"Next Paragraph\", 5,", "\n\"Next Paragraph\", 5,\n\"Next Line\", 5,\n\"Continue Directly\", 9,\n\"Fork Conversation\", 5,\n\"Complete in Branch\", 9,\n\"Complete Alternatives\", 9,\n\"Complete 3 Times\", 9,\n\"Complete Multiple...\", 9,\n\"Complete Multiple Again\", 9,", "\"Complete Multiple...\", 9,\n\"Complete Multiple Again\", 9,\n\"Cancel\", 0,\n\n\"Max Tokens...\", 4,\n\"Temperature...\", 0,\n\"Increase Temperature\", 9,\n\"Decrease Temperature\", 9,\n\"Temperature 0.0\", 11,\n", "\"Temperature 0.0\", 11,\n\n\"Test\", 0,\n\"Debug Info\", 6,\n\"About\", 0.\n\n'''\n"]}
