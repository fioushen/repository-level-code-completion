{"filename": "NOTICE-snippet.py", "chunked_list": ["# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#", "#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"]}
{"filename": "penvm-build.py", "chunked_list": ["#! /usr/bin/env -S python3 -B\n#\n# penvmbuild.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Build and install PENVM.\n\nMost items are taken from src/ to populate the install directory as:\n    bin/\n    lib/\n    share/penvm", "    lib/\n    share/penvm\n\nAll executables are single zipapp applications. The penvmlib is a\nzip archive of all the source. Documents, etc. are under the share\ndirectory.\n\"\"\"\n\nimport os\nimport os.path", "import os\nimport os.path\nimport shutil\nimport subprocess\nimport sys\nimport traceback\n\nHEREFILE = os.path.abspath(sys.argv[0])\nHEREDIR = os.path.dirname(HEREFILE)\nTOPDIR = HEREDIR", "HEREDIR = os.path.dirname(HEREFILE)\nTOPDIR = HEREDIR\n\nSRCDIR = f\"{TOPDIR}/src\"\nLIBDIR = f\"{SRCDIR}/lib\"\nTESTSDIR = f\"{SRCDIR}/tests\"\nTOOLSDIR = f\"{SRCDIR}/tools\"\n\nPENVMZIP = f\"{TOOLSDIR}/penvm-zip/penvmzip.py\"\n", "PENVMZIP = f\"{TOOLSDIR}/penvm-zip/penvmzip.py\"\n\nPENVM_CLIENT_LIBS = [\n    \"penvmlib-client\",\n]\n\nPENVM_SERVER_LIBS = [\n    \"penvmlib-server\",\n]\n", "]\n\nAPPS = [\n    # (appname, appdir, modname, penvmlibs, extralibs)\n    (\"penvm-connect\", f\"{TOOLSDIR}/penvm-connect\", \"penvmconnect\", PENVM_CLIENT_LIBS, None),\n    (\"penvm-boot\", f\"{TOOLSDIR}/penvm-boot\", \"penvmboot\", PENVM_CLIENT_LIBS, None),\n    (\"penvm-deploy\", f\"{TOOLSDIR}/penvm-deploy\", \"penvmdeploy\", PENVM_CLIENT_LIBS, None),\n    (\"penvm-win\", f\"{TOOLSDIR}/penvm-win\", \"penvmwin\", PENVM_CLIENT_LIBS, None),\n    (\"penvm-zip\", f\"{TOOLSDIR}/penvm-zip\", \"penvmzip\", PENVM_CLIENT_LIBS, None),\n    (\"penvm-server\", f\"{TOOLSDIR}/penvm-server\", \"penvmserver\", PENVM_SERVER_LIBS, None),", "    (\"penvm-zip\", f\"{TOOLSDIR}/penvm-zip\", \"penvmzip\", PENVM_CLIENT_LIBS, None),\n    (\"penvm-server\", f\"{TOOLSDIR}/penvm-server\", \"penvmserver\", PENVM_SERVER_LIBS, None),\n]\n\nLIBS = [\n    # (libname, libdirs, extralibs)\n    (\n        \"penvmlib-client\",\n        [\n            f\"{SRCDIR}/client\",", "        [\n            f\"{SRCDIR}/client\",\n            f\"{SRCDIR}/lib\",\n            f\"{SRCDIR}/kernels\",\n            f\"{SRCDIR}/app\",\n            f\"{SRCDIR}/ext\",\n        ],\n        None,\n    ),\n    # (\"penvmlib-lib\", [f\"{SRCDIR}/lib\"], None),", "    ),\n    # (\"penvmlib-lib\", [f\"{SRCDIR}/lib\"], None),\n    # (\"penvmlib-kernels\", [f\"{SRCDIR}/kernels\"], None),\n    (\"penvmlib-server\", [f\"{SRCDIR}/server\", f\"{SRCDIR}/lib\", f\"{SRCDIR}/kernels\"], None),\n]\n\nTESTS = [\n    (\"queue_test\", f\"{TESTSDIR}/queue_test.py\", \"queue_test\", None, None),\n    (\"semaphore_test\", f\"{TESTSDIR}/semaphore_test.py\", \"semaphore_test\", None, None),\n    (\"session_test\", f\"{TESTSDIR}/session_test.py\", \"session_test\", None, None),", "    (\"semaphore_test\", f\"{TESTSDIR}/semaphore_test.py\", \"semaphore_test\", None, None),\n    (\"session_test\", f\"{TESTSDIR}/session_test.py\", \"session_test\", None, None),\n]\n\n\ndef build_apps(apps, libdir, dstdir):\n    \"\"\"Build a zip application with app file and libs then store in a\n    directory.\"\"\"\n    for appname, appdir, modname, libs, extralibs in apps:\n        print()\n        extralibs = extralibs or []\n        dstfilename = f\"{dstdir}/{appname}\"\n        pargs = [\n            PENVMZIP,\n            \"app\",\n            \"-o\",\n            dstfilename,\n            \"-m\",\n            modname,\n        ]\n        if libs:\n            for lib in libs:\n                pargs.extend([\"-l\", f\"{libdir}/{lib}\"])\n        if extralibs:\n            for extralib in extralibs:\n                pargs.extend([\"-l\", extralib])\n        pargs.append(appdir)\n        subprocess.run(pargs)\n        os.chmod(dstfilename, 0o755)", "\n\ndef build_libs(libs, dstdir):\n    \"\"\"Build a zip library with libs then store in a directory.\"\"\"\n    for libname, libdirs, extralibs in libs:\n        print()\n        extralibs = extralibs or []\n        dstfilename = f\"{dstdir}/{libname}\"\n        pargs = [\n            PENVMZIP,\n            \"lib\",\n            \"-o\",\n            dstfilename,\n        ]\n        for extralib in extralibs:\n            pargs.extend([\"-l\", extralib])\n        if libdirs:\n            pargs.extend(libdirs)\n        subprocess.run(pargs)\n        os.chmod(dstfilename, 0o644)", "\n\ndef print_usage():\n    progname = os.path.basename(sys.argv[0])\n    print(\n        f\"\"\"\\\nusage: {progname} <installdir>\n       {progname} -h|--help\n\nBuild files and install.\n\nArguments:\n<installdir>            Installation directory.\n\"\"\",\n        end=\"\",\n    )", "\n\nclass ArgOpts:\n    pass\n\n\ndef main():\n    try:\n        argopts = ArgOpts()\n        argopts.installdir = None\n\n        args = sys.argv[1:]\n        while args:\n            arg = args.pop(0)\n            if arg in [\"-h\", \"--help\"]:\n                print_usage()\n                sys.exit(0)\n            elif not args:\n                argopts.installdir = arg\n            else:\n                raise Exception()\n\n        if argopts.installdir == None:\n            raise Exception()\n    except SystemExit:\n        raise\n    except Exception as e:\n        print(e)\n        msg = e.msg if e and e.msg != \"\" else \"bad/missing arguments\"\n        print(f\"error: {msg}\", file=sys.stderr)\n        sys.exit(1)\n\n    try:\n        bindir = f\"{argopts.installdir}/bin\"\n        libdir = f\"{argopts.installdir}/lib\"\n        testsdir = f\"{argopts.installdir}/tests\"\n        sharedir = f\"{argopts.installdir}/share/penvm\"\n\n        os.makedirs(bindir, exist_ok=True)\n        os.makedirs(libdir, exist_ok=True)\n        os.makedirs(sharedir, exist_ok=True)\n        os.makedirs(testsdir, exist_ok=True)\n\n        # this tool: penvmzip\n        # shutil.copy(PENVMZIP, f\"{bindir}/penvm-zip\")\n\n        # library (FIRST!)\n        build_libs(LIBS, libdir)\n\n        # apps\n        build_apps(APPS, libdir, bindir)\n        build_apps(TESTS, libdir, testsdir)\n\n        # miscellaneous\n        shutil.copy(f\"{TOPDIR}/README.md\", f\"{sharedir}/README.md\")\n        shutil.copy(f\"{TOPDIR}/LICENSE\", f\"{sharedir}/LICENSE\")\n    except Exception as e:\n        traceback.print_exc()\n        print(f\"error: {e}\", file=sys.stderr)\n        sys.exit(1)", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "src/tools/penvm-boot/penvmboot.py", "chunked_list": ["#! /usr/bin/env python3\n#\n# tools/penvmboot.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Set up a PENVM network.\n\"\"\"\n\nimport os\nimport os.path\nimport subprocess", "import os.path\nimport subprocess\nimport sys\nimport time\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.app.boot import Booter\n\n\ndef print_usage():\n    progname = os.path.basename(sys.argv[0])\n    print(\n        f\"\"\"\\\nusage: {progname} [--shell <path>] [-N <network>] <config>\n       {progname} -h|--help\n\nStart PENVM network. Optionally start a shell, else wait indefinitely\n(until killed).\n\nArguments:\n<config>            Configuration file (.penvm).\n-N <network>        Start named network. Default is \"default\".\n--shell <path>      Run a shell.\n--verbose           Output informative details.\n\"\"\",\n        end=\"\",\n    )", "\ndef print_usage():\n    progname = os.path.basename(sys.argv[0])\n    print(\n        f\"\"\"\\\nusage: {progname} [--shell <path>] [-N <network>] <config>\n       {progname} -h|--help\n\nStart PENVM network. Optionally start a shell, else wait indefinitely\n(until killed).\n\nArguments:\n<config>            Configuration file (.penvm).\n-N <network>        Start named network. Default is \"default\".\n--shell <path>      Run a shell.\n--verbose           Output informative details.\n\"\"\",\n        end=\"\",\n    )", "\n\nclass ArgOpts:\n    pass\n\n\ndef main():\n    try:\n        argopts = ArgOpts()\n        argopts.filename = None\n        argopts.network = \"default\"\n        argopts.release = None\n        argopts.shell = None\n        argopts.verbose = False\n\n        args = sys.argv[1:]\n        while args:\n            arg = args.pop(0)\n            if arg in [\"-h\", \"--help\"]:\n                print_usage()\n                sys.exit(0)\n            elif arg == \"-N\" and args:\n                argopts.network = args.pop(0)\n            elif arg == \"-r\" and args:\n                argopts.release = args.pop(0)\n            elif arg == \"--shell\" and args:\n                argopts.shell = args.pop(0)\n            elif arg == \"--verbose\":\n                argopts.verbose = True\n            elif not args:\n                argopts.filename = arg\n            else:\n                raise Exception(\"bad/missing argument\")\n\n        if None in [argopts.filename]:\n            raise Exception()\n    except SystemExit:\n        raise\n    except Exception as e:\n        print(f\"error: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    try:\n        booter = Booter(\n            argopts.filename,\n            argopts.network,\n            argopts.release,\n        )\n        booter.boot()\n\n        if argopts.verbose:\n            print(f\"machines available ({len(booter.network.get_machines())})\")\n\n        if argopts.shell:\n            PS1 = f\"\"\"[pvshell] {booter.env.get(\"PS1\", \"\")}\"\"\"\n            booter.env[\"PS1\"] = PS1\n            booter.env[\"XPS1\"] = PS1\n\n        # print env info\n        if argopts.verbose:\n            print(\"environment settings:\")\n            print(f\"\"\"    export PENVM_AUTO_NETWORK=\"{booter.env['PENVM_AUTO_NETWORK']}\" \"\"\")\n            print(f\"\"\"    export PENVM_RELEASE={booter.release}\"\"\")\n            print(f\"\"\"    export PYTHONPATH=\"{booter.env['PYTHONPATH']}\" \"\"\")\n            # print(f\"\"\"    export PS1=\"{PS1}\" \"\"\")\n\n        if not argopts.shell:\n            if argopts.verbose:\n                print(\"sleeping ...\")\n            booter.wait()\n        else:\n            if argopts.verbose:\n                print(f\"starting shell ({argopts.shell}) ...\")\n            booter.shell(argopts.shell)\n\n        if 0:\n            world = World(filename=argopts.filename)\n            network = world.get_network(argopts.network)\n            # print(f\"{network=}\")\n            if network == None or network.get_targets() in [None, []]:\n                raise Exception(f\"network ({argopts.network}) not found\")\n            network.boot()\n\n            machines = network.get_machines()\n            if machines in [None, []]:\n                raise Exception(\"no machines\")\n            if None in machines:\n                raise Exception(\"not all machines found\")\n\n            if argopts.verbose:\n                print(f\"machines available ({len(machines)})\")\n\n            machconnspecs = [MachineConnectionSpec(machine=machine) for machine in machines]\n\n            release = argopts.release or world.get_meta(\"release\") or get_version_string()\n            if release == None:\n                raise Exception(f\"could not determine release value\")\n\n            releasepath = os.path.expanduser(f\"~/.penvm/releases/{release}\")\n            releaselibs = \":\".join([f\"{releasepath}/{name}\" for name in [\"penvmlib-client\"]])\n\n            # patch env\n            env = os.environ.copy()\n            PENVM_AUTO_NETWORK = \" \".join([str(machconnspec) for machconnspec in machconnspecs])\n            PYTHONPATH = env.get(\"PYTHONPATH\")\n            PYTHONPATH = f\":{PYTHONPATH}\" if PYTHONPATH != None else \"\"\n            PS1 = f\"\"\"[pvshell] {env[\"PS1\"]}\"\"\"\n            env[\"PENVM_AUTO_NETWORK\"] = PENVM_AUTO_NETWORK\n            env[\"PYTHONPATH\"] = f\"{releaselibs}{PYTHONPATH}\"\n            env[\"PENVM_RELEASE\"] = release\n            env[\"PS1\"] = PS1\n            env[\"XPS1\"] = PS1\n\n            # print env info\n            if argopts.verbose:\n                print(\"environment settings:\")\n                print(f\"\"\"    export PENVM_AUTO_NETWORK=\"{PENVM_AUTO_NETWORK}\" \"\"\")\n                print(f\"\"\"    export PENVM_RELEASE={release}\"\"\")\n                print(f\"\"\"    export PYTHONPATH=\"{releaselibs}:$PYTHONPATH\" \"\"\")\n                print(f\"\"\"    export PS1=\"{PS1}\" \"\"\")\n\n            if not argopts.shell:\n                if argopts.verbose:\n                    print(\"sleeping ...\")\n                time.sleep(10000000)\n            else:\n                if argopts.verbose:\n                    print(f\"starting shell ({argopts.shell}) ...\")\n                try:\n                    sp = subprocess.Popen(\n                        [argopts.shell],\n                        pass_fds=[0, 1, 2],\n                        env=env,\n                    )\n                except Exception as e:\n                    raise Exception(f\"failed to start shell ({argopts.shell})\")\n\n                try:\n                    # close streams\n                    sys.stdin.close()\n                    sys.stdout.close()\n                    sys.stderr.close()\n\n                    # close fds\n                    os.close(0)\n                    os.close(1)\n                    os.close(2)\n                except Exception as e:\n                    raise Exception(\"failed to close streams/fds\")\n\n                os.waitpid(sp.pid, 0)\n    except KeyboardInterrupt:\n        pass\n    except Exception as e:\n        print(f\"error: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    if argopts.verbose:\n        print(\"exiting ...\")", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "src/tools/penvm-win/penvmwin.py", "chunked_list": ["#! /usr/bin/env python3\n#\n# tools/penvmwin.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Set up (local) windows/terminals for a PENVM network.\n\"\"\"\n\nimport os\nimport os.path\nimport subprocess", "import os.path\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.client.world import World\n", "from penvm.client.world import World\n\nHEREFILE = os.path.abspath(sys.argv[0])\nTERMINAL_EXEC = os.environ.get(\"PENVM_WIN_TERMINAL\", \"xterm\")\n\n\ndef bytetail_main():\n    import codecs\n    import fcntl\n\n    def bytetail_open():\n        try:\n            filename = sys.argv[1]\n            # print(f\"{filename=}\")\n            if filename == \"-\":\n                f = os.fdopen(sys.stdin.fileno(), \"rb\", buffering=0)\n            else:\n                f = open(filename, \"rb\", buffering=0)\n            # print(f\"opening file ({filename=}) ({f=})\")\n            return f\n        except Exception as e:\n            traceback.print_exc()\n            print(f\"error: {e}\", file=sys.stderr)\n            sys.exit(1)\n\n    def bytetail_read(f):\n        try:\n            dec = codecs.getincrementaldecoder(\"utf-8\")()\n\n            flags = fcntl.fcntl(f.fileno(), fcntl.F_GETFL)\n            flags_block = flags\n            flags_nonblock = flags | os.O_NONBLOCK\n            while True:\n                # read one byte as soon as available\n                fcntl.fcntl(f.fileno(), fcntl.F_SETFL, flags_block)\n                buf = f.read(1)\n                if buf in [b\"\", None]:\n                    # EOF\n                    break\n                s = dec.decode(buf)\n                if s:\n                    print(s, end=\"\", flush=True)\n\n                # read chunks of bytes in non-blocking until nothing\n                fcntl.fcntl(f.fileno(), fcntl.F_SETFL, flags_nonblock)\n                while True:\n                    buf = f.read(1024)\n                    if buf in [b\"\", None]:\n                        # EOF or timeout\n                        break\n                    s = dec.decode(buf)\n                    if s:\n                        print(s, end=\"\", flush=True)\n        except Exception as e:\n            traceback.print_exc()\n            pass\n\n    try:\n        while True:\n            # print(\"starting bytetail loop ...\")\n            timestamp = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime())\n            print(f\"---- [{timestamp}] ------ \u2191 \u2191 \u2191 \u2191 ----------\")\n            f = bytetail_open()\n            bytetail_read(f)\n    finally:\n        windows.close()\n\n    sys.exit(0)", "\n\nclass Window:\n    \"\"\"Log window which creates and monitors a log/fifo file.\"\"\"\n\n    tempd = tempfile.TemporaryDirectory()\n\n    def __init__(self, name, title, usefifo=True, cleanlog=True):\n        self.name = name\n        self.title = title\n        self.path = f\"{self.tempd.name}/{self.name}\"\n        self.usefifo = usefifo\n        self.cleanlog = cleanlog\n        if usefifo:\n            os.mkfifo(self.path, mode=0o600)\n        else:\n            # touch\n            self.fd = os.open(self.path, os.O_CREAT, mode=0o600)\n            os.close(self.fd)\n        self.fd = None\n        self.p = None\n\n    def __del__(self):\n        \"\"\"Clean up.\"\"\"\n        try:\n            if self.fd != None:\n                os.close(self.fd)\n                self.fd = None\n        except:\n            pass\n\n        try:\n            if os.path.exists(self.path):\n                if self.cleanlog or self.usefifo:\n                    os.remove(self.path)\n        except:\n            pass\n\n    def kill(self):\n        try:\n            self.p.kill()\n            self.p = None\n        except:\n            pass\n\n    def write(self, buf):\n        if self.p == None:\n            return\n        if self.fd == None:\n            self.fd = os.open(self.path, os.O_RDWR)\n        os.write(self.fd, buf.encode(\"utf-8\"))\n\n    def terminal(self):\n        filename = os.path.basename(TERMINAL_EXEC)\n        if filename in [\"xterm\"]:\n            title_opt = \"-title\"\n            execute_opt = \"-e\"\n        elif filename in [\"gnome-terminal\"]:\n            title_opt = \"--title\"\n            execute_opt = \"--\"\n        else:\n            title_opt = \"--title\"\n            execute_opt = \"-x\"\n\n        self.p = subprocess.Popen(\n            [TERMINAL_EXEC, title_opt, self.name, execute_opt, HEREFILE, \"--bytetail\", self.path],\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.DEVNULL,\n            stdin=subprocess.DEVNULL,\n            close_fds=True,\n        )", "\n\nclass Windows:\n    \"\"\"Manage multiple log windows.\"\"\"\n\n    def __init__(self, usefifo=True, cleanlog=True):\n        self.usefifo = usefifo\n        self.cleanlog = cleanlog\n        self.windows = {}\n\n    def add(self, name):\n        self.windows[name] = Window(\n            name,\n            f\"Machine: {name}\",\n            usefifo=self.usefifo,\n            cleanlog=self.cleanlog,\n        )\n\n    def close(self):\n        for w in self.windows.values():\n            w.kill()\n\n    def get_spec(self):\n        # TODO: change method name\n        return \" \".join([f\"{w.name}:{w.path}\" for w in self.windows.values()])\n\n    def terminal(self):\n        for w in self.windows.values():\n            w.terminal()\n\n    def write(self, name, out):\n        w = self.windows.get(name)\n        if w:\n            w.write(str(out))\n\n    def write_all(self, out):\n        for w in self.windows.values():\n            w.write(out)\n\n    def write_named(self, d):\n        for name, out in d.items():\n            self.write(name, out)\n\n    def write_sep(self, name, sep=None):\n        sep = sep or \"-\" * 40\n        self.write(name, sep)", "\n\ndef print_usage():\n    progname = os.path.basename(sys.argv[0])\n    print(\n        f\"\"\"\\\nusage: {progname} [--shell <path>] [<networkstr]\n       {progname} -h|--help\n\nStart log windows for a running PENVM network (at\nPENVM_AUTO_NETWORK). Optionally start a shell, else wait\nindefinitely (until killed).\n\nArguments:\n<networkstr>        PENVM network of running machine instances.\n--shell <path>      Run a shell.\n\"\"\",\n        end=\"\",\n    )", "\n\nclass ArgOpts:\n    pass\n\n\ndef main():\n    try:\n        argopts = ArgOpts()\n        argopts.networkstr = os.environ.get(\"PENVM_AUTO_NETWORK\")\n        argopts.shell = None\n\n        args = sys.argv[1:]\n\n        # special/unadvertised\n        if args and args[0] == \"--bytetail\":\n            del sys.argv[1]\n            bytetail_main()\n            sys.exit(0)\n\n        while args:\n            arg = args.pop(0)\n            if arg in [\"-h\", \"--help\"]:\n                print_usage()\n                sys.exit(0)\n            elif arg == \"--shell\" and args:\n                argopts.shell = args.pop(0)\n            elif not args:\n                argopts.networkstr = arg\n            else:\n                raise Exception(\"bad/missing argument\")\n\n        if argopts.networkstr in [None, \"\"]:\n            raise Exception(\"network string not found\")\n    except SystemExit:\n        raise\n    except Exception as e:\n        print(\"error: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    try:\n        world = World()\n        network = World.network()\n\n        windows = Windows()\n\n        machidhostports = argopts.machidhostports.split()\n        for machidhostport in machidhostports:\n            machid, sslprofile, host, port = machidhostport.split(\":\", 3)\n            # print(f\"adding machine ({machid})\")\n            windows.add(machid)\n        windows.terminal()\n\n        env = os.environ.copy()\n        env[\"PENVM_WINDOWS\"] = windows.get_spec()\n        print(f\"\"\"export PENVM_WINDOWS=\"{env.get('PENVM_WINDOWS')}\" \"\"\")\n\n        if not argopts.shell:\n            print(\"sleeping ...\")\n            time.sleep(10000000)\n        else:\n            print(f\"starting shell ({argopts.shell}) ...\")\n            try:\n                sp = subprocess.Popen(\n                    [argopts.shell],\n                    pass_fds=[0, 1, 2],\n                    env=env,\n                )\n            except Exception as e:\n                raise Exception(f\"failed to start shell ({argopts.shell})\")\n\n            try:\n                # close streams\n                sys.stdin.close()\n                sys.stdout.close()\n                sys.stderr.close()\n\n                # close fds\n                os.close(0)\n                os.close(1)\n                os.close(2)\n            except Exception as e:\n                raise Exception(\"failed to close streams/fds\")\n\n            os.waitpid(sp.pid, 0)\n\n        print(\"exiting\")\n    except Exception as e:\n        # traceback.print_exc()\n        print(f\"error: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    sys.exit(0)", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "src/tools/penvm-server/penvmserver.py", "chunked_list": ["#! /usr/bin/env python3\n#\n# tools/penvmserver.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"PENVM server.\n\"\"\"\n\nimport logging\nimport os\nimport os.path", "import os\nimport os.path\nimport subprocess\nimport sys\nfrom sys import stderr\nimport tempfile\nimport time\nimport traceback\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n", "from typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.lib.base import BaseObject\nfrom penvm.server.machine import Machine\n\n\n# set in main()\nlogger = None\n\n\nclass Server(BaseObject):\n    def __init__(self):\n        try:\n            super().__init__(None, logger)\n            self.logger.debug(\"init\")\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            pass\n\n    def background(self):\n        \"\"\"Put in background.\n\n        Steps:\n        1. Forks (multistep).\n        2. Closes stdin, stdout, stderr.\"\"\"\n\n        self.logger.debug(\"backgrounding ...\")\n\n        # fork 1\n        pid = os.fork()\n        if pid > 0:\n            # os._exit(0)\n            sys.exit(0)\n\n        os.setsid()\n        os.chdir(\"/\")\n\n        # fork 2\n        pid = os.fork()\n        if pid > 0:\n            # os._exit(0)\n            sys.exit(0)\n\n        # close fds\n        sys.stdout.flush()\n        sys.stderr.flush()\n        si = open(\"/dev/null\", \"r\")\n        so = open(\"/dev/null\", \"a+\")\n        se = open(\"/dev/null\", \"a+\")\n        os.dup2(si.fileno(), sys.stdin.fileno())\n        os.dup2(so.fileno(), sys.stdout.fileno())\n        os.dup2(se.fileno(), sys.stderr.fileno())\n\n        self.logger.debug(\"background exit\")\n\n    def respawn(self, argopts):\n        self.logger.debug(\"respawning ...\")\n\n        args = sys.argv[:]\n\n        # force full path\n        args[0] = os.path.realpath(args[0])\n\n        f = tempfile.NamedTemporaryFile(\"rt\")\n        # print(f\"{f.name=} {f.file=}\")\n        args.insert(1, \"--announce-file\")\n        args.insert(2, f.name)\n\n        # force python3\n        if args[0] != \"python3\":\n            args.insert(0, \"python3\")\n\n        self.logger.debug(f\"{args=}\")\n        cp = subprocess.run(\n            args,\n            stdin=subprocess.DEVNULL,\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.DEVNULL,\n            # capture_output=True,\n            # text=True,\n            cwd=\"/\",\n            start_new_session=True,\n        )\n        # print(f\"{cp=}\")\n\n        if cp.returncode != 0:\n            # print(f\"error: failed to respawn\", file=sys.stderr, flush=True)\n            self.logger.debug(f\"failed to respawn {cp.returncode=} {cp.stdout=} {cp.stderr=}\")\n            sys.exit(cp.returncode)\n\n        if argopts.announce:\n            # TODO: change this to a pipe!\n            s = \"announce::\"\n            while True:\n                s += f.file.read()\n                # print(f\"{s=}\")\n                if \"\\n\" in s:\n                    break\n                time.sleep(0.2)\n            print(s, flush=True)\n        sys.exit(0)\n\n    def run(self, argopts):\n        self.logger.debug(\"running ...\")\n\n        if argopts.background:\n            self.background()\n\n        self.logger.debug(\n            f\"machine configuration: id={argopts.machineid} host={argopts.host} port={argopts.port}\"\n        )\n        self.logger.debug(\"creating machine ...\")\n\n        try:\n            machine = Machine(\n                argopts.host,\n                argopts.port,\n                sslprofile=argopts.sslprofile,\n                machineid=argopts.machineid,\n            )\n            time.sleep(0.2)\n            if argopts.announce and argopts.announce_filename:\n                lhost, lport = machine.get_addr_port()\n                self.logger.debug(\n                    f\"announcement machineid={argopts.machineid} addr={lhost} port={lport} ssl-profile={argopts.sslprofile}\"\n                )\n                print(\n                    f\"{argopts.machineid}:{argopts.sslprofile or ''}:{lhost}:{lport}\",\n                    file=open(argopts.announce_filename, \"a\"),\n                    flush=True,\n                )\n        except Exception as e:\n            self.logger.debug(f\"failed to start machine {traceback.format_exc()}\")\n\n        # sys.exit(0)\n        self.logger.debug(\"starting/running machine ...\")\n        # TODO: move `ltimeout`` setting elsewhere\n        machine.connmgr.ltimeout = argopts.firstwait\n        if 1:\n            machine.start()\n            machine.wait()\n\n        if 0:\n            machine.run()\n        self.logger.debug(\"exiting ...\")", "\n\nclass Server(BaseObject):\n    def __init__(self):\n        try:\n            super().__init__(None, logger)\n            self.logger.debug(\"init\")\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            pass\n\n    def background(self):\n        \"\"\"Put in background.\n\n        Steps:\n        1. Forks (multistep).\n        2. Closes stdin, stdout, stderr.\"\"\"\n\n        self.logger.debug(\"backgrounding ...\")\n\n        # fork 1\n        pid = os.fork()\n        if pid > 0:\n            # os._exit(0)\n            sys.exit(0)\n\n        os.setsid()\n        os.chdir(\"/\")\n\n        # fork 2\n        pid = os.fork()\n        if pid > 0:\n            # os._exit(0)\n            sys.exit(0)\n\n        # close fds\n        sys.stdout.flush()\n        sys.stderr.flush()\n        si = open(\"/dev/null\", \"r\")\n        so = open(\"/dev/null\", \"a+\")\n        se = open(\"/dev/null\", \"a+\")\n        os.dup2(si.fileno(), sys.stdin.fileno())\n        os.dup2(so.fileno(), sys.stdout.fileno())\n        os.dup2(se.fileno(), sys.stderr.fileno())\n\n        self.logger.debug(\"background exit\")\n\n    def respawn(self, argopts):\n        self.logger.debug(\"respawning ...\")\n\n        args = sys.argv[:]\n\n        # force full path\n        args[0] = os.path.realpath(args[0])\n\n        f = tempfile.NamedTemporaryFile(\"rt\")\n        # print(f\"{f.name=} {f.file=}\")\n        args.insert(1, \"--announce-file\")\n        args.insert(2, f.name)\n\n        # force python3\n        if args[0] != \"python3\":\n            args.insert(0, \"python3\")\n\n        self.logger.debug(f\"{args=}\")\n        cp = subprocess.run(\n            args,\n            stdin=subprocess.DEVNULL,\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.DEVNULL,\n            # capture_output=True,\n            # text=True,\n            cwd=\"/\",\n            start_new_session=True,\n        )\n        # print(f\"{cp=}\")\n\n        if cp.returncode != 0:\n            # print(f\"error: failed to respawn\", file=sys.stderr, flush=True)\n            self.logger.debug(f\"failed to respawn {cp.returncode=} {cp.stdout=} {cp.stderr=}\")\n            sys.exit(cp.returncode)\n\n        if argopts.announce:\n            # TODO: change this to a pipe!\n            s = \"announce::\"\n            while True:\n                s += f.file.read()\n                # print(f\"{s=}\")\n                if \"\\n\" in s:\n                    break\n                time.sleep(0.2)\n            print(s, flush=True)\n        sys.exit(0)\n\n    def run(self, argopts):\n        self.logger.debug(\"running ...\")\n\n        if argopts.background:\n            self.background()\n\n        self.logger.debug(\n            f\"machine configuration: id={argopts.machineid} host={argopts.host} port={argopts.port}\"\n        )\n        self.logger.debug(\"creating machine ...\")\n\n        try:\n            machine = Machine(\n                argopts.host,\n                argopts.port,\n                sslprofile=argopts.sslprofile,\n                machineid=argopts.machineid,\n            )\n            time.sleep(0.2)\n            if argopts.announce and argopts.announce_filename:\n                lhost, lport = machine.get_addr_port()\n                self.logger.debug(\n                    f\"announcement machineid={argopts.machineid} addr={lhost} port={lport} ssl-profile={argopts.sslprofile}\"\n                )\n                print(\n                    f\"{argopts.machineid}:{argopts.sslprofile or ''}:{lhost}:{lport}\",\n                    file=open(argopts.announce_filename, \"a\"),\n                    flush=True,\n                )\n        except Exception as e:\n            self.logger.debug(f\"failed to start machine {traceback.format_exc()}\")\n\n        # sys.exit(0)\n        self.logger.debug(\"starting/running machine ...\")\n        # TODO: move `ltimeout`` setting elsewhere\n        machine.connmgr.ltimeout = argopts.firstwait\n        if 1:\n            machine.start()\n            machine.wait()\n\n        if 0:\n            machine.run()\n        self.logger.debug(\"exiting ...\")", "\n\ndef print_usage():\n    progname = os.path.basename(sys.argv[0])\n    print(\n        f\"\"\"\\\nusage: {progname} [<options>] <host> [<port>]\n       {progname} -h|--help\n\nStart penvm server.\n\nArguments:\n<host>          Address to listen on.\n<port>          Port to listen on. Default is 0, which autoselects an\n                available port.\n--announce      Write <host>:<port> of the listening socket to the\n                announce file.\n--announce-file <filename>\n                Filename to hold the announce info.\n--background    Put server into background: detach from session and\n                redirect I/O to `/dev/null`.\n--firstwait <seconds>\n                Time to wait for first connection before exiting.\n                Default is 30 seconds.\n--machineid <id>\n                Id to use for machine.\n--ssl-profile <name>\n                SSL profile name.\n\"\"\",\n        end=\"\",\n    )", "\n\nclass ArgOpts:\n    pass\n\n\ndef main():\n    global logger\n\n    try:\n        argopts = ArgOpts()\n        argopts.announce = False\n        argopts.announce_filename = None\n        argopts.background = False\n        argopts.firstwait = 30\n        argopts.host = None\n        argopts.machineid = None\n        argopts.port = 0\n        argopts.sslprofile = None\n\n        args = sys.argv[1:]\n        while args:\n            arg = args.pop(0)\n            if arg == \"--announce\":\n                argopts.announce = True\n            elif arg == \"--announce-file\" and args:\n                argopts.announce_filename = args.pop(0)\n            elif arg == \"--background\":\n                argopts.background = True\n            elif arg == \"--firstwait\" and args:\n                argopts.firstwait = int(args.pop(0))\n            elif arg in [\"-h\", \"--help\"]:\n                print_usage()\n                sys.exit(0)\n            elif arg == \"--machineid\" and args:\n                argopts.machineid = args.pop(0)\n            elif arg == \"--ssl-profile\" and args:\n                argopts.sslprofile = args.pop(0)\n            else:\n                argopts.host = arg\n                if args:\n                    argopts.port = int(args.pop(0))\n                if args:\n                    raise Exception()\n\n        if argopts.host == None:\n            raise Exception()\n    except SystemExit:\n        raise\n    except Exception as e:\n        print(\"error: bad/missing argument\", file=sys.stderr)\n        sys.exit(1)\n\n    # set up logger\n    username = os.environ.get(\"USER\", os.environ.get(\"LOGNAME\", os.getpid()))\n    logging.basicConfig(\n        filename=f\"/tmp/penvmserver-{username}.log\",\n        format=\"%(asctime)s:%(levelname)s:%(process)s:%(name)s:%(lineno)d:%(funcName)s:%(msg)s\",\n    )\n    logger = logging.getLogger()\n    logger.setLevel(logging.DEBUG)\n\n    logger = logging.getLogger(__name__)\n\n    # create server\n    server = Server()\n\n    if not argopts.announce_filename:\n        # patch sys.argv for respawn\n        sys.argv[0] = os.path.abspath(sys.argv[0])\n        server.respawn(argopts)\n    else:\n        server.run(argopts)", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "src/tools/penvm-connect/penvmconnect.py", "chunked_list": ["#! /usr/bin/env python3\n#\n# tools/penvmconnect.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Connect to the servers running on a PENVM network/machine.\n\"\"\"\n\nimport code\nimport os.path\nimport sys", "import os.path\nimport sys\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.client.world import World\n\n\ndef print_usage():\n    progname = os.path.basename(sys.argv[0])\n    print(\n        f\"\"\"\\\nusage: {progname} [<networkstr>]\n       {progname} -h|--help\n\nConnect to a PENVM network of running machine instances and interact\nin a Python shell.\n\nArguments:\n<networkstr>        Network string consisting of one or more,\n                    space-separated, machine connection strings\n                    (format <machineid>:<sslprofile>:<host>:<port>)\n                    for each running machine. Defaults to\n                    PENVM_AUTO_NETWORK.\n\"\"\",\n        end=\"\",\n    )", "\n\nclass ArgOpts:\n    pass\n\n\ndef main():\n    try:\n        argopts = ArgOpts()\n        argopts.networkstr = os.environ.get(\"PENVM_AUTO_NETWORK\")\n\n        args = sys.argv[1:]\n        while args:\n            arg = args.pop(0)\n            if arg in [\"-h\", \"--help\"]:\n                print_usage()\n                sys.exit(1)\n            elif not args:\n                argopts.networkstr = arg\n            else:\n                raise Exception(\"bad/missing argument\")\n\n        if argopts.networkstr in [None, \"\"]:\n            raise Exception(\"network string not found\")\n    except SystemExit:\n        raise\n    except Exception as e:\n        print(f\"error: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    try:\n        world = World(networkstr=argopts.networkstr)\n        network = world.get_network()\n        network.boot()\n        machines = network.get_machines()\n        machconnspecs = [m.get_machconnspec() for m in machines]\n\n        # TODO: restrict globals and locals\n        code.interact(\n            banner=\"\"\"Ready.\\n\"\"\"\n            \"\"\"Use \"machines\" to access machines.\\n\"\"\"\n            \"\"\"Use \"machconnspecs\" to access machine connection specs.\\n\"\"\"\n            \"\"\"Use \"network\" for network.\"\"\",\n            local=dict(globals(), **locals()),\n        )\n    except SystemExit:\n        raise\n    except Exception as e:\n        print(f\"error: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    sys.exit(0)", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "src/tools/penvm-deploy/penvmdeploy.py", "chunked_list": ["#! /usr/bin/env -S python3 -B\n#\n# tools/penvmdeploy.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"PENVM library and server deployment tool.\n\nUsing a .penvm configration, deploys the zipped penvm libraries and\nzipapp penvmserver to a set of targets.\n\"\"\"\n", "\"\"\"\n\nimport os.path\nimport subprocess\nimport sys\nimport traceback\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nHEREFILE = os.path.abspath(sys.argv[0])\nHEREDIR = os.path.dirname(HEREFILE)", "HEREFILE = os.path.abspath(sys.argv[0])\nHEREDIR = os.path.dirname(HEREFILE)\nTOPDIR = os.path.dirname(HEREDIR)\n\nBINDIR = f\"{TOPDIR}/bin\"\nLIBDIR = f\"{TOPDIR}/lib\"\n\nPENVMLIBS = [\n    f\"{LIBDIR}/penvmlib-client\",\n    # f\"{LIBDIR}/penvmlib-kernels\",", "    f\"{LIBDIR}/penvmlib-client\",\n    # f\"{LIBDIR}/penvmlib-kernels\",\n    # f\"{LIBDIR}/penvmlib-lib\",\n    f\"{LIBDIR}/penvmlib-server\",\n]\nPENVMSERVER = f\"{BINDIR}/penvm-server\"\n\n# access local libs\nsys.path.insert(0, f\"{LIBDIR}/penvmlib-lib\")\nsys.path.insert(0, f\"{LIBDIR}/penvmlib-client\")", "sys.path.insert(0, f\"{LIBDIR}/penvmlib-lib\")\nsys.path.insert(0, f\"{LIBDIR}/penvmlib-client\")\n\nfrom penvm.client.world import World\nfrom penvm.lib.misc import get_version_string\n\n\ndef deploy_penvmfiles(release, fshomeid, user, host, filenames, dryrun=False):\n    \"\"\"Install file(s) under ~/.penvm/releases/<release>.\"\"\"\n\n    dstdir = f\".penvm/releases/{release}\"\n\n    for filename in filenames:\n        print(f\"{filename} -> {user or ''}@{host} fshomeid ({fshomeid}) release ({release}) ... \")\n\n        if dryrun:\n            continue\n\n        cp = remote_mkdir(user, host, dstdir)\n        if cp.returncode != 0:\n            print(f\"failed ({cp.stderr})\")\n            continue\n\n        dstpath = f\"{dstdir}/{os.path.basename(filename)}\"\n        cp = remote_copyfile(user, host, filename, dstpath)\n        if cp.returncode != 0:\n            print(f\"failed ({cp.stderr})\")", "\n\ndef remote_copyfile(user, host, srcpath, dstpath):\n    \"\"\"Copy local file to remote.\"\"\"\n\n    userhost = f\"{user}@{host}\" if user != None else host\n    userhostpath = f\"{userhost}:{dstpath}\"\n    spargs = [\n        \"scp\",\n        srcpath,\n        userhostpath,\n    ]\n    cp = subprocess.run(spargs, capture_output=True)\n    return cp", "\n\ndef remote_mkdir(user, host, path):\n    \"\"\"Create remote directory.\"\"\"\n\n    userhost = f\"{user}@{host}\" if user != None else host\n    spargs = [\n        \"ssh\",\n        userhost,\n        \"python3\",\n        \"-c\",\n        f\"\"\"'import os; os.makedirs(\"{path}\", exist_ok=True)'\"\"\",\n    ]\n    cp = subprocess.run(spargs, capture_output=True)\n    return cp", "\n\ndef print_usage():\n    progname = os.path.basename(sys.argv[0])\n    print(\n        f\"\"\"\\\nusage: {progname} [--dry] [-N <network>[,...] [-l <libfile>] [-s <serverfile>] <config>\n       {progname} [--list] <config>\n       {progname} -h|--help\n\nDeploy libraries and penvmserver to targets taken from a .penvm\nconfiguration file.\n\nArguments:\n<config>            Configuration file (.penvm suffix).\n--dry               Run without making any changes.\n-l <libfile>        Libraries. Default is from lib/.\n-N <network>[,...]  Apply to targets in named networks.\n-r <release>        Deploy to alternate release name.\n-s <serverfile>     Server file. Default is from bin/.\n\"\"\",\n        end=\"\",\n    )", "\n\nclass ArgOpts:\n    pass\n\n\ndef main():\n    try:\n        argopts = ArgOpts()\n        argopts.dryrun = False\n        argopts.list = False\n        argopts.networks = None\n        argopts.penvmlib_filenames = PENVMLIBS\n        argopts.penvmserver_filename = PENVMSERVER\n        argopts.release = None\n        argopts.world_filename = None\n\n        args = sys.argv[1:]\n        while args:\n            arg = args.pop(0)\n\n            if arg in [\"-h\", \"--help\"]:\n                print_usage()\n                sys.exit(0)\n            elif arg == \"--dry\":\n                argopts.dryrun = True\n            elif arg == \"-l\" and args:\n                argopts.penvmlib_filename = args.pop(0)\n            elif arg == \"--list\":\n                argopts.list = True\n            elif arg == \"-N\":\n                argopts.networks = args.pop(0).split(\",\")\n            elif arg == \"-r\" and args:\n                argopts.release = args.pop(0)\n            elif arg == \"-s\" and args:\n                argopts.penvmserver_filename = args.pop(0)\n            elif not args:\n                argopts.world_filename = arg\n            else:\n                raise Exception()\n\n        if argopts.list:\n            if None in [argopts.world_filename]:\n                raise Exception()\n        else:\n            if None in [argopts.penvmserver_filename, argopts.world_filename]:\n                raise Exception()\n    except SystemExit:\n        raise\n    except Exception as e:\n        print(f\"error: bad/missing arguments ({e})\", file=sys.stderr)\n        sys.exit(1)\n\n    try:\n        try:\n            world = World(filename=argopts.world_filename)\n        except Exception as e:\n            print(e)\n            print(\n                f\"error: bad or nonexistent config file ({argopts.world_filename})\",\n                file=sys.stderr,\n            )\n            sys.exit(1)\n\n        if argopts.list == True:\n            network_names = world.get_network_names()\n            print(f\"networks: {list(network_names)}\")\n\n            for network_name in network_names:\n                network = world.get_network(network_name)\n                if network != None:\n                    print(f\"targets[{network_name}]: {list(network.get_target_names())}\")\n\n            print(f\"targets[*]: {list(world.get_target_names())}\")\n            sys.exit(0)\n\n        if argopts.networks:\n            target_names = set()\n            for network_name in argopts.networks:\n                network = world.get_network(network_name)\n                if network != None:\n                    target_names.update(network.get_target_names())\n        else:\n            target_names = world.get_target_names()\n\n        # print(f\"{target_names=}\")\n\n        userfshomeid2hosts = {}\n        for target_name in target_names:\n            target = world.get_target(target_name)\n            # print(f\"{target=}\")\n            fshomeid = target.config.get(\"fshome-id\")\n            user = target.config.get(\"user\")\n            host = target.config.get(\"host\")\n            hosts = userfshomeid2hosts.setdefault((user, fshomeid), set())\n            hosts.add(host)\n\n        # print(f\"{userfshomeid2hosts=}\")\n\n        filenames = argopts.penvmlib_filenames[:]\n        filenames.append(argopts.penvmserver_filename)\n\n        release = argopts.release or world.get_meta(\"release\") or get_version_string()\n\n        for userfshomeid, hosts in userfshomeid2hosts.items():\n            user, fshomeid = userfshomeid\n            if fshomeid != None:\n                hosts = [list(hosts)[0]]\n            for host in hosts:\n                deploy_penvmfiles(\n                    release,\n                    fshomeid,\n                    user,\n                    host,\n                    filenames,\n                    dryrun=argopts.dryrun,\n                )\n\n    except SystemExit:\n        raise\n    except Exception as e:\n        traceback.print_exc()\n        print(f\"unexpected error ({e})\", file=sys.stderr)\n        sys.exit(1)", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "src/tools/penvm-zip/penvmzip.py", "chunked_list": ["#! /usr/bin/env -S python3 -B\n#\n# tools/penvmzip.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Build penvm app or lib file.\n\"\"\"\n\nimport os\nimport os.path\nimport sys", "import os.path\nimport sys\nimport traceback\nimport zipapp\nimport zipfile\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nHEREFILE = os.path.realpath(sys.argv[0])\nHEREDIR = os.path.dirname(HEREFILE)\nPENVMLIBFILE = os.path.abspath(f\"{HEREDIR}/../../lib/penvmlib\")", "HEREDIR = os.path.dirname(HEREFILE)\nPENVMLIBFILE = os.path.abspath(f\"{HEREDIR}/../../lib/penvmlib\")\nPENVMLIBDIR = os.path.abspath(f\"{HEREDIR}/../../lib\")\n\nif 0:\n    if os.path.exists(PENVMLIBFILE):\n        sys.path.insert(0, PENVMLIBFILE)\n        print(\"info: using penvmlib file\")\n    elif os.path.exists(PENVMLIBDIR):\n        sys.path.insert(0, PENVMLIBDIR)\n        print(\"info: using penvm source\")\n        PENVMLIBFILE = None\n    else:\n        print(\"fatal: cannot find PENVM library file or directory\", file=sys.stderr)\n        sys.exit(1)", "\n    # from penvm.lib.misc import get_version_string\n\n\ndef penvmappzip(appname, appfilename, appdir, extralibs, modname, fnname):\n    \"\"\"Create a zipapp (application zip archive) application file.\n    It will include the PENVM library, the application file, and\n    optional extra, non-PENVM, library files.\n    \"\"\"\n    try:\n        print(\n            f\"building {appname} ...\\n\"\n            f\"    appfile:  {appfilename}\\n\"\n            f\"    module:   {modname}\\n\"\n            f\"    function: {fnname}\\n\",\n            end=\"\",\n        )\n        print(\"    creating archive ...\")\n        zipapp.create_archive(\n            source=appdir,\n            target=appfilename,\n            interpreter=\"/usr/bin/env python3\",\n            main=f\"{modname}:{fnname}\",\n            compressed=True,\n        )\n\n        with zipfile.ZipFile(appfilename, \"a\") as zipf:\n            if extralibs:\n                for name in extralibs:\n                    print(f\"    adding extralib ({name}) ...\")\n                    if not os.path.exists(name):\n                        raise Exception(f\"cannot find extralib ({name})\")\n                    zipfileadd(zipf, name, stripbase=True)\n        os.chmod(appfilename, 0o755)\n    except Exception as e:\n        traceback.print_exc()\n        raise Exception(\"failed to build penvm app\")", "\n\ndef penvmlibzip(libfilename, penvmlibs, extralibs):\n    \"\"\"Create a zip archive for the PENVM library. Optionally, add\n    extra, non-PENVM, library files.\n    \"\"\"\n    try:\n        print(f\"building library {libfilename} ...\")\n        zipf = zipfile.ZipFile(libfilename, \"w\", compression=zipfile.ZIP_DEFLATED)\n        if penvmlibs:\n            for name in penvmlibs:\n                print(f\"    adding library ({name}) ...\")\n                if not os.path.exists(name):\n                    raise Exception(f\"cannot find penvm lib ({name})\")\n                zipfileadd(zipf, name, stripbase=True)\n\n        if extralibs:\n            for name in extralibs:\n                print(f\"    adding extralib ({name}) ...\")\n                if not os.path.exists(name):\n                    raise Exception(f\"cannot find extralib ({name})\")\n                zipfileadd(zipf, name, stripbase=True)\n        zipf.close()\n    except Exception as e:\n        traceback.print_exc()\n        raise Exception(\"failed to build penvm library\")", "\n\ndef zipfileadd(zipf, path, stripbase=False):\n    try:\n        zipf2 = zipfile.ZipFile(path, \"r\")\n    except:\n        zipf2 = None\n\n    if zipf2 != None:\n        zipfilemerge(zipf, path)\n    else:\n        zipfiledirfile(zipf, path, stripbase)", "\n\ndef zipfiledirfile(zipf, path, stripbase=False):\n    arcname = None\n    if os.path.isfile(path):\n        if stripbase:\n            arcname = os.path.basename(path)\n        zipf.write(path, arcname=arcname)\n    else:\n        for root, dirnames, filenames in os.walk(path):\n            if stripbase:\n                _root = root[len(path) + 1 :]\n            else:\n                _root = root\n\n            # ensure dirs are added (for non-__init__.py support)\n            allnames = dirnames + filenames\n            for name in allnames:\n                _path = os.path.join(root, name)\n                arcname = os.path.join(_root, name)\n                # print(f\"{path=} {_path=} {arcname=}\")\n                zipf.write(_path, arcname=arcname)", "\n\ndef zipfilemerge(zipf, path):\n    with zipfile.ZipFile(path, \"r\") as zipf2:\n        for name in zipf2.namelist():\n            zi = zipf2.open(name)\n            zipf.writestr(name, zi.read())\n\n\ndef print_usage():\n    progname = os.path.basename(sys.argv[0])\n    print(\n        f\"\"\"\\\nusage: {progname} app [-f <fnname>] [-l <extralibs>] [-m <modname>] [-o <appfile>] <appdir>\n       {progname} lib [-l <extralibs>] -o <libfile> [<libdir> ...]\n       {progname} -h|--help\n\nBuild single file PENVM application or library file.\n\nArguments:\n<appdir>            Application directory with same named file containing \"main()\".\n<libdir>            Library directory (containing content).\n--dry               Dry run with making changes.\n-f <fnname>         Function name. Default is \"main\".\n-l <extralibs>      Addtitional files/dirs to add to the zip file.\n                    Multiple uses supported.\n-m <modname>        Module name.\n-o <appfile>|<libfile>\n                    Destination for single file application or library.\n\"\"\",\n        end=\"\",\n    )", "\ndef print_usage():\n    progname = os.path.basename(sys.argv[0])\n    print(\n        f\"\"\"\\\nusage: {progname} app [-f <fnname>] [-l <extralibs>] [-m <modname>] [-o <appfile>] <appdir>\n       {progname} lib [-l <extralibs>] -o <libfile> [<libdir> ...]\n       {progname} -h|--help\n\nBuild single file PENVM application or library file.\n\nArguments:\n<appdir>            Application directory with same named file containing \"main()\".\n<libdir>            Library directory (containing content).\n--dry               Dry run with making changes.\n-f <fnname>         Function name. Default is \"main\".\n-l <extralibs>      Addtitional files/dirs to add to the zip file.\n                    Multiple uses supported.\n-m <modname>        Module name.\n-o <appfile>|<libfile>\n                    Destination for single file application or library.\n\"\"\",\n        end=\"\",\n    )", "\n\nclass ArgOpts:\n    pass\n\n\ndef main():\n    try:\n        argopts = ArgOpts()\n        argopts.appdir = None\n        argopts.buildfilename = None\n        argopts.buildtype = None\n        argopts.dryrun = False\n        argopts.extralibs = []\n        argopts.fnname = \"main\"\n        argopts.libdirs = []\n        argopts.modname = None\n\n        args = sys.argv[1:]\n\n        if args:\n            arg = args.pop(0)\n            if arg in [\"-h\", \"--help\"]:\n                print_usage()\n                sys.exit(0)\n            elif arg in [\"app\", \"lib\"]:\n                argopts.buildtype = arg\n            else:\n                raise Exception()\n        else:\n            raise Exception(\"bad/missing build type\")\n\n        if argopts.buildtype == \"app\":\n            while args:\n                arg = args.pop(0)\n                if arg == \"--dry\":\n                    argopts.dryrun = True\n                elif arg == \"-f\" and args:\n                    argopts.fnname = args.pop(0)\n                elif arg == \"-l\" and args:\n                    argopts.extralibs.append(args.pop(0))\n                elif arg == \"-m\" and args:\n                    argopts.modname = args.pop(0)\n                elif arg == \"-o\" and args:\n                    argopts.buildfilename = args.pop(0)\n                elif not args:\n                    argopts.appdir = arg\n                else:\n                    raise Exception()\n\n            if None in [argopts.appdir]:\n                raise Exception()\n        elif argopts.buildtype == \"lib\":\n            while args:\n                arg = args.pop(0)\n                if arg == \"--dry\":\n                    argopts.dryrun = True\n                elif arg == \"-l\" and args:\n                    argopts.extralibs.append(args.pop(0))\n                elif arg == \"-o\" and args:\n                    argopts.buildfilename = args.pop(0)\n                else:\n                    argopts.libdirs = [arg] + args\n                    del args[:]\n\n            if None in [argopts.buildfilename]:\n                raise Exception()\n    except SystemExit:\n        raise\n    except Exception as e:\n        traceback.print_exc()\n        print(\"error: bad/missing argument\", file=sys.stderr)\n        sys.exit(1)\n\n    try:\n        if argopts.buildtype == \"app\":\n            if argopts.buildfilename:\n                buildfilename = argopts.buildfilename\n            else:\n                buildfilename = os.path.basename(argopts.appdir)\n                if buildfilename.endswith(\".py\"):\n                    buildfilename = buildfilename[:-3]\n            argopts.buildfilename = buildfilename\n\n        if argopts.dryrun:\n            print(f\"appdir:        {argopts.appdir}\")\n            print(f\"buildtype:     {argopts.buildtype}\")\n            print(f\"buildfilename: {argopts.buildfilename}\")\n            print(f\"extralibs:     {argopts.extralibs}\")\n            print(f\"fnname:        {argopts.fnname}\")\n            print(f\"libdirs:       {argopts.libdirs}\")\n            print(f\"modname:       {argopts.modname}\")\n            print(f\"penvmlibdir:   {PENVMLIBDIR}\")\n            print(f\"penvmlibfile:  {PENVMLIBFILE}\")\n        else:\n            if argopts.buildtype == \"app\":\n                appname = os.path.basename(buildfilename)\n                penvmappzip(\n                    appname,\n                    argopts.buildfilename,\n                    argopts.appdir,\n                    argopts.extralibs,\n                    argopts.modname or appname,\n                    argopts.fnname,\n                )\n            elif argopts.buildtype == \"lib\":\n                penvmlibzip(\n                    argopts.buildfilename,\n                    argopts.libdirs,\n                    argopts.extralibs,\n                )\n\n    except Exception as e:\n        print(f\"{e}\", file=sys.stderr)\n        sys.exit(1)", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "src/ext/penvm/ext/workers/__init__.py", "chunked_list": ["#\n# penvm/ext/workers/__init__.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"A Worker is a convenience tool to help parcel out the work to the\nnetwork of machines. The steps are:\n\n1. partition the problem space\n1. spawn the work to the network\n1. collect the results\n1. process the results", "1. collect the results\n1. process the results\n1. combine (consolidate) the results into one\n1. return the final result\n\nWorkers may be tailored to suit specific needs. This is espectially\nrequired for the paritition and combine steps, where both\nimplementations cannot be known in advance.\n\"\"\"\n", "\"\"\"\n\nimport io\nimport logging\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.lib.base import BaseObject\n\nlogger = logging.getLogger(__name__)\n", "logger = logging.getLogger(__name__)\n\n\nclass WorkerException(Exception):\n    pass\n\n\nclass Worker(BaseObject):\n    \"\"\"Base, mostly abstract, class.\"\"\"\n\n    def __init__(\n        self,\n        network: \"Network\",\n        nworkers: Union[int, None] = None,\n        auto_collect: bool = True,\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            network: Network object.\n            nworkers: (Maximum) Number of workers to run with.\n            auto_collect: Collect response objects.\"\"\"\n        try:\n            super().__init__(None, logger)\n            tlogger = self.logger.enter()\n\n            self.network = network\n            self._nworkers = nworkers\n            self.enabled = True\n            self.auto_collect = auto_collect\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def call_one(\n        self,\n        idx: int,\n        session: \"Session\",\n        *args: List,\n        **kwargs: Dict,\n    ):\n        \"\"\"Call one.\n\n        Args:\n            idx: Call index.\n            session: Session for call.\n            *args: Positional arguments for call.\n            **kwargs: Keyword arguments for call.\n\n        Note:\n            Override.\n        \"\"\"\n        pass\n\n    def clean(\n        self,\n        sessions: List[\"Session\"],\n    ):\n        \"\"\"Clean/release all sessions.\n\n        Args:\n            sessions: List of sessions to clean.\n\n        Note:\n            Do not override.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            for idx, session in enumerate(sessions):\n                session.kernel.machine_drop_session()\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def collect(\n        self,\n        sessions: List[\"Session\"],\n    ) -> List[Any]:\n        \"\"\"Collect all results.\n\n        Results are collected using\n        [Worker.collect_one][penvm.ext.workers.Worker.collect_one].\n\n        Args:\n            sessions: List of sessions to collect for.\n\n        Returns:\n            Results from calls.\n\n        Note:\n            Do not override.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            results = []\n            if self.auto_collect:\n                for idx, session in enumerate(sessions):\n                    results.append(self.collect_one(idx, session))\n            return results\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def collect_one(\n        self,\n        idx: int,\n        session: \"Session\",\n    ) -> Any:\n        \"\"\"Collect one result.\n\n        Args:\n            idx: Collect index.\n            session: Session to collect for.\n\n        Returns:\n            Collected result.\n\n        Note:\n            Override.\n        \"\"\"\n        pass\n\n    def combine(\n        self,\n        results: List[Any],\n    ) -> Any:\n        \"\"\"Combine all results into one and return it.\n\n        Args:\n            results: Collected results.\n\n        Returns:\n            Combined results.\n\n        Note:\n            Override.\n        \"\"\"\n        pass\n\n    def disable(self):\n        \"\"\"Disable worker.\n\n        Will use fallback if available.\n        \"\"\"\n        self.enabled = False\n\n    def enable(self):\n        \"\"\"Enable worker.\n\n        Will not force use of fallback.\n        \"\"\"\n        self.enabled = True\n\n    @property\n    def machines(self) -> List[\"Machine\"]:\n        \"\"\"Return the machines available for use, subject to the\n        number of workers.\n\n        Returns:\n            List of machines available for use.\n        \"\"\"\n        machines = self.network.get_machines()\n        return machines[: self.nworkers]\n\n    @property\n    def nworkers(self) -> int:\n        \"\"\"Return the number of workers to use.\n\n        Returns:\n            Number of workers to use.\n        \"\"\"\n        if self._nworkers != None:\n            return self._nworkers\n        else:\n            return len(self.network.get_machines())\n\n    def partition(\n        self,\n        *args: List,\n        **kwargs: Dict,\n    ):\n        \"\"\"Partition problem space. Yield for each.\n\n        Args:\n            *args: Positional arguments for call.\n            **kwargs: Keyword arguments for call.\n\n        Yields:\n            (Tuple[List, Dict]): `args` and `kwargs` unchanged.\n\n        Note:\n            Override.\n        \"\"\"\n        yield (args, kwargs)\n\n    def process(\n        self,\n        results: List[Any],\n    ) -> List[Any]:\n        \"\"\"Process and return all results.\n\n        Args:\n            results: Collected results.\n\n        Returns:\n            Results unchanged.\n\n        Note:\n            Override as needed.\n        \"\"\"\n        return results\n\n    def run(\n        self,\n        *args: List,\n        **kwargs: Dict,\n    ) -> Any:\n        \"\"\"Run work across network and return result.\n\n        Args:\n            *args: Positional arguments.\n            **kwargs: Keyword arguments.\n\n        Returns:\n            Final result.\n\n        Note:\n            Do not override.\n        \"\"\"\n        # ensure network is set up\n        try:\n            tlogger = self.logger.enter()\n\n            try:\n                self.network.boot()\n            except Exception as e:\n                raise WorkerException(\"cannot boot network\")\n\n            sessions = self.spawn(*args, **kwargs)\n            results = self.collect(sessions)\n            results = self.process(results)\n            result = self.combine(results)\n            self.clean(sessions)\n            return result\n        except WorkerException as e:\n            raise\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def spawn(\n        self,\n        *args: List,\n        **kwargs: Dict,\n    ) -> List[\"Session\"]:\n        \"\"\"Spawn partitioned work across machines.\n\n        Args:\n            *args: Positional arguments.\n            **kwargs: Keyword arguments.\n\n        Returns:\n            List of sessions used.\n\n        Note:\n            Do not override.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            sessions = []\n            machines = self.machines\n            nmachines = len(machines)\n            for idx, part in enumerate(self.partition(*args, **kwargs)):\n                _args, _kwargs = part\n                _args, _kwargs = self.transform(*_args, **_kwargs)\n                machine = machines[idx % nmachines]\n                session = machine.get_session()\n                sessions.append(session)\n                self.call_one(idx, session, *_args, **_kwargs)\n\n            return sessions\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def test(\n        self,\n        *args: List,\n        **kwargs: Dict,\n    ):\n        \"\"\"Test run.\n\n        No actual calls or processing are made.\n\n        Args:\n            *args: Positional arguments.\n            **kwargs: Keyword arguments.\n\n        Yields:\n            (Tuple[List, Dict]): `args` and `kwargs` after partitioning and transformation.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            # see spawn for calling pattern as below\n            for idx, part in enumerate(self.partition(*args, **kwargs)):\n                _args, _kwargs = part\n                _args, _kwargs = self.transform(*_args, **_kwargs)\n                yield (_args, _kwargs)\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def transform(\n        self,\n        *args: List,\n        **kwargs: Dict,\n    ) -> Tuple[List, Dict]:\n        \"\"\"Transform args and kwargs after partitioning and prior to\n        running.\n\n        Args:\n            *args: Positional arguments.\n            **kwargs: Keyword arguments.\n\n        Returns:\n            `args` and `kwargs` unchanged.\n        \"\"\"\n        return (args, kwargs)", "\n\nclass MirrorMixin:\n    \"\"\"Mixin to provide mirror support for Worker.\n\n    *All* workers are given the same parameters to use (see\n    `partition`).\n    \"\"\"\n\n    def combine(\n        self,\n        results: List[Any],\n    ) -> Dict[str, Any]:\n        \"\"\"Return dictionary with results given under respective\n        machine id keys.\n\n        Args:\n            results: Collected results.\n\n        Returns:\n            Combined results.\n        \"\"\"\n        machines = self.machines\n        d = {}\n        for i, result in enumerate(results):\n            d[machines[i].oid] = result\n        return d\n\n    def partition(\n        self,\n        *args: List,\n        **kwargs: Dict,\n    ):\n        \"\"\"Same args and kwargs (untouched) for each.\n\n        Args:\n            *args: Positional arguments.\n            **kwargs: Keyword arguments.\n\n        Yields:\n            (Tuple[List, Dict]): `args` and `kwargs` unchanged.\n        \"\"\"\n        for idx, machine in enumerate(self.machines):\n            yield (args, kwargs)", "\n\nclass PartitionByFunctionWorker(Worker):\n    \"\"\"No partitioning is done, but the `args` is extended with\n    `nworkers` and `index`. This is suitable for cases in which the\n    receiving function does the partition based on `nworkers` and the\n    `index`.\n    \"\"\"\n\n    def partition(\n        self,\n        *args: List,\n        **kwargs: Dict,\n    ):\n        nworkers = self.nworkers if self.nworkers != None else len(self.machines)\n        for i in range(nworkers):\n            yield (list(args) + [self.nworkers, i], kwargs)", "\n\nclass InputMixin:\n    \"\"\"Mixin to partition the problem space into an input-defined\n    number of partitions.\n    \"\"\"\n\n    def combine(\n        self,\n        results: List[Any],\n    ) -> Dict[int, Any]:\n        \"\"\"Return dictionary with results given under respective\n        partition index.\n\n        Args:\n            results: Collected results.\n\n        Returns:\n            Combined results.\n        \"\"\"\n        d = {}\n        for i, result in enumerate(results):\n            d[i] = result\n        return d\n\n    def partition(\n        self,\n        *args: List,\n        **kwargs: Dict,\n    ) -> Tuple[List, Dict]:\n        \"\"\"Partition input stream.\n\n        Keyword Args:\n            `_` (dict): Input directives.\n            `*` (Any): All others for the call.\n\n        Keyword Args: Keyword Input Directives:\n            `fieldsname` (str): Name of fields list referenced with\n                `transform`.Defaults to \"f\".\n            `file` (file): Input stream.\n            `fsep` (str): Field separator. Defaults to whitespace.\n            `data` (str|bytes): Input data.\n            `rsep` (str): Record separator. Defaults to newline.\n            `striprsep` (bool): Strip record separator. Defaults to\n                `False`.\n            `transform` (str): Python code to transform data fields\n                (accessible via list named `fieldsname`). Defaults to\n                identity.\n\n        Yields:\n            `args` partitioned according to directives.\n        \"\"\"\n        idirectives = kwargs.get(\"_\", {})\n        fieldsname = idirectives.get(\"fieldsname\", \"f\")\n        file = idirectives.get(\"file\")\n        fsep = idirectives.get(\"fsep\", None)\n        data = idirectives.get(\"data\")\n        rsep = idirectives.get(\"rsep\", \"\\n\")\n        striprsep = idirectives.get(\"striprsep\", False)\n        transformstr = idirectives.get(\"transform\", None)\n\n        if transformstr:\n            try:\n                transformcode = compile(transformstr, filename=\"transform\", mode=\"exec\")\n            except Exception as e:\n                raise Exception(f\"transform string compilation failed ({e})\")\n        else:\n            transformcode = None\n\n        # TODO: handle text and bytes lsep and fsep defaults\n        if data != None:\n            if type(data) == str:\n                f = io.StringIO(data)\n            else:\n                f = io.BytesIO(data)\n                if type(rsep) != bytes:\n                    rsep = rsep.encode()\n        elif file != None:\n            f = file\n        else:\n            raise Exception(\"no input stream/data provided\")\n\n        while True:\n            # TODO: update to support non-newline line separator\n            rec = f.readline()\n            if rec == \"\":\n                break\n            if striprsep == True:\n                rec = rec.rstrip(rsep)\n            fields = rec.split(fsep)\n            if transformcode:\n                import os.path\n\n                exec(transformcode, {fieldsname: fields, \"os\": os})\n            _args = [arg.format(*fields) for arg in args]\n            yield (_args, {})", "\n\nclass ExecWorker(Worker):\n    \"\"\"Worker to call executable.\"\"\"\n\n    def __init__(\n        self,\n        cwd: str,\n        network: \"Network\",\n        nworkers: Union[int, None] = None,\n        auto_collect: bool = True,\n        text: bool = True,\n        env: dict = None,\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            cwd: Working directory to use.\n            network: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n            nworkers: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n            auto_collect: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n            text: Work in text mode.\n            env: Environment variable settings.\n        \"\"\"\n        super().__init__(network, nworkers, auto_collect)\n        self.cwd = cwd\n        self.text = text\n        self.env = env\n\n    def call_one(\n        self,\n        idx: int,\n        session: \"Session\",\n        *args: List,\n        **kwargs: Dict,\n    ):\n        \"\"\"Call one.\n\n        Args:\n            args (str): `[0]`: Command path.\n            args (List[Any]): `[1:]`: Command arguments.\n\n        See [Worker.call_one][penvm.ext.workers.Worker.call_one].\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            session.kernel.run_exec(\n                args[0],\n                args[1:],\n                capture_output=True,\n                text=self.text,\n                cwd=self.cwd,\n                env=self.env,\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def collect_one(\n        self,\n        idx: int,\n        session: \"Session\",\n    ) -> Dict:\n        \"\"\"Collect one result.\n\n        Extract information from the payload:\n\n        * `status`: Response status.\n        * `returncode`: Return code from execution.\n        * `stderr`: Stderr output.\n        * `stdout`: Stdout output.\n\n        See [Worker.collect_one][penvm.ext.workers.Worker.collect_one].\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            resp = session.get_response()\n            payload = resp.payload\n            return {\n                \"status\": payload.get(\"-status\"),\n                \"returncode\": payload.get(\"returncode\"),\n                \"stderr\": payload.get(\"stderr\", \"\"),\n                \"stdout\": payload.get(\"stdout\", \"\"),\n            }\n\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()", "\n\nclass OpWorker(Worker):\n    \"\"\"Worker to call an op.\n\n    Note:\n        `auto_collect` is `False` by default because of the\n        nature of operations (many do *not* send responses.)\n    \"\"\"\n\n    def __init__(\n        self,\n        kernelname: str,\n        network: \"Network\",\n        nworkers: Union[int, None] = None,\n        auto_collect: bool = False,\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            kernelname: Name of kernel to use.\n            network: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n            nworkers: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n            auto_collect: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n        \"\"\"\n        super().__init__(network, nworkers, auto_collect)\n        self.kernelname = kernelname\n\n    def call_one(\n        self,\n        idx: int,\n        session: \"Session\",\n        *args: List,\n        **kwargs: Dict,\n    ) -> Any:\n        \"\"\"Call one.\n\n        Args:\n            args (str): `[0]`: Kernel client op method name.\n            args (List[Any]): `[1:]`: Arguments for the method call.\n\n        See [Worker.call_one][penvm.ext.workers.Worker.call_one].\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            opname = args[0]\n            fn = getattr(session.kernel, opname)\n            fn(*args[1:], **kwargs)\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def collect_one(\n        self,\n        idx: int,\n        session: \"Session\",\n    ) -> Dict:\n        \"\"\"Collect one result.\n\n        See [Worker.collect_one][penvm.ext.workers.Worker.collect_one].\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n            resp = session.get_response()\n            payload = resp.payload\n            return payload.dict()\n        except Exception as e:\n            tlogger.error(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()", "\n\nclass PythonCodeWorker(Worker):\n    \"\"\"Worker to call Python code.\"\"\"\n\n    def __init__(\n        self,\n        fallback: str,\n        code: str,\n        network: \"Network\",\n        nworkers: Union[int, None] = None,\n        auto_collect: bool = True,\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            fallback: Fallback function/method to call.\n            code: Python code to run.\n            network: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n            nworkers: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n            auto_collect: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n        \"\"\"\n        super().__init__(network, nworkers, auto_collect)\n        self.fallback = fallback\n        self.code = code\n\n    def call_one(\n        self,\n        idx: int,\n        session: \"Session\",\n        *args: List,\n        **kwargs: Dict,\n    ) -> Any:\n        \"\"\"Call one.\n\n        Args:\n            args (str): `[0]`: Function name to call in provided code.<br>\n            args (List[Any]): `[1:]`: Arguments to call function with.\n            kwargs: Keyword arguments to call function with.\n\n        See [Worker.call_one][penvm.ext.workers.Worker.call_one].\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n            session.kernel.run_python_function(\n                self.code,\n                args[0],\n                args[1:],\n                kwargs,\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def collect_one(\n        self,\n        idx: int,\n        session: \"Session\",\n    ) -> Any:\n        \"\"\"Collect one result.\n\n        Extract information from the payload:\n\n        * `-status`: Execution status.\n        * `return-value`: Function return value.\n\n        See [Worker.collect_one][penvm.ext.workers.Worker.collect_one].\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            resp = session.get_response()\n            payload = resp.payload\n            if payload.get(\"-status\") == \"error\":\n                # TODO: what to do?\n                pass\n            return payload.get(\"return-value\")\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def run(\n        self,\n        *args: List,\n        **kwargs: Dict,\n    ) -> Any:\n        \"\"\"Run fallback or worker run.\n\n        See [Worker.run][penvm.ext.workers.Worker.run].\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            if self.use_fallback(*args, **kwargs) or not self.enabled:\n                return self.fallback(*args, **kwargs)\n            else:\n                return super().run(*args, **kwargs)\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def use_fallback(\n        self,\n        *args: List,\n        **kwargs: Dict,\n    ):\n        \"\"\"Call fallback by default, if available.\"\"\"\n        return self.fallback != None\n\n    def wrun(\n        self,\n        fnname: str,\n    ) -> Callable:\n        \"\"\"Wrap run call to provide `fnname` with `args` and `kwargs`.\n\n        This allows for the function name to *not* have to be in the\n        `args` and better mirror what may have been the original call\n        signature.\n\n        Args:\n            fnname: Function name to call.\n\n        Returns:\n            Wrapped function call.\n        \"\"\"\n\n        def _run(*args, **kwargs) -> Any:\n            return self.run(fnname, *args, **kwargs)\n\n        return _run", "\n\nclass InputExecWorker(InputMixin, ExecWorker):\n    \"\"\"Combined [penvm.ext.workers.InputMixin][] and\n    [penvm.ext.workers.ExecWorker][].\"\"\"\n\n    pass\n\n\nclass InputPythonCodeWorker(InputMixin, PythonCodeWorker):\n    \"\"\"Combined [penvm.ext.workers.InputMixin][] and\n    [penvm.ext.workers.PythonCodeWorker][].\"\"\"\n\n    pass", "\nclass InputPythonCodeWorker(InputMixin, PythonCodeWorker):\n    \"\"\"Combined [penvm.ext.workers.InputMixin][] and\n    [penvm.ext.workers.PythonCodeWorker][].\"\"\"\n\n    pass\n\n\nclass MirrorOpWorker(MirrorMixin, OpWorker):\n    \"\"\"Combined [penvm.ext.workers.MirrorMixin][] and\n    [penvm.ext.workers.OpWorker][].\"\"\"\n\n    pass", "class MirrorOpWorker(MirrorMixin, OpWorker):\n    \"\"\"Combined [penvm.ext.workers.MirrorMixin][] and\n    [penvm.ext.workers.OpWorker][].\"\"\"\n\n    pass\n\n\nclass MirrorExecWorker(MirrorMixin, ExecWorker):\n    \"\"\"Combined [penvm.ext.workers.MirrorMixin][] and\n    [penvm.ext.workers.ExecWorker][].\"\"\"\n\n    pass", "\n\nclass MirrorPythonCodeWorker(MirrorMixin, PythonCodeWorker):\n    \"\"\"Combined [penvm.ext.workers.MirrorMixin][] and\n    [penvm.ext.workers.PythonCodeWorker][].\"\"\"\n\n    pass\n"]}
{"filename": "src/tests/semaphore_test.py", "chunked_list": ["#! /usr/bin/env python3\n#\n# tests/semaphore_test.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom threading import Thread\nimport time\n\nfrom penvm.lib.semaphore import AdjustableSemaphore\n\n\ndef sem_acquire(sem):\n    print(\"sem_acquire ...\")\n    sem.acquire()\n    print(\"sem_acquired ...\")\n    print(f\"{sem.count()=} {sem.max()=}\")", "\n\ndef sem_acquire(sem):\n    print(\"sem_acquire ...\")\n    sem.acquire()\n    print(\"sem_acquired ...\")\n    print(f\"{sem.count()=} {sem.max()=}\")\n\n\ndef sem_2acquire_release_test():\n    print(\"sem_2acquire_release_test\")\n    sem = AdjustableSemaphore()\n    print(f\"{sem.count()=} {sem.max()=}\")\n    sem.acquire()\n    Thread(target=sem_acquire, args=(sem,)).start()\n    time.sleep(1)\n    print(f\"{sem.count()=} {sem.max()=}\")\n    print(\"releasing ...\")\n    sem.release()\n    print(f\"{sem.count()=} {sem.max()=}\")\n    sem.release()\n    print(f\"{sem.count()=} {sem.max()=}\")", "\ndef sem_2acquire_release_test():\n    print(\"sem_2acquire_release_test\")\n    sem = AdjustableSemaphore()\n    print(f\"{sem.count()=} {sem.max()=}\")\n    sem.acquire()\n    Thread(target=sem_acquire, args=(sem,)).start()\n    time.sleep(1)\n    print(f\"{sem.count()=} {sem.max()=}\")\n    print(\"releasing ...\")\n    sem.release()\n    print(f\"{sem.count()=} {sem.max()=}\")\n    sem.release()\n    print(f\"{sem.count()=} {sem.max()=}\")", "\n\ndef sem_acquire_release_test():\n    print(\"sem_acquire_release_test\")\n    sem = AdjustableSemaphore(1)\n    print(f\"{sem.count()=} {sem.max()=}\")\n    sem.acquire()\n    print(f\"{sem.count()=} {sem.max()=}\")\n    sem.release()\n    print(f\"{sem.count()=} {sem.max()=}\")", "\n\ndef main():\n    sem_acquire_release_test()\n    print()\n    sem_2acquire_release_test()\n\n\nif __name__ == \"__main__\":\n    main()", "if __name__ == \"__main__\":\n    main()\n"]}
{"filename": "src/tests/session_test.py", "chunked_list": ["#! /usr/bin/env python3\n#\n# tests/session_test.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom threading import Thread\nimport time\n\nfrom penvm.client.world import World\n\n\ndef main():\n    w = World(filename=\"world.penvm\")\n    print(f\"{w=}\")\n    t = w.get_target(\"localhost\")\n    print(f\"{t=}\")\n    m = t.boot()\n\n    print(f\"{m=}\")", "\n\ndef main():\n    w = World(filename=\"world.penvm\")\n    print(f\"{w=}\")\n    t = w.get_target(\"localhost\")\n    print(f\"{t=}\")\n    m = t.boot()\n\n    print(f\"{m=}\")", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "src/tests/queue_test.py", "chunked_list": ["#! /usr/bin/env python3\n#\n# tests/queue_test.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom threading import Thread\nimport time\n\nfrom penvm.lib.mqueue import MessageQueue\n\n\ndef pop_wait(q):\n    print(\"pop_wait ...\")\n    print(f\"pop_wait {q.pop()=}\")", "\n\ndef pop_wait(q):\n    print(\"pop_wait ...\")\n    print(f\"pop_wait {q.pop()=}\")\n\n\ndef popwait_put_test():\n    print(\"popwait_put_test\")\n    q = MessageQueue()\n    Thread(target=pop_wait, args=(q,)).start()\n    time.sleep(1)\n    q.put(1)", "\n\ndef put_pop_test():\n    print(\"put_pop_test\")\n    q = MessageQueue()\n    q.put(1)\n    print(f\"{q.pop()=}\")\n\n\ndef main():\n    put_pop_test()\n    print()\n    popwait_put_test()", "\ndef main():\n    put_pop_test()\n    print()\n    popwait_put_test()\n\n\nif __name__ == \"__main__\":\n    main()\n", ""]}
{"filename": "src/lib/penvm/lib/thread.py", "chunked_list": ["#\n# penvm/lib/thread.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Provides modified `Thread` to support thread termination.\n\"\"\"\n\nimport ctypes\nimport logging\nimport threading\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union", "import threading\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.lib.base import BaseObject\nfrom penvm.lib.misc import State\n\nlogger = logging.getLogger(__name__)\n\n\nclass ThreadInterrupt(Exception):\n    \"\"\"Special exception for augmented Thread.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize.\"\"\"\n        super().__init__(\"interrupted thread\")", "\nclass ThreadInterrupt(Exception):\n    \"\"\"Special exception for augmented Thread.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize.\"\"\"\n        super().__init__(\"interrupted thread\")\n\n\nclass Thread(BaseObject, threading.Thread):\n    \"\"\"Thread with specific settings and functionality:\n    * Will die on main thread exit.\n    * Support for exception to thread.\n    * Terminatable.\n\n    See https://code.activestate.com/recipes/496960-thread2-killable-threads/.\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: List,\n        **kwargs: Dict,\n    ):\n        \"\"\"Initialize.\n\n        See [theading.Thread][].\n        \"\"\"\n        try:\n            BaseObject.__init__(self, None, logger)\n            threading.Thread.__init__(self, *args, **kwargs)\n            self.oid = self.name\n            self.daemon = True\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            pass\n\n    def get_id(self) -> int:\n        \"\"\"Return thread id.\n\n        Returns:\n            Thread id.\n        \"\"\"\n        if hasattr(self, \"_thread_id\"):\n            return self._thread_id\n\n        for id, thread in threading._active.items():\n            if thread is self:\n                return id\n\n    def raise_exception(self, exc: Exception):\n        \"\"\"Raise a specific exception.\n\n        Args:\n            exc: Exception to raise.\n        \"\"\"\n        self.logger.debug(\"raising exception ({exc}) ...\")\n\n        # TODO: should this be repeated until it is effective?\n\n        threadid = self.get_id()\n        if threadid != None:\n            res = ctypes.pythonapi.PyThreadState_SetAsyncExc(\n                ctypes.c_long(threadid),\n                ctypes.py_object(exc),\n            )\n            self.logger.info(\"raise exception result ({res})\")\n            if res > 1:\n                res2 = ctypes.pythonapi.PyThreadState_SetAsyncExc(\n                    ctypes.c_long(threadid),\n                    0,\n                )\n                # exception raise failure\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            return State(\n                \"thread\",\n                self.oid,\n                {\n                    \"args\": [str(arg) for arg in self._args],\n                    \"kwargs\": [str(arg) for arg in self._kwargs.items()],\n                    \"name\": self._name,\n                    \"native-id\": self.native_id,\n                    \"target\": str(self._target),\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n\n    def terminate(self):\n        \"\"\"Terminate. Raises exception.\"\"\"\n        # TODO: will this ultimately work, e.g., even when returning\n        # from C code/extension? should it repeat until effective?\n        self.logger.debug(\"terminating ...\")\n        self.raise_exception(ThreadInterrupt)", "\nclass Thread(BaseObject, threading.Thread):\n    \"\"\"Thread with specific settings and functionality:\n    * Will die on main thread exit.\n    * Support for exception to thread.\n    * Terminatable.\n\n    See https://code.activestate.com/recipes/496960-thread2-killable-threads/.\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: List,\n        **kwargs: Dict,\n    ):\n        \"\"\"Initialize.\n\n        See [theading.Thread][].\n        \"\"\"\n        try:\n            BaseObject.__init__(self, None, logger)\n            threading.Thread.__init__(self, *args, **kwargs)\n            self.oid = self.name\n            self.daemon = True\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            pass\n\n    def get_id(self) -> int:\n        \"\"\"Return thread id.\n\n        Returns:\n            Thread id.\n        \"\"\"\n        if hasattr(self, \"_thread_id\"):\n            return self._thread_id\n\n        for id, thread in threading._active.items():\n            if thread is self:\n                return id\n\n    def raise_exception(self, exc: Exception):\n        \"\"\"Raise a specific exception.\n\n        Args:\n            exc: Exception to raise.\n        \"\"\"\n        self.logger.debug(\"raising exception ({exc}) ...\")\n\n        # TODO: should this be repeated until it is effective?\n\n        threadid = self.get_id()\n        if threadid != None:\n            res = ctypes.pythonapi.PyThreadState_SetAsyncExc(\n                ctypes.c_long(threadid),\n                ctypes.py_object(exc),\n            )\n            self.logger.info(\"raise exception result ({res})\")\n            if res > 1:\n                res2 = ctypes.pythonapi.PyThreadState_SetAsyncExc(\n                    ctypes.c_long(threadid),\n                    0,\n                )\n                # exception raise failure\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            return State(\n                \"thread\",\n                self.oid,\n                {\n                    \"args\": [str(arg) for arg in self._args],\n                    \"kwargs\": [str(arg) for arg in self._kwargs.items()],\n                    \"name\": self._name,\n                    \"native-id\": self.native_id,\n                    \"target\": str(self._target),\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n\n    def terminate(self):\n        \"\"\"Terminate. Raises exception.\"\"\"\n        # TODO: will this ultimately work, e.g., even when returning\n        # from C code/extension? should it repeat until effective?\n        self.logger.debug(\"terminating ...\")\n        self.raise_exception(ThreadInterrupt)", ""]}
{"filename": "src/lib/penvm/lib/base.py", "chunked_list": ["#\n# penvm/lib/base.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Provide `BaseObject` for all PENVM classes that need its\nfunctionality.\"\"\"\n\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.lib.misc import LoggerAdapter, get_uuid\n", "from penvm.lib.misc import LoggerAdapter, get_uuid\n\n\nclass BaseObject:\n    \"\"\"Base object for PENVM classes.\n\n    Provides common support for `oid` (UU object id) and\n    object-specific `LoggerAdapter` logger.\"\"\"\n\n    name = \"base\"\n\n    def __init__(self, oid: str, logger: \"Logger\"):\n        \"\"\"Initialize.\n\n        Args:\n            oid: Universally unique object id.\n            logger: Logger to wrap with `LoggerAdapter`.\n        \"\"\"\n        self.oid = oid or get_uuid()\n        self.logger = LoggerAdapter(logger, {\"self\": self, \"id\": self.oid})", ""]}
{"filename": "src/lib/penvm/lib/kvstore.py", "chunked_list": ["#\n# penvm/lib/kvstore.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport fnmatch\nimport logging\nimport os\nimport os.path\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nlogger = logging.getLogger(__name__)", "\nlogger = logging.getLogger(__name__)\n\nfrom penvm.lib.base import BaseObject\nfrom penvm.lib.misc import State\n\n\nclass KVStore(BaseObject):\n    \"\"\"Base key+value store.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize.\"\"\"\n        super().__init__(None, logger)\n\n    def drop(\n        self,\n        k: Any,\n    ):\n        \"\"\"Drop value for k.\n\n        Args:\n            k: Key.\n        \"\"\"\n        self.pop(k)\n\n    def exists(\n        self,\n        k: Any,\n    ) -> bool:\n        \"\"\"Indicate if key exists or not.\n\n        Args:\n            k: Key.\n\n        Returns:\n            Status of k in store.\n        \"\"\"\n        pass\n\n    def get(\n        self,\n        k: Any,\n        default: Any = None,\n    ) -> Any:\n        \"\"\"Get value for k.\n\n        Args:\n            k: Any.\n            default: Any.\n\n        Returns:\n            Value for k.\n        \"\"\"\n        pass\n\n    def keys(\n        self,\n        pattern: Union[str, None] = None,\n    ) -> List[Any]:\n        \"\"\"List of keys in store.\n\n        Args:\n            pattern: Filter for keys to return.\n\n        Returns:\n            Keys matching pattern.\n        \"\"\"\n        return []\n\n    def pop(\n        self,\n        k: Any,\n        default: Any = None,\n    ) -> Any:\n        \"\"\"Pop value from store for k.\n\n        Args:\n            k: Key.\n\n        Returns:\n            Value for k or `default` otherwise.\n        \"\"\"\n        pass\n\n    def put(\n        self,\n        k: Any,\n        v: Any,\n    ):\n        \"\"\"Put value in store.\n\n        Args:\n            k: Key.\n            v: Value.\n        \"\"\"\n        pass\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` of store.\n        \"\"\"\n        try:\n            return State(\n                \"kvstore\",\n                self.oid,\n                {\n                    \"names\": list(self.keys()),\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")", "\n\nclass MemoryKVStore(KVStore):\n    \"\"\"Memory based [penvm.lib.kvstore.KVStore][].\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize.\"\"\"\n        super().__init__()\n        self.oid = \"memory\"\n        self.d = {}\n\n    def exists(self, k: str) -> bool:\n        \"\"\"See [penvm.lib.kvstore.KVStore.exists][].\"\"\"\n        return k in self.d\n\n    def get(\n        self,\n        k: str,\n        default: Any = None,\n    ) -> Any:\n        \"\"\"See [penvm.lib.kvstore.KVStore.get][].\"\"\"\n        return self.d.get(k, default)\n\n    def keys(\n        self,\n        pattern: Union[str, None] = None,\n    ) -> List[str]:\n        \"\"\"See See [penvm.lib.kvstore.KVStore.keys][].\"\"\"\n        return fnmatch.filter(self.d.keys(), pattern)\n\n    def pop(self, k: str) -> Any:\n        \"\"\"See [penvm.lib.kvstore.KVStore.pop][].\"\"\"\n        self.d.pop(k)\n\n    def put(self, k: str, v: Any):\n        \"\"\"See [penvm.lib.kvstore.KVStore.put][].\"\"\"\n        self.d[k] = v", "\n\nclass FInfo:\n    \"\"\"File info for [penvm.lib.kvstore.FileKVStore][].\n\n    Tracks value type (text, bytes).\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize.\"\"\"\n        self.type = None", "\n\nclass FileKVStore(KVStore):\n    \"\"\"File based [penvm.lib.kvstore.KVStore][].\"\"\"\n\n    def __init__(\n        self,\n        dirpath: str,\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            dirpath: Directory path to store files.\n\n        See See [penvm.lib.kvstore.KVStore.__init__][].\n        \"\"\"\n        try:\n            super().__init__()\n            self.oid = \"file\"\n\n            self.dirpath = dirpath\n\n            if not self.dirpath.startswith(\"/tmp/\"):\n                raise Exception(\"FileKVStore must be under allowed directory\")\n            self.d = {}\n            os.mkdir(self.dirpath, 0o700)\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            pass\n\n    def __del__(self):\n        if not self.dirpath.startswith(\"/tmp/\"):\n            return\n\n        for name in self.d.keys():\n            self.drop(name)\n\n        try:\n            os.rmdir(self.dirpath)\n        except Exception as e:\n            pass\n\n    def get(\n        self,\n        k: str,\n        default: Union[str, bytes, None] = None,\n    ) -> Union[str, bytes, None]:\n        \"\"\"See [penvm.lib.kvstore.KVStore.get][].\"\"\"\n        try:\n            k = k.replace(\"/\", \"__\")\n            finfo = self.d.get(k)\n            if not finfo:\n                return None\n\n            if finfo.type == \"text\":\n                mode = \"r+t\"\n            elif finfo.type == \"binary\":\n                mode = \"r+b\"\n            path = f\"{self.dirpath}/{k}\"\n            if os.path.exists(path):\n                v = open(path, mode).read()\n        except Exception as e:\n            self.logger.warning(f\"put EXCEPTION ({e})\")\n\n        return v\n\n    def get_path(\n        self,\n        k: str,\n        default: Union[str, None] = None,\n    ) -> str:\n        \"\"\"Return the path associated with the key.\n\n        Args:\n            k: Key.\n            default: Default value.\n\n        Returns:\n            File path holding value.\n        \"\"\"\n        try:\n            path = f\"{self.dirpath}/{k}\"\n            if not os.path.exists(path):\n                return None\n            return path\n        except Exception as e:\n            pass\n\n    def keys(\n        self,\n        pattern=None,\n    ) -> List[str]:\n        \"\"\"See [penvm.lib.kvstore.KVStore.keys][].\"\"\"\n        try:\n            names = list(self.d.keys())\n            # names = os.listdir(f\"{self.dirpath}\")\n        except Exception as e:\n            names = []\n\n        if pattern:\n            names = fnmatch.filter(names, pattern)\n        return names\n\n    def pop(\n        self,\n        k: str,\n    ) -> Union[str, bytes, None]:\n        \"\"\"See [penvm.lib.kvstore.KVStore.pop][].\"\"\"\n        try:\n            v = self.get(k)\n            k = k.replace(\"/\", \"__\")\n            path = f\"{self.dirpath}/{k}\"\n            os.remove(path)\n            self.d.pop(k)\n            return v\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n\n    def put(\n        self,\n        k: str,\n        v: Union[str, bytes],\n    ):\n        \"\"\"See [penvm.lib.kvstore.KVStore.put][].\"\"\"\n        try:\n            k = k.replace(\"/\", \"__\")\n            path = f\"{self.dirpath}/{k}\"\n            self.logger.debug(f\"put {k=} {path=}\")\n\n            finfo = FInfo()\n            if type(v) == str:\n                finfo.type = \"text\"\n                mode = \"w+t\"\n            else:\n                finfo.type = \"binary\"\n                mode = \"w+b\"\n            open(path, mode).write(v)\n            self.d[k] = finfo\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")", ""]}
{"filename": "src/lib/penvm/lib/message.py", "chunked_list": ["#\n# penvm/lib/message.py\n#\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nfrom collections.abc import MutableMapping\nimport copy\nimport io\nimport json\nimport logging", "import json\nimport logging\nimport time\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\nimport yaml\n\nfrom penvm.lib.misc import State, get_uuid\n\nlogger = logging.getLogger(__name__)\n", "logger = logging.getLogger(__name__)\n\nHEADER_SZ_LEN = 5\nHEADER_SZ_FMT = b\"%%0.%dd\" % HEADER_SZ_LEN\nHEADER_SZ_MAX = 100_000 - 1\nPAYLOAD_SZ_LEN = 8\nPAYLOAD_SZ_FMT = b\"%%0.%dd\" % PAYLOAD_SZ_LEN\nPAYLOAD_SZ_MAX = 100_000_000 - 1 - HEADER_SZ_MAX - 40\n\nNON_CONFORMING = \"__non-conforming__\"", "\nNON_CONFORMING = \"__non-conforming__\"\n\n\nclass JSONEncoder(json.JSONEncoder):\n    \"\"\"Enhanced JSONEncoder with support for non-conforming types:\n\n    * `bytes` - Bytes.\n    * `complex` - Complex.\n    * `numpy.*` - Python-only.\n    \"\"\"\n\n    def default(self, o):\n        # TODO: optimize/clean up\n        otype = type(o)\n        if otype == bytes:\n            o = {\n                NON_CONFORMING: {\n                    \"type\": \"bytes\",\n                    \"value\": base64.b64encode(o).decode(\"utf-8\"),\n                }\n            }\n            return o\n        elif otype == complex:\n            o = {\n                NON_CONFORMING: {\n                    \"type\": \"complex\",\n                    \"value\": [o.real, o.imag],\n                }\n            }\n            return o\n        elif otype.__module__ == \"numpy\":\n            try:\n                import numpy\n            except:\n                numpy = None\n\n            f = io.BytesIO()\n            numpy.save(f, o)\n            o = {\n                NON_CONFORMING: {\n                    \"type\": \"numpy\",\n                    \"class\": o.__class__.__name__,\n                    \"value\": base64.b64encode(f.getvalue()).decode(\"utf-8\"),\n                }\n            }\n            return o\n\n        return json.JSONEncoder.default(self, o)", "\n\ndef json_decoder_object_hook(o):\n    \"\"\"Support for decoding of non-conforming types:\n\n    * `bytes` - Bytes.\n    * `complex` - Complex.\n    * `numpy.*` - Numpy serialized objects (Python-only).\n\n    The encoding is an object as:\n\n    ```\n    NON_CONFORMING: {\n        \"type\": <str>,\n        \"value\": <base64encoding>,\n    }\n    ```\n\n    Note: Object keys cannot be bytes.\n    \"\"\"\n\n    if NON_CONFORMING in o:\n        nctype = o.get(NON_CONFORMING).get(\"type\")\n        ncvalue = o.get(NON_CONFORMING).get(\"value\")\n        if nctype:\n            if nctype == \"bytes\":\n                return base64.b64decode(ncvalue.encode(\"utf-8\"))\n            elif nctype == \"complex\":\n                return complex(ncvalue[0], ncvalue[1])\n            elif nctype == \"numpy\":\n                try:\n                    import numpy\n                except:\n                    numpy = None\n\n                f = io.BytesIO(base64.b64decode(ncvalue.encode(\"utf-8\")))\n                return numpy.load(f, allow_pickle=False)\n\n    return o", "\n\nclass MessagePart(MutableMapping):\n    \"\"\"Dict-type object with enhanced json codec support for bytes.\"\"\"\n\n    def __init__(\n        self,\n        d: dict = None,\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            d: Initial configuration.\n        \"\"\"\n        self.d = {}\n        if d != None:\n            self.d.update(d)\n\n    def __delitem__(\n        self,\n        k: Any,\n    ):\n        del self.d[k]\n\n    def __getitem__(self, k):\n        return self.d[k]\n\n    def __iter__(self):\n        return iter(self.d.keys())\n\n    def __len__(self):\n        return len(self.d)\n\n    def __repr__(self):\n        # this can be expensive for big payloads\n        s = str(self.d)\n        if len(s) > 256:\n            s = s[:253] + \"...\"\n        return f\"<{self.__class__.__name__} ({s})>\"\n\n    def __setitem__(self, k, v):\n        self.d[k] = v\n\n    @staticmethod\n    def decode(b: bytes) -> str:\n        \"\"\"Decode bytes with support for local decodings.\n\n        Args:\n            b: Bytes to decode.\n\n        Returns:\n            JSON string.\n        \"\"\"\n        return json.loads(b.decode(\"utf-8\"), object_hook=json_decoder_object_hook)\n\n    def dict(\n        self,\n        clean: bool = False,\n    ) -> Dict:\n        \"\"\"Return a copy as a dict. Optionally clean of \"private\"\n        top-level items (keys start with \"-\").\n\n        Args:\n            clean: Remove keys starting with \"-\".\n\n        Returns:\n            Dictionary.\n        \"\"\"\n        d = copy.deepcopy(self.d)\n        if clean:\n            for k in list(d.keys()):\n                if k.startswith(\"-\"):\n                    del d[k]\n        return d\n\n    def dumps(\n        self,\n        indent: Union[int, None] = None,\n        sort_keys: Union[bool, None] = None,\n    ) -> str:\n        \"\"\"Dump contents as a stringified dict.\n\n        Args:\n            indent: Indent size.\n            sort_keys: Sort keys.\n\n        Returns:\n            Stringified dictionary.\n        \"\"\"\n        # TODO: not reall a stringified dict. drop in favor of json()?\n        kwargs = {}\n        if indent != None:\n            kwargs[\"indent\"] = indent\n        if sort_keys != None:\n            kwargs[\"sort_keys\"] = sort_keys\n        return json.dumps(self.d, **kwargs)\n\n    def encode(self) -> str:\n        \"\"\"Encode items and return JSON string.\n\n        Returns:\n            JSON string.\n        \"\"\"\n        return json.dumps(self.d, cls=JSONEncoder).encode(\"utf-8\")\n\n    def json(\n        self,\n        indent: Union[int, None] = 2,\n        clean: bool = False,\n    ) -> str:\n        \"\"\"Return JSON string.\n\n        Args:\n            indent: Indent size.\n            clean: Remove for keys starting with \"-\".\n\n        Returns:\n            JSON string.\n        \"\"\"\n        d = self.dict(clean)\n        return json.dumps(d, indent=indent)\n\n    def yaml(\n        self,\n        clean: bool = False,\n    ) -> str:\n        \"\"\"Return YAML.\n\n        Args:\n            clean: Remove for keys starting with \"-\".\n\n        Returns:\n            YAML.\n        \"\"\"\n        d = self.dict(clean)\n        return yaml.dump(d)", "\n\nclass Header(MessagePart):\n    \"\"\"Header.\"\"\"\n\n    def __init__(self, d=None):\n        \"\"\"Initialize.\n\n        See [penvm.lib.message.MessagePart][].\n        \"\"\"\n        super().__init__(d)\n        # for new only\n        if \"id\" not in self:\n            self[\"id\"] = get_uuid()", "\n\nclass Payload(MessagePart):\n    \"\"\"Payload.\"\"\"\n\n    def __init__(self, d=None):\n        \"\"\"Initialize.\n\n        See [penvm.lib.message.MessagePart][].\n        \"\"\"\n        super().__init__(d)\n        # for new only\n        if \"-id\" not in self:\n            self[\"-id\"] = get_uuid()", "\n\nclass Message:\n    \"\"\"Object consisting of header and payload objects.\n\n    The header and payload objects are `MessagePart` objects.\n\n    All parts have a `-id` setting unique to the object.\n\n    Message payloads take special fields with `-` prefix:\n\n    * `-type` - Message type (e.g., request, response)\n    * `-status` - Status (e.g., ok, error)\n    * `-message` - Status message, usually for \"error\" status.\n    \"\"\"\n\n    def __init__(\n        self,\n        header: Union[Header, None] = None,\n        payload: Union[Payload, None] = None,\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            header: Header object.\n            payload: Payload object.\n        \"\"\"\n        self.header = header or Header()\n        self.payload = payload or Payload()\n\n    def __repr__(self):\n        return f\"<{self.__class__.__name__} header ({self.header}) payload ({self.payload})>\"\n\n    @staticmethod\n    def decode(b):\n        \"\"\"Decode bytes according to Message format.\n\n        Bytes as:\n\n        * header[HEADER_SZ_LEN] -> sz (encoded as plain text number)\n        * header[HEADER_SZ_LEN:HEADER_SZ_LEN+sz] -> bytes\n        * payload[PAYLOAD_SZ_LEN] -> sz (encoded as plain text number)\n        * payload[PAYLOAD_SZ_LEN:PAYLOAD_SZ_LEN+sz] -> bytes\n\n        See [penvm.lib.message.MessagePart][].\n        \"\"\"\n        hsz = int(b[:HEADER_SZ_LEN])\n        t0 = time.time()\n        h = Header(Header.decode(b[HEADER_SZ_LEN : HEADER_SZ_LEN + hsz]))\n        t1 = time.time()\n        h[\"-decode-elapsed\"] = t1 - t0\n\n        t0 = time.time()\n        pb = b[HEADER_SZ_LEN + hsz :]\n        psz = int(pb[:PAYLOAD_SZ_LEN])\n        p = Payload(Payload.decode(pb[PAYLOAD_SZ_LEN : PAYLOAD_SZ_LEN + psz]))\n        t1 = time.time()\n        p[\"-decode-elapsed\"] = t1 - t0\n\n        return h, p\n\n    def encode(self):\n        \"\"\"Encode.\"\"\"\n        h = self.header.encode()\n        p = self.payload.encode()\n        return (HEADER_SZ_FMT % len(h)) + h + (PAYLOAD_SZ_FMT % len(p)) + p\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            return State(\n                \"message\",\n                self.header.get(\"id\"),\n                {\n                    \"header\": self.header.dict(),\n                    \"payload\": self.payload.dict(),\n                },\n            )\n        except Exception as e:\n            logger.warning(f\"EXCEPTION ({e})\")", "\n\n#\n# conveniences\n#\n\n\ndef Request(*args, **kwargs):\n    \"\"\"Return a request message.\n\n    See [penvm.lib.message.Message][].\n    \"\"\"\n    msg = Message(*args, **kwargs)\n    msg.payload[\"-type\"] = \"request\"\n    return msg", "\n\ndef Response(*args, **kwargs):\n    \"\"\"Return a response message.\n\n    See [penvm.lib.message.Message][].\n    \"\"\"\n    refmsg = kwargs.pop(\"refmsg\", None)\n    msg = Message(*args, **kwargs)\n    if refmsg:\n        msg.header[\"ref-id\"] = refmsg.header.get(\"id\")\n    msg.payload[\"-type\"] = \"response\"\n    return msg", "\n\ndef ErrorResponse(message, *args, **kwargs):\n    \"\"\"Return an error response message.\n\n    See [penvm.lib.message.Message][].\n    \"\"\"\n    msg = Response(*args, **kwargs)\n    msg.payload.update(\n        {\n            \"-status\": \"error\",\n            \"-message\": message,\n        }\n    )\n    return msg", "\n\ndef OkResponse(*args, **kwargs):\n    \"\"\"Return an ok response message.\n\n    See [penvm.lib.message.Message][].\n    \"\"\"\n    msg = Response(*args, **kwargs)\n    msg.payload[\"-status\"] = \"ok\"\n    return msg", ""]}
{"filename": "src/lib/penvm/lib/queue.py", "chunked_list": ["#\n# penvm/lib/queue.py\n#\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport queue\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\n\nclass QueueEmpty:\n    pass", "class QueueEmpty:\n    pass\n\n\nclass Queue:\n    \"\"\"Implementation allowing for inspection and peeking.\n\n    Built on top of [queue.Queue][].\n    \"\"\"\n\n    def __init__(\n        self,\n        qsize: int = 0,\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            qsize: Maximum queue size. 0 for unlimited.\n        \"\"\"\n        self.frozen = False\n        # TODO: support sizing of queue\n        self.qsize = qsize = 10\n        self._queue = queue.Queue(qsize)\n        self._tmp = QueueEmpty\n        self.npop = 0\n        self.nput = 0\n\n    def clear(self):\n        \"\"\"Clear all queued objects.\"\"\"\n        try:\n            while True:\n                self._queue.get(block=False)\n        except queue.Empty as e:\n            pass\n        except Exception:\n            pass\n\n    def freeze(\n        self,\n        state: bool,\n    ):\n        \"\"\"Allow/disallow additions.\n\n        Args:\n            state: New state of queue.\n        \"\"\"\n        self.frozen = state\n\n    def get(self) -> Any:\n        \"\"\"Get copy of object from queue.\n\n        Returns:\n            Item.\n        \"\"\"\n        # TODO: needs some work?\n        if self._queue.qsize():\n            return self._queue.queue[0].copy()\n        return QueueEmpty\n\n    def pop(\n        self,\n        block: bool = True,\n    ) -> Any:\n        \"\"\"Pop object from queue.\n\n        Args:\n            block: Wait for object.\n\n        Returns:\n            Item.\n        \"\"\"\n        try:\n            v = self._queue.get(block=block)\n            self.npop += 1\n            # TODO: what to return if not blocking and no value? None!\n        except queue.Empty as e:\n            v = None\n        return v\n\n    def put(self, o: Any):\n        \"\"\"Put object on queue.\n\n        Args:\n            o: Object.\n        \"\"\"\n        if not self.frozen:\n            self.nput += 1\n            self._queue.put(o)\n        # TODO: raise exception if frozen\n\n    def size(self) -> int:\n        \"\"\"Return queue size.\n\n        Returns:\n            Queue size.\n        \"\"\"\n        return self._queue.qsize()\n\n    def values(self) -> List[Any]:\n        \"\"\"Return (actual) queued values.\n\n        Returns:\n            Queue values.\n        \"\"\"\n        return [v for v in self._queue.queue]", "\n\nclass RoutingQueue(Queue):\n    \"\"\"Route queue operations elsewhere.\n\n    Three functions are registered to handle the different kinds of\n    queueing (and this routing) operations.\n    \"\"\"\n\n    def __init__(\n        self,\n        get: Union[Callable, None] = None,\n        pop: Union[Callable, None] = None,\n        put: Union[Callable, None] = None,\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            get: Function to call for `get`.\n            pop: Function to call for `pop`.\n            put: Function to call for `put`.\n        \"\"\"\n        super().__init__()\n        self._get = get\n        self._pop = pop\n        self._put = put\n\n    def get(self) -> Union[Any, None]:\n        \"\"\"Get a copy of an object.\n\n        Returns:\n            Copy of an object.\n        \"\"\"\n        return None if self._get == None else self._get()\n\n    def pop(\n        self,\n        block: bool = True,\n    ) -> Union[Any, None]:\n        \"\"\"Pop an object.\n\n        Returns:\n            An object.\n        \"\"\"\n        return None if self._pop == None else self._pop(block)\n\n    def put(\n        self,\n        o: Any,\n    ):\n        \"\"\"Put an object.\n\n        Args:\n            o: Object to queue/route.\n        \"\"\"\n        self._put(o)\n\n    def size(self) -> int:\n        \"\"\"Queue size is always 0.\n\n        Returns:\n            0\n        \"\"\"\n        return 0\n\n    def values(self) -> List:\n        \"\"\"Never any values on queue.\n\n        Returns:\n            Empty list.\"\"\"\n        return []", ""]}
{"filename": "src/lib/penvm/lib/misc.py", "chunked_list": ["#\n# penvm/lib/misc.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Collection of miscellaneous code.\n\"\"\"\n\n# import secrets\nimport logging\nfrom logging import LoggerAdapter as _LoggerAdapter\nfrom threading import Lock", "from logging import LoggerAdapter as _LoggerAdapter\nfrom threading import Lock\nimport time\nimport traceback\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom uuid import uuid1\n\nlogger = logging.getLogger(__name__)\n", "logger = logging.getLogger(__name__)\n\nVERSION = (0, 1, 0)\n\n\nclass LogMark:\n    \"\"\"Provides unique id and time information: t0 (start time) and\n    tlast (lap time).\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize.\"\"\"\n        self.t0 = time.time()\n        self.tlast = self.t0\n        self.uuid = get_log_uuid()\n\n    def elapsed(self) -> float:\n        \"\"\"Return elapsed time since object initialize.\n\n        Returns:\n            Elapsed time in seconds.\n        \"\"\"\n        t1 = time.time()\n        return t1, t1 - self.t0\n\n    def lap(self) -> Tuple[float, float, float]:\n        \"\"\"Return triple (now, elasped since init, elapsed since last lap).\n\n        Returns:\n            Tuple of (not, elapsed since init, elapsed since lap) in\n            seconds.\n        \"\"\"\n        tnow = time.time()\n        tlast = self.tlast\n        self.tlast = tnow\n        return tnow, tnow - self.t0, tnow - tlast\n\n    def reset(self):\n        \"\"\"Reset the \"init\" time.\"\"\"\n        self.t0 = time.time()", "\n\nclass LoggerAdapter(_LoggerAdapter):\n    \"\"\"Log adapter which provides \"owner\" information as a prefix in\n    the log entry.\n    \"\"\"\n\n    def __init__(\n        self,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"Initialize.\"\"\"\n        super().__init__(*args, **kwargs)\n\n        o = self.extra.get(\"self\")\n        if o != None:\n            classname = o.__class__.__name__\n            idval = self.extra.get(\"id\", \"-\")\n            self.extra[\"prefix\"] = f\"\"\"{classname}[{idval}]\"\"\"\n        else:\n            self.extra[\"prefix\"] = self.extra.get(\"prefix\", \"\")\n\n    def process(\n        self,\n        msg: str,\n        kwargs: dict,\n    ) -> str:\n        \"\"\"Return processed log message.\n\n        Args:\n            msg: Message format string.\n            kwargs: Dictionary containers items for populating `msg.\n\n        Return:\n            Processed message format string.\n        \"\"\"\n        return \"%s: %s\" % (self.extra.get(\"prefix\"), msg), kwargs\n\n    def enter(\n        self,\n        *args: List,\n        **kwargs: Dict,\n    ) -> \"TaggedLoggerAdapter\":\n        \"\"\"Set up a TaggedLoggerAdapter, call enter(), return new\n        adapter.\n\n        Args:\n            args: Log message args.\n            kwargs: Log message kwargs.\n\n        Returns:\n            TaggedLoggerAdapter.\n        \"\"\"\n        tlogger = TaggedLoggerAdapter(self, stacklevel=4)\n        tlogger.enter(*args, stacklevel=5, **kwargs)\n        return tlogger", "\n\nclass MachineConnectionSpec:\n    \"\"\"Machine connection spec.\n\n    Information required to establish a connection to a machine.\n    \"\"\"\n\n    def __init__(\n        self,\n        machconnstr: Union[str, None] = None,\n        config: Union[dict, None] = None,\n        machine: Union[\"Machine\", None] = None,\n    ):\n        \"\"\"\n        Initialize.\n\n        One of the arguments is used to configure.\n\n        Args:\n            machconnstr: Machine connection string: colon-separated\n                string consisting of machine id, ssl profile, host,\n                port.\n            config: Dictionary of machine configuration settings.\n            machine: Machine object.\n        \"\"\"\n        if machconnstr != None:\n            self.machid, self.sslprofile, self.host, self.port = machconnstr.split(\":\", 3)\n            if self.sslprofile == \"\":\n                self.sslprofile = None\n            self.port = int(self.port)\n        elif config != None:\n            self.machid = config.get(\"machine-id\")\n            self.sslprofile = config.get(\"ssl-profile\")\n            self.host = config.get(\"host\")\n            self.port = config.get(\"port\")\n        elif machine != None:\n            self.machid = machine.oid\n            self.sslprofile = machine.sslprofile\n            self.host = machine.conn.host\n            self.port = machine.conn.port\n        else:\n            raise Exception(\"cannot set up MachineConnectionSpec\")\n\n    def __str__(self):\n        return f\"{self.machid}:{self.sslprofile or ''}:{self.host}:{self.port}\"", "\n\nclass State(dict):\n    \"\"\"Object state.\n\n    Holds object identifying information and a dictionary containing\n    relevant object state.\n    \"\"\"\n\n    def __init__(self, otype: str, oid: str, state: dict):\n        \"\"\"Initialize.\n\n        Args:\n            otype: Object type string.\n            oid: Object id string.\n            state: State information.\n        \"\"\"\n        super().__init__()\n        self.update(\n            {\n                \"timestamp\": get_timestamp(),\n                \"object\": {\n                    \"type\": otype,\n                    \"id\": oid,\n                },\n                \"state\": state,\n            }\n        )", "\n\nclass TaggedLoggerAdapter(_LoggerAdapter):\n    \"\"\"Logger adapter which tags each log entry with a unique id to\n    allow for tracking. Also provides a means to track timing\n    performance.\n\n    Also provides special methods for local (e.g., function/method)\n    logger: enter, exit, elapsed, lap.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize.\"\"\"\n        self.stacklevel = kwargs.pop(\"stacklevel\", 4)\n        super().__init__(*args, **kwargs)\n        self.default_level = logging.DEBUG\n        self.mark = LogMark()\n\n    def critical(self, msg, *args, **kwargs):\n        \"\"\"Make a \"critical\" log entry.\"\"\"\n        _msg = f\"[{self.mark.uuid}] {msg}\"\n        self.log(logging.CRITICAL, _msg, *args, stacklevel=self.stacklevel, **kwargs)\n\n    def debug(self, msg, *args, **kwargs):\n        \"\"\"Make a \"debug\" log entry.\"\"\"\n        _msg = f\"[{self.mark.uuid}] {msg}\"\n        self.log(logging.DEBUG, _msg, *args, stacklevel=self.stacklevel, **kwargs)\n\n    def elapsed(\n        self,\n        msg: Union[str, None] = None,\n    ):\n        \"\"\"Make a log entry with special format string containing:\n        \"ELAPSED\", a tag, time, and elapsed time (from start).\n\n        Args:\n            msg: Additional message to log.\n        \"\"\"\n        t1, elapsed = self.mark.elapsed()\n        _msg = f\"ELAPSED [{self.mark.uuid}, {t1:.5f}, {elapsed:.5f}]\"\n        if msg:\n            _msg = f\"{_msg} {msg}\"\n        self.log(self.default_level, _msg, stacklevel=self.stacklevel)\n\n    def enter(\n        self,\n        msg: Union[str, None] = None,\n        stacklevel: Union[int, None] = None,\n    ):\n        \"\"\"Make a log entry with special format string containing:\n        \"ENTER\", tag, and time.\n\n        Args:\n            msg: Additional message to log.\n            stacklevel: Stack level to extract information from.\n        \"\"\"\n        _msg = f\"ENTER [{self.mark.uuid}, {self.mark.t0:.5f}]\"\n        if msg:\n            _msg = f\"{_msg} {msg}\"\n        stacklevel = stacklevel if stacklevel != None else self.stacklevel\n        self.log(self.default_level, _msg, stacklevel=stacklevel)\n        return self\n\n    def error(self, msg, *args, **kwargs):\n        \"\"\"Mark an \"error\" log entry.\"\"\"\n        _msg = f\"[{self.mark.uuid}] {msg}\"\n        self.log(logging.ERROR, _msg, *args, stacklevel=self.stacklevel, **kwargs)\n\n    def exit(\n        self,\n        msg: Union[str, None] = None,\n    ):\n        \"\"\"Make a log entry with special format string containing:\n        \"EXIT\", tag, time, and elapsed (from start).\n\n        Args:\n            msg: Additional message to log.\n        \"\"\"\n        t1, elapsed = self.mark.elapsed()\n        _msg = f\"EXIT [{self.mark.uuid}, {t1:.5f}, {elapsed:.5f}]\"\n        if msg:\n            _msg = f\"{_msg} {msg}\"\n        self.log(self.default_level, _msg, stacklevel=self.stacklevel)\n\n    def state(\n        self,\n        msg,\n        *args: List,\n        **kwargs: Dict,\n    ):\n        _msg = f\"[{self.mark.uuid}] {msg}\"\n        self.log(logging.INFO, _msg, *args, stacklevel=self.stacklevel, **kwargs)\n\n    def lap(\n        self,\n        msg: Union[str, None] = None,\n    ):\n        \"\"\"Make a log entry with special format string containing:\n        \"LAP\", tag, time, and elapsed from split, and from lap split.\n\n        Args:\n            msg: Additional message to log.\n        \"\"\"\n        t1, elapsed, lap = self.mark.lap()\n        _msg = f\"LAP [{self.mark.uuid}, {t1:.5f}, {elapsed:.5f}, {lap:.5f}]\"\n        if msg:\n            _msg = f\"{_msg} {msg}\"\n        self.log(self.default_level, _msg, stacklevel=self.stacklevel)\n\n    def warning(self, msg, *args, **kwargs):\n        \"\"\"Make a \"warning\" log entry.\"\"\"\n        _msg = f\"[{self.mark.uuid}] {msg}\"\n        self.log(logging.WARNING, _msg, *args, stacklevel=self.stacklevel, **kwargs)", "\n\n# variables for logging\n_log_counter = int(time.time() * 100)\n_log_counter_lock = Lock()\n\n\ndef get_log_uuid() -> str:\n    \"\"\"Return UUID for logging.\n\n    Returns:\n        UUID string value.\n    \"\"\"\n    global _log_counter, _log_counter_lock\n    with _log_counter_lock:\n        _log_counter += 1\n        return \"%x\" % _log_counter", "\n\ndef get_log_uuid1() -> str:\n    \"\"\"Return UUID1 log logging.\n\n    Returns:\n        UUID1 string value.\n    \"\"\"\n    return str(uuid1())\n", "\n\ndef get_log_mark() -> Tuple[float, str]:\n    \"\"\"Get log mark of (now, uuid).\"\"\"\n    return (time.time(), get_log_uuid())\n\n\ndef get_timestamp() -> str:\n    \"\"\"Get timestamp as string.\"\"\"\n    return str(time.time())", "\n\n_counter = int(time.time() * 100)\n_counter_lock = Lock()\n\n\ndef get_uuid() -> str:\n    \"\"\"Alternate `get_uuid` implementation.\"\"\"\n    global _counter, _counter_lock\n    with _counter_lock:\n        _counter += 1\n        return \"%x\" % _counter", "\n\ndef get_uuid1() -> str:\n    \"\"\"Get UUID1 value.\n\n    Returns:\n        UUID1 string value.\n    \"\"\"\n    # return uuid1().hex\n    return str(uuid1())", "    # return secrets.token_urlsafe()\n\n\ndef get_version() -> Tuple:\n    \"\"\"Return PENVM version tuple.\n\n    Returns:\n        Version tuple.\"\"\"\n    return VERSION\n", "\n\ndef get_version_string() -> str:\n    \"\"\"Return PENVM version as a string.\n\n    Returns:\n        Version string.\n    \"\"\"\n    return \"%s.%s.%s\" % VERSION\n", ""]}
{"filename": "src/lib/penvm/lib/mqueue.py", "chunked_list": ["#\n# penvm/lib/mqueue.py\n#\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\n\nfrom penvm.lib.base import BaseObject\nfrom penvm.lib.message import Message", "from penvm.lib.base import BaseObject\nfrom penvm.lib.message import Message\nfrom penvm.lib.misc import State, get_uuid\nfrom penvm.lib.queue import Queue\n\nlogger = logging.getLogger(__name__)\n\n\nclass MessageQueue(BaseObject, Queue):\n    \"\"\"Message queue.\n\n    Built on top of [penvm.lib.queue.Queue][].\n    \"\"\"\n\n    def __init__(self, qsize: int = 0):\n        \"\"\"Initialize.\n\n        Args:\n            qsize: Maximum queue size. 0 for unlimited.\n        \"\"\"\n        BaseObject.__init__(self, None, logger)\n        Queue.__init__(self, qsize)\n\n    def find(\n        self,\n        id: str,\n    ) -> \"Message\":\n        \"\"\"Find and return message in queue with given header id.\n\n        Args:\n            id: Message header id.\n\n        Returns:\n            Matching Message.\n        \"\"\"\n        for v in self.values():\n            if v.header.get(\"id\") == id:\n                return v\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            values = []\n            for v in self.values():\n                if type(v) == Message:\n                    values.append(v.state())\n                else:\n                    values.append(None)\n            return State(\n                \"mqueue\",\n                self.oid,\n                {\n                    \"frozen\": self.frozen,\n                    \"npop\": self.npop,\n                    \"nput\": self.nput,\n                    \"size\": self.qsize,\n                    \"values\": values,\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")", "class MessageQueue(BaseObject, Queue):\n    \"\"\"Message queue.\n\n    Built on top of [penvm.lib.queue.Queue][].\n    \"\"\"\n\n    def __init__(self, qsize: int = 0):\n        \"\"\"Initialize.\n\n        Args:\n            qsize: Maximum queue size. 0 for unlimited.\n        \"\"\"\n        BaseObject.__init__(self, None, logger)\n        Queue.__init__(self, qsize)\n\n    def find(\n        self,\n        id: str,\n    ) -> \"Message\":\n        \"\"\"Find and return message in queue with given header id.\n\n        Args:\n            id: Message header id.\n\n        Returns:\n            Matching Message.\n        \"\"\"\n        for v in self.values():\n            if v.header.get(\"id\") == id:\n                return v\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            values = []\n            for v in self.values():\n                if type(v) == Message:\n                    values.append(v.state())\n                else:\n                    values.append(None)\n            return State(\n                \"mqueue\",\n                self.oid,\n                {\n                    \"frozen\": self.frozen,\n                    \"npop\": self.npop,\n                    \"nput\": self.nput,\n                    \"size\": self.qsize,\n                    \"values\": values,\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")", ""]}
{"filename": "src/lib/penvm/lib/connectionmanager.py", "chunked_list": ["#\n# penvm/lib/connectionmanager.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\nimport socket\nimport threading\nimport traceback\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.lib.base import BaseObject", "\nfrom penvm.lib.base import BaseObject\nfrom penvm.lib.connection import Listener\nfrom penvm.lib.misc import State\n\nlogger = logging.getLogger(__name__)\n\n\nclass ConnectionManager(BaseObject):\n    \"\"\"Manage connections set up by Listener.\n\n    * Listen for new connections (running in a thread).\n    * Spawn accepted connections (`Connection` runs its own threads).\n    \"\"\"\n\n    def __init__(\n        self,\n        machine: \"Machine\",\n        host: str,\n        port: int,\n        sslcontext: Union[\"ssl.SSLContext\", None] = None,\n    ):\n        \"\"\"Set up.\n\n        Args:\n            machine: Machine owning this manager.\n            host: Host address to listen on. 0.0.0.0 for all\n                interfaces.\n            port: Port to listen on. 0 for auto assign.\n            sslcontext: SSL context for SSL encrypted connections.\n        \"\"\"\n        try:\n            super().__init__(None, logger)\n            tlogger = self.logger.enter()\n\n            self.machine = machine\n            self.host = host\n            self.port = port\n            self.sslcontext = sslcontext\n\n            self.conns = {}\n            self.exit = False\n            self.listener = Listener(self.machine, host, port, sslcontext)\n            # TODO: should listen() be called here?\n            self.listener.listen(100)\n            self.ltimeout = 30\n            self.th = None\n            self.init_conn = None\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def drop(\n        self,\n        connectionid: str,\n    ):\n        \"\"\"Drop connection by connection id.\n\n        Args:\n            connectionid: Connection id.\n        \"\"\"\n        self.logger.debug(f\"DROPPED connection {connectionid=} {self.conns.get(connectionid)=}\")\n        self.conns.pop(connectionid)\n\n    def get(\n        self,\n        connectionid: str,\n    ) -> \"Connection\":\n        \"\"\"Get connection by connection id.\n\n        Args:\n            connectionid: Connection id.\n\n        Returns:\n            Connection for connection id.\n        \"\"\"\n        return self.conns.get(connectionid)\n\n    def list(self) -> List[str]:\n        \"\"\"Get list of connection ids.\n\n        Returns:\n            Connection ids.\n        \"\"\"\n        return list(self.conns.keys())\n\n    def run(self):\n        \"\"\"Run.\n\n        Listen for connections and add.\n\n        The initial connection must occur within a short amount of\n        time (first-wait) and remain up for the lifetime of the\n        machine. Once the initial connection drops, all others are\n        dropped and the machine will end up shutting down.\n        \"\"\"\n\n        try:\n            tlogger = self.logger.enter()\n\n            CHECK_TIMEOUT = 10.125\n            CHECK_TIMEOUT = 120.125\n            CHECK_TIMEOUT = 10000000\n\n            try:\n                # initial/firstwait timeout\n                self.listener.settimeout(self.ltimeout)\n                while not self.exit:\n                    try:\n                        tlogger.debug(\n                            f\"listening for connection {self.listener.lhost=} {self.listener.lport=} ...\"\n                        )\n                        conn = self.listener.accept()\n                        tlogger.debug(f\"accepted connection {conn=}\")\n\n                        if self.init_conn == None:\n                            # set to shutdown on connection close/fail of initial connection\n                            self.init_conn = conn\n                            conn.onclose = self.shutdown\n                        else:\n                            # TODO: should be part of accept step?\n                            conn.onclose = self.drop\n\n                        self.conns[conn.oid] = conn\n                        conn.start()\n\n                        # non-initial/post-firstwait update to timeout\n                        if self.ltimeout >= 0 and self.ltimeout != CHECK_TIMEOUT:\n                            tlogger.debug(\"non-intial timeout\")\n                            self.ltimeout = CHECK_TIMEOUT\n                            self.listener.settimeout(self.ltimeout)\n                    except (socket.timeout, TimeoutError):\n                        # periodic wakeup\n                        self.logger.debug(f\"listener timed out after {self.ltimeout}\")\n\n                        if len(self.conns) == 0 and self.ltimeout == CHECK_TIMEOUT:\n                            # cleanup opportunity\n                            break\n\n                        # setup check timeout if not already in place\n                        if self.ltimeout != CHECK_TIMEOUT:\n                            self.ltimeout = CHECK_TIMEOUT\n                            self.listener.settimeout(self.ltimeout)\n                    except Exception as e:\n                        self.logger.debug(f\"EXCEPTION ({e})\")\n            finally:\n                # cleanup\n                for conn in self.conns.values():\n                    conn.close()\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def shutdown(\n        self,\n        connectionid: str,\n    ):\n        \"\"\"Force termination.\n\n        Intended to be called by `Connection.onclose` instead of\n        `ConnectionManager.drop()` when the initial connection\n        (`init_conn`) is closed.\n\n        Args:\n            connectionid: Connection id.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n            self.machine.shutdown(now=True)\n            # should not reach here!\n        finally:\n            tlogger.exit()\n\n    def start(self):\n        \"\"\"Start.\n\n        Background thread to handle connections.\"\"\"\n        try:\n            self.logger.debug(\"starting ...\")\n\n            if not self.th:\n                try:\n                    self.th = threading.Thread(target=self.run)\n                    self.th.daemon = True\n                    self.th.start()\n                except Exception as e:\n                    self.logger.critical(f\"failed to start ({e}\")\n                    self.th = None\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            return State(\n                \"connection-manager\",\n                None,\n                {\n                    \"connection-ids\": self.list(),\n                    \"nconnections\": len(self.conns),\n                    \"listener\": {\n                        \"timeout\": self.ltimeout,\n                        \"addr\": self.listener.lhost,\n                        \"port\": self.listener.lport,\n                    },\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")", "class ConnectionManager(BaseObject):\n    \"\"\"Manage connections set up by Listener.\n\n    * Listen for new connections (running in a thread).\n    * Spawn accepted connections (`Connection` runs its own threads).\n    \"\"\"\n\n    def __init__(\n        self,\n        machine: \"Machine\",\n        host: str,\n        port: int,\n        sslcontext: Union[\"ssl.SSLContext\", None] = None,\n    ):\n        \"\"\"Set up.\n\n        Args:\n            machine: Machine owning this manager.\n            host: Host address to listen on. 0.0.0.0 for all\n                interfaces.\n            port: Port to listen on. 0 for auto assign.\n            sslcontext: SSL context for SSL encrypted connections.\n        \"\"\"\n        try:\n            super().__init__(None, logger)\n            tlogger = self.logger.enter()\n\n            self.machine = machine\n            self.host = host\n            self.port = port\n            self.sslcontext = sslcontext\n\n            self.conns = {}\n            self.exit = False\n            self.listener = Listener(self.machine, host, port, sslcontext)\n            # TODO: should listen() be called here?\n            self.listener.listen(100)\n            self.ltimeout = 30\n            self.th = None\n            self.init_conn = None\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def drop(\n        self,\n        connectionid: str,\n    ):\n        \"\"\"Drop connection by connection id.\n\n        Args:\n            connectionid: Connection id.\n        \"\"\"\n        self.logger.debug(f\"DROPPED connection {connectionid=} {self.conns.get(connectionid)=}\")\n        self.conns.pop(connectionid)\n\n    def get(\n        self,\n        connectionid: str,\n    ) -> \"Connection\":\n        \"\"\"Get connection by connection id.\n\n        Args:\n            connectionid: Connection id.\n\n        Returns:\n            Connection for connection id.\n        \"\"\"\n        return self.conns.get(connectionid)\n\n    def list(self) -> List[str]:\n        \"\"\"Get list of connection ids.\n\n        Returns:\n            Connection ids.\n        \"\"\"\n        return list(self.conns.keys())\n\n    def run(self):\n        \"\"\"Run.\n\n        Listen for connections and add.\n\n        The initial connection must occur within a short amount of\n        time (first-wait) and remain up for the lifetime of the\n        machine. Once the initial connection drops, all others are\n        dropped and the machine will end up shutting down.\n        \"\"\"\n\n        try:\n            tlogger = self.logger.enter()\n\n            CHECK_TIMEOUT = 10.125\n            CHECK_TIMEOUT = 120.125\n            CHECK_TIMEOUT = 10000000\n\n            try:\n                # initial/firstwait timeout\n                self.listener.settimeout(self.ltimeout)\n                while not self.exit:\n                    try:\n                        tlogger.debug(\n                            f\"listening for connection {self.listener.lhost=} {self.listener.lport=} ...\"\n                        )\n                        conn = self.listener.accept()\n                        tlogger.debug(f\"accepted connection {conn=}\")\n\n                        if self.init_conn == None:\n                            # set to shutdown on connection close/fail of initial connection\n                            self.init_conn = conn\n                            conn.onclose = self.shutdown\n                        else:\n                            # TODO: should be part of accept step?\n                            conn.onclose = self.drop\n\n                        self.conns[conn.oid] = conn\n                        conn.start()\n\n                        # non-initial/post-firstwait update to timeout\n                        if self.ltimeout >= 0 and self.ltimeout != CHECK_TIMEOUT:\n                            tlogger.debug(\"non-intial timeout\")\n                            self.ltimeout = CHECK_TIMEOUT\n                            self.listener.settimeout(self.ltimeout)\n                    except (socket.timeout, TimeoutError):\n                        # periodic wakeup\n                        self.logger.debug(f\"listener timed out after {self.ltimeout}\")\n\n                        if len(self.conns) == 0 and self.ltimeout == CHECK_TIMEOUT:\n                            # cleanup opportunity\n                            break\n\n                        # setup check timeout if not already in place\n                        if self.ltimeout != CHECK_TIMEOUT:\n                            self.ltimeout = CHECK_TIMEOUT\n                            self.listener.settimeout(self.ltimeout)\n                    except Exception as e:\n                        self.logger.debug(f\"EXCEPTION ({e})\")\n            finally:\n                # cleanup\n                for conn in self.conns.values():\n                    conn.close()\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def shutdown(\n        self,\n        connectionid: str,\n    ):\n        \"\"\"Force termination.\n\n        Intended to be called by `Connection.onclose` instead of\n        `ConnectionManager.drop()` when the initial connection\n        (`init_conn`) is closed.\n\n        Args:\n            connectionid: Connection id.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n            self.machine.shutdown(now=True)\n            # should not reach here!\n        finally:\n            tlogger.exit()\n\n    def start(self):\n        \"\"\"Start.\n\n        Background thread to handle connections.\"\"\"\n        try:\n            self.logger.debug(\"starting ...\")\n\n            if not self.th:\n                try:\n                    self.th = threading.Thread(target=self.run)\n                    self.th.daemon = True\n                    self.th.start()\n                except Exception as e:\n                    self.logger.critical(f\"failed to start ({e}\")\n                    self.th = None\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            return State(\n                \"connection-manager\",\n                None,\n                {\n                    \"connection-ids\": self.list(),\n                    \"nconnections\": len(self.conns),\n                    \"listener\": {\n                        \"timeout\": self.ltimeout,\n                        \"addr\": self.listener.lhost,\n                        \"port\": self.listener.lport,\n                    },\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")", ""]}
{"filename": "src/lib/penvm/lib/debug.py", "chunked_list": ["#\n# penvm/lib/debug.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Debugging tools.\"\"\"\n\nfrom threading import Lock\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\n\nclass DataDumper:\n    \"\"\"Dumps data to a destination (e.g., file) with support for\n    serialization.\"\"\"\n\n    def __init__(self, path: str):\n        \"\"\"Initialize.\n\n        Args:\n            path: File path to dump data.\n        \"\"\"\n        self.path = path\n        self.lock = Lock()\n        self.f = open(path, \"ab\")\n\n    def __del__(self):\n        try:\n            self.f.close()\n        except:\n            pass\n\n    def writebytes(\n        self,\n        b: bytes,\n        flush: bool = True,\n    ):\n        \"\"\"Write bytes.\n\n        Args:\n            b: Bytes to write\n            flush: Flush stream.\n        \"\"\"\n        try:\n            self.lock.acquire()\n            self.f.write(b)\n            if flush:\n                self.f.flush()\n        except Exception as e:\n            print(f\"EXCEPTION {e}\")\n        finally:\n            self.lock.release()\n\n    def writetext(self, t: str, flush: bool = False):\n        \"\"\"Write text.\n\n        Args:\n            t: String to write.\n            flush: Flush to stream.\n        \"\"\"\n        self.writebytes(t.decode(\"utf-8\"), flush)", "\nclass DataDumper:\n    \"\"\"Dumps data to a destination (e.g., file) with support for\n    serialization.\"\"\"\n\n    def __init__(self, path: str):\n        \"\"\"Initialize.\n\n        Args:\n            path: File path to dump data.\n        \"\"\"\n        self.path = path\n        self.lock = Lock()\n        self.f = open(path, \"ab\")\n\n    def __del__(self):\n        try:\n            self.f.close()\n        except:\n            pass\n\n    def writebytes(\n        self,\n        b: bytes,\n        flush: bool = True,\n    ):\n        \"\"\"Write bytes.\n\n        Args:\n            b: Bytes to write\n            flush: Flush stream.\n        \"\"\"\n        try:\n            self.lock.acquire()\n            self.f.write(b)\n            if flush:\n                self.f.flush()\n        except Exception as e:\n            print(f\"EXCEPTION {e}\")\n        finally:\n            self.lock.release()\n\n    def writetext(self, t: str, flush: bool = False):\n        \"\"\"Write text.\n\n        Args:\n            t: String to write.\n            flush: Flush to stream.\n        \"\"\"\n        self.writebytes(t.decode(\"utf-8\"), flush)", ""]}
{"filename": "src/lib/penvm/lib/semaphore.py", "chunked_list": ["#\n# penvm/lib/semaphore.py\n#\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\nfrom threading import Lock\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\n\nlogger = logging.getLogger(__name__)", "\nlogger = logging.getLogger(__name__)\n\n\nclass AdjustableSemaphore:\n    \"\"\"Semaphore with support for adjusting the limit `n` while in\n    use.\"\"\"\n\n    def __init__(\n        self,\n        n: int = 1,\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            n: Count.\n        \"\"\"\n        self._max = n\n\n        self._curr = 0\n\n        self._lock = Lock()\n        self._waitlock = Lock()\n\n    def acquire(self):\n        \"\"\"Acquire a semaphore.\n\n        Increase current count.\n        \"\"\"\n        while True:\n            if self._lock.acquire(blocking=False):\n                if self._curr < self._max:\n                    self._curr += 1\n                    self._lock.release()\n                    return\n                self._lock.release()\n            self._waitlock.acquire()\n\n    def adjust(self, n: int = 1):\n        \"\"\"Adjust count.\n\n        Args:\n            n: New count.\n        \"\"\"\n        self._lock.acquire()\n        n = n if n > 0 else 1\n        self._max = n\n        self._lock.release()\n        # wake up waiter that might *now* acquire a lock\n        try:\n            self._waitlock.release()\n        except:\n            # ignore if already unlocked!\n            pass\n\n    def count(self) -> int:\n        \"\"\"Return current count.\n\n        Returns:\n            Current count.\n        \"\"\"\n        return self._curr\n\n    def max(self) -> int:\n        \"\"\"Return maximum count allowed.\n\n        Returns:\n            Maximum count.\n        \"\"\"\n        return self._max\n\n    def release(self):\n        \"\"\"Release a semaphore.\n\n        Decreases current count.\n        \"\"\"\n        self._lock.acquire()\n        self._curr = max(self._curr - 1, 0)\n        self._lock.release()\n\n        try:\n            # wake up waiters\n            self._waitlock.release()\n        except Exception as e:\n            pass", ""]}
{"filename": "src/lib/penvm/lib/connection.py", "chunked_list": ["#\n# penvm/lib/connection.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Wrappers for low-level connections.\n\"\"\"\n\nimport logging\nimport socket\nimport time\nimport traceback", "import time\nimport traceback\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.lib.base import BaseObject\nfrom penvm.lib.message import Message\nfrom penvm.lib.misc import State\nfrom penvm.lib.mqueue import MessageQueue\nfrom penvm.lib.queue import RoutingQueue\nfrom penvm.lib.thread import Thread", "from penvm.lib.queue import RoutingQueue\nfrom penvm.lib.thread import Thread\n\n\nDEBUG = False\nif DEBUG:\n    import os\n    from penvm.lib.debug import DataDumper\n\n    ddrecv = DataDumper(f\"/tmp/penvm-ddrecv-{os.getpid()}.log\")\n    ddsend = DataDumper(f\"/tmp/penvm-ddsend-{os.getpid()}.log\")", "\nlogger = logging.getLogger(__name__)\n\nHOSTNAME = socket.gethostname()\n\nBLK_SZ_LEN = 8\nBLK_SZ_FMT = b\"%%0.%dd\" % BLK_SZ_LEN\nBLK_SZ_MAX = 100_000_000 - 1\n\nKB = 1024", "\nKB = 1024\nMB = KB * 1024\nGB = MB * 1024\n\n\nclass ConnectionError(Exception):\n    pass\n\n\nclass Listener(BaseObject):\n    \"\"\"Listener side/socket.\"\"\"\n\n    def __init__(\n        self,\n        machine: \"Machine\",\n        host: str,\n        port: int,\n        sslcontext: Union[\"ssl.SSLContext\", None] = None,\n    ):\n        try:\n            super().__init__(None, logger)\n            tlogger = self.logger.enter()\n\n            self.machine = machine\n            self.host = host\n            self.port = port\n            self.sslcontext = sslcontext\n\n            self.lsock = None\n            self.lhost = None\n            self.lport = None\n        finally:\n            tlogger.exit()\n\n    def accept(self):\n        try:\n            tlogger = self.logger.enter()\n            tlogger.debug(\"accepting ...\")\n\n            sock, addr = self.lsock.accept()\n            tlogger.debug(f\"accepted from sock={sock} addr={addr}\")\n\n            if self.sslcontext:\n                # TODO: ensure (failed/slow/non-ssl) ssl negotiation does not block\n                tlogger.debug(f\"setting up ssl {self.sslcontext=}...\")\n                sock = self.sslcontext.wrap_socket(sock, server_side=True)\n                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n                tlogger.debug(f\"ssl socket ({sock=})\")\n\n            tlogger.debug(\"creating ServerConnection ...\")\n\n            return ServerConnection(self.machine, addr[0], addr[1], self.sslcontext, sock)\n        except Exception as e:\n            tlogger.debug(f\"EXCEPTION ({e})\")\n            # allow timeout to percolate up\n            raise\n        finally:\n            tlogger.exit()\n\n    def is_listening(self):\n        return self.lsock != None\n\n    def listen(\n        self,\n        n: int = 1,\n    ):\n        \"\"\"Set up to listen for connection.\n\n        Args:\n            n: Number of outstanding socket connection requests\n                allowed.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            self.lsock = lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            lsock.bind((self.host, self.port))\n            lsock.listen(n)\n            self.lhost, self.lport = lsock.getsockname()\n        finally:\n            tlogger.exit()\n\n    def settimeout(\n        self,\n        delay: int,\n    ):\n        \"\"\"Set timeout.\n\n        Args:\n            delay: Seconds before timing out on idle connection.\n        \"\"\"\n        self.lsock.settimeout(delay)", "\n\nclass Listener(BaseObject):\n    \"\"\"Listener side/socket.\"\"\"\n\n    def __init__(\n        self,\n        machine: \"Machine\",\n        host: str,\n        port: int,\n        sslcontext: Union[\"ssl.SSLContext\", None] = None,\n    ):\n        try:\n            super().__init__(None, logger)\n            tlogger = self.logger.enter()\n\n            self.machine = machine\n            self.host = host\n            self.port = port\n            self.sslcontext = sslcontext\n\n            self.lsock = None\n            self.lhost = None\n            self.lport = None\n        finally:\n            tlogger.exit()\n\n    def accept(self):\n        try:\n            tlogger = self.logger.enter()\n            tlogger.debug(\"accepting ...\")\n\n            sock, addr = self.lsock.accept()\n            tlogger.debug(f\"accepted from sock={sock} addr={addr}\")\n\n            if self.sslcontext:\n                # TODO: ensure (failed/slow/non-ssl) ssl negotiation does not block\n                tlogger.debug(f\"setting up ssl {self.sslcontext=}...\")\n                sock = self.sslcontext.wrap_socket(sock, server_side=True)\n                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n                tlogger.debug(f\"ssl socket ({sock=})\")\n\n            tlogger.debug(\"creating ServerConnection ...\")\n\n            return ServerConnection(self.machine, addr[0], addr[1], self.sslcontext, sock)\n        except Exception as e:\n            tlogger.debug(f\"EXCEPTION ({e})\")\n            # allow timeout to percolate up\n            raise\n        finally:\n            tlogger.exit()\n\n    def is_listening(self):\n        return self.lsock != None\n\n    def listen(\n        self,\n        n: int = 1,\n    ):\n        \"\"\"Set up to listen for connection.\n\n        Args:\n            n: Number of outstanding socket connection requests\n                allowed.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            self.lsock = lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            lsock.bind((self.host, self.port))\n            lsock.listen(n)\n            self.lhost, self.lport = lsock.getsockname()\n        finally:\n            tlogger.exit()\n\n    def settimeout(\n        self,\n        delay: int,\n    ):\n        \"\"\"Set timeout.\n\n        Args:\n            delay: Seconds before timing out on idle connection.\n        \"\"\"\n        self.lsock.settimeout(delay)", "\n\nclass SocketConnection(BaseObject):\n    \"\"\"Socket connection.\n\n    Provides the interface to the socket.\"\"\"\n\n    def __init__(\n        self,\n        host: str,\n        port: int,\n        sslcontext: Union[\"ssl.SSLContext\", None] = None,\n        sock: Union[\"socket.socket\", None] = None,\n    ):\n        \"\"\"Setup.\n\n        Args:\n            host: Host address.\n            port: Port.\n            sslcontext: SSL context used for wrapping a regular socket\n                to provide encryption.\n            sock: Network socket.\n        \"\"\"\n        try:\n            super().__init__(None, logger)\n            tlogger = self.logger.enter()\n\n            self.host = host\n            self.port = port\n            self.sslcontext = sslcontext\n            self.sock = sock\n        finally:\n            tlogger.exit()\n\n    def __repr__(self):\n        return f\"<SocketConnection id={self.oid} host={self.host} port={self.port}>\"\n\n    def connect(self):\n        \"\"\"Connection to server.\"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            try:\n                sock = None\n                for i in range(5):\n                    try:\n                        tlogger.debug(f\"connecting to server ({self.host}) ({self.port}) ...\")\n                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                        if self.sslcontext:\n                            sock = self.sslcontext.wrap_socket(sock, server_side=False)\n                            tlogger.debug(f\"socket ssl wrapped\")\n                        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n\n                        tlogger.debug(f\"connection info host={self.host} port={self.port}\")\n                        sock.connect((self.host, self.port))\n                        break\n                    except socket.error as e:\n                        # TODO: clean up sock if/as needed\n                        tlogger.debug(f\"socket error ({e})\")\n                        time.sleep(2)\n                    except Exception as e:\n                        if i == 5:\n                            raise\n\n                tlogger.debug(\"connected\")\n                self.sock = sock\n            except Exception as e:\n                tlogger.debug(f\"connection failed ({e})\")\n        finally:\n            tlogger.exit()\n\n    def recv(\n        self,\n        sz: int,\n    ) -> bytes:\n        \"\"\"Receive (all) bytes.\n\n        Args:\n            sz: Number of bytes.\n\n        Returns:\n            Bytes received.\n        \"\"\"\n        l = []\n        while sz > 0:\n            b = self.sock.recv(sz)\n            # TODO: handle signal? not needd since v3.5!\n            if len(b) == 0:\n                self.logger.debug(f\"connection closed ({sz=}) ({l=})\")\n                raise Exception(\"connection closed\")\n                break\n            # self.logger.debug(f\"recv {len(b)=}\")\n            l.append(b)\n            sz -= len(b)\n        # TODO: improve this!?!\n        return b\"\".join(l)\n\n    def recvblk(\n        self,\n        blkszlen: int = BLK_SZ_LEN,\n    ) -> bytes:\n        \"\"\"Receive and return a block.\n\n        Args:\n            blkszlen: Maximum receivable block size.\n\n        Returns:\n            Bytes received.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            try:\n                sz = int(self.recv(blkszlen))\n                t0 = time.time()\n                b = self.recv(sz)\n                elapsed = time.time() - t0\n                if DEBUG:\n                    ddrecv.writebytes(b)\n                tlogger.lap(f\"size ({len(b)}) perf ({len(b)/MB/elapsed:.4f} MB/s)\")\n                return b\n\n            except Exception as e:\n                # traceback.print_exc()\n                raise ConnectionError(\"failed to receive block\")\n        finally:\n            tlogger.exit()\n\n    def xsend(\n        self,\n        b: bytes,\n    ):\n        \"\"\"Send all bytes.\"\"\"\n        self.sock.sendall(b)\n\n    def send(\n        self,\n        b: bytes,\n    ):\n        \"\"\"Send bytes.\n\n        Args:\n            b: Bytes to send.\n        \"\"\"\n        total = 0\n        sz = len(b)\n        while total < sz:\n            count = self.sock.send(b)\n            if count == 0:\n                raise Exception(\"send failed\")\n            total += count\n            b = b[count:]\n\n        # print(f\"------------ send ({total=}) ({sz=})\")\n        self.logger.debug(f\"------------ send ({total=}) ({sz=})\")\n        return total\n\n    def sendblk(\n        self,\n        b: bytes,\n        blkszmax: int = BLK_SZ_MAX,\n        blkszfmt: int = BLK_SZ_FMT,\n    ):\n        \"\"\"Send a block (as bytes).\n\n        Size information is sent over the stream before the data.\n\n        Args:\n            b: Bytes to send.\n            blkszmax: Maximum sendable block size.\n            blkszfmt: Block size field format.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n            try:\n                if len(b) > blkszmax:\n                    raise Exception(f\"block exceeds size ({blkszmax})\")\n\n                b = (blkszfmt % len(b)) + b\n                t0 = time.time()\n                self.send(b)\n                elapsed = time.time() - t0\n                if DEBUG:\n                    ddsend.writebytes(b)\n                # print(f\"size ({len(b)}) perf ({len(b)/MB/elapsed:.4f} MB/s)\")\n                tlogger.lap(f\"size ({len(b)}) perf ({len(b)/MB/elapsed:.4f} MB/s)\")\n            except Exception as e:\n                traceback.print_exc()\n                raise ConnectionError(\"failed to send block\")\n        finally:\n            tlogger.exit()\n\n    def close(self):\n        \"\"\"Close connection.\"\"\"\n        self.logger.debug(\"close\")\n        self.sock.close()\n        self.sock = None\n\n    def is_alive(self) -> bool:\n        \"\"\"Indicate if connection is alive or not.\n\n        Returns:\n            Alive status.\n        \"\"\"\n        return True\n\n    def is_connected(self) -> bool:\n        \"\"\"Indicate if connected or not.\n\n        Returns:\n            Connection status.\n        \"\"\"\n        return self.sock != None", "\n\nclass MessageConnection(SocketConnection):\n    \"\"\"Message connection.\n\n    Provides the interface to the socket with support for messages.\n\n    The headers of incoming and outgoing message are all updated with\n    the connection id.\"\"\"\n\n    def __init__(\n        self,\n        host: str,\n        port: int,\n        sslcontext: Union[\"ssl.SSLContext\", None] = None,\n        sock: Union[\"socket.socket\", None] = None,\n    ):\n        \"\"\"Setup.\n\n        Args:\n            host: Host address.\n            port: Port.\n            sslcontext: SSL context used for wrapping a regular\n                socket to provide encryption.\n            sock: Network socket.\n        \"\"\"\n        try:\n            super().__init__(host, port, sslcontext, sock)\n\n            # self.logger already set up\n            tlogger = self.logger.enter()\n        finally:\n            tlogger.exit()\n\n    def __repr__(self):\n        return f\"<MessageConnection id={self.oid} host={self.host} port={self.port}>\"\n\n    def recvmsg(self) -> \"Message\":\n        \"\"\"Receive message and return (as generic Message).\n\n        Returns:\n            Received message.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            b = self.recvblk()\n            t0 = time.time()\n            h, p = Message.decode(b)\n            elapsed = time.time() - t0\n            tlogger.lap(f\"size ({len(b)}) decode time ({elapsed}:.4f)\")\n            # print(f\"size ({len(b)}) decode time ({elapsed}:.4f)\")\n            return Message(h, p)\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n            raise\n        finally:\n            tlogger.exit()\n\n    def sendmsg(\n        self,\n        msg: \"Message\",\n    ):\n        \"\"\"Send message (serialized).\n\n        Args:\n            msg: Message to send.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            t0 = time.time()\n            b = msg.encode()\n            elapsed = time.time() - t0\n            tlogger.lap(f\"size ({len(b)}) encode time ({elapsed}:.4f)\")\n            self.sendblk(b)\n            # print(f\"size ({len(b)}) encode time ({elapsed}:.4f)\")\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n            raise\n        finally:\n            tlogger.exit()", "\n\nclass Connection(MessageConnection):\n    \"\"\"Connection.\n\n    Provides the interface between the network socket and message\n    queues (incoming, outgoing).\n\n    The headers of incoming and outgoing message are all augmented\n    with the connection id.\"\"\"\n\n    def __init__(\n        self,\n        machine: \"Machine\",\n        host: str,\n        port: int,\n        sslcontext: Union[\"ssl.SSLContext\", None] = None,\n        sock: Union[\"socket.socket\", None] = None,\n        onclose: Union[Callable, None] = None,\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            machine: Machine.\n            host: Host address.\n            port: Port.\n            sslcontext: SSL Context.\n            onclose: Function to call to when connection is closed.\n        \"\"\"\n        try:\n            super().__init__(host, port, sslcontext, sock)\n            self.machine = machine\n            self.onclose = onclose\n\n            self.exit = False\n            self.imq = RoutingQueue(put=self.imq_put)\n            self.omq = MessageQueue()\n            self.recvmsgs_th = None\n            self.sendmsgs_th = None\n        finally:\n            pass\n\n    def __repr__(self):\n        return f\"<Connection id={self.oid} machine={self.machine.oid} host={self.host} port={self.port}>\"\n\n    def close(self):\n        \"\"\"Close connection.\"\"\"\n        try:\n            tlogger = self.logger.enter()\n            super().close()\n            self.exit = True\n            tlogger.debug(f\"onclose ({self.onclose})\")\n            if self.onclose:\n                self.onclose(self.oid)\n        except Exception as e:\n            tlogger.debug(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def imq_put(\n        self,\n        msg: \"Message\",\n    ):\n        \"\"\"Put message on IMQ.\n\n        Args:\n            msg: Message to enqueue.\n        \"\"\"\n        self.machine.imq.put(msg)\n\n    def recvmsgs(self):\n        \"\"\"Receive messages over connection.\n\n        Loops while `self.exit` is `True`.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            while not self.exit:\n                try:\n                    tlogger.debug(\"recvmsgs waiting ...\")\n                    msg = self.recvmsg()\n\n                    tlogger.debug(\"recvmsgs message received\")\n                    # patch header with `Connection.oid`\n                    msg.header[\"connection-id\"] = self.oid\n\n                    self.imq.put(msg)\n\n                    tlogger.debug(\"recvmsgs message put\")\n                except Exception as e:\n                    tlogger.debug(f\"EXCEPTION ({e})\")\n                    # raise\n                    # TODO: close/cleanup should be elsewhere\n                    self.close()\n                    break\n        finally:\n            tlogger.exit()\n\n    def sendmsgs(self):\n        \"\"\"Send message over connection.\n\n        Loops while `self.exit` is `True`.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            while not self.exit:\n                try:\n                    tlogger.debug(\"sendmsgs waiting ...\")\n                    msg = self.omq.pop()\n\n                    tlogger.debug(\"sendmsgs popped message\")\n                    msg.header[\"connection-id\"] = self.oid\n                    self.sendmsg(msg)\n\n                    tlogger.debug(\"sendmsgs sent\")\n                except Exception as e:\n                    tlogger.debug(f\"EXCEPTION ({e})\")\n                    self.close()\n                    raise\n                    break\n        finally:\n            tlogger.exit()\n\n    def start(self):\n        \"\"\"Start recv and send message handing.\"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            # TODO: fix to handle ssl situation\n            if self.sock == None:\n                self.connect()\n                # raise Exception(\"no connection!!!\")\n\n            if not self.sendmsgs_th:\n                try:\n                    tlogger.debug(\"starting sendmsgs ...\")\n\n                    self.sendmsgs_th = Thread(target=self.sendmsgs)\n                    self.sendmsgs_th.daemon = True\n                    self.sendmsgs_th.start()\n                except Exception as e:\n                    tlogger.debug(f\"starting sendmsgs EXCEPTION ({e})\")\n                    self.sendmsgs_th = None\n\n            if not self.recvmsgs_th:\n                try:\n                    tlogger.debug(\"starting recvmsgs ...\")\n\n                    self.recvmsgs_th = Thread(target=self.recvmsgs)\n                    self.recvmsgs_th.daemon = True\n                    self.recvmsgs_th.start()\n                except Exception as e:\n                    tlogger.debug(f\"starting recvmsgs EXCEPTION ({e})\")\n                    self.recvmsgs_th = None\n        except Exception as e:\n            tlogger.debug(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            peer = self.sock.getpeername()\n            return State(\n                \"connection\",\n                self.oid,\n                {\n                    \"initial-connection\": self.machine.connmgr.init_conn == self,\n                    \"host\": self.host,\n                    \"port\": self.port,\n                    \"peer-host\": peer[0],\n                    \"peer-port\": peer[1],\n                    \"nimq\": self.imq.size(),\n                    \"nomq\": self.omq.size(),\n                    \"ssl\": self.sslcontext != None,\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")", "\n\nclass ClientConnection(Connection):\n    \"\"\"Client-side message queue connection.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize.\"\"\"\n        try:\n            super().__init__(*args, **kwargs)\n            tlogger = self.logger.enter()\n        finally:\n            tlogger.exit()", "\n\nclass ServerConnection(Connection):\n    \"\"\"Server-side message queue connection.\n\n    Returned by Listener.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize.\"\"\"\n        try:\n            super().__init__(*args, **kwargs)\n            tlogger = self.logger.enter()\n        finally:\n            tlogger.exit()", ""]}
{"filename": "src/server/penvm/server/machine.py", "chunked_list": ["#\n# penvm/server/machine.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\nimport os\nimport socket\nimport sys\nimport threading\nimport time\nimport traceback", "import time\nimport traceback\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.lib.base import BaseObject\nfrom penvm.lib.connectionmanager import ConnectionManager\nfrom penvm.lib.misc import State, get_timestamp, get_uuid1\nfrom penvm.lib.queue import RoutingQueue\nfrom penvm.server.kernelmanager import KernelManager\nfrom penvm.server.sessionmanager import SessionManager", "from penvm.server.kernelmanager import KernelManager\nfrom penvm.server.sessionmanager import SessionManager\n\n# from penvm.server.storage import StorageManager\nfrom penvm.lib.kvstore import FileKVStore\n\nfrom penvm.kernels.core.server import Kernel as CoreKernel\nfrom penvm.kernels.default.server import Kernel as DefaultKernel\n\nlogger = logging.getLogger(__name__)", "\nlogger = logging.getLogger(__name__)\n\n\nclass Machine(BaseObject):\n    \"\"\"Server-side machine.\n\n    Provides access to all \"managers\" (e.g, connection, kernel,\n    session, store), main incoming and outgoing message queues, and\n    state/control to support debug mode.\"\"\"\n\n    def __init__(\n        self,\n        host: str,\n        port: int,\n        sslprofile: Union[str, None] = None,\n        machineid: Union[str, None] = None,\n    ):\n        \"\"\"Set up server-side machine.\n\n        Args:\n            host: Host address.\n            port: Port.\n            sslprofile: SSL profile for SSL context.\n            machineid: Machine id. Generated if not provided.\n        \"\"\"\n        try:\n            super().__init__(machineid, logger)\n            tlogger = self.logger.enter()\n\n            self.sslprofile = sslprofile\n            self.sslcontext = self.get_sslcontext(self.sslprofile)\n\n            self.connmgr = ConnectionManager(self, host, port, self.sslcontext)\n            self.kernelmgr = KernelManager(self)\n            self.sessmgr = SessionManager(self)\n            # self.storemgr = StorageManager(self)\n            self.fkvstore = FileKVStore(f\"/tmp/penvm-store-{self.oid}-{get_uuid1()}\")\n\n            for kernel_cls in [CoreKernel, DefaultKernel]:\n                self.kernelmgr.set(kernel_cls.name, kernel_cls())\n\n            self._background = False\n            self.debug = False\n\n            self.schedlock = threading.Lock()\n            self.imq = RoutingQueue(put=self.imq_put)\n            self.omq = RoutingQueue(put=self.omq_put)\n\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def features(self) -> Dict:\n        \"\"\"Get a dictionary of features.\n\n        Returns:\n            Dictionary of features.\n        \"\"\"\n        try:\n            # languages\n            d = {\n                \"language\": \"python\",\n                \"python\": {\n                    \"platform\": sys.platform,\n                    \"version\": list(sys.version_info),\n                },\n                \"library\": {},\n            }\n\n            # libraries\n            try:\n                import numpy\n\n                d[\"library\"][\"numpy\"] = numpy.version.full_version\n            except:\n                pass\n\n            return d\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n\n    def get_addr_port(self) -> Tuple[str, int]:\n        \"\"\"Get machine listener address and port.\n\n        Returns:\n            Tuple of listener host and port.\n        \"\"\"\n        return (self.connmgr.listener.lhost, self.connmgr.listener.lport)\n\n    def get_session(\n        self,\n        sessionid: str = \"default\",\n    ) -> \"Session\":\n        \"\"\"Get/create session.\n\n        Args:\n            sessionid (str): Session id (optional).\n\n        Returns:\n            Session.\n        \"\"\"\n        # TODO: no default. must be provided by client\n        return self.sessmgr.setdefault(sessionid)\n\n    def get_sslcontext(\n        self,\n        sslprofile: Union[str, None],\n    ) -> Union[\"ssl.SSLContext\", None]:\n        \"\"\"Load server-side SSLContext based on named ssl profile.\n\n        Args:\n            sslprofile: SSL profile name.\n\n        Returns:\n            SSLContext.\n        \"\"\"\n        if sslprofile:\n            try:\n                import ssl\n\n                sslprofile_dir = os.path.expanduser(f\"~/.penvm/ssl/{sslprofile}\")\n                sslcontext = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n                # sslcontext.verify_mode = ssl.CERT_REQUIRED\n                sslcontext.load_cert_chain(\n                    certfile=f\"{sslprofile_dir}/server.crt\",\n                    keyfile=f\"{sslprofile_dir}/server.key\",\n                )\n                return sslcontext\n            except Exception as e:\n                logger.debug(f\"ssl required but missing for ssl profile ({sslprofile})\")\n                raise Exception(f\"ssl required but missing for ssl profile ({sslprofile})\")\n\n    def imq_put(\n        self,\n        msg: \"Message\",\n    ):\n        \"\"\"Triage message and put on proper session incoming message\n        queue.\n\n        Note: This is where incoming requests result in session\n        creation, then request processing!\n\n        Args:\n            msg: Message to enqueue.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            sessionid = msg.header.get(\"session-id\", \"default\")\n            sess = self.sessmgr.setdefault(sessionid)\n            if sess:\n                sess.imq.put(msg)\n            else:\n                # DROP!\n                tlogger.warning(f\"dropped message for session {sessionid}\")\n                pass\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def omq_put(\n        self,\n        msg: \"Message\",\n    ):\n        \"\"\"Triage message and put on proper connection outgoing\n        message queue.\n\n        Args:\n            msg: Message to enqueue.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            connectionid = msg.header.get(\"connection-id\")\n            conn = self.connmgr.get(connectionid)\n            if conn:\n                conn.omq.put(msg)\n            else:\n                # DROP!\n                tlogger.warning(\"omq_put dropped message\")\n                pass\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def pop_session(\n        self,\n        sessionid: str = \"default\",\n    ) -> \"Session\":\n        \"\"\"Pop session.\n\n        Args:\n            sessionid: Session id.\n\n        Returns:\n            Session.\n        \"\"\"\n        return self.sessmgr.pop(sessionid)\n\n    def run(self):\n        \"\"\"Run \"runnable\" managers.\"\"\"\n        try:\n            tlogger = self.logger.enter()\n            self.connmgr.run()\n            # self.sessmgr.run()\n            # self.opsmgr.run()\n        finally:\n            tlogger.exit()\n\n    def set_debug(\n        self,\n        enabled: bool,\n    ):\n        \"\"\"Set debug mode\n\n        Args:\n            enabled: New state for debug mode.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n            tlogger.debug(\"setting debug ({enabled})\")\n\n            self.debug = enabled\n            if self.debug:\n                try:\n                    if self.schedlock.locked():\n                        self.schedlock.release()\n                except Exception as e:\n                    pass\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def shutdown(\n        self,\n        now: bool = False,\n    ):\n        \"\"\"Shutdown machine.\n\n        Args:\n            now: To shut down \"now\".\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n            tlogger.debug(\"SHUTTTING DOWN ...\")\n            if now:\n                os._exit(0)\n        finally:\n            tlogger.exit()\n\n    def start(self):\n        \"\"\"Start machine.\"\"\"\n        try:\n            tlogger = self.logger.enter()\n            self.connmgr.start()\n            self.sessmgr.start()\n            self.kernelmgr.start()\n        finally:\n            tlogger.exit()\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            uname = os.uname()\n            return State(\n                \"machine\",\n                self.oid,\n                {\n                    \"debug\": self.debug,\n                    \"features\": self.features(),\n                    \"host\": socket.gethostname(),\n                    \"schedlock\": self.schedlock.locked(),\n                    \"timestamp\": get_timestamp(),\n                    \"uname\": {\n                        \"machine\": uname.machine,\n                        \"nodename\": uname.nodename,\n                        \"release\": uname.release,\n                        \"sysname\": uname.sysname,\n                        \"version\": uname.version,\n                    },\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n\n    def step_debug(self):\n        \"\"\"Allow a step if in debug mode.\"\"\"\n        try:\n            tlogger = self.logger.enter()\n            tlogger.debug(\"stepping debug\")\n            if self.debug:\n                try:\n                    if self.schedlock.locked():\n                        self.schedlock.release()\n                except Exception as e:\n                    pass\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def stop(self):\n        \"\"\"Step machine.\"\"\"\n        try:\n            tlogger = self.logger.enter()\n            self.connmgr.stop()\n            # self.sessmgr.stop()\n        finally:\n            tlogger.exit()\n\n    def wait(self):\n        \"\"\"Wait (indefinitely) for machine to exit.\"\"\"\n        try:\n            tlogger = self.logger.enter()\n            time.sleep(1000000000)\n        finally:\n            tlogger.exit()", ""]}
{"filename": "src/server/penvm/server/processor.py", "chunked_list": ["#\n# penvm/server/processor.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\nimport threading\nimport time\nimport traceback\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\n", "\n\nfrom penvm.lib.base import BaseObject\nfrom penvm.lib.misc import State\nfrom penvm.lib.thread import Thread, ThreadInterrupt\nfrom penvm.lib.semaphore import AdjustableSemaphore\n\nlogger = logging.getLogger(__name__)\n\n\nclass Processor(BaseObject):\n    \"\"\"Runs kernel operations.\n\n    Kernel operations are scheduled by the session and run on the\n    processor. Operations are run on a selected kernel. Up to\n    `max_threads` messages can be processsed at a time.\n\n    The number of running \"threads\" can be adjusted dynamically with\n    `max_threads` limiting the number of running thread. Scheduling of\n    new threads resumes when the number of running threads goes below\n    `max_threads`.\"\"\"\n\n    def __init__(\n        self,\n        session: \"Session\",\n        kernelname: str = \"default\",\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            session: Owning session.\n            kernelname: Kernel name.\n        \"\"\"\n        try:\n            super().__init__(None, logger)\n            tlogger = self.logger.enter()\n\n            self.session = session\n            self.kernelname = kernelname\n\n            self.kill = False\n            self.max_threads = 1\n            self.kernel = self.session.machine.kernelmgr.get(kernelname)\n            self.runsem = AdjustableSemaphore(self.max_threads)\n            self.th = None\n            self.threads = set()\n            self.reqid2thread = {}\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def __repr__(self):\n        return f\"<Processor id={self.oid} max_threads={self.max_threads} nthreads={self.active_count()}>\"\n\n    def active_count(self) -> int:\n        \"\"\"Get number of running threads.\n\n        Returns:\n            Number of running threads.\n        \"\"\"\n        return len(self.threads)\n\n    def get_thread_reqids(self) -> List[str]:\n        \"\"\"Get list of request ids for each running thread.\n\n        Returns:\n            List of request ids.\n        \"\"\"\n        return list(self.reqid2thread.keys())\n\n    def run_thread(self, fn: Callable, fargs: List):\n        \"\"\"Runs a thread (to handle a request).\n\n        Machinery manages creating a context, starting a thread,\n        adhering to the thread limit, `ThreadInterrupt` handling,\n        tracking information, and `runsem` semaphore.\n\n        Args:\n            fn: Function to call.\n            fargs: Arguments to pass to function.\n        \"\"\"\n\n        def _run(reqid, target, *args, **kwargs):\n            try:\n                # tlogger = self.logger.enter()\n                try:\n                    tlogger.debug(f\"_run calling target={target} args={args}\")\n                    target(*args)\n                    tlogger.lap(f\"target {target} run completed \")\n                except ThreadInterrupt as e:\n                    tlogger.info(f\"thread interrupted {threading.current_thread()}\")\n                except Exception as e:\n                    tlogger.debug(f\"_run exception ({traceback.format_exc()}\")\n\n                try:\n                    tlogger.debug(f\"removing thread {threading.current_thread()}...\")\n                    self.threads.discard(threading.current_thread())\n                    self.reqid2thread.pop(reqid, None)\n                    tlogger.debug(f\"removed thread {threading.current_thread()}\")\n\n                    if 0:\n                        # clean up \"empty\" sessions unless pinned\n                        tlogger.debug(\"checking to clean up\")\n                        self.session.machine.sessmgr.cleanup(self.session.oid)\n\n                except Exception as e:\n                    tlogger.debug(f\"thread cleanup EXCEPTION ({e})\")\n                tlogger.debug(f\"releasing runsem ({self.session.oid=})...\")\n                self.runsem.release()\n                tlogger.debug(f\"release runsem ({self.session.oid=})\")\n            except Exception as e:\n                self.logger.warning(f\"EXCEPTION ({e})\")\n            finally:\n                # tlogger.exit()\n                pass\n\n        try:\n            tlogger = self.logger.enter()\n\n            tlogger.debug(f\"acquiring runsem ({self.session.oid=})...\")\n            self.runsem.acquire()\n            tlogger.debug(f\"acquired runsem ({self.session.oid=})\")\n\n            _opname, _ctxt, _req = fargs\n            reqid = _req.header.get(\"id\")\n            sessionid = _ctxt.session.oid\n\n            args = [reqid, fn] + list(fargs)\n            th = Thread(target=_run, name=reqid, args=args)\n            th.daemon = True\n            self.threads.add(th)\n            self.reqid2thread[reqid] = th\n            th.start()\n            # cleanup is done in _run()\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def schedule(self, ctxt: \"OpContext\", req: \"Message\"):\n        \"\"\"Schedule thread to run the requested kernel operation.\n\n        Args:\n            ctxt: Context in which to run operation.\n            req: Request message.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            opname = req.payload.get(\"op\")\n            if opname:\n                tlogger.info(f\"opname={opname}\")\n                self.run_thread(self.kernel.run, (opname, ctxt, req))\n            else:\n                tlogger.warning(f\"opname={opname} not found\")\n                # TODO: does this hang here?\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def set_max_threads(self, n: int):\n        \"\"\"Set the upper limit of the number of threads to run.\n\n        Updates the `runsem` semaphore to allow acquisition, if\n        possible.\n\n        Args:\n            n: Maximum number of threads.\n        \"\"\"\n        try:\n            self.max_threads = max(1, n)\n            self.runsem.adjust(self.max_threads)\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n\n    def start(self):\n        \"\"\"Start main processor thread.\"\"\"\n        try:\n            tlogger = self.logger.enter()\n            return\n\n            # TODO: are start()/run() necessary?\n            if not self.th:\n                self.th = Thread(target=self.run)\n                self.th.daemon = True\n            self.th.start()\n\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            return State(\n                \"processor\",\n                self.oid,\n                {\n                    \"kernel\": self.kernelname,\n                    \"max-threads\": self.max_threads,\n                    \"nthreads\": len(self.threads),\n                    \"runsem\": {\n                        \"_lock-locked\": self.runsem._lock.locked(),\n                        \"_waitlock-locked\": self.runsem._waitlock.locked(),\n                        \"count\": self.runsem.count(),\n                        \"max\": self.runsem.max(),\n                    },\n                    \"threads\": [th.state() for th in self.threads],\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n\n    def terminate_thread(self, reqid: str):\n        \"\"\"Forcefully terminate a running thread.\n\n        A `ThreadInterrupt` exception is raised for the thread.\n\n        Args:\n            reqid: Request id.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n            tlogger.info(\"terminating thread ({reqid})\")\n\n            th = self.reqid2thread.get(reqid)\n            th.terminate()\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()", "\n\nclass Processor(BaseObject):\n    \"\"\"Runs kernel operations.\n\n    Kernel operations are scheduled by the session and run on the\n    processor. Operations are run on a selected kernel. Up to\n    `max_threads` messages can be processsed at a time.\n\n    The number of running \"threads\" can be adjusted dynamically with\n    `max_threads` limiting the number of running thread. Scheduling of\n    new threads resumes when the number of running threads goes below\n    `max_threads`.\"\"\"\n\n    def __init__(\n        self,\n        session: \"Session\",\n        kernelname: str = \"default\",\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            session: Owning session.\n            kernelname: Kernel name.\n        \"\"\"\n        try:\n            super().__init__(None, logger)\n            tlogger = self.logger.enter()\n\n            self.session = session\n            self.kernelname = kernelname\n\n            self.kill = False\n            self.max_threads = 1\n            self.kernel = self.session.machine.kernelmgr.get(kernelname)\n            self.runsem = AdjustableSemaphore(self.max_threads)\n            self.th = None\n            self.threads = set()\n            self.reqid2thread = {}\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def __repr__(self):\n        return f\"<Processor id={self.oid} max_threads={self.max_threads} nthreads={self.active_count()}>\"\n\n    def active_count(self) -> int:\n        \"\"\"Get number of running threads.\n\n        Returns:\n            Number of running threads.\n        \"\"\"\n        return len(self.threads)\n\n    def get_thread_reqids(self) -> List[str]:\n        \"\"\"Get list of request ids for each running thread.\n\n        Returns:\n            List of request ids.\n        \"\"\"\n        return list(self.reqid2thread.keys())\n\n    def run_thread(self, fn: Callable, fargs: List):\n        \"\"\"Runs a thread (to handle a request).\n\n        Machinery manages creating a context, starting a thread,\n        adhering to the thread limit, `ThreadInterrupt` handling,\n        tracking information, and `runsem` semaphore.\n\n        Args:\n            fn: Function to call.\n            fargs: Arguments to pass to function.\n        \"\"\"\n\n        def _run(reqid, target, *args, **kwargs):\n            try:\n                # tlogger = self.logger.enter()\n                try:\n                    tlogger.debug(f\"_run calling target={target} args={args}\")\n                    target(*args)\n                    tlogger.lap(f\"target {target} run completed \")\n                except ThreadInterrupt as e:\n                    tlogger.info(f\"thread interrupted {threading.current_thread()}\")\n                except Exception as e:\n                    tlogger.debug(f\"_run exception ({traceback.format_exc()}\")\n\n                try:\n                    tlogger.debug(f\"removing thread {threading.current_thread()}...\")\n                    self.threads.discard(threading.current_thread())\n                    self.reqid2thread.pop(reqid, None)\n                    tlogger.debug(f\"removed thread {threading.current_thread()}\")\n\n                    if 0:\n                        # clean up \"empty\" sessions unless pinned\n                        tlogger.debug(\"checking to clean up\")\n                        self.session.machine.sessmgr.cleanup(self.session.oid)\n\n                except Exception as e:\n                    tlogger.debug(f\"thread cleanup EXCEPTION ({e})\")\n                tlogger.debug(f\"releasing runsem ({self.session.oid=})...\")\n                self.runsem.release()\n                tlogger.debug(f\"release runsem ({self.session.oid=})\")\n            except Exception as e:\n                self.logger.warning(f\"EXCEPTION ({e})\")\n            finally:\n                # tlogger.exit()\n                pass\n\n        try:\n            tlogger = self.logger.enter()\n\n            tlogger.debug(f\"acquiring runsem ({self.session.oid=})...\")\n            self.runsem.acquire()\n            tlogger.debug(f\"acquired runsem ({self.session.oid=})\")\n\n            _opname, _ctxt, _req = fargs\n            reqid = _req.header.get(\"id\")\n            sessionid = _ctxt.session.oid\n\n            args = [reqid, fn] + list(fargs)\n            th = Thread(target=_run, name=reqid, args=args)\n            th.daemon = True\n            self.threads.add(th)\n            self.reqid2thread[reqid] = th\n            th.start()\n            # cleanup is done in _run()\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def schedule(self, ctxt: \"OpContext\", req: \"Message\"):\n        \"\"\"Schedule thread to run the requested kernel operation.\n\n        Args:\n            ctxt: Context in which to run operation.\n            req: Request message.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            opname = req.payload.get(\"op\")\n            if opname:\n                tlogger.info(f\"opname={opname}\")\n                self.run_thread(self.kernel.run, (opname, ctxt, req))\n            else:\n                tlogger.warning(f\"opname={opname} not found\")\n                # TODO: does this hang here?\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def set_max_threads(self, n: int):\n        \"\"\"Set the upper limit of the number of threads to run.\n\n        Updates the `runsem` semaphore to allow acquisition, if\n        possible.\n\n        Args:\n            n: Maximum number of threads.\n        \"\"\"\n        try:\n            self.max_threads = max(1, n)\n            self.runsem.adjust(self.max_threads)\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n\n    def start(self):\n        \"\"\"Start main processor thread.\"\"\"\n        try:\n            tlogger = self.logger.enter()\n            return\n\n            # TODO: are start()/run() necessary?\n            if not self.th:\n                self.th = Thread(target=self.run)\n                self.th.daemon = True\n            self.th.start()\n\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            return State(\n                \"processor\",\n                self.oid,\n                {\n                    \"kernel\": self.kernelname,\n                    \"max-threads\": self.max_threads,\n                    \"nthreads\": len(self.threads),\n                    \"runsem\": {\n                        \"_lock-locked\": self.runsem._lock.locked(),\n                        \"_waitlock-locked\": self.runsem._waitlock.locked(),\n                        \"count\": self.runsem.count(),\n                        \"max\": self.runsem.max(),\n                    },\n                    \"threads\": [th.state() for th in self.threads],\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n\n    def terminate_thread(self, reqid: str):\n        \"\"\"Forcefully terminate a running thread.\n\n        A `ThreadInterrupt` exception is raised for the thread.\n\n        Args:\n            reqid: Request id.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n            tlogger.info(\"terminating thread ({reqid})\")\n\n            th = self.reqid2thread.get(reqid)\n            th.terminate()\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()", ""]}
{"filename": "src/server/penvm/server/session.py", "chunked_list": ["#\n# penvm/server/session.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nA (server-side) session isolates communication, operations, and\nprocessing. Except for special kernel operations which allow for one\nsession to affect another, there are no inter-session dependencies.\n\nEach session has its own incoming and outgoing message queues.\n", "Each session has its own incoming and outgoing message queues.\n\nEach session has and manages its own `Processor` which performs all\nsession-related processing.\n\nConcurrency is supported by the `Processor` (dynamically adjustable\nnumber of threads) and between sessions. Which means that while\none/some session(s) may be blocked, others may not be.\n\"\"\"\n", "\"\"\"\n\nimport logging\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.lib.base import BaseObject\nfrom penvm.lib.misc import State\nfrom penvm.lib.mqueue import MessageQueue\nfrom penvm.lib.thread import Thread\nfrom penvm.kernels.base.server import OpContext", "from penvm.lib.thread import Thread\nfrom penvm.kernels.base.server import OpContext\nfrom penvm.server.processor import Processor\n\nlogger = logging.getLogger(__name__)\n\n\nclass Session(BaseObject):\n    \"\"\"Server-side session.\"\"\"\n\n    def __init__(\n        self,\n        machine: \"Machine\",\n        sessionid: str,\n        kernelname: str = \"default\",\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            machine: Owning machine.\n            sessionid: Session id.\n            kernelname: Kernel name.\n        \"\"\"\n        try:\n            super().__init__(sessionid, logger)\n            tlogger = self.logger.enter()\n\n            self.machine = machine\n\n            self.exit = False\n            # TODO: should session/sessionid be passed to Processor()?\n            self.imq = MessageQueue()\n            self.omq = MessageQueue()\n            self.proc = Processor(self, kernelname)\n            self.th = None\n            self.pinned = False\n        finally:\n            tlogger.exit()\n\n    def __repr__(self):\n        return f\"<Session id={self.oid} machine={self.machine}>\"\n\n    def is_empty(self) -> bool:\n        \"\"\"Return if session is \"empty\", and therefore deletable.\n\n        Returns:\n            \"Emptiness\" status.\n        \"\"\"\n        # TODO: verify that active_count is an appropriate check\n        if self.proc.active_count() == 0 and self.imq.size() == 0 and self.omq.size() == 0:\n            return True\n        return False\n\n    def is_running(self) -> bool:\n        \"\"\"Return running status.\n\n        Returns:\n            Running status.\n        \"\"\"\n        return self.th != None\n\n    def run(self):\n        \"\"\"Run session.\n\n        Loops until `self.exit` is `False`.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            self.proc.start()\n            ctxt = OpContext()\n            ctxt.machine = self.machine\n            ctxt.processor = self.proc\n            ctxt.session = self\n\n            try:\n                while not self.exit:\n                    tlogger.debug(\"waiting for message ...\")\n                    req = self.imq.pop()\n                    if req == None:\n                        # reject dummy \"message\"\n                        continue\n\n                    tlogger.debug(f\"popped message and scheduling ({req.payload.get('op')}) ...\")\n                    if self.machine.debug and not self.oid.startswith(\"-debug-\"):\n                        self.machine.schedlock.acquire()\n                    self.proc.schedule(ctxt, req)\n\n                    tlogger.debug(f\"message scheduled ({req.payload.get('op')})\")\n            except Exception as e:\n                tlogger.warning(f\"EXCEPTION ({e})\")\n                raise\n\n            self.th = None\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def set_kernel(\n        self,\n        kernel: \"Kernel\",\n    ):\n        \"\"\"Set the kernel to use.\n\n        Args:\n            kernel: Kernel.\n        \"\"\"\n        self.logger.debug(\"set kernel\")\n        self.proc.kernel = kernel\n\n    def start(self):\n        \"\"\"Start the main session thread.\"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            if not self.th:\n                try:\n                    self.th = Thread(target=self.run)\n                    self.th.daemon = True\n                    self.th.start()\n                except Exception as e:\n                    tlogger.debug(f\"failed to start ({e})\")\n                    self.th = None\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def stop(self):\n        \"\"\"Stop the `run` method running in a thread.\"\"\"\n        self.exit = True\n        # dummy \"message\" to wake up thread\n        self.imq.put(None)\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            return State(\n                \"session\",\n                self.oid,\n                {\n                    \"imq\": self.imq.state(),\n                    \"nimq\": self.imq.size(),\n                    \"nomq\": self.omq.size(),\n                    \"omq\": self.omq.state(),\n                    \"processor\": self.proc.state(),\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")", ""]}
{"filename": "src/server/penvm/server/storage.py", "chunked_list": ["#\n# penvm/server/storage.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nlogger = logging.getLogger(__name__)\n\nfrom penvm.lib.base import BaseObject\n", "from penvm.lib.base import BaseObject\n\n\nclass StorageManager(BaseObject):\n    \"\"\"Storage manager.\n\n    NIY.\n    \"\"\"\n\n    def __init__(self, machine: \"Machine\"):\n        \"\"\"Initialize.\n\n        Args:\n            machine: Owning machine.\n        \"\"\"\n        try:\n            super().__init__(None, logger)\n            tlogger = self.logger.enter()\n\n            self.machine = machine\n            self.stores = {}\n        finally:\n            tlogger.exit()\n\n    def create(self):\n        pass\n\n    def delete(\n        self,\n        storeid: str,\n    ):\n        \"\"\"Delete by id.\n\n        Args:\n            storeid: Store id.\n        \"\"\"\n        store = self.stores.pop(storeid)\n        if store:\n            # delete\n            pass\n\n    def get(self, storeid: str) -> Any:\n        \"\"\"Get object by id.\n\n        Args:\n            storeid: Store id.\n\n        Returns:\n            Store.\n        \"\"\"\n        return self.store.get(storeid)\n\n    def list(self) -> List[str]:\n        \"\"\"List store ids.\n\n        Returns:\n            Store ids.\n        \"\"\"\n        return self.store.keys()\n\n    def run(self):\n        pass", ""]}
{"filename": "src/server/penvm/server/sessionmanager.py", "chunked_list": ["#\n# penvm/server/sessionmanager.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"All sessions are managed by `SessionManager`. Creation, removal,\ncleanup, and lookups are centrally handled by the `SessionManager`.\n\"\"\"\n\nimport logging\nimport threading\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union", "import threading\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.lib.base import BaseObject\nfrom penvm.lib.misc import State\nfrom penvm.server.session import Session\n\nlogger = logging.getLogger(__name__)\n\n\nclass SessionManager(BaseObject):\n    \"\"\"Manages server-side sessions.\n\n    All sessions are managed by a SessionManager owned by the machine.\"\"\"\n\n    def __init__(\n        self,\n        machine: \"Machine\",\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            machine: Owning machine.\n        \"\"\"\n        try:\n            super().__init__(None, logger)\n            tlogger = self.logger.enter()\n\n            self.machine = machine\n\n            self.lock = threading.Lock()\n            self.sessions = {}\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def cleanup(\n        self,\n        sessionid: str,\n    ):\n        \"\"\"Clean up session (if \"empty\").\n\n        Args:\n            sessionid: Session id.\n        \"\"\"\n        try:\n            self.lock.acquire()\n            sess = self.sessions.get(sessionid)\n            if sess and not sess.pinned:\n                if sess.is_empty():\n                    sess.stop()\n                    self.pop(sessionid)\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            self.lock.release()\n\n    def delete(\n        self,\n        sessionid: str,\n    ):\n        \"\"\"Delete (forced) a session by session id.\n\n        Args:\n            sessionid: Session id.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            sess = self.sessions.pop(sessionid)\n            if sess:\n                # delete\n                pass\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def get(\n        self,\n        sessionid: str,\n    ) -> \"Session\":\n        \"\"\"Get a session by session id.\n\n        Args:\n            sessionid: Session id.\n\n        Returns:\n            Session.\n        \"\"\"\n        try:\n            self.lock.acquire()\n            return self.sessions.get(sessionid)\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            self.lock.release()\n\n    def list(self) -> List[str]:\n        \"\"\"List sessions by session id.\n\n        Returns:\n            Session ids.\n        \"\"\"\n        return list(self.sessions.keys())\n\n    def pop(self, sessionid: str) -> \"Session\":\n        \"\"\"Pop a session by session id.\n\n        Args:\n            sessionid: Session id.\n\n        Returns:\n            Session.\n        \"\"\"\n        try:\n            self.lock.acquire()\n            sess = self.sessions.pop(sessionid)\n            return sess\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            self.lock.release()\n\n    def setdefault(\n        self,\n        sessionid: Union[str, None],\n        default: Union[\"Session\", None] = None,\n    ) -> \"Session\":\n        \"\"\"Get a session (or create new one if not present) by session\n        id.\n\n        Args:\n            sessionid: Session id.\n            default: Session if session not found.\n\n        Returns:\n            Session.\n        \"\"\"\n        try:\n            self.lock.acquire()\n            session = self.sessions.get(sessionid)\n            if not session:\n                session = self.sessions[sessionid] = default or Session(self.machine, sessionid)\n                session.start()\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            self.lock.release()\n        return session\n\n    def start(self):\n        \"\"\"Start.\n\n        NOOP. No background threads.\"\"\"\n        pass\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            return State(\n                \"session-manager\",\n                None,\n                {\n                    \"nsessions\": len(self.sessions),\n                    \"session-ids\": self.list(),\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")", "\n\nclass SessionManager(BaseObject):\n    \"\"\"Manages server-side sessions.\n\n    All sessions are managed by a SessionManager owned by the machine.\"\"\"\n\n    def __init__(\n        self,\n        machine: \"Machine\",\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            machine: Owning machine.\n        \"\"\"\n        try:\n            super().__init__(None, logger)\n            tlogger = self.logger.enter()\n\n            self.machine = machine\n\n            self.lock = threading.Lock()\n            self.sessions = {}\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def cleanup(\n        self,\n        sessionid: str,\n    ):\n        \"\"\"Clean up session (if \"empty\").\n\n        Args:\n            sessionid: Session id.\n        \"\"\"\n        try:\n            self.lock.acquire()\n            sess = self.sessions.get(sessionid)\n            if sess and not sess.pinned:\n                if sess.is_empty():\n                    sess.stop()\n                    self.pop(sessionid)\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            self.lock.release()\n\n    def delete(\n        self,\n        sessionid: str,\n    ):\n        \"\"\"Delete (forced) a session by session id.\n\n        Args:\n            sessionid: Session id.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            sess = self.sessions.pop(sessionid)\n            if sess:\n                # delete\n                pass\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def get(\n        self,\n        sessionid: str,\n    ) -> \"Session\":\n        \"\"\"Get a session by session id.\n\n        Args:\n            sessionid: Session id.\n\n        Returns:\n            Session.\n        \"\"\"\n        try:\n            self.lock.acquire()\n            return self.sessions.get(sessionid)\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            self.lock.release()\n\n    def list(self) -> List[str]:\n        \"\"\"List sessions by session id.\n\n        Returns:\n            Session ids.\n        \"\"\"\n        return list(self.sessions.keys())\n\n    def pop(self, sessionid: str) -> \"Session\":\n        \"\"\"Pop a session by session id.\n\n        Args:\n            sessionid: Session id.\n\n        Returns:\n            Session.\n        \"\"\"\n        try:\n            self.lock.acquire()\n            sess = self.sessions.pop(sessionid)\n            return sess\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            self.lock.release()\n\n    def setdefault(\n        self,\n        sessionid: Union[str, None],\n        default: Union[\"Session\", None] = None,\n    ) -> \"Session\":\n        \"\"\"Get a session (or create new one if not present) by session\n        id.\n\n        Args:\n            sessionid: Session id.\n            default: Session if session not found.\n\n        Returns:\n            Session.\n        \"\"\"\n        try:\n            self.lock.acquire()\n            session = self.sessions.get(sessionid)\n            if not session:\n                session = self.sessions[sessionid] = default or Session(self.machine, sessionid)\n                session.start()\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            self.lock.release()\n        return session\n\n    def start(self):\n        \"\"\"Start.\n\n        NOOP. No background threads.\"\"\"\n        pass\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            return State(\n                \"session-manager\",\n                None,\n                {\n                    \"nsessions\": len(self.sessions),\n                    \"session-ids\": self.list(),\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")", ""]}
{"filename": "src/server/penvm/server/kernelmanager.py", "chunked_list": ["#\n# penvm/server/kernelmanager.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nAll server-side kernels are registered with the manager and accessible\nby name.\n\"\"\"\n\nimport logging\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union", "import logging\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.lib.base import BaseObject\nfrom penvm.lib.misc import State\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass KernelManager(BaseObject):\n    \"\"\"Manage server-side kernels.\"\"\"\n\n    def __init__(self, machine: \"Machine\"):\n        \"\"\"Initialize.\n\n        Args:\n            machine: Machine.\n        \"\"\"\n        super().__init__(None, logger)\n        self.machine = machine\n        self.kernels = {}\n\n    def drop(self, name: str):\n        \"\"\"Drop kernel by name.\n\n        Args:\n            name: Kernel name.\n        \"\"\"\n        self.kernels.pop(name)\n\n    def get(self, name: str) -> \"Kernel\":\n        \"\"\"Get kernel by name.\n\n        Args:\n            name: Kernel name.\n        \"\"\"\n        return self.kernels.get(name)\n\n    def list(self) -> List[str]:\n        \"\"\"Get list of kernel names.\n\n        Returns:\n            Kernel names.\n        \"\"\"\n        return list(self.kernels.keys())\n\n    def set(self, name: str, kernel: \"Kernel\"):\n        \"\"\"Register kernel by name.\n\n        Args:\n            name: Kernel name.\n            kernel: Kernel.\n        \"\"\"\n        self.kernels[name] = kernel\n\n    def start(self):\n        \"\"\"Start.\n\n        No background threads.\"\"\"\n        pass\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            return State(\n                \"kernel-manager\",\n                None,\n                {\n                    \"kernel-ids\": self.list(),\n                    \"nkernels\": len(self.kernels),\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")", "\n\nclass KernelManager(BaseObject):\n    \"\"\"Manage server-side kernels.\"\"\"\n\n    def __init__(self, machine: \"Machine\"):\n        \"\"\"Initialize.\n\n        Args:\n            machine: Machine.\n        \"\"\"\n        super().__init__(None, logger)\n        self.machine = machine\n        self.kernels = {}\n\n    def drop(self, name: str):\n        \"\"\"Drop kernel by name.\n\n        Args:\n            name: Kernel name.\n        \"\"\"\n        self.kernels.pop(name)\n\n    def get(self, name: str) -> \"Kernel\":\n        \"\"\"Get kernel by name.\n\n        Args:\n            name: Kernel name.\n        \"\"\"\n        return self.kernels.get(name)\n\n    def list(self) -> List[str]:\n        \"\"\"Get list of kernel names.\n\n        Returns:\n            Kernel names.\n        \"\"\"\n        return list(self.kernels.keys())\n\n    def set(self, name: str, kernel: \"Kernel\"):\n        \"\"\"Register kernel by name.\n\n        Args:\n            name: Kernel name.\n            kernel: Kernel.\n        \"\"\"\n        self.kernels[name] = kernel\n\n    def start(self):\n        \"\"\"Start.\n\n        No background threads.\"\"\"\n        pass\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            return State(\n                \"kernel-manager\",\n                None,\n                {\n                    \"kernel-ids\": self.list(),\n                    \"nkernels\": len(self.kernels),\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")", ""]}
{"filename": "src/client/penvm/client/world.py", "chunked_list": ["#\n# penvm/client/world.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nThe World object is foundational for defining the set of networks\nand machines available to an application. It can be set up in various\nways: configuration, configuration file, network string, environment\nvariables. All of these provide flexibility for many use cases.\n\nAn application is associated with a world configuration explicitly", "\nAn application is associated with a world configuration explicitly\n(specific configuration or named configuration file) or implicitly\n(environment variable or related .penvm file).\n\nEach running machine instance is defined by a `MachineConnectionSpec`\nwhich can be represented as a Machine Connection string. A machine\nconnection consists of:\n\n* machine id (unique)", "\n* machine id (unique)\n* ssl profile (name)\n* hostname/address\n* port\n\nA network string consists of one or more machine connection strings.\n\"\"\"\n\nimport concurrent.futures", "\nimport concurrent.futures\nimport os\nimport os.path\nimport logging\nimport subprocess\nimport sys\nimport threading\nimport time\nimport traceback", "import time\nimport traceback\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\n\nfrom penvm.client.config import WorldConfig\nfrom penvm.client.machine import Machine\nfrom penvm.lib.base import BaseObject\nfrom penvm.lib.misc import MachineConnectionSpec, get_uuid, get_version_string\n", "from penvm.lib.misc import MachineConnectionSpec, get_uuid, get_version_string\n\nlogger = logging.getLogger(__name__)\n\n\nclass World(BaseObject):\n    \"\"\"World of networks and hosts.\n\n    Configuration is taken from:\n\n    1. `config` keyword argument\n    1. `networkstr` keyword argument\n    1. `filename` keyword argument\n    1. `PENVM_AUTO_NETWORK` environment variable\n    1. `PENVM_WORLD_FILENAME` environment variable\n    1. `<binname>.penvm` found in directory containing executable\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize.\n\n        Keyword Args:\n            config (dict): Dictionary configuration.\n            filename (str): Configuration filename.\n            networkstr (str): Network string of machine connection\n                strings.\n        \"\"\"\n        try:\n            super().__init__(kwargs.get(\"filename\"), logger)\n            tlogger = self.logger.enter()\n\n            self.config = WorldConfig()\n            self.networks = {}\n            self.filename = None\n\n            # print(f\"{kwargs=}\")\n            if kwargs.get(\"config\") != None:\n                # print(\"World config\")\n                self.config.load_config(kwargs[\"config\"])\n            elif kwargs.get(\"networkstr\") != None:\n                # print(\"World networkstr\")\n                self.load_auto_network(\"default\", kwargs[\"networkstr\"])\n            elif kwargs.get(\"filename\") != None:\n                # print(\"World filename\")\n                self.filename = kwargs[\"filename\"]\n                self.config.load(self.filename)\n            elif os.environ.get(\"PENVM_AUTO_NETWORK\") != None:\n                # print(\"World PENVM_AUTO_NETWORK\")\n                self.load_auto_network(\"default\", os.environ.get(\"PENVM_AUTO_NETWORK\"))\n            elif os.environ.get(\"PENVM_WORLD_FILENAME\") != None:\n                # print(\"World PENVM_WORLD_FILENAME\")\n                self.filename = os.environ.get(\"PENVM_WORLD_FILENAME\")\n                self.config.load(self.filename)\n            else:\n                # print(\"World .penvm\")\n                filename, ext = os.path.splitext(os.path.basename(sys.argv[0]))\n                filename = f\"{os.path.dirname(sys.argv[0])}/{filename}.penvm\"\n                # TODO: abspath(filename)?\n                if filename and os.path.exists(filename):\n                    self.config.load(filename)\n                    self.filename = filename\n\n            if self.filename:\n                # TODO: is this the right place for this or way to do this?\n                self.oid = self.filename\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def get_group_names(self):\n        return self.config.get_groups()\n\n    def get_meta(self, name: str) -> Any:\n        \"\"\"Get meta(data) value.\n\n        Returns:\n            Value.\n        \"\"\"\n        return self.config.get_meta(name)\n\n    def get_network(self, network_name: str = \"default\") -> \"Network\":\n        \"\"\"Get network object by name.\n\n        Args:\n            network_name: Network name.\n\n        Returns:\n            Network.\n        \"\"\"\n        network = self.networks.get(network_name)\n        if not network:\n            netconfig = self.config.get_network(network_name)\n            if not netconfig:\n                return None\n            targets = []\n            for target_name in netconfig.get_targets():\n                target = self.get_target(target_name)\n                if target:\n                    targets.append(target)\n            network = Network(network_name, targets, netconfig)\n            self.networks[network_name] = network\n        return network\n\n    def get_networks(self) -> List[\"Network\"]:\n        \"\"\"Get networks.\n\n        Return:\n            List of networks.\n        \"\"\"\n        return list(self.networks.values())\n\n    def get_network_names(self) -> List[str]:\n        \"\"\"Get network names.\n\n        Return:\n            Network names.\n        \"\"\"\n        return self.config.get_networks()\n\n    def get_target(self, target_name: str) -> \"Target\":\n        \"\"\"Get target by name.\n\n        Args:\n            target_name: Target name.\n\n        Returns:\n            Target.\n        \"\"\"\n        return Target(target_name, self.config.get_target(target_name))\n\n    def get_target_names(self) -> List[str]:\n        \"\"\"Get target names.\n\n        Returns:\n            List of target names.\n        \"\"\"\n        return self.config.get_targets()\n\n    def load_auto_network(self, name: str, networkstr: str):\n        \"\"\"Load auto-scheme (predefined, running) network\n\n        The machine connection strings are used to generate a\n        configuration for targets (by machid) and a network.\n\n        Args:\n            name: Network name.\n            networkstr: Network string.\n        \"\"\"\n        try:\n            targets = []\n            for machconnstr in networkstr.split():\n                mcs = MachineConnectionSpec(machconnstr=machconnstr)\n                target_config = {\n                    \"machine-id\": mcs.machid,\n                    \"scheme\": \"auto\",\n                    \"host\": mcs.host,\n                    \"port\": mcs.port,\n                    \"ssl-profile\": mcs.sslprofile,\n                }\n                targets.append(mcs.machid)\n                self.config.add_target(mcs.machid, target_config)\n            net_config = {\n                \"targets\": \" \".join(targets),\n            }\n            self.config.add_network(name, net_config)\n        except Exception as e:\n            traceback.print_exc()\n\n    def shutdown(self):\n        \"\"\"Shut down network.\n\n        Results in machine instances being shut down.\n        \"\"\"\n        for network in self.get_networks():\n            try:\n                network.shutdown()\n            except Exception as e:\n                pass", "\n\nclass Network(BaseObject):\n    \"\"\"Network.\n\n    Encapsulates references to targets and booted machine instances.\n    \"\"\"\n\n    def __init__(self, name: str, targets: List[\"Target\"], config: \"NetworkConfig\"):\n        \"\"\"Initialize.\n\n        Args:\n            name: Network name.\n            targets: List of network targets.\n            config: Network configuration.\n        \"\"\"\n        try:\n            super().__init__(name, logger)\n            tlogger = self.logger.enter()\n\n            self.name = name\n            self.targets = targets\n            self.config = config\n\n            # augment from net config\n            overrides = self.config.get(\"overrides\")\n            if overrides:\n                for target in self.targets:\n                    target.update(overrides)\n\n            self.machines = {}\n        finally:\n            tlogger.exit()\n\n    def __len__(self):\n        return len(self.machines)\n\n    def __str__(self):\n        return \" \".join(self.get_machconnstrs())\n\n    def boot(\n        self,\n        concurrency: Union[int, None] = None,\n    ):\n        \"\"\"Boot (machines in) network.\n\n        Boots machine instances using target information.\n\n        Boot concurrency (\"boot-concurrency\" configuration\n        setting) is: 0: number of targets, 1: serial, > 1\n        concurrent. Final minimum is 1. Default is 1.\n\n        Args:\n            concurrency: Boot concurrency. Overrides configuration if\n                provided.\n        \"\"\"\n        # TODO: run threaded to improve startup/setup times and smooth\n        # out wait/delay/connect times\n        try:\n            tlogger = self.logger.enter()\n\n            if self.machines:\n                # already booted\n                return\n\n            if concurrency == None:\n                concurrency = self.config.get(\"boot-concurrency\", 1)\n                if concurrency == 0:\n                    concurrency = len(self.targets)\n            concurrency = max(1, concurrency)\n\n            # print(f\"{concurrency=}\")\n            if concurrency == 1:\n                # sequential boot\n                for target in self.targets:\n                    self.machines[target.name] = target.boot()\n            else:\n                # TODO: figure out why terminal gets messed up\n                # concurrent boot\n                def _boot(target):\n                    machine = target.boot()\n                    lock.acquire()\n                    self.machines[target.name] = machine\n                    lock.release()\n                    self.logger.debug(f\"booted target ({target.name}) machine ({machine.oid})\")\n                    # print(f\"{machine=}\")\n                    return machine\n\n                lock = threading.Lock()\n\n                with concurrent.futures.ThreadPoolExecutor(max_workers=concurrency) as executor:\n                    # with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:\n                    results = {executor.submit(_boot, target) for target in self.targets}\n                    for future in concurrent.futures.as_completed(results):\n                        # print(f\"{future.result()=}\")\n                        pass\n\n            # TODO: launch penvm-server\n            # TODO: capture host/addr and port\n            # TODO: set up Machines for each\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def get_machconnspecs(self) -> List[\"MachineConnectionSpec\"]:\n        \"\"\"Get `MachineConnectionSpec`s for machines.\n\n        Returns:\n            List of `MachineConnectionSpec`s.\n        \"\"\"\n        return [m.get_machconnspec() for m in self.machines.values()]\n\n    def get_machconnstrs(self) -> List[str]:\n        \"\"\"Get machine connection strings for machines.\n\n        Returns:\n            List of machine connection strings.\n        \"\"\"\n        return [m.get_machconnstr() for m in self.machines.values()]\n\n    def get_machine(self, target_name: str) -> \"Machine\":\n        \"\"\"Get machine.\n\n        Args:\n            target_name (str): Target name.\n\n        Returns:\n            Machine for named target.\n        \"\"\"\n        return self.machines.get(target_name)\n\n    def get_machines(self) -> List[\"Machine\"]:\n        \"\"\"Get list of machines for network.\n\n        Returns:\n            List of `Machine`s.\n        \"\"\"\n        return list(self.machines.values())\n\n    def get_machine_names(self) -> List[str]:\n        \"\"\"Get list of machine names for network.\n\n        Returns:\n            List of machine names.\n        \"\"\"\n        return list(self.machines.keys())\n\n    def get_targets(self) -> List[\"Target\"]:\n        \"\"\"Get targets for network.\n\n        Returns:\n            List of Targets.\n        \"\"\"\n        return self.targets\n\n    def get_target_names(self) -> List[str]:\n        \"\"\"Get target names for network.\n\n        Returns:\n            List of target names.\n        \"\"\"\n        return [target.name for target in self.targets]\n\n    def is_alive(self) -> bool:\n        \"\"\"Indicate if network is alive, or not.\n\n        Returns:\n            `True` or `False`.\n        \"\"\"\n        return self.machines and True or False\n\n    def shutdown(self):\n        \"\"\"Shut down network.\n\n        Request for machines to be shutdown. Clear local tracking\n        of machines by network.\n        \"\"\"\n        self.logger.debug(\"shutdown\")\n        for k, machine in self.machines.items()[:]:\n            s = machine.get_session()\n            s.kernel.machine_shutdown()\n            self.machines.pop(k, None)", "\n\nclass Target(BaseObject):\n    \"\"\"Target.\"\"\"\n\n    def __init__(self, name: str, config: Union[\"TargetConfiguration\", None] = None):\n        \"\"\"Initialize.\n\n        Args:\n            name: Target name.\n            config: Target configuration.\n        \"\"\"\n        try:\n            super().__init__(name, logger)\n            tlogger = self.logger.enter()\n\n            self.name = name\n            self.config = config or {}\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def __repr__(self):\n        # url = self.config.get(\"url\") if self.config else \"\"\n        scheme = self.config.get(\"scheme\")\n        host = self.config.get(\"host\")\n        port = self.config.get(\"port\")\n        user = self.config.get(\"user\")\n        return f\"<Target name={self.name} scheme={scheme} host={host} port={port} user={user}>\"\n\n    def boot(self):\n        \"\"\"Boot machine on target.\n\n        Spawns `penvm-server` processes for each target.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            scheme = self.config.get(\"scheme\")\n            host = self.config.get(\"host\")\n            port = self.config.get(\"port\")\n            user = self.config.get(\"user\")\n            sslprofile = self.config.get(\"ssl-profile\")\n\n            # assign unique machine id\n            machineid = self.config.get(\"machine-id\", get_uuid())\n            serverpath = f\".penvm/releases/{get_version_string()}/penvm-server\"\n\n            t0 = time.time()\n            if scheme == \"auto\":\n                pass\n            else:\n                if scheme == \"ssh\":\n                    spargs = [\n                        \"ssh\",\n                        host,\n                        # \"-T\",\n                        \"-tt\",\n                        \"-x\",\n                    ]\n                    if user:\n                        spargs.extend([\"-l\", user])\n                    if port:\n                        spargs.extend([\"-p\", port])\n\n                elif scheme == \"local\":\n                    serverpath = os.path.expanduser(f\"~/{serverpath}\")\n                    spargs = []\n                else:\n                    return\n\n                spargs.extend(\n                    [\n                        \"python3\",\n                        serverpath,\n                        \"--machineid\",\n                        machineid,\n                        \"--announce\",\n                        \"--background\",\n                        \"--firstwait\",\n                        # \"15\",\n                        \"5\",\n                    ]\n                )\n\n                if sslprofile:\n                    spargs.extend([\"--ssl-profile\", sslprofile])\n\n                spargs.append(host)\n\n                tlogger.debug(\"booting server ...\")\n                tlogger.debug(f\"boot args={spargs}\")\n                # print(f\"boot args={spargs}\")\n                cp = subprocess.run(\n                    spargs,\n                    stdin=subprocess.DEVNULL,\n                    capture_output=True,\n                    text=True,\n                    cwd=\"/\",\n                    timeout=5,\n                )\n\n                if cp.returncode != 0:\n                    tlogger.debug(f\"boot failed returncode={cp.returncode} stderr={cp.stderr}\")\n\n                t1 = time.time()\n                # tlogger.debug(f\"machine booted elapsed ({t1-t0})\")\n\n            # set up Machine info\n            try:\n                # print(f\"{scheme=}\")\n                # print(f\"{self.config=}\")\n                if scheme == \"auto\":\n                    mcs = MachineConnectionSpec(config=self.config)\n                else:\n                    # print(f\"{cp.stdout=}\")\n                    # print(f\"{cp.stderr=}\")\n                    if not cp.stdout.startswith(\"announce::\"):\n                        raise Exception(\n                            f\"could not get penvm-server information ({cp.stderr}). (is penvm-server deployed?)\"\n                        )\n\n                    # trim announcement\n                    s = cp.stdout[10:]\n                    mcs = MachineConnectionSpec(machconnstr=s)\n\n                for _ in range(10):\n                    # TODO: be smart about `sleep`/waiting for remote readiness\n                    if scheme != \"auto\":\n                        time.sleep(0.05)\n                    tlogger.debug(f\"machine announcement received machineconnectionstr={mcs}\")\n\n                    tlogger.debug(\"creating Machine ...\")\n                    mach = Machine(\n                        mcs.host,\n                        mcs.port,\n                        mcs.sslprofile,\n                        mcs.machid,\n                    )\n                    if mach:\n                        mach.start()\n                        break\n\n                t1 = time.time()\n                tlogger.debug(f\"machine created elapsed ({t1-t0})\")\n\n                if mach:\n                    # set up sessions\n                    sessions = self.config.get(\"sessions\")\n                    if sessions:\n                        sess = mach.get_session(\"_\")\n                        for sessionid, session in sessions.items():\n                            kernelname = session.get(\"kernel\")\n                            maxthreads = session.get(\"max-threads\")\n\n                            if kernelname != None:\n                                tlogger.debug(\n                                    f\"session ({sessionid}) setting kernel ({kernelname})\"\n                                )\n                                sess.kernel.session_use_kernel(kernelname, sessionid=sessionid)\n                            if maxthreads != None:\n                                tlogger.debug(\n                                    f\"session ({sessionid}) setting max threads ({maxthreads})\"\n                                )\n                                sess.kernel.session_set_max_threads(\n                                    maxthreads, sessionid=sessionid\n                                )\n\n                    # load assets\n                    pass\n\n                return mach\n            except Exception as e:\n                raise\n        finally:\n            tlogger.exit()\n\n    def update(self, config: dict):\n        \"\"\"Update configuration.\n\n        Args:\n            config: Configuration.\n        \"\"\"\n        self.config.update(config)", ""]}
{"filename": "src/client/penvm/client/config.py", "chunked_list": ["#\n# penvm/client/config.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Collection of configuration support, mostly used in\n[penvm.client.world][].\n\"\"\"\n\nimport copy\nimport itertools\nimport logging", "import itertools\nimport logging\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\nimport yaml\n\nlogger = logging.getLogger(__name__)\n\n\ndef expand_range(s: str) -> str:\n    \"\"\"Expand range settings in string.\n\n    Uses Python style range: `<start>:<end>:<step>`.\n\n    Deprecated.\n\n    Args:\n        s (str): Range string to expand.\n\n    Returns:\n        List of expanded ranges.\n    \"\"\"\n    l = []\n    # print(f\"expand_range ({s=})\")\n    while s:\n        if \"[\" in s:\n            i = s.find(\"[\")\n            ii = s.find(\"]\")\n            l.append([s[:i]])\n            start, end, *rest = s[i + 1 : ii].split(\":\")\n            step = rest[0] if rest else \"1\"\n            sz = min(map(len, [start, end]))\n            start, end, step = int(start), int(end), int(step)\n            l.append(srange(start, end, step, sz))\n            s = s[ii + 1 :]\n        else:\n            l.append([s])\n            s = \"\"\n\n    return [\"\".join(t) for t in itertools.product(*l)]", "def expand_range(s: str) -> str:\n    \"\"\"Expand range settings in string.\n\n    Uses Python style range: `<start>:<end>:<step>`.\n\n    Deprecated.\n\n    Args:\n        s (str): Range string to expand.\n\n    Returns:\n        List of expanded ranges.\n    \"\"\"\n    l = []\n    # print(f\"expand_range ({s=})\")\n    while s:\n        if \"[\" in s:\n            i = s.find(\"[\")\n            ii = s.find(\"]\")\n            l.append([s[:i]])\n            start, end, *rest = s[i + 1 : ii].split(\":\")\n            step = rest[0] if rest else \"1\"\n            sz = min(map(len, [start, end]))\n            start, end, step = int(start), int(end), int(step)\n            l.append(srange(start, end, step, sz))\n            s = s[ii + 1 :]\n        else:\n            l.append([s])\n            s = \"\"\n\n    return [\"\".join(t) for t in itertools.product(*l)]", "\n\ndef expand_range(s: str) -> List[str]:\n    \"\"\"Expand numbered, comma-separated ranges.\n\n    Supported formats are:\n\n    * &lt;start>-&lt;end>\n    * &lt;single>\n\n    Leading 0s set width of resulting numbers (e.g., 001 for a width\n    of three digits).\n\n    Args:\n        s (str): Formatted string.\n\n    Returns:\n        List of expanded ranges.\n    \"\"\"\n    l = []\n    while s:\n        if \"[\" in s:\n            i = s.find(\"[\")\n            ii = s.find(\"]\")\n            l.append([s[:i]])\n            ll = []\n            segment = s[i + 1 : ii]\n            chunks = segment.split(\",\")\n            for chunk in chunks:\n                chunk = chunk.strip()\n                if \"-\" in chunk:\n                    first, last = chunk.split(\"-\")\n                    sz = min(map(len, [first, last]))\n                    first, last = int(first), int(last)\n                    ll.extend(list(srange(first, last + 1, 1, sz)))\n                else:\n                    ll.append(chunk)\n            l.append(ll)\n            s = s[ii + 1 :]\n        else:\n            l.append([s])\n            s = \"\"\n\n    return [\"\".join(t) for t in itertools.product(*l)]", "\n\ndef listify_targets(s: str) -> List[str]:\n    \"\"\"Expand targets settings.\n\n    Args:\n        s: String of targets/target ranges.\n\n    Returns:\n        List of expanded ranges.\n    \"\"\"\n    l = []\n    for name in s.split():\n        l.extend(expand_range(name))\n    return l", "\n\ndef expand_value(v: str, d: dict) -> str:\n    \"\"\"Expand/resolve value using dictionary.\n\n    Resolvable items are specified using the `str.format`.\n\n    Args:\n        v: Regular or format string.\n        d: Dictionary used to resolve format string.\n\n    Returns:\n        Resolved \"value\".\n    \"\"\"\n    if type(v) == str:\n        return v.format(**d)\n    return v", "\n\ndef srange(start: int, end: int, step: int, sz: str):\n    \"\"\"\n    Args:\n        start: Start value.\n        end: End value.\n        step: Step value.\n        sz: Field width.\n\n    Yields:\n        (str): Range value.\n    \"\"\"\n    fmt = \"%%0.%dd\" % (sz,)\n    for v in range(start, end, step):\n        yield fmt % v", "\n\nclass WorldConfig:\n    \"\"\"World configuation.\n\n    Provide high-level methods for working with the world\n    configuration file. This is normally used only by\n    [penvm.client.world.World][].\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize.\"\"\"\n        self.groups = {}\n        self.meta = {}\n        self.networks = {}\n        self.targets = {}\n        self.templates = {}\n\n    def __repr__(self):\n        return f\"<WorldConfig nnetworks={len(self.networks)}  ngroups={len(self.groups)} ntargets={len(self.targets)}>\"\n\n    def add_group(self, name: str, config: dict):\n        \"\"\"Add group.\n\n        Args:\n            name: Group name.\n            config: Configuration.\n        \"\"\"\n        self.groups[name] = GroupConfig(self, name, config)\n\n    def add_meta(self, config: dict):\n        \"\"\"Add meta(data).\n\n        Args:\n            config: Configuration.\n        \"\"\"\n        self.meta.update(config)\n\n    def add_network(self, name: str, config: dict):\n        \"\"\"Add network.\n\n        Args:\n            name: Network name.\n            config: Configuration.\n        \"\"\"\n        self.networks[name] = NetworkConfig(self, name, config)\n\n    def add_target(self, name: str, config: dict):\n        \"\"\"Add target.\n\n        Args:\n            name: Target name.\n            config: Configuration.\n        \"\"\"\n        self.targets[name] = TargetConfig(self, name, config)\n\n    def add_template(self, name: str, config: dict):\n        \"\"\"Add template.\n\n        Args:\n            name: Template name.\n            config: Configuration.\n        \"\"\"\n        template = self.templates[name] = TemplateConfig(self, name, config)\n        template.run()\n\n    def clear(self):\n        \"\"\"Clear configuration.\"\"\"\n        self.networks = {}\n        self.groups = {}\n        self.targets = {}\n        self.templates = {}\n        self.meta = {}\n\n    def load(self, path: str):\n        \"\"\"Load configuration from a file.\n\n        Args:\n            path: File path.\n        \"\"\"\n        try:\n            d = yaml.safe_load(open(path, \"r\"))\n        except Exception as e:\n            print(f\"failed to load world file ({e})\")\n            raise\n\n        self.load_config(d)\n\n    def load_config(self, d: dict):\n        \"\"\"Load configuration from a dictionary.\n\n        Args:\n            d: Configuration.\n        \"\"\"\n        self.add_meta(d.get(\"meta\", {}))\n\n        for name, config in d.get(\"templates\", {}).items():\n            self.add_template(name, config)\n\n        for name, config in d.get(\"targets\", {}).items():\n            self.add_target(name, config)\n\n        for name, config in d.get(\"groups\", {}).items():\n            self.add_group(name, config)\n\n        for name, config in d.get(\"networks\", {}).items():\n            self.add_network(name, config)\n\n    def get_group(self, name: str) -> \"GroupConfig\":\n        \"\"\"Get group.\n\n        Args:\n            name: Group name.\n\n        Returns:\n            Group confguration object.\n        \"\"\"\n        return self.groups.get(name)\n\n    def get_groups(self) -> List[str]:\n        \"\"\"Get group names.\n\n        Returns:\n            List of group names.\n        \"\"\"\n        return self.groups.keys()\n\n    def get_meta(self, name: str) -> Any:\n        \"\"\"Get meta(data).\n\n        Args:\n            name: Metadata item name.\n\n        Returns:\n            Metadata item value.\n        \"\"\"\n        return self.meta.get(name)\n\n    def get_network(self, name: str) -> \"NetworkConfig\":\n        \"\"\"Get network configuration.\n\n        Args:\n            name: Network name.\n\n        Returns:\n            Network configuration object.\n        \"\"\"\n        return self.networks.get(name)\n\n    def get_networks(self) -> List[str]:\n        \"\"\"Get network names.\n\n        Returns:\n            List of network names.\n        \"\"\"\n        return self.networks.keys()\n\n    def get_target(self, name: str) -> \"TargetConfig\":\n        \"\"\"Get target.\n\n        Args:\n            name (str): Target name.\n\n        Returns:\n            Target configuration object.\n        \"\"\"\n        return self.targets.get(name)\n\n    def get_targets(self) -> List[str]:\n        \"\"\"Get target names.\n\n        Returns:\n            List of target names.\n        \"\"\"\n        return self.targets.keys()", "\n\nclass BaseConfig:\n    \"\"\"Base configuration.\n\n    Provides standard methods: `add`, `get`, `update`.\"\"\"\n\n    def __init__(self, world: \"WorldConfig\", name: str, config: Union[dict, None] = None):\n        \"\"\"Initialize.\n\n        Args:\n            world: World configuration object.\n            name: Configuration name.\n            config: Configuration.\n        \"\"\"\n        self.world = world\n        self.config = {\"name\": name}\n        if config:\n            for k, v in config.items():\n                self.add(k, v)\n\n    def add(self, k: Any, v: Any):\n        \"\"\"Add key+value.\n\n        Args:\n            k: Key.\n            v: Value.\n        \"\"\"\n        if k == \"targets\":\n            targets = listify_targets(v)\n            v = \" \".join(targets)\n        self.config[k] = v\n\n    def get(self, k: Any, default: Any = None) -> Any:\n        \"\"\"Get value for key.\n\n        Args:\n            k: Key.\n            default: Default value if key is not found.\n\n        Returns:\n            Value for key.\n        \"\"\"\n        return self.config.get(k, default)\n\n    def update(self, config: dict):\n        \"\"\"Update configuration.\n\n        Args:\n            config: Configuration.\n        \"\"\"\n        self.config.update(config)", "\n\nclass GroupConfig(BaseConfig):\n    \"\"\"Group configuration.\"\"\"\n\n    def __repr__(self):\n        return f\"<GroupConfig name={self.config['name']} config={self.config}>\"\n\n    def get_targets(self) -> List[\"TargetConfig\"]:\n        \"\"\"Get target configuration objects.\n\n        Returns:\n            List of Target configuration objects.\n        \"\"\"\n        targets = []\n        for target in listify_targets(self.config.get(\"targets\", \"\")):\n            targets.extend(target)\n        return targets", "\n\nclass NetworkConfig(BaseConfig):\n    \"\"\"Network configuration.\"\"\"\n\n    def __repr__(self):\n        return f\"<NetworkConfig name={self.config['name']} config={self.config}>\"\n\n    def get_targets(self) -> List[\"TargetConfig\"]:\n        \"\"\"Get target configuration objects.\n\n        Returns:\n            List of Target configuration objects.\n        \"\"\"\n        targets = []\n        for target in listify_targets(self.config.get(\"targets\", \"\")):\n            if target.startswith(\"@\"):\n                group = self.world.groups.get(target[1:])\n                if group:\n                    targets.extend(group.get_targets())\n            else:\n                targets.append(target)\n        return targets", "\n\nclass TargetConfig(BaseConfig):\n    \"\"\"Target configuration.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize.\"\"\"\n        super().__init__(*args, **kwargs)\n        self.config[\"host\"] = self.config.get(\"host\", self.config.get(\"name\"))\n\n    def __repr__(self):\n        return f\"<TargetConfig name={self.config['name']} config={self.config}>\"", "\n\nclass TemplateConfig(BaseConfig):\n    \"\"\"Template configuration.\"\"\"\n\n    def run(self):\n        \"\"\"Add target configurations based on template.\n\n        Automatic substitution for `$target` is done for`host`,\n        `machine-id` with target name.\n        \"\"\"\n        targets = self.config.get(\"targets\")\n        for name in listify_targets(targets):\n            config = copy.deepcopy(self.config)\n            config[\"name\"] = name\n            if config.get(\"host\") == \"$target\":\n                config[\"host\"] = name\n            if config.get(\"machine-id\") == \"$target\":\n                config[\"machine-id\"] = name\n            config.pop(\"targets\")\n            self.world.add_target(name, config)", ""]}
{"filename": "src/client/penvm/client/machine.py", "chunked_list": ["#\n# penvm/client/machine.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport importlib\nimport logging\nimport threading\nimport traceback\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.client.session import Session", "\nfrom penvm.client.session import Session\nfrom penvm.lib.base import BaseObject\nfrom penvm.lib.connection import ClientConnection\nfrom penvm.lib.misc import MachineConnectionSpec\nfrom penvm.lib.mqueue import MessageQueue\nfrom penvm.lib.queue import RoutingQueue\n\nlogger = logging.getLogger(__name__)\n", "logger = logging.getLogger(__name__)\n\n\nclass Machine(BaseObject):\n    \"\"\"Client-side representation of a server-side machine.\"\"\"\n\n    def __init__(\n        self,\n        host: str,\n        port: int,\n        sslprofile: Union[str, None] = None,\n        machineid: Union[str, None] = None,\n    ):\n        \"\"\"Initialize.\n\n        Set up client-side machine representation.\n\n        Args:\n            host: Host address.\n            port: Port.\n            sslprofile: SSL profile for SSL context.\n            machineid: Machine id. Generated if not provided.\n        \"\"\"\n        try:\n            super().__init__(machineid, logger)\n            tlogger = self.logger.enter()\n\n            self.sslprofile = sslprofile\n            self.sslcontext = self.get_sslcontext(self.sslprofile)\n\n            self.conn = ClientConnection(self, host, port, self.sslcontext)\n            self.conn.connect()\n            # time.sleep(0.5)\n            self.conn.start()\n\n            self.exit = False\n\n            self.imq = RoutingQueue(put=self.imq_put)\n            if self.conn:\n                self.omq = RoutingQueue(put=self.omq_put)\n            else:\n                # for testing without a connection\n                self.omq = MessageQueue()\n\n            self.lock = threading.Lock()\n            self.kernels = {}\n            self.sessions = {}\n\n            # standard kernels\n            self.load_kernel(\"core\", \"penvm.kernels.core\")\n            self.load_kernel(\"default\", \"penvm.kernels.default\")\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def __repr__(self):\n        return f\"<Machine id={self.oid} conn={self.conn} nsessions={len(self.sessions)}>\"\n\n    def get_debug_session(self, sessionid: str = None) -> \"Session\":\n        \"\"\"Get debug-specific session.\n\n        Debug sessions (should) start with \"-debug-\". They are treated\n        specially by machines: they are not subject to the debug mode.\n\n        Args:\n            sessionid: Session id (suffix) for a debug session.\n\n        Returns:\n            Session for debugging.\n        \"\"\"\n        return self.get_session(\"\"\"-debug-{sessionid or \"\"}\"\"\")\n\n    def get_kernel_class(self, kernel_name: str) -> Type[\"KernelClient\"]:\n        \"\"\"Get kernel client class.\n\n        Args:\n            kernel_name: Kernel name.\n\n        Returns:\n            Kernel client class for `kernel_name`.\n        \"\"\"\n        return self.kernels.get(kernel_name)\n\n    def get_machconnspec(self) -> MachineConnectionSpec:\n        \"\"\"Get `MachineConnectionSpec` object for this machine.\n\n        Returns:\n            `MachineConnectionSpec` of object for this machine.\n        \"\"\"\n        return MachineConnectionSpec(machine=self)\n\n    def get_machconnstr(self) -> str:\n        \"\"\"Get machine connection string for this machine.\n\n        Returns:\n            Machine connection string.\n        \"\"\"\n        return str(self.get_machconnspec())\n\n    def get_session(\n        self, sessionid: Union[str, None] = None, kernelname: str = \"default\"\n    ) -> \"Session\":\n        \"\"\"Get session.\n\n        Args:\n            sessionid: Session id. Generated if not provided.\n            kernelname: Kernel name.\n\n        Returns:\n            New `Session` for `sessionid` and `kernelname`.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n            tlogger.debug(f\"getting session for sessionid={sessionid}\")\n\n            # lock\n            self.lock.acquire()\n            try:\n                kernelcls = self.get_kernel_class(kernelname)\n                if kernelcls == None:\n                    tlogger.debug(f\"kernel ({kernelname}) not found\")\n                    return\n\n                session = self.sessions.get(sessionid) if sessionid != None else None\n                if session == None:\n                    session = Session(self, sessionid, kernelcls)\n                    session = self.sessions.setdefault(session.oid, session)\n            finally:\n                self.lock.release()\n            return session\n        finally:\n            tlogger.exit()\n\n    def get_sslcontext(self, sslprofile: str) -> \"SSLContext\":\n        \"\"\"Load client-side SSLContext based on named ssl profile.\n\n        Args:\n            sslprofile (str): SSL profile name.\n\n        Returns:\n            `SSLContext` for ssl profile.\n        \"\"\"\n        if sslprofile:\n            try:\n                import ssl\n\n                sslcontext = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n                sslcontext.check_hostname = False\n                sslcontext.verify_mode = ssl.CERT_NONE\n                return sslcontext\n            except Exception as e:\n                logger.debug(f\"ssl required but missing for ssl profile ({sslprofile})\")\n                raise Exception(f\"ssl required but missing for ssl profile ({sslprofile})\")\n\n    def imq_put(self, msg: \"Message\"):\n        \"\"\"Put a message on the IMQ.\n\n        Args:\n            msg: Message object.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n\n            sessionid = msg.header.get(\"session-id\")\n\n            tlogger.debug(f\"imq_put sessionid={sessionid}\")\n            sess = self.sessions.get(sessionid)\n            if sess:\n                sess.imq.put(msg)\n            else:\n                # DROP!\n                tlogger.debug(\"imp_put dropping message\")\n        finally:\n            tlogger.exit()\n\n    def list_kernels(self) -> List[str]:\n        \"\"\"Get list of kernel names.\n\n        Returns:\n            List of kernel names.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n            return list(self.kernels.keys())\n        finally:\n            tlogger.exit()\n\n    def load_assets(self, assets):\n        \"\"\"Load/copy assets to the machines.\n\n        NIY.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n        finally:\n            tlogger.exit()\n\n    def load_kernel(self, kernel_name: str, pkgname: str) -> \"KernelClient\":\n        \"\"\"Load/copy kernel to the machine.\n\n        Kernel support is provided as:\n\n        ```\n            <pkg>/\n              client.py\n                KernelClient\n              server.py\n                Kernel\n        ```\n\n        Args:\n            kernel_name: Kernel name.\n            pkgname: Package name (as a string).\n\n        Returns:\n            Kernel client class.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n            if kernel_name in self.kernels:\n                # TODO: test? allow overwrite for now?\n                pass\n\n            try:\n                mod = importlib.import_module(\".client\", pkgname)\n                cls = getattr(mod, \"KernelClient\")\n                self.kernels[kernel_name] = cls\n            except Exception as e:\n                pass\n\n            # TODO: send kernel to machine (server side)\n            return cls\n        finally:\n            tlogger.exit()\n\n    def omq_put(self, msg: \"Message\"):\n        \"\"\"Put a message on the OMQ.\n\n        Args:\n            msg: Message to enqueue.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n            self.conn.omq.put(msg)\n        finally:\n            tlogger.exit()\n\n    def start(self):\n        \"\"\"Start machine.\"\"\"\n        try:\n            tlogger = self.logger.enter()\n            if 0 and self.conn:\n                self.conn.connect()\n                self.conn.start()\n        finally:\n            tlogger.exit()\n\n    def stop(self):\n        \"\"\"Stop machine.\n\n        Set `exit` attribute to signal machine should exit.\n        \"\"\"\n        try:\n            tlogger = self.logger.enter()\n            self.exit = True\n        finally:\n            tlogger.exit()", ""]}
{"filename": "src/client/penvm/client/session.py", "chunked_list": ["#\n# penvm/client/session.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"A client-side session is used to interact with a machine. Each\nsession has its own unique session id, specified on the client side.\nAny number of concurrent sessions are supported, subject to resource\nlimits.\n\nEach client-side session has its own incoming and outgoing message\nqueues (not the same as those on the server side but related). All", "Each client-side session has its own incoming and outgoing message\nqueues (not the same as those on the server side but related). All\ncommunication is mediated with these message queues with forwarding\nto and from handle automatically (see\n[penvm.lib.connection][]).\n\nConvenience methods are provided for interacting at a high level\nwith the message queues (e.g., `Session.get_response()`).\n\nEach client-side session is set up with access to a selected,", "\nEach client-side session is set up with access to a selected,\nsession-specific, client-side kernel interface. Although not\nabsolutely required, this interface is highly recommended to provide\na function-style interface rather than having to build a `Request`\nmessage.\n\nSee [penvm.server.session][] for details.\n\"\"\"\n", "\"\"\"\n\nimport logging\nfrom pathlib import Path\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.lib.base import BaseObject\nfrom penvm.lib.message import Request\nfrom penvm.lib.mqueue import MessageQueue\n", "from penvm.lib.mqueue import MessageQueue\n\nlogger = logging.getLogger(__name__)\n\n\nclass Session(BaseObject):\n    \"\"\"Client-side session object.\n\n    Provides unique sessionid and access to client-side machine services.\n\n    Low-level methods return the request object. This allows for tracking and\n    followup of a session.\n\n    High-level methods return None.\n    \"\"\"\n\n    def __init__(\n        self,\n        machine: \"Machine\",\n        sessionid: Union[str, None] = None,\n        kernelcls: Type[\"KernelClient\"] = None,\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            machine: Machine owning this session.\n            sessionid: Session id.\n            kernelcls: `KernelClient` class.\n        \"\"\"\n        try:\n            super().__init__(sessionid, logger)\n            tlogger = self.logger.enter()\n\n            self.machine = machine\n            self.imq = MessageQueue()\n            self.kernel = kernelcls(self)\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def __repr__(self):\n        return f\"<Session id={self.oid} machine={self.machine}>\"\n\n    def get_response(self) -> \"Message\":\n        \"\"\"Pull (from remote) and pop from local and return.\n\n        Returns:\n            Response message.\n        \"\"\"\n        self.pull_response()\n        return self.pop_response()\n\n    def new_request(self, op: str, d: Union[dict, None] = None) -> \"Message\":\n        \"\"\"Return session-specific Request object with `op`.\n\n        Args:\n            op: Operation name.\n            d: Request payload settings.\n\n        Returns:\n            Created request.\n        \"\"\"\n        req = Request()\n        req.header[\"session-id\"] = self.oid\n        req.payload[\"op\"] = op\n        if d != None:\n            req.payload.update(d)\n        return req\n\n    def newput_request(self, op: str, d: Union[dict, None] = None) -> \"Message\":\n        \"\"\"Create request and *put it out* to be sent.\n\n        Args:\n            op: Operation name.\n            d: Request payload settings.\n\n        Returns:\n            Created request.\n        \"\"\"\n        req = self.new_request(op, d)\n        return self.put_request(req)\n\n    def pop_response(self) -> \"Message\":\n        \"\"\"Pop response from local and return.\n\n        Returns:\n            Response message.\n        \"\"\"\n        return self.imq.pop()\n\n    def pull_response(self, sessionid: Union[str, None] = None):\n        \"\"\"Pull (pop from remote to local) response.\n\n        Args:\n            sessionid: Session id.\n        \"\"\"\n        self.kernel.session_pop_omq(sessionid)\n\n    def put_request(self, req: \"Message\") -> \"Message\":\n        \"\"\"Put the request on the machine OMQ. Return it, also.\n\n        Args:\n            req: Request message.\n\n        Returns:\n            The Request message, itself.\n        \"\"\"\n        self.machine.omq.put(req)\n        return req", ""]}
{"filename": "src/kernels/penvm/kernels/base/client.py", "chunked_list": ["#\n# penvm/kernels/base/client.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Client-side base kernel support.\"\"\"\n\nimport logging\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.lib.base import BaseObject\n", "from penvm.lib.base import BaseObject\n\nlogger = logging.getLogger(__name__)\n\n\nclass KernelClient(BaseObject):\n    \"\"\"Base kernel client.\n\n    Provides name/oid and logger setup.\n    \"\"\"\n\n    name = \"base\"\n\n    def __init__(\n        self,\n        session: \"Session\",\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            session: Owning session.\n        \"\"\"\n        try:\n            super().__init__(self.name, logger)\n            tlogger = self.logger.enter()\n\n            self.session = session\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def __repr__(self):\n        return f\"<KernelClient name={self.name}>\"", ""]}
{"filename": "src/kernels/penvm/kernels/base/__init__.py", "chunked_list": ["# blocks changes to this package\n"]}
{"filename": "src/kernels/penvm/kernels/base/server.py", "chunked_list": ["#\n# penvm/kernels/base/server.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Server-side base Kernel, Op, and OpContext support.\"\"\"\n\nimport importlib.util\nimport logging\nimport time\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n", "from typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.lib.base import BaseObject\nfrom penvm.lib.misc import State\nfrom penvm.lib.message import Message\n\nlogger = logging.getLogger(__name__)\n\n\nclass Kernel(BaseObject):\n    \"\"\"Base kernel.\n\n    Provides base functionality for working with the kernel.\n    \"\"\"\n\n    name = \"base\"\n\n    def __init__(self):\n        \"\"\"Initialize.\"\"\"\n        try:\n            super().__init__(self.name, logger)\n            tlogger = self.logger.enter()\n\n            self.updated = False\n            self.ops = {}\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def copy(self):\n        \"\"\"Deep copy of this kernel.\"\"\"\n        return copy.deepcopy(self)\n\n    def get_bases(self):\n        \"\"\"Bases (MRO) for kernel.\"\"\"\n        return self.__class__.__mro__\n\n    def list(self):\n        \"\"\"List operation names.\"\"\"\n        return list(self.ops.keys())\n\n    def register(\n        self,\n        opname: str,\n        op: \"Op\",\n    ):\n        \"\"\"Register operation.\n\n        Args:\n            opname: Operation name.\n            op: Op reference.\n        \"\"\"\n        self.updated = True\n        self.ops[opname] = op\n\n    def register_code(\n        self,\n        opname: str,\n        opclassname: str,\n        code: str,\n    ):\n        \"\"\"Register an op by code (in a string).\n\n        Args:\n            opname: Operation name.\n            opclassname: Class name in code snippet.\n            code: Code snippet.\n        \"\"\"\n        try:\n            spec = importlib.util.spec_from_loader(\"ext\", loader=None)\n            ext = importlib.util.module_from_spec(spec)\n            exec(code, ext.__dict__)\n\n            cls = getattr(ext, opclassname)\n            if cls:\n                op = cls()\n                if hasattr(op, \"run\"):\n                    self.ops[opname] = cls()\n                    self.logger.debug(f\"ops ({list(self.ops.keys())} {cls=}\")\n                    self.logger.debug(\"register code succeeded\")\n                else:\n                    self.logger.debug(\"register class has no run method\")\n            else:\n                self.logger.debug(f\"class {opclassname} not found in code\")\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION register code failed {e}\")\n\n    def run(\n        self,\n        opname: str,\n        ctxt: \"OpContext\",\n        req: \"Message\",\n    ):\n        \"\"\"Run the op for `opname`.\n\n        As a *convenience*, a response return value is put into the\n        `session.omq`.\n\n        Args:\n            opname: Operation to run, referenced by name.\n            ctxt: Context to provide operation.\n            req: Request message to provide operation.\n        \"\"\"\n        t0 = time.time()\n        resp = self.run_local(opname, ctxt, req)\n        if isinstance(resp, Message):\n            t1 = time.time()\n            resp.payload[\"-oprun-elapsed\"] = t1 - t0\n            ctxt.session.omq.put(resp)\n        else:\n            if opname not in self.ops:\n                self.logger.error(f\"run opname={opname} not found\")\n            else:\n                # TODO: why is this here? a non-responding op is ok!\n                self.logger.error(f\"run opname={opname} did not succeed\")\n\n    def run_local(\n        self,\n        opname: str,\n        ctxt: \"OpContext\",\n        req: \"Message\",\n    ) -> \"Message\":\n        \"\"\"Run the op for `opname` and return result.\n\n        Suitable for local use.\n\n        Args:\n            opname: See [penvm.kernels.base.server.Kernel.run][].\n            ctxt: See [penvm.kernels.base.server.Kernel.run][].\n            req: See [penvm.kernels.base.server.Kernel.run][].\n\n        Returns:\n            Response (if generated).\n        \"\"\"\n        op = self.ops.get(opname)\n        if op:\n            return op.run(ctxt, req)\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            opnames = sorted(list(self.ops.keys()))\n            return State(\n                \"kernel\",\n                self.name,\n                {\n                    \"bases\": [getattr(cls, \"name\") for cls in self.get_bases() if cls != object],\n                    \"nops\": len(opnames),\n                    \"ops\": opnames,\n                    \"updated\": self.updated,\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n\n    def unregister(self, opname: str):\n        \"\"\"Unregister operation.\n\n        Args:\n            opname: Operation name.\n        \"\"\"\n        try:\n            del self.ops[opname]\n        except Exception as e:\n            pass", "\nclass Kernel(BaseObject):\n    \"\"\"Base kernel.\n\n    Provides base functionality for working with the kernel.\n    \"\"\"\n\n    name = \"base\"\n\n    def __init__(self):\n        \"\"\"Initialize.\"\"\"\n        try:\n            super().__init__(self.name, logger)\n            tlogger = self.logger.enter()\n\n            self.updated = False\n            self.ops = {}\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n        finally:\n            tlogger.exit()\n\n    def copy(self):\n        \"\"\"Deep copy of this kernel.\"\"\"\n        return copy.deepcopy(self)\n\n    def get_bases(self):\n        \"\"\"Bases (MRO) for kernel.\"\"\"\n        return self.__class__.__mro__\n\n    def list(self):\n        \"\"\"List operation names.\"\"\"\n        return list(self.ops.keys())\n\n    def register(\n        self,\n        opname: str,\n        op: \"Op\",\n    ):\n        \"\"\"Register operation.\n\n        Args:\n            opname: Operation name.\n            op: Op reference.\n        \"\"\"\n        self.updated = True\n        self.ops[opname] = op\n\n    def register_code(\n        self,\n        opname: str,\n        opclassname: str,\n        code: str,\n    ):\n        \"\"\"Register an op by code (in a string).\n\n        Args:\n            opname: Operation name.\n            opclassname: Class name in code snippet.\n            code: Code snippet.\n        \"\"\"\n        try:\n            spec = importlib.util.spec_from_loader(\"ext\", loader=None)\n            ext = importlib.util.module_from_spec(spec)\n            exec(code, ext.__dict__)\n\n            cls = getattr(ext, opclassname)\n            if cls:\n                op = cls()\n                if hasattr(op, \"run\"):\n                    self.ops[opname] = cls()\n                    self.logger.debug(f\"ops ({list(self.ops.keys())} {cls=}\")\n                    self.logger.debug(\"register code succeeded\")\n                else:\n                    self.logger.debug(\"register class has no run method\")\n            else:\n                self.logger.debug(f\"class {opclassname} not found in code\")\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION register code failed {e}\")\n\n    def run(\n        self,\n        opname: str,\n        ctxt: \"OpContext\",\n        req: \"Message\",\n    ):\n        \"\"\"Run the op for `opname`.\n\n        As a *convenience*, a response return value is put into the\n        `session.omq`.\n\n        Args:\n            opname: Operation to run, referenced by name.\n            ctxt: Context to provide operation.\n            req: Request message to provide operation.\n        \"\"\"\n        t0 = time.time()\n        resp = self.run_local(opname, ctxt, req)\n        if isinstance(resp, Message):\n            t1 = time.time()\n            resp.payload[\"-oprun-elapsed\"] = t1 - t0\n            ctxt.session.omq.put(resp)\n        else:\n            if opname not in self.ops:\n                self.logger.error(f\"run opname={opname} not found\")\n            else:\n                # TODO: why is this here? a non-responding op is ok!\n                self.logger.error(f\"run opname={opname} did not succeed\")\n\n    def run_local(\n        self,\n        opname: str,\n        ctxt: \"OpContext\",\n        req: \"Message\",\n    ) -> \"Message\":\n        \"\"\"Run the op for `opname` and return result.\n\n        Suitable for local use.\n\n        Args:\n            opname: See [penvm.kernels.base.server.Kernel.run][].\n            ctxt: See [penvm.kernels.base.server.Kernel.run][].\n            req: See [penvm.kernels.base.server.Kernel.run][].\n\n        Returns:\n            Response (if generated).\n        \"\"\"\n        op = self.ops.get(opname)\n        if op:\n            return op.run(ctxt, req)\n\n    def state(self) -> \"State\":\n        \"\"\"Get object state.\n\n        Returns:\n            `State` object.\n        \"\"\"\n        try:\n            opnames = sorted(list(self.ops.keys()))\n            return State(\n                \"kernel\",\n                self.name,\n                {\n                    \"bases\": [getattr(cls, \"name\") for cls in self.get_bases() if cls != object],\n                    \"nops\": len(opnames),\n                    \"ops\": opnames,\n                    \"updated\": self.updated,\n                },\n            )\n        except Exception as e:\n            self.logger.warning(f\"EXCEPTION ({e})\")\n\n    def unregister(self, opname: str):\n        \"\"\"Unregister operation.\n\n        Args:\n            opname: Operation name.\n        \"\"\"\n        try:\n            del self.ops[opname]\n        except Exception as e:\n            pass", "\n\nclass Op(BaseObject):\n    \"\"\"Encapsulates functionality for an operation.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize.\"\"\"\n        super().__init__(None, logger)\n\n    def run(self, req: \"Message\"):\n        \"\"\"Run method.\"\"\"\n        pass", "\n\nclass OpContext:\n    \"\"\"Context to run operation.\n\n    Provides an easy way for an operation to access important and\n    necessary objects and information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize.\"\"\"\n        self.conn = None\n        self.machine = None\n        self.processor = None\n        self.session = None", ""]}
{"filename": "src/kernels/penvm/kernels/core/client.py", "chunked_list": ["#\n# penvm/kernels/core/client.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Client-side interface to access the \"core\" kernel operations.\n\nSee [penvm.kernels.core.server][].\"\"\"\n\nimport logging\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n", "from typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.kernels.base.client import KernelClient as _KernelClient\n\nlogger = logging.getLogger(__name__)\n\n\nclass KernelClient(_KernelClient):\n    name = \"core\"\n\n    def connection_get_state(self, connectionid):\n        \"\"\"See [penvm.kernels.core.server.ConnectionGetState][].\"\"\"\n        d = {\n            \"connection-id\": connectionid,\n        }\n        return self.session.newput_request(\"connection-get-info\", d)\n\n    def echo(self, d):\n        \"\"\"See [penvm.kernels.core.server.Echo][].\"\"\"\n        return self.session.newput_request(\"echo\", d)\n\n    def kernel_add(self, kernelname, kernelsrc):\n        \"\"\"See [penvm.kernels.core.server.KernelAdd][].\"\"\"\n        d = {\n            \"kernel\": kernelname,\n            \"source\": kernelsrc,\n        }\n        return self.session.newput_request(\"kernel-add\", d)\n\n    def kernel_copy(self, src_kernelname, dst_kernelname):\n        \"\"\"See [penvm.kernels.core.server.KernelCopy][].\"\"\"\n        d = {\n            \"src-kernel\": src_kernelname,\n            \"dst-kernel\": dst_kernelname,\n        }\n        return self.session.newput_request(\"kernel-copy\", d)\n\n    def kernel_drop(self, kernelname):\n        \"\"\"See [penvm.kernels.core.server.KernelDrop][].\"\"\"\n        d = {\n            \"kernel\": kernelname,\n        }\n        return self.session.newput_request(\"kernel-drop\", d)\n\n    def kernel_get_state(self, kernelname):\n        \"\"\"See [penvm.kernels.core.server.KernelGetState][].\"\"\"\n        d = {\n            \"kernel\": kernelname,\n        }\n        return self.session.newput_request(\"kernel-get-state\", d)\n\n    def kernel_list_ops(self, kernelname):\n        \"\"\"See [penvm.kernels.core.server.KernelListOps][].\"\"\"\n        d = {\n            \"kernel\": kernelname,\n        }\n        return self.session.newput_request(\"kernel-list-ops\", d)\n\n    def kernel_register_op(\n        self,\n        kernelname,\n        opname,\n        opclassname,\n        code,\n        code_key=None,\n    ):\n        \"\"\"See [penvm.kernels.core.server.KernelRegisterOp][].\"\"\"\n        d = {\n            \"code\": code,\n            \"kernel\": kernelname,\n            \"new-op\": opname,\n            \"op-class\": opclassname,\n        }\n        if code_key:\n            d[\"code-key\"] = code_key\n        return self.session.newput_request(\"kernel-register-op\", d)\n\n    def kernel_unregister_op(\n        self,\n        kernelname,\n        opname,\n    ):\n        \"\"\"See [penvm.kernels.core.server.KernelUnregisterOp][].\"\"\"\n        d = {\n            \"kernel\": kernelname,\n            \"old-op\": opname,\n        }\n        return self.session.newput_request(\"kernel-unregister-op\", d)\n\n    def machine_disable_debug(self):\n        \"\"\"See [penvm.kernels.core.server.MachineDisableDebug][].\"\"\"\n        # TODO: should this force sessionid to \"debug\"?\n        return self.session.newput_request(\"machine-enable-debug\")\n\n    def machine_drop_session(self, sessionid=None):\n        \"\"\"See [penvm.kernels.core.server.MachineDropSession][].\"\"\"\n        d = {}\n        if sessionid:\n            d[\"session-id\"] = sessionid\n        return self.session.newput_request(\"machine-drop-session\", d)\n\n    def machine_enable_debug(self):\n        \"\"\"See [penvm.kernels.core.server.MachineEnableDebug][].\"\"\"\n        # TODO: should this force sessionid to \"debug\"?\n        return self.session.newput_request(\"machine-enable-debug\")\n\n    def machine_get_features(self):\n        \"\"\"See [penvm.kernels.core.server.MachineGetFeatures][].\"\"\"\n        return self.session.newput_request(\"machine-get-features\")\n\n    def machine_get_state(self):\n        \"\"\"See [penvm.kernels.core.server.MachineGetState][].\"\"\"\n        return self.session.newput_request(\"machine-get-state\")\n\n    def machine_list_kernels(self):\n        \"\"\"See [penvm.kernels.core.server.MachineListKernels][].\"\"\"\n        return self.session.newput_request(\"machine-list-kernels\")\n\n    def machine_list_sessions(self):\n        \"\"\"See [penvm.kernels.core.server.MachineListSessions][].\"\"\"\n        return self.session.newput_request(\"machine-list-sessions\")\n\n    def machine_shutdown(self):\n        \"\"\"See [penvm.kernels.core.server.MachineShutdown][].\"\"\"\n        return self.session.newput_request(\"machine-shutdown\")\n\n    def machine_snapshot(self):\n        \"\"\"See [penvm.kernels.core.server.MachineSnapshot][].\"\"\"\n        return self.session.newput_request(\"machine-snapshot\")\n\n    def machine_step_debug(self):\n        \"\"\"See [penvm.kernels.core.server.MachineStepDebug][].\"\"\"\n        # TODO: should this force sessionid to \"debug\"?\n        return self.session.newput_request(\"machine-step-debug\")\n\n    def session_drop_request(self, reqid, sessionid=None):\n        \"\"\"See [penvm.kernels.core.server.SessionDropRequest][].\"\"\"\n        d = {\n            \"request-id\": reqid,\n        }\n        if sessionid:\n            d[\"session-id\"] = sessionid\n        return self.session.newput_request(\"session-drop-request\", d)\n\n    def session_get_message_state(self, msgid, msgqueue, sessionid=None):\n        \"\"\"See [penvm.kernels.core.server.SessionGetMessageState][].\"\"\"\n        d = {\n            \"message-id\": msgid,\n            \"message-queue\": msgqueue,\n        }\n        if sessionid:\n            d[\"session-id\"] = sessionid\n        return self.session.newput_request(\"session-get-message-state\", d)\n\n    def session_get_processor_state(self, sessionid=None):\n        \"\"\"See [penvm.kernels.core.server.SessionGetProcessorState][].\"\"\"\n        d = {}\n        if sessionid:\n            d[\"session-id\"] = sessionid\n        return self.session.newput_request(\"session-get-processor-state\", d)\n\n    def session_get_state(self, sessionid=None):\n        \"\"\"See [penvm.kernels.core.server.SessionGetState][].\"\"\"\n        d = {}\n        if sessionid:\n            d[\"session-id\"] = sessionid\n        return self.session.newput_request(\"session-get-state\", d)\n\n    def session_pin_session(self, sessionid=None):\n        \"\"\"See [penvm.kernels.core.server.SessionPinSession][].\"\"\"\n        d = {}\n        if sessionid:\n            d[\"session-id\"] = sessionid\n        return self.session.newput_request(\"session-pin-session\", d)\n\n    def session_pop_omq(self, sessionid=None, count=1):\n        \"\"\"See [penvm.kernels.core.server.SessionPopOmq][].\"\"\"\n        d = {\n            \"count\": count,\n        }\n        if sessionid != None:\n            d[\"session-id\"] = sessionid\n        return self.session.newput_request(\"session-pop-omq\", d)\n\n    def session_set_max_threads(self, nthreads, sessionid=None):\n        \"\"\"See [penvm.kernels.core.server.SessionSetMaxThreads][].\"\"\"\n        d = {\n            \"nthreads\": nthreads,\n        }\n        if sessionid:\n            d[\"session-id\"] = sessionid\n        return self.session.newput_request(\"session-set-max-threads\", d)\n\n    def session_terminate_request(self, reqid, sessionid=None):\n        \"\"\"See [penvm.kernels.core.server.SessionTerminateRequest][].\"\"\"\n        d = {\n            \"request-id\": reqid,\n        }\n        if sessionid:\n            d[\"session-id\"] = sessionid\n        return self.session.newput_request(\"session-terminate-request\", d)\n\n    def session_unpin_session(self, sessionid=None):\n        \"\"\"See [penvm.kernels.core.server.SessionUnpinSession][].\"\"\"\n        d = {}\n        if sessionid:\n            d[\"session-id\"] = sessionid\n        return self.session.newput_request(\"session-unpin-session\", d)\n\n    def session_use_kernel(self, kernelname, sessionid=None):\n        \"\"\"See [penvm.kernels.core.server.SessionUseKernel][].\"\"\"\n        d = {\n            \"kernel\": kernelname,\n        }\n        if sessionid:\n            d[\"session-id\"] = sessionid\n        return self.session.newput_request(\"session-use-kernel\", d)\n\n    def sleep(self, seconds):\n        \"\"\"See [penvm.kernels.core.server.Sleep][].\"\"\"\n        d = {\n            \"seconds\": seconds,\n        }\n        return self.session.newput_request(\"sleep\", d)", ""]}
{"filename": "src/kernels/penvm/kernels/core/__init__.py", "chunked_list": ["# blocks changes to this package\n"]}
{"filename": "src/kernels/penvm/kernels/core/server.py", "chunked_list": ["#\n# penvm/kernels/core/server.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Server-side \"core\" kernel operations.\n\nThe core operations provide the necessary functionality on which to\nbuild others.\n\nAll kernel operations use messages to receive and replay. Convenience\nfunctions are available:", "All kernel operations use messages to receive and replay. Convenience\nfunctions are available:\n\n* request: `Request`\n* response: `Response`, `OkResponse`, `ErrorResponse`\n\nWhen a `Request` or `Response` is unused/empty, this is reflected in\nthe respective attributes section.\n\nWhereas only one `Request` possible, responses may be `OkResponse` or", "\nWhereas only one `Request` possible, responses may be `OkResponse` or\n`ErrorResponse`. Both may be described to account for possible\nresponses according to the situation.\n\nThe `OkResponse` indicates success and contains response information\nin its payload. The `ErrorResponse` indicates an error (or failure)\nand contains an error messsage in its payload (`-message` field).\"\"\"\n\nfrom importlib.machinery import SourceFileLoader", "\nfrom importlib.machinery import SourceFileLoader\nimport logging\nimport sys\nimport tempfile\nimport time\nimport traceback\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\n", "\n\nfrom penvm.kernels.base.server import Kernel as _Kernel, Op\nfrom penvm.lib.message import ErrorResponse, OkResponse, Payload, Request\nfrom penvm.lib.thread import ThreadInterrupt\n\nlogger = logging.getLogger(__name__)\n\n\nclass ConnectionGetState(Op):\n    \"\"\"Get connection info.\n\n    Attributes: Request:\n        connection-id (str): Connection id.\n\n    Attributes: OkResponse:\n        connection-id (str): Connection id.\n        initial-connection (str): Is initial machine connection.\n        host (str): Connection host name.\n        port (int): Connection port.\n        peer-host (str): Client/peer host name.\n        peer-port (int): Client/peer port.\n        nimq (int): Number of IMQ messages.\n        nomq (int): Number of OMQ messages.\n\n    Attributes: ErrorResponse:\n        -: Error message.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n            connid = req.payload.get(\"connection-id\")\n            conn = ctxt.machine.connmgr.get(connid)\n\n            if conn != None:\n                return OkResponse(\n                    payload=Payload(conn.state()),\n                    refmsg=req,\n                )\n            else:\n                raise Exception(\"bad connection\")\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                \"connection not found\",\n                refmsg=req,\n            )", "\nclass ConnectionGetState(Op):\n    \"\"\"Get connection info.\n\n    Attributes: Request:\n        connection-id (str): Connection id.\n\n    Attributes: OkResponse:\n        connection-id (str): Connection id.\n        initial-connection (str): Is initial machine connection.\n        host (str): Connection host name.\n        port (int): Connection port.\n        peer-host (str): Client/peer host name.\n        peer-port (int): Client/peer port.\n        nimq (int): Number of IMQ messages.\n        nomq (int): Number of OMQ messages.\n\n    Attributes: ErrorResponse:\n        -: Error message.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n            connid = req.payload.get(\"connection-id\")\n            conn = ctxt.machine.connmgr.get(connid)\n\n            if conn != None:\n                return OkResponse(\n                    payload=Payload(conn.state()),\n                    refmsg=req,\n                )\n            else:\n                raise Exception(\"bad connection\")\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                \"connection not found\",\n                refmsg=req,\n            )", "\n\nclass Echo(Op):\n    \"\"\"Echo request payload.\n\n    Attributes: Request:\n        -: Unused.\n\n    Attributes: OkResponse:\n        -: Matches request payload.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            resp = OkResponse(\n                payload=req.payload,\n                refmsg=req,\n            )\n            return resp\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass Log(Op):\n    def run(self, ctxt, req):\n        try:\n            with open(\"/tmp/log\", \"a\") as f:\n                f.write(\"%s\\n\" % req.payload.get(\"text\", \"n/a\"))\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n", "\n\nclass KernelAdd(Op):\n    \"\"\"Add a new kernel.\n\n    Attributes: Request:\n        kernel (str): Name of the kernel.\n        data (str): Kernel file.\n\n    Attributes: Response:\n        -: None.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n            kernel_name = req.payload.get(\"kernel\")\n            kernel_source = req.payload.get(\"source\")\n\n            if None in [kernel_name, kernel_source]:\n                return\n\n            try:\n                with tempfile.NamedTemporaryFile() as f:\n                    f.write(kernel_source.encode(\"utf-8\"))\n                    f.seek(0)\n                    mod = SourceFileLoader(\"\", f.name).load_module()\n                ctxt.machine.kernelmgr.set(kernel_name, mod.Kernel())\n                self.logger.info(f\"completed ({kernel_name})\")\n            except Exception as e:\n                self.logger.critical(f\"EXCEPTION ({e})\")\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass KernelCopy(Op):\n    \"\"\"Make a copy of an existing kernel.\n\n    Attributes: Request:\n        dst-kernel (str): Name of destination kernel.\n        src-kernel (str): Name of source kernel.\n\n    Attributes: Response:\n        -: None.\n    \"\"\"\n\n    # TODO: what kind of return value if any?\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n            src_kernelname = req.payload.get(\"src-kernel\")\n            dst_kernelname = req.payload.get(\"dst-kernel\")\n            if None in [src_kernelname, dst_kernelname]:\n                return\n\n            src_kernel = ctxt.machine.kernelmgr.get(src_kernelname)\n            dst_kernel = src_kernel.copy()\n\n            if None in [src_kernel, dst_kernel]:\n                return\n\n            ctxt.machine.kernelmgr.set(dst_kernelname, dst_kernel)\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass KernelDrop(Op):\n    \"\"\"Drop an kernel. The \"default\" kernel cannot be dropped.\n\n    Attributes: Request:\n        kernel (str): Name of kernel.\n\n    Attributes Response:\n        -: None.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n            name = req.payload.get(\"kernel\")\n            ctxt.machine.kernelmgr.drop(name)\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass KernelGetState(Op):\n    \"\"\"Get kernel info.\n\n    Attributes: Request:\n        kernel (str): Kernel name.\n\n    Attributes: OkResponse:\n        bases (list of str): List of base kernel names.\n        nops (int): Number of operations.\n        ops (list of str): List of operation names.\n        updated (bool): If updated.\n\n    Attributes: ErrorResponse:\n        -: Error message.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            kernelname = req.payload.get(\"kernel\")\n            kernel = ctxt.machine.kernelmgr.get(kernelname)\n            return OkResponse(\n                payload=Payload(kernel.state()),\n                refmsg=req,\n            )\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                \"kernel not found\",\n                refmsg=req,\n            )", "\n\nclass KernelListOps(Op):\n    \"\"\"List op names for kernel.\n\n    Attributes: Request:\n        kernel (str): Kernel name.\n\n    Attributes: OkResponse:\n        names (list of str): List of kernel operation names.\n\n    Attributes: ErrorResponse:\n        -: Error message.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n            kernelname = req.payload.get(\"kernel\")\n            if kernelname == None:\n                return ErrorResponse(\n                    f\"kernel name not provided\",\n                    refmsg=req,\n                )\n\n            kernel = ctxt.machine.kernelmgr.get(kernelname)\n            if kernel == None:\n                return ErrorResponse(\n                    f\"kernel ({kernelname}) not found\",\n                    refmsg=req,\n                )\n\n            names = kernel.list()\n            return OkResponse(\n                payload=Payload({\"names\": names}),\n                refmsg=req,\n            )\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass KernelRegisterOp(Op):\n    \"\"\"Register a new op for an kernel.\n\n    Attributes: Request:\n        kernel (str): Kernel name.\n        new-op (str): Op name.\n        op-class (str): Op class name.\n        code (str): Kernel class definition.\n\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n            kernel_name = req.payload.get(\"kernel\")\n            opname = req.payload.get(\"new-op\")\n            opclassname = req.payload.get(\"op-class\")\n            code = req.payload.get(\"code\")\n            if code == None:\n                code_key = req.payload.get(\"code-key\")\n                if code_key != None:\n                    code = ctxt.machine.fkvstore.get(code_key)\n\n            if None in [kernel_name, opname, opclassname, code]:\n                self.logger.debug(\n                    f\"missing params ({kernel_name=} {opname=} {opclassname=} {code=}\"\n                )\n                return\n\n            kernel = ctxt.machine.kernelmgr.get(kernel_name)\n            if kernel == None:\n                self.logger.debug(f\"cannot find kernel\")\n                return\n\n            kernel.register_code(opname, opclassname, code)\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass KernelUnregisterOp(Op):\n    \"\"\"Unregister an op for an kernel.\"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n            kernel_name = req.payload.get(\"kernel\")\n            opname = req.payload.get(\"old-op\")\n            if None in [kernel_name, opname]:\n                return\n            kernel = ctxt.machine.kernelmgr.get(kernel_name)\n            kernel.unregister(opname)\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass MachineDisableDebug(Op):\n    \"\"\"Disable debug mode.\n\n    Attributes: Request:\n        : Unused.\n\n    Attributes: Response:\n        : None.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            ctxt.machine.set_debug(False)\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass MachineDropConnection(Op):\n    \"\"\"Drop connection.\n\n    Attributes: Request:\n        connection-id: Sessionid for session processor. Defaults to\n            sessionid of session running this op.\n\n    Attributes: Response:\n        : None.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n\n            connid = re.payload.get(\"connection-id\")\n            conn = ctxt.machine.connmgr.get(connid)\n            if conn:\n                conn.close()\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass MachineDropSession(Op):\n    \"\"\"Drop session.\n\n    Attributes: Request:\n        session-id: Sessionid for session processor. Defaults to\n            sessionid of session running this op.\n\n    Attributes: Response:\n        : None.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n\n            reqid = req.header.get(\"id\")\n            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n            if sessionid == None:\n                self.logger.warning(\"bad/missing session id\")\n                return\n\n            session = ctxt.machine.pop_session(sessionid)\n            if session == None:\n                self.logger.warning(f\"session not found for session id ({sessionid}\")\n                return\n\n            self.logger.debug(f\"dropping session ({sessionid}) reqid ({reqid}) ...\")\n\n            # clean up\n            self.logger.debug(f\"imq ({session.imq.values()}) omq ({session.omq.values()}) ...\")\n            self.logger.debug(f\"freezing imq ...\")\n            session.imq.freeze(True)\n\n            self.logger.debug(f\"freezing omq ...\")\n            session.omq.freeze(True)\n\n            self.logger.debug(f\"clearing imq ...\")\n            session.imq.clear()\n\n            self.logger.debug(f\"clearing omq ...\")\n            session.omq.clear()\n\n            self.logger.debug(f\"imq ({session.imq.values()}) omq ({session.omq.values()}) ...\")\n\n            self.logger.debug(f\"terminating request threads ({session.proc.active_count()})...\")\n            for _reqid in session.proc.get_thread_reqids():\n                try:\n                    if _reqid == reqid:\n                        self.logger.debug(f\"skip terminating reqid ({_reqid})\")\n                    else:\n                        self.logger.debug(f\"terminating reqid ({_reqid})\")\n                        session.proc.terminate_thread(_reqid)\n                except Exception as e:\n                    self.logger.debug(f\"EXCEPTION ({e})\")\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass MachineEnableDebug(Op):\n    \"\"\"Disable debug mode.\n\n    Attributes: Request:\n        : Unused.\n\n    Attributes: Response:\n        : None.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            ctxt.machine.set_debug(True)\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass MachineStepDebug(Op):\n    \"\"\"Trigger step of debug.\n\n    Requires that debug is on.\n\n    See [penvm.kernels.core.server.MachineEnableDebug][] and\n    [penvm.kernels.core.server.MachineDisableDebug][].\n\n    Attributes: Request:\n        -: Unused.\n\n    Attributes: OkResponse:\n        -: None.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            ctxt.machine.step_debug()\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass MachineGetFeatures(Op):\n    \"\"\"Get and return machine features.\n\n    Features are settings which describe the environment and context\n    that a machine runs with. E.g., the base language (i.e., python)\n    and the version.\n\n    Attributes: Request:\n        -: Unused.\n\n    Attributes: OkResponse:\n        -: Dictionary of machine features.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            return OkResponse(\n                payload=Payload(ctxt.machine.features()),\n                refmsg=req,\n            )\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                \"machine not found\",\n                refmsg=req,\n            )", "\n\nclass MachineGetState(Op):\n    \"\"\"Get and return machine state.\n\n    Attributes: Request:\n        -: Unused.\n\n    Attributes: OkResponse:\n        : Dictionary of state.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n            return OkResponse(\n                payload=Payload(ctxt.machine.state()),\n                refmsg=req,\n            )\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                \"machine not found\",\n                refmsg=req,\n            )", "\n\nclass MachineListConnections(Op):\n    \"\"\"List machine connections.\n\n    Attributes: Request:\n        -: Unused.\n\n    Attributes: OkResponse:\n        names: List of connection ids.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n            connids = ctxt.machine.connmgr.list()\n            return OkResponse(\n                payload=Payload(\n                    {\n                        \"names\": list(connids),\n                    }\n                ),\n                refmsg=req,\n            )\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                f\"{e}\",\n                refmsg=req,\n            )", "\n\nclass MachineListKernels(Op):\n    \"\"\"List kernels by name registered with the machine.\n\n    Attributes: Request:\n        -: Unused.\n\n    Attributes: OkResponse:\n        names: List of kernel names.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n            return OkResponse(\n                payload=Payload(\n                    {\n                        \"names\": ctxt.machine.kernelmgr.list(),\n                    }\n                ),\n                refmsg=req,\n            )\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                f\"{e}\",\n                refmsg=req,\n            )", "\n\nclass MachineListSessions(Op):\n    \"\"\"List machine sessions.\n\n    Attributes: Request:\n        -: Unused.\n\n    Attributes: OkResponse:\n        names: List of session ids.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n            sessionids = ctxt.machine.sessmgr.list()\n            return OkResponse(\n                payload=Payload(\n                    {\n                        \"names\": list(sessionids),\n                    },\n                ),\n                refmsg=req,\n            )\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                f\"{e}\",\n                refmsg=req,\n            )", "\n\nclass MachineSnapshot(Op):\n    \"\"\"Snapshot machine state and return.\n\n    Snapshottable state taken from:\n\n    * Single: [penvm.kernels.core.server.MachineGetState][].\n    * Single: [penvm.kernels.default.server.StoreGetState][].\n    * For each: [penvm.kernels.core.server.ConnectionGetState][].\n    * For each: [penvm.kernels.core.server.SessionGetState][].\n    * For each: [penvm.kernels.core.server.KernelGetState][].\n\n    Attributes: Request:\n        -: Unused.\n\n    Attributes: OkResponse:\n        -: Dictionary of state.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            # TODO: ensure this runs in a session with the required ops\n            self.logger.debug(\"run\")\n            run_local = ctxt.session.proc.kernel.run_local\n            payload = Payload()\n\n            _req = Request()\n            _resp = run_local(\"machine-get-state\", ctxt, _req)\n            self.logger.debug(f\"{_resp=}\")\n            payload[\"machine\"] = _resp.payload.dict(clean=True)\n\n            _resp = run_local(\"store-get-state\", ctxt, _req)\n            self.logger.debug(f\"{_resp=}\")\n            payload[\"store\"] = _resp.payload.dict(clean=True)\n\n            _req = Request()\n            conns = payload[\"connections\"] = {}\n            for connid in ctxt.machine.connmgr.list():\n                _req.payload[\"connection-id\"] = connid\n                _resp = run_local(\"connection-get-state\", ctxt, _req)\n                self.logger.debug(f\"{_resp=}\")\n                conns[connid] = _resp.payload.dict(clean=True)\n\n            _req = Request()\n            sessions = payload[\"sessions\"] = {}\n            for sessid in ctxt.machine.sessmgr.list():\n                _req.payload[\"session-id\"] = sessid\n                _resp = run_local(\"session-get-state\", ctxt, _req)\n                self.logger.debug(f\"{_resp=}\")\n                sessions[sessid] = _resp.payload.dict(clean=True)\n\n            _req = Request()\n            kernels = payload[\"kernels\"] = {}\n            for name in ctxt.machine.kernelmgr.list():\n                _req.payload[\"kernel\"] = name\n                _resp = run_local(\"kernel-get-state\", ctxt, _req)\n                self.logger.debug(f\"{_resp=}\")\n                kernels[name] = _resp.payload.dict(clean=True)\n\n            self.logger.debug(f\"{payload=}\")\n            return OkResponse(\n                payload=payload,\n                refmsg=req,\n            )\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                f\"{e}\",\n                refmsg=req,\n            )", "\n\nclass MachineShutdown(Op):\n    \"\"\"Shut down the machine.\n\n    Attributes: Request:\n        : Unused.\n\n    Attributes: Response:\n        : None.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        \"\"\"Shut down machine.\"\"\"\n        self.logger.debug(\"run\")\n        # TODO: can a reply be sent to ack? I think so!\n        sys.exit(0)", "\n\nclass SessionDropRequest(Op):\n    \"\"\"Drop request from session IMQ.\"\"\"\n\n    def run(self, ctxt, req):\n        \"\"\"Run operation.\"\"\"\n        pass\n\n\nclass SessionGetMessageState(Op):\n    \"\"\"Get session message state (from message queue).\n\n    Attributes: Request:\n        session-id: Session id for session.\n        message-id: Message id of request held by session.\n        message-queue: One of \"in\" or \"out\".\n\n    Attributes: Response:\n        dict: Request state dictionary.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        \"\"\"Run operation.\"\"\"\n\n        try:\n            self.logger.debug(\"run\")\n            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n            msgid = req.payload.get(\"message-id\")\n            msgqueue = req.payload.get(\"message-queue\")\n\n            sess = ctxt.machine.get_session(sessionid)\n\n            if msgqueue == \"in\":\n                mq = sess.imq\n            elif msgqueue == \"out\":\n                mq = sess.omq\n            else:\n                mq = None\n            msg = mq.find(msgid)\n            if msg == None:\n                return ErrorResponse(\n                    \"message not found\",\n                    refmsg=req,\n                )\n            return OkResponse(payload=Payload(msg.state()))\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                \"message not found\",\n                refmsg=req,\n            )", "\n\nclass SessionGetMessageState(Op):\n    \"\"\"Get session message state (from message queue).\n\n    Attributes: Request:\n        session-id: Session id for session.\n        message-id: Message id of request held by session.\n        message-queue: One of \"in\" or \"out\".\n\n    Attributes: Response:\n        dict: Request state dictionary.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        \"\"\"Run operation.\"\"\"\n\n        try:\n            self.logger.debug(\"run\")\n            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n            msgid = req.payload.get(\"message-id\")\n            msgqueue = req.payload.get(\"message-queue\")\n\n            sess = ctxt.machine.get_session(sessionid)\n\n            if msgqueue == \"in\":\n                mq = sess.imq\n            elif msgqueue == \"out\":\n                mq = sess.omq\n            else:\n                mq = None\n            msg = mq.find(msgid)\n            if msg == None:\n                return ErrorResponse(\n                    \"message not found\",\n                    refmsg=req,\n                )\n            return OkResponse(payload=Payload(msg.state()))\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                \"message not found\",\n                refmsg=req,\n            )", "\n\nclass SessionGetProcessorState(Op):\n    \"\"\"Get session processor state.\n\n    Attributes: Request:\n        session-id: Session id for session.\n\n    Attributes: Response:\n        dict: Request state dictionary.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        \"\"\"Run operation.\"\"\"\n\n        try:\n            self.logger.debug(\"run\")\n\n            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n            sess = ctxt.machine.get_session(sessionid)\n            return OkResponse(payload=Payload(sess.proc.state()))\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                \"session not found\",\n                refmsg=req,\n            )", "\n\nclass SessionGetState(Op):\n    \"\"\"Get session info.\n\n    Attributes: Request:\n        session-id: Session id for session.\n\n    Attributes: OkResponse:\n        -: Dictionary of state.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n\n            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n            sess = ctxt.machine.get_session(sessionid)\n            return OkResponse(\n                payload=Payload(sess.state()),\n                refmsg=req,\n            )\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                \"session not found\",\n                refmsg=req,\n            )", "\n\nclass SessionPinSession(Op):\n    \"\"\"Pin session.\n\n    Attributes: Request:\n        session-id: Session id for session.\n\n    Attributes: Response:\n        : None.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n\n            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n            sess = ctxt.machine.get_session(sessionid)\n            sess.pin = True\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass SessionPopOmq(Op):\n    \"\"\"\n    Pop waiting message from session OMQ.\n\n    Attributes: Request:\n        count: Number of times to pop the OMQ. Blocking for values\n            of >= 1. For 0, pop all values. Defaults to 1.\n        session-id: Override sessionid. Defaults to sessionid of\n            session running this op.\n\n    Attributes: Response:\n        : None.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n            connectionid = req.header.get(\"connection-id\")\n            session = ctxt.machine.sessmgr.get(sessionid)\n\n            count = req.payload.get(\"count\", 1)\n            if count >= 1:\n                for _ in range(count):\n                    resp = session.omq.pop()\n                    resp.header[\"session-id\"] = sessionid\n                    resp.header[\"connection-id\"] = connectionid\n                    ctxt.machine.omq.put(resp)\n            elif count == 0:\n                while True:\n                    resp = session.omq.pop(block=False)\n                    if resp == None:\n                        break\n\n                    resp.header[\"session-id\"] = sessionid\n                    resp.header[\"connection-id\"] = connectionid\n                    ctxt.machine.omq.put(resp)\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass SessionSetMaxThreads(Op):\n    \"\"\"Set max threads for session.\"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n            nthreads = req.payload.get(\"nthreads\")\n\n            if None in [nthreads, sessionid]:\n                return\n            if type(nthreads) != int:\n                return\n\n            session = ctxt.machine.get_session(sessionid)\n            session.proc.set_max_threads(nthreads)\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass SessionUseKernel(Op):\n    \"\"\"Set session to use an kernel.\"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n            kernel_name = req.payload.get(\"kernel\")\n\n            if None in [sessionid, kernel_name]:\n                self.logger.warning(f\"kernel and or sessionid not provided\")\n                return\n\n            kernel = ctxt.machine.kernelmgr.get(kernel_name)\n            if not kernel:\n                self.logger.warning(f\"kernel ({kernel_name}) not found\")\n                return\n\n            sess = ctxt.machine.get_session(sessionid)\n            sess.set_kernel(kernel)\n            self.logger.state(f\"session ({sessionid}) using kernel ({kernel_name})\")\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass SessionTerminateRequest(Op):\n    \"\"\"Terminate running request thread/task for session.\n\n    Attributes: Request:\n        reqid: Request id.\n        session-id: Session id for session processor.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n\n            reqid = req.payload.get(\"request-id\")\n            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n            self.logger.debug(f\"^^^^^^^^ terminate payload {reqid=} {sessionid=}\")\n\n            if reqid == None:\n                self.logger.warning(\"bad/missing request id\")\n                return\n\n            if sessionid == None:\n                self.logger.warning(\"bad/missing session id\")\n                return\n\n            session = ctxt.machine.get_session(sessionid)\n            if session == None:\n                self.logger.warning(f\"session not found for session id ({sessionid}\")\n                return\n\n            session.proc.terminate_thread(reqid)\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass SessionUnpinSession(Op):\n    \"\"\"Unpin session.\n\n    Attributes: Request:\n        session-id: Session id for session.\n\n    Attributes: Response:\n        : None.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n\n            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n            sess = ctxt.machine.get_session(sessionid)\n            sess.pin = False\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass SessionUsekernel(Op):\n    \"\"\"Update session to use a specific, previously registered kernel.\"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n            if sessionid == None:\n                return\n            session = ctxt.machine.get_session(sessionid)\n\n            kernelname = req.payload.get(\"kernel\")\n            kernel = ctxt.machine.kernelmgr.get(kernelname)\n            session.set_kernel(kernel)\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass Sleep(Op):\n    \"\"\"Sleep.\n\n    Attributes: Request:\n        seconds: Number (int or float) of seconds to sleep.\n        check-interval: Number of seconds to between checks for an\n            interrupt.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n\n            seconds = req.payload.get(\"seconds\")\n            check_interval = req.payload.get(\"check-interval\", 1)\n\n            if type(seconds) not in [int, float] or seconds < 0:\n                return\n            if type(check_interval) not in [int, float] or seconds < 0:\n                return\n\n            while seconds > 0:\n                time.sleep(min(seconds, check_interval))\n                seconds -= check_interval\n        except ThreadInterrupt as e:\n            raise\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            self.logger.warning(f\"bad/missing sleep time ({seconds})\")", "\n\nclass Kernel(_Kernel):\n    name = \"core\"\n\n    def __init__(self):\n        super().__init__()\n        self.ops.update(\n            {\n                \"connection-get-state\": ConnectionGetState(),\n                \"echo\": Echo(),\n                \"log\": Log(),\n                \"machine-disable-debug\": MachineDisableDebug(),\n                \"machine-drop-connection\": MachineDropConnection(),\n                \"machine-drop-session\": MachineDropSession(),\n                \"machine-enable-debug\": MachineEnableDebug(),\n                \"machine-get-features\": MachineGetFeatures(),\n                \"machine-get-state\": MachineGetState(),\n                \"machine-list-connections\": MachineListConnections(),\n                \"machine-list-kernels\": MachineListKernels(),\n                \"machine-list-sessions\": MachineListSessions(),\n                \"machine-shutdown\": MachineShutdown(),\n                \"machine-step-debug\": MachineStepDebug(),\n                \"machine-snapshot\": MachineSnapshot(),\n                \"kernel-add\": KernelAdd(),\n                \"kernel-copy\": KernelCopy(),\n                \"kernel-drop\": KernelDrop(),\n                \"kernel-get-state\": KernelGetState(),\n                \"kernel-list-ops\": KernelListOps(),\n                \"kernel-register-op\": KernelRegisterOp(),\n                \"kernel-unregister-op\": KernelUnregisterOp(),\n                \"session-drop-request\": SessionDropRequest(),\n                \"session-get-message-state\": SessionGetMessageState(),\n                \"session-get-processor-state\": SessionGetProcessorState(),\n                \"session-get-state\": SessionGetState(),\n                \"session-pop-omq\": SessionPopOmq(),\n                \"session-set-max-threads\": SessionSetMaxThreads(),\n                \"session-terminate-request\": SessionTerminateRequest(),\n                \"session-use-kernel\": SessionUseKernel(),\n                \"sleep\": Sleep(),\n            },\n        )", ""]}
{"filename": "src/kernels/penvm/kernels/default/client.py", "chunked_list": ["#\n# penvm/kernels/default/client.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Client-side interface to access the \"default\" kernel operations.\n\nSee [penvm.kernels.default.server][].\"\"\"\n\nimport copy\nimport logging\nfrom pathlib import Path", "import logging\nfrom pathlib import Path\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.lib.message import Request\nfrom penvm.kernels.core.client import KernelClient as _KernelClient\n\nlogger = logging.getLogger(__name__)\n\n\nclass KernelClient(_KernelClient):\n    \"\"\"Additional kernel ops.\"\"\"\n\n    name = \"default\"\n\n    def __init__(self, session):\n        super().__init__(session)\n\n    def file_copyto(self, lpath, rpath, blksize=1024):\n        \"\"\"Copy local file to remote.\"\"\"\n        lpp = Path(lpath)\n        if not lpp.exists():\n            # TODO: what to do?\n            return\n\n        try:\n            with open(lpath, \"rb\") as f:\n                count = 0\n                start = 0\n                while True:\n                    req = Request(\"file-put\")\n                    req.payload[\"path\"] = rpath\n                    req.payload[\"start\"] = start\n                    data = req.payload[\"data\"] = f.read(blksize)\n                    self.session.put_request(req)\n\n                    self.session.put_request(Request(\"omq-pop\"))\n                    if data == b\"\":\n                        break\n                    start + len(data)\n                    count += 1\n\n            for i in range(count):\n                resp = self.imq.pop()\n                if resp.payload.get(\"-status\") == \"error\":\n                    raise Exception(f\"expected {count} responses got error on {i}\")\n        except Exception as e:\n            # TODO: what to do here?\n            self.logger.debug(\"failed ({e})\")\n\n    def file_copyfrom(self, rpath, lpath, blksize=1024):\n        \"\"\"Copy remote file to local.\"\"\"\n        pass\n\n    def file_get_block(self, filename, start=None, size=None):\n        \"\"\"See [penvm.kernels.default.server.FileGetBlock][].\"\"\"\n        d = {\n            \"path\": filename,\n        }\n        if start != None:\n            d[\"start\"] = start\n        if size != None:\n            d[\"size\"] = size\n        return self.session.newput_request(\"file-get-block\", d)\n\n    def file_get_status(self, path):\n        \"\"\"See [penvm.kernels.default.server.FileGetStatus][].\"\"\"\n        d = {\n            \"path\": path,\n        }\n        return self.session.newput_request(\"file-get-status\", d)\n\n    def file_list(self, path, pattern=None, sort=None, split=None):\n        \"\"\"See [penvm.kernels.default.server.FileList][].\"\"\"\n        d = {\n            \"path\": path,\n        }\n        if pattern != None:\n            d[\"pattern\"] = pattern\n        if sort != None:\n            d[\"sort\"] = sort\n        if split != None:\n            d[\"split\"] = split\n        return self.session.newput_request(\"file-list\", d)\n\n    def file_put_block(self, path, data, start=None, size=None, truncate=None):\n        \"\"\"See [penvm.kernels.default.server.FilePutBlock][].\"\"\"\n        d = {\n            \"path\": path,\n            \"data\": data,\n        }\n        if start != None:\n            d[\"start\"] = start\n        if size != None:\n            d[\"size\"] = size\n        if truncate != None:\n            d[\"truncate\"] = truncate\n        return self.session.newput_request(\"file-put-block\", d)\n\n    def file_set_status(self, path, uid=None, gid=None, user=None, group=None, mode=None):\n        \"\"\"See [penvm.kernels.default.server.FileSetStatus][].\"\"\"\n        d = {\n            \"path\": path,\n            \"uid\": uid,\n            \"gid\": gid,\n            \"user\": user,\n            \"group\": group,\n            \"mode\": mode,\n        }\n        return self.session.newput_request(\"file-set-status\", d)\n\n    def run_exec(\n        self,\n        path,\n        args,\n        capture_output=False,\n        text=True,\n        env=None,\n        cwd=None,\n        path_key=None,\n    ):\n        \"\"\"See [penvm.kernels.default.server.RunExec][].\"\"\"\n        d = {\n            \"args\": [str(arg) for arg in args],\n            \"capture-output\": capture_output,\n            \"text\": text,\n        }\n        if path != None:\n            d[\"path\"] = path\n        elif path_key != None:\n            d[\"path-key\"] = path_key\n        if env != None:\n            d[\"env\"] = env\n        if cwd != None:\n            d[\"cwd\"] = cwd\n        return self.session.newput_request(\"run-exec\", d)\n\n    def run_exec_stream(\n        self,\n        path,\n        args,\n        capture_output=False,\n        text=True,\n        env=None,\n        wd=None,\n        path_key=None,\n    ):\n        \"\"\"See [penvm.kernels.default.server.RunExecStream][].\"\"\"\n        d = {\n            \"args\": [str(arg) for arg in args],\n            \"capture-output\": capture_output,\n            \"text\": text,\n        }\n        if path != None:\n            d[\"path\"] = path\n        elif path_key != None:\n            d[\"path-key\"] = path_key\n        if env != None:\n            d[\"env\"] = env\n        if wd != None:\n            d[\"wd\"] = wd\n        return self.session.newput_request(\"run-exec-stream\", d)\n\n    def run_python(self, code, args=None, kwargs=None, _globals=None, _locals=None):\n        \"\"\"See [penvm.kernels.default.server.RunPython][].\"\"\"\n        _locals = copy.deepcopy(_locals) if _locals != None else {}\n        _locals[\"__penvm__\"] = True\n        d = {\n            \"code\": code,\n        }\n        if args != None:\n            d[\"args\"] = args\n        if kwargs != None:\n            d[\"kwargs\"] = kwargs\n        if _locals != None:\n            d[\"locals\"] = _locals\n        if _globals != None:\n            d[\"globals\"] = _globals\n        return self.session.newput_request(\"run-python\", d)\n\n    def run_python_function(self, code, fnname, args=None, kwargs=None):\n        \"\"\"See [penvm.kernels.default.server.RunPythonFunction][].\"\"\"\n        d = {\n            \"args\": args,\n            \"code\": code,\n            \"fn-name\": fnname,\n            \"kwargs\": kwargs,\n        }\n        return self.session.newput_request(\"run-python-function\", d)\n\n    def store_drop(self, name):\n        \"\"\"See [penvm.kernels.default.server.StoreDrop][].\"\"\"\n        d = {\n            \"name\": name,\n        }\n        return self.session.newput_request(\"store-drop\", d)\n\n    def store_get(self, name):\n        \"\"\"See [penvm.kernels.default.server.StoreGet][].\"\"\"\n        d = {\n            \"name\": name,\n        }\n        return self.session.newput_request(\"store-get\", d)\n\n    def store_get_state(self):\n        \"\"\"See [penvm.kernels.default.server.StoreGetState][].\"\"\"\n        return self.session.newput_request(\"store-get-state\")\n\n    def store_list(self, pattern=None):\n        \"\"\"See [penvm.kernels.default.server.StoreList][].\"\"\"\n        d = {}\n        if pattern:\n            d[\"pattern\"] = pattern\n        return self.session.newput_request(\"store-list\", d)\n\n    def store_pop(self, name):\n        \"\"\"See [penvm.kernels.default.server.StorePop][].\"\"\"\n        d = {\n            \"name\": name,\n        }\n        return self.session.newput_request(\"store-pop\", d)\n\n    def store_put(self, name, data):\n        \"\"\"See [penvm.kernels.default.server.StorePut][].\"\"\"\n        d = {\n            \"name\": name,\n            \"data\": data,\n        }\n        return self.session.newput_request(\"store-put\", d)", "\n\nclass KernelClient(_KernelClient):\n    \"\"\"Additional kernel ops.\"\"\"\n\n    name = \"default\"\n\n    def __init__(self, session):\n        super().__init__(session)\n\n    def file_copyto(self, lpath, rpath, blksize=1024):\n        \"\"\"Copy local file to remote.\"\"\"\n        lpp = Path(lpath)\n        if not lpp.exists():\n            # TODO: what to do?\n            return\n\n        try:\n            with open(lpath, \"rb\") as f:\n                count = 0\n                start = 0\n                while True:\n                    req = Request(\"file-put\")\n                    req.payload[\"path\"] = rpath\n                    req.payload[\"start\"] = start\n                    data = req.payload[\"data\"] = f.read(blksize)\n                    self.session.put_request(req)\n\n                    self.session.put_request(Request(\"omq-pop\"))\n                    if data == b\"\":\n                        break\n                    start + len(data)\n                    count += 1\n\n            for i in range(count):\n                resp = self.imq.pop()\n                if resp.payload.get(\"-status\") == \"error\":\n                    raise Exception(f\"expected {count} responses got error on {i}\")\n        except Exception as e:\n            # TODO: what to do here?\n            self.logger.debug(\"failed ({e})\")\n\n    def file_copyfrom(self, rpath, lpath, blksize=1024):\n        \"\"\"Copy remote file to local.\"\"\"\n        pass\n\n    def file_get_block(self, filename, start=None, size=None):\n        \"\"\"See [penvm.kernels.default.server.FileGetBlock][].\"\"\"\n        d = {\n            \"path\": filename,\n        }\n        if start != None:\n            d[\"start\"] = start\n        if size != None:\n            d[\"size\"] = size\n        return self.session.newput_request(\"file-get-block\", d)\n\n    def file_get_status(self, path):\n        \"\"\"See [penvm.kernels.default.server.FileGetStatus][].\"\"\"\n        d = {\n            \"path\": path,\n        }\n        return self.session.newput_request(\"file-get-status\", d)\n\n    def file_list(self, path, pattern=None, sort=None, split=None):\n        \"\"\"See [penvm.kernels.default.server.FileList][].\"\"\"\n        d = {\n            \"path\": path,\n        }\n        if pattern != None:\n            d[\"pattern\"] = pattern\n        if sort != None:\n            d[\"sort\"] = sort\n        if split != None:\n            d[\"split\"] = split\n        return self.session.newput_request(\"file-list\", d)\n\n    def file_put_block(self, path, data, start=None, size=None, truncate=None):\n        \"\"\"See [penvm.kernels.default.server.FilePutBlock][].\"\"\"\n        d = {\n            \"path\": path,\n            \"data\": data,\n        }\n        if start != None:\n            d[\"start\"] = start\n        if size != None:\n            d[\"size\"] = size\n        if truncate != None:\n            d[\"truncate\"] = truncate\n        return self.session.newput_request(\"file-put-block\", d)\n\n    def file_set_status(self, path, uid=None, gid=None, user=None, group=None, mode=None):\n        \"\"\"See [penvm.kernels.default.server.FileSetStatus][].\"\"\"\n        d = {\n            \"path\": path,\n            \"uid\": uid,\n            \"gid\": gid,\n            \"user\": user,\n            \"group\": group,\n            \"mode\": mode,\n        }\n        return self.session.newput_request(\"file-set-status\", d)\n\n    def run_exec(\n        self,\n        path,\n        args,\n        capture_output=False,\n        text=True,\n        env=None,\n        cwd=None,\n        path_key=None,\n    ):\n        \"\"\"See [penvm.kernels.default.server.RunExec][].\"\"\"\n        d = {\n            \"args\": [str(arg) for arg in args],\n            \"capture-output\": capture_output,\n            \"text\": text,\n        }\n        if path != None:\n            d[\"path\"] = path\n        elif path_key != None:\n            d[\"path-key\"] = path_key\n        if env != None:\n            d[\"env\"] = env\n        if cwd != None:\n            d[\"cwd\"] = cwd\n        return self.session.newput_request(\"run-exec\", d)\n\n    def run_exec_stream(\n        self,\n        path,\n        args,\n        capture_output=False,\n        text=True,\n        env=None,\n        wd=None,\n        path_key=None,\n    ):\n        \"\"\"See [penvm.kernels.default.server.RunExecStream][].\"\"\"\n        d = {\n            \"args\": [str(arg) for arg in args],\n            \"capture-output\": capture_output,\n            \"text\": text,\n        }\n        if path != None:\n            d[\"path\"] = path\n        elif path_key != None:\n            d[\"path-key\"] = path_key\n        if env != None:\n            d[\"env\"] = env\n        if wd != None:\n            d[\"wd\"] = wd\n        return self.session.newput_request(\"run-exec-stream\", d)\n\n    def run_python(self, code, args=None, kwargs=None, _globals=None, _locals=None):\n        \"\"\"See [penvm.kernels.default.server.RunPython][].\"\"\"\n        _locals = copy.deepcopy(_locals) if _locals != None else {}\n        _locals[\"__penvm__\"] = True\n        d = {\n            \"code\": code,\n        }\n        if args != None:\n            d[\"args\"] = args\n        if kwargs != None:\n            d[\"kwargs\"] = kwargs\n        if _locals != None:\n            d[\"locals\"] = _locals\n        if _globals != None:\n            d[\"globals\"] = _globals\n        return self.session.newput_request(\"run-python\", d)\n\n    def run_python_function(self, code, fnname, args=None, kwargs=None):\n        \"\"\"See [penvm.kernels.default.server.RunPythonFunction][].\"\"\"\n        d = {\n            \"args\": args,\n            \"code\": code,\n            \"fn-name\": fnname,\n            \"kwargs\": kwargs,\n        }\n        return self.session.newput_request(\"run-python-function\", d)\n\n    def store_drop(self, name):\n        \"\"\"See [penvm.kernels.default.server.StoreDrop][].\"\"\"\n        d = {\n            \"name\": name,\n        }\n        return self.session.newput_request(\"store-drop\", d)\n\n    def store_get(self, name):\n        \"\"\"See [penvm.kernels.default.server.StoreGet][].\"\"\"\n        d = {\n            \"name\": name,\n        }\n        return self.session.newput_request(\"store-get\", d)\n\n    def store_get_state(self):\n        \"\"\"See [penvm.kernels.default.server.StoreGetState][].\"\"\"\n        return self.session.newput_request(\"store-get-state\")\n\n    def store_list(self, pattern=None):\n        \"\"\"See [penvm.kernels.default.server.StoreList][].\"\"\"\n        d = {}\n        if pattern:\n            d[\"pattern\"] = pattern\n        return self.session.newput_request(\"store-list\", d)\n\n    def store_pop(self, name):\n        \"\"\"See [penvm.kernels.default.server.StorePop][].\"\"\"\n        d = {\n            \"name\": name,\n        }\n        return self.session.newput_request(\"store-pop\", d)\n\n    def store_put(self, name, data):\n        \"\"\"See [penvm.kernels.default.server.StorePut][].\"\"\"\n        d = {\n            \"name\": name,\n            \"data\": data,\n        }\n        return self.session.newput_request(\"store-put\", d)", ""]}
{"filename": "src/kernels/penvm/kernels/default/__init__.py", "chunked_list": ["# blocks changes to this package\n"]}
{"filename": "src/kernels/penvm/kernels/default/server.py", "chunked_list": ["#\n# penvm/kernels/default/server.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Server-side \"default\" kernel operations.\n\nThe default operations providing the necessary functionality for\nmany/most use cases including support for: filesystem, kv store, and\nbinary and python code execution.\n\nFor an explanation of the Request and Response sections see", "\nFor an explanation of the Request and Response sections see\n[penvm.kernels.core.server][].\"\"\"\n\nimport fnmatch\n\ntry:\n    import grp\nexcept:\n    grp = None", "import logging\nimport os\nimport os.path\nfrom pathlib import Path\n\ntry:\n    import pwd\nexcept:\n    pwd = None\nimport select", "import select\nimport shutil\nimport subprocess\nimport traceback\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.kernels.base.server import Op\nfrom penvm.kernels.core.server import Kernel as _Kernel\nfrom penvm.lib.message import ErrorResponse, OkResponse, Payload\n", "from penvm.lib.message import ErrorResponse, OkResponse, Payload\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass FileGetBlock(Op):\n    \"\"\"Read data (block) from a file object.\n\n    Attributes: Request:\n        path (str): File path.\n        size (int): Size (in bytes) to read. Defaults to 1024.\n        start (int): Offset from file start. Defaults to 0.\n\n    Attributes: OkResponse:\n        data (bytes): Bytes (up to `size`) from file block.\n        size (int): Size (in bytes) read.\n        start (int): Offset from file start.\n\n    Attributes: ErrorResponse:\n        -: Error message.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            payload = req.payload\n            path = payload.get(\"path\")\n            size = payload.get(\"size\", 1024)\n            start = payload.get(\"start\", 0)\n\n            if not path:\n                return ErrorResponse(\n                    \"path not provided\",\n                    refmsg=req,\n                )\n\n            pp = Path(path)\n            if not pp.exists():\n                return ErrorResponse(\n                    f\"path ({path}) not found\",\n                    refmsg=req,\n                )\n\n            try:\n                f = pp.open(\"rb\")\n                f.seek(start)\n                return OkResponse(\n                    payload=Payload(\n                        {\"data\": f.read(size), \"size\": size, \"start\": start},\n                    ),\n                    refmsg=req,\n                )\n            except Exception as e:\n                return ErrorResponse(\n                    f\"{e}\",\n                    refmsg=req,\n                )\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass FileGetStatus(Op):\n    \"\"\"Get file status (`os.stat()`).\n\n    Attributes: Request:\n        path (str): File path to stat.\n\n    Attributes: OkResponse:\n        mode (int): File mode.\n        ino (int): Inode.\n        dev (int): Device identifier.\n        nlink (int): Number of hard links.\n        uid (int): User id of file owner.\n        gid (int): Group id of file owner.\n        size (int): File size (in bytes).\n        atime (int): Most recent access time (in seconds).\n        mtime (int): Most recent content modication time (in seconds).\n        ctime (int): Most recent metadata change time (in seconds).\n\n    Attributes: ErrorResponse:\n        -: Error message.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            path = req.payload.get(\"path\")\n            if path != None:\n                return ErrorResponse(\"path not provided\")\n\n            if not os.path.exists(path):\n                return ErrorResponse(\"path not found\")\n\n            st = os.stat(path)\n            return OkResponse(\n                payload={\n                    \"mode\": st.st_mode,\n                    \"ino\": st.st_ino,\n                    \"dev\": st.st_dev,\n                    \"nlink\": st.st_nlink,\n                    \"uid\": st.st_uid,\n                    \"gid\": st.st_gid,\n                    \"size\": st.st_size,\n                    \"atime\": st.st_atime,\n                    \"mtime\": st.st_mtime,\n                    \"ctime\": st.st_ctime,\n                },\n                refmsg=req,\n            )\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass FileList(Op):\n    \"\"\"List filenames/dirnames at filesystem path.\n\n    Attributes: Request:\n        path (str): Directory path.\n        filter (str): Filename filter. Defaults to no filter.\n        sort (bool): Sort names. Defaults to False.\n\n    Attributes: Response:\n        names (list of str): List of directory entries.\n\n    Attributes: ErrorResponse:\n        -: Error message.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            payload = req.payload\n            path = payload.get(\"path\")\n            pattern = payload.get(\"pattern\")\n            sort = payload.get(\"sort\", False)\n            split = payload.get(\"split\", False)\n\n            if not path:\n                return ErrorResponse(\n                    \"path not provided\",\n                    refmsg=req,\n                )\n\n            try:\n                if split:\n                    if os.path.isdir(path):\n                        for root, dirnames, filenames in os.walk(path):\n                            break\n                    else:\n                        root, dirnames, filenames = None, [], [path]\n\n                    if pattern:\n                        dirnames = fnmatch.filter(dirnames, pattern)\n                        filenames = fnmatch.filter(filenames, pattern)\n                    if sort:\n                        dirnames.sort()\n                        filenames.sort()\n\n                    return OkResponse(\n                        payload=Payload(\n                            {\n                                \"dirnames\": dirnames,\n                                \"filenames\": filenames,\n                            }\n                        ),\n                        refmsg=req,\n                    )\n                else:\n                    if os.path.isdir(path):\n                        names = os.listdir(path)\n                    elif os.path.isfile(path):\n                        names = [os.path.basename(path)]\n\n                    if pattern:\n                        names = fnmatch.filter(names, pattern)\n                    if sort:\n                        names.sort()\n\n                    return OkResponse(\n                        payload=Payload({\"names\": names}),\n                        refmsg=req,\n                    )\n            except Exception as e:\n                return ErrorResponse(\n                    f\"{e}\",\n                    refmsg=req,\n                )\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass FilePutBlock(Op):\n    \"\"\"Write data (block) to a file object.\n\n    Attributes: Request:\n        data (bytes): Data to store.\n        path (str): File path.\n        size (int): Size (in bytes) of data.\n        start (int): Offset from file start. Defaults to 0.\n        truncate (bool): Flag to indicate truncation of file. Defaults\n            to False.\n\n    Attributes: OkResponse:\n        -: Empty.\n\n    Attributes: ErrorResponse:\n        -: Error message.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            payload = req.payload\n            data = payload.get(\"data\")\n            path = payload.get(\"path\")\n            size = payload.get(\"size\", len(data))\n            start = payload.get(\"start\", 0)\n            truncate = payload.get(\"truncate\", False)\n\n            if not path:\n                return ErrorResponse(\n                    \"path not provided\",\n                    refmsg=req,\n                )\n            if not data:\n                return ErrorResponse(\n                    \"data not provided\",\n                    refmsg=req,\n                )\n\n            pp = Path(path)\n            if not pp.parent.is_dir():\n                return ErrorResponse(\n                    f\"parent path ({pp.parent.isabsolute()}) does not exist\",\n                    refmsg=req,\n                )\n\n            try:\n                with pp.open(\"wb+\") as f:\n                    if truncate:\n                        # TODO: support truncateat?\n                        f.truncate()\n                    f.seek(start)\n                    if size != None:\n                        f.write(data[:size])\n                    else:\n                        f.write(data)\n                    f.close()\n                return OkResponse(\n                    refmsg=req,\n                )\n            except Exception as e:\n                return ErrorResponse(\n                    f\"{e}\",\n                    refmsg=req,\n                )\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass FileSetStatus(Op):\n    \"\"\"Set file status settings.\n\n    Attributes: Request:\n        path (str): File object path.\n        uid (int): User id of file owner.\n        user (str): User name of file owner.\n        gid (int): Group id of file owner.\n        group (int): Group name of file owner.\n        mode (int): File mode.\n\n    Attributes: Response:\n        -: None.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            payload = req.payload\n            path = payload.get(\"path\")\n            uid = payload.get(\"uid\")\n            user = payload.get(\"user\")\n            gid = payload.get(\"gid\")\n            group = payload.get(\"group\")\n            mode = payload.get(\"mode\")\n\n            if path == None:\n                return\n\n            if not os.path.exists(path):\n                return\n\n            if user and pwd:\n                pw = pwd.getpwnam(user)\n                if pw:\n                    uid = pw.pw_uid\n            if group and grp:\n                gr = grp.getgrnam(group)\n                if gr:\n                    gid = gr.gr_gid\n\n            if uid == None:\n                uid = -1\n            if gid == None:\n                gid = -1\n\n            try:\n                if mode != None:\n                    os.chmod(path, mode)\n            except:\n                pass\n\n            try:\n                if uid != -1 and gid != -1:\n                    os.chown(path, uid, gid)\n            except:\n                pass\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass RunExec(Op):\n    \"\"\"Run a locally available executable via a path with arguments.\n\n    Attributes: Request:\n        args (list of string): Arguments. Defaults to empty list.\n        capture_output (bool): Capture stdout/stderr. Defaults to\n            True.\n        env (dict|list of strings): Dictionary or list of strings for\n            the environment.\n        path (str): Path of executable. See also `path-key`.\n        path-key (str): Name of item in file kvstore. See also `path`.\n        text (bool): Treat output as \"text\". Otherwise, \"binary\".\n        cwd (str): Working directory to run under. Defaults to \"/\".\n\n    Attributes: OkResponse:\n        returncode (int): Exit/return code\n        stderr (str): stderr output\n        stdout (str): stdout output\n    \"\"\"\n\n    def run(self, ctxt, req):\n        \"\"\"Run operation.\"\"\"\n        try:\n            self.logger.debug(\"run\")\n\n            payload = req.payload\n\n            args = list(payload.get(\"args\", []))\n            capture_output = payload.get(\"capture-output\", True)\n            env = payload.get(\"env\", None)\n            path = payload.get(\"path\")\n            path_key = payload.get(\"path-key\")\n            text = payload.get(\"text\", False)\n            cwd = payload.get(\"cwd\", \"/\")\n\n            self.logger.debug(f\"path {path} path-key {path_key}\")\n            if path == None:\n                path = ctxt.machine.fkvstore.get_path(path_key)\n                # TODO: make it executable in a different call?\n                os.chmod(path, 0o700)\n\n            if None in [path]:\n                return ErrorResponse(\n                    \"path not provided\",\n                    refmsg=req,\n                )\n            elif not os.path.exists(path):\n                _path = shutil.which(path)\n                if _path == None:\n                    return ErrorResponse(\n                        f\"file ({path}) not found\",\n                        refmsg=req,\n                    )\n                path = _path\n\n            kwargs = {\n                \"capture_output\": capture_output,\n                \"cwd\": cwd,\n                \"text\": text,\n            }\n            if env:\n                kwargs[\"env\"] = env\n\n            cp = subprocess.run(\n                [path] + args,\n                **kwargs,\n            )\n            return OkResponse(\n                payload=Payload(\n                    {\n                        \"stdout\": cp.stdout,\n                        \"stderr\": cp.stderr,\n                        \"returncode\": cp.returncode,\n                    }\n                ),\n                refmsg=req,\n            )\n        except Exception as e:\n            return ErrorResponse(\n                f\"{e}\",\n                refmsg=req,\n            )", "\n\nclass RunExecStream(Op):\n    \"\"\"Run a locally available executable via a path with arguments\n    with streaming capability.\n\n    Whereas `RunExec` runs the executable, waits for it to complete,\n    then collects and returns the `stdout`, `stderr`, and\n    `returncode`, `RunExecStream` streams partial results over the\n    lifetime of the operation. As such, an undetermined number of\n    responses are collected and returned. When the operation\n    completes, a final message will contain a `returncode` != `None`.\n    The requester must perform queue management (e.g.,\n    `session-pop-omq` at the server, and consume the messages at the\n    client side).\n\n    Note:\n        `stdin` is not supported.\n\n    Attributes: Request:\n        args (list of string): Arguments. Defaults to empty list.\n        capture_output (bool): Capture stdout/stderr. Defaults to\n            True.\n        env: (dict|list of strings): Dictionary or list of strings for\n            the environment.\n        path (str): Path of executable. See also `path-key`.\n        path-key (str): Name of item in file kvstore. See also `path`.\n        text (bool): Treat output as \"text\". Otherwise, \"binary\".\n        cwd (str): Working directory to run under. Defaults to \"/\".\n\n    Attributes: OkResponse:\n        returncode (int|None): Exit/return code. Last response sends\n            `returncode` != `None`.\n        stderr (str): `stderr` output.\n        stdout (str): `stdout` output.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        \"\"\"Run operation.\"\"\"\n        try:\n            self.logger.debug(\"run\")\n\n            payload = req.payload\n\n            args = list(payload.get(\"args\", []))\n            capture_output = payload.get(\"capture-output\", True)\n            env = payload.get(\"env\", None)\n            path = payload.get(\"path\")\n            path_key = payload.get(\"path-key\")\n            text = payload.get(\"text\", False)\n            cwd = payload.get(\"cwd\", \"/\")\n\n            self.logger.debug(f\"path {path} path-key {path_key}\")\n            if path == None:\n                path = ctxt.machine.fkvstore.get_path(path_key)\n                # TODO: make it executable in a different call?\n                os.chmod(path, 0o700)\n\n            if None in [path]:\n                return ErrorResponse(\n                    \"path not provided\",\n                    refmsg=req,\n                )\n            elif not os.path.exists(path):\n                return ErrorResponse(\n                    f\"file ({path}) not found\",\n                    refmsg=req,\n                )\n            else:\n                kwargs = {\n                    \"cwd\": cwd,\n                    \"text\": text,\n                }\n                if capture_output:\n                    kwargs[\"stdout\"] = subprocess.PIPE\n                    kwargs[\"stderr\"] = subprocess.PIPE\n                if env:\n                    kwargs[\"env\"] = env\n\n                if 0:\n                    # no buffering, allows short reads\n                    kwargs[\"bufsize\"] = 0\n                if 1:\n                    # line buffered\n                    kwargs[\"bufsize\"] = 1\n\n                try:\n                    sp = subprocess.Popen(\n                        [path] + args,\n                        **kwargs,\n                    )\n\n                    POLLIN = select.POLLIN\n                    POLLOUT = select.POLLOUT\n                    POLLHEN = select.POLLHUP | select.POLLERR | select.POLLNVAL\n\n                    stdout_fd = sp.stdout.fileno()\n                    stderr_fd = sp.stderr.fileno()\n\n                    poll = select.poll()\n                    poll.register(stdout_fd, select.POLLIN)\n                    poll.register(stderr_fd, select.POLLIN)\n\n                    self.logger.debug(f\"{sp.stdout=} {sp.stdout.line_buffering=} {sp.stderr=}\")\n                    sp.stdout.reconfigure(line_buffering=True)\n                    sp.stderr.reconfigure(line_buffering=True)\n\n                    self.logger.debug(f\"starting ...\")\n\n                    nfds = 2\n                    while nfds:\n                        populated = False\n                        resp = OkResponse(\n                            refmsg=req,\n                        )\n                        for fd, event in poll.poll():\n                            self.logger.debug(f\"{fd=} {event=}\")\n                            if event & POLLIN:\n                                if fd == stdout_fd:\n                                    populated = True\n                                    resp.payload[\"stdout\"] = sp.stdout.read(128)\n                                else:\n                                    # assume stderr\n                                    populated = True\n                                    resp.payload[\"stderr\"] = sp.stderr.read(128)\n                            if event & POLLHEN:\n                                poll.unregister(fd)\n                                nfds -= 1\n                        if populated:\n                            ctxt.session.omq.put(resp)\n\n                    sp.wait()\n                    self.logger.debug(f\"final\")\n                    resp = OkResponse(\n                        refmsg=req,\n                    )\n                    resp.payload[\"returncode\"] = sp.returncode\n                    return resp\n                except Exception as e:\n                    # TODO: cleanup? kill?\n                    sp.kill()\n                    raise\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                f\"{e}\",\n                refmsg=req,\n            )", "\n\nclass RunPython(Op):\n    \"\"\"Run python code snippet with typed args and typed kwargs.\n\n    The code is executed in a thread of the `machine`.\n\n    Danger:\n        Running in the machine process can cause problems.\n\n    See [penvm.kernels.default.server.RunExec][].\n\n    Attributes: Request:\n        args (typed list): Arguments.\n        code (str): Code snippet.\n        globals (typed dict): Dictionary of \"globals\" to use. Defaults\n            to current \"globals\".\n        kwargs (typed dict): Keyword arguments.\n        locals (typed dict): Dictionary of \"locals\" to use. Defaults\n            to empty dict.\n        path-key (str): Path of code snippet in file kvstore. See also\n            `code`.\n\n    Attributes: Response:\n        return-value (typed value): Taken from `returnvalue` in locals.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        \"\"\"Run operation.\"\"\"\n        try:\n            self.logger.debug(\"run\")\n            payload = req.payload\n\n            code = payload.get(\"code\")\n            path_key = payload.get(\"path-key\")\n\n            if code == None:\n                code = ctxt.machine.fkvstore.get(path_key)\n\n            # TODO: should args and kwargs be distinct or in one of locals or globals\n            args = payload.get(\"args\", [])\n            _locals = payload.get(\"locals\", {})\n            _globals = payload.get(\"globals\", None)\n            kwargs = payload.get(\"kwargs\", {})\n\n            if None in [code]:\n                return ErrorResponse(\n                    \"code not provided\",\n                    refmsg=req,\n                )\n            else:\n                try:\n                    co = compile(code, \"<string>\", \"exec\")\n                except Exception as e:\n                    self.logger.warning(f\"EXCEPTION ({e})\")\n                    co = None\n\n                if co == None:\n                    return ErrorResponse(\n                        \"code does not compile\",\n                        refmsg=req,\n                    )\n                else:\n                    try:\n                        exec(code, _globals, _locals)\n                        return OkResponse(\n                            payload=Payload({\"return-value\": _locals.get(\"returnvalue\")}),\n                            refmsg=req,\n                        )\n                    except Exception as e:\n                        self.logger.warning(f\"EXCEPTION ({e})\")\n                        resp = ErrorResponse(\n                            f\"{e}\",\n                            refmsg=req,\n                        )\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass RunPythonFunction(Op):\n    \"\"\"Run function from python code snippet with typed args and typed\n    kwargs.\n\n    The code is executed in a thread of the `machine`.\n\n    Danger:\n        Running in the machine process can cause problems.\n\n    See [penvm.kernels.default.server.RunExec][].\n\n    Attributes: Request:\n        args (typed list): Arguments.\n        code (str): Code snippet.\n        code-key (str): Code snippet in file kvstore. See also `code`.\n        globals (typed dict): Dictionary of \"globals\" to use. Defaults\n            to current \"globals\"\n        kwargs (typed dict): Keyword arguments.\n        locals (typed dict): Dictionary of \"locals\" to use. Defaults\n            to empty dict\n        path-key (str): Path of code snippet in file kvstore. See also\n            `code`.\n\n    Attributes: OkResponse:\n        return-value (typed): Return value from function call.\n    \"\"\"\n\n    code_template = \"\"\"\\\nfn = globals().get(fnname)\n__penvm_returnvalue__ = fn(*args, **kwargs)\n\"\"\"\n\n    def run(self, ctxt, req):\n        \"\"\"Run operation.\"\"\"\n        try:\n            self.logger.debug(\"run\")\n            payload = req.payload\n\n            # TODO: tweak args and kwargs handling\n            args = payload.get(\"args\", [])\n            code = payload.get(\"code\")\n            path_key = payload.get(\"path-key\")\n            if code == None:\n                code = ctxt.machine.fkvstore.get(path_key)\n            fnname = payload.get(\"fn-name\")\n            kwargs = payload.get(\"kwargs\") or {}\n\n            _globals = payload.get(\"globals\", {})\n            _locals = payload.get(\n                \"locals\",\n                {\n                    \"args\": args,\n                    \"fnname\": fnname,\n                    \"kwargs\": kwargs,\n                },\n            )\n\n            if code == None:\n                return ErrorResponse(\n                    \"code not provided\",\n                    refmsg=req,\n                )\n            elif fnname == None:\n                return ErrorResponse(\n                    \"fnname not provided\",\n                    refmsg=req,\n                )\n            else:\n                try:\n                    co = compile(code, \"<string>\", \"exec\")\n                except Exception as e:\n                    self.logger.warning(f\"EXCEPTION ({e})\")\n                    co = None\n\n                if co == None:\n                    return ErrorResponse(\n                        \"code does not compile\",\n                        refmsg=req,\n                    )\n                else:\n                    try:\n                        # load provided code\n                        exec(code, _globals)\n                        # run fn\n                        exec(self.code_template, _globals, _locals)\n                        resp = OkResponse(\n                            payload=Payload(\n                                {\"return-value\": _locals.get(\"__penvm_returnvalue__\")}\n                            ),\n                            refmsg=req,\n                        )\n                        return resp\n                    except Exception as e:\n                        self.logger.warning(f\"EXCEPTION ({e})\")\n                        resp = ErrorResponse(\n                            f\"{e}\",\n                            refmsg=req,\n                        )\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass StoreDrop(Op):\n    \"\"\"Drop item from store.\n\n    Attributes: Request:\n        name: Item name.\n    TODO: should an reponse be sent?\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n\n            name = req.payload.get(\"name\")\n            if name != None:\n                ctxt.machine.fkvstore.drop(name)\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass StoreGet(Op):\n    \"\"\"Get item from store.\n\n    Attributes: Request:\n        name: Item name.\n\n    Attributes: Response:\n        data: Data as text or binary.\n        name: Item name.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n\n            name = req.payload.get(\"name\")\n            data = ctxt.machine.fkvstore.get(name)\n            if data == None:\n                return ErrorResponse(\n                    f\"name ({name}) not in store\",\n                    refmsg=req,\n                )\n            else:\n                return OkResponse(\n                    payload=Payload(\n                        {\n                            \"name\": name,\n                            \"data\": data,\n                        }\n                    ),\n                    refmsg=req,\n                )\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                f\"{e}\",\n                refmsg=req,\n            )", "\n\nclass StoreGetState(Op):\n    \"\"\"Get store state.\n\n    Attributes: Request:\n        : Unused.\n\n    Attributes: OkResponse:\n        : Dictionary of state.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n            return OkResponse(\n                payload=Payload(ctxt.machine.fkvstore.state()),\n                refmsg=req,\n            )\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                \"store not found\",\n                refmsg=req,\n            )", "\n\nclass StoreList(Op):\n    \"\"\"Get item from store.\n\n    Attributes: Request:\n        -: Unused.\n\n    Attributes: Response:\n        names: Item name.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n\n            fkvstore = ctxt.machine.fkvstore\n            return OkResponse(\n                payload=Payload({\"names\": list(fkvstore.keys())}),\n                refmsg=req,\n            )\n        except Exception as e:\n            self.logger.error(f\"{e}\")\n            return ErrorResponse(\n                f\"{e}\",\n                refmsg=req,\n            )", "\n\nclass StorePop(Op):\n    \"\"\"Get item from store and remove from store.\n\n    Attributes: Request:\n        name: Item name.\n\n    Attributes: Response:\n        data: Data as text or binary.\n        name: Item name.\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n\n            name = req.payload.get(\"name\")\n            resp = StoreGet().run(ctxt, req)\n            if name != None:\n                ctxt.machine.fkvstore.drop(name)\n            return resp\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass StorePut(Op):\n    \"\"\"Put item into store.\n\n    Attributes: Request:\n        data: Data as text or binary.\n        name: Item name.\n    TODO: should an reponse be sent?\n    \"\"\"\n\n    def run(self, ctxt, req):\n        try:\n            self.logger.debug(\"run\")\n\n            ftype = req.payload.get(\"type\", \"text\")\n            name = req.payload.get(\"name\")\n            data = req.payload.get(\"data\")\n            if None in [name, data]:\n                # DROP!\n                self.logger.debug(f\"drop for bad 'name' or 'data'\")\n                return\n            if data:\n                self.logger.debug(f\"putting {name=} {ftype=} {ctxt.machine.fkvstore.dirpath=} ...\")\n                ctxt.machine.fkvstore.put(name, data)\n        except Exception as e:\n            self.logger.error(f\"{e}\")", "\n\nclass Kernel(_Kernel):\n    name = \"default\"\n\n    def __init__(self):\n        super().__init__()\n        self.ops.update(\n            {\n                \"file-get-block\": FileGetBlock(),\n                \"file-get-stat\": FileGetStatus(),\n                \"file-list\": FileList(),\n                \"file-put-block\": FilePutBlock(),\n                \"file-set-stat\": FileSetStatus(),\n                \"run-exec\": RunExec(),\n                \"run-exec-stream\": RunExecStream(),\n                \"run-python\": RunPython(),\n                \"run-python-function\": RunPythonFunction(),\n                \"store-drop\": StoreDrop(),\n                \"store-get\": StoreGet(),\n                \"store-get-state\": StoreGetState(),\n                \"store-list\": StoreList(),\n                \"store-pop\": StorePop(),\n                \"store-put\": StorePut(),\n            }\n        )", ""]}
{"filename": "src/app/penvm/app/connect.py", "chunked_list": [""]}
{"filename": "src/app/penvm/app/boot.py", "chunked_list": ["#\n# penvm/app/boot.py\n\n# PENVM\n#\n# Copyright 2023 J4M Solutions\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at", "# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.", "# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Boot support for PENVM world/network.\n\"\"\"\n\nimport os\nimport os.path\nimport subprocess\nimport sys", "import subprocess\nimport sys\nimport time\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom penvm.client.world import World\nfrom penvm.lib.misc import MachineConnectionSpec, get_version_string\n\n\nclass Booter:\n    \"\"\"Provides PENVM network boot support from configuration file.\"\"\"\n\n    def __init__(\n        self,\n        configfilename: str,\n        networkname: str,\n        release: str,\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            configfilename: Configuration file name.\n            networkname: Network name.\n            release: PENVM release.\n        \"\"\"\n        self.configfilename = configfilename\n        self.networkname = networkname\n        self.release = release\n\n        self.world = None\n        self.network = None\n        self.env = None\n\n    def boot(self):\n        \"\"\"Boot.\"\"\"\n        try:\n            self.world = World(filename=self.configfilename)\n            self.network = self.world.get_network(self.networkname)\n            # print(f\"{self.networkname=}\")\n            if self.network == None or self.network.get_targets() in [None, []]:\n                raise Exception(f\"network ({self.networkname}) not found\")\n            self.network.boot()\n\n            machines = self.network.get_machines()\n            if machines in [None, []]:\n                raise Exception(\"no machines\")\n            if None in machines:\n                raise Exception(\"not all machines found\")\n\n            self.release = self.release or self.world.get_meta(\"release\") or get_version_string()\n            if self.release == None:\n                raise Exception(f\"could not determine release value\")\n\n            releasepath = os.path.expanduser(f\"~/.penvm/releases/{self.release}\")\n            releaselibs = \":\".join([f\"{releasepath}/{name}\" for name in [\"penvmlib-client\"]])\n\n            # patch env\n            self.env = os.environ.copy()\n            PENVM_AUTO_NETWORK = str(self.network)\n            PYTHONPATH = self.env.get(\"PYTHONPATH\")\n            if PYTHONPATH != None:\n                PYTHONPATH = f\"{releaselibs}:{PYTHONPATH}\"\n            else:\n                PYTHONPATH = releaselibs\n\n            self.env[\"PENVM_AUTO_NETWORK\"] = PENVM_AUTO_NETWORK\n            self.env[\"PENVM_RELEASE\"] = self.release\n            self.env[\"PYTHONPATH\"] = PYTHONPATH\n        except Exception as e:\n            raise\n        finally:\n            pass\n\n    def shell(\n        self,\n        path: str,\n    ):\n        \"\"\"Start shell with environment.\"\"\"\n        try:\n            try:\n                sp = subprocess.Popen(\n                    [path],\n                    pass_fds=[0, 1, 2],\n                    env=self.env,\n                )\n            except Exception as e:\n                raise Exception(f\"failed to start shell ({path})\")\n\n            try:\n                # close streams\n                sys.stdin.close()\n                sys.stdout.close()\n                sys.stderr.close()\n\n                # close fds\n                os.close(0)\n                os.close(1)\n                os.close(2)\n            except Exception as e:\n                raise Exception(\"failed to close streams/fds\")\n\n            os.waitpid(sp.pid, 0)\n        except Exception as e:\n            raise\n\n    def wait(self, secs: int = 1000000):\n        \"\"\"Wait indefinitely.\"\"\"\n        time.sleep(secs)", "\nclass Booter:\n    \"\"\"Provides PENVM network boot support from configuration file.\"\"\"\n\n    def __init__(\n        self,\n        configfilename: str,\n        networkname: str,\n        release: str,\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            configfilename: Configuration file name.\n            networkname: Network name.\n            release: PENVM release.\n        \"\"\"\n        self.configfilename = configfilename\n        self.networkname = networkname\n        self.release = release\n\n        self.world = None\n        self.network = None\n        self.env = None\n\n    def boot(self):\n        \"\"\"Boot.\"\"\"\n        try:\n            self.world = World(filename=self.configfilename)\n            self.network = self.world.get_network(self.networkname)\n            # print(f\"{self.networkname=}\")\n            if self.network == None or self.network.get_targets() in [None, []]:\n                raise Exception(f\"network ({self.networkname}) not found\")\n            self.network.boot()\n\n            machines = self.network.get_machines()\n            if machines in [None, []]:\n                raise Exception(\"no machines\")\n            if None in machines:\n                raise Exception(\"not all machines found\")\n\n            self.release = self.release or self.world.get_meta(\"release\") or get_version_string()\n            if self.release == None:\n                raise Exception(f\"could not determine release value\")\n\n            releasepath = os.path.expanduser(f\"~/.penvm/releases/{self.release}\")\n            releaselibs = \":\".join([f\"{releasepath}/{name}\" for name in [\"penvmlib-client\"]])\n\n            # patch env\n            self.env = os.environ.copy()\n            PENVM_AUTO_NETWORK = str(self.network)\n            PYTHONPATH = self.env.get(\"PYTHONPATH\")\n            if PYTHONPATH != None:\n                PYTHONPATH = f\"{releaselibs}:{PYTHONPATH}\"\n            else:\n                PYTHONPATH = releaselibs\n\n            self.env[\"PENVM_AUTO_NETWORK\"] = PENVM_AUTO_NETWORK\n            self.env[\"PENVM_RELEASE\"] = self.release\n            self.env[\"PYTHONPATH\"] = PYTHONPATH\n        except Exception as e:\n            raise\n        finally:\n            pass\n\n    def shell(\n        self,\n        path: str,\n    ):\n        \"\"\"Start shell with environment.\"\"\"\n        try:\n            try:\n                sp = subprocess.Popen(\n                    [path],\n                    pass_fds=[0, 1, 2],\n                    env=self.env,\n                )\n            except Exception as e:\n                raise Exception(f\"failed to start shell ({path})\")\n\n            try:\n                # close streams\n                sys.stdin.close()\n                sys.stdout.close()\n                sys.stderr.close()\n\n                # close fds\n                os.close(0)\n                os.close(1)\n                os.close(2)\n            except Exception as e:\n                raise Exception(\"failed to close streams/fds\")\n\n            os.waitpid(sp.pid, 0)\n        except Exception as e:\n            raise\n\n    def wait(self, secs: int = 1000000):\n        \"\"\"Wait indefinitely.\"\"\"\n        time.sleep(secs)", ""]}
