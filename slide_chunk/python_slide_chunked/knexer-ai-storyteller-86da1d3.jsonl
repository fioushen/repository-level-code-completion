{"filename": "filter_ideas.py", "chunked_list": ["import openai\nimport json\nimport concurrent\nimport random\n\nnum_voters = 6\n\n\ndef filter_ideas(ideas, criteria):\n    all_ideas = []\n    with concurrent.futures.ThreadPoolExecutor() as executor:\n        # Use a list comprehension to create a list of two Future objects\n        future_list = [\n            executor.submit(pick_five, ideas, criteria) for _ in range(num_voters)\n        ]\n\n        # As the futures complete, extend `all_ideas` with their results\n        for future in concurrent.futures.as_completed(future_list):\n            all_ideas.extend(future.result())\n\n    counts = [(idea, all_ideas.count(idea)) for idea in set(all_ideas)]\n    sorted_by_votes = sorted(counts, key=lambda x: x[1], reverse=True)\n\n    return sorted_by_votes", "def filter_ideas(ideas, criteria):\n    all_ideas = []\n    with concurrent.futures.ThreadPoolExecutor() as executor:\n        # Use a list comprehension to create a list of two Future objects\n        future_list = [\n            executor.submit(pick_five, ideas, criteria) for _ in range(num_voters)\n        ]\n\n        # As the futures complete, extend `all_ideas` with their results\n        for future in concurrent.futures.as_completed(future_list):\n            all_ideas.extend(future.result())\n\n    counts = [(idea, all_ideas.count(idea)) for idea in set(all_ideas)]\n    sorted_by_votes = sorted(counts, key=lambda x: x[1], reverse=True)\n\n    return sorted_by_votes", "\n\ndef format_ideas(ideas):\n    return \"\\n\".join([f\"{i}. {idea}\" for i, idea in enumerate(ideas, start=1)])\n\n\ndef pick_five(ideas, criteria):\n    shuffled_ideas = ideas\n    random.shuffle(shuffled_ideas)\n\n    prompt = f\"\"\"You are an AI writing assistant helping an author filter through their story concepts to find the ideas with the most potential.\nThe following is a list of ideas for an illustrated children's book:\n\n{format_ideas(ideas)}\n\nPick the five {criteria}.\"\"\"\n\n    unformatted_five_ideas = openai.ChatCompletion.create(\n        model=\"gpt-3.5-turbo\",\n        messages=[\n            {\"role\": \"user\", \"content\": prompt},\n        ],\n        n=1,\n        temperature=1,\n    )\n\n    five_titles_list = openai.ChatCompletion.create(\n        model=\"gpt-3.5-turbo\",\n        messages=[\n            {\"role\": \"user\", \"content\": prompt},\n            unformatted_five_ideas.choices[0].message,\n            {\n                \"role\": \"user\",\n                \"content\": \"\"\"Reformat the titles of your chosen five ideas into a json list format.\nOutput json ONLY - your output will be directly parsed so it must have NO other text such as a preamble.\"\"\",\n            },\n        ],\n        n=1,\n        temperature=0,\n    )\n\n    try:\n        return json.loads(five_titles_list.choices[0].message.content)\n    except:\n        print(f\"Could not parse as JSON: {five_titles_list.choices[0].message.content}\")\n        return []", ""]}
{"filename": "parsing_utils.py", "chunked_list": ["import re\n\n\ndef parse_numbered_list(response):\n    # Response is a string with a numbered list of items\n\n    # Match the start of each list element\n    # Regex explanation:\n    # ^(\\d+) - Match a number at the start of a line\n    # [^\\w\\n] - Match a non-word character (e.g. a period, colon, or close parenthesis)\n    matches = re.finditer(r\"^(\\d+)[^\\w\\n]\", response, re.MULTILINE)\n\n    # Extract indices and sort them\n    indices = [match.start() for match in matches]\n    indices.append(len(response))\n    indices.sort()\n\n    # Extract items using indices\n    items = [\n        response[indices[i] : indices[i + 1]].strip() for i in range(len(indices) - 1)\n    ]\n\n    # Remove the number, punctuation, and leading whitespace from each item\n    items = [re.sub(r\"^\\d+[^\\w\\n]\\s*\", \"\", item, flags=re.MULTILINE) for item in items]\n\n    if len(items) != 3:\n        return []\n\n    return items", ""]}
{"filename": "write_story.py", "chunked_list": ["import os\nimport sys\nfrom collections import defaultdict\nfrom fuzzywuzzy import fuzz\nimport openai\nfrom dotenv import load_dotenv\n\nfrom ideation import Ideation\nfrom filter_ideas import filter_ideas\nfrom outline_story import Outliner", "from filter_ideas import filter_ideas\nfrom outline_story import Outliner\nfrom draft_story import Drafter\n\nfrom story_development.development_ga import DevelopmentGA\n\n\ndef print_numbered_list(label, list):\n    print(f\"\\n{label}:\\n\")\n    for i, item in enumerate(list, start=1):\n        print(f\"{i}. {item}\")", "\n\ndef get_full_idea(ideas, title):\n    return max(\n        [(idea, fuzz.partial_ratio(idea, title)) for idea in ideas], key=lambda x: x[1]\n    )[0]\n\n\nload_dotenv()\nopenai.api_key = os.environ[\"OPENAI_API_KEY\"]", "load_dotenv()\nopenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\nif len(sys.argv) != 2:\n    print(f\"wrong number of args, expected 1, got {len(sys.argv)}\")\n    exit()\n\n# Collect (optional) user-specified conditioning information, e.g. target audience, characters, setting, visual style, plot elements, etc.\nconditioning_info = sys.argv[1]\n", "conditioning_info = sys.argv[1]\n\nprint(f\"Generating a story conditioned on:\\n{conditioning_info}\")\n\n# Come up with a bunch of ideas\nideas = Ideation(conditioning_info).make_ideas(3)\nprint_numbered_list(\"Generated ideas\", ideas)\n\n# Find the best ideas\nmost_creative = filter_ideas(", "# Find the best ideas\nmost_creative = filter_ideas(\n    ideas, \"most creative, surprising, and unexpected ideas that excite the imagination\"\n)\nprint_numbered_list(\"Most creative ideas\", most_creative)\n\nbest_fit = filter_ideas(\n    ideas, \"ideas that best fit the client's constraints:\\n{conditioning_info}\"\n)\nprint_numbered_list(\"Most targeted ideas\", best_fit)", ")\nprint_numbered_list(\"Most targeted ideas\", best_fit)\n\ncutest = filter_ideas(ideas, \"cutest and most adorable stories\")\nprint_numbered_list(\"Cutest ideas\", cutest)\n\n# Combine the weighted vote counts from each filter\ncombined_vote_counts = defaultdict(float)\nfor weight, votes in zip([0.5, 0.3, 0.2], [most_creative, best_fit, cutest]):\n    for idea, count in votes:\n        combined_vote_counts[idea] += count * weight", "for weight, votes in zip([0.5, 0.3, 0.2], [most_creative, best_fit, cutest]):\n    for idea, count in votes:\n        combined_vote_counts[idea] += count * weight\n\n# Sort the combined vote counts in descending order\nsorted_by_combined_votes = sorted(\n    combined_vote_counts.items(), key=lambda x: x[1], reverse=True\n)\n\nprint_numbered_list(\"Overall best ideas\", sorted_by_combined_votes)", "\nprint_numbered_list(\"Overall best ideas\", sorted_by_combined_votes)\n\nselected_title = sorted_by_combined_votes[0][0]\nselected_idea = get_full_idea(ideas, selected_title)\nprint(f\"\\nSelected idea:\\n\")\nprint(selected_idea)\n\npremise = f\"{selected_title}: {selected_idea}\"\noutliner = Outliner(conditioning_info, premise)", "premise = f\"{selected_title}: {selected_idea}\"\noutliner = Outliner(conditioning_info, premise)\ninitial_ideas = outliner.outline(1)\nprint(\"\\n\\nNotes:\\n\\n\")\nprint(initial_ideas[0])\n\nga = DevelopmentGA(conditioning_info, premise, initial_ideas)\nbest_individual = ga.evolve(0, 1, 2)\n\nstories = Drafter(conditioning_info, best_individual.get_notes()).draft()", "\nstories = Drafter(conditioning_info, best_individual.get_notes()).draft()\nprint(f\"\\nPotential stories:\\n\")\nprint(\"\\n\\n========\\n\\n\".join(story for story in stories))\n\n# Write a more detailed story description\n# Split the story up into pages, each with a couple lines of story and a brief image description.\n# Produce an illustration for each page. Special care will need to be taken to get (semi) consistent characters and settings.\n# Format the series of pages into a book.\n", "# Format the series of pages into a book.\n"]}
{"filename": "ideation.py", "chunked_list": ["import re\nimport openai\n\n\ndef parse_ideas(texts):\n    # The regular expression pattern:\n    # It looks for a number followed by a '.', ':', or ')' (with optional spaces)\n    # and then captures any text until it finds a newline character or the end of the string\n    pattern = re.compile(r\"\\d[\\.\\:\\)]\\s*(.*?)(?=\\n\\d|$)\", re.MULTILINE)\n\n    # Find all matches using the 'findall' method\n    matches = []\n    for text in texts:\n        matches = matches + pattern.findall(text)\n\n    # Return the matches\n    return matches", "\n\nclass Ideation:\n    def __init__(self, conditioning_info):\n        self.conditioning_info = conditioning_info\n\n    def outline_prompt(self):\n        return f\"\"\"You are an AI storybook writer. You write engaging, creative, and highly diverse content for illustrated books for children.\nThe first step in your process is ideation - workshop a bunch of ideas and find the ones with that special spark.\n\nYour client has provided some constraints for you to satisfy, but within those constraints you have total artistic control, so get creative with it!\nClient constraints:\n{self.conditioning_info}\n\nEach idea should have a title and a 2-3 sentence premise mentioning the protagonist, the setting, and the conflict, while also highlighting what makes the story interesting.\nHere's an example of a successful premise:\n\u201cRomeo and Juliet\": Two teens, Romeo and Juliet, pursue their forbidden love with each other\u2014to the chagrin of their rival families. When Juliet must choose between her family and her heart, both lovers must find a way to stay united, even if fate won't allow it.\n\n\nCome up with a numbered list of eight of your best ideas. Focus on variety within the scope of the client's requests.\n\"\"\"\n\n    def make_ideas(self, n):\n        response = openai.ChatCompletion.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[\n                {\"role\": \"user\", \"content\": self.outline_prompt()},\n            ],\n            n=n,\n            temperature=1,\n        )\n\n        return parse_ideas([choice.message.content for choice in response.choices])", ""]}
{"filename": "outline_story.py", "chunked_list": ["import openai\n\nclass Outliner:\n    def __init__(self, conditioning_info, premise):\n        self.conditioning_info = conditioning_info\n        self.premise = premise\n\n    def outline_prompt(self):\n        return f\"\"\"You are an AI storyteller who specializes in illustrated books for young children. You are fleshing out a story premise for a client today.\nThe client's requirements are:\n{self.conditioning_info}\n\nThe story premise is:\n{self.premise}\n\nFirst, expand that quick premise into a more detailed form, including:\n- What characters are involved in the story? What are their motivations? How might they interact with and relate to one another?\n- What settings and environments will the story take place in? What makes them unique? How do they relate to the premise and the characters?\n- What are the main themes and messages in the story?\n\nThen, given that information, write an outline for the story.\nFollow a classic narrative structure: exposition, rising action, climax, falling action, and resolution.\nEnsure that the story has a clear message and a logical progression.\n\"\"\"\n\n    def outline(self, n=1):\n        response = openai.ChatCompletion.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[\n                {\"role\": \"user\", \"content\": self.outline_prompt()},\n            ],\n            n=n,\n            temperature=1,\n        )\n\n        return [choice.message.content for choice in response.choices]", ""]}
{"filename": "draft_story.py", "chunked_list": ["import openai\n\n\nclass Drafter:\n    def __init__(self, conditioning_info, outline):\n        self.conditioning_info = conditioning_info\n        self.outline = outline\n\n    def draft_prompt(self):\n        return f\"\"\"You are an award-winning author of illustrated children's books. You have been contracted by a client to write a custom book for them.\nThey gave you these requiremnts: {self.conditioning_info}\n\nThe following is a story outline you came up with for the book:\n{self.outline}\n\nCompose a rough draft of the book itself. Your draft should be a sequence of page descriptions, where each page has:\n- a composition,\n- the contents of any text paragraphs on the page, and\n- a brief description of the illustration.\"\"\"\n\n    def draft(self):\n        response = openai.ChatCompletion.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[\n                {\"role\": \"user\", \"content\": self.draft_prompt()},\n            ],\n            n=2,\n            temperature=1,\n        )\n\n        return [choice.message.content for choice in response.choices]", ""]}
{"filename": "story_development/test_themes.py", "chunked_list": ["import openai\n\nimport os\nfrom dotenv import load_dotenv\n\nfrom story_development.themes import Themes\n\nload_dotenv()\nopenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n", "openai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\nconditioning_info = \"target audience is a 5 year old boy.The story should help the reader overcome a fear of butterflies.\"\npremise = '\"The Butterfly Keeper\": In a small village, a young boy named Juan loves catching and collecting butterflies. However, when he learns about the importance of butterflies in the ecosystem, he must reconcile his love of catching them with the need to protect them.'\noutline = \"\"\"Expanded Story Premise:\n\nCharacters:\n- Juan, a curious and adventurous 5-year-old boy who loves catching butterflies.\n- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.", "- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.\n\nSetting:\n- A small village surrounded by lush green forests and meadows.\n- A butterfly garden filled with colorful flowers and plants, where Juan spends most of his time catching butterflies.\n- The Butterfly Keeper's home, a cottage in the woods, surrounded by a butterfly sanctuary.\n\nThemes:\n- Caring for nature and its creatures.", "Themes:\n- Caring for nature and its creatures.\n- Empathy and understanding.\n- Overcoming fears.\n\nOutline:\n\nExposition:\n- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.", "- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.\n\nRising Action:\n- Juan spots a rare butterfly in his garden, which he wants to catch. Despite Abuela's warning, he chases after it but ends up getting hurt and scaring the butterfly away.\n- Feeling guilty, Juan decides to learn more about how to care for butterflies. He asks Abuela for help, and she suggests that they visit the Butterfly Keeper to learn from an expert.\n\nClimax:\n- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.", "- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.\n\nFalling Action:\n- Juan realizes his fear of butterflies stems from not knowing enough about them. He apologizes to the Butterfly Keeper and asks to learn more.\n- The Butterfly Keeper teaches Juan how to gently hold and care for the butterflies, and Juan gains a newfound appreciation and understanding for these beautiful creatures.\n\nResolution:\n- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"", "- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"\nthemes = Themes(conditioning_info, premise, outline)\nthemes.score(verbose=True, n=3)\nrecommendations = themes.make_recommendations(1, verbose=True)\n[print(recommendation) for recommendation in recommendations]\n"]}
{"filename": "story_development/test_apply_recommendation.py", "chunked_list": ["import openai\n\nimport os\nfrom dotenv import load_dotenv\nfrom ga.individual import Individual\n\nfrom story_development.characters import Characters\n\nload_dotenv()\nopenai.api_key = os.environ[\"OPENAI_API_KEY\"]", "load_dotenv()\nopenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\nconditioning_info = \"target audience is a 5 year old boy.The story should help the reader overcome a fear of butterflies.\"\npremise = '\"The Butterfly Keeper\": In a small village, a young boy named Juan loves catching and collecting butterflies. However, when he learns about the importance of butterflies in the ecosystem, he must reconcile his love of catching them with the need to protect them.'\noutline = \"\"\"Expanded Story Premise:\n\nCharacters:\n- Juan, a curious and adventurous 5-year-old boy who loves catching butterflies.\n- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.", "- Juan, a curious and adventurous 5-year-old boy who loves catching butterflies.\n- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.\n\nSetting:\n- A small village surrounded by lush green forests and meadows.\n- A butterfly garden filled with colorful flowers and plants, where Juan spends most of his time catching butterflies.\n- The Butterfly Keeper's home, a cottage in the woods, surrounded by a butterfly sanctuary.\n\nThemes:", "\nThemes:\n- Caring for nature and its creatures.\n- Empathy and understanding.\n- Overcoming fears.\n\nOutline:\n\nExposition:\n- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.", "Exposition:\n- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.\n\nRising Action:\n- Juan spots a rare butterfly in his garden, which he wants to catch. Despite Abuela's warning, he chases after it but ends up getting hurt and scaring the butterfly away.\n- Feeling guilty, Juan decides to learn more about how to care for butterflies. He asks Abuela for help, and she suggests that they visit the Butterfly Keeper to learn from an expert.\n\nClimax:\n- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.", "Climax:\n- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.\n\nFalling Action:\n- Juan realizes his fear of butterflies stems from not knowing enough about them. He apologizes to the Butterfly Keeper and asks to learn more.\n- The Butterfly Keeper teaches Juan how to gently hold and care for the butterflies, and Juan gains a newfound appreciation and understanding for these beautiful creatures.\n\nResolution:\n- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.", "Resolution:\n- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"\ncharacters = Characters(conditioning_info, premise, outline)\nindividual = Individual(characters)\nrecommendation = \"\"\"Combine Abuela and the Butterfly Keeper into one character - a wise, caring grandmother who is also an expert on butterflies. This would reduce redundancy and make her character more unique. She can guide Juan throughout the story, teaching him about the importance of butterflies while also offering him a chance to learn from her expertise.\"\"\"\nprint(individual.apply_recommendation(characters, recommendation, verbose=True))\n"]}
{"filename": "story_development/characters.py", "chunked_list": ["from ga.category import Category\n\n\nclass Characters(Category):\n    def __init__(self, conditioning_info, premise, notes):\n        Category.__init__(self, conditioning_info, premise, notes)\n\n    def category_name(self):\n        return \"characters\"\n\n    def best_possible_score(self):\n        return 25\n\n    def rubric(self):\n        return \"\"\"An ideal cast of characters will:\n- Be memorable and original\n- Have distinct characterization and roles, with minimal redundancy\n- Be relatable for the target audience\n- Have clear motivations, goals, and, for the main characters, growth\n- Have age-appropriate complexity and depth\"\"\"\n\n    def recommendations_reminder(self):\n        return \"\"\"Remember that combining characters, distilling overly complex characters, and simplifying for the target audience are often important too, not only adding things. Don't be afraid to recommend big changes.\"\"\"", ""]}
{"filename": "story_development/test_outline.py", "chunked_list": ["import openai\n\nimport os\nfrom dotenv import load_dotenv\n\nfrom story_development.outline import Outline\n\nload_dotenv()\nopenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n", "openai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\nconditioning_info = \"target audience is a 5 year old boy.The story should help the reader overcome a fear of butterflies.\"\npremise = '\"The Butterfly Keeper\": In a small village, a young boy named Juan loves catching and collecting butterflies. However, when he learns about the importance of butterflies in the ecosystem, he must reconcile his love of catching them with the need to protect them.'\noutline = \"\"\"Expanded Story Premise:\n\nCharacters:\n- Juan, a curious and adventurous 5-year-old boy who loves catching butterflies.\n- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.", "- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.\n\nSetting:\n- A small village surrounded by lush green forests and meadows.\n- A butterfly garden filled with colorful flowers and plants, where Juan spends most of his time catching butterflies.\n- The Butterfly Keeper's home, a cottage in the woods, surrounded by a butterfly sanctuary.\n\nThemes:\n- Caring for nature and its creatures.", "Themes:\n- Caring for nature and its creatures.\n- Empathy and understanding.\n- Overcoming fears.\n\nOutline:\n\nExposition:\n- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.", "- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.\n\nRising Action:\n- Juan spots a rare butterfly in his garden, which he wants to catch. Despite Abuela's warning, he chases after it but ends up getting hurt and scaring the butterfly away.\n- Feeling guilty, Juan decides to learn more about how to care for butterflies. He asks Abuela for help, and she suggests that they visit the Butterfly Keeper to learn from an expert.\n\nClimax:\n- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.", "- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.\n\nFalling Action:\n- Juan realizes his fear of butterflies stems from not knowing enough about them. He apologizes to the Butterfly Keeper and asks to learn more.\n- The Butterfly Keeper teaches Juan how to gently hold and care for the butterflies, and Juan gains a newfound appreciation and understanding for these beautiful creatures.\n\nResolution:\n- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"", "- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"\noutline = Outline(conditioning_info, premise, outline)\noutline.score(verbose=True, n=3)\nrecommendations = outline.make_recommendations(1, verbose=True)\n[print(recommendation) for recommendation in recommendations]\n"]}
{"filename": "story_development/setting.py", "chunked_list": ["from ga.category import Category\n\n\nclass Setting(Category):\n    def __init__(self, conditioning_info, premise, notes):\n        Category.__init__(self, conditioning_info, premise, notes)\n\n    def category_name(self):\n        return \"setting\"\n\n    def best_possible_score(self):\n        return 25\n\n    def rubric(self):\n        return \"\"\"An ideal setting:\n- excites the imagination with originality and depth\n- has excellent potential for illustration\n- is relatable and appropriate for the target audience\n- demonstrates themes or conflict with illustrative or contrasting setting elements\n- has well-differentiated locations with distinct story roles and contrasting characteristics (give a 5/5 if it has only one location)\"\"\"\n\n    def recommendations_reminder(self):\n        return \"\"\"Prefer to keep things simple - replacing, simplifying, or deleting a location, or combining two redundant locations - instead of adding more stuff. Don't be afraid to recommend big changes. Remember, these are early story notes, so focus on the core elements. Descriptive language and non-story-relevant details will happen later.\"\"\"", ""]}
{"filename": "story_development/test_characters.py", "chunked_list": ["import openai\n\nimport os\nfrom dotenv import load_dotenv\n\nfrom story_development.characters import Characters\n\nload_dotenv()\nopenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n", "openai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\nconditioning_info = \"target audience is a 5 year old boy.The story should help the reader overcome a fear of butterflies.\"\npremise = '\"The Butterfly Keeper\": In a small village, a young boy named Juan loves catching and collecting butterflies. However, when he learns about the importance of butterflies in the ecosystem, he must reconcile his love of catching them with the need to protect them.'\noutline = \"\"\"Expanded Story Premise:\n\nCharacters:\n- Juan, a curious and adventurous 5-year-old boy who loves catching butterflies.\n- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.", "- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.\n\nSetting:\n- A small village surrounded by lush green forests and meadows.\n- A butterfly garden filled with colorful flowers and plants, where Juan spends most of his time catching butterflies.\n- The Butterfly Keeper's home, a cottage in the woods, surrounded by a butterfly sanctuary.\n\nThemes:\n- Caring for nature and its creatures.", "Themes:\n- Caring for nature and its creatures.\n- Empathy and understanding.\n- Overcoming fears.\n\nOutline:\n\nExposition:\n- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.", "- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.\n\nRising Action:\n- Juan spots a rare butterfly in his garden, which he wants to catch. Despite Abuela's warning, he chases after it but ends up getting hurt and scaring the butterfly away.\n- Feeling guilty, Juan decides to learn more about how to care for butterflies. He asks Abuela for help, and she suggests that they visit the Butterfly Keeper to learn from an expert.\n\nClimax:\n- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.", "- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.\n\nFalling Action:\n- Juan realizes his fear of butterflies stems from not knowing enough about them. He apologizes to the Butterfly Keeper and asks to learn more.\n- The Butterfly Keeper teaches Juan how to gently hold and care for the butterflies, and Juan gains a newfound appreciation and understanding for these beautiful creatures.\n\nResolution:\n- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"", "- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"\ncharacters = Characters(conditioning_info, premise, outline)\ncharacters.score(verbose=True, n=1)\nrecommendation = characters.make_recommendation(verbose=True)\n"]}
{"filename": "story_development/development_ga.py", "chunked_list": ["import openai\n\nfrom ga.ga import GeneticAlgorithmBase\nfrom ga.individual import Individual\nfrom outline_story import Outliner\nfrom story_development.characters import Characters\nfrom story_development.outline import Outline\nfrom story_development.setting import Setting\nfrom story_development.themes import Themes\n", "from story_development.themes import Themes\n\n\nclass DevelopmentGA(GeneticAlgorithmBase):\n    def __init__(self, conditioning_info, premise, inital_ideas):\n        self.conditioning_info = conditioning_info\n        self.premise = premise\n        initial_population = [self.make_individual(idea) for idea in inital_ideas]\n        GeneticAlgorithmBase.__init__(self, initial_population)\n\n    def make_individual(self, notes):\n        return Individual(\n            [\n                Characters(self.conditioning_info, self.premise, notes),\n                Setting(self.conditioning_info, self.premise, notes),\n                Themes(self.conditioning_info, self.premise, notes),\n                Outline(self.conditioning_info, self.premise, notes),\n            ]\n        )\n\n    def compute_fitness(self, individual):\n        if not individual.is_scored():\n            individual.score()\n\n        return individual.total_score()\n\n    def mutate(self, individual):\n        category, recommendation = individual.make_recommendation()\n        print(f\"Got recommendation for {category.category_name()}: {recommendation}\")\n        mutated_notes = individual.apply_recommendation(category, recommendation)\n        print(f\"Revised notes: {mutated_notes}\")\n        return self.make_individual(mutated_notes)\n\n    def crossover(self, parent1, parent2):\n        # Given two individuals, parent1 as the primary and parent2 as the secondary\n        # Identify the best things about parent2, based on the feedback\n        # Update parent1 to incorporate those best things\n        raise NotImplementedError(\n            \"Derived classes must implement the crossover operator\"\n        )", ""]}
{"filename": "story_development/themes.py", "chunked_list": ["from ga.category import Category\n\n\nclass Themes(Category):\n    def __init__(self, conditioning_info, premise, notes):\n        Category.__init__(self, conditioning_info, premise, notes)\n\n    def category_name(self):\n        return \"themes\"\n\n    def best_possible_score(self):\n        return 20\n\n    def rubric(self):\n        return \"\"\"Ideal themes are:\n- Relevant and engaging for the target audience (see client requirements above)\n- Clearly shown by and well-explored in the events of the story\n- Positive, empowering, and educational\n- Respectful of diversity, avoiding stereotypes and cultural insensitivity\"\"\"\n\n    def recommendations_reminder(self):\n        return \"\"\"Remember that combining themes, distilling overly complex themes, and simplifying for the target audience are often important too, not only adding things. Don't be afraid to recommend big changes.\"\"\"", ""]}
{"filename": "story_development/outline.py", "chunked_list": ["from ga.category import Category\n\n\nclass Outline(Category):\n    def __init__(self, conditioning_info, premise, notes):\n        Category.__init__(self, conditioning_info, premise, notes)\n\n    def category_name(self):\n        return \"outline\"\n\n    def best_possible_score(self):\n        return 25\n\n    def rubric(self):\n        return \"\"\"An ideal outline:\n- Conflict and tension: Has a clear and compelling central conflict that creates tension\n- Resolution: Resolves its central conflict in a satisfying and logical manner that does not feel abrupt or unjustified\n- Pacing: Is ruthlessly edited and engagingly paced; every event is critical to the story\n- Narrative consistency: Follows a logical progression, with no plot holes, non sequitors, or unfulfilled promises\n- Character-driven: Drives plot by the actions decisions of characters, not external events or coincidences\"\"\"\n\n    def recommendations_reminder(self):\n        return \"\"\"Remember that eliminating or combining redundant events, refocusing on the central conflict, and simplifying concepts for the target audience are often important too, not only adding more things. Don't be afraid to recommend big changes. Finally, remember that this is just an outline, so focus on the core elements of the plot; descriptive language will happen later.\"\"\"", ""]}
{"filename": "story_development/test_feedback.py", "chunked_list": ["import openai\n\nimport os\nfrom dotenv import load_dotenv\n\nfrom story_development.development_ga import DevelopmentGA\n\nload_dotenv()\nopenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n", "openai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\nconditioning_info = \"target audience is a 5 year old boy.The story should help the reader overcome a fear of butterflies.\"\npremise = \"\\\"The Butterfly Keeper\\\": In a small village, a young boy named Juan loves catching and collecting butterflies. However, when he learns about the importance of butterflies in the ecosystem, he must reconcile his love of catching them with the need to protect them.\"\noutline = \"\"\"Expanded Story Premise:\n\nCharacters:\n- Juan, a curious and adventurous 5-year-old boy who loves catching butterflies.\n- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.", "- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.\n\nSetting:\n- A small village surrounded by lush green forests and meadows.\n- A butterfly garden filled with colorful flowers and plants, where Juan spends most of his time catching butterflies.\n- The Butterfly Keeper's home, a cottage in the woods, surrounded by a butterfly sanctuary.\n\nThemes:\n- Caring for nature and its creatures.", "Themes:\n- Caring for nature and its creatures.\n- Empathy and understanding.\n- Overcoming fears.\n\nOutline:\n\nExposition:\n- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.", "- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.\n\nRising Action:\n- Juan spots a rare butterfly in his garden, which he wants to catch. Despite Abuela's warning, he chases after it but ends up getting hurt and scaring the butterfly away.\n- Feeling guilty, Juan decides to learn more about how to care for butterflies. He asks Abuela for help, and she suggests that they visit the Butterfly Keeper to learn from an expert.\n\nClimax:\n- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.", "- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.\n\nFalling Action:\n- Juan realizes his fear of butterflies stems from not knowing enough about them. He apologizes to the Butterfly Keeper and asks to learn more.\n- The Butterfly Keeper teaches Juan how to gently hold and care for the butterflies, and Juan gains a newfound appreciation and understanding for these beautiful creatures.\n\nResolution:\n- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"", "- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"\nga = DevelopmentGA(conditioning_info, premise, [outline])\nga.get_feedback(outline, verbose=True)"]}
{"filename": "story_development/test_setting.py", "chunked_list": ["import openai\n\nimport os\nfrom dotenv import load_dotenv\n\nfrom story_development.setting import Setting\n\nload_dotenv()\nopenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n", "openai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\nconditioning_info = \"target audience is a 5 year old boy.The story should help the reader overcome a fear of butterflies.\"\npremise = '\"The Butterfly Keeper\": In a small village, a young boy named Juan loves catching and collecting butterflies. However, when he learns about the importance of butterflies in the ecosystem, he must reconcile his love of catching them with the need to protect them.'\noutline = \"\"\"Expanded Story Premise:\n\nCharacters:\n- Juan, a curious and adventurous 5-year-old boy who loves catching butterflies.\n- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.", "- Abuela, Juan's grandmother, who is wise and caring. She is concerned about the butterflies' welfare and wants to teach Juan about their importance.\n- The Butterfly Keeper, an expert on butterflies who lives outside the village. She is empathetic and patient and teaches Juan about the importance of butterflies in the ecosystem.\n\nSetting:\n- A small village surrounded by lush green forests and meadows.\n- A butterfly garden filled with colorful flowers and plants, where Juan spends most of his time catching butterflies.\n- The Butterfly Keeper's home, a cottage in the woods, surrounded by a butterfly sanctuary.\n\nThemes:\n- Caring for nature and its creatures.", "Themes:\n- Caring for nature and its creatures.\n- Empathy and understanding.\n- Overcoming fears.\n\nOutline:\n\nExposition:\n- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.", "- Juan loves catching and collecting butterflies in his butterfly garden. He doesn't understand why his grandmother, Abuela, is concerned about harming the butterflies.\n- Abuela tells Juan about the importance of butterflies in the ecosystem, and how they help pollinate plants and flowers. She shows him how to care for the butterflies, and they release them back into the garden.\n\nRising Action:\n- Juan spots a rare butterfly in his garden, which he wants to catch. Despite Abuela's warning, he chases after it but ends up getting hurt and scaring the butterfly away.\n- Feeling guilty, Juan decides to learn more about how to care for butterflies. He asks Abuela for help, and she suggests that they visit the Butterfly Keeper to learn from an expert.\n\nClimax:\n- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.", "- At the Butterfly Keeper's home, Juan learns about the different types of butterflies and how they contribute to the ecosystem. He also helps the Butterfly Keeper care for the butterflies and releases them back into their sanctuary.\n- However, when Juan encounters a large butterfly, he becomes scared and runs away, leaving the butterfly in danger. The Butterfly Keeper tells Juan that having a fear of butterflies is okay, but he must learn to empathize with them and respect their place in nature.\n\nFalling Action:\n- Juan realizes his fear of butterflies stems from not knowing enough about them. He apologizes to the Butterfly Keeper and asks to learn more.\n- The Butterfly Keeper teaches Juan how to gently hold and care for the butterflies, and Juan gains a newfound appreciation and understanding for these beautiful creatures.\n\nResolution:\n- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"", "- Juan returns home and shows Abuela all that he has learned while caring for the butterflies. He promises to protect and respect them, and never harm them again.\n- The story ends with Juan and Abuela sitting in the butterfly garden, watching the beautiful creatures flutter around them, feeling grateful for all that they have learned.\"\"\"\nsetting = Setting(conditioning_info, premise, outline)\nsetting.score(verbose=True, n=3)\nrecommendations = setting.make_recommendations(1, verbose=True)\n[print(recommendation) for recommendation in recommendations]\n"]}
{"filename": "ga/category.py", "chunked_list": ["import openai\n\nimport random\nimport re\n\n\nclass Category:\n    def __init__(self, conditioning_info, premise, notes):\n        self.conditioning_info = conditioning_info\n        self.premise = premise\n        self.notes = notes\n\n    def category_name(self):\n        raise NotImplementedError(\"Derived classes must define a category name\")\n\n    def best_possible_score(self):\n        raise NotImplementedError(\"Derived classes must define the best possible score\")\n\n    def rubric(self):\n        raise NotImplementedError(\"Derived classes must define the rubric\")\n\n    def recommendations_reminder(self):\n        raise NotImplementedError(\n            \"Derived classes must define the recommendations reminder\"\n        )\n\n    def scoring_prompt(self):\n        return f\"\"\"I'm working on an illustrated children's story for a client.\nThey gave me a premise:\n{self.premise}\nThey gave me other requirements:\n{self.conditioning_info}\n\nI have elaborated on the premise, producing these notes:\n{self.notes}\n\nCritique this story's {self.category_name()} based on this rubric.\n\n{self.rubric()}\n\nFollow the list structure of the rubric. For each item, discuss things the story's {self.category_name()} do well and things they do poorly in that respect, then lastly score that item out of 5. Be as harsh as possible!\n\nEnd your review with \"Overall Score: <sum of item scores>/{self.best_possible_score()}\". N/A for any item should count as a 5.\"\"\"\n\n    def score(self, verbose=False, n=1):\n        self.scores = []\n        prompt = self.scoring_prompt()\n        if verbose:\n            print(prompt)\n\n        response = openai.ChatCompletion.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[\n                {\"role\": \"user\", \"content\": prompt},\n            ],\n            n=n,\n            temperature=1,\n        )\n\n        if verbose:\n            [print(choice.message.content) for choice in response.choices]\n\n        scores = [\n            self.parse_score(prompt, choice.message.content)\n            for choice in response.choices\n        ]\n        scores = [score for score in scores if score is not None]\n\n        actual = len(scores)\n        if actual < n:\n            print(\n                f\"WARNING: Only {actual} scores could be parsed of the {n} responses.\"\n            )\n            self.score(verbose, n - actual)\n\n        self.scores.extend(scores)\n\n    def is_scored(self):\n        return hasattr(self, \"scores\")\n\n    def average_score(self):\n        return sum([int(score[\"score\"]) for score in self.scores]) / len(self.scores)\n\n    def normalized_score(self):\n        return self.average_score() / self.best_possible_score()\n\n    def parse_score(self, prompt, response):\n        score_regex = re.compile(\n            r\"Overall Score:\\s*(\\d{1,2}(?:\\.\\d{1,2})?)/\"\n            + f\"{self.best_possible_score()}\"\n        )\n        match = score_regex.search(response)\n\n        if not match:\n            print(f\"WARNING: Could not parse score from response: {response}\")\n            return None\n\n        overall_score = float(match.group(1))\n\n        return {\n            \"conversation\": [\n                {\"role\": \"user\", \"content\": prompt},\n                {\"role\": \"assistant\", \"content\": response},\n            ],\n            \"score\": overall_score,\n        }\n\n    def recommendations_prompt(self):\n        return f\"\"\"Based on your feedback, give three independent, detailed recommendations for how to improve the outline.\nEach recommendation should solve a problem highlighted above and specify every detail on what should be changed and how. DO NOT list multiple alternatives, options, or examples; give one detailed, concrete solution.\nEach recommendation should be independent of the others, as they will be evaluated separately.\n\n{self.recommendations_reminder()}\n\nGive your recommendations in a numbered list format. Omit preface, omit a summary, and omit other notes; include only the list itself.\"\"\"\n\n    def make_recommendation(self, verbose=False):\n        # Choose a score to improve on, weighted by mismatch between score and best possible score\n        num_missing_points = self.best_possible_score() * len(self.scores) - sum(\n            [score[\"score\"] for score in self.scores]\n        )\n        missing_point = random.uniform(0, num_missing_points)\n        current = 0\n        for score in self.scores:\n            current += self.best_possible_score() - score[\"score\"]\n            if current > missing_point:\n                return self.make_recommendation_from_score(score, verbose)\n\n    def make_recommendation_from_score(self, score, verbose=False):\n        prompt = self.recommendations_prompt()\n        if verbose:\n            print(prompt)\n        recommendations = openai.ChatCompletion.create(\n            model=\"gpt-3.5-turbo\",\n            messages=score[\"conversation\"] + [{\"role\": \"user\", \"content\": prompt}],\n            n=1,\n            temperature=1,\n        )\n        if verbose:\n            print(recommendations.choices[0].message.content)\n        pick_best_prompt = \"Which of those is the best recommendation? Repeat the recommendation, without the number and without any other preface text.\"\n        best_recommendation = openai.ChatCompletion.create(\n            model=\"gpt-3.5-turbo\",\n            messages=score[\"conversation\"]\n            + [{\"role\": \"user\", \"content\": prompt}]\n            + [recommendations.choices[0].message]\n            + [{\"role\": \"user\", \"content\": pick_best_prompt}],\n            n=1,\n            temperature=1,\n        )\n        if verbose:\n            print(best_recommendation.choices[0].message.content)\n\n        return best_recommendation.choices[0].message.content\n\n    def apply_recommendation_prompt(self, recommendation):\n        return f\"\"\"I'm working on an illustrated children's story for a client.\nThey gave me a premise:\n{self.premise}\nThey gave me other requirements:\n{self.conditioning_info}\n\nI have elaborated on the premise, producing these notes:\n====== ORIGINAL NOTES ======\n{self.notes}\n====== END ORIGINAL NOTES ======\n\nI received this feedback on the story's {self.category_name()}:\n{recommendation}\n\nRevise the notes to incorporate this feedback.\nBegin your response by strategizing how you will change the story notes based on the feedback. In addition to an overall plan, also carefully identify and resolve ambiguity in the recommendation. How are other aspects of the story impacted by the recommendation? Is there anything the recommendation doesn't specify adequately? Resolve that ambiguity before starting the revised notes, to ensure they are self-consistent, specific and fully meet the recommendation's objective.\nThen write your revised notes, wrapped in \"====== REVISED NOTES ======\" and \"====== END REVISED NOTES ======\".\"\"\"", ""]}
{"filename": "ga/ga.py", "chunked_list": ["import random\n\n# Implements a basic genetic algorithm. Derived classes must implement the various operators.\nclass GeneticAlgorithmBase:\n    def __init__(self, initial_population):\n        self.population = initial_population\n        self.population_size = len(initial_population)\n        self.fitness_cache = {}\n\n    # Memoize fitness calculations\n    def fitness(self, individual):\n        if individual not in self.fitness_cache:\n            self.fitness_cache[individual] = self.compute_fitness(individual)\n        return self.fitness_cache[individual]\n\n    def compute_fitness(self, individual):\n        raise NotImplementedError(\"Derived classes must implement the fitness function\")\n\n    def mutate(self, individual):\n        raise NotImplementedError(\"Derived classes must implement the mutation operator\")\n\n    def crossover(self, parent1, parent2):\n        raise NotImplementedError(\"Derived classes must implement the crossover operator\")\n\n    # Select parents randomly, proportional to their fitness\n    # todo - tournament selection is probably better. Interpreting the fitness value as ~probability is an unprincipled hack.\n    # Or culling to top-k, copying all of those, and then *also* picking some parents from that set?\n    def select_parents(self):\n        total_fitness = sum(self.fitness(individual) for individual in self.population)\n        pick = random.uniform(0, total_fitness)\n        current = 0\n        for individual in self.population:\n            current += self.fitness(individual)\n            if current > pick:\n                return individual\n        return self.population[-1]\n\n    def evolve(self, crossover_prob, mutation_prob, generations):\n        for _ in range(generations):\n            new_population = []\n            for _ in range(self.population_size):\n                parent1 = self.select_parents()\n                parent2 = self.select_parents()\n                if random.random() < crossover_prob:\n                    offspring = self.crossover(parent1, parent2)\n                else:\n                    offspring = random.choice([parent1, parent2])\n                if random.random() < mutation_prob:\n                    offspring = self.mutate(offspring)\n                new_population.append(offspring)\n            self.population = new_population\n            # self.fitness_cache = {} # clearing memoization cache probably not needed? We are cloning so keeping it helps\n\n        best_individual = max(self.population, key=self.fitness)\n        return best_individual", ""]}
{"filename": "ga/individual.py", "chunked_list": ["import random\n\nimport openai\n\n\nclass Individual:\n    def __init__(self, categories):\n        self.categories = categories\n\n    def get_notes(self):\n        return self.categories[0].notes\n\n    def is_scored(self):\n        return all(category.is_scored() for category in self.categories)\n\n    def score(self, verbose=False, n=3):\n        for category in self.categories:\n            print(f\"====== Scoring {category.category_name()} ======\")\n            category.score(verbose=verbose, n=n)\n            print(\n                f\"Average score for {category.category_name()}: {category.average_score()}/{category.best_possible_score()}\"\n            )\n\n    def total_score(self):\n        return sum(category.average_score() for category in self.categories)\n\n    def normalized_score(self):\n        return sum(category.normalized_score() for category in self.categories) / len(\n            self.categories\n        )\n\n    def best_possible_score(self):\n        return sum(category.best_possible_score() for category in self.categories)\n\n    def make_recommendation(self, verbose=False):\n        num_missing_points = self.best_possible_score() - self.total_score()\n\n        # Pick a category to improve on, weighted by how many points they're missing\n        # Categories with worse scores (more missing points) are probably easier to improve\n        missing_point = random.uniform(0, num_missing_points)\n        current = 0\n        for category in self.categories:\n            current += category.best_possible_score() - category.average_score()\n            if current > missing_point:\n                return category, category.make_recommendation(verbose=verbose)\n\n    def apply_recommendation(self, category, recommendation, verbose=False):\n        # Given the premise, conditioning info, and notes, apply the recommendation to make new notes\n        prompt = category.apply_recommendation_prompt(recommendation)\n        if verbose:\n            print(prompt)\n        application = openai.ChatCompletion.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[{\"role\": \"user\", \"content\": prompt}],\n            n=1,\n            temperature=1,\n        )\n        if verbose:\n            print(application.choices[0].message.content)\n\n        revised_notes_begin = \"====== REVISED NOTES ======\"\n        revised_notes_end = \"====== END REVISED NOTES ======\"\n\n        # Extract the revised notes from the response\n        revised_notes = (\n            application.choices[0]\n            .message.content.split(revised_notes_begin)[1]\n            .split(revised_notes_end)[0]\n        )\n\n        # Sanity check: make sure the revised notes are different from the original notes, and long enough to maybe be notes\n        if (\n            revised_notes == category.notes\n            or len(revised_notes) < len(category.notes) / 2\n        ):\n            return self.apply_recommendation(category, recommendation, verbose=verbose)\n\n        return revised_notes", ""]}
{"filename": "pitching/test_pitching_server.py", "chunked_list": ["import openai\n\nimport os\nfrom dotenv import load_dotenv\nfrom example_app.backend.server import WebSocketServer\n\nfrom pitching.make_premise import make_premise, function_registry\n\nload_dotenv()\nopenai.api_key = os.environ[\"OPENAI_API_KEY\"]", "load_dotenv()\nopenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\n# Create task graphs\noverall_graph = make_premise(2)\noverall_graph.graph_input = {\n    \"conditioning_info\": \"The client is a dog food company. The story should help sell their dog food.\"\n}\n\nserver = WebSocketServer(overall_graph, function_registry())", "\nserver = WebSocketServer(overall_graph, function_registry())\nprint(\"Created server.\")\nserver.run()\n"]}
{"filename": "pitching/pick_best_idea.py", "chunked_list": ["from collections import defaultdict\nfrom typing import Any, Iterable\n\nfrom fuzzywuzzy import fuzz  # type: ignore\n\nfrom llmtaskgraph.task_graph import TaskGraph, GraphContext\nfrom llmtaskgraph.task import TaskGraphTask, PythonTask\nfrom llmtaskgraph.function_registry import FunctionRegistry\nfrom pitching.score_ideas import (\n    score_ideas,", "from pitching.score_ideas import (\n    score_ideas,\n    function_registry as score_ideas_function_registry,\n)\n\n\ndef init_most_creative(context: GraphContext) -> dict[str, str | list[str]]:\n    return {\n        \"criteria\": \"most creative, surprising, and unexpected ideas that excite the imagination\",\n        \"ideas\": context.graph_input()[\"ideas\"],\n    }", "\n\ndef init_best_fit(context: GraphContext) -> dict[str, str | list[str]]:\n    return {\n        \"criteria\": f\"\"\"ideas that best fit the client's constraints:\\n{context.graph_input()[\"conditioning_info\"]}\"\"\",\n        \"ideas\": context.graph_input()[\"ideas\"],\n    }\n\n\ndef init_cutest(context: GraphContext) -> dict[str, str | list[str]]:\n    return {\n        \"criteria\": \"cutest and most adorable stories\",\n        \"ideas\": context.graph_input()[\"ideas\"],\n    }", "\ndef init_cutest(context: GraphContext) -> dict[str, str | list[str]]:\n    return {\n        \"criteria\": \"cutest and most adorable stories\",\n        \"ideas\": context.graph_input()[\"ideas\"],\n    }\n\n\ndef weighted_sum(\n    context: GraphContext,\n    most_creative: list[tuple[str, int]],\n    best_fit: list[tuple[str, int]],\n    cutest: list[tuple[str, int]],\n) -> str:\n    ideas = context.graph_input()[\"ideas\"]\n    weights = [0.5, 0.3, 0.2]\n    votes = [most_creative, best_fit, cutest]\n    combined_vote_counts: dict[str, float] = defaultdict(float)\n    for weight, vote in zip(weights, votes):\n        for idea, count in vote:\n            combined_vote_counts[idea] += count * weight\n\n    print_numbered_list(\"Most creative\", most_creative)\n    print_numbered_list(\"Best fit\", best_fit)\n    print_numbered_list(\"Cutest\", cutest)\n\n    selected_title = max(combined_vote_counts.items(), key=lambda x: x[1])[0]\n\n    # Find the idea that best matches the selected title\n    matches: Iterable[tuple[str, float]] = [\n        (idea, fuzz.partial_ratio(idea, selected_title)) for idea in ideas  # type: ignore\n    ]\n    selected_idea: str = max(\n        matches,\n        key=lambda x: x[1],\n    )[0]\n\n    return selected_idea", "def weighted_sum(\n    context: GraphContext,\n    most_creative: list[tuple[str, int]],\n    best_fit: list[tuple[str, int]],\n    cutest: list[tuple[str, int]],\n) -> str:\n    ideas = context.graph_input()[\"ideas\"]\n    weights = [0.5, 0.3, 0.2]\n    votes = [most_creative, best_fit, cutest]\n    combined_vote_counts: dict[str, float] = defaultdict(float)\n    for weight, vote in zip(weights, votes):\n        for idea, count in vote:\n            combined_vote_counts[idea] += count * weight\n\n    print_numbered_list(\"Most creative\", most_creative)\n    print_numbered_list(\"Best fit\", best_fit)\n    print_numbered_list(\"Cutest\", cutest)\n\n    selected_title = max(combined_vote_counts.items(), key=lambda x: x[1])[0]\n\n    # Find the idea that best matches the selected title\n    matches: Iterable[tuple[str, float]] = [\n        (idea, fuzz.partial_ratio(idea, selected_title)) for idea in ideas  # type: ignore\n    ]\n    selected_idea: str = max(\n        matches,\n        key=lambda x: x[1],\n    )[0]\n\n    return selected_idea", "\n\nregistry = FunctionRegistry()\ninit_most_creative_id = registry.register(init_most_creative)\ninit_best_fit_id = registry.register(init_best_fit)\ninit_cutest_id = registry.register(init_cutest)\nweighted_sum_id = registry.register(weighted_sum)\nregistry = registry.merge(score_ideas_function_registry())\n\n\ndef function_registry() -> FunctionRegistry:\n    return registry.copy()", "\n\ndef function_registry() -> FunctionRegistry:\n    return registry.copy()\n\n\ndef pick_best_idea() -> TaskGraph:\n    task_graph = TaskGraph()\n    most_creative = TaskGraphTask(\n        score_ideas(10),\n        init_most_creative_id,\n    )\n    task_graph.add_task(most_creative)\n\n    best_fit = TaskGraphTask(\n        score_ideas(10),\n        init_best_fit_id,\n    )\n    task_graph.add_task(best_fit)\n    cutest = TaskGraphTask(\n        score_ideas(10),\n        init_cutest_id,\n    )\n    task_graph.add_task(cutest)\n    task_graph.add_output_task(\n        PythonTask(weighted_sum_id, most_creative, best_fit, cutest)\n    )\n    return task_graph", "\n\ndef print_numbered_list(label: str, list: list[Any]) -> None:\n    print(f\"\\n{label}:\\n\")\n    for i, item in enumerate(list, start=1):\n        print(f\"{i}. {item}\")\n"]}
{"filename": "pitching/test_pitching.py", "chunked_list": ["import asyncio\nimport json\nimport openai\n\nimport os\nfrom dotenv import load_dotenv\nfrom llmtaskgraph.task_graph import TaskGraph\n\nfrom pitching.make_premise import make_premise, function_registry\n", "from pitching.make_premise import make_premise, function_registry\n\nload_dotenv()\nopenai.api_key = os.environ[\"OPENAI_API_KEY\"]\n\n# Create task graphs\noverall_graph = make_premise(2)\n\nconditioning_info = \"The client is a dog food company. The story should help sell their dog food by manipulating the readers.\"\nprint(\"Graph constructed:\")", "conditioning_info = \"The client is a dog food company. The story should help sell their dog food by manipulating the readers.\"\nprint(\"Graph constructed:\")\nprint(json.dumps(overall_graph.to_json()))\noverall_graph_2 = TaskGraph.from_json(overall_graph.to_json())\noverall_graph_2.graph_input = {\"conditioning_info\": conditioning_info}\nbest_idea: str = asyncio.run(overall_graph_2.run(function_registry()))\nprint(best_idea)\nprint(json.dumps(overall_graph_2.to_json()))\n", ""]}
{"filename": "pitching/make_premise.py", "chunked_list": ["from llmtaskgraph.task import TaskGraphTask\nfrom llmtaskgraph.task_graph import GraphContext, TaskGraph\nfrom llmtaskgraph.function_registry import FunctionRegistry, forward_graph_input\n\nfrom pitching.ideation import (\n    make_ideas,\n    function_registry as make_ideas_function_registry,\n)\nfrom pitching.pick_best_idea import (\n    pick_best_idea,", "from pitching.pick_best_idea import (\n    pick_best_idea,\n    function_registry as pick_best_idea_function_registry,\n)\n\n\ndef init_pick_best(\n    context: GraphContext, ideas: list[str]\n) -> dict[str, str | list[str]]:\n    return {\n        \"conditioning_info\": context.graph_input()[\"conditioning_info\"],\n        \"ideas\": ideas,\n    }", "\n\nregistry = FunctionRegistry()\ninit_pick_best_id = registry.register(init_pick_best)\n\n\ndef function_registry() -> FunctionRegistry:\n    return registry.merge(pick_best_idea_function_registry()).merge(\n        make_ideas_function_registry()\n    )", "\n\ndef make_premise(num_idea_sets: int) -> TaskGraph:\n    overall_graph = TaskGraph()\n    make_ideas_task = TaskGraphTask(make_ideas(num_idea_sets), forward_graph_input)\n    overall_graph.add_task(make_ideas_task)\n\n    overall_graph.add_output_task(\n        TaskGraphTask(\n            pick_best_idea(),\n            init_pick_best_id,\n            make_ideas_task,\n        )\n    )\n    return overall_graph", ""]}
{"filename": "pitching/ideation.py", "chunked_list": ["from llmtaskgraph.task import LLMTask, PythonTask\nfrom llmtaskgraph.task_graph import GraphContext, TaskGraph\nfrom llmtaskgraph.function_registry import FunctionRegistry, FunctionId, openai_chat\n\nimport re\n\n\ndef parse_ideas(response: str) -> list[str]:\n    # The regular expression pattern:\n    # It looks for a number followed by a '.', ':', or ')' (with optional spaces)\n    # and then captures any text until it finds a newline character or the end of the string\n    pattern = re.compile(r\"\\d[\\.\\:\\)]\\s*(.*?)(?=\\n\\d|$)\", re.MULTILINE)\n\n    return pattern.findall(response)", "\n\ndef make_eight_ideas(context: GraphContext) -> str:\n    return f\"\"\"You are an AI storybook writer. You write engaging, creative, and highly diverse content for illustrated books for children.\nThe first step in your process is ideation - workshop a bunch of ideas and find the ones with that special spark.\n\nYour client has provided some constraints for you to satisfy, but within those constraints you have total artistic control, so get creative with it!\nClient constraints:\n{context.graph_input()[\"conditioning_info\"]}\n\nEach idea should have a title and a 2-3 sentence premise mentioning the protagonist, the setting, and the conflict, while also highlighting what makes the story interesting.\nHere's an example of a successful premise:\n\u201cRomeo and Juliet\": Two teens, Romeo and Juliet, pursue their forbidden love with each other\u2014to the chagrin of their rival families. When Juliet must choose between her family and her heart, both lovers must find a way to stay united, even if fate won't allow it.\n\n\nCome up with a numbered list of eight of your best ideas. Focus on variety within the scope of the client's requests.\n\"\"\"", "\n\ndef join_ideas(*idea_lists: list[str]) -> list[str]:\n    ideas: list[str] = []\n    for idea_list in idea_lists:\n        ideas.extend(idea_list)\n    return ideas\n\n\nregistry = FunctionRegistry()", "\nregistry = FunctionRegistry()\nmake_eight_ideas_id: FunctionId[[], str] = registry.register(make_eight_ideas)\nparse_ideas_id: FunctionId[[str], list[str]] = registry.register_no_context(parse_ideas)\njoin_ideas_id: FunctionId[[list[str]], list[str]] = registry.register_no_context(\n    join_ideas\n)\n\n\ndef function_registry() -> FunctionRegistry:\n    return registry.copy()", "\ndef function_registry() -> FunctionRegistry:\n    return registry.copy()\n\n\ndef make_ideas(num_idea_sets: int) -> TaskGraph:\n    make_ideas = TaskGraph()\n    ideation_tasks: list[LLMTask] = []\n    for _ in range(num_idea_sets):\n        ideation_task = LLMTask(\n            make_eight_ideas_id,\n            openai_chat,\n            {\"model\": \"gpt-3.5-turbo\", \"n\": 1, \"temperature\": 1},\n            parse_ideas_id,\n        )\n        ideation_tasks.append(ideation_task)\n        make_ideas.add_task(ideation_task)\n\n    make_ideas.add_output_task(PythonTask(join_ideas_id, *ideation_tasks))\n    return make_ideas", ""]}
{"filename": "pitching/score_ideas.py", "chunked_list": ["from llmtaskgraph.task import PythonTask, LLMTask\nfrom llmtaskgraph.task_graph import GraphContext, TaskGraph\nfrom llmtaskgraph.function_registry import (\n    FunctionRegistry,\n    openai_chat,\n    dont_parse,\n    parse_json,\n)\n\nimport random", "\nimport random\n\n\ndef pick_top_five(context: GraphContext) -> str:\n    def format_ideas(ideas: list[str]) -> str:\n        shuffled_ideas = ideas\n        random.shuffle(shuffled_ideas)\n        return \"\\n\".join(\n            [f\"{i}. {idea}\" for i, idea in enumerate(shuffled_ideas, start=1)]\n        )\n\n    return f\"\"\"You are an AI writing assistant helping an author filter through their story concepts to find the ideas with the most potential.\nThe following is a list of ideas for an illustrated children's book:\n\n{format_ideas(context.graph_input()[\"ideas\"])}\n\nPick the five {context.graph_input()[\"criteria\"]}.\"\"\"", "\n\ndef extract_titles(top_five: str) -> str:\n    return f\"\"\"Extract the titles of the below five story premises into a json list format:\n{top_five}\n\nOutput json ONLY - your output will be directly parsed so it must have NO other text such as a preamble.\"\"\"\n\n\ndef tally_votes(*idea_lists: list[str]) -> list[tuple[str, int]]:\n    all_ideas: list[str] = []\n    for idea_list in idea_lists:\n        all_ideas.extend(idea_list)\n\n    counts = [(idea, all_ideas.count(idea)) for idea in set(all_ideas)]\n    sorted_by_votes = sorted(counts, key=lambda x: x[1], reverse=True)\n    return sorted_by_votes", "\ndef tally_votes(*idea_lists: list[str]) -> list[tuple[str, int]]:\n    all_ideas: list[str] = []\n    for idea_list in idea_lists:\n        all_ideas.extend(idea_list)\n\n    counts = [(idea, all_ideas.count(idea)) for idea in set(all_ideas)]\n    sorted_by_votes = sorted(counts, key=lambda x: x[1], reverse=True)\n    return sorted_by_votes\n", "\n\nregistry = FunctionRegistry()\npick_top_five_id = registry.register(pick_top_five)\nextract_titles_id = registry.register_no_context(extract_titles)\ntally_votes_id = registry.register_no_context(tally_votes)\n\n\ndef function_registry() -> FunctionRegistry:\n    return registry.copy()", "def function_registry() -> FunctionRegistry:\n    return registry.copy()\n\n\ndef score_ideas(num_voters: int) -> TaskGraph:\n    task_graph = TaskGraph()\n    titles_tasks: list[LLMTask] = []\n    for _ in range(num_voters):\n        # Pick the top five ideas\n        top_five = LLMTask(\n            pick_top_five_id,\n            openai_chat,\n            {\"model\": \"gpt-3.5-turbo\", \"n\": 1, \"temperature\": 1},\n            dont_parse,\n        )\n        task_graph.add_task(top_five)\n\n        # Extract the list of titles\n        extract_titles = LLMTask(\n            extract_titles_id,\n            openai_chat,\n            {\"model\": \"gpt-3.5-turbo\", \"n\": 1, \"temperature\": 0},\n            parse_json,\n            top_five,\n        )\n        task_graph.add_task(extract_titles)\n        titles_tasks.append(extract_titles)\n\n    task_graph.add_output_task(PythonTask(tally_votes_id, *titles_tasks))\n    return task_graph", ""]}
