{"filename": "setup.py", "chunked_list": ["from setuptools import setup, find_packages\n\nwith open(\"requirements.txt\") as f:\n    required = f.read().splitlines()\n\nsetup(\n    name='stl-mob',\n    version='0.1',\n    packages=find_packages(),\n    package_dir={'': 'src'},", "    packages=find_packages(),\n    package_dir={'': 'src'},\n    install_requires=required\n)"]}
{"filename": "examples/control.py", "chunked_list": ["import time\n\nimport numpy as np\n\nfrom stl_mob.ctrl.wrapper import get_controller\nfrom stl_mob.envs.wrapper import get_env\nfrom stl_mob.stl.tasks import SequenceTask, Map\n\n\ndef test_controller():\n    task_map = Map.generate_map(5,\n                                pos_range=((-5, -5), (5, 5)),\n                                obs_size_range=((1, 1), (2, 2)),\n                                map_size=(10., 10.))\n    task = SequenceTask.generate_task(task_map, num_wp=4)\n    robots = [\n        'point',\n        'car',\n        'doggo',\n        # 'drone'\n    ]\n\n    for robot in robots:\n        env = get_env(robot, task)\n        controller = get_controller(robot)\n\n        obs = env.reset()\n        env.set_goal(np.array([2, 2]))\n        for _ in range(200):\n            time.sleep(0.01)\n            action = controller(obs)\n            obs, _, _, _ = env.step(action)", "\ndef test_controller():\n    task_map = Map.generate_map(5,\n                                pos_range=((-5, -5), (5, 5)),\n                                obs_size_range=((1, 1), (2, 2)),\n                                map_size=(10., 10.))\n    task = SequenceTask.generate_task(task_map, num_wp=4)\n    robots = [\n        'point',\n        'car',\n        'doggo',\n        # 'drone'\n    ]\n\n    for robot in robots:\n        env = get_env(robot, task)\n        controller = get_controller(robot)\n\n        obs = env.reset()\n        env.set_goal(np.array([2, 2]))\n        for _ in range(200):\n            time.sleep(0.01)\n            action = controller(obs)\n            obs, _, _, _ = env.step(action)", "\n\nif __name__ == '__main__':\n    test_controller()\n"]}
{"filename": "examples/pnc.py", "chunked_list": ["import numpy as np\n\nfrom stl_mob.ctrl.wrapper import get_controller\nfrom stl_mob.envs.wrapper import get_env\nfrom stl_mob.stl.solver import StlpySolver\nfrom stl_mob.stl.tasks import Map, SequenceTask\n\n\ndef test_pnc():\n    robots = [\n        'point',\n        'car',\n        'doggo',\n        # 'drone'\n    ]\n\n    solver = StlpySolver(space_dim=2)\n\n    path = None\n    while path is None:\n        task_map = Map.generate_map(5,\n                                    pos_range=((-3, -3), (3, 3)),\n                                    obs_size_range=((0.1, 0.1), (0.5, 0.5)),\n                                    map_size=(10., 10.))\n        task = SequenceTask.generate_task(task_map, num_wp=4)\n        spec = task.get_spec().get_stlpy_form()\n        path, info = solver.solve_stlpy_formula(spec, task.sample_init_pos(), task.total_time_steps)\n\n    for robot in robots:\n        env = get_env(robot, task)\n        controller = get_controller(robot)\n\n        obs = env.reset(init_pos=path[0])\n        env.set_goal(np.array([2, 2]))\n        for wp in path[1:]:\n            env.set_goal(wp)\n            for _ in range(1000):\n                action = controller(obs)\n                obs, _, _, _ = env.step(action)\n                if env.reached():\n                    break\n            if not env.reached():\n                print(\"Failed to reach goal in 1000 steps\")\n                break", "def test_pnc():\n    robots = [\n        'point',\n        'car',\n        'doggo',\n        # 'drone'\n    ]\n\n    solver = StlpySolver(space_dim=2)\n\n    path = None\n    while path is None:\n        task_map = Map.generate_map(5,\n                                    pos_range=((-3, -3), (3, 3)),\n                                    obs_size_range=((0.1, 0.1), (0.5, 0.5)),\n                                    map_size=(10., 10.))\n        task = SequenceTask.generate_task(task_map, num_wp=4)\n        spec = task.get_spec().get_stlpy_form()\n        path, info = solver.solve_stlpy_formula(spec, task.sample_init_pos(), task.total_time_steps)\n\n    for robot in robots:\n        env = get_env(robot, task)\n        controller = get_controller(robot)\n\n        obs = env.reset(init_pos=path[0])\n        env.set_goal(np.array([2, 2]))\n        for wp in path[1:]:\n            env.set_goal(wp)\n            for _ in range(1000):\n                action = controller(obs)\n                obs, _, _, _ = env.step(action)\n                if env.reached():\n                    break\n            if not env.reached():\n                print(\"Failed to reach goal in 1000 steps\")\n                break", "\n\nif __name__ == '__main__':\n    test_pnc()\n"]}
{"filename": "examples/time_evaluator.py", "chunked_list": ["from stl_mob.evaluate.plan_and_ctrl_time import TimeEvaluator\nfrom stl_mob.stl.tasks import Map, SequenceTask, CoverTask, BranchTask, LoopTask, SignalTask\n\n\ndef demo(task_name=\"seq\", robot_name=\"doggo\"):\n    task_map = Map.generate_map(4,\n                                pos_range=((-3, -3), (3, 3)),\n                                obs_size_range=((0.1, 0.1), (0.5, 0.5)),\n                                map_size=(10., 10.))\n    if task_name == \"seq\":\n        task = SequenceTask.generate_task(task_map, num_wp=4)\n    elif task_name == \"cover\":\n        task = CoverTask.generate_task(task_map, num_wp=4)\n    elif task_name == \"branch\":\n        task = BranchTask.generate_task(task_map, num_wp=4)\n    elif task_name == \"loop\":\n        task = LoopTask.generate_task(task_map, num_wp=4)\n    elif task_name == \"signal\":\n        task = SignalTask.generate_task(task_map, num_wp=4)\n    else:\n        raise ValueError(f\"Unknown task name: {task_name}\")\n\n    # The video will show when enable_gui=True\n    evaluator = TimeEvaluator(task, robot_name, enable_gui=False, store_video=True)\n\n    planning_time, ctrl_time = evaluator.eval()\n\n    print(f\"STL spec: {task}\")\n    print(f\"obstacles: {task.task_map.obs_list}\")\n    print(f\"waypoints: {task.wp_list}\")\n    print(f\"Planning time: {planning_time: .3f}\")\n    print(f\"Control time steps: {ctrl_time}\")", "\n\nif __name__ == '__main__':\n    demo()\n"]}
{"filename": "examples/stl.py", "chunked_list": ["from matplotlib import pyplot as plt\n\nfrom stl_mob.stl.solver import StlpySolver\nfrom stl_mob.stl.tasks import BranchTask, CoverTask, LoopTask, Map, SequenceTask, SignalTask, AltCoverTask\n\n\ndef test_seq_task_sol():\n    task_map = Map.generate_map(4, (-5, 5), ((1, 1), (2, 2)))\n    task = SequenceTask.generate_task(task_map, 4, total_time_steps=10)\n    spec = task.get_spec().get_stlpy_form()\n    solver = StlpySolver(space_dim=2)\n    path, info = solver.solve_stlpy_formula(\n        spec, task.sample_init_pos(), task.total_time_steps)\n    print(path)\n    print(task)\n    task.plot_solution(path)\n    plt.show()\n\n    print(task.get_quantitative_info())", "\n\ndef test_cover_task_sol():\n    task_map = Map.generate_map(4, (-5, 5), ((1, 1), (2, 2)))\n    task = CoverTask.generate_task(task_map, 4, total_time_steps=10)\n    spec = task.get_spec().get_stlpy_form()\n    solver = StlpySolver(space_dim=2)\n    path, info = solver.solve_stlpy_formula(\n        spec, task.sample_init_pos(), task.total_time_steps)\n    print(path)\n    print(task)\n    task.plot_solution(path)\n    plt.show()", "\n\ndef test_branch_task_sol():\n    task_map = Map.generate_map(4, (-5, 5), ((1, 1), (2, 2)))\n    task = BranchTask.generate_task(task_map, 4, total_time_steps=16)\n    spec = task.get_spec().get_stlpy_form()\n    solver = StlpySolver(space_dim=2)\n    path, info = solver.solve_stlpy_formula(\n        spec, task.sample_init_pos(), task.total_time_steps)\n    print(path)\n    print(task)\n    task.plot_solution(path)\n    plt.show()", "\n\ndef test_loop_task_sol():\n    task_map = Map.generate_map(4, (-5, 5), ((1, 1), (2, 2)))\n    task = LoopTask.generate_task(task_map, 4, total_time_steps=16)\n    spec = task.get_spec().get_stlpy_form()\n    solver = StlpySolver(space_dim=2)\n    path, info = solver.solve_stlpy_formula(\n        spec, task.sample_init_pos(), task.total_time_steps)\n    print(path)\n    print(task)\n    task.plot_solution(path)\n    plt.show()", "\n\ndef test_signal_task_sol():\n    task_map = Map.generate_map(4, (-5, 5), ((1, 1), (2, 2)))\n    task = SignalTask.generate_task(task_map, 6, total_time_steps=8)\n    spec = task.get_spec().get_stlpy_form()\n    solver = StlpySolver(space_dim=2)\n    path, info = solver.solve_stlpy_formula(\n        spec, task.sample_init_pos(), task.total_time_steps)\n    print(f\"the last second waypoint is: {task.wp_list[-2]}\")\n    print(f\"the last waypoint is: {task.wp_list[-1]}\")\n    print(path)\n    print(task)\n    task.plot_solution(path)\n    plt.show()", "\n\ndef test_alt_cover_task_sol():\n    task_map = Map.generate_map(1, (-5, 5), ((1, 1), (2, 2)))\n    task = AltCoverTask.generate_task(task_map, 3, total_time_steps=15)\n    spec = task.get_spec().get_stlpy_form()\n    solver = StlpySolver(space_dim=2)\n    path, info = solver.solve_stlpy_formula(\n        spec, task.sample_init_pos(), task.total_time_steps)\n    print(path)\n    print(task)\n    task.plot_solution(path)\n    plt.show()", "\n\nif __name__ == \"__main__\":\n    test_seq_task_sol()\n    test_cover_task_sol()\n    test_branch_task_sol()\n    test_loop_task_sol()\n    test_signal_task_sol()\n    test_alt_cover_task_sol()\n", ""]}
{"filename": "examples/envs.py", "chunked_list": ["from stl_mob.envs.wrapper import PointEnv, CarEnv, DoggoEnv\nfrom stl_mob.envs.wrapper import get_env\nfrom stl_mob.stl.tasks import SequenceTask, Map\n\n\ndef test_all_env_render_and_step():\n    task_map = Map.generate_map(5,\n                                pos_range=((-5, -5), (5, 5)),\n                                obs_size_range=((1, 1), (2, 2)),\n                                map_size=(10., 10.))\n    task = SequenceTask.generate_task(task_map, num_wp=4)\n    envs = [\n        PointEnv(task),\n        CarEnv(task),\n        DoggoEnv(task),\n        # DroneEnv(task),\n    ]\n    for env in envs:\n        env.reset()\n        for _ in range(100):\n            env.step(env.gym_env.action_space.sample())", "\n\ndef customize_map():\n    task_map = Map.generate_map(1,\n                                pos_range=((-0.5, -1.5), (-0.5, -1.5)),\n                                obs_size_range=((3.0, 0.4), (3.0, 0.4)),\n                                map_size=(10., 10.))\n    task = SequenceTask.generate_task(task_map, num_wp=0)\n    env = get_env(\"doggo\", task)\n\n    env.reset(init_pos=[-3, -3])\n    env.add_wp_marker([-2.0, -0.5], 0.3, color=(1, 0, 0, 0.5), alpha=0.5, label=\"A\")\n    env.add_wp_marker([3.0, -1.8], 0.3, color=(0, 1, 1, 0.5), alpha=0.5, label=\"B\")\n    env.add_wp_marker([3.0, 2.5], 0.3, color=(1, 1, 0, 0.5), alpha=0.5, label=\"C\")\n    env.set_goal([-0.5, -1.5])\n\n    while True:\n        env.gym_env.render()", "\n\nif __name__ == '__main__':\n    # test_all_env_render_and_step()\n    customize_map()\n"]}
{"filename": "src/stl_mob/__init__.py", "chunked_list": [""]}
{"filename": "src/stl_mob/utils.py", "chunked_list": ["import os\nfrom os.path import dirname, abspath\n\nimport stl_mob\n\nDATA_DIR = os.path.join(dirname(dirname(dirname(abspath(stl_mob.__file__)))), 'data')\nPROJ_DIR = dirname(abspath(stl_mob.__file__))\n"]}
{"filename": "src/stl_mob/stl/solver.py", "chunked_list": ["import time\n\nimport gurobipy as gp\nimport numpy as np\nfrom gurobipy import GRB\nfrom stlpy.STL import STLTree, LinearPredicate, NonlinearPredicate\nfrom stlpy.solvers.base import STLSolver\nfrom stlpy.systems import LinearSystem\n\n\nclass GurobiMICPSolver(STLSolver):\n    \"\"\"\n    Given an :class:`.STLFormula` :math:`\\\\varphi` and a :class:`.LinearSystem`,\n    solve the optimization problem\n\n    .. math::\n\n        \\min & -\\\\rho^{\\\\varphi}(y_0,y_1,\\dots,y_T) + \\sum_{t=0}^T x_t^TQx_t + u_t^TRu_t\n\n        \\\\text{s.t. } & x_0 \\\\text{ fixed}\n\n        & x_{t+1} = A x_t + B u_t\n\n        & y_{t} = C x_t + D u_t\n\n        & \\\\rho^{\\\\varphi}(y_0,y_1,\\dots,y_T) \\geq 0\n\n    with Gurobi using mixed-integer convex programming. This gives a globally optimal\n    solution, but may be computationally expensive for long and complex specifications.\n\n    .. note::\n\n        This class implements the algorithm described in\n\n        Belta C, et al.\n        *Formal methods for control synthesis: an optimization perspective*.\n        Anual Review of Control, Robotics, and Autonomous Systems, 2019.\n\n    :param spec:            An :class:`.STLFormula` describing the specification.\n    :param sys:             A :class:`.LinearSystem` describing the system dynamics.\n    :param x0:              A ``(n,1)`` numpy matrix describing the initial state.\n    :param T:               A positive integer fixing the total number of timesteps :math:`T`.\n    :param M:               (optional) A large positive scalar used to rewrite ``min`` and ``max`` as\n                            mixed-integer constraints. Default is ``1000``.\n    :param robustness_cost: (optional) Boolean flag for adding a linear cost to maximize\n                            the robustness measure. Default is ``True``.\n    :param presolve:        (optional) A boolean indicating whether to use Gurobi's\n                            presolve routines. Default is ``True``.\n    :param verbose:         (optional) A boolean indicating whether to print detailed\n                            solver info. Default is ``True``.\n    \"\"\"\n\n    def __init__(self, spec, sys, x0, T, M=1000, robustness_cost=True,\n                 presolve=True, verbose=True):\n        assert M > 0, \"M should be a (large) positive scalar\"\n        super().__init__(spec, sys, x0, T, verbose)\n\n        self.M = float(M)\n        self.presolve = presolve\n\n        # Set up the optimization problem\n        self.model = gp.Model(\"STL_MICP\")\n\n        # Store the cost function, which will added to self.model right before solving\n        self.cost = 0.0\n\n        # Set some model parameters\n        if not self.presolve:\n            self.model.setParam('Presolve', 0)\n        if not self.verbose:\n            self.model.setParam('OutputFlag', 0)\n\n        if self.verbose:\n            print(\"Setting up optimization problem...\")\n            st = time.time()  # for computing setup time\n\n        # Create optimization variables\n        self.y = self.model.addMVar((self.sys.p, self.T), lb=-float('inf'), name='y')\n        self.x = self.model.addMVar((self.sys.n, self.T), lb=-float('inf'), name='x')\n        self.u = self.model.addMVar((self.sys.m, self.T), lb=-float('inf'), name='u')\n        self.rho = self.model.addMVar(1, name=\"rho\", lb=0.0)  # lb sets minimum robustness\n\n        # Add cost and constraints to the optimization problem\n        self.AddDynamicsConstraints()\n        self.AddSTLConstraints()\n        self.AddRobustnessConstraint()\n        if robustness_cost:\n            self.AddRobustnessCost()\n\n        if self.verbose:\n            print(f\"Setup complete in {time.time() - st} seconds.\")\n\n    def AddControlBounds(self, u_min, u_max):\n        for t in range(self.T):\n            self.model.addConstr(u_min <= self.u[:, t])\n            self.model.addConstr(self.u[:, t] <= u_max)\n\n    def AddStateBounds(self, x_min, x_max):\n        for t in range(self.T):\n            self.model.addConstr(x_min <= self.x[:, t])\n            self.model.addConstr(self.x[:, t] <= x_max)\n\n    def AddQuadraticCost(self, Q, R):\n        self.cost += self.x[:, 0] @ Q @ self.x[:, 0] + self.u[:, 0] @ R @ self.u[:, 0]\n        for t in range(1, self.T):\n            self.cost += self.x[:, t] @ Q @ self.x[:, t] + self.u[:, t] @ R @ self.u[:, t]\n\n        print(type(self.cost))\n\n    def AddRobustnessCost(self):\n        self.cost -= 1 * self.rho\n\n    def AddRobustnessConstraint(self, rho_min=0.0):\n        self.model.addConstr(self.rho >= rho_min)\n\n    def Solve(self, time_limit=None):\n        # Set the cost function now, right before we solve.\n        # This is needed since model.setObjective resets the cost.\n        self.model.setObjective(self.cost, GRB.MINIMIZE)\n        if time_limit is not None:\n            self.model.setParam(\"TimeLimit\", time_limit)\n\n        # Do the actual solving\n        self.model.optimize()\n\n        if self.model.status == GRB.OPTIMAL:\n            if self.verbose:\n                print(\"\\nOptimal Solution Found!\\n\")\n            x = self.x.X\n            u = self.u.X\n            rho = self.rho.X[0]\n\n            # Report optimal cost and robustness\n            if self.verbose:\n                print(\"Solve time: \", self.model.Runtime)\n                print(\"Optimal robustness: \", rho)\n                print(\"\")\n        else:\n            if self.verbose:\n                print(f\"\\nOptimization failed with status {self.model.status}.\\n\")\n            x = None\n            u = None\n            rho = -np.inf\n\n        return (x, u, rho, self.model.Runtime)\n\n    def AddDynamicsConstraints(self):\n        # Initial condition\n        self.model.addConstr(self.x[:, 0] == self.x0)\n\n        # Dynamics\n        for t in range(self.T - 1):\n            self.model.addConstr(\n                self.x[:, t + 1] == self.sys.A @ self.x[:, t] + self.sys.B @ self.u[:, t])\n\n            self.model.addConstr(\n                self.y[:, t] == self.sys.C @ self.x[:, t] + self.sys.D @ self.u[:, t])\n\n        self.model.addConstr(\n            self.y[:, self.T - 1] == self.sys.C @ self.x[:, self.T - 1] + self.sys.D @ self.u[:, self.T - 1])\n\n    def AddSTLConstraints(self):\n        \"\"\"\n        Add the STL constraints\n\n            (x,u) |= specification\n\n        to the optimization problem, via the recursive introduction\n        of binary variables for all subformulas in the specification.\n        \"\"\"\n        # Recursively traverse the tree defined by the specification\n        # to add binary variables and constraints that ensure that\n        # rho is the robustness value\n        z_spec = self.model.addMVar(1, vtype=GRB.CONTINUOUS)\n        self.AddSubformulaConstraints(self.spec, z_spec, 0)\n        self.model.addConstr(z_spec == 1)\n\n    def AddSubformulaConstraints(self, formula, z, t):\n        \"\"\"\n        Given an STLFormula (formula) and a binary variable (z),\n        add constraints to the optimization problem such that z\n        takes value 1 only if the formula is satisfied (at time t).\n\n        If the formula is a predicate, this constraint uses the \"big-M\"\n        formulation\n\n            A[x(t);u(t)] - b + (1-z)M >= 0,\n\n        which enforces A[x;u] - b >= 0 if z=1, where (A,b) are the\n        linear constraints associated with this predicate.\n\n        If the formula is not a predicate, we recursively traverse the\n        subformulas associated with this formula, adding new binary\n        variables z_i for each subformula and constraining\n\n            z <= z_i  for all i\n\n        if the subformulas are combined with conjunction (i.e. all\n        subformulas must hold), or otherwise constraining\n\n            z <= sum(z_i)\n\n        if the subformulas are combined with disjuction (at least one\n        subformula must hold).\n        \"\"\"\n        # We're at the bottom of the tree, so add the big-M constraints\n        if isinstance(formula, LinearPredicate):\n            # a.T*y - b + (1-z)*M >= rho\n            self.model.addConstr(formula.a.T @ self.y[:, t] - formula.b + (1 - z) * self.M >= self.rho)\n\n            # Force z to be binary\n            b = self.model.addMVar(1, vtype=GRB.BINARY)\n            self.model.addConstr(z == b)\n\n        elif isinstance(formula, NonlinearPredicate):\n            raise TypeError(\"Mixed integer programming does not support nonlinear predicates\")\n\n        # We haven't reached the bottom of the tree, so keep adding\n        # boolean constraints recursively\n        else:\n            if formula.combination_type == \"and\":\n                for i, subformula in enumerate(formula.subformula_list):\n                    z_sub = self.model.addMVar(1, vtype=GRB.CONTINUOUS)\n                    t_sub = formula.timesteps[i]  # the timestep at which this formula\n                    # should hold\n                    self.AddSubformulaConstraints(subformula, z_sub, t + t_sub)\n                    self.model.addConstr(z <= z_sub)\n\n            else:  # combination_type == \"or\":\n                z_subs = []\n                for i, subformula in enumerate(formula.subformula_list):\n                    z_sub = self.model.addMVar(1, vtype=GRB.CONTINUOUS)\n                    z_subs.append(z_sub)\n                    t_sub = formula.timesteps[i]\n                    self.AddSubformulaConstraints(subformula, z_sub, t + t_sub)\n                self.model.addConstr(z <= sum(z_subs))", "\n\nclass GurobiMICPSolver(STLSolver):\n    \"\"\"\n    Given an :class:`.STLFormula` :math:`\\\\varphi` and a :class:`.LinearSystem`,\n    solve the optimization problem\n\n    .. math::\n\n        \\min & -\\\\rho^{\\\\varphi}(y_0,y_1,\\dots,y_T) + \\sum_{t=0}^T x_t^TQx_t + u_t^TRu_t\n\n        \\\\text{s.t. } & x_0 \\\\text{ fixed}\n\n        & x_{t+1} = A x_t + B u_t\n\n        & y_{t} = C x_t + D u_t\n\n        & \\\\rho^{\\\\varphi}(y_0,y_1,\\dots,y_T) \\geq 0\n\n    with Gurobi using mixed-integer convex programming. This gives a globally optimal\n    solution, but may be computationally expensive for long and complex specifications.\n\n    .. note::\n\n        This class implements the algorithm described in\n\n        Belta C, et al.\n        *Formal methods for control synthesis: an optimization perspective*.\n        Anual Review of Control, Robotics, and Autonomous Systems, 2019.\n\n    :param spec:            An :class:`.STLFormula` describing the specification.\n    :param sys:             A :class:`.LinearSystem` describing the system dynamics.\n    :param x0:              A ``(n,1)`` numpy matrix describing the initial state.\n    :param T:               A positive integer fixing the total number of timesteps :math:`T`.\n    :param M:               (optional) A large positive scalar used to rewrite ``min`` and ``max`` as\n                            mixed-integer constraints. Default is ``1000``.\n    :param robustness_cost: (optional) Boolean flag for adding a linear cost to maximize\n                            the robustness measure. Default is ``True``.\n    :param presolve:        (optional) A boolean indicating whether to use Gurobi's\n                            presolve routines. Default is ``True``.\n    :param verbose:         (optional) A boolean indicating whether to print detailed\n                            solver info. Default is ``True``.\n    \"\"\"\n\n    def __init__(self, spec, sys, x0, T, M=1000, robustness_cost=True,\n                 presolve=True, verbose=True):\n        assert M > 0, \"M should be a (large) positive scalar\"\n        super().__init__(spec, sys, x0, T, verbose)\n\n        self.M = float(M)\n        self.presolve = presolve\n\n        # Set up the optimization problem\n        self.model = gp.Model(\"STL_MICP\")\n\n        # Store the cost function, which will added to self.model right before solving\n        self.cost = 0.0\n\n        # Set some model parameters\n        if not self.presolve:\n            self.model.setParam('Presolve', 0)\n        if not self.verbose:\n            self.model.setParam('OutputFlag', 0)\n\n        if self.verbose:\n            print(\"Setting up optimization problem...\")\n            st = time.time()  # for computing setup time\n\n        # Create optimization variables\n        self.y = self.model.addMVar((self.sys.p, self.T), lb=-float('inf'), name='y')\n        self.x = self.model.addMVar((self.sys.n, self.T), lb=-float('inf'), name='x')\n        self.u = self.model.addMVar((self.sys.m, self.T), lb=-float('inf'), name='u')\n        self.rho = self.model.addMVar(1, name=\"rho\", lb=0.0)  # lb sets minimum robustness\n\n        # Add cost and constraints to the optimization problem\n        self.AddDynamicsConstraints()\n        self.AddSTLConstraints()\n        self.AddRobustnessConstraint()\n        if robustness_cost:\n            self.AddRobustnessCost()\n\n        if self.verbose:\n            print(f\"Setup complete in {time.time() - st} seconds.\")\n\n    def AddControlBounds(self, u_min, u_max):\n        for t in range(self.T):\n            self.model.addConstr(u_min <= self.u[:, t])\n            self.model.addConstr(self.u[:, t] <= u_max)\n\n    def AddStateBounds(self, x_min, x_max):\n        for t in range(self.T):\n            self.model.addConstr(x_min <= self.x[:, t])\n            self.model.addConstr(self.x[:, t] <= x_max)\n\n    def AddQuadraticCost(self, Q, R):\n        self.cost += self.x[:, 0] @ Q @ self.x[:, 0] + self.u[:, 0] @ R @ self.u[:, 0]\n        for t in range(1, self.T):\n            self.cost += self.x[:, t] @ Q @ self.x[:, t] + self.u[:, t] @ R @ self.u[:, t]\n\n        print(type(self.cost))\n\n    def AddRobustnessCost(self):\n        self.cost -= 1 * self.rho\n\n    def AddRobustnessConstraint(self, rho_min=0.0):\n        self.model.addConstr(self.rho >= rho_min)\n\n    def Solve(self, time_limit=None):\n        # Set the cost function now, right before we solve.\n        # This is needed since model.setObjective resets the cost.\n        self.model.setObjective(self.cost, GRB.MINIMIZE)\n        if time_limit is not None:\n            self.model.setParam(\"TimeLimit\", time_limit)\n\n        # Do the actual solving\n        self.model.optimize()\n\n        if self.model.status == GRB.OPTIMAL:\n            if self.verbose:\n                print(\"\\nOptimal Solution Found!\\n\")\n            x = self.x.X\n            u = self.u.X\n            rho = self.rho.X[0]\n\n            # Report optimal cost and robustness\n            if self.verbose:\n                print(\"Solve time: \", self.model.Runtime)\n                print(\"Optimal robustness: \", rho)\n                print(\"\")\n        else:\n            if self.verbose:\n                print(f\"\\nOptimization failed with status {self.model.status}.\\n\")\n            x = None\n            u = None\n            rho = -np.inf\n\n        return (x, u, rho, self.model.Runtime)\n\n    def AddDynamicsConstraints(self):\n        # Initial condition\n        self.model.addConstr(self.x[:, 0] == self.x0)\n\n        # Dynamics\n        for t in range(self.T - 1):\n            self.model.addConstr(\n                self.x[:, t + 1] == self.sys.A @ self.x[:, t] + self.sys.B @ self.u[:, t])\n\n            self.model.addConstr(\n                self.y[:, t] == self.sys.C @ self.x[:, t] + self.sys.D @ self.u[:, t])\n\n        self.model.addConstr(\n            self.y[:, self.T - 1] == self.sys.C @ self.x[:, self.T - 1] + self.sys.D @ self.u[:, self.T - 1])\n\n    def AddSTLConstraints(self):\n        \"\"\"\n        Add the STL constraints\n\n            (x,u) |= specification\n\n        to the optimization problem, via the recursive introduction\n        of binary variables for all subformulas in the specification.\n        \"\"\"\n        # Recursively traverse the tree defined by the specification\n        # to add binary variables and constraints that ensure that\n        # rho is the robustness value\n        z_spec = self.model.addMVar(1, vtype=GRB.CONTINUOUS)\n        self.AddSubformulaConstraints(self.spec, z_spec, 0)\n        self.model.addConstr(z_spec == 1)\n\n    def AddSubformulaConstraints(self, formula, z, t):\n        \"\"\"\n        Given an STLFormula (formula) and a binary variable (z),\n        add constraints to the optimization problem such that z\n        takes value 1 only if the formula is satisfied (at time t).\n\n        If the formula is a predicate, this constraint uses the \"big-M\"\n        formulation\n\n            A[x(t);u(t)] - b + (1-z)M >= 0,\n\n        which enforces A[x;u] - b >= 0 if z=1, where (A,b) are the\n        linear constraints associated with this predicate.\n\n        If the formula is not a predicate, we recursively traverse the\n        subformulas associated with this formula, adding new binary\n        variables z_i for each subformula and constraining\n\n            z <= z_i  for all i\n\n        if the subformulas are combined with conjunction (i.e. all\n        subformulas must hold), or otherwise constraining\n\n            z <= sum(z_i)\n\n        if the subformulas are combined with disjuction (at least one\n        subformula must hold).\n        \"\"\"\n        # We're at the bottom of the tree, so add the big-M constraints\n        if isinstance(formula, LinearPredicate):\n            # a.T*y - b + (1-z)*M >= rho\n            self.model.addConstr(formula.a.T @ self.y[:, t] - formula.b + (1 - z) * self.M >= self.rho)\n\n            # Force z to be binary\n            b = self.model.addMVar(1, vtype=GRB.BINARY)\n            self.model.addConstr(z == b)\n\n        elif isinstance(formula, NonlinearPredicate):\n            raise TypeError(\"Mixed integer programming does not support nonlinear predicates\")\n\n        # We haven't reached the bottom of the tree, so keep adding\n        # boolean constraints recursively\n        else:\n            if formula.combination_type == \"and\":\n                for i, subformula in enumerate(formula.subformula_list):\n                    z_sub = self.model.addMVar(1, vtype=GRB.CONTINUOUS)\n                    t_sub = formula.timesteps[i]  # the timestep at which this formula\n                    # should hold\n                    self.AddSubformulaConstraints(subformula, z_sub, t + t_sub)\n                    self.model.addConstr(z <= z_sub)\n\n            else:  # combination_type == \"or\":\n                z_subs = []\n                for i, subformula in enumerate(formula.subformula_list):\n                    z_sub = self.model.addMVar(1, vtype=GRB.CONTINUOUS)\n                    z_subs.append(z_sub)\n                    t_sub = formula.timesteps[i]\n                    self.AddSubformulaConstraints(subformula, z_sub, t + t_sub)\n                self.model.addConstr(z <= sum(z_subs))", "\n\nclass StlpySolver:\n    def __init__(self, space_dim: int):\n        self.space_dim = space_dim\n        self._ctrl_sys = self._get_ctrl_system(space_dim)\n\n    @staticmethod\n    def _get_ctrl_system(dim: int):\n        A = np.eye(dim)\n        B = np.eye(dim)\n        C = np.eye(dim)\n        D = np.zeros([dim, dim])\n        sys = LinearSystem(A, B, C, D)\n\n        return sys\n\n    def solve_stlpy_formula(self,\n                            spec: STLTree,\n                            x0: np.ndarray,\n                            total_time: int,\n                            solver_name=\"gurobi\",\n                            u_bound: tuple = (-20., 20.),\n                            x_bound: tuple = (-10., 10.),\n                            rho_min: float = 0.2,\n                            time_limit=None):\n        if solver_name == \"gurobi\":\n            solver = GurobiMICPSolver(\n                spec, self._ctrl_sys, x0, total_time, verbose=False)\n        else:\n            raise NotImplementedError(f\"{solver_name} is not supported yet\")\n\n        solver.AddQuadraticCost(\n            Q=np.diag(0.0 * np.random.random(self.space_dim)), R=np.eye(self.space_dim))\n        solver.AddControlBounds(*u_bound)\n        solver.AddRobustnessConstraint(rho_min=rho_min)\n        solver.AddStateBounds(*x_bound)\n        x, u, rho, solve_t = solver.Solve(time_limit=time_limit)\n\n        info = dict(u=u, rho=rho, solve_t=solve_t)\n\n        if x is not None:\n            x = np.array(x).T\n        return x, info", ""]}
{"filename": "src/stl_mob/stl/tasks.py", "chunked_list": ["from abc import ABC, abstractmethod\nfrom functools import reduce\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.patches import Rectangle\nfrom stlpy.STL import STLTree\n\nfrom stl_mob.stl.stl import STL, inside_rectangle_formula, outside_rectangle_formula\n", "from stl_mob.stl.stl import STL, inside_rectangle_formula, outside_rectangle_formula\n\n\nclass Obstacle:\n    def __init__(self, pos: np.ndarray, size: np.ndarray, keepout: float = 0.0):\n        self.pos = pos\n        self.size = size\n        self.keepout = keepout\n        self.bound = np.stack([self.pos - (self.size + self.keepout) / 2,\n                               self.pos + (self.size + self.keepout) / 2]).T.flatten()\n\n        self.spec = None\n        self.neg_spec = None\n\n    def get_spec(self, obs_name: str = None):\n        if obs_name is None:\n            obs_name = str(self)\n        if self.spec is None:\n            self.spec = STL(outside_rectangle_formula(self.bound, 0, 1, 2, name=obs_name))\n        return self.spec\n\n    def workaround_not(self, obs_name: str = None):\n        if obs_name is None:\n            obs_name = str(self)\n        if self.neg_spec is None:\n            self.neg_spec = STL(inside_rectangle_formula(self.bound, 0, 1, 2, name=obs_name))\n        return self.neg_spec\n\n    def workaround_implies(self, other: STL, obs_name: str = None):\n        neg_spec = self.workaround_not(obs_name=obs_name)\n        return neg_spec | other\n\n    def contains(self, pos: np.ndarray):\n        return np.all(np.abs(pos - self.pos) < (self.size + self.keepout) / 2 - 1e-3)\n\n    def __repr__(self):\n        return f\"obs(pos={self.pos}, size={self.size})\"", "\n\nclass Waypoint:\n    def __init__(self, pos: np.ndarray, size: float):\n        self.pos = pos\n        self.size = size\n        self.bound = np.stack([self.pos - self.size / 2, self.pos + self.size / 2]).T.flatten()\n        self.spec = None\n        self.neg_spec = None\n\n    def get_spec(self, wp_name: str = None):\n        if wp_name is None:\n            wp_name = str(self)\n        if self.spec is None:\n            self.spec = STL(inside_rectangle_formula(self.bound, 0, 1, 2, name=wp_name))\n        return self.spec\n\n    def workaround_not(self, wp_name: str = None):\n        if wp_name is None:\n            wp_name = str(self)\n        if self.neg_spec is None:\n            self.neg_spec = STL(outside_rectangle_formula(self.bound, 0, 1, 2, name=wp_name))\n        return self.neg_spec\n\n    def workaround_implies(self, other: STL, wp_name: str = None):\n        neg_spec = self.workaround_not(wp_name=wp_name)\n        return neg_spec | other\n\n    def contains(self, pos: np.ndarray):\n        return np.all(np.abs(pos - self.pos) < self.size / 2 + 1e-3)\n\n    def __repr__(self):\n        return f\"wp(pos={self.pos}, size={self.size})\"", "\n\nclass Map:\n    def __init__(self,\n                 obs_list: list[Obstacle],\n                 pos_range: tuple,\n                 obs_size_range: tuple,\n                 map_size: tuple,\n                 obs_name_list: str = None,\n                 shuffle_obs_name: bool = True):\n        self.obs_list = obs_list\n        self.pos_range = pos_range\n        self.obs_size_range = obs_size_range\n        self.map_size = map_size\n        self.shuffle_obs_name = shuffle_obs_name\n\n        if obs_name_list is None:\n            self.obs_name_list = [f\"obs_{i}\" for i in range(len(obs_list))]\n            if shuffle_obs_name:\n                np.random.shuffle(self.obs_name_list)\n        else:\n            self.obs_name_list = obs_name_list\n\n    @classmethod\n    def generate_map(cls, num_obs: int,\n                     pos_range: tuple[tuple, tuple],\n                     obs_size_range: tuple[tuple, tuple],\n                     map_size: tuple[float, float] = (10., 10.)) -> \"Map\":\n        obs_list = []\n        for _ in range(num_obs):\n            size = np.random.uniform(*obs_size_range)\n            pos = np.random.uniform(*pos_range)\n            obs = Obstacle(pos, size)\n            obs_list.append(obs)\n        return cls(obs_list, pos_range, obs_size_range, map_size)\n\n    def get_spec(self) -> STLTree:\n        spec = self.obs_list[0].get_spec(obs_name=self.obs_name_list[0])\n        for obs, obs_name in zip(self.obs_list[1:], self.obs_name_list[1:]):\n            spec = spec & obs.get_spec(obs_name=obs_name)\n        return spec\n\n    def plot(self) -> tuple[plt.Figure, plt.Axes]:\n        fig, ax = plt.subplots()\n        ax.set_xlim([-self.map_size[0], self.map_size[0]])\n        ax.set_ylim([-self.map_size[1], self.map_size[1]])\n\n        for obs in self.obs_list:\n            rect = Rectangle(obs.pos - obs.size / 2, obs.size[0], obs.size[1], color=\"red\", alpha=0.5)\n            ax.add_patch(rect)\n\n        return fig, ax\n\n    def inside_obs(self, pos: np.ndarray) -> bool:\n        for obs in self.obs_list:\n            if obs.contains(pos):\n                return True\n        return False", "\n\nclass TaskBase(ABC):\n    def __init__(self,\n                 task_map: Map,\n                 wp_list: list[Waypoint],\n                 wp_size: float,\n                 total_time_steps: int,\n                 wp_name_list: str = None,\n                 shuffle_wp_name: bool = True):\n        self.task_map = task_map\n        self.wp_list = wp_list\n        self.wp_size = wp_size\n        self.total_time_steps = total_time_steps\n        self.shuffle_wp_name = shuffle_wp_name\n        self.spec = None\n\n        if wp_name_list is None:\n            self.wp_name_list = [f\"wp_{i}\" for i in range(len(wp_list))]\n            if shuffle_wp_name:\n                np.random.shuffle(self.wp_name_list)\n        else:\n            self.wp_name_list = wp_name_list\n\n    @classmethod\n    def generate_task(cls,\n                      task_map: Map,\n                      num_wp: int,\n                      wp_size: float = 0.5,\n                      total_time_steps: int = 20):\n        wp_list = []\n        for i in range(num_wp):\n            pos = np.random.uniform(*task_map.pos_range, size=2)\n            while task_map.inside_obs(pos):\n                pos = np.random.uniform(*task_map.pos_range, size=2)\n            wp = Waypoint(pos, wp_size)\n            wp_list.append(wp)\n        return cls(task_map, wp_list, wp_size, total_time_steps)\n\n    def plot_map(self):\n        fig, ax = self.task_map.plot()\n        for wp in self.wp_list:\n            rect = Rectangle(wp.pos - wp.size / 2, wp.size, wp.size, color=\"blue\", alpha=0.5)\n            ax.add_patch(rect)\n        return fig, ax\n\n    def plot_solution(self, path: list):\n        fig, ax = self.plot_map()\n        ax.scatter([p[0] for p in path], [p[1] for p in path], color=\"green\")\n\n        return fig, ax\n\n    def sample_init_pos(self):\n        pos = np.random.uniform(*self.task_map.pos_range, size=2)\n        while self.task_map.inside_obs(pos):\n            pos = np.random.uniform(*self.task_map.pos_range, size=2)\n        return pos\n\n    def get_spec(self) -> STL:\n        if self.spec is None:\n            self.spec = self._get_spec()\n            self.spec.simplify()\n        return self.spec\n\n    def get_quantitative_info(self) -> tuple[np.ndarray, np.ndarray]:\n        wp_info = np.array([np.r_[wp.pos, wp.size] for wp in self.wp_list])\n        obs_info = np.array([np.r_[obs.pos, obs.size] for obs in self.task_map.obs_list])\n\n        return wp_info, obs_info\n\n    def __repr__(self):\n        return self.get_spec().__repr__()\n\n    @abstractmethod\n    def _get_spec(self) -> STL:\n        pass", "\n\nclass SequenceTask(TaskBase):\n    def _get_spec(self) -> STL:\n        intv = self.total_time_steps // len(self.wp_list)\n        seq_spec = self.wp_list[0].get_spec(self.wp_name_list[0]).eventually(0, intv)\n        for i in range(1, len(self.wp_list)):\n            seq_spec = seq_spec & self.wp_list[i].get_spec(self.wp_name_list[i]).eventually(i * intv, (i + 1) * intv)\n        collision_spec = self.task_map.get_spec().always(0, self.total_time_steps)\n        spec = seq_spec & collision_spec\n\n        return spec", "\n\nclass CoverTask(TaskBase):\n    def _get_spec(self):\n        cover_spec = self.wp_list[0].get_spec(self.wp_name_list[0]).eventually(0, self.total_time_steps)\n        for i in range(1, len(self.wp_list)):\n            cover_spec &= self.wp_list[i].get_spec(self.wp_name_list[i]).eventually(0, self.total_time_steps)\n        collision_spec = self.task_map.get_spec().always(0, self.total_time_steps)\n        spec = cover_spec & collision_spec\n\n        return spec", "\n\nclass BranchTask(TaskBase):\n\n    @classmethod\n    def generate_task(cls,\n                      task_map: Map,\n                      num_wp: int,\n                      wp_size: float = 0.5,\n                      total_time_steps: int = 20):\n        assert num_wp % 2 == 0\n        return super().generate_task(task_map, num_wp, wp_size, total_time_steps)\n\n    def _get_spec(self):\n        # each two waypoints are one group, if reach one, must reach the other later\n        branch_spec = self.wp_list[0].get_spec(self.wp_name_list[0]).eventually(0, self.total_time_steps // 2) & \\\n                      self.wp_list[1].get_spec(self.wp_name_list[1]).eventually(self.total_time_steps // 2,\n                                                                                self.total_time_steps)\n\n        for i in range(2, len(self.wp_list), 2):\n            branch_spec |= self.wp_list[i].get_spec(self.wp_name_list[i]).eventually(0, self.total_time_steps // 2) & \\\n                           self.wp_list[i + 1].get_spec(self.wp_name_list[i + 1]).eventually(self.total_time_steps // 2,\n                                                                                             self.total_time_steps)\n\n        collision_spec = self.task_map.get_spec().always(0, self.total_time_steps)\n        spec = branch_spec & collision_spec\n\n        return spec", "\n\nclass LoopTask(TaskBase):\n    def _get_spec(self):\n        # loop among all waypoints\n        loop_spec = self.wp_list[0].get_spec(self.wp_name_list[0]) & self.wp_list[1].get_spec(\n            self.wp_name_list[1]).eventually(0, 1)\n        for i in range(1, len(self.wp_list)):\n            loop_spec |= \\\n                self.wp_list[i].get_spec(self.wp_name_list[i]) & self.wp_list[(i + 1) % len(self.wp_list)].get_spec(\n                    self.wp_name_list[(i + 1) % len(self.wp_list)]).eventually(0, 1)\n        loop_spec = loop_spec.always(1, self.total_time_steps - 1)\n\n        collision_spec = self.task_map.get_spec().always(0, self.total_time_steps)\n        spec = loop_spec & collision_spec\n\n        return spec", "\n\nclass SignalTask(TaskBase):\n    def _get_spec(self):\n        # repeatedly visit all waypoints except the last one until visit the last second waypoint,\n        # finally reach the last one\n        signal_spec = self.wp_list[0].get_spec(self.wp_name_list[0])\n        for i in range(1, len(self.wp_list) - 1):\n            signal_spec |= self.wp_list[i].get_spec(self.wp_name_list[i])\n        signal_spec = signal_spec\n        signal_spec = signal_spec.until(self.wp_list[-2].get_spec(self.wp_name_list[-2]), 1, self.total_time_steps - 3)\n        signal_spec &= self.wp_list[-1].get_spec(self.wp_name_list[-1]).eventually(0, self.total_time_steps)\n\n        collision_spec = self.task_map.get_spec().always(0, self.total_time_steps)\n        spec = signal_spec & collision_spec\n\n        return spec", "\n\nclass AltCoverTask(TaskBase):\n    def _get_spec(self):\n        # STL spec like F[0,28]B&G[0,28](B=>F[0,28]C)&G[0,28](C=>F[0,28]A)&G[0,28]~obs\n        all_wps_specs = [wp.get_spec(self.wp_name_list[i]) for i, wp in enumerate(self.wp_list)]\n        all_neg_wps_specs = [wp.workaround_not(\"~\" + self.wp_name_list[i]) for i, wp in enumerate(self.wp_list)]\n        better_cover_spec = all_wps_specs[0].eventually(0, self.total_time_steps)\n        for i in range(1, len(self.wp_list)):\n            better_cover_spec &= all_wps_specs[i].eventually(0, self.total_time_steps)\n\n        seq_spec = reduce(lambda x, y: x & y, all_neg_wps_specs[1:]).until(all_wps_specs[0], 0, self.total_time_steps)\n        for i in range(1, len(self.wp_list) - 1):\n            seq_spec |= reduce(\n                lambda x, y: x & y,\n                all_neg_wps_specs[i + 1:]).until(\n                all_wps_specs[i], 0, self.total_time_steps)\n\n        better_cover_spec &= seq_spec\n\n        collision_spec = self.task_map.get_spec().always(0, self.total_time_steps)\n        spec = better_cover_spec & collision_spec\n\n        return spec", ""]}
{"filename": "src/stl_mob/stl/__init__.py", "chunked_list": [""]}
{"filename": "src/stl_mob/stl/stl.py", "chunked_list": ["from collections import deque\nfrom typing import Union\n\nimport numpy as np\nfrom stlpy.STL import STLTree, STLFormula, LinearPredicate\n\nCOLORED = False\n\nif COLORED:\n    from termcolor import colored\nelse:\n    def colored(text, color):\n        return text", "if COLORED:\n    from termcolor import colored\nelse:\n    def colored(text, color):\n        return text\n\n\nclass STL:\n    def __init__(self, ast: Union[list, str, STLTree, STLFormula, LinearPredicate]):\n        self.ast = ast\n        self.single_operators = (\"~\", \"G\", \"F\")\n        self.binary_operators = (\"&\", \"|\", \"->\", \"U\")\n        self.sequence_operators = (\"G\", \"F\", \"U\")\n        self.stlpy_form = None\n        self.expr_repr = None\n\n    \"\"\"\n    Syntax Functions\n    \"\"\"\n\n    def __and__(self, other: 'STL') -> 'STL':\n        ast = [\"&\", self.ast, other.ast]\n        return STL(ast)\n\n    def __or__(self, other: 'STL') -> 'STL':\n        ast = [\"|\", self.ast, other.ast]\n        return STL(ast)\n\n    def __invert__(self) -> 'STL':\n        ast = [\"~\", self.ast]\n        return STL(ast)\n\n    def implies(self, other: 'STL') -> 'STL':\n        ast = [\"->\", self.ast, other.ast]\n        return STL(ast)\n\n    def eventually(self, start: int = 0, end: int = None):\n        ast = [\"F\", self.ast, start, end]\n        return STL(ast)\n\n    def always(self, start: int = 0, end: int = None) -> 'STL':\n        ast = [\"G\", self.ast, start, end]\n        return STL(ast)\n\n    def until(self, other: 'STL', start: int = 0, end: int = None) -> 'STL':\n        ast = [\"U\", self.ast, other.ast, start, end]\n        return STL(ast)\n\n    def get_stlpy_form(self):\n        # catch already converted form\n        if self.stlpy_form is None:\n            self.stlpy_form = self._to_stlpy(self.ast)\n\n        return self.stlpy_form\n\n    def _to_stlpy(self, ast) -> STLTree:\n        if self._is_leaf(ast):\n            if isinstance(ast, str):\n                raise ValueError(f\"str variable {ast} not supported\")\n            self.stlpy_form = ast\n            return ast\n\n        if ast[0] == \"~\":\n            self.stlpy_form = self._handle_not(ast)\n        elif ast[0] == \"G\":\n            self.stlpy_form = self._handle_always(ast)\n        elif ast[0] == \"F\":\n            self.stlpy_form = self._handle_eventually(ast)\n        elif ast[0] == \"&\":\n            self.stlpy_form = self._handle_and(ast)\n        elif ast[0] == \"|\":\n            self.stlpy_form = self._handle_or(ast)\n        elif ast[0] == \"->\":\n            self.stlpy_form = self._handle_implies(ast)\n        elif ast[0] == \"U\":\n            self.stlpy_form = self._handle_until(ast)\n        else:\n            raise ValueError(f\"Unknown operator {ast[0]}\")\n\n        return self.stlpy_form\n\n    def _handle_not(self, ast):\n        sub_form = self._to_stlpy(ast[1])\n        return sub_form.negation()\n\n    def _handle_and(self, ast):\n        sub_form_1 = self._to_stlpy(ast[1])\n        sub_form_2 = self._to_stlpy(ast[2])\n        return sub_form_1 & sub_form_2\n\n    def _handle_or(self, ast):\n        sub_form_1 = self._to_stlpy(ast[1])\n        sub_form_2 = self._to_stlpy(ast[2])\n        return sub_form_1 | sub_form_2\n\n    def _handle_implies(self, ast):\n        sub_form_1 = self._to_stlpy(ast[1])\n        sub_form_2 = self._to_stlpy(ast[2])\n        return sub_form_1.negation() | sub_form_2\n\n    def _handle_eventually(self, ast):\n        sub_form = self._to_stlpy(ast[1])\n        return sub_form.eventually(ast[2], ast[3])\n\n    def _handle_always(self, ast):\n        sub_form = self._to_stlpy(ast[1])\n        return sub_form.always(ast[2], ast[3])\n\n    def _handle_until(self, ast):\n        sub_form_1 = self._to_stlpy(ast[1])\n        sub_form_2 = self._to_stlpy(ast[2])\n        return sub_form_1.until(sub_form_2, ast[3], ast[4])\n\n    @staticmethod\n    def _is_leaf(ast):\n        return issubclass(type(ast), STLFormula) or isinstance(ast, str)\n\n    def simplify(self):\n        if self.stlpy_form is None:\n            self.get_stlpy_form()\n        self.stlpy_form.simplify()\n\n    def __repr__(self):\n        if self.expr_repr is not None:\n            return self.expr_repr\n\n        single_operators = (\"~\", \"G\", \"F\")\n        binary_operators = (\"&\", \"|\", \"->\", \"U\")\n        time_bounded_operators = (\"G\", \"F\", \"U\")\n\n        # traverse ast\n        operator_stack = [self.ast]\n        expr = \"\"\n        cur = self.ast\n\n        def push_stack(ast):\n            if isinstance(ast, str) and ast in time_bounded_operators:\n                time_window = f\"[{cur[-2]}, {cur[-1]}]\"\n                operator_stack.append(time_window)\n            operator_stack.append(ast)\n\n        while operator_stack:\n            cur = operator_stack.pop()\n            if self._is_leaf(cur):\n                expr += cur.__str__()\n            elif isinstance(cur, str):\n                if cur == \"(\" or cur == \")\":\n                    expr += cur\n                elif cur.startswith(\"[\"):\n                    expr += colored(cur, \"yellow\") + \" \"\n                else:\n                    if cur in (\"G\", \"F\"):\n                        if cur == \"F\":\n                            expr += colored(\"F\", \"magenta\")\n                        else:\n                            expr += colored(cur, \"magenta\")\n                    elif cur in (\"&\", \"|\", \"->\", \"U\"):\n                        expr += \" \" + colored(cur, \"magenta\")\n                        if cur != \"U\":\n                            expr += \" \"\n                    elif cur in (\"~\",):\n                        expr += colored(cur, \"magenta\")\n            elif cur[0] in single_operators:\n                # single operator\n                if not self._is_leaf(cur[1]):\n                    push_stack(\")\")\n                push_stack(cur[1])\n                if not self._is_leaf(cur[1]):\n                    push_stack(\"(\")\n                push_stack(cur[0])\n            elif cur[0] in binary_operators:\n                # binary operator\n                if not self._is_leaf(cur[2]) and cur[2][0] in binary_operators:\n                    push_stack(\")\")\n                    push_stack(cur[2])\n                    push_stack(\"(\")\n                else:\n                    push_stack(cur[2])\n                push_stack(cur[0])\n                if not self._is_leaf(cur[1]) and cur[1][0] in binary_operators:\n                    push_stack(\")\")\n                    push_stack(cur[1])\n                    push_stack(\"(\")\n                else:\n                    push_stack(cur[1])\n\n        self.expr_repr = expr\n        return expr\n\n    def get_all_predicates(self):\n        all_preds = []\n        queue = deque([self.ast])\n\n        while queue:\n            cur = queue.popleft()\n\n            if self._is_leaf(cur):\n                all_preds.append(cur)\n            elif cur[0] in self.single_operators:\n                queue.append(cur[1])\n            elif cur[0] in self.binary_operators:\n                queue.append(cur[1])\n                queue.append(cur[2])\n            else:\n                raise RuntimeError(\"Should never visit here\")\n\n        return all_preds", "\n\ndef inside_rectangle_formula(bounds, y1_index, y2_index, d, name=None):\n    \"\"\"\n    Create an STL formula representing being inside a\n    rectangle with the given bounds:\n\n    ::\n\n       y2_max   +-------------------+\n                |                   |\n                |                   |\n                |                   |\n       y2_min   +-------------------+\n                y1_min              y1_max\n\n    :param bounds:      Tuple ``(y1_min, y1_max, y2_min, y2_max)`` containing\n                        the bounds of the rectangle.\n    :param y1_index:    index of the first (``y1``) dimension\n    :param y2_index:    index of the second (``y2``) dimension\n    :param d:           dimension of the overall signal\n    :param name:        (optional) string describing this formula\n\n    :return inside_rectangle:   An ``STLFormula`` specifying being inside the\n                                rectangle at time zero.\n    \"\"\"\n    assert y1_index < d, \"index must be less than signal dimension\"\n    assert y2_index < d, \"index must be less than signal dimension\"\n\n    # Unpack the bounds\n    y1_min, y1_max, y2_min, y2_max = bounds\n\n    # Create predicates a*y >= b for each side of the rectangle\n    a1 = np.zeros((1, d));\n    a1[:, y1_index] = 1\n    right = LinearPredicate(a1, y1_min)\n    left = LinearPredicate(-a1, -y1_max)\n\n    a2 = np.zeros((1, d));\n    a2[:, y2_index] = 1\n    top = LinearPredicate(a2, y2_min)\n    bottom = LinearPredicate(-a2, -y2_max)\n\n    # Take the conjuction across all the sides\n    inside_rectangle = right & left & top & bottom\n\n    # set the names\n    if name is not None:\n        inside_rectangle.__str__ = lambda: str(name)\n        inside_rectangle.__repr__ = lambda: str(name)\n\n    return inside_rectangle", "\n\ndef outside_rectangle_formula(bounds, y1_index, y2_index, d, name=None):\n    \"\"\"\n    Create an STL formula representing being outside a\n    rectangle with the given bounds:\n\n    ::\n\n       y2_max   +-------------------+\n                |                   |\n                |                   |\n                |                   |\n       y2_min   +-------------------+\n                y1_min              y1_max\n\n    :param bounds:      Tuple ``(y1_min, y1_max, y2_min, y2_max)`` containing\n                        the bounds of the rectangle.\n    :param y1_index:    index of the first (``y1``) dimension\n    :param y2_index:    index of the second (``y2``) dimension\n    :param d:           dimension of the overall signal\n    :param name:        (optional) string describing this formula\n\n    :return outside_rectangle:   An ``STLFormula`` specifying being outside the\n                                 rectangle at time zero.\n    \"\"\"\n    assert y1_index < d, \"index must be less than signal dimension\"\n    assert y2_index < d, \"index must be less than signal dimension\"\n\n    # Unpack the bounds\n    y1_min, y1_max, y2_min, y2_max = bounds\n\n    # Create predicates a*y >= b for each side of the rectangle\n    a1 = np.zeros((1, d))\n    a1[:, y1_index] = 1\n    right = LinearPredicate(a1, y1_max)\n    left = LinearPredicate(-a1, -y1_min)\n\n    a2 = np.zeros((1, d))\n    a2[:, y2_index] = 1\n    top = LinearPredicate(a2, y2_max)\n    bottom = LinearPredicate(-a2, -y2_min)\n\n    # Take the disjuction across all the sides\n    outside_rectangle = right | left | top | bottom\n\n    # set the names\n    if name is not None:\n        outside_rectangle.__str__ = lambda: str(name)\n        outside_rectangle.__repr__ = lambda: str(name)\n\n    return outside_rectangle", ""]}
{"filename": "src/stl_mob/envs/__init__.py", "chunked_list": [""]}
{"filename": "src/stl_mob/envs/wrapper.py", "chunked_list": ["from abc import ABC, abstractmethod\nfrom typing import Union, List\n\nimport gym\nimport numpy as np\n\nfrom stl_mob.envs.mujoco_robots.robots.engine import Engine\nfrom stl_mob.envs.pybullet_robots.base import BulletEnv\nfrom stl_mob.envs.pybullet_robots.robots.drone import Drone\nfrom stl_mob.stl.tasks import TaskBase", "from stl_mob.envs.pybullet_robots.robots.drone import Drone\nfrom stl_mob.stl.tasks import TaskBase\n\n\nclass EnvWrapper(ABC):\n    def __init__(self, task: TaskBase, enable_gui: bool = True):\n        self.task = task\n        self.enable_gui = enable_gui\n        self.obstacle_list = self.task.task_map.obs_list\n        self.wp_list = self.task.wp_list\n        self._goal = None\n        self.gym_env: Union[Engine, BulletEnv] = self.build_env()\n\n    @abstractmethod\n    def _set_goal(self, goal: Union[List, np.ndarray]):\n        raise NotImplementedError()\n\n    @abstractmethod\n    def build_env(self) -> Union[Engine, BulletEnv]:\n        raise NotImplementedError()\n\n    @abstractmethod\n    def get_pos(self):\n        pass\n\n    @abstractmethod\n    def set_pos(self, pos: Union[List, np.ndarray]):\n        pass\n\n    @abstractmethod\n    def get_obs(self) -> np.ndarray:\n        pass\n\n    def set_goal(self, goal: Union[List, np.ndarray]):\n        self._set_goal(goal)\n        self._goal = np.array(goal)\n\n    def get_goal(self) -> np.ndarray:\n        return self._goal\n\n    def step(self, action: Union[List, np.ndarray]):\n        if self.enable_gui:\n            self.gym_env.render()\n        return self.gym_env.step(action)\n\n    def reset(self, init_pos: Union[List, np.ndarray] = None):\n        self.gym_env.reset()\n        if init_pos is not None:\n            self.set_pos(init_pos)\n        return self.get_obs()\n\n    def reached(self, reach_radius: float = 0.3) -> bool:\n        return np.linalg.norm(self.get_pos() - self.get_goal()) < reach_radius\n\n    def close(self):\n        self.gym_env.close()", "\n\nclass MujocoEnv(EnvWrapper, ABC):\n    BASE_SENSORS = ['accelerometer', 'velocimeter', 'gyro', 'magnetometer']\n\n    def __init__(self, task: TaskBase, enable_gui: bool = True):\n        super().__init__(task, enable_gui)\n        for wp in self.task.wp_list:\n            self.add_wp_marker(wp.pos, wp.size)\n\n    def get_obs_config(self) -> dict:\n        config = {\n            'walls_num': len(self.task.task_map.obs_list),\n            'walls_locations': [obs.pos for obs in self.task.task_map.obs_list],\n            'walls_size': [obs.size for obs in self.task.task_map.obs_list],\n        }\n        return config\n\n    @abstractmethod\n    def get_robot_config(self) -> dict:\n        pass\n\n    def add_wp_marker(self,\n                      pos: Union[List, np.ndarray],\n                      size: float, color=(0, 1, 1, 0.5),\n                      alpha=0.5,\n                      label: str = \"\"):\n        self.gym_env.add_render_callback(lambda: self.gym_env.render_sphere(pos=pos,\n                                                                            size=size,\n                                                                            color=color,\n                                                                            alpha=alpha,\n                                                                            label=label))\n\n    def build_env(self) -> Engine:\n        config = self.get_robot_config()\n        config.update(self.get_obs_config())\n        gym_env = Engine(config)\n\n        return gym_env\n\n    def _set_goal(self, goal: Union[List, np.ndarray]):\n        self.gym_env.set_goal_position(goal_xy=goal[:2])\n\n    def get_pos(self) -> np.ndarray:\n        return np.array(self.gym_env.robot_pos[:2])\n\n    def get_obs(self) -> np.ndarray:\n        return self.gym_env.obs()", "\n\nclass PointEnv(MujocoEnv):\n\n    def get_robot_config(self) -> dict:\n        return {\n            \"robot_base\": f\"xmls/point.xml\",\n            'sensors_obs': self.BASE_SENSORS,\n            'observe_com': False,\n            'observe_goal_comp': True\n        }\n\n    def set_pos(self, pos: Union[List, np.ndarray]):\n        body_id = self.gym_env.sim.model.body_name2id('robot')\n        self.gym_env.sim.model.body_pos[body_id][:2] = pos\n        self.gym_env.sim.data.body_xpos[body_id][:2] = pos\n        self.gym_env.sim.forward()", "\n\nclass CarEnv(MujocoEnv):\n\n    def get_robot_config(self) -> dict:\n        return {\n            \"robot_base\": f\"xmls/car.xml\",\n            'sensors_obs': self.BASE_SENSORS,\n            'observe_com': False,\n            'observe_goal_comp': True,\n            'box_size': 0.125,  # Box half-radius size\n            'box_keepout': 0.125,  # Box keepout radius for placement\n            'box_density': 0.0005\n        }\n\n    def set_pos(self, pos: Union[List, np.ndarray]):\n        indx = self.gym_env.sim.model.get_joint_qpos_addr(\"robot\")\n        sim_state = self.gym_env.sim.get_state()\n\n        sim_state.qpos[indx[0]:indx[0] + 2] = pos\n        self.gym_env.sim.set_state(sim_state)\n        self.gym_env.sim.forward()", "\n\nclass DoggoEnv(MujocoEnv):\n\n    def get_robot_config(self) -> dict:\n        extra_sensor = [\n            'touch_ankle_1a',\n            'touch_ankle_2a',\n            'touch_ankle_3a',\n            'touch_ankle_4a',\n            'touch_ankle_1b',\n            'touch_ankle_2b',\n            'touch_ankle_3b',\n            'touch_ankle_4b'\n        ]\n        return {\n            \"robot_base\": f\"xmls/doggo.xml\",\n            'sensors_obs': self.BASE_SENSORS + extra_sensor,\n            'observe_com': False,\n            'observe_goal_comp': True\n        }\n\n    def set_pos(self, pos: Union[List, np.ndarray]):\n        indx = self.gym_env.sim.model.get_joint_qpos_addr(\"robot\")\n        sim_state = self.gym_env.sim.get_state()\n\n        sim_state.qpos[indx[0]:indx[0] + 2] = pos\n        self.gym_env.sim.set_state(sim_state)\n        self.gym_env.sim.forward()", "\n\nclass DroneEnv(EnvWrapper):\n\n    def build_env(self) -> gym.Env:\n        return BulletEnv(Drone(enable_gui=self.enable_gui))\n\n    def _set_goal(self, goal: Union[List, np.ndarray]):\n        pass\n\n    def get_pos(self) -> np.ndarray:\n        # np.array(p.getBasePositionAndOrientation(self.robot_id, self.client_id)[0])\n        pass\n\n    def set_pos(self, pos: Union[List, np.ndarray]):\n        pass\n\n    def get_obs(self) -> np.ndarray:\n        pass", "\n\ndef get_env(robot_name: str, task: TaskBase, enable_gui: bool = True):\n    if robot_name == \"drone\":\n        return DroneEnv(task, enable_gui)\n    elif robot_name == \"point\":\n        return PointEnv(task, enable_gui)\n    elif robot_name == \"car\":\n        return CarEnv(task, enable_gui)\n    elif robot_name == \"doggo\":\n        return DoggoEnv(task, enable_gui)\n    else:\n        raise ValueError(f\"Env {robot_name} not found\")", ""]}
{"filename": "src/stl_mob/envs/mujoco_robots/__init__.py", "chunked_list": [""]}
{"filename": "src/stl_mob/envs/mujoco_robots/robots/world.py", "chunked_list": ["#!/usr/bin/env python\n\nimport os\nfrom collections import OrderedDict\nfrom copy import deepcopy\n\nimport numpy as np\nimport xmltodict\nfrom mujoco_py import const, load_model_from_path, load_model_from_xml, MjSim, MjViewer, MjRenderContextOffscreen\n", "from mujoco_py import const, load_model_from_path, load_model_from_xml, MjSim, MjViewer, MjRenderContextOffscreen\n\nfrom stl_mob.envs import mujoco_robots\n\n'''\nTools that allow the Safety Gym Engine to interface to MuJoCo.\n\nThe World class owns the underlying mujoco scene and the XML,\nand is responsible for regenerating the simulator.\n", "and is responsible for regenerating the simulator.\n\nThe way to use this is to configure a World() based on your needs \n(number of objects, etc) and then call `world.reset()`.\n\n*NOTE:* The simulator should be accessed as `world.sim` and not just\nsaved separately, because it may change between resets.\n\nConfiguration is idiomatically done through Engine configuration,\nso any changes to this configuration should also be reflected in ", "Configuration is idiomatically done through Engine configuration,\nso any changes to this configuration should also be reflected in \nchanges to the Engine.\n\nTODO:\n- unit test scaffold\n'''\n\n# Default location to look for /xmls folder:\nBASE_DIR = os.path.dirname(mujoco_robots.__file__)", "# Default location to look for /xmls folder:\nBASE_DIR = os.path.dirname(mujoco_robots.__file__)\n\n\ndef convert(v):\n    ''' Convert a value into a string for mujoco XML '''\n    if isinstance(v, (int, float, str)):\n        return str(v)\n    # Numpy arrays and lists\n    return ' '.join(str(i) for i in np.asarray(v))", "\n\ndef rot2quat(theta):\n    ''' Get a quaternion rotated only about the Z axis '''\n    return np.array([np.cos(theta / 2), 0, 0, np.sin(theta / 2)], dtype='float64')\n\n\nclass World:\n    # Default configuration (this should not be nested since it gets copied)\n    # *NOTE:* Changes to this configuration should also be reflected in `Engine` configuration\n    DEFAULT = {\n        'robot_base': 'xmls/car.xml',  # Which robot XML to use as the base\n        'robot_xy': np.zeros(2),  # Robot XY location\n        'robot_rot': 0,  # Robot rotation about Z axis\n\n        'floor_size': [3.5, 3.5, .1],  # Used for displaying the floor\n\n        # Objects -- this is processed and added by the Engine class\n        'objects': {},  # map from name -> object dict\n        # Geoms -- similar to objects, but they are immovable and fixed in the scene.\n        'geoms': {},  # map from name -> geom dict\n        # Mocaps -- mocap objects which are used to control other objects\n        'mocaps': {},\n\n        # Determine whether we create render contexts\n        'observe_vision': False,\n    }\n\n    def __init__(self, config={}, render_context=None):\n        ''' config - JSON string or dict of configuration.  See self.parse() '''\n        self.parse(config)  # Parse configuration\n        self.first_reset = True\n        self.viewer = None\n        self.render_context = render_context\n        self.update_viewer_sim = False\n        self.robot = Robot(self.robot_base)\n\n    def parse(self, config):\n        ''' Parse a config dict - see self.DEFAULT for description '''\n        self.config = deepcopy(self.DEFAULT)\n        self.config.update(deepcopy(config))\n        for key, value in self.config.items():\n            assert key in self.DEFAULT, f'Bad key {key}'\n            setattr(self, key, value)\n\n    @property\n    def data(self):\n        ''' Helper to get the simulation data instance '''\n        return self.sim.data\n\n    # TODO: remove this when mujoco-py fix is merged and a new version is pushed\n    # https://github.com/openai/mujoco-py/pull/354\n    # Then all uses of `self.world.get_sensor()` should change to `self.data.get_sensor`.\n    def get_sensor(self, name):\n        id = self.model.sensor_name2id(name)\n        adr = self.model.sensor_adr[id]\n        dim = self.model.sensor_dim[id]\n        return self.data.sensordata[adr:adr + dim].copy()\n\n    def build(self):\n        ''' Build a world, including generating XML and moving objects '''\n        # Read in the base XML (contains robot, camera, floor, etc)\n        self.robot_base_path = os.path.join(BASE_DIR, self.robot_base)\n        with open(self.robot_base_path) as f:\n            self.robot_base_xml = f.read()\n        # Nested OrderedDict objects\n        self.xml = xmltodict.parse(self.robot_base_xml)\n\n        # Convenience accessor for xml dictionary\n        worldbody = self.xml['mujoco']['worldbody']\n\n        # Move robot position to starting position\n        worldbody['body']['@pos'] = convert(\n            np.r_[self.robot_xy, self.robot.z_height])\n        worldbody['body']['@quat'] = convert(rot2quat(self.robot_rot))\n\n        # We need this because xmltodict skips over single-item lists in the tree\n        worldbody['body'] = [worldbody['body']]\n        if 'geom' in worldbody:\n            worldbody['geom'] = [worldbody['geom']]\n        else:\n            worldbody['geom'] = []\n\n        # Add equality section if missing\n        if 'equality' not in self.xml['mujoco']:\n            self.xml['mujoco']['equality'] = OrderedDict()\n        equality = self.xml['mujoco']['equality']\n        if 'weld' not in equality:\n            equality['weld'] = []\n\n        # Add asset section if missing\n        if 'asset' not in self.xml['mujoco']:\n            # old default rgb1: \".4 .5 .6\"\n            # old default rgb2: \"0 0 0\"\n            # light pink: \"1 0.44 .81\"\n            # light blue: \"0.004 0.804 .996\"\n            # light purple: \".676 .547 .996\"\n            # med blue: \"0.527 0.582 0.906\"\n            # indigo: \"0.293 0 0.508\"\n            asset = xmltodict.parse('''\n                <asset>\n                    <texture type=\"skybox\" builtin=\"gradient\" rgb1=\"0.527 0.582 0.906\" rgb2=\"0.1 0.1 0.35\"\n                        width=\"800\" height=\"800\" markrgb=\"1 1 1\" mark=\"random\" random=\"0.001\"/>\n                    <texture name=\"texplane\" builtin=\"checker\" height=\"100\" width=\"100\"\n                        rgb1=\"0.7 0.7 0.7\" rgb2=\"0.8 0.8 0.8\" type=\"2d\"/>\n                    <material name=\"MatPlane\" reflectance=\"0.1\" shininess=\"0.1\" specular=\"0.1\"\n                        texrepeat=\"10 10\" texture=\"texplane\"/>\n                </asset>\n                ''')\n            self.xml['mujoco']['asset'] = asset['asset']\n\n        # Add light to the XML dictionary\n        light = xmltodict.parse('''<b>\n            <light cutoff=\"100\" diffuse=\"1 1 1\" dir=\"0 0 -1\" directional=\"true\"\n                exponent=\"1\" pos=\"0 0 0.5\" specular=\"0 0 0\" castshadow=\"false\"/>\n            </b>''')\n        worldbody['light'] = light['b']['light']\n\n        # Add floor to the XML dictionary if missing\n        if not any(g.get('@name') == 'floor' for g in worldbody['geom']):\n            floor = xmltodict.parse('''\n                <geom name=\"floor\" type=\"plane\" condim=\"6\"/>\n                ''')\n            worldbody['geom'].append(floor['geom'])\n\n        # Make sure floor renders the same for every world\n        for g in worldbody['geom']:\n            if g['@name'] == 'floor':\n                g.update({'@size': convert(self.floor_size),\n                          '@rgba': '1 1 1 1', '@material': 'MatPlane'})\n\n        # Add cameras to the XML dictionary\n        cameras = xmltodict.parse('''<b>\n            <camera name=\"fixednear\" pos=\"0 -2 2\" zaxis=\"0 -1 1\"/>\n            <camera name=\"fixedfar\" pos=\"0 -5 5\" zaxis=\"0 -1 1\"/>\n            </b>''')\n        worldbody['camera'] = cameras['b']['camera']\n\n        # Build and add a tracking camera (logic needed to ensure orientation correct)\n        theta = self.robot_rot\n        xyaxes = dict(\n            x1=np.cos(theta),\n            x2=-np.sin(theta),\n            x3=0,\n            y1=np.sin(theta),\n            y2=np.cos(theta),\n            y3=1\n        )\n        pos = dict(\n            xp=0 * np.cos(theta) + (-2) * np.sin(theta),\n            yp=0 * (-np.sin(theta)) + (-2) * np.cos(theta),\n            zp=2\n        )\n        track_camera = xmltodict.parse('''<b>\n            <camera name=\"track\" mode=\"track\" pos=\"{xp} {yp} {zp}\" xyaxes=\"{x1} {x2} {x3} {y1} {y2} {y3}\"/>\n            </b>'''.format(**pos, **xyaxes))\n        worldbody['body'][0]['camera'] = [\n            worldbody['body'][0]['camera'],\n            track_camera['b']['camera']\n        ]\n\n        # Add objects to the XML dictionary\n        for name, object in self.objects.items():\n            assert object['name'] == name, f'Inconsistent {name} {object}'\n            object = object.copy()  # don't modify original object\n            object['quat'] = rot2quat(object['rot'])\n            if name == 'box':\n                dim = object['size'][0]\n                object['dim'] = dim\n                object['width'] = dim / 2\n                object['x'] = dim\n                object['y'] = dim\n                body = xmltodict.parse('''\n                    <body name=\"{name}\" pos=\"{pos}\" quat=\"{quat}\">\n                        <freejoint name=\"{name}\"/>\n                        <geom name=\"{name}\" type=\"{type}\" size=\"{size}\" density=\"{density}\"\n                            rgba=\"{rgba}\" group=\"{group}\"/>\n                        <geom name=\"col1\" type=\"{type}\" size=\"{width} {width} {dim}\" density=\"{density}\"\n                            rgba=\"{rgba}\" group=\"{group}\" pos=\"{x} {y} 0\"/>\n                        <geom name=\"col2\" type=\"{type}\" size=\"{width} {width} {dim}\" density=\"{density}\"\n                            rgba=\"{rgba}\" group=\"{group}\" pos=\"-{x} {y} 0\"/>\n                        <geom name=\"col3\" type=\"{type}\" size=\"{width} {width} {dim}\" density=\"{density}\"\n                            rgba=\"{rgba}\" group=\"{group}\" pos=\"{x} -{y} 0\"/>\n                        <geom name=\"col4\" type=\"{type}\" size=\"{width} {width} {dim}\" density=\"{density}\"\n                            rgba=\"{rgba}\" group=\"{group}\" pos=\"-{x} -{y} 0\"/>\n                    </body>\n                '''.format(**{k: convert(v) for k, v in object.items()}))\n            else:\n                body = xmltodict.parse('''\n                    <body name=\"{name}\" pos=\"{pos}\" quat=\"{quat}\">\n                        <freejoint name=\"{name}\"/>\n                        <geom name=\"{name}\" type=\"{type}\" size=\"{size}\" density=\"{density}\"\n                            rgba=\"{rgba}\" group=\"{group}\"/>\n                    </body>\n                '''.format(**{k: convert(v) for k, v in object.items()}))\n            # Append new body to world, making it a list optionally\n            # Add the object to the world\n            worldbody['body'].append(body['body'])\n        # Add mocaps to the XML dictionary\n        for name, mocap in self.mocaps.items():\n            # Mocap names are suffixed with 'mocap'\n            assert mocap['name'] == name, f'Inconsistent {name} {object}'\n            assert name.replace(\n                'mocap', 'obj') in self.objects, f'missing object for {name}'\n            # Add the object to the world\n            mocap = mocap.copy()  # don't modify original object\n            mocap['quat'] = rot2quat(mocap['rot'])\n            body = xmltodict.parse('''\n                <body name=\"{name}\" mocap=\"true\">\n                    <geom name=\"{name}\" type=\"{type}\" size=\"{size}\" rgba=\"{rgba}\"\n                        pos=\"{pos}\" quat=\"{quat}\" contype=\"0\" conaffinity=\"0\" group=\"{group}\"/>\n                </body>\n            '''.format(**{k: convert(v) for k, v in mocap.items()}))\n            worldbody['body'].append(body['body'])\n            # Add weld to equality list\n            mocap['body1'] = name\n            mocap['body2'] = name.replace('mocap', 'obj')\n            weld = xmltodict.parse('''\n                <weld name=\"{name}\" body1=\"{body1}\" body2=\"{body2}\" solref=\".02 1.5\"/>\n            '''.format(**{k: convert(v) for k, v in mocap.items()}))\n            equality['weld'].append(weld['weld'])\n        # Add geoms to XML dictionary\n        for name, geom in self.geoms.items():\n            assert geom['name'] == name, f'Inconsistent {name} {geom}'\n            geom = geom.copy()  # don't modify original object\n            geom['quat'] = rot2quat(geom['rot'])\n            geom['contype'] = geom.get('contype', 1)\n            geom['conaffinity'] = geom.get('conaffinity', 1)\n            body = xmltodict.parse('''\n                <body name=\"{name}\" pos=\"{pos}\" quat=\"{quat}\">\n                    <geom name=\"{name}\" type=\"{type}\" size=\"{size}\" rgba=\"{rgba}\" group=\"{group}\"\n                        contype=\"{contype}\" conaffinity=\"{conaffinity}\"/>\n                </body>\n            '''.format(**{k: convert(v) for k, v in geom.items()}))\n            # Append new body to world, making it a list optionally\n            # Add the object to the world\n            worldbody['body'].append(body['body'])\n\n        # Instantiate simulator\n        # print(xmltodict.unparse(self.xml, pretty=True))\n        self.xml_string = xmltodict.unparse(self.xml)\n        self.model = load_model_from_xml(self.xml_string)\n        self.sim = MjSim(self.model)\n\n        # Add render contexts to newly created sim\n        if self.render_context is None and self.observe_vision:\n            render_context = MjRenderContextOffscreen(\n                self.sim, device_id=-1, quiet=True)\n            render_context.vopt.geomgroup[:] = 1\n            self.render_context = render_context\n\n        if self.render_context is not None:\n            self.render_context.update_sim(self.sim)\n\n        # Recompute simulation intrinsics from new position\n        self.sim.forward()\n\n    def rebuild(self, config={}, state=True):\n        ''' Build a new sim from a model if the model changed '''\n        if state:\n            old_state = self.sim.get_state()\n        # self.config.update(deepcopy(config))\n        # self.parse(self.config)\n        self.parse(config)\n        self.build()\n        if state:\n            self.sim.set_state(old_state)\n        self.sim.forward()\n\n    def reset(self, build=True):\n        ''' Reset the world (sim is accessed through self.sim) '''\n        if build:\n            self.build()\n        # set flag so that renderer knows to update sim\n        self.update_viewer_sim = True\n\n    def render(self, mode='human'):\n        ''' Render the environment to the screen '''\n        if self.viewer is None:\n            self.viewer = MjViewer(self.sim)\n            # Turn all the geom groups on\n            self.viewer.vopt.geomgroup[:] = 1\n            # Set camera if specified\n            if mode == 'human':\n                self.viewer.cam.fixedcamid = -1\n                self.viewer.cam.type = const.CAMERA_FREE\n            else:\n                self.viewer.cam.fixedcamid = self.model.camera_name2id(mode)\n                self.viewer.cam.type = const.CAMERA_FIXED\n        if self.update_viewer_sim:\n            self.viewer.update_sim(self.sim)\n            self.update_viewer_sim = False\n        self.viewer.render()\n\n    def robot_com(self):\n        ''' Get the position of the robot center of mass in the simulator world reference frame '''\n        return self.body_com('robot')\n\n    def robot_pos(self):\n        ''' Get the position of the robot in the simulator world reference frame '''\n        return self.body_pos('robot')\n\n    def robot_mat(self):\n        ''' Get the rotation matrix of the robot in the simulator world reference frame '''\n        return self.body_mat('robot')\n\n    def robot_vel(self):\n        ''' Get the velocity of the robot in the simulator world reference frame '''\n        return self.body_vel('robot')\n\n    def body_com(self, name):\n        ''' Get the center of mass of a named body in the simulator world reference frame '''\n        return self.data.subtree_com[self.model.body_name2id(name)].copy()\n\n    def body_pos(self, name):\n        ''' Get the position of a named body in the simulator world reference frame '''\n        return self.data.get_body_xpos(name).copy()\n\n    def body_mat(self, name):\n        ''' Get the rotation matrix of a named body in the simulator world reference frame '''\n        return self.data.get_body_xmat(name).copy()\n\n    def body_vel(self, name):\n        ''' Get the velocity of a named body in the simulator world reference frame '''\n        return self.data.get_body_xvelp(name).copy()\n\n    def set_body_pos(self, name, new_pos):\n        ''' Set the position of a named body in the simulator world reference frame '''\n        body_pos = self.data.get_body_xpos(name)\n        body_pos[:len(new_pos)] = new_pos", "\n\nclass Robot:\n    ''' Simple utility class for getting mujoco-specific info about a robot '''\n\n    def __init__(self, path):\n        base_path = os.path.join(BASE_DIR, path)\n        self.sim = MjSim(load_model_from_path(base_path))\n        self.sim.forward()\n\n        # Needed to figure out z-height of free joint of offset body\n        self.z_height = self.sim.data.get_body_xpos('robot')[2]\n        # Get a list of geoms in the robot\n        self.geom_names = [\n            n for n in self.sim.model.geom_names if n != 'floor']\n        # Needed to figure out the observation spaces\n        self.nq = self.sim.model.nq\n        self.nv = self.sim.model.nv\n        # Needed to figure out action space\n        self.nu = self.sim.model.nu\n        # Needed to figure out observation space\n        # See engine.py for an explanation for why we treat these separately\n        self.hinge_pos_names = []\n        self.hinge_vel_names = []\n        self.ballquat_names = []\n        self.ballangvel_names = []\n        self.sensor_dim = {}\n        for name in self.sim.model.sensor_names:\n            id = self.sim.model.sensor_name2id(name)\n            self.sensor_dim[name] = self.sim.model.sensor_dim[id]\n            sensor_type = self.sim.model.sensor_type[id]\n            if self.sim.model.sensor_objtype[id] == const.OBJ_JOINT:\n                joint_id = self.sim.model.sensor_objid[id]\n                joint_type = self.sim.model.jnt_type[joint_id]\n                if joint_type == const.JNT_HINGE:\n                    if sensor_type == const.SENS_JOINTPOS:\n                        self.hinge_pos_names.append(name)\n                    elif sensor_type == const.SENS_JOINTVEL:\n                        self.hinge_vel_names.append(name)\n                    else:\n                        t = self.sim.model.sensor_type[i]\n                        raise ValueError(\n                            'Unrecognized sensor type {} for joint'.format(t))\n                elif joint_type == const.JNT_BALL:\n                    if sensor_type == const.SENS_BALLQUAT:\n                        self.ballquat_names.append(name)\n                    elif sensor_type == const.SENS_BALLANGVEL:\n                        self.ballangvel_names.append(name)\n                elif joint_type == const.JNT_SLIDE:\n                    # Adding slide joints is trivially easy in code,\n                    # but this removes one of the good properties about our observations.\n                    # (That we are invariant to relative whole-world transforms)\n                    # If slide joints are added we sould ensure this stays true!\n                    raise ValueError(\n                        'Slide joints in robots not currently supported')", ""]}
{"filename": "src/stl_mob/envs/mujoco_robots/robots/__init__.py", "chunked_list": [""]}
{"filename": "src/stl_mob/envs/mujoco_robots/robots/engine.py", "chunked_list": ["#!/usr/bin/env python\n\nfrom collections import OrderedDict\nfrom copy import deepcopy\n\nimport glfw\nimport gym\nimport gym.spaces\nimport mujoco_py\nimport numpy as np", "import mujoco_py\nimport numpy as np\nfrom PIL import Image\nfrom mujoco_py import (MjRenderContextOffscreen, MjViewer, MujocoException,\n                       const)\n\nfrom stl_mob.envs.mujoco_robots.robots.world import Robot, World\n\n# Distinct colors for different types of objects.\n# For now this is mostly used for visualization.", "# Distinct colors for different types of objects.\n# For now this is mostly used for visualization.\n# This also affects the vision observation, so if training from pixels.\nCOLOR_BOX = np.array([1, 1, 0, 1])\nCOLOR_BUTTON = np.array([1, .5, 0, 1])\nCOLOR_GOAL = np.array([0, 1, 0, 1])\nCOLOR_VASE = np.array([0, 1, 1, 1])\nCOLOR_HAZARD = np.array([0, 0, 1, 1])\nCOLOR_PILLAR = np.array([.5, .5, 1, 1])\nCOLOR_WALL = np.array([.5, .5, .5, 1])", "COLOR_PILLAR = np.array([.5, .5, 1, 1])\nCOLOR_WALL = np.array([.5, .5, .5, 1])\nCOLOR_GREMLIN = np.array([0.5, 0, 1, 1])\nCOLOR_CIRCLE = np.array([0, 1, 0, 1])\nCOLOR_RED = np.array([1, 0, 0, 1])\n\n# Groups are a mujoco-specific mechanism for selecting which geom objects to \"see\"\n# We use these for raycasting lidar, where there are different lidar types.\n# These work by turning \"on\" the group to see and \"off\" all the other groups.\n# See obs_lidar_natural() for more.", "# These work by turning \"on\" the group to see and \"off\" all the other groups.\n# See obs_lidar_natural() for more.\nGROUP_GOAL = 0\nGROUP_BOX = 1\nGROUP_BUTTON = 1\nGROUP_WALL = 2\nGROUP_PILLAR = 2\nGROUP_HAZARD = 3\nGROUP_VASE = 4\nGROUP_GREMLIN = 5", "GROUP_VASE = 4\nGROUP_GREMLIN = 5\nGROUP_CIRCLE = 6\n\n# Constant for origin of world\nORIGIN_COORDINATES = np.zeros(3)\n\n# Constant defaults for rendering frames for humans (not used for vision)\nDEFAULT_WIDTH = 1500\nDEFAULT_HEIGHT = 1500", "DEFAULT_WIDTH = 1500\nDEFAULT_HEIGHT = 1500\n\n\nclass ResamplingError(AssertionError):\n    ''' Raised when we fail to sample a valid distribution of objects or goals '''\n    pass\n\n\ndef theta2vec(theta):\n    ''' Convert an angle (in radians) to a unit vector in that angle around Z '''\n    return np.array([np.cos(theta), np.sin(theta), 0.0])", "\ndef theta2vec(theta):\n    ''' Convert an angle (in radians) to a unit vector in that angle around Z '''\n    return np.array([np.cos(theta), np.sin(theta), 0.0])\n\n\ndef quat2mat(quat):\n    ''' Convert Quaternion to a 3x3 Rotation Matrix using mujoco '''\n    q = np.array(quat, dtype='float64')\n    m = np.zeros(9, dtype='float64')\n    mujoco_py.functions.mju_quat2Mat(m, q)\n    return m.reshape((3, 3))", "\n\ndef quat2zalign(quat):\n    ''' From quaternion, extract z_{ground} dot z_{body} '''\n    # z_{body} from quaternion [a,b,c,d] in ground frame is:\n    # [ 2bd + 2ac,\n    #   2cd - 2ab,\n    #   a**2 - b**2 - c**2 + d**2\n    # ]\n    # so inner product with z_{ground} = [0,0,1] is\n    # z_{body} dot z_{ground} = a**2 - b**2 - c**2 + d**2\n    a, b, c, d = quat\n    return a ** 2 - b ** 2 - c ** 2 + d ** 2", "\n\nclass Engine(gym.Env, gym.utils.EzPickle):\n    '''\n    Engine: an environment-building tool for safe exploration research.\n\n    The Engine() class entails everything to do with the tasks and safety \n    requirements of Safety Gym environments. An Engine() uses a World() object\n    to interface to MuJoCo. World() configurations are inferred from Engine()\n    configurations, so an environment in Safety Gym can be completely specified\n    by the config dict of the Engine() object.\n\n    '''\n\n    metadata = {\"render.modes\": [\"human\", \"rgb_array\"]}\n\n    # Default configuration (this should not be nested since it gets copied)\n    DEFAULT = {\n        'num_steps': 1000,  # Maximum number of environment steps in an episode\n\n        'action_noise': 0.0,  # Magnitude of independent per-component gaussian action noise\n\n        # Placement limits (min X, min Y, max X, max Y)\n        'placements_extents': [-2, -2, 2, 2],\n        'placements_margin': 0.0,  # Additional margin added to keepout when placing objects\n\n        # Floor\n        # In display mode, the visible part of the floor is cropped\n        'floor_display_mode': False,\n\n        # Robot\n        # Robot placements list (defaults to full extents)\n        'robot_placements': None,\n        'robot_locations': [],  # Explicitly place robot XY coordinate\n        'robot_keepout': 0.4,  # Needs to be set to match the robot XML used\n        'robot_base': 'xmls/car.xml',  # Which robot XML to use as the base\n        'robot_rot': None,  # Override robot starting angle\n\n        # Starting position distribution\n        'randomize_layout': True,  # If false, set the random seed before layout to constant\n        'build_resample': True,  # If true, rejection sample from valid environments\n        'continue_goal': False,  # If true, draw a new goal after achievement\n        # If true, end episode when resampling fails,\n        'terminate_resample_failure': True,\n        # otherwise, raise a python exception.\n        # TODO: randomize starting joint positions\n\n        # Observation flags - some of these require other flags to be on\n        # By default, only robot sensor observations are enabled.\n        'observation_flatten': True,  # Flatten observation into a vector\n        'observe_sensors': True,  # Observe all sensor data from simulator\n        'observe_goal_dist': False,  # Observe the distance to the goal\n        'observe_goal_comp': True,  # Observe a compass vector to the goal\n        'observe_goal_lidar': False,  # Observe the goal with a lidar sensor\n        'observe_box_comp': False,  # Observe the box with a compass\n        'observe_box_lidar': False,  # Observe the box with a lidar\n        'observe_circle': False,  # Observe the origin with a lidar\n        'observe_remaining': False,  # Observe the fraction of steps remaining\n        'observe_walls': False,  # Observe the walls with a lidar space\n        'observe_hazards': False,  # Observe the vector from agent to hazards\n        'observe_vases': False,  # Observe the vector from agent to vases\n        'observe_pillars': False,  # Lidar observation of pillar object positions\n        'observe_buttons': False,  # Lidar observation of button object positions\n        'observe_gremlins': False,  # Gremlins are observed with lidar-like space\n        'observe_vision': False,  # Observe vision from the robot\n        # These next observations are unnormalized, and are only for debugging\n        'observe_qpos': False,  # Observe the qpos of the world\n        'observe_qvel': False,  # Observe the qvel of the robot\n        'observe_ctrl': False,  # Observe the previous action\n        'observe_freejoint': False,  # Observe base robot free joint\n        'observe_com': False,  # Observe the center of mass of the robot\n\n        # Render options\n        'render_labels': False,\n        'render_lidar_markers': True,\n        'render_lidar_radius': 0.15,\n        'render_lidar_size': 0.025,\n        'render_lidar_offset_init': 0.5,\n        'render_lidar_offset_delta': 0.06,\n\n        # Vision observation parameters\n        'vision_size': (60, 40),\n        # Size (width, height) of vision observation; gets flipped internally to (rows, cols) format\n        'vision_render': True,  # Render vision observation in the viewer\n        # Size to render the vision in the viewer\n        'vision_render_size': (300, 200),\n\n        # Lidar observation parameters\n        'lidar_num_bins': 10,  # Bins (around a full circle) for lidar sensing\n        # Maximum distance for lidar sensitivity (if None, exponential distance)\n        'lidar_max_dist': None,\n        'lidar_exp_gain': 1.0,  # Scaling factor for distance in exponential distance lidar\n        'lidar_type': 'pseudo',  # 'pseudo', 'natural', see self.obs_lidar()\n        'lidar_alias': True,  # Lidar bins alias into each other\n\n        # Compass observation parameters\n        # Set to 2 or 3 for XY or XYZ unit vector compass observation.\n        'compass_shape': 2,\n\n        # Task\n        # goal, button, push, x, z, circle, or none (for screenshots)\n        'task': 'goal',\n\n        # Goal parameters\n        # Placements where goal may appear (defaults to full extents)\n        'goal_placements': None,\n        'goal_locations': [],  # Fixed locations to override placements\n        'goal_keepout': 0.4,  # Keepout radius when placing goals\n        'goal_size': 0.3,  # Radius of the goal area (if using task 'goal')\n\n        # Box parameters (only used if task == 'push')\n        # Box placements list (defaults to full extents)\n        'box_placements': None,\n        'box_locations': [],  # Fixed locations to override placements\n        'box_keepout': 0.2,  # Box keepout radius for placement\n        'box_size': 0.2,  # Box half-radius size\n        'box_density': 0.001,  # Box density\n        'box_null_dist': 2,  # Within box_null_dist * box_size radius of box, no box reward given\n\n        # Reward is distance towards goal plus a constant for being within range of goal\n        # reward_distance should be positive to encourage moving towards the goal\n        # if reward_distance is 0, then the reward function is sparse\n        'reward_distance': 1.0,  # Dense reward multiplied by the distance moved to the goal\n        'reward_goal': 1.0,  # Sparse reward for being inside the goal area\n        'reward_box_dist': 1.0,  # Dense reward for moving the robot towards the box\n        'reward_box_goal': 1.0,  # Reward for moving the box towards the goal\n        'reward_orientation': False,  # Reward for being upright\n        'reward_orientation_scale': 0.002,  # Scale for uprightness reward\n        'reward_orientation_body': 'robot',  # What body to get orientation from\n        'reward_exception': -10.0,  # Reward when encoutering a mujoco exception\n        # Reward for forward locomotion tests (vel in x direction)\n        'reward_x': 1.0,\n        'reward_z': 1.0,  # Reward for standup tests (vel in z direction)\n        # Reward for circle goal (complicated formula depending on pos and vel)\n        'reward_circle': 1e-1,\n        # Clip reward, last resort against physics errors causing magnitude spikes\n        'reward_clip': 100,\n\n        # Buttons are small immovable spheres, to the environment\n        'buttons_num': 0,  # Number of buttons to add\n        # Buttons placements list (defaults to full extents)\n        'buttons_placements': None,\n        'buttons_locations': [],  # Fixed locations to override placements\n        'buttons_keepout': 0.3,  # Buttons keepout radius for placement\n        'buttons_size': 0.1,  # Size of buttons in the scene\n        'buttons_cost': 1.0,  # Cost for pressing the wrong button, if constrain_buttons\n        # Buttons have a timeout period (steps) before resampling\n        'buttons_resampling_delay': 10,\n\n        # Circle parameters (only used if task == 'circle')\n        'circle_radius': 1.5,\n\n        # Sensor observations\n        # Specify which sensors to add to observation space\n        'sensors_obs': ['accelerometer', 'velocimeter', 'gyro', 'magnetometer'],\n        'sensors_hinge_joints': True,  # Observe named joint position / velocity sensors\n        'sensors_ball_joints': True,  # Observe named balljoint position / velocity sensors\n        'sensors_angle_components': True,  # Observe sin/cos theta instead of theta\n\n        # Walls - barriers in the environment not associated with any constraint\n        # NOTE: this is probably best to be auto-generated than manually specified\n        'walls_num': 0,  # Number of walls\n        'walls_placements': None,  # This should not be used\n        'walls_locations': [],  # This should be used and length == walls_num\n        'walls_keepout': 0.0,  # This should not be used\n        'walls_size': 0.5,  # Should be fixed at fundamental size of the world\n\n        # Constraints - flags which can be turned on\n        # By default, no constraints are enabled, and all costs are indicator functions.\n        'constrain_hazards': False,  # Constrain robot from being in hazardous areas\n        'constrain_vases': False,  # Constrain frobot from touching objects\n        'constrain_pillars': False,  # Immovable obstacles in the environment\n        'constrain_buttons': False,  # Penalize pressing incorrect buttons\n        'constrain_gremlins': False,  # Moving objects that must be avoided\n        # If true, all costs are either 1 or 0 for a given step.\n        'constrain_indicator': True,\n\n        # Hazardous areas\n        'hazards_num': 0,  # Number of hazards in an environment\n        # Placements list for hazards (defaults to full extents)\n        'hazards_placements': None,\n        'hazards_locations': [],  # Fixed locations to override placements\n        'hazards_keepout': 0.4,  # Radius of hazard keepout for placement\n        'hazards_size': 0.3,  # Radius of hazards\n        'hazards_cost': 1.0,  # Cost (per step) for violating the constraint\n\n        # Vases (objects we should not touch)\n        'vases_num': 0,  # Number of vases in the world\n        # Vases placements list (defaults to full extents)\n        'vases_placements': None,\n        'vases_locations': [],  # Fixed locations to override placements\n        'vases_keepout': 0.15,  # Radius of vases keepout for placement\n        'vases_size': 0.1,  # Half-size (radius) of vase object\n        'vases_density': 0.001,  # Density of vases\n        'vases_sink': 4e-5,  # Experimentally measured, based on size and density,\n        # how far vases \"sink\" into the floor.\n        # Mujoco has soft contacts, so vases slightly sink into the floor,\n        # in a way which can be hard to precisely calculate (and varies with time)\n        # Ignore some costs below a small threshold, to reduce noise.\n        # Cost (per step) for being in contact with a vase\n        'vases_contact_cost': 1.0,\n        # Cost (per step) per meter of displacement for a vase\n        'vases_displace_cost': 0.0,\n        'vases_displace_threshold': 1e-3,  # Threshold for displacement being \"real\"\n        # Cost (per step) per m/s of velocity for a vase\n        'vases_velocity_cost': 1.0,\n        'vases_velocity_threshold': 1e-4,  # Ignore very small velocities\n\n        # Pillars (immovable obstacles we should not touch)\n        'pillars_num': 0,  # Number of pillars in the world\n        # Pillars placements list (defaults to full extents)\n        'pillars_placements': None,\n        'pillars_locations': [],  # Fixed locations to override placements\n        'pillars_keepout': 0.3,  # Radius for placement of pillars\n        'pillars_size': 0.2,  # Half-size (radius) of pillar objects\n        'pillars_height': 0.5,  # Half-height of pillars geoms\n        # Cost (per step) for being in contact with a pillar\n        'pillars_cost': 1.0,\n\n        # Gremlins (moving objects we should avoid)\n        'gremlins_num': 0,  # Number of gremlins in the world\n        # Gremlins placements list (defaults to full extents)\n        'gremlins_placements': None,\n        'gremlins_locations': [],  # Fixed locations to override placements\n        # Radius for keeping out (contains gremlin path)\n        'gremlins_keepout': 0.5,\n        'gremlins_travel': 0.3,  # Radius of the circle traveled in\n        'gremlins_size': 0.1,  # Half-size (radius) of gremlin objects\n        'gremlins_density': 0.001,  # Density of gremlins\n        'gremlins_contact_cost': 1.0,  # Cost for touching a gremlin\n        'gremlins_dist_threshold': 0.2,  # Threshold for cost for being too close\n        'gremlins_dist_cost': 1.0,  # Cost for being within distance threshold\n\n        # Frameskip is the number of physics simulation steps per environment step\n        # Frameskip is sampled as a binomial distribution\n        # For deterministic steps, set frameskip_binom_p = 1.0 (always take max frameskip)\n        # Number of draws trials in binomial distribution (max frameskip)\n        'frameskip_binom_n': 10,\n        # Probability of trial return (controls distribution)\n        'frameskip_binom_p': 1.0,\n\n        # Random state seed (avoid name conflict with self.seed)\n        '_seed': None,\n\n        # Never Done\n        'never_done': True,\n    }\n\n    def __init__(self, config={}):\n        # First, parse configuration. Important note: LOTS of stuff happens in\n        # parse, and many attributes of the class get set through setattr. If you\n        # are trying to track down where an attribute gets initially set, and\n        # can't find it anywhere else, it's probably set via the config dict\n        # and this parse function.\n        self.parse(config)\n        gym.utils.EzPickle.__init__(self, config=config)\n\n        # Load up a simulation of the robot, just to figure out observation space\n        self.robot = Robot(self.robot_base)\n\n        self.action_space = gym.spaces.Box(-1,\n                                           1, (self.robot.nu,), dtype=np.float32)\n        self.build_observation_space()\n        self.build_placements_dict()\n\n        self.viewer = None\n        self.world = None\n        self.clear()\n\n        self.seed(self._seed)\n        self.done = True\n\n        self.render_callback_list = []\n\n    def parse(self, config):\n        ''' Parse a config dict - see self.DEFAULT for description '''\n        self.config = deepcopy(self.DEFAULT)\n        self.config.update(deepcopy(config))\n        for key, value in self.config.items():\n            assert key in self.DEFAULT, f'Bad key {key}'\n            setattr(self, key, value)\n\n    @property\n    def sim(self):\n        ''' Helper to get the world's simulation instance '''\n        return self.world.sim\n\n    @property\n    def model(self):\n        ''' Helper to get the world's model instance '''\n        return self.sim.model\n\n    @property\n    def data(self):\n        ''' Helper to get the world's simulation data instance '''\n        return self.sim.data\n\n    @property\n    def robot_pos(self):\n        ''' Helper to get current robot position '''\n        return self.data.get_body_xpos('robot').copy()\n\n    @property\n    def goal_pos(self):\n        ''' Helper to get goal position from layout '''\n        if self.task in ['goal', 'push']:\n            return self.data.get_body_xpos('goal').copy()\n        elif self.task == 'button':\n            return self.data.get_body_xpos(f'button{self.goal_button}').copy()\n        elif self.task == 'circle':\n            return ORIGIN_COORDINATES\n        elif self.task == 'none':\n            return np.zeros(2)  # Only used for screenshots\n        else:\n            raise ValueError(f'Invalid task {self.task}')\n\n    @property\n    def box_pos(self):\n        ''' Helper to get the box position '''\n        return self.data.get_body_xpos('box').copy()\n\n    @property\n    def buttons_pos(self):\n        ''' Helper to get the list of button positions '''\n        return [self.data.get_body_xpos(f'button{i}').copy() for i in range(self.buttons_num)]\n\n    @property\n    def vases_pos(self):\n        ''' Helper to get the list of vase positions '''\n        return [self.data.get_body_xpos(f'vase{p}').copy() for p in range(self.vases_num)]\n\n    @property\n    def gremlins_obj_pos(self):\n        ''' Helper to get the current gremlin position '''\n        return [self.data.get_body_xpos(f'gremlin{i}obj').copy() for i in range(self.gremlins_num)]\n\n    @property\n    def pillars_pos(self):\n        ''' Helper to get list of pillar positions '''\n        return [self.data.get_body_xpos(f'pillar{i}').copy() for i in range(self.pillars_num)]\n\n    @property\n    def hazards_pos(self):\n        ''' Helper to get the hazards positions from layout '''\n        return [self.data.get_body_xpos(f'hazard{i}').copy() for i in range(self.hazards_num)]\n\n    @property\n    def walls_pos(self):\n        ''' Helper to get the hazards positions from layout '''\n        return [self.data.get_body_xpos(f'wall{i}').copy() for i in range(self.walls_num)]\n\n    def build_observation_space(self):\n        ''' Construct observtion space.  Happens only once at during __init__ '''\n        obs_space_dict = OrderedDict()  # See self.obs()\n\n        if self.observe_freejoint:\n            obs_space_dict['freejoint'] = gym.spaces.Box(\n                -np.inf, np.inf, (7,), dtype=np.float32)\n        if self.observe_com:\n            obs_space_dict['com'] = gym.spaces.Box(\n                -np.inf, np.inf, (3,), dtype=np.float32)\n        if self.observe_sensors:\n            for sensor in self.sensors_obs:  # Explicitly listed sensors\n                dim = self.robot.sensor_dim[sensor]\n                obs_space_dict[sensor] = gym.spaces.Box(\n                    -np.inf, np.inf, (dim,), dtype=np.float32)\n            # Velocities don't have wraparound effects that rotational positions do\n            # Wraparounds are not kind to neural networks\n            # Whereas the angle 2*pi is very close to 0, this isn't true in the network\n            # In theory the network could learn this, but in practice we simplify it\n            # when the sensors_angle_components switch is enabled.\n            for sensor in self.robot.hinge_vel_names:\n                obs_space_dict[sensor] = gym.spaces.Box(\n                    -np.inf, np.inf, (1,), dtype=np.float32)\n            for sensor in self.robot.ballangvel_names:\n                obs_space_dict[sensor] = gym.spaces.Box(\n                    -np.inf, np.inf, (3,), dtype=np.float32)\n            # Angular positions have wraparound effects, so output something more friendly\n            if self.sensors_angle_components:\n                # Single joints are turned into sin(x), cos(x) pairs\n                # These should be easier to learn for neural networks,\n                # Since for angles, small perturbations in angle give small differences in sin/cos\n                for sensor in self.robot.hinge_pos_names:\n                    obs_space_dict[sensor] = gym.spaces.Box(\n                        -np.inf, np.inf, (2,), dtype=np.float32)\n                # Quaternions are turned into 3x3 rotation matrices\n                # Quaternions have a wraparound issue in how they are normalized,\n                # where the convention is to change the sign so the first element to be positive.\n                # If the first element is close to 0, this can mean small differences in rotation\n                # lead to large differences in value as the latter elements change sign.\n                # This also means that the first element of the quaternion is not expectation zero.\n                # The SO(3) rotation representation would be a good replacement here,\n                # since it smoothly varies between values in all directions (the property we want),\n                # but right now we have very little code to support SO(3) roatations.\n                # Instead we use a 3x3 rotation matrix, which if normalized, smoothly varies as well.\n                for sensor in self.robot.ballquat_names:\n                    obs_space_dict[sensor] = gym.spaces.Box(-np.inf,\n                                                            np.inf, (3, 3), dtype=np.float32)\n            else:\n                # Otherwise include the sensor without any processing\n                # TODO: comparative study of the performance with and without this feature.\n                for sensor in self.robot.hinge_pos_names:\n                    obs_space_dict[sensor] = gym.spaces.Box(\n                        -np.inf, np.inf, (1,), dtype=np.float32)\n                for sensor in self.robot.ballquat_names:\n                    obs_space_dict[sensor] = gym.spaces.Box(\n                        -np.inf, np.inf, (4,), dtype=np.float32)\n        if self.task == 'push':\n            if self.observe_box_comp:\n                obs_space_dict['box_compass'] = gym.spaces.Box(\n                    -1.0, 1.0, (self.compass_shape,), dtype=np.float32)\n            if self.observe_box_lidar:\n                obs_space_dict['box_lidar'] = gym.spaces.Box(\n                    0.0, 1.0, (self.lidar_num_bins,), dtype=np.float32)\n        if self.observe_goal_dist:\n            obs_space_dict['goal_dist'] = gym.spaces.Box(\n                0.0, 1.0, (1,), dtype=np.float32)\n        if self.observe_goal_comp:\n            obs_space_dict['goal_compass'] = gym.spaces.Box(\n                -1.0, 1.0, (self.compass_shape,), dtype=np.float32)\n        if self.observe_goal_lidar:\n            obs_space_dict['goal_lidar'] = gym.spaces.Box(\n                0.0, 1.0, (self.lidar_num_bins,), dtype=np.float32)\n        if self.task == 'circle' and self.observe_circle:\n            obs_space_dict['circle_lidar'] = gym.spaces.Box(\n                0.0, 1.0, (self.lidar_num_bins,), dtype=np.float32)\n        if self.observe_remaining:\n            obs_space_dict['remaining'] = gym.spaces.Box(\n                0.0, 1.0, (1,), dtype=np.float32)\n        if self.walls_num and self.observe_walls:\n            obs_space_dict['walls_lidar'] = gym.spaces.Box(\n                0.0, 1.0, (self.lidar_num_bins,), dtype=np.float32)\n        if self.observe_hazards:\n            obs_space_dict['hazards_lidar'] = gym.spaces.Box(\n                0.0, 1.0, (self.lidar_num_bins,), dtype=np.float32)\n        if self.observe_vases:\n            obs_space_dict['vases_lidar'] = gym.spaces.Box(\n                0.0, 1.0, (self.lidar_num_bins,), dtype=np.float32)\n        if self.gremlins_num and self.observe_gremlins:\n            obs_space_dict['gremlins_lidar'] = gym.spaces.Box(\n                0.0, 1.0, (self.lidar_num_bins,), dtype=np.float32)\n        if self.pillars_num and self.observe_pillars:\n            obs_space_dict['pillars_lidar'] = gym.spaces.Box(\n                0.0, 1.0, (self.lidar_num_bins,), dtype=np.float32)\n        if self.buttons_num and self.observe_buttons:\n            obs_space_dict['buttons_lidar'] = gym.spaces.Box(\n                0.0, 1.0, (self.lidar_num_bins,), dtype=np.float32)\n        if self.observe_qpos:\n            obs_space_dict['qpos'] = gym.spaces.Box(-np.inf,\n                                                    np.inf, (self.robot.nq,), dtype=np.float32)\n        if self.observe_qvel:\n            obs_space_dict['qvel'] = gym.spaces.Box(-np.inf,\n                                                    np.inf, (self.robot.nv,), dtype=np.float32)\n        if self.observe_ctrl:\n            obs_space_dict['ctrl'] = gym.spaces.Box(-np.inf,\n                                                    np.inf, (self.robot.nu,), dtype=np.float32)\n        if self.observe_vision:\n            width, height = self.vision_size\n            rows, cols = height, width\n            self.vision_size = (rows, cols)\n            obs_space_dict['vision'] = gym.spaces.Box(\n                0, 1.0, self.vision_size + (3,), dtype=np.float32)\n        # Flatten it ourselves\n        self.obs_space_dict = obs_space_dict\n        if self.observation_flatten:\n            self.obs_flat_size = sum([np.prod(i.shape)\n                                      for i in self.obs_space_dict.values()])\n            self.observation_space = gym.spaces.Box(-np.inf,\n                                                    np.inf, (self.obs_flat_size,), dtype=np.float32)\n        else:\n            self.observation_space = gym.spaces.Dict(obs_space_dict)\n\n    def toggle_observation_space(self):\n        self.observation_flatten = not (self.observation_flatten)\n        self.build_observation_space()\n\n    def placements_from_location(self, location, keepout):\n        ''' Helper to get a placements list from a given location and keepout '''\n        x, y = location\n        return [(x - keepout, y - keepout, x + keepout, y + keepout)]\n\n    def placements_dict_from_object(self, object_name):\n        ''' Get the placements dict subset just for a given object name '''\n        placements_dict = {}\n        if hasattr(self, object_name + 's_num'):  # Objects with multiplicity\n            plural_name = object_name + 's'\n            object_fmt = object_name + '{i}'\n            object_num = getattr(self, plural_name + '_num', None)\n            object_locations = getattr(self, plural_name + '_locations', [])\n            object_placements = getattr(\n                self, plural_name + '_placements', None)\n            object_keepout = getattr(self, plural_name + '_keepout')\n        else:  # Unique objects\n            object_fmt = object_name\n            object_num = 1\n            object_locations = getattr(self, object_name + '_locations', [])\n            object_placements = getattr(\n                self, object_name + '_placements', None)\n            object_keepout = getattr(self, object_name + '_keepout')\n        for i in range(object_num):\n            if i < len(object_locations):\n                x, y = object_locations[i]\n                k = object_keepout + 1e-9  # Epsilon to account for numerical issues\n                placements = [(x - k, y - k, x + k, y + k)]\n            else:\n                placements = object_placements\n            placements_dict[object_fmt.format(i=i)] = (\n                placements, object_keepout)\n        return placements_dict\n\n    def build_placements_dict(self):\n        ''' Build a dict of placements.  Happens once during __init__. '''\n        # Dictionary is map from object name -> tuple of (placements list, keepout)\n        placements = {}\n\n        placements.update(self.placements_dict_from_object('robot'))\n        placements.update(self.placements_dict_from_object('wall'))\n\n        if self.task in ['goal', 'push']:\n            placements.update(self.placements_dict_from_object('goal'))\n        if self.task == 'push':\n            placements.update(self.placements_dict_from_object('box'))\n        if self.task == 'button' or self.buttons_num:  # self.constrain_buttons:\n            placements.update(self.placements_dict_from_object('button'))\n        if self.hazards_num:  # self.constrain_hazards:\n            placements.update(self.placements_dict_from_object('hazard'))\n        if self.vases_num:  # self.constrain_vases:\n            placements.update(self.placements_dict_from_object('vase'))\n        if self.pillars_num:  # self.constrain_pillars:\n            placements.update(self.placements_dict_from_object('pillar'))\n        if self.gremlins_num:  # self.constrain_gremlins:\n            placements.update(self.placements_dict_from_object('gremlin'))\n\n        self.placements = placements\n\n    def seed(self, seed=None):\n        ''' Set internal random state seeds '''\n        self._seed = np.random.randint(2 ** 32) if seed is None else seed\n\n    def build_layout(self):\n        ''' Rejection sample a placement of objects to find a layout. '''\n        if not self.randomize_layout:\n            self.rs = np.random.RandomState(0)\n\n        for _ in range(10000):\n            if self.sample_layout():\n                break\n        else:\n            raise ResamplingError('Failed to sample layout of objects')\n\n    def sample_layout(self):\n        ''' Sample a single layout, returning True if successful, else False. '''\n\n        def placement_is_valid(xy, layout):\n            for other_name, other_xy in layout.items():\n                other_keepout = self.placements[other_name][1]\n                dist = np.sqrt(np.sum(np.square(xy - other_xy)))\n                if dist < other_keepout + self.placements_margin + keepout:\n                    return False\n            return True\n\n        layout = {}\n        for name, (placements, keepout) in self.placements.items():\n            conflicted = True\n            for _ in range(100):\n                xy = self.draw_placement(placements, keepout)\n                if placement_is_valid(xy, layout):\n                    conflicted = False\n                    break\n            if conflicted:\n                return False\n            layout[name] = xy\n        self.layout = layout\n        return True\n\n    def constrain_placement(self, placement, keepout):\n        ''' Helper function to constrain a single placement by the keepout radius '''\n        xmin, ymin, xmax, ymax = placement\n        return (xmin + keepout, ymin + keepout, xmax - keepout, ymax - keepout)\n\n    def draw_placement(self, placements, keepout):\n        ''' \n        Sample an (x,y) location, based on potential placement areas.\n\n        Summary of behavior: \n\n        'placements' is a list of (xmin, xmax, ymin, ymax) tuples that specify \n        rectangles in the XY-plane where an object could be placed. \n\n        'keepout' describes how much space an object is required to have\n        around it, where that keepout space overlaps with the placement rectangle.\n\n        To sample an (x,y) pair, first randomly select which placement rectangle\n        to sample from, where the probability of a rectangle is weighted by its\n        area. If the rectangles are disjoint, there's an equal chance the (x,y) \n        location will wind up anywhere in the placement space. If they overlap, then\n        overlap areas are double-counted and will have higher density. This allows\n        the user some flexibility in building placement distributions. Finally, \n        randomly draw a uniform point within the selected rectangle.\n\n        '''\n        if placements is None:\n            choice = self.constrain_placement(self.placements_extents, keepout)\n        else:\n            # Draw from placements according to placeable area\n            constrained = []\n            for placement in placements:\n                xmin, ymin, xmax, ymax = self.constrain_placement(\n                    placement, keepout)\n                if xmin > xmax or ymin > ymax:\n                    continue\n                constrained.append((xmin, ymin, xmax, ymax))\n            assert len(\n                constrained), 'Failed to find any placements with satisfy keepout'\n            if len(constrained) == 1:\n                choice = constrained[0]\n            else:\n                areas = [(x2 - x1) * (y2 - y1)\n                         for x1, y1, x2, y2 in constrained]\n                probs = np.array(areas) / np.sum(areas)\n                choice = constrained[self.rs.choice(len(constrained), p=probs)]\n        xmin, ymin, xmax, ymax = choice\n        return np.array([self.rs.uniform(xmin, xmax), self.rs.uniform(ymin, ymax)])\n\n    def random_rot(self):\n        ''' Use internal random state to get a random rotation in radians '''\n        return self.rs.uniform(0, 2 * np.pi)\n\n    def build_world_config(self):\n        ''' Create a world_config from our own config '''\n        # TODO: parse into only the pieces we want/need\n        world_config = {}\n\n        world_config['robot_base'] = self.robot_base\n        world_config['robot_xy'] = self.layout['robot']\n        if self.robot_rot is None:\n            world_config['robot_rot'] = self.random_rot()\n        else:\n            world_config['robot_rot'] = float(self.robot_rot)\n\n        if self.floor_display_mode:\n            floor_size = max(self.placements_extents)\n            world_config['floor_size'] = [floor_size + .1, floor_size + .1, 1]\n\n        # if not self.observe_vision:\n        #    world_config['render_context'] = -1  # Hijack this so we don't create context\n        world_config['observe_vision'] = self.observe_vision\n\n        # Extra objects to add to the scene\n        world_config['objects'] = {}\n        if self.vases_num:\n            for i in range(self.vases_num):\n                name = f'vase{i}'\n                object = {'name': name,\n                          'size': np.ones(3) * self.vases_size,\n                          'type': 'box',\n                          'density': self.vases_density,\n                          'pos': np.r_[self.layout[name], self.vases_size - self.vases_sink],\n                          'rot': self.random_rot(),\n                          'group': GROUP_VASE,\n                          'rgba': COLOR_VASE}\n                world_config['objects'][name] = object\n        if self.gremlins_num:\n            self._gremlins_rots = dict()\n            for i in range(self.gremlins_num):\n                name = f'gremlin{i}obj'\n                self._gremlins_rots[i] = self.random_rot()\n                object = {'name': name,\n                          'size': np.ones(3) * self.gremlins_size,\n                          'type': 'box',\n                          'density': self.gremlins_density,\n                          'pos': np.r_[self.layout[name.replace('obj', '')], self.gremlins_size],\n                          'rot': self._gremlins_rots[i],\n                          'group': GROUP_GREMLIN,\n                          'rgba': COLOR_GREMLIN}\n                world_config['objects'][name] = object\n        if self.task == 'push':\n            object = {'name': 'box',\n                      'type': 'box',\n                      'size': np.ones(3) * self.box_size,\n                      'pos': np.r_[self.layout['box'], self.box_size],\n                      'rot': self.random_rot(),\n                      'density': self.box_density,\n                      'group': GROUP_BOX,\n                      'rgba': COLOR_BOX}\n            world_config['objects']['box'] = object\n\n        # Extra geoms (immovable objects) to add to the scene\n        world_config['geoms'] = {}\n        if self.task in ['goal', 'push']:\n            geom = {'name': 'goal',\n                    'size': [self.goal_size, 0.05],\n                    'pos': np.r_[self.layout['goal'], self.goal_size / 2 + 1e-2],\n                    'rot': self.random_rot(),\n                    'type': 'cylinder',\n                    'contype': 0,\n                    'conaffinity': 0,\n                    'group': GROUP_GOAL,\n                    'rgba': COLOR_GOAL * [1, 1, 1, 0.25]}  # transparent\n            world_config['geoms']['goal'] = geom\n        if self.hazards_num:\n            for i in range(self.hazards_num):\n                name = f'hazard{i}'\n                geom = {'name': name,\n                        # self.hazards_size / 2],\n                        'size': [self.hazards_size, 1e-2],\n                        # self.hazards_size / 2 + 1e-2],\n                        'pos': np.r_[self.layout[name], 2e-2],\n                        'rot': self.random_rot(),\n                        'type': 'cylinder',\n                        'contype': 0,\n                        'conaffinity': 0,\n                        'group': GROUP_HAZARD,\n                        'rgba': COLOR_HAZARD * [1, 1, 1, 0.25]}  # 0.1]}  # transparent\n                world_config['geoms'][name] = geom\n        if self.pillars_num:\n            for i in range(self.pillars_num):\n                name = f'pillar{i}'\n                geom = {'name': name,\n                        'size': [self.pillars_size, self.pillars_height],\n                        'pos': np.r_[self.layout[name], self.pillars_height],\n                        'rot': self.random_rot(),\n                        'type': 'cylinder',\n                        'group': GROUP_PILLAR,\n                        'rgba': COLOR_PILLAR}\n                world_config['geoms'][name] = geom\n        if self.walls_num:\n            for i in range(self.walls_num):\n                name = f'wall{i}'\n\n                if isinstance(self.walls_size, int):\n                    wall_size = np.ones(3) * self.walls_size\n                elif isinstance(self.walls_size, list):\n                    assert len(self.walls_size) == self.walls_num\n                    wall_size = np.array(self.walls_size[i])\n                    assert wall_size.shape == (2,)\n                    wall_size = np.r_[wall_size, 0.2]\n                else:\n                    raise ValueError(f'walls_size must be int or list, not {type(self.walls_size)}')\n\n                geom = {'name': name,\n                        'size': wall_size,\n                        'pos': np.r_[self.layout[name], 0.2],\n                        'rot': 0,\n                        'type': 'box',\n                        'group': GROUP_WALL,\n                        'rgba': COLOR_WALL}\n                world_config['geoms'][name] = geom\n        if self.buttons_num:\n            for i in range(self.buttons_num):\n                name = f'button{i}'\n                geom = {'name': name,\n                        'size': np.ones(3) * self.buttons_size,\n                        'pos': np.r_[self.layout[name], self.buttons_size],\n                        'rot': self.random_rot(),\n                        'type': 'sphere',\n                        'group': GROUP_BUTTON,\n                        'rgba': COLOR_BUTTON}\n                world_config['geoms'][name] = geom\n        if self.task == 'circle':\n            geom = {'name': 'circle',\n                    'size': np.array([self.circle_radius, 1e-2]),\n                    'pos': np.array([0, 0, 2e-2]),\n                    'rot': 0,\n                    'type': 'cylinder',\n                    'contype': 0,\n                    'conaffinity': 0,\n                    'group': GROUP_CIRCLE,\n                    'rgba': COLOR_CIRCLE * [1, 1, 1, 0.1]}\n            world_config['geoms']['circle'] = geom\n\n        # Extra mocap bodies used for control (equality to object of same name)\n        world_config['mocaps'] = {}\n        if self.gremlins_num:\n            for i in range(self.gremlins_num):\n                name = f'gremlin{i}mocap'\n                mocap = {'name': name,\n                         'size': np.ones(3) * self.gremlins_size,\n                         'type': 'box',\n                         'pos': np.r_[self.layout[name.replace('mocap', '')], self.gremlins_size],\n                         'rot': self._gremlins_rots[i],\n                         'group': GROUP_GREMLIN,\n                         'rgba': np.array([1, 1, 1, .1]) * COLOR_GREMLIN}\n                # 'rgba': np.array([1, 1, 1, 0]) * COLOR_GREMLIN}\n                world_config['mocaps'][name] = mocap\n\n        return world_config\n\n    def clear(self):\n        ''' Reset internal state for building '''\n        self.layout = None\n\n    def build_goal(self):\n        ''' Build a new goal position, maybe with resampling due to hazards '''\n        if self.task == 'goal':\n            self.build_goal_position()\n            self.last_dist_goal = self.dist_goal()\n        elif self.task == 'push':\n            self.build_goal_position()\n            self.last_dist_goal = self.dist_goal()\n            self.last_dist_box = self.dist_box()\n            self.last_box_goal = self.dist_box_goal()\n        elif self.task == 'button':\n            assert self.buttons_num > 0, 'Must have at least one button'\n            self.build_goal_button()\n            self.last_dist_goal = self.dist_goal()\n        elif self.task in ['x', 'z']:\n            self.last_robot_com = self.world.robot_com()\n        elif self.task in ['circle', 'none']:\n            pass\n        else:\n            raise ValueError(f'Invalid task {self.task}')\n\n    def sample_goal_position(self):\n        ''' Sample a new goal position and return True, else False if sample rejected '''\n        placements, keepout = self.placements['goal']\n        goal_xy = self.draw_placement(placements, keepout)\n        for other_name, other_xy in self.layout.items():\n            other_keepout = self.placements[other_name][1]\n            dist = np.sqrt(np.sum(np.square(goal_xy - other_xy)))\n            if dist < other_keepout + self.placements_margin + keepout:\n                return False\n        self.layout['goal'] = goal_xy\n        return True\n\n    def build_goal_position(self):\n        ''' Build a new goal position, maybe with resampling due to hazards '''\n        # Resample until goal is compatible with layout\n        if 'goal' in self.layout:\n            del self.layout['goal']\n        for _ in range(10000):  # Retries\n            if self.sample_goal_position():\n                break\n        else:\n            raise ResamplingError('Failed to generate goal')\n        # Move goal geom to new layout position\n        self.world_config_dict['geoms']['goal']['pos'][:2] = self.layout['goal']\n        # self.world.rebuild(deepcopy(self.world_config_dict))\n        # self.update_viewer_sim = True\n        goal_body_id = self.sim.model.body_name2id('goal')\n        self.sim.model.body_pos[goal_body_id][:2] = self.layout['goal']\n        self.sim.forward()\n\n    def set_goal_position(self, goal_xy):\n        if 'goal' in self.layout:\n            del self.layout['goal']\n        self.layout['goal'] = goal_xy\n\n        self.world_config_dict['geoms']['goal']['pos'][:2] = self.layout['goal']\n        goal_body_id = self.sim.model.body_name2id('goal')\n        self.sim.model.body_pos[goal_body_id][:2] = self.layout['goal']\n        self.sim.forward()\n\n    def build_goal_button(self):\n        ''' Pick a new goal button, maybe with resampling due to hazards '''\n        self.goal_button = self.rs.choice(self.buttons_num)\n\n    def build(self):\n        ''' Build a new physics simulation environment '''\n        # Sample object positions\n        self.build_layout()\n\n        # Build the underlying physics world\n        self.world_config_dict = self.build_world_config()\n\n        if self.world is None:\n            self.world = World(self.world_config_dict)\n            self.world.reset()\n            self.world.build()\n        else:\n            self.world.reset(build=False)\n            self.world.rebuild(self.world_config_dict, state=False)\n        # Redo a small amount of work, and setup initial goal state\n        self.build_goal()\n\n        # Save last action\n        self.last_action = np.zeros(self.action_space.shape)\n\n        # Save last subtree center of mass\n        self.last_subtreecom = self.world.get_sensor('subtreecom')\n\n    def reset(self):\n        ''' Reset the physics simulation and return observation '''\n        self._seed += 1  # Increment seed\n        self.rs = np.random.RandomState(self._seed)\n        self.done = False\n        self.steps = 0  # Count of steps taken in this episode\n        # Set the button timer to zero (so button is immediately visible)\n        self.buttons_timer = 0\n\n        self.clear()\n        self.build()\n        # Save the layout at reset\n        self.reset_layout = deepcopy(self.layout)\n\n        cost = self.cost()\n        assert cost['cost'] == 0, f'World has starting cost! {cost}'\n\n        # Reset stateful parts of the environment\n        self.first_reset = False  # Built our first world successfully\n\n        # Return an observation\n        return self.obs()\n\n    def dist_goal(self):\n        ''' Return the distance from the robot to the goal XY position '''\n        return self.dist_xy(self.goal_pos)\n\n    def dist_box(self):\n        ''' Return the distance from the robot to the box (in XY plane only) '''\n        assert self.task == 'push', f'invalid task {self.task}'\n        return np.sqrt(np.sum(np.square(self.box_pos - self.world.robot_pos())))\n\n    def dist_box_goal(self):\n        ''' Return the distance from the box to the goal XY position '''\n        assert self.task == 'push', f'invalid task {self.task}'\n        return np.sqrt(np.sum(np.square(self.box_pos - self.goal_pos)))\n\n    def dist_xy(self, pos):\n        ''' Return the distance from the robot to an XY position '''\n        pos = np.asarray(pos)\n        if pos.shape == (3,):\n            pos = pos[:2]\n        robot_pos = self.world.robot_pos()\n        return np.sqrt(np.sum(np.square(pos - robot_pos[:2])))\n\n    def world_xy(self, pos):\n        ''' Return the world XY vector to a position from the robot '''\n        assert pos.shape == (2,)\n        return pos - self.world.robot_pos()[:2]\n\n    def ego_xy(self, pos):\n        ''' Return the egocentric XY vector to a position from the robot '''\n        assert pos.shape == (2,), f'Bad pos {pos}'\n        robot_3vec = self.world.robot_pos()\n        robot_mat = self.world.robot_mat()\n        pos_3vec = np.concatenate([pos, [0]])  # Add a zero z-coordinate\n        world_3vec = pos_3vec - robot_3vec\n        return np.matmul(world_3vec, robot_mat)[:2]  # only take XY coordinates\n\n    def obs_compass(self, pos):\n        '''\n        Return a robot-centric compass observation of a list of positions.\n\n        Compass is a normalized (unit-lenght) egocentric XY vector,\n        from the agent to the object.\n\n        This is equivalent to observing the egocentric XY angle to the target,\n        projected into the sin/cos space we use for joints.\n        (See comment on joint observation for why we do this.)\n        '''\n        pos = np.asarray(pos)\n        if pos.shape == (2,):\n            pos = np.concatenate([pos, [0]])  # Add a zero z-coordinate\n        # Get ego vector in world frame\n        vec = pos - self.world.robot_pos()\n        # Rotate into frame\n        vec = np.matmul(vec, self.world.robot_mat())\n        # Truncate\n        vec = vec[:self.compass_shape]\n        # Normalize\n        vec /= np.sqrt(np.sum(np.square(vec))) + 0.001\n        assert vec.shape == (self.compass_shape,), f'Bad vec {vec}'\n        return vec\n\n    def obs_vision(self):\n        ''' Return pixels from the robot camera '''\n        # Get a render context so we can\n        rows, cols = self.vision_size\n        width, height = cols, rows\n        vision = self.sim.render(\n            width, height, camera_name='vision', mode='offscreen')\n        return np.array(vision, dtype='float32') / 255\n\n    def obs_lidar(self, positions, group):\n        '''\n        Calculate and return a lidar observation.  See sub methods for implementation.\n        '''\n        if self.lidar_type == 'pseudo':\n            return self.obs_lidar_pseudo(positions)\n        elif self.lidar_type == 'natural':\n            return self.obs_lidar_natural(group)\n        else:\n            raise ValueError(f'Invalid lidar_type {self.lidar_type}')\n\n    def obs_lidar_natural(self, group):\n        '''\n        Natural lidar casts rays based on the ego-frame of the robot.\n        Rays are circularly projected from the robot body origin\n        around the robot z axis.\n        '''\n        body = self.model.body_name2id('robot')\n        grp = np.asarray([i == group for i in range(\n            int(const.NGROUP))], dtype='uint8')\n        pos = np.asarray(self.world.robot_pos(), dtype='float64')\n        mat_t = self.world.robot_mat()\n        obs = np.zeros(self.lidar_num_bins)\n        for i in range(self.lidar_num_bins):\n            theta = (i / self.lidar_num_bins) * np.pi * 2\n            # Rotate from ego to world frame\n            vec = np.matmul(mat_t, theta2vec(theta))\n            vec = np.asarray(vec, dtype='float64')\n            dist, _ = self.sim.ray_fast_group(pos, vec, grp, 1, body)\n            if dist >= 0:\n                obs[i] = np.exp(-dist)\n        return obs\n\n    def obs_lidar_pseudo(self, positions):\n        '''\n        Return a robot-centric lidar observation of a list of positions.\n\n        Lidar is a set of bins around the robot (divided evenly in a circle).\n        The detection directions are exclusive and exhaustive for a full 360 view.\n        Each bin reads 0 if there are no objects in that direction.\n        If there are multiple objects, the distance to the closest one is used.\n        Otherwise the bin reads the fraction of the distance towards the robot.\n\n        E.g. if the object is 90% of lidar_max_dist away, the bin will read 0.1,\n        and if the object is 10% of lidar_max_dist away, the bin will read 0.9.\n        (The reading can be thought of as \"closeness\" or inverse distance)\n\n        This encoding has some desirable properties:\n            - bins read 0 when empty\n            - bins smoothly increase as objects get close\n            - maximum reading is 1.0 (where the object overlaps the robot)\n            - close objects occlude far objects\n            - constant size observation with variable numbers of objects\n        '''\n        obs = np.zeros(self.lidar_num_bins)\n        for pos in positions:\n            pos = np.asarray(pos)\n            if pos.shape == (3,):\n                pos = pos[:2]  # Truncate Z coordinate\n            # X, Y as real, imaginary components\n            z = np.complex(*self.ego_xy(pos))\n            dist = np.abs(z)\n            angle = np.angle(z) % (np.pi * 2)\n            bin_size = (np.pi * 2) / self.lidar_num_bins\n            bin = int(angle / bin_size)\n            bin_angle = bin_size * bin\n            if self.lidar_max_dist is None:\n                sensor = np.exp(-self.lidar_exp_gain * dist)\n            else:\n                sensor = max(0, self.lidar_max_dist - dist) / \\\n                         self.lidar_max_dist\n            obs[bin] = max(obs[bin], sensor)\n            # Aliasing\n            if self.lidar_alias:\n                alias = (angle - bin_angle) / bin_size\n                assert 0 <= alias <= 1, f'bad alias {alias}, dist {dist}, angle {angle}, bin {bin}'\n                bin_plus = (bin + 1) % self.lidar_num_bins\n                bin_minus = (bin - 1) % self.lidar_num_bins\n                obs[bin_plus] = max(obs[bin_plus], alias * sensor)\n                obs[bin_minus] = max(obs[bin_minus], (1 - alias) * sensor)\n        return obs\n\n    def obs(self):\n        ''' Return the observation of our agent '''\n        self.sim.forward()  # Needed to get sensordata correct\n        obs = {}\n\n        if self.observe_goal_dist:\n            obs['goal_dist'] = np.array([np.exp(-self.dist_goal())])\n        if self.observe_goal_comp:\n            obs['goal_compass'] = self.obs_compass(self.goal_pos)\n        if self.observe_goal_lidar:\n            obs['goal_lidar'] = self.obs_lidar([self.goal_pos], GROUP_GOAL)\n        if self.task == 'push':\n            box_pos = self.box_pos\n            if self.observe_box_comp:\n                obs['box_compass'] = self.obs_compass(box_pos)\n            if self.observe_box_lidar:\n                obs['box_lidar'] = self.obs_lidar([box_pos], GROUP_BOX)\n        if self.task == 'circle' and self.observe_circle:\n            obs['circle_lidar'] = self.obs_lidar([self.goal_pos], GROUP_CIRCLE)\n        if self.observe_freejoint:\n            joint_id = self.model.joint_name2id('robot')\n            joint_qposadr = self.model.jnt_qposadr[joint_id]\n            assert joint_qposadr == 0  # Needs to be the first entry in qpos\n            obs['freejoint'] = self.data.qpos[:7]\n        if self.observe_com:\n            obs['com'] = self.world.robot_com()\n        if self.observe_sensors:\n            # Sensors which can be read directly, without processing\n            for sensor in self.sensors_obs:  # Explicitly listed sensors\n                obs[sensor] = self.world.get_sensor(sensor)\n            for sensor in self.robot.hinge_vel_names:\n                obs[sensor] = self.world.get_sensor(sensor)\n            for sensor in self.robot.ballangvel_names:\n                obs[sensor] = self.world.get_sensor(sensor)\n            # Process angular position sensors\n            if self.sensors_angle_components:\n                for sensor in self.robot.hinge_pos_names:\n                    # Ensure not 1D, 1-element array\n                    theta = float(self.world.get_sensor(sensor))\n                    obs[sensor] = np.array([np.sin(theta), np.cos(theta)])\n                for sensor in self.robot.ballquat_names:\n                    quat = self.world.get_sensor(sensor)\n                    obs[sensor] = quat2mat(quat)\n            else:  # Otherwise read sensors directly\n                for sensor in self.robot.hinge_pos_names:\n                    obs[sensor] = self.world.get_sensor(sensor)\n                for sensor in self.robot.ballquat_names:\n                    obs[sensor] = self.world.get_sensor(sensor)\n        if self.observe_remaining:\n            obs['remaining'] = np.array([self.steps / self.num_steps])\n            assert 0.0 <= obs['remaining'][0] <= 1.0, 'bad remaining {}'.format(\n                obs['remaining'])\n        if self.walls_num and self.observe_walls:\n            obs['walls_lidar'] = self.obs_lidar(self.walls_pos, GROUP_WALL)\n        if self.observe_hazards:\n            obs['hazards_lidar'] = self.obs_lidar(\n                self.hazards_pos, GROUP_HAZARD)\n        if self.observe_vases:\n            obs['vases_lidar'] = self.obs_lidar(self.vases_pos, GROUP_VASE)\n        if self.gremlins_num and self.observe_gremlins:\n            obs['gremlins_lidar'] = self.obs_lidar(\n                self.gremlins_obj_pos, GROUP_GREMLIN)\n        if self.pillars_num and self.observe_pillars:\n            obs['pillars_lidar'] = self.obs_lidar(\n                self.pillars_pos, GROUP_PILLAR)\n        if self.buttons_num and self.observe_buttons:\n            # Buttons observation is zero while buttons are resetting\n            if self.buttons_timer == 0:\n                obs['buttons_lidar'] = self.obs_lidar(\n                    self.buttons_pos, GROUP_BUTTON)\n            else:\n                obs['buttons_lidar'] = np.zeros(self.lidar_num_bins)\n        if self.observe_qpos:\n            obs['qpos'] = self.data.qpos.copy()\n        if self.observe_qvel:\n            obs['qvel'] = self.data.qvel.copy()\n        if self.observe_ctrl:\n            obs['ctrl'] = self.data.ctrl.copy()\n        if self.observe_vision:\n            obs['vision'] = self.obs_vision()\n\n        if self.observation_flatten:\n            flat_obs = np.zeros(self.obs_flat_size, dtype=np.float32)\n            offset = 0\n            for k in sorted(self.obs_space_dict.keys()):\n                k_size = np.prod(obs[k].shape)\n                flat_obs[offset:offset + k_size] = obs[k].flat\n                offset += k_size\n            obs = flat_obs\n        assert self.observation_space.contains(\n            obs), f'Bad obs {obs} {self.observation_space}'\n        return obs\n\n    def cost(self):\n        ''' Calculate the current costs and return a dict '''\n        self.sim.forward()  # Ensure positions and contacts are correct\n        cost = {}\n        # Conctacts processing\n        if self.constrain_vases:\n            cost['cost_vases_contact'] = 0\n        if self.constrain_pillars:\n            cost['cost_pillars'] = 0\n        if self.constrain_buttons:\n            cost['cost_buttons'] = 0\n        if self.constrain_gremlins:\n            cost['cost_gremlins'] = 0\n        buttons_constraints_active = self.constrain_buttons and (\n                self.buttons_timer == 0)\n        for contact in self.data.contact[:self.data.ncon]:\n            geom_ids = [contact.geom1, contact.geom2]\n            geom_names = sorted([self.model.geom_id2name(g) for g in geom_ids])\n            if self.constrain_vases and any(n.startswith('vase') for n in geom_names):\n                if any(n in self.robot.geom_names for n in geom_names):\n                    cost['cost_vases_contact'] += self.vases_contact_cost\n            if self.constrain_pillars and any(n.startswith('pillar') for n in geom_names):\n                if any(n in self.robot.geom_names for n in geom_names):\n                    cost['cost_pillars'] += self.pillars_cost\n            if buttons_constraints_active and any(n.startswith('button') for n in geom_names):\n                if any(n in self.robot.geom_names for n in geom_names):\n                    if not any(n == f'button{self.goal_button}' for n in geom_names):\n                        cost['cost_buttons'] += self.buttons_cost\n            if self.constrain_gremlins and any(n.startswith('gremlin') for n in geom_names):\n                if any(n in self.robot.geom_names for n in geom_names):\n                    cost['cost_gremlins'] += self.gremlins_contact_cost\n\n        # Displacement processing\n        if self.constrain_vases and self.vases_displace_cost:\n            cost['cost_vases_displace'] = 0\n            for i in range(self.vases_num):\n                name = f'vase{i}'\n                dist = np.sqrt(\n                    np.sum(\n                        np.square(self.data.get_body_xpos(name)[: 2] - self.reset_layout[name])))\n                if dist > self.vases_displace_threshold:\n                    cost['cost_vases_displace'] += dist * \\\n                                                   self.vases_displace_cost\n\n        # Velocity processing\n        if self.constrain_vases and self.vases_velocity_cost:\n            # TODO: penalize rotational velocity too, but requires another cost coefficient\n            cost['cost_vases_velocity'] = 0\n            for i in range(self.vases_num):\n                name = f'vase{i}'\n                vel = np.sqrt(\n                    np.sum(np.square(self.data.get_body_xvelp(name))))\n                if vel >= self.vases_velocity_threshold:\n                    cost['cost_vases_velocity'] += vel * \\\n                                                   self.vases_velocity_cost\n\n        # Calculate constraint violations\n        if self.constrain_hazards:\n            cost['cost_hazards'] = 0\n            for h_pos in self.hazards_pos:\n                h_dist = self.dist_xy(h_pos)\n                if h_dist <= self.hazards_size:\n                    cost['cost_hazards'] += self.hazards_cost * \\\n                                            (self.hazards_size - h_dist)\n\n        # Sum all costs into single total cost\n        cost['cost'] = sum(v for k, v in cost.items() if k.startswith('cost_'))\n\n        # Optionally remove shaping from reward functions.\n        if self.constrain_indicator:\n            for k in list(cost.keys()):\n                cost[k] = float(cost[k] > 0.0)  # Indicator function\n\n        self._cost = cost\n\n        return cost\n\n    def goal_met(self):\n        ''' Return true if the current goal is met this step '''\n        if self.task == 'goal':\n            return self.dist_goal() <= self.goal_size\n        if self.task == 'push':\n            return self.dist_box_goal() <= self.goal_size\n        if self.task == 'button':\n            for contact in self.data.contact[:self.data.ncon]:\n                geom_ids = [contact.geom1, contact.geom2]\n                geom_names = sorted([self.model.geom_id2name(g)\n                                     for g in geom_ids])\n                if any(n == f'button{self.goal_button}' for n in geom_names):\n                    if any(n in self.robot.geom_names for n in geom_names):\n                        return True\n            return False\n        if self.task in ['x', 'z', 'circle', 'none']:\n            return False\n        raise ValueError(f'Invalid task {self.task}')\n\n    def set_mocaps(self):\n        ''' Set mocap object positions before a physics step is executed '''\n        if self.gremlins_num:  # self.constrain_gremlins:\n            phase = float(self.data.time)\n            for i in range(self.gremlins_num):\n                name = f'gremlin{i}'\n                target = np.array(\n                    [np.sin(phase), np.cos(phase)]) * self.gremlins_travel\n                pos = np.r_[target, [self.gremlins_size]]\n                self.data.set_mocap_pos(name + 'mocap', pos)\n\n    def update_layout(self):\n        ''' Update layout dictionary with new places of objects '''\n        self.sim.forward()\n        for k in list(self.layout.keys()):\n            # Mocap objects have to be handled separately\n            if 'gremlin' in k:\n                continue\n            self.layout[k] = self.data.get_body_xpos(k)[:2].copy()\n\n    def buttons_timer_tick(self):\n        ''' Tick the buttons resampling timer '''\n        self.buttons_timer = max(0, self.buttons_timer - 1)\n\n    def step(self, action):\n        ''' Take a step and return observation, reward, done, and info '''\n        action = np.array(action, copy=False)  # Cast to ndarray\n        # assert not self.done, 'Environment must be reset before stepping'\n        self.done = False\n\n        info = {}\n\n        # Set action\n        action_range = self.model.actuator_ctrlrange\n        # action_scale = action_range[:,1] - action_range[:, 0]\n        self.data.ctrl[:] = np.clip(action, action_range[:, 0],\n                                    action_range[:, 1])  # np.clip(action * 2 / action_scale, -1, 1)\n        if self.action_noise:\n            self.data.ctrl[:] += self.action_noise * \\\n                                 self.rs.randn(self.model.nu)\n\n        # Simulate physics forward\n        exception = False\n        for _ in range(self.rs.binomial(self.frameskip_binom_n, self.frameskip_binom_p)):\n            try:\n                self.set_mocaps()\n                self.sim.step()  # Physics simulation step\n            except MujocoException as me:\n                print('MujocoException', me)\n                exception = True\n                break\n        if exception:\n            self.done = True\n            reward = self.reward_exception\n            info['cost_exception'] = 1.0\n        else:\n            self.sim.forward()  # Needed to get sensor readings correct!\n\n            # Reward processing\n            reward = self.reward()\n\n            # Constraint violations\n            info.update(self.cost())\n\n            # Button timer (used to delay button resampling)\n            self.buttons_timer_tick()\n\n            # Goal processing\n            if self.goal_met():\n                info['goal_met'] = True\n                reward += self.reward_goal\n                if self.continue_goal:\n                    # Update the internal layout so we can correctly resample (given objects have moved)\n                    self.update_layout()\n                    # Reset the button timer (only used for task='button' environments)\n                    self.buttons_timer = self.buttons_resampling_delay\n                    # Try to build a new goal, end if we fail\n                    if self.terminate_resample_failure:\n                        try:\n                            self.build_goal()\n                        except ResamplingError as e:\n                            # Normal end of episode\n                            self.done = True\n                    else:\n                        # Try to make a goal, which could raise a ResamplingError exception\n                        self.build_goal()\n                else:\n                    self.done = True\n\n        # Timeout\n        self.steps += 1\n        if self.steps >= self.num_steps:\n            self.done = True  # Maximum number of steps in an episode reached\n\n        return self.obs(), reward, False if self.never_done else self.done, info\n\n    def reward(self, keep_last=False):\n        ''' Calculate the dense component of reward.  Call exactly once per step '''\n        reward = 0.0\n        # Distance from robot to goal\n        if self.task in ['goal', 'button']:\n            dist_goal = self.dist_goal()\n            reward += (self.last_dist_goal - dist_goal) * self.reward_distance\n            if keep_last:\n                self.last_dist_goal = dist_goal\n        # Distance from robot to box\n        if self.task == 'push':\n            dist_box = self.dist_box()\n            gate_dist_box_reward = (\n                    self.last_dist_box > self.box_null_dist * self.box_size)\n            reward += (self.last_dist_box - dist_box) * \\\n                      self.reward_box_dist * gate_dist_box_reward\n            if keep_last:\n                self.last_dist_box = dist_box\n        # Distance from box to goal\n        if self.task == 'push':\n            dist_box_goal = self.dist_box_goal()\n            reward += (self.last_box_goal - dist_box_goal) * \\\n                      self.reward_box_goal\n            if keep_last:\n                self.last_box_goal = dist_box_goal\n        # Used for forward locomotion tests\n        if self.task == 'x':\n            robot_com = self.world.robot_com()\n            reward += (robot_com[0] - self.last_robot_com[0]) * self.reward_x\n            if not keep_last:\n                self.last_robot_com = robot_com\n        # Used for jump up tests\n        if self.task == 'z':\n            robot_com = self.world.robot_com()\n            reward += (robot_com[2] - self.last_robot_com[2]) * self.reward_z\n            if keep_last:\n                self.last_robot_com = robot_com\n        # Circle environment reward\n        if self.task == 'circle':\n            robot_com = self.world.robot_com()\n            robot_vel = self.world.robot_vel()\n            x, y, _ = robot_com\n            u, v, _ = robot_vel\n            radius = np.sqrt(x ** 2 + y ** 2)\n            reward += (((-u * y + v * x) / radius) / (1 + np.abs(radius - self.circle_radius))\n                       ) * self.reward_circle\n        # Intrinsic reward for uprightness\n        if self.reward_orientation:\n            zalign = quat2zalign(self.data.get_body_xquat(\n                self.reward_orientation_body))\n            reward += self.reward_orientation_scale * zalign\n        # Clip reward\n        if self.reward_clip:\n            in_range = reward < self.reward_clip and reward > -self.reward_clip\n            if not (in_range):\n                reward = np.clip(reward, -self.reward_clip, self.reward_clip)\n                print(f'Warning: reward{reward} was outside of range!')\n        return reward\n\n    def render_lidar(self, poses, color, offset, group):\n        ''' Render the lidar observation '''\n        robot_pos = self.world.robot_pos()\n        robot_mat = self.world.robot_mat()\n        lidar = self.obs_lidar(poses, group)\n        for i, sensor in enumerate(lidar):\n            if self.lidar_type == 'pseudo':\n                i += 0.5  # Offset to center of bin\n            theta = 2 * np.pi * i / self.lidar_num_bins\n            rad = self.render_lidar_radius\n            binpos = np.array(\n                [np.cos(theta) * rad, np.sin(theta) * rad, offset])\n            pos = robot_pos + np.matmul(binpos, robot_mat.transpose())\n            alpha = min(1, sensor + .1)\n            self.viewer.add_marker(pos=pos,\n                                   size=self.render_lidar_size * np.ones(3),\n                                   type=const.GEOM_SPHERE,\n                                   rgba=np.array(color) * alpha,\n                                   label='')\n\n    def render_compass(self, pose, color, offset):\n        ''' Render a compass observation '''\n        robot_pos = self.world.robot_pos()\n        robot_mat = self.world.robot_mat()\n        # Truncate the compass to only visualize XY component\n        compass = np.concatenate([self.obs_compass(pose)[:2] * 0.15, [offset]])\n        pos = robot_pos + np.matmul(compass, robot_mat.transpose())\n        self.viewer.add_marker(pos=pos,\n                               size=.05 * np.ones(3),\n                               type=const.GEOM_SPHERE,\n                               rgba=np.array(color) * 0.5,\n                               label='')\n\n    def render_area(self, pos, size, color, label='', alpha=0.1):\n        ''' Render a radial area in the environment '''\n        z_size = min(size, 0.3)\n        pos = np.asarray(pos)\n        if pos.shape == (2,):\n            pos = np.r_[pos, 0]  # Z coordinate 0\n        self.viewer.add_marker(pos=pos,\n                               size=[size, size, z_size],\n                               type=const.GEOM_CYLINDER,\n                               rgba=np.array(color) * alpha,\n                               label=label if self.render_labels else '')\n\n    def render_sphere(self, pos, size, color, label='', alpha=0.1):\n        ''' Render a radial area in the environment '''\n        pos = np.asarray(pos)\n        if pos.shape == (2,):\n            pos = np.r_[pos, 0]  # Z coordinate 0\n        self.viewer.add_marker(pos=pos,\n                               size=size * np.ones(3),\n                               type=const.GEOM_SPHERE,\n                               rgba=np.array(color) * alpha,\n                               label=label if self.render_labels else '')\n\n    def render_swap_callback(self):\n        ''' Callback between mujoco render and swapping GL buffers '''\n        if self.observe_vision and self.vision_render:\n            self.viewer.draw_pixels(self.save_obs_vision, 0, 0)\n\n    def add_render_callback(self, callback):\n        self.render_callback_list.append(callback)\n\n    def render(self,\n               mode='human',\n               camera_id=None,\n               width=DEFAULT_WIDTH,\n               height=DEFAULT_HEIGHT,\n               follow=False,\n               vertical=False,\n               scale=12.0):\n        ''' Render the environment to the screen '''\n\n        if self.viewer is None or mode != self._old_render_mode:\n            self.pos_queue = []\n            # Set camera if specified\n            if mode == 'human':\n                self.viewer = MjViewer(self.sim)\n                self.viewer.cam.fixedcamid = -1\n                self.viewer.cam.type = const.CAMERA_FREE\n            else:\n                self.viewer = MjRenderContextOffscreen(self.sim)\n                self.viewer._hide_overlay = True\n                self.viewer.cam.type = const.CAMERA_FREE\n\n            self.viewer.cam.lookat[0] = 0\n            self.viewer.cam.lookat[1] = 0\n\n            self.viewer.render_swap_callback = self.render_swap_callback\n            # self.viewer.cam.trackbodyid = 4  # id of the body to track\n\n            # Turn all the geom groups on\n            self.viewer.vopt.geomgroup[:] = 1\n            self._old_render_mode = mode\n\n        if follow:\n            self.pos_queue.append(self.robot_pos)\n            self.pos_queue = self.pos_queue[-20:]\n            mean_pos = np.mean(np.array(self.pos_queue), axis=0)\n            self.viewer.cam.lookat[0] = mean_pos[0]\n            self.viewer.cam.lookat[1] = mean_pos[1]\n\n        if vertical:\n            self.viewer.cam.elevation = -90\n            self.viewer.cam.azimuth = 90  # camera rotation around the camera's vertical axis\n\n        self.viewer.cam.distance = scale\n\n        self.viewer.update_sim(self.sim)\n\n        if camera_id is not None:\n            # Update camera if desired\n            self.viewer.cam.fixedcamid = camera_id\n\n        # Lidar markers\n        if self.render_lidar_markers:\n            # Height offset for successive lidar indicators\n            offset = self.render_lidar_offset_init\n            if 'box_lidar' in self.obs_space_dict or 'box_compass' in self.obs_space_dict:\n                if 'box_lidar' in self.obs_space_dict:\n                    self.render_lidar(\n                        [self.box_pos], COLOR_BOX, offset, GROUP_BOX)\n                if 'box_compass' in self.obs_space_dict:\n                    self.render_compass(self.box_pos, COLOR_BOX, offset)\n                offset += self.render_lidar_offset_delta\n            if 'goal_lidar' in self.obs_space_dict or 'goal_compass' in self.obs_space_dict:\n                if 'goal_lidar' in self.obs_space_dict:\n                    self.render_lidar(\n                        [self.goal_pos], COLOR_GOAL, offset, GROUP_GOAL)\n                if 'goal_compass' in self.obs_space_dict:\n                    self.render_compass(self.goal_pos, COLOR_GOAL, offset)\n                offset += self.render_lidar_offset_delta\n            if 'buttons_lidar' in self.obs_space_dict:\n                self.render_lidar(self.buttons_pos,\n                                  COLOR_BUTTON, offset, GROUP_BUTTON)\n                offset += self.render_lidar_offset_delta\n            if 'circle_lidar' in self.obs_space_dict:\n                self.render_lidar([ORIGIN_COORDINATES],\n                                  COLOR_CIRCLE, offset, GROUP_CIRCLE)\n                offset += self.render_lidar_offset_delta\n            if 'walls_lidar' in self.obs_space_dict:\n                self.render_lidar(self.walls_pos, COLOR_WALL,\n                                  offset, GROUP_WALL)\n                offset += self.render_lidar_offset_delta\n            if 'hazards_lidar' in self.obs_space_dict:\n                self.render_lidar(self.hazards_pos,\n                                  COLOR_HAZARD, offset, GROUP_HAZARD)\n                offset += self.render_lidar_offset_delta\n            if 'pillars_lidar' in self.obs_space_dict:\n                self.render_lidar(self.pillars_pos,\n                                  COLOR_PILLAR, offset, GROUP_PILLAR)\n                offset += self.render_lidar_offset_delta\n            if 'gremlins_lidar' in self.obs_space_dict:\n                self.render_lidar(self.gremlins_obj_pos,\n                                  COLOR_GREMLIN, offset, GROUP_GREMLIN)\n                offset += self.render_lidar_offset_delta\n            if 'vases_lidar' in self.obs_space_dict:\n                self.render_lidar(self.vases_pos, COLOR_VASE,\n                                  offset, GROUP_VASE)\n                offset += self.render_lidar_offset_delta\n\n        # Add goal marker\n        if self.task == 'button':\n            self.render_area(self.goal_pos, self.buttons_size *\n                             2, COLOR_BUTTON, 'goal', alpha=0.1)\n\n        # Add indicator for nonzero cost\n        if self._cost.get('cost', 0) > 0:\n            self.render_sphere(self.world.robot_pos(),\n                               0.25, COLOR_RED, alpha=.5)\n\n        # Draw vision pixels\n        if self.observe_vision and self.vision_render:\n            vision = self.obs_vision()\n            vision = np.array(vision * 255, dtype='uint8')\n            vision = Image.fromarray(vision).resize(self.vision_render_size)\n            vision = np.array(vision, dtype='uint8')\n            self.save_obs_vision = vision\n\n        for callback in self.render_callback_list:\n            callback()\n\n        if mode == 'human':\n            self.viewer.render()\n        elif mode == 'rgb_array':\n            self.viewer.render(width, height)\n            data = self.viewer.read_pixels(width, height, depth=False)\n            self.viewer._markers[:] = []\n            self.viewer._overlay.clear()\n            return data[::-1, :, :]\n\n    def close(self):\n        if self.viewer is not None:\n            try:\n                glfw.destroy_window(self.viewer.window)\n            except AttributeError:\n                pass", ""]}
{"filename": "src/stl_mob/envs/pybullet_robots/base.py", "chunked_list": ["from abc import ABC, abstractmethod\nfrom collections import namedtuple\nfrom typing import Union, List\n\nimport gym\nimport numpy as np\nimport pybullet as p\n\nfrom stl_mob.envs.pybullet_robots.utils import no_render\n", "from stl_mob.envs.pybullet_robots.utils import no_render\n\nObjID = namedtuple(\"ObjID\", [\"visual_id\", \"collision_id\"])\n\n\nclass WorldBase(ABC):\n    def __init__(self, enable_gui: bool):\n        if enable_gui:\n            self.client_id = p.connect(p.GUI)\n        else:\n            self.client_id = p.connect(p.DIRECT)\n\n        self._init_param()\n\n        with no_render():\n            self._build_world()\n\n        p.setRealTimeSimulation(0, physicsClientId=self.client_id)\n\n    @abstractmethod\n    def _init_param(self):\n        raise NotImplementedError()\n\n    @abstractmethod\n    def _build_world(self):\n        raise NotImplementedError()\n\n    @abstractmethod\n    def reset(self):\n        raise NotImplementedError()", "\n\nclass RobotBase(ABC):\n    def __init__(self, world: WorldBase):\n        self.world = world\n\n        self.client_id = self.world.client_id\n\n        with no_render():\n            self.robot_id = self._load_robot()\n\n        self._init_param()\n\n    @abstractmethod\n    def _load_robot(self) -> int:\n        raise NotImplementedError()\n\n    @abstractmethod\n    def _init_param(self):\n        raise NotImplementedError()\n\n    @abstractmethod\n    def reset(self):\n        raise NotImplementedError()\n\n    @abstractmethod\n    def ctrl(self, cmd: np.ndarray):\n        raise NotImplementedError()\n\n    @abstractmethod\n    def get_obs(self) -> np.ndarray:\n        pass", "\n\nclass BulletEnv(gym.Env):\n\n    def __init__(self, robot: RobotBase):\n        self.world = robot.world\n        self.robot = robot\n\n        self._expose()\n        self._camera_following = False\n\n    def _expose(self):\n        self.client_id = self.world.client_id\n\n    def switch_render_mode(self):\n        self._camera_following = not self._camera_following\n\n    def reset(self):\n        self.world.reset()\n        self.robot.reset()\n\n    def get_obs(self):\n        return self.robot.get_obs()\n\n    def step(self, cmd: Union[np.ndarray, List[np.ndarray]]):\n        self.robot.ctrl(cmd)\n        p.stepSimulation(self.client_id)\n        if self._camera_following:\n            base_pos, base_orn = p.getBasePositionAndOrientation(self.robot.robot_id,\n                                                                 physicsClientId=self.client_id)\n            p.resetDebugVisualizerCamera(cameraDistance=1.0,\n                                         cameraYaw=75,\n                                         cameraPitch=-20,\n                                         cameraTargetPosition=base_pos)\n        return self.get_obs(), 0, False, {}\n\n    def render(self, mode=\"human\"):\n        pass", ""]}
{"filename": "src/stl_mob/envs/pybullet_robots/env_editor.py", "chunked_list": ["from typing import Dict, Tuple, Union, List\n\nimport numpy as np\nimport pybullet as p\nimport pybullet_data\n\nfrom stl_mob.envs.pybullet_robots.base import ObjID\n\n\nclass EnvEditor:\n    def __init__(self, client_id: int):\n        self.client_id = client_id\n\n        # cache objects to avoid recreation\n        self.objects: Dict[str, Dict[Tuple, ObjID]] = {\n            \"ball\": {},\n            \"cube\": {},\n            \"duck\": {}\n        }\n\n        p.setAdditionalSearchPath(pybullet_data.getDataPath(),\n                                  physicsClientId=self.client_id)\n\n    def get_shape(self, name: str, props: tuple) -> ObjID:\n        obj_id = self.objects[name].get(props, None)\n        if obj_id is not None:\n            return obj_id\n\n        if name == \"ball\":\n            size, color = props\n            radius = 0.1 * size\n            vid = p.createVisualShape(shapeType=p.GEOM_SPHERE,\n                                      rgbaColor=color,\n                                      radius=radius,\n                                      physicsClientId=self.client_id)\n            cid = None\n            obj_id = ObjID(vid, cid)\n\n        elif name == \"cube\":\n            size, color, specular = props\n            radius = 0.1 * size\n            vid = p.createVisualShape(shapeType=p.GEOM_BOX,\n                                      rgbaColor=color,\n                                      halfExtents=[radius] * 3,\n                                      physicsClientId=self.client_id)\n            cid = p.createCollisionShape(shapeType=p.GEOM_BOX,\n                                         halfExtents=[radius] * 3,\n                                         physicsClientId=self.client_id)\n            obj_id = ObjID(vid, cid)\n\n        elif name == \"duck\":\n            size, color, specular = props\n            shift = np.array([0, -0.02, 0]) * size\n            mesh_scale = np.array([0.1, 0.1, 0.1]) * size\n            vid = p.createVisualShape(shapeType=p.GEOM_MESH,\n                                      fileName=\"duck.obj\",\n                                      rgbaColor=color,\n                                      specularColor=specular,\n                                      visualFramePosition=shift,\n                                      meshScale=mesh_scale,\n                                      physicsClientId=self.client_id)\n            cid = p.createCollisionShape(shapeType=p.GEOM_MESH,\n                                         fileName=\"duck_vhacd.obj\",\n                                         collisionFramePosition=shift,\n                                         meshScale=mesh_scale,\n                                         physicsClientId=self.client_id)\n            obj_id = ObjID(vid, cid)\n        else:\n            raise NotImplementedError()\n\n        self.objects[name][props] = obj_id\n        return obj_id\n\n    def add_ball(self,\n                 pos: Union[List, np.ndarray],\n                 size: float = 2.0,\n                 color: Tuple = (0, 1, 0, 0.5)\n                 ) -> int:\n        props = (size, color)\n        obj_id = self.get_shape(\"ball\", props)\n        body_id = p.createMultiBody(baseMass=0.0,\n                                    baseInertialFramePosition=[0, 0, 0],\n                                    baseVisualShapeIndex=obj_id.visual_id,\n                                    basePosition=pos,\n                                    useMaximalCoordinates=True,\n                                    physicsClientId=self.client_id)\n        return body_id\n\n    def remove_body(self, body_id):\n        p.removeBody(body_id, physicsClientId=self.client_id)\n\n    def add_cube(self,\n                 pos: Union[List, np.ndarray],\n                 ori: Union[List, np.ndarray] = (np.pi / 2, 0, np.pi),\n                 size: float = 1.0,\n                 color: Tuple = (0.7, 0.7, 0.7, 1.0),\n                 specular: Tuple = (0.7, 0.7, 0.7, 0.4)\n                 ) -> int:\n        props = (size, color, specular)\n        obj_id = self.get_shape(\"cube\", props)\n        body_id = p.createMultiBody(baseMass=1.0 * size,\n                                    baseVisualShapeIndex=obj_id.visual_id,\n                                    baseCollisionShapeIndex=obj_id.collision_id,\n                                    basePosition=pos,\n                                    baseOrientation=p.getQuaternionFromEuler(\n                                        ori),\n                                    useMaximalCoordinates=True,\n                                    physicsClientId=self.client_id)\n        return body_id\n\n    def add_duck(self,\n                 pos: Union[List, np.ndarray],\n                 ori: Union[List, np.ndarray] = (np.pi / 2, 0, np.pi),\n                 size: float = 1.0,\n                 color: Tuple = (1, 1, 1, 0.75),\n                 specular: Tuple = (0, 1, 1, 0.4)\n                 ) -> int:\n        props = (size, color, specular)\n        obj_id = self.get_shape(\"duck\", props)\n        body_id = p.createMultiBody(baseMass=1.0 * size,\n                                    baseInertialFramePosition=[0, 0, 0],\n                                    baseVisualShapeIndex=obj_id.visual_id,\n                                    baseCollisionShapeIndex=obj_id.collision_id,\n                                    basePosition=pos,\n                                    baseOrientation=p.getQuaternionFromEuler(\n                                        ori),\n                                    useMaximalCoordinates=True,\n                                    physicsClientId=self.client_id)\n        return body_id\n\n    def change_color(self, obj_id: int, rgb_color: Tuple, link_id: int = -1):\n        p.changeVisualShape(objectUniqueId=obj_id,\n                            linkIndex=link_id,\n                            rgbaColor=rgb_color,\n                            physicsClientId=self.client_id)\n\n    def plot_trajectory(self, traj):\n        for i, waypoint in enumerate(traj):\n            self.add_ball(waypoint, size=0.5, color=(0, 0.5, 1.0, 0.5))\n\n    def attach(self,\n               par_body_id: int,\n               par_link_id: int,\n               chi_body_id: int,\n               chi_link_id: int,\n               joint_type: int = p.JOINT_FIXED,\n               joint_axis: Union[Tuple, List] = (0, 0, 0),\n               par_frame_pos: Union[Tuple, List] = (0, 0, 0),\n               chi_frame_pos: Union[Tuple, List] = (0, 0, 0),\n               par_frame_ori: Union[Tuple, List] = None,\n               chi_frame_ori: Union[Tuple, List] = None) -> int:\n        return p.createConstraint(parentBodyUniqueId=par_body_id,\n                                  parentLinkIndex=par_link_id,\n                                  childBodyUniqueId=chi_body_id,\n                                  childLinkIndex=chi_link_id,\n                                  jointType=joint_type,\n                                  jointAxis=joint_axis,\n                                  parentFramePosition=par_frame_pos,\n                                  childFramePosition=chi_frame_pos,\n                                  parentFrameOrientation=par_frame_ori,\n                                  childFrameOrientation=chi_frame_ori,\n                                  physicsClientId=self.client_id)\n\n    def detach(self, attach_id: int):\n        p.removeConstraint(attach_id, self.client_id)", "\nclass EnvEditor:\n    def __init__(self, client_id: int):\n        self.client_id = client_id\n\n        # cache objects to avoid recreation\n        self.objects: Dict[str, Dict[Tuple, ObjID]] = {\n            \"ball\": {},\n            \"cube\": {},\n            \"duck\": {}\n        }\n\n        p.setAdditionalSearchPath(pybullet_data.getDataPath(),\n                                  physicsClientId=self.client_id)\n\n    def get_shape(self, name: str, props: tuple) -> ObjID:\n        obj_id = self.objects[name].get(props, None)\n        if obj_id is not None:\n            return obj_id\n\n        if name == \"ball\":\n            size, color = props\n            radius = 0.1 * size\n            vid = p.createVisualShape(shapeType=p.GEOM_SPHERE,\n                                      rgbaColor=color,\n                                      radius=radius,\n                                      physicsClientId=self.client_id)\n            cid = None\n            obj_id = ObjID(vid, cid)\n\n        elif name == \"cube\":\n            size, color, specular = props\n            radius = 0.1 * size\n            vid = p.createVisualShape(shapeType=p.GEOM_BOX,\n                                      rgbaColor=color,\n                                      halfExtents=[radius] * 3,\n                                      physicsClientId=self.client_id)\n            cid = p.createCollisionShape(shapeType=p.GEOM_BOX,\n                                         halfExtents=[radius] * 3,\n                                         physicsClientId=self.client_id)\n            obj_id = ObjID(vid, cid)\n\n        elif name == \"duck\":\n            size, color, specular = props\n            shift = np.array([0, -0.02, 0]) * size\n            mesh_scale = np.array([0.1, 0.1, 0.1]) * size\n            vid = p.createVisualShape(shapeType=p.GEOM_MESH,\n                                      fileName=\"duck.obj\",\n                                      rgbaColor=color,\n                                      specularColor=specular,\n                                      visualFramePosition=shift,\n                                      meshScale=mesh_scale,\n                                      physicsClientId=self.client_id)\n            cid = p.createCollisionShape(shapeType=p.GEOM_MESH,\n                                         fileName=\"duck_vhacd.obj\",\n                                         collisionFramePosition=shift,\n                                         meshScale=mesh_scale,\n                                         physicsClientId=self.client_id)\n            obj_id = ObjID(vid, cid)\n        else:\n            raise NotImplementedError()\n\n        self.objects[name][props] = obj_id\n        return obj_id\n\n    def add_ball(self,\n                 pos: Union[List, np.ndarray],\n                 size: float = 2.0,\n                 color: Tuple = (0, 1, 0, 0.5)\n                 ) -> int:\n        props = (size, color)\n        obj_id = self.get_shape(\"ball\", props)\n        body_id = p.createMultiBody(baseMass=0.0,\n                                    baseInertialFramePosition=[0, 0, 0],\n                                    baseVisualShapeIndex=obj_id.visual_id,\n                                    basePosition=pos,\n                                    useMaximalCoordinates=True,\n                                    physicsClientId=self.client_id)\n        return body_id\n\n    def remove_body(self, body_id):\n        p.removeBody(body_id, physicsClientId=self.client_id)\n\n    def add_cube(self,\n                 pos: Union[List, np.ndarray],\n                 ori: Union[List, np.ndarray] = (np.pi / 2, 0, np.pi),\n                 size: float = 1.0,\n                 color: Tuple = (0.7, 0.7, 0.7, 1.0),\n                 specular: Tuple = (0.7, 0.7, 0.7, 0.4)\n                 ) -> int:\n        props = (size, color, specular)\n        obj_id = self.get_shape(\"cube\", props)\n        body_id = p.createMultiBody(baseMass=1.0 * size,\n                                    baseVisualShapeIndex=obj_id.visual_id,\n                                    baseCollisionShapeIndex=obj_id.collision_id,\n                                    basePosition=pos,\n                                    baseOrientation=p.getQuaternionFromEuler(\n                                        ori),\n                                    useMaximalCoordinates=True,\n                                    physicsClientId=self.client_id)\n        return body_id\n\n    def add_duck(self,\n                 pos: Union[List, np.ndarray],\n                 ori: Union[List, np.ndarray] = (np.pi / 2, 0, np.pi),\n                 size: float = 1.0,\n                 color: Tuple = (1, 1, 1, 0.75),\n                 specular: Tuple = (0, 1, 1, 0.4)\n                 ) -> int:\n        props = (size, color, specular)\n        obj_id = self.get_shape(\"duck\", props)\n        body_id = p.createMultiBody(baseMass=1.0 * size,\n                                    baseInertialFramePosition=[0, 0, 0],\n                                    baseVisualShapeIndex=obj_id.visual_id,\n                                    baseCollisionShapeIndex=obj_id.collision_id,\n                                    basePosition=pos,\n                                    baseOrientation=p.getQuaternionFromEuler(\n                                        ori),\n                                    useMaximalCoordinates=True,\n                                    physicsClientId=self.client_id)\n        return body_id\n\n    def change_color(self, obj_id: int, rgb_color: Tuple, link_id: int = -1):\n        p.changeVisualShape(objectUniqueId=obj_id,\n                            linkIndex=link_id,\n                            rgbaColor=rgb_color,\n                            physicsClientId=self.client_id)\n\n    def plot_trajectory(self, traj):\n        for i, waypoint in enumerate(traj):\n            self.add_ball(waypoint, size=0.5, color=(0, 0.5, 1.0, 0.5))\n\n    def attach(self,\n               par_body_id: int,\n               par_link_id: int,\n               chi_body_id: int,\n               chi_link_id: int,\n               joint_type: int = p.JOINT_FIXED,\n               joint_axis: Union[Tuple, List] = (0, 0, 0),\n               par_frame_pos: Union[Tuple, List] = (0, 0, 0),\n               chi_frame_pos: Union[Tuple, List] = (0, 0, 0),\n               par_frame_ori: Union[Tuple, List] = None,\n               chi_frame_ori: Union[Tuple, List] = None) -> int:\n        return p.createConstraint(parentBodyUniqueId=par_body_id,\n                                  parentLinkIndex=par_link_id,\n                                  childBodyUniqueId=chi_body_id,\n                                  childLinkIndex=chi_link_id,\n                                  jointType=joint_type,\n                                  jointAxis=joint_axis,\n                                  parentFramePosition=par_frame_pos,\n                                  childFramePosition=chi_frame_pos,\n                                  parentFrameOrientation=par_frame_ori,\n                                  childFrameOrientation=chi_frame_ori,\n                                  physicsClientId=self.client_id)\n\n    def detach(self, attach_id: int):\n        p.removeConstraint(attach_id, self.client_id)", ""]}
{"filename": "src/stl_mob/envs/pybullet_robots/__init__.py", "chunked_list": ["\n"]}
{"filename": "src/stl_mob/envs/pybullet_robots/utils.py", "chunked_list": ["import os\nfrom collections import namedtuple\n\nimport numpy as np\nimport pybullet as p\n\nJointInfo = namedtuple('JointInfo',\n                       ['joint_index', 'joint_name', 'joint_type', 'q_index', 'u_index', 'flags',\n                        'joint_damping', 'joint_friction', 'joint_lower_limit', 'joint_upper_limit',\n                        'joint_max_force', 'joint_max_velocity', 'link_name', 'joint_axis',", "                        'joint_damping', 'joint_friction', 'joint_lower_limit', 'joint_upper_limit',\n                        'joint_max_force', 'joint_max_velocity', 'link_name', 'joint_axis',\n                        'parent_frame_pos', 'parent_frame_orn', 'parent_index'])\n\n\ndef get_joint_info(body, joint, client_id) -> JointInfo:\n    return JointInfo(*p.getJointInfo(body, joint, physicsClientId=client_id))\n\n\ndef is_fixed_joint(robot_id, joint, client_id) -> bool:\n    return get_joint_info(robot_id, joint, client_id).joint_type == p.JOINT_FIXED", "\ndef is_fixed_joint(robot_id, joint, client_id) -> bool:\n    return get_joint_info(robot_id, joint, client_id).joint_type == p.JOINT_FIXED\n\n\ndef is_movable_joint(robot_id, joint_id, client_id) -> bool:\n    return not is_fixed_joint(robot_id, joint_id, client_id)\n\n\ndef get_joint_ranges(robot_id, controllable_joints, client_id):\n    lower_limits, upper_limits, joint_ranges = [], [], []\n\n    for i in controllable_joints:\n        joint_info = p.getJointInfo(robot_id, i, physicsClientId=client_id)\n        lb, ub = joint_info[8:10]\n        r = lb - ub\n\n        lower_limits.append(lb)\n        upper_limits.append(ub)\n        joint_ranges.append(r)\n\n    return lower_limits, upper_limits, joint_ranges", "\ndef get_joint_ranges(robot_id, controllable_joints, client_id):\n    lower_limits, upper_limits, joint_ranges = [], [], []\n\n    for i in controllable_joints:\n        joint_info = p.getJointInfo(robot_id, i, physicsClientId=client_id)\n        lb, ub = joint_info[8:10]\n        r = lb - ub\n\n        lower_limits.append(lb)\n        upper_limits.append(ub)\n        joint_ranges.append(r)\n\n    return lower_limits, upper_limits, joint_ranges", "\n\ndef reset_joint_pos(pos, robot_id: int, client_id: int):\n    indx = 0\n    for i in range(p.getNumJoints(robot_id, client_id)):\n        if not is_fixed_joint(robot_id, i, client_id):\n            p.resetJointState(robot_id,\n                              jointIndex=i,\n                              targetValue=pos[indx],\n                              physicsClientId=client_id)\n            indx += 1", "\n\ndef half_angle(degree):\n    n = np.round(degree / (2 * np.pi))\n    degree = degree - n * 2 * np.pi\n\n    return degree\n\n\nclass video_recorder:\n    def __init__(self, client_id: int, store_path: str):\n        self.client_id = client_id\n        self.store_path = store_path\n        self.logging_unique_id = None\n\n    def __enter__(self):\n        if self.store_path is not None:\n            os.makedirs(f\"{os.path.dirname(self.store_path)}\", exist_ok=True)\n            self.logging_unique_id = p.startStateLogging(loggingType=p.STATE_LOGGING_VIDEO_MP4,\n                                                         fileName=self.store_path,\n                                                         physicsClientId=self.client_id)\n            return self.logging_unique_id\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.store_path is not None:\n            p.stopStateLogging(self.logging_unique_id)", "\nclass video_recorder:\n    def __init__(self, client_id: int, store_path: str):\n        self.client_id = client_id\n        self.store_path = store_path\n        self.logging_unique_id = None\n\n    def __enter__(self):\n        if self.store_path is not None:\n            os.makedirs(f\"{os.path.dirname(self.store_path)}\", exist_ok=True)\n            self.logging_unique_id = p.startStateLogging(loggingType=p.STATE_LOGGING_VIDEO_MP4,\n                                                         fileName=self.store_path,\n                                                         physicsClientId=self.client_id)\n            return self.logging_unique_id\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.store_path is not None:\n            p.stopStateLogging(self.logging_unique_id)", "\n\nclass no_render:\n    def __enter__(self):\n        p.configureDebugVisualizer(p.COV_ENABLE_RENDERING, 0)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        p.configureDebugVisualizer(p.COV_ENABLE_RENDERING, 1)\n", ""]}
{"filename": "src/stl_mob/envs/pybullet_robots/robots/__init__.py", "chunked_list": ["from os.path import dirname, abspath\n\nROBOT_ASSETS_PATH = f\"{dirname(abspath(__file__))}/assets\"\n"]}
{"filename": "src/stl_mob/envs/pybullet_robots/robots/drone.py", "chunked_list": ["from xml.etree import ElementTree\n\nimport numpy as np\nimport pybullet as p\nimport pybullet_data\n\nfrom stl_mob.envs.pybullet_robots.base import WorldBase, RobotBase\nfrom stl_mob.envs.pybullet_robots.robots import ROBOT_ASSETS_PATH\n\n\nclass World(WorldBase):\n    def _init_param(self):\n        self.g = 9.8\n        self.timestep = 1 / 50\n\n    def _build_world(self):\n        p.setAdditionalSearchPath(\n            pybullet_data.getDataPath(), physicsClientId=self.client_id)\n        p.loadURDF(\"plane.urdf\", physicsClientId=self.client_id)\n        p.setGravity(0, 0, -self.g, physicsClientId=self.client_id)\n        p.setTimeStep(self.timestep, physicsClientId=self.client_id)\n        p.configureDebugVisualizer(\n            p.COV_ENABLE_GUI, 0, physicsClientId=self.client_id)\n\n    def reset(self):\n        pass", "\n\nclass World(WorldBase):\n    def _init_param(self):\n        self.g = 9.8\n        self.timestep = 1 / 50\n\n    def _build_world(self):\n        p.setAdditionalSearchPath(\n            pybullet_data.getDataPath(), physicsClientId=self.client_id)\n        p.loadURDF(\"plane.urdf\", physicsClientId=self.client_id)\n        p.setGravity(0, 0, -self.g, physicsClientId=self.client_id)\n        p.setTimeStep(self.timestep, physicsClientId=self.client_id)\n        p.configureDebugVisualizer(\n            p.COV_ENABLE_GUI, 0, physicsClientId=self.client_id)\n\n    def reset(self):\n        pass", "\n\nclass Drone(RobotBase):\n    def __init__(self,\n                 drone_name: str = \"hb\",\n                 enable_gui=True):\n        self.urdf_path = f\"{ROBOT_ASSETS_PATH}/drone\"\n        self.drone_name = drone_name\n        self.init_low = [-3, -3, 1]\n        self.init_high = [3, 3, 3]\n\n        world = World(enable_gui=enable_gui)\n        super(Drone, self).__init__(world)\n        self._init_param()\n\n    def reset(self):\n        init_pos = np.random.uniform(self.init_low, self.init_high)\n        p.resetBasePositionAndOrientation(self.robot_id,\n                                          init_pos,\n                                          p.getQuaternionFromEuler([0, 0, 0]),\n                                          self.client_id)\n\n    def _load_robot(self) -> int:\n        robot_id = p.loadURDF(self.urdf_path + f\"/{self.drone_name}.urdf\",\n                              basePosition=[2, 2, 2],\n                              baseOrientation=p.getQuaternionFromEuler(\n                                  [0, 0, 0]),\n                              flags=p.URDF_USE_SELF_COLLISION,\n                              physicsClientId=self.client_id)\n\n        return robot_id\n\n    def _init_param(self):\n        urdf_tree = ElementTree.parse(\n            f\"{self.urdf_path}/{self.drone_name}.urdf\").getroot()\n\n        self.m = float(urdf_tree[1][0][1].attrib['value'])\n        self.l = float(urdf_tree[0].attrib['arm'])\n        self.thrust2weight = float(urdf_tree[0].attrib['thrust2weight'])\n        self.kf = float(urdf_tree[0].attrib['kf'])\n        self.km = float(urdf_tree[0].attrib['km'])\n        self.max_speed_kmh = float(urdf_tree[0].attrib['max_speed_kmh'])\n        self.prop_radius = float(urdf_tree[0].attrib['prop_radius'])\n\n        ixx = float(urdf_tree[1][0][2].attrib['ixx'])\n        iyy = float(urdf_tree[1][0][2].attrib['iyy'])\n        izz = float(urdf_tree[1][0][2].attrib['izz'])\n        self.J = np.diag([ixx, iyy, izz])\n        self.J_inv = np.linalg.inv(self.J)\n\n        self.collision_h = float(urdf_tree[1][2][1][0].attrib['length'])\n        self.collision_r = float(urdf_tree[1][2][1][0].attrib['radius'])\n        collision_shape_offsets = [\n            float(s) for s in urdf_tree[1][2][0].attrib['xyz'].split(' ')]\n        self.collision_z_offset = collision_shape_offsets[2]\n\n        self.gnd_eff_coef = float(urdf_tree[0].attrib['gnd_eff_coeff'])\n\n        drag_coeff_xy = float(urdf_tree[0].attrib['drag_coeff_xy'])\n        drag_coeff_z = float(urdf_tree[0].attrib['drag_coeff_z'])\n        self.drag_coef = np.array([drag_coeff_xy, drag_coeff_xy, drag_coeff_z])\n\n        self.dw_coef_1 = float(urdf_tree[0].attrib['dw_coeff_1'])\n        self.dw_coef_2 = float(urdf_tree[0].attrib['dw_coeff_2'])\n        self.dw_coef_3 = float(urdf_tree[0].attrib['dw_coeff_3'])\n\n        gravity = self.world.g * self.m  # noqa\n        self.hover_rpm = np.sqrt(gravity / (4 * self.kf))\n        self.max_rpm = np.sqrt((self.thrust2weight * gravity) / (4 * self.kf))\n\n        self.max_thrust = (4 * self.kf * self.max_rpm ** 2)\n        if self.drone_name == \"cf2x\":\n            self.max_xy_torque = (2 * self.l * self.kf *\n                                  self.max_rpm ** 2) / np.sqrt(2)\n        elif self.drone_name in [\"cf2p\", \"hb\"]:\n            self.max_xy_torque = (self.l * self.kf * self.max_rpm ** 2)\n\n        self.max_z_torque = (2 * self.km * self.max_rpm ** 2)\n\n        # A and B are used for building the equation for computing control input\n        self.A = np.array([[1, 1, 1, 1], [0, 1, 0, -1],\n                           [-1, 0, 1, 0], [-1, 1, -1, 1]])\n        self.A_inv = np.linalg.inv(self.A)\n        self.B = np.array([1 / self.kf,\n                           1 / (self.kf * self.l),\n                           1 / (self.kf * self.l),\n                           1 / self.km])\n\n    def ctrl(self, cmd: np.ndarray):\n        \"\"\"\n        Apply control cmd and step simulation\n        :param cmd: rotation per minute of 4 motors\n        \"\"\"\n        forces = np.array(cmd ** 2) * self.kf\n        torques = np.array(cmd ** 2) * self.km\n        z_torque = (-torques[0] + torques[1] - torques[2] + torques[3])\n        for i in range(4):\n            p.applyExternalForce(self.robot_id,\n                                 i,\n                                 forceObj=[0, 0, forces[i]],\n                                 posObj=[0, 0, 0],\n                                 flags=p.LINK_FRAME,\n                                 physicsClientId=self.client_id)\n        p.applyExternalTorque(self.robot_id,\n                              -1,\n                              torqueObj=[0, 0, z_torque],\n                              flags=p.LINK_FRAME,\n                              physicsClientId=self.client_id)\n\n    def get_base_pos_and_ori(self) -> np.ndarray:\n        return p.getBasePositionAndOrientation(self.robot_id, self.client_id)\n\n    def get_obs(self) -> np.ndarray:\n        pos, ori = p.getBasePositionAndOrientation(\n            self.robot_id, self.client_id)\n        ori = p.getEulerFromQuaternion(ori)\n        vel, rot = p.getBaseVelocity(self.robot_id, self.client_id)\n\n        return np.concatenate([pos, ori, vel, rot])", ""]}
{"filename": "src/stl_mob/ctrl/__init__.py", "chunked_list": [""]}
{"filename": "src/stl_mob/ctrl/wrapper.py", "chunked_list": ["import numpy as np\nfrom stable_baselines3 import PPO\n\nfrom stl_mob.utils import DATA_DIR\n\n\nclass Controller:\n    def __init__(self, robot_name: str):\n        if robot_name == 'point':\n            self.policy = PPO.load(f\"{DATA_DIR}/controllers/point_ppo.zip\")\n        elif robot_name == 'car':\n            self.policy = PPO.load(f\"{DATA_DIR}/controllers/car_ppo.zip\")\n        elif robot_name == 'doggo':\n            self.policy = PPO.load(f\"{DATA_DIR}/controllers/doggo_ppo.zip\")\n        elif robot_name == 'drone':\n            self.policy = PPO.load(f\"{DATA_DIR}/controllers/drone_ppo.zip\")\n        else:\n            raise ValueError(f\"Unknown robot name: {robot_name}\")\n\n    def __call__(self, gc_obs: np.ndarray) -> np.ndarray:\n        action = self.policy.predict(gc_obs)[0]\n        return action", "\n\ndef get_controller(robot_name: str) -> Controller:\n    return Controller(robot_name)\n"]}
{"filename": "src/stl_mob/ctrl/drone_pid/base.py", "chunked_list": ["from abc import ABC, abstractmethod\n\n\nclass ControllerBase(ABC):\n    @abstractmethod\n    def reset(self):\n        raise NotImplementedError()\n\n    @abstractmethod\n    def control(self, goal):\n        raise NotImplementedError()", ""]}
{"filename": "src/stl_mob/ctrl/drone_pid/__init__.py", "chunked_list": ["from .drone.pid import DronePID\n"]}
{"filename": "src/stl_mob/ctrl/drone_pid/drone/pid.py", "chunked_list": ["import numpy as np\nimport pybullet as p\nfrom scipy.optimize import nnls\n\nfrom stl_mob.envs.pybullet_robots.robots.drone import Drone\nfrom ..base import ControllerBase\n\n\nclass DronePID(ControllerBase):\n    \"\"\"\n    Adapted from\n    https://github.com/utiasDSL/gym-pybullet-drones/blob/master/gym_pybullet_drones/control/SimplePIDControl.py\n    \"\"\"\n\n    def __init__(self, drone: Drone):\n        self.drone = drone\n\n        # Default PID coefficients\n        self._force_p_coef = np.array([.1, .1, .2])\n        self._force_i_coef = np.array([.0001, .0001, .0001])\n        self._force_d_coef = np.array([.3, .3, .4])\n        self._torque_p_coef = np.array([.3, .3, .05])\n        self._torque_i_coef = np.array([.0001, .0001, .0001])\n        self._torque_d_coef = np.array([.3, .3, .5])\n\n        self.last_pos_e = np.zeros(3)\n        self.integral_pos_e = np.zeros(3)\n        self.last_rpy_e = np.zeros(3)\n        self.integral_rpy_e = np.zeros(3)\n\n        # constrain the max roll and pitch angles for stability\n        self.max_roll_pitch = np.pi / 6\n\n    def reset(self):\n        self.last_pos_e = np.zeros(3)\n        self.integral_pos_e = np.zeros(3)\n        self.last_rpy_e = np.zeros(3)\n        self.integral_rpy_e = np.zeros(3)\n\n    def control(self, goal: np.ndarray) -> np.ndarray:\n        cur_pos, cur_ori = self.drone.get_base_pos_and_ori()\n\n        target_force = self._compute_target_force(goal, cur_pos)\n        target_thrust = self._compute_target_thrust(target_force, cur_ori)\n\n        target_rpy = self._compute_target_rotation(target_force)\n        target_torque = self._compute_target_torque(target_rpy, cur_ori)\n\n        # control commands in rpm\n        rpm = self._compute_rpm(target_thrust, target_torque)\n\n        return rpm\n\n    def _compute_target_force(self, goal: np.ndarray, cur_pos: np.ndarray) -> np.ndarray:\n        pos_e = goal - np.array(cur_pos).reshape(3)\n        d_pos_e = (pos_e - self.last_pos_e) / self.drone.world.timestep\n        self.last_pos_e = pos_e\n        self.integral_pos_e = self.integral_pos_e + pos_e * self.drone.world.timestep\n\n        target_force = (np.array([0, 0, self.drone.m * self.drone.world.g])\n                        + np.multiply(self._force_p_coef, pos_e)\n                        + np.multiply(self._force_i_coef, self.integral_pos_e)\n                        + np.multiply(self._force_d_coef, d_pos_e))\n\n        return target_force\n\n    def _compute_target_thrust(self, target_force: np.ndarray, cur_ori: np.ndarray) -> float:\n        cur_rotation = np.array(\n            p.getMatrixFromQuaternion(cur_ori)).reshape(3, 3)\n        target_thrust = np.dot(cur_rotation, target_force)\n        target_thrust = target_thrust.clip(0, self.drone.max_thrust)\n\n        return target_thrust[2]\n\n    def _compute_target_rotation(self, target_force: np.ndarray) -> np.ndarray:\n        target_rpy = np.zeros(3)\n\n        sign_z = np.sign(target_force[2])\n        if sign_z == 0:\n            sign_z = 1\n\n        target_rpy[0] = np.arcsin(-sign_z * target_force[1] /\n                                  np.linalg.norm(target_force))\n        target_rpy[0] = np.clip(\n            target_rpy[0], -self.max_roll_pitch, self.max_roll_pitch)\n        target_rpy[1] = np.arctan2(\n            sign_z * target_force[0], sign_z * target_force[2])\n        target_rpy[1] = np.clip(\n            target_rpy[1], -self.max_roll_pitch, self.max_roll_pitch)\n        # Yaw is intended to leave as 0\n\n        return target_rpy\n\n    def _compute_target_torque(self, target_rpy: np.ndarray, cur_ori: np.ndarray) -> np.ndarray:\n        cur_rpy = p.getEulerFromQuaternion(cur_ori)\n        rpy_e = target_rpy - np.array(cur_rpy)\n\n        if rpy_e[2] > np.pi:\n            rpy_e[2] = rpy_e[2] - 2 * np.pi\n        if rpy_e[2] < -np.pi:\n            rpy_e[2] = rpy_e[2] + 2 * np.pi\n        d_rpy_e = (rpy_e - self.last_rpy_e) / self.drone.world.timestep\n        self.last_rpy_e = rpy_e\n        self.integral_rpy_e = self.integral_rpy_e + rpy_e * self.drone.world.timestep\n\n        target_torque = (np.multiply(self._torque_p_coef, rpy_e)\n                         + np.multiply(self._torque_i_coef,\n                                       self.integral_rpy_e)\n                         + np.multiply(self._torque_d_coef, d_rpy_e))\n\n        max_xy_torque = self.drone.max_xy_torque\n        max_z_torque = self.drone.max_z_torque\n\n        ub = np.array([max_xy_torque, max_xy_torque, max_z_torque])\n        lb = -ub\n        target_torque = target_torque.clip(lb, ub)\n\n        return target_torque\n\n    def _compute_rpm(self, target_thrust: float, target_torque: np.ndarray) -> np.ndarray:\n        x = np.concatenate([[target_thrust], target_torque])\n        bx = self.drone.B * x\n        power_rpm = self.drone.A_inv @ bx\n        power_rpm = power_rpm.clip(0, self.drone.max_rpm ** 2)\n\n        if np.min(power_rpm) < 0:\n            power_rpm, res = nnls(self.drone.A, bx, maxiter=20)\n\n        return np.sqrt(power_rpm)\n\n    def set_force_pid_coef(self,\n                           p_coef: np.ndarray,\n                           i_coef: np.ndarray,\n                           d_coef: np.ndarray):\n        self._force_p_coef = p_coef\n        self._force_i_coef = i_coef\n        self._force_d_coef = d_coef\n\n    def set_torque_pid_coef(self,\n                            p_coef: np.ndarray,\n                            i_coef: np.ndarray,\n                            d_coef: np.ndarray):\n        self._torque_p_coef = p_coef\n        self._torque_i_coef = i_coef\n        self._torque_d_coef = d_coef", "class DronePID(ControllerBase):\n    \"\"\"\n    Adapted from\n    https://github.com/utiasDSL/gym-pybullet-drones/blob/master/gym_pybullet_drones/control/SimplePIDControl.py\n    \"\"\"\n\n    def __init__(self, drone: Drone):\n        self.drone = drone\n\n        # Default PID coefficients\n        self._force_p_coef = np.array([.1, .1, .2])\n        self._force_i_coef = np.array([.0001, .0001, .0001])\n        self._force_d_coef = np.array([.3, .3, .4])\n        self._torque_p_coef = np.array([.3, .3, .05])\n        self._torque_i_coef = np.array([.0001, .0001, .0001])\n        self._torque_d_coef = np.array([.3, .3, .5])\n\n        self.last_pos_e = np.zeros(3)\n        self.integral_pos_e = np.zeros(3)\n        self.last_rpy_e = np.zeros(3)\n        self.integral_rpy_e = np.zeros(3)\n\n        # constrain the max roll and pitch angles for stability\n        self.max_roll_pitch = np.pi / 6\n\n    def reset(self):\n        self.last_pos_e = np.zeros(3)\n        self.integral_pos_e = np.zeros(3)\n        self.last_rpy_e = np.zeros(3)\n        self.integral_rpy_e = np.zeros(3)\n\n    def control(self, goal: np.ndarray) -> np.ndarray:\n        cur_pos, cur_ori = self.drone.get_base_pos_and_ori()\n\n        target_force = self._compute_target_force(goal, cur_pos)\n        target_thrust = self._compute_target_thrust(target_force, cur_ori)\n\n        target_rpy = self._compute_target_rotation(target_force)\n        target_torque = self._compute_target_torque(target_rpy, cur_ori)\n\n        # control commands in rpm\n        rpm = self._compute_rpm(target_thrust, target_torque)\n\n        return rpm\n\n    def _compute_target_force(self, goal: np.ndarray, cur_pos: np.ndarray) -> np.ndarray:\n        pos_e = goal - np.array(cur_pos).reshape(3)\n        d_pos_e = (pos_e - self.last_pos_e) / self.drone.world.timestep\n        self.last_pos_e = pos_e\n        self.integral_pos_e = self.integral_pos_e + pos_e * self.drone.world.timestep\n\n        target_force = (np.array([0, 0, self.drone.m * self.drone.world.g])\n                        + np.multiply(self._force_p_coef, pos_e)\n                        + np.multiply(self._force_i_coef, self.integral_pos_e)\n                        + np.multiply(self._force_d_coef, d_pos_e))\n\n        return target_force\n\n    def _compute_target_thrust(self, target_force: np.ndarray, cur_ori: np.ndarray) -> float:\n        cur_rotation = np.array(\n            p.getMatrixFromQuaternion(cur_ori)).reshape(3, 3)\n        target_thrust = np.dot(cur_rotation, target_force)\n        target_thrust = target_thrust.clip(0, self.drone.max_thrust)\n\n        return target_thrust[2]\n\n    def _compute_target_rotation(self, target_force: np.ndarray) -> np.ndarray:\n        target_rpy = np.zeros(3)\n\n        sign_z = np.sign(target_force[2])\n        if sign_z == 0:\n            sign_z = 1\n\n        target_rpy[0] = np.arcsin(-sign_z * target_force[1] /\n                                  np.linalg.norm(target_force))\n        target_rpy[0] = np.clip(\n            target_rpy[0], -self.max_roll_pitch, self.max_roll_pitch)\n        target_rpy[1] = np.arctan2(\n            sign_z * target_force[0], sign_z * target_force[2])\n        target_rpy[1] = np.clip(\n            target_rpy[1], -self.max_roll_pitch, self.max_roll_pitch)\n        # Yaw is intended to leave as 0\n\n        return target_rpy\n\n    def _compute_target_torque(self, target_rpy: np.ndarray, cur_ori: np.ndarray) -> np.ndarray:\n        cur_rpy = p.getEulerFromQuaternion(cur_ori)\n        rpy_e = target_rpy - np.array(cur_rpy)\n\n        if rpy_e[2] > np.pi:\n            rpy_e[2] = rpy_e[2] - 2 * np.pi\n        if rpy_e[2] < -np.pi:\n            rpy_e[2] = rpy_e[2] + 2 * np.pi\n        d_rpy_e = (rpy_e - self.last_rpy_e) / self.drone.world.timestep\n        self.last_rpy_e = rpy_e\n        self.integral_rpy_e = self.integral_rpy_e + rpy_e * self.drone.world.timestep\n\n        target_torque = (np.multiply(self._torque_p_coef, rpy_e)\n                         + np.multiply(self._torque_i_coef,\n                                       self.integral_rpy_e)\n                         + np.multiply(self._torque_d_coef, d_rpy_e))\n\n        max_xy_torque = self.drone.max_xy_torque\n        max_z_torque = self.drone.max_z_torque\n\n        ub = np.array([max_xy_torque, max_xy_torque, max_z_torque])\n        lb = -ub\n        target_torque = target_torque.clip(lb, ub)\n\n        return target_torque\n\n    def _compute_rpm(self, target_thrust: float, target_torque: np.ndarray) -> np.ndarray:\n        x = np.concatenate([[target_thrust], target_torque])\n        bx = self.drone.B * x\n        power_rpm = self.drone.A_inv @ bx\n        power_rpm = power_rpm.clip(0, self.drone.max_rpm ** 2)\n\n        if np.min(power_rpm) < 0:\n            power_rpm, res = nnls(self.drone.A, bx, maxiter=20)\n\n        return np.sqrt(power_rpm)\n\n    def set_force_pid_coef(self,\n                           p_coef: np.ndarray,\n                           i_coef: np.ndarray,\n                           d_coef: np.ndarray):\n        self._force_p_coef = p_coef\n        self._force_i_coef = i_coef\n        self._force_d_coef = d_coef\n\n    def set_torque_pid_coef(self,\n                            p_coef: np.ndarray,\n                            i_coef: np.ndarray,\n                            d_coef: np.ndarray):\n        self._torque_p_coef = p_coef\n        self._torque_i_coef = i_coef\n        self._torque_d_coef = d_coef", ""]}
{"filename": "src/stl_mob/ctrl/drone_pid/drone/__init__.py", "chunked_list": ["from .pid import DronePID\n"]}
{"filename": "src/stl_mob/evaluate/plan_and_ctrl_time.py", "chunked_list": ["import os\n\nimport numpy as np\nfrom gym.wrappers import Monitor\n\nfrom stl_mob.ctrl.wrapper import get_controller\nfrom stl_mob.envs.wrapper import get_env\nfrom stl_mob.stl.solver import StlpySolver\nfrom stl_mob.stl.tasks import TaskBase\nfrom stl_mob.utils import DATA_DIR", "from stl_mob.stl.tasks import TaskBase\nfrom stl_mob.utils import DATA_DIR\n\n\nclass TimeEvaluator:\n    def __init__(self, task: TaskBase, robot_name: str, enable_gui: bool = True, store_video: bool = False):\n        self.space_dims = {\n            \"point\": 2,\n            \"car\": 2,\n            \"doggo\": 2,\n            \"drone\": 3\n        }\n\n        self.task = task\n        self.robot_name = robot_name\n        self.enable_gui = enable_gui\n        self.store_video = store_video\n\n        self.env = get_env(self.robot_name, self.task, self.enable_gui)\n        self.solver = StlpySolver(space_dim=self.space_dims[self.robot_name])\n        self.controller = get_controller(self.robot_name)\n\n    def plan(self):\n        path, info = self.solver.solve_stlpy_formula(self.task.get_spec().get_stlpy_form(),\n                                                     x0=self.task.sample_init_pos(),\n                                                     total_time=self.task.total_time_steps)\n\n        solve_time = info[\"solve_t\"]\n        return path, solve_time\n\n    def ctrl(self, path: np.ndarray, max_wp_step: int = 300) -> float:\n        total_time = 0\n\n        if self.store_video:\n            save_dir = f\"{DATA_DIR}/videos/{self.robot_name}_{type(self.task).__name__.lower()}\"\n            os.makedirs(save_dir, exist_ok=True)\n            self.env.gym_env = Monitor(self.env.gym_env, save_dir, force=True)\n\n        obs = self.env.reset(init_pos=path[0])\n        for wp in path[1:]:\n            self.env.set_goal(wp)\n            t = 0\n            for t in range(max_wp_step):\n                action = self.controller(obs)\n                obs, _, _, _ = self.env.step(action)\n                if self.env.reached():\n                    break\n            total_time += t\n            if not self.env.reached():\n                return float('inf')\n\n        return total_time\n\n    def eval(self):\n        path, solve_t = self.plan()\n\n        if path is None:\n            return float('inf'), float('inf')\n\n        ctrl_time = self.ctrl(path)\n        return solve_t, ctrl_time", ""]}
{"filename": "src/stl_mob/evaluate/__init__.py", "chunked_list": [""]}
