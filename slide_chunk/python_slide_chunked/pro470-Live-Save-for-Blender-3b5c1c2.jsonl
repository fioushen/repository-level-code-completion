{"filename": "__init__.py", "chunked_list": ["bl_info = {\n    \"name\": \"Live Save 2\",\n    \"description\": \"Automatically saves the project with a timestamp when changes are made\",\n    \"author\": \"Your Name\",\n    \"version\": (0, 1),\n    \"blender\": (3, 3, 0),\n    \"location\": \"View3D > UI panel\",\n    \"warning\": \"Experimental\",\n    \"category\": \"System\"\n}", "    \"category\": \"System\"\n}\n\n\nfrom . import Live_Addon\n\n\ndef register():\n    Live_Addon.register()\n", "\n\ndef unregister():\n    Live_Addon.unregister()\n"]}
{"filename": "Live_Addon/__init__.py", "chunked_list": ["import re\n\nfrom . import props\nfrom . import ops\nfrom . import handlers\nfrom . import ui\nfrom . import timer\nfrom . import utils\nimport bpy\nimport os", "import bpy\nimport os\nimport shutil\n\n\ndef register():\n    props.register()\n    ops.register()\n    timer.register()\n    handlers.register()\n    ui.register()", "\n\ndef unregister():\n    ui.unregister()\n    handlers.unregister()\n    timer.unregister()\n    ops.unregister()\n    file_path12 = bpy.context.window_manager.my_addon_props.file_path\n    version_folder_path = bpy.context.window_manager.my_addon_props.file_path_version\n    blend_match = r\"\\.blend\"\n    matched_blend = re.search(blend_match, file_path12)\n    # when it is not a folder and it is a blend file\n    if not os.path.isdir(file_path12) and matched_blend and os.path.exists(file_path12):\n        os.remove(file_path12)\n        if os.path.exists(version_folder_path):\n            shutil.rmtree(version_folder_path)\n    props.unregister()", ""]}
{"filename": "Live_Addon/utils/comparison.py", "chunked_list": ["import bpy\nfrom .. import props\nimport numpy as np\nimport sqlite3\n\n\ndef check_undo_redo(context):\n    print(\"i called \")\n    wm = context.window_manager\n    current_count = bpy.context.window_manager.my_addon_props.exec_count\n    print(\"current exec\")\n    print(current_count)\n    previous_count = wm.get(\"_previous_count\", 0)\n    if current_count != previous_count:\n        print(\"ungleich\")\n        wm[\"_previous_count\"] = current_count\n        print(\"setting current\")\n        return True\n    return False", "\n\nmy_dict = {}\nstored = my_dict.get(\"stored_data\", {})\n\n\ndef compare_blend_data():\n    global stored\n    if bpy.context.window_manager.my_addon_props.mouse_detect:\n        \n        data_blocks = {\n            *bpy.data.meshes,\n            *bpy.data.materials,\n            *bpy.data.textures,\n            *bpy.data.images,\n            *bpy.data.objects,\n            *bpy.data.lights,\n            *bpy.data.cameras,\n            *bpy.data.curves,\n            *bpy.data.armatures,\n            *bpy.data.actions,\n            *bpy.data.libraries,\n            *bpy.data.scenes,\n            *bpy.data.sounds,\n            *bpy.data.worlds,\n            *bpy.data.fonts,\n            *bpy.data.grease_pencils,\n            *bpy.data.metaballs,\n            *bpy.data.paint_curves,\n            *bpy.data.particles,\n            *bpy.data.shape_keys,\n            *bpy.data.texts,\n            *bpy.data.volumes,\n            *bpy.data.pointclouds,\n            *bpy.data.movieclips,\n            *bpy.data.lightprobes,\n            *bpy.data.lattices,\n            *bpy.data.hair_curves,\n            *bpy.data.cache_files,\n            *bpy.data.linestyles,\n            *bpy.data.speakers\n        }\n\n        current_data = {\"data\": {}}\n        for obj in data_blocks:\n            obj_data = {}\n            for prop_name in dir(obj):\n                if prop_name:\n                    try:\n                        prop_value = getattr(obj, prop_name)\n                        if not prop_name.startswith(\"__\"):\n                            obj_data[prop_name] = prop_value\n\n                        for sub_prop_name in dir(prop_value):\n                            if not sub_prop_name.startswith(\"__\"):\n                                try:\n                                    sub_prop_value = getattr(prop_value, sub_prop_name)\n                                    if isinstance(sub_prop_value, (int, float, str, bool)):\n                                        obj_data[f\"{prop_name}.{sub_prop_name}\"] = sub_prop_value\n                                    elif isinstance(sub_prop_value, (tuple, list)):\n                                        # Convert tuple and list to list before storing in dictionary\n                                        obj_data[f\"{prop_name}.{sub_prop_name}\"] = list(sub_prop_value)\n                                    elif isinstance(sub_prop_value, np.ndarray):\n                                        # Convert numpy arrays to lists before storing in dictionary\n                                        obj_data[f\"{prop_name}.{sub_prop_name}\"] = sub_prop_value.tolist()\n                                    else:\n                                        # If the sub-property is not a supported data type, skip it\n                                        continue\n                                    for sub_sub_prop_name in dir(sub_prop_value):\n                                        if not sub_sub_prop_name.startswith(\"__\"):\n                                            try:\n                                                sub_sub_prop_value = getattr(sub_prop_value, sub_sub_prop_name)\n                                                if isinstance(sub_sub_prop_value, (int, float, str, bool)):\n                                                    obj_data[f\"{prop_name}.{sub_prop_name}.{sub_sub_prop_name}\"] = sub_sub_prop_value\n                                                elif isinstance(sub_sub_prop_value, (tuple, list)):\n                                                    # Convert tuple and list to list before storing in dictionary\n                                                    obj_data[f\"{prop_name}.{sub_prop_name}.{sub_sub_prop_name}\"] = list(sub_sub_prop_value)\n                                                elif isinstance(sub_sub_prop_value, np.ndarray):\n                                                    # Convert numpy arrays to lists before storing in dictionary\n                                                    obj_data[f\"{prop_name}.{sub_prop_name}.{sub_sub_prop_name}\"] = sub_sub_prop_value.tolist()\n                                                else:\n                                                    # If the sub-sub-property is not a supported data type, skip it\n                                                    continue\n                                            except:\n                                                # If there's an error, skip the sub-sub-property\n                                                pass\n                                except:\n                                    # If there's an error, skip the sub-property\n                                    pass\n                    except:\n                        # If there's an error, skip the property\n                        pass\n            current_data[\"data\"][obj] = obj_data\n\n        if current_data != stored:\n            my_dict['stored_data'] = current_data\n            stored = current_data\n            # print(stored)\n            # print(current_data)\n            print(\"made it here\")\n            bpy.context.window_manager.my_addon_props.mouse_detect = False\n            return True\n        bpy.context.window_manager.my_addon_props.mouse_detect = False\n    return False", "\n    # if not np.array_equal(current_data, stored):\n"]}
{"filename": "Live_Addon/utils/file_path.py", "chunked_list": ["import os\nimport bpy\nimport platform\nimport datetime\nimport re\nimport tempfile\nfrom .. import props\nfrom . import common\n\n\ndef get_default_path():\n    if platform.system() == \"Windows\":\n        appdata_folder = os.path.join(os.environ[\"APPDATA\"])\n    else:\n        appdata_folder = os.path.join(os.environ[\"HOME\"], \".config\")\n    return appdata_folder", "\n\ndef get_default_path():\n    if platform.system() == \"Windows\":\n        appdata_folder = os.path.join(os.environ[\"APPDATA\"])\n    else:\n        appdata_folder = os.path.join(os.environ[\"HOME\"], \".config\")\n    return appdata_folder\n\n\ndef build_new_file_path():\n    current_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n    timestep_regex = r\"\\d{4}\\.\\d{2}\\.\\d{2}_\\d{2}-\\d{2}-\\d{2}\"\n    new_path = re.sub(timestep_regex, current_time, bpy.context.window_manager.my_addon_props.file_path)\n    return new_path", "\n\ndef build_new_file_path():\n    current_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n    timestep_regex = r\"\\d{4}\\.\\d{2}\\.\\d{2}_\\d{2}-\\d{2}-\\d{2}\"\n    new_path = re.sub(timestep_regex, current_time, bpy.context.window_manager.my_addon_props.file_path)\n    return new_path\n\n\ndef match_in_timestep():\n    if os.path.exists(bpy.context.window_manager.my_addon_props.file_path):\n        timestep_regex = r\"\\d{4}\\.\\d{2}\\.\\d{2}_\\d{2}-\\d{2}-\\d{2}\"\n        matched1 = re.search(timestep_regex, bpy.context.window_manager.my_addon_props.file_path)\n        return matched1\n    else:\n        return False", "\ndef match_in_timestep():\n    if os.path.exists(bpy.context.window_manager.my_addon_props.file_path):\n        timestep_regex = r\"\\d{4}\\.\\d{2}\\.\\d{2}_\\d{2}-\\d{2}-\\d{2}\"\n        matched1 = re.search(timestep_regex, bpy.context.window_manager.my_addon_props.file_path)\n        return matched1\n    else:\n        return False\n\n\ndef create_new_file_path():\n    file_name = \"my_blend_file_\"\n    current_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n    addonpref = props.preference.prefs()\n    created_filepath = os.path.join(addonpref.livesavede, file_name + current_time + \".blend\")\n    return created_filepath", "\n\ndef create_new_file_path():\n    file_name = \"my_blend_file_\"\n    current_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n    addonpref = props.preference.prefs()\n    created_filepath = os.path.join(addonpref.livesavede, file_name + current_time + \".blend\")\n    return created_filepath\n\n\ndef create_new_file_path_version():\n    project_name = os.path.splitext(os.path.basename(bpy.context.window_manager.my_addon_props.file_path))[0]\n\n    # Create the version folder name with the project name and version count\n    version_folder_name = f\"{project_name}_version_folder\"\n\n    # Create the full path for the version folder\n    version_folder_path = os.path.join(os.path.dirname(bpy.context.window_manager.my_addon_props.file_path),\n                                       version_folder_name)\n\n    return version_folder_path", "\n\ndef create_new_file_path_version():\n    project_name = os.path.splitext(os.path.basename(bpy.context.window_manager.my_addon_props.file_path))[0]\n\n    # Create the version folder name with the project name and version count\n    version_folder_name = f\"{project_name}_version_folder\"\n\n    # Create the full path for the version folder\n    version_folder_path = os.path.join(os.path.dirname(bpy.context.window_manager.my_addon_props.file_path),\n                                       version_folder_name)\n\n    return version_folder_path", "\n\ndef build_new_p_file_path_version():\n    file_name = \"my_blend_file_\"\n    current_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n    addonpref = props.preference.prefs()\n    created_filepath = os.path.join(addonpref.livesavede, file_name + current_time)\n    version_folder_name = f\"{created_filepath}_permenant_version_folder\"\n    version_folder_path = os.path.join(os.path.dirname(bpy.context.window_manager.my_addon_props.file_path),\n                                       version_folder_name)\n    return version_folder_path", "\n\ndef make_image_dir():\n    addonpref = props.preference.prefs()\n    image_dir = os.path.join(addonpref.image_file_path, \"Images from Blender\")\n    if not os.path.exists(image_dir):\n        os.mkdir(image_dir)\n    return image_dir\n\n\ndef make_image_file_path_udim(image_name):\n        image_dir = make_image_dir()\n        currrent_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n        udim = '<UDIM>'\n        image_file_path = os.path.join(image_dir, image_name + currrent_time + udim + common.file_extension_format())\n        return image_file_path", "\n\ndef make_image_file_path_udim(image_name):\n        image_dir = make_image_dir()\n        currrent_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n        udim = '<UDIM>'\n        image_file_path = os.path.join(image_dir, image_name + currrent_time + udim + common.file_extension_format())\n        return image_file_path\n\n\ndef make_image_file_path(image_name):\n        image_dir = make_image_dir()\n        currrent_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n        image_file_path = os.path.join(image_dir, image_name + currrent_time + common.file_extension_format())\n        return image_file_path", "\n\ndef make_image_file_path(image_name):\n        image_dir = make_image_dir()\n        currrent_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n        image_file_path = os.path.join(image_dir, image_name + currrent_time + common.file_extension_format())\n        return image_file_path\n\n# file_name = \"live_backup\"\n# current_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")", "# file_name = \"live_backup\"\n# current_time = datetime.datetime.now().strftime(\"%Y.%m.%d_%H-%M-%S\")\n# file_path = os.path.join(appdata_folder, file_name + current_time + \".blend\")\n"]}
{"filename": "Live_Addon/utils/__init__.py", "chunked_list": ["from . import comparison\nfrom . import saving_function\nfrom . import file_path\nfrom . import common\n\n\n\ndef register():\n    pass\n", "\n\ndef unregister():\n    pass\n"]}
{"filename": "Live_Addon/utils/saving_function.py", "chunked_list": ["import bpy\nimport os\nimport datetime\nfrom . import file_path\nfrom . import comparison\nfrom . import common\nimport importlib\n\n\nfph = file_path", "\nfph = file_path\n\n\ndef run_once():\n    has_run = False\n\n    def inner():\n        nonlocal has_run\n        if not has_run:\n            print(\"This function will only execute once.\")\n            has_run = True\n            return True\n        else:\n            return False\n\n    return inner", "\n\ndef save_to_file(file_path1):\n    bpy.ops.wm.save_as_mainfile(filepath=file_path1, copy=True)\n\n\ndef save_image_textures():\n    for img in bpy.data.images:\n        try:\n            if img.is_dirty:\n                if img.filepath:\n                    img.save()\n                else:\n                    img.filepath = file_path.make_image_file_path(img.name)\n                    img.save()\n        except Exception as e:\n            print(str(e))\n            if not os.path.exists(img.filepath):\n                img.filepath = file_path.make_image_file_path_udim(img.name)\n                img.save()", "\n\ndef save_blend_file():\n\n    if bpy.data.is_saved:\n        bpy.ops.wm.save_mainfile()\n    elif comparison.compare_blend_data():\n        if fph.match_in_timestep():\n            new_file_path = fph.build_new_file_path()\n            print(\"im about to delete\")\n            print(bpy.context.window_manager.my_addon_props.file_path, new_file_path)\n            os.rename(bpy.context.window_manager.my_addon_props.file_path, new_file_path)\n            print(\"i deleted\")\n            bpy.context.window_manager.my_addon_props.file_path = new_file_path\n            if os.path.exists(bpy.context.window_manager.my_addon_props.file_path_version):\n                new_version_folder = fph.create_new_file_path_version()\n                os.rename(bpy.context.window_manager.my_addon_props.file_path_version, new_version_folder)\n                bpy.context.window_manager.my_addon_props.file_path_version = new_version_folder\n            elif bpy.context.window_manager.my_addon_props.is_enabled_version:\n                new_version_folder = fph.create_new_file_path_version()\n                bpy.context.window_manager.my_addon_props.file_path_version = new_version_folder\n        else:\n            bpy.context.window_manager.my_addon_props.file_path = fph.create_new_file_path()\n            print(\"wrong place\")\n            save_to_file(bpy.context.window_manager.my_addon_props.file_path)\n            if bpy.context.window_manager.my_addon_props.is_enabled_version:\n                new_version_folder = fph.create_new_file_path_version()\n                bpy.context.window_manager.my_addon_props.file_path_version = new_version_folder\n        # write all materials, textures and node groups to a library\n        data_blocks = {\n            *bpy.data.meshes,\n            *bpy.data.materials,\n            *bpy.data.textures,\n            *bpy.data.images,\n            *bpy.data.objects,\n            *bpy.data.lights,\n            *bpy.data.cameras,\n            *bpy.data.curves,\n            *bpy.data.armatures,\n            *bpy.data.actions,\n            *bpy.data.libraries,\n            *bpy.data.scenes,\n            *bpy.data.sounds,\n            *bpy.data.worlds,\n            *bpy.data.fonts,\n            *bpy.data.grease_pencils,\n            *bpy.data.metaballs,\n            *bpy.data.paint_curves,\n            *bpy.data.particles,\n            *bpy.data.shape_keys,\n            *bpy.data.speakers,\n            *bpy.data.texts,\n            *bpy.data.window_managers,\n            *bpy.data.workspaces,\n            *bpy.data.volumes,\n            *bpy.data.pointclouds,\n            *bpy.data.movieclips,\n            *bpy.data.lightprobes,\n            *bpy.data.libraries,\n            *bpy.data.lattices,\n            *bpy.data.hair_curves,\n            *bpy.data.collections,\n            *bpy.data.cache_files,\n            *bpy.data.linestyles,\n            *bpy.data.brushes,\n            *bpy.data.speakers,\n            *bpy.data.screens\n        }\n        bpy.data.libraries.write(bpy.context.window_manager.my_addon_props.file_path, data_blocks)\n        print(\"Data appended successfully to the copied blend file.\")\n    else:\n        pass", ""]}
{"filename": "Live_Addon/utils/common.py", "chunked_list": ["import re\n\nimport bpy\nimport importlib\n\nfrom .. import props\nimport os\n\n\"\"\"\nprops_module1 = props.Live_Addon", "\"\"\"\nprops_module1 = props.Live_Addon\n\n\n# Use props_module.addon here\n\n\ndef module() -> str:\n    return props_module1.name\n", "    return props_module1.name\n\n\ndef prefs() -> bpy.types.AddonPreferences:\n    return bpy.context.preferences.addons[module()].preferences\n    \n\"\"\"\n\n\ndef file_extension_format():\n    addon_prefs = props.preference.prefs()\n    image_format = addon_prefs.image_format\n\n    if image_format == 'PNG':\n        return '.png'\n    elif image_format == 'JPEG':\n        return '.jpg'\n    elif image_format == 'BMP':\n        return '.bmp'\n    elif image_format == 'TARGA':\n        return '.tga'\n    elif image_format == 'OPEN_EXR':\n        return '.exr'\n    elif image_format == 'HDR':\n        return '.hdr'\n    elif image_format == 'TIFF':\n        return '.tif'\n    elif image_format == 'AVI_JPEG':\n        return '.avi'\n    elif image_format == 'AVI_RAW':\n        return '.avi'\n    elif image_format == 'FRAMESERVER':\n        return '.fs'\n    elif image_format == 'Cineon':\n        return '.cin'\n    elif image_format == 'DPX':\n        return '.dpx'\n    elif image_format == 'OpenEXR_MULTILAYER':\n        return '.exr'\n    elif image_format == 'JP2':\n        return '.jp2'\n    elif image_format == 'IRIS':\n        return '.rgb'\n    elif image_format == 'J2C':\n        return '.j2c'\n    elif image_format == 'webp':\n        return '.webp'", "\ndef file_extension_format():\n    addon_prefs = props.preference.prefs()\n    image_format = addon_prefs.image_format\n\n    if image_format == 'PNG':\n        return '.png'\n    elif image_format == 'JPEG':\n        return '.jpg'\n    elif image_format == 'BMP':\n        return '.bmp'\n    elif image_format == 'TARGA':\n        return '.tga'\n    elif image_format == 'OPEN_EXR':\n        return '.exr'\n    elif image_format == 'HDR':\n        return '.hdr'\n    elif image_format == 'TIFF':\n        return '.tif'\n    elif image_format == 'AVI_JPEG':\n        return '.avi'\n    elif image_format == 'AVI_RAW':\n        return '.avi'\n    elif image_format == 'FRAMESERVER':\n        return '.fs'\n    elif image_format == 'Cineon':\n        return '.cin'\n    elif image_format == 'DPX':\n        return '.dpx'\n    elif image_format == 'OpenEXR_MULTILAYER':\n        return '.exr'\n    elif image_format == 'JP2':\n        return '.jp2'\n    elif image_format == 'IRIS':\n        return '.rgb'\n    elif image_format == 'J2C':\n        return '.j2c'\n    elif image_format == 'webp':\n        return '.webp'", "\n\ndef file_path_test(number):\n    new_filepath = new_file_path_func(number)\n\n    # check if the new filepath exists\n    if os.path.exists(new_filepath):\n        print(f\"{new_filepath} already exists!\")\n        return True\n    else:\n        print(f\"{new_filepath} does not exist.\")\n        return False", "\n\ndef new_file_path_func(number):\n    new_filepath = \"Bernd\"\n    addon_prefs = props.preference.prefs()\n    print(bpy.context.window_manager.my_addon_props.p_version_path)\n\n    if bpy.data.is_saved or os.path.exists(bpy.context.window_manager.my_addon_props.p_version_path):\n        file_path = bpy.data.filepath\n        dirname = os.path.dirname(file_path)\n        matched = re.search(r\"_permenant_version\", file_path)\n\n        if matched:\n            target_folder = os.path.dirname(file_path)\n            # Get a list of all .blend files in the target folder\n            blend_files = [f for f in os.listdir(target_folder) if f.endswith(\".blend\")]\n\n            # Sort the blend files by their creation time, with the oldest file first\n            oldest_first = sorted(blend_files, key=lambda f: os.path.getctime(os.path.join(target_folder, f)))\n\n            # Extract just the filenames from the file paths\n            oldest_first_filenames = [os.path.basename(f) for f in oldest_first]\n\n            filename = os.path.basename(file_path)\n\n            try:\n                if isinstance(number, int):\n                    target_file_index = oldest_first_filenames.index(filename)\n                    print(f\"The index of {file_path} is {target_file_index}\")\n                    new_filepath = os.path.join(dirname, oldest_first[target_file_index + number])\n                elif isinstance(number, str):\n                    if number == \"first\":\n                        new_filepath = os.path.join(dirname, oldest_first[0])\n                    elif number == \"last\":\n                        new_filepath = os.path.join(dirname, oldest_first[-1])\n            except ValueError and IndexError:\n                print(f\"{file_path} is not in the list\")\n\n            return new_filepath\n\n        else:\n            project_name = os.path.splitext(os.path.basename(file_path))[0]\n            dirname = os.path.dirname(file_path)\n            p_version_folder_name = f\"{project_name}_permenant_version\"\n            p_version_folder_path = os.path.join(dirname, p_version_folder_name)\n            print(p_version_folder_path)\n            target_folder = p_version_folder_path\n\n            if os.path.exists(target_folder):\n                # get the directory and filename without extension\n                directory, filename = os.path.split(file_path)\n                filename, ext = os.path.splitext(filename)\n\n                # if not, start with version 1\n                new_version = number\n                if new_version == \"first\":\n                    new_version = 1\n                new_filename = f\"{filename}_v{new_version:03}{ext}\"\n\n                # create the new filepath with the new filename\n                new_filepath = os.path.join(target_folder, new_filename)\n                return new_filepath\n\n    elif os.path.exists(bpy.context.window_manager.my_addon_props.p_version_path):\n        target_folder = bpy.context.window_manager.my_addon_props.p_version_path\n        new_version = number\n        # loop through all blend files in the directory and find the matching filepath\n        version_files = sorted([f for f in os.listdir(target_folder) if f.endswith(\".blend\")])\n        new_filepath = os.path.join(target_folder, version_files[0])\n        return new_filepath\n\n    return new_filepath", "\n\ndef file_path_version_open(number):\n    new_filepath = new_file_path_func(number)\n    # check if the new filepath exists\n    if os.path.exists(new_filepath):\n        bpy.ops.wm.open_mainfile(filepath=new_filepath)\n\ndef go_to_original():\n    original_file_path = \"\"\n    file_path = bpy.data.filepath\n    matched = re.search(r\"_permenant_version\", file_path)\n\n    if matched:\n        directory, filename = os.path.split(file_path)\n        filename, ext = os.path.splitext(filename)\n        new_filename = directory.replace(\"_permenant_version\", \"\")\n        dirname = os.path.dirname(directory)\n        original_file_path = os.path.join(dirname, new_filename + ext)\n        return original_file_path\n    else:\n        print(\"This is the original file!\")\n        return original_file_path", "def go_to_original():\n    original_file_path = \"\"\n    file_path = bpy.data.filepath\n    matched = re.search(r\"_permenant_version\", file_path)\n\n    if matched:\n        directory, filename = os.path.split(file_path)\n        filename, ext = os.path.splitext(filename)\n        new_filename = directory.replace(\"_permenant_version\", \"\")\n        dirname = os.path.dirname(directory)\n        original_file_path = os.path.join(dirname, new_filename + ext)\n        return original_file_path\n    else:\n        print(\"This is the original file!\")\n        return original_file_path", "\n\ndef go_to_original_test():\n    new_filepath = go_to_original()\n\n    # check if the new filepath exists\n    if os.path.exists(new_filepath):\n        print(f\"{new_filepath} already exists!\")\n        return True\n    else:\n        print(f\"{new_filepath} does not exist.\")\n        return False", "\ndef go_to_original_open():\n    new_filepath = go_to_original()\n    # check if the new filepath exists\n    if os.path.exists(new_filepath):\n        bpy.ops.wm.open_mainfile(filepath=new_filepath)\n\n\ndef update_index(self, context):\n    index = bpy.context.window_manager.list_index\n    my_list = bpy.context.window_manager.my_list\n\n    file_path = my_list[index].p_version_file_path\n    if os.path.exists(file_path):\n        bpy.ops.wm.open_mainfile(filepath=file_path)", "def update_index(self, context):\n    index = bpy.context.window_manager.list_index\n    my_list = bpy.context.window_manager.my_list\n\n    file_path = my_list[index].p_version_file_path\n    if os.path.exists(file_path):\n        bpy.ops.wm.open_mainfile(filepath=file_path)\n\n\n", "\n\n\n"]}
{"filename": "Live_Addon/ops/open_original.py", "chunked_list": ["import bpy\nfrom bpy.types import Operator\nfrom .. import utils\ncom = utils.common\n\n\nclass LiveSaveLoadOriginal(Operator):\n    bl_idname = 'livesave.load_original'\n    bl_label = 'Load Next'\n    bl_options = {'INTERNAL'}\n    bl_description = 'Load the original iteration of this file'\n\n    @classmethod\n    def poll(cls, context):\n        return com.go_to_original_test()\n\n    def execute(self, context):\n        com.go_to_original_open()\n        return {'FINISHED'}", ""]}
{"filename": "Live_Addon/ops/save_p_version.py", "chunked_list": ["import os\nimport re\nfrom .. import utils\nimport bpy\nfph = utils.file_path\n\nclass save_p_version(bpy.types.Operator):\n    bl_idname = 'live_save.save_p_version'\n    bl_label = 'Save Previous Version'\n    bl_description = 'Save a permenant version of your file'\n\n    blend_match = r\"\\.blend\"\n    timestep_regex = r\"\\d{4}\\.\\d{2}\\.\\d{2}_\\d{2}-\\d{2}-\\d{2}\"\n\n\n    def execute(self, context):\n        file_path12 = bpy.context.window_manager.my_addon_props.file_path\n        matched_blend = re.search(self.blend_match, file_path12)\n        if bpy.data.is_saved:\n            filepath = bpy.data.filepath\n            project_name = os.path.splitext(os.path.basename(filepath))[0]\n            p_version_folder_name = f\"{project_name}_permenant_version\"\n            p_version_folder_path = os.path.join(os.path.dirname(filepath), p_version_folder_name)\n\n            if not os.path.exists(p_version_folder_path):\n                os.makedirs(p_version_folder_path, exist_ok=True)\n\n            version_files = sorted([f for f in os.listdir(p_version_folder_path) if f.endswith(\".blend\")])\n            my_list = context.window_manager.my_list\n            for i in range(len(version_files)):\n                if len(version_files) == 0:\n                    break\n                old_path = os.path.join(p_version_folder_path, version_files[i])\n                match = re.search(r\"_v\\d{3}\", version_files[i])\n                if match:\n                    new_name = f\"{project_name}_v{i + 1:03}.blend\"\n                    new_path = os.path.join(p_version_folder_path, new_name)\n                    os.rename(old_path, new_path)\n                try:\n                    list_new_item = my_list[i]\n                    match = re.search(r\"_v\\d{3}\", list_new_item.name)\n                    if match:\n                        list_new_item.name = new_name\n                    elif not os.path.exists(os.path.join(p_version_folder_path, list_new_item.name)):\n                        os.rename(new_path, os.path.join(p_version_folder_path, list_new_item.name))\n                    list_new_item.p_version_file_path = new_path\n                except IndexError:\n                    list_new_item = bpy.context.window_manager.my_list.add()\n                    list_new_item.name = new_name\n                    list_new_item.p_version_file_path = new_path\n\n            version_count = len(version_files)\n\n            current_version_name = f\"{project_name}_v{version_count + 1:03d}.blend\"\n            current_version_path = os.path.join(p_version_folder_path, current_version_name)\n\n            bpy.ops.wm.save_as_mainfile(filepath=current_version_path, copy=True)\n\n            list_new_item = bpy.context.window_manager.my_list.add()\n            list_new_item.name = current_version_name\n            list_new_item.p_version_file_path = current_version_path\n        elif not os.path.isdir(file_path12) and matched_blend and os.path.exists(file_path12):\n            version_folder_path = bpy.context.window_manager.my_addon_props.p_version_path\n\n            if not os.path.exists(version_folder_path):\n                bpy.context.window_manager.my_addon_props.p_version_path = fph.build_new_p_file_path_version()\n                version_folder_path = bpy.context.window_manager.my_addon_props.p_version_path\n                os.makedirs(version_folder_path, exist_ok=True)\n\n            version_files = sorted([f for f in os.listdir(version_folder_path) if f.endswith(\".blend\")])\n            my_list = context.window_manager.my_list\n            for i in range(len(version_files)):\n                if len(version_files) == 0:\n                    break\n                project_name = version_files[i].split(\"_v\")[0]\n                old_path = os.path.join(version_folder_path, version_files[i])\n                new_name = f\"{project_name}_v{i + 1:03}.blend\"\n                new_path = os.path.join(version_folder_path, new_name)\n                os.rename(old_path, new_path)\n                try:\n                    list_new_item = my_list[i]\n                    list_new_item.name = new_name\n                    list_new_item.p_version_file_path = new_path\n                except IndexError:\n                    list_new_item = bpy.context.window_manager.my_list.add()\n                    list_new_item.name = new_name\n                    list_new_item.p_version_file_path = new_path\n\n            project_name = os.path.basename(version_folder_path)\n            project_name = project_name[:-15]\n\n            version_count = len(version_files)\n            \n            current_version_name = f\"{project_name}_v{version_count + 1:03d}.blend\"\n            current_version_path = os.path.join(version_folder_path, current_version_name)\n\n            list_new_item = bpy.context.window_manager.my_list.add()\n            list_new_item.name = current_version_name\n            list_new_item.p_version_file_path = current_version_path\n\n            bpy.ops.wm.save_as_mainfile(filepath=current_version_path, copy=True)\n\n        return {'FINISHED'}", "\n\n"]}
{"filename": "Live_Addon/ops/save_with_browser.py", "chunked_list": ["import bpy\nfrom bpy.props import StringProperty\n\n\nclass SaveAsMainfileOperator(bpy.types.Operator):\n    bl_idname = \"wm.save_as_mainfile_with_browser\"\n    bl_label = \"Save As Mainfile with Browser\"\n    filepath: StringProperty(subtype='FILE_PATH')\n\n    @classmethod\n    def poll(cls, context):\n        return not bpy.data.is_saved\n\n    def execute(self, context):\n        # Add \".blend\" to the end of the filepath\n        filepath_blend = self.filepath + \".blend\"\n        bpy.ops.wm.save_as_mainfile(filepath=filepath_blend)\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        context.window_manager.fileselect_add(self)\n        return {'RUNNING_MODAL'}", ""]}
{"filename": "Live_Addon/ops/detect_mouseclick.py", "chunked_list": ["import importlib\nimport bpy\nfrom .. import props\n\nprops_module = props.preference\n\n\nclass UserActionDetector(bpy.types.Operator):\n    bl_idname = \"wm.user_action_detector\"\n    bl_label = \"User Action Detector\"\n\n    def modal(self, context, event):\n        #i want to add the enter key to the list of keys that will trigger the operator\n        if event.type in {'LEFTMOUSE', 'RIGHTMOUSE', 'RET'} and event.value == 'RELEASE':\n            print(\"User action detected\")\n            bpy.context.window_manager.my_addon_props.mouse_detect = True\n            addon_prefs = props_module.prefs()\n            if not addon_prefs.is_enabled:\n                self.cancel(context)\n                return {'CANCELLED'}\n\n        return {'PASS_THROUGH'}\n\n    def execute(self, context):\n        wm = context.window_manager\n        wm.modal_handler_add(self)\n        return {'RUNNING_MODAL'}\n\n    def cancel(self, context):\n        return {'CANCELLED'}", ""]}
{"filename": "Live_Addon/ops/__init__.py", "chunked_list": ["import bpy\nfrom .. import props\nfrom . import timer\nfrom . import save_with_browser\nfrom . import detect_mouseclick\nfrom . import save_p_version\nfrom . import load_p_version_pre\nfrom . import load_p_version_post\nfrom . import first_p_version\nfrom . import last_p_version", "from . import first_p_version\nfrom . import last_p_version\nfrom . import open_original\n\naddonpref = props.preference.prefs()\n\nCLASSES = [\n    timer.LiveSaveMessageHandler,\n    save_with_browser.SaveAsMainfileOperator,\n    detect_mouseclick.UserActionDetector,", "    save_with_browser.SaveAsMainfileOperator,\n    detect_mouseclick.UserActionDetector,\n    save_p_version.save_p_version,\n    load_p_version_pre.LiveSaveLoadPre,\n    load_p_version_post.LiveSaveLoadNext,\n    first_p_version.LiveSaveLoadFirst,\n    last_p_version.LiveSaveLoadLast,\n    open_original.LiveSaveLoadOriginal,\n]\n", "]\n\nregister, unregister = bpy.utils.register_classes_factory(CLASSES)\n"]}
{"filename": "Live_Addon/ops/timer.py", "chunked_list": ["import datetime\nimport threading\nimport pprint\nimport bpy\nfrom .. import utils\nimport importlib\nfrom .. import props\n\nprops_module = props.preference\nfrom .. import handlers", "props_module = props.preference\nfrom .. import handlers\n# Use props_module.addon here\n\nclass LiveSaveMessageHandler(bpy.types.Operator):\n    bl_idname = \"wm.live_save_message_handler\"\n    bl_label = \"Live Save Message Handler\"\n\n    _timer = None\n    is_running = False\n    onlyonce: bpy.props.BoolProperty(default=False)\n\n    def update_timer(self, context):\n        addon_prefs = props_module.prefs()\n        wm = context.window_manager\n        if self._timer != addon_prefs.Timer:\n            wm.event_timer_remove(self._timer)\n            self._timer = None\n        if not self._timer:\n            self._timer = wm.event_timer_add(addon_prefs.Timer, window=context.window)\n\n    def modal(self, context, event):\n        if event.type == 'TIMER':\n            addon_prefs = props_module.prefs()\n            if not addon_prefs.is_enabled:\n                self.cancel(context)\n                return {'CANCELLED'}\n            self.update_timer(context)\n            if bpy.data.is_dirty or utils.comparison.check_undo_redo(context):\n                if not self.is_running:\n                    self.is_running = True\n                    p = threading.Thread(target=self.my_thread_function)\n                    p.start()\n                    if not addon_prefs.background_save:\n                        p.join()\n        return {'PASS_THROUGH'}\n\n    def execute(self, context):\n        addon_prefs = props_module.prefs()\n        wm = context.window_manager\n        self._timer = wm.event_timer_add(addon_prefs.Timer, window=context.window)\n        wm.modal_handler_add(self)\n        bpy.app.handlers.undo_post.append(handlers.undo_redo.redo_handler)\n        bpy.app.handlers.redo_post.append(handlers.undo_redo.redo_handler)\n        return {'RUNNING_MODAL'}\n\n    def cancel(self, context):\n        wm = context.window_manager\n        wm.event_timer_remove(self._timer)\n        bpy.app.handlers.undo_post.remove(handlers.undo_redo.redo_handler)\n        bpy.app.handlers.redo_post.remove(handlers.undo_redo.redo_handler)\n\n        return {'CANCELLED'}\n\n    def my_thread_function(self):\n        start_time = datetime.datetime.now()\n        try:\n            utils.saving_function.save_blend_file()\n            utils.saving_function.save_image_textures()\n        except Exception as e:\n            print(e)\n        end_time = datetime.datetime.now()\n        execution_time = end_time - start_time\n        addon_prefs = props_module.prefs()\n        dyn_save = addon_prefs.dynamic_save\n        if dyn_save:\n            if execution_time > datetime.timedelta(seconds=1):\n                addon_prefs.Timer = 10\n            elif execution_time < datetime.timedelta(seconds=1):\n                addon_prefs.Timer = 1\n        self.is_running = False\n\n    @property\n    def timer(self):\n        return self._timer", ""]}
{"filename": "Live_Addon/ops/first_p_version.py", "chunked_list": ["import bpy\nfrom bpy.types import Operator\nfrom .. import utils\n\ncom = utils.common\n\n\nclass LiveSaveLoadFirst(Operator):\n    bl_idname = 'livesave.load_first'\n    bl_label = 'Load Next'\n    bl_options = {'INTERNAL'}\n    bl_description = 'Load the first iteration of this file'\n\n    @classmethod\n    def poll(cls, context):\n        return com.file_path_test(\"first\")\n\n    def execute(self, context):\n        com.file_path_version_open(\"first\")\n        return {'FINISHED'}", ""]}
{"filename": "Live_Addon/ops/last_p_version.py", "chunked_list": ["import bpy\nfrom bpy.types import Operator\nfrom .. import utils\ncom = utils.common\n\n\nclass LiveSaveLoadLast(Operator):\n    bl_idname = 'livesave.load_last'\n    bl_label = 'Load Next'\n    bl_options = {'INTERNAL'}\n    bl_description = 'Load the last iteration of this file'\n\n    @classmethod\n    def poll(cls, context):\n        return com.file_path_test(\"last\")\n\n    def execute(self, context):\n        com.file_path_version_open(\"last\")\n        return {'FINISHED'}", ""]}
{"filename": "Live_Addon/ops/load_p_version_post.py", "chunked_list": ["import bpy\nfrom bpy.types import Operator\nfrom .. import utils\ncom = utils.common\n\n\nclass LiveSaveLoadNext(Operator):\n    bl_idname = 'livesave.load_next'\n    bl_label = 'Load Next'\n    bl_options = {'INTERNAL'}\n    bl_description = 'Load the pre iteration of this file'\n\n    @classmethod\n    def poll(cls, context):\n        return com.file_path_test(1)\n\n    def execute(self, context):\n        com.file_path_version_open(1)\n        return {'FINISHED'}", ""]}
{"filename": "Live_Addon/ops/load_p_version_pre.py", "chunked_list": ["import bpy\nfrom .. import utils\nfrom bpy.types import Operator\ncom = utils.common\n\n\nclass LiveSaveLoadPre(Operator):\n    bl_idname = 'livesave.load_pre'\n    bl_label = 'Load Pre'\n    bl_options = {'INTERNAL'}\n    bl_description = 'Load the pre iteration of this file'\n\n    @classmethod\n    def poll(cls, context):\n        return com.file_path_test(-1)\n\n    def execute(self, context):\n        com.file_path_version_open(-1)\n        return {'FINISHED'}", ""]}
{"filename": "Live_Addon/handlers/undo_redo.py", "chunked_list": ["import bpy\n\n\ndef redo_handler(dummy):\n    print(\"undo did happend\")\n    bpy.context.window_manager.my_addon_props.exec_count += 1\n"]}
{"filename": "Live_Addon/handlers/__init__.py", "chunked_list": ["import bpy\nfrom . import live_load_hanlder\nfrom . import live_save_handler\nfrom . import undo_redo\n\n\ndef register():\n    if live_load_hanlder.auto_start not in bpy.app.handlers.load_post:\n        bpy.app.handlers.load_post.append(live_load_hanlder.auto_start)\n\n    if live_save_handler.on_save_post_handler not in bpy.app.handlers.save_post:\n        bpy.app.handlers.save_post.append(live_save_handler.on_save_post_handler)", "\n\ndef unregister():\n    if live_load_hanlder.auto_start in bpy.app.handlers.load_post:\n        bpy.app.handlers.load_post.remove(live_load_hanlder.auto_start)\n\n    if live_save_handler.on_save_post_handler in bpy.app.handlers.save_post:\n        bpy.app.handlers.save_post.remove(live_save_handler.on_save_post_handler)"]}
{"filename": "Live_Addon/handlers/live_save_handler.py", "chunked_list": ["import bpy\nimport os\nimport shutil\nfrom .. import props\n\n\n@bpy.app.handlers.persistent\ndef on_save_post_handler(dummy):\n    file_path12 = bpy.context.window_manager.my_addon_props.file_path\n    if bpy.data.filepath:\n        if os.path.exists(file_path12):\n            os.remove(file_path12)", ""]}
{"filename": "Live_Addon/handlers/live_load_hanlder.py", "chunked_list": ["import os\n\nimport bpy\nimport importlib\nfrom ..timer import save_version as sv\nfrom .. import props\nfrom .. import utils as u\nfph = u.file_path\ncom = u.common\n", "com = u.common\n\n\nutils_module = props.preference\n# Use props_module.addon here\n\n\n@bpy.app.handlers.persistent\ndef auto_start(dummy):\n    prefs = utils_module.prefs()\n    window_manager = bpy.context.window_manager\n    if prefs.auto_start_save:\n        print(\"auto start save\")\n        file_path = fph.create_new_file_path()\n        bpy.ops.wm.save_as_mainfile(filepath=file_path)\n    if prefs.is_enabled:\n        bpy.ops.wm.live_save_message_handler('EXEC_DEFAULT')\n        bpy.ops.wm.user_action_detector('EXEC_DEFAULT')\n    if bpy.context.window_manager.my_addon_props.is_enabled_version:\n        if not bpy.app.timers.is_registered(sv.save_version):\n            bpy.app.timers.register(sv.save_version, first_interval=bpy.context.window_manager.my_addon_props.version_timer, persistent=True)\n\n    if com.file_path_test(\"first\"):\n        p_version_folder_path = os.path.dirname(com.new_file_path_func(\"first\"))\n        version_files = sorted([f for f in os.listdir(p_version_folder_path) if f.endswith(\".blend\")])\n        for i in range(len(version_files)):\n            if len(version_files) == 0:\n                break\n            new_path = os.path.join(p_version_folder_path, version_files[i])\n            list_new_item = bpy.context.window_manager.my_list.add()\n            list_new_item.name = version_files[i]\n            list_new_item.p_version_file_path = new_path", "def auto_start(dummy):\n    prefs = utils_module.prefs()\n    window_manager = bpy.context.window_manager\n    if prefs.auto_start_save:\n        print(\"auto start save\")\n        file_path = fph.create_new_file_path()\n        bpy.ops.wm.save_as_mainfile(filepath=file_path)\n    if prefs.is_enabled:\n        bpy.ops.wm.live_save_message_handler('EXEC_DEFAULT')\n        bpy.ops.wm.user_action_detector('EXEC_DEFAULT')\n    if bpy.context.window_manager.my_addon_props.is_enabled_version:\n        if not bpy.app.timers.is_registered(sv.save_version):\n            bpy.app.timers.register(sv.save_version, first_interval=bpy.context.window_manager.my_addon_props.version_timer, persistent=True)\n\n    if com.file_path_test(\"first\"):\n        p_version_folder_path = os.path.dirname(com.new_file_path_func(\"first\"))\n        version_files = sorted([f for f in os.listdir(p_version_folder_path) if f.endswith(\".blend\")])\n        for i in range(len(version_files)):\n            if len(version_files) == 0:\n                break\n            new_path = os.path.join(p_version_folder_path, version_files[i])\n            list_new_item = bpy.context.window_manager.my_list.add()\n            list_new_item.name = version_files[i]\n            list_new_item.p_version_file_path = new_path", "\n\n\n\n\n"]}
{"filename": "Live_Addon/props/prefs.py", "chunked_list": ["import bpy\nfrom . import preference\nfrom ..utils import file_path\n\n\n\nclass LiveSavePreferences(bpy.types.AddonPreferences):\n    bl_idname = preference.module()\n\n    def update_timer(self, context):\n        wm = context.window_manager\n        operator = wm.operators.get(\"wm.live_save_message_handler\")\n        if operator:\n            wm.event_timer_remove(operator.timer)\n            operator.timer = wm.event_timer_add(self.Timer, window=context.window)\n\n    def update_live_save(self, context):\n        if self.is_enabled:\n            bpy.ops.wm.live_save_message_handler('EXEC_DEFAULT')\n            bpy.ops.wm.user_action_detector('EXEC_DEFAULT')\n\n    Timer: bpy.props.FloatProperty(\n        name=\"Timer\",\n        description=\"A slider for the timers\",\n        default=1.0,\n        min=0.1,\n        max=10.0,\n        soft_min=0.0,\n        soft_max=5.0,\n        step=1,\n        precision=2,\n        update=update_timer\n    )\n\n    is_enabled: bpy.props.BoolProperty(\n        name=\"Enable Live Save\",\n        description=\"Enable or disable Live Save\",\n        default=True,\n        update=update_live_save\n    )\n\n    livesavede: bpy.props.StringProperty(\n        name='Live Save Directory',\n        description='The directory where initial saves will be stored',\n        default=file_path.get_default_path(),\n        subtype='FILE_PATH'\n    )\n\n    background_save: bpy.props.BoolProperty(\n        name=\"Background Save\",\n        description=\"Enable or disable Background Save(when on data lost can happen)\",\n        default=False,\n    )\n\n    dynamic_save: bpy.props.BoolProperty(\n        name=\"Dynamic Save\",\n        description=\"Enable or disable Dynamic Save\",\n        default=True,\n    )\n\n    image_format: bpy.props.EnumProperty(\n        name=\"Image Format\",\n        description=\"Image Format\",\n        items=[\n            ('PNG', 'PNG', ' save images with the PNG format'),\n            ('JPEG', 'JPEG', 'save images with the JPEG format'),\n            ('BMP', 'BMP', 'save images with the BMP format'),\n            ('TARGA', 'TARGA', 'save images with the TARGA format'),\n            ('OPEN_EXR', 'OPEN_EXR', 'save images with the OPEN_EXR format'),\n            ('HDR', 'HDR', 'save images with the HDR format'),\n            ('TIFF', 'TIFF', 'save images with the TIFF format'),\n            ('AVI_JPEG', 'AVI_JPEG', 'save images with the AVI_JPEG format'),\n            ('AVI_RAW', 'AVI_RAW', 'save images with the AVI_RAW format'),\n            ('FRAMESERVER', 'FRAMESERVER', 'save images with the FRAMESERVER format'),\n            ('Cineon', 'Cineon', 'save images with the Cineon format'),\n            ('DPX', 'DPX', 'save images with the DPX format'),\n            ('OpenEXR_MULTILAYER', 'OpenEXR_MULTILAYER', 'save images with the OpenEXR_MULTILAYER format'),\n            ('JP2', 'JP2', 'save images with the JP2 format'),\n            ('IRIS', 'IRIS', 'save images with the IRIS format'),\n            ('J2C', 'J2C', 'save images with the J2C format'),\n            ('webp', 'webp', 'save images with the webp format')\n        ],\n        default='PNG',\n    )\n\n    image_file_path: bpy.props.StringProperty(\n        name='Image File Path',\n        description='The directory where initial saves will be stored',\n        default=file_path.get_default_path(),\n        subtype='FILE_PATH'\n    )\n\n    auto_start_save: bpy.props.BoolProperty(\n        name=\"Auto Start Save\",\n        description=\"Enable or disable Auto Start Save\",\n        default=False,\n    )\n\n    turn_on_off_p_version: bpy.props.BoolProperty(\n        name=\"Turn On/Off P Version\",\n        description=\"Enable or disable Turn On/Off P Version\",\n        default=False,\n    )\n\n    turn_on_off_version: bpy.props.BoolProperty(\n        name=\"Turn On/Off Version\",\n        description=\"Enable or disable Turn On/Off Version\",\n        default=False,\n    )\n\n    def draw(self, context):\n        layout = self.layout\n        layout.prop(self, \"is_enabled\")\n        layout.prop(self, \"Timer\")\n        layout.prop(self, \"livesavede\")\n        layout.prop(self, \"background_save\")\n        layout.prop(self, \"dynamic_save\")\n        layout.prop(self, \"image_format\")\n        layout.prop(self, \"image_file_path\")\n        layout.prop(self, \"auto_start_save\")\n        layout.prop(self, \"turn_on_off_p_version\")\n        layout.prop(self, \"turn_on_off_version\")", ""]}
{"filename": "Live_Addon/props/Live_Addon.py", "chunked_list": ["import bpy\n\nname = __name__.partition(\".\")[0]\n\n\nclass LiveSaveProps(bpy.types.PropertyGroup):\n    addon: bpy.props.StringProperty(\n        name='Live_Addon',\n        description='Live module',\n        default=name,\n    )\n\n    @property\n    def prefs(self) -> bpy.types.AddonPreferences:\n        from .. import props\n\n        return props.preference.prefs()", ""]}
{"filename": "Live_Addon/props/internal_prefs.py", "chunked_list": ["import bpy\nfrom bpy.props import StringProperty\nfrom bpy.types import PropertyGroup\nfrom ..timer import save_version\nfrom .. import utils\nfph = utils.file_path\n\n\nclass MyAddonProperties(bpy.types.PropertyGroup):\n    file_path: bpy.props.StringProperty(\n        name=\"File Path\",\n        description=\"Enter file path\",\n        default=\"Bernd\"\n    )\n\n    file_path_version: bpy.props.StringProperty(\n        name=\"File Path Version\",\n        description=\"Enter file path\",\n        default=\"Bernd\"\n    )\n\n    exec_count: bpy.props.IntProperty(\n        name=\"exec count\",\n        description='The count or the the undo/redo',\n        default=0,\n        step=1\n    )\n\n    mouse_detect: bpy.props.BoolProperty(\n        name=\"Detects mouse click\",\n        description=\"when you release the mouse it will set is to true\",\n        default=False\n    )\n\n    version_timer: bpy.props.FloatProperty(\n        name=\"Timer Version\",\n        description=\"A slider for the timers\",\n        default=1.0,\n        min=1,\n        max=60*60,\n        soft_min=2,\n        soft_max=600,\n        step=1,\n        precision=2,\n        update=save_version.update_version_timer\n    )\n\n    is_enabled_version: bpy.props.BoolProperty(\n        name=\"Enable Version\",\n        description=\"Enable or disable Version\",\n        default=True,\n        update=save_version.update_version_bool\n    )\n\n    version_count: bpy.props.IntProperty(\n        name=\"Version Number\",\n        description='The count of the version',\n        default=1,\n        step=1,\n        min=1\n    )\n\n    p_version_path: bpy.props.StringProperty(\n        name=\"Version Path\",\n        description=\"Enter file path\",\n        default=\"Bernd\"\n    )", "class MyAddonProperties(bpy.types.PropertyGroup):\n    file_path: bpy.props.StringProperty(\n        name=\"File Path\",\n        description=\"Enter file path\",\n        default=\"Bernd\"\n    )\n\n    file_path_version: bpy.props.StringProperty(\n        name=\"File Path Version\",\n        description=\"Enter file path\",\n        default=\"Bernd\"\n    )\n\n    exec_count: bpy.props.IntProperty(\n        name=\"exec count\",\n        description='The count or the the undo/redo',\n        default=0,\n        step=1\n    )\n\n    mouse_detect: bpy.props.BoolProperty(\n        name=\"Detects mouse click\",\n        description=\"when you release the mouse it will set is to true\",\n        default=False\n    )\n\n    version_timer: bpy.props.FloatProperty(\n        name=\"Timer Version\",\n        description=\"A slider for the timers\",\n        default=1.0,\n        min=1,\n        max=60*60,\n        soft_min=2,\n        soft_max=600,\n        step=1,\n        precision=2,\n        update=save_version.update_version_timer\n    )\n\n    is_enabled_version: bpy.props.BoolProperty(\n        name=\"Enable Version\",\n        description=\"Enable or disable Version\",\n        default=True,\n        update=save_version.update_version_bool\n    )\n\n    version_count: bpy.props.IntProperty(\n        name=\"Version Number\",\n        description='The count of the version',\n        default=1,\n        step=1,\n        min=1\n    )\n\n    p_version_path: bpy.props.StringProperty(\n        name=\"Version Path\",\n        description=\"Enter file path\",\n        default=\"Bernd\"\n    )", "\n\nclass ListItem(PropertyGroup):\n    \"\"\"Group of properties representing an item in the list.\"\"\"\n\n    name: StringProperty(\n           name=\"Name\",\n           description=\"A name for this item\",\n           default=\"Untitled\")\n\n    p_version_file_path: StringProperty(\n           name=\"Any other property you want\",\n           description=\"\",\n           default=\"\")", ""]}
{"filename": "Live_Addon/props/__init__.py", "chunked_list": ["import bpy\nfrom . import Live_Addon\nfrom . import prefs\nfrom . import preference\nfrom . import internal_prefs\nfrom ..utils import common\nfrom bpy.props import StringProperty, IntProperty, CollectionProperty\n\n\ndef register():\n    bpy.utils.register_class(Live_Addon.LiveSaveProps)\n    bpy.utils.register_class(prefs.LiveSavePreferences)\n    bpy.utils.register_class(internal_prefs.MyAddonProperties)\n    bpy.utils.register_class(internal_prefs.ListItem)\n\n\n    bpy.types.WindowManager.LiveSave = bpy.props.PointerProperty(type=Live_Addon.LiveSaveProps)\n    bpy.types.WindowManager.my_addon_props = bpy.props.PointerProperty(type=internal_prefs.MyAddonProperties)\n    bpy.types.WindowManager.my_list = CollectionProperty(type=internal_prefs.ListItem)\n    bpy.types.WindowManager.list_index = IntProperty(name=\"Index for my_list\", default=0)", "\ndef register():\n    bpy.utils.register_class(Live_Addon.LiveSaveProps)\n    bpy.utils.register_class(prefs.LiveSavePreferences)\n    bpy.utils.register_class(internal_prefs.MyAddonProperties)\n    bpy.utils.register_class(internal_prefs.ListItem)\n\n\n    bpy.types.WindowManager.LiveSave = bpy.props.PointerProperty(type=Live_Addon.LiveSaveProps)\n    bpy.types.WindowManager.my_addon_props = bpy.props.PointerProperty(type=internal_prefs.MyAddonProperties)\n    bpy.types.WindowManager.my_list = CollectionProperty(type=internal_prefs.ListItem)\n    bpy.types.WindowManager.list_index = IntProperty(name=\"Index for my_list\", default=0)", "\n\n\ndef unregister():\n    del bpy.types.WindowManager.my_list\n    del bpy.types.WindowManager.list_index\n    del bpy.types.WindowManager.my_addon_props\n    del bpy.types.WindowManager.LiveSave\n\n    bpy.utils.unregister_class(internal_prefs.ListItem)\n    bpy.utils.unregister_class(internal_prefs.MyAddonProperties)\n    bpy.utils.unregister_class(prefs.LiveSavePreferences)\n    bpy.utils.unregister_class(Live_Addon.LiveSaveProps)", "\n"]}
{"filename": "Live_Addon/props/preference.py", "chunked_list": ["import bpy\nfrom . import Live_Addon\n\n\ndef module() -> str:\n    return Live_Addon.name\n\n\ndef prefs() -> bpy.types.AddonPreferences:\n    return bpy.context.preferences.addons[module()].preferences", "def prefs() -> bpy.types.AddonPreferences:\n    return bpy.context.preferences.addons[module()].preferences\n"]}
{"filename": "Live_Addon/ui/n_panel.py", "chunked_list": ["import bpy\nimport os\nimport datetime\nfrom .. import props\nfrom .. import utils\n\n\nclass LiveSavePanel(bpy.types.Panel):\n    bl_label = \"Live Save\"\n    bl_idname = \"LIVE_SAVE_PT_panel\"\n    bl_space_type = 'VIEW_3D'\n    bl_region_type = 'UI'\n    bl_category = 'Live Save'\n\n    def draw(self, context):\n        layout = self.layout\n        addon_prefs = props.preference.prefs()\n        myaddonprops = bpy.context.window_manager.my_addon_props\n\n        row = layout.row()\n        row.prop(addon_prefs, \"is_enabled\", text=\"Enable Live Save\")\n\n        row = layout.row()\n        row.prop(addon_prefs, \"background_save\", text=\"Background Save\")\n\n        row = layout.row()\n        row.prop(addon_prefs, \"dynamic_save\", text=\"dynamic Save\")\n\n        layout.separator()\n\n        #only draw when dynamic save is enabled\n        if not addon_prefs.dynamic_save:\n            row = layout.row()\n            row.prop(addon_prefs, \"Timer\", text=\"Timer\")\n\n\n\n            layout.separator()\n\n        layout.operator(\"wm.save_as_mainfile_with_browser\")\n\n        layout.separator()\n\n        if addon_prefs.is_enabled:\n            layout.operator(\"wm.live_save_message_handler\", text=\"Start Live Save\", emboss=False)\n        else:\n            layout.operator(\"wm.live_save_message_handler\", text=\"Stop Live Save\", emboss=False)\n\n        layout.separator()\n        if bpy.data.is_saved:\n            if bpy.data.is_dirty:\n                layout.label(text=\"Edited\", icon='ERROR')\n            elif os.path.exists(bpy.data.filepath):\n                last_save_time = datetime.datetime.fromtimestamp(os.path.getmtime(bpy.data.filepath))\n                layout.label(text=f\"Saved at {last_save_time:%Y-%m-%d %H:%M:%S}\")\n        else:\n            if os.path.exists(bpy.context.window_manager.my_addon_props.file_path):\n                last_save_time = datetime.datetime.fromtimestamp(os.path.getmtime(bpy.context.window_manager.my_addon_props.file_path))\n                layout.label(text=f\"Saved at {last_save_time:%Y-%m-%d %H:%M:%S}\")\n            else:\n                layout.label(text=\"Edited\", icon='ERROR')", ""]}
{"filename": "Live_Addon/ui/__init__.py", "chunked_list": ["import bpy\nfrom . import n_panel\nfrom . import menu_label\nfrom . import p_version_n_panel\nfrom . import version_n_panel\nfrom . import uilist_p_version\n\n\ndef register():\n    bpy.utils.register_class(n_panel.LiveSavePanel)\n    bpy.utils.register_class(menu_label.SaveStatusPanel)\n    bpy.utils.register_class(p_version_n_panel.LiveSavePVersionPanel)\n    bpy.utils.register_class(version_n_panel.LiveSaveVersionPanel)\n    bpy.utils.register_class(uilist_p_version.MY_UL_List)\n    bpy.utils.register_class(uilist_p_version.LIST_OT_NewItem)\n    bpy.utils.register_class(uilist_p_version.LIST_OT_DeleteItem)\n    bpy.utils.register_class(uilist_p_version.OPEN_OT_P_VERSION_INDEX)\n    bpy.types.VIEW3D_MT_editor_menus.append(menu_label.SaveStatusPanel.draw)\n    if bpy.app.timers.is_registered(menu_label.redraw_menu):\n        bpy.app.timers.register(menu_label.redraw_menu, persistent=True, first_interval=1.0)", "def register():\n    bpy.utils.register_class(n_panel.LiveSavePanel)\n    bpy.utils.register_class(menu_label.SaveStatusPanel)\n    bpy.utils.register_class(p_version_n_panel.LiveSavePVersionPanel)\n    bpy.utils.register_class(version_n_panel.LiveSaveVersionPanel)\n    bpy.utils.register_class(uilist_p_version.MY_UL_List)\n    bpy.utils.register_class(uilist_p_version.LIST_OT_NewItem)\n    bpy.utils.register_class(uilist_p_version.LIST_OT_DeleteItem)\n    bpy.utils.register_class(uilist_p_version.OPEN_OT_P_VERSION_INDEX)\n    bpy.types.VIEW3D_MT_editor_menus.append(menu_label.SaveStatusPanel.draw)\n    if bpy.app.timers.is_registered(menu_label.redraw_menu):\n        bpy.app.timers.register(menu_label.redraw_menu, persistent=True, first_interval=1.0)", "\n\ndef unregister():\n    if bpy.app.timers.is_registered(menu_label.redraw_menu):\n        bpy.app.timers.unregister(menu_label.redraw_menu)\n    bpy.types.VIEW3D_MT_editor_menus.remove(menu_label.SaveStatusPanel.draw)\n    bpy.utils.unregister_class(menu_label.SaveStatusPanel)\n    bpy.utils.unregister_class(n_panel.LiveSavePanel)\n    bpy.utils.unregister_class(p_version_n_panel.LiveSavePVersionPanel)\n    bpy.utils.unregister_class(version_n_panel.LiveSaveVersionPanel)\n    bpy.utils.unregister_class(uilist_p_version.MY_UL_List)\n    bpy.utils.unregister_class(uilist_p_version.LIST_OT_NewItem)\n    bpy.utils.unregister_class(uilist_p_version.LIST_OT_DeleteItem)\n    bpy.utils.unregister_class(uilist_p_version.OPEN_OT_P_VERSION_INDEX)", "\n\n"]}
{"filename": "Live_Addon/ui/uilist_p_version.py", "chunked_list": ["import os\n\nimport bpy\nfrom bpy.types import UIList, Operator\n\n\nclass MY_UL_List(UIList):\n    \"\"\"Demo UIList.\"\"\"\n\n    def draw_item(self, context, layout, data, item, icon, active_data,\n                  active_propname, index):\n\n        # We could write some code to decide which icon to use here...\n        custom_icon = 'OBJECT_DATAMODE'\n\n        # Make sure your code supports all 3 layout types\n        if self.layout_type in {'DEFAULT', 'COMPACT'}:\n            layout.label(text=item.name, icon = custom_icon)\n            #layout.operator('my_list.open_p_version_index', text=\"\", icon='GREASEPENCIL')\n\n        elif self.layout_type in {'GRID'}:\n            layout.alignment = 'CENTER'\n            layout.label(text=\"\", icon = custom_icon)", "\n\nclass LIST_OT_NewItem(Operator):\n    \"\"\"Add a new item to the list.\"\"\"\n\n    bl_idname = \"my_list.new_item\"\n    bl_label = \"Add a new item\"\n\n    def execute(self, context):\n        bpy.ops.live_save.save_p_version('EXEC_DEFAULT')\n\n        return{'FINISHED'}", "\n\nclass LIST_OT_DeleteItem(Operator):\n    \"\"\"Delete the selected item from the list.\"\"\"\n\n    bl_idname = \"my_list.delete_item\"\n    bl_label = \"Deletes an item\"\n\n    @classmethod\n    def poll(cls, context):\n        return context.window_manager.my_list\n\n    def execute(self, context):\n        my_list = context.window_manager.my_list\n        index = context.window_manager.list_index\n        if os.path.exists(my_list[index].p_version_file_path):\n            os.remove(my_list[index].p_version_file_path)\n\n        my_list.remove(index)\n        context.window_manager.list_index = min(max(0, index - 1), len(my_list) - 1)\n\n        return{'FINISHED'}", "\n\nclass OPEN_OT_P_VERSION_INDEX(Operator):\n    \"\"\"Open the selected item from the list.\"\"\"\n\n    bl_idname = \"my_list.open_p_version_index\"\n    bl_label = \"Open an item\"\n\n    @classmethod\n    def poll(cls, context):\n        return context.window_manager.my_list\n\n    def execute(self, context):\n        my_list = context.window_manager.my_list\n        index = context.window_manager.list_index\n        if os.path.exists(my_list[index].p_version_file_path):\n            bpy.ops.wm.open_mainfile(filepath=my_list[index].p_version_file_path)\n        else:\n            self.report({'ERROR'}, 'File not found')\n\n        return{'FINISHED'}", "\"\"\"\nclass LIST_OT_MoveItem(Operator):\n    \"\"\"\"Move an item in the list.\"\"\"\"\n\n    bl_idname = \"my_list.move_item\"\n    bl_label = \"Move an item in the list\"\n\n    direction: bpy.props.EnumProperty(items=(('UP', 'Up', \"\"), ('DOWN', 'Down', \"\"),))\n\n    @classmethod", "\n    @classmethod\n    def poll(cls, context):\n        return context.window_manager.my_list\n\n    def move_index(self):\n        \"\"\"\" Move index of an item render queue while clamping it. \"\"\"\"\n\n        index = bpy.context.window_manager.list_index\n        list_length = len(bpy.context.window_manager.my_list) - 1  # (index starts at 0)", "        index = bpy.context.window_manager.list_index\n        list_length = len(bpy.context.window_manager.my_list) - 1  # (index starts at 0)\n        new_index = index + (-1 if self.direction == 'UP' else 1)\n\n        bpy.context.window_manager.list_index = max(0, min(new_index, list_length))\n\n    def execute(self, context):\n        my_list = context.window_manager.my_list\n        index = context.window_manager.list_index\n", "        index = context.window_manager.list_index\n\n        neighbor = index + (-1 if self.direction == 'UP' else 1)\n        my_list.move(neighbor, index)\n        self.move_index()\n\n        return{'FINISHED'}\n\"\"\"\n", ""]}
{"filename": "Live_Addon/ui/menu_label.py", "chunked_list": ["import bpy\nimport os\nimport time\n\n\nclass SaveStatusPanel(bpy.types.Operator):\n    bl_idname = \"wm.save_status_panel\"\n    bl_label = \"Save Status\"\n\n\n    def draw(self, context):\n        layout = self.layout\n\n        # check if file is dirty\n        if bpy.data.is_dirty:\n            row = layout.row(align=True)\n            row.label(text=\"Edited\", icon='ERROR')\n        else:\n            row = layout.row(align=True)\n            row.label(text=\"\", icon='NONE')\n\n    def modal(self, context, event):\n        if event.type in {'ESC'}:\n            wm = context.window_manager\n            wm.event_timer_remove(self._timer)\n            wm.modal_handler_remove(self)\n            return {'CANCELLED'}\n        elif event.type == 'TIMER':\n            if bpy.data.is_dirty:\n                self.tag_redraw()\n            else:\n                self.tag_redraw()\n        return {'PASS_THROUGH'}", "\n\ndef redraw_menu():\n    for area in bpy.context.screen.areas:\n        if area.type == 'VIEW_3D':\n            for region in area.regions:\n                if region.type == 'UI':\n                    region.tag_redraw()\n    return 0.1\n", "\n"]}
{"filename": "Live_Addon/ui/version_n_panel.py", "chunked_list": ["import bpy\nimport os\nimport datetime\nfrom .. import props\nfrom .. import utils\n\n\nclass LiveSaveVersionPanel(bpy.types.Panel):\n    bl_label = \"Version\"\n    bl_idname = \"LIVE_SAVE_VERSION_PT_panel\"\n    bl_space_type = 'VIEW_3D'\n    bl_region_type = 'UI'\n    bl_category = 'Live Save'\n\n    def draw(self, context):\n        layout = self.layout\n        props.preference.prefs()\n        myaddonprops = bpy.context.window_manager.my_addon_props\n\n        bx = layout.box().column()\n        bx.prop(myaddonprops, \"is_enabled_version\", text=\"Enable Version\")\n        col = bx.column()\n        col.enabled = myaddonprops.is_enabled_version\n        col.prop(myaddonprops, \"version_count\", text=\"Versions Count\")\n        col.prop(myaddonprops, \"version_timer\", text=\"Timer Version\")", "\n"]}
{"filename": "Live_Addon/ui/p_version_n_panel.py", "chunked_list": ["import bpy\nimport os\nimport datetime\nfrom .. import props\nfrom .. import utils\n\n\nclass LiveSavePVersionPanel(bpy.types.Panel):\n    bl_label = \"Permenant Version\"\n    bl_idname = \"LIVE_SAVE_P_VERSION_PT_panel\"\n    bl_space_type = 'VIEW_3D'\n    bl_region_type = 'UI'\n    bl_category = 'Live Save'\n\n    def draw(self, context):\n        layout = self.layout\n        addon_prefs = props.preference.prefs()\n        myaddonprops = bpy.context.window_manager.my_addon_props\n        WindowManager = context.window_manager\n\n        if WindowManager.my_list:\n            row = layout.box().column()\n            row.template_list(\"MY_UL_List\", \"The_List\", WindowManager,\n                              \"my_list\", WindowManager, \"list_index\")\n            raw = row.row(align=True)\n            raw.operator('my_list.new_item', text='NEW', icon='ADD')\n            raw.operator('my_list.delete_item', text='REMOVE', icon='REMOVE')\n\n            item = WindowManager.my_list[WindowManager.list_index]\n            row.operator('my_list.open_p_version_index', text=\"\", icon='GREASEPENCIL')\n            #row.prop(item, \"name\")\n\n        bx = layout.box().column()\n        sx = bx.grid_flow(align=True)\n        sx.operator(\"livesave.load_pre\", text=\"\", icon='REW')\n        sx.operator(\"livesave.load_next\", text=\"\", icon='FF')\n        bx.operator(\"live_save.save_p_version\", text=\"Save Permenant Version\")\n        bx = layout.box().column()\n        bx.operator(\"livesave.load_first\", text=\"First Permenant Version\")\n        bx.operator(\"livesave.load_last\", text=\"Last Permenant Version\")\n        bx.operator(\"livesave.load_original\", text=\"Load Original File\")", "        #bx.operator(\"live_save.open_p_version_folder\", text=\"Open Permenant Version Folder\")\n        #bx.operator(\"live_save.delete_p_version\", text=\"Delete Permenant Version\")\n\n\n\n\n"]}
{"filename": "Live_Addon/timer/save_version.py", "chunked_list": ["import re\n\nimport bpy\nimport os\nimport shutil\nfrom .. import utils\nfrom .. import props\nprefs = props.preference.prefs()\n\n\ndef save_version():\n    file_path12 = bpy.context.window_manager.my_addon_props.file_path\n    blend_match = r\"\\.blend\"\n    timestep_regex = r\"\\d{4}\\.\\d{2}\\.\\d{2}_\\d{2}-\\d{2}-\\d{2}\"\n    matched_blend = re.search(blend_match, file_path12)\n    # Get the current Blender file path\n    if bpy.data.is_saved and bpy.data.is_dirty:\n        filepath = bpy.data.filepath\n\n        # Extract the project name without the file extension\n        project_name = os.path.splitext(os.path.basename(filepath))[0]\n\n        # Create the version folder name with the project name and version count\n        version_folder_name = f\"{project_name}_version_folder\"\n\n        # Create the full path for the version folder\n        version_folder_path = os.path.join(os.path.dirname(filepath), version_folder_name)\n\n        # Create the version folder if it doesn't exist\n        if not os.path.exists(version_folder_path):\n            os.makedirs(version_folder_path, exist_ok=True)\n\n    elif not os.path.isdir(file_path12) and matched_blend and os.path.exists(file_path12) and utils.comparison.compare_blend_data():\n\n        version_folder_path = bpy.context.window_manager.my_addon_props.file_path_version\n        # Extract name without the .blender extension but not with os.path.splitext\n        #project_name = os.path.basename(version_folder_path)\n        #create project name without the .blend extension\n        #project_name = project_name[:-15]\n\n        # Create the version folder if it doesn't exist\n        if not os.path.exists(version_folder_path):\n            os.makedirs(version_folder_path, exist_ok=True)\n    else:\n        return bpy.context.window_manager.my_addon_props.version_timer\n\n    # get existing version files and sort by name\n    version_files = sorted([f for f in os.listdir(version_folder_path) if f.endswith(\".blend\")])\n\n    # Delete the oldest version(s) if there are more than three versions\n    if len(version_files) >= bpy.context.window_manager.my_addon_props.version_count:\n        # delete the oldest version files until bpy.context.window_manager.my_addon_props.version_count is reached\n        for i in range(len(version_files) - bpy.context.window_manager.my_addon_props.version_count + 1):\n            os.remove(os.path.join(version_folder_path, version_files[i]))\n    version_files_new = sorted([f for f in os.listdir(version_folder_path) if f.endswith(\".blend\")])\n        # rename existing version files to ensure unique names\n    for i in range(len(version_files_new)):\n        if len(version_files_new) == 0:\n            break\n        elif re.search(timestep_regex, version_files_new[i]):\n            project_name = version_files_new[i].split(\"_v\")[0]\n        old_path = os.path.join(version_folder_path, version_files_new[i])\n        new_name = f\"{project_name}_v{i + 1:03}.blend\"\n        new_path = os.path.join(version_folder_path, new_name)\n        os.rename(old_path, new_path)\n\n    version_count = len(os.listdir(version_folder_path))\n    if re.search(timestep_regex, version_folder_path):\n        # Extract name without the .blender extension but not with os.path.splitext\n        project_name = os.path.basename(version_folder_path)\n        #create project name without the .blend extension\n        project_name = project_name[:-15]\n\n    # Save the current version with a unique file name\n    current_version_name = f\"{project_name}_v{version_count + 1:03d}.blend\"\n    current_version_path = os.path.join(version_folder_path, current_version_name)\n\n    bpy.ops.wm.save_as_mainfile(filepath=current_version_path, copy=True)\n\n    return bpy.context.window_manager.my_addon_props.version_timer", "\n\ndef save_version():\n    file_path12 = bpy.context.window_manager.my_addon_props.file_path\n    blend_match = r\"\\.blend\"\n    timestep_regex = r\"\\d{4}\\.\\d{2}\\.\\d{2}_\\d{2}-\\d{2}-\\d{2}\"\n    matched_blend = re.search(blend_match, file_path12)\n    # Get the current Blender file path\n    if bpy.data.is_saved and bpy.data.is_dirty:\n        filepath = bpy.data.filepath\n\n        # Extract the project name without the file extension\n        project_name = os.path.splitext(os.path.basename(filepath))[0]\n\n        # Create the version folder name with the project name and version count\n        version_folder_name = f\"{project_name}_version_folder\"\n\n        # Create the full path for the version folder\n        version_folder_path = os.path.join(os.path.dirname(filepath), version_folder_name)\n\n        # Create the version folder if it doesn't exist\n        if not os.path.exists(version_folder_path):\n            os.makedirs(version_folder_path, exist_ok=True)\n\n    elif not os.path.isdir(file_path12) and matched_blend and os.path.exists(file_path12) and utils.comparison.compare_blend_data():\n\n        version_folder_path = bpy.context.window_manager.my_addon_props.file_path_version\n        # Extract name without the .blender extension but not with os.path.splitext\n        #project_name = os.path.basename(version_folder_path)\n        #create project name without the .blend extension\n        #project_name = project_name[:-15]\n\n        # Create the version folder if it doesn't exist\n        if not os.path.exists(version_folder_path):\n            os.makedirs(version_folder_path, exist_ok=True)\n    else:\n        return bpy.context.window_manager.my_addon_props.version_timer\n\n    # get existing version files and sort by name\n    version_files = sorted([f for f in os.listdir(version_folder_path) if f.endswith(\".blend\")])\n\n    # Delete the oldest version(s) if there are more than three versions\n    if len(version_files) >= bpy.context.window_manager.my_addon_props.version_count:\n        # delete the oldest version files until bpy.context.window_manager.my_addon_props.version_count is reached\n        for i in range(len(version_files) - bpy.context.window_manager.my_addon_props.version_count + 1):\n            os.remove(os.path.join(version_folder_path, version_files[i]))\n    version_files_new = sorted([f for f in os.listdir(version_folder_path) if f.endswith(\".blend\")])\n        # rename existing version files to ensure unique names\n    for i in range(len(version_files_new)):\n        if len(version_files_new) == 0:\n            break\n        elif re.search(timestep_regex, version_files_new[i]):\n            project_name = version_files_new[i].split(\"_v\")[0]\n        old_path = os.path.join(version_folder_path, version_files_new[i])\n        new_name = f\"{project_name}_v{i + 1:03}.blend\"\n        new_path = os.path.join(version_folder_path, new_name)\n        os.rename(old_path, new_path)\n\n    version_count = len(os.listdir(version_folder_path))\n    if re.search(timestep_regex, version_folder_path):\n        # Extract name without the .blender extension but not with os.path.splitext\n        project_name = os.path.basename(version_folder_path)\n        #create project name without the .blend extension\n        project_name = project_name[:-15]\n\n    # Save the current version with a unique file name\n    current_version_name = f\"{project_name}_v{version_count + 1:03d}.blend\"\n    current_version_path = os.path.join(version_folder_path, current_version_name)\n\n    bpy.ops.wm.save_as_mainfile(filepath=current_version_path, copy=True)\n\n    return bpy.context.window_manager.my_addon_props.version_timer", "\n\ndef update_version_timer(self, context):\n    if bpy.app.timers.is_registered(save_version):\n        bpy.app.timers.unregister(save_version)\n        bpy.app.timers.register(save_version)\n\n\n\ndef update_version_bool(self, context):\n    if self.is_enabled_version:\n        if not bpy.app.timers.is_registered(save_version):\n            bpy.app.timers.register(save_version)\n    else:\n        if bpy.app.timers.is_registered(save_version):\n            bpy.app.timers.unregister(save_version)", "\ndef update_version_bool(self, context):\n    if self.is_enabled_version:\n        if not bpy.app.timers.is_registered(save_version):\n            bpy.app.timers.register(save_version)\n    else:\n        if bpy.app.timers.is_registered(save_version):\n            bpy.app.timers.unregister(save_version)\n", ""]}
{"filename": "Live_Addon/timer/__init__.py", "chunked_list": ["import bpy\nfrom . import save_version\nfrom .. import props\n\n\n\ndef register():\n    if bpy.context.window_manager.my_addon_props.is_enabled_version:\n        if not bpy.app.timers.is_registered(save_version.save_version):\n            interval = bpy.context.window_manager.my_addon_props.version_timer\n            bpy.app.timers.register(save_version.save_version, first_interval=interval, persistent=True)", "\n\ndef unregister():\n    if bpy.app.timers.is_registered(save_version.save_version):\n        bpy.app.timers.unregister(save_version.save_version)\n"]}
