{"filename": "ascension.py", "chunked_list": ["from os import listdir, getcwd\nfrom os.path import isdir, isfile, exists\nfrom json import load, dump\nfrom hsr_client.utils import ImageManipulation as img\nfrom PIL import Image\n\nBASE_CHAR = getcwd()+\"/characters/\"\nBASE_MATERIALS =  getcwd()+\"/materials/\"\nchars = [f for f in listdir(BASE_CHAR) if isfile(BASE_CHAR+f)]\nmaterials = [f for f in listdir(BASE_MATERIALS) if isfile(BASE_MATERIALS+f)]", "chars = [f for f in listdir(BASE_CHAR) if isfile(BASE_CHAR+f)]\nmaterials = [f for f in listdir(BASE_MATERIALS) if isfile(BASE_MATERIALS+f)]\nfrom io import BytesIO\ncards_bg = {\n            'card_5': Image.open(f'{getcwd()}/cards/card_5.webp').convert(\"RGBA\"),\n            'card_3': Image.open(f'{getcwd()}/cards/card_3.webp').convert(\"RGBA\"),\n            'card_4': Image.open(f'{getcwd()}/cards/card_4.webp').convert(\"RGBA\"),\n            'card_2': Image.open(f'{getcwd()}/cards/card_2.webp').convert(\"RGBA\"),\n            'card_1': Image.open(f'{getcwd()}/cards/card_0.webp').convert(\"RGBA\"),\n            'card_0': Image.open(f'{getcwd()}/cards/card_0.webp').convert(\"RGBA\")", "            'card_1': Image.open(f'{getcwd()}/cards/card_0.webp').convert(\"RGBA\"),\n            'card_0': Image.open(f'{getcwd()}/cards/card_0.webp').convert(\"RGBA\")\n        }\n\nfor char in chars:\n    \n\n    name = char.replace(\".json\",\"\",1)\n    if not exists(f\"{getcwd()}/ascension/{name}-ascension.png\"):\n        with open(BASE_CHAR+char, 'r') as f:\n            data = load(f)\n\n\n        costs_dict = {'levels': {}, 'skills': {}}\n\n        items = data['itemReferences']\n        levels = data['levelData']\n\n        for lvl in levels:\n            costs = lvl['cost']\n            print(costs)\n            for c in costs:\n                if str(c['id']) not in costs_dict['levels']:\n                    costs_dict['levels'][str(c['id'])] = c['count']\n                else:\n                    costs_dict['levels'][str(c['id'])] += c['count']\n\n        skills = data['skills']\n\n        for skill in skills:\n            lvls = skill['levelData']\n            for lvl in lvls:\n                costs = lvl['cost']\n                for c in costs:\n                    if str(c['id']) not in costs_dict['skills']:\n                        costs_dict['skills'][str(c['id'])] = c['count']\n                    else:\n                        costs_dict['skills'][str(c['id'])] += c['count']\n\n\n        costs_dict['items'] = items\n        cards = {'levels': [], 'skills': []}\n        with open(\"test.json\", 'w') as f:\n            dump(costs_dict, f, indent=1)\n        for it in ['levels', 'skills']:\n            for item_id in costs_dict[it]:\n                if item_id in costs_dict['items']:            \n            \n                    \n                        with open(f\"{getcwd()}/images/materials/{item_id}-{item_id}-iconpath.png\", 'rb') as f:\n                            \n                            bytes_obj = BytesIO(f.read())\n                        print(cards_bg[f\"card_{costs_dict['items'][str(item_id)]['rarity']}\"])                \n                        cards[it].append({\n                            'card_bg': cards_bg[f\"card_{costs_dict['items'][str(item_id)]['rarity']}\"],\n                            'txt': costs_dict[it][str(item_id)],\n                            'img' : bytes_obj,\n                            'title': costs_dict['items'][str(item_id)]['name']\n                        })\n                \n\n        with open(f\"{getcwd()}/images/characters/{name}-{name}-splashiconpath.png\", \"rb\") as f:\n            bytes_ = BytesIO(f.read())\n        bg_img = Image.open(f\"{getcwd()}/images/characters/{name}-{name}-bgpath.png\", 'r').convert(\"RGBA\")\n        img_ = img.create_image_card(name.title(),bytes_, False ,'Ascension',  0, 0, bg_img)\n\n        max_item = 5\n        start_x = img_.size[0] // 2 - 250\n        start_y = 250   \n        end_x = start_x + (112*5)\n\n        cards_list = cards['levels'] + cards['skills']\n\n        rows = 1\n        for c, card in enumerate(cards_list,1):\n            count_fix = c\n            if c > (rows * max_item):\n                rows += 1\n                count_fix = (c - ((rows-1) * max_item))\n            else:\n                if rows > 1:\n                    count_fix = c - ((rows-1) * max_item)\n                else:\n                    count_fix = c \n            \n            \n            c_img = img.create_card_image(card)\n            x = start_x + (122 * (count_fix - 1)) + 30\n            y = start_y + (145 * (rows - 1))+ 30\n            img_.paste(c_img, (x,y), c_img)\n\n        img_ = img_.crop((0,0, 1600, img_.size[1]))\n        img_ = img.add_corners(img_,45)\n        img_.show()\n\n        img_.save(f\"{getcwd()}/ascension/{name}-ascension.png\")", ""]}
{"filename": "raw_data.py", "chunked_list": ["from main import SRSClient\nfrom hsr_client.constants import Item, Language\nfrom hsr_client.routes import *\nfrom os import getcwd, mkdir\nfrom os.path import exists\n\nfrom json import dump\nfrom time import sleep\n\nfrom pathlib import Path", "\nfrom pathlib import Path\n\nfrom datetime import datetime\n\n\n\nsave_path = f\"{getcwd()}/raw_data\"\nclient = SRSClient()\n", "client = SRSClient()\n\nroutes = {\n    Item.CHARACTER.name : CHARACTERS,\n    Item.PLAYERCARD.name : PLAYERCARDS,\n    Item.FOOD.name : CONSUMABLES,\n    Item.RELIC.name : RELICS,\n    Item.LIGHTCONE.name : LIGHTCONES,\n    Item.BOOK.name : BOOKS,\n    Item.MATERIAL.name : MATERIALS", "    Item.BOOK.name : BOOKS,\n    Item.MATERIAL.name : MATERIALS\n    }\n\nfolders = {\n    Item.CHARACTER.name : 'characters/',\n    Item.PLAYERCARD.name : 'playercards/',\n    Item.FOOD.name : 'foods/',\n    Item.RELIC.name : 'relics/',\n    Item.LIGHTCONE.name : 'lightcones/',", "    Item.RELIC.name : 'relics/',\n    Item.LIGHTCONE.name : 'lightcones/',\n    Item.BOOK.name : 'books/',\n    Item.MATERIAL.name : 'materials/'\n     }\n\ndef create_path(path :str):\n    path_ = Path(f'{save_path}/{path}')\n    if not exists(f'{save_path}/{path}'):\n        path_.mkdir(parents=True)", "    \n\ndef correct_route(url : str):\n   return url.replace('/','s/',1)\n\ndef convert(seconds: int | float):\n    seconds = seconds % (24 * 3600)\n    hour = seconds // 3600\n    seconds %= 3600\n    minutes = seconds // 60\n    seconds %= 60\n     \n    return \"%d:%02d:%02d\" % (hour, minutes, seconds)", "\nSTART_TIME = datetime.now()\n\nlanguage = Language.EN\n\n\n'''\niterate over all languages to get data in all languages\n'''\n", "'''\n\n\n\n#for language in Languages:  \n'''\niterate over all languages to get data in all languages\n'''\n\nentries = client.get_all_items(None, language) # this gets all items that exist in search database of starrailstation.com", "\nentries = client.get_all_items(None, language) # this gets all items that exist in search database of starrailstation.com\n\nfor entry in entries:\n    create_path(f'{language}/{folders[entry.type.name]}')\n    if not exists(f'{save_path}/{language}/{folders[entry.type.name]}/{entry.id}.json'):\n        \n        '''\n        fetches data\n        '''\n        data = client.fetch(language, routes[entry.type.name], True, entry.id)              \n        print(f'[downloading] [Language: {language}]', Item(entry.type).name, entry.name)\n        with open(f'{save_path}/{language}/{folders[entry.type.name]}/{entry.id}.json', 'w') as f:\n            dump(data, f, indent=1)", "\n\nprint(f'[downloading] [Language: {language}]', 'ACHIEVEMENTS')   \ndata = client.fetch(language, ACHIEVEMENTS, False)\nwith open(f'{save_path}/{language}/achievements.json', 'w') as f:\n    dump(data, f, indent=1)\n\n\nprint(f'[downloading] [Language: {language}]', 'SIMULATED UNIVERSE', 'Date', ROUGE_DATE)     \n", "print(f'[downloading] [Language: {language}]', 'SIMULATED UNIVERSE', 'Date', ROUGE_DATE)     \n\ndata = client.fetch(language, ROUGES, False)\nwith open(f'{save_path}/{language}/simulatedUniverse.json', 'w') as f:\n    dump(data, f, indent=1)\n\ngachaConfig = Routes(file='gachaConfig.json', path='')\ndata = client.fetch(language, gachaConfig, False)\nwith open(f'{save_path}/{language}/gachaConfig.json', 'w') as f:\n    dump(data, f, indent=1)", "with open(f'{save_path}/{language}/gachaConfig.json', 'w') as f:\n    dump(data, f, indent=1)\n\nEND_TIME = datetime.now()\nprint(f' [HSR-DATA] download completed in {convert((END_TIME - START_TIME).total_seconds())}')"]}
{"filename": "main.py", "chunked_list": ["from requests_cache import CachedSession\nfrom hsr_client.datamodels.searchItem import *\nfrom hsr_client.datamodels.character import Character\nfrom hsr_client.routes import *\nfrom typing import Union, List, LiteralString\nfrom hsr_client.utils import generate_t, base36encode\nfrom hsr_client.constants import *\nfrom hsr_client.errors import *\n\nfrom json import dump", "\nfrom json import dump\n\nclass SRSClient:\n    '''\n    StarRailStation Website Client\n\n    : initializes the client\n\n\n\n    '''\n    def __init__(self) -> None:\n        \n        self.__session = CachedSession(cache_name='srs.cache', backend='sqlite', expire_after=3600)\n\n        self.__session.headers.update(\n            {'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36 Edg/112.0.1722.68',\n             'referer': 'https://starrailstation.com/'}\n        )\n\n    def generate_hash_route(self, language: Language, route: Routes, goto: bool = False, item_id : Union[int, str]=''):\n        '''\n        \n        :generates hashed route for fetching data\n\n        --\n        params\n        --\n\n        - language: Languages Enum\n             Languages.EN, Languages.RU etc\n        - route: a Routes object\n        - goto: if you want to search in a specific route [True] \n             defaults to False\n        \n        - item_id : id of the item you want to search in a route\n        \n        '''\n\n        if not isinstance(language, Language):\n            raise InvalidLanguage\n        \n        url = route.generate_main_lang_path(language)\n        if goto:\n            if route.path is not None:\n                url = f\"{route.generate_goto_lang_path(language)}{item_id}.json\"            \n\n        hashed_path = base36encode(generate_t(url))\n\n        return  f\"{MAIN_ROUTE}{hashed_path}\"\n\n\n\n\n        \n    \n    def fetch(self, language: Language , route: Routes, goto: bool = False, item_id : Union[int, str] = '') -> List[dict] | dict | None:\n        '''\n        \n        :fetches data from the api route\n        --\n        params\n        --\n\n        - language: Languages Enum\n             Languages.EN, Languages.RU etc\n\n        - route: a Routes object\n\n        - goto: if you want to search in a specific route [True] \n             defaults to False\n        \n        - item_id : id of the item you want to search in a route\n        \n        '''\n\n        if not isinstance(language, Language):\n            raise InvalidLanguage\n\n        response = self.__session.get(self.generate_hash_route(language, route, goto, item_id))\n    \n\n        if response.status_code  < 300:\n            data = response.json()\n            if 'entries' in data:\n                return data['entries']\n            else:\n                return data\n            \n\n    def get_all_items(self,  type: Optional[Item], language: Language = Language.EN) -> list[SearchItem]:\n        '''\n        \n        :fetches all items from api route\n        --\n        params\n        --\n\n        - language: Languages Enum\n             Languages.EN, Languages.RU etc\n        - type : a type object \n             Item.MATERIALS, Item.PLAYERCARDS, Item.CHARACTERS etc\n        \n        \n        '''\n\n        if not isinstance(language, Language):\n            raise InvalidLanguage\n\n        response = self.fetch(language, SEARCH, False)\n\n        if response is not None:\n            all_items = [SearchItem(**{ **d, **{'id': d['url'].split(\"/\")[1]}}) for d in response]\n            if type is not None:\n                return list(filter(lambda x: x.type == type, all_items))\n           \n      \n            return all_items\n        \n        raise Exception('Not enough arguments provided, or nothing is returned from api call!')", "        \n   "]}
{"filename": "hsr_client/hsr_types.py", "chunked_list": ["\n\n\nLevel = int\nCount = int\nSuperimposition = int"]}
{"filename": "hsr_client/errors.py", "chunked_list": ["# define Python user-defined exceptions\nclass InvalidLanguage(Exception):\n    \"Raised when the language is not of type Languages\"\n    pass\n\n\n\nclass InvalidSearchItem(Exception):\n    \"\"\"raised when incorrect searchitem is used.\"\"\"\n    pass", "\n\n\nclass InvalidFilter(Exception):\n    def __init__(self, filters) -> None:\n        super().__init__()\n        self.filters = filters\n        \n\n    def __str__(self) -> str:\n        return f\"Provided parameter doesnot exist in search item, available paramaters for filter [{' ,'.join(self.filters)}]\"", "    \nclass EmptyResponse(Exception):\n    \"\"\"Raised when returned data is empty, 404 response is got\"\"\"\n\nclass BackendError(Exception):\n    \"\"\"\n    Raised when a problem is detected with backend, mostly happens when\n    backend changes , please report such errors\n    \"\"\""]}
{"filename": "hsr_client/__init__.py", "chunked_list": ["from typing import List\nfrom hsr_client.constants import Language, Item\nfrom hsr_client.backend import BackendAdapter\nfrom hsr_client import datamodels as models\nfrom hsr_client.datamodels.chara import Character\nfrom hsr_client.datamodels.lightcone import Lightcone\nfrom hsr_client.datamodels.searchItem import SearchItem\n\n\n# Public facing api client.\nclass HsrClient:\n    def __init__(self):\n        # abstract away multiple backends. with a single backend adapter.\n        # i guess this is too much.\n        # just using SRSBackend here would have been enough.\n        self.adapter = BackendAdapter()\n\n    # # our own api related logic goes here\n    # # in this case, looping and searching.\n    # # here we have the convinience of working with our own data models. (ex: Trace)\n    # def find_trace(self, trace_name) -> models.trace.Trace:\n    #     # for trace in self.adapter().fetch_traces():\n    #     #     if trace.name  == trace_name:\n    #     #         return\n    #     ...\n\n    # def get_character(self, chara_name) -> models.chara.Character:\n    #     # nothing else to do here.\n    #     return self.adapter().get_character(chara_name)\n\n    def get_lightcone(self, name=None, searchItem=None) -> Lightcone:\n        \"\"\"\n        get lightcone by name or with SearchItem\n        \"\"\"\n\n        if name is not None:\n            return self.adapter().get_lightcone_by_name(name)\n        elif searchItem is not None:\n            return self.adapter().resolve_lightcone(searchItem)\n        else:\n            raise Exception(\"either name or searchItem is necessary\")\n\n\n    def get_character(self, name=None, searchItem=None) -> Character:\n        \"\"\"\n        Get Character by name or `SearchItem`\n        \"\"\"\n        if name is not None:\n            return self.adapter().get_character_by_name(name)\n        elif searchItem is not None:\n            return self.adapter().resolve_character(searchItem)\n        else:\n            raise Exception(\"either name or searchItem is necessary\")\n\n\n    def search_item(\n        self,\n        item_type: Item,\n        filter=None\n    ) -> List[SearchItem]:\n        return self.adapter().search_item(item_type)", "\n# Public facing api client.\nclass HsrClient:\n    def __init__(self):\n        # abstract away multiple backends. with a single backend adapter.\n        # i guess this is too much.\n        # just using SRSBackend here would have been enough.\n        self.adapter = BackendAdapter()\n\n    # # our own api related logic goes here\n    # # in this case, looping and searching.\n    # # here we have the convinience of working with our own data models. (ex: Trace)\n    # def find_trace(self, trace_name) -> models.trace.Trace:\n    #     # for trace in self.adapter().fetch_traces():\n    #     #     if trace.name  == trace_name:\n    #     #         return\n    #     ...\n\n    # def get_character(self, chara_name) -> models.chara.Character:\n    #     # nothing else to do here.\n    #     return self.adapter().get_character(chara_name)\n\n    def get_lightcone(self, name=None, searchItem=None) -> Lightcone:\n        \"\"\"\n        get lightcone by name or with SearchItem\n        \"\"\"\n\n        if name is not None:\n            return self.adapter().get_lightcone_by_name(name)\n        elif searchItem is not None:\n            return self.adapter().resolve_lightcone(searchItem)\n        else:\n            raise Exception(\"either name or searchItem is necessary\")\n\n\n    def get_character(self, name=None, searchItem=None) -> Character:\n        \"\"\"\n        Get Character by name or `SearchItem`\n        \"\"\"\n        if name is not None:\n            return self.adapter().get_character_by_name(name)\n        elif searchItem is not None:\n            return self.adapter().resolve_character(searchItem)\n        else:\n            raise Exception(\"either name or searchItem is necessary\")\n\n\n    def search_item(\n        self,\n        item_type: Item,\n        filter=None\n    ) -> List[SearchItem]:\n        return self.adapter().search_item(item_type)", "\n\nif __name__ == \"__main__\":\n    client = HsrClient()\n    print(client.get_lightcone(name=\"Arrows\"))\n    print(\"--\" * 50)\n    print(client.search_item(Item.CHARACTER))\n    print(\"--\" * 50)\n    chara = client.get_character(name=\"March 7th\")\n    print(chara)\n    print(\"--\" * 50)\n    print(chara.stats(level=72))\n    \n    print(\"--\" * 50)\n    print(chara.ascension_mats())\n\n    \n    print(\"--\" * 50)\n\n    print(chara.skills()[0].scaling[1].description)"]}
{"filename": "hsr_client/utils.py", "chunked_list": ["\nfrom __future__ import annotations\n\nfrom hsr_client.errors import InvalidFilter\n\nfrom typing import Any, Union\nimport inspect\nfrom datetime import date, timedelta, datetime\nimport calendar\n", "import calendar\n\n\n\ndef generate_t(input):\n    t = 0\n\n    for n in range(len(input)):\n        t = (t << 5) -t + list(bytes(input, encoding=\"utf8\"))[n]\n        t = t & t\n    t = t % (2**32) \n    return t", "\ndef base36encode(number):\n    if not isinstance(number, int):\n        raise TypeError('number must be an integer')\n    is_negative = number < 0\n    number = abs(number)\n\n    alphabet, base36 = ['0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ', '']\n\n    while number:\n        number, i = divmod(number, 36)\n        base36 = alphabet[i] + base36\n    if is_negative:\n        base36 = '-' + base36\n\n    return base36.lower() or alphabet[0].lower()", "\ndef check(model, attribute : str, value : Union[str, bool, int]):\n    \"\"\"checks in a model for attribute and returns it if attributes matches the value given\n    to be used for \n\n    Args:\n        model (SearchItem): SearchItem model\n        attribute (str): attribute of searchItem\n        value (Union[str, bool, int]): value to match\n\n    Raises:\n        InvalidFilter: raised when provided attribute [filter] doesnot exist in search item\n\n    Returns:\n        SearchItem: \n    \"\"\"    \n    \n    from hsr_client.datamodels.searchItem import SearchItem\n    model : SearchItem\n    if hasattr(model, attribute):\n\n\n        if isinstance(model.__getattribute__(attribute), str):\n            if value.lower() in model.__getattribute__(attribute).lower():\n                return model\n        \n        if value == model.__getattribute__(attribute):\n            return model\n    \n    raise InvalidFilter(model.available_filters())", "        \n\n\n\n\n\n\n\n\n", "\n\n\n\ndef get_weekday(date : date):\n\n    return calendar.weekday(date.year, date.month, date.day)\n\n    \ndef get_monday(date : date):\n    return date - timedelta(days=get_weekday(date))", "    \ndef get_monday(date : date):\n    return date - timedelta(days=get_weekday(date))\n\n\n\ndef logc(*msg):\n    stack = inspect.stack()\n    class_name = stack[1][0].f_locals[\"self\"].__class__.__name__\n    print(f\"[{class_name}] at [{datetime.now().strftime('%c')}] - \", *msg)", "\n\n\n\n\n                        \n\n"]}
{"filename": "hsr_client/constants.py", "chunked_list": ["from enum import Enum, IntEnum\n\n\nO_VALUE = \"831f36f73549d1d18a12937d98be4c56\"\nclass Item(IntEnum):\n    \"\"\"\n    Search Item types\n\n    \"\"\"\n\n    CHARACTER = 0\n    LIGHTCONE = 1\n    RELIC = 2\n    BOOK = 3\n    MATERIAL = 4\n    PLAYERCARD = 5\n    FOOD = 6\n\n    def __str__(self) -> int:\n        return self.value", "\n\nclass Language(str, Enum):\n    \"\"\"\n\n    Allowed languages\n    \"\"\"\n\n    EN = \"en\"\n    CN = \"cn\"\n    DE = \"de\"\n    ES = \"es\"\n    FR = \"fr\"\n    ID = \"id\"\n    JP = \"jp\"\n    KR = \"kr\"\n    PT = \"pt\"\n    RU = \"ru\"\n    TH = \"th\"\n\n    def __str__(self) -> str:\n        return str(self.value)", "\n\nclass _RelicTypes(str, Enum):\n    \"\"\"\n    Relic Types\n    \"\"\"\n\n    BODY = \"Body\"\n    FEET = \"Feet\"\n    PLANAR_SPHERE = \"Planar Sphere\"\n    LINK_ROPE = \"Link Rope\"\n    HANDS = \"Hands\"\n\n    def __str__(self) -> str:\n        return str(self.value)", "\n\nclass MaterialTypes(int, Enum):\n    \"\"\"\n    Material Types   \n    \"\"\"\n\n    CHARACTER_EXP_MATERIALS = 1\n    CHARACTER_ASCENSION_MATERIALS = 2\n    TRACE_MATERIAL_LIGHTCONE_ASCENSION_MATERIALS = 3    \n    TRACE_MATERIALS = 4\n    LIGHTCONE_EXP_MATERIALS = 5\n    RELIC_EXP_MATERIALS = 6\n    TRACE_MATERIAL_CHARACTER_ASCENSION_MATERIALS = 7\n    WARP_ITEM = 8\n    LIMITED_WARP_ITEM = 9\n    CONSUMABLES = 10\n    COMMON_CURRENCY = 11\n    RARE_CURRENCY = 12\n    WORLD_CURRECNY = 13\n    VALUABE_OBJECT = 14\n    RELIC_COFFRET = 15\n    SYNTHESIS_MATERIAL = 17\n    RECIPE = 17", ""]}
{"filename": "hsr_client/paths.py", "chunked_list": ["from enum import Enum\n\nclass Path(Enum):\n    HARMONY = \"Applies buffs to allies to improve team's combat capabilities\"\n    DESTRUCTION = \"Deals outstanding amounts of damage and possesses great survivability. Suitable for various combat scenarios\"\n    HUNT = \"Deals extraordinary amounts of single-target damage The main damage dealer against Elite Enemies\"\n    ERUDITION = \"Deals remarkable amounts of multi-target damage. The main damage dealer against group of enemies\"\n    NIHILITY = \"Applies debuffs to enemies to reduce their combat capabilities\"\n    PRESERVATION = \"Possesses powerful defensive abilities to protect allies in various ways\"\n    ABUNDANCE = \"Heals allies and restores HP to them.\"\n\n    def describe(self):\n        return self.value", "\nif __name__ == \"__main__\":\n    path = Path.HARMONY\n    print(path.describe())"]}
{"filename": "hsr_client/routes.py", "chunked_list": ["\nfrom hsr_client.constants import O_VALUE\nfrom datetime import datetime, date\nfrom hsr_client.utils import get_monday\n\nMAIN_ROUTE = f'https://starrailstation.com/api/v1/data/{O_VALUE}/'\nIMAGE_ROUTE = 'https://starrailstation.com/assets/{assetId}.webp'\nAUDIO_ROUTE = 'https://starrailstation.com/assets/{assetId}.mp3'\n\n\nclass Routes:\n    '''\n    This class is meant to convert json files\n    to routes for navigating or going to specific Item\n\n    ---\n    example:\n    ---\n    \n    - main path is en/characters.json\n    - goto path is en/characters/id.json\n    \n    '''\n\n    def __init__(self, file: str, path: str = '') -> None:\n        self.file = file\n        self.path = path\n\n        if self.path == '':\n            self.path = f\"{file.replace('.json','/',1)}\"    \n\n    def generate_goto_lang_path(self, lang: str):\n        return f'{lang}/{self.path}'\n\n    def generate_main_lang_path(self, lang: str):\n        return f\"{lang}/{self.file}\"", "\n\nclass Routes:\n    '''\n    This class is meant to convert json files\n    to routes for navigating or going to specific Item\n\n    ---\n    example:\n    ---\n    \n    - main path is en/characters.json\n    - goto path is en/characters/id.json\n    \n    '''\n\n    def __init__(self, file: str, path: str = '') -> None:\n        self.file = file\n        self.path = path\n\n        if self.path == '':\n            self.path = f\"{file.replace('.json','/',1)}\"    \n\n    def generate_goto_lang_path(self, lang: str):\n        return f'{lang}/{self.path}'\n\n    def generate_main_lang_path(self, lang: str):\n        return f\"{lang}/{self.file}\"", "\n\nSEARCH = Routes(file='searchItems.json', path='materials/')\nCHARACTERS = Routes(file='characters.json')\nEQUIPMENT = Routes(file='equipment.json', path='materials/')\nRELICS = Routes(file='relics.json')\nMATERIALS = Routes(file='materials.json')\nBOOKS = Routes('books.json')\nCONSUMABLES = Routes('foods.json', path='materials/')\nPLAYERCARDS = Routes('playercards.json', path='materials/')", "CONSUMABLES = Routes('foods.json', path='materials/')\nPLAYERCARDS = Routes('playercards.json', path='materials/')\nLIGHTCONES = Routes('lightcones.json')\nACHIEVEMENTS = Routes(file='achievements.json', path=None)\n\n'''\nnot month safe calculation for now\n\n'''\nCURRENT_DATE  = datetime.now().date()", "'''\nCURRENT_DATE  = datetime.now().date()\nROUGE_DATE =  get_monday(CURRENT_DATE)\n\n\nROUGES = Routes(file=f'rogue/{str(ROUGE_DATE)}.json', path=f'rogue/{str(ROUGE_DATE)}.json') #idk site has rogue spelling\n\n"]}
{"filename": "hsr_client/backend/__init__.py", "chunked_list": ["from typing import Union\nfrom hsr_client.backend.hoyo_backend import HoyoBackend\nfrom .util import Backend\n\nfrom .srs_backend import SRSBackend\n\nfrom requests_cache import CachedSession\n\nclass BackendAdapter():\n    def __init__(self):\n        self.backends = {\n            SRSBackend: SRSBackend(),\n        }\n\n\n    def __call__(self, adapter_name=SRSBackend) -> Union[SRSBackend, HoyoBackend]:\n        \"\"\"allows us to  access backend directly via `client.adapter().backend_method()`\n        instead of `client.adapter.backends[SRSBackend].backend_method()` or\n        something like `client.adapter.default_backend.backend_method()` or \"\"\"\n        return self.backends[adapter_name]", "class BackendAdapter():\n    def __init__(self):\n        self.backends = {\n            SRSBackend: SRSBackend(),\n        }\n\n\n    def __call__(self, adapter_name=SRSBackend) -> Union[SRSBackend, HoyoBackend]:\n        \"\"\"allows us to  access backend directly via `client.adapter().backend_method()`\n        instead of `client.adapter.backends[SRSBackend].backend_method()` or\n        something like `client.adapter.default_backend.backend_method()` or \"\"\"\n        return self.backends[adapter_name]", "\n"]}
{"filename": "hsr_client/backend/util.py", "chunked_list": ["# for VS Code intellisense only.\nfrom typing import List\nimport hsr_client.datamodels as models\nfrom requests_cache import CachedSession\n\nclass Backend():\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.session = CachedSession(\n                                    cache_name='hsr.cache',\n                                    backend='sqlite',\n                                    expire_after=3600)\n        \n        self.session.headers.update(\n            {\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/113.0\"\n            }\n   \n        )", ""]}
{"filename": "hsr_client/backend/srs_backend/__init__.py", "chunked_list": ["import json\nfrom typing import List, Union, Optional, Literal\nfrom requests_cache import CachedSession\n\nfrom hsr_client.backend.srs_backend.parsers.material import parse_material\n\nfrom hsr_client.constants import Language, Item\nfrom hsr_client.datamodels import chara\nfrom hsr_client.datamodels.chara import Character\nfrom hsr_client.datamodels.lightcone import Lightcone", "from hsr_client.datamodels.chara import Character\nfrom hsr_client.datamodels.lightcone import Lightcone\nfrom hsr_client.datamodels.searchItem import SearchItem\nfrom hsr_client.datamodels.material import Material\n\nfrom hsr_client.errors import InvalidLanguage, InvalidSearchItem, EmptyResponse\nfrom hsr_client import routes\nfrom hsr_client.utils import base36encode, generate_t, check\nfrom hsr_client.backend.util import Backend\nimport hsr_client.datamodels as models", "from hsr_client.backend.util import Backend\nimport hsr_client.datamodels as models\n\n\n\nroute_mapping = {\n    Item.CHARACTER: routes.CHARACTERS,\n    Item.PLAYERCARD: routes.PLAYERCARDS,\n    Item.FOOD: routes.CONSUMABLES,\n    Item.RELIC: routes.RELICS,", "    Item.FOOD: routes.CONSUMABLES,\n    Item.RELIC: routes.RELICS,\n    Item.LIGHTCONE: routes.LIGHTCONES,\n    Item.BOOK: routes.BOOKS,\n    Item.MATERIAL: routes.MATERIALS,\n}\n\n\n# backend for starrail station.\nclass SRSBackend(Backend):\n    def __init__(self) -> None:\n        super().__init__()\n        # self.session = CachedSession(cache_name='srs.cache', backend='sqlite', expire_after=3600)\n\n    def generate_hash_route(\n        self,\n        language: Language,\n        route: routes.Routes,\n        goto: bool = False,\n        item_id: Union[int, str] = \"\",\n    ):\n        \"\"\"\n\n        :generates hashed route for fetching data\n\n        --\n        params\n        --\n\n        - language: Languages Enum\n             Languages.ENG, Languages.RU etc\n        - route: a Routes object\n        - goto: if you want to search in a specific route [True]\n             defaults to False\n\n        - item_id : id of the item you want to search in a route\n\n        \"\"\"\n\n        if not isinstance(language, Language):\n            raise InvalidLanguage\n\n        url = route.generate_main_lang_path(language)\n        if goto:\n            if route.path is not None:\n                url = f\"{route.generate_goto_lang_path(language)}{item_id}.json\"\n\n        hashed_path = base36encode(generate_t(url))\n\n        return f\"{routes.MAIN_ROUTE}{hashed_path}\"\n\n    def __fetch(\n        self,\n        language: Language,\n        route: routes.Routes,\n        goto: bool = False,\n        item_id: Union[int, str] = \"\",\n    ) -> List[dict] | dict | None:\n        \"\"\"\n\n        :fetches data from the api route\n        --\n        params\n        --\n\n        - language: Languages Enum\n             Languages.EN, Languages.RU etc\n\n        - route: a Routes object\n\n        - goto: if you want to search in a specific route [True]\n             defaults to False\n\n        - item_id : id of the item you want to search in a route\n\n        \"\"\"\n\n        if not isinstance(language, Language):\n            raise InvalidLanguage\n\n        self.session.headers.update({\"referer\": \"https://starrailstation.com/\"})\n\n        response = self.session.get(\n            self.generate_hash_route(language, route, goto, item_id)\n        )\n\n        if response.status_code < 300:\n            data = response.json()\n            if \"entries\" in data:\n                return data[\"entries\"]\n            else:\n                return data\n\n    def search_item(\n        self, item_type: Optional[Item] = None, \n        language: Language = Language.EN\n        ) -> list[SearchItem]:\n        \"\"\"\n\n        :fetches all items from api route\n        --\n        params\n        --\n\n        - language: Languages Enum\n            Languages.EN, Languages.RU etc\n        - type : a type object\n            Item.MATERIALS, Item.PLAYERCARDS, Item.CHARACTERS etc\n\n\n        \"\"\"\n\n        if not isinstance(language, Language):\n            raise InvalidLanguage\n\n        response = self.__fetch(language, routes.SEARCH, False)\n\n        if response is not None:\n            all_items = [\n                SearchItem(\n                    **{\n                        **d,\n                        **{\"id\": d[\"url\"].split(\"/\")[1]},\n                        \"iconPath\": routes.IMAGE_ROUTE.format(assetId=d[\"iconPath\"]),\n                    }\n                )\n                for d in response\n            ]\n            if item_type is not None:\n                return list(filter(lambda x: x.type == item_type, all_items))\n\n            return all_items\n        else:\n            raise EmptyResponse\n\n    # TODO: fix this: what if searchitem was result of a search with different language\n    # thatn the language passed to this function. maybe language can be a part of\n    # the class itself. and fetch would simply use that language.\n    # also jsut to prevent backend changing language in the middle of a function with\n    # multi api calls. data structures involved in these cross api calls should also\n    # have the language attribute as part of them. (stuff liek SearchItem)\n    # or maybe even models?\n\n    def resolve_lightcone(\n        self, search_item: SearchItem, \n        language: Language = Language.EN\n        ) -> Lightcone:\n        \"\"\"get details of a light cone\n\n        Args:\n            item (SearchItem): SearchItem of Lightcone type.\n            language (Languages, optional):  Defaults to Languages.EN.\n\n        Raises:\n            InvalidItemType: if SearchItem is not of Lightcone Type\n            InvalidSearchItem: if item is not a SearchItem\n        Returns:\n            Lightcone: Lightcone object\n        \"\"\"\n        from hsr_client.backend.srs_backend.parsers.lightcone import parse_lightcone\n\n        if isinstance(search_item, SearchItem):\n            if search_item.type != Item.LIGHTCONE:\n                raise InvalidSearchItem(\n                    \"Expected Type.LIGHTCONES, found: \" + str(search_item.type)\n                )\n\n            response = self.__fetch(language, routes.LIGHTCONES, True, search_item.id)\n            if response is not None:\n                return parse_lightcone(response, self)\n            else:\n                raise EmptyResponse\n\n        else:\n            raise TypeError(\"provided argument is not a `SearchItem`\")\n\n\n    def resolve_character(\n        self, search_item: SearchItem, \n        language: Language = Language.EN\n        ) :\n        # unimplemented\n        pass\n\n    def get_lightcone_by_name(\n        self, name: str,\n        language: Language = Language.EN\n        ) -> Lightcone:\n        \"\"\"Gets lightcone by name\n\n        Args:\n            name (str): name of the lightcone\n            language (Languages, optional): Defaults to Languages.EN.\n\n        Returns:\n            Lightcone:\n        \"\"\"\n        lightcones = self.search_item(Item.LIGHTCONE)\n\n        for lightcone in lightcones:\n            # use check to filter search item\n            item = check(lightcone, \"name\", name)\n            if item is not None:\n                return self.resolve_lightcone(item)\n   \n        '''\n        Function with declared type of \"Lightcone\" must return value on all code paths\n        Type \"None\" cannot be assigned to type \"Lightcone\"\n        '''\n        #TODO: fix this typing issue \n        raise EmptyResponse\n\n\n    def get_character_by_name(\n        self, name: str, \n        language: Language = Language.EN\n        ) -> Character:\n        \"\"\"Gets lightcone by name\n\n        Args:\n            name (str): name of the lightcone\n            language (Language, optional): Defaults to Language.EN.\n\n        Returns:\n            Character:\n        \"\"\"\n        with open(\"tests/data/character.json\") as f:\n            character_raw = json.load(f)\n\n        from .parsers.character import parse_character\n        character = parse_character(character_raw, self)\n\n\n        return character\n     \n\n    def resolve_material(\n            self, search_item : SearchItem,\n            language : Language = Language.EN\n        ) -> Material:\n        \"\"\"get details of a Material\n\n        Args:\n            item (SearchItem): SearchItem of Material type.\n            language (Languages, optional):  Defaults to Languages.EN.\n\n        Raises:\n            InvalidItemType: if SearchItem is not of Material Type\n            InvalidSearchItem: if item is not a SearchItem\n        Returns:\n            Material : Material object\n        \"\"\"\n\n        if isinstance(search_item, SearchItem):\n            if search_item.type != Item.MATERIAL:\n                raise InvalidSearchItem(\n                    \"Expected Item.MATERIAL, found: \" + str(search_item.type)\n                )\n\n            response = self.__fetch(language, routes.MATERIALS, True, search_item.id)\n            if response is not None:\n                return parse_material(response, self)\n            else:\n                raise EmptyResponse\n\n        else:\n            raise TypeError(\"provided argument is not a `SearchItem`\")", "# backend for starrail station.\nclass SRSBackend(Backend):\n    def __init__(self) -> None:\n        super().__init__()\n        # self.session = CachedSession(cache_name='srs.cache', backend='sqlite', expire_after=3600)\n\n    def generate_hash_route(\n        self,\n        language: Language,\n        route: routes.Routes,\n        goto: bool = False,\n        item_id: Union[int, str] = \"\",\n    ):\n        \"\"\"\n\n        :generates hashed route for fetching data\n\n        --\n        params\n        --\n\n        - language: Languages Enum\n             Languages.ENG, Languages.RU etc\n        - route: a Routes object\n        - goto: if you want to search in a specific route [True]\n             defaults to False\n\n        - item_id : id of the item you want to search in a route\n\n        \"\"\"\n\n        if not isinstance(language, Language):\n            raise InvalidLanguage\n\n        url = route.generate_main_lang_path(language)\n        if goto:\n            if route.path is not None:\n                url = f\"{route.generate_goto_lang_path(language)}{item_id}.json\"\n\n        hashed_path = base36encode(generate_t(url))\n\n        return f\"{routes.MAIN_ROUTE}{hashed_path}\"\n\n    def __fetch(\n        self,\n        language: Language,\n        route: routes.Routes,\n        goto: bool = False,\n        item_id: Union[int, str] = \"\",\n    ) -> List[dict] | dict | None:\n        \"\"\"\n\n        :fetches data from the api route\n        --\n        params\n        --\n\n        - language: Languages Enum\n             Languages.EN, Languages.RU etc\n\n        - route: a Routes object\n\n        - goto: if you want to search in a specific route [True]\n             defaults to False\n\n        - item_id : id of the item you want to search in a route\n\n        \"\"\"\n\n        if not isinstance(language, Language):\n            raise InvalidLanguage\n\n        self.session.headers.update({\"referer\": \"https://starrailstation.com/\"})\n\n        response = self.session.get(\n            self.generate_hash_route(language, route, goto, item_id)\n        )\n\n        if response.status_code < 300:\n            data = response.json()\n            if \"entries\" in data:\n                return data[\"entries\"]\n            else:\n                return data\n\n    def search_item(\n        self, item_type: Optional[Item] = None, \n        language: Language = Language.EN\n        ) -> list[SearchItem]:\n        \"\"\"\n\n        :fetches all items from api route\n        --\n        params\n        --\n\n        - language: Languages Enum\n            Languages.EN, Languages.RU etc\n        - type : a type object\n            Item.MATERIALS, Item.PLAYERCARDS, Item.CHARACTERS etc\n\n\n        \"\"\"\n\n        if not isinstance(language, Language):\n            raise InvalidLanguage\n\n        response = self.__fetch(language, routes.SEARCH, False)\n\n        if response is not None:\n            all_items = [\n                SearchItem(\n                    **{\n                        **d,\n                        **{\"id\": d[\"url\"].split(\"/\")[1]},\n                        \"iconPath\": routes.IMAGE_ROUTE.format(assetId=d[\"iconPath\"]),\n                    }\n                )\n                for d in response\n            ]\n            if item_type is not None:\n                return list(filter(lambda x: x.type == item_type, all_items))\n\n            return all_items\n        else:\n            raise EmptyResponse\n\n    # TODO: fix this: what if searchitem was result of a search with different language\n    # thatn the language passed to this function. maybe language can be a part of\n    # the class itself. and fetch would simply use that language.\n    # also jsut to prevent backend changing language in the middle of a function with\n    # multi api calls. data structures involved in these cross api calls should also\n    # have the language attribute as part of them. (stuff liek SearchItem)\n    # or maybe even models?\n\n    def resolve_lightcone(\n        self, search_item: SearchItem, \n        language: Language = Language.EN\n        ) -> Lightcone:\n        \"\"\"get details of a light cone\n\n        Args:\n            item (SearchItem): SearchItem of Lightcone type.\n            language (Languages, optional):  Defaults to Languages.EN.\n\n        Raises:\n            InvalidItemType: if SearchItem is not of Lightcone Type\n            InvalidSearchItem: if item is not a SearchItem\n        Returns:\n            Lightcone: Lightcone object\n        \"\"\"\n        from hsr_client.backend.srs_backend.parsers.lightcone import parse_lightcone\n\n        if isinstance(search_item, SearchItem):\n            if search_item.type != Item.LIGHTCONE:\n                raise InvalidSearchItem(\n                    \"Expected Type.LIGHTCONES, found: \" + str(search_item.type)\n                )\n\n            response = self.__fetch(language, routes.LIGHTCONES, True, search_item.id)\n            if response is not None:\n                return parse_lightcone(response, self)\n            else:\n                raise EmptyResponse\n\n        else:\n            raise TypeError(\"provided argument is not a `SearchItem`\")\n\n\n    def resolve_character(\n        self, search_item: SearchItem, \n        language: Language = Language.EN\n        ) :\n        # unimplemented\n        pass\n\n    def get_lightcone_by_name(\n        self, name: str,\n        language: Language = Language.EN\n        ) -> Lightcone:\n        \"\"\"Gets lightcone by name\n\n        Args:\n            name (str): name of the lightcone\n            language (Languages, optional): Defaults to Languages.EN.\n\n        Returns:\n            Lightcone:\n        \"\"\"\n        lightcones = self.search_item(Item.LIGHTCONE)\n\n        for lightcone in lightcones:\n            # use check to filter search item\n            item = check(lightcone, \"name\", name)\n            if item is not None:\n                return self.resolve_lightcone(item)\n   \n        '''\n        Function with declared type of \"Lightcone\" must return value on all code paths\n        Type \"None\" cannot be assigned to type \"Lightcone\"\n        '''\n        #TODO: fix this typing issue \n        raise EmptyResponse\n\n\n    def get_character_by_name(\n        self, name: str, \n        language: Language = Language.EN\n        ) -> Character:\n        \"\"\"Gets lightcone by name\n\n        Args:\n            name (str): name of the lightcone\n            language (Language, optional): Defaults to Language.EN.\n\n        Returns:\n            Character:\n        \"\"\"\n        with open(\"tests/data/character.json\") as f:\n            character_raw = json.load(f)\n\n        from .parsers.character import parse_character\n        character = parse_character(character_raw, self)\n\n\n        return character\n     \n\n    def resolve_material(\n            self, search_item : SearchItem,\n            language : Language = Language.EN\n        ) -> Material:\n        \"\"\"get details of a Material\n\n        Args:\n            item (SearchItem): SearchItem of Material type.\n            language (Languages, optional):  Defaults to Languages.EN.\n\n        Raises:\n            InvalidItemType: if SearchItem is not of Material Type\n            InvalidSearchItem: if item is not a SearchItem\n        Returns:\n            Material : Material object\n        \"\"\"\n\n        if isinstance(search_item, SearchItem):\n            if search_item.type != Item.MATERIAL:\n                raise InvalidSearchItem(\n                    \"Expected Item.MATERIAL, found: \" + str(search_item.type)\n                )\n\n            response = self.__fetch(language, routes.MATERIALS, True, search_item.id)\n            if response is not None:\n                return parse_material(response, self)\n            else:\n                raise EmptyResponse\n\n        else:\n            raise TypeError(\"provided argument is not a `SearchItem`\")", "        "]}
{"filename": "hsr_client/backend/srs_backend/parsers/lightcone.py", "chunked_list": ["from hsr_client.datamodels.lightcone import MaterialCount, Lightcone\nfrom hsr_client.datamodels.material import Material\nfrom hsr_client.datamodels.searchItem import SearchItem\nfrom hsr_client.constants import Item\n\nfrom hsr_client.paths import Path\nfrom hsr_client.constants import MaterialTypes\nfrom hsr_client.backend.srs_backend import SRSBackend\n\nfrom bs4 import BeautifulSoup", "\nfrom bs4 import BeautifulSoup\n\n\ndef parse_lightcone(raw_data, be: SRSBackend) -> Lightcone:\n    # name\n    lc_name = raw_data[\"name\"]\n    # rarity\n    lc_rarity = raw_data[\"rarity\"]\n    # description\n    lc_description = BeautifulSoup(raw_data[\"descHash\"], features=\"lxml\").get_text()\n\n    # path\n    lc_path = None\n    raw_path = raw_data[\"baseType\"][\"name\"]\n\n    if raw_path == \"The Hunt\":\n        lc_path = Path.HUNT\n\n    elif raw_path == \"Harmony\":\n        lc_path = Path.HARMONY\n    elif raw_path == \"Destruction\":\n        lc_path = Path.DESTRUCTION\n    elif raw_path == \"Erudition\":\n        lc_path = Path.ERUDITION\n    elif raw_path == \"Nihility\":\n        lc_path = Path.NIHILITY\n    elif raw_path == \"Preservation\":\n        lc_path = Path.PRESERVATION\n    elif raw_path == \"Abundance\":\n        lc_path = Path.ABUNDANCE\n    else:\n        raise Exception(f\"failed to parse lightcone, raw_path unknown: ${raw_path}\")\n\n    # ability\n    lc_ability = {}\n    ability_desc_template = BeautifulSoup(\n        raw_data[\"skill\"][\"descHash\"], features=\"lxml\"\n    ).get_text()\n    simp_template_params = map(lambda si: si[\"params\"], raw_data[\"skill\"][\"levelData\"])\n\n    for simp_no, template_params_per_simp in enumerate(simp_template_params, start=1):\n        ability_desc = ability_desc_template\n        for slot_no, template_param in enumerate(template_params_per_simp, start=1):\n            replace_text = f\"#{slot_no}[i]\"\n            # print(\"replacing: \" + replace_text + \" with \" + str(template_param) + \" in \" + ability_desc)\n            ability_desc = ability_desc.replace(replace_text, str(template_param))\n\n        lc_ability[simp_no] = ability_desc\n\n\n\n    # ascension mats\n    ascension_mats = []\n\n    for lvl in raw_data['levelData']:\n        __lvl = lvl['maxLevel']\n        __mtrls = list()\n        if 'cost' in lvl:\n            for mtrl in lvl['cost']:\n                '''\n                create an dummy SearchItem just for fetching with ID param and Type            \n                '''\n                \n                __mtrlobj = be.resolve_material(SearchItem(id=int(mtrl['id']), type=Item.MATERIAL, url='', iconPath='', rarity=0, name=''))\n                __mtrls.append(MaterialCount(material=__mtrlobj, count=mtrl['count']))\n        ascension_mats.append((__lvl, __mtrls))\n\n\n\n    # prepare actual lightcone.\n    lightcone = Lightcone(\n        name=lc_name,\n        rarity=lc_rarity,\n        description=lc_description,\n        path=lc_path,\n        ability=lc_ability,\n        ascension_mats=dict(ascension_mats),\n    )\n\n    # _stats (has to be done after object creation)\n    setattr(lightcone, \"_stats\", raw_data[\"levelData\"])\n\n    return lightcone", ""]}
{"filename": "hsr_client/backend/srs_backend/parsers/character.py", "chunked_list": ["from typing import Dict\nfrom hsr_client.backend.srs_backend import SRSBackend\nfrom hsr_client.backend.srs_backend.parsers.eidolon import parse_eidolon\nfrom hsr_client.backend.srs_backend.parsers.material import parse_material\nfrom hsr_client.backend.srs_backend.parsers.trace import parse_non_skill_traces\nfrom hsr_client.datamodels.chara import Character\nfrom hsr_client.datamodels.element import Element\nfrom hsr_client.datamodels.lightcone import MaterialCount, Lightcone\nfrom hsr_client.datamodels.material import Material\nfrom hsr_client.paths import Path", "from hsr_client.datamodels.material import Material\nfrom hsr_client.paths import Path\nfrom bs4 import BeautifulSoup\n\n\ndef parse_character(character_raw, srs_be: SRSBackend) -> Character:\n    # name\n    c_name = character_raw[\"name\"]\n    # rarity\n    c_rarity = character_raw[\"rarity\"]\n    # description\n    c_description = BeautifulSoup(character_raw[\"descHash\"], features=\"lxml\").get_text()\n\n    # element\n    c_element = None\n    raw_element = character_raw[\"damageType\"][\"name\"]\n    if raw_element == \"Ice\":\n        c_element = Element.ICE\n    else:\n        raise Exception(f\"failed to parse lightcone, raw_path unknown: ${raw_path}\")\n\n    # path\n    c_path = None\n    raw_path = character_raw[\"baseType\"][\"name\"]\n    if raw_path == \"The Hunt\":\n        c_path = Path.HUNT\n    elif raw_path == \"Harmony\":\n        c_path = Path.HARMONY\n    elif raw_path == \"Destruction\":\n        c_path = Path.DESTRUCTION\n    elif raw_path == \"Erudition\":\n        c_path = Path.ERUDITION\n    elif raw_path == \"Nihility\":\n        c_path = Path.NIHILITY\n    elif raw_path == \"Preservation\":\n        c_path = Path.PRESERVATION\n    elif raw_path == \"Abundance\":\n        c_path = Path.ABUNDANCE\n    else:\n        raise Exception(f\"failed to parse lightcone, raw_path unknown: ${raw_path}\")\n\n\n    # eidolons\n    c_eidolons = []\n    # resonance aka rank. aka eidolon number\n    for resonance_data in character_raw[\"ranks\"]:\n        c_eidolons.append(parse_eidolon(resonance_data))\n\n   \n    # traces.\n    c_traces = []\n    parse_non_skill_traces(character_raw['skillTreePoints'], c_traces)\n\n    # ascension_mats\n\n\n\n \n\n    # ascension_mats={\n    #     20: [\n    #         MaterialCount(\n    #             material=Material(name=\"foo1\", description=\"bar1\"), count=1\n    #         ),\n    #         MaterialCount(\n    #             material=Material(name=\"foo2\", description=\"bar2\"), count=2\n    #         ),\n    #     ],\n    #     30: [\n    #         MaterialCount(\n    #             material=Material(name=\"foo3\", description=\"bar3\"), count=3\n    #         ),\n    #     ],\n    # },\n\n\n    character = Character(\n        name=c_name,\n        rarity=c_rarity,\n        description=c_description,\n        path=c_path,\n        eidolons=c_eidolons,\n        traces=c_traces,\n        element=c_element,\n    )\n\n\n\n    # _stats (has to be done after object creation)\n    setattr(character, \"_chara_levelData\", character_raw[\"levelData\"])\n    setattr(character, '_chara_skills', character_raw['skills'])\n    setattr(character, '_backend', srs_be)\n  \n    return character"]}
{"filename": "hsr_client/backend/srs_backend/parsers/trace.py", "chunked_list": ["from typing import List\nfrom bs4 import BeautifulSoup\nfrom hsr_client.backend.srs_backend import SRSBackend\nimport hsr_client.datamodels as models\nfrom hsr_client.datamodels.material import MaterialCount\n\nfrom  hsr_client.datamodels import trace\nfrom hsr_client.errors import BackendError\n\n\ndef additional_info(trace_node):\n    container =  trace_node.get(\"embedBuff\") or trace_node.get(\"embedBonusSkill\")\n    if container is None:\n        # TODO: log this, this might hint that the backend response structure has changed.\n        raise ValueError(\"trace data doesn't have a additional info, TODO: fix this error message\")\n    return container", "\n\ndef additional_info(trace_node):\n    container =  trace_node.get(\"embedBuff\") or trace_node.get(\"embedBonusSkill\")\n    if container is None:\n        # TODO: log this, this might hint that the backend response structure has changed.\n        raise ValueError(\"trace data doesn't have a additional info, TODO: fix this error message\")\n    return container\n\n\ndef parse_non_skill_traces(trace_nodes, traces=[], parent=None) -> List[trace.Trace]:\n    for trace_node in trace_nodes:\n        \n        info = additional_info(trace_node)\n\n        # extract name\n        name = info[\"name\"]\n\n        # prepare description\n        t_description =  info.get(\"descHash\")\n\n        if t_description is not None:\n            t_description = BeautifulSoup(t_description, features='lxml').get_text()\n            template_params = info['levelData'][0]['params']\n\n            for slot_no, template_param in enumerate(template_params, start=1):\n                replace_text = f\"#{slot_no}[i]\"\n                t_description = t_description.replace(replace_text, str(template_param))\n\n        else:\n            desc_name = BeautifulSoup(info['statusList'][0][\"key\"], features='lxml').get_text()\n            desc_value = str(info['statusList'][0][\"value\"] * 100)\n            t_description = f\"{desc_name}: {desc_value}\"\n\n\n\n        # prepare unlock preprequisite\n        unlock_prerequisite = trace.UnlockPrerequisite(\n                trace=parent,\n                level=info[\"levelReq\"],\n                ascension=additional_info(trace_node)[\"promotionReq\"]\n        )\n\n        # prepare tht trace itself.\n        if trace_node[\"type\"] == 1:\n            _trace = trace.BonusAbility(\n                name=name,\n                description=t_description,\n                activation_mats=[],\n                unlock_prerequisite=unlock_prerequisite\n            )\n\n        elif trace_node[\"type\"] == 2:\n            _trace = trace.StatBonus(\n                name=name,\n                description=t_description,\n                activation_mats=[],\n                unlock_prerequisite=unlock_prerequisite\n            )\n        \n        else:\n            raise BackendError(\"Invalid trace type(int) found: \", trace_node[\"type\"])\n\n        traces.append(_trace)\n\n        # parse child traces\n        children = trace_node.get(\"children\")\n        if children is not None or children != []:\n            parse_non_skill_traces(children, traces, parent=_trace)\n\n\n    return []", "\n\ndef parse_non_skill_traces(trace_nodes, traces=[], parent=None) -> List[trace.Trace]:\n    for trace_node in trace_nodes:\n        \n        info = additional_info(trace_node)\n\n        # extract name\n        name = info[\"name\"]\n\n        # prepare description\n        t_description =  info.get(\"descHash\")\n\n        if t_description is not None:\n            t_description = BeautifulSoup(t_description, features='lxml').get_text()\n            template_params = info['levelData'][0]['params']\n\n            for slot_no, template_param in enumerate(template_params, start=1):\n                replace_text = f\"#{slot_no}[i]\"\n                t_description = t_description.replace(replace_text, str(template_param))\n\n        else:\n            desc_name = BeautifulSoup(info['statusList'][0][\"key\"], features='lxml').get_text()\n            desc_value = str(info['statusList'][0][\"value\"] * 100)\n            t_description = f\"{desc_name}: {desc_value}\"\n\n\n\n        # prepare unlock preprequisite\n        unlock_prerequisite = trace.UnlockPrerequisite(\n                trace=parent,\n                level=info[\"levelReq\"],\n                ascension=additional_info(trace_node)[\"promotionReq\"]\n        )\n\n        # prepare tht trace itself.\n        if trace_node[\"type\"] == 1:\n            _trace = trace.BonusAbility(\n                name=name,\n                description=t_description,\n                activation_mats=[],\n                unlock_prerequisite=unlock_prerequisite\n            )\n\n        elif trace_node[\"type\"] == 2:\n            _trace = trace.StatBonus(\n                name=name,\n                description=t_description,\n                activation_mats=[],\n                unlock_prerequisite=unlock_prerequisite\n            )\n        \n        else:\n            raise BackendError(\"Invalid trace type(int) found: \", trace_node[\"type\"])\n\n        traces.append(_trace)\n\n        # parse child traces\n        children = trace_node.get(\"children\")\n        if children is not None or children != []:\n            parse_non_skill_traces(children, traces, parent=_trace)\n\n\n    return []", "\n# def parse_skill_traces(raw_skills, srs_be: SRSBackend):\n#     for raw_skill in raw_skills:\n#         # name\n#         skill_name = raw_skill['name']\n\n#         # scaling: LevelScaling\n        \n#         desc_template = BeautifulSoup(\n#             raw_skills[\"descHash\"], features=\"lxml\"", "#         desc_template = BeautifulSoup(\n#             raw_skills[\"descHash\"], features=\"lxml\"\n#         ).get_text()\n\n#         template_params_all_levels = map(\n#             lambda d: d['params'],\n#             raw_skills[\"levelData\"]\n#         )\n\n#         for level, level_data in raw_skills['levelData']:", "\n#         for level, level_data in raw_skills['levelData']:\n#             template_params = level_data['params']\n#             skill_desc = desc_template\n            \n#             for slot_no, template_param in enumerate(template_params, start=1):\n#                 replace_text = f\"#{slot_no}[i]\"\n#                 # print(\"replacing: \" + replace_text + \" with \" + str(template_param) + \" in \" + ability_desc)\n#                 skill_desc = skill_desc.replace(replace_text, str(template_param))\n", "#                 skill_desc = skill_desc.replace(replace_text, str(template_param))\n\n            \n\n#             raw_matcounts =level_data['cost']\n\n#             ascension_mats_per_level = []\n#             for raw_matcount in raw_matcounts:\n#                 mat_id = raw_matcount['id']\n", "#                 mat_id = raw_matcount['id']\n\n#                 from hsr_client.backend.srs_backend.parsers.material import parse_material\n#                 mat = parse_material(mat_id, srs_be)\n                \n                \n#                 mat_count = raw_matcount['count']\n\n#                 ascension_mats_per_level.append(\n#                     MaterialCount(", "#                 ascension_mats_per_level.append(\n#                     MaterialCount(\n#                     material=mat,\n#                     count = mat_count,\n#                     )\n#                 )\n\n\n\n# def parse_traces(raw_character_data, srs_be: SRSBackend)  -> List[models.trace.Trace]:", "\n# def parse_traces(raw_character_data, srs_be: SRSBackend)  -> List[models.trace.Trace]:\n#     non_skill_traces = []\n#     parse_non_skill_traces(raw_character_data['skillTreePoints'], non_skill_traces)\n#     skill_traces = parse_skill_traces(raw_character_data['skills'])\n\n#     return [*non_skill_traces, *skill_traces]"]}
{"filename": "hsr_client/backend/srs_backend/parsers/material.py", "chunked_list": ["\nfrom bs4 import BeautifulSoup\nfrom ....constants import MaterialTypes\nfrom hsr_client.datamodels.material import Material\n\n\n\ndef parse_material(raw_data, be) -> Material:\n\n\n    print(raw_data)\n\n\n    mtrl_name = raw_data['embeddedItem']['name']\n    mtrl_desc = BeautifulSoup(raw_data['embeddedItem']['desc'], features='lxml').get_text()\n    mtrl_lore = BeautifulSoup(raw_data['embeddedItem']['lore'], features='lxml').get_text()\n    mrtl_source= raw_data['embeddedItem']['comeFrom']\n    mtrl_type = MaterialTypes(raw_data['embeddedItem']['purposeId'])\n\n    mtrl_rarity = raw_data['embeddedItem']['rarity']\n\n\n    # TODO: create the actual material with ID.\n\n    # actually , can just move backend fetch this out of here and put it in srs_backend\n    # just let this function parse materail nothing else.\n\n    material = Material(\n        name=mtrl_name,\n        rarity=mtrl_rarity,\n        description=mtrl_desc,\n        lore = mtrl_lore,\n        type=mtrl_type,\n        source=mrtl_source\n    )\n\n    return material", "\n"]}
{"filename": "hsr_client/backend/srs_backend/parsers/eidolon.py", "chunked_list": ["from hsr_client.datamodels.chara import Character\nfrom hsr_client.datamodels.eidolon import Eidolon\nfrom bs4 import BeautifulSoup\n\n\ndef parse_eidolon(raw_data) -> Character:\n    # name\n    e_name = raw_data[\"name\"]\n    # resonance\n    e_resonance = raw_data[\"id\"]\n\n    # description\n    description_template = BeautifulSoup(\n        raw_data[\"descHash\"], features=\"lxml\"\n    ).get_text()\n    template_params = raw_data[\"params\"]\n\n\n    for slot_no, template_param in enumerate(template_params, start=1):\n        replace_text = f\"#{slot_no}[i]\"\n        description_template = description_template.replace(replace_text, str(template_param))\n\n    e_description = description_template\n\n    eidolon = Eidolon(\n        name=e_name,\n        resonance=e_resonance,\n        description=e_description\n    )\n\n    return eidolon", ""]}
{"filename": "hsr_client/backend/hoyo_backend/__init__.py", "chunked_list": ["from typing import List, Union\nfrom hsr_client.datamodels.searchItem import SearchItem\nfrom hsr_client.errors import  InvalidLanguage\nfrom ..util import Backend\nimport hsr_client.datamodels as models\nfrom .constants import Item\nfrom .routes import *\nfrom .parsers import searchItem\n\nclass HoyoBackend(Backend):\n\n    def __init__(self) -> None:\n\n        super().__init__()\n        \n        self.custom_headers =  {\"x-rpc-language\": \"en-us\",\n                                \"x-rpc-wiki_app\": \"hsr\",\n                                \"Origin\": \"https://wiki.hoyolab.com\",    \n                                \"Referer\": \"https://wiki.hoyolab.com/\"}\n        \n\n    def __get_response(self, method: str, route, **params) -> None | dict | list[dict]:  \n        \"\"\"Fetches response data from the api route\n\n        Args:\n            method (str): GET, POST\n            route (str): api route\n            params (kwargs) : request payload \n\n        Returns:\n            None | dict | list[dict]: returns the response\n        \"\"\"        \n      \n      \n        self.session.headers.update(self.custom_headers)\n\n        payload = {'json' : params} if method == 'POST' else {'params': params}\n        response = self.session.request(method, route,force_refresh=True, **payload)   \n        if response.status_code < 300:\n            data = response.json()\n            if data['message'] == 'OK' and data['retcode'] == 0:\n                return data['data'].get('list', data['data'].get('entries', data['data'].get('page', None)))\n\n\n\n    def __entries(self, item : Item, **params) -> list[SearchItem]:\n        \"\"\"gets all entries from api route of given type\n\n        Args:\n            item (Item): Item enum. Item.CHARACTERS, Item.MATERIALS\n            ---\n            allowed kwargs\n            ---\n            page_num : int [1..... 99]\n            page_size : int [number of items in one page]\n\n\n        Returns:\n            list[SearchItem]: returns a list of SearchItem\n        \"\"\"       \n\n        params.update({'use_es': True})\n        response = self.__get_response('POST', ENTRY_LIST, filters=[], menu_id=item, **params)\n\n        if response is not None:            \n            return [SearchItem(**searchItem.make_model_compatible(item, item)) for item in response]\n\n    def __entry_detail(self, item : Union[SearchItem, int]) -> dict:\n        \"\"\"gets the detail of a search item\n        item passed should be either a SearchItem, or the id of the entry\n\n        Args:\n            item (SearchItem, int): SearchItem [from __entries] or ID of the entry.\n\n        Returns:\n            dict: returns the data fetched\n        \"\"\"        \n        entry_page_id = item\n        if isinstance(entry_page_id, SearchItem):\n            entry_page_id = entry_page_id.id\n\n        response = self.__get_response('GET', ENTRY_PAGE, entry_page_id=entry_page_id)\n\n        if response is not None:            \n            return response # type: ignore\n\n    \n    def get_trace_description(self) -> str:\n        \"\"\"if you'd like to get the trace's description later.\"\"\"\n        pass", "\nclass HoyoBackend(Backend):\n\n    def __init__(self) -> None:\n\n        super().__init__()\n        \n        self.custom_headers =  {\"x-rpc-language\": \"en-us\",\n                                \"x-rpc-wiki_app\": \"hsr\",\n                                \"Origin\": \"https://wiki.hoyolab.com\",    \n                                \"Referer\": \"https://wiki.hoyolab.com/\"}\n        \n\n    def __get_response(self, method: str, route, **params) -> None | dict | list[dict]:  \n        \"\"\"Fetches response data from the api route\n\n        Args:\n            method (str): GET, POST\n            route (str): api route\n            params (kwargs) : request payload \n\n        Returns:\n            None | dict | list[dict]: returns the response\n        \"\"\"        \n      \n      \n        self.session.headers.update(self.custom_headers)\n\n        payload = {'json' : params} if method == 'POST' else {'params': params}\n        response = self.session.request(method, route,force_refresh=True, **payload)   \n        if response.status_code < 300:\n            data = response.json()\n            if data['message'] == 'OK' and data['retcode'] == 0:\n                return data['data'].get('list', data['data'].get('entries', data['data'].get('page', None)))\n\n\n\n    def __entries(self, item : Item, **params) -> list[SearchItem]:\n        \"\"\"gets all entries from api route of given type\n\n        Args:\n            item (Item): Item enum. Item.CHARACTERS, Item.MATERIALS\n            ---\n            allowed kwargs\n            ---\n            page_num : int [1..... 99]\n            page_size : int [number of items in one page]\n\n\n        Returns:\n            list[SearchItem]: returns a list of SearchItem\n        \"\"\"       \n\n        params.update({'use_es': True})\n        response = self.__get_response('POST', ENTRY_LIST, filters=[], menu_id=item, **params)\n\n        if response is not None:            \n            return [SearchItem(**searchItem.make_model_compatible(item, item)) for item in response]\n\n    def __entry_detail(self, item : Union[SearchItem, int]) -> dict:\n        \"\"\"gets the detail of a search item\n        item passed should be either a SearchItem, or the id of the entry\n\n        Args:\n            item (SearchItem, int): SearchItem [from __entries] or ID of the entry.\n\n        Returns:\n            dict: returns the data fetched\n        \"\"\"        \n        entry_page_id = item\n        if isinstance(entry_page_id, SearchItem):\n            entry_page_id = entry_page_id.id\n\n        response = self.__get_response('GET', ENTRY_PAGE, entry_page_id=entry_page_id)\n\n        if response is not None:            \n            return response # type: ignore\n\n    \n    def get_trace_description(self) -> str:\n        \"\"\"if you'd like to get the trace's description later.\"\"\"\n        pass"]}
{"filename": "hsr_client/backend/hoyo_backend/constants.py", "chunked_list": ["from enum import Enum, IntEnum\n\n\n\nclass Item(IntEnum):\n    \n    '''\n    HoYoLab Wiki Entries\n    Item | Codes\n\n    - PATHS : 102\n    - CHARACTERS : 104\n    - NPCS : 105\n    - LIGHTCONES : 107\n    - RELICS : 108\n    - MATERIALS : 110\n    - MUSIC_DISKS : 117\n    - ENEMIES : 112\n    '''\n    \n    PATHS = 102\n    CHARACTERS = 104\n    NPCS = 105\n    LIGHTCONES = 107\n    RELICS = 108\n    MATERIALS = 110\n    MUSIC_DISKS = 117\n    ENEMIES = 112\n\n    def __str__(self) -> str:\n        return str(self.value)"]}
{"filename": "hsr_client/backend/hoyo_backend/routes.py", "chunked_list": ["\n'''\nHoYoLab Wiki routes\n\n'''\nENTRY_LIST = 'https://sg-wiki-api.hoyolab.com/hoyowiki/hsr/wapi/get_entry_page_list'\nENTRY_URL_ROUTE = 'https://wiki.hoyolab.com/pc/hsr/entry/{entry_id}'\nENTRY_PAGE = 'https://sg-wiki-api.hoyolab.com/hoyowiki/hsr/wapi/entry_page'\n", ""]}
{"filename": "hsr_client/backend/hoyo_backend/parsers/searchItem.py", "chunked_list": ["\n\nfrom ..constants import Item\nfrom ..routes import ENTRY_URL_ROUTE\n\ndef make_model_compatible(raw_data : dict, item: Item):\n\n\n    __compatibledict = {\n       \n    }\n    __compatibledict['url'] = ENTRY_URL_ROUTE.format(entry_id = raw_data.get('entry_page_id', 0))\n    __compatibledict['name'] = raw_data['name']\n    __compatibledict['iconPath'] = raw_data['icon_url']\n    __compatibledict['id'] = raw_data['entry_page_id']\n    __compatibledict['type'] = int(item)\n\n    exclude = {'name', 'icon_url', 'id'}\n\n    ## add extra keys for filtering \n    extra_keys = list(set(raw_data['filter_values'].keys()) - exclude)\n    for k in extra_keys:\n        if 'values' in raw_data['filter_values'][k]:             \n            if 'rarity' in k:\n                __compatibledict['rarity'] = int(raw_data['filter_values'][k]['values'][0][0])\n            else:                \n                __compatibledict[k] = raw_data['filter_values'][k]['values'][0] \n\n   \n           \n   \n    return __compatibledict", "\n"]}
{"filename": "hsr_client/datamodels/lightcone.py", "chunked_list": ["from typing import Dict, List, NewType, Tuple, Iterable\nfrom pydantic import BaseModel, PrivateAttr\nfrom hsr_client.datamodels.material import Material, MaterialCount\nfrom hsr_client.errors import BackendError\nfrom hsr_client.hsr_types import  Superimposition, Level\nfrom hsr_client.paths import Path\n\nclass Stats(BaseModel):\n    \"\"\"\n    Lightcone's base stats\n    \"\"\"\n    ATK: int\n    \"\"\"Lightcone base ATK\"\"\"\n    HP: int\n    \"\"\"Lightcone base HP\"\"\"\n    DEF: int\n    \"\"\"Lightcone DEF\"\"\"", "\n\n\n\n\n\n\nclass Lightcone(BaseModel):\n    \"\"\"\n    Model to represent a Lightcone\n\n\n\n    Attributes:\n\n        - name: name of the lightcone\n        - description: description of the lightcone\n        - path: Path association of the Lightcone\n        - ability: lightcone ability description for given superimposition (int)\n        - ascension_mats: ascension materials required to level up beyond given `Level` (int)\n\n    \"\"\"\n\n    name: str\n    \"name of the lightcone\"\n    rarity: int\n    \"\"\"rarity of the lightcone\"\"\"\n    description: str\n    \"\"\"short description of the lightcone\"\"\"\n    path: Path\n    \"\"\"Path association of the lightcone\"\"\"\n\n\n\n    # directly using starrail station's `levelData` structure here. since `Stats`\n    # going to be accessed only via a function anyway.\n    # offering it via an instance variable like `stats` would be unncessarily big\n    # listing. of `Stats` for level 1 through 80\n    # offering a function instead will also feature proof the model\n    # since no public attribute is exposed now, that will change later.\n    # only downside I can think of is, if the user wants to save the \n    # model via json() etc., the stats wont be a part of it.\n    # but i feel limitation is better than making breaking change.\n    _stats = PrivateAttr()\n\n    # # lightcone stats scaling by `Level` (int)\n    # stats: Dict[Level, Stats]\n    \n    \n\n    ability: Dict[Superimposition, str]\n    \"\"\"lightcone ability description for given `Superimposition (int)`\"\"\"\n    # ascension materials required to level up beyond given `Level` (int)\n    ascension_mats: Dict[Level, List[MaterialCount]]\n    \"\"\"ascension mats required to level up beyond the given `Level (int)` \"\"\"\n\n    def stats(self, level: Level, ascended=False) -> Stats:\n        \"\"\"\n        Get Ligthcone's Stats for the given level. when ascended=True is used\n        on levels where ascension is possible, gives `Stats` for ascended levels\n        instead.\n        \"\"\"\n        if level < 1 or level > 80:\n            raise ValueError(\" 1 <= level <= 80 criteria not satisfied.\")\n        \n        for ascension_entry in self._stats:\n            if level <= ascension_entry[\"maxLevel\"]:\n                if ascension_entry[\"maxLevel\"] == level and ascended == True:\n                    continue\n                \n                return Stats(\n                    ATK=ascension_entry[\"attackBase\"] + ascension_entry[\"attackAdd\"] * (level - 1),\n                    HP=ascension_entry[\"hpBase\"] + ascension_entry[\"hpAdd\"] * (level - 1),\n                    DEF=ascension_entry[\"defenseBase\"] + ascension_entry[\"defenseAdd\"] * (level - 1),\n                )\n\n        raise BackendError(\"levelData for Stats appears to be emtpy, this most\"\n                           \"likely hints Library out of date with backend sources\"\n                           \"please report this bug.\")", "         \n\n     \n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    \n\n    lightcone = Lightcone(\n        name=\"light cone\",\n        rarity=4,\n        description=\"this is a light cone , and this is its history\",\n        path = Path.HARMONY,\n        ability={\n            1: \"at superimposition level damage bonus is 30%\"\n        },\n        ascension_mats={\n        20: [\n            MaterialCount(material=Material(name=\"foo1\", description=\"bar1\", rarity=4, source=[\"somewhere\"], lore=\"nice lore\"), count=1),\n            MaterialCount(material=Material(name=\"foo2\", description=\"bar2\", rarity=4, source=[\"somewhere\"], lore=\"nice lore\"), count=2),\n        ],\n        30: [\n            MaterialCount(material=Material(name=\"foo3\", description=\"bar3\", rarity=4, source=[\"somewhere\"], lore=\"nice lore\"), count=3),\n        ]\n    })\n\n    import json\n    setattr(lightcone, \"_stats\", json.loads(\"\"\"\n    [\n    {\n        \"promotion\": 0,\n        \"maxLevel\": 20,\n        \"cost\": [\n            {\n                \"id\": 29328,\n                \"count\": 3000\n            },\n            {\n                \"id\": 549437,\n                \"count\": 4\n            }\n        ],\n        \"attackBase\": 14.4,\n        \"attackAdd\": 2.16,\n        \"hpBase\": 38.4,\n        \"hpAdd\": 5.76,\n        \"defenseBase\": 12,\n        \"defenseAdd\": 1.8\n    },\n    {\n        \"promotion\": 1,\n        \"maxLevel\": 30,\n        \"cost\": [\n            {\n                \"id\": 29328,\n                \"count\": 6000\n            },\n            {\n                \"id\": 635674,\n                \"count\": 2\n            },\n            {\n                \"id\": 549437,\n                \"count\": 8\n            }\n        ],\n        \"attackBase\": 31.68,\n        \"attackAdd\": 2.16,\n        \"hpBase\": 84.48,\n        \"hpAdd\": 5.76,\n        \"defenseBase\": 26.4,\n        \"defenseAdd\": 1.8\n    },\n    {\n        \"promotion\": 2,\n        \"maxLevel\": 40,\n        \"cost\": [\n            {\n                \"id\": 29328,\n                \"count\": 12000\n            },\n            {\n                \"id\": 920201,\n                \"count\": 2\n            },\n            {\n                \"id\": 633378,\n                \"count\": 4\n            }\n        ],\n        \"attackBase\": 54.72,\n        \"attackAdd\": 2.16,\n        \"hpBase\": 145.92,\n        \"hpAdd\": 5.76,\n        \"defenseBase\": 45.6,\n        \"defenseAdd\": 1.8\n    },\n    {\n        \"promotion\": 3,\n        \"maxLevel\": 50,\n        \"cost\": [\n            {\n                \"id\": 29328,\n                \"count\": 30000\n            },\n            {\n                \"id\": 920201,\n                \"count\": 4\n            },\n            {\n                \"id\": 633378,\n                \"count\": 6\n            }\n        ],\n        \"attackBase\": 77.76,\n        \"attackAdd\": 2.16,\n        \"hpBase\": 207.36,\n        \"hpAdd\": 5.76,\n        \"defenseBase\": 64.8,\n        \"defenseAdd\": 1.8\n    },\n    {\n        \"promotion\": 4,\n        \"maxLevel\": 60,\n        \"cost\": [\n            {\n                \"id\": 29328,\n                \"count\": 60000\n            },\n            {\n                \"id\": 836260,\n                \"count\": 3\n            },\n            {\n                \"id\": 717319,\n                \"count\": 3\n            }\n        ],\n        \"attackBase\": 100.8,\n        \"attackAdd\": 2.16,\n        \"hpBase\": 268.8,\n        \"hpAdd\": 5.76,\n        \"defenseBase\": 84,\n        \"defenseAdd\": 1.8\n    },\n    {\n        \"promotion\": 5,\n        \"maxLevel\": 70,\n        \"cost\": [\n            {\n                \"id\": 29328,\n                \"count\": 120000\n            },\n            {\n                \"id\": 836260,\n                \"count\": 6\n            },\n            {\n                \"id\": 717319,\n                \"count\": 5\n            }\n        ],\n        \"attackBase\": 123.84,\n        \"attackAdd\": 2.16,\n        \"hpBase\": 330.24,\n        \"hpAdd\": 5.76,\n        \"defenseBase\": 103.2,\n        \"defenseAdd\": 1.8\n    },\n    {\n        \"promotion\": 6,\n        \"maxLevel\": 80,\n        \"cost\": [],\n        \"attackBase\": 146.88,\n        \"attackAdd\": 2.16,\n        \"hpBase\": 391.68,\n        \"hpAdd\": 5.76,\n        \"defenseBase\": 122.4,\n        \"defenseAdd\": 1.8\n    }\n]\n    \"\"\"))\n\n    lvl_20_ascension_mats = lightcone.ascension_mats[20] # TODO: this doesn't read well. what does ascension_mats[20] mean, unless u look at the type.\n\n\n\n    print(lightcone.stats(20, ascended=True))", "\nif __name__ == \"__main__\":\n\n    \n\n    lightcone = Lightcone(\n        name=\"light cone\",\n        rarity=4,\n        description=\"this is a light cone , and this is its history\",\n        path = Path.HARMONY,\n        ability={\n            1: \"at superimposition level damage bonus is 30%\"\n        },\n        ascension_mats={\n        20: [\n            MaterialCount(material=Material(name=\"foo1\", description=\"bar1\", rarity=4, source=[\"somewhere\"], lore=\"nice lore\"), count=1),\n            MaterialCount(material=Material(name=\"foo2\", description=\"bar2\", rarity=4, source=[\"somewhere\"], lore=\"nice lore\"), count=2),\n        ],\n        30: [\n            MaterialCount(material=Material(name=\"foo3\", description=\"bar3\", rarity=4, source=[\"somewhere\"], lore=\"nice lore\"), count=3),\n        ]\n    })\n\n    import json\n    setattr(lightcone, \"_stats\", json.loads(\"\"\"\n    [\n    {\n        \"promotion\": 0,\n        \"maxLevel\": 20,\n        \"cost\": [\n            {\n                \"id\": 29328,\n                \"count\": 3000\n            },\n            {\n                \"id\": 549437,\n                \"count\": 4\n            }\n        ],\n        \"attackBase\": 14.4,\n        \"attackAdd\": 2.16,\n        \"hpBase\": 38.4,\n        \"hpAdd\": 5.76,\n        \"defenseBase\": 12,\n        \"defenseAdd\": 1.8\n    },\n    {\n        \"promotion\": 1,\n        \"maxLevel\": 30,\n        \"cost\": [\n            {\n                \"id\": 29328,\n                \"count\": 6000\n            },\n            {\n                \"id\": 635674,\n                \"count\": 2\n            },\n            {\n                \"id\": 549437,\n                \"count\": 8\n            }\n        ],\n        \"attackBase\": 31.68,\n        \"attackAdd\": 2.16,\n        \"hpBase\": 84.48,\n        \"hpAdd\": 5.76,\n        \"defenseBase\": 26.4,\n        \"defenseAdd\": 1.8\n    },\n    {\n        \"promotion\": 2,\n        \"maxLevel\": 40,\n        \"cost\": [\n            {\n                \"id\": 29328,\n                \"count\": 12000\n            },\n            {\n                \"id\": 920201,\n                \"count\": 2\n            },\n            {\n                \"id\": 633378,\n                \"count\": 4\n            }\n        ],\n        \"attackBase\": 54.72,\n        \"attackAdd\": 2.16,\n        \"hpBase\": 145.92,\n        \"hpAdd\": 5.76,\n        \"defenseBase\": 45.6,\n        \"defenseAdd\": 1.8\n    },\n    {\n        \"promotion\": 3,\n        \"maxLevel\": 50,\n        \"cost\": [\n            {\n                \"id\": 29328,\n                \"count\": 30000\n            },\n            {\n                \"id\": 920201,\n                \"count\": 4\n            },\n            {\n                \"id\": 633378,\n                \"count\": 6\n            }\n        ],\n        \"attackBase\": 77.76,\n        \"attackAdd\": 2.16,\n        \"hpBase\": 207.36,\n        \"hpAdd\": 5.76,\n        \"defenseBase\": 64.8,\n        \"defenseAdd\": 1.8\n    },\n    {\n        \"promotion\": 4,\n        \"maxLevel\": 60,\n        \"cost\": [\n            {\n                \"id\": 29328,\n                \"count\": 60000\n            },\n            {\n                \"id\": 836260,\n                \"count\": 3\n            },\n            {\n                \"id\": 717319,\n                \"count\": 3\n            }\n        ],\n        \"attackBase\": 100.8,\n        \"attackAdd\": 2.16,\n        \"hpBase\": 268.8,\n        \"hpAdd\": 5.76,\n        \"defenseBase\": 84,\n        \"defenseAdd\": 1.8\n    },\n    {\n        \"promotion\": 5,\n        \"maxLevel\": 70,\n        \"cost\": [\n            {\n                \"id\": 29328,\n                \"count\": 120000\n            },\n            {\n                \"id\": 836260,\n                \"count\": 6\n            },\n            {\n                \"id\": 717319,\n                \"count\": 5\n            }\n        ],\n        \"attackBase\": 123.84,\n        \"attackAdd\": 2.16,\n        \"hpBase\": 330.24,\n        \"hpAdd\": 5.76,\n        \"defenseBase\": 103.2,\n        \"defenseAdd\": 1.8\n    },\n    {\n        \"promotion\": 6,\n        \"maxLevel\": 80,\n        \"cost\": [],\n        \"attackBase\": 146.88,\n        \"attackAdd\": 2.16,\n        \"hpBase\": 391.68,\n        \"hpAdd\": 5.76,\n        \"defenseBase\": 122.4,\n        \"defenseAdd\": 1.8\n    }\n]\n    \"\"\"))\n\n    lvl_20_ascension_mats = lightcone.ascension_mats[20] # TODO: this doesn't read well. what does ascension_mats[20] mean, unless u look at the type.\n\n\n\n    print(lightcone.stats(20, ascended=True))", "\n\n"]}
{"filename": "hsr_client/datamodels/element.py", "chunked_list": ["\nfrom typing import Optional, Union, List, NewType\nfrom enum import Enum\n\nclass Element(Enum):\n    QUANTUM = \"Using Quantum attacks to inflict Weakness Break will deal Quantum DMG and cause Entanglement, delaying the enemy's action and dealing Additional Quantum DMG to the affected enemy at the start of the next turn. When the enemy is hit, this extra DMG will increase.\"\n    PHYSICAL = \"Using Physical attacks to trigger Weakness Break will deal Physical DMG and apply Bleed effect, dealing Physical DoT.\"\n    FIRE = \"Using Fire attacks to trigger Weakness Break will deal Fire DMG and apply the Burn effect, dealing Fire DoT.\"\n    ICE = \"Using Ice Aattacks to trigger Weakness Break will deal Ice DMG and Freeze the target, immobilizing the enmy and dealing Additional Ice DMG.\"\n    LIGHTNING = \"Using Lightning attacks to trigger Weakness Break will deal Lightning DMG and apply the Shock effect, dealing Lightning DoT.\"\n    WIND = \"Using Wind attacks to trigger Weakness Break will deal Wind DMG and apply the Wind Shear effect, dealing Wind DoT.\"\n    IMAGINARY = \"When using an Imaginary attack to inflict Weakness Break on target enemy, the attack will deal Imaginary DMG and additionaly inflicts Imprisonment. Imprisoned enemies suffer from delayed actions and SPD Reduction.\"\n\n    def describe(self):\n        return self.value", "\nif __name__ == \"__main__\":\n    elem = Element.WIND\n    print(elem.describe())"]}
{"filename": "hsr_client/datamodels/character.py", "chunked_list": ["from pydantic import BaseModel, validator, Field, Extra\nfrom typing import Optional\nfrom hsr_client.routes import IMAGE_ROUTE, AUDIO_ROUTE\nfrom hsr_client.constants import Item, _RelicTypes\nfrom hsr_client.datamodels.searchItem import SearchItem\n\nclass DamageType(BaseModel):\n\n    id : int\n    iconPath : Optional[str] \n    color : Optional[str] \n    name : Optional[str]\n    rarity: Optional[int] \n\n    @validator('iconPath', pre=True)\n    def get_icon_path(cls, v):\n        if v != \"\":\n            return IMAGE_ROUTE.format(assetId=v)\n        return ''", "\n\n\nclass BaseType(BaseModel):\n\n    id : int\n    iconPath : Optional[str] \n    altIconPath : Optional[str]\n    color : Optional[str] \n    rarity: Optional[int] \n    name : Optional[str]\n\n    @validator('iconPath', pre=True)\n    def get_icon_path(cls, v):\n        if v != \"\":\n            return IMAGE_ROUTE.format(assetId=v)\n        return ''", "\n\nclass LevelData(BaseModel):\n\n    promotion : int\n    max : int  = Field(alias='maxLevel')\n    base_atk : float = Field(alias='attackBase')\n    add_atk : float = Field(alias='attackAdd')\n    base_hp : float = Field(alias='hpBase')\n    add_hp : float = Field(alias='hpAdd')\n    base_def : float = Field(alias='defenseBase')\n    add_def : float = Field(alias='defenseAdd')\n    crit_rate : float = Field(alias='crate')\n    crit_damage : float = Field(alias='cdmg')\n    aggro : int \n    base_speed : int = Field(alias='speedBase')\n    add_speed : int = Field(alias='speedAdd')\n    cost : list[SearchItem]\n\n    @validator('cost', pre=True)\n    def get_materials(cls, v):\n\n        list_ = []\n        if len(v) != 0:\n            for item in v:\n                list_.append(SearchItem(**item))\n        return list_", "\nclass Rank(BaseModel):\n    id : int\n    iconPath : str\n    artPath : str\n    description : str = Field(alias='descHash')\n    params : list[int]\n\n    @validator('iconPath', pre=True)\n    def get_icon_path(cls, v):\n        if v != \"\":\n            return IMAGE_ROUTE.format(assetId=v)\n        return ''\n\n    @validator('artPath', pre=True)\n    def get_art_path(cls, v):\n        if v != \"\":\n            return IMAGE_ROUTE.format(assetId=v)\n        return ''", "\nclass SkillLevel(BaseModel):\n    level : int\n    params : list[int]\n    req_level : int = Field(alias='levelReq')\n    req_promotion : int = Field(alias='promotionReq')\n    cost : list[SearchItem]\n\n    @validator('cost', pre=True)\n    def get_materials(cls, v):\n\n        list_ = []\n        if len(v) != 0:\n            for item in v:\n                list_.append(SearchItem(**item))\n        return list_", "\n\nclass Skill(BaseModel):\n\n    id : int\n    name : str\n    target: str = Field(alias='tagHash')\n    type : str = Field(alias='typeDescHash')\n    iconPath : Optional[str]\n    req_level : int = Field(alias='levelReq')\n    req_promotion : int = Field(alias='promotionReq')\n    levels : list[SkillLevel] = Field(alias='levelData')\n\n    @validator('iconPath', pre=True)\n    def get_icon_path(cls, v):\n        if v != \"\":\n            return IMAGE_ROUTE.format(assetId=v)\n\n    @validator('levels', pre=True)\n    def get_skill_levels(cls, v):\n        list_ = []\n        if len(v) != 0:\n            for lvl in v:\n                list_.append(SkillLevel(**lvl))\n        return v", "\nclass BuffStatus(BaseModel):\n    value : float\n    key : str\n\nclass Buff(BaseModel):\n    id : int\n    name: str\n    req_level : int = Field(alias='levelReq')\n    iconPath : str\n    status : list[BuffStatus] = Field(alias='statusList')\n    cost: list[SearchItem]\n\n    @validator('status', pre=True)\n    def get_buff_status(cls, v):\n\n        list_ = []\n        if len(v) != 0:\n            for item in v:\n                list_.append(BuffStatus(**item))\n        return list_\n\n    @validator('cost', pre=True)\n    def get_materials(cls, v):\n\n        list_ = []\n        if len(v) != 0:\n            for item in v:\n                list_.append(SearchItem(**item))\n        return list_", "\n\n    \nclass BonusSkill(BaseModel):\n    id : int\n    name : str\n    description : str = Field(alias='descHash')\n    iconPath : str\n    req_level : int = Field(alias='levelReq')\n    req_promotion : int = Field(alias='promotionReq')\n    levels: list[SkillLevel] = Field(alias='levelData')\n\n    @validator('iconPath', pre=True)\n    def get_icon_path(cls, v):\n        if v != \"\":\n            return IMAGE_ROUTE.format(assetId=v)\n\n    @validator('levels', pre=True)\n    def get_skill_levels(cls, v):\n        list_ = []\n        if len(v) != 0:\n            for lvl in v:\n                list_.append(SkillLevel(**lvl))\n        return v", "\n\nclass SubSkill(BaseModel):\n    id : int\n    type : int\n    sub_skills : list = Field(alias='children')\n    buff : Optional[Buff] = Field(alias='embedBuff')\n    cost: Optional[list[SearchItem]]\n    bonus_skill : Optional[BonusSkill] = Field(alias='embedBonusSkill')\n\n\n    @validator(\"sub_skills\", pre=True)\n    def get_sub_skills(cls, v):\n        list_ = []\n        if len(v) != 0:\n            for item in v:\n                checker = {}                \n                checker['has_subskills'] = 'children' in item\n                checker['has_buff'] = 'buff' in item or 'embedBuff' in item\n                checker['has_bonus'] = 'embedBonusSkill' in item\n\n                list_.append(SubSkill(**{**item, **checker}))\n        return list_\n\n    @validator(\"buff\", pre=True)\n    def get_buff(cls, v):\n\n        if len(v) != 0:\n            return Buff(**v)\n        return v\n    \n    @validator('cost', pre=True)\n    def get_materials(cls, v):\n\n        list_ = []\n        if len(v) != 0:\n            for item in v:\n                list_.append(SearchItem(**item))\n        return list_", "    \nclass SkillTreePoints(BaseModel):\n    id : int\n    type : int\n    sub_skills : list = Field(alias='children')\n    buff : Optional[Buff]\n    bonus_skill : Optional[BonusSkill] = Field(alias='embedBonusSkill')\n    has_bonus : Optional[bool]\n    has_buff : Optional[bool]\n    has_subskills : Optional[bool]\n\n    \n    @validator(\"sub_skills\", pre=True)\n    def get_sub_skills(cls, v):\n        list_ = []\n        if len(v) != 0:\n            for item in v:\n                checker = {}                \n                checker['has_subskills'] = 'children' in item\n                checker['has_buff'] = 'buff' in item or 'embedBuff' in item\n                checker['has_bonus'] = 'embedBonusSkill' in item\n\n                list_.append(SubSkill(**{**item, **checker}))\n        return list_\n\n    @validator(\"buff\", pre=True)\n    def get_buff(cls, v):  \n              \n        if len(v) != 0:\n            return Buff(**v)\n        return ''\n    \n    @validator(\"bonus_skill\", pre=True)\n    def get_bonus_skill(cls, v):\n        if len(v) != 0:\n            return BonusSkill(**v)\n        return ''", "    \nclass RelicProps(BaseModel):\n    type : _RelicTypes = Field(alias='relicTypeHash')\n    type_icon : str = Field(alias='relicTypeIcon')\n    prop : str = Field(alias='propertyName')    \n    prop_icon : str = Field(alias='propertyIconPath')\n\n    @validator('type', pre=True)\n    def get_relic_type(cls, v):\n        return _RelicTypes(v)\n    \n    @validator('type_icon', pre=True)\n    def get_relic_type_icon(cls, v):\n        if v != \"\":\n            return IMAGE_ROUTE.format(assetId=v)\n        \n    @validator('prop_icon', pre=True)\n    def get_relic_prop_icon(cls, v):\n        if v != \"\":\n            return IMAGE_ROUTE.format(assetId=v)", "\n\n\nclass RecommendedRelics(BaseModel):\n\n    two_piece : list = Field(alias='twoPcSets')\n    four_piece  : list = Field(alias='fourPcSets')\n    recommended_props : list[RelicProps] = Field(alias='props')\n\n    @validator(\"recommended_props\", pre=True)\n    def get_rec_props(cls, v):\n        list_ = []\n        if len(v) != 0:\n            for item in v:\n                list_.append(RelicProps(**item))\n        return list_", "\nclass VoiceNote(BaseModel):\n\n    id : int\n    title : str\n    text : str\n    unlock: str = Field(alias='unlockRequirement')\n    cn : str = Field(alias='cnUrl')\n    en : str = Field(alias='enUrl')\n    kr : str = Field(alias='krUrl')\n    jp : str = Field(alias='jpUrl')\n\n    @validator('cn', pre=True)\n    def get_cn_url(cls, v):\n        if v != '':\n            return AUDIO_ROUTE.format(assetId=v)\n        \n    @validator('jp', pre=True)\n    def get_jp_url(cls, v):\n        if v != '':\n            return AUDIO_ROUTE.format(assetId=v)\n    \n    @validator('kr', pre=True)\n    def get_kr_url(cls, v):\n        if v != '':\n            return AUDIO_ROUTE.format(assetId=v)\n    \n    @validator('en', pre=True)\n    def get_en_url(cls, v):\n        if v != '':\n            return AUDIO_ROUTE.format(assetId=v)", "\nclass Character(BaseModel):\n\n    name: str\n    spRequirement : int\n    rarity: int\n    description : str = Field(alias='descHash')\n    iconPath : Optional[str] \n    figPath : Optional[str] \n    fgPath : Optional[str] \n    bgPath : Optional[str] \n    artPath :Optional[str] \n    miniIconPath : Optional[str] \n    splashIconPath : Optional[str] \n    element : DamageType = Field(alias='damageType')\n    baseType : BaseType = Field(alias='baseType')\n    levels : list[LevelData] = Field(alias='levelData')\n    ranks : list[Rank]\n    skills : list[Skill]\n    skill_points : list[SkillTreePoints] = Field(alias='skillTreePoints')\n    relics : RecommendedRelics = Field(alias='relicRecommend')\n    voice_lines : list[VoiceNote] = Field(alias='voiceItems')\n\n    \n    class Config:\n        extra = Extra.ignore\n\n    @validator('iconPath', pre=True)\n    def get_icon_path(cls, v):\n        if v != '':\n            return IMAGE_ROUTE.format(assetId=v)\n        return v\n    \n    @validator('figPath', pre=True)\n    def get_fig_path(cls, v):\n        if v != '':\n            return IMAGE_ROUTE.format(assetId=v)\n        return v\n    \n        \n    @validator('fgPath', pre=True)\n    def get_fg_path(cls, v):\n        if v != '':\n            return IMAGE_ROUTE.format(assetId=v)\n        return v\n    \n    @validator('bgPath', pre=True)\n    def get_bg_path(cls, v):\n        if v != '':\n            return IMAGE_ROUTE.format(assetId=v)\n        return v\n    \n        \n    @validator('miniIconPath', pre=True)\n    def get_miniIcon_path(cls, v):\n        if v != '':\n            return IMAGE_ROUTE.format(assetId=v)\n        return v\n    \n        \n    @validator('splashIconPath', pre=True)\n    def get_splashIcon_path(cls, v):\n        if v != '':\n            return IMAGE_ROUTE.format(assetId=v)\n        return v\n    \n    @validator('artPath', pre=True)\n    def get_art_path(cls, v):\n        if v != '':\n            return IMAGE_ROUTE.format(assetId=v)\n        return v\n\n    @validator('element', pre=True)\n    def get_damage_type(cls, v):\n        return DamageType(**v)\n\n    @validator('baseType', pre=True)\n    def get_base_type(cls, v):\n\n        return BaseType(**v)\n    \n    @validator('levels', pre=True)\n    def get_levels(cls, v):\n        list_ = []\n        if len(v) != 0:\n            for item in v:\n                list_.append(LevelData(**item))\n\n        return list_\n    \n    @validator('ranks', pre=True)\n    def get_ranks(cls, v):\n        list_ = []\n        if len(v) != 0:\n            for item in v:\n                list_.append(Rank(**item))\n        return list_\n    \n    @validator('skills', pre=True)\n    def get_skills(cls ,v):\n        list_ = []\n        if len(v) != 0:\n            for item in v:\n                list_.append(Skill(**item))\n        return list_\n    \n    @validator('skill_points', pre=True)\n    def get_skill_points(cls ,v):\n        list_ = []\n        if len(v) != 0:\n            for item in v:\n                checker = {}                \n                checker['has_subskills'] = 'children' in item\n                checker['has_buff'] = 'buff' in item or 'embedBuff' in item\n                checker['has_bonus'] = 'embedBonusSkill' in item\n\n                list_.append(SkillTreePoints(**{**item, **checker}))\n        return list_\n\n    @validator('relics', pre=True)\n    def get_relics(cls, v):\n\n        if len(v) != 0:\n            return RecommendedRelics(**v)\n\n        return ''\n    \n    @validator('voice_lines', pre=True)\n    def get_vl(cls, v):\n        list_ = []\n        if len(v) != 0:\n            for item in v:\n               list_.append(VoiceNote(**item))\n\n        return list_", "\n\n\n    \n\n\n"]}
{"filename": "hsr_client/datamodels/__init__.py", "chunked_list": ["# from . import chara, trace, material, eidolon"]}
{"filename": "hsr_client/datamodels/trace.py", "chunked_list": ["\nfrom typing import Dict, Optional, Union, List, NewType, Tuple\nfrom pydantic import BaseModel, validator, Field, Extra, ValidationError\n\nfrom enum import Enum\n\nfrom hsr_client.datamodels.lightcone import MaterialCount\nfrom hsr_client.datamodels.material import Material\nfrom hsr_client.hsr_types import Level\n", "from hsr_client.hsr_types import Level\n\n\n\nclass UnlockPrerequisite(BaseModel):\n    \"\"\"criteria to satisfy before this trace can be unlocked.\"\"\"\n    # character ascension required.\n    ascension: Optional[int]\n    # character level required\n    level: Optional[int]\n    # trace to be unlocked before.\n    trace: Optional['Trace']", "  \n    \n\nclass BonusAbility(BaseModel):\n    # name of the trace.\n    name : str\n    # description of the trace.\n    description: Optional[str]\n\n\n\n    # list of materials required to activate the trace.\n    activation_mats: List[MaterialCount]\n    # criteria to satisfy before this trace can be unlocked.\n    unlock_prerequisite: Optional[UnlockPrerequisite]", "\n\n    # @validator\n    # def ensure_level_one(cls, level):\n    #     if level is not 1:\n    #         raise ValidationError(\"Bonus Ability's level can only be equal to 1\")\n\n# StatBonus = NewType('StatBonus', BonusAbility)\nclass StatBonus(BonusAbility):\n    pass", "class StatBonus(BonusAbility):\n    pass\n\nclass LevelScaling(BaseModel):\n    upgrade_mats: List[MaterialCount]\n    description: str\n    \n\n# TODO: decide all the parameters\nclass Skill(BaseModel):\n    \"\"\"Traces possessed by the `Character`\"\"\"\n    # name of the trace.\n    name : str\n    # how the trace scales with level\n    scaling: Dict[Level, LevelScaling]", "# TODO: decide all the parameters\nclass Skill(BaseModel):\n    \"\"\"Traces possessed by the `Character`\"\"\"\n    # name of the trace.\n    name : str\n    # how the trace scales with level\n    scaling: Dict[Level, LevelScaling]\n\nTrace = Union[Skill, StatBonus, BonusAbility]\n   ", "Trace = Union[Skill, StatBonus, BonusAbility]\n   \n\n\n\nUnlockPrerequisite.update_forward_refs()\n\n\n", ""]}
{"filename": "hsr_client/datamodels/searchItem.py", "chunked_list": ["from pydantic import BaseModel, validator, Field, Extra\nfrom typing import Optional, Union, Literal\nfrom hsr_client.routes import IMAGE_ROUTE\nfrom hsr_client.constants import Item\nfrom hsr_client.backend.hoyo_backend.constants import Item as HoyoItems\n\n\nclass SearchItem(BaseModel):\n    \"\"\"SearchItem\n\n    Attributes:\n\n    url : site url for item\n    iconPath : icon url of the  item\n    type: type of item - lightcones, materials, characters\n    rarity: rarity of the item\n    id : ID of the item\n\n    Filters:\n\n        - available_filters()\n            to see the attributes you can filter item on\n\n\n    \"\"\"\n\n    url: Optional[str]\n    iconPath: Optional[str]\n    type: Union[HoyoItems, Item]\n    name: Optional[str]\n    rarity: Optional[int]\n    id: Union[int, str]\n\n    class Config:\n        extra = Extra.allow\n\n    def available_filters(self):\n        \"\"\"TODO: add documentation here\"\"\"\n\n        return [f for f in self.__dict__.keys() if f not in [\"url\", \"iconPath\", \"id\"]]\n\n    @validator('type', pre=True)\n    def get_correct_type(cls, v):\n\n        if isinstance(v, str):\n            v = int(v)        \n        if v > 100:\n            return HoyoItems(v)\n        else:\n            return Item(v)\n        \n\n    def __str__(self):\n        if self.type > 50:\n            return str(\n                f\"<{HoyoItems(str(self.type)).name} name={self.name} rarity={self.rarity} iconPath={self.iconPath}>\"\n            )\n        return str(\n            f\"<{Item(self.type).name} name={self.name} rarity={self.rarity} iconPath={self.iconPath}>\"\n        )\n\n    def __repr__(self):\n        if self.type > 50:\n            return str(\n                f\"<{HoyoItems(str(self.type)).name} name={self.name} rarity={self.rarity} iconPath={self.iconPath}>\"\n            )\n        return str(\n            f\"<{Item(self.type).name} name={self.name} rarity={self.rarity} iconPath={self.iconPath}>\"\n        )", ""]}
{"filename": "hsr_client/datamodels/material.py", "chunked_list": ["\nfrom pydantic import BaseModel, PrivateAttr\nfrom typing import Optional, Dict, List\nfrom ..constants import MaterialTypes\n\n\n\n\n\n", "\n\n\n\n#     MODIFICATION NOTES: obtain will be replaced by source. which can be a type of its own.\n#            iconPath is starrail specific. need something more general that fits with hoyolab aswell\n#            id has no place as a visible attribute, maybe it can be an internal attribute for reference purpose\n#            but the api doesn't flow backwards, most of the time, so need to think if ID is even necessary.\n#            Ofcourse it might still be needed, just shouldn't be a part of public api.\n\nclass Material(BaseModel):\n\n    \"\"\"Material Model\n\n    Attributes:\n        name: name of the material.\n        type: type of material, character exp, playercard, consumable etc.\n        rarity: rarity of the material.\n        description : description of the material.\n        lore : lore of the material, if it has any attached to it.\n        obtain: list of locations , route, shops where you can get the material from.\n        usage: material consumed or used by equipment or character in ascension, boost or upgrade. {'character': [], 'equipment' : []}\n    \"\"\"       \n\n \n    name : str\n    # type: int\n\n\n    rarity : int\n    \"\"\"Rarity of the Material\"\"\"\n    description : str\n    \"\"\"Description of the Material\"\"\"\n    lore : Optional[str]\n    \"\"\"Lore/Notes/Comments on the Material\"\"\"      \n    # TODO: determine icon stratergy\n    # is it image, or url or what?\n\n    type : MaterialTypes\n    # This will be a string for now. maybe own type later? \n    # i don't find any use for now.\n    source: List[str]\n    \"\"\"Where to obtain the Material\"\"\"\n        \n   \n    _meta = PrivateAttr()", "#            Ofcourse it might still be needed, just shouldn't be a part of public api.\n\nclass Material(BaseModel):\n\n    \"\"\"Material Model\n\n    Attributes:\n        name: name of the material.\n        type: type of material, character exp, playercard, consumable etc.\n        rarity: rarity of the material.\n        description : description of the material.\n        lore : lore of the material, if it has any attached to it.\n        obtain: list of locations , route, shops where you can get the material from.\n        usage: material consumed or used by equipment or character in ascension, boost or upgrade. {'character': [], 'equipment' : []}\n    \"\"\"       \n\n \n    name : str\n    # type: int\n\n\n    rarity : int\n    \"\"\"Rarity of the Material\"\"\"\n    description : str\n    \"\"\"Description of the Material\"\"\"\n    lore : Optional[str]\n    \"\"\"Lore/Notes/Comments on the Material\"\"\"      \n    # TODO: determine icon stratergy\n    # is it image, or url or what?\n\n    type : MaterialTypes\n    # This will be a string for now. maybe own type later? \n    # i don't find any use for now.\n    source: List[str]\n    \"\"\"Where to obtain the Material\"\"\"\n        \n   \n    _meta = PrivateAttr()", "\n    \n\n\nclass MaterialCount(BaseModel):\n    material: Material\n    count: int\n"]}
{"filename": "hsr_client/datamodels/eidolon.py", "chunked_list": ["\nfrom typing import Optional, Union, List, NewType\nfrom pydantic import BaseModel\n\nclass Eidolon(BaseModel):\n    \"\"\"Character's Eidolon\"\"\"\n    # eidolon name\n    name : str\n    \"\"\"Eidolon's Name\"\"\"\n    resonance: int\n    \"\"\"Eidolon Number/Resonance/Rank\"\"\"\n    description: Optional[str]\n    \"\"\"Eidolon short description.\"\"\"", "    # TODO: add eidolon icon property."]}
{"filename": "hsr_client/datamodels/chara.py", "chunked_list": ["\nfrom typing import Dict, List\nfrom bs4 import BeautifulSoup\nfrom pydantic import BaseModel, PrivateAttr\nfrom hsr_client.datamodels.trace import Skill\n\n\n\nfrom hsr_client.datamodels.eidolon import Eidolon\nfrom hsr_client.datamodels.element import Element", "from hsr_client.datamodels.eidolon import Eidolon\nfrom hsr_client.datamodels.element import Element\nfrom hsr_client.datamodels.lightcone import MaterialCount\nfrom hsr_client.hsr_types import Level\nfrom . import trace\nfrom hsr_client.paths import Path\n\nfrom enum import Enum\n\n\nclass Stats(BaseModel):\n    ATK: float\n    HP: float\n    DEF: float\n    CRIT: float\n    CDMG: float\n    SPD: float\n    TAUNT: float", "\n\nclass Stats(BaseModel):\n    ATK: float\n    HP: float\n    DEF: float\n    CRIT: float\n    CDMG: float\n    SPD: float\n    TAUNT: float", "\n\n# TODO: decide all the parameters\nclass Character(BaseModel):\n    \"\"\"Traces possessed by the `Character`\"\"\"\n    name: str\n    \"\"\"Name of the Character\"\"\"\n    rarity: int\n    \"\"\"Rarity of the Character\"\"\"\n    element: Element\n    \"\"\"Element of the Character\"\"\"\n    description: str\n    \"\"\"short description about the character.\"\"\"\n    path: Path\n    \"\"\"Path followed by the Character`\"\"\"\n    eidolons: List[Eidolon]\n    \"\"\"Character's Eidolons\"\"\"\n    traces: list[trace.Trace]\n    \"\"\"Character's Traces, does not include Skills, use `skills()` instead.\"\"\"\n\n    # srs backend levelData contains stats and ascension mats data.\n    _chara_levelData = PrivateAttr()\n    # srs backend skills; contains skill data and its ascension data\n    _chara_skills = PrivateAttr()\n    _backend = PrivateAttr()\n\n    def stats(self, level, ascended=False) -> Stats:\n        \"\"\"\n        Get Character's Stats for the given level. when `ascended=True` is used\n        on levels where ascension is possible, gives `Stats` for ascended levels\n        instead.\n        \"\"\"\n        if level < 1 or level > 80: # TODO: or is this 90?\n            raise ValueError(\" 1 <= level <= 80 criteria not satisfied.\")\n        \n        for ascension_entry in self._chara_levelData:\n            if level <= ascension_entry[\"maxLevel\"]:\n                if ascension_entry[\"maxLevel\"] == level and ascended == True:\n                    continue\n                \n                return Stats(\n                    ATK=ascension_entry[\"attackBase\"] + ascension_entry[\"attackAdd\"] * (level - 1),\n                    HP=ascension_entry[\"hpBase\"] + ascension_entry[\"hpAdd\"] * (level - 1),\n                    DEF=ascension_entry[\"defenseBase\"] + ascension_entry[\"defenseAdd\"] * (level - 1),\n                    SPD=ascension_entry[\"speedBase\"] + ascension_entry[\"speedAdd\"] * (level - 1),\n                    CRIT=ascension_entry[\"crate\"] * 100,\n                    CDMG=ascension_entry[\"cdmg\"] * 100,\n                    TAUNT=ascension_entry[\"aggro\"],\n                )\n\n    def ascension_mats(self) -> Dict[Level, List[MaterialCount]]:\n        \"\"\"\n        Returns the ascension materails grouped by ascension level.\n        \n        ```\n        # example\n        mats_to_ascend_beyond_level_20 = chara.ascension_mats[20]\n        \n        for ascension_mat in mats_to_ascend_beyond_level_20:\n            print(ascension_mat.material.name)\n            print(ascension_mat.material.description)\n            print(ascension_mat.count)\n        ```\n\n        \"\"\"\n        ascension_mats = {}\n        for per_ascension_data in self._chara_levelData:\n            \n            level = per_ascension_data['maxLevel']\n            raw_matcounts =per_ascension_data['cost']\n\n            ascension_mats_per_level = []\n            for raw_matcount in raw_matcounts:\n                mat_id = raw_matcount['id']\n\n                from hsr_client.backend.srs_backend.parsers.material import parse_material\n                mat = parse_material(mat_id, self._backend)\n                \n                \n                mat_count = raw_matcount['count']\n\n                ascension_mats_per_level.append(\n                    MaterialCount(\n                    material=mat,\n                    count = mat_count,\n                    )\n                )\n            ascension_mats[level] = ascension_mats_per_level\n\n        return ascension_mats\n    \n    def skills(self) -> List[Skill]:\n        \"\"\"Returns a List of `Skill`s that the character posseses\"\"\"\n        # skills\n        skills = []\n        \n        raw_skills = self._chara_skills\n\n\n        for raw_skill in raw_skills:\n            # name\n            skill_name = raw_skill['name']\n\n            # scaling: LevelScaling\n                        \n\n            scaling = {}\n            for level, level_data in enumerate(raw_skill['levelData'], start=1):\n\n                desc_template = BeautifulSoup(\n                    raw_skill[\"descHash\"], features=\"lxml\"\n                ).get_text()\n\n                template_params = level_data['params']\n\n                skill_desc = desc_template\n                for slot_no, template_param in enumerate(template_params, start=1):\n                    replace_text = f\"#{slot_no}[i]\"\n                    # print(\"replacing: \" + replace_text + \" with \" + str(template_param) + \" in \" + ability_desc)\n                    skill_desc = skill_desc.replace(replace_text, str(template_param))\n\n                \n\n                raw_matcounts =level_data['cost']\n\n                upgrade_mats_per_level = []\n                for raw_matcount in raw_matcounts:\n                    mat_id = raw_matcount['id']\n\n                    from hsr_client.backend.srs_backend.parsers.material import parse_material\n                    mat = parse_material(mat_id, self._backend)\n                    \n                    \n                    mat_count = raw_matcount['count']\n\n                    upgrade_mats_per_level.append(\n                        MaterialCount(\n                        material=mat,\n                        count = mat_count,\n                        )\n                    )\n\n                scaling[level] = trace.LevelScaling(\n                    upgrade_mats=upgrade_mats_per_level,\n                    description=skill_desc\n                )\n\n            skills.append(\n                Skill(\n                    name=skill_name,\n                    scaling=scaling,\n                )\n            )\n        return skills", "\n"]}
{"filename": "tests/srs_backend_test.py", "chunked_list": ["\nimport unittest\nfrom hsr_client.backend.srs_backend import SRSBackend\nfrom hsr_client.backend.srs_backend.parsers.trace import parse_trace_data\nfrom hsr_client.datamodels.searchItem import SearchItem\nfrom hsr_client.constants import Item\n\nclass Test_backend(unittest.TestCase):\n    \n    def test_traces(self):\n        import json\n        with open(\"tests/data/traces.json\") as f:\n            trace_node= json.load(f)\n            print(trace_data)\n            traces = []\n            parse_trace_data(trace_node, traces)\n            for trace in traces:\n                ...\n\n    def test_chara(self):\n\n        srs = SRSBackend()\n        chara = srs.get_character(target_name=\"march\")\n        print(chara.name)\n\n    def test_mtrl(self):\n\n        srs = SRSBackend()\n        mtrl = srs.resolve_material(search_item=SearchItem(url='', iconPath='', type=Item.MATERIAL, name='', rarity=4, id=24001))\n        print(mtrl)", "\nif __name__ == \"__main__\":\n    unittest.main()"]}
