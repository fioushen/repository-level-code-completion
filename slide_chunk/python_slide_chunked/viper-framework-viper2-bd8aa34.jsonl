{"filename": "setup.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nfrom setuptools import setup\n\nsetup()\n"]}
{"filename": "viper2/__init__.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nfrom viper2.common.printer import Printer\n\nprinter = Printer()\n"]}
{"filename": "viper2/common/version.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nVIPER_VERSION = \"2.0\"\n"]}
{"filename": "viper2/common/arguments.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nimport argparse\nfrom typing import Optional\n\n\nclass ArgumentError(Exception):\n    pass", "class ArgumentError(Exception):\n    pass\n\n\nclass ArgumentParser(argparse.ArgumentParser):\n    def error(self, message: str):\n        raise ArgumentError()\n\n    def exit(self, status: Optional[int] = 0, message: Optional[str] = None):\n        raise ArgumentError()", ""]}
{"filename": "viper2/common/errors.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nERROR_NO_OPEN_FILE = \"This command expects a session to a file to be open\"\n"]}
{"filename": "viper2/common/sanitize.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\ndef sanitize_url(url: str) -> str:\n    return url.replace(\"http\", \"hxxp\").replace(\".\", \"[.]\")\n"]}
{"filename": "viper2/common/__init__.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n"]}
{"filename": "viper2/common/module.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nfrom argparse import Namespace\nfrom typing import Any, Tuple\n\nfrom .arguments import ArgumentError, ArgumentParser\nfrom .file import FileObject\n", "from .file import FileObject\n\n\nclass ModuleRunError(Exception):\n    pass\n\n\nclass Module:\n    cmd = \"\"\n    description = \"\"\n\n    def __init__(self) -> None:\n        self.args: Namespace\n        self.__args_input: Tuple[Any, ...]\n        self.args_parser = ArgumentParser(prog=self.cmd, description=self.description)\n\n    def add_args(self, *args: Any) -> None:\n        self.__args_input = args\n\n    @staticmethod\n    def supports_file(file_object: FileObject) -> bool:\n        raise NotImplementedError\n\n    def run(self) -> None:\n        try:\n            self.args = self.args_parser.parse_args(self.__args_input)\n        except ArgumentError as exc:\n            raise ModuleRunError() from exc", ""]}
{"filename": "viper2/common/printer.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nfrom typing import Any\n\nfrom rich.console import Console\nfrom rich.table import Table\n\n\nclass Printer:\n    def __init__(self):\n        self.__console = Console()\n\n    def info(self, msg: str, *args: Any) -> None:\n        self.__console.print(msg % args)\n\n    def warning(self, msg: str, *args: Any) -> None:\n        self.__console.print(f\"[yellow]WARNING: {msg % args}[/]\")\n\n    def error(self, msg: str, *args: Any) -> None:\n        self.__console.print(f\"[red]ERROR: {msg % args}[/]\")\n\n    def success(self, msg: str, *args: Any) -> None:\n        self.__console.print(f\"[green]{msg % args}[/]\")\n\n    def table(self, columns, rows) -> None:\n        table = Table(show_header=True, header_style=\"bold\")\n\n        for column in columns:\n            table.add_column(column)\n\n        for row in rows:\n            table.add_row(*row)\n\n        self.__console.print(table)", "\n\nclass Printer:\n    def __init__(self):\n        self.__console = Console()\n\n    def info(self, msg: str, *args: Any) -> None:\n        self.__console.print(msg % args)\n\n    def warning(self, msg: str, *args: Any) -> None:\n        self.__console.print(f\"[yellow]WARNING: {msg % args}[/]\")\n\n    def error(self, msg: str, *args: Any) -> None:\n        self.__console.print(f\"[red]ERROR: {msg % args}[/]\")\n\n    def success(self, msg: str, *args: Any) -> None:\n        self.__console.print(f\"[green]{msg % args}[/]\")\n\n    def table(self, columns, rows) -> None:\n        table = Table(show_header=True, header_style=\"bold\")\n\n        for column in columns:\n            table.add_column(column)\n\n        for row in rows:\n            table.add_row(*row)\n\n        self.__console.print(table)", ""]}
{"filename": "viper2/common/file.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nimport binascii\nimport hashlib\nimport os\n\nimport magic\n", "import magic\n\n\n# pylint: disable=too-many-instance-attributes\nclass FileObject:\n    def __init__(self, path: str):\n        self.path = path\n        self.name = \"\"\n        self.size = 0\n        self.magic = \"\"\n        self.mime = \"\"\n        self.md5 = \"\"\n        self.sha1 = \"\"\n        self.sha256 = \"\"\n        self.sha512 = \"\"\n        self.crc32 = \"\"\n        self.ssdeep = \"\"\n\n        if os.path.exists(self.path) and os.path.isfile(self.path):\n            self.name = os.path.basename(self.path)\n            self.size = os.path.getsize(self.path)\n            self.magic = magic.from_file(self.path)\n            self.mime = magic.from_file(self.path, mime=True)\n            self.__hashes()\n\n    @property\n    def data(self):\n        with open(self.path, \"rb\") as handle:\n            return handle.read()\n\n    def get_chunks(self):\n        with open(self.path, \"rb\") as handle:\n            while True:\n                chunk = handle.read(16 * 1024)\n                if not chunk:\n                    break\n                yield chunk\n\n    def __hashes(self):\n        crc = 0\n        md5 = hashlib.md5()\n        sha1 = hashlib.sha1()\n        sha256 = hashlib.sha256()\n        sha512 = hashlib.sha512()\n\n        for chunk in self.get_chunks():\n            crc = binascii.crc32(chunk, crc)\n            md5.update(chunk)\n            sha1.update(chunk)\n            sha256.update(chunk)\n            sha512.update(chunk)\n\n        # pylint: disable=consider-using-f-string\n        self.crc32 = \"\".join(\"%02X\" % ((crc >> i) & 0xFF) for i in [24, 16, 8, 0])\n        self.md5 = md5.hexdigest()\n        self.sha1 = sha1.hexdigest()\n        self.sha256 = sha256.hexdigest()\n        self.sha512 = sha512.hexdigest()", ""]}
{"filename": "viper2/core/database.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nimport datetime\n\nfrom peewee import (\n    CharField,\n    DatabaseProxy,\n    DateTimeField,", "    DatabaseProxy,\n    DateTimeField,\n    ForeignKeyField,\n    IntegerField,\n    Model,\n    SqliteDatabase,\n    TextField,\n)\n\ndatabase_proxy = DatabaseProxy()", "\ndatabase_proxy = DatabaseProxy()\n\n\nclass BaseModel(Model):\n    class Meta:  # pylint: disable=too-few-public-methods\n        database = database_proxy\n\n\nclass File(BaseModel):\n    name = CharField()\n    size = IntegerField()\n    magic = CharField()\n    mime = CharField()\n    md5 = CharField()\n    crc32 = CharField()\n    sha1 = CharField()\n    sha256 = CharField()\n    sha512 = CharField()\n    ssdeep = CharField()\n    created_date = DateTimeField(default=datetime.datetime.now)\n    parent = ForeignKeyField(\"self\", backref=\"children\", null=True)", "\nclass File(BaseModel):\n    name = CharField()\n    size = IntegerField()\n    magic = CharField()\n    mime = CharField()\n    md5 = CharField()\n    crc32 = CharField()\n    sha1 = CharField()\n    sha256 = CharField()\n    sha512 = CharField()\n    ssdeep = CharField()\n    created_date = DateTimeField(default=datetime.datetime.now)\n    parent = ForeignKeyField(\"self\", backref=\"children\", null=True)", "\n\nclass Tag(BaseModel):\n    file = ForeignKeyField(File, backref=\"tags\")\n    name = CharField(unique=True)\n\n\nclass Note(BaseModel):\n    file = ForeignKeyField(File, backref=\"notes\")\n    title = CharField()\n    body = TextField()", "\n\ndef init_db(db_path: str) -> None:\n    database_proxy.initialize(SqliteDatabase(db_path))\n    database_proxy.create_tables([File, Tag, Note])\n"]}
{"filename": "viper2/core/projects.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nimport logging\nimport os\n\nfrom .database import init_db\nfrom .storage import Storage\n", "from .storage import Storage\n\nlog = logging.getLogger(\"viper\")\n\nPROJECT_DEFAULT = \"default\"\n\n\n# pylint: disable=too-few-public-methods\nclass Project:\n    def __init__(self, name: str) -> None:\n        self.name = name\n        if self.name == PROJECT_DEFAULT:\n            self.path = Storage().root_path\n        else:\n            self.path = os.path.join(Storage().projects_path, self.name)\n\n        if not os.path.exists(self.path):\n            os.makedirs(self.path)\n\n        init_db(os.path.join(self.path, \"viper.db\"))\n\n    def is_default(self) -> bool:\n        if self.name == PROJECT_DEFAULT:\n            return True\n\n        return False", "class Project:\n    def __init__(self, name: str) -> None:\n        self.name = name\n        if self.name == PROJECT_DEFAULT:\n            self.path = Storage().root_path\n        else:\n            self.path = os.path.join(Storage().projects_path, self.name)\n\n        if not os.path.exists(self.path):\n            os.makedirs(self.path)\n\n        init_db(os.path.join(self.path, \"viper.db\"))\n\n    def is_default(self) -> bool:\n        if self.name == PROJECT_DEFAULT:\n            return True\n\n        return False", "\n\nclass Projects:\n    def __init__(self) -> None:\n        self.current = Project(PROJECT_DEFAULT)\n\n    def open(self, name: str) -> None:\n        self.current = Project(name)\n\n    def close(self) -> None:\n        if self.current and self.current.name != PROJECT_DEFAULT:\n            self.current = Project(PROJECT_DEFAULT)\n\n    def list(self) -> list:\n        if not os.path.exists(Storage().projects_path):\n            return []\n\n        projects_list = []\n        for project_name in os.listdir(Storage().projects_path):\n            projects_list.append(os.path.join(Storage().projects_path, project_name))\n\n        return projects_list", "\n\nprojects = Projects()\n"]}
{"filename": "viper2/core/sessions.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nimport datetime\nimport os\nimport time\nfrom typing import List, Optional\n\nfrom viper2 import printer", "\nfrom viper2 import printer\n\nfrom ..common.file import FileObject\nfrom .database import File\n\n\n# pylint: disable=too-few-public-methods\nclass Session:\n    def __init__(self) -> None:\n        self.identifier: int\n        self.file: FileObject\n        self.created_at = datetime.datetime.fromtimestamp(time.time()).strftime(\n            \"%Y-%m-%d %H:%M:%S\"\n        )", "class Session:\n    def __init__(self) -> None:\n        self.identifier: int\n        self.file: FileObject\n        self.created_at = datetime.datetime.fromtimestamp(time.time()).strftime(\n            \"%Y-%m-%d %H:%M:%S\"\n        )\n\n\nclass Sessions:\n    def __init__(self) -> None:\n        self.current: Optional[Session] = None\n        self.__sessions: List[Session] = []\n\n        # This is used to keep trace of the results from the last \"find\" command\n        # so we can reference them in other commands (primarily \"open\").\n        # TODO: However, this is not really the optimal place for this, as\n        #       this class is intended only to keep track of currently open\n        #       files. Find results are a little off-spec.\n        self.__last_find: List[File] = []\n\n    def add_find(self, results: List[File]) -> None:\n        self.__last_find = results\n\n    def get_find(self) -> List[File]:\n        return self.__last_find\n\n    def all(self) -> List[Session]:\n        return self.__sessions\n\n    def close(self) -> None:\n        self.current = None\n\n    def reset(self) -> None:\n        self.close()\n        self.__sessions = []\n\n    def switch(self, session: Session) -> None:\n        self.current = session\n\n    def new(self, file_path: str) -> None:\n        file_object = FileObject(file_path)\n        for session in self.__sessions:\n            if session.file and session.file.path == file_path:\n                printer.error(\n                    \"There is already a session open with file to path %s\",\n                    session.file.path,\n                )\n                return\n\n        if not os.path.exists(file_object.path):\n            printer.error(\"File does not exist at path %s\", file_object.path)\n            return\n\n        session = Session()\n        session.identifier = len(self.__sessions) + 1\n        session.file = file_object\n\n        try:\n            file = File.get(File.sha256 == file_object.sha256)\n        except File.DoesNotExist:  # pylint: disable=no-member\n            pass\n        else:\n            session.file.name = file.name\n\n        self.__sessions.append(session)\n        self.current = session\n\n        printer.success(\n            \"New session opened to file %s with ID %d\",\n            session.file.path,\n            session.identifier,\n        )", "\nclass Sessions:\n    def __init__(self) -> None:\n        self.current: Optional[Session] = None\n        self.__sessions: List[Session] = []\n\n        # This is used to keep trace of the results from the last \"find\" command\n        # so we can reference them in other commands (primarily \"open\").\n        # TODO: However, this is not really the optimal place for this, as\n        #       this class is intended only to keep track of currently open\n        #       files. Find results are a little off-spec.\n        self.__last_find: List[File] = []\n\n    def add_find(self, results: List[File]) -> None:\n        self.__last_find = results\n\n    def get_find(self) -> List[File]:\n        return self.__last_find\n\n    def all(self) -> List[Session]:\n        return self.__sessions\n\n    def close(self) -> None:\n        self.current = None\n\n    def reset(self) -> None:\n        self.close()\n        self.__sessions = []\n\n    def switch(self, session: Session) -> None:\n        self.current = session\n\n    def new(self, file_path: str) -> None:\n        file_object = FileObject(file_path)\n        for session in self.__sessions:\n            if session.file and session.file.path == file_path:\n                printer.error(\n                    \"There is already a session open with file to path %s\",\n                    session.file.path,\n                )\n                return\n\n        if not os.path.exists(file_object.path):\n            printer.error(\"File does not exist at path %s\", file_object.path)\n            return\n\n        session = Session()\n        session.identifier = len(self.__sessions) + 1\n        session.file = file_object\n\n        try:\n            file = File.get(File.sha256 == file_object.sha256)\n        except File.DoesNotExist:  # pylint: disable=no-member\n            pass\n        else:\n            session.file.name = file.name\n\n        self.__sessions.append(session)\n        self.current = session\n\n        printer.success(\n            \"New session opened to file %s with ID %d\",\n            session.file.path,\n            session.identifier,\n        )", "\n\nsessions = Sessions()\n"]}
{"filename": "viper2/core/__init__.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n"]}
{"filename": "viper2/core/storage.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nimport os\n\nfrom platformdirs import user_data_dir\n\nfrom viper2 import printer\n", "from viper2 import printer\n\nfrom ..common.file import FileObject\n\n\nclass Storage:\n    def __init__(self) -> None:\n        self.root_path = user_data_dir(\"viper2\", \"viper2\")\n        self.projects_path = os.path.join(self.root_path, \"projects\")\n\n    def add_file(self, project_path: str, file_object: FileObject) -> str:\n        sha256 = file_object.sha256\n        if not sha256:\n            printer.error(\"The file does not have a valid sha256 hash\")\n            return \"\"\n\n        file_dir = os.path.join(\n            project_path, \"files\", sha256[0], sha256[1], sha256[2], sha256[3]\n        )\n\n        if not os.path.exists(file_dir):\n            os.makedirs(file_dir)\n\n        file_path = os.path.join(file_dir, sha256)\n\n        if os.path.exists(file_path):\n            printer.warning(\"The file exists already, skip\")\n            return file_path\n\n        with open(file_path, \"wb\") as handle:\n            for chunk in file_object.get_chunks():\n                handle.write(chunk)\n\n        printer.success(\"Successfully stored file in repository\")\n        return file_path\n\n    def get_file_path(self, project_path: str, sha256: str) -> str:\n        file_path = os.path.join(\n            project_path, \"files\", sha256[0], sha256[1], sha256[2], sha256[3], sha256\n        )\n\n        if not os.path.exists(file_path):\n            return \"\"\n\n        return file_path", ""]}
{"filename": "viper2/core/modules.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nimport importlib\nimport inspect\nimport os\nimport pkgutil\nimport shutil\nimport sys", "import shutil\nimport sys\nimport tempfile\n\nfrom pipreqs import pipreqs  # type: ignore\n\nfrom viper2 import printer\n\nfrom ..common.module import Module\n", "from ..common.module import Module\n\nmodules = {}\n\n\ndef get_module_dependencies(module_path: str) -> list:\n    if not os.path.exists(module_path):\n        return []\n\n    imports = []\n    with tempfile.TemporaryDirectory() as temp_dir:\n        shutil.copy(module_path, os.path.join(temp_dir, os.path.basename(module_path)))\n        imports = pipreqs.get_all_imports(temp_dir)\n\n    return imports", "\n\ndef have_dependency(dependency: str) -> bool:\n    if dependency == \"viper\":\n        return True\n\n    try:\n        importlib.import_module(dependency)\n    except ModuleNotFoundError:\n        return False\n\n    return True", "\n\ndef load_modules(modules_path: str) -> None:\n    if not modules_path:\n        return\n\n    if not os.path.exists(modules_path):\n        printer.error(\"The modules directory does not exist at path: %s\", modules_path)\n        return\n\n    sys.path.insert(0, modules_path)\n    for _, module_name, ispkg in pkgutil.iter_modules([modules_path]):\n        if ispkg:\n            continue\n\n        module_path = os.path.join(modules_path, f\"{module_name}.py\")\n        dependencies = get_module_dependencies(module_path)\n        can_import = True\n        for dep in dependencies:\n            if not have_dependency(dep):\n                can_import = False\n                printer.error(\n                    \"Module at path %s requires the following missing library: '%s'\",\n                    module_path,\n                    dep,\n                )\n\n        if not can_import:\n            printer.error(\"Cannot proceed importing module '%s'\", module_name)\n            continue\n\n        try:\n            module = importlib.import_module(module_name)\n        except ImportError as exc:\n            printer.error(\n                \"Failed to import module with name '%s': %s\", module_name, exc\n            )\n            continue\n\n        for member_name, member_object in inspect.getmembers(module):\n            if not inspect.isclass(member_object):\n                continue\n\n            if issubclass(member_object, Module) and member_object is not Module:\n                if not hasattr(member_object, \"cmd\"):\n                    printer.error(\n                        \"The module %s does not have a `cmd` attribute, cannot load\",\n                        member_name,\n                    )\n                    continue\n\n                # printer.debug(\n                #     \"Loaded module %s (%s)\",\n                #     member_object.cmd,\n                #     member_object.description,\n                # )\n                modules[member_object.cmd] = {\n                    \"class\": member_object,\n                    \"description\": member_object.description,\n                }\n\n    sys.path.remove(modules_path)", ""]}
{"filename": "viper2/ui/__init__.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nimport argparse\nimport shlex\n\nfrom viper2 import printer\n\nfrom ..core.modules import load_modules, modules", "\nfrom ..core.modules import load_modules, modules\nfrom ..core.projects import projects\nfrom ..core.sessions import sessions\nfrom .cmd import load_commands\nfrom .shell import Shell\n\n\ndef run(cmd: str, modules_path: str) -> None:\n    commands = load_commands()\n    load_modules(modules_path)\n    cmd_words = shlex.split(cmd)\n    cmd_name = cmd_words[0].lower().strip()\n    cmd_args = cmd_words[1:]\n\n    if cmd_name in commands:\n        cmd = commands[cmd_name][\"class\"]()\n        cmd.add_args(*cmd_args)\n        cmd.run()\n    elif cmd_name in modules:\n        mod = modules[cmd_name][\"class\"]()\n        mod.add_args(*cmd_args)\n        mod.run()\n    else:\n        printer.error('No module or command found for \"%s\"', cmd_name)", "def run(cmd: str, modules_path: str) -> None:\n    commands = load_commands()\n    load_modules(modules_path)\n    cmd_words = shlex.split(cmd)\n    cmd_name = cmd_words[0].lower().strip()\n    cmd_args = cmd_words[1:]\n\n    if cmd_name in commands:\n        cmd = commands[cmd_name][\"class\"]()\n        cmd.add_args(*cmd_args)\n        cmd.run()\n    elif cmd_name in modules:\n        mod = modules[cmd_name][\"class\"]()\n        mod.add_args(*cmd_args)\n        mod.run()\n    else:\n        printer.error('No module or command found for \"%s\"', cmd_name)", "\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        prog=\"viper\", description=\"Binary analysis and management framework\"\n    )\n    parser.add_argument(\n        \"-m\",\n        \"--modules\",\n        action=\"store\",\n        metavar=\"MODULES_PATH\",\n        help=\"path to a folder containing Viper modules to load\",\n    )\n    parser.add_argument(\n        \"-p\",\n        \"--project\",\n        action=\"store\",\n        metavar=\"PROJECT_NAME\",\n        help=\"open a project\",\n    )\n    parser.add_argument(\n        \"-o\",\n        \"--open\",\n        action=\"store\",\n        metavar=\"FILE_PATH\",\n        help=\"open a file\",\n    )\n    parser.add_argument(\n        \"-r\",\n        \"--run\",\n        action=\"store\",\n        metavar=\"COMMAND\",\n        help=\"run a command or module instead of opening the shell\",\n    )\n    args = parser.parse_args()\n\n    if args.project:\n        projects.open(args.project)\n\n    if args.open:\n        sessions.new(args.open)\n\n    if args.run:\n        run(cmd=args.run, modules_path=args.modules)\n        return\n\n    shell = Shell(modules_path=args.modules)\n    shell.run()", ""]}
{"filename": "viper2/ui/logo.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nfrom rich.console import Console\n\nfrom ..common.version import VIPER_VERSION\n\n\ndef logo():\n    console = Console()\n    console.print(\n        f\"\"\"\n[red]  \u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 [/]\n[yellow]  \u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588[/]\n[green]  \u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588 [/]\n[blue]   \u2588\u2588  \u2588\u2588  \u2588\u2588 \u2588\u2588      \u2588\u2588      \u2588\u2588   \u2588\u2588[/]\n[magenta]    \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588[/]  [white]v{VIPER_VERSION}[/]\n\"\"\"\n    )", "\ndef logo():\n    console = Console()\n    console.print(\n        f\"\"\"\n[red]  \u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 [/]\n[yellow]  \u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588[/]\n[green]  \u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588 [/]\n[blue]   \u2588\u2588  \u2588\u2588  \u2588\u2588 \u2588\u2588      \u2588\u2588      \u2588\u2588   \u2588\u2588[/]\n[magenta]    \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588[/]  [white]v{VIPER_VERSION}[/]\n\"\"\"\n    )", ""]}
{"filename": "viper2/ui/shell.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nimport shlex\nimport subprocess\nfrom typing import List, Tuple\n\nfrom prompt_toolkit import PromptSession\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory", "from prompt_toolkit import PromptSession\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\nfrom prompt_toolkit.shortcuts import clear as prompt_clear\n\nfrom viper2 import printer\n\nfrom ..core.database import File\nfrom ..core.modules import load_modules, modules\nfrom ..core.projects import projects\nfrom ..core.sessions import sessions", "from ..core.projects import projects\nfrom ..core.sessions import sessions\nfrom .cmd import load_commands\nfrom .logo import logo\n\n\nclass Shell:\n    def __init__(self, modules_path: str = \"\") -> None:\n        self.__running: bool = True\n        self.__commands: dict = {}\n        self.__modules_path: str = modules_path\n        self.__modules: dict = {}\n\n    def __welcome(self) -> None:\n        logo()\n\n        printer.info(\n            \"[magenta]You have [bold]%d[/] file/s in your [bold]%s[/] project[/]\",\n            File.select().count(),\n            projects.current.name,\n        )\n\n    def __prompt(self) -> List[Tuple[str, str]]:\n        text = []\n        if not projects.current.is_default():\n            text.append((\"bold ansicyan\", f\"{projects.current.name} \"))\n\n        text.append((\"ansicyan\", \"viper \"))\n\n        if sessions.current:\n            text.append((\"ansigray\", sessions.current.file.name))\n\n            try:\n                File.get(File.sha256 == sessions.current.file.sha256)\n            except File.DoesNotExist:  # pylint: disable=no-member\n                text.append((\"ansimagenta\", \" [not stored]\"))\n\n        text.append((\"ansicyan\", \"> \"))\n        return text\n\n    def __expand_args(self, args: List[str]) -> List[str]:\n        for index, arg in enumerate(args):\n            if arg == \"$file\" and sessions.current:\n                args[index] = sessions.current.file.path\n\n        return args\n\n    def exit(self) -> None:\n        printer.info(\"Exiting...\")\n        self.__running = False\n\n    def help(self) -> None:\n        rows = [\n            [\"help\", \"Display this help message\"],\n            [\"clear\", \"Clear the screen\"],\n            [\"exit, quit\", \"Exit from the Viper shell\"],\n        ]\n        for cmd_name, cmd_properties in self.__commands.items():\n            rows.append([cmd_name, cmd_properties[\"description\"]])\n\n        printer.info(\"[bold]Commands:[/]\")\n        printer.table(columns=[\"Command\", \"Description\"], rows=rows)\n\n        print(\"\")\n\n        if len(self.__modules) == 0:\n            printer.info(\"No modules available\")\n            return\n\n        rows = []\n        for module_name, module_properties in self.__modules.items():\n            rows.append([module_name, module_properties[\"description\"]])\n\n        printer.info(\"[bold]Modules:[/]\")\n        printer.table(columns=[\"Module\", \"Description\"], rows=rows)\n\n    def clear(self) -> None:\n        prompt_clear()\n\n    def exec(self, cmd_name, cmd_args) -> None:\n        with subprocess.Popen([cmd_name] + cmd_args, stdout=subprocess.PIPE) as proc:\n            stdout, _ = proc.communicate()\n            print(stdout.decode())\n\n    def run(self) -> None:\n        self.__welcome()\n\n        self.__commands = load_commands()\n        load_modules(self.__modules_path)\n        self.__modules = modules\n\n        session: PromptSession = PromptSession()\n\n        while self.__running:\n            try:\n                self.__prompt()\n                cmd_string = session.prompt(\n                    self.__prompt(), auto_suggest=AutoSuggestFromHistory()\n                )\n            except KeyboardInterrupt:\n                continue\n            except EOFError:\n                self.exit()\n                continue\n\n            if cmd_string.strip() == \"\":\n                continue\n\n            cmd_words = shlex.split(cmd_string)\n            cmd_name = cmd_words[0].lower().strip()\n            cmd_args = self.__expand_args(cmd_words[1:])\n\n            if cmd_name.startswith(\"!\"):\n                self.exec(cmd_name[1:], cmd_args)\n                continue\n\n            if cmd_name in (\"exit\", \"quit\"):\n                self.exit()\n                continue\n\n            if cmd_name == \"help\":\n                self.help()\n                continue\n\n            if cmd_name == \"clear\":\n                self.clear()\n                continue\n\n            if cmd_name in self.__commands:\n                cmd = self.__commands[cmd_name][\"class\"]()\n                cmd.add_args(*cmd_args)\n                cmd.run()\n                continue\n\n            if cmd_name in self.__modules:\n                mod = self.__modules[cmd_name][\"class\"]()\n                mod.add_args(*cmd_args)\n                mod.run()\n                continue\n\n            printer.error('No command or module found for \"%s\"', cmd_name)", ""]}
{"filename": "viper2/ui/cmd/parent.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nfrom viper2 import printer\nfrom viper2.common.errors import ERROR_NO_OPEN_FILE\nfrom viper2.core.database import File\nfrom viper2.core.sessions import sessions\n\nfrom .command import Command", "\nfrom .command import Command\n\n\nclass Parent(Command):\n    cmd = \"parent\"\n    description = \"Specify a parent to the currently open file\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        subparsers = self.args_parser.add_subparsers(dest=\"subname\")\n        subparsers.add_parser(\"delete\", help=\"Delete the existing parent\")\n        add = subparsers.add_parser(\n            \"add\", help=\"Add a parent ot the currently open file\"\n        )\n        add.add_argument(\"parent\", help=\"SHA256 hash of the parent\")\n\n    def run(self) -> None:\n        super().run()\n\n        if not sessions.current:\n            printer.error(ERROR_NO_OPEN_FILE)\n            return\n\n        try:\n            file = File.get(File.sha256 == sessions.current.file.sha256)\n        except File.DoesNotExist:  # pylint: disable=no-member\n            printer.error(\n                'The currently open file is not stored, use \"store\" command first'\n            )\n            return\n\n        if self.args.subname == \"delete\":\n            file.parent = None\n            file.save()\n            printer.success(\"Parent successfully deleted\")\n        elif self.args.subname == \"add\":\n            if file.parent:\n                printer.error(\"The currently open file already has a parent!\")\n                return\n\n            if self.args.parent == sessions.current.file.sha256:\n                printer.error(\n                    \"The specified parent is the same as the currently open file\"\n                )\n                return\n\n            try:\n                parent = File.get(File.sha256 == self.args.parent)\n            except File.DoesNotExist:  # pylint: disable=no-member\n                printer.error(\n                    \"The specified parent with hash %s does not exist\", self.args.parent\n                )\n                return\n\n            file.parent = parent\n            file.save()\n\n            printer.success(\"Successfully added parent\")\n        else:\n            if not file.parent:\n                printer.info(\"The currently open file does not have a parent\")\n            else:\n                printer.table(\n                    columns=[\"Date\", \"Name\", \"SHA1\", \"Magic\", \"Tags\"],\n                    rows=[\n                        [\n                            str(file.parent.created_date),\n                            file.parent.name,\n                            file.parent.sha1,\n                            file.parent.magic,\n                            \", \".join(tag.name for tag in file.parent.tags),\n                        ]\n                    ],\n                )", ""]}
{"filename": "viper2/ui/cmd/info.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nfrom typing import cast\n\nfrom viper2 import printer\nfrom viper2.common.errors import ERROR_NO_OPEN_FILE\nfrom viper2.common.module import Module\nfrom viper2.core.database import File, Tag", "from viper2.common.module import Module\nfrom viper2.core.database import File, Tag\nfrom viper2.core.modules import modules\nfrom viper2.core.sessions import sessions\n\nfrom .command import Command\n\n\nclass Info(Command):\n    cmd = \"info\"\n    description = \"Show information on the open file\"\n\n    def run(self) -> None:\n        if not sessions.current:\n            printer.error(ERROR_NO_OPEN_FILE)\n            return\n\n        try:\n            file = File.get(File.sha256 == sessions.current.file.sha256)\n            tags = Tag.select().where(Tag.file == file)\n        except File.DoesNotExist:  # pylint: disable=no-member\n            tags_string = \"\"\n        else:\n            tags_string = \", \".join(tag.name for tag in list(tags))\n\n        printer.table(\n            columns=[\"Key\", \"Value\"],\n            rows=[\n                [\"Name\", sessions.current.file.name],\n                [\"Tags\", tags_string],\n                [\"Path\", sessions.current.file.path],\n                [\"Size\", str(sessions.current.file.size)],\n                [\"Magic\", sessions.current.file.magic],\n                [\"Mime\", sessions.current.file.mime],\n                [\"MD5\", sessions.current.file.md5],\n                [\"SHA1\", sessions.current.file.sha1],\n                [\"SHA256\", sessions.current.file.sha256],\n                [\"SHA512\", sessions.current.file.sha512],\n                [\"SSdeep\", sessions.current.file.ssdeep],\n                [\"CRC32\", sessions.current.file.crc32],\n            ],\n        )\n\n        supported_modules = []\n        for module_name, module_properties in modules.items():\n            mod = cast(Module, module_properties[\"class\"])\n            try:\n                if mod.supports_file(sessions.current.file):\n                    supported_modules.append(\n                        [module_name, module_properties[\"description\"]]\n                    )\n            except NotImplementedError:\n                pass\n\n        if len(supported_modules) > 0:\n            print(\"\")\n\n            printer.info(\"The following modules support the analysis of this file:\")\n            printer.table(columns=[\"Module\", \"Description\"], rows=supported_modules)", "class Info(Command):\n    cmd = \"info\"\n    description = \"Show information on the open file\"\n\n    def run(self) -> None:\n        if not sessions.current:\n            printer.error(ERROR_NO_OPEN_FILE)\n            return\n\n        try:\n            file = File.get(File.sha256 == sessions.current.file.sha256)\n            tags = Tag.select().where(Tag.file == file)\n        except File.DoesNotExist:  # pylint: disable=no-member\n            tags_string = \"\"\n        else:\n            tags_string = \", \".join(tag.name for tag in list(tags))\n\n        printer.table(\n            columns=[\"Key\", \"Value\"],\n            rows=[\n                [\"Name\", sessions.current.file.name],\n                [\"Tags\", tags_string],\n                [\"Path\", sessions.current.file.path],\n                [\"Size\", str(sessions.current.file.size)],\n                [\"Magic\", sessions.current.file.magic],\n                [\"Mime\", sessions.current.file.mime],\n                [\"MD5\", sessions.current.file.md5],\n                [\"SHA1\", sessions.current.file.sha1],\n                [\"SHA256\", sessions.current.file.sha256],\n                [\"SHA512\", sessions.current.file.sha512],\n                [\"SSdeep\", sessions.current.file.ssdeep],\n                [\"CRC32\", sessions.current.file.crc32],\n            ],\n        )\n\n        supported_modules = []\n        for module_name, module_properties in modules.items():\n            mod = cast(Module, module_properties[\"class\"])\n            try:\n                if mod.supports_file(sessions.current.file):\n                    supported_modules.append(\n                        [module_name, module_properties[\"description\"]]\n                    )\n            except NotImplementedError:\n                pass\n\n        if len(supported_modules) > 0:\n            print(\"\")\n\n            printer.info(\"The following modules support the analysis of this file:\")\n            printer.table(columns=[\"Module\", \"Description\"], rows=supported_modules)", ""]}
{"filename": "viper2/ui/cmd/store.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nfrom viper2 import printer\nfrom viper2.common.errors import ERROR_NO_OPEN_FILE\nfrom viper2.common.file import FileObject\nfrom viper2.core.database import File\nfrom viper2.core.projects import projects\nfrom viper2.core.sessions import sessions", "from viper2.core.projects import projects\nfrom viper2.core.sessions import sessions\nfrom viper2.core.storage import Storage\n\nfrom .command import Command, CommandRunError\n\n\nclass Store(Command):\n    cmd = \"store\"\n    description = \"Store one or multiple files in the database and the local repository\"\n\n    def add_file(self, file_object: FileObject) -> None:\n        try:\n            File.get(File.sha256 == file_object.sha256)\n        except File.DoesNotExist:  # pylint: disable=no-member\n            file = File(\n                name=file_object.name,\n                size=file_object.size,\n                magic=file_object.magic,\n                mime=file_object.mime,\n                md5=file_object.md5,\n                crc32=file_object.crc32,\n                sha1=file_object.sha1,\n                sha256=file_object.sha256,\n                sha512=file_object.sha512,\n                ssdeep=file_object.ssdeep,\n            )\n            file.save()\n            printer.success(\"Stored file details into database\")\n\n        storage = Storage()\n        if not storage.get_file_path(projects.current.path, file_object.sha256):\n            new_path = storage.add_file(projects.current.path, file_object)\n            printer.success(\"Stored file %s to %s\", file_object.name, new_path)\n\n    def run(self) -> None:\n        try:\n            super().run()\n        except CommandRunError:\n            return\n\n        if not sessions.current:\n            printer.error(ERROR_NO_OPEN_FILE)\n            return\n\n        self.add_file(sessions.current.file)", ""]}
{"filename": "viper2/ui/cmd/projects.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nimport os\nimport shutil\nimport time\n\nfrom prompt_toolkit.shortcuts import confirm\n", "from prompt_toolkit.shortcuts import confirm\n\nfrom viper2 import printer\nfrom viper2.core.projects import projects\nfrom viper2.core.sessions import sessions\n\nfrom .command import Command, CommandRunError\n\n\nclass Projects(Command):\n    cmd = \"projects\"\n    description = \"List or switch existing projects\"\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        group = self.args_parser.add_mutually_exclusive_group()\n        group.add_argument(\n            \"-l\", \"--list\", action=\"store_true\", help=\"list all existing projects\"\n        )\n        group.add_argument(\n            \"-s\",\n            \"--switch\",\n            metavar=\"PROJECT NAME\",\n            help=\"switch to the specified project (create one if it doesn't exist)\",\n        )\n        group.add_argument(\n            \"-c\",\n            \"--close\",\n            action=\"store_true\",\n            help=\"close the currently open project\",\n        )\n        group.add_argument(\n            \"-d\",\n            \"--delete\",\n            metavar=\"PROJECT NAME\",\n            help=\"delete the specified project\",\n        )\n\n    def run(self) -> None:\n        try:\n            super().run()\n        except CommandRunError:\n            return\n\n        if self.args.list:\n            projects_list = projects.list()\n            if len(projects_list) == 0:\n                printer.info(\"There are no projects currently\")\n                return\n\n            rows = []\n            for project_path in projects_list:\n                project_name = os.path.basename(project_path)\n                project_ct_date = time.ctime(os.path.getctime(project_path))\n                rows.append([project_name, project_ct_date])\n\n            printer.table(columns=[\"Project Name\", \"Creation Date\"], rows=rows)\n        elif self.args.switch:\n            # When we switch project, we reset sessions so that any previously\n            # open sessions are closed and removed.\n            sessions.reset()\n            projects.open(self.args.switch)\n            printer.success('Switched to project with name \"%s\"', self.args.switch)\n        elif self.args.close:\n            # Similarly to switch, if we close the current project, we should\n            # also close all active sessions.\n            sessions.reset()\n            projects.close()\n        elif self.args.delete:\n            delete = confirm(\n                \"Are you sure? This will permanently delete all files in that project!\"\n            )\n            if not delete:\n                return\n\n            if projects.current.name == self.args.delete:\n                projects.close()\n\n            for project_path in projects.list():\n                if os.path.basename(project_path) == self.args.delete:\n                    shutil.rmtree(project_path)\n                    printer.success(\n                        \"Successfully deleted project at path %s\", project_path\n                    )\n                    return\n\n            printer.error('Could not find a project with name \"%s\"', self.args.delete)\n        else:\n            self.args_parser.print_usage()", "\nclass Projects(Command):\n    cmd = \"projects\"\n    description = \"List or switch existing projects\"\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        group = self.args_parser.add_mutually_exclusive_group()\n        group.add_argument(\n            \"-l\", \"--list\", action=\"store_true\", help=\"list all existing projects\"\n        )\n        group.add_argument(\n            \"-s\",\n            \"--switch\",\n            metavar=\"PROJECT NAME\",\n            help=\"switch to the specified project (create one if it doesn't exist)\",\n        )\n        group.add_argument(\n            \"-c\",\n            \"--close\",\n            action=\"store_true\",\n            help=\"close the currently open project\",\n        )\n        group.add_argument(\n            \"-d\",\n            \"--delete\",\n            metavar=\"PROJECT NAME\",\n            help=\"delete the specified project\",\n        )\n\n    def run(self) -> None:\n        try:\n            super().run()\n        except CommandRunError:\n            return\n\n        if self.args.list:\n            projects_list = projects.list()\n            if len(projects_list) == 0:\n                printer.info(\"There are no projects currently\")\n                return\n\n            rows = []\n            for project_path in projects_list:\n                project_name = os.path.basename(project_path)\n                project_ct_date = time.ctime(os.path.getctime(project_path))\n                rows.append([project_name, project_ct_date])\n\n            printer.table(columns=[\"Project Name\", \"Creation Date\"], rows=rows)\n        elif self.args.switch:\n            # When we switch project, we reset sessions so that any previously\n            # open sessions are closed and removed.\n            sessions.reset()\n            projects.open(self.args.switch)\n            printer.success('Switched to project with name \"%s\"', self.args.switch)\n        elif self.args.close:\n            # Similarly to switch, if we close the current project, we should\n            # also close all active sessions.\n            sessions.reset()\n            projects.close()\n        elif self.args.delete:\n            delete = confirm(\n                \"Are you sure? This will permanently delete all files in that project!\"\n            )\n            if not delete:\n                return\n\n            if projects.current.name == self.args.delete:\n                projects.close()\n\n            for project_path in projects.list():\n                if os.path.basename(project_path) == self.args.delete:\n                    shutil.rmtree(project_path)\n                    printer.success(\n                        \"Successfully deleted project at path %s\", project_path\n                    )\n                    return\n\n            printer.error('Could not find a project with name \"%s\"', self.args.delete)\n        else:\n            self.args_parser.print_usage()", ""]}
{"filename": "viper2/ui/cmd/children.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nfrom viper2 import printer\nfrom viper2.common.errors import ERROR_NO_OPEN_FILE\nfrom viper2.core.database import File\nfrom viper2.core.sessions import sessions\n\nfrom .command import Command", "\nfrom .command import Command\n\n\nclass Children(Command):\n    cmd = \"children\"\n    description = \"Get a list of the open file's children\"\n\n    def run(self) -> None:\n        if not sessions.current:\n            printer.error(ERROR_NO_OPEN_FILE)\n            return\n\n        try:\n            file = File.get(File.sha256 == sessions.current.file.sha256)\n        except File.DoesNotExist:  # pylint: disable=no-member\n            printer.error(\"The currently open file is not stored\")\n            return\n\n        rows = []\n        for child in file.children:\n            rows.append(\n                [\n                    str(child.created_date),\n                    child.name,\n                    child.sha1,\n                    child.magic,\n                    \", \".join(tag.name for tag in child.tags),\n                ]\n            )\n\n        if len(rows) == 0:\n            printer.info(\"The currently open file does not have children\")\n            return\n\n        printer.table(columns=[\"Date\", \"Name\", \"SHA1\", \"Magic\", \"Tags\"], rows=rows)", ""]}
{"filename": "viper2/ui/cmd/sessions.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nfrom viper2 import printer\nfrom viper2.core.sessions import sessions\n\nfrom .command import Command, CommandRunError\n\n\nclass Sessions(Command):\n    cmd = \"sessions\"\n    description = \"List or switch sessions\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        group = self.args_parser.add_mutually_exclusive_group()\n        group.add_argument(\n            \"-l\", \"--list\", action=\"store_true\", help=\"list all existing sessions\"\n        )\n        group.add_argument(\n            \"-s\", \"--switch\", type=int, help=\"switch to the specified session\"\n        )\n\n    def __list(self) -> None:\n        if not sessions.all():\n            printer.info(\"There are no open sessions\")\n            return\n\n        rows = []\n        for session in sessions.all():\n            current = \"\"\n            if session == sessions.current:\n                current = \"Yes\"\n\n            rows.append(\n                [\n                    str(session.identifier),\n                    session.file.name,\n                    session.file.sha1,\n                    session.created_at,\n                    current,\n                ]\n            )\n\n        printer.info(\"[bold]Open sessions:[/]\")\n        printer.table(columns=[\"#\", \"Name\", \"SHA1\", \"Created At\", \"Current\"], rows=rows)\n\n    def __switch(self, identifier: int) -> None:\n        for session in sessions.all():\n            if identifier == session.identifier:\n                sessions.switch(session)\n                return\n\n        printer.error(\"The specified session ID doesn't seem to exist\")\n\n    def run(self) -> None:\n        try:\n            super().run()\n        except CommandRunError:\n            return\n\n        if self.args.list:\n            self.__list()\n        elif self.args.switch:\n            self.__switch(self.args.switch)\n        else:\n            self.args_parser.print_usage()", "\n\nclass Sessions(Command):\n    cmd = \"sessions\"\n    description = \"List or switch sessions\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        group = self.args_parser.add_mutually_exclusive_group()\n        group.add_argument(\n            \"-l\", \"--list\", action=\"store_true\", help=\"list all existing sessions\"\n        )\n        group.add_argument(\n            \"-s\", \"--switch\", type=int, help=\"switch to the specified session\"\n        )\n\n    def __list(self) -> None:\n        if not sessions.all():\n            printer.info(\"There are no open sessions\")\n            return\n\n        rows = []\n        for session in sessions.all():\n            current = \"\"\n            if session == sessions.current:\n                current = \"Yes\"\n\n            rows.append(\n                [\n                    str(session.identifier),\n                    session.file.name,\n                    session.file.sha1,\n                    session.created_at,\n                    current,\n                ]\n            )\n\n        printer.info(\"[bold]Open sessions:[/]\")\n        printer.table(columns=[\"#\", \"Name\", \"SHA1\", \"Created At\", \"Current\"], rows=rows)\n\n    def __switch(self, identifier: int) -> None:\n        for session in sessions.all():\n            if identifier == session.identifier:\n                sessions.switch(session)\n                return\n\n        printer.error(\"The specified session ID doesn't seem to exist\")\n\n    def run(self) -> None:\n        try:\n            super().run()\n        except CommandRunError:\n            return\n\n        if self.args.list:\n            self.__list()\n        elif self.args.switch:\n            self.__switch(self.args.switch)\n        else:\n            self.args_parser.print_usage()", ""]}
{"filename": "viper2/ui/cmd/tags.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nimport peewee\n\nfrom viper2 import printer\nfrom viper2.common.errors import ERROR_NO_OPEN_FILE\nfrom viper2.core.database import File, Tag\nfrom viper2.core.sessions import sessions", "from viper2.core.database import File, Tag\nfrom viper2.core.sessions import sessions\n\nfrom .command import Command, CommandRunError\n\n\nclass Tags(Command):\n    cmd = \"tags\"\n    description = \"Tag files in the database\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        subparsers = self.args_parser.add_subparsers(dest=\"subname\")\n        subparsers.add_parser(\"list\", help=\"List all existing tags\")\n        add = subparsers.add_parser(\"add\", help=\"Add one or more tags to open file\")\n        add.add_argument(\n            \"-t\", \"--tag\", action=\"append\", help=\"Specify a tag\", required=True\n        )\n\n    def list(self) -> None:\n        tags = Tag.select(Tag.name).distinct(True)\n        for tag in list(tags):\n            print(tag.name)\n\n    def add(self, tags) -> None:\n        if not sessions.current:\n            printer.error(ERROR_NO_OPEN_FILE)\n            return\n\n        try:\n            file = File.get(File.sha256 == sessions.current.file.sha256)\n        except File.DoesNotExist:  # pylint: disable=no-member\n            printer.error(\n                \"The currently open file is not stored in the database, \"\n                'use \"store\" command first'\n            )\n            return\n\n        for tag in tags:\n            try:\n                new_tag = Tag(name=tag, file=file)\n                new_tag.save()\n            except peewee.IntegrityError:\n                printer.error('The tag \"%s\" already exists', tag)\n\n    def run(self) -> None:\n        try:\n            super().run()\n        except CommandRunError:\n            return\n\n        if self.args.subname == \"list\":\n            self.list()\n        elif self.args.subname == \"add\":\n            self.add(self.args.tag)", ""]}
{"filename": "viper2/ui/cmd/__init__.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nfrom .about import About\nfrom .children import Children\nfrom .close import Close\nfrom .export import Export\nfrom .find import Find\nfrom .info import Info", "from .find import Find\nfrom .info import Info\nfrom .open import Open\nfrom .parent import Parent\nfrom .projects import Projects\nfrom .sessions import Sessions\nfrom .store import Store\nfrom .tags import Tags\n\n\ndef load_commands() -> dict:\n    return {\n        About.cmd: {\"class\": About, \"description\": About.description},\n        Children.cmd: {\"class\": Children, \"description\": Children.description},\n        Close.cmd: {\"class\": Close, \"description\": Close.description},\n        Export.cmd: {\"class\": Export, \"description\": Export.description},\n        Info.cmd: {\"class\": Info, \"description\": Info.description},\n        Find.cmd: {\"class\": Find, \"description\": Find.description},\n        Open.cmd: {\"class\": Open, \"description\": Open.description},\n        Parent.cmd: {\"class\": Parent, \"description\": Parent.description},\n        Projects.cmd: {\"class\": Projects, \"description\": Projects.description},\n        Sessions.cmd: {\"class\": Sessions, \"description\": Sessions.description},\n        Store.cmd: {\"class\": Store, \"description\": Store.description},\n        Tags.cmd: {\"class\": Tags, \"description\": Tags.description},\n    }", "\n\ndef load_commands() -> dict:\n    return {\n        About.cmd: {\"class\": About, \"description\": About.description},\n        Children.cmd: {\"class\": Children, \"description\": Children.description},\n        Close.cmd: {\"class\": Close, \"description\": Close.description},\n        Export.cmd: {\"class\": Export, \"description\": Export.description},\n        Info.cmd: {\"class\": Info, \"description\": Info.description},\n        Find.cmd: {\"class\": Find, \"description\": Find.description},\n        Open.cmd: {\"class\": Open, \"description\": Open.description},\n        Parent.cmd: {\"class\": Parent, \"description\": Parent.description},\n        Projects.cmd: {\"class\": Projects, \"description\": Projects.description},\n        Sessions.cmd: {\"class\": Sessions, \"description\": Sessions.description},\n        Store.cmd: {\"class\": Store, \"description\": Store.description},\n        Tags.cmd: {\"class\": Tags, \"description\": Tags.description},\n    }", ""]}
{"filename": "viper2/ui/cmd/close.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nfrom viper2.core.sessions import sessions\n\nfrom .command import Command\n\n\nclass Close(Command):\n    cmd = \"close\"\n    description = \"Close the current session\"\n\n    def run(self) -> None:\n        sessions.close()", "\nclass Close(Command):\n    cmd = \"close\"\n    description = \"Close the current session\"\n\n    def run(self) -> None:\n        sessions.close()\n"]}
{"filename": "viper2/ui/cmd/find.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nfrom viper2 import printer\nfrom viper2.core.database import File, Tag\nfrom viper2.core.sessions import sessions\n\nfrom .command import Command, CommandRunError\n", "from .command import Command, CommandRunError\n\n\nclass Find(Command):\n    cmd = \"find\"\n    description = \"Find files stored in the database and local repository\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.args_parser.add_argument(", "        super().__init__()\n        self.args_parser.add_argument(\n            \"key\",\n            nargs=\"?\",\n            choices=[\n                \"all\",\n                \"name\",\n                \"magic\",\n                \"mime\",\n                \"md5\",", "                \"mime\",\n                \"md5\",\n                \"sha1\",\n                \"sha256\",\n                \"tag\",\n                \"note\",\n                \"ssdeep\",\n            ],\n            help=\"search key\",\n        )", "            help=\"search key\",\n        )\n        self.args_parser.add_argument(\n            \"value\", nargs=\"?\", help=\"search value or pattern\"\n        )\n\n    def run(self) -> None:\n        try:\n            super().run()\n        except CommandRunError:", "            super().run()\n        except CommandRunError:\n            return\n\n        match self.args.key:\n            case \"all\":\n                files = File.select().order_by(File.created_date)\n            case \"name\":\n                files = File.select().where(File.name.contains(self.args.value))\n            case \"magic\":", "                files = File.select().where(File.name.contains(self.args.value))\n            case \"magic\":\n                files = File.select().where(File.magic.contains(self.args.value))\n            case \"mime\":\n                files = File.select().where(File.mime.contains(self.args.value))\n            case \"md5\":\n                files = File.select().where(File.md5 == self.args.value)\n            case \"sha1\":\n                files = File.select().where(File.sha1 == self.args.value)\n            case \"sha256\":", "                files = File.select().where(File.sha1 == self.args.value)\n            case \"sha256\":\n                files = File.select().where(File.sha256 == self.args.value)\n            case \"sha512\":\n                files = File.select().where(File.sha512 == self.args.value)\n            case \"tag\":\n                files = (\n                    File.select()\n                    .join(Tag, on=Tag.file == File.id)  # pylint: disable=no-member\n                    .where(Tag.name.contains(self.args.value))", "                    .join(Tag, on=Tag.file == File.id)  # pylint: disable=no-member\n                    .where(Tag.name.contains(self.args.value))\n                )\n            case \"note\":\n                # TODO\n                files = []\n            case \"ssdeep\":\n                files = File.select().where(File.ssdeep.contains(self.args.value))\n\n        if len(files) == 0:", "\n        if len(files) == 0:\n            printer.info(\"No matching results\")\n            return\n\n        sessions.add_find(files)\n\n        rows = []\n        counter = 1\n        for file in files:", "        counter = 1\n        for file in files:\n            tags = \", \".join(tag.name for tag in file.tags)\n            rows.append(\n                [\n                    str(counter),\n                    str(file.created_date),\n                    file.name,\n                    file.sha1,\n                    file.magic,", "                    file.sha1,\n                    file.magic,\n                    tags,\n                ]\n            )\n            counter += 1\n\n        printer.table(columns=[\"#\", \"Date\", \"Name\", \"SHA1\", \"Magic\", \"Tags\"], rows=rows)\n", ""]}
{"filename": "viper2/ui/cmd/open.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nimport os\n\nfrom viper2 import printer\nfrom viper2.core.projects import projects\nfrom viper2.core.sessions import sessions\nfrom viper2.core.storage import Storage", "from viper2.core.sessions import sessions\nfrom viper2.core.storage import Storage\n\nfrom .command import Command, CommandRunError\n\n\nclass Open(Command):\n    cmd = \"open\"\n    description = \"Open a session to a file\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.args_parser.add_argument(\n            \"-f\", \"--file\", action=\"store\", help=\"open the file specified at path\"\n        )\n        self.args_parser.add_argument(\n            \"-l\",\n            \"--last\",\n            action=\"store\",\n            help=\"# of a result from the last `find` command\",\n        )\n\n    def run(self) -> None:\n        try:\n            super().run()\n        except CommandRunError:\n            return\n\n        if self.args.file:\n            if not os.path.exists(self.args.file):\n                printer.error(\n                    \"The specified file at path %s does not exist\", self.args.file\n                )\n                return\n\n            sessions.new(self.args.file)\n        elif self.args.last:\n            for idx, entry in enumerate(sessions.get_find(), start=1):\n                if idx == int(self.args.last):\n                    sessions.new(\n                        Storage().get_file_path(\n                            projects.current.path, str(entry.sha256)\n                        )\n                    )\n                    return\n\n            printer.error(\"Did not find a last find entry with the provided #\")\n        else:\n            self.args_parser.print_usage()", ""]}
{"filename": "viper2/ui/cmd/about.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nimport platform\nimport sys\n\nfrom viper2 import printer\nfrom viper2.common.version import VIPER_VERSION\n", "from viper2.common.version import VIPER_VERSION\n\nfrom .command import Command\n\n\nclass About(Command):\n    cmd = \"about\"\n    description = \"Show information about Viper 2\"\n\n    def run(self) -> None:\n        rows = []\n        rows.append([\"Viper Version\", VIPER_VERSION])\n        rows.append([\"Python executable\", sys.executable])\n        rows.append([\"Python Version\", platform.python_version()])\n\n        printer.table(columns=[\"Key\", \"Value\"], rows=rows)", ""]}
{"filename": "viper2/ui/cmd/export.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nimport os\nimport shutil\n\nfrom viper2 import printer\nfrom viper2.common.errors import ERROR_NO_OPEN_FILE\nfrom viper2.core.sessions import sessions", "from viper2.common.errors import ERROR_NO_OPEN_FILE\nfrom viper2.core.sessions import sessions\n\nfrom .command import Command\n\n\nclass Export(Command):\n    cmd = \"export\"\n    description = \"Export the currently open file to a destionation path\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.args_parser.add_argument(\n            \"dst\", help=\"Destination path to export the file to\"\n        )\n\n    def run(self) -> None:\n        super().run()\n\n        if not sessions.current:\n            printer.error(ERROR_NO_OPEN_FILE)\n            return\n\n        if not self.args.dst:\n            printer.error(\"You need to specify a destionation path\")\n            return\n\n        dst = self.args.dst\n\n        # If the specified destination path exists and it is a folder, we use\n        # the file name from the original file for the destination too.\n        if os.path.isdir(self.args.dst):\n            dst = os.path.join(self.args.dst, sessions.current.file.name)\n\n        printer.info(\"Exporting file %s to %s\", sessions.current.file.path, dst)\n        shutil.copy2(sessions.current.file.path, dst)", ""]}
{"filename": "viper2/ui/cmd/command.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\nfrom argparse import Namespace\nfrom typing import Any, Tuple\n\nfrom viper2.common.arguments import ArgumentError, ArgumentParser\n\n\nclass CommandRunError(Exception):\n    pass", "\n\nclass CommandRunError(Exception):\n    pass\n\n\nclass Command:\n    cmd = \"\"\n    description = \"\"\n\n    def __init__(self) -> None:\n        self.args: Namespace\n        self.__args_input: Tuple[Any, ...]\n        self.args_parser = ArgumentParser(prog=self.cmd, description=self.description)\n\n    def add_args(self, *args: Any) -> None:\n        self.__args_input = args\n\n    def run(self) -> None:\n        try:\n            self.args = self.args_parser.parse_args(self.__args_input)\n        except ArgumentError as exc:\n            raise CommandRunError() from exc", ""]}
