{"filename": "backend/tests/test_main.py", "chunked_list": ["import pytest\n\n\n@pytest.mark.anyio\nasync def test_root(client):\n    response = await client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Hello World\"}\n", ""]}
{"filename": "backend/tests/__init__.py", "chunked_list": [""]}
{"filename": "backend/tests/conftest.py", "chunked_list": ["import pytest\nfrom app.config import settings\nfrom app.database import Base\nfrom app.main import app\nfrom httpx import AsyncClient\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom testcontainers.core.waiting_utils import wait_for_logs\nfrom testcontainers.postgres import PostgresContainer\n", "from testcontainers.postgres import PostgresContainer\n\n\n@pytest.fixture(scope=\"session\")\ndef anyio_backend():\n    return \"asyncio\"\n\n\n@pytest.fixture\nasync def client():", "@pytest.fixture\nasync def client():\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        yield client\n\n\n@pytest.fixture(scope=\"session\")\ndef postgres_container():\n    postgres = PostgresContainer(\n        image=\"postgres:15.2\",\n        user=settings.postgres_user,\n        password=settings.postgres_password,\n        dbname=settings.postgres_db + \"_test\",\n        port=settings.postgres_port,\n    )\n\n    with postgres:\n        wait_for_logs(\n            postgres,\n            r\"UTC \\[1\\] LOG:  database system is ready to accept connections\",\n            10,\n        )\n        postgres.driver = \"asyncpg\"\n        yield postgres", "\n\n@pytest.fixture(scope=\"session\")\nasync def db_engine(postgres_container):\n    engine = create_async_engine(postgres_container.get_connection_url())\n    yield engine\n\n\n@pytest.fixture(scope=\"session\")\nasync def db_session(db_engine):", "@pytest.fixture(scope=\"session\")\nasync def db_session(db_engine):\n    async_session = sessionmaker(db_engine, class_=AsyncSession, expire_on_commit=False)\n    yield async_session\n\n\n@pytest.fixture\nasync def db(db_session, db_engine):\n    async with db_engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)  # Just in case.", "    async with db_engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)  # Just in case.\n        await conn.run_sync(Base.metadata.create_all)\n\n    async with db_session() as session:\n        yield session\n\n    async with db_engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n", "        await conn.run_sync(Base.metadata.drop_all)\n"]}
{"filename": "backend/tests/routers/test_repository_routers.py", "chunked_list": ["from json import dumps\n\nimport pytest\n\nSAMPLE_REPOSITORY_DATA = [\n    {\n        \"player_name\": \"player\",\n        \"repo_owner\": \"gitguesser\",\n        \"repo_name\": \"gitguesser\",\n        \"repo_branch\": \"main\",", "        \"repo_name\": \"gitguesser\",\n        \"repo_branch\": \"main\",\n    },\n]\n\n\n# We need test repo in our app. So we add one using game route.\nasync def create_repository(client, repo_data):\n    response = await client.post(\"game/\", content=dumps(repo_data))\n    response = await client.get(\"game/\" + str(response.json()[\"game_id\"]))", "    response = await client.post(\"game/\", content=dumps(repo_data))\n    response = await client.get(\"game/\" + str(response.json()[\"game_id\"]))\n\n    repo_id = response.json()[\"repository_id\"]\n    assert isinstance(repo_id, int)\n\n    return repo_id\n\n\n@pytest.mark.parametrize(\"repo_data\", SAMPLE_REPOSITORY_DATA)", "\n@pytest.mark.parametrize(\"repo_data\", SAMPLE_REPOSITORY_DATA)\n@pytest.mark.anyio\nasync def test_get_correct_repository(client, repo_data):\n    repo_id = await create_repository(client, repo_data)\n    response = await client.get(\"repository/\" + str(repo_id))\n    assert response.status_code == 200\n    response_json = response.json()\n    assert response_json[\"id\"] == repo_id\n    assert response_json[\"name\"] == repo_data[\"repo_name\"]", "    assert response_json[\"id\"] == repo_id\n    assert response_json[\"name\"] == repo_data[\"repo_name\"]\n    assert response_json[\"owner\"] == repo_data[\"repo_owner\"]\n    assert response_json[\"branch\"] == repo_data[\"repo_branch\"]\n\n    return repo_id\n\n\n@pytest.mark.parametrize(\"repo_data\", SAMPLE_REPOSITORY_DATA)\n@pytest.mark.anyio", "@pytest.mark.parametrize(\"repo_data\", SAMPLE_REPOSITORY_DATA)\n@pytest.mark.anyio\nasync def test_correct_repository_get_root_directory(client, repo_data):\n    repo_id = await test_get_correct_repository(client, repo_data)\n    response = await client.get(\"repository/\" + str(repo_id) + \"/tree\")\n    assert response.status_code == 200\n    response_json = response.json()\n    assert \"subdirectories\" in response_json\n    assert any(dir[\"name\"] == \"backend\" for dir in response_json[\"subdirectories\"])\n    assert any(dir[\"name\"] == \"frontend\" for dir in response_json[\"subdirectories\"])", "    assert any(dir[\"name\"] == \"backend\" for dir in response_json[\"subdirectories\"])\n    assert any(dir[\"name\"] == \"frontend\" for dir in response_json[\"subdirectories\"])\n    assert all(len(dir[\"id\"]) > 0 for dir in response_json[\"subdirectories\"])\n\n    backend_dir_id = [\n        dir[\"id\"] for dir in response_json[\"subdirectories\"] if dir[\"name\"] == \"backend\"\n    ][0]\n    return str(repo_id) + \"/tree/\" + str(backend_dir_id)\n\n", "\n\n@pytest.mark.parametrize(\"repo_data\", SAMPLE_REPOSITORY_DATA)\n@pytest.mark.anyio\nasync def test_correct_repository_get_no_directory(client, repo_data):\n    repo_id = await test_get_correct_repository(client, repo_data)\n    response = await client.get(\"repository/\" + str(repo_id) + \"/tree/0\")\n    assert response.status_code == 404\n    assert response.json() == {\"detail\": \"Directory not found\"}\n", "    assert response.json() == {\"detail\": \"Directory not found\"}\n\n\n@pytest.mark.parametrize(\"repo_data\", SAMPLE_REPOSITORY_DATA)\n@pytest.mark.anyio\nasync def test_correct_repository_get_correct_directory(client, repo_data):\n    directory_url = await test_correct_repository_get_root_directory(client, repo_data)\n    response = await client.get(\"repository/\" + directory_url)\n    assert response.status_code == 200\n    response_json = response.json()", "    assert response.status_code == 200\n    response_json = response.json()\n    assert \"subdirectories\" in response_json\n    assert any(dir[\"name\"] == \"app\" for dir in response_json[\"subdirectories\"])\n    assert any(dir[\"name\"] == \"tests\" for dir in response_json[\"subdirectories\"])\n    assert all(len(dir[\"id\"]) > 0 for dir in response_json[\"subdirectories\"])\n\n\n@pytest.mark.anyio\nasync def test_get_no_repository(client):", "@pytest.mark.anyio\nasync def test_get_no_repository(client):\n    response = await client.get(\"repository/1\")\n    assert response.status_code == 404\n    assert response.json() == {\"detail\": \"Repository not found\"}\n\n\n@pytest.mark.anyio\nasync def test_no_repository_get_no_directory(client):\n    response = await client.get(\"repository/1/tree/1\")", "async def test_no_repository_get_no_directory(client):\n    response = await client.get(\"repository/1/tree/1\")\n    assert response.status_code == 404\n    assert response.json() == {\"detail\": \"Repository not found\"}\n\n\n@pytest.mark.anyio\nasync def test_no_repository_get_root_directory(client):\n    response = await client.get(\"repository/1/tree\")\n    assert response.status_code == 404", "    response = await client.get(\"repository/1/tree\")\n    assert response.status_code == 404\n    assert response.json() == {\"detail\": \"Repository not found\"}\n"]}
{"filename": "backend/tests/routers/__init__.py", "chunked_list": [""]}
{"filename": "backend/tests/routers/test_game_routers.py", "chunked_list": ["from datetime import datetime\nfrom json import dumps\n\nimport pytest\nfrom pydantic.datetime_parse import parse_datetime\n\nCORRECT_GAME_DATA = [\n    {\n        \"player_name\": \"player\",\n        \"repo_owner\": \"gitguesser\",", "        \"player_name\": \"player\",\n        \"repo_owner\": \"gitguesser\",\n        \"repo_name\": \"gitguesser\",\n        \"repo_branch\": \"main\",\n    },\n]\n\nINCORRECT_GAME_DATA = [\n    {},\n    {", "    {},\n    {\n        \"repo_owner\": \"gitguesser\",\n        \"repo_name\": \"gitguesser\",\n        \"repo_branch\": \"main\",\n    },\n    {\n        \"player_name\": \"player\",\n        \"repo_owner\": \"I don't have this repo\",\n        \"repo_name\": \"gitguesser\",", "        \"repo_owner\": \"I don't have this repo\",\n        \"repo_name\": \"gitguesser\",\n        \"repo_branch\": \"main\",\n    },\n]\n\n\n@pytest.mark.parametrize(\"game_data\", INCORRECT_GAME_DATA)\n@pytest.mark.anyio\nasync def test_post_incorrect_game(client, game_data):", "@pytest.mark.anyio\nasync def test_post_incorrect_game(client, game_data):\n    response = await client.post(\"game/\", content=dumps(game_data))\n    assert (\n        response.status_code == 404 or response.status_code == 422\n    )  # Maybe add json check but i don't think it is worth the effort.\n\n\n@pytest.mark.parametrize(\"game_data\", CORRECT_GAME_DATA)\n@pytest.mark.anyio", "@pytest.mark.parametrize(\"game_data\", CORRECT_GAME_DATA)\n@pytest.mark.anyio\nasync def test_post_correct_game(client, game_data):\n    start_time = datetime.now()\n\n    response = await client.post(\"game/\", content=dumps(game_data))\n    assert response.status_code == 200\n    assert response.json()[\"game_id\"] == 1\n\n    new_game_data = response.json()", "\n    new_game_data = response.json()\n    new_game_data[\"start_time\"] = start_time\n    return new_game_data\n\n\n@pytest.mark.parametrize(\"game_data\", CORRECT_GAME_DATA)\n@pytest.mark.anyio\nasync def test_get_correct_game(client, game_data):\n    new_game_data = await test_post_correct_game(client, game_data)", "async def test_get_correct_game(client, game_data):\n    new_game_data = await test_post_correct_game(client, game_data)\n    max_time = datetime.now()\n\n    response = await client.get(\"game/\" + str(new_game_data[\"game_id\"]))\n    assert response.status_code == 200\n    response_json = response.json()\n    assert response_json[\"id\"] == new_game_data[\"game_id\"]\n    assert response_json[\"player_name\"] == game_data[\"player_name\"]\n    assert \"repository_id\" in response_json and isinstance(", "    assert response_json[\"player_name\"] == game_data[\"player_name\"]\n    assert \"repository_id\" in response_json and isinstance(\n        response_json[\"repository_id\"], int\n    )\n    assert \"start_time\" in response_json\n    start_time = parse_datetime(response_json[\"start_time\"])\n    assert new_game_data[\"start_time\"] <= start_time <= max_time\n\n\n@pytest.mark.parametrize(\"game_data\", CORRECT_GAME_DATA)", "\n@pytest.mark.parametrize(\"game_data\", CORRECT_GAME_DATA)\n@pytest.mark.anyio\nasync def test_correct_game_get_results_without_answer(client, game_data):\n    new_game_data = await test_post_correct_game(client, game_data)\n\n    response = await client.get(\"game/\" + str(new_game_data[\"game_id\"]) + \"/results\")\n    assert response.status_code == 404\n    assert response.json() == {\"detail\": \"Game not found\"}\n", "    assert response.json() == {\"detail\": \"Game not found\"}\n\n\n@pytest.mark.parametrize(\"game_data\", CORRECT_GAME_DATA)\n@pytest.mark.anyio\nasync def test_correct_game_post_answer(client, game_data):\n    new_game_data = await test_post_correct_game(client, game_data)\n\n    sample_answer = {\"answer\": \"sample\"}\n    new_game_data[\"answer\"] = \"sample\"", "    sample_answer = {\"answer\": \"sample\"}\n    new_game_data[\"answer\"] = \"sample\"\n    response = await client.post(\n        \"game/\" + str(new_game_data[\"game_id\"]), content=dumps(sample_answer)\n    )\n    assert response.status_code == 200\n\n    return new_game_data\n\n", "\n\n@pytest.mark.parametrize(\"game_data\", CORRECT_GAME_DATA)\n@pytest.mark.anyio\nasync def test_correct_game_get_results_with_answer(client, game_data):\n    new_game_data = await test_correct_game_post_answer(client, game_data)\n\n    response = await client.get(\"game/\" + str(new_game_data[\"game_id\"]) + \"/results\")\n    assert response.status_code == 200\n    response_json = response.json()", "    assert response.status_code == 200\n    response_json = response.json()\n    assert response_json[\"player_answer\"] == new_game_data[\"answer\"]\n    assert \"end_time\" in response_json\n    assert \"score\" in response_json\n    assert \"player_answer\" in response_json\n\n\n@pytest.mark.anyio\nasync def test_get_no_game(client):", "@pytest.mark.anyio\nasync def test_get_no_game(client):\n    response = await client.get(\"game/1\")\n    assert response.status_code == 404\n    assert response.json() == {\"detail\": \"Game not found\"}\n\n\n@pytest.mark.anyio\nasync def test_no_game_get_results(client):\n    response = await client.get(\"game/1/results\")", "async def test_no_game_get_results(client):\n    response = await client.get(\"game/1/results\")\n    assert response.status_code == 404\n    assert response.json() == {\"detail\": \"Game not found\"}\n\n\n@pytest.mark.anyio\nasync def test_no_game_post_answer(client):\n    sample_answer = {\"answer\": \"sample\"}\n    response = await client.post(\"game/1\", content=dumps(sample_answer))", "    sample_answer = {\"answer\": \"sample\"}\n    response = await client.post(\"game/1\", content=dumps(sample_answer))\n    assert response.status_code == 404\n    assert response.json() == {\"detail\": \"Game not found\"}\n"]}
{"filename": "backend/tests/routers/test_search_routers.py", "chunked_list": ["import pytest\n\n\n@pytest.mark.anyio\nasync def test_search(client):\n    response = await client.get(\"search/?query=java\")\n    assert response.status_code == 200\n    assert \"repos\" in response.json()\n    assert len(response.json()[\"repos\"]) > 0\n", "    assert len(response.json()[\"repos\"]) > 0\n\n\n@pytest.mark.anyio\nasync def test_search_incorrect(client):\n    response = await client.get(\"search/\")\n    assert response.status_code == 404\n"]}
{"filename": "backend/tests/routers/conftest.py", "chunked_list": ["import pytest\nfrom app.dependencies import get_session\nfrom app.main import app\nfrom httpx import AsyncClient\n\n\n@pytest.fixture\nasync def client(db):\n    app.dependency_overrides[get_session] = lambda: db\n    async with AsyncClient(app=app, base_url=\"http://test/\") as client:", "    app.dependency_overrides[get_session] = lambda: db\n    async with AsyncClient(app=app, base_url=\"http://test/\") as client:\n        yield client\n    app.dependency_overrides.clear()\n"]}
{"filename": "backend/tests/services/test_game_service.py", "chunked_list": ["import pytest\nfrom app.models.models import Game\nfrom app.schemas.game import GameStartConfig\nfrom app.services import game_service\nfrom fastapi import HTTPException\nfrom sqlalchemy import func, select\n\nCORRECT_GAME_START_CONFIG = [\n    GameStartConfig(\n        player_name=\"player\",", "    GameStartConfig(\n        player_name=\"player\",\n        repo_name=\"gitguesser\",\n        repo_owner=\"gitguesser\",\n        repo_branch=\"main\",\n    ),\n]\n\nINCORRECT_GAME_START_CONFIG = [\n    GameStartConfig(", "INCORRECT_GAME_START_CONFIG = [\n    GameStartConfig(\n        player_name=\"player\",\n        repo_name=\"gitguesser\",\n        repo_owner=\"abcd\",\n        repo_branch=\"main\",\n    ),\n    GameStartConfig(\n        player_name=\"player\",\n        repo_name=\"gitguesser\",", "        player_name=\"player\",\n        repo_name=\"gitguesser\",\n        repo_owner=\"gitguesser\",\n        repo_branch=\"master\",\n    ),\n]\n\n\n@pytest.fixture\nasync def game_id(db):", "@pytest.fixture\nasync def game_id(db):\n    return await game_service.start_game(\n        db=db, game_config=CORRECT_GAME_START_CONFIG[0]\n    )\n\n\nasync def _count(db):\n    return await db.scalar(select(func.count(\"*\")).select_from(Game))\n", "    return await db.scalar(select(func.count(\"*\")).select_from(Game))\n\n\n@pytest.mark.parametrize(\"game_config\", CORRECT_GAME_START_CONFIG)\n@pytest.mark.anyio\nasync def test_start_game_correct(db, game_config):\n    assert await _count(db) == 0\n\n    id = await game_service.start_game(db=db, game_config=game_config)\n    game = await db.scalar(select(Game).where(Game.id == int(id)))", "    id = await game_service.start_game(db=db, game_config=game_config)\n    game = await db.scalar(select(Game).where(Game.id == int(id)))\n\n    assert await _count(db) == 1\n    assert game is not None\n    assert game.player_name == game_config.player_name\n    assert game.repository_id is not None\n\n\n@pytest.mark.parametrize(\"game_config\", INCORRECT_GAME_START_CONFIG)", "\n@pytest.mark.parametrize(\"game_config\", INCORRECT_GAME_START_CONFIG)\n@pytest.mark.anyio\nasync def test_start_game_incorrect(db, game_config):\n    with pytest.raises(HTTPException) as excinfo:\n        await game_service.start_game(db=db, game_config=game_config)\n\n    assert excinfo.value.status_code == 404\n    assert await _count(db) == 0\n", "    assert await _count(db) == 0\n\n\n@pytest.mark.anyio\nasync def test_get_game_when_exists(db, game_id):\n    game = await game_service.get_game(db=db, game_id=game_id)\n\n    assert game is not None\n    assert game.id == game_id\n", "    assert game.id == game_id\n\n\n@pytest.mark.anyio\nasync def test_get_game_when_not_exists(db):\n    with pytest.raises(HTTPException) as excinfo:\n        await game_service.get_game(db=db, game_id=0)\n\n    assert excinfo.value.status_code == 404\n    assert await _count(db) == 0", "    assert excinfo.value.status_code == 404\n    assert await _count(db) == 0\n\n\n@pytest.mark.anyio\nasync def test_give_answer_correct(db, game_id):\n    game = await game_service.get_game(db=db, game_id=game_id)\n    assert game.end_time is None\n    assert game.player_answer is None\n", "    assert game.player_answer is None\n\n    answer = game.correct_answer\n    await game_service.give_answer(db=db, game_id=game_id, answer=answer)\n\n    game = await game_service.get_game(db=db, game_id=game_id)\n    assert game.score == 0\n    assert game.end_time is not None\n    assert game.player_answer == answer\n", "    assert game.player_answer == answer\n\n\n@pytest.mark.anyio\nasync def test_give_wrong_correct(db, game_id):\n    game = await game_service.get_game(db=db, game_id=game_id)\n    assert game.end_time is None\n    assert game.player_answer is None\n\n    answer = game.correct_answer + \"/does_not_exist\"", "\n    answer = game.correct_answer + \"/does_not_exist\"\n    await game_service.give_answer(db=db, game_id=game_id, answer=answer)\n\n    game = await game_service.get_game(db=db, game_id=game_id)\n    assert game.score > 0\n    assert game.end_time is not None\n    assert game.player_answer == answer\n", ""]}
{"filename": "backend/tests/services/__init__.py", "chunked_list": [""]}
{"filename": "backend/tests/services/test_repository_service.py", "chunked_list": ["import pytest\nfrom app.models.models import Repository\nfrom app.services import repository_service\nfrom fastapi import HTTPException\nfrom sqlalchemy import func, select\n\nCORRECT_REPOSITORY = [\n    {\n        \"owner\": \"gitguesser\",\n        \"name\": \"gitguesser\",", "        \"owner\": \"gitguesser\",\n        \"name\": \"gitguesser\",\n        \"branch\": \"main\",\n    },\n]\n\nINCORRECT_REPOSITORY = [\n    {\n        \"owner\": \"gitguesser\",\n        \"name\": \"gitguesser\",", "        \"owner\": \"gitguesser\",\n        \"name\": \"gitguesser\",\n        \"branch\": \"master\",\n    },\n    {\n        \"owner\": \"gitguesser\",\n        \"name\": \"gitguesser1\",\n        \"branch\": \"main\",\n    },\n]", "    },\n]\n\n\n@pytest.fixture\nasync def repo_id(db):\n    return await repository_service.update_repo(\n        db=db, owner=\"gitguesser\", name=\"gitguesser\", branch=\"main\"\n    )\n", "    )\n\n\nasync def _count(db):\n    return await db.scalar(select(func.count(\"*\")).select_from(Repository))\n\n\n@pytest.mark.parametrize(\"repo_data\", CORRECT_REPOSITORY)\n@pytest.mark.anyio\nasync def test_update_repo_correct(db, repo_data):", "@pytest.mark.anyio\nasync def test_update_repo_correct(db, repo_data):\n    assert await _count(db) == 0\n\n    id = await repository_service.update_repo(db=db, **repo_data)\n    repo = await db.scalar(select(Repository).where(Repository.id == int(id)))\n\n    assert await _count(db) == 1\n    assert repo is not None\n    assert repo.name == repo_data[\"name\"]", "    assert repo is not None\n    assert repo.name == repo_data[\"name\"]\n    assert repo.owner == repo_data[\"owner\"]\n    assert repo.branch == repo_data[\"branch\"]\n    assert len(repo.data) > 0\n\n\n@pytest.mark.parametrize(\"repo_data\", CORRECT_REPOSITORY)\n@pytest.mark.anyio\nasync def test_update_repo_unchanged(db, repo_data):", "@pytest.mark.anyio\nasync def test_update_repo_unchanged(db, repo_data):\n    assert await _count(db) == 0\n\n    await repository_service.update_repo(db=db, **repo_data)\n    await repository_service.update_repo(db=db, **repo_data)\n\n    assert await _count(db) == 1\n\n", "\n\n@pytest.mark.parametrize(\"repo_data\", INCORRECT_REPOSITORY)\n@pytest.mark.anyio\nasync def test_update_repo_incorrect(db, repo_data):\n    assert await _count(db) == 0\n\n    with pytest.raises(HTTPException) as excinfo:\n        await repository_service.update_repo(db=db, **repo_data)\n", "\n    assert excinfo.value.status_code == 404\n    assert await _count(db) == 0\n\n\n@pytest.mark.anyio\nasync def test_get_repo_when_exists(db, repo_id):\n    repo = await repository_service.get_repo(db=db, repo_id=repo_id)\n\n    assert repo is not None", "\n    assert repo is not None\n    assert repo.id == repo_id\n\n\n@pytest.mark.anyio\nasync def test_get_repo_when_not_exists(db):\n    with pytest.raises(HTTPException) as excinfo:\n        repo = await repository_service.get_repo(db=db, repo_id=0)\n", "\n    assert excinfo.value.status_code == 404\n    assert await _count(db) == 0\n\n\n@pytest.mark.anyio\nasync def test_get_directory_when_not_exists(db, repo_id):\n    with pytest.raises(HTTPException) as excinfo:\n        await repository_service.get_directory(db=db, repo_id=repo_id, directory_id=\"0\")\n", "\n    assert excinfo.value.status_code == 404\n\n\n@pytest.mark.anyio\nasync def test_get_root_directory(db, repo_id):\n    dir = await repository_service.get_root_directory(db=db, repo_id=repo_id)\n\n    assert dir is not None\n    assert dir.name == \"\"", "    assert dir is not None\n    assert dir.name == \"\"\n    assert len(dir.subdirectories) > 0\n    assert any(d.name == \"backend\" for d in dir.subdirectories)\n    assert any(d.name == \"frontend\" for d in dir.subdirectories)\n    assert all(len(d.id) > 0 for d in dir.subdirectories)\n\n\n@pytest.mark.anyio\nasync def test_get_random_file_path(db, repo_id):", "@pytest.mark.anyio\nasync def test_get_random_file_path(db, repo_id):\n    path = await repository_service.get_random_file_path(db=db, repo_id=repo_id)\n\n    assert path is not None\n\n\n@pytest.mark.anyio\nasync def test_get_random_file_path_when_not_exists(db):\n    with pytest.raises(HTTPException) as excinfo:\n        await repository_service.get_random_file_path(db=db, repo_id=0)", "async def test_get_random_file_path_when_not_exists(db):\n    with pytest.raises(HTTPException) as excinfo:\n        await repository_service.get_random_file_path(db=db, repo_id=0)\n\n    assert excinfo.value.status_code == 404\n"]}
{"filename": "backend/tests/services/test_search_service.py", "chunked_list": ["import pytest\nfrom app.services import search_service\nfrom fastapi import HTTPException\n\n\n@pytest.mark.anyio\nasync def test_search_repos():\n    data = await search_service.search_repos(query=\"python\")\n\n    assert len(data.repos) > 0", "\n    assert len(data.repos) > 0\n\n\n@pytest.mark.anyio\nasync def test_search_incorrect():\n    with pytest.raises(HTTPException) as excinfo:\n        await search_service.search_repos(query=\"\")\n", ""]}
{"filename": "backend/app/database.py", "chunked_list": ["from app.config import settings\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import declarative_base, sessionmaker\n\nengine = create_async_engine(\n    \"postgresql+asyncpg://\"\n    f\"{settings.postgres_user}:{settings.postgres_password}@\"\n    f\"db:{settings.postgres_port}/{settings.postgres_db}\",\n    echo=True,\n)", "    echo=True,\n)\nBase = declarative_base()\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n\nasync def init_models():\n    async with engine.begin() as conn:\n        await conn.run_sync(\n            Base.metadata.drop_all", "        await conn.run_sync(\n            Base.metadata.drop_all\n        )  # Can be commented in future if we want to preserve data in database.\n        await conn.run_sync(Base.metadata.create_all)\n"]}
{"filename": "backend/app/main.py", "chunked_list": ["from app.database import init_models\nfrom app.routers import game, repository, search\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp = FastAPI()\n\n\napp.add_middleware(\n    CORSMiddleware,", "app.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\napp.include_router(game.router)", "\napp.include_router(game.router)\napp.include_router(repository.router)\napp.include_router(search.router)\n\n\n@app.on_event(\"startup\")\nasync def on_startup():\n    await init_models()\n", "    await init_models()\n\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n"]}
{"filename": "backend/app/config.py", "chunked_list": ["from pydantic import BaseSettings\n\n\nclass Settings(BaseSettings):\n    \"\"\"Loads configuration of the application.\n\n    When an instance of this class is created, its attributes are\n    initialized using the values from both environment variables and\n    the content of .env file.\n    \"\"\"\n\n    postgres_user: str\n    postgres_password: str\n    postgres_port: int\n    postgres_db: str\n    github_username: str | None\n    github_token: str | None\n\n    class Config:\n        case_sensitive = False\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"", "\n\nsettings = Settings()\n"]}
{"filename": "backend/app/dependencies.py", "chunked_list": ["from app.database import async_session\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n\nasync def get_session() -> AsyncSession:\n    async with async_session() as session:\n        yield session\n"]}
{"filename": "backend/app/__init__.py", "chunked_list": [""]}
{"filename": "backend/app/schemas/game.py", "chunked_list": ["from datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass GameWithId(BaseModel):\n    game_id: int\n\n\nclass GameStartConfig(BaseModel):\n    player_name: str\n    repo_name: str\n    repo_owner: str\n    repo_branch: str", "\nclass GameStartConfig(BaseModel):\n    player_name: str\n    repo_name: str\n    repo_owner: str\n    repo_branch: str\n\n\nclass GameInfo(BaseModel):\n    id: int\n    repository_id: int\n    player_name: str\n    start_time: datetime\n    file_name: str\n\n    class Config:\n        orm_mode = True", "class GameInfo(BaseModel):\n    id: int\n    repository_id: int\n    player_name: str\n    start_time: datetime\n    file_name: str\n\n    class Config:\n        orm_mode = True\n", "\n\nclass GameResults(GameInfo):\n    end_time: datetime\n    score: int\n    player_answer: str\n    correct_answer: str\n\n    class Config:\n        orm_mode = True", "\n\nclass PlayerAnswer(BaseModel):\n    answer: str\n"]}
{"filename": "backend/app/schemas/__init__.py", "chunked_list": [""]}
{"filename": "backend/app/schemas/repository.py", "chunked_list": ["from pydantic import BaseModel\n\n\nclass DirectoryInfo(BaseModel):\n    id: str\n    name: str\n\n\nclass Directory(DirectoryInfo):\n    subdirectories: list[DirectoryInfo]", "class Directory(DirectoryInfo):\n    subdirectories: list[DirectoryInfo]\n\n\nclass Repository(BaseModel):\n    id: int\n    name: str\n    owner: str\n    branch: str\n\n    class Config:\n        orm_mode = True", ""]}
{"filename": "backend/app/schemas/search.py", "chunked_list": ["from pydantic import BaseModel\n\n\nclass Repository(BaseModel):\n    name: str\n    owner: str\n    branch: str\n\n\nclass Repositories(BaseModel):\n    repos: list[Repository]", "\nclass Repositories(BaseModel):\n    repos: list[Repository]\n"]}
{"filename": "backend/app/routers/game.py", "chunked_list": ["from app.dependencies import get_session\nfrom app.schemas.game import (\n    GameInfo,\n    GameResults,\n    GameStartConfig,\n    GameWithId,\n    PlayerAnswer,\n)\nfrom app.services import game_service\nfrom fastapi import APIRouter, Depends", "from app.services import game_service\nfrom fastapi import APIRouter, Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nrouter = APIRouter(\n    prefix=\"/game\",\n    tags=[\"game\"],\n)\n\n", "\n\n@router.post(\n    \"/\",\n    response_model=GameWithId,\n    description=\"Starts a new game.\",\n)\nasync def start_game(\n    game_start_config: GameStartConfig, session: AsyncSession = Depends(get_session)\n):", "    game_start_config: GameStartConfig, session: AsyncSession = Depends(get_session)\n):\n    game_id = await game_service.start_game(db=session, game_config=game_start_config)\n    return {\"game_id\": game_id}\n\n\n@router.get(\n    \"/{id}\",\n    response_model=GameInfo,\n    description=\"Retrieves information about a game with given id.\",", "    response_model=GameInfo,\n    description=\"Retrieves information about a game with given id.\",\n)\nasync def get_game_info(id: int, session: AsyncSession = Depends(get_session)):\n    game = await game_service.get_game(db=session, game_id=id)\n    return game\n\n\n@router.get(\n    \"/{id}/results\",", "@router.get(\n    \"/{id}/results\",\n    response_model=GameResults,\n    description=\"Retrieves results of finished game with given id.\",\n)\nasync def get_game_results(id: int, session: AsyncSession = Depends(get_session)):\n    game = await game_service.get_game_answered(db=session, game_id=id)\n    return game\n\n", "\n\n@router.post(\"/{id}\", description=\"Sends player answer for a game with given id.\")\nasync def send_answer(\n    id: int, answer: PlayerAnswer, session: AsyncSession = Depends(get_session)\n):\n    await game_service.give_answer(db=session, game_id=id, answer=answer.answer)\n    return\n", ""]}
{"filename": "backend/app/routers/__init__.py", "chunked_list": [""]}
{"filename": "backend/app/routers/repository.py", "chunked_list": ["from app.dependencies import get_session\nfrom app.schemas.repository import Directory, Repository\nfrom app.services import repository_service\nfrom fastapi import APIRouter, Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nrouter = APIRouter(\n    prefix=\"/repository\",\n    tags=[\"repository\"],\n)", "    tags=[\"repository\"],\n)\n\n\n@router.get(\n    \"/{id}/tree\",\n    response_model=Directory,\n    description=\"Returns root directory of the repository with given id.\",\n)\nasync def get_root_directory(id: int, session: AsyncSession = Depends(get_session)):", ")\nasync def get_root_directory(id: int, session: AsyncSession = Depends(get_session)):\n    root_directory = await repository_service.get_root_directory(db=session, repo_id=id)\n    return root_directory\n\n\n@router.get(\n    \"/{id}/tree/{directory_id}\",\n    response_model=Directory,\n    description=\"Returns directory with given id that belongs to the repository.\",", "    response_model=Directory,\n    description=\"Returns directory with given id that belongs to the repository.\",\n)\nasync def get_directory(\n    id: int, directory_id: str, session: AsyncSession = Depends(get_session)\n):\n    directory = await repository_service.get_directory(\n        db=session, repo_id=id, directory_id=directory_id\n    )\n    return directory", "    )\n    return directory\n\n\n@router.get(\n    \"/{id}\",\n    response_model=Repository,\n    description=\"Returns information about a repository with given id.\",\n)\nasync def get_repository(id: int, session: AsyncSession = Depends(get_session)):", ")\nasync def get_repository(id: int, session: AsyncSession = Depends(get_session)):\n    repository = await repository_service.get_repo(db=session, repo_id=id)\n    return repository\n"]}
{"filename": "backend/app/routers/search.py", "chunked_list": ["from app.schemas.search import Repositories\nfrom app.services import search_service\nfrom fastapi import APIRouter\n\nrouter = APIRouter(\n    prefix=\"/search\",\n    tags=[\"search\"],\n)\n\n", "\n\n@router.get(\n    \"/\",\n    response_model=Repositories,\n    description=\"Gets repositories from GitHub.\",\n)\nasync def search_repos(query: str = \"\"):\n    return await search_service.search_repos(query=query)\n", "    return await search_service.search_repos(query=query)\n"]}
{"filename": "backend/app/models/models.py", "chunked_list": ["import datetime\n\nfrom app.database import Base\nfrom sqlalchemy import Column, DateTime, ForeignKey, Index, Integer, String\nfrom sqlalchemy.dialects.postgresql import JSONB\nfrom sqlalchemy.orm import relationship\n\n\nclass Game(Base):\n    __tablename__ = \"games\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    repository_id = Column(Integer, ForeignKey(\"repositories.id\"), nullable=False)\n    start_time = Column(DateTime, nullable=False)\n    end_time = Column(DateTime)\n    player_name = Column(String, nullable=False)\n    correct_answer = Column(String, nullable=False)\n    player_answer = Column(String)\n    score = Column(Integer)\n    file_name = Column(String)\n\n    repository = relationship(\"Repository\", back_populates=\"games\")", "class Game(Base):\n    __tablename__ = \"games\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    repository_id = Column(Integer, ForeignKey(\"repositories.id\"), nullable=False)\n    start_time = Column(DateTime, nullable=False)\n    end_time = Column(DateTime)\n    player_name = Column(String, nullable=False)\n    correct_answer = Column(String, nullable=False)\n    player_answer = Column(String)\n    score = Column(Integer)\n    file_name = Column(String)\n\n    repository = relationship(\"Repository\", back_populates=\"games\")", "\n\nclass Repository(Base):\n    __tablename__ = \"repositories\"\n    __table_args__ = (Index(\"idx_name_owner\", \"name\", \"owner\"),)\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    owner = Column(String, nullable=False)\n    branch = Column(String, nullable=False)\n    etag = Column(String, nullable=False)\n    data = Column(JSONB, nullable=False)\n    creation_date = Column(DateTime, nullable=False, default=datetime.datetime.utcnow)\n\n    games = relationship(\"Game\", back_populates=\"repository\")", ""]}
{"filename": "backend/app/models/__init__.py", "chunked_list": [""]}
{"filename": "backend/app/services/game_service.py", "chunked_list": ["import datetime\n\nfrom app.models.models import Game\nfrom app.schemas.game import GameStartConfig\nfrom app.services.repository_service import get_random_file_path, update_repo\nfrom fastapi import HTTPException\nfrom sqlalchemy import select, update\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n", "\n\nasync def start_game(*, db: AsyncSession, game_config: GameStartConfig) -> int:\n    \"\"\"Starts a game based on data in game_config and returns its id.\"\"\"\n    repo_id = await update_repo(\n        db=db,\n        owner=game_config.repo_owner,\n        name=game_config.repo_name,\n        branch=game_config.repo_branch,\n    )", "        branch=game_config.repo_branch,\n    )\n\n    correct_answer = await get_random_file_path(db=db, repo_id=repo_id)\n\n    game = Game(\n        repository_id=repo_id,\n        start_time=datetime.datetime.utcnow(),\n        player_name=game_config.player_name,\n        correct_answer=correct_answer.rsplit(\"/\", 1)[0],", "        player_name=game_config.player_name,\n        correct_answer=correct_answer.rsplit(\"/\", 1)[0],\n        file_name=correct_answer.split(\"/\")[-1],\n    )\n    db.add(game)\n    await db.commit()\n\n    return game.id\n\n", "\n\nasync def get_game(*, db: AsyncSession, game_id: int) -> Game:\n    \"\"\"Returns the game with given id or raises a 404 HTTPException if it does not exist.\"\"\"\n    game = await db.scalar(select(Game).where(Game.id == int(game_id)))\n    if game is None:\n        raise HTTPException(status_code=404, detail=\"Game not found\")\n\n    return game\n", "    return game\n\n\n# Maybe add tests for it in service test.\nasync def get_game_answered(*, db: AsyncSession, game_id: int) -> Game:\n    \"\"\"Returns the game with given id which was answered or raises a 404 HTTPException if it does not exist.\"\"\"\n    game = await db.scalar(select(Game).where(Game.id == int(game_id)))\n    if game is None or game.end_time is None:\n        raise HTTPException(status_code=404, detail=\"Game not found\")\n", "\n    return game\n\n\nasync def give_answer(*, db: AsyncSession, game_id: int, answer: str) -> None:\n    \"\"\"Gives answer to the game with given id.\n\n    If the game does not exist, raises a 404 HTTPException. If it has already\n    ended, nothing happens.\n    The score is calculated as the distance (in directories tree) between", "    ended, nothing happens.\n    The score is calculated as the distance (in directories tree) between\n    user's answer and the correct answer (lower score is better).\n    \"\"\"\n    game = await get_game(db=db, game_id=game_id)\n\n    if game.end_time is not None:\n        return\n\n    correct_path = game.correct_answer.split(\"/\") if game.correct_answer != \"\" else []", "\n    correct_path = game.correct_answer.split(\"/\") if game.correct_answer != \"\" else []\n    player_path = answer.split(\"/\") if answer != \"\" and answer != \" \" else []\n\n    min_len = min(len(correct_path), len(player_path))\n    i = 0\n    while i < min_len and correct_path[i] == player_path[i]:\n        i += 1\n    score = len(correct_path) + len(player_path) - 2 * i\n", "    score = len(correct_path) + len(player_path) - 2 * i\n\n    await db.execute(\n        update(Game)\n        .where(Game.id == int(game_id))\n        .values(\n            dict(score=score, end_time=datetime.datetime.utcnow(), player_answer=answer)\n        )\n    )\n    await db.commit()", "    )\n    await db.commit()\n"]}
{"filename": "backend/app/services/repository_service.py", "chunked_list": ["import random\n\nimport httpx\nfrom app.config import settings\nfrom app.models.models import Repository\nfrom app.schemas.repository import Directory, DirectoryInfo\nfrom fastapi import HTTPException, status\nfrom sqlalchemy import func, literal_column, select\nfrom sqlalchemy.dialects.postgresql import JSONB\nfrom sqlalchemy.ext.asyncio import AsyncSession", "from sqlalchemy.dialects.postgresql import JSONB\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n\nasync def update_repo(*, db: AsyncSession, owner: str, name: str, branch: str) -> int:\n    \"\"\"Saves the repository in the database and returns its id.\n\n    If the repository is already saved, then it checks if the newest one has\n    been updated since saving it (using ETag). If there are any updates, it saves\n    a new copy to the database. If the repository does not exist, raises a 404 HTTPException.", "    been updated since saving it (using ETag). If there are any updates, it saves\n    a new copy to the database. If the repository does not exist, raises a 404 HTTPException.\n    \"\"\"\n    repo = await db.scalar(\n        select(Repository)\n        .where(Repository.name == name)\n        .where(Repository.owner == owner)\n        .where(Repository.branch == branch)\n        .order_by(Repository.creation_date.desc())\n        .limit(1)", "        .order_by(Repository.creation_date.desc())\n        .limit(1)\n    )\n\n    response = None\n\n    endpoint = (\n        f\"https://api.github.com/repos/{owner}/{name}/git/trees/{branch}?recursive=true\"\n    )\n    auth = None\n    if settings.github_username and settings.github_token:\n        auth = (settings.github_username, settings.github_token)", "    )\n    auth = None\n    if settings.github_username and settings.github_token:\n        auth = (settings.github_username, settings.github_token)\n    async with httpx.AsyncClient(auth=auth) as client:\n        if repo is None:\n            response = await client.get(endpoint)\n        else:\n            response = await client.get(endpoint, headers={\"If-None-Match\": repo.etag})\n\n    if response.status_code == status.HTTP_200_OK:\n        repo = Repository(\n            name=name,\n            owner=owner,\n            branch=branch,\n            etag=response.headers[\"etag\"],\n            data=_parse_response(response),\n        )\n        db.add(repo)\n        await db.commit()\n    elif response.status_code == status.HTTP_404_NOT_FOUND:\n        raise HTTPException(status_code=404, detail=\"Repository not found\")\n    elif response.status_code != status.HTTP_304_NOT_MODIFIED:\n        raise HTTPException(status_code=404, detail=\"Error connecting to GitHub API\")", "\n    if response.status_code == status.HTTP_200_OK:\n        repo = Repository(\n            name=name,\n            owner=owner,\n            branch=branch,\n            etag=response.headers[\"etag\"],\n            data=_parse_response(response),\n        )\n        db.add(repo)\n        await db.commit()\n    elif response.status_code == status.HTTP_404_NOT_FOUND:\n        raise HTTPException(status_code=404, detail=\"Repository not found\")\n    elif response.status_code != status.HTTP_304_NOT_MODIFIED:\n        raise HTTPException(status_code=404, detail=\"Error connecting to GitHub API\")", "\n    return repo.id\n\n\nasync def get_repo(*, db: AsyncSession, repo_id: int) -> Repository:\n    \"\"\"Returns the repository with given id or raises a 404 HTTPException if it does not exist.\"\"\"\n    repo = await db.scalar(select(Repository).where(Repository.id == int(repo_id)))\n    if repo is None:\n        raise HTTPException(status_code=404, detail=\"Repository not found\")\n", "\n    return repo\n\n\nasync def get_directory(\n    *, db: AsyncSession, repo_id: int, directory_id: str\n) -> Directory:\n    \"\"\"Returns the directory with given id that belongs to the repository.\n\n    Raises a 404 HTTPException if the repository does not exist or it", "\n    Raises a 404 HTTPException if the repository does not exist or it\n    does not contain this directory.\n    \"\"\"\n    await get_repo(db=db, repo_id=repo_id)\n\n    val = literal_column(\"value\", type_=JSONB)\n\n    directory = await db.scalar(\n        select(val)", "    directory = await db.scalar(\n        select(val)\n        .select_from(Repository, func.jsonb_array_elements(Repository.data).alias())\n        .where(Repository.id == int(repo_id))\n        .where(val.contains({\"sha\": directory_id}))\n    )\n\n    if directory is None:\n        raise HTTPException(status_code=404, detail=\"Directory not found\")\n", "\n    q = await db.scalars(\n        select(val)\n        .select_from(Repository, func.jsonb_array_elements(Repository.data).alias())\n        .where(Repository.id == int(repo_id))\n        .where(val.contains({\"parent\": directory[\"path\"]}))\n        .where(val.contains({\"type\": \"tree\"}))\n    )\n    subdirectories = q.all()\n", "    subdirectories = q.all()\n\n    return Directory(\n        id=directory[\"sha\"],\n        name=directory[\"path\"].split(\"/\")[-1],\n        subdirectories=[\n            DirectoryInfo(id=subdir[\"sha\"], name=subdir[\"path\"].split(\"/\")[-1])\n            for subdir in subdirectories\n        ],\n    )", "        ],\n    )\n\n\nasync def get_root_directory(*, db: AsyncSession, repo_id: int) -> Directory:\n    \"\"\"Returns the root directory of the repository with given id.\n\n    Raises a 404 HTTPException if the repository does not exist.\n    \"\"\"\n    await get_repo(db=db, repo_id=repo_id)", "    \"\"\"\n    await get_repo(db=db, repo_id=repo_id)\n\n    val = literal_column(\"value\", type_=JSONB)\n\n    q = await db.scalars(\n        select(val)\n        .select_from(Repository, func.jsonb_array_elements(Repository.data).alias())\n        .where(Repository.id == int(repo_id))\n        .where(val.contains({\"parent\": \"\"}))", "        .where(Repository.id == int(repo_id))\n        .where(val.contains({\"parent\": \"\"}))\n        .where(val.contains({\"type\": \"tree\"}))\n    )\n\n    subdirectories = q.all()\n\n    return Directory(\n        id=\"\",\n        name=\"\",", "        id=\"\",\n        name=\"\",\n        subdirectories=[\n            DirectoryInfo(id=subdir[\"sha\"], name=subdir[\"path\"].split(\"/\")[-1])\n            for subdir in subdirectories\n        ],\n    )\n\n\nasync def get_random_file_path(*, db: AsyncSession, repo_id: int) -> str:", "\nasync def get_random_file_path(*, db: AsyncSession, repo_id: int) -> str:\n    \"\"\"Returns path to a randomly selected file that belongs to the repository.\n\n    Raises a 404 HTTPException if the repository does not exist.\n    The returned path is in the format 'a/b/c/file.txt'.\n    \"\"\"\n    await get_repo(db=db, repo_id=repo_id)\n\n    val = literal_column(\"value\", type_=JSONB)", "\n    val = literal_column(\"value\", type_=JSONB)\n\n    q = await db.scalars(\n        select(val)\n        .select_from(Repository, func.jsonb_array_elements(Repository.data).alias())\n        .where(Repository.id == int(repo_id))\n        .where(val.contains({\"type\": \"blob\"}))\n    )\n", "    )\n\n    return random.choice(q.all())[\"path\"]\n\n\ndef _parse_response(response):\n    data = response.json()[\"tree\"]\n    for item in data:\n        item[\"parent\"] = \"/\".join(item[\"path\"].split(\"/\")[:-1])\n    return data", ""]}
{"filename": "backend/app/services/__init__.py", "chunked_list": [""]}
{"filename": "backend/app/services/search_service.py", "chunked_list": ["import httpx\nfrom app.config import settings\nfrom app.schemas.search import Repositories, Repository\nfrom fastapi import HTTPException, status\n\n\nasync def search_repos(*, query: str) -> list[Repository]:\n    \"\"\"Finds repositories on Github.\"\"\"\n    endpoint = f\"https://api.github.com/search/repositories?q={query}&sort=stars&order=desc&per_page=50\"\n    auth = None\n    if settings.github_username and settings.github_token:\n        auth = (settings.github_username, settings.github_token)", "    endpoint = f\"https://api.github.com/search/repositories?q={query}&sort=stars&order=desc&per_page=50\"\n    auth = None\n    if settings.github_username and settings.github_token:\n        auth = (settings.github_username, settings.github_token)\n    async with httpx.AsyncClient(auth=auth) as client:\n        response = await client.get(endpoint)\n\n    if response.status_code == status.HTTP_200_OK:\n        data = response.json()[\"items\"]\n        return Repositories(\n            repos=[\n                Repository(\n                    name=item[\"name\"],\n                    owner=item[\"owner\"][\"login\"],\n                    branch=item[\"default_branch\"],\n                )\n                for item in data\n            ]\n        )", "    raise HTTPException(status_code=404, detail=\"Error connecting to GitHub API\")\n"]}
