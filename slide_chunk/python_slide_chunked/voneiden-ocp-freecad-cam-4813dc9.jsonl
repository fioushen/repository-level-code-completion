{"filename": "tests/test_adaptive.py", "chunked_list": ["import cadquery as cq\n\nfrom ocp_freecad_cam import Endmill\nfrom ocp_freecad_cam.api import Job\nfrom ocp_freecad_cam.visualizer import (\n    generate_visual_commands,\n    visual_commands_to_edges,\n)\n\n\ndef test_cq_adaptive():\n    box = cq.Workplane().box(10, 10, 1)\n    top = box.faces(\">Z\").workplane()\n    adaptive_shape = box.faces(\">Z\")\n    tool = Endmill(diameter=1, v_feed=150)\n    job = Job(top, box, \"grbl\", units=\"metric\")\n    job = job.adaptive(adaptive_shape, tool)\n    gcode = job.to_gcode()\n    lines = gcode.split(\"\\n\")\n    start_index = lines.index(\"(Begin operation: AdaptiveOp_1)\")\n    finish_index = lines.index(\"(Finish operation: AdaptiveOp_1)\")\n    job.show()  # coverage for visualizer\n    job.save_fcstd(\"debug.fcstd\")\n    # Don't care what it generates as long as it's at least 100 lines\n    assert (finish_index - start_index) > 100\n    assert \"F150\" in gcode\n\n    visual_cmds = generate_visual_commands(job.job_impl.fc_job)\n    visual_commands_to_edges(visual_cmds, job.job_impl.backward)", "\n\ndef test_cq_adaptive():\n    box = cq.Workplane().box(10, 10, 1)\n    top = box.faces(\">Z\").workplane()\n    adaptive_shape = box.faces(\">Z\")\n    tool = Endmill(diameter=1, v_feed=150)\n    job = Job(top, box, \"grbl\", units=\"metric\")\n    job = job.adaptive(adaptive_shape, tool)\n    gcode = job.to_gcode()\n    lines = gcode.split(\"\\n\")\n    start_index = lines.index(\"(Begin operation: AdaptiveOp_1)\")\n    finish_index = lines.index(\"(Finish operation: AdaptiveOp_1)\")\n    job.show()  # coverage for visualizer\n    job.save_fcstd(\"debug.fcstd\")\n    # Don't care what it generates as long as it's at least 100 lines\n    assert (finish_index - start_index) > 100\n    assert \"F150\" in gcode\n\n    visual_cmds = generate_visual_commands(job.job_impl.fc_job)\n    visual_commands_to_edges(visual_cmds, job.job_impl.backward)", ""]}
{"filename": "tests/test_profile.py", "chunked_list": ["import cadquery as cq\nimport pytest\n\nfrom ocp_freecad_cam import Endmill\nfrom ocp_freecad_cam.api import Job\n\n\n@pytest.mark.parametrize(\n    \"test_unit,expected_gcode_1,expected_gcode_2\",\n    [", "    \"test_unit,expected_gcode_1,expected_gcode_2\",\n    [\n        (\"metric\", \"G21\\n\", \"G1 X-5.000 Y-5.500 Z-1.000\\n\"),\n        (\"imperial\", \"G20\\n\", \"G1 X-5.0000 Y-5.5000 Z-1.0000\\n\"),\n    ],\n)\ndef test_cq_profile(test_unit, expected_gcode_1, expected_gcode_2):\n    box = cq.Workplane().box(10, 10, 1)\n    top = box.faces(\">Z\").workplane()\n    profile_shape = box.faces(\"<Z\")\n    tool = Endmill(diameter=1)\n    job = Job(top, box, \"grbl\", units=test_unit)\n    job = job.profile(profile_shape, tool)\n    gcode = job.to_gcode()\n\n    assert expected_gcode_1 in gcode\n    assert expected_gcode_2 in gcode", ""]}
{"filename": "tests/test_gcode.py", "chunked_list": ["import cadquery as cq\nimport pytest\n\nfrom ocp_freecad_cam import Endmill, Job\n\n\ndef test_cq_spindle_feeds_and_speeds():\n    box = cq.Workplane().box(10, 10, 1)\n    top = box.faces(\">Z\").workplane()\n    profile_shape = box.faces(\"<Z\")\n    tool = Endmill(diameter=1, h_feed=250, v_feed=50, speed=12000)\n    job = Job(top, box, \"grbl\").profile(profile_shape, tool)\n    gcode = job.to_gcode()\n\n    assert \"F50\" in gcode\n    assert \"F250\" in gcode\n    assert \"S12000\" in gcode", "\n\ndef assert_gcode(f):\n    def _assert_gcode(gcode):\n        assert f(gcode)\n\n    return _assert_gcode\n\n\nno_coolant_assertion = lambda gcode: \"M7\" not in gcode and \"M8\" not in gcode  # noqa", "\nno_coolant_assertion = lambda gcode: \"M7\" not in gcode and \"M8\" not in gcode  # noqa\nflood_coolant_assertion = lambda gcode: \"M8\" in gcode and \"M7\" not in gcode  # noqa\nmist_coolant_assertion = lambda gcode: \"M7\" in gcode and \"M8\" not in gcode  # noqa\n\n\n@pytest.mark.parametrize(\n    \"job_coolant,op_coolant,assertion\",\n    [\n        (None, None, no_coolant_assertion),", "    [\n        (None, None, no_coolant_assertion),\n        (\"None\", \"None\", no_coolant_assertion),\n        (\"Flood\", \"None\", no_coolant_assertion),\n        (\"Mist\", \"None\", no_coolant_assertion),\n        (\"Flood\", None, flood_coolant_assertion),\n        (\"Mist\", None, mist_coolant_assertion),\n        (\"None\", \"Flood\", flood_coolant_assertion),\n        (\"None\", \"Mist\", mist_coolant_assertion),\n    ],", "        (\"None\", \"Mist\", mist_coolant_assertion),\n    ],\n)\ndef test_cq_coolant(job_coolant, op_coolant, assertion):\n    box = cq.Workplane().box(10, 10, 1)\n    top = box.faces(\">Z\").workplane()\n    profile_shape = box.faces(\"<Z\")\n    tool = Endmill(diameter=1)\n    job = Job(top, box, \"grbl\", coolant=job_coolant).profile(  # noqa\n        profile_shape, tool, coolant=op_coolant  # noqa\n    )\n\n    assert assertion(job.to_gcode())", ""]}
{"filename": "tests/test_dressup.py", "chunked_list": ["import cadquery as cq\n\nfrom ocp_freecad_cam import Endmill\nfrom ocp_freecad_cam.api import Dogbone, Job, Tab\n\n\ndef test_cq_tab():\n    box = cq.Workplane().box(10, 10, 2)\n    top = box.faces(\">Z\").workplane()\n    tool = Endmill(diameter=1)\n    job = Job(top, box, \"grbl\").profile(box.faces(\"<Z\"), tool, dressups=[Tab()])\n    gcode = job.to_gcode()\n    assert \"DressupTag\" in gcode\n    assert \"ProfileOp_1\" not in gcode", "\n\ndef test_cq_dogbone():\n    box = cq.Workplane().box(10, 10, 2)\n    top = box.faces(\">Z\").workplane()\n    tool = Endmill(diameter=1)\n    job = Job(top, box, \"grbl\").pocket(box.faces(\">Z\"), tool, dressups=[Dogbone()])\n    gcode = job.to_gcode()\n    assert \"(Begin operation: DressupDogbone)\" in gcode\n    assert \"(Begin operation: PocketOp_1)\" not in gcode", ""]}
{"filename": "tests/test_engrave.py", "chunked_list": ["import cadquery as cq\n\nfrom ocp_freecad_cam import Endmill\nfrom ocp_freecad_cam.api import Job\n\n\ndef test_cq_engrave():\n    box = cq.Workplane().box(10, 10, 1)\n    top = box.faces(\">Z\").workplane()\n    engrave_shape = box.edges(\">Z\")\n    tool = Endmill(name=\"1mm\", diameter=1)\n    job = Job(top, box, \"grbl\", units=\"metric\")\n    job = job.engrave(engrave_shape, tool)\n    gcode = job.to_gcode()\n    lines = gcode.split(\"\\n\")\n    start_index = lines.index(\"(Begin operation: EngraveOp_1)\")\n    finish_index = lines.index(\"(Finish operation: EngraveOp_1)\")\n    job.show()  # coverage for visualizer\n    # Don't care what it generates as long as it's at least 100 lines\n    assert (finish_index - start_index) == 13", ""]}
{"filename": "tests/test_drill.py", "chunked_list": ["import cadquery as cq\n\nfrom ocp_freecad_cam import Drill\nfrom ocp_freecad_cam.api import Job\n\n\ndef test_drill():\n    wp = (\n        cq.Workplane()\n        .box(5, 5, 2)\n        .faces(\">Z\")\n        .workplane()\n        .pushPoints([(-1.5, -1.5), (0, 1.5), (0.5, -1)])\n        .circle(0.5)\n        .cutThruAll()\n    )\n\n    top = wp.faces(\">Z\").workplane()\n    hole_edges = wp.faces(\"<Z\").objects[0].innerWires()\n\n    tool = Drill(diameter=\"1 mm\")\n    job = Job(top, wp, \"grbl\")\n    job = job.drill(hole_edges, tool)\n    job.to_gcode()\n    job.show()", ""]}
{"filename": "tests/test_params.py", "chunked_list": ["import io\n\nimport cadquery as cq\nimport FreeCAD\nimport Part\nimport pytest\nfrom Path.Main import Job as FCJob\n\nfrom ocp_freecad_cam import Endmill, VBit\nfrom ocp_freecad_cam.api_util import AutoUnitKey", "from ocp_freecad_cam import Endmill, VBit\nfrom ocp_freecad_cam.api_util import AutoUnitKey\nfrom ocp_freecad_cam.fc_impl import (\n    DeburrOp,\n    DrillOp,\n    FaceOp,\n    HelixOp,\n    PocketOp,\n    ProfileOp,\n    Surface3DOp,", "    ProfileOp,\n    Surface3DOp,\n    VCarveOp,\n)\n\n\n@pytest.fixture\ndef fc_doc():\n    doc = FreeCAD.newDocument(\"Test Doc\")\n    FreeCAD.setActiveDocument(doc.Name)\n    yield doc\n    FreeCAD.closeDocument(doc.Name)", "\n\n@pytest.fixture\ndef fc_cube_base_feature(fc_doc):\n    buffer = io.BytesIO()\n    cmp = cq.Compound.makeCompound(cq.Workplane().box(5, 5, 5).objects)\n    cmp.exportBrep(buffer)\n    buffer.seek(0)\n    brep = buffer.read().decode(\"utf8\")\n    fc_compound = Part.Compound()\n    fc_compound.importBrepFromString(brep)\n    feature = fc_doc.addObject(\"Part::Feature\", f\"root_brep\")\n    feature.Shape = fc_compound\n    return feature", "\n\n@pytest.fixture\ndef fc_job(fc_cube_base_feature):\n    job = FCJob.Create(\"Job\", [fc_cube_base_feature])\n    tools = [tool for tool in job.Tools.Group]\n    for tool in tools:\n        job.Tools.removeObject(tool)\n\n    return job", "\n\ndef endmill_tc(fc_job, unit):\n    endmill = Endmill(diameter=1)\n    return endmill.tool_controller(fc_job, unit)\n\n\ndef vbit_tc(fc_job, unit):\n    vbit = VBit(tip_diameter=0.1, tip_angle=60)\n    return vbit.tool_controller(fc_job, unit)", "\n\n@pytest.mark.parametrize(\n    \"module,tc_f\",\n    [\n        (ProfileOp, endmill_tc),\n        (FaceOp, endmill_tc),\n        (PocketOp, endmill_tc),\n        (DrillOp, endmill_tc),\n        (HelixOp, endmill_tc),", "        (DrillOp, endmill_tc),\n        (HelixOp, endmill_tc),\n        (DeburrOp, endmill_tc),\n        (VCarveOp, vbit_tc),\n        (Surface3DOp, endmill_tc),\n    ],\n)\ndef test_params(fc_job, module, tc_f):\n    tc = tc_f(fc_job.Proxy, \"metric\")\n    fc_instance = module.fc_module.Create(\"test\")\n    fc_instance.ToolController = tc\n\n    for param in module.param_mapping.values():\n        enumeration = None\n\n        if isinstance(param, AutoUnitKey):\n            param = param.key\n        elif isinstance(param, tuple):\n            param, enumeration = param\n\n        assert hasattr(fc_instance, param)", ""]}
{"filename": "tests/test_waterline.py", "chunked_list": ["import cadquery as cq\n\nfrom ocp_freecad_cam import Endmill\nfrom ocp_freecad_cam.api import Job\n\n\ndef test_cq_waterline():\n    box = cq.Workplane().cylinder(10, 10)\n    top = box.faces(\">Z\").workplane()\n    tool = Endmill(diameter=1)\n    job = Job(top, box, \"grbl\", units=\"metric\")\n    job = job.waterline(None, tool, sample_interval=\"0.5 mm\", bound_box=\"stock\")\n    gcode = job.to_gcode()\n    lines = gcode.split(\"\\n\")\n    start_index = lines.index(\"(Begin operation: WaterlineOp_1)\")\n    finish_index = lines.index(\"(Finish operation: WaterlineOp_1)\")\n\n    # Don't care what it generates as long as it's at least 100 lines\n    assert (finish_index - start_index) > 100", ""]}
{"filename": "tests/test_helix.py", "chunked_list": ["import cadquery as cq\n\nfrom ocp_freecad_cam import Endmill\nfrom ocp_freecad_cam.api import Job\n\n\ndef test_drill():\n    wp = (\n        cq.Workplane()\n        .box(5, 5, 2)\n        .faces(\">Z\")\n        .workplane()\n        .pushPoints([(-1.5, -1.5), (0, 1.5), (0.5, -1)])\n        .circle(0.5)\n        .cutThruAll()\n    )\n\n    top = wp.faces(\">Z\").workplane()\n    hole_edges = wp.faces(\"<Z\").objects[0].innerWires()\n\n    tool = Endmill(diameter=\"0.5 mm\")\n    job = Job(top, wp, \"grbl\")\n    job = job.helix(hole_edges, tool)\n    job.to_gcode()\n    job.show()", ""]}
{"filename": "tests/test_buggy_outer_wire.py", "chunked_list": ["import os\nfrom io import BytesIO\n\nimport cadquery as cq\nimport pytest\nfrom OCP.ShapeAnalysis import ShapeAnalysis\nfrom OCP.ShapeFix import ShapeFix_Shape\n\nfrom ocp_freecad_cam import Endmill, Job\n", "from ocp_freecad_cam import Endmill, Job\n\n\n@pytest.fixture\ndef buggy_face():\n    base_path = os.path.dirname(__file__)\n    with open(os.path.join(base_path, \"face_with_buggy_outer_wire.brep\"), \"r\") as f:\n        brep = BytesIO(f.read().encode(\"utf8\"))\n    face = cq.Face.importBrep(brep)\n    return face", "\n\ndef test_occt_shape_analysis_outer_wire_bug(buggy_face):\n    wrong_wire = cq.Wire(ShapeAnalysis.OuterWire_s(buggy_face.wrapped))\n    assert buggy_face.outerWire().Length() != wrong_wire.Length()\n\n    buggy_compound = cq.Compound.makeCompound([buggy_face])\n    sf = ShapeFix_Shape(buggy_compound.wrapped)\n    sf.Perform()\n    fixed_compound = cq.Compound(sf.Shape())\n    correct_wire = cq.Wire(ShapeAnalysis.OuterWire_s(fixed_compound.Faces()[0].wrapped))\n    assert buggy_face.outerWire().Length() == correct_wire.Length()", "\n\ndef test_buggy_profile(buggy_face):\n    tool = Endmill(diameter=1)\n    job = Job(buggy_face, cq.Compound.makeCompound([buggy_face]), \"grbl\").profile(\n        buggy_face, tool, holes=True\n    )\n\n    assert \"G1 X-8.250 Y-7.134\" in job.to_gcode()\n", ""]}
{"filename": "docs/conf.py", "chunked_list": ["import os\nimport sys\n\n# Configuration file for the Sphinx documentation builder.\n#\n# For the full list of built-in configuration values, see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Project information -----------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information", "# -- Project information -----------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information\n\nproject = \"ocp-freecad-cam\"\ncopyright = \"2023, Matti Eiden\"\nauthor = \"Matti Eiden\"\n\n# -- General configuration ---------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n", "# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n\nextensions = [\"sphinx.ext.autodoc\", \"sphinx_rtd_theme\", \"sphinx_tabs.tabs\"]\n\ntemplates_path = [\"_templates\"]\nexclude_patterns = [\"_build\", \"Thumbs.db\", \".DS_Store\"]\n\n\n# -- Options for HTML output -------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output", "# -- Options for HTML output -------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n\nhtml_theme = \"sphinx_rtd_theme\"\n\nhtml_static_path = [\"_static\"]\n\nsys.path.append(os.path.join(os.getcwd(), \"../src/\"))\n\n# autodoc_member_order = \"bysource\"", "\n# autodoc_member_order = \"bysource\"\n\nautodoc_typehints_format = \"fully-qualified\"\nautodoc_mock_imports = [\n    \"Path\",\n    \"FreeCAD\",\n    \"Part\",\n    \"OCP\",\n    \"PathScripts\",", "    \"OCP\",\n    \"PathScripts\",\n    \"cadquery\",\n    \"build123d\",\n]\n"]}
{"filename": "docs/examples/cq_adaptive.py", "chunked_list": ["import cadquery as cq\n\nfrom ocp_freecad_cam import Endmill, Job\nfrom ocp_freecad_cam.api_util import Expression\n\nwp = (\n    cq.Workplane()\n    .rect(10, 10)\n    .extrude(5)\n    .faces(\">Z\")", "    .extrude(5)\n    .faces(\">Z\")\n    .workplane()\n    .rect(8, 8)\n    .cutBlind(-1)\n    .faces(\">Z\")\n    .rect(10, 2)\n    .cutBlind(-1)\n)\n", ")\n\npocket = wp.faces(\">Z[1]\")\ntop = wp.faces(\">Z\").workplane()\ntool = Endmill(diameter=1)\njob = Job(top, wp).adaptive(\n    pocket,\n    tool=tool,\n    step_over=50,\n    start_depth=Expression(\"0 mm\"),", "    step_over=50,\n    start_depth=Expression(\"0 mm\"),\n)\n"]}
{"filename": "docs/examples/b3d_profile.py", "chunked_list": ["from build123d import Axis, Box, BuildPart\n\nfrom ocp_freecad_cam import Endmill, Job\n\nwith BuildPart() as part:\n    Box(5, 5, 2)\n\nz_faces = part.faces().sort_by(Axis.Z)\ntop = z_faces[-1]\nbottom = z_faces[0]", "top = z_faces[-1]\nbottom = z_faces[0]\n\ntool = Endmill(diameter=1)\njob = Job(top, part.solids()).profile(bottom, tool)\n"]}
{"filename": "docs/examples/cq_pocket.py", "chunked_list": ["import cadquery as cq\n\nfrom ocp_freecad_cam import Endmill, Job\n\nwp = (\n    cq.Workplane()\n    .rect(10, 10)\n    .extrude(5)\n    .faces(\">Z\")\n    .workplane()", "    .faces(\">Z\")\n    .workplane()\n    .rect(8, 8)\n    .cutBlind(-2)\n    .faces(\">Z\")\n    .rect(10, 2)\n    .cutBlind(-2)\n)\n\npocket = wp.faces(\">Z[1]\")", "\npocket = wp.faces(\">Z[1]\")\ntop = wp.faces(\">Z\").workplane()\ntool = Endmill(diameter=1)\njob = Job(top, wp).pocket(pocket, tool=tool, pattern=\"offset\")\n"]}
{"filename": "docs/examples/cq_helix.py", "chunked_list": ["import cadquery as cq\n\nfrom ocp_freecad_cam import Endmill, Job\n\nwp = (\n    cq.Workplane()\n    .box(5, 5, 2)\n    .faces(\">Z\")\n    .workplane()\n    .pushPoints([(-1.5, -1.5), (0, 1.5), (0.5, -1)])", "    .workplane()\n    .pushPoints([(-1.5, -1.5), (0, 1.5), (0.5, -1)])\n    .circle(0.5)\n    .cutThruAll()\n)\n\ntop = wp.faces(\">Z\").workplane()\nhole_edges = wp.faces(\"<Z\").objects[0].innerWires()\n\n", "\n\ntool = Endmill(diameter=\"0.5 mm\")\njob = Job(top, wp).helix(hole_edges, tool)\n"]}
{"filename": "docs/examples/generate_image.py", "chunked_list": ["from OCP.AIS import AIS_DisplayMode, AIS_InteractiveContext, AIS_Shaded, AIS_Shape\nfrom OCP.Aspect import Aspect_DisplayConnection, Aspect_TypeOfTriedronPosition\nfrom OCP.Image import Image_AlienPixMap\nfrom OCP.OpenGl import OpenGl_GraphicDriver\nfrom OCP.Quantity import Quantity_Color\nfrom OCP.TCollection import TCollection_AsciiString\nfrom OCP.V3d import V3d_Viewer\nfrom OCP.Xw import Xw_Window\n\nfrom ocp_freecad_cam.api import Job", "\nfrom ocp_freecad_cam.api import Job\nfrom ocp_freecad_cam.api_util import extract_topods_shapes\n\n\ndef render(shapes, output_path):\n    display_connection = Aspect_DisplayConnection()\n    graphic_driver = OpenGl_GraphicDriver(display_connection)\n    viewer = V3d_Viewer(graphic_driver)\n    viewer.SetDefaultLights()\n    viewer.SetLightOn()\n\n    context = AIS_InteractiveContext(viewer)\n    context.SetDisplayMode(AIS_DisplayMode.AIS_Shaded, True)\n    context.DefaultDrawer().SetFaceBoundaryDraw(True)\n    view = viewer.CreateView()\n    view.TriedronDisplay(\n        Aspect_TypeOfTriedronPosition.Aspect_TOTP_RIGHT_LOWER, Quantity_Color(), 0.1\n    )\n    params = view.ChangeRenderingParams()\n    params.NbMsaaSamples = 8\n    params.IsAntialiasingEnabled = True\n    window = Xw_Window(display_connection, \"\", 0, 0, 660, 495)\n    window.SetVirtual(True)\n    view.SetWindow(window)\n    view.MustBeResized()\n\n    for shape in shapes:\n        context.Display(shape, False)\n\n    view.FitAll()\n    view.Redraw()\n\n    image = Image_AlienPixMap()\n    view.ToPixMap(image, 660, 495)\n    image.Save(TCollection_AsciiString(output_path))", "\n\ndef render_file(file_path, display_object_names, output_path):\n    with open(file_path, \"r\") as f:\n        ast = compile(f.read(), file_path, \"exec\")\n\n    _locals = {}\n    exec(ast, _locals)\n\n    display_shapes = []\n    for name in display_object_names:\n        obj = _locals[name]\n        if isinstance(obj, Job):\n            display_shapes.append(obj.show())\n        else:\n            shapes = extract_topods_shapes(obj)\n            if not shapes:\n                shapes = extract_topods_shapes(obj, compound=True)\n            if not shapes:\n                raise ValueError(\"No shapes found)\")\n            ais_shapes = []\n            for shape in shapes:\n                ais_shape = AIS_Shape(shape)\n                ais_shape.SetHilightMode(AIS_Shaded)\n                ais_shapes.append(ais_shape)\n\n            display_shapes += ais_shapes\n\n    render(display_shapes, output_path)", "\n\nif __name__ == \"__main__\":\n    render_file(\"cq_profile.py\", [\"wp\", \"job\"], \"images/cq_profile.png\")\n    render_file(\"cq_pocket.py\", [\"wp\", \"job\"], \"images/cq_pocket.png\")\n    render_file(\"cq_drill.py\", [\"wp\", \"job\"], \"images/cq_drill.png\")\n    render_file(\"cq_helix.py\", [\"wp\", \"job\"], \"images/cq_helix.png\")\n    render_file(\"cq_adaptive.py\", [\"wp\", \"job\"], \"images/cq_adaptive.png\")\n", ""]}
{"filename": "docs/examples/cq_drill.py", "chunked_list": ["import cadquery as cq\n\nfrom ocp_freecad_cam import Drill, Job\n\nwp = (\n    cq.Workplane()\n    .box(5, 5, 2)\n    .faces(\">Z\")\n    .workplane()\n    .pushPoints([(-1.5, -1.5), (0, 1.5), (0.5, -1)])", "    .workplane()\n    .pushPoints([(-1.5, -1.5), (0, 1.5), (0.5, -1)])\n    .circle(0.5)\n    .cutThruAll()\n)\n\ntop = wp.faces(\">Z\").workplane()\nhole_edges = wp.faces(\"<Z\").objects[0].innerWires()\n\n", "\n\ntool = Drill(diameter=\"1 mm\")\njob = Job(top, wp).drill(hole_edges, tool)\n"]}
{"filename": "docs/examples/cq_profile.py", "chunked_list": ["import cadquery as cq\n\nfrom ocp_freecad_cam import Endmill, Job\n\nwp = cq.Workplane().box(5, 5, 2)\n\ntop = wp.faces(\">Z\").workplane()\nprofile_shape = wp.faces(\"<Z\")\n\ntool = Endmill(diameter=\"1 mm\")", "\ntool = Endmill(diameter=\"1 mm\")\njob = Job(top, wp).profile(profile_shape, tool)\n"]}
{"filename": "src/ocp_freecad_cam/api_tool.py", "chunked_list": ["from dataclasses import dataclass, field\nfrom typing import ClassVar, Literal, Optional\n\nfrom Path.Tool import Bit, Controller\n\nfrom ocp_freecad_cam.api_util import AutoUnitKey, ParamMapping, apply_params, map_params\n\n\nclass FCBit:\n    ...\n    Proxy: Bit.ToolBit", "class FCBit:\n    ...\n    Proxy: Bit.ToolBit\n\n\nclass FCToolController:\n    ...\n    Proxy: Controller.ToolController\n\n", "\n\n@dataclass(kw_only=True)\nclass Toolbit:\n    \"\"\"\n    Base class for Toolbits\n    \"\"\"\n\n    _bit: Optional[FCBit] = field(init=False)\n    _tool_controller: Optional[FCToolController] = field(init=False)\n    params: dict[str, str] = field(init=False)\n    param_mapping: ClassVar[ParamMapping] = {\n        # \"chip_load\": \"ChipLoad\",\n        # \"flutes\": \"Flutes\",\n        # \"material\": \"Material\",\n    }\n\n    tc_param_mapping: ClassVar[ParamMapping] = {\n        \"speed\": \"SpindleSpeed\",\n        \"spindle_dir\": (\n            \"SpindleDirection\",\n            {\"forward\": \"Forward\", \"reverse\": \"Reverse\", \"none\": \"None\"},\n        ),\n        \"h_feed\": AutoUnitKey(\"HorizFeed\", mode=\"feed\"),\n        \"v_feed\": AutoUnitKey(\"VertFeed\", mode=\"feed\"),\n    }\n\n    _file_name: ClassVar[str]\n\n    name: str = \"\"\n    \"\"\" Completely optional tool name \"\"\"\n\n    number: int = 1\n    \"\"\" Tool number for tool change purposes \"\"\"\n\n    path: Optional[str] = None\n    \"\"\" \n    Tool shape path. Not needed if the shape is located in the expected\n    library folder \n    \"\"\"\n\n    # Removed these three attributes as they have currently\n    # no function in FreeCAD besides bookkeeping.\n    # chip_load: str = None\n    # flutes: int = None\n    # material: str = None\n\n    # TC attributes\n    h_feed: float | str = None\n    \"\"\"\n    Horizontal feed rate. Units are either mm/min or in/min. Floats\n    are interpreted with the job units. Strings should include the unit.\n    \"\"\"\n    v_feed: float | str = None\n    \"\"\"\n    Vertical feed rate. Units are either mm/min or in/min. Floats\n    are interpreted with the job units. Strings should include the unit.\n    \"\"\"\n    speed: float | str = None\n    \"\"\"\n    Spindle speed in RPM.\n    \"\"\"\n    spindle_dir: Literal[\"forward\", \"reverse\", \"none\"] = None\n    \"\"\"\n    Spindle direction, forward (clockwise) or reverse (counterclockwise).\n    \"\"\"\n\n    def __post_init__(self):\n        self._bit = None\n        self._tool_controller = None\n\n        self.params = map_params(\n            self.param_mapping, **self._collect_params(self.param_mapping)\n        )\n        self.tc_params = map_params(\n            self.tc_param_mapping, **self._collect_params(self.tc_param_mapping)\n        )\n\n    def _collect_params(self, mapping: ParamMapping):\n        return {k: v for k in mapping.keys() if (v := getattr(self, k)) is not None}\n\n    def tool_controller(self, fc_job, units):\n        if self._tool_controller is None:\n            self.create(fc_job, units)\n        return self._tool_controller\n\n    def create(self, fc_job, units):\n        tool_shape = Bit.findToolShape(self._file_name, self.path)\n        if not tool_shape:\n            raise ValueError(\n                f\"Could not find tool {self._file_name} (path: {self.path})\"\n            )\n\n        self._bit = Bit.Factory.Create(self.name, tool_shape)\n        self._tool_controller = Controller.Create(\n            f\"TC: {self.name}\", tool=self._bit, toolNumber=self.number\n        )\n        fc_job.addToolController(self._tool_controller)\n        apply_params(self._bit, self.params, units)\n        apply_params(self._tool_controller, self.tc_params, units)", "\n\n@dataclass(kw_only=True)\nclass Endmill(Toolbit):\n    \"\"\"\n    Endmill is the standard cylindrical tool bit.\n    \"\"\"\n\n    _file_name: ClassVar[str] = \"endmill.fcstd\"\n    param_mapping = {\n        **Toolbit.param_mapping,\n        \"cutting_edge_height\": AutoUnitKey(\"CuttingEdgeHeight\"),\n        \"diameter\": AutoUnitKey(\"Diameter\"),\n        \"length\": AutoUnitKey(\"Length\"),\n        \"shank_diameter\": AutoUnitKey(\"Shank Diameter\"),\n    }\n\n    cutting_edge_height: float | str = None\n    \"\"\" \n    Length of the cutter aka maximum cut depth. Floats are interpreted \n    either in mm or in depending on job unit.\n    \"\"\"\n    diameter: float | str = None\n    \"\"\" \n    Diameter of the cutter. Floats are interpreted \n    either in mm or in depending on job unit.\n    \"\"\"\n    length: float | str = None\n    \"\"\" \n    Total length of the tool from spindle holder. Floats are interpreted \n    either in mm or in depending on job unit.\n    \"\"\"\n    shank_diameter: float | str = None\n    \"\"\" \n    Diameter of the shank abover the cutter. Floats are interpreted \n    either in mm or in depending on job unit.\n    \"\"\"", "\n\n@dataclass(kw_only=True)\nclass Ballnose(Endmill):\n    \"\"\"\n    Ballnose is an Endmill with a round tip.\n    \"\"\"\n\n    _file_name: ClassVar[str] = \"ballnose.fcstd\"\n", "\n\n@dataclass(kw_only=True)\nclass VBit(Endmill):\n    \"\"\"\n    V-Bit's are engraving tools that come in various shapes. Depth of cut\n    defines the cut width. Typically used with the V-Carve operation (for\n    variable width cuts) or Engrave operation (for constant width).\n    \"\"\"\n\n    _file_name: ClassVar[str] = \"v-bit.fcstd\"\n\n    param_mapping = {\n        **Endmill.param_mapping,\n        \"tip_angle\": \"TipAngle\",\n        \"tip_diameter\": AutoUnitKey(\"TipDiameter\"),\n    }\n\n    tip_angle: float = None\n    \"\"\" Tip angle in degrees, typically 15, 30, 60 or 90. \"\"\"\n    tip_diameter: float | str = None\n    \"\"\" \n    Diameter of the tip. Friendly reminder that low grade V-bits have\n    huge disparity, ie something advertised as 0.1 mm can be actually 0.3 m.\n    Measure your bits if doing high detail work!\n    \n    Floats are interpreted either in mm or in depending on Job unit.\n    \"\"\"", "\n\n@dataclass(kw_only=True)\nclass Chamfer(VBit):\n    \"\"\"\n    Chamfer has same attributes as a VBit. In practice, they have usually\n    comparatively wide tip diameters.\n    \"\"\"\n\n    _file_name: ClassVar[str] = \"chamfer.fcstd\"", "\n\n@dataclass(kw_only=True)\nclass Drill(Toolbit):\n    \"\"\"\n    A Drill tool for.. drilling holes!\n    \"\"\"\n\n    _file_name: ClassVar[str] = \"drill.fcstd\"\n    param_mapping = {\n        **Toolbit.param_mapping,\n        \"diameter\": AutoUnitKey(\"Diameter\"),\n        \"length\": AutoUnitKey(\"Length\"),\n        \"tip_angle\": AutoUnitKey(\"TipAngle\"),\n    }\n\n    diameter: float | str = None\n    \"\"\" \n    Diameter of the drill. Floats are interpreted either in mm or in \n    depending on job unit. \n    \"\"\"\n    length: float | str = None\n    \"\"\"\n    Length of the drill from tip to collet. Floats are interpreted either \n    in mm or in depending on job unit. \n    \"\"\"\n    tip_angle: float = None\n    \"\"\"\n    Tip angle in degrees. Determines the extra distance of penetration needed\n    to get the correct hole size.\n    \"\"\"", "\n\n@dataclass(kw_only=True)\nclass Probe(Toolbit):\n    \"\"\"\n    Please refer to FreeCAD on how to use this tool.\n    \"\"\"\n\n    _file_name: ClassVar[str] = \"probe.fcstd\"\n    param_mapping = {\n        **Toolbit.param_mapping,\n        \"diameter\": AutoUnitKey(\"Diameter\"),\n        \"length\": AutoUnitKey(\"Length\"),\n        \"shank_diameter\": AutoUnitKey(\"Shank Diameter\"),\n    }\n\n    diameter: float | str = None\n    \"\"\" \n    Diameter of the probe. Floats are interpreted either in mm or in \n    depending on job unit. \n    \"\"\"\n    length: float | str = None\n    \"\"\"\n    Length of the drill from tip to collet. Floats are interpreted either \n    in mm or in depending on job unit. \n    \"\"\"\n    shank_diameter: float | str = None\n    \"\"\" \n    Diameter of the probe shank. Probably irrelevant in FreeCAD. \n    Floats are interpreted either in mm or in depending on job unit. \n    \"\"\"", "\n\n@dataclass(kw_only=True)\nclass SlittingSaw(Toolbit):\n    \"\"\"\n    Please refer to FreeCAD on how to use this.\n    \"\"\"\n\n    _file_name: ClassVar[str] = \"slittingsaw.fcstd\"\n    param_mapping = {\n        **Toolbit.param_mapping,\n        \"blade_thickness\": AutoUnitKey(\"BladeThickness\"),\n        \"cap_diameter\": AutoUnitKey(\"CapDiameter\"),\n        \"cap_height\": AutoUnitKey(\"CapHeight\"),\n        \"diameter\": AutoUnitKey(\"Diameter\"),\n        \"length\": AutoUnitKey(\"Length\"),\n        \"shank_diameter\": AutoUnitKey(\"Shank Diameter\"),\n    }\n\n    blade_thickness: float | str = None\n    cap_diameter: float | str = None\n    cap_height: float | str = None\n    diameter: float | str = None\n    length: float | str = None\n    shank_diameter: float | str = None", "\n\n@dataclass(kw_only=True)\nclass Bullnose(Endmill):\n    \"\"\"\n    A mix of Endmill and Ballnose, the Bullnose has a flat area\n    at the tip with rounded cutting edges.\n    \"\"\"\n\n    _file_name: ClassVar[str] = \"bullnose.fcstd\"\n    param_mapping = {\n        **Endmill.param_mapping,\n        \"flat_radius\": AutoUnitKey(\"FlatRadius\"),\n    }\n    flat_radius: float | str = None\n    \"\"\"\n    The radius of the flat part and the tip of the tool.\n    Floats are interpreted either in mm or in depending on job unit. \n    \"\"\"", "\n\n@dataclass(kw_only=True)\nclass ThreadMill(Toolbit):\n    \"\"\"\n    Please refer to FreeCAD on how to use this tool.\n    \"\"\"\n\n    _file_name: ClassVar[str] = \"bullnose.fcstd\"\n    param_mapping = {\n        **Toolbit.param_mapping,\n        \"crest\": AutoUnitKey(\"Crest\"),\n        \"diameter\": AutoUnitKey(\"Diameter\"),\n        \"length\": AutoUnitKey(\"Length\"),\n        \"neck_diameter\": AutoUnitKey(\"NeckDiameter\"),\n        \"neck_length\": AutoUnitKey(\"NeckLength\"),\n        \"shank_diameter\": AutoUnitKey(\"ShankDiameter\"),\n        \"cutting_angle\": \"cuttingAngle\",\n    }\n\n    crest: float | str = None\n    diameter: float | str = None\n    length: float | str = None\n    neck_diameter: float | str = None\n    neck_length: float | str = None\n    shank_diameter: float | str = None\n    cutting_angle: float = None", ""]}
{"filename": "src/ocp_freecad_cam/api.py", "chunked_list": ["\"\"\"\nThis is the user facing API of ocp_freecad_cam\n\"\"\"\nimport logging\nimport os\nfrom copy import copy\nfrom typing import Literal, Optional\n\nimport Path.Log as Log\nimport PathScripts.PathUtils as PathUtils", "import Path.Log as Log\nimport PathScripts.PathUtils as PathUtils\nfrom Path.Dressup import DogboneII, Tags\n\nfrom ocp_freecad_cam.api_tool import Toolbit\nfrom ocp_freecad_cam.api_util import (\n    AutoUnitKey,\n    CompoundSource,\n    ShapeSourceOrIterable,\n    extract_plane,", "    ShapeSourceOrIterable,\n    extract_plane,\n    extract_topods_shapes,\n    map_params,\n    shape_source_to_compound,\n)\nfrom ocp_freecad_cam.common import PlaneSource, PostProcessor\nfrom ocp_freecad_cam.fc_impl import (\n    AdaptiveOp,\n    DeburrOp,", "    AdaptiveOp,\n    DeburrOp,\n    Dressup,\n    DrillOp,\n    EngraveOp,\n    FaceOp,\n    HelixOp,\n    JobImpl,\n    Op,\n    PocketOp,", "    Op,\n    PocketOp,\n    ProfileOp,\n)\nfrom ocp_freecad_cam.fc_impl import Stock as StockImpl\nfrom ocp_freecad_cam.fc_impl import StockBase, Surface3DOp, VCarveOp, WaterlineOp\n\ntry:\n    import cadquery as cq\nexcept ImportError:\n    cq = None", "try:\n    import build123d as b3d\nexcept ImportError:\n    b3d = None\n\nlogging.basicConfig()\nlogging.getLogger().setLevel(logging.INFO)\n\nif os.environ.get(\"DEBUG\", False):\n    logging.getLogger().setLevel(logging.DEBUG)\n    Log._useConsole = False\n    Log._defaultLogLevel = Log.Level.DEBUG", "if os.environ.get(\"DEBUG\", False):\n    logging.getLogger().setLevel(logging.DEBUG)\n    Log._useConsole = False\n    Log._defaultLogLevel = Log.Level.DEBUG\n\n\nclass Job:\n    def __init__(\n        self,\n        top_plane: PlaneSource,\n        model: CompoundSource,\n        post_processor: PostProcessor = None,\n        units: Literal[\"metric\", \"imperial\"] = \"metric\",\n        geometry_tolerance=None,\n        coolant: Literal[\"None\", \"Flood\", \"Mist\"] = \"None\",\n        final_depth_expression=\"OpFinalDepth\",\n        start_depth_expression=\"OpStartDepth\",\n        step_down_expression=\"OpToolDiameter\",\n        clearance_height_expression=\"OpStockZMax+SetupSheet.ClearanceHeightOffset\",\n        clearance_height_offset=\"5.00 mm\",\n        safe_height_expression=\"OpStockZMax+SetupSheet.SafeHeightOffset\",\n        safe_height_offset=\"3.00 mm\",\n        stock: StockBase = StockImpl(),\n    ):\n        \"\"\"\n        Job is the starting point for all CAM operations. It takes a top plane\n        as a zero reference (center of the plane is X = Y = Z = 0) and a whole\n        model (solid or compound) for the purposes of stock size calculation.\n\n        Additionally, it is possible to override defaults of FreeCAD job, Stock\n        and SetupSheet attributes.\n\n        :param top_plane: The zero reference for the job\n        :param model: Model for determining the stock size. Also, 3D ops use\n            the whole model unless otherwise specified.\n        :param post_processor: Postprocessor for the G-Code output.\n        :param units: Units of the shapes and g-code output,\n            metric (mm) or imperial (in).\n        :param geometry_tolerance: smaller increases accuracy, but slows\n            down computation.\n        :param coolant: default coolant mode for the job\n        :param final_depth_expression: custom expression for calculating  the\n            default final (bottom) depth\n        :param start_depth_expression:custom expression for calculating the\n            default start (top) depth\n        :param step_down_expression: custom expression for calculating the\n            default stepdown, default is tool diameter\n        :param clearance_height_expression: custom expression for calculating\n            the default clearance height\n        :param clearance_height_offset: add or remove a default offset to\n            clearance height\n        :param safe_height_expression: custom expression for calculating\n            the default safe (rapid) height\n        :param safe_height_offset: add or remove a default offset to safe\n            height\n        :param stock: Used to generate the job stock\n        \"\"\"\n        model_compounds = extract_topods_shapes(model, compound=True)\n        if (model_count := len(model_compounds)) != 1:\n            raise ValueError(\n                f\"Job should be based around a single compound (got {model_count})\"\n            )\n\n        self.job_impl = JobImpl(\n            top=extract_plane(top_plane),\n            model=model_compounds[0],\n            post_processor=post_processor,\n            units=units,\n            geometry_tolerance=geometry_tolerance,\n            coolant=coolant,\n            final_depth_expression=final_depth_expression,\n            start_depth_expression=start_depth_expression,\n            step_down_expression=step_down_expression,\n            clearance_height_expression=clearance_height_expression,\n            clearance_height_offset=clearance_height_offset,\n            safe_height_expression=safe_height_expression,\n            safe_height_offset=safe_height_offset,\n            stock=stock,\n        )\n\n        self._needs_rebuild = True\n\n    def show(self, show_object=None, force_rebuild=False):\n        \"\"\"\n        Generates an AIS_InteractiveObject that can be used to display\n        the result in cq-editor or cq-viewer\n\n        :param show_object:\n        :param force_rebuild: set to True if you've tweaked some parameters\n            outside the normal fluent flow\n        :return: AIS_InteractiveObject that can be given to show_object\n        \"\"\"\n        ais = self.job_impl.show(\n            show_object=show_object, rebuild=self._needs_rebuild or force_rebuild\n        )\n        self._needs_rebuild = False\n        return ais\n\n    def to_gcode(self, force_rebuild=False):\n        \"\"\"\n        Generates G-Code.\n\n        Output is generated by the job's postprocessor and in the job's units.\n\n        :param force_rebuild: set to True if you've tweaked some parameters\n            outside the normal fluent flow\n        :return:\n        \"\"\"\n        gcode = self.job_impl.to_gcode(rebuild=self._needs_rebuild or force_rebuild)\n        self._needs_rebuild = False\n        return gcode\n\n    def save_fcstd(self, filename=\"debug.fcstd\", force_rebuild=False):\n        \"\"\"\n        Save the current document so that it can be opened manually in\n        FreeCAD.\n\n        :param filename: Filename to save to (relative to current dir)\n        :param force_rebuild: set to True if you've tweaked some parameters\n            outside the normal fluent flow\n        :return:\n        \"\"\"\n        rv = self.job_impl.save_fcstd(\n            filename, rebuild=self._needs_rebuild or force_rebuild\n        )\n        self._needs_rebuild = False\n        return rv\n\n    def _add_op(self, op: Op):\n        new_ops = self.job_impl.ops[:]\n        new_ops.append(op)\n        new_job = copy(self)\n        new_job.job_impl = new_job.job_impl.copy(new_ops)\n        new_job._needs_rebuild = True\n        return new_job\n\n    def profile(\n        self,\n        shapes: ShapeSourceOrIterable,\n        tool: \"Toolbit\",\n        *,\n        side: Literal[\"out\", \"in\", \"mid\"] = \"out\",\n        direction: Literal[\"cw\", \"ccw\"] = \"cw\",\n        handle_multiple_features: Literal[\n            \"collectively\", \"individually\"\n        ] = \"collectively\",\n        offset_extra: float = 0.0,\n        circles: bool = False,\n        holes: bool = False,\n        perimeter: bool = True,\n        dressups: list[\"Dressup\"] = None,\n        # OP depth\n        clearance_height=None,\n        final_depth=None,\n        safe_height=None,\n        start_depth=None,\n        step_down=None,\n        coolant: Literal[\"None\", \"Flood\", \"Mist\"] = \"None\",\n    ):\n        \"\"\"\n        2.5D profile operation will operate on faces, wires and edges.\n\n        Edges do not have to form a closed loop, and they do not have to be\n        on the same Z-level. See https://wiki.freecad.org/Path_Profile\n        for usage notes.\n\n        :param shapes: Shape(s) to perform this OP on\n        :param tool: Tool to use in this OP\n        :param side: Defines whether cutter radius compensation is applied\n            on the inside or the outside of the perimeter (outer wire).\n            Irrelevant for open edges.\n        :param direction: Defines the direction of travel (clockwise or\n            counterclockwise).\n        :param handle_multiple_features: Defines whether to combine features\n            or handle them as individual sub operations.\n        :param offset_extra: Additional offset.\n        :param circles: Faces: profile circular holes (inner wires).\n        :param holes: Faces: profile non-circular holes (inner wires).\n        :param perimeter: Faces: mill the perimeter (outer wire).\n        :param dressups: Define dressups to use in this OP. For example\n            Tab (tags) or Dogbone.\n        \"\"\"\n\n        use_comp = side != \"mid\"\n        if not use_comp:\n            # Side is irrelevant if we're not using cutter radius compensation\n            # Set to some valid value\n            side = \"out\"\n\n        op = ProfileOp(\n            # Profile settings\n            side=side,\n            direction=direction,\n            handle_multiple_features=handle_multiple_features,\n            offset_extra=offset_extra,\n            use_comp=use_comp,\n            process_circles=circles,\n            process_holes=holes,\n            process_perimeter=perimeter,\n            # Op settings\n            tool=tool,\n            dressups=dressups or [],\n            compound_data=shape_source_to_compound(shapes),\n            clearance_height=clearance_height,\n            final_depth=final_depth,\n            safe_height=safe_height,\n            start_depth=start_depth,\n            step_down=step_down,\n            coolant=coolant,\n        )\n        return self._add_op(op)\n\n    def face(\n        self,\n        shapes: ShapeSourceOrIterable,\n        tool: \"Toolbit\",\n        *,\n        finish_depth: float = None,\n        boundary: Literal[\"boundbox\", \"face\", \"perimeter\", \"stock\"] = None,\n        clear_edges: bool = None,\n        exclude_raised: bool = None,\n        pattern: Literal[\"zigzag\", \"offset\", \"zigzag_offset\", \"line\", \"grid\"] = None,\n        # OP depth\n        clearance_height=None,\n        final_depth=None,\n        safe_height=None,\n        start_depth=None,\n        step_down=None,\n        coolant: Literal[\"None\", \"Flood\", \"Mist\"] = \"None\",\n    ) -> \"Job\":\n        \"\"\"\n        2.5D face operation to clear material from a surface.\n\n        See https://wiki.freecad.org/Path_MillFace for usage notes.\n\n        :param shapes: Shape(s) to perform this OP on\n        :param tool: Tool to use in this OP\n        :param finish_depth:\n        :param boundary:\n        :param clear_edges:\n        :param exclude_raised:\n        :param pattern:\n        :return:\n        \"\"\"\n\n        op = FaceOp(\n            finish_depth=finish_depth,\n            boundary=boundary,\n            clear_edges=clear_edges,\n            exclude_raised=exclude_raised,\n            pattern=pattern,\n            tool=tool,\n            compound_data=shape_source_to_compound(\n                shapes,\n            ),\n            clearance_height=clearance_height,\n            final_depth=final_depth,\n            safe_height=safe_height,\n            start_depth=start_depth,\n            step_down=step_down,\n            coolant=coolant,\n        )\n        return self._add_op(op)\n\n    def pocket(\n        self,\n        shapes: ShapeSourceOrIterable,\n        tool: \"Toolbit\",\n        *,\n        finish_depth: float = 0,\n        pattern: Literal[\n            \"zigzag\", \"offset\", \"zigzag_offset\", \"line\", \"grid\"\n        ] = \"zigzag\",\n        cut_mode: Literal[\"climb\", \"conventional\"] = \"climb\",\n        extra_offset: float = 0,\n        keep_tool_down: bool = False,\n        min_travel: bool = False,\n        pocket_last_stepover: float = 0,\n        start_at: Literal[\"center\", \"edge\"] = \"center\",\n        step_over: float = 100,\n        use_outline: bool = False,\n        zigzag_angle: float = 45.0,\n        dressups: list[Dressup] = None,\n        # OP depth\n        clearance_height=None,\n        final_depth=None,\n        safe_height=None,\n        start_depth=None,\n        step_down=None,\n        coolant: Literal[\"None\", \"Flood\", \"Mist\"] = \"None\",\n    ) -> \"Job\":\n        \"\"\"\n        2.5D pocket operation.\n\n        See https://wiki.freecad.org/Path_Pocket_Shape for usage notes.\n\n        :param shapes: Shape(s) to perform this OP on.\n        :param tool: Tool to use in this OP.\n        :param finish_depth: Final pass depth, 0 to disable.\n        :param pattern: Pocket tool path pattern.\n        :param cut_mode: Climb/Conventional selection.\n        :param extra_offset: Offset the operation boundaries.\n        :param keep_tool_down: Attempts to avoid unnecessary retractions\n        :param min_travel: Use 3D sorting of path\n        :param pocket_last_stepover: ?\n        :param start_at: Where the pocketing operation starts (inside-out vs\n            outside-in)\n        :param step_over: Step over by percentage of cutter diameter\n        :param use_outline: Use outline of base geometry\n        :param zigzag_angle: Valid when zigzagging\n        :param dressups: Dressup operations\n        :return:\n        \"\"\"\n\n        op = PocketOp(\n            finish_depth=finish_depth,\n            pattern=pattern,\n            cut_mode=cut_mode,\n            extra_offset=extra_offset,\n            keep_tool_down=keep_tool_down,\n            min_travel=min_travel,\n            pocket_last_stepover=pocket_last_stepover,\n            start_at=start_at,\n            step_over=step_over,\n            use_outline=use_outline,\n            zigzag_angle=zigzag_angle,\n            # OP settings\n            tool=tool,\n            dressups=dressups or [],\n            compound_data=shape_source_to_compound(shapes),\n            clearance_height=clearance_height,\n            final_depth=final_depth,\n            safe_height=safe_height,\n            start_depth=start_depth,\n            step_down=step_down,\n            coolant=coolant,\n        )\n        return self._add_op(op)\n\n    def drill(\n        self,\n        shapes: ShapeSourceOrIterable,\n        tool: \"Toolbit\",\n        dwell_time: Optional[float] = None,\n        extra_offset: Optional[Literal[\"none\", \"1x\", \"2x\"]] = \"none\",\n        peck_depth: Optional[float] = None,\n        keep_tool_down: Optional[bool] = False,\n        retract_height: Optional[bool] = None,\n        chip_break_enabled: Optional[bool] = False,\n        # OP depth\n        clearance_height=None,\n        final_depth=None,\n        safe_height=None,\n        start_depth=None,\n        step_down=None,\n        coolant: Literal[\"None\", \"Flood\", \"Mist\"] = \"None\",\n    ):\n        \"\"\"\n        Drilling OP works at least on circular edges and cylindrical\n        faces.\n\n        See https://wiki.freecad.org/Path_Drilling for usage notes.\n\n        :param shapes: shapes to perform this op on\n        :param tool: tool to use\n        :param dwell_time: setting this to any value will enable dwell\n        :param extra_offset: extend drilling depth\n        :param peck_depth:\n        :param keep_tool_down:\n        :param retract_height:\n        :param chip_break_enabled:\n        :return:\n        \"\"\"\n\n        op = DrillOp(\n            tool=tool,\n            dwell_time=dwell_time,\n            extra_offset=extra_offset,\n            peck_depth=peck_depth,\n            keep_tool_down=keep_tool_down,\n            retract_height=retract_height,\n            chip_break_enabled=chip_break_enabled,\n            compound_data=shape_source_to_compound(shapes),\n            clearance_height=clearance_height,\n            final_depth=final_depth,\n            safe_height=safe_height,\n            start_depth=start_depth,\n            step_down=step_down,\n            coolant=coolant,\n        )\n        return self._add_op(op)\n\n    def helix(\n        self,\n        shapes: ShapeSourceOrIterable,\n        tool: \"Toolbit\",\n        *,\n        direction: Optional[Literal[\"cw\", \"ccw\"]] = \"cw\",\n        offset_extra: Optional[float] = 0,\n        start_radius: Optional[float] = 0,\n        start_side: Optional[Literal[\"out\", \"in\"]] = \"out\",\n        step_over: Optional[float] = 50,\n        # OP depth\n        clearance_height=None,\n        final_depth=None,\n        safe_height=None,\n        start_depth=None,\n        step_down=None,\n        coolant: Literal[\"None\", \"Flood\", \"Mist\"] = \"None\",\n    ):\n        \"\"\"\n        Perform a helix plunge.\n\n        See https://wiki.freecad.org/Path_Helix for usage notes.\n\n        :param shapes: circular shapes to perform the op on\n        :param tool: tool to use\n        :param direction: default clockwise helix\n        :param offset_extra: negative value creates a roughing pass followed\n            by a final pass with the original radius\n        :param start_radius: inner radius?\n        :param start_side: define where the op starts when doing multiple passes\n        :param step_over: percentage of tool diameter to step over\n        :return:\n        \"\"\"\n\n        op = HelixOp(\n            direction=direction,\n            offset_extra=offset_extra,\n            start_radius=start_radius,\n            start_side=start_side,\n            step_over=step_over,\n            # Op\n            tool=tool,\n            compound_data=shape_source_to_compound(\n                shapes,\n            ),\n            clearance_height=clearance_height,\n            final_depth=final_depth,\n            safe_height=safe_height,\n            start_depth=start_depth,\n            step_down=step_down,\n            coolant=coolant,\n        )\n        return self._add_op(op)\n\n    def deburr(\n        self,\n        shapes: ShapeSourceOrIterable,\n        tool: \"Toolbit\",\n        *,\n        width: float | str = \"1 mm\",\n        extra_depth: float | str = \"0.5 mm\",\n        direction: Literal[\"cw\", \"ccw\"] = \"cw\",\n        entry_point: int = 0,\n        # OP depth\n        clearance_height=None,\n        final_depth=None,\n        safe_height=None,\n        start_depth=None,\n        step_down=None,\n        coolant: Literal[\"None\", \"Flood\", \"Mist\"] = \"None\",\n    ):\n        \"\"\"\n        Deburring operation, typically using a chamfer tool.\n\n        See https://wiki.freecad.org/Path_Deburr for usage notes.\n\n        :param shapes:\n        :param tool:\n        :param width:\n        :param extra_depth:\n        :param direction:\n        :param entry_point:\n        :param clearance_height:\n        :param final_depth:\n        :param safe_height:\n        :param start_depth:\n        :param step_down:\n        :return:\n        \"\"\"\n        op = DeburrOp(\n            width=width,\n            extra_depth=extra_depth,\n            direction=direction,\n            entry_point=entry_point,\n            # Op\n            tool=tool,\n            compound_data=shape_source_to_compound(shapes),\n            clearance_height=clearance_height,\n            final_depth=final_depth,\n            safe_height=safe_height,\n            start_depth=start_depth,\n            step_down=step_down,\n            coolant=coolant,\n        )\n        return self._add_op(op)\n\n    def engrave(\n        self,\n        shapes: ShapeSourceOrIterable,\n        tool: \"Toolbit\",\n        *,\n        start_vertex: int = 0,\n        # OP depth\n        clearance_height=None,\n        final_depth=None,\n        safe_height=None,\n        start_depth=None,\n        step_down=None,\n        coolant: Literal[\"None\", \"Flood\", \"Mist\"] = \"None\",\n    ):\n        \"\"\"\n        Engraving OP follows edges.\n\n        See https://wiki.freecad.org/Path_Engrave for usage notes.\n\n        :param shapes:\n        :param tool:\n        :param start_vertex:\n        :param clearance_height:\n        :param final_depth:\n        :param safe_height:\n        :param start_depth:\n        :param step_down:\n        :return:\n        \"\"\"\n        op = EngraveOp(\n            start_vertex=start_vertex,\n            tool=tool,\n            compound_data=shape_source_to_compound(shapes),\n            clearance_height=clearance_height,\n            final_depth=final_depth,\n            safe_height=safe_height,\n            start_depth=start_depth,\n            step_down=step_down,\n            coolant=coolant,\n        )\n        return self._add_op(op)\n\n    def vcarve(\n        self,\n        shapes: ShapeSourceOrIterable,\n        tool: \"Toolbit\",\n        *,\n        discretize: float = 0.01,\n        colinear: float = 10.0,\n        # OP depth\n        clearance_height=None,\n        final_depth=None,\n        safe_height=None,\n        start_depth=None,\n        step_down=None,\n        coolant: Literal[\"None\", \"Flood\", \"Mist\"] = \"None\",\n    ):\n        \"\"\"\n        V-Carve based on voronoi diagrams.\n\n        Verify the tool path carefully! This algorithm is sometimes\n        unstable.\n\n        See https://wiki.freecad.org/Path_Vcarve for usage notes.\n\n        :param shapes:\n        :param tool:\n        :param discretize: Try a smaller value if getting too many retracts.\n        :param colinear:\n        :return:\n        \"\"\"\n\n        op = VCarveOp(\n            discretize=discretize,\n            colinear=colinear,\n            # Op\n            tool=tool,\n            compound_data=shape_source_to_compound(shapes),\n            clearance_height=clearance_height,\n            final_depth=final_depth,\n            safe_height=safe_height,\n            start_depth=start_depth,\n            step_down=step_down,\n            coolant=coolant,\n        )\n        return self._add_op(op)\n\n    def surface(\n        self,\n        shapes: Optional[ShapeSourceOrIterable],\n        tool: \"Toolbit\",\n        *,\n        bound_box: Literal[\"base_bound_box\", \"stock\"] = \"base_bound_box\",\n        cut_mode: Literal[\"climb\", \"conventional\"] = \"climb\",\n        cut_pattern: Literal[\n            \"line\", \"circular\", \"circular_zig_zag\", \"offset\", \"spiral\", \"zigzag\"\n        ] = \"line\",\n        cut_pattern_angle: float = 0,\n        cut_pattern_reversed: bool = False,\n        depth_offset: float = 0,\n        layer_mode: Literal[\"single\", \"multi\"] = \"single\",\n        profile_edges: Literal[\"none\", \"only\", \"first\", \"last\"] = \"none\",\n        sample_interval: float | str = \"1.0 mm\",\n        step_over: float = 100,\n        angular_deflection: float | str = \"0.25 mm\",\n        linear_deflection: float\n        | str = \"0.001 mm\",  # Not visible in UI, but this is the default in code\n        circular_use_g2g3: bool = False,\n        gap_threshold: float | str = \"0.01 mm\",\n        optimize_linear_paths: bool = True,\n        optimize_step_over_transitions: bool = False,\n        avoid_last_x_faces: int = 0,\n        avoid_last_x_internal_features: bool = True,\n        boundary_adjustment: float | str = 0,\n        boundary_enforcement: bool = True,\n        multiple_features: Literal[\"collectively\", \"individually\"] = \"collectively\",\n        internal_features_adjustment: float | str = 0,\n        internal_features_cut: bool = True,\n        start_point: tuple[float | str, float | str, float | str] = None,\n        scan_type: Literal[\"planar\", \"rotational\"] = \"planar\",\n        # OP depth\n        clearance_height=None,\n        final_depth=None,\n        safe_height=None,\n        start_depth=None,\n        step_down=None,\n        coolant: Literal[\"None\", \"Flood\", \"Mist\"] = \"None\",\n    ):\n        \"\"\"\n        3D surface op that mills the part using a XY scan pattern\n        and a drop-down algorithm.\n\n        If no shape(s) are provided, performs the OP on the whole model.\n\n        See https://wiki.freecad.org/Path_Surface for usage notes.\n\n        :param shapes:\n        :param tool:\n        :param bound_box:\n        :param cut_mode:\n        :param cut_pattern:\n        :param cut_pattern_angle:\n        :param cut_pattern_reversed:\n        :param depth_offset:\n        :param layer_mode:\n        :param profile_edges:\n        :param sample_interval:\n        :param step_over:\n        :param angular_deflection:\n        :param linear_deflection:\n        :param circular_use_g2g3:\n        :param gap_threshold:\n        :param optimize_linear_paths:\n        :param optimize_step_over_transitions:\n        :param avoid_last_x_faces:\n        :param avoid_last_x_internal_features:\n        :param boundary_adjustment:\n        :param boundary_enforcement:\n        :param multiple_features:\n        :param internal_features_adjustment:\n        :param internal_features_cut:\n        :param start_point:\n        :param scan_type:\n        :param clearance_height:\n        :param final_depth:\n        :param safe_height:\n        :param start_depth:\n        :param step_down:\n        :return:\n        \"\"\"\n        op = Surface3DOp(\n            bound_box=bound_box,\n            cut_mode=cut_mode,\n            cut_pattern=cut_pattern,\n            cut_pattern_angle=cut_pattern_angle,\n            cut_pattern_reversed=cut_pattern_reversed,\n            depth_offset=depth_offset,\n            layer_mode=layer_mode,\n            profile_edges=profile_edges,\n            sample_interval=sample_interval,\n            step_over=step_over,\n            angular_deflection=angular_deflection,\n            linear_deflection=linear_deflection,\n            circular_use_g2g3=circular_use_g2g3,\n            gap_threshold=gap_threshold,\n            optimize_linear_paths=optimize_linear_paths,\n            optimize_step_over_transitions=optimize_step_over_transitions,\n            avoid_last_x_faces=avoid_last_x_faces,\n            avoid_last_x_internal_features=avoid_last_x_internal_features,\n            boundary_adjustment=boundary_adjustment,\n            boundary_enforcement=boundary_enforcement,\n            multiple_features=multiple_features,\n            internal_features_adjustment=internal_features_adjustment,\n            internal_features_cut=internal_features_cut,\n            start_point=start_point,\n            scan_type=scan_type,\n            # Op\n            tool=tool,\n            compound_data=shape_source_to_compound(shapes, allow_none=True),\n            clearance_height=clearance_height,\n            final_depth=final_depth,\n            safe_height=safe_height,\n            start_depth=start_depth,\n            step_down=step_down,\n            coolant=coolant,\n        )\n        return self._add_op(op)\n\n    def waterline(\n        self,\n        shapes: Optional[ShapeSourceOrIterable],\n        tool: \"Toolbit\",\n        *,\n        algorithm: Literal[\"ocl\", \"experimental\"] = \"ocl\",\n        bound_box: Literal[\"base\", \"stock\"] = \"base\",\n        cut_mode: Literal[\"climb\", \"conventional\"] = \"climb\",\n        depth_offset: float | str = 0,\n        layer_mode: Literal[\"single\", \"multi\"] = \"single\",\n        sample_interval: float | str = \"1.00 mm\",\n        angular_deflection: float | str = \"0.25 mm\",\n        linear_deflection: float | str = \"0.01 mm\",\n        # OP depth\n        clearance_height=None,\n        final_depth=None,\n        safe_height=None,\n        start_depth=None,\n        step_down=None,\n        coolant: Literal[\"None\", \"Flood\", \"Mist\"] = \"None\",\n    ):\n        \"\"\"\n        Similar to the Surface OP, but performs the operation using a push\n        cutter in the XY plane. Used for milling features on the XY-plane.\n\n        If no shape(s) are provided, performs the OP on the whole model.\n\n        See https://wiki.freecad.org/Path_Waterline for usage notes.\n\n        :param shapes:\n        :param tool:\n        :param algorithm:\n        :param bound_box:\n        :param cut_mode:\n        :param depth_offset:\n        :param layer_mode:\n        :param sample_interval:\n        :param angular_deflection:\n        :param linear_deflection:\n        :param clearance_height:\n        :param final_depth:\n        :param safe_height:\n        :param start_depth:\n        :param step_down:\n        :return:\n        \"\"\"\n        op = WaterlineOp(\n            algorithm=algorithm,\n            bound_box=bound_box,\n            cut_mode=cut_mode,\n            depth_offset=depth_offset,\n            layer_mode=layer_mode,\n            sample_interval=sample_interval,\n            angular_deflection=angular_deflection,\n            linear_deflection=linear_deflection,\n            # Op\n            tool=tool,\n            compound_data=shape_source_to_compound(shapes, allow_none=True),\n            clearance_height=clearance_height,\n            final_depth=final_depth,\n            safe_height=safe_height,\n            start_depth=start_depth,\n            step_down=step_down,\n            coolant=coolant,\n        )\n        return self._add_op(op)\n\n    def adaptive(\n        self,\n        shapes: Optional[ShapeSourceOrIterable],\n        tool: \"Toolbit\",\n        *,\n        finishing_profile: bool = True,\n        force_inside_cut: bool = False,\n        helix_angle: float = 5,\n        helix_cone_angle: float = 0,\n        helix_diameter_limit: float | str = 0,\n        keep_tool_down_ratio: float | str = \"3.00 mm\",\n        lift_distance: float | str = 0,\n        operation_type: Literal[\"clearing\", \"profiling\"] = \"clearing\",\n        side: Literal[\"in\", \"out\"] = \"in\",\n        step_over: float = 20,\n        stock_to_leave: float | str = 0,\n        tolerance: float = 0.1,\n        use_helix_arcs: bool = False,\n        use_outline: bool = False,\n        # OP depth\n        clearance_height=None,\n        final_depth=None,\n        safe_height=None,\n        start_depth=None,\n        step_down=None,\n        coolant: Literal[\"None\", \"Flood\", \"Mist\"] = \"None\",\n    ):\n        \"\"\"\n        Adaptive op generates a tool path to maintain constant cutter\n        engagement.\n\n        See https://wiki.freecad.org/Path_Adaptive for usage notes.\n\n        :param shapes:\n        :param tool:\n        :param finishing_profile:\n        :param force_inside_cut:\n        :param helix_angle:\n        :param helix_cone_angle:\n        :param helix_diameter_limit:\n        :param keep_tool_down_ratio:\n        :param lift_distance:\n        :param operation_type:\n        :param side:\n        :param step_over:\n        :param stock_to_leave:\n        :param tolerance:\n        :param use_helix_arcs:\n        :param use_outline:\n        :param clearance_height:\n        :param final_depth:\n        :param safe_height:\n        :param start_depth:\n        :param step_down:\n        :return:\n        \"\"\"\n        op = AdaptiveOp(\n            finishing_profile=finishing_profile,\n            force_inside_cut=force_inside_cut,\n            helix_angle=helix_angle,\n            helix_cone_angle=helix_cone_angle,\n            helix_diameter_limit=helix_diameter_limit,\n            keep_tool_down_ratio=keep_tool_down_ratio,\n            lift_distance=lift_distance,\n            operation_type=operation_type,\n            side=side,\n            step_over=step_over,\n            stock_to_leave=stock_to_leave,\n            tolerance=tolerance,\n            use_helix_arcs=use_helix_arcs,\n            use_outline=use_outline,\n            # Op\n            tool=tool,\n            compound_data=shape_source_to_compound(\n                shapes,\n            ),\n            clearance_height=clearance_height,\n            final_depth=final_depth,\n            safe_height=safe_height,\n            start_depth=start_depth,\n            step_down=step_down,\n            coolant=coolant,\n        )\n        return self._add_op(op)", "\n\nclass Dogbone(Dressup):\n    factory = DogboneII\n    mapping = {\n        \"incision\": \"Incision\",\n        \"custom\": \"Custom\",\n        \"side\": \"Side\",\n        \"style\": (\n            \"Style\",\n            {\n                \"dogbone\": \"Dogbone\",\n                \"thor\": \"T-bone horizontal\",\n                \"tver\": \"T-bone vertical\",\n                \"tlong\": \"T-bone long edge\",\n                \"tshort\": \"T-bone short edge\",\n            },\n        ),\n    }\n\n    def __init__(\n        self,\n        incision: Optional[Literal[\"adaptive\", \"fixed\", \"custom\"]] = None,\n        custom: Optional[float] = None,\n        side: Optional[Literal[\"left\", \"right\"]] = None,\n        style: Optional[Literal[\"dogbone\", \"thor\", \"tver\", \"tlong\", \"tshort\"]] = None,\n    ):\n        \"\"\"\n        Dogbone dressup generates \"dogbones\" to tight corners that the\n        cylindrical cutter would normally not be able to reach.\n\n        See https://wiki.freecad.org/Path_DressupDogbone for usage notes.\n        :param incision:\n        :param custom:\n        :param side:\n        :param style:\n        \"\"\"\n        self.params = map_params(\n            self.mapping, incision=incision, custom=custom, side=side, style=style\n        )\n\n    def create(self, job_impl: \"JobImpl\", base):\n        # DogboneII has this required code that exists only on the GUI side\n        fc_obj = super().create(job_impl, base)\n        job_impl.fc_job.Proxy.addOperation(fc_obj, base)\n\n        # Also..\n        # FreeCAD BUG: Need to do some manual black magic\n        # Code copied from FreeCAD GUI side\n        for i in fc_obj.Base.InList:\n            if hasattr(i, \"Group\") and fc_obj.Base.Name in [o.Name for o in i.Group]:\n                i.Group = [o for o in i.Group if o.Name != fc_obj.Base.Name]\n\n        return fc_obj", "\n\nclass Tab(Dressup):\n    factory = Tags\n    mapping = {\n        \"angle\": \"Angle\",\n        \"height\": AutoUnitKey(\"Height\"),\n        \"width\": AutoUnitKey(\"Width\"),\n        \"positions\": \"Positions\",\n        \"disabled\": \"Disabled\",\n        \"fillet_radius\": \"Radius\",\n        \"segmentation_factor\": \"SegmentationFactor\",\n    }\n\n    def __init__(\n        self,\n        angle=None,\n        height=None,\n        width=None,\n        positions=None,\n        disabled=None,\n        fillet_radius=None,\n        segmentation_factor=None,\n    ):\n        \"\"\"\n        Tab dressup generates tabs (or tags), useful for example when\n        profiling to keep the part attached to the stock.\n\n        See https://wiki.freecad.org/Path_DressupTag for usage notes.\n\n        :param angle:\n        :param height:\n        :param width:\n        :param positions:\n        :param disabled:\n        :param fillet_radius:\n        :param segmentation_factor:\n        \"\"\"\n        self.params = map_params(\n            self.mapping,\n            angle=angle,\n            height=height,\n            width=width,\n            positions=positions,\n            disabled=disabled,\n            fillet_radius=fillet_radius,\n            segmentation_factor=segmentation_factor,\n        )\n\n    def create(self, job_impl: \"JobImpl\", base):\n        obj = super().create(job_impl, base)\n\n        # FreeCAD BUG: Need to do some manual black magic\n        # Code copied from FreeCAD GUI side\n        for i in obj.Base.InList:\n            if hasattr(i, \"Group\") and obj.Base.Name in [o.Name for o in i.Group]:\n                i.Group = [o for o in i.Group if o.Name != obj.Base.Name]\n\n        return obj", "\n\nStock = StockImpl\n"]}
{"filename": "src/ocp_freecad_cam/api_util.py", "chunked_list": ["import io\nfrom dataclasses import dataclass\nfrom typing import Literal, Optional, TypeAlias, Union\n\nimport FreeCAD\nimport Path.Base.Util as PathUtil\nfrom OCP.BRepBuilderAPI import BRepBuilderAPI_Transform\nfrom OCP.BRepTools import BRepTools\nfrom OCP.gp import gp_Pln, gp_Pnt, gp_Trsf\nfrom OCP.ShapeFix import ShapeFix_Shape", "from OCP.gp import gp_Pln, gp_Pnt, gp_Trsf\nfrom OCP.ShapeFix import ShapeFix_Shape\nfrom OCP.TopAbs import TopAbs_EDGE, TopAbs_FACE, TopAbs_ShapeEnum\nfrom OCP.TopExp import TopExp_Explorer\nfrom OCP.TopoDS import (\n    TopoDS_Builder,\n    TopoDS_Compound,\n    TopoDS_Edge,\n    TopoDS_Face,\n    TopoDS_Shape,", "    TopoDS_Face,\n    TopoDS_Shape,\n    TopoDS_Solid,\n    TopoDS_Vertex,\n    TopoDS_Wire,\n)\n\nfrom ocp_freecad_cam.common import PlaneSource\n\ntry:", "\ntry:\n    import cadquery as cq\nexcept ImportError:\n    cq = None\ntry:\n    import build123d as b3d\nexcept ImportError:\n    b3d = None\n", "    b3d = None\n\nTopoDS_ShapeTypes: TypeAlias = Union[\n    TopoDS_Face, TopoDS_Wire, TopoDS_Edge, TopoDS_Vertex, TopoDS_Compound\n]\nCompoundSource: TypeAlias = Union[\n    TopoDS_Compound,\n    \"cq.Compound\",\n    \"b3d.Compound\",\n    \"cq.Workplane\",", "    \"b3d.Compound\",\n    \"cq.Workplane\",\n    \"b3d.ShapeList\",\n    \"cq.Solid\",\n    \"b3d.Solid\",\n]\nShapeSource: TypeAlias = Union[\n    TopoDS_ShapeTypes,\n    \"cq.Workplane\",\n    \"cq.Face\",", "    \"cq.Workplane\",\n    \"cq.Face\",\n    \"cq.Wire\",\n    \"cq.Edge\",\n    \"cq.Vertex\",\n    \"cq.Compound\",\n    \"b3d.ShapeList\",\n    \"b3d.Face\",\n    \"b3d.Wire\",\n    \"b3d.Edge\",", "    \"b3d.Wire\",\n    \"b3d.Edge\",\n    \"b3d.Vertex\",\n    \"b3d.Compound\",\n    \"b3d.Part\",\n]\nShapeSourceOrIterable: TypeAlias = Union[ShapeSource, list[ShapeSource]]\n\n\n# todo wire needs to be broken to edges..", "\n# todo wire needs to be broken to edges..\n\n\ndef extract_topods_shapes(\n    shape_source: ShapeSourceOrIterable, compound=False\n) -> list[TopoDS_ShapeTypes]:\n    if isinstance(shape_source, list):\n        shapes = []\n        for source in shape_source:", "        shapes = []\n        for source in shape_source:\n            shapes += extract_topods_shapes(source, compound=compound)\n        return shapes\n\n    if cq:\n        valid_cq_shapes = (\n            [cq.Compound, cq.Solid]\n            if compound\n            else [cq.Face, cq.Wire, cq.Edge, cq.Vertex]", "            if compound\n            else [cq.Face, cq.Wire, cq.Edge, cq.Vertex]\n        )\n        if isinstance(shape_source, cq.Workplane):\n            return [\n                shape.wrapped\n                for shape in shape_source.objects\n                if type(shape) in valid_cq_shapes\n            ]\n        elif type(shape_source) in valid_cq_shapes:", "            ]\n        elif type(shape_source) in valid_cq_shapes:\n            return [shape_source.wrapped]\n    if b3d:\n        valid_b3d_shapes = (\n            [b3d.Compound, b3d.Solid, b3d.Part]\n            if compound\n            else [b3d.Face, b3d.Wire, b3d.Vertex]\n        )\n        if isinstance(shape_source, b3d.ShapeList):", "        )\n        if isinstance(shape_source, b3d.ShapeList):\n            return [\n                shape.wrapped\n                for shape in shape_source\n                if type(shape) in valid_b3d_shapes\n            ]\n        elif type(shape_source) in valid_b3d_shapes:\n            return [shape_source.wrapped]\n", "            return [shape_source.wrapped]\n\n    valid_topods_shapes = (\n        [TopoDS_Compound, TopoDS_Solid]\n        if compound\n        else [TopoDS_Face, TopoDS_Wire, TopoDS_Edge, TopoDS_Vertex]\n    )\n    if type(shape_source) in valid_topods_shapes:\n        return [shape_source]\n", "        return [shape_source]\n\n    raise ValueError(f\"Unknown shape source of type {type(shape_source)}\")\n\n\ndef split_shapes_by_type(\n    shapes: list[TopoDS_ShapeTypes],\n) -> tuple[list[TopoDS_Face], list[TopoDS_Edge], list[TopoDS_Vertex]]:\n    faces = []\n    wires = []", "    faces = []\n    wires = []\n    edges = []\n    vertices = []\n    for shape in shapes:\n        if isinstance(shape, TopoDS_Face):\n            faces.append(shape)\n        elif isinstance(shape, TopoDS_Wire):\n            wires.append(shape)\n        elif isinstance(shape, TopoDS_Edge):", "            wires.append(shape)\n        elif isinstance(shape, TopoDS_Edge):\n            edges.append(shape)\n        elif isinstance(shape, TopoDS_Vertex):\n            vertices.append(shape)\n        elif isinstance(shape, TopoDS_Compound):\n            faces += break_shape_to(shape, TopAbs_FACE)\n        else:\n            raise ValueError(f\"Unknown shape type {type(shape)}\")\n", "            raise ValueError(f\"Unknown shape type {type(shape)}\")\n\n    # Selecting wires is not supported by FreeCAD so explode wires\n    # into edges\n    for wire in wires:\n        wire_edges = break_shape_to(wire, TopAbs_EDGE)\n        edges += wire_edges\n\n    return faces, edges, vertices\n", "    return faces, edges, vertices\n\n\ndef break_shape_to(\n    shape: TopoDS_Shape, shape_type: TopAbs_ShapeEnum\n) -> list[TopoDS_Shape]:\n    sub_shapes = []\n    explorer = TopExp_Explorer(shape, shape_type)\n    while explorer.More():\n        sub_shape = explorer.Current()", "    while explorer.More():\n        sub_shape = explorer.Current()\n        sub_shapes.append(sub_shape)\n        explorer.Next()\n    return sub_shapes\n\n\ndef transform_shapes(shapes: list[TopoDS_Shape], trsf: gp_Trsf) -> list[TopoDS_Shape]:\n    return [transform_shape(shape, trsf) for shape in shapes]\n", "    return [transform_shape(shape, trsf) for shape in shapes]\n\n\ndef transform_shape(shape: TopoDS_Shape, trsf: gp_Trsf) -> TopoDS_Shape:\n    return BRepBuilderAPI_Transform(shape, trsf).Shape()\n\n\ndef shapes_to_brep(shapes: list[TopoDS_Shape]):\n    return [shape_to_brep(shape) for shape in shapes]\n", "    return [shape_to_brep(shape) for shape in shapes]\n\n\ndef scale_shape(shape: TopoDS_Shape, scale_factor: float) -> TopoDS_Shape:\n    trsf = gp_Trsf()\n    center_of_the_universe = gp_Pnt(0, 0, 0)\n    trsf.SetScale(center_of_the_universe, scale_factor)\n    return transform_shape(shape, trsf)\n\n", "\n\ndef shape_to_brep(shape: TopoDS_Shape):\n    # Fix the shape first so that FreeCAD doesn't choke on it\n    shape_fix = ShapeFix_Shape(shape)\n    shape_fix.Perform()\n    fixed_shape = shape_fix.Shape()\n\n    data = io.BytesIO()\n    BRepTools.Write_s(fixed_shape, data)", "    data = io.BytesIO()\n    BRepTools.Write_s(fixed_shape, data)\n    data.seek(0)\n    return data.read().decode(\"utf8\")\n\n\ndef shape_source_to_compound_brep(\n    shape_source: ShapeSourceOrIterable,\n    trsf: gp_Trsf,\n    scale_factor: Optional[float],", "    trsf: gp_Trsf,\n    scale_factor: Optional[float],\n    allow_none=False,\n):\n    if allow_none and shape_source is None:\n        return {\n            \"face_count\": 0,\n            \"edge_count\": 0,\n            \"vertex_count\": 0,\n            \"compound_brep\": None,", "            \"vertex_count\": 0,\n            \"compound_brep\": None,\n        }\n\n    shapes = extract_topods_shapes(shape_source)\n    if not shapes:\n        shapes = extract_topods_shapes(shape_source, True)\n    faces, edges, vertices = split_shapes_by_type(shapes)\n\n    if not faces and not edges and not vertices:", "\n    if not faces and not edges and not vertices:\n        raise ValueError(\"Empty ShapeSource\")\n\n    compound = TopoDS_Compound()\n    builder = TopoDS_Builder()\n    builder.MakeCompound(compound)\n\n    for face in faces:\n        builder.Add(compound, face)", "    for face in faces:\n        builder.Add(compound, face)\n\n    for edge in edges:\n        builder.Add(compound, edge)\n\n    for vertex in vertices:\n        builder.Add(compound, vertex)\n\n    compound = transform_shape(compound, trsf)", "\n    compound = transform_shape(compound, trsf)\n    if scale_factor:\n        compound = scale_shape(compound, scale_factor)\n\n    return {\n        \"face_count\": len(faces),\n        \"edge_count\": len(edges),\n        \"vertex_count\": len(vertices),\n        \"compound_brep\": shape_to_brep(compound),", "        \"vertex_count\": len(vertices),\n        \"compound_brep\": shape_to_brep(compound),\n    }\n\n\n@dataclass\nclass CompoundData:\n    face_count: int\n    edge_count: int\n    vertex_count: int", "    edge_count: int\n    vertex_count: int\n    compound: Optional[TopoDS_Compound]\n\n    def to_transformed_brep(\n        self, trsf: gp_Trsf, scale_factor: float = None\n    ) -> Optional[str]:\n        if self.compound is None:\n            return None\n        compound = transform_shape(self.compound, trsf)", "            return None\n        compound = transform_shape(self.compound, trsf)\n        if scale_factor:\n            compound = scale_shape(compound, scale_factor)\n        return shape_to_brep(compound)\n\n\ndef shape_source_to_compound(\n    shape_source: ShapeSourceOrIterable,\n    allow_none=False,", "    shape_source: ShapeSourceOrIterable,\n    allow_none=False,\n) -> CompoundData:\n    if allow_none and shape_source is None:\n        return CompoundData(0, 0, 0, None)\n\n    shapes = extract_topods_shapes(shape_source)\n    if not shapes:\n        shapes = extract_topods_shapes(shape_source, True)\n    faces, edges, vertices = split_shapes_by_type(shapes)", "        shapes = extract_topods_shapes(shape_source, True)\n    faces, edges, vertices = split_shapes_by_type(shapes)\n\n    if not faces and not edges and not vertices:\n        raise ValueError(\"Empty ShapeSource\")\n\n    compound = TopoDS_Compound()\n    builder = TopoDS_Builder()\n    builder.MakeCompound(compound)\n", "    builder.MakeCompound(compound)\n\n    for face in faces:\n        builder.Add(compound, face)\n\n    for edge in edges:\n        builder.Add(compound, edge)\n\n    for vertex in vertices:\n        builder.Add(compound, vertex)", "    for vertex in vertices:\n        builder.Add(compound, vertex)\n\n    return CompoundData(len(faces), len(edges), len(vertices), compound)\n\n\nclass AutoUnitKey:\n    def __init__(self, key, mode: Literal[\"distance\", \"feed\"] = \"distance\"):\n        self.key = key\n        self.mode = mode", "        self.key = key\n        self.mode = mode\n\n\nclass AutoUnitValue:\n    def __init__(self, value, mode: Literal[\"distance\", \"feed\"] = \"distance\"):\n        self.value = value\n        self.mode = mode\n\n    def convert(self, unit: Literal[\"metric\", \"imperial\"]):", "\n    def convert(self, unit: Literal[\"metric\", \"imperial\"]):\n        return self._convert(self.value, unit)\n\n    def value_unit(self, unit: Literal[\"metric\", \"imperial\"]):\n        match (unit, self.mode):\n            case \"metric\", \"distance\":\n                return \"mm\"\n            case \"metric\", \"feed\":\n                return \"mm/min\"", "            case \"metric\", \"feed\":\n                return \"mm/min\"\n            case \"imperial\", \"distance\":\n                return \"in\"\n            case \"imperial\", \"feed\":\n                return \"in/min\"\n\n        raise ValueError(f\"Undefined unit/mode combination: {unit} / {self.mode}\")\n\n    def _convert(self, value, unit: Literal[\"metric\", \"imperial\"]):", "\n    def _convert(self, value, unit: Literal[\"metric\", \"imperial\"]):\n        pq = FreeCAD.Units.parseQuantity\n\n        if isinstance(value, (int, float)):\n            return float(pq(f\"{value} {self.value_unit(unit)}\"))\n\n        elif isinstance(value, tuple):\n            return tuple(self._convert(v, unit) for v in value)\n", "            return tuple(self._convert(v, unit) for v in value)\n\n        return float(pq(value))\n\n\nclass Expression:\n    def __init__(self, expression):\n        self.expression = expression\n\n", "\n\nParamMapping: TypeAlias = dict[str, Union[str, AutoUnitKey, dict[str, str]]]\n\n\ndef map_prop(mapping: ParamMapping, k, v):\n    result = mapping[k]\n    match result:\n        case AutoUnitKey():\n            return result.key, AutoUnitValue(v, mode=result.mode)", "        case AutoUnitKey():\n            return result.key, AutoUnitValue(v, mode=result.mode)\n        case (nk, dv):\n            return nk, dv[v]\n        case nk:\n            return nk, v\n\n\ndef map_params(mapping: ParamMapping, **kwargs):\n    return dict(map_prop(mapping, k, v) for k, v in kwargs.items() if v is not None)", "def map_params(mapping: ParamMapping, **kwargs):\n    return dict(map_prop(mapping, k, v) for k, v in kwargs.items() if v is not None)\n\n\ndef apply_params(fc_obj, params, unit: Literal[\"metric\", \"imperial\"]):\n    for k, v in params.items():\n        if isinstance(v, AutoUnitValue):\n            v = v.convert(unit)\n        if isinstance(v, Expression):\n            fc_obj.setExpression(k, v.expression)", "        if isinstance(v, Expression):\n            fc_obj.setExpression(k, v.expression)\n        else:\n            PathUtil.setProperty(fc_obj, k, v)\n\n\ndef extract_plane(plane_source: PlaneSource) -> gp_Pln:\n    if cq:\n        if isinstance(plane_source, cq.Workplane):\n            return plane_source.plane.toPln()", "        if isinstance(plane_source, cq.Workplane):\n            return plane_source.plane.toPln()\n\n        elif isinstance(plane_source, (cq.Plane, cq.Face)):\n            return plane_source.toPln()\n\n    if b3d:\n        if isinstance(plane_source, b3d.Plane):\n            return plane_source.wrapped\n        elif isinstance(plane_source, b3d.Face):", "            return plane_source.wrapped\n        elif isinstance(plane_source, b3d.Face):\n            return b3d.Plane(face=plane_source).wrapped\n\n    if isinstance(plane_source, gp_Pln):\n        return plane_source\n\n    raise ValueError(f\"Unknown type of plane: {type(plane_source)}\")\n", ""]}
{"filename": "src/ocp_freecad_cam/fc_impl_util.py", "chunked_list": ["from OCP.gp import gp_Ax3, gp_Pln, gp_Trsf\n\n\ndef calculate_transforms(plane: gp_Pln) -> (gp_Trsf, gp_Trsf):\n    \"\"\"\n    Implementation from CadQuery\n\n    Forward transform relative to top plane everything that goes to FreeCAD\n    Backward transform to visualize stuff produced by FreeCAD\n\n    \"\"\"\n    forward = gp_Trsf()\n    backward = gp_Trsf()\n\n    global_coord_system = gp_Ax3()\n    local_coord_system = plane.Position()\n\n    forward.SetTransformation(global_coord_system, local_coord_system)\n    backward.SetTransformation(local_coord_system, global_coord_system)\n\n    return forward, backward", ""]}
{"filename": "src/ocp_freecad_cam/__init__.py", "chunked_list": ["import sys\n\n# This needs to be done due to some weird bug that causes\n# ImportError: 'FreeCAD' is not a built-in module\n# For example in CQ-Editor if import reload is enabled\nif hasattr(sys, \"_cached_freecad_module\"):\n    sys.modules[\"FreeCAD\"] = sys._cached_freecad_module\nelse:\n    import FreeCAD  # noqa\n\n    sys._cached_freecad_module = sys.modules[\"FreeCAD\"]", "\nfrom ocp_freecad_cam.api import Job\nfrom ocp_freecad_cam.api_tool import (\n    Ballnose,\n    Bullnose,\n    Chamfer,\n    Drill,\n    Endmill,\n    Probe,\n    SlittingSaw,", "    Probe,\n    SlittingSaw,\n    ThreadMill,\n    VBit,\n)\n\n__all__ = [\n    Job,\n    Ballnose,\n    Bullnose,", "    Ballnose,\n    Bullnose,\n    Chamfer,\n    Drill,\n    Endmill,\n    Probe,\n    SlittingSaw,\n    ThreadMill,\n    VBit,\n]", "    VBit,\n]\n"]}
{"filename": "src/ocp_freecad_cam/visualizer.py", "chunked_list": ["import math\nfrom abc import ABC\nfrom collections import defaultdict\nfrom itertools import pairwise\nfrom typing import TYPE_CHECKING, Callable, Optional, Union\n\nfrom cadquery.units import DEG2RAD\nfrom OCP.AIS import AIS_Circle, AIS_Line, AIS_MultipleConnectedInteractive, AIS_Shape\nfrom OCP.BRepBuilderAPI import BRepBuilderAPI_MakeEdge\nfrom OCP.GC import GC_MakeArcOfCircle", "from OCP.BRepBuilderAPI import BRepBuilderAPI_MakeEdge\nfrom OCP.GC import GC_MakeArcOfCircle\nfrom OCP.GCE2d import GCE2d_MakeSegment\nfrom OCP.Geom import (\n    Geom_CartesianPoint,\n    Geom_Circle,\n    Geom_ConicalSurface,\n    Geom_CylindricalSurface,\n    Geom_Surface,\n)", "    Geom_Surface,\n)\nfrom OCP.Geom2d import Geom2d_Line\nfrom OCP.gp import gp_Ax2, gp_Ax3, gp_Dir, gp_Dir2d, gp_Pnt, gp_Pnt2d, gp_Trsf, gp_Vec\nfrom OCP.Quantity import Quantity_Color, Quantity_NOC_GREEN, Quantity_NOC_YELLOW\nfrom OCP.TopoDS import TopoDS_Builder, TopoDS_Compound, TopoDS_Edge\nfrom Path.Post.Command import buildPostList\n\nfrom ocp_freecad_cam.api_util import transform_shape\n", "from ocp_freecad_cam.api_util import transform_shape\n\nif TYPE_CHECKING:\n    pass\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nais_color_map = {\n    \"yellow\": Quantity_Color(Quantity_NOC_YELLOW),", "ais_color_map = {\n    \"yellow\": Quantity_Color(Quantity_NOC_YELLOW),\n    \"green\": Quantity_Color(Quantity_NOC_GREEN),\n}\nrgb_color_map = {\n    \"yellow\": (150, 150, 0),\n    \"green\": (0, 200, 0),\n}\n\n", "\n\nclass VisualCommand(ABC):\n    def __init__(self, *, x, y, z, **kwargs):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    def to_ais(self, start: \"VisualCommand\"):\n        raise NotImplementedError", "    def to_ais(self, start: \"VisualCommand\"):\n        raise NotImplementedError\n\n    def to_edge(self, start: \"VisualCommand\") -> Optional[tuple[TopoDS_Edge, str]]:\n        raise NotImplementedError\n\n    def __eq__(self, other):\n        if isinstance(other, VisualCommand):\n            return self.x == other.x and self.y == other.y and self.z == other.z\n        raise TypeError(f\"Can not compare {type(self)} with {type(other)}\")", "            return self.x == other.x and self.y == other.y and self.z == other.z\n        raise TypeError(f\"Can not compare {type(self)} with {type(other)}\")\n\n\nclass LinearVisualCommand(VisualCommand):\n    def to_ais(self, start: \"VisualCommand\"):\n        if start == self:\n            return None\n        start_point = Geom_CartesianPoint(start.x, start.y, start.z)\n        end_point = Geom_CartesianPoint(self.x, self.y, self.z)", "        start_point = Geom_CartesianPoint(start.x, start.y, start.z)\n        end_point = Geom_CartesianPoint(self.x, self.y, self.z)\n\n        return AIS_Line(start_point, end_point)\n\n    def to_edge(self, start: \"VisualCommand\") -> Optional[tuple[TopoDS_Edge, str]]:\n        if start == self:\n            return None\n\n        start_point = gp_Pnt(start.x, start.y, start.z)", "\n        start_point = gp_Pnt(start.x, start.y, start.z)\n        end_point = gp_Pnt(self.x, self.y, self.z)\n        return BRepBuilderAPI_MakeEdge(start_point, end_point).Edge(), \"yellow\"\n\n\nclass RapidVisualCommand(LinearVisualCommand):\n    pass\n\n", "\n\nclass ArcVisualCommand(LinearVisualCommand, ABC):\n    def __init__(self, *, arc_plane, i=None, j=None, k=None, **kwargs):\n        # TODO: XY has i and j, not k!\n        super().__init__(**kwargs)\n        self.arc_plane = arc_plane\n        self.i = i\n        self.j = j\n        self.k = k", "        self.j = j\n        self.k = k\n\n    def circle_normal_dir(self, circle_normal: gp_Vec):\n        raise NotImplementedError\n\n    @property\n    def clockwise(self):\n        raise NotImplementedError\n", "        raise NotImplementedError\n\n    def to_ais(self, start: VisualCommand):\n        shape, color = self._to_shape(start)\n        if isinstance(shape, Geom_Circle):\n            ais_shape = AIS_Circle(shape)\n        else:\n            ais_shape = AIS_Shape(shape)\n\n        if color:", "\n        if color:\n            ais_shape.SetColor(ais_color_map[color])\n        return ais_shape\n\n    def to_edge(self, start: \"VisualCommand\") -> Optional[tuple[TopoDS_Edge, str]]:\n        shape, color = self._to_shape(start)\n        if isinstance(shape, TopoDS_Edge):\n            edge = shape\n        else:", "            edge = shape\n        else:\n            edge = BRepBuilderAPI_MakeEdge(shape).Edge()\n\n        return edge, \"yellow\"  # todo hardcoded color is a wee silly\n\n    def _to_shape(\n        self, start: VisualCommand\n    ) -> tuple[Union[TopoDS_Edge, Geom_Circle], str]:\n        if self.arc_plane == (0, 0, 1):", "    ) -> tuple[Union[TopoDS_Edge, Geom_Circle], str]:\n        if self.arc_plane == (0, 0, 1):\n            if self.i is None or self.j is None:\n                raise ValueError(\"I and J must be defined for XY arc\")\n            cx = start.x + self.i\n            cy = start.y + self.j\n            cz = (start.z + self.z) / 2.0\n            i = self.i\n            j = self.j\n            k = cz - start.z", "            j = self.j\n            k = cz - start.z\n            height = k * 2\n            start_center = gp_Pnt(cx, cy, start.z)\n            radius = math.sqrt(self.i**2 + self.j**2)\n            full_circle = start.x == self.x and start.y == self.y\n\n        elif self.arc_plane == (0, 1, 0):\n            if self.i is None or self.k is None:\n                raise ValueError(\"I and K must be defined for XZ arc\")", "            if self.i is None or self.k is None:\n                raise ValueError(\"I and K must be defined for XZ arc\")\n            cx = start.x + self.i\n            cy = (start.y + self.y) / 2.0\n            cz = start.z + self.k\n            i = self.i\n            j = cy - start.y\n            k = self.k\n            height = j * 2\n            start_center = gp_Pnt(cx, start.y, cz)", "            height = j * 2\n            start_center = gp_Pnt(cx, start.y, cz)\n            radius = math.sqrt(self.i**2 + self.k**2)\n            full_circle = start.x == self.x and start.z == self.z\n\n        elif self.arc_plane == (1, 0, 0):\n            if self.j is None or self.k is None:\n                raise ValueError(\"J and K must be defined for YZ arc\")\n            cx = (start.x + self.x) / 2.0\n            cy = start.y + self.j", "            cx = (start.x + self.x) / 2.0\n            cy = start.y + self.j\n            cz = start.z + self.k\n            i = cx - start.x\n            j = self.j\n            k = self.k\n            height = i * 2\n            start_center = gp_Pnt(start.x, cy, cz)\n            radius = math.sqrt(self.j**2 + self.k**2)\n            full_circle = start.y == self.y and start.z == self.z", "            radius = math.sqrt(self.j**2 + self.k**2)\n            full_circle = start.y == self.y and start.z == self.z\n\n        else:\n            raise ValueError(f\"Unknown arc plane: {self.arc_plane}\")\n\n        c = gp_Pnt(cx, cy, cz)\n        if height:\n            # FreeCAD helix always starts from (X+radius, Y)\n            # Same thing for CQ helix. Only need to calc pitch", "            # FreeCAD helix always starts from (X+radius, Y)\n            # Same thing for CQ helix. Only need to calc pitch\n            # FreeCAD also produces only full or half circle, so\n            # exploit that :-D\n            if full_circle:\n                pitch = abs(height)\n            else:\n                pitch = abs(height / 2)\n            e = makeHelix(\n                pitch,", "            e = makeHelix(\n                pitch,\n                height,\n                radius,\n                start_center,\n                gp_Dir(*self.arc_plane),\n                lefthand=not self.clockwise,\n            )\n            return e, \"green\"\n", "            return e, \"green\"\n\n        # XY\n        arc_plane = gp_Vec(*self.arc_plane)\n        cv = gp_Vec(i, j, k)\n        forward = cv.Crossed(arc_plane)\n        circle_normal = cv.Crossed(forward)\n        circle_normal_dir = self.circle_normal_dir(circle_normal)\n\n        forward_dir = gp_Dir(forward.X(), forward.Y(), forward.Z())", "\n        forward_dir = gp_Dir(forward.X(), forward.Y(), forward.Z())\n        circle_ax = gp_Ax2(c, circle_normal_dir, forward_dir)\n        geom_circle = Geom_Circle(circle_ax, radius)\n        start_point = gp_Pnt(start.x, start.y, start.z)\n        end_point = gp_Pnt(self.x, self.y, self.z)\n\n        if start_point.IsEqual(end_point, 1e-4):\n            return geom_circle, \"yellow\"\n        else:", "            return geom_circle, \"yellow\"\n        else:\n            curve = GC_MakeArcOfCircle(\n                geom_circle.Circ(), start_point, end_point, True\n            ).Value()\n            edge = BRepBuilderAPI_MakeEdge(curve).Edge()\n            return edge, \"yellow\"\n\n\ndef makeHelix(", "\ndef makeHelix(\n    pitch: float,\n    height: float,\n    radius: float,\n    center: gp_Pnt,\n    dir: gp_Dir,\n    angle: float = 360.0,\n    lefthand: bool = False,\n) -> \"TopoDS_Edge\":", "    lefthand: bool = False,\n) -> \"TopoDS_Edge\":\n    \"\"\"\n    Make a helix with a given pitch, height and radius\n    By default a cylindrical surface is used to create the helix. If\n    the fourth parameter is set (the apex given in degree) a conical surface\n    is used instead.\n\n    Implementation copied from CadQuery, which looks like it borrowed the code from\n    FreeCAD.. unable to trace the original author from commit history, but", "    Implementation copied from CadQuery, which looks like it borrowed the code from\n    FreeCAD.. unable to trace the original author from commit history, but\n    thanks CQ and FreeCAD contributors!\n    \"\"\"\n\n    # 1. build underlying cylindrical/conical surface\n    if angle == 360.0:\n        geom_surf: Geom_Surface = Geom_CylindricalSurface(gp_Ax3(center, dir), radius)\n    else:\n        geom_surf = Geom_ConicalSurface(", "    else:\n        geom_surf = Geom_ConicalSurface(\n            gp_Ax3(center, dir),\n            angle * DEG2RAD,\n            radius,\n        )\n\n    # 2. construct a segment in the u,v domain\n    if lefthand:\n        geom_line = Geom2d_Line(gp_Pnt2d(0.0, 0.0), gp_Dir2d(-2 * math.pi, pitch))", "    if lefthand:\n        geom_line = Geom2d_Line(gp_Pnt2d(0.0, 0.0), gp_Dir2d(-2 * math.pi, pitch))\n    else:\n        geom_line = Geom2d_Line(gp_Pnt2d(0.0, 0.0), gp_Dir2d(2 * math.pi, pitch))\n\n    # 3. put it together into am edge\n    n_turns = height / pitch\n    u_start = geom_line.Value(0.0)\n    u_stop = geom_line.Value(n_turns * math.sqrt((2 * math.pi) ** 2 + pitch**2))\n    geom_seg = GCE2d_MakeSegment(u_start, u_stop).Value()", "    u_stop = geom_line.Value(n_turns * math.sqrt((2 * math.pi) ** 2 + pitch**2))\n    geom_seg = GCE2d_MakeSegment(u_start, u_stop).Value()\n\n    e = BRepBuilderAPI_MakeEdge(geom_seg, geom_surf).Edge()\n    return e\n\n\nclass CWArcVisualCommand(ArcVisualCommand):\n    def circle_normal_dir(self, circle_normal: gp_Vec):\n        return gp_Dir(circle_normal.X(), circle_normal.Y(), circle_normal.Z())", "    def circle_normal_dir(self, circle_normal: gp_Vec):\n        return gp_Dir(circle_normal.X(), circle_normal.Y(), circle_normal.Z())\n\n    @property\n    def clockwise(self):\n        return True\n\n\nclass CCWArcVisualCommand(ArcVisualCommand):\n    def circle_normal_dir(self, circle_normal: gp_Vec):", "class CCWArcVisualCommand(ArcVisualCommand):\n    def circle_normal_dir(self, circle_normal: gp_Vec):\n        return gp_Dir(-circle_normal.X(), -circle_normal.Y(), -circle_normal.Z())\n\n    @property\n    def clockwise(self):\n        return False\n\n\ndef visualize_fc_job(", "\ndef visualize_fc_job(\n    job, inverse_trsf: gp_Trsf, show_object: Optional[Callable] = None\n):\n    visual_commands = generate_visual_commands(job)\n    if show_object is None:\n        logger.warning(\"No show object - unable to automatically visualize job\")\n        return visual_commands_to_ais(visual_commands, inverse_trsf=inverse_trsf)\n\n    match source_module := show_object.__module__.split(\".\")[0]:  # noqa", "\n    match source_module := show_object.__module__.split(\".\")[0]:  # noqa\n        case \"cq_editor\" | \"cq_viewer\":\n            ais = visual_commands_to_ais(visual_commands, inverse_trsf=inverse_trsf)\n            if ais is None:\n                logger.warning(\"Empty job, nothing to show\")\n                return None\n            show_object(ais, \"G-Code\")  # todo better naming\n            return ais\n", "            return ais\n\n        case \"ocp_vscode\":\n            color_compounds = visual_commands_to_edges(\n                visual_commands, inverse_trsf=inverse_trsf\n            )\n            if color_compounds is None:\n                logger.warning(\"Empty job, nothing to show\")\n                return None\n", "                return None\n\n            for color, compound in color_compounds:\n                show_object(\n                    compound, options={\"color\": rgb_color_map[color]}\n                )  # TODO better renaming\n            return color_compounds\n        case _:\n            logger.warning(\n                f\"Unsupported show_object source module ({source_module}) - visualizing as edges without color\"", "            logger.warning(\n                f\"Unsupported show_object source module ({source_module}) - visualizing as edges without color\"\n            )\n            color_compounds = visual_commands_to_edges(\n                visual_commands, inverse_trsf=inverse_trsf\n            )\n            if color_compounds is None:\n                logger.warning(\"Empty job, nothing to show\")\n                return None\n            for color, compound in color_compounds:", "                return None\n            for color, compound in color_compounds:\n                show_object(compound)\n            return color_compounds\n\n\ndef generate_visual_commands(job):\n    \"\"\"\n    Visualize a FreeCAD job\n    https://wiki.freecad.org/Path_scripting#The_FreeCAD_Internal_GCode_Format", "    Visualize a FreeCAD job\n    https://wiki.freecad.org/Path_scripting#The_FreeCAD_Internal_GCode_Format\n    \"\"\"\n    params = {\"x\": 0, \"y\": 0, \"arc_plane\": (0, 0, 1)}\n    relative = False\n    canned = False\n    canned_r = False\n    canned_z = None\n\n    visual_commands = []", "\n    visual_commands = []\n\n    postlist = buildPostList(job)\n    for name, sub_op_list in postlist:\n        for op in sub_op_list:\n            if hasattr(op, \"Path\"):\n                commands = op.Path.Commands\n            else:\n                commands = op.Proxy.commandlist", "            else:\n                commands = op.Proxy.commandlist\n\n            for command in commands:\n                new_params = {k.lower(): v for k, v in command.Parameters.items()}\n                if relative:\n                    # Convert to absolute\n                    rel_attrs = [\"x\", \"y\", \"z\"]\n                    for attr in rel_attrs:\n                        if attr in new_params:", "                    for attr in rel_attrs:\n                        if attr in new_params:\n                            # This will catch fire if params does not have a previous value\n                            # Not sure if FreeCAD generates code like that, so lets see\n                            # if it needs to be handled..\n                            new_params[attr] = new_params[attr] + params[attr]\n                combined_params = {**params, **new_params}\n                match command.Name:\n                    case \"G0\":\n                        params = add_command(", "                    case \"G0\":\n                        params = add_command(\n                            visual_commands, RapidVisualCommand, **combined_params\n                        )\n                    case \"G1\":\n                        params = add_command(\n                            visual_commands, LinearVisualCommand, **combined_params\n                        )\n                    case \"G2\":\n                        params = add_command(", "                    case \"G2\":\n                        params = add_command(\n                            visual_commands, CWArcVisualCommand, **combined_params\n                        )\n                    case \"G3\":\n                        params = add_command(\n                            visual_commands, CCWArcVisualCommand, **combined_params\n                        )\n                    case \"G17\":\n                        params[\"arc_plane\"] = (0, 0, 1)", "                    case \"G17\":\n                        params[\"arc_plane\"] = (0, 0, 1)\n                    case \"G18\":\n                        params[\"arc_plane\"] = (0, 1, 0)\n                    case \"G19\":\n                        params[\"arc_plane\"] = (1, 0, 0)\n                    case \"G81\":\n                        # Canned cycle\n                        # FreeCAD canned cycle looks to be in a format like\n                        # G81 X2.000 Y-2.000 Z-2.000 R3.000", "                        # FreeCAD canned cycle looks to be in a format like\n                        # G81 X2.000 Y-2.000 Z-2.000 R3.000\n                        # So we issue two commands, first going down to Z\n                        # and then coming back up to R\n                        if not canned:\n                            if not canned_r:\n                                canned_z = params[\"z\"]\n                            canned = True\n\n                        add_command(", "\n                        add_command(\n                            visual_commands, LinearVisualCommand, **combined_params\n                        )\n                        if canned_r:\n                            combined_params = {\n                                **combined_params,\n                                \"z\": combined_params[\"r\"],\n                            }\n                        else:", "                            }\n                        else:\n                            combined_params = {**combined_params, \"z\": canned_z}\n                        params = add_command(\n                            visual_commands, LinearVisualCommand, **combined_params\n                        )\n\n                    case \"G80\":\n                        # End of canned cycle\n                        canned = False", "                        # End of canned cycle\n                        canned = False\n\n                    case \"G91\":\n                        relative = True\n                        print(\"Relative mode on\")\n                    case \"G90\":\n                        relative = False\n                        print(\"Relative mode off\")\n", "                        print(\"Relative mode off\")\n\n                    case \"G98\":\n                        # Canned cycle mode, probably not relevant\n                        canned_r = False\n                    case \"G99\":\n                        canned_r = True\n\n                    case \"G54\":\n                        pass", "                    case \"G54\":\n                        pass\n\n                    case _:\n                        if command.Name.startswith(\"(\"):\n                            continue\n                        if command.Name.startswith(\"M\"):\n                            continue\n                        print(\"Unknown gcode\", command.Name)\n    return visual_commands", "                        print(\"Unknown gcode\", command.Name)\n    return visual_commands\n\n\ndef visual_commands_to_ais(\n    visual_commands: list[VisualCommand], inverse_trsf: Optional[gp_Trsf] = None\n):\n    if len(visual_commands) < 2:\n        return\n", "        return\n\n    group = AIS_MultipleConnectedInteractive()\n    if inverse_trsf:\n        group.SetLocalTransformation(inverse_trsf)\n\n    for start, end in pairwise(visual_commands):\n        shape = end.to_ais(start)\n        if shape:\n            group.Connect(shape)", "        if shape:\n            group.Connect(shape)\n\n    # UnsetSelectionMode?\n    # Color?\n    return group\n\n\ndef visual_commands_to_edges(\n    visual_commands: list[VisualCommand], inverse_trsf: Optional[gp_Trsf] = None", "def visual_commands_to_edges(\n    visual_commands: list[VisualCommand], inverse_trsf: Optional[gp_Trsf] = None\n) -> list[tuple[str, TopoDS_Compound]]:\n    if len(visual_commands) < 2:\n        return []\n\n    def to_transformed_compound(edges, inverse_trsf: Optional[gp_Trsf]):\n        compound = TopoDS_Compound()\n        builder = TopoDS_Builder()\n        builder.MakeCompound(compound)", "        builder = TopoDS_Builder()\n        builder.MakeCompound(compound)\n\n        for edge in edges:\n            builder.Add(compound, edge)\n        if inverse_trsf:\n            return transform_shape(compound, inverse_trsf)\n        return compound\n\n    color_edge_map = defaultdict(list)", "\n    color_edge_map = defaultdict(list)\n    for start, end in pairwise(visual_commands):\n        edge_color_pair = end.to_edge(start)\n        if edge_color_pair:\n            edge, color_key = end.to_edge(start)\n            color_edge_map[color_key].append(edge)\n\n    color_compound_map = {\n        color: to_transformed_compound(edges, inverse_trsf)", "    color_compound_map = {\n        color: to_transformed_compound(edges, inverse_trsf)\n        for color, edges in color_edge_map.items()\n    }\n    return list(color_compound_map.items())\n\n\ndef add_command(\n    visual_commands: list[VisualCommand], cls: type[VisualCommand], **params\n):", "    visual_commands: list[VisualCommand], cls: type[VisualCommand], **params\n):\n    try:\n        cmd = cls(**params)\n        visual_commands.append(cmd)\n    except TypeError as ex:\n        print(\"Bonk\", ex)\n    return params\n", ""]}
{"filename": "src/ocp_freecad_cam/common.py", "chunked_list": ["from typing import TYPE_CHECKING, Literal, TypeAlias, Union\n\nif TYPE_CHECKING:\n    import build123d as b3d\n    import cadquery as cq\n\nFaceSource: TypeAlias = Union[\n    \"cq.Workplane\", \"cq.Face\", list[\"cq.Face\"], \"b3d.Face\", list[\"b3d.Face\"]\n]\nPlaneSource: TypeAlias = Union[", "]\nPlaneSource: TypeAlias = Union[\n    \"cq.Workplane\", \"cq.Plane\", \"cq.Face\", \"b3d.Plane\", \"b3d.Face\"\n]\nPlane: TypeAlias = Union[\"cq.Plane\", \"b3d.Plane\"]\n\n\nPostProcessor: TypeAlias = Literal[\n    \"KineticNCBeamicon2\",\n    \"centroid\",", "    \"KineticNCBeamicon2\",\n    \"centroid\",\n    \"comparams\",\n    \"dxf\",\n    \"dynapath\",\n    \"fablin\",\n    \"fangling\",\n    \"fanuc\",\n    \"grbl\",\n    \"heidenhain\",", "    \"grbl\",\n    \"heidenhain\",\n    \"jtech\",\n    \"linuxcnc\",\n    \"mach3_mach4\",\n    \"marlin\",\n    \"nccad\",\n    \"opensbp\",\n    \"philips\",\n    \"refactored_centroid\",", "    \"philips\",\n    \"refactored_centroid\",\n    \"refactored_grbl\",\n    \"refactored_linuxcnc\",\n    \"refactored_mach3_mach4\",\n    \"refactored_test\",\n    \"rml\",\n    \"rrf\",\n    \"smoothie\",\n    \"uccnc\",", "    \"smoothie\",\n    \"uccnc\",\n]\n"]}
{"filename": "src/ocp_freecad_cam/fc_impl.py", "chunked_list": ["\"\"\"\nOperation abstractions that interface directly with FreeCAD API\n\nDeveloper notes:\n- Setting Operation.Base resets some (?) properties\n- Pocket 3D appears to be buggy, https://github.com/FreeCAD/FreeCAD/issues/6815 possibly related\n\n\n\"\"\"\nimport tempfile", "\"\"\"\nimport tempfile\nfrom abc import ABC\nfrom copy import copy\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING, Literal, Optional\n\nimport FreeCAD\nimport Part\nimport Path.Base.SetupSheet as PathSetupSheet", "import Part\nimport Path.Base.SetupSheet as PathSetupSheet\nimport Path.Base.Util as PathUtil\nfrom OCP.gp import gp_Pln\nfrom OCP.TopoDS import TopoDS_Compound\nfrom Path.Dressup import Boundary\nfrom Path.Main import Job as FCJob\nfrom Path.Main import Stock as FCStock\nfrom Path.Op import (\n    Adaptive,", "from Path.Op import (\n    Adaptive,\n    Deburr,\n    Drilling,\n    Engrave,\n    Helix,\n    MillFace,\n    PocketShape,\n    Profile,\n    Surface,", "    Profile,\n    Surface,\n)\nfrom Path.Op import Vcarve as FCVCarve\nfrom Path.Op import Waterline\nfrom Path.Post.Command import buildPostList\nfrom Path.Post.Processor import PostProcessor as FCPostProcessor\n\nfrom ocp_freecad_cam.api_util import (\n    AutoUnitKey,", "from ocp_freecad_cam.api_util import (\n    AutoUnitKey,\n    CompoundData,\n    ParamMapping,\n    apply_params,\n    map_params,\n    scale_shape,\n    shape_to_brep,\n    transform_shape,\n)", "    transform_shape,\n)\nfrom ocp_freecad_cam.common import PostProcessor\nfrom ocp_freecad_cam.fc_impl_util import calculate_transforms\nfrom ocp_freecad_cam.visualizer import visualize_fc_job\n\nif TYPE_CHECKING:\n    from api import Job  # noqa\n\n\nclass JobImpl:\n    _job_param_mapping = {\"geometry_tolerance\": \"GeometryTolerance\"}\n    _setup_sheet_param_mapping = {\n        \"coolant\": \"CoolantMode\",\n        \"final_depth_expression\": \"FinalDepthExpression\",\n        \"start_depth_expression\": \"StartDepthExpression\",\n        \"step_down_expression\": \"StepDownExpression\",\n        \"clearance_height_expression\": \"ClearanceHeightExpression\",\n        \"clearance_height_offset\": AutoUnitKey(\"ClearanceHeightOffset\"),\n        \"safe_height_expression\": \"SafeHeightExpression\",\n        \"safe_height_offset\": AutoUnitKey(\"SafeHeightOffset\"),\n    }\n\n    def __init__(\n        self,\n        *,\n        top: gp_Pln,\n        model: TopoDS_Compound,\n        post_processor: Optional[PostProcessor],\n        units: Literal[\"metric\", \"imperial\"],\n        geometry_tolerance,\n        coolant,\n        final_depth_expression,\n        start_depth_expression,\n        step_down_expression,\n        clearance_height_expression,\n        clearance_height_offset,\n        safe_height_expression,\n        safe_height_offset,\n        stock,\n    ):\n        self.top = top\n        self.forward, self.backward = calculate_transforms(top)\n        self.units = units\n\n        self.model = model\n        transformed_job_model = transform_shape(model, self.forward)\n        if sf := self.scale_factor:\n            transformed_job_model = scale_shape(transformed_job_model, sf)\n\n        self.model_brep = shape_to_brep(transformed_job_model)\n\n        self.post_processor = post_processor\n\n        self.job_params = map_params(\n            self._job_param_mapping, geometry_tolerance=geometry_tolerance\n        )\n\n        self.setup_sheet_params = map_params(\n            self._setup_sheet_param_mapping,\n            coolant=coolant,\n            final_depth_expression=final_depth_expression,\n            start_depth_expression=start_depth_expression,\n            step_down_expression=step_down_expression,\n            clearance_height_expression=clearance_height_expression,\n            clearance_height_offset=clearance_height_offset,\n            safe_height_expression=safe_height_expression,\n            safe_height_offset=safe_height_offset,\n        )\n\n        self.stock = stock\n        self.doc = None\n        self.ops = []\n\n    @property\n    def scale_factor(self):\n        if self.units == \"metric\":\n            return None\n        elif self.units == \"imperial\":\n            return 25.4\n        raise ValueError(f\"Unknown unit: ({self.units})\")\n\n    def _set_active(self):\n        FreeCAD.setActiveDocument(self.doc.Name)\n\n    def _build(self, rebuild=False):\n        if self.doc:\n            if not rebuild:\n                return\n            FreeCAD.closeDocument(self.doc)\n\n        self.doc = FreeCAD.newDocument(\"ocp_freecad_cam\")\n        self._set_active()\n        fc_compound = Part.Compound()\n        fc_compound.importBrepFromString(self.model_brep)\n        feature = self.doc.addObject(\"Part::Feature\", f\"root_brep\")\n        feature.Shape = fc_compound\n\n        fc_job = FCJob.Create(\"Job\", [feature])\n        self.fc_job = fc_job\n\n        apply_params(self.fc_job, self.job_params, self.units)\n        setup_sheet = self.fc_job.SetupSheet\n        apply_params(setup_sheet, self.setup_sheet_params, self.units)\n\n        if self.stock:\n            self.stock.create_stock(self)\n\n        # Remove default tools as we'll create our own later\n        # Necessary also because of  buggy FX implementation\n        tools = [tool for tool in self.fc_job.Tools.Group]\n        for tool in tools:\n            self.fc_job.Tools.removeObject(tool)\n        if self.post_processor:\n            fc_job.PostProcessor = self.post_processor\n\n        for op in self.ops:\n            op.execute(self)\n\n        self.doc.recompute()\n\n    def save_fcstd(self, filename, rebuild=False):\n        self._build(rebuild)\n        self.doc.saveAs(filename)\n\n    def to_gcode(self, rebuild=False):\n        if self.post_processor is None:\n            raise ValueError(\n                \"No postprocessor set - set Job postprocessor to a valid value\"\n            )\n        self._build(rebuild)\n        postlist = buildPostList(self.fc_job)\n        processor = FCPostProcessor.load(self.fc_job.PostProcessor)\n\n        for idx, section in enumerate(postlist):\n            name, sublist = section\n            with tempfile.NamedTemporaryFile() as tmp_file:\n                options = [\"--no-show-editor\"]\n                if self.units == \"imperial\":\n                    options.append(\"--inches\")\n\n                gcode = processor.export(sublist, tmp_file.name, \" \".join(options))\n                return gcode\n\n    def show(self, show_object=None, rebuild=False):\n        self._build(rebuild)\n        return visualize_fc_job(self.fc_job, self.backward, show_object=show_object)\n\n    def copy(self, ops):\n        job_impl = copy(self)\n        job_impl.doc = None\n        job_impl.ops = ops\n        return job_impl", "\n\nclass JobImpl:\n    _job_param_mapping = {\"geometry_tolerance\": \"GeometryTolerance\"}\n    _setup_sheet_param_mapping = {\n        \"coolant\": \"CoolantMode\",\n        \"final_depth_expression\": \"FinalDepthExpression\",\n        \"start_depth_expression\": \"StartDepthExpression\",\n        \"step_down_expression\": \"StepDownExpression\",\n        \"clearance_height_expression\": \"ClearanceHeightExpression\",\n        \"clearance_height_offset\": AutoUnitKey(\"ClearanceHeightOffset\"),\n        \"safe_height_expression\": \"SafeHeightExpression\",\n        \"safe_height_offset\": AutoUnitKey(\"SafeHeightOffset\"),\n    }\n\n    def __init__(\n        self,\n        *,\n        top: gp_Pln,\n        model: TopoDS_Compound,\n        post_processor: Optional[PostProcessor],\n        units: Literal[\"metric\", \"imperial\"],\n        geometry_tolerance,\n        coolant,\n        final_depth_expression,\n        start_depth_expression,\n        step_down_expression,\n        clearance_height_expression,\n        clearance_height_offset,\n        safe_height_expression,\n        safe_height_offset,\n        stock,\n    ):\n        self.top = top\n        self.forward, self.backward = calculate_transforms(top)\n        self.units = units\n\n        self.model = model\n        transformed_job_model = transform_shape(model, self.forward)\n        if sf := self.scale_factor:\n            transformed_job_model = scale_shape(transformed_job_model, sf)\n\n        self.model_brep = shape_to_brep(transformed_job_model)\n\n        self.post_processor = post_processor\n\n        self.job_params = map_params(\n            self._job_param_mapping, geometry_tolerance=geometry_tolerance\n        )\n\n        self.setup_sheet_params = map_params(\n            self._setup_sheet_param_mapping,\n            coolant=coolant,\n            final_depth_expression=final_depth_expression,\n            start_depth_expression=start_depth_expression,\n            step_down_expression=step_down_expression,\n            clearance_height_expression=clearance_height_expression,\n            clearance_height_offset=clearance_height_offset,\n            safe_height_expression=safe_height_expression,\n            safe_height_offset=safe_height_offset,\n        )\n\n        self.stock = stock\n        self.doc = None\n        self.ops = []\n\n    @property\n    def scale_factor(self):\n        if self.units == \"metric\":\n            return None\n        elif self.units == \"imperial\":\n            return 25.4\n        raise ValueError(f\"Unknown unit: ({self.units})\")\n\n    def _set_active(self):\n        FreeCAD.setActiveDocument(self.doc.Name)\n\n    def _build(self, rebuild=False):\n        if self.doc:\n            if not rebuild:\n                return\n            FreeCAD.closeDocument(self.doc)\n\n        self.doc = FreeCAD.newDocument(\"ocp_freecad_cam\")\n        self._set_active()\n        fc_compound = Part.Compound()\n        fc_compound.importBrepFromString(self.model_brep)\n        feature = self.doc.addObject(\"Part::Feature\", f\"root_brep\")\n        feature.Shape = fc_compound\n\n        fc_job = FCJob.Create(\"Job\", [feature])\n        self.fc_job = fc_job\n\n        apply_params(self.fc_job, self.job_params, self.units)\n        setup_sheet = self.fc_job.SetupSheet\n        apply_params(setup_sheet, self.setup_sheet_params, self.units)\n\n        if self.stock:\n            self.stock.create_stock(self)\n\n        # Remove default tools as we'll create our own later\n        # Necessary also because of  buggy FX implementation\n        tools = [tool for tool in self.fc_job.Tools.Group]\n        for tool in tools:\n            self.fc_job.Tools.removeObject(tool)\n        if self.post_processor:\n            fc_job.PostProcessor = self.post_processor\n\n        for op in self.ops:\n            op.execute(self)\n\n        self.doc.recompute()\n\n    def save_fcstd(self, filename, rebuild=False):\n        self._build(rebuild)\n        self.doc.saveAs(filename)\n\n    def to_gcode(self, rebuild=False):\n        if self.post_processor is None:\n            raise ValueError(\n                \"No postprocessor set - set Job postprocessor to a valid value\"\n            )\n        self._build(rebuild)\n        postlist = buildPostList(self.fc_job)\n        processor = FCPostProcessor.load(self.fc_job.PostProcessor)\n\n        for idx, section in enumerate(postlist):\n            name, sublist = section\n            with tempfile.NamedTemporaryFile() as tmp_file:\n                options = [\"--no-show-editor\"]\n                if self.units == \"imperial\":\n                    options.append(\"--inches\")\n\n                gcode = processor.export(sublist, tmp_file.name, \" \".join(options))\n                return gcode\n\n    def show(self, show_object=None, rebuild=False):\n        self._build(rebuild)\n        return visualize_fc_job(self.fc_job, self.backward, show_object=show_object)\n\n    def copy(self, ops):\n        job_impl = copy(self)\n        job_impl.doc = None\n        job_impl.ops = ops\n        return job_impl", "\n\nclass Op(ABC):\n    fc_module: ModuleType\n    params: ParamMapping\n\n    __param_mapping = {\n        \"clearance_height\": \"ClearanceHeight\",\n        \"final_depth\": \"FinalDepth\",\n        \"safe_height\": \"SafeHeight\",\n        \"start_depth\": \"StartDepth\",\n        \"step_down\": \"StepDown\",\n        \"coolant\": \"CoolantMode\",\n    }\n\n    def __init__(\n        self,\n        *,\n        tool,\n        compound_data: CompoundData,\n        name=None,\n        # Expressions\n        clearance_height=None,\n        final_depth=None,\n        safe_height=None,\n        start_depth=None,\n        step_down=None,\n        coolant=None,\n        dressups: Optional[list[\"Dressup\"]] = None,\n    ):\n        self.name = name\n        self.tool = tool\n        self.compound_data = compound_data\n\n        self.dressups = dressups or []\n        self.__params = map_params(\n            self.__param_mapping,\n            clearance_height=clearance_height,\n            final_depth=final_depth,\n            safe_height=safe_height,\n            start_depth=start_depth,\n            step_down=step_down,\n            coolant=coolant,\n        )\n\n    def n(self, job_impl: JobImpl):\n        same_ops = [op for op in job_impl.ops if isinstance(op, self.__class__)]\n        return same_ops.index(self) + 1\n\n    def execute(self, job_impl: JobImpl):\n        base_features = self.create_base_features(job_impl)\n\n        op_tool_controller = self.tool.tool_controller(\n            job_impl.fc_job.Proxy, job_impl.units\n        )\n        fc_op = self.create_operation(job_impl, base_features)\n        apply_params(fc_op, self.__params, job_impl.units)\n        fc_op.ToolController = op_tool_controller\n        fc_op.Proxy.execute(fc_op)\n        self.create_dressups(job_impl, fc_op)\n\n    def create_base_features(self, job_impl: JobImpl):\n        doc = job_impl.doc\n        compound_brep = self.compound_data.to_transformed_brep(\n            job_impl.forward, job_impl.scale_factor\n        )\n        if compound_brep is None:\n            return []\n\n        fc_compound = Part.Compound()\n        fc_compound.importBrepFromString(compound_brep)\n        feature = doc.addObject(\"Part::Feature\", f\"op_brep_{self.n(job_impl)}\")\n        feature.Shape = fc_compound\n\n        base_features = []\n        sub_selectors = []\n\n        for i in range(1, self.compound_data.face_count + 1):\n            sub_selectors.append(f\"Face{i}\")\n        for i in range(1, self.compound_data.edge_count + 1):\n            sub_selectors.append(f\"Edge{i}\")\n        for i in range(1, self.compound_data.vertex_count + 1):\n            sub_selectors.append(f\"Vertex{i}\")\n\n        base_features.append((feature, tuple(sub_selectors)))\n        return base_features\n\n    def create_operation(self, job_impl: JobImpl, base_features):\n        name = self.label(job_impl)\n        PathSetupSheet.RegisterOperation(\n            name, self.fc_module.Create, self.fc_module.SetupProperties\n        )\n        fc_op = self.fc_module.Create(name)\n        fc_op.Base = base_features\n        apply_params(fc_op, self.params, job_impl.units)\n        return fc_op\n\n    def create_dressups(self, job_impl, fc_op):\n        base = fc_op\n        for dressup in self.dressups:\n            fc_dressup = dressup.create(job_impl, base)\n            for k, v in dressup.params:\n                PathUtil.setProperty(fc_dressup, k, v)\n            fc_dressup.Proxy.execute(fc_dressup)\n            base = fc_dressup\n\n    def label(self, job_impl: JobImpl):\n        if self.name:\n            return self.name\n        return f\"{self.__class__.__name__}_{self.n(job_impl)}\"", "\n\nclass ProfileOp(Op):\n    fc_module = Profile\n    param_mapping = {\n        \"side\": (\n            \"Side\",\n            {\n                \"in\": \"Inside\",\n                \"out\": \"Outside\",\n            },\n        ),\n        \"direction\": (\n            \"Direction\",\n            {\n                \"cw\": \"CW\",\n                \"ccw\": \"CCW\",\n            },\n        ),\n        \"handle_multiple_features\": (\n            \"HandleMultipleFeatures\",\n            {\n                \"collectively\": \"Collectively\",\n                \"individually\": \"Individually\",\n            },\n        ),\n        \"offset_extra\": AutoUnitKey(\"OffsetExtra\"),\n        \"use_comp\": \"UseComp\",\n        \"process_circles\": \"processCircles\",\n        \"process_holes\": \"processHoles\",\n        \"process_perimeter\": \"processPerimeter\",\n    }\n\n    def __init__(\n        self,\n        *args,\n        side: Literal[\"in\", \"out\"],\n        direction: Literal[\"cw\", \"ccw\"],\n        handle_multiple_features: Literal[\"collectively\", \"individually\"],\n        offset_extra: float,\n        use_comp: bool,\n        process_circles: bool,\n        process_holes: bool,\n        process_perimeter: bool,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.params = map_params(\n            self.param_mapping,\n            side=side,\n            direction=direction,\n            handle_multiple_features=handle_multiple_features,\n            offset_extra=offset_extra,\n            use_comp=use_comp,\n            process_circles=process_circles,\n            process_holes=process_holes,\n            process_perimeter=process_perimeter,\n        )", "\n\nclass FaceOp(Op):\n    fc_module = MillFace\n    param_mapping = {\n        \"finish_depth\": AutoUnitKey(\"FinishDepth\"),\n        \"boundary\": (\n            \"BoundaryShape\",\n            {\n                \"boundbox\": \"Boundbox\",\n                \"face\": \"Face Region\",\n                \"perimeter\": \"Perimeter\",\n                \"stock\": \"Stock\",\n            },\n        ),\n        \"clear_edges\": \"ClearEdges\",\n        \"exclude_raised\": \"ExcludeRaisedAreas\",\n        \"pattern\": (\n            \"OffsetPattern\",\n            {\n                \"zigzag\": \"ZigZag\",\n                \"offset\": \"Offset\",\n                \"zigzag_offset\": \"ZigZagOffset\",\n                \"line\": \"Line\",\n                \"grid\": \"Grid,\",\n            },\n        ),\n    }\n\n    def __init__(\n        self,\n        *args,\n        finish_depth: float,\n        boundary: Literal[\"boundbox\", \"face\", \"perimeter\", \"stock\"],\n        clear_edges: bool,\n        exclude_raised: bool,\n        pattern: Literal[\"zigzag\", \"offset\", \"zigzag_offset\", \"line\", \"grid\"],\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.params = map_params(\n            self.param_mapping,\n            finish_depth=finish_depth,\n            boundary=boundary,\n            clear_edges=clear_edges,\n            exclude_raised=exclude_raised,\n            pattern=pattern,\n        )", "\n\nclass PocketOp(Op):\n    fc_module = PocketShape\n    param_mapping = {\n        \"finish_depth\": AutoUnitKey(\"FinishDepth\"),\n        \"pattern\": (\n            \"OffsetPattern\",\n            {\n                \"zigzag\": \"ZigZag\",\n                \"offset\": \"Offset\",\n                \"zigzag_offset\": \"ZigZagOffset\",\n                \"line\": \"Line\",\n                \"grid\": \"Grid,\",\n            },\n        ),\n        \"cut_mode\": (\"CutMode\", {\"climb\": \"Climb\", \"conventional\": \"Conventional\"}),\n        \"extra_offset\": AutoUnitKey(\"ExtraOffset\"),\n        \"keep_tool_down\": \"KeepToolDown\",\n        \"min_travel\": \"MinTravel\",\n        \"pocket_last_stepover\": \"PocketLastStepOver\",\n        \"start_at\": (\n            \"StartAt\",\n            {\n                \"center\": \"Center\",\n                \"edge\": \"Edge\",\n            },\n        ),\n        \"step_over\": \"StepOver\",\n        \"use_outline\": \"UseOutline\",\n        \"zigzag_angle\": \"ZigZagAngle\",\n    }\n\n    def __init__(\n        self,\n        *args,\n        finish_depth: float,\n        pattern: Literal[\"zigzag\", \"offset\", \"zigzag_offset\", \"line\", \"grid\"],\n        cut_mode: Literal[\"climb\", \"conventional\"],\n        extra_offset: float,\n        keep_tool_down: bool,\n        min_travel: bool,\n        pocket_last_stepover: float,\n        start_at: Literal[\"center\", \"edge\"],\n        step_over: float,\n        use_outline: bool,\n        zigzag_angle: float,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.params = map_params(\n            self.param_mapping,\n            finish_depth=finish_depth,\n            pattern=pattern,\n            cut_mode=cut_mode,\n            extra_offset=extra_offset,\n            keep_tool_down=keep_tool_down,\n            min_travel=min_travel,\n            pocket_last_stepover=pocket_last_stepover,\n            start_at=start_at,\n            step_over=step_over,\n            use_outline=use_outline,\n            zigzag_angle=zigzag_angle,\n        )", "\n\nclass DrillOp(Op):\n    fc_module = Drilling\n\n    param_mapping = {\n        \"dwell_time\": \"DwellTime\",\n        \"dwell_enabled\": \"DwellEnabled\",\n        \"extra_offset\": (\n            \"ExtraOffset\",\n            {\"none\": \"None\", \"1x\": \"Drill Tip\", \"2x\": \"2x Drill Tip\"},\n        ),\n        \"keep_tool_down\": \"KeepToolDown\",\n        \"peck_depth\": AutoUnitKey(\"PeckDepth\"),\n        \"peck_enabled\": \"PeckEnabled\",\n        \"retract_height\": \"RetractHeight\",\n        \"chip_break_enabled\": \"chipBreakEnabled\",\n    }\n\n    def __init__(\n        self,\n        *args,\n        dwell_time: Optional[float],\n        extra_offset: Optional[float],\n        peck_depth: Optional[float],\n        keep_tool_down: Optional[bool],\n        retract_height: Optional[bool],\n        chip_break_enabled: Optional[bool],\n        **kwargs,\n    ):\n        \"\"\"\n        Attributes in FreeCAD but not here:\n        * RetractMode is overriden by KeepToolDown in FC code\n        * AddTipLength is not used anywhere?\n        \"\"\"\n\n        super().__init__(*args, **kwargs)\n        dwell_enabled = None if dwell_time is None else dwell_time > 0\n        peck_enabled = None if peck_depth is None else peck_depth > 0\n\n        self.params = map_params(\n            self.param_mapping,\n            dwell_time=dwell_time,\n            dwell_enabled=dwell_enabled,\n            extra_offset=extra_offset,\n            keep_tool_down=keep_tool_down,\n            peck_depth=peck_depth,\n            peck_enabled=peck_enabled,\n            retract_height=retract_height,\n            chip_break_enabled=chip_break_enabled,\n        )", "\n\nclass HelixOp(Op):\n    fc_module = Helix\n    param_mapping = {\n        \"direction\": (\"Direction\", {\"cw\": \"CW\", \"ccw\": \"CCW\"}),\n        \"offset_extra\": AutoUnitKey(\"OffsetExtra\"),\n        \"start_radius\": \"StartRadius\",\n        \"start_side\": (\"StartSide\", {\"out\": \"Outside\", \"in\": \"Inside\"}),\n        \"step_over\": \"StepOver\",\n    }\n\n    def __init__(\n        self,\n        *args,\n        direction: Optional[Literal[\"cw\", \"ccw\"]],\n        offset_extra: Optional[float],\n        start_radius: Optional[float],\n        start_side: Optional[Literal[\"out\", \"in\"]],\n        step_over: Optional[float],\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.params = map_params(\n            self.param_mapping,\n            direction=direction,\n            offset_extra=offset_extra,\n            start_radius=start_radius,\n            start_side=start_side,\n            step_over=step_over,\n        )", "\n\nclass EngraveOp(Op):\n    fc_module = Engrave\n    param_mapping = {\"start_vertex\": \"StartVertex\"}\n\n    def __init__(self, *args, start_vertex: int, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.params = map_params(self.param_mapping, start_vertex=start_vertex)\n", "\n\nclass DeburrOp(Op):\n    fc_module = Deburr\n    param_mapping = {\n        \"width\": AutoUnitKey(\"Width\"),\n        \"extra_depth\": AutoUnitKey(\"ExtraDepth\"),\n        \"direction\": (\"Direction\", {\"cw\": \"CW\", \"ccw\": \"CCW\"}),\n        \"entry_point\": \"EntryPoint\",\n    }\n\n    def __init__(\n        self,\n        *args,\n        width: float,\n        extra_depth: float,\n        direction: Literal[\"cw\", \"ccw\"],\n        entry_point: int,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.params = map_params(\n            self.param_mapping,\n            width=width,\n            extra_depth=extra_depth,\n            direction=direction,\n            entry_point=entry_point,\n        )", "\n\nclass VCarveOp(Op):\n    fc_module = FCVCarve\n    param_mapping = {\n        \"discretize\": \"Discretize\",\n        \"colinear\": \"Colinear\",\n    }\n\n    def __init__(self, *args, discretize: float, colinear: float, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.params = map_params(\n            self.param_mapping, discretize=discretize, colinear=colinear\n        )", "\n\nclass Surface3DOp(Op):\n    fc_module = Surface\n    param_mapping = {\n        \"bound_box\": (\"BoundBox\", {\"base_bound_box\": \"BaseBoundBox\", \"stock\": \"Stock\"}),\n        \"cut_mode\": (\"CutMode\", {\"climb\": \"Climb\", \"conventional\": \"Conventional\"}),\n        \"cut_pattern\": (\n            \"CutPattern\",\n            {\n                \"line\": \"Line\",\n                \"circular\": \"Circular\",\n                \"circular_zig_zag\": \"CircularZigZag\",\n                \"offset\": \"Offset\",\n                \"spiral\": \"Spiral\",\n                \"zigzag\": \"ZigZag\",\n            },\n        ),\n        \"cut_pattern_angle\": \"CutPatternAngle\",\n        \"cut_pattern_reversed\": \"CutPatternReversed\",\n        \"depth_offset\": AutoUnitKey(\"DepthOffset\"),\n        \"layer_mode\": (\"LayerMode\", {\"single\": \"Single-pass\", \"multi\": \"Multi-pass\"}),\n        \"profile_edges\": (\n            \"ProfileEdges\",\n            {\"none\": \"None\", \"only\": \"Only\", \"first\": \"First\", \"last\": \"Last\"},\n        ),\n        \"sample_interval\": \"SampleInterval\",\n        \"step_over\": \"StepOver\",\n        \"angular_deflection\": AutoUnitKey(\"AngularDeflection\"),\n        \"linear_deflection\": AutoUnitKey(\"LinearDeflection\"),\n        \"circular_use_g2g3\": \"CircularUseG2G3\",\n        \"gap_threshold\": AutoUnitKey(\"GapThreshold\"),\n        \"optimize_linear_paths\": \"OptimizeLinearPaths\",\n        \"optimize_step_over_transitions\": \"OptimizeStepOverTransitions\",\n        \"avoid_last_x_faces\": \"AvoidLastX_Faces\",\n        \"avoid_last_x_internal_features\": \"AvoidLastX_InternalFeatures\",\n        \"boundary_adjustment\": AutoUnitKey(\"BoundaryAdjustment\"),\n        \"boundary_enforcement\": \"BoundaryEnforcement\",\n        \"multiple_features\": (\n            \"HandleMultipleFeatures\",\n            {\"collectively\": \"Collectively\", \"individually\": \"Individually\"},\n        ),\n        \"internal_features_adjustment\": AutoUnitKey(\"InternalFeaturesAdjustment\"),\n        \"internal_features_cut\": \"InternalFeaturesCut\",\n        \"start_point\": AutoUnitKey(\"StartPoint\"),\n        \"scan_type\": (\"ScanType\", {\"planar\": \"Planar\", \"rotational\": \"Rotational\"}),\n    }\n\n    def __init__(\n        self,\n        *args,\n        bound_box: Literal[\"base_bound_box\", \"stock\"],\n        cut_mode: Literal[\"climb\", \"conventional\"],\n        cut_pattern: Literal[\n            \"line\", \"circular\", \"circular_zig_zag\", \"offset\", \"spiral\", \"zigzag\"\n        ],\n        cut_pattern_angle: float,\n        cut_pattern_reversed: bool,\n        depth_offset: float,\n        layer_mode: Literal[\"single\", \"multi\"],\n        profile_edges: Literal[\"none\", \"only\", \"first\", \"last\"],\n        sample_interval: float | str,\n        step_over: float,\n        angular_deflection: float | str,\n        linear_deflection: float | str,\n        circular_use_g2g3: bool,\n        gap_threshold: float | str,\n        optimize_linear_paths: bool,\n        optimize_step_over_transitions: bool,\n        avoid_last_x_faces: int,\n        avoid_last_x_internal_features: bool,\n        boundary_adjustment: float | str,\n        boundary_enforcement: bool,\n        multiple_features: Literal[\"collectively\", \"individually\"],\n        internal_features_adjustment: float | str,\n        internal_features_cut: bool,\n        start_point: tuple[float | str, float | str, float | str],\n        scan_type: Literal[\"planar\", \"rotational\"],\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.params = map_params(\n            self.param_mapping,\n            bound_box=bound_box,\n            cut_mode=cut_mode,\n            cut_pattern=cut_pattern,\n            cut_pattern_angle=cut_pattern_angle,\n            cut_pattern_reversed=cut_pattern_reversed,\n            depth_offset=depth_offset,\n            layer_mode=layer_mode,\n            profile_edges=profile_edges,\n            sample_interval=sample_interval,\n            step_over=step_over,\n            angular_deflection=angular_deflection,\n            linear_deflection=linear_deflection,\n            circular_use_g2g3=circular_use_g2g3,\n            gap_threshold=gap_threshold,\n            optimize_linear_paths=optimize_linear_paths,\n            optimize_step_over_transitions=optimize_step_over_transitions,\n            avoid_last_x_faces=avoid_last_x_faces,\n            avoid_last_x_internal_features=avoid_last_x_internal_features,\n            boundary_adjustment=boundary_adjustment,\n            boundary_enforcement=boundary_enforcement,\n            multiple_features=multiple_features,\n            internal_features_adjustment=internal_features_adjustment,\n            internal_features_cut=internal_features_cut,\n            start_point=start_point,\n            scan_type=scan_type,\n        )", "\n\nclass WaterlineOp(Op):\n    fc_module = Waterline\n    param_mapping = {\n        \"algorithm\": (\n            \"Algorithm\",\n            {\"ocl\": \"OCL Dropcutter\", \"experimental\": \"Experimental\"},\n        ),\n        \"bound_box\": (\"BoundBox\", {\"base\": \"BaseBoundBox\", \"stock\": \"Stock\"}),\n        \"cut_mode\": (\"CutMode\", {\"climb\": \"Climb\", \"conventional\": \"Conventional\"}),\n        \"depth_offset\": AutoUnitKey(\"DepthOffset\"),\n        \"layer_mode\": (\"LayerMode\", {\"single\": \"Single-pass\", \"multi\": \"Multi-pass\"}),\n        \"sample_interval\": AutoUnitKey(\"SampleInterval\"),\n        \"angular_deflection\": AutoUnitKey(\"AngularDeflection\"),\n        \"linear_deflection\": AutoUnitKey(\"LinearDeflection\"),\n    }\n\n    def __init__(\n        self,\n        *args,\n        algorithm: Literal[\"ocl\", \"experimental\"],\n        bound_box: Literal[\"base\", \"stock\"],\n        cut_mode: Literal[\"climb\", \"conventional\"],\n        depth_offset: float | str,\n        layer_mode: Literal[\"single\", \"multi\"],\n        sample_interval: float | str,\n        angular_deflection: float | str,\n        linear_deflection: float | str,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.params = map_params(\n            self.param_mapping,\n            algorithm=algorithm,\n            bound_box=bound_box,\n            cut_mode=cut_mode,\n            depth_offset=depth_offset,\n            layer_mode=layer_mode,\n            sample_interval=sample_interval,\n            angular_deflection=angular_deflection,\n            linear_deflection=linear_deflection,\n        )", "\n\nclass AdaptiveOp(Op):\n    fc_module = Adaptive\n    param_mapping = {\n        \"finishing_profile\": \"FinishingProfile\",\n        \"force_inside_cut\": \"ForceInsideCut\",\n        \"helix_angle\": \"HelixAngle\",\n        \"helix_cone_angle\": \"HelixConeAngle\",\n        \"helix_diameter_limit\": AutoUnitKey(\"HelixDiameterLimit\"),\n        \"keep_tool_down_ratio\": AutoUnitKey(\"KeepToolDownRatio\"),\n        \"lift_distance\": AutoUnitKey(\"LiftDistance\"),\n        \"operation_type\": (\n            \"OperationType\",\n            {\"clearing\": \"Clearing\", \"profiling\": \"Profiling\"},\n        ),\n        \"side\": (\"Side\", {\"in\": \"Inside\", \"out\": \"Outside\"}),\n        \"step_over\": \"StepOver\",\n        \"stock_to_leave\": AutoUnitKey(\"StockToLeave\"),\n        \"tolerance\": \"Tolerance\",\n        \"use_helix_arcs\": \"UseHelixArcs\",\n        \"use_outline\": \"UseOutline\",\n    }\n\n    def __init__(\n        self,\n        *args,\n        finishing_profile: bool,\n        force_inside_cut: bool,\n        helix_angle: float,\n        helix_cone_angle: float,\n        helix_diameter_limit: float | str,\n        keep_tool_down_ratio: float | str,\n        lift_distance: float | str,\n        operation_type: Literal[\"clearing\", \"profiling\"],\n        side: Literal[\"in\", \"out\"],\n        step_over: float,\n        stock_to_leave: float | str,\n        tolerance: float = 0,\n        use_helix_arcs: bool,\n        use_outline: bool,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.params = map_params(\n            self.param_mapping,\n            finishing_profile=finishing_profile,\n            force_inside_cut=force_inside_cut,\n            helix_angle=helix_angle,\n            helix_cone_angle=helix_cone_angle,\n            helix_diameter_limit=helix_diameter_limit,\n            keep_tool_down_ratio=keep_tool_down_ratio,\n            lift_distance=lift_distance,\n            operation_type=operation_type,\n            side=side,\n            step_over=step_over,\n            stock_to_leave=stock_to_leave,\n            tolerance=tolerance,\n            use_helix_arcs=use_helix_arcs,\n            use_outline=use_outline,\n        )", "\n\nclass Dressup:\n    factory = None\n    params = None\n\n    def create(self, job_impl, base):\n        return self.factory.Create(base)\n\n\nclass Boundary(Dressup):\n    factory = Boundary", "\n\nclass Boundary(Dressup):\n    factory = Boundary\n\n    # TODO\n\n\nclass StockBase(ABC):\n    def create_stock(self, fc_job: FCJob):\n        raise NotImplementedError", "class StockBase(ABC):\n    def create_stock(self, fc_job: FCJob):\n        raise NotImplementedError\n\n\nclass Stock(StockBase):\n    _param_mapping = {\n        \"xn\": AutoUnitKey(\"ExtXneg\"),\n        \"xp\": AutoUnitKey(\"ExtXpos\"),\n        \"yn\": AutoUnitKey(\"ExtYneg\"),\n        \"yp\": AutoUnitKey(\"ExtYpos\"),\n        \"zn\": AutoUnitKey(\"ExtZneg\"),\n        \"zp\": AutoUnitKey(\"ExtZpos\"),\n    }\n\n    def __init__(\n        self,\n        xn: float | str = None,\n        xp: float | str = None,\n        yn: float | str = None,\n        yp: float | str = None,\n        zn: float | str = None,\n        zp: float | str = None,\n    ):\n        \"\"\"\n        Simple extent based stock\n\n        :param xn: offset to X negative\n        :param xp: offset to X positive\n        :param yn: offset to Y negative\n        :param yp: offset to Y positive\n        :param zn: offset to Z negative\n        :param zp: offset to Z positive\n        \"\"\"\n        self.params = map_params(\n            self._param_mapping,\n            xn=xn,\n            xp=xp,\n            yn=yn,\n            yp=yp,\n            zn=zn,\n            zp=zp,\n        )\n        self.fc_stock = None\n\n    def create_stock(self, job_impl: JobImpl):\n        fc_job = job_impl.fc_job\n        job_impl.doc.removeObject(fc_job.Stock.Name)\n        fc_stock = FCStock.CreateFromBase(job_impl.fc_job)\n        apply_params(fc_stock, self.params, job_impl.units)\n        PathUtil.setProperty(job_impl.fc_job, \"Stock\", fc_stock)", ""]}
