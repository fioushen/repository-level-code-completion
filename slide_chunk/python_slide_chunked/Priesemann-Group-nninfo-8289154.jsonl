{"filename": "setup.py", "chunked_list": ["from setuptools import setup\n\nsetup(\n    name='nninfo',\n    packages=['nninfo'],\n    version='1.0',\n    description='Deep Neural Network Information Toolkit',\n    classifiers=[\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",", "        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Development Status :: 5 - Production/Stable\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Intended Audience :: Science/Research\",\n        \"Environment :: Console\",\n        \"Environment :: Other Environment\",\n        \"Topic :: Scientific/Engineering :: Bio-Informatics\",\n        \"Topic :: Scientific/Engineering :: Physics\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",", "        \"Topic :: Scientific/Engineering :: Physics\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n    ]\n)"]}
{"filename": "nninfo/experiment.py", "chunked_list": ["import os\nimport re\nfrom pathlib import Path\n\nimport numpy as np\nimport torch\nimport torch.utils.data\n\nimport nninfo\nfrom nninfo.data_set import DataSet", "import nninfo\nfrom nninfo.data_set import DataSet\nfrom nninfo.trainer import Trainer\nfrom nninfo.schedule import Schedule\nfrom nninfo.model.neural_network import NeuralNetwork, NeuronID, NoisyNeuralNetwork\nfrom nninfo.tasks.task_manager import TaskManager\nfrom nninfo.tester import Tester\nfrom nninfo.file_io import FileManager, CheckpointManager\n\n", "\n\nlog = nninfo.logger.get_logger(__name__)\n\nCONFIG_FILE_NAME = \"config.yaml\"\n\nclass Experiment:\n    \"\"\"\n    Manages the entire experiment, is directly in contact with the user script but also\n    the main components.\n    After connecting the components, user script should use preferably methods of this class.\n\n    1) is given an instance of TaskManager to feed data into the program and split the dataset\n       if necessary\n\n    2) is given an instance of NeuralNetwork in model.py that will be trained and tested on\n\n    3) is given an instance of Trainer that is responsible\n       for each chapter (predefined set of training epochs)\n       of the training process (gets data from TaskManager via dataset_name).\n\n    4) is given an instance of Tester that is called after each chunk of training is done\n       (gets data from TaskManager)\n\n    5) can be given an instance of Schedule. This makes automating the experiment easier.\n\n    6) creates an instance of CheckpointManager that stores the main experiment parameters\n       for loading afterwards. This can be used to\n       a) analyze the training afterwards\n       b) resume training from last or earlier chapters\n    \"\"\"\n\n    def __init__(self,\n                 experiment_id: str,\n                 network: NeuralNetwork,\n                 task: TaskManager,\n                 trainer: Trainer,\n                 tester: Tester,\n                 schedule: Schedule,\n                 _load: bool = False):\n        \"\"\"Creates a new Experiment instance from the given components.\n\n        Args:\n            experiment_id (str): Unique identifier for the experiment.\n            network (NeuralNetwork): NeuralNetwork instance.\n            task (TaskManager): TaskManager instance.\n            trainer (Trainer): Trainer instance.\n            tester (Tester): Tester instance.\n            schedule (Schedule): Schedule instance.\n            _load (bool, optional): Internal flag only. For loading an experiment, use Experiment.load().\n        \"\"\"\n\n        self._experiment_id = experiment_id\n        self._run_id = 0\n        self._experiment_dir = self._find_experiment_dir(experiment_id)\n\n        if not _load:\n\n            if os.path.exists(self._experiment_dir):\n                raise FileExistsError(f\"Experiment directory {self._experiment_dir} already exists.\"\n                                      \"Please choose a different experiment_id or use Experiment.load(experiment_id).\")\n\n            standard_dir_maker = FileManager(\n                \"../experiments/\", write=True\n            )\n            self._experiment_dir = standard_dir_maker.make_experiment_dir(\n                experiment_id, overwrite=False)\n\n        nninfo.logger.add_exp_file_handler(self._experiment_dir)\n        log.info(f\"Starting exp_{experiment_id}\")\n\n        # create checkpoint_manager that saves checkpoints to _experiment_dir for the entire experiment\n        self.checkpoint_manager = CheckpointManager(self._experiment_dir / \"checkpoints\")\n        self.checkpoint_manager.parent = self\n\n        self._set_components(network, task, trainer, tester, schedule)\n\n    @staticmethod\n    def _find_experiment_dir(experiment_id: str):\n        \"\"\"Finds the experiment directory based on the experiment id.\n\n        Args:\n            experiment_id (str): Unique identifier for the experiment.\n\n        Returns:\n            str: Path to the experiment directory.\n        \"\"\"\n\n        return Path(__file__).parent.parent / \"experiments\" / f\"exp_{experiment_id}\"\n    \n    @staticmethod\n    def load(exp_id: str):\n        \"\"\"Loads an experiment from a file.\n\n        Args:\n            exp_id (str): Unique identifier for the experiment.\n\n        Returns:\n            Experiment: Experiment instance.\n        \"\"\"\n\n        experiment_dir = Experiment._find_experiment_dir(exp_id)\n        return Experiment.load_file(experiment_dir / CONFIG_FILE_NAME)\n\n    @staticmethod\n    def load_file(path: Path):\n        \"\"\"Loads an experiment from a file.\n\n        Args:\n            path (Path): Path to the experiment file.\n\n        Returns:\n            Experiment: Experiment instance.\n        \"\"\"\n        file_manager = FileManager(path.parent, read=True)\n        config = file_manager.read(path.name)\n        return Experiment.from_config(config)\n\n    @staticmethod\n    def from_config(config):\n        \"\"\"Loads an experiment from a config dict.\n\n        Args:\n            config (dict): Dictionary containing the experiment configuration.\n\n        Returns:\n            Experiment: Experiment instance.\n        \"\"\"\n\n        experiment_id = config[\"experiment_id\"]\n        network = NeuralNetwork.from_config(config[\"network\"])\n        task = TaskManager.from_config(config[\"task\"])\n        trainer = Trainer.from_config(config[\"trainer\"])\n        tester = Tester.from_config(config[\"tester\"])\n        schedule = Schedule.from_config(config[\"schedule\"])\n\n        experiment = Experiment(experiment_id, network,\n                                task, trainer, tester, schedule, _load=True)\n        trainer.initialize_components()\n        experiment.load_last_checkpoint()\n\n        return experiment\n\n    def to_config(self):\n        \"\"\"Creates a config dictionary from the experiment.\n\n        Returns:\n            dict: Dictionary containing the experiment configuration.\n        \"\"\"\n\n        config = {\n            \"experiment_id\": self._experiment_id,\n            \"network\": self._network.to_config(),\n            \"task\": self._task.to_config(),\n            \"trainer\": self._trainer.to_config(),\n            \"tester\": self._tester.to_config(),\n            \"schedule\": self._schedule.to_config()\n        }\n\n        return config\n\n    def load_last_checkpoint(self):\n        \"\"\"Loads the last checkpoint of the experiment.\"\"\"\n\n        try:\n            last_run = self.checkpoint_manager.get_last_run()\n        except ValueError:\n            raise\n\n        try:\n            last_chapter = self.checkpoint_manager.get_last_chapter_in_run(last_run)\n        except ValueError:\n            raise\n\n        self.load_checkpoint(last_run, last_chapter)\n\n    def load_checkpoint(self, run_id, chapter_id):\n        \"\"\"Loads a checkpoint of the experiment.\n\n        Args:\n            run_id (int): Run id of the checkpoint.\n            chapter_id (int): Chapter id of the checkpoint.\n        \"\"\"\n\n        checkpoint = self.checkpoint_manager.get_checkpoint(run_id, chapter_id)\n\n        self.network.load_state_dict(checkpoint[\"model_state_dict\"])\n        self.trainer.load_optimizer_state_dict(\n            checkpoint[\"optimizer_state_dict\"]\n        )\n        self.trainer.set_n_chapters_trained(checkpoint[\"chapter_id\"])\n        self.trainer.set_n_epochs_trained(checkpoint[\"epoch_id\"])\n\n        torch.set_rng_state(checkpoint[\"torch_seed\"])\n        np.random.set_state(checkpoint[\"numpy_seed\"])\n\n        log.info(f\"Successfully loaded checkpoint {run_id}-{chapter_id}.\")\n\n        self._run_id = checkpoint[\"run_id\"]\n\n    def save_components(self):\n\n        component_saver = FileManager(\n            self._experiment_dir, write=True)\n\n        config = self.to_config()\n        component_saver.write(config, CONFIG_FILE_NAME)\n\n    def run_following_schedule(self, continue_run=False, chapter_ends=None, use_cuda=False, use_ipex=False, compute_test_loss=None):\n\n        if chapter_ends is None:\n            if self._schedule is None:\n                log.error(\n                    \"You can only use run_following_schedule if you have \"\n                    + \"a schedule connected to the experiment or pass a schedule.\"\n                )\n                return\n            else:\n                chapter_ends = self._schedule.chapter_ends\n\n        if continue_run:\n            log.warning(\n                \"Continuing run {} at chapter {}.\".format(\n                    self.run_id, self.chapter_id)\n            )\n        else:\n            if self.chapter_id != 0 or self.epoch_id != 0:\n                log.error(\n                    \"You can only use run_following_schedule if you reset the training to a new run.\"\n                )\n                return\n\n        info = \"Starting training on run {} starting at chapter {}, epoch {}\".format(\n            self.run_id, self.chapter_id, self.epoch_id\n        )\n        log.info(info)\n        print(info)\n        for c in range(self.chapter_id, len(chapter_ends) - 1):\n            if chapter_ends[c] != self.epoch_id:\n                log.error(\n                    \"Error on continuing schedule,\"\n                    + \" schedule.chapter_ends[{}]={}\".format(c, chapter_ends[c])\n                    + \" and experiment's self.epoch_id={} \".format(self.epoch_id)\n                    + \"do not fit together.\"\n                )\n                raise ValueError\n            # running c+1:\n            n_epochs_chapter = chapter_ends[c + 1] - chapter_ends[c]\n            self._trainer.train_chapter(\n                n_epochs_chapter=n_epochs_chapter, use_cuda=use_cuda, use_ipex=use_ipex, compute_test_loss=compute_test_loss)\n\n    def continue_runs_following_schedule(self, runs_id_list, stop_epoch, schedule=None, use_cuda=False, compute_test_loss=None):\n        if schedule is None:\n            if self._schedule is None:\n                log.error(\n                    \"You can only use run_following_schedule if you have \"\n                    + \"a schedule connected to the experiment or pass a schedule.\"\n                )\n                return\n            else:\n                schedule = self._schedule\n\n        cut_off = np.argmax(\n            np.array(schedule.chapter_ends_continued) > stop_epoch)\n        chapter_ends = schedule.chapter_ends_continued[:cut_off]\n        for run_id in runs_id_list:\n            last_chapter = self.checkpoint_manager.get_last_chapter_in_run(run_id)\n            self.load_checkpoint(run_id, last_chapter)\n            self.run_following_schedule(\n                continue_run=True, chapter_ends=chapter_ends, use_cuda=use_cuda, compute_test_loss=compute_test_loss)\n\n    def rerun(self, n_runs, like_run_id=None):\n        \"\"\"\n        Reruns the experiment for a given number of runs. For doing this, it uses\n        the checkpoints of a previous run that are found in the checkpoints directory\n        and produces the same checkpoints with a new network initialization.\n\n        Args:\n            n_runs (int): Number of additional runs that should be performed.\n            like_run_id (int): Run id of the run that should be replicated. If not set,\n                defaults to run_id=0.\n        \"\"\"\n        log.info(\"Setting up rerun of experiment: n_runs=\" + str(n_runs))\n\n        if like_run_id is None:\n            like_run_id = 0\n\n        ckpt_list = self.checkpoint_manager.list_checkpoints(run_ids=[\n                                                              like_run_id])\n\n        ckpt_list = [ckpt[1] for ckpt in ckpt_list]\n        epoch_list = [self.schedule.get_epoch_for_chapter(c) for c in ckpt_list]\n        log.warning(\"Extracted schedule: \" + str(epoch_list))\n\n        last_run_id = self.checkpoint_manager.get_last_run()\n\n        for i in range(n_runs):\n            # getting everything to the same state as requested\n            self.load_checkpoint(run_id=like_run_id, chapter_id=0)\n            # get the new run_id\n            self._run_id = last_run_id + 1\n            # reinitialize the network with a new seed\n            self._network.init_weights(randomize_seed=True)\n            self.run_following_schedule(chapter_ends=epoch_list)\n            last_run_id = self._run_id\n\n    def save_checkpoint(self):\n        \"\"\"\n        Calls the CheckpointManager to save the current state of the network and the optimizer\n        (is necessary for optimizers that depend on their own past)\n        together with the state of random number generators (of numpy and torch).\n        \"\"\"\n        self.checkpoint_manager.save()\n\n    def _set_components(self, network, task, trainer, tester, schedule):\n        self._network = network\n        self._network.parent = self\n\n        self._task = task\n        self._task.parent = self\n\n        self._trainer = trainer\n        self._trainer.parent = self\n\n        self._tester = tester\n        self._tester.parent = self\n\n        self._schedule = schedule\n        self._schedule.parent = self\n\n    @property\n    def all_key_components_connected(self):\n        \"\"\"\n        Property (function that is disguised as an object variable)\n        that checks whether all components for this experiment\n        are already in place. (For now, all are needed to start the experiment,\n        this could be changed in the future though, for example Test might not\n        be relevant for every experiment.)\n\n        Returns:\n             (bool): All components are connected, True or False.\n        \"\"\"\n\n        all_comp_flag = True\n        if self._task is None:\n            log.info(\"Task still missing.\")\n            all_comp_flag = False\n        if self._network is None:\n            log.info(\"Network still missing.\")\n            all_comp_flag = False\n        if self._trainer is None:\n            log.info(\"Trainer still missing.\")\n            all_comp_flag = False\n        if self._tester is None:\n            log.info(\"Tester still missing.\")\n            all_comp_flag = False\n        return all_comp_flag\n    \n    def capture_activations(\n            self,\n            dataset,\n            run_id,\n            chapter_id,\n            repeat_dataset=1,\n            batch_size=10 ** 4,\n            before_noise=False,\n            condition=None,\n            quantizer_params=None,\n        ):\n        \"\"\"\n        Captures activations for current network state for the given dataset.\n\n        Returns:\n            Iterator that yields dictionaries with keys X, Y, L1, L2, ...\n                and ndarrays of size (batch_size, ) containing activations\n        \"\"\"\n\n        # Load checkpoint for given run and chapter\n        self.load_checkpoint(run_id, chapter_id)\n\n        assert isinstance(self.network, NoisyNeuralNetwork) or before_noise == False, 'Extraction after noise only possible for noisy network!'\n        \n        if not isinstance(dataset, DataSet):\n            dataset = self.task[dataset]\n\n        if not condition is None:\n            dataset = dataset.condition(len(dataset), condition)\n        \n        feeder = torch.utils.data.DataLoader(dataset, batch_size=batch_size)\n\n        self.network.eval()\n        \n        for x, y in feeder:\n            for _ in range(repeat_dataset):\n\n                if isinstance(self.network, NoisyNeuralNetwork):\n                    act_dict = self.network.extract_activations(\n                        x, before_noise=before_noise, quantizer_params=quantizer_params\n                    )\n                else:\n                    act_dict = self.network.extract_activations(\n                        x, quantizer_params=quantizer_params\n                    )\n\n                act_dict[\"X\"] = x.detach().numpy()\n\n                act_dict[\"Y\"] = y.detach().numpy()\n\n                # Add decision function. Index of maximum value of output layer. If multiple output neurons have the same activation, choose the first!\n                act_dict[\"Yhat\"] = np.argmax(\n                    act_dict[\"L{}\".format(len(act_dict) - 2)], axis=1\n                )\n\n                # Reshape to neuron id dicts NeuronID->[activations]\n                act_dict = {\n                    NeuronID(layer_id, (neuron_idx + 1,)): act_dict[layer_id][:, neuron_idx]\n                    if act_dict[layer_id].ndim > 1\n                    else act_dict[layer_id]\n                    for layer_id in act_dict\n                    for neuron_idx in range(\n                        act_dict[layer_id].shape[1]\n                        if act_dict[layer_id].ndim > 1\n                        else 1\n                    )\n                }\n\n                yield act_dict \n\n    @property\n    def experiment_dir(self):\n        return self._experiment_dir\n\n    @property\n    def id(self):\n        return self._experiment_id\n\n    @property\n    def run_id(self):\n        return self._run_id\n\n    @property\n    def chapter_id(self):\n        return self.trainer.n_chapters_trained\n\n    @property\n    def epoch_id(self):\n        return self.trainer.n_epochs_trained\n\n    @property\n    def network(self):\n        return self._network\n\n    @property\n    def trainer(self):\n        return self._trainer\n\n    @property\n    def task(self):\n        return self._task\n\n    @property\n    def tester(self):\n        return self._tester\n\n    @property\n    def schedule(self):\n        return self._schedule", ""]}
{"filename": "nninfo/exp_comp.py", "chunked_list": ["from abc import ABC\n\nimport nninfo\n\nlog = nninfo.logger.get_logger(__name__)\n\n\nclass ExperimentComponent(ABC):\n    \"\"\"\n    Abstract class that defines parent property for each component of the experiment\n    (experiment is then the parent of each component, if they are connected).\n    \"\"\"\n\n    def __init__(self):\n        self._parent = None\n        super().__init__()\n\n    @property\n    def parent(self):\n        return self._parent\n\n    @parent.setter\n    def parent(self, parent):\n        if self.parent is not None:\n            if parent is not None:\n                log.warning(\n                    \"Parent of {} is changed to experiment {}.\".format(\n                        type(self)),\n                    parent.id,\n                )\n            else:\n                log.info(\"Parent of {} is removed.\".format(type(self)))\n        self._parent = parent", ""]}
{"filename": "nninfo/plot.py", "chunked_list": ["from math import comb\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport nninfo\n\n_dataset_display_names = {\n    'full_set/train': 'Train Set', 'full_set/test': 'Test Set'}", "_dataset_display_names = {\n    'full_set/train': 'Train Set', 'full_set/test': 'Test Set'}\n\n\n##### Performance plots #####\n\ndef plot_accuracy(performance, dataset_name, ax, **kwargs):\n\n    # Get maximum epoch and format broken axis\n    max_epoch_exponent = int(np.ceil(np.log10(performance['epoch_id'].max())))\n    nninfo.plot.format_figure_broken_axis(ax, max_exp=max_epoch_exponent)\n\n    dataset_display_name = _dataset_display_names.get(\n        dataset_name, dataset_name)\n    \n    kwargs = kwargs.copy()\n    kwargs.setdefault('lw', 1)\n    kwargs.setdefault('label', f'{dataset_display_name} Accuracy')\n    \n    # Plot loss\n    nninfo.plot.plot_mean_and_interval(performance, ax, x=('epoch_id', ''), y=(\n        dataset_name, 'accuracy'), **kwargs)", "\n\ndef plot_loss(performance, dataset_name, ax, **kwargs):\n\n    # Get maximum epoch and format broken axis\n    max_epoch_exponent = int(np.ceil(np.log10(performance['epoch_id'].max())))\n    nninfo.plot.format_figure_broken_axis(ax, max_exp=max_epoch_exponent)\n\n    dataset_display_name = _dataset_display_names.get(\n        dataset_name, dataset_name)\n\n    kwargs = kwargs.copy()\n    kwargs.setdefault('lw', 1)\n    kwargs.setdefault('label', f'{dataset_display_name} Accuracy')\n\n    # Plot loss\n    nninfo.plot.plot_mean_and_interval(performance, ax, x=('epoch_id', ''), y=(\n        dataset_name, 'loss'), **kwargs)", "\n\ndef plot_loss_accuracy(performance, ax, ax2, dataset_names=['full_set/train', 'full_set/test'], **kwargs):\n    \"\"\"\n    Plot loss and accuracy.\n    \"\"\"\n\n    max_epoch_exponent = int(np.ceil(np.log10(performance['epoch_id'].max())))\n    nninfo.plot.format_figure_broken_axis(ax, max_exp=max_epoch_exponent)\n\n    kwargs = kwargs.copy()\n    kwargs.setdefault('lw', 1)\n\n    for dataset_name in dataset_names:\n\n        dataset_display_name = _dataset_display_names.get(\n            dataset_name, dataset_name)\n\n        # Plot accuracy\n        nninfo.plot.plot_mean_and_interval(performance, ax, x=('epoch_id', ''), y=(\n            dataset_name, 'accuracy'), label=f'{dataset_display_name} Accuracy', **kwargs)\n        ax.set_xlabel(\"Epochs\")\n        ax.set_ylabel(\"Accuracy\")\n        ax.plot([], label=f'{dataset_display_name} Loss')\n\n        # Plot loss\n        ax2.plot([])  # advance color cycle\n        nninfo.plot.plot_mean_and_interval(performance, ax2, x=(\n            'epoch_id', ''), y=(dataset_name, 'loss'), **kwargs)\n        ax2.set_xlabel(\"Epochs\")\n        ax2.set_ylabel(\"Loss\")\n\n        max_epoch = performance['epoch_id'].max()\n\n        print(f'Avg. {dataset_display_name} accuracy at epoch {max_epoch}:',\n              performance[performance['epoch_id'] ==\n                          max_epoch][(dataset_name, 'accuracy')].mean(),\n              '+-',\n              performance[performance['epoch_id'] == max_epoch][(dataset_name, 'accuracy')].std(ddof=1))", "\n###### PID PLOTS ######\n\n\ndef plot_representational_complexity(pid_summary: pd.DataFrame, ax: plt.Axes, quantile_level=0.95, use_median=False, **kwargs):\n\n    max_epoch_exponent = int(np.ceil(np.log10(pid_summary['epoch_id'].max())))\n    format_figure_broken_axis(ax, max_epoch_exponent)\n\n    plot_mean_and_interval(\n        pid_summary, ax, x='epoch_id', y='representational_complexity', quantile_level=quantile_level, use_median=use_median, **kwargs)", "\n\ndef plot_degree_of_synergy_atoms(pid_summary: pd.DataFrame, ax: plt.Axes, quantile_level=0.95, use_median=False, **kwargs):\n\n    max_epoch_exponent = int(np.ceil(np.log10(pid_summary['epoch_id'].max())))\n    format_figure_broken_axis(ax, max_epoch_exponent)\n\n    max_degree = pid_summary['degree_of_synergy_atoms'].columns.max()\n\n    for degree in range(1, max_degree + 1):\n        plot_mean_and_interval(\n            pid_summary, ax, x=pid_summary['epoch_id'], y=('degree_of_synergy_atoms', degree), quantile_level=quantile_level, use_median=use_median, label=f'Deg. of syn. {degree}', **kwargs)", "\ndef plot_reing_directed_differences(reing_results: pd.DataFrame, ax: plt.Axes, quantile_level=0.95, use_median=False, labels=None, **kwargs):\n\n    max_epoch_exponent = int(np.ceil(np.log10(reing_results['epoch_id'].max())))\n    format_figure_broken_axis(ax, max_epoch_exponent)\n\n    # Find all columns that match the patterh 'C(k||k+1)'\n    for reing_column_name in reing_results.columns[reing_results.columns.str.match('C\\(\\d+\\|\\|\\d+\\)')]:\n        label = reing_column_name if labels is None else labels[reing_column_name]\n        plot_mean_and_interval(\n            reing_results, ax, x=reing_results['epoch_id'], y=reing_column_name, quantile_level=quantile_level, use_median=use_median, label=reing_column_name, **kwargs)", "\ndef plot_reing_complexity(reing_results: pd.DataFrame, ax: plt.Axes, quantile_level=0.95, use_median=False, **kwargs):\n\n    max_epoch_exponent = int(np.ceil(np.log10(reing_results['epoch_id'].max())))\n    format_figure_broken_axis(ax, max_epoch_exponent)\n\n    plot_mean_and_interval(\n        reing_results, ax, x=reing_results['epoch_id'], y='reing_complexity', quantile_level=quantile_level, use_median=use_median, **kwargs)\n\n##### HELPER FUNCTIONS ######", "\n##### HELPER FUNCTIONS ######\n\ndef plot_mean_and_interval(df, ax, x=('epoch_id', ''), y='c', use_median=False, quantile_level=0.95, zorder_shift=0, **kwargs):\n    df_center = df.groupby(x).median(\n    ) if use_median else df.groupby(df.epoch_id).mean()\n    df_high = df.groupby(df.epoch_id).quantile(.5 - quantile_level / 2)\n    df_low = df.groupby(df.epoch_id).quantile(.5 + quantile_level / 2)\n\n    kwargs.setdefault('label', '')\n\n    line = ax.plot(df_center[y], zorder=1+zorder_shift,\n                   solid_capstyle='butt', **kwargs)\n    ax.fill_between(df_low.index, df_low[y].values,\n                    df_high[y].values, color=line[-1].get_color(), alpha=0.3, zorder=0+zorder_shift, linewidth=0)", "\n\ndef format_figure_broken_axis(ax, max_exp=4):\n\n    ax.set_xscale('symlog', linthresh=1, linscale=.6)\n\n    ax.set_xlim(0, 10**max_exp)\n    ax.set_xticks([0] + [10**i for i in range(max_exp+1)])\n    ax.set_xticklabels(['$0$', '$1$'] + ['' if i %\n                                         2 == 1 else f'$10^{i}$' for i in range(1, max_exp+1)])\n\n    # Broken axis\n    d = .01\n    broken_x = 0.07\n    breakspacing = 0.015\n    ax.plot((broken_x-breakspacing*0.9, broken_x+breakspacing*0.9), (0, 0),\n            color='w', transform=ax.transAxes, clip_on=False, linewidth=.8, zorder=3)\n    ax.plot((broken_x-breakspacing*0.9, broken_x+breakspacing*0.9), (1, 1),\n            color='w', transform=ax.transAxes, clip_on=False, linewidth=.8, zorder=3)\n\n    kwargs = dict(transform=ax.transAxes, color='k',\n                  clip_on=False, linewidth=.8, zorder=4)\n    ax.plot((broken_x-d-breakspacing, broken_x+d -\n             breakspacing), (-3*d, +3*d), **kwargs)\n    ax.plot((broken_x-d-breakspacing, broken_x+d -\n             breakspacing), (1-3*d, 1+3*d), **kwargs)\n    ax.plot((broken_x-d+breakspacing, broken_x+d +\n             breakspacing), (-3*d, +3*d), **kwargs)\n    ax.plot((broken_x-d+breakspacing, broken_x+d +\n             breakspacing), (1-3*d, 1+3*d), **kwargs)"]}
{"filename": "nninfo/config.py", "chunked_list": ["from os import cpu_count\nimport os\n\n# set the maximum number of workers, typically to the number of cpus minus 1\ncpus = cpu_count()\nif cpus is None:\n    raise OSError\nelif cpus <= 2:\n    N_WORKERS = cpus\nelse:\n    N_WORKERS = cpu_count()", "    \n# for cluster safe usage uncomment:\nCLUSTER_MODE = int(os.environ.get(\"CLUSTER_MODE\", 0)) == 1\n\nif CLUSTER_MODE:\n    N_WORKERS = int(os.environ.get(\"SLURM_CPUS_PER_TASK\", 1))\n\nprint(f'{N_WORKERS=}')"]}
{"filename": "nninfo/file_io.py", "chunked_list": ["# you may not need all of these, if you know your data file types\n# and the way FileManager handles them.\nimport os, re, glob\nfrom pathlib import Path\nimport shutil\nimport pickle\nimport json\nimport ast\nimport copy\n", "import copy\n\nimport numpy as np\nimport scipy.io as io\nimport torch\nimport yaml\nimport pandas as pd\nfrom filelock import FileLock\n\nimport nninfo", "\nimport nninfo\nfrom .exp_comp import ExperimentComponent\n\nFILELOCK_TIMEOUT = -1\n\n\nlog = nninfo.logger.get_logger(__name__)\n\nEXPERIMENT_DIR_STANDARD = {", "\nEXPERIMENT_DIR_STANDARD = {\n    \"experiment_dir\": \"exp_{:04d}/\",\n    \"experiment_dir_str\": \"exp_{}/\",\n    \"checkpoints\": \"checkpoints/\",\n    \"measurements\": \"measurements/\",\n    \"plots\": \"plots/\",\n    \"logs\": \"log/\",\n    \"components\": \"components/\",\n}", "    \"components\": \"components/\",\n}\n\nFILENAME_STANDARD = {\n    \"checkpoint\": \"ckpt_r{:06d}_c{:06d}_e{:012d}.pt\",\n    \"checkpoint_loading\": \"ckpt_r{:06d}_c{:06d}_e*.pt\",\n    \"checkpoint_loading_all_runs\": \"ckpt_r*_c{:06d}_e*.pt\",\n    \"checkpoint_loading_all_chapters\": \"ckpt_r{:06d}_c*_e*.pt\",\n    \"measurement_history\": \"measurement_history.json\",\n    \"measurement_file\": \"meas_r{:06d}_c{:06d}_e{:012d}.jsonl\",", "    \"measurement_history\": \"measurement_history.json\",\n    \"measurement_file\": \"meas_r{:06d}_c{:06d}_e{:012d}.jsonl\",\n}\n\nCHECKPOINT_FILE_NAME_PATTERN = \"ckpt_r*_c*_e*.pt\"\n\nclass NoAliasDumper(yaml.SafeDumper):\n    def ignore_aliases(self, data):\n        return True\n", "\n\nclass CheckpointManager(ExperimentComponent):\n    \"\"\"\n    Implemented following this:\n    https://discuss.pytorch.org/t/saving-and-loading-a-model-in-pytorch/2610/3\n\n    Allows for storing and reloading of the network state,\n    optimizer state and random number generator states.\n    \"\"\"\n\n    def __init__(self, checkpoint_dir):\n        super().__init__()\n        self._checkpoint_dir = checkpoint_dir\n\n    def save(self, filename=None):\n        state = {\n            \"chapter_id\": self.parent.chapter_id,\n            \"model_state_dict\": self.parent.network.state_dict(),\n            \"optimizer_state_dict\": self.parent.trainer.optimizer_state_dict(),\n            \"epoch_id\": self.parent.epoch_id,\n            \"torch_seed\": torch.get_rng_state(),\n            \"numpy_seed\": np.random.get_state(),\n            \"run_id\": self.parent.run_id,\n        }\n        \"\"\"\n        Saves the current state of the experiment as a checkpoint\n        in the experiments/expXXXX/checkpoints/\n        directory. Outputs a message if succeeded.\n        \"\"\"\n\n        if filename is None:\n            filename = FILENAME_STANDARD[\"checkpoint\"]\n\n        final_filename = filename.format(\n            self.parent.run_id, self.parent.chapter_id, self.parent.epoch_id\n        )\n        torch.save(state, self._checkpoint_dir / final_filename)\n\n        log.info(\n            \"Successfully saved current state of the training as {}.\".format(\n                final_filename\n            )\n        )\n    \n    def get_checkpoint_filename(self, run_id, chapter_id):\n        \"\"\"Returns the filename of the checkpoint with the given run_id and chapter_id.\n        \n        Args:\n            run_id (int): run_id of the checkpoint\n            chapter_id (int): chapter_id of the checkpoint\n            \n        Returns:\n            str: filename of the checkpoint\n        \"\"\"\n        \n        file_name = FILENAME_STANDARD[\"checkpoint_loading\"].format(run_id, chapter_id)\n        \n        file_paths = list(self._checkpoint_dir.glob(file_name))\n\n        if len(file_paths) == 0:\n            raise FileNotFoundError(f\"Could not find file {file_name}\")\n        elif len(file_paths) > 1:\n            raise RuntimeError(f\"Found more than one file matching {file_name}\")\n        \n        file_path = file_paths[0]\n        \n        return file_path\n    \n    def get_checkpoint(self, run_id, chapter_id):\n        \"\"\"Returns the checkpoint with the given run_id and chapter_id.\n        \n        Args:\n            run_id (int): run_id of the checkpoint\n            chapter_id (int): chapter_id of the checkpoint\n            \n        Returns:\n            dict: checkpoint\n        \"\"\"\n        \n        file_name = self.get_checkpoint_filename(run_id, chapter_id)\n\n        return torch.load(file_name)\n\n    def read(self, filename):\n        if self._checkpoint_loader is None:\n            self.init_loader_saver()\n        return self._checkpoint_loader.read(filename)\n\n    def list_all_checkpoints(self):\n        \"\"\"Collects all checkpoint files in the checkpoints directory.\n        \n        Returns:\n            list: list of tuples (run_id, chapter_id)\n        \"\"\"\n\n        # Get all checkpoint files that match the pattern\n        checkpoints = self._checkpoint_dir.glob(CHECKPOINT_FILE_NAME_PATTERN)\n        checkpoints = [checkpoint.name for checkpoint in checkpoints]\n\n        # extract run_id and chapter_id from filename\n        checkpoints = [\n            (\n                int(re.findall(r\"r(\\d+)\", checkpoint)[0]),\n                int(re.findall(r\"c(\\d+)\", checkpoint)[0]),\n            )\n            for checkpoint in checkpoints\n        ]\n\n        return sorted(checkpoints)\n\n    def list_checkpoints(self, run_ids=None, chapter_ids=None):\n        \n        checkpoints = self.list_all_checkpoints()\n\n        if run_ids is not None:\n\n            if isinstance(run_ids, int):\n                run_ids = [run_ids]\n\n            checkpoints = [checkpoint for checkpoint in checkpoints if checkpoint[0] in run_ids]\n\n        if chapter_ids is not None:\n\n            if isinstance(chapter_ids, int):\n                chapter_ids = [chapter_ids]\n\n            checkpoints = [checkpoint for checkpoint in checkpoints if checkpoint[1] in chapter_ids]\n\n        return checkpoints\n    \n    def get_run_ids(self):\n        \"\"\"Returns a sorted list of all runs that have checkpoints.\"\"\"\n        return sorted(list(set(checkpoint[0] for checkpoint in self.list_all_checkpoints())))\n    \n    def get_chapter_ids(self, run_id):\n        \"\"\"Returns a sorted list of all chapters that have checkpoints.\"\"\"\n        return sorted(list(set(checkpoint[1] for checkpoint in self.list_all_checkpoints() if checkpoint[0] == run_id)))\n    \n    def get_last_run(self):\n        \"\"\"Returns the last run that has checkpoints.\"\"\"\n\n        runs = self.get_run_ids()\n\n        if len(runs) == 0:\n            raise ValueError(\"No runs found.\")\n        \n        return max(runs)\n    \n    def get_last_chapter_in_run(self, run_id):\n        \"\"\"Returns the last chapter in a run that has a checkpoint.\"\"\"\n\n        checkpoints = self.list_checkpoints(run_ids=[run_id])\n\n        if len(checkpoints) == 0:\n            raise ValueError(\"No checkpoints found for run_id {}\".format(run_id))\n\n        return max(checkpoints, key=lambda x: x[1])[1]", "        \n\nclass MeasurementManager:\n    \"\"\"\n    Allows for storing and reloading of the network state,\n    optimizer state and random number generator states.\n    \"\"\"\n\n    def __init__(self, experiment_dir: Path, measurement_subdir=\"measurements/\"):\n        self._measurement_saver = FileManager(\n            experiment_dir / measurement_subdir, write=True\n        )\n        self._measurement_loader = FileManager(\n            experiment_dir / measurement_subdir, read=True\n        )\n        self._history_dict = None\n        lock = FileLock(FILENAME_STANDARD[\"measurement_history\"]+\".lock\", timeout=FILELOCK_TIMEOUT)\n        with lock.acquire():\n            self.load_history()\n\n    def load_history(self):\n        try:\n            self._history_dict = self._measurement_loader.read(\n                \"measurement_history.json\"\n            )\n        except FileNotFoundError:\n            log.info(\n                \"Measurement history not found. Creating new measurement_history.json\"\n            )\n            self._measurement_saver.write(dict(), \"measurement_history.json\")\n            self._history_dict = self._measurement_loader.read(\n                \"measurement_history.json\"\n            )\n\n    def get_next_measurement_id(self):\n        # This function could also look into the settings of old measurements in order not to\n        # repeat parts of or full measurements. At the moment it just finds the maximum of the\n        # other ids though\n        try:\n            id = int(max(self._history_dict, key=int)) + 1\n        except Exception as e:\n            id = 0\n        return id\n\n    def save(self, measurement, measurement_id=None):\n        \"\"\"\n        Save a measurement by appending it to the right file.\n        \"\"\"\n        lock = FileLock(FILENAME_STANDARD[\"measurement_history\"]+\".lock\", timeout=FILELOCK_TIMEOUT)\n        with lock.acquire():\n            self.load_history()\n\n            if measurement_id is None:\n                measurement_id = self.get_next_measurement_id()\n            save_dict = measurement.get_measurement_dict(measurement_id)\n\n            run_id = save_dict[\"run_id\"]\n            chapter_id = save_dict[\"chapter_id\"]\n            epoch_id = save_dict[\"epoch_id\"]\n            type_str = save_dict[\"measurement_type\"]\n\n            if type_str == \"pid\":\n                file_prefix = \"active_\"\n            elif type_str == \"fisher\":\n                file_prefix = \"structural_\"\n            elif type_str == \"weight\":\n                file_prefix = \"structural_\"\n            elif type_str == \"mi\":\n                file_prefix = \"active_\"\n            else:\n                raise NotImplementedError\n            self._measurement_saver.append(\n                save_dict,\n                file_prefix\n                + FILENAME_STANDARD[\"measurement_file\"].format(\n                    run_id, chapter_id, epoch_id\n                ),\n            )\n            if measurement_id in self._history_dict:\n                self._history_dict[measurement_id].append((run_id, chapter_id, epoch_id))\n            else:\n                self._history_dict[measurement_id] = [(run_id, chapter_id, epoch_id)]\n            self._measurement_saver.write(\n                self._history_dict, FILENAME_STANDARD[\"measurement_history\"]\n            )\n\n        return measurement_id\n\n    def load(self, filename=\"*.jsonl\", **kwargs):\n        file_list = self._measurement_loader.list_files_in_dir(filename)\n        row_list = []\n        for f in file_list:\n            row_list.extend(self._measurement_loader.read(f, **kwargs))\n        return pd.DataFrame(row_list)\n\n    @property\n    def history_dict(self):\n        self.load_history()\n        return copy.deepcopy(self._history_dict)", "\n\nclass FileManager:\n    def __init__(self, rel_path, read=False, write=False):\n        if (read and write) or (not read and not write):\n            log.error(\"FileManager should either read or write in one directory.\")\n            raise AttributeError\n\n        self._read = read\n        self._write = write\n        module_dir = os.path.dirname(__file__)\n        self._rel_path = rel_path\n        self._path = os.path.join(module_dir, rel_path)\n\n        self.tuple_as_str = False\n\n    def list_subdirs_in_dir(self):\n        d = self._path\n        return [\n            os.path.join(d, o)\n            for o in os.listdir(d)\n            if os.path.isdir(os.path.join(d, o))\n        ]\n\n    def list_files_in_dir(self, filename=None):\n        if filename is not None:\n            filepath = os.path.join(self._path, filename)\n            names = [os.path.basename(x) for x in glob.glob(filepath)]\n            return names\n        return os.listdir(self._path)\n\n    def find_file(self, filename):\n        # here glob is used, because it is nicer for a filename that includes a '*'\n        filepath = os.path.join(self._path, filename)\n        filepath_list = glob.glob(filepath)\n        if len(filepath_list) == 1:\n            new_filepath = filepath_list[0]\n        elif len(filepath_list) > 1:\n            log.warning(\"Multiple files meet this criterion: {}\".format(filepath_list))\n            idx = input(\"Specify index (0,1..)\")\n            log.info(\"Chose index {}\".format(idx))\n            new_filepath = filepath_list[idx]\n        else:\n            raise FileNotFoundError\n        return os.path.basename(new_filepath)\n\n    def write(self, data, filename):\n        if not self.write:\n            log.error(\"Not allowed to write.\")\n            raise PermissionError\n\n        ext = os.path.splitext(filename)[1]\n        if ext == \".pt\":\n            self._write_torch_state_pt(data, filename)\n        elif ext == \".jsonl\":\n            self._write_jsonl(data, filename)\n        elif ext == \".json\":\n            self._write_json(data, filename)\n        elif ext == \".npy\":\n            self._write_npy(data, filename)\n        elif ext == \".yaml\":\n            self._write_yaml(data, filename)\n        else:\n            raise NotImplementedError\n\n    def append(self, data, filename):\n        if not self.write:\n            log.error(\"Not allowed to write.\")\n            raise PermissionError\n\n        ext = os.path.splitext(filename)[1]\n        if ext == \".jsonl\":\n            self._write_jsonl(data, filename, append=True)\n        else:\n            log.error(\"Appending not implemented for file extension \" + ext)\n            raise NotImplementedError\n\n    def _write_torch_state_pt(self, state, filename):\n        filepath = os.path.join(self._path, filename)\n        torch.save(state, filepath)\n\n    def _write_jsonl(self, data, filename, append=False):\n        filepath = os.path.join(self._path, filename)\n        enc = MultiDimensionalArrayEncoder()\n        json_str = enc.encode(data)\n        if append:\n            with open(filepath, \"a\") as f:\n                f.write(json_str + \"\\n\")\n        else:\n            with open(filepath, \"w\") as f:\n                f.write(json_str + \"\\n\")\n\n    def _write_json(self, data, filename):\n        filepath = os.path.join(self._path, filename)\n        enc = MultiDimensionalArrayEncoder()\n        json_str = enc.encode(data)\n        with open(filepath, \"w\") as f:\n            f.write(json_str)\n\n    def _write_npy(self, data, filename):\n        filepath = os.path.join(self._path, filename)\n        np.save(filepath, data, allow_pickle=False)\n\n    def _write_yaml(self, data, filename):\n        filepath = os.path.join(self._path, filename)\n        with open(filepath, \"w\") as f:\n            yaml.dump(data, f, Dumper=NoAliasDumper, sort_keys=False)\n\n    def read(self, filename, line=None, **kwargs):\n        if not self.read:\n            log.error(\"Permission Error: Not allowed to read.\")\n            raise PermissionError\n\n        ext = os.path.splitext(filename)[1]\n        if ext == \".npy\":\n            return self._read_numpy(filename)\n        elif ext == \".mat\":\n            return self._read_mat(filename)\n        elif ext == \".pt\":\n            return self._read_torch_state_pt(filename)\n        elif ext == \".pkl\":\n            return self._read_pickle(filename)\n        elif ext == \".jsonl\":\n            return self._read_jsonl(filename, line, **kwargs)\n        elif ext == \".json\":\n            return self._read_json(filename, **kwargs)\n        elif ext == \".yaml\":\n            return self._read_yaml(filename, **kwargs)\n        else:\n            log.error(\"Filetype {} not supported.\".format(ext))\n            raise IOError\n\n    def _read_torch_state_pt(self, filename):\n        filepath = os.path.join(self._path, filename)\n        return torch.load(filepath)\n\n    def _read_numpy(self, filename):\n        filepath = os.path.join(self._path, filename)\n        return np.load(filepath)\n\n    def _read_mat(self, filename):\n        filepath = os.path.join(self._path, filename)\n        return io.loadmat(filepath)\n\n    def _read_pickle(self, filename):\n        filepath = os.path.join(self._path, filename)\n        with open(filepath, \"rb\") as f:\n            data = pickle.load(f)\n        return data\n\n    def _read_jsonl(self, filename, jsonl_line_id=None, **kwargs):\n        filepath = os.path.join(self._path, filename)\n        if \"tuple_as_str\" in kwargs:\n            self.tuple_as_str = kwargs[\"tuple_as_str\"]\n        else:\n            self.tuple_as_str = True\n        if jsonl_line_id is None:\n            row_list = []\n            with open(filepath, \"r\") as f:\n                for line in f:\n                    if line.startswith(\"{\"):\n                        json_line = json.loads(line, object_hook=self.hinted_tuple_hook)\n                        row_list.append(json_line)\n            return row_list\n        else:\n            json_string = \"\"\n            with open(filepath, \"r\") as f:\n                for i, line in enumerate(f):\n                    if i == jsonl_line_id - 1:\n                        json_string = line.rstrip(\"\\n\")\n                        break\n            return json.loads(json_string, object_hook=self.hinted_tuple_hook)\n\n    def _read_json(self, filename, **kwargs):\n        if \"tuple_as_str\" in kwargs:\n            self.tuple_as_str = kwargs[\"tuple_as_str\"]\n        else:\n            self.tuple_as_str = False\n        filepath = os.path.join(self._path, filename)\n        with open(filepath, \"r\") as f:\n            return json.load(f, object_hook=self.hinted_tuple_hook)\n        \n    def _read_yaml(self, filename, **kwargs):\n        filepath = os.path.join(self._path, filename)\n        with open(filepath, \"r\") as f:\n            return yaml.safe_load(f)\n\n    def make_experiment_dir(self, id, overwrite=False):\n        if not self.write:\n            log.error(\"Not allowed to write.\")\n            raise PermissionError\n        experiment_dir = EXPERIMENT_DIR_STANDARD[\"experiment_dir_str\"].format(id)\n\n        experiment_dir_abs_path = os.path.join(self._path, experiment_dir)\n        experiment_dir_rel_path = os.path.join(self._rel_path, experiment_dir)\n\n        if os.path.exists(experiment_dir_abs_path):\n            log.warning(\n                \"Experiment directory with same id already exists: \"\n                + experiment_dir_abs_path\n            )\n            if overwrite:\n                log.warning(\"Overwrite existing experiment directory?\")\n                if input(\"Overwrite existing experiment directory? [y/n]\") == \"y\":\n                    #log.info(\n                    #    \"Overwriting experiment directory with id {} accepted by user.\".format(\n                    #        id\n                    #    )\n                    #)\n                    shutil.rmtree(experiment_dir_abs_path)\n                else:\n                    log.error(\"Overwriting not permitted by user.\")\n                    raise PermissionError\n            else:\n                log.error(\"Overwriting not set as argument when calling Experiment().\")\n                raise PermissionError\n\n        os.mkdir(experiment_dir_abs_path)\n\n        for key, value in EXPERIMENT_DIR_STANDARD.items():\n            if not key == \"experiment_dir\" and not key  == \"experiment_dir_str\":\n                new_dir = os.path.join(experiment_dir_abs_path, value)\n                os.mkdir(new_dir)\n\n        log.info(\n            \"Successfully made new experiment directory {} for experiment {}\".format(\n                experiment_dir_rel_path, str(id)\n            )\n        )\n        return Path(experiment_dir_abs_path)\n\n    def hinted_tuple_hook(self, obj):\n        \"\"\"\n        Helper function that is called for decoding of json lines files.\n        Whenever the json object that is\n        encoded has strings as key or value arguments that are strings, they are checked\n        for the prefix '__tuple__'. If such a tuple is found, the rest of the string\n        is decoded via ast.literal_eval and thereby turned into a tuple.\n        While this works fine for smaller files, it\n        might cause a significant slowdown for larger files. However, this does not hurt\n        too much the performance, since we are just appending to the measurement\n        files. Also, this is why in nninfo the\n        standard is, to have several json objects in one file, each on a seperate line.\n        Also keep in mind the potential security risk of ast.literal_eval.\n        \"\"\"\n\n        def parse(item):\n            if isinstance(item, str):\n                if item.startswith(\"__tuple__\"):\n                    if self.tuple_as_str:\n                        parsed = item.lstrip(\"__tuple__\")\n                    else:\n                        parsed = ast.literal_eval(item.lstrip(\"__tuple__\"))\n                elif item.startswith(\"__int__\"):\n                    parsed = ast.literal_eval(item.lstrip(\"__int__\"))\n                else:\n                    parsed = item\n            elif isinstance(item, list):\n                parsed = list()\n                for el in item:\n                    parsed.append(parse(el))\n            elif isinstance(item, dict):\n                parsed = dict()\n                for k, v in item.items():\n                    parsed_key = parse(k)\n                    parsed_value = parse(v)\n                    parsed[parsed_key] = parsed_value\n            else:\n                parsed = item\n            return parsed\n\n        return parse(obj)", "\n\nclass MultiDimensionalArrayEncoder(json.JSONEncoder):\n    \"\"\"\n    Encoder, inherits from json.JSONEncoder. Modifies it in the sense that it handles\n    tuples differently from lists. Tuples are packed into strings before writing to to\n    the file. Each of these str(tuple()) objects has a prefix \"__tuple__\" which identifies\n    it as a tuple. When loading the json object, these strings are decoded via the\n    hinted_tuple_hook.\n\n    Keyword arguments can be used to set the underlying JSONEncoder objects at __init__.\n    For example, skipkeys, ensure_ascii, check_circular, allow_nan, sort_keys, indent can\n    be set. However, for the functionality of nninfo, the JSON objects have to be in one\n    line each.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        super(MultiDimensionalArrayEncoder, self).__init__(**kwargs)\n\n    def encode(self, obj):\n        def hint_tuples(item, key=False):\n            if isinstance(item, tuple):\n                return \"__tuple__\" + str(item)\n            if isinstance(item, int) and key:\n                return \"__int__\" + str(item)\n            if isinstance(item, list):\n                return [hint_tuples(e) for e in item]\n            if isinstance(item, dict):\n                return {\n                    hint_tuples(key, key=True): hint_tuples(value)\n                    for key, value in item.items()\n                }\n            else:\n                return item\n\n        return super(MultiDimensionalArrayEncoder, self).encode(hint_tuples(obj))", ""]}
{"filename": "nninfo/data_set.py", "chunked_list": ["import torch\nimport numpy as np\nfrom numpy.random import Philox, Generator\n\nSUBSET_SYMBOL = \"/\"  # <dataset>/<subset>/<subsubset> etc.\n\nclass DataSet(torch.utils.data.Dataset):\n    def __init__(self, task, name):\n        self._task = task\n        self._name = name\n        self._subsets = []\n\n    @staticmethod\n    def from_config(task, config):\n        \"\"\"\n        Creates a new DataSet from a config dictionary\n        \"\"\"\n        if task.finite:\n            return CachedDataset.from_config(task, config)\n        else:\n            return LazyDataset.from_config(task, config)\n        \n    def to_config(self):\n        \"\"\"\n        Returns a dictionary representation of the dataset tree\n        \"\"\"\n        d = dict(name=self._name)\n        \n        if self._subsets:\n            d[\"subsets\"] = [subset.to_config() for subset in self._subsets]\n\n        return d\n    \n    def _load_subsets_from_config_list(self, config_list):\n        self._subsets = [\n            SubSet.from_config(self, subset_config)\n            for subset_config in config_list\n        ]\n\n    def __str__(self, level=0):\n        \"\"\"\n        Recursive function that allows for printing of the Dataset Tree / Subset Branch.\n\n        Args:\n            level (int): level of branch\n\n        Returns:\n            str: Representation of this branch (Tree).\n        \"\"\"\n        ret = \"\\t\" * level + self.__repr__() + \"\\n\"\n        for subset in self._subsets:\n            ret += subset.__str__(level=level + 1)\n        return ret\n\n    def __repr__(self):\n        return (\n            self._name\n            + \": \\t\"\n            + str(len(self))\n            + \" elements.\"\n            + (\"(lazy)\" if isinstance(self, LazyDataset) else \"\")\n            + (\"(cached)\" if isinstance(self, CachedDataset) else \"\")\n        )\n\n    def find(self, dataset_name):\n        \"\"\"\n        Depth-first search for dataset_name in the dataset tree\n        \"\"\"\n        if self._name == dataset_name:\n            return self\n        else:\n            for subset in self._subsets:\n                result = subset.find(dataset_name)\n                if not result is None:\n                    return result\n            return None\n\n    def create_subset(self, name, subset_slice, random_split_seed=None):\n        subset = SubSet(self, name, subset_slice, random_split_seed=random_split_seed)\n        self._subsets.append(subset)\n\n    def train_test_val_random_split(self, train_len, test_len, val_len, seed):\n\n        total_len = train_len + test_len + val_len\n\n        if len(self) != total_len:\n            raise ValueError(\n                \"Split can only be performed if the subdatasets total\"\n                \"length matches with the length of the dataset\"\n            )\n\n        train_name = self._name + SUBSET_SYMBOL + \"train\"\n        test_name = self._name + SUBSET_SYMBOL + \"test\"\n        val_name = self._name + SUBSET_SYMBOL + \"val\"\n\n        # create subsets\n        self.create_subset(train_name, slice(None, train_len), random_split_seed=seed)\n        self.create_subset(test_name, slice(train_len, train_len + test_len), random_split_seed=seed)\n        self.create_subset(val_name, slice(train_len + test_len, None), random_split_seed=seed)\n        return [train_name, test_name, val_name]\n\n    def train_test_val_sequential_split(self, train_len, test_len, val_len):\n        assert train_len + test_len + val_len == len(self), 'Split can only be performed if the subsets comprise the whole set'\n\n        train_name = self._name + SUBSET_SYMBOL + \"train\"\n        test_name = self._name + SUBSET_SYMBOL + \"test\"\n        val_name = self._name + SUBSET_SYMBOL + \"val\"\n\n        self.create_subset(train_name, slice(None, train_len))\n        self.create_subset(test_name, slice(train_len, train_len + test_len))\n        self.create_subset(val_name, slice(train_len + test_len, None))\n\n    def one_class_split(self):\n        return self._class_wise_split(\"one_class\")\n\n    def all_but_one_class_split(self):\n        return self._class_wise_split(\"all_but_one_class\")\n\n    def multiple_class_split(self, class_list):\n        return self._class_wise_split(\"multiple\", class_list=class_list)\n\n    def _class_wise_split(self, method, class_list=None):\n        dataset_labels_np = self._y# if self is CachedDataset else np.array(self)[:, 1]\n        # TODO: Test this for one-hot-labels\n        classes = np.unique(dataset_labels_np)\n        return_name_list = []\n        if method == \"one_class\":\n            for cls_idx, cls in enumerate(classes):\n                keep_idx = np.where(dataset_labels_np == cls)[0]\n                cls_name = self._name + SUBSET_SYMBOL + \"class_\" + str(cls_idx)\n                self.create_subset(cls_name, keep_idx)\n                return_name_list.append(cls_name)\n        elif method == \"all_but_one_class\":\n            for cls_idx, cls in enumerate(classes):\n                keep_idx = np.where(dataset_labels_np != cls)[0]\n                cls_name = self._name + SUBSET_SYMBOL + \"not_class_\" + str(cls_idx)\n                self.create_subset(cls_name, keep_idx)\n                return_name_list.append(cls_name)\n        elif method == \"multiple\":\n            keep_idx_list = []\n            cls_name = self._name + SUBSET_SYMBOL + \"multiple\"\n            for el in class_list:\n                temp = np.where(dataset_labels_np == el)[0].tolist()\n                print(type(temp))\n                keep_idx_list.extend(temp)\n                cls_name += \"_\" + str(el)\n            keep_idx = np.array(keep_idx_list)\n            self.create_subset(cls_name, keep_idx)\n        else:\n            raise NotImplementedError\n        return return_name_list\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def task(self):\n        return self._task\n\n    @property\n    def subsets(self):\n        return self._subsets", "\n\nclass SubSet(DataSet):\n    \"\"\"\n    SubSet of data, that is directly connected to the original 'full_set', and takes its samples\n    from there. Never change the order of the parent Dataset!\n    \"\"\"\n\n    def __init__(self, parent, name, subset_slice, random_split_seed=None):\n        \"\"\"Defines a subset of the parent dataset, that is defined by the indices in parent_indices\n\n        Args:\n            parent (DataSet): Parent dataset\n            name (str): Name of the subset\n            subset_slice (slice): Slice of the parent indices that are used for this subset\n            random_split_seed (int, optional): Seed for shuffling the parent indices before slicing\n        \"\"\"\n        super().__init__(parent.task, name)\n        self._parent = parent\n        self._random_split_seed = random_split_seed\n        self._slice = subset_slice\n\n        if random_split_seed is not None:\n            generator = np.random.default_rng(random_split_seed)\n            parent_indices = generator.permutation(len(parent))\n        else:\n            parent_indices = np.arange(len(parent))\n\n        self._indices = parent_indices[subset_slice]\n\n    @staticmethod\n    def from_config(parent, config):\n        \n        subsets = [SubSet.from_config(parent, subset_config) for subset_config in config.get('subsets', [])]\n\n        subset = SubSet(parent, config['name'], eval(config['subset_slice']), config.get('random_split_seed', None))\n        subset._subsets = subsets\n\n        return subset\n    \n    def to_config(self):\n\n        d = dict(name=self._name, subset_slice=str(self._slice))\n\n        if self._random_split_seed is not None:\n            d['random_split_seed'] = self._random_split_seed\n\n        if self._subsets:\n            d['subsets'] = [subset.to_dict() for subset in self._subsets]\n\n        return d\n\n    def __getitem__(self, idx):\n        return self.parent[self._indices[idx]]\n\n    def __len__(self):\n        return len(self._indices)\n\n    @property\n    def parent(self):\n        return self._parent\n\n    @property\n    def indices(self):\n        return self._indices", "\n\nclass CachedDataset(DataSet):\n    def __init__(self, task, name):\n        super().__init__(task, name)\n        x, y = self._task.load_samples()\n        self._x, self._y = x, y\n\n    @staticmethod\n    def from_config(task, config):\n        dataset = CachedDataset(task, config['name'])\n        dataset._load_subsets_from_config_list(config.get('subsets', []))\n        return dataset\n\n    def __len__(self):\n        return self._x.shape[0]\n\n    def __getitem__(self, idx):\n        return self._x[idx], self._y[idx]", "\n\nclass LazyDataset(DataSet):\n    def __init__(self, task, name, length, seed=None, condition=None):\n        super().__init__(task, name)\n        assert not task.finite\n        self._len = length\n\n        if not seed is None:\n            self._seed = seed\n        else:\n            seed_generator = Generator(Philox())\n            self._seed = int(\n                seed_generator.integers(np.iinfo(np.int64).max)\n            )  # Has to be int to be json serializable\n\n        self._philox = Philox(seed)\n        self._philox_state = self._philox.state\n        self._rng = Generator(self._philox)\n\n        self._condition = condition\n\n    @staticmethod\n    def from_config(task, config):\n        dataset = LazyDataset(\n            task, config['name'], config['length'], config.get('seed', None), config.get('condition', None)\n        )\n\n        dataset._load_subsets_from_config_list(config.get('subsets', []))\n\n        return dataset\n    \n    def to_config(self):\n        d = dict(\n            name=self._name,\n            length=self._len,\n            seed=self._seed,\n            condition=self._condition,\n        )\n\n        if self._subsets:\n            d[\"subsets\"] = [subset.to_dict() for subset in self._subsets]\n\n        return d\n    \n    def extend(self, n_samples):\n        \"\"\"\n        Get a copy of the dataset with a different length\n        \"\"\"\n        name_ext = self._name + \"_ext\"\n        return LazyDataset(self._task, name_ext, n_samples, self._seed)\n\n    def condition(self, n_samples, condition):\n        \"\"\"\n        Get a copy of the dataset with a condition\n        \"\"\"\n        name_cond = self._name + \"_cond\"\n        return LazyDataset(\n            self._task, name_cond, n_samples, self._seed, condition=condition\n        )\n\n    def __len__(self):\n        return self._len\n\n    def __getitem__(self, idx):\n        if idx >= self._len:\n            raise IndexError\n\n        self._philox_state[\"state\"][\"counter\"][-1] = idx\n        self._philox.state = self._philox_state\n        return self._task.generate_sample(self._rng, condition=self._condition)", "    "]}
{"filename": "nninfo/logger.py", "chunked_list": ["import logging\n\n\ndef get_logger(name):\n    # Create a custom logger\n    logger = logging.getLogger(name)\n\n    # Create handlers\n    c_handler = logging.StreamHandler()\n\n    # Create formatters and add it to handlers\n    c_format = logging.Formatter(\"%(name)s: %(message)s\")\n\n    c_handler.setFormatter(c_format)\n\n    c_handler.setLevel(logging.WARNING)\n\n    # Add handlers to the logger\n    logger.addHandler(c_handler)\n    return logger", "\n\ndef add_exp_file_handler(experiment_dir):\n    main_logger = logging.getLogger(\"nninfo\")\n    f_handler = logging.FileHandler(experiment_dir / \"log\" / \"exp_log.log\")\n    f_format = logging.Formatter(\n        \"%(asctime)s [%(name)-13.13s] [%(levelname)-5.5s]  %(message)s\"\n    )\n    f_handler.setFormatter(f_format)\n    f_handler.setLevel(logging.INFO)\n    # check if logger for this experiment exists already\n    if main_logger.handlers:\n        for h in main_logger.handlers:\n            if h.__dict__[\"baseFilename\"] == f_handler.baseFilename:\n                return\n    main_logger.addHandler(f_handler)", "\n\ndef remove_exp_file_handler(experiment_dir):\n    main_logger = logging.getLogger(\"nninfo\")\n    dummy = logging.FileHandler(experiment_dir + \"log/exp_log.log\")\n    for h in main_logger.handlers:\n        if h.__dict__[\"baseFilename\"] == dummy.baseFilename:\n            main_logger.handlers.remove(h)\n", ""]}
{"filename": "nninfo/__init__.py", "chunked_list": ["import logging\nimport os\n\nfrom . import logger\nfrom . import config\nfrom . import experiment\nfrom . import trainer\nfrom . import tester\nfrom . import tasks\nfrom . import file_io", "from . import tasks\nfrom . import file_io\nfrom . import plot\nfrom . import data_set\nfrom . import analysis\nfrom . import schedule\n\nfrom .experiment import *\nfrom .trainer import *\nfrom .tester import *", "from .trainer import *\nfrom .tester import *\nfrom .model.neural_network import *\nfrom .tasks import *\n\nmodule_dir = os.path.dirname(__file__) + \"/\"  # path to this file\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s [%(name)-13.13s] [%(levelname)-5.5s]  %(message)s\",", "    level=logging.INFO,\n    format=\"%(asctime)s [%(name)-13.13s] [%(levelname)-5.5s]  %(message)s\",\n    filename=module_dir + \"../experiments/nninfo.log\",\n    filemode=\"a\",\n)\nlogging.getLogger(\"nninfo\").info(\"STARTUP NNINFO SESSION\")\n"]}
{"filename": "nninfo/utils.py", "chunked_list": ["import shutil\n\nfrom .experiment import Experiment\n\n\ndef remove_experiment(experiment_id, yes=False, silent=False):\n    \"\"\"\n    Removes an experiment from the database.\n\n    Args:\n        experiment_id (str): id of the experiment to be removed\n        yes (bool): if True, no confirmation is asked\n        silent (bool): if True, no error is raised if experiment does not exist\n    \"\"\"\n    experiment_dir = Experiment._find_experiment_dir(experiment_id)\n\n    if not experiment_dir.exists():\n        if silent:\n            print(\n                f'Experiment {experiment_id} does not exist at path {experiment_dir}. Skipping removal.')\n            return\n        raise ValueError(\n            f'Experiment {experiment_id} does not exist at path {experiment_dir}.')\n\n    if not yes:\n        print(\n            f'Are you sure you want to remove experiment {experiment_id} at path {experiment_dir}? (y/n)')\n        answer = input()\n        if answer != 'y':\n            return\n\n    # Recursively remove experiment directory\n    shutil.rmtree(experiment_dir)\n\n    print(f'Removed experiment {experiment_id} from database.')", ""]}
{"filename": "nninfo/tester.py", "chunked_list": ["import torch\nfrom torch.utils.data import DataLoader\n\nfrom nninfo.exp_comp import ExperimentComponent\nfrom nninfo.model.quantization import quantizer_list_factory\n\n\nclass Tester(ExperimentComponent):\n    \"\"\"\n    Is called after each training chapter to perform predefined tests and save their results.\n    Args:\n        dataset_name (str): Name of the dataset in the TaskManagers dataset\n            dict that should be tested on.\n    \"\"\"\n\n    BATCH_SIZE = 10_000\n\n    def __init__(self, dataset_name):\n        super().__init__()\n        self._dataset_name = dataset_name\n        self._net = None\n        self._task = None\n\n    @staticmethod\n    def from_config(config):\n        return Tester(config[\"dataset_name\"])\n\n    def to_config(self):\n        return {\"dataset_name\": self._dataset_name}\n\n    def _get_output_activations(self, dataset_name=None, quantizer_params=None, quantizer=None):\n        self._net = self.parent.network\n        self._task = self.parent.task\n\n        if quantizer is None:\n            quantizer = quantizer_list_factory(\n                quantizer_params, self._net.get_limits_list())\n\n        self._net.eval()\n        if dataset_name is None:\n            dataset_name = self._dataset_name\n        feeder = DataLoader(\n            self._task[dataset_name], batch_size=self.BATCH_SIZE\n        )\n        with torch.no_grad():\n            for x_test, y_test in feeder:\n                yield self._net.forward(x_test, quantizer, apply_output_softmax=True), y_test\n\n    def compute_loss_and_accuracy(self, dataset_name=None, quantizer_params=None, quantizer=None):\n\n        activations_iter = self._get_output_activations(\n            dataset_name, quantizer_params, quantizer)\n\n        loss_fn = self.parent.trainer.loss\n\n        total_size = 0\n        correct = 0\n        test_loss = 0\n        for pred_y_test, y_test in activations_iter:\n\n            # Compute loss\n            loss = loss_fn(pred_y_test, y_test)\n            test_loss += loss.item() * pred_y_test.shape[0]\n\n            # Compute accuracy\n            if self.parent.task.task.y_dim > 1 and y_test.ndim == 1:\n                # One-hot-representation\n                decision = pred_y_test.argmax(dim=1)\n                correct += (decision == y_test).sum().item()\n            else:\n                # Binary output representations\n                decision = torch.round(pred_y_test)\n                correct += torch.all(decision == y_test, axis=1).sum().item()\n\n            total_size += pred_y_test.shape[0]\n\n        loss = test_loss / total_size\n        accuracy = correct / total_size\n\n        return loss, accuracy", ""]}
{"filename": "nninfo/schedule.py", "chunked_list": ["\nimport numpy as np\n\nimport nninfo\n\n\nclass Schedule:\n    \"\"\"\n    Can create epoch lists for preplanned experiment chapters. These chapters are the main\n    structure of the training period of the experiment and allow for spaced saving of\n    checkpoints.\n\n    The plan is to end a chapter of the experiment when a epoch contained in the chapter_ends\n    variable of this class is reached. This is not applied yet, but the class\n    is already able to create log spaced and lin spaced numbers of epochs,\n    which should then help with the actual experiment run. However, for the log-spaced chapter\n    planning, the number of chapter_ends can be lower than the number of chapters that are\n    given as n_chapter_wished.\n\n    Does not need to inherit from ExperimentComponent, because it is not calling anything else.\n    \"\"\"\n\n    def __init__(self):\n        self.chapter_ends = None\n        self.chapter_ends_continued = None\n\n    @staticmethod\n    def from_config(config):\n        \"\"\"\n        Creates a Schedule object from a config dictionary.\n\n        Args:\n            config (dict): Dictionary containing the config for the Schedule object.\n\n        Returns:\n            Schedule object.\n        \"\"\"\n\n        schedule = Schedule()\n        schedule.chapter_ends = config[\"chapter_ends\"]\n        schedule.chapter_ends_continued = config[\"chapter_ends_continued\"]\n        return schedule\n\n    def to_config(self):\n        \"\"\"\n        Creates a config dictionary from the Schedule object.\n\n        Returns:\n            Dictionary containing the config for the Schedule object.\n        \"\"\"\n\n        config = {\n            \"chapter_ends\": self.chapter_ends,\n            \"chapter_ends_continued\": self.chapter_ends_continued,\n        }\n        return config\n\n    def create_log_spaced_chapters(self, n_epochs, n_chapters_wished):\n        \"\"\"\n        Function that creates a list of numbers which are the epoch indices where chapters\n        are ended. The indices are created logarithmically spaced over the total number of\n        epochs for this experiment (n_epochs).\n\n        Args:\n            n_epochs (int): Total number of epochs for this experiment.\n            n_chapters_wished (int): Number of chapters the experiment should take to reach the\n                total number of epochs n_epochs.\n\n        Sets self.chapter_ends to a list of these indices (int).\n\n        Sets self.chapter_ends_continued to a list of a continued of chapter_ends\n        until n_epochs*n_epochs (int).\n        \"\"\"\n\n        def log_space(n_e, n_c):\n            end = np.log10(n_e)\n            epochs = np.logspace(0, end, n_c + 1, endpoint=True)\n            epochs = np.round(epochs).astype(int)\n            epochs = np.unique(epochs)\n            # add a 0 in the front for consistency\n            epochs = np.insert(epochs, 0, 0)\n            return epochs\n\n        self.chapter_ends = log_space(n_epochs, n_chapters_wished).tolist()\n        self.chapter_ends_continued = log_space(\n            n_epochs * n_epochs, n_chapters_wished * 2\n        ).tolist()\n\n    def create_lin_spaced_chapters(self, n_epochs, n_chapters_wished):\n        \"\"\"\n        Function that creates a list of numbers, which are the epoch indices where chapters\n        are ended. The indices are created linearly spaced over the total number of\n        epochs for this experiment (n_epochs).\n\n        Args:\n            n_epochs (int): Total number of epochs for this experiment.\n            n_chapters_wished (int): Number of chapters the experiment should take to reach the\n                total number of epochs n_epochs.\n\n        Sets self.chapter_ends to a list of these indices (int).\n\n        Sets self.chapter_ends_continued to a list of a continued of chapter_ends\n        until n_epochs*100 (int).\n        \"\"\"\n\n        def lin_space(n_e, n_c):\n            epochs = np.linspace(0, n_e, n_c + 1, endpoint=True)\n            epochs = np.round(epochs).astype(int)\n            epochs = np.unique(epochs)\n            return epochs\n\n        self.chapter_ends = lin_space(n_epochs, n_chapters_wished).tolist()\n        self.chapter_ends_continued = lin_space(\n            n_epochs * 100, n_chapters_wished * 100\n        ).tolist()\n\n    def get_epoch_for_chapter(self, chapter):\n        \"\"\"\n        Returns the epoch index for a given chapter index.\n\n        Args:\n            chapter (int): Index of the chapter.\n\n        Returns:\n            Epoch index (int).\n        \"\"\"\n\n        return self.chapter_ends_continued[chapter]\n\n    def save(self, path):\n        saver = nninfo.file_io.FileManager(path, write=True)\n        save_dict = {\n            \"chapter_ends\": self.chapter_ends,\n            \"chapter_ends_continued\": self.chapter_ends_continued,\n        }\n        saver.write(save_dict, \"schedule.json\")\n\n    def _load(self, path):\n        loader = nninfo.file_io.FileManager(path, read=True)\n        load_dict = loader.read(\"schedule.json\")\n        self.chapter_ends = load_dict[\"chapter_ends\"]\n        self.chapter_ends_continued = load_dict[\"chapter_ends_continued\"]\n\n    def __str__(self):\n        return str(self.chapter_ends)", ""]}
{"filename": "nninfo/trainer.py", "chunked_list": ["from typing import Optional\nimport numpy as np\nfrom torch.utils.data import DataLoader\nimport torch.optim as optim\nimport torch.nn as nn\n\nimport nninfo\nfrom nninfo.config import CLUSTER_MODE\nfrom nninfo.exp_comp import ExperimentComponent\nfrom nninfo.model.quantization import quantizer_list_factory", "from nninfo.exp_comp import ExperimentComponent\nfrom nninfo.model.quantization import quantizer_list_factory\n\nlog = nninfo.logger.get_logger(__name__)\n\n# optimizers for pytorch\nOPTIMIZERS_PYTORCH = {\"SGD\": optim.SGD, \"Adam\": optim.Adam}\n\n# the losses that are available at the moment\nLOSSES_PYTORCH = {", "# the losses that are available at the moment\nLOSSES_PYTORCH = {\n    \"BCELoss\": nn.BCELoss,\n    \"CELoss\": nn.CrossEntropyLoss,\n    \"MSELoss\": nn.MSELoss,\n}\n\n\nclass Trainer(ExperimentComponent):\n    \"\"\"\n    Trains the network using chapter structure.\n    Define your training settings here.\n    \"\"\"\n\n    def __init__(\n        self,\n        dataset_name,\n        optim_str,\n        loss_str,\n        lr,\n        shuffle,\n        batch_size,\n        quantizer,\n        momentum=0\n    ):\n        \"\"\"\n        Sets training parameters. Is also called when loading parameters from file.\n        Args:\n            dataset_name (str): Name of the dataset in the TaskManagers dataset\n                dict that should be trained on.\n            optim_str (str): One of the optimizers available in constant OPTIMIZERS_PYTORCH.\n                It is easy to add new ones, if necessary, since most commonly used ones are\n                already implemented in pytorch.\n            loss_str (str): One of the losses available in LOSSES_PYTORCH.\n                It is easy to add new ones, if necessary, since most commonly used ones are\n                already implemented in pytorch.\n            lr (float): The learning rate that should be used for the training.\n            shuffle (bool): Whether to shuffle\n            batch_size (int): Number of samples from the dataset that should be used together\n                as a batch for one training step, for example in (Batch) Stochastic Gradient\n                Descent.\n            n_epochs_chapter (int): If the number of epochs per chapter is a constant it can\n                be also set here. Otherwise it must be passed each time train_chapter is\n                called.\n        \"\"\"\n\n        self._dataset_name = dataset_name\n        self._lr = lr\n        self._batch_size = batch_size\n        self._optim_str = optim_str\n        self._loss_str = loss_str\n        self._shuffle = shuffle\n        self._quantizer_params = quantizer\n        self._momentum = momentum\n\n        self._n_epochs_trained = 0\n        self._n_chapters_trained = 0\n\n        super().__init__()\n\n    @staticmethod\n    def from_config(config):\n        trainer = Trainer(\n            dataset_name=config[\"dataset_name\"],\n            optim_str=config[\"optim_str\"],\n            loss_str=config[\"loss_str\"],\n            lr=config[\"lr\"],\n            shuffle=config[\"shuffle\"],\n            batch_size=config[\"batch_size\"],\n            quantizer=config.get(\"quantizer\", None),\n            momentum=config.get(\"momentum\", 0)\n        )\n\n        return trainer\n\n    def to_config(self):\n        param_dict = {\n            \"dataset_name\": self._dataset_name,\n            \"optim_str\": self._optim_str,\n            \"batch_size\": self._batch_size,\n            \"shuffle\": self._shuffle,\n            \"lr\": self._lr,\n            \"loss_str\": self._loss_str,\n            \"n_epochs_trained\": self._n_epochs_trained,\n            \"n_chapters_trained\": self._n_chapters_trained,\n            \"quantizer\": self._quantizer_params,\n            \"momentum\": self._momentum\n        }\n\n        return param_dict\n\n    @property\n    def loss(self):\n        return self._loss\n\n    @property\n    def lr(self):\n        return self._lr\n\n    @property\n    def n_epochs_trained(self):\n        return self._n_epochs_trained\n\n    @property\n    def n_chapters_trained(self):\n        return self._n_chapters_trained\n\n    def set_n_epochs_trained(self, n_epochs_trained):\n        \"\"\"\n        Sets the number of epochs trained to a new value.\n        Should not be called by user, only by experiment.\n        \"\"\"\n        log.info(\"n_epochs_trained is changed from outside.\")\n        self._n_epochs_trained = n_epochs_trained\n\n    def set_n_chapters_trained(self, n_chapters_trained):\n        \"\"\"\n        Sets the number of epochs trained to a new value.\n        Should not be called by user, only by experiment.\n        \"\"\"\n        log.info(\"n_chapters_trained is changed from outside.\")\n        self._n_chapters_trained = n_chapters_trained\n\n    def optimizer_state_dict(self):\n        return self._optimizer.state_dict()\n\n    def load_optimizer_state_dict(self, opt_state_dict):\n        self._optimizer.load_state_dict(opt_state_dict)\n\n    def train_chapter(\n        self, use_cuda, use_ipex, n_epochs_chapter=None, compute_test_loss=Optional[bool]\n    ):\n        \"\"\"\n        Perform the training steps for a given number of epochs. If no n_epochs_chapter is given\n        it is expected to have already been set in set_training_parameters(..).\n        Args:\n            n_epochs_chapter (int):    Number of epochs to train for this chapter of the training.\n            compute_test_loss (bool):  Whether to compute the test loss after each epoch. When None is passed,\n                                        it is set to not CLUSTER_MODE.\n        \"\"\"\n\n        if compute_test_loss is None:\n            compute_test_loss = not CLUSTER_MODE\n\n        # make experiment components ready for training\n        self._start_chapter(use_ipex)\n        # set model to train mode\n        self._net.train()\n\n        if use_cuda and not next(self._net.parameters()).is_cuda:\n            print('Moving model to CUDA')\n            self._net.cuda()\n\n        # create a DataLoader that then feeds the chosen dataset into the network during training\n        feeder = DataLoader(\n            self._task[self._dataset_name],\n            batch_size=self._batch_size,\n            shuffle=self._shuffle,\n        )\n\n        # central training loop\n        for _ in range(n_epochs_chapter):\n            full_loss = 0\n\n            for local_x_batch, local_y_batch in feeder:\n\n                if use_cuda:\n                    local_x_batch = local_x_batch.cuda()\n                    local_y_batch = local_y_batch.cuda()\n\n                # zeroes the gradient buffers of all parameters\n                self._optimizer.zero_grad()\n\n                self._net.train()\n                pred_y = self._net(local_x_batch, quantizers=self._quantizer)\n                loss = self._loss(pred_y, local_y_batch)\n                loss.backward()\n\n                self._optimizer.step()\n                full_loss += loss.cpu().item() * len(local_y_batch)\n            self._n_epochs_trained += 1\n            print_str = (\n                \"trained epoch: \"\n                + str(self._n_epochs_trained)\n                + \"; train loss: \"\n                + str(np.sum(full_loss) / len(feeder.dataset))\n                + (f\"; test loss: {self._tester.compute_loss_and_accuracy(quantizer=self._quantizer)[0]}\" if compute_test_loss else \"\")\n            )\n            print(print_str)\n            log.info(print_str)\n        self._end_chapter()\n\n    def _start_chapter(self, use_ipex=False):\n\n        first_overall_epoch = self._n_epochs_trained == 0 and self.parent.run_id == 0\n        first_epoch_in_run = self._n_epochs_trained == 0\n        if first_overall_epoch:\n            self.initialize_components(use_ipex)\n            self.parent.save_components()\n        if first_epoch_in_run:\n            self.parent.save_checkpoint()\n\n        log.info(\"Started training chapter {}.\".format(self._n_chapters_trained + 1))\n\n    def initialize_components(self, use_ipex=False):\n\n        self._net = self.parent.network\n        if self._optim_str == \"SGD\":\n            self._optimizer = OPTIMIZERS_PYTORCH[self._optim_str](\n                self._net.parameters(), lr=self._lr, momentum=self._momentum\n            )\n        else:\n            self._optimizer = OPTIMIZERS_PYTORCH[self._optim_str](\n                self._net.parameters(), lr=self._lr\n            )\n        self._loss = LOSSES_PYTORCH[self._loss_str]()\n        self._task = self.parent.task\n        self._tester = self.parent.tester\n        self._quantizer = quantizer_list_factory(self._quantizer_params, self.parent.network.get_limits_list())\n\n        if use_ipex:\n            import intel_extension_for_pytorch as ipex # type: ignore\n            self._net, self._optimizer = ipex.optimize(self._net, optimizer=self._optimizer)\n\n    def _end_chapter(self):\n        self._n_chapters_trained += 1\n        log.info(\"Finished training chapter {}.\".format(self._n_chapters_trained))\n        print(\"Finished training chapter {}.\".format(self._n_chapters_trained))\n        self.parent.save_checkpoint()", "class Trainer(ExperimentComponent):\n    \"\"\"\n    Trains the network using chapter structure.\n    Define your training settings here.\n    \"\"\"\n\n    def __init__(\n        self,\n        dataset_name,\n        optim_str,\n        loss_str,\n        lr,\n        shuffle,\n        batch_size,\n        quantizer,\n        momentum=0\n    ):\n        \"\"\"\n        Sets training parameters. Is also called when loading parameters from file.\n        Args:\n            dataset_name (str): Name of the dataset in the TaskManagers dataset\n                dict that should be trained on.\n            optim_str (str): One of the optimizers available in constant OPTIMIZERS_PYTORCH.\n                It is easy to add new ones, if necessary, since most commonly used ones are\n                already implemented in pytorch.\n            loss_str (str): One of the losses available in LOSSES_PYTORCH.\n                It is easy to add new ones, if necessary, since most commonly used ones are\n                already implemented in pytorch.\n            lr (float): The learning rate that should be used for the training.\n            shuffle (bool): Whether to shuffle\n            batch_size (int): Number of samples from the dataset that should be used together\n                as a batch for one training step, for example in (Batch) Stochastic Gradient\n                Descent.\n            n_epochs_chapter (int): If the number of epochs per chapter is a constant it can\n                be also set here. Otherwise it must be passed each time train_chapter is\n                called.\n        \"\"\"\n\n        self._dataset_name = dataset_name\n        self._lr = lr\n        self._batch_size = batch_size\n        self._optim_str = optim_str\n        self._loss_str = loss_str\n        self._shuffle = shuffle\n        self._quantizer_params = quantizer\n        self._momentum = momentum\n\n        self._n_epochs_trained = 0\n        self._n_chapters_trained = 0\n\n        super().__init__()\n\n    @staticmethod\n    def from_config(config):\n        trainer = Trainer(\n            dataset_name=config[\"dataset_name\"],\n            optim_str=config[\"optim_str\"],\n            loss_str=config[\"loss_str\"],\n            lr=config[\"lr\"],\n            shuffle=config[\"shuffle\"],\n            batch_size=config[\"batch_size\"],\n            quantizer=config.get(\"quantizer\", None),\n            momentum=config.get(\"momentum\", 0)\n        )\n\n        return trainer\n\n    def to_config(self):\n        param_dict = {\n            \"dataset_name\": self._dataset_name,\n            \"optim_str\": self._optim_str,\n            \"batch_size\": self._batch_size,\n            \"shuffle\": self._shuffle,\n            \"lr\": self._lr,\n            \"loss_str\": self._loss_str,\n            \"n_epochs_trained\": self._n_epochs_trained,\n            \"n_chapters_trained\": self._n_chapters_trained,\n            \"quantizer\": self._quantizer_params,\n            \"momentum\": self._momentum\n        }\n\n        return param_dict\n\n    @property\n    def loss(self):\n        return self._loss\n\n    @property\n    def lr(self):\n        return self._lr\n\n    @property\n    def n_epochs_trained(self):\n        return self._n_epochs_trained\n\n    @property\n    def n_chapters_trained(self):\n        return self._n_chapters_trained\n\n    def set_n_epochs_trained(self, n_epochs_trained):\n        \"\"\"\n        Sets the number of epochs trained to a new value.\n        Should not be called by user, only by experiment.\n        \"\"\"\n        log.info(\"n_epochs_trained is changed from outside.\")\n        self._n_epochs_trained = n_epochs_trained\n\n    def set_n_chapters_trained(self, n_chapters_trained):\n        \"\"\"\n        Sets the number of epochs trained to a new value.\n        Should not be called by user, only by experiment.\n        \"\"\"\n        log.info(\"n_chapters_trained is changed from outside.\")\n        self._n_chapters_trained = n_chapters_trained\n\n    def optimizer_state_dict(self):\n        return self._optimizer.state_dict()\n\n    def load_optimizer_state_dict(self, opt_state_dict):\n        self._optimizer.load_state_dict(opt_state_dict)\n\n    def train_chapter(\n        self, use_cuda, use_ipex, n_epochs_chapter=None, compute_test_loss=Optional[bool]\n    ):\n        \"\"\"\n        Perform the training steps for a given number of epochs. If no n_epochs_chapter is given\n        it is expected to have already been set in set_training_parameters(..).\n        Args:\n            n_epochs_chapter (int):    Number of epochs to train for this chapter of the training.\n            compute_test_loss (bool):  Whether to compute the test loss after each epoch. When None is passed,\n                                        it is set to not CLUSTER_MODE.\n        \"\"\"\n\n        if compute_test_loss is None:\n            compute_test_loss = not CLUSTER_MODE\n\n        # make experiment components ready for training\n        self._start_chapter(use_ipex)\n        # set model to train mode\n        self._net.train()\n\n        if use_cuda and not next(self._net.parameters()).is_cuda:\n            print('Moving model to CUDA')\n            self._net.cuda()\n\n        # create a DataLoader that then feeds the chosen dataset into the network during training\n        feeder = DataLoader(\n            self._task[self._dataset_name],\n            batch_size=self._batch_size,\n            shuffle=self._shuffle,\n        )\n\n        # central training loop\n        for _ in range(n_epochs_chapter):\n            full_loss = 0\n\n            for local_x_batch, local_y_batch in feeder:\n\n                if use_cuda:\n                    local_x_batch = local_x_batch.cuda()\n                    local_y_batch = local_y_batch.cuda()\n\n                # zeroes the gradient buffers of all parameters\n                self._optimizer.zero_grad()\n\n                self._net.train()\n                pred_y = self._net(local_x_batch, quantizers=self._quantizer)\n                loss = self._loss(pred_y, local_y_batch)\n                loss.backward()\n\n                self._optimizer.step()\n                full_loss += loss.cpu().item() * len(local_y_batch)\n            self._n_epochs_trained += 1\n            print_str = (\n                \"trained epoch: \"\n                + str(self._n_epochs_trained)\n                + \"; train loss: \"\n                + str(np.sum(full_loss) / len(feeder.dataset))\n                + (f\"; test loss: {self._tester.compute_loss_and_accuracy(quantizer=self._quantizer)[0]}\" if compute_test_loss else \"\")\n            )\n            print(print_str)\n            log.info(print_str)\n        self._end_chapter()\n\n    def _start_chapter(self, use_ipex=False):\n\n        first_overall_epoch = self._n_epochs_trained == 0 and self.parent.run_id == 0\n        first_epoch_in_run = self._n_epochs_trained == 0\n        if first_overall_epoch:\n            self.initialize_components(use_ipex)\n            self.parent.save_components()\n        if first_epoch_in_run:\n            self.parent.save_checkpoint()\n\n        log.info(\"Started training chapter {}.\".format(self._n_chapters_trained + 1))\n\n    def initialize_components(self, use_ipex=False):\n\n        self._net = self.parent.network\n        if self._optim_str == \"SGD\":\n            self._optimizer = OPTIMIZERS_PYTORCH[self._optim_str](\n                self._net.parameters(), lr=self._lr, momentum=self._momentum\n            )\n        else:\n            self._optimizer = OPTIMIZERS_PYTORCH[self._optim_str](\n                self._net.parameters(), lr=self._lr\n            )\n        self._loss = LOSSES_PYTORCH[self._loss_str]()\n        self._task = self.parent.task\n        self._tester = self.parent.tester\n        self._quantizer = quantizer_list_factory(self._quantizer_params, self.parent.network.get_limits_list())\n\n        if use_ipex:\n            import intel_extension_for_pytorch as ipex # type: ignore\n            self._net, self._optimizer = ipex.optimize(self._net, optimizer=self._optimizer)\n\n    def _end_chapter(self):\n        self._n_chapters_trained += 1\n        log.info(\"Finished training chapter {}.\".format(self._n_chapters_trained))\n        print(\"Finished training chapter {}.\".format(self._n_chapters_trained))\n        self.parent.save_checkpoint()"]}
{"filename": "nninfo/postprocessing/pid_postprocessing.py", "chunked_list": ["from ast import literal_eval\nfrom itertools import chain, combinations\n\nimport pandas as pd\n\n\nclass Antichain:\n\n    def __init__(self, antichain_string):\n        self._antichain_tuple = literal_eval(antichain_string)\n\n        assert isinstance(self._antichain_tuple, tuple)\n        assert all(isinstance(a, tuple) for a in self._antichain_tuple)\n        assert all(isinstance(l, int)\n                   for a in self._antichain_tuple for l in a)\n\n    def degree_of_synergy(self):\n        return min(len(a) for a in self._antichain_tuple)\n    \n    def max_index(self):\n        return max(max(a) for a in self._antichain_tuple)\n\n    def __len__(self):\n        return len(self._antichain_tuple)\n\n    def __iter__(self):\n        return iter(self._antichain_tuple)", "\n\ndef _compute_degree_of_synergy_atoms(pid: pd.DataFrame):\n\n    degrees_of_synergy = [Antichain(antichain_string).degree_of_synergy()\n                          for antichain_string in pid.columns]\n    degree_of_synergy_atoms = pid.groupby(\n        degrees_of_synergy, axis=1).sum()\n\n    return degree_of_synergy_atoms", "\n\ndef _compute_mutual_information(pid: pd.DataFrame):\n\n    mutual_information = pid.sum(axis=1)\n    mutual_information.name = ''\n\n    return mutual_information\n\n\ndef _compute_representational_complexity(degree_of_synergy_atoms: pd.DataFrame, mutual_information: pd.DataFrame):\n\n    repr_compl = (degree_of_synergy_atoms *\n                  degree_of_synergy_atoms.columns).sum(axis=1) / mutual_information\n    repr_compl.name = ''\n\n    return repr_compl", "\n\ndef _compute_representational_complexity(degree_of_synergy_atoms: pd.DataFrame, mutual_information: pd.DataFrame):\n\n    repr_compl = (degree_of_synergy_atoms *\n                  degree_of_synergy_atoms.columns).sum(axis=1) / mutual_information\n    repr_compl.name = ''\n\n    return repr_compl\n", "\n\ndef get_pid_summary_quantities(pid: pd.DataFrame, pid_part: str = 'avg_pid'):\n    \"\"\"\n    Compute summary quantities of a PID DataFrame.\n    \"\"\"\n\n    # Select the part of the PID to be used\n    pid_part = pid[pid_part]\n\n    degree_of_synergy_atoms = _compute_degree_of_synergy_atoms(pid_part)\n    mutual_information = _compute_mutual_information(pid_part)\n\n    repr_compl = _compute_representational_complexity(\n        degree_of_synergy_atoms, mutual_information)\n\n    # Combine into a DataFrame with a MultiIndex including run_id, chapter_id and epoch_id\n\n    summary_quantities = degree_of_synergy_atoms\n    summary_quantities.columns = pd.MultiIndex.from_arrays(\n        [['degree_of_synergy_atoms'] * len(degree_of_synergy_atoms.columns), degree_of_synergy_atoms.columns])\n    summary_quantities['mutual_information'] = mutual_information\n    summary_quantities['representational_complexity'] = repr_compl\n    summary_quantities['run_id'] = pid['run_id']\n    summary_quantities['chapter_id'] = pid['chapter_id']\n    summary_quantities['epoch_id'] = pid['epoch_id']\n\n    return summary_quantities", "\n\ndef _powerset(iterable):\n    \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n\n\ndef get_mi_or_entropy(pid: pd.DataFrame, pid_part: str = 'avg_pid'):\n\n    n = max(Antichain(antichain_string).max_index()\n            for antichain_string in pid.avg_pid.columns)\n\n    pid_part = pid[pid_part]\n    source_sets = list(_powerset(range(1, n + 1)))[1:]\n\n    df_entropies = pd.DataFrame()\n    for source_set in source_sets:\n        H = pd.Series(0, index=pid_part.index)\n        for achain_str in pid_part.columns:\n            achain = Antichain(achain_str)\n            for a in achain:\n                if set(a).issubset(source_set):\n                    H += pid_part[achain_str]\n                    break\n        df_entropies[str(source_set)] = H\n    return df_entropies", "def get_mi_or_entropy(pid: pd.DataFrame, pid_part: str = 'avg_pid'):\n\n    n = max(Antichain(antichain_string).max_index()\n            for antichain_string in pid.avg_pid.columns)\n\n    pid_part = pid[pid_part]\n    source_sets = list(_powerset(range(1, n + 1)))[1:]\n\n    df_entropies = pd.DataFrame()\n    for source_set in source_sets:\n        H = pd.Series(0, index=pid_part.index)\n        for achain_str in pid_part.columns:\n            achain = Antichain(achain_str)\n            for a in achain:\n                if set(a).issubset(source_set):\n                    H += pid_part[achain_str]\n                    break\n        df_entropies[str(source_set)] = H\n    return df_entropies"]}
{"filename": "nninfo/postprocessing/reing_postprocessing.py", "chunked_list": ["import pandas as pd\n\ndef get_directed_reing_complexity(reing_differences: pd.DataFrame):\n    n = sum(reing_differences.columns.str.match(r'C\\(\\d+\\|\\|\\d+\\)'))\n\n    complexity = pd.DataFrame()\n    complexity['run_id'] = reing_differences['run_id']\n    complexity['chapter_id'] = reing_differences['chapter_id']\n    complexity['epoch_id'] = reing_differences['epoch_id']\n    complexity['reing_complexity'] = sum(k * reing_differences[f'C({k}||{k+1})'] for k in range(1, n)) / sum(reing_differences[f'C({k}||{k+1})'] for k in range(1, n))\n    return complexity"]}
{"filename": "nninfo/model/quantization.py", "chunked_list": ["from abc import abstractmethod, ABC\nfrom dataclasses import dataclass\nfrom typing import Union, Tuple, List\n\nimport numpy as np\nimport torch\n\nLimits = Union[Tuple[float, float], str]\n\n@dataclass\nclass Quantizer(ABC):\n    \"\"\"\n        n_levels: Number of equidistant quantization levels\n    \"\"\"\n\n    n_levels: int\n    limits: Limits\n\n    @abstractmethod\n    def __call__(self, x: torch.Tensor):\n        pass", "\n@dataclass\nclass Quantizer(ABC):\n    \"\"\"\n        n_levels: Number of equidistant quantization levels\n    \"\"\"\n\n    n_levels: int\n    limits: Limits\n\n    @abstractmethod\n    def __call__(self, x: torch.Tensor):\n        pass", "\n\n@dataclass\nclass StochasticQuantizer(Quantizer):\n    \"\"\"Stochastically rounds either up or down to the nearest Q3 quantization level.\n    The probability of rounding up is proportional to the normalized remainder.\n    \"\"\"\n\n    def __post_init__(self):\n\n        # Make sure the limits are finite\n        assert np.isfinite(self.limits[0]) and np.isfinite(\n            self.limits[1]), f\"Quantization limits are not finite {self.limits}\"\n\n        self.scale = (self.limits[1] - self.limits[0]) / (self.n_levels - 1)\n\n    def __call__(self, x: torch.Tensor):\n\n\n        # Make sure all activations are within the limits\n        assert torch.all(x >= self.limits[0]) and torch.all(\n            x <= self.limits[1]), f\"Activations are not within the limits {self.limits}\"\n\n        x_normalized = (x - self.limits[0]) / self.scale\n\n        ceil_prob = torch.remainder(x_normalized, 1)\n        ceil_mask = torch.bernoulli(ceil_prob)\n\n        floored = FloorNoGradient.apply(\n            x_normalized) * self.scale + self.limits[0]\n        ceiled = CeilNoGradient.apply(\n            x_normalized) * self.scale + self.limits[0]\n\n        return torch.where(ceil_mask == 1, ceiled, floored)", "\n@dataclass\nclass Q3Quantizer(Quantizer):\n    \"\"\"The two outmost bins are only half the width than the others and round to the binning limits.\"\"\"\n\n    def __post_init__(self):\n\n        # Make sure the limits are finite\n        assert np.isfinite(self.limits[0]) and np.isfinite(\n            self.limits[1]), f\"Quantization limits are not finite {self.limits}\"\n\n        self.scale = (self.limits[1] - self.limits[0]) / (self.n_levels - 1)\n\n    def __call__(self, x: torch.Tensor):\n\n        # Make sure all activations are within the limits\n        assert torch.all(x >= self.limits[0]) and torch.all(\n            x <= self.limits[1]), f\"Activations are not within the limits {self.limits}\"\n\n        return torch.round((x - self.limits[0]) / self.scale) * self.scale + self.limits[0]", "\n\nclass CeilNoGradient(torch.autograd.Function):\n    @staticmethod\n    def forward(ctx, x):\n        return x.ceil()\n\n    @staticmethod\n    def backward(ctx, g):\n        return g", "\n\nclass FloorNoGradient(torch.autograd.Function):\n    @staticmethod\n    def forward(ctx, x):\n        return x.floor()\n\n    @staticmethod\n    def backward(ctx, g):\n        return g", "\n\ndef quantizer_factory(rounding_point: str, levels: int, limits: Limits) -> Quantizer:\n    if rounding_point == \"stochastic\":\n        return StochasticQuantizer(levels, limits)\n    elif rounding_point == \"center_saturating\":\n        return Q3Quantizer(levels, limits)\n    else:\n        raise NotImplementedError(\n            f'No quantizer with rounding point {rounding_point} is available.')", "\n\ndef quantizer_list_factory(quantizer_params: Union[None, dict, list], limits: List[Limits]) -> List[Quantizer]:\n\n    if quantizer_params is None:\n        return [lambda x: x] * len(limits)\n\n    if isinstance(quantizer_params, dict):\n        quantizer_param_list = [quantizer_params] * len(limits)\n    elif isinstance(quantizer_params, list):\n        quantizer_param_list = quantizer_params\n\n    return [(quantizer_factory(**params, limits=limits) if params is not None else (lambda x: x)) for params, limits in zip(quantizer_param_list, limits)]", "\n"]}
{"filename": "nninfo/model/neural_network.py", "chunked_list": ["import copy\nfrom dataclasses import dataclass, field\nfrom functools import cache\nfrom typing import Optional, Union, Tuple, List\nfrom ast import literal_eval\n\nimport torch.nn as nn\nimport torch\nimport numpy as np\nimport scipy as scp", "import numpy as np\nimport scipy as scp\nimport yaml\n\nimport nninfo\nfrom ..file_io import NoAliasDumper\nfrom .quantization import quantizer_list_factory\n\nLimits = Union[Tuple[float, float], str]\n\nclass RandomRotation(nn.Module):\n\n    def __init__(self, dim, rng_seed):\n        super(RandomRotation, self).__init__()\n        self.dim = dim\n        self.rng_seed = rng_seed\n\n        rng = np.random.default_rng(self.rng_seed)\n        self.rotation_matrix = torch.tensor(scp.stats.special_ortho_group.rvs(dim, random_state=rng), dtype=torch.float32)\n\n    def forward(self, x):\n        return torch.matmul(x, self.rotation_matrix)", "Limits = Union[Tuple[float, float], str]\n\nclass RandomRotation(nn.Module):\n\n    def __init__(self, dim, rng_seed):\n        super(RandomRotation, self).__init__()\n        self.dim = dim\n        self.rng_seed = rng_seed\n\n        rng = np.random.default_rng(self.rng_seed)\n        self.rotation_matrix = torch.tensor(scp.stats.special_ortho_group.rvs(dim, random_state=rng), dtype=torch.float32)\n\n    def forward(self, x):\n        return torch.matmul(x, self.rotation_matrix)", "\nCONNECTION_LAYERS_PYTORCH = {\n    \"input\": lambda: (lambda x: x),\n    \"identity\": lambda: (lambda x: x),\n    \"linear\": nn.Linear,\n    \"dropout\": nn.Dropout,\n    \"maxpool2d\": nn.MaxPool2d,\n    \"conv2d\": nn.Conv2d,\n    \"flatten\": nn.Flatten,\n    \"random_rotation\": RandomRotation,", "    \"flatten\": nn.Flatten,\n    \"random_rotation\": RandomRotation,\n}\n\nACTIV_FUNCS_PYTORCH = {\n    None: lambda: (lambda x: x),\n    \"input\": lambda: (lambda x:x),  \n    \"relu\": lambda: torch.relu,\n    \"tanh\": lambda: torch.tanh,\n    \"hardtanh\": lambda: nn.Hardtanh(),", "    \"tanh\": lambda: torch.tanh,\n    \"hardtanh\": lambda: nn.Hardtanh(),\n    \"sigmoid\": lambda: torch.sigmoid,\n    \"softmax\": lambda: torch.nn.functional.softmax,\n    \"log_softmax\": lambda: torch.nn.functional.log_softmax,\n    \"softmax_output\": lambda: (lambda x: x),\n}\n\nACTIV_FUNCS_BINNING_LIMITS = {\n    None: (-np.inf, np.inf),", "ACTIV_FUNCS_BINNING_LIMITS = {\n    None: (-np.inf, np.inf),\n    \"input\": None,\n    \"relu\": (0.0, np.inf),\n    \"tanh\": (-1.0, 1.0),\n    \"hardtanh\": (-1.0, 1.0),\n    \"sigmoid\": (0.0, 1.0),\n    \"softmax\": (0.0, 1.0),\n    \"log_softmax\": (-np.inf, 0.0),\n    \"softmax_output\": (0.0, 1.0),", "    \"log_softmax\": (-np.inf, 0.0),\n    \"softmax_output\": (0.0, 1.0),\n}\n\nINITIALIZERS_PYTORCH = {\n    \"xavier\": nn.init.xavier_uniform_,\n    \"he_kaiming\": nn.init.kaiming_uniform_,\n    \"he_kaiming_normal\": nn.init.kaiming_normal_,\n}\n", "}\n\n\n@dataclass\nclass LayerInfo:\n    \"\"\"A layer of a neural network.\n    \n        Consists of a connection layer and an activation function.\n    \"\"\"\n    \n    connection_layer: str\n    activation_function: str\n    connection_layer_kwargs: Optional[dict] = field(default_factory=dict)\n    activation_function_kwargs: Optional[dict] = field(default_factory=dict)\n\n    @staticmethod\n    def from_config(layer_dict):\n        return LayerInfo(\n            connection_layer=layer_dict[\"connection_layer\"],\n            connection_layer_kwargs=layer_dict[\"connection_layer_kwargs\"],\n            activation_function=layer_dict[\"activation_function\"],\n            activation_function_kwargs=layer_dict[\"activation_function_kwargs\"],\n        )\n    \n    def to_config(self):\n        return {\n            \"connection_layer\": self.connection_layer,\n            \"connection_layer_kwargs\": self.connection_layer_kwargs,\n            \"activation_function\": self.activation_function,\n            \"activation_function_kwargs\": self.activation_function_kwargs,\n        }", "    \n@dataclass(frozen=True)\nclass NeuronID():\n    \"\"\"Index of a neuron in a neural network.\n\n    Consists of a layer label and a neuron index.\n    The input layer is labeled \"X\", the output layer \"Y\",\n    and the hidden layers \"L1\", \"L2\", ...\n    \"\"\"\n    layer: str\n    index: Union[int, Tuple[int, ...]]\n\n    @staticmethod\n    def to_yaml(dumper, data):\n        # Dumps a NeuronID to a string in YAML.\n        return dumper.represent_scalar(\"!NeuronID\", f\"layer={data.layer}, index={data.index}\")\n        \n    @staticmethod\n    def from_yaml(loader, node):\n        # Loads a NeuronID from a string in YAML.\n        value = loader.construct_scalar(node)\n        layer=value.split(\"layer=\")[1].split(\",\")[0]\n        index=value.split(\"index=\")[1]\n        index=literal_eval(index)\n        return NeuronID(layer, index)", "    \nNoAliasDumper.add_representer(NeuronID, NeuronID.to_yaml)\nyaml.SafeLoader.add_constructor(\"!NeuronID\", NeuronID.from_yaml)\n\nclass NeuralNetwork(nninfo.exp_comp.ExperimentComponent, nn.Module):\n    \"\"\"\n    Model that is trained and analysed.\n\n    CUDA acceleration is not implemented yet, but will certainly be possible in the future.\n    \"\"\"\n\n    def __init__(\n            self,\n            layer_infos: List[LayerInfo],\n            init_str,\n            **kwargs\n    ):\n        \"\"\"\n        Creates a new instance of NeuralNetwork and sets all structural parameters of the model.\n\n        Important comment: the external indexing of the layers is 1,...,n for convenience.\n        However, I could not find a way to use this indexing also for the inner structure. Maybe\n        we might change that in the future to avoid errors.\n\n        Args:\n\n        Keyword Args:\n            noise_stddev (float): in case of a noisy neural network\n        \"\"\"\n        # call pytorch super class\n        super().__init__()\n\n        self._layer_infos = layer_infos\n        self._params = kwargs\n\n        self.n_layers = len(layer_infos)\n\n        self._connection_layers = []\n        self._activ_funcs = []\n        self._module_list = nn.ModuleList()\n\n        for layer_info in layer_infos:\n\n            try:\n                activation_function_factory = ACTIV_FUNCS_PYTORCH[layer_info.activation_function]\n            except KeyError:\n                raise ValueError(f\"Activation function {layer_info.activation_function} not supported.\")\n            \n            activation_function = activation_function_factory(**layer_info.activation_function_kwargs)\n\n            self._activ_funcs.append(activation_function)\n\n            try:\n                connection_layer_factory = CONNECTION_LAYERS_PYTORCH[layer_info.connection_layer]\n            except KeyError:\n                raise ValueError(f\"Connection layer {layer_info.connection_layer} not supported.\")\n            \n            connection_layer = connection_layer_factory(**layer_info.connection_layer_kwargs)\n\n            self._connection_layers.append(connection_layer)\n            if isinstance(connection_layer, nn.Module):\n                self._module_list.append(connection_layer)\n\n        self._initializer = None\n        self._init_str = init_str\n\n        self.init_weights()\n\n    @staticmethod\n    def from_config(config):\n        \"\"\"\n        Creates a NeuralNetwork instance from a config dictionary.\n\n        Args:\n            config (dict): Dictionary with all the necessary information to create a NeuralNetwork instance.\n\n        Returns:\n            NeuralNetwork: Instance of NeuralNetwork with the given configuration.\n        \"\"\"\n\n        config = config.copy()\n        net_type = config.pop(\"net_type\")\n\n\n        layer_configs = [LayerInfo.from_config(layer_info) for layer_info in config.pop(\"layers\")]\n\n        if net_type == \"feedforward\":\n            return NeuralNetwork(layer_configs, **config)\n        elif net_type == \"noisy_feedforward\":\n            return NoisyNeuralNetwork(layer_configs, **config)\n\n        raise KeyError(f\"Unknown network type '{net_type}'\")\n\n    def to_config(self):\n        \"\"\"\n        Is called when the experiment saves all its components at the beginning of an experiment.\n\n        Returns:\n            dict: Dictionary with all the network settings necessary to create the network again\n                for rerunning and later investigation.\n        \"\"\"\n        param_dict = {\n            \"layers\": [layer_info.to_config() for layer_info in self._layer_infos],\n            \"net_type\": \"feedforward\",\n            \"init_str\": self._init_str,\n        }\n\n        return copy.deepcopy(param_dict)\n    \n    @cache\n    def get_layer_sizes(self):\n        \"\"\"\n        Returns:\n            list of int: List of layer output sizes.\n        \"\"\"\n        shapes = [self.parent.task.x_dim]\n\n        for i in range(1, self.n_layers):\n\n            layer_info = self._layer_infos[i]\n\n            if \"out_features\" in layer_info.connection_layer_kwargs:\n                shapes.append(layer_info.connection_layer_kwargs[\"out_features\"])\n            elif \"out_channels\" in layer_info.connection_layer_kwargs:\n                shapes.append(layer_info.connection_layer_kwargs[\"out_channels\"])\n            else:\n                shapes.append(None)\n\n    def get_layer_structure_dict(self):\n        layer_dict = dict()\n        for i, size in enumerate(self.get_layer_sizes()):\n            if i == 0:\n                layer_label = \"X\"\n            else:\n                layer_label = \"L\" + str(i)\n            neuron_id_list = []\n            for n in range(size):\n                neuron_id_list.append(NeuronID(layer_label, n + 1))\n            layer_dict[layer_label] = neuron_id_list\n\n        layer_label = \"Y\"\n        neuron_id_list = []\n        for n in range(self.get_layer_sizes()[-1]):\n            neuron_id_list.append(NeuronID(layer_label, n + 1))\n        layer_dict[layer_label] = neuron_id_list\n        return layer_dict\n\n    def get_binning_limits(self):\n        \"\"\"\n        returns: {neuron_id -> (low, high) or \"binary\"}\n        \"\"\"\n        structure = self.get_layer_structure_dict()\n        limit_dict = dict()\n        for layer_label in structure:\n            for neuron_id in structure[layer_label]:\n                if layer_label == \"X\" or layer_label == \"Y\":\n                    limit_dict[neuron_id] = self.parent.task.get_binning_limits(\n                        layer_label\n                    )\n                elif layer_label.startswith(\"L\"):\n                    i = int(layer_label.lstrip(\"L\"))\n                    limit_dict[neuron_id] = ACTIV_FUNCS_BINNING_LIMITS[\n                        self._layer_infos[i].activation_function\n                    ]\n                else:\n                    raise NotImplementedError(\n                        \"Value \" + layer_label + \"not allowed for layer_label.\"\n                    )\n        return limit_dict\n\n    def get_limits_list(self) -> List[Limits]:\n        \"\"\"\n        Currently returns None for the input Limits\n        returns: [(low, high) or \"binary\"]\n        \"\"\"\n        return [ACTIV_FUNCS_BINNING_LIMITS[layer_info.activation_function] for layer_info in self._layer_infos]\n\n    def forward(self, x, quantizers, return_activations=False, apply_output_softmax=None):\n        \"\"\"\n\n        Forward pass for the network, given a batch.\n\n        Args:\n            x (torch tensor): batch from dataset to be fed into the network\n        Returns:\n            torch tensor: output of the network\n        \"\"\"\n\n        if apply_output_softmax is None:\n            apply_output_softmax = return_activations\n\n        if return_activations:\n            activations = {}\n\n        for i in range(self.n_layers):\n\n            x = self._connection_layers[i](x)\n            x = self._activ_funcs[i](x)\n\n            if apply_output_softmax and self._layer_infos[i].activation_function == 'softmax_output':\n                x = torch.softmax(x, dim=1)\n\n            x = quantizers[i](x)\n\n            if return_activations:\n                activations[\"L\" + str(i + 1)] = x.detach().numpy()\n\n        if return_activations:\n            return x, activations\n        \n        return x\n\n    def extract_activations(self, x, quantizer_params):\n        \"\"\"\n        Extracts the activities using the input given. Used by Analysis. Outputs\n        activities together in a dictionary (because of variable sizes of the layers).\n\n        Args:\n            x (torch tensor): batch from dataset to calculate the activities on. Typically\n                feed the entire dataset in one large batch.\n            before_noise (bool): In a noisyNN, sample before or after applying noise\n\n        Returns:\n            dict: dictionary with each neuron_id as key,\n                labeled \"L1\",..,\"L<n>\",\n                where \"L1\" corresponds to the output of the first layer and \"L<n>\" to\n                the output of the final layer. Notice that this indexing is different\n                from the internal layer structures indices (they are\n                uncomfortable to change).\n        \"\"\"\n        test_quantizers = quantizer_list_factory(\n            quantizer_params, self.get_limits_list())\n\n        with torch.no_grad():\n            _, activations = self.forward(x, quantizers=test_quantizers, return_activations=True)\n\n        return activations\n\n    def init_weights(self, randomize_seed=False):\n        \"\"\"\n        Initialize the weights using the init_str that was set at initialization\n        (one of the initializers provided in INITIALIZERS_PYTORCH).\n\n        Args:\n            randomize_seed (bool): If true, the torch seed is reset before the initialization.\n        \"\"\"\n\n        self._initializer = INITIALIZERS_PYTORCH[self._init_str]\n        if randomize_seed:\n            torch.seed()\n        self.apply(self._init_weight_fct)\n\n    def _init_weight_fct(self, m):\n        if isinstance(m, nn.Linear):\n            if self._init_str == \"xavier\":\n                self._initializer(m.weight, gain=5./3.)\n            else:\n                self._initializer(m.weight)\n        elif isinstance(m, nn.Conv2d):\n            if self._init_str == \"xavier\":\n                self._initializer(m.weight, gain=np.sqrt(2))\n            else:\n                self._initializer(m.weight)\n        elif isinstance(m, nn.Sequential):\n            if len(m) == 2 and isinstance(m[0], nn.Linear):\n                if self._init_str == \"xavier\":\n                    self._initializer(m[0].weight, gain=5./3.)\n                else:\n                    self._initializer(m[0].weight)\n        elif not isinstance(m, (nn.ModuleList, NeuralNetwork, nn.MaxPool2d, nn.Flatten)):\n            raise NotImplementedError(\n                f\"Weight initialization for {m} is not implemented.\"\n            )\n\n\n    def __call__(self, x, quantizers):\n        return self.forward(x, quantizers)\n\n    def get_input_output_dimensions(self):\n        input_dim = self.get_layer_sizes()[0]\n        output_dim = self.get_layer_sizes()[-1]\n        return input_dim, output_dim\n\n    def neuron_ids(self, only_real_neurons=False):\n        \"\"\"\n        Create a simple list of all nodes of the network\n        (including input, target, bias nodes).\n\n        Args:\n            only_real_neurons: Whether you want to only include neurons\n                whose ids begin with 'L'. Default is False\n\n        Returns:\n            list: neuron ids\n        \"\"\"\n        names = []\n        if not only_real_neurons:\n            names.append((\"B\", (1,)))\n        for layer_name, neurons in self.get_layer_structure_dict().items():\n            if (not only_real_neurons) or (\n                only_real_neurons and layer_name.startswith(\"L\")\n            ):\n                for neuron in neurons:\n                    names.append(neuron)\n        return names\n\n    def connectome(self):\n        \"\"\"\n        Returns:\n            an empty connectome matrix\n        \"\"\"\n        neuron_list = self.neuron_ids()\n        connectome = [[]]\n        connectome[0].append(\"input_neuron_ids\")\n        connectome[0].extend(neuron_list)\n        for neuron in neuron_list:\n            connectome.append([neuron])\n            connectome[-1].extend([float(-1) for i in range(len(neuron_list))])\n        return connectome\n\n    def trainable_parameters(self):\n        \"\"\"\n        Create a list of all trainable parameters.\n        Ugly code still.\n\n        Returns:\n            list: List of all trainable parameters.\n                dim 0: parameters\n                dim 1: input neuron_id, output neuron_id, parameter_id\n        \"\"\"\n        connectome = self.connectome()\n        param_list = []\n        param_index = 0\n        for name, param in self.named_parameters():\n            if param.requires_grad:\n                _, internal_index, wb = name.split(\".\")\n                layer_index = int(internal_index) + 1\n                if wb == \"weight\":\n                    for i in range(param.shape[0]):\n                        for j in range(param.shape[1]):\n                            input_layer, output_layer = (\n                                \"L\" + str(layer_index - 1),\n                                \"L\" + str(layer_index),\n                            )\n                            if input_layer == \"L0\":\n                                input_layer = \"X\"\n                            k = connectome[0].index((input_layer, (j + 1,)))\n                            l = connectome[0].index((output_layer, (i + 1,)))\n                            connectome[k][l] = param_index\n                            param_list.append(\n                                [connectome[0][k], connectome[0][l], param_index]\n                            )\n                            param_index += 1\n                elif wb == \"bias\":\n                    for i in range(param.shape[0]):\n                        k = connectome[0].index((\"B\", (1,)))\n                        l = connectome[0].index(\n                            (\"L\" + str(layer_index), (i + 1,)))\n                        connectome[k][l] = param_index\n                        param_list.append(\n                            [connectome[0][k], connectome[0][l], param_index]\n                        )\n                        param_index += 1\n        return param_list", "\n\nclass NoisyNeuralNetwork(NeuralNetwork):\n    def forward(self, x, return_activations=False, save_before_noise=False, quantizer=None, apply_output_softmax=False):\n        \n        if return_activations:\n            activations = {}\n\n        for i in range(self.n_layers):\n            x = self.layers[i](x)\n            x = self._activ_funcs[i](x)\n\n            if apply_output_softmax and self._activ_func_str[i] == 'softmax_output':\n                x = torch.softmax(x, dim=1)\n\n            # add gaussian noise to the layer with stddev noise_stddev\n            if return_activations and save_before_noise:\n                activations[\"L\" + str(i + 1)] = x.detach().numpy()\n\n            # if i != self.n_layers - 1:\n            limits = ACTIV_FUNCS_BINNING_LIMITS[self._activ_func_str[i]]\n            sampled_noise = torch.empty(x.shape).normal_(\n                mean=0, std=self._params[\"noise_stddev\"] * (limits[1]-limits[0])\n            )\n            x = x + sampled_noise\n\n            if return_activations and not save_before_noise:\n                activations[\"L\" + str(i + 1)] = x.detach().numpy()\n\n        if return_activations:\n            return x, activations\n\n        return x\n\n    def to_config(self):\n        param_dict = super.to_config()\n        param_dict[\"noise_stddev\"] = self._params[\"noise_stddev\"]\n        return param_dict", ""]}
{"filename": "nninfo/analysis/binning.py", "chunked_list": ["import numpy as np\nfrom tqdm import tqdm\nfrom abc import ABC, abstractmethod\nfrom collections import Counter\nfrom scipy.stats import norm\nfrom sxpid import SxPID\nfrom nninfo.config import CLUSTER_MODE\n\n__all__ = [\"Binning\"]\n", "__all__ = [\"Binning\"]\n\n\nclass Binning(ABC):\n    \"\"\"\n    Used for discretizing continuous activation data and produces a pmf\n    from the discretized values.\n    \"\"\"\n\n    def __init__(self, groupings, **kwargs):\n        \"\"\"\n        Args:\n            groupings:  List of PID variables, each defined as a list of neuron ids\n        \"\"\"\n        self._params = kwargs\n        self._groupings = groupings\n        self._counter = None\n        self.reset()\n\n    def reset(self):\n        self._counter = Counter()\n\n    @classmethod\n    def from_binning_method(\n        cls, binning_method, groupings, source_id_lists, target_id_list, **kwargs\n    ):\n        if binning_method == \"fixed_size\":\n            return FixedSizeBinning(groupings, **kwargs)\n        elif binning_method == \"goldfeld:fixed_size\":\n            return GoldfeldBinning(source_id_lists, target_id_list, **kwargs)\n        elif binning_method == \"none\":\n            return NoneBinnig(groupings, **kwargs)\n        else:\n            raise NotImplementedError\n\n    def apply(self, activations):\n        \"\"\"\n        Bins a batch of activations\n        activations: {neuron_id -> [activations]}\n        groupings: [[neuron_ids_source1/target], [neuron_ids_source2], ..., [neuron_ids_sourceN/target]]\n        \"\"\"\n        grouped_activations = zip(\n            *[\n                zip(\n                    *[\n                        self.discretize(activations[neuron_id], neuron_id)\n                        for neuron_id in grouping\n                    ]\n                )\n                for grouping in self._groupings\n            ]\n        )\n        self._counter.update(grouped_activations)\n\n    def get_pdf(self):\n        total = sum(self._counter.values())\n        return {rlz: count / total for (rlz, count) in self._counter.items()}\n\n    def get_params(self):\n        return {**self._params, \"binning_method\": self.get_binning_method()}\n\n    @abstractmethod\n    def discretize(self, activations, neuron_id):\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_binning_method(self):\n        raise NotImplementedError", "\n\nclass NoneBinnig(Binning):\n    \"\"\"\n    Binning method that expects already discretized values and therefore skips the discretization step\n    \"\"\"\n    def __init__(self, groupings, **kwargs):\n        \"\"\"\n        Expected kwargs:\n            limits: {neuron_id -> (lower_limit, upper_limit) or \"binary\"}\n            n_bins: number of bins\n        \"\"\"\n        super().__init__(groupings, **kwargs)\n\n    def get_binning_method(self):\n        return \"none\"\n\n    def discretize(self, activations, neuron_id):\n        return activations", "\nclass FixedSizeBinning(Binning):\n    def __init__(self, groupings, **kwargs):\n        \"\"\"\n        Expected kwargs:\n            limits: {neuron_id -> (lower_limit, upper_limit) or \"binary\"}\n            n_bins: number of bins\n        \"\"\"\n        super().__init__(groupings, **kwargs)\n\n    def get_binning_method(self):\n        return \"fixed_size\"\n\n    def discretize(self, activations, neuron_id):\n        \"\"\"\n\n        Args:\n            activations (numpy array): all activations\n            neuron_id: id of the neuron on which discretization should be performed\n\n        Returns: (numpy array) discretized version of the activations of neuron\n            with neuron_id\n\n        \"\"\"\n        limits = self._params[\"limits\"][neuron_id]\n        if limits == \"binary\":\n            activations = activations.astype(np.int64)\n            return activations\n        elif isinstance(limits, tuple) and limits[0] != -np.inf and limits[1] != np.inf:\n            binning_range = limits[1] - limits[0]\n            bin_size = binning_range / self._params[\"n_bins\"]\n            discretized = np.floor(activations / bin_size).astype(\"int\")\n        else:\n            raise NotImplementedError(\n                \"Applying discretization to layer with \"\n                + str(limits)\n                + \" limits is not possible\"\n            )\n        return discretized", "\n\nclass GoldfeldBinning(FixedSizeBinning):\n    def __init__(self, source_id_lists, target_id_list, **kwargs):\n        super().__init__(None, **kwargs)\n        \"\"\"\n        All sources are expected to be noisy, the target is assumed non-noisy.\n        Expected kwargs:\n            std_dev: standard deviation of gaussians\n            limits: {neuron_id -> (lower_limit, upper_limit) or \"binary\"}\n            n_bins: number of bins inside limits\n            extra_bin_factor: Determines how many bins to add outside of limits as 2 * ceil(bin_width * std_dev / bin_size)\n            prob_threshold: Events with probability mass lower than this threshold are excluded from PID for performance. pmf is normalized after exclusion.\n        \"\"\"\n\n        self._source_id_lists = source_id_lists\n        self._target_id_list = target_id_list\n\n        beta = self._params[\"std_dev\"]\n\n        self._bin_centers = []\n\n        extra_bin_factor = self._params[\"extra_bin_factor\"]\n\n        # Calculate center positions of bins of relevant neurons (i.e. those which appear in a grouping)\n        for grouping in source_id_lists:\n            for neuron_id in grouping:\n\n                limits = self._params[\"limits\"][neuron_id]\n                binning_range = limits[1] - limits[0]\n                bin_size = binning_range / self._params[\"n_bins\"]\n                n_extra_bins = int(np.ceil(extra_bin_factor * beta / bin_size))\n\n                neuron_bin_centers = (\n                    np.linspace(\n                        limits[0] - n_extra_bins * bin_size,\n                        limits[1] + n_extra_bins * bin_size,\n                        self._params[\"n_bins\"] + 2 * n_extra_bins,\n                        endpoint=False,\n                    )\n                    + bin_size / 2\n                )\n\n                self._bin_centers.append(neuron_bin_centers)\n\n        # Dictionary from target tuples to full ndarray source pmfs.\n        self._probability_dict = {}\n\n        # Full unnormalized pmf for all bin combinations\n        self._accumulated_probabilites = np.zeros(\n            shape=tuple(len(nbc) for nbc in self._bin_centers)\n        )\n\n        # Initialize normal distribution\n        self._normal = norm(loc=0, scale=beta).pdf\n\n    def get_binning_method(self):\n        return \"goldfeld:fixed_size\"\n\n    def apply(self, activations):\n        \"\"\"\n        Apply Goldfeld binnning to a batch of activations, i.e. evaluate multidimensional Gaussians \n        with the distance of the sample from the bin centers.\n        \"\"\"\n\n        # First digitize the non-noisy target varible\n        digitized_target = list(\n            zip(\n                *[\n                    self.discretize(activations[neuron_id], neuron_id)\n                    for neuron_id in self._target_id_list\n                ]\n            )\n        )\n\n        # Find relevant activations source, i.e. from neurons of interest for the requested PID groupings\n        relevant_activations = np.hstack(\n            tuple(\n                activations[neuron_id][:, np.newaxis]\n                for grouping in self._source_id_lists\n                for neuron_id in grouping\n            )\n        )\n\n        # For each sample, calculate the contributions to the accumulated_probabilities by\n        # evaluating 1D Gaussians for the dimensions separately and (outer) multiplying them.\n        # This exploits the fact that our evaluation points are on a cartesian grid and the Gaussian\n        # Factorizes over dimensions.\n        for i, sample in tqdm(\n            enumerate(relevant_activations),\n            total=len(relevant_activations),\n            disable=CLUSTER_MODE,\n        ):  # vectorize!\n            sample_contributions = 1\n            for neuron_sample, neuron_bin_centers in zip(sample, self._bin_centers):\n                neuron_marginal = self._normal(neuron_bin_centers - neuron_sample)\n                sample_contributions = np.multiply.outer(\n                    sample_contributions, neuron_marginal\n                )\n\n            if digitized_target[i] in self._probability_dict:\n                self._probability_dict[digitized_target[i]] += sample_contributions\n            else:\n                self._probability_dict[digitized_target[i]] = sample_contributions\n\n    def get_pdf(self):\n        \"\"\"\n        Applies the threshold, groups dimensions of _accumulated_probabilities according to groupings,\n        reencodes the accumulated_probabilities in a sparse matrix format (COO)\n        and normalizes it.\n        \"\"\"\n\n        # Find that a full pmf array would have after applying the variable grouping for PID analysis\n        grouped_shape = ()\n        i = 0\n        for grouping in self._source_id_lists:\n            group_bins = 1\n            for _ in grouping:\n                group_bins *= len(self._bin_centers[i])\n                i += 1\n            grouped_shape += (group_bins,)\n        grouped_shape += (len(self._probability_dict),)\n\n        # Create coordinate array according to shape and flatten it\n        coords = (\n            np.indices(grouped_shape).reshape(len(grouped_shape), -1).T\n        )  # shape=(n_samples, n_PID_variables)\n\n        flattened_pmf = np.stack(\n            list(self._probability_dict.values()), axis=-1\n        ).flatten()  # shape=n_samples\n\n        # normalize\n        flattened_pmf = flattened_pmf / flattened_pmf.sum()\n\n        # Apply threshold or find it first\n        if \"prob_threshold\" in self._params:\n            eps = self._params[\"prob_threshold\"]\n        else:\n            q = self._params[\n                \"min_incl_prob\"\n            ]  # Minimum total probability to be included in the PID\n            eps = self.find_thr(flattened_pmf, q)\n\n        above_threshold_indices = np.nonzero(flattened_pmf >= eps)\n\n        filtered_coords = coords[above_threshold_indices]\n        filtered_pmf = flattened_pmf[above_threshold_indices]\n\n        print(filtered_pmf.sum())\n        print(filtered_pmf.sum() - filtered_pmf.min())\n\n        # Normalize\n        normalized_pmf = filtered_pmf / np.sum(filtered_pmf)\n        print(\"Remaining total pmf:\", np.sum(filtered_pmf) / np.sum(flattened_pmf))\n\n        # Create SxPID pdf directly, without creating dictionary first. Make coords F-contiguous for performance reasons.\n        return SxPID.PDF(np.asfortranarray(filtered_coords), normalized_pmf)\n\n    def find_thr(self, a, q, bias_l=0, bias_g=0, first_call=True):\n        \"\"\"\n        Args:\n            a: normalized array of weights\n            q: quantile\n        Returns:\n            thr: largest threshold such that a[a >= thr].sum() >= q\n        \"\"\"\n        if len(a) == 1:\n            return a[0]\n\n        if len(a) == 2:\n            min = np.min(a)\n            max = np.max(a)\n            return max if max + bias_g >= q else min\n\n        pivot_idx = int(q * len(a)) if first_call else int(len(a) / 2)\n        partitioned = np.partition(a, kth=pivot_idx, axis=None)\n\n        sum_l = np.sum(partitioned[:pivot_idx]) + bias_l\n        sum_g = np.sum(partitioned[pivot_idx + 1 :]) + bias_g\n\n        if sum_l < 1 - q and sum_g < q:\n            return partitioned[pivot_idx]\n\n        if sum_g > q:\n            return self.find_thr(\n                partitioned[pivot_idx:],\n                q,\n                bias_l=sum_l,\n                bias_g=bias_g,\n                first_call=False,\n            )\n        else:\n            return self.find_thr(\n                partitioned[: pivot_idx + 1],\n                q,\n                bias_l=bias_l,\n                bias_g=sum_g,\n                first_call=False,\n            )", ""]}
{"filename": "nninfo/analysis/measurement.py", "chunked_list": ["from abc import ABC, abstractmethod\nfrom typing import ClassVar, Literal\n\nimport filelock\nimport pandas as pd\nimport yaml\n\nfrom ..file_io import NoAliasDumper\nfrom ..experiment import Experiment\n", "from ..experiment import Experiment\n\n\nclass Measurement(ABC):\n    MEASUREMENT_CONFIG_FILE_NAME = \"config.yaml\"\n    MEASUREMENT_RESULTS_FILE_NAME = \"results.h5\"\n    MEASUREMENT_RESULTS_FILE_LOCK = \"results.lock\"\n\n    measurement_type: ClassVar[str]\n\n    def __init__(self,\n                 experiment: Experiment,\n                 measurement_id: str,\n                 dataset_name: str,\n                 dataset_kwargs: dict = None,\n                 quantizer_params: list[dict] = None,\n                 _load: bool = False):\n\n        self._experiment = experiment\n        self._measurement_id = measurement_id\n        self._quantizer_params = quantizer_params\n\n        self._dataset_name = dataset_name\n        self._dataset_kwargs = dataset_kwargs or {}\n\n        self._measurement_dir = experiment.experiment_dir / measurement_id\n        self._config_file = self._measurement_dir / self.MEASUREMENT_CONFIG_FILE_NAME\n\n        self._results_file = self._measurement_dir / self.MEASUREMENT_RESULTS_FILE_NAME\n        self._results_file_lock = self._measurement_dir / \\\n            self.MEASUREMENT_RESULTS_FILE_LOCK\n\n        if not _load:\n            self._create_dir_and_config()\n\n    def _create_dir_and_config(self):\n\n        try:\n            self._measurement_dir.mkdir(parents=True, exist_ok=False)\n        except FileExistsError:\n            if self._config_file.exists():\n                config = Measurement._load_yaml(self._config_file)\n                if config == self.to_config():\n                    return\n            raise FileExistsError(\n                \"The measurement directory already exists and the config does not match.\")\n\n        with open(self._config_file, \"w\") as f:\n            yaml.dump(self.to_config(), f, Dumper=NoAliasDumper)\n\n    def to_config(self):\n        return {\n            \"measurement_type\": self.measurement_type,\n            \"experiment_id\": self._experiment.id,\n            \"measurement_id\": self._measurement_id,\n            \"dataset_name\": self._dataset_name,\n            \"dataset_kwargs\": self._dataset_kwargs,\n            \"quantizer_params\": self._quantizer_params\n        }\n\n    @classmethod\n    def from_config(cls, experiment, config):\n\n        config = config.copy()\n\n        assert config.pop(\"measurement_type\") == cls.measurement_type, \\\n            \"The measurement type in the config does not match the measurement type of the class.\"\n        assert config.pop(\"experiment_id\") == experiment.id, \\\n            \"The experiment id in the config does not match the experiment id of the experiment.\"\n\n        return cls(experiment=experiment, **config, _load=True)\n\n    @staticmethod\n    def _load_yaml(file):\n        with open(file, \"r\") as f:\n            return yaml.safe_load(f)\n\n    @classmethod\n    def load(cls, experiment: Experiment, measurement_id: str):\n        config_file = experiment.experiment_dir / \\\n            measurement_id / cls.MEASUREMENT_CONFIG_FILE_NAME\n\n        config = cls._load_yaml(config_file)\n\n        return cls.from_config(experiment, config)\n\n    def save_results(self, run_id, chapter_id, results_df):\n        \"\"\"Appends the results to the hdf5 file in the corresponding measurement directory.\n\n        \"\"\"\n\n        # Add columns for run_ids, chapter_ids and epoch_ids\n        results_df.insert(loc=0, column=\"run_id\", value=run_id)\n        results_df.insert(loc=1, column=\"chapter_id\", value=chapter_id)\n        results_df.insert(loc=2, column=\"epoch_id\",\n                            value=self._experiment.schedule.get_epoch_for_chapter(chapter_id))\n\n        with filelock.FileLock(self._results_file_lock):\n            with pd.HDFStore(self._results_file) as store:\n                store.put(\"results\", results_df,\n                          append=True, format=\"table\")\n\n    def perform_measurements(self, run_ids: Literal['all'] | int | list[int], chapter_ids: Literal['all'] | int | list[int], exists_ok: bool = True):\n\n        checkpoint_ids = self._experiment.checkpoint_manager.list_all_checkpoints()\n\n        if not run_ids == 'all':\n\n            if isinstance(run_ids, int):\n                run_ids = [run_ids]\n\n            # Filter out checkpoint_ids that are not in run_ids\n            checkpoint_ids = [c for c in checkpoint_ids if c[0] in run_ids]\n\n        if not chapter_ids == 'all':\n\n            if isinstance(chapter_ids, int):\n                chapter_ids = [chapter_ids]\n\n            # Filter out checkpoint_ids that are not in chapter_ids\n            checkpoint_ids = [c for c in checkpoint_ids if c[1] in chapter_ids]\n\n        print(\n            f\"Performing measurements for {len(checkpoint_ids)} checkpoints: {checkpoint_ids}.\")\n\n        # Perform measurements for all run_ids and chapter_ids sequentially\n        for checkpoint_id in checkpoint_ids:\n            self.perform_measurement(checkpoint_id[0], checkpoint_id[1], exists_ok=exists_ok)\n\n    def perform_measurement(self, run_id: int, chapter_id: int, exists_ok: bool = True):\n\n        if not self._results_file.exists():\n            self._create_results_file()\n\n        # Check if there is already a result for this run_id and chapter_id\n        if self._check_if_result_exists(run_id, chapter_id):\n            if exists_ok:\n                print(\n                    f\"There is already a {self.measurement_type!r} result for run_id {run_id} and chapter_id {chapter_id}. Skipping.\")\n                return\n            raise ValueError(\n                f\"There is already a {self.measurement_type!r} result for run_id {run_id} and chapter_id {chapter_id}. Aborting.\")\n\n        print(\n            f\"Performing {self.measurement_type!r} measurement for run_id {run_id} and chapter_id {chapter_id}.\")\n        results = self._measure(run_id, chapter_id)\n\n        self.save_results(run_id, chapter_id, results)\n\n    def _create_results_file(self):\n        \"\"\"Creates the results file.\n\n        \"\"\"\n        with filelock.FileLock(self._results_file_lock):\n            with pd.HDFStore(self._results_file) as store:\n                store.put(\"results\", pd.DataFrame(),\n                          append=True, format=\"table\")\n\n    def _check_if_result_exists(self, run_id: int, chapter_id: int):\n\n        results = self.results\n        if results[(results[\"run_id\"] == run_id) & (results[\"chapter_id\"] == chapter_id)].shape[0] > 0:\n            return True\n\n    @abstractmethod\n    def _measure(self, *args, **kwargs):\n        raise NotImplementedError\n\n    @property\n    def results(self):\n\n        with filelock.FileLock(self._results_file_lock):\n            with pd.HDFStore(self._results_file) as store:\n                try:\n                    results_df = store.select(\"results\")\n                except KeyError:\n                    results_df = pd.DataFrame(columns=[\"run_id\", \"chapter_id\", \"epoch_id\"])\n\n        return results_df", ""]}
{"filename": "nninfo/analysis/__init__.py", "chunked_list": ["from .binning import *\nfrom .pid_measurement import *\nfrom .performance_measurement import *\n"]}
{"filename": "nninfo/analysis/reing.py", "chunked_list": ["\"\"\"Implementation of Reing et al. (2021) directed local differences between cohesion measures.\n\n\"\"\"\n\nimport numpy as np\nimport scipy.stats as stats\nfrom math import comb\nfrom itertools import chain, combinations\n\nimport sxpid", "\nimport sxpid\n\ndef _get_entropy(pdf, var_id_list):\n    \"\"\"Calculate the entropy of a variable.\n\n    Parameters\n    ----------\n    pdf_dict : dict\n        Dictionary with keys being realization tuples and values their probability\n    var_id_list : list\n        List of variable IDs.\n\n    Returns\n    -------\n    float\n        Entropy of the variable.\n\n    \"\"\"\n    delete_id_list = [i for i in range(pdf.nVar) if i not in var_id_list]\n    marginalized_pdf = pdf.marginalize(*delete_id_list)\n    return stats.entropy(marginalized_pdf.probs, base=2)", "\ndef powerset(iterable):\n    \"\"\"Return the powerset of an iterable.\n\n    Parameters\n    ----------\n    iterable : iterable\n        Iterable to calculate the powerset of.\n\n    Returns\n    -------\n    list\n        List of all subsets of the iterable.\n\n    \"\"\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))", "\ndef compute_C_k(pdf_dict, k):\n    \"\"\"This definition is sligntly different than in the paper\n        compute_C_k(k) is equivalent to C_k(k+1) in the paper (Equation 9)\n        But the paper is wrong, because it uses C_k(k) in equation 10\n    \"\"\"\n    n = len(next(iter(pdf_dict.keys()))) - 1\n\n    # Create SxPID Pdf\n    pdf = sxpid.SxPID.PDF.from_dict(pdf_dict)\n\n\n    # Find all combinations of length k of the variables\n    source_combinations = list(combinations(range(n), k))\n\n    target_index = n\n\n    C_k = 1/comb(n, k) * sum([_get_entropy(pdf, source_combination + (target_index,))\n                            - _get_entropy(pdf, source_combination) for source_combination in source_combinations])\n\n    return C_k", "\ndef compute_C_k_diffs(pdf_dict):\n    n = len(next(iter(pdf_dict.keys()))) - 1\n    C_k = [compute_C_k(pdf_dict, k) for k in range(0, n + 1)]\n    C_k_diffs = {f'C({k-1}||{k})':C_k[k-1] - C_k[k] for k in range(1, n + 1)}\n\n    return C_k_diffs"]}
{"filename": "nninfo/analysis/performance_measurement.py", "chunked_list": ["import pandas as pd\n\nfrom .measurement import Measurement\nfrom ..experiment import Experiment\nfrom .. import logger\n\nlog = logger.get_logger(__name__)\n\n\nclass PerformanceMeasurement(Measurement):\n    measurement_type = \"performance\"\n    \"\"\"\n    Computes loss and accuracy for a given dataset.\n    \"\"\"\n\n    def __init__(self,\n                 experiment: Experiment,\n                 dataset_names: str,\n                 measurement_id: str = 'performance',\n                 dataset_kwargs: dict = None,\n                 quantizer_params=None,\n                 _load=False,\n                 ):\n\n        self._dataset_names = dataset_names\n\n        super().__init__(\n            experiment=experiment,\n            measurement_id=measurement_id,\n            dataset_name=None,\n            dataset_kwargs=dataset_kwargs,\n            quantizer_params=quantizer_params,\n            _load=_load\n        )\n\n    def to_config(self):\n        config = super().to_config()\n        config[\"dataset_names\"] = self._dataset_names\n        return config\n    \n    @classmethod\n    def from_config(cls, experiment, config):\n\n        config = config.copy()\n        del config[\"dataset_name\"]\n\n        return super().from_config(experiment, config)\n\n    def _measure(self, run_id, chapter_id):\n\n        self._experiment.load_checkpoint(run_id, chapter_id)\n\n        dfs = []\n        for dataset_name in self._dataset_names:\n            loss, acc = self._experiment.tester.compute_loss_and_accuracy(\n                dataset_name, self._quantizer_params)\n\n            dfs.append(pd.DataFrame({'loss': [loss], 'accuracy': [acc]}))\n\n        df = pd.concat(dfs, axis=1, keys=self._dataset_names)\n\n        return df", "\nclass PerformanceMeasurement(Measurement):\n    measurement_type = \"performance\"\n    \"\"\"\n    Computes loss and accuracy for a given dataset.\n    \"\"\"\n\n    def __init__(self,\n                 experiment: Experiment,\n                 dataset_names: str,\n                 measurement_id: str = 'performance',\n                 dataset_kwargs: dict = None,\n                 quantizer_params=None,\n                 _load=False,\n                 ):\n\n        self._dataset_names = dataset_names\n\n        super().__init__(\n            experiment=experiment,\n            measurement_id=measurement_id,\n            dataset_name=None,\n            dataset_kwargs=dataset_kwargs,\n            quantizer_params=quantizer_params,\n            _load=_load\n        )\n\n    def to_config(self):\n        config = super().to_config()\n        config[\"dataset_names\"] = self._dataset_names\n        return config\n    \n    @classmethod\n    def from_config(cls, experiment, config):\n\n        config = config.copy()\n        del config[\"dataset_name\"]\n\n        return super().from_config(experiment, config)\n\n    def _measure(self, run_id, chapter_id):\n\n        self._experiment.load_checkpoint(run_id, chapter_id)\n\n        dfs = []\n        for dataset_name in self._dataset_names:\n            loss, acc = self._experiment.tester.compute_loss_and_accuracy(\n                dataset_name, self._quantizer_params)\n\n            dfs.append(pd.DataFrame({'loss': [loss], 'accuracy': [acc]}))\n\n        df = pd.concat(dfs, axis=1, keys=self._dataset_names)\n\n        return df", ""]}
{"filename": "nninfo/analysis/pid_measurement.py", "chunked_list": ["import copy\n\nimport pandas as pd\nfrom sxpid import SxPID\nfrom broja2pid import BROJA_2PID\n\nfrom .measurement import Measurement\nfrom .binning import Binning\nfrom ..config import N_WORKERS, CLUSTER_MODE\nfrom ..experiment import Experiment", "from ..config import N_WORKERS, CLUSTER_MODE\nfrom ..experiment import Experiment\nfrom ..model.neural_network import NeuronID\nfrom .. import logger\nfrom .reing import compute_C_k_diffs\n\nlog = logger.get_logger(__name__)\n\n\nclass PIDMeasurement(Measurement):\n    measurement_type = \"pid\"\n    \"\"\"\n    A single PID Measurement, that can be saved into the file structure after computation.\n    \"\"\"\n\n    def __init__(self,\n                 experiment: Experiment,\n                 measurement_id: str,\n                 dataset_name: str,\n                 pid_definition: str,\n                 target_id_list: list[NeuronID],\n                 source_id_lists: list[list[NeuronID]],\n                 binning_kwargs,\n                 pid_kwargs: dict = None,\n                 dataset_kwargs: dict = None,\n                 quantizer_params=None,\n                 _load=False,\n                 ):\n\n        self._pid_definition = pid_definition\n        self._pid_kwargs = pid_kwargs or {}\n\n        self.T = sorted(target_id_list)\n        self.S = [sorted(s) for s in source_id_lists]\n\n        self._n_sources = len(source_id_lists)\n\n        self._binning_kwargs = binning_kwargs or {}\n\n        super().__init__(\n            experiment=experiment,\n            measurement_id=measurement_id,\n            dataset_name=dataset_name,\n            dataset_kwargs=dataset_kwargs,\n            quantizer_params=quantizer_params,\n            _load=_load\n        )\n\n        binning_kwargs_copy = copy.deepcopy(binning_kwargs)\n        binning_method = binning_kwargs_copy.pop(\"binning_method\")\n        self._binning = Binning.from_binning_method(\n            binning_method,\n            source_id_lists + [target_id_list],\n            source_id_lists,\n            target_id_list,\n            **binning_kwargs_copy\n        )\n\n    def to_config(self):\n        config = super().to_config()\n        config[\"pid_definition\"] = self._pid_definition\n        config[\"pid_kwargs\"] = self._pid_kwargs\n        config[\"binning_kwargs\"] = self._binning_kwargs\n        config[\"target_id_list\"] = self.T\n        config[\"source_id_lists\"] = self.S\n        return config\n\n    def _measure(self, run_id, chapter_id):\n\n        # get the activations for the current run_id and chapter_id\n        activations_iter = self._experiment.capture_activations(\n            dataset=self._dataset_name,\n            run_id=run_id,\n            chapter_id=chapter_id,\n            repeat_dataset=self._dataset_kwargs.get(\"repeat_dataset\", 1),\n            before_noise=self._binning_kwargs.get(\"before_noise\", False),\n            quantizer_params=self._quantizer_params,\n        )\n\n        self._binning.reset()\n        for activations in activations_iter:\n            self._binning.apply(activations)\n\n        pdf_dict = self._binning.get_pdf()\n\n        try:\n            pid_function = self._pid_measures[self._pid_definition]\n        except KeyError:\n            raise NotImplementedError(\n                f\"PID definition {self._pid_definition} is not implemented.\"\n            )\n\n        results = pid_function(self, pdf_dict, **self._pid_kwargs)\n\n        return results\n\n    def _perform_sxpid(self, sxpid_pdf):\n        results = SxPID.pid(\n            sxpid_pdf, verbose=0 if CLUSTER_MODE else 2, n_threads=N_WORKERS, pointwise=False\n        )\n\n        # Convert results to a row in a dataframe. The multiindex column names are (\"informative\"/\"misinformative\"/\"average\", str(antichain))\n        inf = pd.DataFrame({str(k): [v[0]] for k, v in results.items()})\n        misinf = pd.DataFrame({str(k): [v[1]] for k, v in results.items()})\n        avg = pd.DataFrame({str(k): [v[2]] for k, v in results.items()})\n\n        return pd.concat([inf, misinf, avg], axis=1, keys=['inf_pid', 'misinf_pid', 'avg_pid'])\n\n    def _perform_brojapid(self, pdf_dict):\n        \n\n        # BROJA-PID expects the target to be the first variable:\n        broja_pdf_dict = {(key[-1],) + key[:-1]\n                           : value for key, value in pdf_dict.items()}\n\n        results = BROJA_2PID.pid(\n            broja_pdf_dict, cone_solver=\"ECOS\"\n        )\n\n        avg_dict = {\n            '((1, 2,),)': [results[\"CI\"]],\n            '((1,),)': [results[\"UIY\"]],\n            '((2,),)': [results[\"UIZ\"]],\n            '((1,), (2,))': [results[\"SI\"]]\n        }\n\n        return pd.DataFrame(avg_dict)\n\n    def _perform_reing(self, reing_pdf):\n        results_dict = compute_C_k_diffs(reing_pdf)\n\n        return pd.DataFrame({str(k): [v] for k, v in results_dict.items()})\n\n    _pid_measures = {'sxpid': _perform_sxpid,\n                     'brojapid': _perform_brojapid,\n                     'reing': _perform_reing}", "\nclass PIDMeasurement(Measurement):\n    measurement_type = \"pid\"\n    \"\"\"\n    A single PID Measurement, that can be saved into the file structure after computation.\n    \"\"\"\n\n    def __init__(self,\n                 experiment: Experiment,\n                 measurement_id: str,\n                 dataset_name: str,\n                 pid_definition: str,\n                 target_id_list: list[NeuronID],\n                 source_id_lists: list[list[NeuronID]],\n                 binning_kwargs,\n                 pid_kwargs: dict = None,\n                 dataset_kwargs: dict = None,\n                 quantizer_params=None,\n                 _load=False,\n                 ):\n\n        self._pid_definition = pid_definition\n        self._pid_kwargs = pid_kwargs or {}\n\n        self.T = sorted(target_id_list)\n        self.S = [sorted(s) for s in source_id_lists]\n\n        self._n_sources = len(source_id_lists)\n\n        self._binning_kwargs = binning_kwargs or {}\n\n        super().__init__(\n            experiment=experiment,\n            measurement_id=measurement_id,\n            dataset_name=dataset_name,\n            dataset_kwargs=dataset_kwargs,\n            quantizer_params=quantizer_params,\n            _load=_load\n        )\n\n        binning_kwargs_copy = copy.deepcopy(binning_kwargs)\n        binning_method = binning_kwargs_copy.pop(\"binning_method\")\n        self._binning = Binning.from_binning_method(\n            binning_method,\n            source_id_lists + [target_id_list],\n            source_id_lists,\n            target_id_list,\n            **binning_kwargs_copy\n        )\n\n    def to_config(self):\n        config = super().to_config()\n        config[\"pid_definition\"] = self._pid_definition\n        config[\"pid_kwargs\"] = self._pid_kwargs\n        config[\"binning_kwargs\"] = self._binning_kwargs\n        config[\"target_id_list\"] = self.T\n        config[\"source_id_lists\"] = self.S\n        return config\n\n    def _measure(self, run_id, chapter_id):\n\n        # get the activations for the current run_id and chapter_id\n        activations_iter = self._experiment.capture_activations(\n            dataset=self._dataset_name,\n            run_id=run_id,\n            chapter_id=chapter_id,\n            repeat_dataset=self._dataset_kwargs.get(\"repeat_dataset\", 1),\n            before_noise=self._binning_kwargs.get(\"before_noise\", False),\n            quantizer_params=self._quantizer_params,\n        )\n\n        self._binning.reset()\n        for activations in activations_iter:\n            self._binning.apply(activations)\n\n        pdf_dict = self._binning.get_pdf()\n\n        try:\n            pid_function = self._pid_measures[self._pid_definition]\n        except KeyError:\n            raise NotImplementedError(\n                f\"PID definition {self._pid_definition} is not implemented.\"\n            )\n\n        results = pid_function(self, pdf_dict, **self._pid_kwargs)\n\n        return results\n\n    def _perform_sxpid(self, sxpid_pdf):\n        results = SxPID.pid(\n            sxpid_pdf, verbose=0 if CLUSTER_MODE else 2, n_threads=N_WORKERS, pointwise=False\n        )\n\n        # Convert results to a row in a dataframe. The multiindex column names are (\"informative\"/\"misinformative\"/\"average\", str(antichain))\n        inf = pd.DataFrame({str(k): [v[0]] for k, v in results.items()})\n        misinf = pd.DataFrame({str(k): [v[1]] for k, v in results.items()})\n        avg = pd.DataFrame({str(k): [v[2]] for k, v in results.items()})\n\n        return pd.concat([inf, misinf, avg], axis=1, keys=['inf_pid', 'misinf_pid', 'avg_pid'])\n\n    def _perform_brojapid(self, pdf_dict):\n        \n\n        # BROJA-PID expects the target to be the first variable:\n        broja_pdf_dict = {(key[-1],) + key[:-1]\n                           : value for key, value in pdf_dict.items()}\n\n        results = BROJA_2PID.pid(\n            broja_pdf_dict, cone_solver=\"ECOS\"\n        )\n\n        avg_dict = {\n            '((1, 2,),)': [results[\"CI\"]],\n            '((1,),)': [results[\"UIY\"]],\n            '((2,),)': [results[\"UIZ\"]],\n            '((1,), (2,))': [results[\"SI\"]]\n        }\n\n        return pd.DataFrame(avg_dict)\n\n    def _perform_reing(self, reing_pdf):\n        results_dict = compute_C_k_diffs(reing_pdf)\n\n        return pd.DataFrame({str(k): [v] for k, v in results_dict.items()})\n\n    _pid_measures = {'sxpid': _perform_sxpid,\n                     'brojapid': _perform_brojapid,\n                     'reing': _perform_reing}", ""]}
{"filename": "nninfo/tasks/combined_mnist_task.py", "chunked_list": ["import torch\nimport torchvision.datasets\n\nfrom .task import Task\n\nclass CombinedMnistTask(Task):\n    task_id = \"combined_mnist_1d_dat\"\n\n    @property\n    def finite(self):\n        return True\n\n    @property\n    def x_limits(self):\n        return (0, 1)\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 784\n\n    @property\n    def y_dim(self):\n        return 20\n\n    def load_samples(self):\n        mnist = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=True)\n        mnist_test = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=False)\n\n        fmnist = torchvision.datasets.FashionMNIST(\n            root=\"../\", download=True, train=True)\n        fmnist_test = torchvision.datasets.FashionMNIST(\n            root=\"../\", download=True, train=False)\n\n        x = torch.cat([mnist.data, fmnist.data, mnist_test.data,\n                       fmnist_test.data]).reshape(-1, 784) / 256.\n        y = torch.cat([mnist.targets, fmnist.targets + 10, mnist_test.targets,\n                       fmnist_test.targets + 10])\n\n        return x.type(torch.float32), y.type(torch.long)"]}
{"filename": "nninfo/tasks/mnist_eight_binary_task.py", "chunked_list": ["import torch\nimport torchvision.datasets\n\nfrom .task import Task\n\nclass MnistEightBinaryTask(Task):\n    \"\"\"Mnist task but only with digits from 0-7\n\n    len train: 48200\n    len test: 48275\n\n    \"\"\"\n\n    task_id = \"mnist8_binary_dat\"\n\n    @property\n    def finite(self):\n        return True\n\n    @property\n    def x_limits(self):\n        return (0, 1)\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 784\n\n    @property\n    def y_dim(self):\n        return 3\n\n    def load_samples(self):\n        mnist = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=True)\n        mnist_test = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=False)\n        qmnist_test = torchvision.datasets.QMNIST(\n            root=\"../\", what='test50k', download=True, train=False)\n\n        x = torch.cat([mnist.data, mnist_test.data,\n                       qmnist_test.data]).reshape(-1, 784) / 256.\n        y = torch.cat([mnist.targets, mnist_test.targets,\n                       qmnist_test.targets[:, 0]])\n\n        # Filter out digits 8 and 9\n        filter_mask = (y != 8) & (y != 9)\n        y = y[filter_mask]\n        x = x[filter_mask]\n\n        y_binary = self.binary(y, 3)\n\n        return x.type(torch.float32), y_binary.type(torch.float32)\n\n    def binary(self, x, bits):\n        mask = 2**torch.arange(bits).to(x.device, x.dtype)\n        return x.unsqueeze(-1).bitwise_and(mask).ne(0).byte()"]}
{"filename": "nninfo/tasks/mnist_shuffled.py", "chunked_list": ["import torch\nimport torchvision\nimport numpy as np\n\nfrom .task import Task\n\nclass Mnist1DShuffledTask(Task):\n    task_id = \"mnist_1d_shuffled_dat\"\n    \n    @property\n    def finite(self):\n        return True\n\n    @property\n    def x_limits(self):\n        return (0, 1)\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 784\n\n    @property\n    def y_dim(self):\n        return 10\n\n\n    def load_samples(self, component_dir):\n        mnist = torchvision.datasets.MNIST(root=\"../\", download=True, train=True)\n        mnist_test = torchvision.datasets.MNIST(root=\"../\", download=True, train=False)\n        qmnist_test = torchvision.datasets.QMNIST(root=\"../\", what='test50k', download=True, train=False)\n        \n        x = torch.cat([mnist.data, mnist_test.data, qmnist_test.data]).reshape(-1, 784) / 256.\n        y = torch.cat([mnist.targets, mnist_test.targets, qmnist_test.targets[:,0]])\n\n        # Shuffle y labels for test and train set separately\n        rng = np.random.default_rng(42 + self._kwargs[\"seed\"])\n        y[:60_000] = torch.tensor(rng.permutation(y[:60_000]))\n        y[60_000:] = torch.tensor(rng.permutation(y[60_000:]))\n\n        return x.type(torch.float32), y.type(torch.long)"]}
{"filename": "nninfo/tasks/combined_mnist_octal_task.py", "chunked_list": ["import torch\nimport torchvision.datasets\n\nfrom .task import Task, octal_encode_label\n\nclass CombinedMnistOctalTask(Task):\n    task_id = \"combined_mnist_octal_dat\"\n\n    @property\n    def finite(self):\n        return True\n\n    @property\n    def x_limits(self):\n        return (0, 1)\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 784\n\n    @property\n    def y_dim(self):\n        return 2\n\n    def load_samples(self):\n        mnist = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=True)\n        mnist_test = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=False)\n\n        fmnist = torchvision.datasets.FashionMNIST(\n            root=\"../\", download=True, train=True)\n        fmnist_test = torchvision.datasets.FashionMNIST(\n            root=\"../\", download=True, train=False)\n\n        x = torch.cat([mnist.data, fmnist.data, mnist_test.data,\n                       fmnist_test.data]).reshape(-1, 784) / 256.\n        y = torch.cat([mnist.targets, fmnist.targets + 10, mnist_test.targets,\n                       fmnist_test.targets + 10])\n\n        y_binary = octal_encode_label(y, 2)\n\n        return x.type(torch.float32), y_binary.type(torch.float32)"]}
{"filename": "nninfo/tasks/tishby_task.py", "chunked_list": ["import torch\n\nfrom ..file_io import FileManager\nfrom .task import Task\n\nclass TishbyTask(Task):\n    task_id = \"tishby_dat\"\n\n    @property\n    def finite(self):\n        return True\n\n    @property\n    def x_limits(self):\n        return \"binary\"\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 12\n\n    @property\n    def y_dim(self):\n        return 1\n\n    def load_samples(self):\n        self._data_location = \"../data/Tishby_2017/\"\n        dataset_reader = FileManager(\n            self._data_location, read=True)\n        data_dict = dataset_reader.read(\"var_u.mat\")\n        x = data_dict[\"F\"]\n        y = data_dict[\"y\"].T\n        return torch.tensor(x, dtype=torch.float), torch.tensor(y, dtype=torch.float)"]}
{"filename": "nninfo/tasks/task.py", "chunked_list": ["import numpy as np\nimport torch.utils.data\nimport torchvision\nfrom abc import ABC, abstractmethod\n\nimport nninfo\nlog = nninfo.logger.get_logger(__name__)\n\nclass Task(ABC):\n\n    def __init__(self, **kwargs):\n        self._kwargs = kwargs\n\n    _subclasses = {}\n\n    @classmethod\n    def __init_subclass__(cls, **kwargs):\n        super().__init_subclass__(**kwargs)\n        cls._subclasses[cls.task_id] = cls\n\n    @staticmethod\n    def list_available_tasks():\n        return list(Task._subclasses.keys())\n\n    @property\n    def kwargs(self):\n        return self._kwargs\n\n    @property\n    @abstractmethod\n    def finite(self):\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def task_id(self):\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def x_limits(self):\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def y_limits(self):\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def x_dim(self):\n        \"\"\"\n        Returns the dimension of the feature component of a single sample\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def y_dim(self):\n        \"\"\"\n        Returns the dimension of the label component of a single sample\n        \"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    def from_id(cls, task_id, **kwargs):\n        return cls._subclasses[task_id](**kwargs)\n\n    def generate_sample(self, rng, condition=None):\n        raise NotImplementedError(\n            \"Finite-sample tasks do not support the generation of samples.\"\n        )\n\n    @abstractmethod\n    def load_samples(self):\n        raise NotImplementedError", "class Task(ABC):\n\n    def __init__(self, **kwargs):\n        self._kwargs = kwargs\n\n    _subclasses = {}\n\n    @classmethod\n    def __init_subclass__(cls, **kwargs):\n        super().__init_subclass__(**kwargs)\n        cls._subclasses[cls.task_id] = cls\n\n    @staticmethod\n    def list_available_tasks():\n        return list(Task._subclasses.keys())\n\n    @property\n    def kwargs(self):\n        return self._kwargs\n\n    @property\n    @abstractmethod\n    def finite(self):\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def task_id(self):\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def x_limits(self):\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def y_limits(self):\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def x_dim(self):\n        \"\"\"\n        Returns the dimension of the feature component of a single sample\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def y_dim(self):\n        \"\"\"\n        Returns the dimension of the label component of a single sample\n        \"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    def from_id(cls, task_id, **kwargs):\n        return cls._subclasses[task_id](**kwargs)\n\n    def generate_sample(self, rng, condition=None):\n        raise NotImplementedError(\n            \"Finite-sample tasks do not support the generation of samples.\"\n        )\n\n    @abstractmethod\n    def load_samples(self):\n        raise NotImplementedError", "\ndef binary_encode_label(y, bits):\n    \"\"\"Encode the label tensor y as a tensor of bits.\"\"\"\n    mask = 2**torch.arange(bits).to(y.device, y.dtype)\n    return y.unsqueeze(-1).bitwise_and(mask).ne(0).byte()\n\n\ndef quaternary_encode_label(y, quits):\n    \"\"\"Encode the label tensor y as a tensor of quits.\"\"\"\n    binary = binary_encode_label(y, 2*quits)\n    return binary[:, ::2] + 2 * binary[:, 1::2]", "\n\ndef octal_encode_label(y, octs):\n    \"\"\"Encode the label tensor y as a tensor of octs.\"\"\"\n    quaternary = quaternary_encode_label(y, 2*octs)\n    return quaternary[:, ::2] + 4 * quaternary[:, 1::2]"]}
{"filename": "nninfo/tasks/emnist_task.py", "chunked_list": ["import torch\nimport torchvision.datasets\n\nfrom .task import Task\n\nclass EMnist1DTask(Task):\n    task_id = \"emnist_1d_dat\"\n\n    @property\n    def finite(self):\n        return True\n\n    @property\n    def x_limits(self):\n        return (0, 1)\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 784\n\n    @property\n    def y_dim(self):\n        return 10\n\n    def load_samples(self):\n        emnist = torchvision.datasets.EMNIST(\n            root=\".../\", split='digits', download=True, train=True)\n        emnist_test = torchvision.datasets.EMNIST(\n            root=\"../\", split='digits', download=True, train=False)\n\n        x = torch.cat([torch.transpose(emnist.data, 1, 2), torch.transpose(\n            emnist_test.data, 1, 2)]).reshape(-1, 784) / 256\n        y = torch.cat([emnist.targets, emnist_test.targets])\n\n        return x.type(torch.float32), y.type(torch.long)"]}
{"filename": "nninfo/tasks/mnist_binary_task.py", "chunked_list": ["import torch\nimport torchvision.datasets\n\nfrom .task import Task\n\nclass MnistBinaryTask(Task):\n    task_id = \"mnist_binary_dat\"\n\n    @property\n    def finite(self):\n        return True\n\n    @property\n    def x_limits(self):\n        return (0, 1)\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 784\n\n    @property\n    def y_dim(self):\n        return 4\n\n    def load_samples(self):\n        mnist = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=True)\n        mnist_test = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=False)\n        qmnist_test = torchvision.datasets.QMNIST(\n            root=\"../\", what='test50k', download=True, train=False)\n\n        x = torch.cat([mnist.data, mnist_test.data,\n                       qmnist_test.data]).reshape(-1, 784) / 256.\n        y = torch.cat([mnist.targets, mnist_test.targets,\n                       qmnist_test.targets[:, 0]])\n\n        y_binary = self.binary(y, 4)\n\n        return x.type(torch.float32), y_binary.type(torch.float32)\n\n    def binary(self, x, bits):\n        mask = 2**torch.arange(bits).to(x.device, x.dtype)\n        return x.unsqueeze(-1).bitwise_and(mask).ne(0).byte()"]}
{"filename": "nninfo/tasks/fake_task.py", "chunked_list": ["import torch\nimport numpy as np\n\nfrom .task import Task\n\nclass FakeTask(Task):\n    task_id = \"fake_dat\"\n\n    @property\n    def finite(self):\n        return True\n\n    @property\n    def x_limits(self):\n        return \"binary\"\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        if \"x_dim\" in self._kwargs:\n            x_dim = self._kwargs[\"x_dim\"]\n        else:\n            x_dim = 12\n        return x_dim\n\n    @property\n    def y_dim(self):\n        return 1\n\n    def load_samples(self):\n        n_bits = self.x_dim\n        x = _create_all_possible_n_bit_configurations(n_bits)\n\n        # effectively setting y with x_0=0 to 1\n        y = np.zeros(x.shape[0], dtype=np.int)\n        y[int(x.shape[0] / 2):] = y[int(x.shape[0] / 2):] + 1\n        y = y[:, np.newaxis]\n        return torch.tensor(x, dtype=torch.float), torch.tensor(y, dtype=torch.float)", "    \ndef _create_all_possible_n_bit_configurations(n_bits):\n    n_samples = 2 ** n_bits\n    # create all integer values\n    x_int = np.linspace(0, n_samples - 1, n_samples, endpoint=True, dtype=np.uint32)[\n        :, np.newaxis\n    ]\n    # unpack integer values into bits\n    x_bit = np.unpackbits(np.flip(x_int.view(\"uint8\")), axis=1)\n    # cut bits to x_dim dimensions\n    return x_bit[:, x_bit.shape[1] - n_bits:]"]}
{"filename": "nninfo/tasks/cifar10_task.py", "chunked_list": ["import torch\nimport torchvision.datasets\n\nfrom .task import Task\n\nclass CIFAR10Task(Task):\n    task_id = \"cifar10_1d_dat\"\n\n    @property\n    def finite(self):\n        return True\n\n    @property\n    def x_limits(self):\n        return (0, 1)\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 32 * 32 * 3\n\n    @property\n    def y_dim(self):\n        return 10\n\n    def load_samples(self):\n\n        cifar10_train = torchvision.datasets.CIFAR10(\n            root=\"../\", download=True, train=True)\n        cifar10_test = torchvision.datasets.CIFAR10(\n            root=\"../\", download=True, train=False)\n        x_train = torch.from_numpy(cifar10_train.data) / 1.\n        x_test = torch.from_numpy(cifar10_test.data) / 1.\n        x = torch.cat([x_train, x_test])\n        x = x - torch.mean(x_train, axis=[0, 1, 2])\n        x = x / torch.std(x_train, axis=[0, 1, 2])\n\n        x = torch.transpose(x, 1, 3)\n\n        y = torch.cat([torch.tensor(cifar10_train.targets),\n                      torch.tensor(cifar10_test.targets)])\n\n        return x.type(torch.float32), y.type(torch.long)"]}
{"filename": "nninfo/tasks/combined_mnist_quaternary_task.py", "chunked_list": ["import torch\nimport torchvision.datasets\n\nfrom .task import Task, quaternary_encode_label\n\nclass CombinedMnistQuaternaryTask(Task):\n\n    task_id = \"combined_mnist_quaternary_dat\"\n\n    @property\n    def finite(self):\n        return True\n\n    @property\n    def x_limits(self):\n        return (0, 1)\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 784\n\n    @property\n    def y_dim(self):\n        return 3\n\n    def load_samples(self):\n        mnist = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=True)\n        mnist_test = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=False)\n\n        fmnist = torchvision.datasets.FashionMNIST(\n            root=\"../\", download=True, train=True)\n        fmnist_test = torchvision.datasets.FashionMNIST(\n            root=\"../\", download=True, train=False)\n\n        x = torch.cat([mnist.data, fmnist.data, mnist_test.data,\n                       fmnist_test.data]).reshape(-1, 784) / 256.\n        y = torch.cat([mnist.targets, fmnist.targets + 10, mnist_test.targets,\n                       fmnist_test.targets + 10])\n\n        y_binary = quaternary_encode_label(y, 3)\n\n        return x.type(torch.float32), y_binary.type(torch.float32)"]}
{"filename": "nninfo/tasks/__init__.py", "chunked_list": ["import os\nimport glob\n\n# Get a list of all Python module files in the current directory\nmodules = glob.glob(os.path.dirname(__file__) + \"/*.py\")\n__all__ = [os.path.basename(f)[:-3] for f in modules if os.path.isfile(f) and not f.startswith('_')]"]}
{"filename": "nninfo/tasks/fashion_mnist_task.py", "chunked_list": ["import torch\nimport torchvision.datasets\n\nfrom .task import Task\n\nclass FashionMnistTask(Task):\n    task_id = \"fashion_mnist_1d_dat\"\n\n    @property\n    def finite(self):\n        return True\n\n    @property\n    def x_limits(self):\n        return (0, 1)\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 784\n\n    @property\n    def y_dim(self):\n        return 10\n\n    def load_samples(self):\n        mnist = torchvision.datasets.FashionMNIST(\n            root=\"../\", download=True, train=True)\n        mnist_test = torchvision.datasets.FashionMNIST(\n            root=\"../\", download=True, train=False)\n\n        x = torch.cat([mnist.data, mnist_test.data]).reshape(-1, 784) / 256.\n        y = torch.cat([mnist.targets, mnist_test.targets])\n\n        return x.type(torch.float32), y.type(torch.long)"]}
{"filename": "nninfo/tasks/mnist_reduced_task.py", "chunked_list": ["import torch\nimport torchvision.datasets\n\nfrom .task import Task\n\nclass ReducedMnistTask(Task):\n    task_id = \"mnist_reduced_dat\"\n\n    @property\n    def finite(self):\n        return True\n\n    @property\n    def x_limits(self):\n        return (0, 1)\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 784\n\n    @property\n    def y_dim(self):\n        return 10\n\n    def load_samples(self):\n        mnist = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=True)\n        mnist_test = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=False)\n\n        x = torch.cat([mnist.train_data, mnist_test.test_data]\n                      ).reshape(-1, 784)\n        y = torch.cat([mnist.train_labels, mnist_test.test_labels])\n\n        # Apply filter\n        f = (y == 3) | (y == 6) | (y == 8) | (y == 9)\n        x = x[f]\n        y = y[f]\n\n        return x.type(torch.float32), y.type(torch.long)"]}
{"filename": "nninfo/tasks/parity_task.py", "chunked_list": ["import torch\nimport numpy as np\n\nfrom .task import Task\n\nclass ParityTask(Task):\n    task_id = \"parity\"\n\n    @property\n    def finite(self):\n        return False\n\n    @property\n    def x_limits(self):\n        return (0, 1) if self._kwargs[\"continuous\"] else \"binary\"\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return self._kwargs[\"n_bits\"]\n\n    @property\n    def y_dim(self):\n        return 1\n\n    def generate_sample(self, rng, condition=None):\n        n_bits = self._kwargs[\"n_bits\"]\n\n        if self._kwargs[\"continuous\"]:\n            x = rng.random(size=n_bits, dtype=np.float32)\n            y = (x >= 0.5).sum() % 2\n        else:\n            x = rng.integers(2, size=n_bits)\n            y = x.sum() % 2\n\n        return torch.tensor(x, dtype=torch.float), torch.tensor([y], dtype=torch.float)"]}
{"filename": "nninfo/tasks/xor_task.py", "chunked_list": ["import torch\nimport numpy as np\n\nfrom .task import Task\n\nclass XorTask(Task):\n    task_id = \"xor_dat\"\n\n    @property\n    def finite(self):\n        return False\n\n    @property\n    def x_limits(self):\n        return (0, 1)\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 2\n\n    @property\n    def y_dim(self):\n        return 1\n\n    def generate_sample(self, rng, condition=None):\n        x = rng.random(2, dtype=np.float32)\n        y = (x[0] >= 0.5) ^ (x[1] >= 0.5)\n        return x, torch.tensor([y], dtype=torch.float)"]}
{"filename": "nninfo/tasks/xor_misinfo_task.py", "chunked_list": ["import torch\nimport numpy as np\n\nfrom .task import Task\n\nclass XorTaskMissInfo(Task):\n    task_id = \"XorTaskMissInfo_dat\"\n\n    @property\n    def finite(self):\n        return False\n\n    @property\n    def x_limits(self):\n        return (0, 1)\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 3\n\n    @property\n    def y_dim(self):\n        return 1\n\n    def generate_sample(self, rng, condition=None):\n        x = rng.random(3, dtype=np.float32)\n        y = (x[0] >= 0.5) ^ (x[1] >= 0.5)\n        return x, torch.tensor([y], dtype=torch.float)"]}
{"filename": "nninfo/tasks/mnist1d_task.py", "chunked_list": ["import torch\nimport torchvision.datasets\n\nfrom .task import Task\n\nclass Mnist1DTask(Task):\n    task_id = \"mnist_1d_dat\"\n\n    @property\n    def finite(self):\n        return True\n\n    @property\n    def x_limits(self):\n        return (0, 1)\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 784\n\n    @property\n    def y_dim(self):\n        return 10\n\n    def load_samples(self):\n        mnist = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=True)\n        mnist_test = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=False)\n        qmnist_test = torchvision.datasets.QMNIST(\n            root=\"../\", what='test50k', download=True, train=False)\n\n        x = torch.cat([mnist.data, mnist_test.data,\n                      qmnist_test.data]).reshape(-1, 784) / 256.\n        y = torch.cat([mnist.targets, mnist_test.targets,\n                      qmnist_test.targets[:, 0]])\n\n        return x.type(torch.float32), y.type(torch.long)"]}
{"filename": "nninfo/tasks/combined_mnist_binary_task.py", "chunked_list": ["import torch\nimport torchvision.datasets\n\nfrom .task import Task, binary_encode_label\n\nclass CombinedMnistBinaryTask(Task):\n    task_id = \"combined_mnist_binary_dat\"\n\n    @property\n    def finite(self):\n        return True\n\n    @property\n    def x_limits(self):\n        return (0, 1)\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 784\n\n    @property\n    def y_dim(self):\n        return 5\n\n    def load_samples(self):\n        mnist = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=True)\n        mnist_test = torchvision.datasets.MNIST(\n            root=\"../\", download=True, train=False)\n\n        fmnist = torchvision.datasets.FashionMNIST(\n            root=\"../\", download=True, train=True)\n        fmnist_test = torchvision.datasets.FashionMNIST(\n            root=\"../\", download=True, train=False)\n\n        x = torch.cat([mnist.data, fmnist.data, mnist_test.data,\n                       fmnist_test.data]).reshape(-1, 784) / 256.\n        y = torch.cat([mnist.targets, fmnist.targets + 10, mnist_test.targets,\n                       fmnist_test.targets + 10])\n\n        y_binary = binary_encode_label(y, 5)\n\n        return x.type(torch.float32), y_binary.type(torch.float32)"]}
{"filename": "nninfo/tasks/checkerboard_task.py", "chunked_list": ["import torch\nimport numpy as np\n\nfrom .task import Task\n\nclass CheckerboardTask(Task):\n    task_id = \"checkerboard\"\n\n    @property\n    def finite(self):\n        return False\n\n    @property\n    def x_limits(self):\n        return (0, 1)\n\n    @property\n    def y_limits(self):\n        return \"binary\"\n\n    @property\n    def x_dim(self):\n        return 2\n\n    @property\n    def y_dim(self):\n        return 1\n\n    def generate_sample(self, rng, condition=None):\n        size = self._kwargs['size']\n        x = rng.random(2, dtype=np.float32)\n        y = (int(x[0] * size[0]) + int(x[1] * size[1])) % 2\n        return x, torch.tensor([y], dtype=torch.float)"]}
{"filename": "nninfo/tasks/rec_majority_task.py", "chunked_list": ["from .task import Task\n\nclass RecMajorityTask(Task):\n    task_id = \"rec_maj\"\n\n    def __init__(self, **kwargs):\n        \"\"\"\n        Expected kwargs:\n            voter_list: list of numbers of voters for each recursive layer\n        \"\"\"\n        super().__init__(self, kwargs)\n\n        assert \"voter_list\" in kwargs\n\n    def x_limits(self):\n        return \"binary\"\n\n    def y_limits(self):\n        return \"binary\"\n\n    def x_dim(self):\n        return self._kwargs[\"voter_list\"][0]\n\n    def y_dim(self):\n        return 1\n\n    def generate_sample(self, rng):\n        x = rng.integers(1, size=10)"]}
{"filename": "nninfo/tasks/task_manager.py", "chunked_list": ["from ..exp_comp import ExperimentComponent\nfrom ..data_set import DataSet, CachedDataset, LazyDataset\nfrom .task import Task\n\nclass TaskManager(ExperimentComponent):\n    \"\"\"\n    Helper class, handles a task with one 'full_set' dataset and several subsets,\n    which are then used by Trainer, Tester or Evaluation.\n    \"\"\"\n\n    def __init__(self, task_id=None, **kwargs):\n        \"\"\"\n        Creates a new instance of TaskManager. Loads the\n        dataset according to task_id.\n\n        Keyword Args:\n            task_id (str): one of the pre-implemented Tasks:\n                'tishby_dat', 'andreas_dat', 'fake_dat' etc.\n\n        Passes additional arguments on to dataset creation if given.\n        \"\"\"\n\n        super().__init__()\n\n        self._dataset = None\n        self._kwargs = kwargs\n\n        task_kwargs = kwargs.get(\"task_kwargs\", {})\n        self.task = Task.from_id(task_id, **task_kwargs)\n\n        if self.task.finite:\n            self._dataset = CachedDataset(self.task, \"full_set\")\n        else:\n            seed = kwargs[\"seed\"]\n            n_samples = kwargs[\"n_samples\"]\n            self._dataset = LazyDataset(self.task, \"full_set\", n_samples, seed)\n    \n    @staticmethod\n    def from_config(config):\n        \"\"\"\n        Creates a new TaskManager from a config dictionary\n        \"\"\"\n        task_manager = TaskManager(\n            task_id=config[\"task_id\"],\n            **config[\"kwarg_dict\"],\n        )\n\n        task_manager._dataset = DataSet.from_config(task_manager.task, config[\"subsets\"])\n\n        return task_manager\n\n    def to_config(self):\n        \"\"\"\n        Creates a config dictionary from the TaskManager\n        \"\"\"\n        output_dict = {\n            \"task_id\": self.task.task_id,\n            \"kwarg_dict\": self._kwargs,\n            \"subsets\": self._dataset.to_config(),\n            \"task_kwargs\": self.task.kwargs,\n        }\n\n        return output_dict\n\n    def get_binning_limits(self, label):\n        if label == \"X\":\n            return self.task.x_limits\n        elif label == \"Y\":\n            return self.task.y_limits\n        else:\n            raise AttributeError\n\n    def get_input_output_dimensions(self):\n        return self.task.x_dim, self.task.y_dim\n\n    def __getitem__(self, dataset_name):\n        \"\"\"\n        Finds the dataset by the given name in the dataset tree\n        \"\"\"\n        return self._dataset.find(dataset_name)\n\n    def __str__(self, level=0):\n        ret = self._dataset.__str__()\n        return ret"]}
