{"filename": "tests/test_examples.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nfrom examples import hello_world, psycopg2_connect, server_utilisation, sqlalchemy_orm, sqlalchemy_raw\n\n\ndef test_hello_world():\n    hello_world.main()", "\ndef test_hello_world():\n    hello_world.main()\n\n\ndef test_psycopg2_connect():\n    psycopg2_connect.main()\n\n\ndef test_server_utilisation():\n    server_utilisation.main(duration_sec=2.0)", "\ndef test_server_utilisation():\n    server_utilisation.main(duration_sec=2.0)\n\n\ndef test_sqlalchemy_orm():\n    sqlalchemy_orm.main()\n\n\ndef test_sqlalchemy_raw():\n    sqlalchemy_raw.main()", "\ndef test_sqlalchemy_raw():\n    sqlalchemy_raw.main()\n"]}
{"filename": "tests/test_types.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport re\n\nimport questdb_connect as qdbc\n", "import questdb_connect as qdbc\n\n\ndef test_resolve_type_from_name():\n    for type_class in qdbc.QUESTDB_TYPES:\n        resolved_class = qdbc.resolve_type_from_name(type_class.__visit_name__)\n        assert type_class.__visit_name__ == resolved_class.__visit_name__\n        assert isinstance(type_class(), resolved_class)\n        assert isinstance(resolved_class(), type_class)\n\n    for n in range(1, 61):\n        g_name = qdbc.geohash_type_name(n)\n        g_class = qdbc.resolve_type_from_name(g_name)\n        assert isinstance(g_class(), qdbc.geohash_class(n))", "\n\ndef test_superset_default_mappings():\n    default_column_type_mappings = (\n        (re.compile(\"^LONG256\", re.IGNORECASE), qdbc.Long256),\n        (re.compile(\"^BOOLEAN\", re.IGNORECASE), qdbc.Boolean),\n        (re.compile(\"^BYTE\", re.IGNORECASE), qdbc.Byte),\n        (re.compile(\"^SHORT\", re.IGNORECASE), qdbc.Short),\n        (re.compile(\"^INT\", re.IGNORECASE), qdbc.Int),\n        (re.compile(\"^LONG\", re.IGNORECASE), qdbc.Long),\n        (re.compile(\"^FLOAT\", re.IGNORECASE), qdbc.Float),\n        (re.compile(\"^DOUBLE'\", re.IGNORECASE), qdbc.Double),\n        (re.compile(\"^SYMBOL\", re.IGNORECASE), qdbc.Symbol),\n        (re.compile(\"^STRING\", re.IGNORECASE), qdbc.String),\n        (re.compile(\"^UUID\", re.IGNORECASE), qdbc.UUID),\n        (re.compile(\"^CHAR\", re.IGNORECASE), qdbc.Char),\n        (re.compile(\"^TIMESTAMP\", re.IGNORECASE), qdbc.Timestamp),\n        (re.compile(\"^DATE\", re.IGNORECASE), qdbc.Date)\n    )\n    for type_class in qdbc.QUESTDB_TYPES:\n        for pattern, _expected_type in default_column_type_mappings:\n            matching_name = pattern.match(type_class.__visit_name__)\n            if matching_name:\n                resolved_class = qdbc.resolve_type_from_name(matching_name.group(0))\n                assert type_class.__visit_name__ == resolved_class.__visit_name__\n                assert isinstance(type_class(), resolved_class)\n                assert isinstance(resolved_class(), type_class)\n                break\n    geohash_pattern = re.compile(r\"^GEOHASH\\(\\d+[b|c]\\)\", re.IGNORECASE)\n    for n in range(1, 61):\n        g_name = qdbc.geohash_type_name(n)\n        matching_name = geohash_pattern.match(g_name).group(0)\n        assert matching_name == g_name\n        g_class = qdbc.resolve_type_from_name(g_name)\n        assert isinstance(g_class(), qdbc.geohash_class(n))", ""]}
{"filename": "tests/__init__.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\n"]}
{"filename": "tests/test_superset.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport datetime\nfrom unittest import mock\n\nimport pytest", "\nimport pytest\nfrom qdb_superset.db_engine_specs.questdb import QuestDbEngineSpec\nfrom questdb_connect.types import QUESTDB_TYPES, Timestamp\nfrom sqlalchemy import column, literal_column\nfrom sqlalchemy.types import TypeEngine\n\n\ndef test_build_sqlalchemy_uri():\n    request_uri = QuestDbEngineSpec.build_sqlalchemy_uri(\n        {\n            \"host\": \"localhost\",\n            \"port\": \"8812\",\n            \"username\": \"admin\",\n            \"password\": \"quest\",\n            \"database\": \"main\",\n        }\n    )\n    assert request_uri == \"questdb://admin:quest@localhost:8812/main\"", "def test_build_sqlalchemy_uri():\n    request_uri = QuestDbEngineSpec.build_sqlalchemy_uri(\n        {\n            \"host\": \"localhost\",\n            \"port\": \"8812\",\n            \"username\": \"admin\",\n            \"password\": \"quest\",\n            \"database\": \"main\",\n        }\n    )\n    assert request_uri == \"questdb://admin:quest@localhost:8812/main\"", "\n\ndef test_default_schema_for_query():\n    assert QuestDbEngineSpec.get_default_schema_for_query(\"main\", None) == None\n\n\ndef test_get_text_clause():\n    sql_clause = \"SELECT * FROM public.mytable t1\"\n    sql_clause += \" JOIN public.myclient t2 ON t1.id = t2.id\"\n    expected_clause = \"SELECT * FROM mytable t1 JOIN myclient t2 ON t1.id = t2.id\"\n    actual_clause = str(QuestDbEngineSpec.get_text_clause(sql_clause))\n    print(f\"sql: {sql_clause}, ex: {expected_clause}, ac: {actual_clause}\")\n    assert expected_clause == actual_clause", "\n\ndef test_epoch_to_dttm():\n    assert QuestDbEngineSpec.epoch_to_dttm() == \"{col} * 1000000\"\n\n\n@pytest.mark.parametrize(\n    (\"target_type\", \"expected_result\", \"dttm\"),\n    [\n        (", "    [\n        (\n                \"Date\",\n                \"TO_DATE('2023-04-28', 'YYYY-MM-DD')\",\n                datetime.datetime(2023, 4, 28, 23, 55, 59, 281567),\n        ),\n        (\n                \"DateTime\",\n                \"TO_TIMESTAMP('2023-04-28T23:55:59.281567', 'yyyy-MM-ddTHH:mm:ss.SSSUUUZ')\",\n                datetime.datetime(2023, 4, 28, 23, 55, 59, 281567),", "                \"TO_TIMESTAMP('2023-04-28T23:55:59.281567', 'yyyy-MM-ddTHH:mm:ss.SSSUUUZ')\",\n                datetime.datetime(2023, 4, 28, 23, 55, 59, 281567),\n        ),\n        (\n                \"TimeStamp\",\n                \"TO_TIMESTAMP('2023-04-28T23:55:59.281567', 'yyyy-MM-ddTHH:mm:ss.SSSUUUZ')\",\n                datetime.datetime(2023, 4, 28, 23, 55, 59, 281567),\n        ),\n        (\"UnknownType\", None, datetime.datetime(2023, 4, 28, 23, 55, 59, 281567)),\n    ],", "        (\"UnknownType\", None, datetime.datetime(2023, 4, 28, 23, 55, 59, 281567)),\n    ],\n)\ndef test_convert_dttm(target_type, expected_result, dttm) -> None:\n    # datetime(year, month, day, hour, minute, second, microsecond)\n    for target in (\n            target_type,\n            target_type.upper(),\n            target_type.lower(),\n            target_type.capitalize(),\n    ):\n        assert expected_result == QuestDbEngineSpec.convert_dttm(\n            target_type=target, dttm=dttm\n        )", "\n\ndef test_get_datatype():\n    assert QuestDbEngineSpec.get_datatype(\"int\") == \"INT\"\n    assert QuestDbEngineSpec.get_datatype([\"int\"]) == \"['int']\"\n\n\ndef test_get_column_spec():\n    for native_type in QUESTDB_TYPES:\n        column_spec = QuestDbEngineSpec.get_column_spec(native_type.__visit_name__)\n        assert native_type == column_spec.sqla_type\n        assert native_type != Timestamp or column_spec.is_dttm", "\n\ndef test_get_sqla_column_type():\n    for native_type in QUESTDB_TYPES:\n        column_type = QuestDbEngineSpec.get_sqla_column_type(native_type.__visit_name__)\n        assert isinstance(column_type, TypeEngine.__class__)\n\n\ndef test_get_allow_cost_estimate():\n    assert not QuestDbEngineSpec.get_allow_cost_estimate(extra=None)", "def test_get_allow_cost_estimate():\n    assert not QuestDbEngineSpec.get_allow_cost_estimate(extra=None)\n\n\ndef test_get_view_names():\n    assert set() == QuestDbEngineSpec.get_view_names(\"main\", None, None)\n\n\ndef test_get_table_names():\n    inspector = mock.Mock()\n    inspector.get_table_names = mock.Mock(\n        return_value=[\"public.table\", \"table_2\", '\"public.table_3\"']\n    )\n    pg_result = QuestDbEngineSpec.get_table_names(\n        database=mock.ANY, schema=\"public\", inspector=inspector\n    )\n    assert {\"table\", '\"public.table_3\"', \"table_2\"} == pg_result", "def test_get_table_names():\n    inspector = mock.Mock()\n    inspector.get_table_names = mock.Mock(\n        return_value=[\"public.table\", \"table_2\", '\"public.table_3\"']\n    )\n    pg_result = QuestDbEngineSpec.get_table_names(\n        database=mock.ANY, schema=\"public\", inspector=inspector\n    )\n    assert {\"table\", '\"public.table_3\"', \"table_2\"} == pg_result\n", "\n\ndef test_time_exp_literal_no_grain(test_engine):\n    col = literal_column(\"COALESCE(a, b)\")\n    expr = QuestDbEngineSpec.get_timestamp_expr(col, None, None)\n    result = str(expr.compile(None, dialect=test_engine.dialect))\n    assert \"COALESCE(a, b)\" == result\n\n\ndef test_time_ex_lowr_col_no_grain(test_engine):\n    col = column(\"lower_case\")\n    expr = QuestDbEngineSpec.get_timestamp_expr(col, None, None)\n    result = str(expr.compile(None, dialect=test_engine.dialect))\n    assert \"lower_case\" == result", "\ndef test_time_ex_lowr_col_no_grain(test_engine):\n    col = column(\"lower_case\")\n    expr = QuestDbEngineSpec.get_timestamp_expr(col, None, None)\n    result = str(expr.compile(None, dialect=test_engine.dialect))\n    assert \"lower_case\" == result\n"]}
{"filename": "tests/test_dialect.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport datetime\n\nimport questdb_connect as qdbc\nimport sqlalchemy as sqla", "import questdb_connect as qdbc\nimport sqlalchemy as sqla\nfrom sqlalchemy.orm import Session\n\nfrom tests.conftest import ALL_TYPES_TABLE_NAME, collect_select_all, collect_select_all_raw_connection\n\n\ndef test_insert(test_engine, test_model):\n    with test_engine.connect() as conn:\n        assert test_engine.dialect.has_table(conn, ALL_TYPES_TABLE_NAME)\n        assert not test_engine.dialect.has_table(conn, 'scorchio')\n        now = datetime.datetime(2023, 4, 12, 23, 55, 59, 342380)\n        now_date = now.date()\n        expected = (\"(True, 8, 12, 13, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n                    \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n                    \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n                    \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\\n\"\n                    \"(True, 8, 12, 13, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n                    \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n                    \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n                    \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\")\n        insert_stmt = sqla.insert(test_model).values(\n            col_boolean=True,\n            col_byte=8,\n            col_short=12,\n            col_int=13,\n            col_long=14,\n            col_float=15.234,\n            col_double=16.88993244,\n            col_symbol='coconut',\n            col_string='banana',\n            col_char='C',\n            col_uuid='6d5eb038-63d1-4971-8484-30c16e13de5b',\n            col_date=now_date,\n            col_ts=now,\n            col_geohash='dfvgsj2vptwu',\n            col_long256='0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a'\n        )\n        conn.execute(insert_stmt)\n        conn.execute(sqla.insert(test_model), {\n            'col_boolean': True,\n            'col_byte': 8,\n            'col_short': 12,\n            'col_int': 13,\n            'col_long': 14,\n            'col_float': 15.234,\n            'col_double': 16.88993244,\n            'col_symbol': 'coconut',\n            'col_string': 'banana',\n            'col_char': 'C',\n            'col_uuid': '6d5eb038-63d1-4971-8484-30c16e13de5b',\n            'col_date': now_date,\n            'col_ts': now,\n            'col_geohash': 'dfvgsj2vptwu',\n            'col_long256': '0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a'\n        })\n        assert collect_select_all(conn, expected_rows=2) == expected\n    assert collect_select_all_raw_connection(test_engine, expected_rows=2) == expected", "\n\ndef test_inspect(test_engine, test_model):\n    now = datetime.datetime(2023, 4, 12, 23, 55, 59, 342380)\n    now_date = now.date()\n    session = Session(test_engine)\n    try:\n        session.add(test_model(\n            col_boolean=True,\n            col_byte=8,\n            col_short=12,\n            col_int=0,\n            col_long=14,\n            col_float=15.234,\n            col_double=16.88993244,\n            col_symbol='coconut',\n            col_string='banana',\n            col_char='C',\n            col_uuid='6d5eb038-63d1-4971-8484-30c16e13de5b',\n            col_date=now_date,\n            col_ts=now,\n            col_geohash='dfvgsj2vptwu',\n            col_long256='0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a'\n        ))\n        session.commit()\n    finally:\n        if session:\n            session.close()\n    metadata = sqla.MetaData()\n    table = sqla.Table(ALL_TYPES_TABLE_NAME, metadata, autoload_with=test_engine)\n    table_columns = str([(col.name, col.type, col.primary_key) for col in table.columns])\n    assert table_columns == str([\n        ('col_boolean', qdbc.Boolean(), False),\n        ('col_byte', qdbc.Byte(), False),\n        ('col_short', qdbc.Short(), False),\n        ('col_int', qdbc.Int(), False),\n        ('col_long', qdbc.Long(), False),\n        ('col_float', qdbc.Float(), False),\n        ('col_double', qdbc.Double(), False),\n        ('col_symbol', qdbc.Symbol(), False),\n        ('col_string', qdbc.String(), False),\n        ('col_char', qdbc.Char(), False),\n        ('col_uuid', qdbc.UUID(), False),\n        ('col_date', qdbc.Date(), False),\n        ('col_ts', qdbc.Timestamp(), True),\n        ('col_geohash', qdbc.GeohashInt(), False),\n        ('col_long256', qdbc.Long256(), False)\n    ])", "\n\ndef test_multiple_insert(test_engine, test_model):\n    now = datetime.datetime(2023, 4, 12, 23, 55, 59, 342380)\n    now_date = now.date()\n    session = Session(test_engine)\n    num_rows = 3\n    expected = (\"(True, 8, 12, 2, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n                \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n                \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n                \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\\n\"\n                \"(True, 8, 12, 1, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n                \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n                \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n                \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\\n\"\n                \"(True, 8, 12, 0, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n                \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n                \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n                \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\")\n    try:\n        for idx in range(num_rows):\n            session.add(test_model(\n                col_boolean=True,\n                col_byte=8,\n                col_short=12,\n                col_int=idx,\n                col_long=14,\n                col_float=15.234,\n                col_double=16.88993244,\n                col_symbol='coconut',\n                col_string='banana',\n                col_char='C',\n                col_uuid='6d5eb038-63d1-4971-8484-30c16e13de5b',\n                col_date=now_date,\n                col_ts=now,\n                col_geohash='dfvgsj2vptwu',\n                col_long256='0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a'\n            ))\n            session.commit()\n        assert collect_select_all(session, expected_rows=num_rows) == expected\n    finally:\n        if session:\n            session.close()\n        assert collect_select_all_raw_connection(test_engine, expected_rows=num_rows) == expected", "\n\ndef test_bulk_insert(test_engine, test_model):\n    now = datetime.datetime(2023, 4, 12, 23, 55, 59, 342380)\n    now_date = now.date()\n    session = Session(test_engine)\n    num_rows = 3\n    expected = (\"(True, 8, 12, 2, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n                \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n                \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n                \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\\n\"\n                \"(True, 8, 12, 1, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n                \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n                \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n                \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\\n\"\n                \"(True, 8, 12, 0, 14, 15.234, 16.88993244, 'coconut', 'banana', 'C', \"\n                \"UUID('6d5eb038-63d1-4971-8484-30c16e13de5b'), datetime.datetime(2023, 4, 12, \"\n                \"0, 0), datetime.datetime(2023, 4, 12, 23, 55, 59, 342380), 'dfvgsj', \"\n                \"'0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a')\")\n    models = [\n        test_model(\n            col_boolean=True,\n            col_byte=8,\n            col_short=12,\n            col_int=idx,\n            col_long=14,\n            col_float=15.234,\n            col_double=16.88993244,\n            col_symbol='coconut',\n            col_string='banana',\n            col_char='C',\n            col_uuid='6d5eb038-63d1-4971-8484-30c16e13de5b',\n            col_date=now_date,\n            col_ts=now,\n            col_geohash='dfvgsj2vptwu',\n            col_long256='0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a'\n        ) for idx in range(num_rows)\n    ]\n    try:\n        session.bulk_save_objects(models)\n        session.commit()\n        assert collect_select_all(session, expected_rows=num_rows) == expected\n    finally:\n        if session:\n            session.close()\n        assert collect_select_all_raw_connection(test_engine, expected_rows=num_rows) == expected", "\n\ndef test_functions(test_engine):\n    with test_engine.connect() as conn:\n        expected = [row[0] for row in conn.execute(\"SELECT name FROM functions()\").fetchall()]\n        assert qdbc.get_functions_list() == expected\n\n\ndef test_keywords(test_engine):\n    with test_engine.connect() as conn:\n        expected = [row[0] for row in conn.execute(\"SELECT keyword FROM keywords()\").fetchall()]\n        assert qdbc.get_keywords_list() == expected", "def test_keywords(test_engine):\n    with test_engine.connect() as conn:\n        expected = [row[0] for row in conn.execute(\"SELECT keyword FROM keywords()\").fetchall()]\n        assert qdbc.get_keywords_list() == expected\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport os\nfrom typing import NamedTuple\n\nimport pytest", "\nimport pytest\nimport questdb_connect as qdbc\nfrom sqlalchemy import Column, MetaData, text\nfrom sqlalchemy.orm import declarative_base\n\nos.environ.setdefault('SQLALCHEMY_SILENCE_UBER_WARNING', '1')\n\nALL_TYPES_TABLE_NAME = 'all_types_table'\nMETRICS_TABLE_NAME = 'metrics_table'", "ALL_TYPES_TABLE_NAME = 'all_types_table'\nMETRICS_TABLE_NAME = 'metrics_table'\n\n\nclass TestConfig(NamedTuple):\n    host: str\n    port: int\n    username: str\n    password: str\n    database: str\n    __test__ = True", "\n\n@pytest.fixture(scope='session', autouse=True, name='test_config')\ndef test_config_fixture() -> TestConfig:\n    return TestConfig(\n        host=os.environ.get('QUESTDB_CONNECT_HOST', 'localhost'),\n        port=int(os.environ.get('QUESTDB_CONNECT_PORT', '8812')),\n        username=os.environ.get('QUESTDB_CONNECT_USER', 'admin'),\n        password=os.environ.get('QUESTDB_CONNECT_PASSWORD', 'quest'),\n        database=os.environ.get('QUESTDB_CONNECT_DATABASE', 'main')\n    )", "\n\n@pytest.fixture(scope='module', name='test_engine')\ndef test_engine_fixture(test_config: TestConfig):\n    engine = None\n    try:\n        engine = qdbc.create_engine(\n            test_config.host,\n            test_config.port,\n            test_config.username,\n            test_config.password,\n            test_config.database)\n        return engine\n    finally:\n        if engine:\n            engine.dispose()\n            del engine", "\n\n@pytest.fixture(autouse=True, name='test_model')\ndef test_model_fixture(test_engine):\n    Base = declarative_base(metadata=MetaData())\n\n    class TableModel(Base):\n        __tablename__ = ALL_TYPES_TABLE_NAME\n        __table_args__ = (qdbc.QDBTableEngine(ALL_TYPES_TABLE_NAME, 'col_ts', qdbc.PartitionBy.DAY, is_wal=True),)\n        col_boolean = Column('col_boolean', qdbc.Boolean)\n        col_byte = Column('col_byte', qdbc.Byte)\n        col_short = Column('col_short', qdbc.Short)\n        col_int = Column('col_int', qdbc.Int)\n        col_long = Column('col_long', qdbc.Long)\n        col_float = Column('col_float', qdbc.Float)\n        col_double = Column('col_double', qdbc.Double)\n        col_symbol = Column('col_symbol', qdbc.Symbol)\n        col_string = Column('col_string', qdbc.String)\n        col_char = Column('col_char', qdbc.Char)\n        col_uuid = Column('col_uuid', qdbc.UUID)\n        col_date = Column('col_date', qdbc.Date)\n        col_ts = Column('col_ts', qdbc.Timestamp, primary_key=True)\n        col_geohash = Column('col_geohash', qdbc.GeohashInt)\n        col_long256 = Column('col_long256', qdbc.Long256)\n\n    Base.metadata.drop_all(test_engine)\n    Base.metadata.create_all(test_engine)\n    return TableModel", "\n\n@pytest.fixture(autouse=True, name='test_metrics')\ndef test_metrics_fixture(test_engine):\n    Base = declarative_base(metadata=MetaData())\n\n    class TableMetrics(Base):\n        __tablename__ = METRICS_TABLE_NAME\n        __table_args__ = (qdbc.QDBTableEngine(METRICS_TABLE_NAME, 'ts', qdbc.PartitionBy.HOUR, is_wal=True),)\n        source = Column(qdbc.Symbol)\n        attr_name = Column(qdbc.Symbol)\n        attr_value = Column(qdbc.Double)\n        ts = Column(qdbc.Timestamp, primary_key=True)\n\n    Base.metadata.drop_all(test_engine)\n    Base.metadata.create_all(test_engine)\n    return TableMetrics", "\n\ndef collect_select_all(session, expected_rows) -> str:\n    while True:\n        rs = session.execute(text(f'select * from public.{ALL_TYPES_TABLE_NAME} order by 1 asc'))\n        if rs.rowcount == expected_rows:\n            return '\\n'.join(str(row) for row in rs)\n\n\ndef collect_select_all_raw_connection(test_engine, expected_rows) -> str:\n    conn = test_engine.raw_connection()\n    try:\n        while True:\n            with conn.cursor() as cursor:\n                cursor.execute(f'select * from public.{ALL_TYPES_TABLE_NAME} order by 1 asc')\n                if cursor.rowcount == expected_rows:\n                    return '\\n'.join(str(row) for row in cursor)\n    finally:\n        if conn:\n            conn.close()", "\ndef collect_select_all_raw_connection(test_engine, expected_rows) -> str:\n    conn = test_engine.raw_connection()\n    try:\n        while True:\n            with conn.cursor() as cursor:\n                cursor.execute(f'select * from public.{ALL_TYPES_TABLE_NAME} order by 1 asc')\n                if cursor.rowcount == expected_rows:\n                    return '\\n'.join(str(row) for row in cursor)\n    finally:\n        if conn:\n            conn.close()", ""]}
{"filename": "src/examples/server_utilisation.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport datetime\nimport enum\nimport os\nimport random", "import os\nimport random\nimport time\n\nos.environ.setdefault(\"SQLALCHEMY_SILENCE_UBER_WARNING\", \"1\")\n\nimport questdb_connect as qdbc\nfrom sqlalchemy import Column, MetaData, create_engine\nfrom sqlalchemy.orm import Session, declarative_base\n", "from sqlalchemy.orm import Session, declarative_base\n\n\nclass BaseEnum(enum.Enum):\n    @classmethod\n    def rand(cls):\n        return cls._value2member_map_[random.randint(0, len(cls._member_map_) - 1)]\n\n\nclass Nodes(BaseEnum):\n    NODE0 = 0\n    NODE1 = 1", "\nclass Nodes(BaseEnum):\n    NODE0 = 0\n    NODE1 = 1\n\n\nclass Metrics(BaseEnum):\n    CPU = 0\n    RAM = 1\n    HDD0 = 2\n    HDD1 = 3\n    NETWORK = 4", "\n\nBase = declarative_base(metadata=MetaData())\n\n\nclass NodeMetrics(Base):\n    __tablename__ = \"node_metrics\"\n    __table_args__ = (\n        qdbc.QDBTableEngine(\"node_metrics\", \"ts\", qdbc.PartitionBy.HOUR, is_wal=True),\n    )\n    source = Column(qdbc.Symbol)  # Nodes\n    attr_name = Column(qdbc.Symbol)  # Metrics\n    attr_value = Column(qdbc.Double)\n    ts = Column(qdbc.Timestamp, primary_key=True)", "\n\ndef main(duration_sec: float = 10.0):\n    end_time = time.time() + max(duration_sec - 0.5, 2.0)\n    engine = create_engine(\"questdb://localhost:8812/main\")\n    session = Session(engine)\n    max_batch_size = 3000\n    try:\n        Base.metadata.drop_all(engine)\n        Base.metadata.create_all(engine)\n        batch_size = 0\n        while time.time() < end_time:\n            node = Nodes.rand()\n            session.add(\n                NodeMetrics(\n                    source=node.name,\n                    attr_name=Metrics.rand().name,\n                    attr_value=random.random() * node.value * random.randint(1, 100),\n                    ts=datetime.datetime.utcnow(),\n                )\n            )\n            batch_size += 1\n            if batch_size > max_batch_size:\n                session.commit()\n                batch_size = 0\n        if batch_size > 0:\n            session.commit()\n    finally:\n        if session:\n            session.close()\n        if engine:\n            engine.dispose()", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "src/examples/hello_world.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport datetime\nimport os\n\nos.environ.setdefault(\"SQLALCHEMY_SILENCE_UBER_WARNING\", \"1\")", "\nos.environ.setdefault(\"SQLALCHEMY_SILENCE_UBER_WARNING\", \"1\")\n\nimport questdb_connect as qdbc\nfrom sqlalchemy import Column, MetaData, create_engine, insert\nfrom sqlalchemy.orm import declarative_base\n\nBase = declarative_base(metadata=MetaData())\n\n\nclass Signal(Base):\n    __tablename__ = \"signal\"\n    __table_args__ = (\n        qdbc.QDBTableEngine(\"signal\", \"ts\", qdbc.PartitionBy.HOUR, is_wal=True),\n    )\n    source = Column(qdbc.Symbol)\n    value = Column(qdbc.Double)\n    ts = Column(qdbc.Timestamp, primary_key=True)", "\n\nclass Signal(Base):\n    __tablename__ = \"signal\"\n    __table_args__ = (\n        qdbc.QDBTableEngine(\"signal\", \"ts\", qdbc.PartitionBy.HOUR, is_wal=True),\n    )\n    source = Column(qdbc.Symbol)\n    value = Column(qdbc.Double)\n    ts = Column(qdbc.Timestamp, primary_key=True)", "\n\ndef main():\n    engine = create_engine(\"questdb://localhost:8812/main\")\n    try:\n        Base.metadata.create_all(engine)\n        with engine.connect() as conn:\n            conn.execute(\n                insert(Signal).values(\n                    source=\"coconut\", value=16.88993244, ts=datetime.datetime.utcnow()\n                )\n            )\n    finally:\n        if engine:\n            engine.dispose()", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "src/examples/sqlalchemy_raw.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport sqlalchemy as sqla\n\n\ndef main():\n    print(f\"SqlAlchemy {sqla.__version__}\")\n\n    table_name = \"sqlalchemy_raw\"\n    engine = sqla.create_engine(\"questdb://localhost:8812/main\", echo=True, future=True)\n    try:\n        with engine.connect() as conn:\n            conn.execute(sqla.text(f\"DROP TABLE IF EXISTS {table_name}\"))\n            conn.execute(\n                sqla.text(f\"CREATE TABLE IF NOT EXISTS {table_name} (x int, y int)\")\n            )\n            conn.execute(\n                sqla.text(f\"INSERT INTO {table_name} (x, y) VALUES (:x, :y)\"),\n                [{\"x\": 1, \"y\": 1}, {\"x\": 2, \"y\": 4}],\n            )\n            conn.commit()\n\n            result = conn.execute(\n                sqla.text(f\"SELECT x, y FROM {table_name} WHERE y > :y\"), {\"y\": 2}\n            )\n            for row in result:\n                print(f\"x: {row.x}  y: {row.y}\")\n\n            result = conn.execute(sqla.text(f\"SELECT x, y FROM {table_name}\"))\n            for dict_row in result.mappings():\n                x = dict_row[\"x\"]\n                y = dict_row[\"y\"]\n                print(f\"x: {x}  y: {y}\")\n    finally:\n        if engine:\n            engine.dispose()", "\ndef main():\n    print(f\"SqlAlchemy {sqla.__version__}\")\n\n    table_name = \"sqlalchemy_raw\"\n    engine = sqla.create_engine(\"questdb://localhost:8812/main\", echo=True, future=True)\n    try:\n        with engine.connect() as conn:\n            conn.execute(sqla.text(f\"DROP TABLE IF EXISTS {table_name}\"))\n            conn.execute(\n                sqla.text(f\"CREATE TABLE IF NOT EXISTS {table_name} (x int, y int)\")\n            )\n            conn.execute(\n                sqla.text(f\"INSERT INTO {table_name} (x, y) VALUES (:x, :y)\"),\n                [{\"x\": 1, \"y\": 1}, {\"x\": 2, \"y\": 4}],\n            )\n            conn.commit()\n\n            result = conn.execute(\n                sqla.text(f\"SELECT x, y FROM {table_name} WHERE y > :y\"), {\"y\": 2}\n            )\n            for row in result:\n                print(f\"x: {row.x}  y: {row.y}\")\n\n            result = conn.execute(sqla.text(f\"SELECT x, y FROM {table_name}\"))\n            for dict_row in result.mappings():\n                x = dict_row[\"x\"]\n                y = dict_row[\"y\"]\n                print(f\"x: {x}  y: {y}\")\n    finally:\n        if engine:\n            engine.dispose()", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "src/examples/__init__.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport os\n\nCONNECTION_ATTRS = {\n    \"host\": os.environ.get(\"QUESTDB_CONNECT_HOST\", \"localhost\"),", "CONNECTION_ATTRS = {\n    \"host\": os.environ.get(\"QUESTDB_CONNECT_HOST\", \"localhost\"),\n    \"port\": int(os.environ.get(\"QUESTDB_CONNECT_PORT\", \"8812\")),\n    \"username\": os.environ.get(\"QUESTDB_CONNECT_USER\", \"admin\"),\n    \"password\": os.environ.get(\"QUESTDB_CONNECT_PASSWORD\", \"quest\"),\n}\n"]}
{"filename": "src/examples/psycopg2_connect.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\n\n\n\"\"\"\nThis code connects to a running QuestDB instance and displays information", "\"\"\"\nThis code connects to a running QuestDB instance and displays information\nabout the tables and partitions in the database. It uses two SQL statements\nto retrieve this information: \"tables()\" and \"table_partitions()\". The output\nis formatted and printed to the console.\n\"\"\"\nimport json\n\nfrom questdb_connect import connect\n", "from questdb_connect import connect\n\nfrom examples import CONNECTION_ATTRS\n\n\ndef print_partition(row):\n    p_index, p_by, _, min_ts, max_ts, num_rows, _, p_size, *_ = row\n    print(\n        f\" - Partition {p_index} by {p_by} [{min_ts}, {max_ts}] {num_rows} rows {p_size}\"\n    )", "\n\ndef print_table(row):\n    table_id, table_name, ts_column, p_by, _, _, is_wal, dir_name = row\n    msg = \", \".join(\n        (\n            f\"Table id:{table_id}\",\n            f\"name:{table_name}\",\n            f\"ts-col:{ts_column}\",\n            f\"partition-by:{p_by}\",\n            f\"is-wal:{is_wal}\",\n            f\"dir-name:{dir_name}\",\n        )\n    )\n    print(msg)", "\n\ndef print_server_info(dsn_parameters):\n    print(f\"QuestDB server information: {json.dumps(dsn_parameters, indent=4)}\")\n\n\ndef main():\n    with connect(**CONNECTION_ATTRS) as conn:\n        print_server_info(conn.get_dsn_parameters())\n        with conn.cursor() as tables_cur, conn.cursor() as partitions_cur:\n            tables_cur.execute(\"tables()\")\n            for table_row in tables_cur.fetchall():\n                print_table(table_row)\n                partitions_cur.execute(f\"table_partitions('{table_row[1]}')\")\n                for partition_row in partitions_cur.fetchall():\n                    print_partition(partition_row)", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "src/examples/sqlalchemy_orm.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport datetime\nimport json\nimport os\nimport time", "import os\nimport time\n\nos.environ.setdefault(\"SQLALCHEMY_SILENCE_UBER_WARNING\", \"1\")\n\nimport questdb_connect as qdbc\nfrom sqlalchemy import Column, MetaData, insert, text\nfrom sqlalchemy.orm import declarative_base\n\nfrom examples import CONNECTION_ATTRS", "\nfrom examples import CONNECTION_ATTRS\n\nBase = declarative_base(metadata=MetaData())\ntable_name = \"all_types\"\n\n\nclass MyTable(Base):\n    __tablename__ = table_name\n    __table_args__ = (\n        qdbc.QDBTableEngine(table_name, \"col_ts\", qdbc.PartitionBy.DAY, is_wal=True),\n    )\n    col_boolean = Column(qdbc.Boolean)\n    col_byte = Column(qdbc.Byte)\n    col_short = Column(qdbc.Short)\n    col_int = Column(qdbc.Int)\n    col_long = Column(qdbc.Long)\n    col_float = Column(qdbc.Float)\n    col_double = Column(qdbc.Double)\n    col_symbol = Column(qdbc.Symbol)\n    col_string = Column(qdbc.String)\n    col_char = Column(qdbc.Char)\n    col_uuid = Column(qdbc.UUID)\n    col_date = Column(qdbc.Date)\n    col_ts = Column(qdbc.Timestamp, primary_key=True)\n    col_geohash = Column(qdbc.GeohashInt)\n    col_long256 = Column(qdbc.Long256)", "\n\ndef main():\n    # obtain the engine, which we will dispose of at the end in the finally\n    engine = qdbc.create_engine(**CONNECTION_ATTRS)\n    try:\n        # delete any previous existing 'all_types' table\n        while True:\n            try:\n                Base.metadata.drop_all(engine)\n                break\n            except Exception as see:\n                if \"Connection refused\" in str(see.orig):\n                    print(f\"awaiting for QuestDB to start\")\n                    time.sleep(3)\n                else:\n                    raise see\n\n        # create the 'all_types' table\n        Base.metadata.create_all(engine)\n\n        # connect with QuestDB\n        with engine.connect() as conn:\n            # insert a fully populated row\n            now = datetime.datetime(2023, 4, 22, 18, 10, 10, 765123)\n            conn.execute(\n                insert(MyTable).values(\n                    col_boolean=True,\n                    col_byte=8,\n                    col_short=12,\n                    col_int=13,\n                    col_long=14,\n                    col_float=15.234,\n                    col_double=16.88993244,\n                    col_symbol=\"coconut\",\n                    col_string=\"banana\",\n                    col_char=\"C\",\n                    col_uuid=\"6d5eb038-63d1-4971-8484-30c16e13de5b\",\n                    col_date=now.date(),\n                    col_ts=now,\n                    col_geohash=\"dfvgsj2vptwu\",\n                    col_long256=\"0xa3b400fcf6ed707d710d5d4e672305203ed3cc6254d1cefe313e4a465861f42a\",\n                )\n            )\n            columns = [col.name for col in MyTable.__table__.columns]\n            while True:\n                rs = conn.execute(text(\"all_types\"))\n                if rs.rowcount:\n                    print(f\"rows: {rs.rowcount}\")\n                    for row in rs:\n                        print(json.dumps(dict(zip(columns, map(str, row))), indent=4))\n                    break\n    finally:\n        if engine:\n            engine.dispose()", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "src/questdb_connect/table_engine.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport sqlalchemy\n\nfrom .common import PartitionBy\n", "from .common import PartitionBy\n\n\nclass QDBTableEngine(\n    sqlalchemy.sql.base.SchemaEventTarget, sqlalchemy.sql.visitors.Traversible\n):\n    def __init__(\n        self,\n        table_name: str,\n        ts_col_name: str,\n        partition_by: PartitionBy = PartitionBy.DAY,\n        is_wal: bool = True,\n    ):\n        sqlalchemy.sql.visitors.Traversible.__init__(self)\n        self.name = table_name\n        self.ts_col_name = ts_col_name\n        self.partition_by = partition_by\n        self.is_wal = is_wal\n        self.compiled = None\n\n    def get_table_suffix(self):\n        if self.compiled is None:\n            self.compiled = \"\"\n            has_ts = self.ts_col_name is not None\n            is_partitioned = self.partition_by and self.partition_by != PartitionBy.NONE\n            if has_ts:\n                self.compiled += f'TIMESTAMP(\"{self.ts_col_name}\")'\n            if is_partitioned:\n                if not has_ts:\n                    raise sqlalchemy.exc.ArgumentError(\n                        None,\n                        \"Designated timestamp must be specified for partitioned table\",\n                    )\n                self.compiled += f\" PARTITION BY {self.partition_by.name}\"\n            if self.is_wal:\n                if not is_partitioned:\n                    raise sqlalchemy.exc.ArgumentError(\n                        None, \"WAL table requires designated timestamp and partition by\"\n                    )\n                if self.is_wal:\n                    self.compiled += \" WAL\"\n                else:\n                    self.compiled += \" BYPASS WAL\"\n        return self.compiled\n\n    def _set_parent(self, parent, **_kwargs):\n        parent.engine = self", ""]}
{"filename": "src/questdb_connect/compilers.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport abc\n\nimport sqlalchemy\n", "import sqlalchemy\n\nfrom .common import quote_identifier, remove_public_schema\nfrom .types import QDBTypeMixin\n\n\nclass QDBDDLCompiler(sqlalchemy.sql.compiler.DDLCompiler, abc.ABC):\n    def visit_create_schema(self, create, **kw):\n        raise Exception(\"QuestDB does not support SCHEMAS, there is only 'public'\")\n\n    def visit_drop_schema(self, drop, **kw):\n        raise Exception(\"QuestDB does not support SCHEMAS, there is only 'public'\")\n\n    def visit_create_table(self, create, **kw):\n        table = create.element\n        create_table = f\"CREATE TABLE {quote_identifier(table.fullname)} (\"\n        create_table += \", \".join(\n            [self.get_column_specification(c.element) for c in create.columns]\n        )\n        return create_table + \") \" + table.engine.get_table_suffix()\n\n    def get_column_specification(self, column: sqlalchemy.Column, **_):\n        if not isinstance(column.type, QDBTypeMixin):\n            raise sqlalchemy.exc.ArgumentError(\n                \"Column type is not a valid QuestDB type\"\n            )\n        return column.type.column_spec(column.name)", "\n\nclass QDBSQLCompiler(sqlalchemy.sql.compiler.SQLCompiler, abc.ABC):\n    def _is_safe_for_fast_insert_values_helper(self):\n        return True\n\n    def visit_textclause(self, textclause, add_to_result_map=None, **kw):\n        textclause.text = remove_public_schema(textclause.text)\n        return super().visit_textclause(textclause, add_to_result_map, **kw)\n", ""]}
{"filename": "src/questdb_connect/types.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport enum\n\nimport sqlalchemy\n", "import sqlalchemy\n\nfrom .common import quote_identifier\n\n_GEOHASH_BYTE_MAX = 8\n_GEOHASH_SHORT_MAX = 16\n_GEOHASH_INT_MAX = 32\n_GEOHASH_LONG_BITS = 60\n_TYPE_CACHE = {\n    # key:   '__visit_name__' of the implementor of QDBTypeMixin", "_TYPE_CACHE = {\n    # key:   '__visit_name__' of the implementor of QDBTypeMixin\n    # value: implementor class itself\n}\n\n\ndef geohash_type_name(bits):\n    if not isinstance(bits, int) or bits < 0 or bits > _GEOHASH_LONG_BITS:\n        raise sqlalchemy.exc.ArgumentError(\n            f\"geohash precision must be int [0, {_GEOHASH_LONG_BITS}]\"\n        )\n    if 0 < bits <= _GEOHASH_BYTE_MAX:\n        return f\"GEOHASH(8b)\"\n    elif _GEOHASH_BYTE_MAX < bits <= _GEOHASH_SHORT_MAX:\n        return \"GEOHASH(3c)\"\n    elif _GEOHASH_SHORT_MAX < bits <= _GEOHASH_INT_MAX:\n        return \"GEOHASH(6c)\"\n    return f\"GEOHASH(12c)\"", "\n\ndef geohash_class(bits):\n    if not isinstance(bits, int) or bits < 0 or bits > _GEOHASH_LONG_BITS:\n        raise sqlalchemy.exc.ArgumentError(\n            f\"geohash precision must be int [0, {_GEOHASH_LONG_BITS}]\"\n        )\n    if 0 < bits <= _GEOHASH_BYTE_MAX:\n        return GeohashByte\n    elif _GEOHASH_BYTE_MAX < bits <= _GEOHASH_SHORT_MAX:\n        return GeohashShort\n    elif _GEOHASH_SHORT_MAX < bits <= _GEOHASH_INT_MAX:\n        return GeohashInt\n    return GeohashLong", "\n\nclass QDBTypeMixin(sqlalchemy.types.TypeDecorator):\n    __visit_name__ = \"QDBTypeMixin\"\n    impl = sqlalchemy.types.String\n    cache_ok = True\n\n    @classmethod\n    def matches_type_name(cls, type_name):\n        return cls if type_name == cls.__visit_name__ else None\n\n    def column_spec(self, column_name):\n        return f\"{quote_identifier(column_name)} {self.__visit_name__}\"\n\n    def compile(self, dialect=None):\n        return self.__visit_name__", "\n\nclass Boolean(QDBTypeMixin):\n    __visit_name__ = \"BOOLEAN\"\n    impl = sqlalchemy.types.Boolean\n    type_code = 1\n\n\nclass Byte(QDBTypeMixin):\n    __visit_name__ = \"BYTE\"\n    impl = sqlalchemy.types.Integer\n    type_code = 2", "class Byte(QDBTypeMixin):\n    __visit_name__ = \"BYTE\"\n    impl = sqlalchemy.types.Integer\n    type_code = 2\n\n\nclass Short(QDBTypeMixin):\n    __visit_name__ = \"SHORT\"\n    type_code = 3\n    impl = sqlalchemy.types.Integer", "\n\nclass Char(QDBTypeMixin):\n    __visit_name__ = \"CHAR\"\n    type_code = 4\n\n\nclass Int(QDBTypeMixin):\n    __visit_name__ = \"INT\"\n    type_code = 5\n    impl = sqlalchemy.types.Integer", "\n\nclass Long(QDBTypeMixin):\n    __visit_name__ = \"LONG\"\n    type_code = 6\n    impl = sqlalchemy.types.Integer\n\n\nclass Date(QDBTypeMixin):\n    __visit_name__ = \"DATE\"\n    type_code = 7\n    impl = sqlalchemy.types.Date", "class Date(QDBTypeMixin):\n    __visit_name__ = \"DATE\"\n    type_code = 7\n    impl = sqlalchemy.types.Date\n\n\nclass Timestamp(QDBTypeMixin):\n    __visit_name__ = \"TIMESTAMP\"\n    type_code = 8\n    impl = sqlalchemy.types.DateTime", "\n\nclass Float(QDBTypeMixin):\n    __visit_name__ = \"FLOAT\"\n    type_code = 9\n    impl = sqlalchemy.types.Float\n\n\nclass Double(QDBTypeMixin):\n    __visit_name__ = \"DOUBLE\"\n    type_code = 10\n    impl = sqlalchemy.types.Float", "class Double(QDBTypeMixin):\n    __visit_name__ = \"DOUBLE\"\n    type_code = 10\n    impl = sqlalchemy.types.Float\n\n\nclass String(QDBTypeMixin):\n    __visit_name__ = \"STRING\"\n    type_code = 11\n", "\n\nclass Symbol(QDBTypeMixin):\n    __visit_name__ = \"SYMBOL\"\n    type_code = 12\n\n\nclass Long256(QDBTypeMixin):\n    __visit_name__ = \"LONG256\"\n    type_code = 13", "\n\nclass GeohashByte(QDBTypeMixin):\n    __visit_name__ = geohash_type_name(8)\n    type_code = 14\n\n\nclass GeohashShort(QDBTypeMixin):\n    __visit_name__ = geohash_type_name(16)\n    type_code = 15", "\n\nclass GeohashInt(QDBTypeMixin):\n    __visit_name__ = geohash_type_name(32)\n    type_code = 16\n\n\nclass GeohashLong(QDBTypeMixin):\n    __visit_name__ = geohash_type_name(60)\n    type_code = 17", "\n\nclass UUID(QDBTypeMixin):\n    __visit_name__ = \"UUID\"\n    type_code = 19\n\n\nQUESTDB_TYPES = [\n    Long256,\n    Boolean,", "    Long256,\n    Boolean,\n    Byte,\n    Short,\n    Char,\n    Int,\n    Long,\n    UUID,\n    Float,\n    Double,", "    Float,\n    Double,\n    Date,\n    Timestamp,\n    Symbol,\n    String,\n    GeohashByte,\n    GeohashInt,\n    GeohashShort,\n    GeohashLong,", "    GeohashShort,\n    GeohashLong,\n]\n\n\ndef resolve_type_from_name(type_name):\n    if not type_name:\n        return None\n    type_class = _TYPE_CACHE.get(type_name)\n    if not type_class:\n        for candidate_class in QUESTDB_TYPES:\n            type_class = candidate_class.matches_type_name(type_name)\n            if type_class:\n                _TYPE_CACHE[type_name] = type_class\n                break\n            elif (\n                \"GEOHASH\" in type_name.upper() and \"(\" in type_name and \")\" in type_name\n            ):\n                open_p = type_name.index(\"(\")\n                close_p = type_name.index(\")\")\n                description = type_name[open_p + 1 : close_p]\n                g_size = int(description[:-1])\n                if description[-1] in (\"C\", \"c\"):\n                    g_size *= 5\n                type_class = geohash_class(g_size)\n                break\n    return type_class", ""]}
{"filename": "src/questdb_connect/keywords_functions.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\n\n\ndef get_keywords_list(conn=None):\n    return __initialize_list(\n        conn, \"SELECT keyword FROM keywords()\", __keywords, __default_keywords\n    )", "def get_keywords_list(conn=None):\n    return __initialize_list(\n        conn, \"SELECT keyword FROM keywords()\", __keywords, __default_keywords\n    )\n\n\ndef get_functions_list(conn=None):\n    return __initialize_list(\n        conn, \"SELECT name FROM functions()\", __func_names, __default_func_names\n    )", "\n\ndef __initialize_list(conn, sql_stmt, target_list, default_target_list):\n    if not target_list:\n        try:\n            with conn.cursor() as functions_cur:\n                functions_cur.execute(sql_stmt)\n                for func_row in functions_cur.fetchall():\n                    target_list.append(func_row[0])\n        except Exception as _ignore:\n            target_list.extend(default_target_list)\n    return target_list", "\n\n__func_names = []\n__default_func_names = [\n    \"abs\",\n    \"acos\",\n    \"all_tables\",\n    \"and\",\n    \"asin\",\n    \"atan\",", "    \"asin\",\n    \"atan\",\n    \"atan2\",\n    \"avg\",\n    \"base64\",\n    \"between\",\n    \"build\",\n    \"case\",\n    \"cast\",\n    \"ceil\",", "    \"cast\",\n    \"ceil\",\n    \"ceiling\",\n    \"coalesce\",\n    \"concat\",\n    \"cos\",\n    \"cot\",\n    \"count\",\n    \"count_distinct\",\n    \"current_database\",", "    \"count_distinct\",\n    \"current_database\",\n    \"current_schema\",\n    \"current_schemas\",\n    \"current_user\",\n    \"date_trunc\",\n    \"dateadd\",\n    \"datediff\",\n    \"day\",\n    \"day_of_week\",", "    \"day\",\n    \"day_of_week\",\n    \"day_of_week_sunday_first\",\n    \"days_in_month\",\n    \"degrees\",\n    \"dump_memory_usage\",\n    \"dump_thread_stacks\",\n    \"extract\",\n    \"first\",\n    \"floor\",", "    \"first\",\n    \"floor\",\n    \"flush_query_cache\",\n    \"format_type\",\n    \"haversine_dist_deg\",\n    \"hour\",\n    \"ilike\",\n    \"information_schema._pg_expandarray\",\n    \"isOrdered\",\n    \"is_leap_year\",", "    \"isOrdered\",\n    \"is_leap_year\",\n    \"ksum\",\n    \"last\",\n    \"left\",\n    \"length\",\n    \"like\",\n    \"list\",\n    \"log\",\n    \"long_sequence\",", "    \"log\",\n    \"long_sequence\",\n    \"lower\",\n    \"lpad\",\n    \"ltrim\",\n    \"make_geohash\",\n    \"max\",\n    \"memory_metrics\",\n    \"micros\",\n    \"millis\",", "    \"micros\",\n    \"millis\",\n    \"min\",\n    \"minute\",\n    \"month\",\n    \"not\",\n    \"now\",\n    \"nsum\",\n    \"nullif\",\n    \"pg_advisory_unlock_all\",", "    \"nullif\",\n    \"pg_advisory_unlock_all\",\n    \"pg_attrdef\",\n    \"pg_attribute\",\n    \"pg_catalog.age\",\n    \"pg_catalog.current_database\",\n    \"pg_catalog.current_schema\",\n    \"pg_catalog.current_schemas\",\n    \"pg_catalog.pg_attrdef\",\n    \"pg_catalog.pg_attribute\",", "    \"pg_catalog.pg_attrdef\",\n    \"pg_catalog.pg_attribute\",\n    \"pg_catalog.pg_class\",\n    \"pg_catalog.pg_database\",\n    \"pg_catalog.pg_description\",\n    \"pg_catalog.pg_get_expr\",\n    \"pg_catalog.pg_get_keywords\",\n    \"pg_catalog.pg_get_partkeydef\",\n    \"pg_catalog.pg_get_userbyid\",\n    \"pg_catalog.pg_index\",", "    \"pg_catalog.pg_get_userbyid\",\n    \"pg_catalog.pg_index\",\n    \"pg_catalog.pg_inherits\",\n    \"pg_catalog.pg_is_in_recovery\",\n    \"pg_catalog.pg_locks\",\n    \"pg_catalog.pg_namespace\",\n    \"pg_catalog.pg_roles\",\n    \"pg_catalog.pg_shdescription\",\n    \"pg_catalog.pg_table_is_visible\",\n    \"pg_catalog.pg_type\",", "    \"pg_catalog.pg_table_is_visible\",\n    \"pg_catalog.pg_type\",\n    \"pg_catalog.txid_current\",\n    \"pg_catalog.version\",\n    \"pg_class\",\n    \"pg_database\",\n    \"pg_description\",\n    \"pg_get_expr\",\n    \"pg_get_keywords\",\n    \"pg_get_partkeydef\",", "    \"pg_get_keywords\",\n    \"pg_get_partkeydef\",\n    \"pg_index\",\n    \"pg_inherits\",\n    \"pg_is_in_recovery\",\n    \"pg_locks\",\n    \"pg_namespace\",\n    \"pg_postmaster_start_time\",\n    \"pg_proc\",\n    \"pg_range\",", "    \"pg_proc\",\n    \"pg_range\",\n    \"pg_roles\",\n    \"pg_type\",\n    \"position\",\n    \"power\",\n    \"radians\",\n    \"reader_pool\",\n    \"regexp_replace\",\n    \"replace\",", "    \"regexp_replace\",\n    \"replace\",\n    \"right\",\n    \"rnd_bin\",\n    \"rnd_boolean\",\n    \"rnd_byte\",\n    \"rnd_char\",\n    \"rnd_date\",\n    \"rnd_double\",\n    \"rnd_float\",", "    \"rnd_double\",\n    \"rnd_float\",\n    \"rnd_geohash\",\n    \"rnd_int\",\n    \"rnd_log\",\n    \"rnd_long\",\n    \"rnd_long256\",\n    \"rnd_short\",\n    \"rnd_str\",\n    \"rnd_symbol\",", "    \"rnd_str\",\n    \"rnd_symbol\",\n    \"rnd_timestamp\",\n    \"rnd_uuid4\",\n    \"round\",\n    \"round_down\",\n    \"round_half_even\",\n    \"round_up\",\n    \"row_number\",\n    \"rpad\",", "    \"row_number\",\n    \"rpad\",\n    \"rtrim\",\n    \"second\",\n    \"session_user\",\n    \"simulate_crash\",\n    \"sin\",\n    \"size_pretty\",\n    \"split_part\",\n    \"sqrt\",", "    \"split_part\",\n    \"sqrt\",\n    \"starts_with\",\n    \"stddev_samp\",\n    \"string_agg\",\n    \"strpos\",\n    \"substring\",\n    \"sum\",\n    \"switch\",\n    \"sysdate\",", "    \"switch\",\n    \"sysdate\",\n    \"systimestamp\",\n    \"table_columns\",\n    \"table_partitions\",\n    \"table_writer_metrics\",\n    \"tables\",\n    \"tan\",\n    \"timestamp_ceil\",\n    \"timestamp_floor\",", "    \"timestamp_ceil\",\n    \"timestamp_floor\",\n    \"timestamp_sequence\",\n    \"timestamp_shuffle\",\n    \"to_char\",\n    \"to_date\",\n    \"to_long128\",\n    \"to_lowercase\",\n    \"to_pg_date\",\n    \"to_str\",", "    \"to_pg_date\",\n    \"to_str\",\n    \"to_timestamp\",\n    \"to_timezone\",\n    \"to_uppercase\",\n    \"to_utc\",\n    \"touch\",\n    \"trim\",\n    \"txid_current\",\n    \"typeOf\",", "    \"txid_current\",\n    \"typeOf\",\n    \"upper\",\n    \"version\",\n    \"wal_tables\",\n    \"week_of_year\",\n    \"year\",\n]\n__keywords = []\n__default_keywords = [", "__keywords = []\n__default_keywords = [\n    \"add\",\n    \"all\",\n    \"alter\",\n    \"and\",\n    \"as\",\n    \"asc\",\n    \"asof\",\n    \"backup\",", "    \"asof\",\n    \"backup\",\n    \"between\",\n    \"by\",\n    \"cache\",\n    \"capacity\",\n    \"case\",\n    \"cast\",\n    \"column\",\n    \"columns\",", "    \"column\",\n    \"columns\",\n    \"copy\",\n    \"create\",\n    \"cross\",\n    \"database\",\n    \"default\",\n    \"delete\",\n    \"desc\",\n    \"distinct\",", "    \"desc\",\n    \"distinct\",\n    \"drop\",\n    \"else\",\n    \"end\",\n    \"except\",\n    \"exists\",\n    \"fill\",\n    \"foreign\",\n    \"from\",", "    \"foreign\",\n    \"from\",\n    \"grant\",\n    \"group\",\n    \"header\",\n    \"if\",\n    \"in\",\n    \"index\",\n    \"inner\",\n    \"insert\",", "    \"inner\",\n    \"insert\",\n    \"intersect\",\n    \"into\",\n    \"isolation\",\n    \"join\",\n    \"key\",\n    \"latest\",\n    \"limit\",\n    \"lock\",", "    \"limit\",\n    \"lock\",\n    \"lt\",\n    \"nan\",\n    \"natural\",\n    \"nocache\",\n    \"none\",\n    \"not\",\n    \"null\",\n    \"on\",", "    \"null\",\n    \"on\",\n    \"only\",\n    \"or\",\n    \"order\",\n    \"outer\",\n    \"over\",\n    \"partition\",\n    \"primary\",\n    \"references\",", "    \"primary\",\n    \"references\",\n    \"rename\",\n    \"repair\",\n    \"right\",\n    \"sample\",\n    \"select\",\n    \"show\",\n    \"splice\",\n    \"system\",", "    \"splice\",\n    \"system\",\n    \"table\",\n    \"tables\",\n    \"then\",\n    \"to\",\n    \"transaction\",\n    \"truncate\",\n    \"type\",\n    \"union\",", "    \"type\",\n    \"union\",\n    \"unlock\",\n    \"update\",\n    \"values\",\n    \"when\",\n    \"where\",\n    \"with\",\n    \"writer\",\n]", "    \"writer\",\n]\n"]}
{"filename": "src/questdb_connect/identifier_preparer.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport abc\n\nimport sqlalchemy\n", "import sqlalchemy\n\nfrom .common import quote_identifier\n\n\ndef _none(_ignore):\n    return None\n\n\n_special_chars = {", "\n_special_chars = {\n    \"(\",\n    \")\",\n    \"[\",\n    \"[]\",\n    \"{\",\n    \"}\",\n    \"'\",\n    '\"',", "    \"'\",\n    '\"',\n    \":\",\n    \";\",\n    \".\",\n    \"!\",\n    \"%\",\n    \"&\",\n    \"*\",\n    \"$\",", "    \"*\",\n    \"$\",\n    \"@\",\n    \"~\",\n    \"^\",\n    \"-\",\n    \"?\",\n    \"/\",\n    \"\\\\\",\n    \" \",", "    \"\\\\\",\n    \" \",\n    \"\\t\",\n    \"\\r\",\n    \"\\n\",\n}\n\n\ndef _has_special_char(_value):\n    for candidate in _value:\n        if candidate in _special_chars:\n            return True\n    return False", "def _has_special_char(_value):\n    for candidate in _value:\n        if candidate in _special_chars:\n            return True\n    return False\n\n\nclass QDBIdentifierPreparer(sqlalchemy.sql.compiler.IdentifierPreparer, abc.ABC):\n    schema_for_object = staticmethod(_none)\n\n    def __init__(\n        self,\n        dialect,\n        initial_quote='\"',\n        final_quote=None,\n        escape_quote='\"',\n        quote_case_sensitive_collations=False,\n        omit_schema=True,\n    ):\n        super().__init__(\n            dialect=dialect,\n            initial_quote=initial_quote,\n            final_quote=final_quote,\n            escape_quote=escape_quote,\n            quote_case_sensitive_collations=quote_case_sensitive_collations,\n            omit_schema=omit_schema,\n        )\n\n    def quote_identifier(self, value):\n        return quote_identifier(value)\n\n    def _requires_quotes(self, _value):\n        return _value and _has_special_char(_value)\n\n    def format_schema(self, name):\n        \"\"\"Prepare a quoted schema name.\"\"\"\n        return \"\"\n\n    def format_table(self, table, use_schema=True, name=None):\n        \"\"\"Prepare a quoted table and schema name.\"\"\"\n        return quote_identifier(name if name else table.name)", ""]}
{"filename": "src/questdb_connect/dialect.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport abc\n\nimport sqlalchemy\nfrom sqlalchemy.dialects.postgresql.psycopg2 import PGDialect_psycopg2", "import sqlalchemy\nfrom sqlalchemy.dialects.postgresql.psycopg2 import PGDialect_psycopg2\nfrom sqlalchemy.sql.compiler import GenericTypeCompiler\n\nfrom .compilers import QDBDDLCompiler, QDBSQLCompiler\nfrom .identifier_preparer import QDBIdentifierPreparer\nfrom .inspector import QDBInspector\n\n# ===== SQLAlchemy Dialect ======\n# https://docs.sqlalchemy.org/en/14/ apache-superset requires SQLAlchemy 1.4", "# ===== SQLAlchemy Dialect ======\n# https://docs.sqlalchemy.org/en/14/ apache-superset requires SQLAlchemy 1.4\n\n\ndef connection_uri(\n    host: str, port: str, username: str, password: str, database: str = \"main\"\n):\n    return f\"questdb://{username}:{password}@{host}:{port}/{database}\"\n\n\ndef create_engine(\n    host: str, port: int, username: str, password: str, database: str = \"main\"\n):\n    return sqlalchemy.create_engine(\n        connection_uri(host, port, username, password, database),\n        future=False,\n        hide_parameters=False,\n        implicit_returning=False,\n        isolation_level=\"REPEATABLE READ\",\n    )", "\n\ndef create_engine(\n    host: str, port: int, username: str, password: str, database: str = \"main\"\n):\n    return sqlalchemy.create_engine(\n        connection_uri(host, port, username, password, database),\n        future=False,\n        hide_parameters=False,\n        implicit_returning=False,\n        isolation_level=\"REPEATABLE READ\",\n    )", "\n\nclass QuestDBDialect(PGDialect_psycopg2, abc.ABC):\n    name = \"questdb\"\n    psycopg2_version = (2, 9)\n    default_schema_name = \"public\"\n    statement_compiler = QDBSQLCompiler\n    ddl_compiler = QDBDDLCompiler\n    type_compiler = GenericTypeCompiler\n    inspector = QDBInspector\n    preparer = QDBIdentifierPreparer\n    supports_schemas = False\n    supports_statement_cache = False\n    supports_server_side_cursors = False\n    supports_native_boolean = True\n    supports_views = False\n    supports_empty_insert = False\n    supports_multivalues_insert = True\n    supports_comments = True\n    inline_comments = False\n    postfetch_lastrowid = False\n    non_native_boolean_check_constraint = False\n    max_identifier_length = 255\n    _user_defined_max_identifier_length = 255\n    _has_native_hstore = False\n    supports_is_distinct_from = False\n\n    @classmethod\n    def dbapi(cls):\n        import questdb_connect as dbapi\n\n        return dbapi\n\n    def get_schema_names(self, conn, **kw):\n        return [\"public\"]\n\n    def get_table_names(self, conn, schema=None, **kw):\n        return [row.table for row in self._exec(conn, \"SHOW TABLES\")]\n\n    def has_table(self, conn, table_name, schema=None):\n        return self._exec(conn, f\"tables() WHERE name='{table_name}'\").rowcount == 1\n\n    @sqlalchemy.engine.reflection.cache\n    def get_columns(self, conn, table_name, schema=None, **kw):\n        return self.inspector.format_table_columns(\n            table_name, self._exec(conn, f\"table_columns('{table_name}')\")\n        )\n\n    def get_pk_constraint(self, conn, table_name, schema=None, **kw):\n        return []\n\n    def get_foreign_keys(\n        self,\n        conn,\n        table_name,\n        schema=None,\n        postgresql_ignore_search_path=False,\n        **kw,\n    ):\n        return []\n\n    def get_temp_table_names(self, conn, **kw):\n        return []\n\n    def get_view_names(self, conn, schema=None, **kw):\n        return []\n\n    def get_temp_view_names(self, conn, schema=None, **kw):\n        return []\n\n    def get_view_definition(self, conn, view_name, schema=None, **kw):\n        pass\n\n    def get_indexes(self, conn, table_name, schema=None, **kw):\n        return []\n\n    def get_unique_constraints(self, conn, table_name, schema=None, **kw):\n        return []\n\n    def get_check_constraints(self, conn, table_name, schema=None, **kw):\n        return []\n\n    def has_sequence(self, conn, sequence_name, schema=None, **_kw):\n        return False\n\n    def do_begin_twophase(self, conn, xid):\n        raise NotImplementedError\n\n    def do_prepare_twophase(self, conn, xid):\n        raise NotImplementedError\n\n    def do_rollback_twophase(self, conn, xid, is_prepared=True, recover=False):\n        raise NotImplementedError\n\n    def do_commit_twophase(self, conn, xid, is_prepared=True, recover=False):\n        raise NotImplementedError\n\n    def do_recover_twophase(self, conn):\n        raise NotImplementedError\n\n    def set_isolation_level(self, dbapi_conn, level):\n        pass\n\n    def get_isolation_level(self, dbapi_conn):\n        return None\n\n    def _exec(self, conn, sql_query):\n        return conn.execute(sqlalchemy.text(sql_query))", ""]}
{"filename": "src/questdb_connect/__init__.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport os\nimport time\n\nimport psycopg2", "\nimport psycopg2\n\nfrom questdb_connect.common import PartitionBy, remove_public_schema\nfrom questdb_connect.compilers import QDBDDLCompiler, QDBSQLCompiler\nfrom questdb_connect.dialect import QuestDBDialect, connection_uri, create_engine\nfrom questdb_connect.identifier_preparer import QDBIdentifierPreparer\nfrom questdb_connect.inspector import QDBInspector\nfrom questdb_connect.keywords_functions import get_functions_list, get_keywords_list\nfrom questdb_connect.table_engine import QDBTableEngine", "from questdb_connect.keywords_functions import get_functions_list, get_keywords_list\nfrom questdb_connect.table_engine import QDBTableEngine\nfrom questdb_connect.types import (\n    QUESTDB_TYPES,\n    UUID,\n    Boolean,\n    Byte,\n    Char,\n    Date,\n    Double,", "    Date,\n    Double,\n    Float,\n    GeohashByte,\n    GeohashInt,\n    GeohashLong,\n    GeohashShort,\n    Int,\n    Long,\n    Long256,", "    Long,\n    Long256,\n    QDBTypeMixin,\n    Short,\n    String,\n    Symbol,\n    Timestamp,\n    geohash_class,\n    geohash_type_name,\n    resolve_type_from_name,", "    geohash_type_name,\n    resolve_type_from_name,\n)\n\n# QuestDB timestamps: https://questdb.io/docs/guides/working-with-timestamps-timezones/\n# The native timestamp format used by QuestDB is a Unix timestamp in microsecond resolution.\n# Although timestamps in nanoseconds will be parsed, the output will be truncated to\n# microseconds. QuestDB does not store time zone information alongside timestamp values\n# and therefore it should be assumed that all timestamps are in UTC.\nos.environ[\"TZ\"] = \"UTC\"", "# and therefore it should be assumed that all timestamps are in UTC.\nos.environ[\"TZ\"] = \"UTC\"\ntime.tzset()\n\n# ===== DBAPI =====\n# https://peps.python.org/pep-0249/\n\napilevel = \"2.0\"\nthreadsafety = 2\nparamstyle = \"pyformat\"", "threadsafety = 2\nparamstyle = \"pyformat\"\n\n\nclass Error(Exception):\n    pass\n\n\nclass Cursor(psycopg2.extensions.cursor):\n    def execute(self, query, vars=None):\n        \"\"\"execute(query, vars=None) -- Execute query with bound vars.\"\"\"\n        return super().execute(remove_public_schema(query), vars)", "class Cursor(psycopg2.extensions.cursor):\n    def execute(self, query, vars=None):\n        \"\"\"execute(query, vars=None) -- Execute query with bound vars.\"\"\"\n        return super().execute(remove_public_schema(query), vars)\n\n\ndef cursor_factory(*args, **kwargs):\n    return Cursor(*args, **kwargs)\n\n\ndef connect(**kwargs):\n    host = kwargs.get(\"host\") or \"127.0.0.1\"\n    port = kwargs.get(\"port\") or 8812\n    user = kwargs.get(\"username\") or \"admin\"\n    password = kwargs.get(\"password\") or \"quest\"\n    database = kwargs.get(\"database\") or \"main\"\n    conn = psycopg2.connect(\n        cursor_factory=cursor_factory,\n        host=host,\n        port=port,\n        user=user,\n        password=password,\n        database=database,\n    )\n    # retrieve and cache function names and keywords lists\n    get_keywords_list(conn)\n    get_functions_list(conn)\n    return conn", "\n\ndef connect(**kwargs):\n    host = kwargs.get(\"host\") or \"127.0.0.1\"\n    port = kwargs.get(\"port\") or 8812\n    user = kwargs.get(\"username\") or \"admin\"\n    password = kwargs.get(\"password\") or \"quest\"\n    database = kwargs.get(\"database\") or \"main\"\n    conn = psycopg2.connect(\n        cursor_factory=cursor_factory,\n        host=host,\n        port=port,\n        user=user,\n        password=password,\n        database=database,\n    )\n    # retrieve and cache function names and keywords lists\n    get_keywords_list(conn)\n    get_functions_list(conn)\n    return conn", ""]}
{"filename": "src/questdb_connect/common.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport enum\nimport re\n\n\nclass PartitionBy(enum.Enum):\n    DAY = 0\n    MONTH = 1\n    YEAR = 2\n    NONE = 3\n    HOUR = 4\n    WEEK = 5", "\n\nclass PartitionBy(enum.Enum):\n    DAY = 0\n    MONTH = 1\n    YEAR = 2\n    NONE = 3\n    HOUR = 4\n    WEEK = 5\n", "\n\ndef remove_public_schema(query):\n    if query and isinstance(query, str) and \"public\" in query:\n        return re.sub(_PUBLIC_SCHEMA_FILTER, \"\", query)\n    return query\n\n\ndef quote_identifier(identifier: str):\n    if not identifier:\n        return None\n    first = 0\n    last = len(identifier)\n    if identifier[first] in _QUOTES:\n        first += 1\n    if identifier[last - 1] in _QUOTES:\n        last -= 1\n    return f'\"{identifier[first:last]}\"'", "def quote_identifier(identifier: str):\n    if not identifier:\n        return None\n    first = 0\n    last = len(identifier)\n    if identifier[first] in _QUOTES:\n        first += 1\n    if identifier[last - 1] in _QUOTES:\n        last -= 1\n    return f'\"{identifier[first:last]}\"'", "\n\n_PUBLIC_SCHEMA_FILTER = re.compile(\n    r\"(')?(public(?(1)\\1|)\\.)\", re.IGNORECASE | re.MULTILINE\n)\n_QUOTES = (\"'\", '\"')\n"]}
{"filename": "src/questdb_connect/inspector.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport abc\n\nimport sqlalchemy\n", "import sqlalchemy\n\nfrom .common import PartitionBy\nfrom .table_engine import QDBTableEngine\nfrom .types import resolve_type_from_name\n\n\nclass QDBInspector(sqlalchemy.engine.reflection.Inspector, abc.ABC):\n    def reflecttable(\n        self,\n        table,\n        include_columns,\n        exclude_columns=(),\n        resolve_fks=True,\n        _extend_on=None,\n    ):\n        # backward compatibility SQLAlchemy 1.3\n        return self.reflect_table(\n            table, include_columns, exclude_columns, resolve_fks, _extend_on\n        )\n\n    def reflect_table(\n        self,\n        table,\n        include_columns=None,\n        exclude_columns=None,\n        resolve_fks=False,\n        _extend_on=None,\n    ):\n        table_name = table.name\n        result_set = self.bind.execute(f\"tables() WHERE name = '{table_name}'\")\n        if not result_set:\n            self._panic_table(table_name)\n        table_attrs = result_set.first()\n        if table_attrs:\n            col_ts_name = table_attrs[\"designatedTimestamp\"]\n            partition_by = PartitionBy[table_attrs[\"partitionBy\"]]\n            is_wal = True if table_attrs[\"walEnabled\"] else False\n        else:\n            col_ts_name = None\n            partition_by = PartitionBy.NONE\n            is_wal = True\n        for row in self.bind.execute(f\"table_columns('{table_name}')\"):\n            col_name = row[0]\n            if include_columns and col_name not in include_columns:\n                continue\n            if exclude_columns and col_name in exclude_columns:\n                continue\n            col_type = resolve_type_from_name(row[1])\n            if col_ts_name and col_ts_name.upper() == col_name.upper():\n                table.append_column(\n                    sqlalchemy.Column(col_name, col_type, primary_key=True)\n                )\n            else:\n                table.append_column(sqlalchemy.Column(col_name, col_type))\n        table.engine = QDBTableEngine(table_name, col_ts_name, partition_by, is_wal)\n        table.metadata = sqlalchemy.MetaData()\n\n    def get_columns(self, table_name, schema=None, **kw):\n        result_set = self.bind.execute(f\"table_columns('{table_name}')\")\n        return self.format_table_columns(table_name, result_set)\n\n    def get_schema_names(self):\n        return [\"public\"]\n\n    def format_table_columns(self, table_name, result_set):\n        if not result_set:\n            self._panic_table(table_name)\n        return [\n            {\n                \"name\": row[0],\n                \"type\": resolve_type_from_name(row[1])(),\n                \"nullable\": True,\n                \"autoincrement\": False,\n            }\n            for row in result_set\n        ]\n\n    def _panic_table(self, table_name):\n        raise sqlalchemy.orm.exc.NoResultFound(f\"Table '{table_name}' does not exist\")", ""]}
{"filename": "src/qdb_superset/__init__.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\n"]}
{"filename": "src/qdb_superset/db_engine_specs/__init__.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\n"]}
{"filename": "src/qdb_superset/db_engine_specs/questdb.py", "chunked_list": ["#\n#     ___                  _   ____  ____\n#    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n#   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n#   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n#    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n#\n#  Copyright (c) 2014-2019 Appsicle\n#  Copyright (c) 2019-2023 QuestDB\n#", "#  Copyright (c) 2019-2023 QuestDB\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,", "#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nfrom __future__ import annotations\n\nimport re\nfrom datetime import datetime", "import re\nfrom datetime import datetime\nfrom typing import Any\n\nimport questdb_connect.types as qdbc_types\nfrom flask_babel import gettext as __\nfrom marshmallow import fields, Schema\nfrom questdb_connect.common import remove_public_schema\nfrom sqlalchemy.engine.base import Engine\nfrom sqlalchemy.engine.reflection import Inspector", "from sqlalchemy.engine.base import Engine\nfrom sqlalchemy.engine.reflection import Inspector\nfrom sqlalchemy.sql.expression import text, TextClause\nfrom sqlalchemy.types import TypeEngine\n\nfrom superset.db_engine_specs.base import (\n    BaseEngineSpec,\n    BasicParametersMixin,\n    BasicParametersType,\n)", "    BasicParametersType,\n)\n\nfrom superset.utils import core as utils\nfrom superset.utils.core import GenericDataType\n\n\nclass QuestDbParametersSchema(Schema):\n    username = fields.String(\n        description=__(\"username\"),\n        dump_default=\"admin\",\n        load_default=\"admin\",\n    )\n    password = fields.String(\n        description=__(\"password\"),\n        dump_default=\"quest\",\n        load_default=\"quest\",\n    )\n    host = fields.String(\n        description=__(\"host\"),\n        dump_default=\"host.docker.internal\",\n        load_default=\"host.docker.internal\",\n    )\n    port = fields.Integer(\n        description=__(\"port\"),\n        dump_default=\"8812\",\n        load_default=\"8812\",\n    )\n    database = fields.String(\n        description=__(\"database\"),\n        dump_default=\"main\",\n        load_default=\"main\",\n    )", "\n\nclass QuestDbEngineSpec(BaseEngineSpec, BasicParametersMixin):\n    engine = \"questdb\"\n    engine_name = \"QuestDB\"\n    default_driver = \"psycopg2\"\n    encryption_parameters = {\"sslmode\": \"prefer\"}\n    sqlalchemy_uri_placeholder = \"questdb://username:password@host:port/database\"\n    parameters_schema = QuestDbParametersSchema()\n    time_groupby_inline = False\n    allows_hidden_cc_in_orderby = True\n    time_secondary_columns = True\n    try_remove_schema_from_table_name = True\n    max_column_name_length = 120\n    supports_dynamic_schema = False\n    top_keywords: set[str] = set({})\n    # https://en.wikipedia.org/wiki/ISO_8601#Durations\n    # https://questdb.io/docs/reference/function/date-time/#date_trunc\n    _time_grain_expressions = {\n        None: \"{col}\",\n        \"PT1S\": \"DATE_TRUNC('second', {col})\",\n        \"PT1M\": \"DATE_TRUNC('minute', {col})\",\n        \"PT1H\": \"DATE_TRUNC('hour', {col})\",\n        \"P1D\": \"DATE_TRUNC('day', {col})\",\n        \"P1W\": \"DATE_TRUNC('week', {col})\",\n        \"P1M\": \"DATE_TRUNC('month', {col})\",\n        \"P1Y\": \"DATE_TRUNC('year', {col})\",\n        \"P3M\": \"DATE_TRUNC('quarter', {col})\",\n    }\n    column_type_mappings = (\n        (\n            re.compile(\"^LONG256\", re.IGNORECASE),\n            qdbc_types.Long256,\n            GenericDataType.STRING,\n        ),\n        (\n            re.compile(\"^BOOLEAN\", re.IGNORECASE),\n            qdbc_types.Boolean,\n            GenericDataType.BOOLEAN,\n        ),\n        (\n            re.compile(\"^BYTE\", re.IGNORECASE),\n            qdbc_types.Byte,\n            GenericDataType.NUMERIC,\n        ),\n        (\n            re.compile(\"^SHORT\", re.IGNORECASE),\n            qdbc_types.Short,\n            GenericDataType.NUMERIC,\n        ),\n        (re.compile(\"^INT\", re.IGNORECASE), qdbc_types.Int, GenericDataType.NUMERIC),\n        (\n            re.compile(\"^LONG\", re.IGNORECASE),\n            qdbc_types.Long,\n            GenericDataType.NUMERIC,\n        ),\n        (\n            re.compile(\"^FLOAT\", re.IGNORECASE),\n            qdbc_types.Float,\n            GenericDataType.NUMERIC,\n        ),\n        (\n            re.compile(\"^DOUBLE'\", re.IGNORECASE),\n            qdbc_types.Double,\n            GenericDataType.NUMERIC,\n        ),\n        (\n            re.compile(\"^SYMBOL\", re.IGNORECASE),\n            qdbc_types.Symbol,\n            GenericDataType.STRING,\n        ),\n        (\n            re.compile(\"^STRING\", re.IGNORECASE),\n            qdbc_types.String,\n            GenericDataType.STRING,\n        ),\n        (\n            re.compile(\"^UUID\", re.IGNORECASE),\n            qdbc_types.UUID,\n            GenericDataType.STRING,\n        ),\n        (\n            re.compile(\"^CHAR\", re.IGNORECASE),\n            qdbc_types.Char,\n            GenericDataType.STRING,\n        ),\n        (\n            re.compile(\"^TIMESTAMP\", re.IGNORECASE),\n            qdbc_types.Timestamp,\n            GenericDataType.TEMPORAL,\n        ),\n        (\n            re.compile(\"^DATE\", re.IGNORECASE),\n            qdbc_types.Date,\n            GenericDataType.TEMPORAL,\n        ),\n        (\n            re.compile(r\"^GEOHASH\\(\\d+[b|c]\\)\", re.IGNORECASE),\n            qdbc_types.GeohashLong,\n            GenericDataType.STRING,\n        ),\n    )\n\n    @classmethod\n    def build_sqlalchemy_uri(\n        cls,\n        parameters: BasicParametersType,\n        encrypted_extra: dict[str, str] | None = None,\n    ) -> str:\n        host = parameters.get(\"host\")\n        port = parameters.get(\"port\")\n        username = parameters.get(\"username\")\n        password = parameters.get(\"password\")\n        database = parameters.get(\"database\")\n        return f\"questdb://{username}:{password}@{host}:{port}/{database}\"\n\n    @classmethod\n    def get_default_schema_for_query(cls, database, query) -> str | None:\n        \"\"\"Return the default schema for a given query.\"\"\"\n        return None\n\n    @classmethod\n    def epoch_to_dttm(cls) -> str:\n        \"\"\"SQL expression that converts epoch (seconds) to datetime that can be used\n        in a query. The reference column should be denoted as `{col}` in the return\n        expression, e.g. \"FROM_UNIXTIME({col})\"\n        :return: SQL Expression\n        \"\"\"\n        return \"{col} * 1000000\"\n\n    @classmethod\n    def convert_dttm(\n        cls, target_type: str, dttm: datetime, db_extra: dict[str, Any] | None = None\n    ) -> str | None:\n        \"\"\"Convert a Python `datetime` object to a SQL expression.\n        :param target_type: The target type of expression\n        :param dttm: The datetime object\n        :return: The SQL expression\n        \"\"\"\n        type_u = target_type.upper()\n        if type_u == \"DATE\":\n            return f\"TO_DATE('{dttm.date().isoformat()}', 'YYYY-MM-DD')\"\n        if type_u in (\"DATETIME\", \"TIMESTAMP\"):\n            dttm_formatted = dttm.isoformat(sep=\"T\", timespec=\"microseconds\")\n            return f\"TO_TIMESTAMP('{dttm_formatted}', 'yyyy-MM-ddTHH:mm:ss.SSSUUUZ')\"\n        return None\n\n    @classmethod\n    def get_datatype(cls, type_code: Any) -> str | None:\n        \"\"\"Change column type code from cursor description to string representation.\n        :param type_code: Type code from cursor description\n        :return: String representation of type code\n        \"\"\"\n        if type_code and isinstance(type_code, str):\n            return type_code.upper()\n        return str(type_code)\n\n    @classmethod\n    def get_column_spec(\n        cls,\n        native_type: str | None,\n        db_extra: dict[str, Any] | None = None,\n        source: utils.ColumnTypeSource = utils.ColumnTypeSource.GET_TABLE,\n    ) -> utils.ColumnSpec | None:\n        \"\"\"Get generic type related specs regarding a native column type.\n        :param native_type: Native database type\n        :param db_extra: The database extra object\n        :param source: Type coming from the database table or cursor description\n        :return: ColumnSpec object\n        \"\"\"\n        sqla_type = qdbc_types.resolve_type_from_name(native_type)\n        if not sqla_type:\n            return BaseEngineSpec.get_column_spec(native_type, db_extra, source)\n        name_u = sqla_type.__visit_name__\n        generic_type = GenericDataType.STRING\n        if name_u == \"BOOLEAN\":\n            generic_type = GenericDataType.BOOLEAN\n        elif name_u in (\"BYTE\", \"SHORT\", \"INT\", \"LONG\", \"FLOAT\", \"DOUBLE\"):\n            generic_type = GenericDataType.NUMERIC\n        elif name_u in (\"SYMBOL\", \"STRING\", \"CHAR\", \"LONG256\", \"UUID\"):\n            generic_type = GenericDataType.STRING\n        elif name_u in (\"DATE\", \"TIMESTAMP\"):\n            generic_type = GenericDataType.TEMPORAL\n        elif \"GEOHASH\" in name_u and \"(\" in name_u and \")\" in name_u:\n            generic_type = GenericDataType.STRING\n        return utils.ColumnSpec(\n            sqla_type,\n            generic_type,\n            generic_type == GenericDataType.TEMPORAL,\n        )\n\n    @classmethod\n    def get_sqla_column_type(\n        cls,\n        native_type: str | None,\n        db_extra: dict[str, Any] | None = None,\n        source: utils.ColumnTypeSource = utils.ColumnTypeSource.GET_TABLE,\n    ) -> TypeEngine | None:\n        \"\"\"Converts native database type to sqlalchemy column type.\n        :param native_type: Native database type\n        :param db_extra: The database extra object\n        :param source: Type coming from the database table or cursor description\n        :return: ColumnSpec object\n        \"\"\"\n        return qdbc_types.resolve_type_from_name(native_type).impl\n\n    @classmethod\n    def select_star(  # pylint: disable=too-many-arguments\n        cls,\n        database: Any,\n        table_name: str,\n        engine: Engine,\n        schema: str | None = None,\n        limit: int = 100,\n        show_cols: bool = False,\n        indent: bool = True,\n        latest_partition: bool = True,\n        cols: list[dict[str, Any]] | None = None,\n    ) -> str:\n        \"\"\"Generate a \"SELECT * from table_name\" query with appropriate limit.\n        :param database: Database instance\n        :param table_name: Table name, unquoted\n        :param engine: SqlAlchemy Engine instance\n        :param schema: Schema, unquoted\n        :param limit: limit to impose on query\n        :param show_cols: Show columns in query; otherwise use \"*\"\n        :param indent: Add indentation to query\n        :param latest_partition: Only query the latest partition\n        :param cols: Columns to include in query\n        :return: SQL query\n        \"\"\"\n        return super().select_star(\n            database,\n            table_name,\n            engine,\n            None,\n            limit,\n            show_cols,\n            indent,\n            latest_partition,\n            cols,\n        )\n\n    @classmethod\n    def get_allow_cost_estimate(cls, extra: dict[str, Any]) -> bool:\n        return False\n\n    @classmethod\n    def get_view_names(\n        cls,\n        database,\n        inspector: Inspector,\n        schema: str | None,\n    ) -> set[str]:\n        return set()\n\n    @classmethod\n    def get_text_clause(cls, clause: str) -> TextClause:\n        \"\"\"\n        SQLAlchemy wrapper to ensure text clauses are escaped properly\n\n        :param clause: string clause with potentially unescaped characters\n        :return: text clause with escaped characters\n        \"\"\"\n        if cls.allows_escaped_colons:\n            clause = clause.replace(\":\", \"\\\\:\")\n        return text(remove_public_schema(clause))", ""]}
