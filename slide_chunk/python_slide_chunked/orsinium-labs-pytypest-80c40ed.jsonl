{"filename": "pytypest/_fixture_factory.py", "chunked_list": ["from __future__ import annotations\n\nfrom functools import update_wrapper\nfrom typing import TYPE_CHECKING, Protocol, overload\n\nfrom ._fixture import Fixture\nfrom ._scope import Scope\n\n\nif TYPE_CHECKING:\n    from typing import Callable, Iterator, Literal, TypeVar\n\n    from typing_extensions import ParamSpec\n\n    R = TypeVar('R')\n    P = ParamSpec('P')", "\nif TYPE_CHECKING:\n    from typing import Callable, Iterator, Literal, TypeVar\n\n    from typing_extensions import ParamSpec\n\n    R = TypeVar('R')\n    P = ParamSpec('P')\n\n\nclass FixtureMaker(Protocol):\n    \"\"\"\n    The type of the callback returned by the @fixture\n    when the decorator is called without the wrapped function\n    and it has a function scope.\n    \"\"\"\n    @overload\n    def __call__(self, callback: Callable[P, Iterator[R]]) -> Fixture[P, R]:\n        pass\n\n    @overload\n    def __call__(self, callback: Callable[P, R]) -> Fixture[P, R]:\n        pass\n\n    def __call__(self, callback):\n        pass", "\n\nclass FixtureMaker(Protocol):\n    \"\"\"\n    The type of the callback returned by the @fixture\n    when the decorator is called without the wrapped function\n    and it has a function scope.\n    \"\"\"\n    @overload\n    def __call__(self, callback: Callable[P, Iterator[R]]) -> Fixture[P, R]:\n        pass\n\n    @overload\n    def __call__(self, callback: Callable[P, R]) -> Fixture[P, R]:\n        pass\n\n    def __call__(self, callback):\n        pass", "\n\nclass FixtureMakerWithScope(Protocol):\n    \"\"\"\n    The type of the callback returned by the @fixture\n    when non-function `scope` is passed.\n\n    For non-function scope, fixtures must not accept arguments.\n    The reason is that it cannot be properly cached.\n    \"\"\"\n    @overload\n    def __call__(self, callback: Callable[[], Iterator[R]]) -> Fixture[[], R]:\n        pass\n\n    @overload\n    def __call__(self, callback: Callable[[], R]) -> Fixture[[], R]:\n        pass\n\n    def __call__(self, callback):\n        pass", "\n\n@overload\ndef fixture(\n    callback: None = None,\n    *,\n    scope: Literal[Scope.FUNCTION] = Scope.FUNCTION,\n) -> FixtureMaker:\n    \"\"\"fixture decorator with explicit function scope.\n\n    ::\n        @fixture(scope=Scope.FUNCTION)\n        def get_user():\n            return User()\n\n    \"\"\"\n    pass", "\n\n@overload\ndef fixture(\n    callback: None = None,\n    *,\n    scope: Scope,\n) -> FixtureMakerWithScope:\n    \"\"\"fixture decorator with scope.\n\n    ::\n\n        @fixture(scope=Scope.SESSION)\n        def get_user():\n            return User()\n\n    \"\"\"\n    pass", "\n\n@overload\ndef fixture(callback: Callable[P, Iterator[R]]) -> Fixture[P, R]:\n    \"\"\"fixture decorator with teardown without scope.\n\n    ::\n\n        @fixture\n        def get_user():\n            yield User()\n\n    \"\"\"\n    pass", "\n\n@overload\ndef fixture(callback: Callable[P, R]) -> Fixture[P, R]:\n    \"\"\"fixture decorator without teardown without scope.\n\n    ::\n\n        @fixture\n        def get_user():\n            return User()\n\n    \"\"\"\n    pass", "\n\ndef fixture(\n    callback: Callable | None = None,\n    **kwargs,\n) -> Fixture[P, R] | Callable[[Callable], Fixture]:\n    \"\"\"A decorator to create a new fixture.\n\n    Fixtures are executed only when called, cached for the given scope,\n    and may have teardown logic that is executed when exiting the scope.\n\n    ::\n\n        @fixture\n        def get_user() -> Iterator[User]:\n            # setup\n            u = User()\n            # fixtures can use other fixtures\n            db = get_database()\n            db.insert(u)\n\n            # provide data for the test\n            yield u\n\n            # teardown\n            db.delete(u)\n\n    You can call the fixture to get the yielded value::\n\n        def test_user():\n            user = get_user()\n\n    Or you can use it as a context manager::\n\n        def test_user():\n            with get_user as user:\n                ...\n\n    Fixtures can accept arguments::\n\n        @fixture\n        def get_user(name: str):\n            ...\n\n        def test_user():\n            conn = get_user(name='Guido')\n\n    Fixtures without teardown may use `return` instead of `yield`::\n\n        @fixture\n        def get_user() -> User:\n            return User()\n\n    Fixtures can be called not only from test functions,\n    but from other fixtures, pytest fixtures, or helper functions\n    within a test run.\n\n    \"\"\"\n    if callback is not None:\n        fixture = Fixture(callback, **kwargs)\n        return update_wrapper(fixture, callback)\n\n    def wrapper(callback: Callable) -> Fixture:\n        fixture = Fixture(callback, **kwargs)\n        return update_wrapper(fixture, callback)\n    return wrapper", ""]}
{"filename": "pytypest/_scope.py", "chunked_list": ["from enum import Enum\n\n\nclass Scope(Enum):\n    \"\"\"Scope for which the fixture.\n\n    The scope defines when the fixture cache will be reset\n    and the teardown executed.\n    \"\"\"\n\n    FUNCTION = 'function'\n    \"\"\"\n    Default. Teardown is called at the end of the test function.\n    \"\"\"\n\n    CLASS = 'class'\n    \"\"\"\n    Teardown is called after the last test in a test class.\n    \"\"\"\n\n    MODULE = 'module'\n    \"\"\"\n    Teardown is called after the last test in a file.\n    \"\"\"\n\n    PACKAGE = 'package'\n    \"\"\"\n    Experimental. Teardown is called after the last test in a directory.\n    \"\"\"\n\n    SESSION = 'session'\n    \"\"\"\n    Teardown is called after the last tests overall in the current session.\n    \"\"\"", ""]}
{"filename": "pytypest/_manager.py", "chunked_list": ["from __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom typing import Callable\n\nfrom ._hub import hub\nfrom ._scope import Scope\nfrom ._scope_manager import ScopeManager\n\n\ndef defer(scope: Scope, callback: Callable[[], None]) -> None:\n    \"\"\"Schedule the callback to be called when leaving the scope.\n\n    ::\n\n        defer(Scope.FUNCTION, self.teardown)\n\n    \"\"\"\n    if hub.manager is None:\n        raise RuntimeError('pytest plugin is not activated')\n    scope_manager = hub.manager.get_scope(scope)\n    scope_manager.defer(callback)", "\n\ndef defer(scope: Scope, callback: Callable[[], None]) -> None:\n    \"\"\"Schedule the callback to be called when leaving the scope.\n\n    ::\n\n        defer(Scope.FUNCTION, self.teardown)\n\n    \"\"\"\n    if hub.manager is None:\n        raise RuntimeError('pytest plugin is not activated')\n    scope_manager = hub.manager.get_scope(scope)\n    scope_manager.defer(callback)", "\n\n@dataclass(frozen=True)\nclass Manager:\n    \"\"\"Holds a stack of scope managers with smaller scope being on top.\n    \"\"\"\n    _scopes: list[ScopeManager] = field(default_factory=list)\n\n    def get_scope(self, scope: Scope) -> ScopeManager:\n        for scope_manager in self._scopes:\n            if scope_manager.scope is scope:\n                return scope_manager\n        raise LookupError(f'cannot find ScopeManager for `{scope.value}` scope')\n\n    def enter_scope(self, scope: Scope) -> None:\n        scope_manager = ScopeManager(scope)\n        self._scopes.append(scope_manager)\n        scope_manager.enter_scope()\n\n    def exit_scope(self, scope: Scope) -> None:\n        scope_manager = self._scopes.pop()\n        assert scope_manager.scope == scope\n        scope_manager.exit_scope()", ""]}
{"filename": "pytypest/_autouse.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom ._hub import hub\n\n\nif TYPE_CHECKING:\n    from ._fixture import Fixture\n", "\n\ndef autouse(*fixtures: Fixture[[], None]) -> None:\n    \"\"\"Register fixtures to be used automatically when entering a scope.\n\n    Can be called only once in runtime.\n\n    ::\n\n        autouse(\n            create_database,\n            clear_cache,\n            fixtures.forbid_networking,\n        )\n\n    \"\"\"\n    if hub.autouse is not None:\n        raise RuntimeError('autouse can be called only once')\n    hub.autouse = fixtures", ""]}
{"filename": "pytypest/_parametrize.py", "chunked_list": ["from __future__ import annotations\n\nimport inspect\nfrom typing import TYPE_CHECKING, Callable\n\nimport pytest\nfrom typing_extensions import ParamSpec\n\nfrom ._case import Case\n", "from ._case import Case\n\n\nif TYPE_CHECKING:\n    from _pytest.mark import ParameterSet\n\nP = ParamSpec('P')\n\n\ndef parametrize(\n    func: Callable[P, None],\n    *cases: Case[P],\n    **named_cases: Case[P],\n) -> Callable[[], None]:\n    \"\"\"Create a test for each case, each test calling the given func.\n\n    ::\n\n        def _test_add(a: int, b: int, exp: int) -> None:\n            assert a + b == exp\n\n        test_add = parametrize(\n            _test_add,\n            case(3, 4, exp=7),\n            case(4, 5, exp=9),\n            zeros=case(0, 0, exp=0),\n        )\n\n    \"\"\"\n    sig = inspect.Signature.from_callable(func)\n    params = list(sig.parameters)\n    table: list[ParameterSet | list] = []\n    row: ParameterSet | list\n    all_cases = list(cases)\n    for name, case in named_cases.items():\n        all_cases.append(case.with_id(name))\n    for case in all_cases:\n        bound = sig.bind(*case.args, **case.kwargs)\n        bound.apply_defaults()\n        row = [bound.arguments[p] for p in params]\n        if case.id or case.tags:\n            marks = [getattr(pytest.mark, tag) for tag in (case.tags or [])]\n            row = pytest.param(*row, id=case.id, marks=tuple(marks))\n        table.append(row)\n    func.__defaults__ = ()\n    return pytest.mark.parametrize(params, table)(func)", "\ndef parametrize(\n    func: Callable[P, None],\n    *cases: Case[P],\n    **named_cases: Case[P],\n) -> Callable[[], None]:\n    \"\"\"Create a test for each case, each test calling the given func.\n\n    ::\n\n        def _test_add(a: int, b: int, exp: int) -> None:\n            assert a + b == exp\n\n        test_add = parametrize(\n            _test_add,\n            case(3, 4, exp=7),\n            case(4, 5, exp=9),\n            zeros=case(0, 0, exp=0),\n        )\n\n    \"\"\"\n    sig = inspect.Signature.from_callable(func)\n    params = list(sig.parameters)\n    table: list[ParameterSet | list] = []\n    row: ParameterSet | list\n    all_cases = list(cases)\n    for name, case in named_cases.items():\n        all_cases.append(case.with_id(name))\n    for case in all_cases:\n        bound = sig.bind(*case.args, **case.kwargs)\n        bound.apply_defaults()\n        row = [bound.arguments[p] for p in params]\n        if case.id or case.tags:\n            marks = [getattr(pytest.mark, tag) for tag in (case.tags or [])]\n            row = pytest.param(*row, id=case.id, marks=tuple(marks))\n        table.append(row)\n    func.__defaults__ = ()\n    return pytest.mark.parametrize(params, table)(func)", ""]}
{"filename": "pytypest/_fixture.py", "chunked_list": ["from __future__ import annotations\n\nimport inspect\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Callable, Generic, Iterator, Literal, TypeVar\n\nfrom typing_extensions import ParamSpec\n\nfrom ._manager import defer", "\nfrom ._manager import defer\nfrom ._scope import Scope\n\n\nR = TypeVar('R')\nP = ParamSpec('P')\n\n\nclass Sentinel(Enum):\n    \"\"\"A helper to define a singleton sentinel object in a mypy-friendly way.\n\n    ::\n\n        _: Literal[Sentinel.UNSET] = Sentinel.UNSET\n\n    \"\"\"\n    UNSET = object()", "\nclass Sentinel(Enum):\n    \"\"\"A helper to define a singleton sentinel object in a mypy-friendly way.\n\n    ::\n\n        _: Literal[Sentinel.UNSET] = Sentinel.UNSET\n\n    \"\"\"\n    UNSET = object()", "\n\n@dataclass\nclass Fixture(Generic[P, R]):\n    \"\"\"A test fixture with setup and optional teardown.\n\n    Should be constructed using :func:`pytypest.fixture`::\n\n        @fixture\n        def get_user() -> Iterator[User]:\n            ... # setup\n            yield User()\n            ... # teardown\n\n    \"\"\"\n    _callback: Callable[P, R | Iterator[R]]\n    scope: Scope = Scope.FUNCTION\n    _iters: list[Iterator[R]] = field(default_factory=list)\n    _result: R | Literal[Sentinel.UNSET] = Sentinel.UNSET\n\n    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R:\n        \"\"\"Allows the fixture to be called as a function.\n\n        ::\n\n            @fixture\n            def get_user():\n                ...\n\n            user = get_user()\n\n        \"\"\"\n        if self.scope != Scope.FUNCTION:\n            msg = 'fixtures with non-function scope must not accept arguments'\n            assert not args and not kwargs, msg\n        is_cached = self._result != Sentinel.UNSET and not args and not kwargs\n        if is_cached:\n            return self._result  # type: ignore[return-value]\n        result = self.setup(*args, **kwargs)\n        defer(self.scope, self.teardown)\n        return result\n\n    def setup(self, *args: P.args, **kwargs: P.kwargs) -> R:\n        \"\"\"Execute setup logic of the fixture and get its result.\n\n        Setup is everything that goes before `yield` or `return`.\n\n        Avoid using this method directly. It doesn't use cached results,\n        doesn't use the scope, and doesn't defer teardown.\n        Prefer calling the fixture or using it as a context manager.\n        \"\"\"\n        if inspect.isgeneratorfunction(self._callback):\n            iterator = self._callback(*args, **kwargs)\n            result = next(iterator)\n            self._iters.append(iterator)\n        else:\n            result = self._callback(*args, **kwargs)\n        if not args and not kwargs:\n            self._result = result\n        return result\n\n    def teardown(self) -> None:\n        \"\"\"Execute teardown logic of the fixture (if available).\n\n        Teardown is the code that goes after `yield` (if `yield` is present).\n\n        Can be safely called mutiple times.\n        \"\"\"\n        for iterator in self._iters:\n            try:\n                next(iterator)\n            except StopIteration:\n                pass\n            else:\n                raise RuntimeError('fixture must have at most one yield')\n        self._iters = []\n        self._result = Sentinel.UNSET\n\n    def __enter__(self) -> R:\n        \"\"\"Allows the fixture to be used as a context manager.\n\n        ::\n\n            @fixture\n            def get_user():\n                ...\n\n            with get_user as user:\n                ...\n\n        Regardless of the scope, the setup is executed when entering\n        the context, and the teardown is when leaving it.\n\n        \"\"\"\n        return self.setup()\n\n    def __exit__(self, *exc_info) -> None:\n        self.teardown()", ""]}
{"filename": "pytypest/__init__.py", "chunked_list": ["\"\"\"Type-safe and maintainable fixtures and parametrization for pytest.\n\"\"\"\n\nfrom . import experimental, fixtures\nfrom ._autouse import autouse\nfrom ._case import case\nfrom ._fixture_factory import fixture\nfrom ._parametrize import parametrize\nfrom ._scope import Scope\n", "from ._scope import Scope\n\n\n__version__ = '1.0.0'\n__all__ = [\n    'autouse',\n    'case',\n    'experimental',\n    'fixture',\n    'fixtures',", "    'fixture',\n    'fixtures',\n    'parametrize',\n    'Scope',\n]\n"]}
{"filename": "pytypest/_scope_manager.py", "chunked_list": ["from __future__ import annotations\n\nfrom collections import deque\nfrom dataclasses import dataclass, field\nfrom typing import Callable\n\nfrom ._scope import Scope\n\n\nFinalizer = Callable[[], None]", "\nFinalizer = Callable[[], None]\n\n\n@dataclass\nclass ScopeManager:\n    scope: Scope\n    _deferred: deque[Finalizer] = field(default_factory=deque)\n\n    def defer(self, callback: Finalizer) -> None:\n        self._deferred.append(callback)\n\n    def enter_scope(self) -> None:\n        assert not self._deferred\n\n    def exit_scope(self) -> None:\n        while self._deferred:\n            callback = self._deferred.pop()\n            callback()", ""]}
{"filename": "pytypest/_plugin.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import Iterator\n\nimport pytest\n\nfrom ._hub import hub\nfrom ._manager import Manager\nfrom ._scope import Scope\n", "from ._scope import Scope\n\n\nSESSION_ATTR = '_pytypest_manager'\n\n\ndef pytest_sessionstart(session: pytest.Session) -> None:\n    manager = Manager()\n    hub.manager = manager\n    setattr(session, SESSION_ATTR, manager)", "\n\ndef _manage_scope(request: pytest.FixtureRequest) -> Iterator[None]:\n    hub.request = request\n    manager: Manager = getattr(request.session, SESSION_ATTR)\n    scope = Scope(request.scope)\n    manager.enter_scope(scope)\n    if hub.autouse:\n        for fixture in hub.autouse:\n            if fixture.scope == scope:\n                fixture()\n    yield\n    manager.exit_scope(scope)\n    hub.request = None", "\n\nenter_function = pytest.fixture(scope='function', autouse=True)(_manage_scope)\nenter_class = pytest.fixture(scope='class', autouse=True)(_manage_scope)\nenter_module = pytest.fixture(scope='module', autouse=True)(_manage_scope)\nenter_package = pytest.fixture(scope='package', autouse=True)(_manage_scope)\nenter_session = pytest.fixture(scope='session', autouse=True)(_manage_scope)\n"]}
{"filename": "pytypest/_hub.py", "chunked_list": ["from __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import TYPE_CHECKING\n\n\nif TYPE_CHECKING:\n    import pytest\n\n    from ._fixture import Fixture\n    from ._manager import Manager", "\n\n@dataclass\nclass Hub:\n    \"\"\"Singleton holding all global state.\n    \"\"\"\n    manager: Manager | None = None\n    request: pytest.FixtureRequest | None = None\n    autouse: tuple[Fixture[[], None], ...] | None = None\n\n    def reset(self) -> None:\n        \"\"\"Clean up all global state.\n\n        Used for pytypest's unit tests' isolation.\n        \"\"\"\n        self.manager = None\n        self.request = None\n        self.autouse = None", "\n\nhub = Hub()\n"]}
{"filename": "pytypest/_case.py", "chunked_list": ["from __future__ import annotations\n\nimport dataclasses\nfrom typing import Any, Generic, TypeVar\n\nfrom typing_extensions import ParamSpec\n\n\nP = ParamSpec('P')\nS = TypeVar('S')", "P = ParamSpec('P')\nS = TypeVar('S')\n\n\n@dataclasses.dataclass(frozen=True)\nclass CaseMaker:\n    \"\"\"Create a new test case to be used with parametrized tests.\n\n    ::\n\n        def _test_add(a: int, b: int, exp: int):\n            assert a + b == exp\n\n        test_add = parametrize(\n            _test_add,\n            case(4, 5, exp=9),\n        )\n\n    \"\"\"\n    _id: str | None = None\n    _tags: tuple[str, ...] | None = None\n\n    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> Case[P]:\n        return Case(args=args, kwargs=kwargs, id=self._id, tags=self._tags)\n\n    def id(self, id: str) -> CaseMaker:\n        \"\"\"Give a name to the test case.\n\n        ::\n\n            test_logout = parametrize(\n                _test_logout,\n                case.id('anonymous_user')(user1),\n            )\n\n        \"\"\"\n        return dataclasses.replace(self, _id=id)\n\n    def tags(self, *tags: str) -> CaseMaker:\n        \"\"\"Mark the case with tags that can be used to filter specific tests.\n\n        ::\n\n            test_logout = parametrize(\n                _test_logout,\n                case.tags('slow', 'integration')(user1),\n            )\n\n        \"\"\"\n        return dataclasses.replace(self, _tags=tags)", "\n\ncase = CaseMaker()\n\n\n@dataclasses.dataclass(frozen=True)\nclass Case(Generic[P]):\n    \"\"\"A single test case for parametrized tests.\n\n    Use :func:`pytypest.case` to create a new one.\n    \"\"\"\n    args: tuple\n    kwargs: dict[str, Any]\n    id: str | None = None\n    tags: tuple[str, ...] | None = None\n\n    def with_id(self, id: str) -> Case[P]:\n        return dataclasses.replace(self, id=id)", ""]}
{"filename": "pytypest/fixtures/_helpers.py", "chunked_list": ["from __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Callable\n\nimport pytest\n\n\n@dataclass(frozen=True)\nclass NetworkGuard:\n    allowed: frozenset[tuple[str, int]]\n    wrapped: Callable[..., list]\n\n    def __call__(\n        self,\n        host: bytes | str | None,\n        port: bytes | str | int | None,\n        *args,\n        **kwargs,\n    ) -> list:\n        if (host, port) not in self.allowed:\n            msg = f'connection to {host}:{port} is not allowed'  # type: ignore\n            pytest.fail(msg)\n        return self.wrapped(host, port, *args, **kwargs)", "@dataclass(frozen=True)\nclass NetworkGuard:\n    allowed: frozenset[tuple[str, int]]\n    wrapped: Callable[..., list]\n\n    def __call__(\n        self,\n        host: bytes | str | None,\n        port: bytes | str | int | None,\n        *args,\n        **kwargs,\n    ) -> list:\n        if (host, port) not in self.allowed:\n            msg = f'connection to {host}:{port} is not allowed'  # type: ignore\n            pytest.fail(msg)\n        return self.wrapped(host, port, *args, **kwargs)", ""]}
{"filename": "pytypest/fixtures/__init__.py", "chunked_list": ["from __future__ import annotations\n\nfrom ._misc import (\n    chdir, defer, enter_context, forbid_networking, get_project_root,\n    preserve_mapping,\n)\nfrom ._pytest import (\n    capture_logs, capture_std, delattr, get_pytest_fixture, get_request,\n    make_temp_dir, monkeypatch, record_warnings, setattr,\n)", "    make_temp_dir, monkeypatch, record_warnings, setattr,\n)\n\n\n__all__ = [\n    'capture_logs',\n    'capture_std',\n    'chdir',\n    'defer',\n    'delattr',", "    'defer',\n    'delattr',\n    'enter_context',\n    'forbid_networking',\n    'get_project_root',\n    'get_pytest_fixture',\n    'get_request',\n    'make_temp_dir',\n    'monkeypatch',\n    'preserve_mapping',", "    'monkeypatch',\n    'preserve_mapping',\n    'record_warnings',\n    'setattr',\n]\n"]}
{"filename": "pytypest/fixtures/_misc.py", "chunked_list": ["from __future__ import annotations\n\nimport os\nimport socket\nimport unittest.mock\nfrom pathlib import Path\nfrom typing import (\n    Callable, ContextManager, Iterator, MutableMapping, Sequence, TypeVar,\n)\n", ")\n\nfrom .._fixture_factory import fixture\nfrom .._hub import hub\nfrom ._helpers import NetworkGuard\n\n\nT = TypeVar('T')\n\n", "\n\n@fixture\ndef defer(callback: Callable[[], object]) -> Iterator[None]:\n    \"\"\"Execute the given callback when leaving the test function.\n\n    It's a nice way to clean up after a test function without\n    creating a fixture or a context manager.\n\n    Similar to :pytest:`pytest.FixtureRequest.addfinalizer`.\n\n    ::\n\n        stream = open('some-file.txt')\n        defer(stream.close)\n\n    \"\"\"\n    yield\n    callback()", "\n\n@fixture\ndef enter_context(manager: ContextManager[T]) -> Iterator[T]:\n    \"\"\"\n    Enter the context manager, return its result,\n    and exit the context when leaving the test function.\n\n    It's a bit imilar to `contextlib.ExitStack` in a sense\n    that it helps to keep code indentation low\n    when entering multiple context managers.\n\n    ::\n\n        stream = enter_context(open('some_file'))\n\n    \"\"\"\n    with manager as value:\n        yield value", "\n\n@fixture\ndef forbid_networking(\n    *,\n    allowed: Sequence[tuple[str, int]] = (),\n) -> Iterator[None]:\n    \"\"\"Forbid network connections during the test.\n\n    This fixture is a good candidate for :func:`pytypest.autouse`.\n\n    The `allowed` argument accepts a sequence of `(host, port)` pairs\n    to which connections should still be allowed.\n\n    ::\n\n        forbid_networking(allowed=[('example.com', 443)])\n\n    \"\"\"\n    guard = NetworkGuard(\n        allowed=frozenset(allowed),\n        wrapped=socket.getaddrinfo,\n    )\n    socket.getaddrinfo = guard\n    yield\n    socket.getaddrinfo = guard.wrapped", "\n\n@fixture\ndef chdir(path: Path | str) -> Iterator[None]:\n    \"\"\"Change the current working dir to the given path.\n\n    Similar to :pytest:`pytest.MonkeyPatch.chdir`.\n\n    ::\n\n        chdir('/')\n\n    \"\"\"\n    old_path = Path.cwd()\n    os.chdir(path)\n    yield\n    os.chdir(old_path)", "\n\n@fixture\ndef preserve_mapping(target: MutableMapping) -> Iterator[None]:\n    \"\"\"Restore the current state of the mapping after leaving the test.\n\n    After calling the fixture, you can safely modify the given mapping,\n    and these changes will be reverted before the next test starts.\n\n    It's not a deep copy, though. If you modify a list inside of the mapping,\n    that modification will escape the test.\n\n    ::\n\n        import sys\n        preserve_mapping(sys.modules)\n        sys.modules['requests'] = Mock()\n\n    \"\"\"\n    with unittest.mock.patch.dict(target):\n        yield", "\n\ndef get_project_root() -> Path:\n    \"\"\"Get the path to the root directory of the project.\n\n    ::\n\n        root = get_project_root()\n        assert (root / 'pyproject.toml').exists()\n\n    https://docs.pytest.org/en/7.1.x/reference/customize.html#finding-the-rootdir\n    \"\"\"\n    if hub.request is None:\n        raise RuntimeError('pytest plugin is not active')\n    return hub.request.session.config.rootpath", ""]}
{"filename": "pytypest/fixtures/_pytest.py", "chunked_list": ["from __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Any, Iterator\n\nimport pytest\n\nfrom .._fixture_factory import fixture\nfrom .._hub import hub\n", "from .._hub import hub\n\n\n@fixture\ndef get_request() -> pytest.FixtureRequest:\n    \"\"\"Get meta information about the currently running test.\n\n    A wrapper around :pytest:`request` pytest fixture.\n\n    ::\n\n        request = get_request()\n        verbosity = request.config.getoption(\"verbose\")\n        if verbosity > 0:\n            ...\n\n    \"\"\"\n    if hub.request is None:\n        raise RuntimeError('pytest plugin is not active')\n    return hub.request", "\n\n@fixture\ndef get_pytest_fixture(name: str) -> Any:\n    \"\"\"Get a pytest fixture by its name.\n\n    A wrapper around :pytest:`pytest.FixtureRequest.getfixturevalue`.\n\n    This is useful for using fixtures from third-party pytest plugins.\n    All built-in pytest fixtures already have a convenient wrapper in pytypest.\n\n    For example, get ``event_loop`` fixture from pytest-asyncio::\n\n        from asyncio import AbstractEventLoop\n        loop: AbstractEventLoop = get_pytest_fixture('event_loop')\n\n    \"\"\"\n    request = get_request()\n    return request.getfixturevalue(name)", "\n\n@fixture\ndef capture_std(*, binary: bool = False, fd: bool = False) -> pytest.CaptureFixture:\n    \"\"\"Capture stdout and stderr.\n\n    A wrapper around :pytest:`capsys`, :pytest:`capfd`, :pytest:`capsysbinary`,\n    and :pytest:`capfdbinary` pytest fixtures.\n\n    ::\n\n        cap = capture_std()\n        print('hello')\n        captured = cap.readouterr()\n        assert captured.out.rstrip() == 'hello'\n\n    \"\"\"\n    root = 'fd' if fd else 'sys'\n    suffix = 'binary' if binary else ''\n    return get_pytest_fixture(f'cap{root}{suffix}')", "\n\n@fixture\ndef capture_logs() -> pytest.LogCaptureFixture:\n    \"\"\"Capture all log records.\n\n    A wrapper around :pytest:`caplog` pytest fixture.\n\n    ::\n\n        import logging\n        cap = capture_logs()\n        logging.warning('oh hi mark')\n        record = cap.records[-1]\n        assert record.message == 'oh hi mark'\n\n    \"\"\"\n    return get_pytest_fixture('caplog')", "\n\n@fixture\ndef record_warnings() -> pytest.WarningsRecorder:\n    \"\"\"Record all warnings (emitted using ``warnings`` module).\n\n    A wrapper around :pytest:`recwarn` pytest fixture.\n\n    ::\n\n        import warnings\n        rec = fixtures.record_warnings()\n        warnings.warn('oh hi mark', UserWarning)\n        w = rec.pop(UserWarning)\n        assert str(w.message) == 'oh hi mark'\n\n    \"\"\"\n    return get_pytest_fixture('recwarn')", "\n\n@fixture\ndef make_temp_dir(basename: str | None = None, numbered: bool = True) -> Path:\n    \"\"\"Create a temporary directory.\n\n    A wrapper around :pytest:`tmp_path` and :pytest:`tmp_path_factory`\n    pytest fixtures.\n\n    Args:\n        basename: if specified, the created directory will have this name.\n        numbered: if True (default), ensure the directory is unique\n            by adding a numbered suffix greater than any existing one.\n\n    ::\n\n        dir_path = fixtures.make_temp_dir()\n        file_path = dir_path / 'example.py'\n        file_path.write_text('1 + 2')\n        ...\n        content = file_path.read_text()\n        assert content == '1 + 2'\n\n    \"\"\"\n    if basename is not None:\n        factory: pytest.TempPathFactory = get_pytest_fixture('tmp_path_factory')\n        return factory.mktemp(basename=basename, numbered=numbered)\n    return get_pytest_fixture('tmp_path')", "\n\n@fixture\ndef monkeypatch() -> Iterator[pytest.MonkeyPatch]:\n    \"\"\"Patch attributes of objects for the duration of test.\n\n    A wrapper around :pytest:`monkeypatch` pytest fixture.\n\n    Usually, you don't need to use this fixture directly. The preferred way to\n    patch things is using :func:`pytypest.fixtures.setattr`,\n    :func:`pytypest.fixtures.delattr`, and :func:`pytypest.fixtures.preserve_mapping`.\n    \"\"\"\n    patcher = pytest.MonkeyPatch()\n    yield patcher\n    patcher.undo()", "\n\n@fixture\ndef setattr(\n    target: object | str,\n    name: str,\n    value: object,\n    *,\n    must_exist: bool = True,\n) -> Iterator[None]:\n    \"\"\"Patch an attribute for the duration of test.\n\n    A wrapper around :pytest:`pytest.MonkeyPatch.setattr`.\n\n    The target can be either the object to patch or the full import path to the object.\n    The target can be any object, including modules, classes, methods, and functions.\n\n    ::\n\n        from unittest.mock import Mock\n        mock = Mock()\n        setattr('logging', 'info', mock)\n\n    \"\"\"\n    patcher = pytest.MonkeyPatch()\n    if isinstance(target, str):\n        patcher.setattr(f'{target}.{name}', value, raising=must_exist)\n    else:\n        patcher.setattr(target, name, value, raising=must_exist)\n    yield\n    patcher.undo()", "\n\n@fixture\ndef delattr(\n    target: object | str,\n    name: str,\n    *,\n    must_exist: bool = True,\n) -> Iterator[None]:\n    \"\"\"Delete attribute of an object for the duration of test.\n\n    A wrapper around :pytest:`pytest.MonkeyPatch.delattr`.\n\n    The target can be either the object to patch or the full import path to the object.\n    The target can be any object, including modules, classes, methods, and functions.\n\n    ::\n\n        delattr(logging, 'info')\n\n    \"\"\"\n    patcher = pytest.MonkeyPatch()\n    if isinstance(target, str):\n        patcher.delattr(f'{target}.{name}', raising=must_exist)\n    else:\n        patcher.delattr(target, name, raising=must_exist)\n    yield\n    patcher.undo()", ""]}
{"filename": "pytypest/experimental/__init__.py", "chunked_list": ["from ._attr import attr\nfrom ._patcher import patcher\n\n\n__all__ = ['attr', 'patcher']\n"]}
{"filename": "pytypest/experimental/_patcher.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import Any, Iterator, TypeVar\n\nimport pytest\n\nfrom .._fixture_factory import fixture\n\n\nK = TypeVar('K')", "\nK = TypeVar('K')\nV = TypeVar('V')\n\n\nclass AttrPatcher:\n    def __init__(\n        self,\n        patcher: pytest.MonkeyPatch,\n        target: object | str,\n    ) -> None:\n        self.__patcher = patcher\n        self.__target = target\n\n    def __setattr__(self, name: str, value: object) -> None:\n        if name.startswith('_AttrPatcher__'):\n            return super().__setattr__(name, value)\n        if isinstance(self.__target, str):\n            self.__patcher.setattr(f'{self.__target}.{name}', value)\n        else:\n            self.__patcher.setattr(self.__target, name, value)\n\n    def __delattr__(self, name: str) -> None:\n        self.__patcher.delattr(self.__target, name)", "\n\n@fixture\ndef patcher(target: object | str) -> Iterator[Any]:\n    \"\"\"A fixture to patch and delete attributes of the given object.\n\n    Patch an attribute::\n\n        patcher(logging).info = Mock()\n\n    Delete an attribute::\n\n        del patcher(logging).info\n\n    The object can be also specified as a full import path string::\n\n        patcher('logging').info = Mock()\n\n    All changes to the object will be reverted when leaving the context.\n    \"\"\"\n    monkey_patcher = pytest.MonkeyPatch()\n    yield AttrPatcher(monkey_patcher, target)\n    monkey_patcher.undo()", ""]}
{"filename": "pytypest/experimental/_attr.py", "chunked_list": ["from __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import TYPE_CHECKING, Any, Generic, TypeVar, overload\n\nfrom typing_extensions import ParamSpec\n\n\nif TYPE_CHECKING:\n    from .._fixture import Fixture", "if TYPE_CHECKING:\n    from .._fixture import Fixture\n\n\nP = ParamSpec('P')\nR = TypeVar('R')\n\n\ndef attr(fixture: Fixture[P, R], *args: P.args, **kwargs: P.kwargs) -> Attr[P, R]:\n    \"\"\"A wrapper to use a fixture as a container attribute.\n\n    A fixture wrapped with ``attr`` can be accessed as a class attribute\n    without explicitly calling it. It's equivalent to defining a ``@property``\n    that calls the fixture inside and returns its result but shorter.\n\n    ::\n\n        class Fixtures:\n            user = attr(get_user)\n\n        def test_user():\n            f = Fixtures()\n            assert f.user.name == 'mark'\n\n    \"\"\"\n    return Attr(fixture, args, kwargs)", "def attr(fixture: Fixture[P, R], *args: P.args, **kwargs: P.kwargs) -> Attr[P, R]:\n    \"\"\"A wrapper to use a fixture as a container attribute.\n\n    A fixture wrapped with ``attr`` can be accessed as a class attribute\n    without explicitly calling it. It's equivalent to defining a ``@property``\n    that calls the fixture inside and returns its result but shorter.\n\n    ::\n\n        class Fixtures:\n            user = attr(get_user)\n\n        def test_user():\n            f = Fixtures()\n            assert f.user.name == 'mark'\n\n    \"\"\"\n    return Attr(fixture, args, kwargs)", "\n\n@dataclass(frozen=True)\nclass Attr(Generic[P, R]):\n    fixture: Fixture[P, R]\n    args: tuple\n    kwargs: dict[str, Any]\n\n    @overload\n    def __get__(self, obj: None, objtype: type) -> Attr[P, R]:\n        pass\n\n    @overload\n    def __get__(self, obj: object, objtype: type) -> R:\n        pass\n\n    def __get__(self, obj: object | None, objtype: type) -> Attr[P, R] | R:\n        if obj is None:\n            return self\n        return self.fixture(*self.args, **self.kwargs)", ""]}
{"filename": "tests/test_parametrize.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nimport pytest\n\nfrom pytypest import case, parametrize\n\n\nif TYPE_CHECKING:\n    from _pytest.mark.structures import Mark", "\nif TYPE_CHECKING:\n    from _pytest.mark.structures import Mark\n\n\ndef test_parametrize() -> None:\n    def inner(a: int, b: int):\n        pass\n    wrapped = parametrize(\n        inner,\n        case(3, 4),\n        case(5, b=6),\n        case(a=7, b=8),\n        case(b=10, a=9),\n        case.id('one')(11, 12),\n        case.tags('two', 'three')(13, 14),\n        four=case(15, 16),\n    )\n    mark: Mark\n    (mark,) = wrapped.pytestmark  # type: ignore[attr-defined]\n    assert mark.name == 'parametrize'\n    assert mark.args == (\n        ['a', 'b'],\n        [\n            [3, 4], [5, 6], [7, 8], [9, 10],\n            pytest.param(11, 12, id='one'),\n            pytest.param(13, 14, marks=(pytest.mark.two, pytest.mark.three)),\n            pytest.param(15, 16, id='four'),\n        ],\n    )", "\n\ndef test_preserve_marks() -> None:\n    @pytest.mark.two\n    def inner(a: int, b: int):\n        pass\n    wrapped = parametrize(inner, case(3, 4))\n    wrapped = pytest.mark.three(wrapped)\n    marks = wrapped.pytestmark  # type: ignore[attr-defined]\n    assert len(marks) == 3", ""]}
{"filename": "tests/test_fixture.py", "chunked_list": ["from typing import Callable\n\nimport pytest\n\nfrom pytypest import Scope, fixture\n\n\ndef test_setup_return() -> None:\n    log = []\n\n    @fixture\n    def fixt():\n        log.append(42)\n        return 13\n\n    assert fixt.setup() == 13\n    assert log == [42]", "\n\ndef test_setup_yield() -> None:\n    log = []\n\n    @fixture\n    def fixt():\n        log.append(42)\n        yield 13\n\n    assert fixt.setup() == 13\n    assert log == [42]", "\n\ndef test_teardown_return() -> None:\n    @fixture\n    def fixt():\n        return 13\n\n    fixt.teardown()\n    assert fixt.setup() == 13\n    fixt.teardown()", "\n\ndef test_teardown_yield() -> None:\n    log = []\n\n    @fixture\n    def fixt():\n        yield 13\n        log.append(42)\n\n    fixt.teardown()\n    assert fixt.setup() == 13\n    fixt.teardown()\n    assert log == [42]", "\n\ndef test_teardown_on_leaving_scope(isolated: None, scoped: Callable) -> None:\n    log = []\n\n    @fixture(scope=Scope.CLASS)\n    def fixt():\n        log.append('s')\n        yield 62\n        log.append('t')\n\n    with scoped('class'):\n        with scoped('function'):\n            assert log == []\n            for _ in range(4):\n                assert fixt() == 62\n                assert log == ['s']\n        assert log == ['s']\n\n    assert log == ['s', 't']", "\n\ndef test_disallow_double_yield(isolated, scoped):\n    @fixture\n    def fixt():\n        yield\n        yield\n\n    msg = 'fixture must have at most one yield'\n    with pytest.raises(RuntimeError, match=msg):\n        with scoped('function'):\n            fixt()", "\n\ndef test_plugin_not_active():\n    @fixture\n    def fixt():\n        yield\n\n    msg = 'pytest plugin is not activated'\n    with pytest.raises(RuntimeError, match=msg):\n        fixt()", "\n\ndef test_context_manager(isolated, scoped):\n    log = []\n\n    @fixture\n    def fixt():\n        log.append('s')\n        yield 67\n        log.append('t')\n\n    with scoped('function'):\n        assert log == []\n        with fixt as val:\n            assert log == ['s']\n            assert val == 67\n        assert log == ['s', 't']\n    assert log == ['s', 't']", ""]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/test_autouse.py", "chunked_list": ["import pytest\n\nfrom pytypest import Scope, autouse, fixture\n\n\ndef test_double_autouse(isolated) -> None:\n    @fixture\n    def fixt():\n        yield\n\n    autouse(fixt)\n    msg = 'autouse can be called only once'\n    with pytest.raises(RuntimeError, match=msg):\n        autouse(fixt)", "\n\ndef test_autouse(isolated, scoped) -> None:\n    log = []\n\n    @fixture(scope=Scope.CLASS)\n    def fixt():\n        log.append('s')\n        yield\n        log.append('t')\n\n    autouse(fixt)\n    assert log == []\n    with scoped('class'):\n        assert log == ['s']\n        with scoped('function'):\n            assert log == ['s']\n        assert log == ['s']\n    assert log == ['s', 't']", ""]}
{"filename": "tests/test_experimental.py", "chunked_list": ["from __future__ import annotations\n\nfrom pytypest import experimental, fixture\n\n\nclass Global:\n    attr: int = 42\n\n\ndef test_setattr(isolated, scoped):\n    class A:\n        a = 13\n\n    with scoped('function'):\n        p = experimental.patcher(A)\n        p.a = 54\n        assert A.a == 54\n    assert A.a == 13", "\ndef test_setattr(isolated, scoped):\n    class A:\n        a = 13\n\n    with scoped('function'):\n        p = experimental.patcher(A)\n        p.a = 54\n        assert A.a == 54\n    assert A.a == 13", "\n\ndef test_setattr__str_target(isolated, scoped):\n    target = f'{Global.__module__}.{Global.__name__}'\n    with scoped('function'):\n        p = experimental.patcher(target)\n        p.attr = 99\n        assert Global.attr == 99\n    assert Global.attr == 42\n", "\n\ndef test_delattr(isolated, scoped):\n    class A:\n        a = 13\n\n    with scoped('function'):\n        p = experimental.patcher(A)\n        del p.a\n        assert not hasattr(A, 'a')\n    assert A.a == 13", "\n\ndef test_attr(isolated, scoped):\n    log = []\n\n    @fixture\n    def fixt():\n        log.append('s')\n        yield 14\n        log.append('t')\n\n    class Container:\n        val = experimental.attr(fixt)\n\n    c = Container()\n    assert Container.val.fixture is fixt\n    with scoped('function'):\n        assert log == []\n        for _ in range(4):\n            assert c.val == 14\n            assert log == ['s']\n    assert log == ['s', 't']", ""]}
{"filename": "tests/test_fixtrues.py", "chunked_list": ["from __future__ import annotations\n\nfrom contextlib import contextmanager\nfrom pathlib import Path\n\nimport pytest\nimport requests\n\nfrom pytypest import fixtures\n", "from pytypest import fixtures\n\n\nclass Global:\n    attr: int = 42\n\n\ndef test_get_request(isolated, scoped) -> None:\n    with scoped('function'):\n        req = fixtures.get_request()\n        assert req.function is test_get_request\n        assert req.scope == 'function'", "\n\ndef test_get_request__not_active() -> None:\n    msg = 'pytest plugin is not active'\n    with pytest.raises(RuntimeError, match=msg):\n        fixtures.get_request()\n\n\ndef test_make_temp_dir(isolated, scoped) -> None:\n    with scoped('function'):\n        path = fixtures.make_temp_dir()\n        assert path.is_dir()", "def test_make_temp_dir(isolated, scoped) -> None:\n    with scoped('function'):\n        path = fixtures.make_temp_dir()\n        assert path.is_dir()\n\n\ndef test_make_temp_dir__basename(isolated, scoped) -> None:\n    with scoped('function'):\n        path = fixtures.make_temp_dir('hello', numbered=False)\n        assert path.is_dir()\n        assert path.name == 'hello'", "\n\ndef test_make_temp_dir__numbered(isolated, scoped) -> None:\n    with scoped('function'):\n        path = fixtures.make_temp_dir('hello', numbered=True)\n        assert path.is_dir()\n        assert path.name == 'hello0'\n\n\ndef test_chdir(isolated, scoped) -> None:\n    dir1 = Path.cwd()\n    with scoped('function'):\n        fixtures.chdir(dir1.parent)\n        dir2 = Path.cwd()\n        assert dir2 == dir1.parent", "\ndef test_chdir(isolated, scoped) -> None:\n    dir1 = Path.cwd()\n    with scoped('function'):\n        fixtures.chdir(dir1.parent)\n        dir2 = Path.cwd()\n        assert dir2 == dir1.parent\n\n\ndef test_get_pytest_fixture(isolated, scoped, tmp_path) -> None:\n    with scoped('function'):\n        path = fixtures.get_pytest_fixture('tmp_path')\n        assert path is tmp_path", "\ndef test_get_pytest_fixture(isolated, scoped, tmp_path) -> None:\n    with scoped('function'):\n        path = fixtures.get_pytest_fixture('tmp_path')\n        assert path is tmp_path\n\n\n@pytest.mark.parametrize('given, expected', [\n    (fixtures.capture_std, 'capsys'),\n    (lambda: fixtures.capture_std(binary=True), 'capsysbinary'),", "    (fixtures.capture_std, 'capsys'),\n    (lambda: fixtures.capture_std(binary=True), 'capsysbinary'),\n    (lambda: fixtures.capture_std(fd=True), 'capfd'),\n    (lambda: fixtures.capture_std(binary=True, fd=True), 'capfdbinary'),\n    (fixtures.capture_logs, 'caplog'),\n    (fixtures.record_warnings, 'recwarn'),\n])\ndef test_proxying(isolated, scoped, given, expected, request) -> None:\n    with scoped('function'):\n        fixt1 = request.getfixturevalue(expected)\n        fixt2 = fixtures.get_pytest_fixture(expected)\n        fixt3 = given()\n        assert fixt1 is fixt2\n        assert fixt2 is fixt3", "\n\ndef test_defer(isolated, scoped) -> None:\n    log = []\n    with scoped('function'):\n        fixtures.defer(lambda: log.append(1))\n        assert log == []\n    assert log == [1]\n\n\ndef test_defer__no_scope(isolated, scoped) -> None:\n    msg = 'cannot find ScopeManager for `function` scope'\n    with pytest.raises(LookupError, match=msg):\n        fixtures.defer(lambda: None)\n    with scoped('class'):\n        with pytest.raises(LookupError, match=msg):\n            fixtures.defer(lambda: None)", "\n\ndef test_defer__no_scope(isolated, scoped) -> None:\n    msg = 'cannot find ScopeManager for `function` scope'\n    with pytest.raises(LookupError, match=msg):\n        fixtures.defer(lambda: None)\n    with scoped('class'):\n        with pytest.raises(LookupError, match=msg):\n            fixtures.defer(lambda: None)\n", "\n\ndef test_enter_context(isolated, scoped) -> None:\n    log = []\n\n    @contextmanager\n    def man():\n        log.append('enter')\n        yield 17\n        log.append('exit')\n\n    with scoped('function'):\n        res = fixtures.enter_context(man())\n        assert log == ['enter']\n        assert res == 17\n    assert log == ['enter', 'exit']", "\n\ndef test_forbid_networking__bad_host(isolated, scoped) -> None:\n    with scoped('function'):\n        fixtures.forbid_networking()\n        msg = 'connection to example.com:443 is not allowed'\n        with pytest.raises(BaseException, match=msg):\n            requests.get('https://example.com/')\n\n\ndef test_forbid_networking__bad_port(isolated, scoped) -> None:\n    with scoped('function'):\n        fixtures.forbid_networking(allowed=[('example.com', 80)])\n        msg = 'connection to example.com:443 is not allowed'\n        with pytest.raises(BaseException, match=msg):\n            requests.get('https://example.com/')", "\n\ndef test_forbid_networking__bad_port(isolated, scoped) -> None:\n    with scoped('function'):\n        fixtures.forbid_networking(allowed=[('example.com', 80)])\n        msg = 'connection to example.com:443 is not allowed'\n        with pytest.raises(BaseException, match=msg):\n            requests.get('https://example.com/')\n\n\ndef test_forbid_networking__allowed_host_port(isolated, scoped) -> None:\n    with scoped('function'):\n        fixtures.forbid_networking(\n            allowed=[('example.com', 443)],\n        )\n        requests.get('https://example.com/')", "\n\ndef test_forbid_networking__allowed_host_port(isolated, scoped) -> None:\n    with scoped('function'):\n        fixtures.forbid_networking(\n            allowed=[('example.com', 443)],\n        )\n        requests.get('https://example.com/')\n\n\ndef test_monkeypatch(isolated, scoped):\n    class A:\n        a = 13\n\n    with scoped('function'):\n        p = fixtures.monkeypatch()\n        p.setattr(A, 'a', 54)\n        assert A.a == 54", "\n\ndef test_monkeypatch(isolated, scoped):\n    class A:\n        a = 13\n\n    with scoped('function'):\n        p = fixtures.monkeypatch()\n        p.setattr(A, 'a', 54)\n        assert A.a == 54", "\n\ndef test_setattr(isolated, scoped):\n    class A:\n        a = 13\n\n    with scoped('function'):\n        fixtures.setattr(A, 'a', 54)\n        assert A.a == 54\n    assert A.a == 13", "\n\ndef test_setattr__str_target(isolated, scoped):\n    target = f'{Global.__module__}.{Global.__name__}'\n    with scoped('function'):\n        fixtures.setattr(target, 'attr', 99)\n        assert Global.attr == 99\n    assert Global.attr == 42\n\n\ndef test_delattr(isolated, scoped):\n    class A:\n        a = 13\n\n    with scoped('function'):\n        fixtures.delattr(A, 'a')\n        assert not hasattr(A, 'a')\n    assert A.a == 13", "\n\ndef test_delattr(isolated, scoped):\n    class A:\n        a = 13\n\n    with scoped('function'):\n        fixtures.delattr(A, 'a')\n        assert not hasattr(A, 'a')\n    assert A.a == 13", "\n\ndef test_delattr__str_target(isolated, scoped):\n    target = f'{Global.__module__}.{Global.__name__}'\n    with scoped('function'):\n        fixtures.delattr(target, 'attr')\n        assert not hasattr(Global, 'attr')\n    assert Global.attr == 42\n\n\ndef test_preserve_mapping(isolated, scoped):\n    d = {1: 2, 3: 4, 5: 6}\n    with scoped('function'):\n        fixtures.preserve_mapping(d)\n        d[1] = 7\n        del d[5]\n        assert d == {1: 7, 3: 4}\n    assert d == {1: 2, 3: 4, 5: 6}", "\n\ndef test_preserve_mapping(isolated, scoped):\n    d = {1: 2, 3: 4, 5: 6}\n    with scoped('function'):\n        fixtures.preserve_mapping(d)\n        d[1] = 7\n        del d[5]\n        assert d == {1: 7, 3: 4}\n    assert d == {1: 2, 3: 4, 5: 6}", "\n\ndef test_get_project_root(isolated, scoped):\n    with scoped('function'):\n        root = fixtures.get_project_root()\n        assert (root / 'pyproject.toml').is_file()\n        assert (root / 'pytypest').is_dir()\n\n\ndef test_get_project_root__not_active() -> None:\n    msg = 'pytest plugin is not active'\n    with pytest.raises(RuntimeError, match=msg):\n        fixtures.get_project_root()", "\ndef test_get_project_root__not_active() -> None:\n    msg = 'pytest plugin is not active'\n    with pytest.raises(RuntimeError, match=msg):\n        fixtures.get_project_root()\n\n\ndef test_capture_std(isolated, scoped):\n    with scoped('function'):\n        cap = fixtures.capture_std()\n        print('hello')\n        captured = cap.readouterr()\n        assert captured.out == 'hello\\n'", "\n\ndef test_capture_logs(isolated, scoped):\n    with scoped('function'):\n        import logging\n        cap = fixtures.capture_logs()\n        logging.warning('oh hi mark')\n        record = cap.records[-1]\n        assert record.message == 'oh hi mark'\n", "\n\ndef test_record_warnings(isolated, scoped):\n    with scoped('function'):\n        import warnings\n        rec = fixtures.record_warnings()\n        warnings.warn('oh hi mark', UserWarning, stacklevel=1)\n        w = rec.pop(UserWarning)\n        assert str(w.message) == 'oh hi mark'\n", ""]}
{"filename": "tests/conftest.py", "chunked_list": ["from __future__ import annotations\n\nfrom contextlib import contextmanager\nfrom typing import Callable, Iterator\n\nimport pytest\n\nfrom pytypest import _plugin\nfrom pytypest._hub import hub\n", "from pytypest._hub import hub\n\n\n@pytest.fixture\ndef isolated(request: pytest.FixtureRequest) -> Iterator[None]:\n    _plugin.pytest_sessionstart(request.session)\n    yield\n    hub.reset()\n    delattr(request.session, _plugin.SESSION_ATTR)\n", "\n\n@pytest.fixture\ndef scoped(request: pytest.FixtureRequest) -> Iterator[Callable]:\n\n    @contextmanager\n    def wrapper(scope: str):\n        from _pytest.scope import Scope\n\n        old_scope = request._scope\n        request._scope = Scope(scope)\n        it = _plugin._manage_scope(request)\n        next(it)\n        try:\n            yield\n        finally:\n            try:\n                next(it)\n            except StopIteration:\n                pass\n            request._scope = old_scope\n\n    yield wrapper", ""]}
{"filename": "integration/test_args.py", "chunked_list": ["\"\"\"Fixtures with arguments aren't cached.\n\"\"\"\nfrom typing import Iterator\n\nfrom pytypest import fixture\n\n\n_setup = []\n\n", "\n\n@fixture\ndef fixt(a, b) -> Iterator[int]:\n    _setup.append(a)\n    return a + b\n\n\ndef test_simple1():\n    n = fixt(6, b=7)\n    assert n == 13\n    assert _setup == [6]", "def test_simple1():\n    n = fixt(6, b=7)\n    assert n == 13\n    assert _setup == [6]\n\n\ndef test_simple2():\n    n = fixt(a=3, b=4)\n    assert n == 7\n    assert _setup == [6, 3]", "\n\ndef test_double():\n    n1 = fixt(a=3, b=4)\n    assert n1 == 7\n    assert _setup == [6, 3, 3]\n    n1 = fixt(a=4, b=5)\n    assert n1 == 9\n    assert _setup == [6, 3, 3, 4]\n", "\n\ndef test_after():\n    assert _setup == [6, 3, 3, 4]\n"]}
{"filename": "integration/test_teardown.py", "chunked_list": ["\"\"\"The basic test for fixtures with teardown.\n\"\"\"\nfrom typing import Iterator\n\nfrom pytypest import fixture\n\n\n_setup = []\n_teardown = []\n", "_teardown = []\n\n\n@fixture\ndef fixt() -> Iterator[int]:\n    _setup.append(0)\n    yield 13\n    _teardown.append(0)\n\n\ndef test_simple():\n    n = fixt()\n    assert n == 13\n    assert _setup == [0]\n    assert _teardown == []", "\n\ndef test_simple():\n    n = fixt()\n    assert n == 13\n    assert _setup == [0]\n    assert _teardown == []\n\n\ndef test_after():\n    assert _setup == [0]\n    assert _teardown == [0]", "\ndef test_after():\n    assert _setup == [0]\n    assert _teardown == [0]\n"]}
{"filename": "integration/test_simple.py", "chunked_list": ["\"\"\"The most basic test for the most basic fixture.\n\"\"\"\nfrom pytypest import fixture\n\n\n@fixture\ndef fixt() -> int:\n    return 13\n\n\ndef test_simple():\n    n = fixt()\n    assert n == 13", "\n\ndef test_simple():\n    n = fixt()\n    assert n == 13\n"]}
{"filename": "integration/test_parametrize.py", "chunked_list": ["\"\"\"The basic test for `parametrize` and `case`.\n\"\"\"\nfrom pytypest import case, parametrize\n\n\ndef _test_double(x: int, exp: int):\n    assert x * 2 == exp\n\n\ntest_double = parametrize(", "\ntest_double = parametrize(\n    _test_double,\n    case(3, 6),\n    case(3, exp=6),\n    case(x=3, exp=6),\n    case.id('pos-only')(3, 6),\n)\n\n\ndef _test_divide(x: int, y: int = 1, *, exp: int):\n    assert x // y == exp", "\n\ndef _test_divide(x: int, y: int = 1, *, exp: int):\n    assert x // y == exp\n\n\ntest_divide = parametrize(\n    _test_divide,\n    case(8, 2, exp=4),\n    case(3, exp=3),", "    case(8, 2, exp=4),\n    case(3, exp=3),\n)\n"]}
{"filename": "integration/test_attr.py", "chunked_list": ["\"\"\"Fixtures can be combined into containers.\n\nFixtures in a container instance must be available without calling them.\n\"\"\"\nfrom pytypest import fixture\nfrom pytypest.experimental import attr\n\n\n_setup = []\n", "_setup = []\n\n\n@fixture\ndef fixt() -> int:\n    _setup.append(0)\n    return 13\n\n\nclass Container:\n    val = attr(fixt)", "\nclass Container:\n    val = attr(fixt)\n\n\ndef test_simple():\n    assert _setup == []\n    assert Container.val.fixture is fixt\n    assert _setup == []\n    c = Container()\n    assert _setup == []\n    assert c.val == 13\n    assert _setup == [0]", ""]}
{"filename": "integration/test_scope_class.py", "chunked_list": ["\"\"\"Teardown for class-scoped fixtures is executed after leaving the class scope.\n\"\"\"\nfrom typing import Iterator\n\nfrom pytypest import Scope, fixture\n\n\n_setup = []\n_teardown = []\n", "_teardown = []\n\n\n@fixture(scope=Scope.CLASS)\ndef fixt() -> Iterator[int]:\n    _setup.append(0)\n    yield 13\n    _teardown.append(0)\n\n\nclass TestClass:\n    def test_simple_1(self):\n        n = fixt()\n        assert n == 13\n        assert _setup == [0]\n        assert _teardown == []\n\n    def test_simple_2(self):\n        n = fixt()\n        assert n == 13\n        assert _setup == [0]\n        assert _teardown == []\n\n    def test_after_test(self):\n        assert _setup == [0]\n        assert _teardown == []", "\n\nclass TestClass:\n    def test_simple_1(self):\n        n = fixt()\n        assert n == 13\n        assert _setup == [0]\n        assert _teardown == []\n\n    def test_simple_2(self):\n        n = fixt()\n        assert n == 13\n        assert _setup == [0]\n        assert _teardown == []\n\n    def test_after_test(self):\n        assert _setup == [0]\n        assert _teardown == []", "\n\ndef test_after_class():\n    assert _setup == [0]\n    assert _teardown == [0]\n"]}
{"filename": "integration/__init__.py", "chunked_list": [""]}
{"filename": "integration/test_args_n_teardown.py", "chunked_list": ["\"\"\"Teardown must be executed for fixtures with arguments.\n\"\"\"\nfrom typing import Iterator\n\nfrom pytypest import fixture\n\n\n_setup = []\n_teardown = []\n", "_teardown = []\n\n\n@fixture\ndef fixt(a, b) -> Iterator[int]:\n    _setup.append(a)\n    yield a + b\n    _teardown.append(a)\n\n\ndef test_simple1():\n    n = fixt(6, b=7)\n    assert n == 13\n    assert _setup == [6]\n    assert _teardown == []", "\n\ndef test_simple1():\n    n = fixt(6, b=7)\n    assert n == 13\n    assert _setup == [6]\n    assert _teardown == []\n\n\ndef test_simple2():\n    n1 = fixt(a=3, b=4)\n    assert n1 == 7\n    n2 = fixt(a=5, b=4)\n    assert n2 == 9\n    assert _setup == [6, 3, 5]\n    assert _teardown == [6]", "\ndef test_simple2():\n    n1 = fixt(a=3, b=4)\n    assert n1 == 7\n    n2 = fixt(a=5, b=4)\n    assert n2 == 9\n    assert _setup == [6, 3, 5]\n    assert _teardown == [6]\n\n\ndef test_after():\n    assert _setup == [6, 3, 5]\n    assert _teardown == [6, 3, 5]", "\n\ndef test_after():\n    assert _setup == [6, 3, 5]\n    assert _teardown == [6, 3, 5]\n"]}
{"filename": "integration/test_unwrap.py", "chunked_list": ["\"\"\"\nTeardown for fixtures must be executed in the reverse order to how they are called.\n\nSo, the first called fixture is teared down the last.\n\"\"\"\nfrom __future__ import annotations\n\nfrom typing import Iterator\n\nfrom pytypest import fixture", "\nfrom pytypest import fixture\n\n\n_setup = []\n_teardown = []\n\n\n@fixture\ndef a() -> Iterator[None]:\n    _setup.append('a')\n    yield\n    _teardown.append('a')", "@fixture\ndef a() -> Iterator[None]:\n    _setup.append('a')\n    yield\n    _teardown.append('a')\n\n\n@fixture\ndef b() -> Iterator[None]:\n    _setup.append('b')\n    yield\n    _teardown.append('b')", "def b() -> Iterator[None]:\n    _setup.append('b')\n    yield\n    _teardown.append('b')\n\n\n@fixture\ndef c() -> Iterator[None]:\n    a()\n    _setup.append('c')\n    yield\n    _teardown.append('c')", "\n\ndef test_simple() -> None:\n    c()\n    b()\n    a()\n    assert _setup == ['a', 'c', 'b']\n\n\ndef test_after() -> None:\n    assert _teardown == ['b', 'c', 'a']", "\ndef test_after() -> None:\n    assert _teardown == ['b', 'c', 'a']\n"]}
{"filename": "docs/conf.py", "chunked_list": ["project = 'pytypest'\ncopyright = '2023, @orsinium'\nauthor = '@orsinium'\ntemplates_path = ['_templates']\nhtml_theme = 'alabaster'\nautodoc_typehints_format = 'short'\nautodoc_preserve_defaults = True\nautodoc_member_order = 'bysource'\n\nextensions = [", "\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.napoleon',\n    'sphinx.ext.autosummary',\n    'sphinx.ext.extlinks',\n    'myst_parser',\n]\n\nextlinks = {", "\nextlinks = {\n    'pytest': ('https://docs.pytest.org/en/latest/reference/reference.html#%s', '%s'),\n}\n"]}
