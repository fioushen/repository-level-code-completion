{"filename": "setup.py", "chunked_list": ["from distutils.core import setup\n\nsetup(name='Apollo',\n      version='1.0',\n      packages=[\"cdm_processing\", \"utils\", \"simulating\", \"data_generating\"],\n     )"]}
{"filename": "extras/eval_mapping_solutions.py", "chunked_list": ["# Some code to see if we can speed up concept mapping\nimport random\nimport pandas as pd\nimport timeit\n\nrandom.seed(0)\n\nids_to_map = [random.randint(0, int(1e7)) for i in range(1000)]\nsource_ids = [random.randint(0, int(1e7)) for i in range(100000)]\ntarget_ids = [random.randint(0, int(1e7)) for i in range(100000)]", "source_ids = [random.randint(0, int(1e7)) for i in range(100000)]\ntarget_ids = [random.randint(0, int(1e7)) for i in range(100000)]\n\n\n# Using pandas\nmapping = pd.DataFrame({\"source_id\": source_ids, \"target_id\": target_ids})\nmapping.set_index(\"source_id\", drop=True, inplace=True)\ndf = pd.DataFrame({\"source_id\": ids_to_map})\nstmt = '''\nresult = df.merge(mapping, how=\"inner\", left_on=\"source_id\", right_index=True)", "stmt = '''\nresult = df.merge(mapping, how=\"inner\", left_on=\"source_id\", right_index=True)\n'''\ntimeit.timeit(stmt=stmt, globals=globals(), number=10)\n# 0.13781319199999942\n\n# Using a dictionary\nmapping = dict(zip(source_ids, target_ids))\n\n\ndef do_map(x):\n    if x in mapping:\n        return mapping[x]\n    else:\n        return -1", "\n\ndef do_map(x):\n    if x in mapping:\n        return mapping[x]\n    else:\n        return -1\n\n\nstmt = '''", "\nstmt = '''\nresult = [do_map(x) for x in ids_to_map]\n'''\ntimeit.timeit(stmt=stmt, globals=globals(), number=10)\n# 0.0017271530000471103\n"]}
{"filename": "extras/analyse_profile_stats.py", "chunked_list": ["# Code to display the results of profiling\n\nimport pstats\nfrom pstats import SortKey\np = pstats.Stats('../stats')\np.strip_dirs().sort_stats(SortKey.CUMULATIVE).print_stats(25)\n"]}
{"filename": "extras/read_stats.py", "chunked_list": ["import pstats\nfrom pstats import SortKey\np = pstats.Stats('stats')\np.strip_dirs().sort_stats(SortKey.CUMULATIVE).print_stats(25)"]}
{"filename": "extras/explore_all_parquet_ops.py", "chunked_list": ["import cdm_processing.cdm_processor_utils as cdm_utils\n\ncdm_folder = \"D:/GPM_CCAE\"\ncdm_tables = cdm_utils.get_cdm_tables(cdm_folder, 1)\ncdm_tables[\"person\"] = cdm_utils.add_date_of_birth(cdm_tables[\"person\"])\ndrug_mapping = cdm_utils.load_mapping_to_ingredients(cdm_folder=cdm_folder)\ncdm_tables[\"drug_exposure\"] = cdm_utils.map_concepts(cdm_table=cdm_tables[\"drug_exposure\"],\n                                                     concept_id_field=\"drug_concept_id\",\n                                                     mapping=drug_mapping)\ncombined_table = cdm_utils.union_domain_tables(cdm_tables)", "                                                     mapping=drug_mapping)\ncombined_table = cdm_utils.union_domain_tables(cdm_tables)\ncombined_table, removed_concepts = cdm_utils.remove_concepts(combined_table=combined_table,\n                                                             concept_ids=[0, 900000010])\ncombined_table, removed_duplicates = cdm_utils.remove_duplicates(combined_table=combined_table)\ncombined_table, visit_occurrence, mapping_stats = cdm_utils.link_events_to_visits(combined_table=combined_table,\n                                                                                  visit_occurrence=cdm_tables[\n                                                                                      \"visit_occurrence\"],\n                                                                                  mising_visit_concept_id=1)\n", "                                                                                  mising_visit_concept_id=1)\n\n# Create CEHR-BERT sequence format\nimport duckdb\n\ncon = duckdb.connect(database=':memory:', read_only=False)\ncon.register(\"visit_occurrence\", visit_occurrence)\ncon.register(\"observation_period_table\", cdm_tables[\"observation_period\"])\ncon.register(\"person\", cdm_tables[\"person\"])\ncon.register(\"combined_table\", combined_table)", "con.register(\"person\", cdm_tables[\"person\"])\ncon.register(\"combined_table\", combined_table)\nsql = \"CREATE TABLE visits AS \" \\\n      \"SELECT visit_occurrence.*, \" \\\n      \"  observation_period_id, \" \\\n      \"  ROW_NUMBER() OVER (PARTITION BY observation_period_id ORDER BY visit_start_date) AS visit_rank \" \\\n      \"FROM visit_occurrence \" \\\n      \"INNER JOIN observation_period_table \" \\\n      \"  ON visit_occurrence.person_id = observation_period_table.person_id \" \\\n      \"    AND visit_occurrence.visit_start_date >= observation_period_table.observation_period_start_date \" \\", "      \"  ON visit_occurrence.person_id = observation_period_table.person_id \" \\\n      \"    AND visit_occurrence.visit_start_date >= observation_period_table.observation_period_start_date \" \\\n      \"    AND visit_occurrence.visit_start_date <= observation_period_table.observation_period_end_date\"\ncon.execute(sql)\n\nsql = \"CREATE TABLE interval_tokens AS \" \\\n      \"SELECT CASE \" \\\n      \"    WHEN days < 0 THEN 'W-1' \" \\\n      \"    WHEN days < 28 THEN 'W' || CAST(CAST(FLOOR(days / 7) AS INT) AS VARCHAR) \" \\\n      \"    WHEN days < 360 THEN 'M' || CAST(CAST(FLOOR(days / 30) AS INT) AS VARCHAR) \" \\", "      \"    WHEN days < 28 THEN 'W' || CAST(CAST(FLOOR(days / 7) AS INT) AS VARCHAR) \" \\\n      \"    WHEN days < 360 THEN 'M' || CAST(CAST(FLOOR(days / 30) AS INT) AS VARCHAR) \" \\\n      \"    ELSE 'LT' \" \\\n      \"  END AS concept_id, \" \\\n      \"  0 AS visit_segments, \" \\\n      \"  0 AS dates, \" \\\n      \" -1 AS ages, \" \\\n      \"  visit_rank AS visit_concept_orders, \" \\\n      \"  0 AS visit_concept_ids, \" \\\n      \"  -2 AS sort_order, \" \\", "      \"  0 AS visit_concept_ids, \" \\\n      \"  -2 AS sort_order, \" \\\n      \"  observation_period_id \" \\\n      \"FROM (\" \\\n      \"  SELECT visits.visit_start_date - previous_visit.visit_end_date AS days,\" \\\n      \"    visits.* \" \\\n      \"  FROM visits \" \\\n      \"  INNER JOIN visits previous_visit\" \\\n      \"    ON visits.observation_period_id = previous_visit.observation_period_id \" \\\n      \"      AND visits.visit_rank = previous_visit.visit_rank + 1\" \\", "      \"    ON visits.observation_period_id = previous_visit.observation_period_id \" \\\n      \"      AND visits.visit_rank = previous_visit.visit_rank + 1\" \\\n      \") intervals\"\ncon.execute(sql)\n\nsql = \"CREATE TABLE start_tokens AS \" \\\n      \"SELECT 'VS' AS concept_id, \" \\\n      \"  visit_rank % 2 + 1 AS visit_segments, \" \\\n      \"  DATE_DIFF('week', DATE '1970-01-01', visit_start_date) AS dates, \" \\\n      \"  DATE_DIFF('month', date_of_birth, visit_start_date) AS ages, \" \\", "      \"  DATE_DIFF('week', DATE '1970-01-01', visit_start_date) AS dates, \" \\\n      \"  DATE_DIFF('month', date_of_birth, visit_start_date) AS ages, \" \\\n      \"  visit_rank AS visit_concept_orders, \" \\\n      \"  visit_concept_id AS visit_concept_ids, \" \\\n      \"  -1 AS sort_order, \" \\\n      \"  observation_period_id \" \\\n      \"FROM visits \" \\\n      \"INNER JOIN person \" \\\n      \"  ON visits.person_id = person.person_id\"\ncon.execute(sql)", "      \"  ON visits.person_id = person.person_id\"\ncon.execute(sql)\n\nsql = \"CREATE TABLE event_tokens AS \" \\\n      \"SELECT CAST(concept_id AS VARCHAR) AS concept_id, \" \\\n      \"  visit_rank % 2 + 1 AS visit_segments, \" \\\n      \"  DATE_DIFF('week', DATE '1970-01-01', start_date) AS dates, \" \\\n      \"  DATE_DIFF('month', date_of_birth,start_date) AS ages, \" \\\n      \"  visit_rank AS visit_concept_orders, \" \\\n      \"  visit_concept_id AS visit_concept_ids, \" \\", "      \"  visit_rank AS visit_concept_orders, \" \\\n      \"  visit_concept_id AS visit_concept_ids, \" \\\n      \"  concept_id AS sort_order, \" \\\n      \"  observation_period_id \" \\\n      \"FROM combined_table \" \\\n      \"INNER JOIN visits \" \\\n      \"  ON combined_table.internal_visit_id = visits.internal_visit_id \" \\\n      \"INNER JOIN person \" \\\n      \"  ON visits.person_id = person.person_id\"\ncon.execute(sql)", "      \"  ON visits.person_id = person.person_id\"\ncon.execute(sql)\n\nsql = \"CREATE TABLE end_tokens AS \" \\\n      \"SELECT 'VE' AS concept_id, \" \\\n      \"  visit_rank % 2 + 1 AS visit_segments, \" \\\n      \"  DATE_DIFF('week', DATE '1970-01-01', visit_end_date) AS dates, \" \\\n      \"  DATE_DIFF('month', date_of_birth, visit_end_date) AS ages, \" \\\n      \"  visit_rank AS visit_concept_orders, \" \\\n      \"  visit_concept_id AS visit_concept_ids, \" \\", "      \"  visit_rank AS visit_concept_orders, \" \\\n      \"  visit_concept_id AS visit_concept_ids, \" \\\n      \"  9223372036854775807 AS sort_order, \" \\\n      \"  observation_period_id \" \\\n      \"FROM visits \" \\\n      \"INNER JOIN person \" \\\n      \"  ON visits.person_id = person.person_id\"\ncon.execute(sql)\n\nsql = \"SELECT *, \" \\", "\nsql = \"SELECT *, \" \\\n      \"  ROW_NUMBER() OVER (PARTITION BY observation_period_id ORDER BY sort_order) AS orders \" \\\n      \"FROM (\" \\\n      \"  SELECT * FROM interval_tokens \" \\\n      \"  UNION ALL \" \\\n      \"  SELECT * FROM start_tokens \" \\\n      \"  UNION ALL \" \\\n      \"  SELECT * FROM event_tokens \" \\\n      \"  UNION ALL \" \\", "      \"  SELECT * FROM event_tokens \" \\\n      \"  UNION ALL \" \\\n      \"  SELECT * FROM end_tokens\" \\\n      \") tokens \" \\\n      \"ORDER BY observation_period_id, visit_concept_orders, sort_order\"\nunion_tokens = con.execute(sql).arrow()\ncon.execute(\"DROP TABLE interval_tokens\")\ncon.execute(\"DROP TABLE start_tokens\")\ncon.execute(\"DROP TABLE event_tokens\")\ncon.execute(\"DROP TABLE end_tokens\")", "con.execute(\"DROP TABLE event_tokens\")\ncon.execute(\"DROP TABLE end_tokens\")\n\ncehr_bert_input = union_tokens.group_by(\"observation_period_id\").aggregate(\n    [(\"concept_id\", \"list\"), (\"visit_segments\", \"list\"), (\"dates\", \"list\"), (\"ages\", \"list\"),\n     (\"visit_concept_orders\", \"list\"), (\"visit_concept_ids\", \"list\"), (\"orders\", \"list\"), (\"concept_id\", \"count\"),\n     (\"visit_concept_orders\", \"max\")]).rename_columns([\"observation_period_id\", \"concept_id\", \"visit_segments\", \"dates\",\n                                                       \"ages\", \"visit_concept_orders\", \"visit_concept_ids\", \"orders\",\n                                                       \"num_of_concepts\", \"num_of_visits\"])\n", "                                                       \"num_of_concepts\", \"num_of_visits\"])\n"]}
{"filename": "extras/analyze_cehr_bert_sequence_format.py", "chunked_list": ["# Some code to analyze the sequence format used by cehr-bert\n\nimport pandas as pd\nimport pyarrow.parquet as pq\nimport os\n\n# folder = \"D:/omopSynthea/cehr-bert/patient_sequence\"\n# file = pq.read_table(os.path.join(folder, \"part-00000-c0fda67a-757c-41ba-8c31-a69d1f7bf530-c000.snappy.parquet\"))\nfolder = \"D:/GPM_CCAE/patient_sequence\"\nfile = \"part0001.parquet\"", "folder = \"D:/GPM_CCAE/patient_sequence\"\nfile = \"part0001.parquet\"\nfolder = \"D:/GPM_MDCD/cehr-bert/hospitalization\"\nfile = \"part-00000-41b43fb8-f5c0-4d94-8455-830e730bc13d-c000.snappy.parquet\"\nfolder = \"D:/GPM_MDCD/cehr-bert/hopitalization_outcome\"\nfile = \"part-00000-eac1df12-7972-46d8-8b3f-e98f7bab9090-c000.snappy.parquet\"\nfolder = \"D:/GPM_MDCD/cehr-bert/hospitalization_target\"\nfile = \"part-00000-b6bd2591-3b0b-4582-a1ed-b00bb9d49963-c000.snappy.parquet\"\n\npfile = pq.read_table(os.path.join(folder, file))", "\npfile = pq.read_table(os.path.join(folder, file))\n\nx = pfile.to_pandas()\nprint(x.dtypes)\nfor column in x.columns:\n  print(f\"column: {column}\")\n  print(x[column].iat[0])\n  # print(x[column].iat[0].dtype)\n", "  # print(x[column].iat[0].dtype)\n\nlen(x)\n\n\nfull = pd.read_parquet(folder)\ncids = full[\"concept_ids\"]\ncids = full[\"visit_concept_ids\"]\ncids = full[\"dates\"]\nx = [j for i in cids for j in i]", "cids = full[\"dates\"]\nx = [j for i in cids for j in i]\nx = set(x)\nx = list(x)\nx.sort()\nx[:25]\nx[-25:-1]\n\nfor i in range(len(full)):\n  cidLen = full[\"num_of_concepts\"].iat[i]\n  if len(full[\"concept_ids\"].iat[i]) != cidLen:\n    print(f\"Issue with concept_ids for {i}\")\n  if len(full[\"visit_segments\"].iat[i]) != cidLen:\n    print(f\"Issue with visit_segments for {i}\")\n  if len(full[\"orders\"].iat[i]) != cidLen:\n    print(f\"Issue with orders for {i}\")\n  if len(full[\"dates\"].iat[i]) != cidLen:\n    print(f\"Issue with dates for {i}\")\n  if len(full[\"ages\"].iat[i]) != cidLen:\n    print(f\"Issue with ages for {i}\")\n  if len(full[\"visit_concept_orders\"].iat[i]) != cidLen:\n    print(f\"Issue visit_concept_orders ages for {i}\")\n\n  max([max(x) for x in full[\"visit_concept_orders\"]])\n  min([len(x) for x in full[\"visit_concept_orders\"]])", "for i in range(len(full)):\n  cidLen = full[\"num_of_concepts\"].iat[i]\n  if len(full[\"concept_ids\"].iat[i]) != cidLen:\n    print(f\"Issue with concept_ids for {i}\")\n  if len(full[\"visit_segments\"].iat[i]) != cidLen:\n    print(f\"Issue with visit_segments for {i}\")\n  if len(full[\"orders\"].iat[i]) != cidLen:\n    print(f\"Issue with orders for {i}\")\n  if len(full[\"dates\"].iat[i]) != cidLen:\n    print(f\"Issue with dates for {i}\")\n  if len(full[\"ages\"].iat[i]) != cidLen:\n    print(f\"Issue with ages for {i}\")\n  if len(full[\"visit_concept_orders\"].iat[i]) != cidLen:\n    print(f\"Issue visit_concept_orders ages for {i}\")\n\n  max([max(x) for x in full[\"visit_concept_orders\"]])\n  min([len(x) for x in full[\"visit_concept_orders\"]])", "\n\ntotal_visits = 0\nshady_visits = 0\nfor i in range(len(full)):\n  dates = full[\"dates\"].iat[i]\n  days = (max(dates) - min(dates)) * 7\n  vcos = full[\"visit_concept_orders\"].iat[i]\n  visits = max(vcos)\n  total_visits += visits\n  if visits > days / 2:\n    shady_visits += visits", "\nprint(f\"Total visits: {total_visits}\")\nprint(f\"Shady visits: {shady_visits}\")\nprint(f\"Shady visits: {shady_visits / total_visits}\")\n\n\n\n"]}
{"filename": "extras/problems_with_pandas.py", "chunked_list": ["# For my own sanity, a documentation of issues I've had with pandas:\nimport pandas as pd\n\n# Storing and retrieving integers --------------------------------------------------------------------------------------\n# By default, pandas stores integers as int64, which can't store nulls. This leads to silent conversion to float64:\ndf = pd.DataFrame({\"int\": [1, 2]})\ndf[\"int\"].dtype\n# dtype('int64')\ndf.iloc[0, 0] = None\ndf[\"int\"].dtype", "df.iloc[0, 0] = None\ndf[\"int\"].dtype\n# dtype('float64')\n\n# To avoid this, we can use the nullable integer type:\ndf = pd.DataFrame({\"int\": pd.array([1, 2], dtype=pd.Int64Dtype())})\ndf[\"int\"].dtype\n# Int64Dtype()\ndf.iloc[0, 0] = None\ndf[\"int\"].dtype", "df.iloc[0, 0] = None\ndf[\"int\"].dtype\n# Int64Dtype()\n\n# Slicing and indexing -------------------------------------------------------------------------------------------------\n# When slicing a DataFrame, the index is preserved, even when creating a copy:\ndf = pd.DataFrame({\"int\": [1, 2, 3, 4, 5]})\npart_df = df[df.int > 3].copy()\npart_df.int[0]\n# Key error", "part_df.int[0]\n# Key error\n\n# Instead, we need to reset the index:\npart_df = df[df.int > 3].copy().reset_index(drop=True)\npart_df.int[0]\n# 4\n"]}
{"filename": "simulating/simulator.py", "chunked_list": ["\"\"\"\nSimulate CDM data for testing purposes. Persons are simulated to have hidden disease states. Some states are fixed at\nthe start, to simulate fixed traits such as genetics, while the remaining states are dynamic. The probability to enter\na dynamic disease state depending on the current disease states in a non-linear way (i.e. using interactions between\nstates). Concepts are simulated to be observed with probabilities depending on the current disease states, again in a\nnon-linear way. Concepts imply visits, and visits in return increase the probability of observing concepts, thus causing\nconcepts to cluster in time. The simulated data is saved in the CDM format.\n\nTo generate patient-level predicition problems with a gold standard, the model is executed. For each person, an index\ndate is randomly selected, and Monte-Carlo simulations are performed to simulate the future.", "To generate patient-level predicition problems with a gold standard, the model is executed. For each person, an index\ndate is randomly selected, and Monte-Carlo simulations are performed to simulate the future.\n\"\"\"\nimport cProfile\nimport configparser\nimport json\nimport logging\nimport multiprocessing\nimport os\nimport sys", "import os\nimport sys\nfrom typing import List\nfrom dataclasses import dataclass\n\nimport numpy as np\nimport tqdm as tqdm\n\nimport cdm_data\nimport utils.logger as logger", "import cdm_data\nimport utils.logger as logger\n\nLOGGER_FILE_NAME = \"_simulation_log.txt\"\nQUIET = 0\nCHATTY = 1\nOBSESSIVE = 2\nJSON_FILE_NAME = \"_simulation.json\"\nPRETRAINING_FOLDER = \"pretraining\"\nTRAIN_FOLDER = \"train\"", "PRETRAINING_FOLDER = \"pretraining\"\nTRAIN_FOLDER = \"train\"\nTEST_FOLDER = \"test\"\nSTATE_TRANSITION_INTERCEPT = -6  # Log probability intercept of transitioning to a new state.\nCONCEPT_OBSERVATION_INTERCEPT = -8  # Log probability intercept of observing a concept.\nAGE_INDEX = -2\nGENDER_INDEX = -1\n\n\ndef logistic(x):\n    return 1 / (1 + np.exp(-x))", "\ndef logistic(x):\n    return 1 / (1 + np.exp(-x))\n\n\n@dataclass\nclass SimulationSettings:\n    dynamic_state_count: int = 10\n    fixed_state_count: int = 5\n    concept_count: int = 100\n    serious_concept_count: int = 10\n    visit_multiplier: int = 2\n    days_to_simulate: int = 365 * 2", "\n\n@dataclass\nclass SimulationTask:\n    partition_count: int\n\n\n@dataclass\nclass PreTrainingTask(SimulationTask):\n    person_count: int", "class PreTrainingTask(SimulationTask):\n    person_count: int\n\n\n@dataclass\nclass PredictionTask(SimulationTask):\n    train_person_count: int\n    test_person_count: int\n    prediction_window: int\n", "\n\ndef _simulate_date_of_birth(current_date: np.datetime64, age_indicator: int) -> tuple[int, int, int]:\n    \"\"\"\n    Simulate a date of birth for a person.\n\n    Args:\n        current_date: The current date.\n        age_indicator: An indicator of the age of the person.\n    Returns:\n        A tuple of the year, month and day of birth.\n    \"\"\"\n    if age_indicator == 0:\n        # Simulate a date of birth for a child:\n        birth_date = current_date - np.random.randint(0, 365 * 18)\n    else:\n        # Simulate a date of birth for an adult:\n        birth_date = current_date - np.random.randint(365 * 18, 365 * 100)\n    birth_date = np.datetime64(birth_date, 'D')\n    return birth_date.astype('datetime64[Y]').astype(int) + 1970, \\\n           birth_date.astype('datetime64[M]').astype(int) % 12 + 1, \\\n           birth_date.astype('datetime64[D]').astype(int) % 31 + 1", "\n\nclass Simulator:\n    # Note: Tried using scipy.sparse.csr_matrix, but it was 100 times slower than using a dense matrix.\n\n    def __init__(self,\n                 root_folder: str,\n                 settings: SimulationSettings = None,\n                 json_file_name: str = None,\n                 log_verbosity: int = QUIET,\n                 max_cores: int = 1):\n        self._root_folder = root_folder\n        if not os.path.exists(root_folder):\n            os.makedirs(root_folder)\n        self._profile = False\n        self._log_verbosity = log_verbosity\n        self._max_cores = max_cores\n        self._task = SimulationTask(0)\n        self._configure_logger()\n        if settings is None:\n            self._init_from_json(json_file_name)\n        else:\n            self._init_from_settings(settings)\n            self.save_to_json(os.path.join(self._root_folder, JSON_FILE_NAME))\n\n    def _init_from_json(self, json_file_name: str):\n        logging.info(\"Loading simulation configuration from %s\", json_file_name)\n        with open(json_file_name, \"r\") as f:\n            loaded = json.load(f)\n        self._settings = SimulationSettings(**loaded[\"simulation_settings\"])\n        self._state_count = loaded[\"state_count\"]\n        self._concept_ids = np.array(loaded[\"concept_ids\"])\n        self._serious_concept_idx = np.array(loaded[\"serious_concept_idx\"])\n        self._initial_state_probabilities = np.array(loaded[\"initial_state_probabilities\"])\n        self._dynamic_state_entry_coefs = [np.array(matrix) for matrix in loaded[\"dynamic_state_entry_coefs\"]]\n        self._dynamic_state_exit_probabilities = np.array(loaded[\"dynamic_state_exit_probabilities\"])\n        self._concept_emmision_coefs = [np.array(matrix) for matrix in loaded[\"concept_emmision_coefs\"]]\n\n    def _init_from_settings(self, settings: SimulationSettings):\n        self._settings = settings\n        self._state_count = settings.dynamic_state_count + settings.fixed_state_count + 2  # + 2 for age and sex\n        self._concept_ids = np.arange(settings.concept_count) + 1000000\n\n        # Initialize probabilities and coefficients:\n        self._initial_state_probabilities = np.concatenate((\n            np.random.beta(size=settings.dynamic_state_count, a=1, b=4) / settings.dynamic_state_count,\n            np.random.uniform(size=settings.fixed_state_count + 2)\n        ))\n        # Note: really only need half of these matrices to be filled, because interaction matrix will be symmetrical\n        # over diagonal, but it's easier to just fill them completely:\n        self._dynamic_state_entry_coefs = []\n        for i in range(settings.dynamic_state_count):\n            matrix = np.zeros(self._state_count * self._state_count)\n            non_zero_count = round(len(matrix) / self._state_count)\n            matrix[np.random.choice(len(matrix), size=non_zero_count, replace=False)] = \\\n                np.random.laplace(loc=0, scale=0.1, size=non_zero_count)\n            self._dynamic_state_entry_coefs.append(matrix.reshape(self._state_count, self._state_count))\n        self._dynamic_state_exit_probabilities = \\\n            np.random.beta(size=settings.dynamic_state_count, a=0.2, b=3) / settings.dynamic_state_count\n        self._concept_emmision_coefs = []\n        for i in range(settings.concept_count):\n            matrix = np.zeros(self._state_count * self._state_count)\n            non_zero_count = round(len(matrix) / np.sqrt(self._settings.concept_count))\n            matrix[np.random.choice(len(matrix), size=non_zero_count, replace=False)] = \\\n                np.random.laplace(loc=0, scale=0.5, size=non_zero_count)\n            self._concept_emmision_coefs.append(matrix.reshape(self._state_count, self._state_count))\n        self._serious_concept_idx = np.zeros(settings.concept_count, dtype=bool)\n        self._serious_concept_idx[np.random.choice(settings.concept_count,\n                                                   size=settings.serious_concept_count,\n                                                   replace=False)] = True\n\n    def set_profile(self, profile: bool):\n        self._profile = profile\n\n    def get_profile(self):\n        return self._profile\n\n    def _configure_logger(self):\n        logger.create_logger(os.path.join(self._root_folder, LOGGER_FILE_NAME))\n\n    def _simulate_person(self, person_id: int):\n        if isinstance(self._task, PredictionTask):\n            prediction_labels = np.zeros(self._settings.concept_count, dtype=bool)\n            # Currently just using full prediction window, but could change to make index day random:\n            index_day = self._settings.days_to_simulate - self._task.prediction_window\n            is_prediction = True\n        else:\n            prediction_labels = None\n            index_day = 0\n            is_prediction = False\n        start_date = np.datetime64(\"2010-01-01\") + np.random.randint(0, 365 * 10)\n        state = np.random.binomial(n=1, p=self._initial_state_probabilities)\n        self._cdm_data.add_observation_period(person_id=person_id,\n                                              observation_period_id=person_id,\n                                              observation_period_start_date=start_date,\n                                              observation_period_end_date=start_date + self._settings.days_to_simulate)\n        year_of_birth, month_of_birth, day_of_birth = _simulate_date_of_birth(start_date, state[AGE_INDEX])\n        gender_concept_id = 8507 if state[GENDER_INDEX] == 0 else 8532\n        self._cdm_data.add_person(person_id=person_id,\n                                  year_of_birth=year_of_birth,\n                                  month_of_birth=month_of_birth,\n                                  day_of_birth=day_of_birth,\n                                  gender_concept_id=gender_concept_id)\n        visit_occurrence_id = person_id * 100000\n        for t in range(self._settings.days_to_simulate):\n            if self._log_verbosity == OBSESSIVE:\n                logging.debug(\"Person: %s, Day: %s, State: %s\", person_id, t, state)\n            state_interaction_matrix = np.outer(state, state)\n            # Roll dice to change state:\n            flip_to_one = logistic(\n                np.sum(np.asarray(self._dynamic_state_entry_coefs) * state_interaction_matrix[np.newaxis, :, :],\n                       axis=(1, 2)) - 6) * (state[:self._settings.dynamic_state_count] == 0)\n            flip_to_zero = (self._dynamic_state_exit_probabilities * (state[:self._settings.dynamic_state_count] == 1))\n            state_flip_probabilities = flip_to_one + flip_to_zero\n            state[:self._settings.dynamic_state_count] = np.logical_xor(state[:self._settings.dynamic_state_count],\n                                                                        np.random.binomial(n=1,\n                                                                                           p=state_flip_probabilities))\n            # Roll dice to observe a concept:\n            concept_probabilities = logistic(CONCEPT_OBSERVATION_INTERCEPT + np.sum(\n                np.asarray(self._concept_emmision_coefs) * state_interaction_matrix[np.newaxis, :, :], axis=(1, 2)))\n            admission_concept_idx = (np.random.binomial(n=1, p=concept_probabilities) != 0)\n            visit = admission_concept_idx.any()\n            if visit:\n                # Roll dice again to observe a concept (to simulate the fact that some concepts are more likely to be\n                # observed during a visit):\n                observed_concept_idx = admission_concept_idx | (np.random.binomial(n=self._settings.visit_multiplier,\n                                                                                   p=concept_probabilities) != 0)\n                if is_prediction and t > index_day:\n                    prediction_labels = prediction_labels | observed_concept_idx\n                else:\n                    concept_ids = self._concept_ids[observed_concept_idx]\n                    for concept_id in concept_ids:\n                        self._cdm_data.add_condition_occurrence(person_id=person_id,\n                                                                condition_start_date=start_date + t,\n                                                                condition_concept_id=concept_id,\n                                                                visit_occurrence_id=visit_occurrence_id)\n                    # If admission concept is serious, make the visit an emergency room visit, otherwise make it an\n                    # outpatient visit:\n                    if (admission_concept_idx & self._serious_concept_idx).any():\n                        visit_concept_id = 9203  # Emergency room visit\n                    else:\n                        visit_concept_id = 9201  # Outpatient visit\n                    self._cdm_data.add_visit_occurrence(person_id=person_id,\n                                                        visit_start_date=start_date + t,\n                                                        visit_end_date=start_date + t,\n                                                        visit_concept_id=visit_concept_id,\n                                                        visit_occurrence_id=visit_occurrence_id)\n                    visit_occurrence_id += 1\n                    if self._log_verbosity == OBSESSIVE:\n                        logging.debug(\"Person %s visit on day %s with concept IDs: %s\", person_id, t, concept_ids)\n        if isinstance(self._cdm_data, cdm_data.CdmDataWithLabels):\n            for i in range(self._settings.concept_count):\n                self._cdm_data.add_label(person_id=person_id,\n                                         concept_id=self._concept_ids[i],\n                                         label=prediction_labels[i])\n\n    def simulate(self, task: SimulationTask):\n        \"\"\"\n        Process the CDM data in the provided cdm_data_path.\n        \"\"\"\n        self._task = task\n        if isinstance(task, PreTrainingTask):\n            logging.info(\"Simulating data for pre-training task\")\n            output_folder = os.path.join(self._root_folder, PRETRAINING_FOLDER)\n            if not os.path.exists(output_folder):\n                os.makedirs(output_folder)\n        elif isinstance(task, PredictionTask):\n            logging.info(\"Simulating data for prediction task\")\n            train_folder = os.path.join(self._root_folder, TRAIN_FOLDER)\n            if not os.path.exists(train_folder):\n                os.makedirs(train_folder)\n            test_folder = os.path.join(self._root_folder, TEST_FOLDER)\n            if not os.path.exists(test_folder):\n                os.makedirs(test_folder)\n        else:\n            raise ValueError(\"Unknown task type: %s\" % type(task))\n        if self._profile:\n            cProfile.runctx(statement=\"self._simulate()\",\n                            locals={\"self\": self},\n                            globals={},\n                            filename=\"../stats\")\n        else:\n            self._simulate()\n\n    def _simulate(self):\n        if self._profile:\n            logging.info(\"Profiling mode enabled, running first partition in single thread\")\n            self._simulate_partition(0)\n        elif self._max_cores == 1:\n            # Run single thread in main thread for easier debugging:\n            for partition_i in range(self._task.partition_count):\n                self._simulate_partition(partition_i)\n        else:\n            pool = multiprocessing.get_context(\"spawn\").Pool(processes=self._max_cores)\n            tasks = range(self._task.partition_count)\n            work = self._simulate_partition\n            for _ in tqdm.tqdm(pool.imap_unordered(work, tasks), total=len(tasks)):\n                pass\n            pool.close()\n        logging.info(\"Finished simulation\")\n\n    def _simulate_partition(self, partition_i: int):\n        # This function is executed within a thread\n        # Need to re-configure logger because we're in a thread:\n        self._configure_logger()\n        logging.debug(\"Starting partition %s of %s\", partition_i, self._task.partition_count)\n        if isinstance(self._task, PreTrainingTask):\n            self._simulate_person_set(partition_i=partition_i,\n                                      persons_per_partition=self._task.person_count // self._task.partition_count,\n                                      output_folder=os.path.join(self._root_folder, PRETRAINING_FOLDER))\n        elif isinstance(self._task, PredictionTask):\n            self._simulate_person_set(partition_i=partition_i,\n                                      persons_per_partition=self._task.train_person_count // self._task.partition_count,\n                                      output_folder=os.path.join(self._root_folder, TRAIN_FOLDER))\n            self._simulate_person_set(partition_i=partition_i,\n                                      persons_per_partition=self._task.test_person_count // self._task.partition_count,\n                                      output_folder=os.path.join(self._root_folder, TEST_FOLDER))\n        else:\n            raise ValueError(\"Unknown task type: %s\" % type(self._task))\n        logging.debug(\"Finished partition %s of %s\", partition_i, self._task.partition_count)\n\n    def _simulate_person_set(self,\n                             partition_i: int,\n                             persons_per_partition: int,\n                             output_folder: str):\n        if isinstance(self._task, PredictionTask):\n            self._cdm_data = cdm_data.CdmDataWithLabels()\n        else:\n            self._cdm_data = cdm_data.CdmData()\n        for i in range(persons_per_partition * partition_i, persons_per_partition * (partition_i + 1)):\n            self._simulate_person(person_id=i)\n        self._cdm_data.log_statistics(partition_i=partition_i)\n        self._cdm_data.write_to_parquet(output_folder, partition_i)\n\n    def save_to_json(self, file_name: str):\n        with open(file_name, \"w\") as f:\n            to_save = {\n                \"simulation_settings\": self._settings.__dict__,\n                \"state_count\": self._state_count,\n                \"concept_ids\": self._concept_ids.tolist(),\n                \"serious_concept_idx\": self._serious_concept_idx.tolist(),\n                \"initial_state_probabilities\": self._initial_state_probabilities.tolist(),\n                \"dynamic_state_exit_probabilities\": self._dynamic_state_exit_probabilities.tolist(),\n                \"dynamic_state_entry_coefs\": [matrix.tolist() for matrix in self._dynamic_state_entry_coefs],\n                \"concept_emmision_coefs\": [matrix.tolist() for matrix in self._concept_emmision_coefs]\n            }\n            json.dump(to_save, f)", "\n\ndef main(args: List[str]):\n    config = configparser.ConfigParser()\n    with open(args[0]) as file:  # Explicitly opening file so error is thrown when not found\n        config.read_file(file)\n    if config[\"simulation\"].get(\"json_file_name\") == \"\":\n        settings = SimulationSettings(\n            dynamic_state_count=config[\"simulation\"].getint(\"dynamic_state_count\"),\n            fixed_state_count=config[\"simulation\"].getint(\"fixed_state_count\"),\n            concept_count=config[\"simulation\"].getint(\"concept_count\"),\n            serious_concept_count=config[\"simulation\"].getint(\"serious_concept_count\"),\n            visit_multiplier=config[\"simulation\"].getint(\"visit_multiplier\"),\n            days_to_simulate=config[\"simulation\"].getint(\"days_to_simulate\"))\n        json_file_name = None\n    else:\n        settings = None\n        json_file_name = config[\"simulation\"].get(\"json_file_name\")\n        config.remove_section(\"simulation\")\n    simulator = Simulator(root_folder=config[\"system\"].get(\"root_folder\"),\n                          settings=settings,\n                          json_file_name=json_file_name,\n                          log_verbosity=config[\"debug\"].getint(\"log_verbosity\"),\n                          max_cores=config[\"system\"].getint(\"max_cores\"))\n    # Log config after initializing cdm_data_processor so logger is initialized:\n    logger.log_config(config)\n    if config[\"debug\"].getboolean(\"profile\"):\n        simulator.set_profile(True)\n    if config[\"pre-training data generation\"].getboolean(\"generate_pre_training_data\"):\n        task = PreTrainingTask(partition_count=config[\"pre-training data generation\"].getint(\"partition_count\"),\n                               person_count=config[\"pre-training data generation\"].getint(\"person_count\"))\n        simulator.simulate(task)\n    if config[\"prediction data generation\"].getboolean(\"generate_prediction_data\"):\n        task = PredictionTask(partition_count=config[\"prediction data generation\"].getint(\"partition_count\"),\n                              train_person_count=config[\"prediction data generation\"].getint(\"train_person_count\"),\n                              test_person_count=config[\"prediction data generation\"].getint(\"test_person_count\"),\n                              prediction_window=config[\"prediction data generation\"].getint(\"prediction_window\"))\n        simulator.simulate(task)", "\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        raise Exception(\"Must provide path to ini file as argument\")\n    else:\n        main(sys.argv[1:])\n"]}
{"filename": "simulating/__init__.py", "chunked_list": [""]}
{"filename": "simulating/cdm_data.py", "chunked_list": ["\"\"\"\nThis module contains the CdmData class, which is used to store the data that is generated by the simulation. The\ndata is stored in dynamic arrays, which are then concatenated into a single numpy array when the simulation is\ncomplete. The data is then written to parquet files.\n\"\"\"\nimport os\nfrom collections import defaultdict\nfrom typing import Type\nimport logging\n", "import logging\n\nimport numpy as np\nimport pyarrow as pa\nimport pyarrow.parquet as pq\n\n\nclass DynamicArray:\n    \"\"\"\n    A dynamic array that can be appended to one at a time. The array is split into blocks of a fixed size, and the\n    blocks are concatenated when the array is collected.\n    \"\"\"\n\n    BLOCK_SIZE = 1000\n\n    def __init__(self, dtype: Type = np.float64):\n        self._dtype = dtype\n        self._blocks = []\n        self._current_block = self._create_block()\n        self._cursor = -1\n\n    def _create_block(self):\n        if self._dtype == np.datetime64:\n            return np.full(shape=self.BLOCK_SIZE, fill_value=np.datetime64(\"2010-01-01\"))\n        else:\n            return np.zeros(self.BLOCK_SIZE, dtype=self._dtype)\n\n    def append(self, value):\n        self._cursor += 1\n        if self._cursor >= self.BLOCK_SIZE:\n            self._blocks.append(self._current_block)\n            self._current_block = self._create_block()\n            self._cursor = 0\n        self._current_block[self._cursor] = value\n\n    def __len__(self):\n        return len(self._blocks) * self.BLOCK_SIZE + self._cursor + 1\n\n    def collect(self) -> np.ndarray:\n        return np.concatenate(self._blocks + [self._current_block[:self._cursor + 1]])", "\n\ndef _create_folder_if_not_exists(folder: str):\n    if not os.path.exists(folder):\n        os.makedirs(folder, exist_ok=True)\n\n\nclass CdmData:\n    \"\"\"\n    The data that is generated by the simulation.\n    \"\"\"\n\n    def __init__(self):\n        self._person_person_id = DynamicArray(np.int64)\n        self._person_year_of_birth = DynamicArray(np.int32)\n        self._person_month_of_birth = DynamicArray(np.int32)\n        self._person_day_of_birth = DynamicArray(np.int32)\n        self._person_gender_concept_id = DynamicArray(np.int32)\n        self._visit_occurrence_person_id = DynamicArray(np.int64)\n        self._visit_occurrence_visit_occurrence_id = DynamicArray(np.int64)\n        self._visit_occurrence_visit_start_date = DynamicArray(np.datetime64)\n        self._visit_occurrence_visit_end_date = DynamicArray(np.datetime64)\n        self._visit_occurrence_visit_concept_id = DynamicArray(np.int32)\n        self._condition_occurrence_person_id = DynamicArray(np.int64)\n        self._condition_occurrence_visit_occurrence_id = DynamicArray(np.int64)\n        self._condition_occurrence_condition_start_date = DynamicArray(np.datetime64)\n        self._condition_occurrence_condition_concept_id = DynamicArray(np.int32)\n        self._observation_period_person_id = DynamicArray(np.int64)\n        self._observation_period_observation_period_id = DynamicArray(np.int64)\n        self._observation_period_observation_period_start_date = DynamicArray(np.datetime64)\n        self._observation_period_observation_period_end_date = DynamicArray(np.datetime64)\n\n    def add_person(self, person_id: int, year_of_birth: int, month_of_birth: int, day_of_birth: int,\n                   gender_concept_id: int):\n        self._person_person_id.append(person_id)\n        self._person_year_of_birth.append(year_of_birth)\n        self._person_month_of_birth.append(month_of_birth)\n        self._person_day_of_birth.append(day_of_birth)\n        self._person_gender_concept_id.append(gender_concept_id)\n\n    def add_visit_occurrence(self, person_id: int, visit_occurrence_id: int, visit_start_date: np.datetime64,\n                             visit_end_date: np.datetime64, visit_concept_id: int):\n        self._visit_occurrence_person_id.append(person_id)\n        self._visit_occurrence_visit_occurrence_id.append(visit_occurrence_id)\n        self._visit_occurrence_visit_start_date.append(visit_start_date)\n        self._visit_occurrence_visit_end_date.append(visit_end_date)\n        self._visit_occurrence_visit_concept_id.append(visit_concept_id)\n\n    def add_condition_occurrence(self, person_id: int, visit_occurrence_id: int, condition_start_date: np.datetime64,\n                                 condition_concept_id: int):\n        self._condition_occurrence_person_id.append(person_id)\n        self._condition_occurrence_visit_occurrence_id.append(visit_occurrence_id)\n        self._condition_occurrence_condition_start_date.append(condition_start_date)\n        self._condition_occurrence_condition_concept_id.append(condition_concept_id)\n\n    def add_observation_period(self, person_id: int, observation_period_id: int,\n                               observation_period_start_date: np.datetime64,\n                               observation_period_end_date: np.datetime64):\n        self._observation_period_person_id.append(person_id)\n        self._observation_period_observation_period_id.append(observation_period_id)\n        self._observation_period_observation_period_start_date.append(observation_period_start_date)\n        self._observation_period_observation_period_end_date.append(observation_period_end_date)\n\n    def write_to_parquet(self, root_folder: str, partition_i: int):\n        person = pa.Table.from_arrays(arrays=[\n            self._person_person_id.collect(),\n            self._person_year_of_birth.collect(),\n            self._person_month_of_birth.collect(),\n            self._person_day_of_birth.collect(),\n            self._person_gender_concept_id.collect()],\n            names=[\"person_id\", \"year_of_birth\", \"month_of_birth\", \"day_of_birth\", \"gender_concept_id\"])\n        visit_occurrence = pa.Table.from_arrays(arrays=[\n            self._visit_occurrence_person_id.collect(),\n            self._visit_occurrence_visit_occurrence_id.collect(),\n            self._visit_occurrence_visit_start_date.collect(),\n            self._visit_occurrence_visit_end_date.collect(),\n            self._visit_occurrence_visit_concept_id.collect()],\n            names=[\"person_id\", \"visit_occurrence_id\", \"visit_start_date\", \"visit_end_date\", \"visit_concept_id\"])\n        condition_occurrence = pa.Table.from_arrays(arrays=[\n            self._condition_occurrence_person_id.collect(),\n            self._condition_occurrence_visit_occurrence_id.collect(),\n            self._condition_occurrence_condition_start_date.collect(),\n            self._condition_occurrence_condition_concept_id.collect()],\n            names=[\"person_id\", \"visit_occurrence_id\", \"condition_start_date\", \"condition_concept_id\"])\n        observation_period = pa.Table.from_arrays(arrays=[\n            self._observation_period_person_id.collect(),\n            self._observation_period_observation_period_id.collect(),\n            self._observation_period_observation_period_start_date.collect(),\n            self._observation_period_observation_period_end_date.collect()],\n            names=[\"person_id\", \"observation_period_id\", \"observation_period_start_date\",\n                   \"observation_period_end_date\"])\n        file_name = \"part{:04d}.parquet\".format(partition_i + 1)\n        _create_folder_if_not_exists(os.path.join(root_folder, \"person\"))\n        pq.write_table(person, os.path.join(root_folder, \"person\", file_name))\n        _create_folder_if_not_exists(os.path.join(root_folder, \"visit_occurrence\"))\n        pq.write_table(visit_occurrence, os.path.join(root_folder, \"visit_occurrence\", file_name))\n        _create_folder_if_not_exists(os.path.join(root_folder, \"condition_occurrence\"))\n        pq.write_table(condition_occurrence, os.path.join(root_folder, \"condition_occurrence\", file_name))\n        _create_folder_if_not_exists(os.path.join(root_folder, \"observation_period\"))\n        pq.write_table(observation_period, os.path.join(root_folder, \"observation_period\", file_name))\n\n    def log_statistics(self, partition_i: int):\n        logging.debug(\"Partition %s persons: %s\", partition_i, len(self._person_person_id))\n        logging.debug(\"Partition %s visit_occurrences: %s\", partition_i, len(self._visit_occurrence_person_id))\n        total_days = np.sum(np.subtract(self._observation_period_observation_period_end_date.collect(),\n                                        self._observation_period_observation_period_start_date.collect()).view(\n            np.int64))\n        logging.debug(\"Partition %s mean days between visits: %.1f\", partition_i,\n                      total_days / len(self._visit_occurrence_person_id))\n        logging.debug(\"Partition %s mean concepts per visit: %.1f\", partition_i,\n                      len(self._condition_occurrence_person_id) / len(self._visit_occurrence_person_id))\n        logging.debug(\"Partition %s unique concept count: %s\", partition_i,\n                      len(np.unique(self._condition_occurrence_condition_concept_id.collect())))\n        logging.debug(\"Partition %s percent ER visits: %.1f%%\", partition_i,\n                      100 * sum(self._visit_occurrence_visit_concept_id.collect() == 9203) /\n                      len(self._visit_occurrence_person_id))", "\n\nclass _Labels:\n\n    person_id: DynamicArray\n    label: DynamicArray\n\n    def __init__(self):\n        super().__init__()\n        self.person_id = DynamicArray(np.int64)\n        self.label = DynamicArray(bool)", "\n\nclass CdmDataWithLabels(CdmData):\n\n    def __init__(self):\n        super().__init__()\n        self._concept_id_to_labels: defaultdict[int, _Labels] = defaultdict(_Labels)\n\n    def add_label(self, person_id: int, concept_id: int, label: bool):\n        labels = self._concept_id_to_labels[concept_id]\n        labels.person_id.append(person_id)\n        labels.label.append(label)\n\n    def write_to_parquet(self, root_folder: str, partition_i: int):\n        super().write_to_parquet(root_folder, partition_i)\n        for concept_id, labels in self._concept_id_to_labels.items():\n            table = pa.Table.from_arrays(arrays=[\n                labels.person_id.collect(),\n                labels.label.collect()],\n                names=[\"person_id\", \"label\"])\n            folder_name = \"label_c{:04d}\".format(concept_id)\n            _create_folder_if_not_exists(os.path.join(root_folder, folder_name))\n            file_name = \"part{:04d}.parquet\".format(partition_i + 1)\n            pq.write_table(table, os.path.join(root_folder, folder_name, file_name))\n\n    def log_statistics(self, partition_i: int):\n        super().log_statistics(partition_i)\n        means = DynamicArray(np.float64)\n        for labels in self._concept_id_to_labels.values():\n            means.append(np.mean(labels.label.collect()))\n        logging.debug(\"Partition %s percent labels positive: %.1f%%\", partition_i, 100 * np.mean(means.collect()))", ""]}
{"filename": "cdm_processing/cdm_processor_utils.py", "chunked_list": ["import os\nfrom typing import List, Dict\n\nimport pyarrow.parquet as pq\nimport pyarrow.compute as pc\nimport pyarrow as pa\nimport duckdb\n\nPERSON = \"person\"\n", "PERSON = \"person\"\n\nPERSON_ID = \"person_id\"\nLOGGER_FILE_NAME = \"_cdm_processing_log.txt\"  # Start with underscore so ignored by Parquet\nPROFILE_MAX_PERSONS = 1000\nSTART_DATE_FIELDS = {\n    \"observation_period\": \"observation_period_start_date\",\n    \"visit_occurrence\": \"visit_start_date\",\n    \"condition_occurrence\": \"condition_start_date\",\n    \"drug_exposure\": \"drug_exposure_start_date\",", "    \"condition_occurrence\": \"condition_start_date\",\n    \"drug_exposure\": \"drug_exposure_start_date\",\n    \"procedure_occurrence\": \"procedure_date\",\n    \"device_exposure\": \"device_exposure_start_date\",\n    \"measurement\": \"measurement_date\",\n    \"observation\": \"observation_date\",\n    \"death\": \"death_date\",\n}\nCONCEPT_ID_FIELDS = {\n    \"visit_occurrence\": \"visit_concept_id\",", "CONCEPT_ID_FIELDS = {\n    \"visit_occurrence\": \"visit_concept_id\",\n    \"condition_occurrence\": \"condition_concept_id\",\n    \"drug_exposure\": \"drug_concept_id\",\n    \"procedure_occurrence\": \"procedure_concept_id\",\n    \"device_exposure\": \"device_concept_id\",\n    \"measurement\": \"measurement_concept_id\",\n    \"observation\": \"observation_concept_id\",\n    \"death\": \"death_concept_id\",\n}", "    \"death\": \"death_concept_id\",\n}\nSTART_DATE = \"start_date\"\nCONCEPT_ID = \"concept_id\"\nDOMAIN_TABLES = [\n    \"condition_occurrence\",\n    \"drug_exposure\",\n    \"procedure_occurrence\",\n    \"device_exposure\",\n    \"measurement\",", "    \"device_exposure\",\n    \"measurement\",\n    \"observation\",\n    \"death\",\n]\nDEATH = \"death\"\nDEATH_CONCEPT_ID = \"death_concept_id\"\nDEATH_CONCEPT_ID_VALUE = 4306655\nINTERNAL_VISIT_ID = \"internal_visit_id\"\nVISIT_OCCURRENCE = \"visit_occurrence\"", "INTERNAL_VISIT_ID = \"internal_visit_id\"\nVISIT_OCCURRENCE = \"visit_occurrence\"\nVISIT_OCCURRENCE_ID = \"visit_occurrence_id\"\nCONCEPT = \"concept\"\nCONCEPT_ANCESTOR = \"concept_ancestor\"\nYEAR_OF_BIRTH = \"year_of_birth\"\nMONTH_OF_BIRTH = \"month_of_birth\"\nDAY_OF_BIRTH = \"day_of_birth\"\nDATE_OF_BIRTH = \"date_of_birth\"\nSOURCE_CONCEPT_ID = \"source_concept_id\"", "DATE_OF_BIRTH = \"date_of_birth\"\nSOURCE_CONCEPT_ID = \"source_concept_id\"\nTARGET_CONCEPT_ID = \"target_concept_id\"\n\n\ndef add_date_of_birth(person: pa.Table) -> pa.Table:\n    \"\"\"\n    Compute the date of birth from a person table, and add it as a column called 'date_of_birth'.\n    \"\"\"\n    dob = pc.strptime(\n        pc.binary_join_element_wise(\n            pc.cast(person[YEAR_OF_BIRTH], pa.string()),\n            pc.cast(pc.coalesce(person[MONTH_OF_BIRTH], 1), pa.string()),\n            pc.cast(pc.coalesce(person[DAY_OF_BIRTH], 1), pa.string()),\n            \"-\"\n        ),\n        format=\"%Y-%m-%d\",\n        unit=\"s\"\n    )\n    return person.append_column(DATE_OF_BIRTH, dob)", "\n\ndef union_domain_tables(cdm_tables: Dict[str, pa.Table]) -> pa.Table:\n    \"\"\"\n    Combines all domain tables into a single table. For this, column names will be normalized first.\n    Entries in the death table will automatically be assigned a concept ID (4306655).\n\n    Args:\n        cdm_tables: A dictionary, mapping from CDM table name to table data.\n\n    Returns:\n        A table with a person_id, concept_id, visit_occurrence_id, and a start_date column.\n    \"\"\"\n    available_domain_tables = list(set(DOMAIN_TABLES) & set(cdm_tables))\n    normalized_tables = []\n    if DEATH in cdm_tables:\n        death = cdm_tables[DEATH]\n        death = death.select([PERSON_ID, START_DATE_FIELDS[DEATH]]).rename_columns(\n            [PERSON_ID, START_DATE]\n        ).append_column(\n            CONCEPT_ID,\n            pa.array([DEATH_CONCEPT_ID_VALUE] * len(death), pa.int32())\n        ).append_column(\n            VISIT_OCCURRENCE_ID,\n            pa.nulls(len(death), pa.int64())\n        )\n        available_domain_tables.remove(DEATH)\n        normalized_tables.append(death)\n    for table in available_domain_tables:\n        normalized_table = cdm_tables[table].select(\n            [PERSON_ID, START_DATE_FIELDS[table], CONCEPT_ID_FIELDS[table], VISIT_OCCURRENCE_ID]).rename_columns(\n            [PERSON_ID, START_DATE, CONCEPT_ID, VISIT_OCCURRENCE_ID]\n        )\n        normalized_tables.append(normalized_table)\n    event_table = pa.concat_tables(normalized_tables)\n    return event_table", "\n\ndef remove_concepts(event_table: pa.Table, concept_ids: List[int]) -> tuple[pa.Table, int]:\n    \"\"\"\n    Removes all rows from a table that have a concept ID in the given list.\n\n    Args:\n        event_table: A table with a person_id, concept_id and a start_date column.\n        concept_ids: A list of concept IDs to remove.\n\n    Returns:\n        A tuple with the count of removed rows, and a table with the same schema as the input table, but without the\n            rows with the given concept IDs.\n    \"\"\"\n    count_before = len(event_table)\n    result = event_table.filter(~pc.is_in(pc.field(CONCEPT_ID), pa.array(concept_ids)))\n    return result, count_before - len(result)", "\n\ndef remove_duplicates(event_table: pa.Table) -> tuple[pa.Table, int]:\n    \"\"\"\n    Removes all rows with duplicate person_id, concept_id, and start_date combinations.\n\n    Args:\n        event_table: A table with a person_id, concept_id and a start_date column.\n\n    Returns:\n        A tuple with the count of removed rows, and a table with the same schema as the input table, but without the\n            duplicate rows.\n    \"\"\"\n    count_before = len(event_table)\n    con = duckdb.connect(database=':memory:', read_only=False)\n    con.execute(\"SET enable_progress_bar = false\")\n    con.register(\"event_table\", event_table)\n    sql = \"SELECT DISTINCT * FROM event_table\"\n    result = con.execute(sql).arrow()\n    duckdb.close(con)\n    return result, count_before - len(result)", "\n\ndef link_events_to_visits(event_table: pa.Table,\n                          visit_occurrence: pa.Table,\n                          mising_visit_concept_id: int = 0) -> tuple[pa.Table, pa.Table, Dict[str, int]]:\n    \"\"\"\n    Links events to visits by finding the visit that contains the event's start date.\n\n    Args:\n        event_table: A table with a person_id, concept_id and a start_date column.\n        visit_occurrence: The CDM visit_occurrence table\n        mising_visit_concept_id: The concept ID to use for visits that were generated because events could not be\n            linked to an existing visit.\n\n    Returns:\n        A tuple of 3 items: (1) the combined table with an additional internal_visit_id column, (2) the visit_occurrence\n        table with an additional internal_visit_id column and added visits if some events could not be mapped to\n        existing visits, and (3) a dataframe with the number of visits mapped by ID, data, or to new visits.\n    \"\"\"\n    # DuckDb seems to be the fastest way (by far) to do these join, especially the one on dates\n    visit_occurrence = visit_occurrence.append_column(\"internal_visit_id\",\n                                                      pa.array(range(len(visit_occurrence)), pa.int64()))\n    con = duckdb.connect(database=':memory:', read_only=False)\n    con.execute(\"SET enable_progress_bar = false\")\n    con.register(\"event_table\", event_table)\n    con.register(\"visit_occurrence\", visit_occurrence)\n    # Join by visit_occurrence_id:\n    sql = \"CREATE TABLE joined_1 AS \" \\\n          \"SELECT event_table.*, \" \\\n          \"   internal_visit_id AS id_from_id \" \\\n          \"FROM event_table \" \\\n          \"LEFT JOIN visit_occurrence \" \\\n          \"  ON event_table.visit_occurrence_id = visit_occurrence.visit_occurrence_id \"\n    con.execute(sql)\n    # Join by date:\n    sql = \"CREATE TABLE joined_2 AS \" \\\n          \"SELECT joined_1.person_id, \" \\\n          \"  joined_1.start_date, \" \\\n          \"  joined_1.concept_id, \" \\\n          \"  joined_1.id_from_id, \" \\\n          \"  MIN(visit_occurrence.internal_visit_id) AS id_from_date \" \\\n          \"FROM joined_1 \" \\\n          \"LEFT JOIN visit_occurrence \" \\\n          \"  ON joined_1.person_id = visit_occurrence.person_id \" \\\n          \"    AND start_date >= visit_start_date \" \\\n          \"    AND start_date <= visit_end_date \" \\\n          \"GROUP BY joined_1.person_id, \" \\\n          \"  joined_1.start_date,\" \\\n          \"  joined_1.concept_id, \" \\\n          \"  joined_1.id_from_id\"\n    con.execute(sql)\n    # Create missing visits from unmapped event dates:\n    sql = \"CREATE TABLE missing_visits AS \" \\\n          \"SELECT person_id, \" \\\n          \"  start_date AS visit_start_date, \" \\\n          \"  start_date AS visit_end_date,\" \\\n          \"  {max_internal_visit_id} + ROW_NUMBER() OVER(ORDER BY person_id, start_date) AS internal_visit_id, \" \\\n          \"  CAST({mising_visit_concept_id} AS BIGINT) AS visit_concept_id \" \\\n          \"FROM ( \" \\\n          \"  SELECT DISTINCT person_id,\" \\\n          \"    start_date \" \\\n          \"  FROM joined_2 \" \\\n          \"  WHERE id_from_id IS NULL\" \\\n          \"     AND id_from_date IS NULL \" \\\n          \") AS missing_visits\"\n    sql = sql.format(max_internal_visit_id=len(visit_occurrence) - 1, mising_visit_concept_id=mising_visit_concept_id)\n    con.execute(sql)\n    new_visits = con.execute(\"SELECT COUNT(*) FROM missing_visits\").fetchone()[0]\n    existing_visits = len(visit_occurrence)\n    # Join to the missing visits:\n    sql = \"CREATE TABLE joined_3 AS \" \\\n          \"SELECT joined_2.*, \" \\\n          \"   missing_visits.internal_visit_id AS id_from_new_visit \" \\\n          \"FROM joined_2 \" \\\n          \"LEFT JOIN missing_visits \" \\\n          \"  ON joined_2.person_id = missing_visits.person_id \" \\\n          \"    AND start_date = visit_start_date\"\n    con.execute(sql)\n    sql = \"SELECT person_id, \" \\\n          \"  concept_id, \" \\\n          \"  start_date, \" \\\n          \"  COALESCE(id_from_id, id_from_date, id_from_new_visit) AS internal_visit_id \" \\\n          \"FROM joined_3\"\n    event_table = con.execute(sql).arrow()\n    sql = \"SELECT person_id, \" \\\n          \"  visit_start_date, \" \\\n          \"  visit_end_date, \" \\\n          \"  visit_concept_id, \" \\\n          \"  internal_visit_id \" \\\n          \"FROM visit_occurrence \" \\\n          \"\" \\\n          \"UNION ALL \" \\\n          \"\" \\\n          \"SELECT person_id, \" \\\n          \"  visit_start_date, \" \\\n          \"  visit_end_date, \" \\\n          \"  visit_concept_id, \" \\\n          \"  internal_visit_id \" \\\n          \"FROM missing_visits\"\n    visit_occurrence = con.execute(sql).arrow()\n    sql = \"SELECT CAST(SUM(mapped_by_id) AS INT) AS mapped_by_id, \" \\\n          \"  CAST(SUM(mapped_by_date) AS INT) AS mapped_by_date, \" \\\n          \"  CAST(SUM(mapped_by_new_visit) AS INT) AS mapped_to_new_visit \" \\\n          \"FROM ( \" \\\n          \"  SELECT CASE WHEN id_from_id IS NOT NULL THEN 1 ELSE 0 END AS mapped_by_id, \" \\\n          \"    CASE WHEN id_from_date IS NOT NULL AND id_from_id IS NULL THEN 1 ELSE 0 END AS mapped_by_date, \" \\\n          \"    CASE WHEN id_from_new_visit IS NOT NULL THEN 1 ELSE 0 END AS mapped_by_new_visit \" \\\n          \"  FROM joined_3 \" \\\n          \") AS counts\"\n    statistics = con.execute(sql).fetchdf().iloc[0].to_dict()\n    statistics[\"new_visits\"] = new_visits\n    statistics[\"existing_visits\"] = existing_visits\n    con.execute(\"DROP TABLE joined_1\")\n    con.execute(\"DROP TABLE joined_2\")\n    con.execute(\"DROP TABLE joined_3\")\n    con.execute(\"DROP TABLE missing_visits\")\n    duckdb.close(con)\n    return event_table, visit_occurrence, statistics", "\n\ndef load_mapping_to_ingredients(cdm_folder: str) -> pa.Table:\n    \"\"\"\n    Uses the concept and concept_ancestor table to construct a mapping from drugs to ingredients.\n    Args:\n        cdm_folder: The path where the CDM Parquet files are saved (using the GeneralPretrainModelTools packages).\n\n    Returns:\n        A dictionary from drug concept ID to ingredient concept ID.\n    \"\"\"\n    ingredients = pq.read_table(\n        os.path.join(cdm_folder, CONCEPT),\n        columns=[\"concept_id\"],\n        filters=[(\"concept_class_id\", \"==\", \"Ingredient\")],\n    )\n    concept_ancestor = pq.read_table(os.path.join(cdm_folder, CONCEPT_ANCESTOR))\n    concept_ancestor = concept_ancestor.join(\n        ingredients,\n        keys=[\"ancestor_concept_id\"],\n        right_keys=[\"concept_id\"],\n        join_type=\"inner\",\n    ).select([\"descendant_concept_id\", \"ancestor_concept_id\"]).rename_columns(\n        [SOURCE_CONCEPT_ID, TARGET_CONCEPT_ID])\n    return concept_ancestor", "\n\ndef map_concepts(cdm_table: pa.Table, concept_id_field: str, mapping: pa.Table) -> pa.Table:\n    \"\"\"\n    Maps a concept ID field to another concept ID using a mapping table.\n    Args:\n        cdm_table: The table to map.\n        concept_id_field: The name of the field containing the concept ID.\n        mapping: A table with two columns: source_concept_id and target_concept_id.\n\n    Returns:\n        A table with the same columns as cdm_table, but with the values in the concept ID field replaced by the\n        target_concept_id. Any records that did not have a matching concept were removed. Any records that map to\n        multiple concepts are duplicated.\n    \"\"\"\n    intermediate_columns = cdm_table.column_names\n    intermediate_columns.remove(concept_id_field)\n    intermediate_columns.append(TARGET_CONCEPT_ID)\n    final_columns = cdm_table.column_names\n    final_columns.remove(concept_id_field)\n    final_columns.append(concept_id_field)\n    return cdm_table.join(\n        mapping,\n        keys=[concept_id_field],\n        right_keys=[SOURCE_CONCEPT_ID],\n        join_type=\"inner\",\n    ).select(intermediate_columns).rename_columns(final_columns)", ""]}
{"filename": "cdm_processing/abstract_cdm_processor.py", "chunked_list": ["import cProfile\nfrom abc import ABC, abstractmethod\nimport multiprocessing\nimport os\nfrom typing import Dict\nimport logging\n\nimport pyarrow.parquet as pq\nimport pyarrow as pa\nimport tqdm", "import pyarrow as pa\nimport tqdm\n\nfrom utils.logger import create_logger\n\nPERSON = \"person\"\nCDM_TABLES = [\n    \"person\",\n    \"observation_period\",\n    \"visit_occurrence\",", "    \"observation_period\",\n    \"visit_occurrence\",\n    \"condition_occurrence\",\n    \"drug_exposure\",\n    \"procedure_occurrence\",\n    \"device_exposure\",\n    \"measurement\",\n    \"observation\",\n    \"death\",\n]", "    \"death\",\n]\nLOGGER_FILE_NAME = \"_cdm_processing_log.txt\"  # Start with underscore so ignored by Parquet\n\n\nclass AbstractCdmDataProcessor(ABC):\n    \"\"\"\n    An abstract class that implements iterating over partitioned data as generated by the\n    GeneralPretrainedModelTools R package. It divides the partitions over various threads,\n    and calls the _process_parition_cdm_data() function with all data of a partition.\n\n    Args:\n        cdm_data_path: The path where the CDM Parquet files are saved (using the GeneralPretrainModelTools packages).\n        max_cores: The maximum number of CPU cores to use. If set to -1, all multihreading code will be bypassed for\n                   easier debugging.\n    \"\"\"\n\n    def __init__(self, cdm_data_path: str, output_path: str, max_cores: int = 1):\n        if not os.path.exists(output_path):\n            os.makedirs(output_path)\n        self._cdm_data_path = cdm_data_path\n        self._max_cores = max_cores\n        self._person_partition_count = 0\n        self._output_path = output_path\n        self._profile = False\n        self._configure_logger()\n\n    def set_profile(self, profile: bool):\n        self._profile = profile\n\n    def get_profile(self):\n        return self._profile\n\n    def _configure_logger(self):\n        create_logger(os.path.join(self._output_path, LOGGER_FILE_NAME))\n\n    @abstractmethod\n    def _process_parition_cdm_data(self, cdm_tables: Dict[str, pa.Table], partition_i: int):\n        # This functon is called for every parition (It is executed within a thread.)\n        pass\n\n    def process_cdm_data(self):\n        \"\"\"\n        Process the CDM data in the provided cdm_data_path.\n        \"\"\"\n        if self._profile:\n            cProfile.runctx(statement=\"self._process_cdm_data()\",\n                            locals={\"self\": self},\n                            globals={},\n                            filename=\"../stats\")\n        else:\n            self._process_cdm_data()\n\n    def _process_cdm_data(self):\n        self._get_partition_counts()\n        if self._profile:\n            logging.info(\"Profiling mode enabled, running first partition in single thread\")\n            self._process_partition(0)\n        elif self._max_cores == 1:\n            # Run single thread in main thread for easier debugging:\n            for partition_i in range(self._person_partition_count):\n                self._process_partition(partition_i)\n        else:\n            pool = multiprocessing.get_context(\"spawn\").Pool(processes=self._max_cores)\n            tasks = range(self._person_partition_count)\n            work = self._process_partition\n            for _ in tqdm.tqdm(pool.imap_unordered(work, tasks), total=len(tasks)):\n                pass\n            pool.close()\n        logging.info(\"Finished processing data\")\n\n    def _get_partition_counts(self):\n        files = os.listdir(os.path.join(self._cdm_data_path, PERSON))\n        self._person_partition_count = len(\n            list(filter(lambda x: \".parquet\" in x, files))\n        )\n        logging.info(\"Found %s partitions\", self._person_partition_count)\n\n    def _process_partition(self, partition_i: int):\n        # This function is executed within a thread\n        # Need to re-configure logger because we're in a thread:\n        self._configure_logger()\n        logging.debug(\"Starting partition %s of %s\", partition_i, self._person_partition_count)\n\n        file_name = \"part{:04d}.parquet\".format(partition_i + 1)\n        available_tables = [table for table in CDM_TABLES if table in os.listdir(self._cdm_data_path)]\n        cdm_tables = {table: pq.read_table(os.path.join(self._cdm_data_path, table, file_name)) for table in\n                      available_tables}\n        self._process_parition_cdm_data(cdm_tables, partition_i)\n\n        logging.debug(\"Finished partition %s of %s\", partition_i, self._person_partition_count)", ""]}
{"filename": "cdm_processing/__init__.py", "chunked_list": [""]}
{"filename": "cdm_processing/cehr_bert_cdm_processor.py", "chunked_list": ["import os\nimport sys\nfrom typing import Dict, List\nimport logging\nimport configparser\n\nimport duckdb\nimport pyarrow as pa\nimport pyarrow.parquet as pq\n", "import pyarrow.parquet as pq\n\nfrom cdm_processing.abstract_cdm_processor import AbstractCdmDataProcessor\nimport cdm_processing.cdm_processor_utils as cdm_utils\nimport utils.logger as logger\n\n\ndef _create_cehr_bert_tables(cdm_tables: Dict[str, pa.Table], event_table: pa.Table) -> pa.Table:\n    \"\"\"\n    Creates the table needed for the CEHR-BERT model.\n    Args:\n        cdm_tables: A dictionary of CDM tables, with the table name as key and the table as value. The person table\n            should have the date_of_birth field added using the add_date_of_birth_to_person_table() function.\n        event_table: The table with the clinical events. This is a combination across the CDM domain tables, as created\n            by the union_cdm_tables() function.\n\n    Returns:\n        A table with the data needed for the CEHR-BERT model.\n    \"\"\"\n    con = duckdb.connect(database=':memory:', read_only=False)\n    con.execute(\"SET enable_progress_bar = false\")\n    con.register(\"visit_occurrence\", cdm_tables[\"visit_occurrence\"])\n    con.register(\"observation_period_table\", cdm_tables[\"observation_period\"])\n    con.register(\"person\", cdm_tables[\"person\"])\n    con.register(\"event_table\", event_table)\n    sql = \"CREATE TABLE visits AS \" \\\n          \"SELECT visit_occurrence.*, \" \\\n          \"  observation_period_id, \" \\\n          \"  ROW_NUMBER() OVER (PARTITION BY observation_period_id ORDER BY visit_start_date) AS visit_rank \" \\\n          \"FROM visit_occurrence \" \\\n          \"INNER JOIN observation_period_table \" \\\n          \"  ON visit_occurrence.person_id = observation_period_table.person_id \" \\\n          \"    AND visit_occurrence.visit_start_date >= observation_period_table.observation_period_start_date \" \\\n          \"    AND visit_occurrence.visit_start_date <= observation_period_table.observation_period_end_date\"\n    con.execute(sql)\n    sql = \"CREATE TABLE interval_tokens AS \" \\\n          \"SELECT CASE \" \\\n          \"    WHEN days < 0 THEN 'W-1' \" \\\n          \"    WHEN days < 28 THEN 'W' || CAST(CAST(FLOOR(days / 7) AS INT) AS VARCHAR) \" \\\n          \"    WHEN days < 360 THEN 'M' || CAST(CAST(FLOOR(days / 30) AS INT) AS VARCHAR) \" \\\n          \"    ELSE 'LT' \" \\\n          \"  END AS concept_ids, \" \\\n          \"  0 AS visit_segments, \" \\\n          \"  0 AS dates, \" \\\n          \" -1 AS ages, \" \\\n          \"  visit_rank AS visit_concept_orders, \" \\\n          \"  CAST('0' AS VARCHAR) AS visit_concept_ids, \" \\\n          \"  -2 AS sort_order, \" \\\n          \"  observation_period_id, \" \\\n          \"  person_id \" \\\n          \"FROM (\" \\\n          \"  SELECT visits.visit_start_date - previous_visit.visit_end_date AS days,\" \\\n          \"    visits.* \" \\\n          \"  FROM visits \" \\\n          \"  INNER JOIN visits previous_visit\" \\\n          \"    ON visits.observation_period_id = previous_visit.observation_period_id \" \\\n          \"      AND visits.visit_rank = previous_visit.visit_rank + 1\" \\\n          \") intervals\"\n    con.execute(sql)\n    sql = \"CREATE TABLE start_tokens AS \" \\\n          \"SELECT 'VS' AS concept_ids, \" \\\n          \"  visit_rank % 2 + 1 AS visit_segments, \" \\\n          \"  DATE_DIFF('week', DATE '1970-01-01', visit_start_date) AS dates, \" \\\n          \"  DATE_DIFF('month', date_of_birth, visit_start_date) AS ages, \" \\\n          \"  visit_rank AS visit_concept_orders, \" \\\n          \"  CAST(visit_concept_id AS VARCHAR) AS visit_concept_ids, \" \\\n          \"  -1 AS sort_order, \" \\\n          \"  observation_period_id, \" \\\n          \"  person.person_id \" \\\n          \"FROM visits \" \\\n          \"INNER JOIN person \" \\\n          \"  ON visits.person_id = person.person_id\"\n    con.execute(sql)\n    sql = \"CREATE TABLE event_tokens AS \" \\\n          \"SELECT CAST(concept_id AS VARCHAR) AS concept_ids, \" \\\n          \"  visit_rank % 2 + 1 AS visit_segments, \" \\\n          \"  DATE_DIFF('week', DATE '1970-01-01', start_date) AS dates, \" \\\n          \"  DATE_DIFF('month', date_of_birth,start_date) AS ages, \" \\\n          \"  visit_rank AS visit_concept_orders, \" \\\n          \"  CAST(visit_concept_id AS VARCHAR) AS visit_concept_ids, \" \\\n          \"  concept_id AS sort_order, \" \\\n          \"  observation_period_id, \" \\\n          \"  person.person_id \" \\\n          \"FROM event_table \" \\\n          \"INNER JOIN visits \" \\\n          \"  ON event_table.internal_visit_id = visits.internal_visit_id \" \\\n          \"INNER JOIN person \" \\\n          \"  ON visits.person_id = person.person_id\"\n    con.execute(sql)\n    sql = \"CREATE TABLE end_tokens AS \" \\\n          \"SELECT 'VE' AS concept_ids, \" \\\n          \"  visit_rank % 2 + 1 AS visit_segments, \" \\\n          \"  DATE_DIFF('week', DATE '1970-01-01', visit_end_date) AS dates, \" \\\n          \"  DATE_DIFF('month', date_of_birth, visit_end_date) AS ages, \" \\\n          \"  visit_rank AS visit_concept_orders, \" \\\n          \"  CAST(visit_concept_id AS VARCHAR) AS visit_concept_ids, \" \\\n          \"  9223372036854775807 AS sort_order, \" \\\n          \"  observation_period_id, \" \\\n          \"  person.person_id \" \\\n          \"FROM visits \" \\\n          \"INNER JOIN person \" \\\n          \"  ON visits.person_id = person.person_id\"\n    con.execute(sql)\n    sql = \"SELECT *, \" \\\n          \"  ROW_NUMBER() OVER \" \\\n          \"    (PARTITION BY observation_period_id ORDER BY visit_concept_orders, sort_order) - 1  AS orders \" \\\n          \"FROM (\" \\\n          \"  SELECT * FROM interval_tokens \" \\\n          \"  UNION ALL \" \\\n          \"  SELECT * FROM start_tokens \" \\\n          \"  UNION ALL \" \\\n          \"  SELECT * FROM event_tokens \" \\\n          \"  UNION ALL \" \\\n          \"  SELECT * FROM end_tokens\" \\\n          \") tokens \" \\\n          \"ORDER BY observation_period_id, visit_concept_orders, sort_order\"\n    union_tokens = con.execute(sql).arrow()\n    con.execute(\"DROP TABLE visits\")\n    con.execute(\"DROP TABLE interval_tokens\")\n    con.execute(\"DROP TABLE start_tokens\")\n    con.execute(\"DROP TABLE event_tokens\")\n    con.execute(\"DROP TABLE end_tokens\")\n    duckdb.close(con)\n    cehr_bert_input = union_tokens.group_by(\"observation_period_id\").aggregate([\n        (\"person_id\", \"max\"),\n        (\"concept_ids\", \"list\"),\n        (\"visit_segments\", \"list\"),\n        (\"dates\", \"list\"),\n        (\"ages\", \"list\"),\n        (\"visit_concept_orders\", \"list\"),\n        (\"visit_concept_ids\", \"list\"),\n        (\"orders\", \"list\"),\n        (\"concept_ids\", \"count\"),\n        (\"visit_concept_orders\", \"max\")]).rename_columns(\n        [\"observation_period_id\",\n         \"person_id\",\n         \"concept_ids\",\n         \"visit_segments\",\n         \"dates\",\n         \"ages\",\n         \"visit_concept_orders\",\n         \"visit_concept_ids\",\n         \"orders\",\n         \"num_of_concepts\",\n         \"num_of_visits\"])\n    return cehr_bert_input", "\n\nclass CehrBertCdmDataProcessor(AbstractCdmDataProcessor):\n    \"\"\"\n    A re-implementation of the processor for CEHR-BERT (https://github.com/cumc-dbmi/cehr-bert)\n    \"\"\"\n\n    def __init__(self, cdm_data_path: str, output_path: str, max_cores: int = -1,\n                 map_drugs_to_ingredients: bool = False, concepts_to_remove: List[int] = [0]):\n        super().__init__(\n            cdm_data_path=cdm_data_path, output_path=output_path, max_cores=max_cores\n        )\n        self._map_drugs_to_ingredients = map_drugs_to_ingredients\n        self._concepts_to_remove = concepts_to_remove\n        if self._map_drugs_to_ingredients:\n            self._drug_mapping = cdm_utils.load_mapping_to_ingredients(self._cdm_data_path)\n\n    def _process_parition_cdm_data(self, cdm_tables: Dict[str, pa.Table], partition_i: int):\n        \"\"\"\n        Process a single partition of CDM data, and save the result to disk.\n        \"\"\"\n        cdm_tables[\"person\"] = cdm_utils.add_date_of_birth(cdm_tables[\"person\"])\n        if self._map_drugs_to_ingredients:\n            cdm_tables[\"drug_exposure\"] = cdm_utils.map_concepts(cdm_table=cdm_tables[\"drug_exposure\"],\n                                                                 concept_id_field=\"drug_concept_id\",\n                                                                 mapping=self._drug_mapping)\n        event_table = cdm_utils.union_domain_tables(cdm_tables)\n        event_table, removed_concepts = cdm_utils.remove_concepts(event_table=event_table,\n                                                                  concept_ids=self._concepts_to_remove)\n        event_table, removed_duplicates = cdm_utils.remove_duplicates(event_table=event_table)\n        event_table, visit_occurrence, mapping_stats = cdm_utils.link_events_to_visits(event_table=event_table,\n                                                                                       visit_occurrence=cdm_tables[\n                                                                                           \"visit_occurrence\"],\n                                                                                       mising_visit_concept_id=1)\n        cdm_tables[\"visit_occurrence\"] = visit_occurrence\n        cehr_bert_input = _create_cehr_bert_tables(cdm_tables=cdm_tables, event_table=event_table)\n        file_name = \"part{:04d}.parquet\".format(partition_i + 1)\n        pq.write_table(cehr_bert_input, os.path.join(self._output_path, file_name))\n\n        logging.debug(\"Partition %s persons: %s\", partition_i, len(cdm_tables[\"person\"]))\n        logging.debug(\"Partition %s observation periods: %s\", partition_i, len(cdm_tables[\"observation_period\"]))\n        logging.debug(\"Partition %s removed events having unwanted concept ID: %s\", partition_i, removed_concepts)\n        logging.debug(\"Partition %s removed duplicate events: %s\", partition_i, removed_duplicates)\n        logging.debug(\"Partition %s events mapped to visit by ID: %s\", partition_i, mapping_stats[\"mapped_by_id\"])\n        logging.debug(\"Partition %s events mapped to visit by date: %s\", partition_i, mapping_stats[\"mapped_by_date\"])\n        logging.debug(\"Partition %s events mapped to new visits: %s\", partition_i, mapping_stats[\"mapped_to_new_visit\"])\n        logging.debug(\"Partition %s existing visits: %s\", partition_i, mapping_stats[\"existing_visits\"])\n        logging.debug(\"Partition %s newly created visits: %s\", partition_i, mapping_stats[\"new_visits\"])", "\n\ndef main(args: List[str]):\n    config = configparser.ConfigParser()\n    with open(args[0]) as file:  # Explicitly opening file so error is thrown when not found\n        config.read_file(file)\n    cdm_data_processor = CehrBertCdmDataProcessor(\n        cdm_data_path=config[\"system\"].get(\"cdm_data_path\"),\n        max_cores=config[\"system\"].getint(\"max_cores\"),\n        output_path=config[\"system\"].get(\"output_path\"),\n        map_drugs_to_ingredients=config[\"mapping\"].getboolean(\"map_drugs_to_ingredients\"),\n        concepts_to_remove=[int(x) for x in config[\"mapping\"].get(\"concepts_to_remove\").split(\",\")],\n    )\n    # Log config after initializing cdm_data_processor so logger is initialized:\n    logger.log_config(config)\n    if config[\"debug\"].getboolean(\"profile\"):\n        cdm_data_processor.set_profile(True)\n    cdm_data_processor.process_cdm_data()", "\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        raise Exception(\"Must provide path to ini file as argument\")\n    else:\n        main(sys.argv[1:])\n"]}
{"filename": "utils/logger.py", "chunked_list": ["import logging\nimport sys\n\ndef _add_stream_handler(logger: logging.Logger):\n    stream_handler = logging.StreamHandler()\n    stream_handler.setLevel(logging.INFO)\n    logger.addHandler(stream_handler)\n    return logger\n\n\ndef _add_file_handler(logger: logging.Logger, log_file_name: str):\n    file_handler = logging.FileHandler(log_file_name, mode=\"a\")\n    formatter = logging.Formatter(\n        fmt=\"%(asctime)s - %(levelname)-8s %(message)s\", datefmt=\"%m-%d %H:%M\")\n    file_handler.setFormatter(formatter)\n    file_handler.setLevel(logging.DEBUG)\n    logger.addHandler(file_handler)\n    return logger", "\n\ndef _add_file_handler(logger: logging.Logger, log_file_name: str):\n    file_handler = logging.FileHandler(log_file_name, mode=\"a\")\n    formatter = logging.Formatter(\n        fmt=\"%(asctime)s - %(levelname)-8s %(message)s\", datefmt=\"%m-%d %H:%M\")\n    file_handler.setFormatter(formatter)\n    file_handler.setLevel(logging.DEBUG)\n    logger.addHandler(file_handler)\n    return logger", "\n\ndef create_logger(log_file_name: str):\n    \"\"\"\n    Sets up the root logger where it writes all logging events to file, and writing events at or above 'info' to\n    console. Events are appended to the log file.\n\n    Args:\n        log_file_name: The name of the file where the log will be written to.\n    \"\"\"\n    logger = logging.getLogger()\n    logger.setLevel(logging.DEBUG)\n    if not len(logger.handlers):\n        _add_file_handler(logger=logger, log_file_name=log_file_name)\n        _add_stream_handler(logger=logger)\n\n    sys.excepthook = handle_exception", "\nclass _ConfigLogger(object):\n\n    def log_config(self, config):\n        logging.info(\"Config:\")\n        config.write(self)\n    def write(self, data):\n        line = data.strip()\n        logging.info(line)\n\ndef log_config(config):\n    config_logger = _ConfigLogger()\n    config_logger.log_config(config)", "\ndef log_config(config):\n    config_logger = _ConfigLogger()\n    config_logger.log_config(config)\n\n\ndef handle_exception(exc_type, exc_value, exc_traceback):\n    if not issubclass(exc_type, KeyboardInterrupt):\n        logger = logging.getLogger()\n        logger.critical(\"Uncaught exception\", exc_info=(exc_type, exc_value, exc_traceback))\n    sys.__excepthook__(exc_type, exc_value, exc_traceback)", ""]}
{"filename": "tests/test_cdm_data.py", "chunked_list": ["import shutil\nimport tempfile\nimport os\n\nimport unittest\n\nimport numpy as np\n\nfrom simulating import cdm_data\n", "from simulating import cdm_data\n\n\nclass TestCdmData(unittest.TestCase):\n\n    def setUp(self) -> None:\n        self.temp_folder = tempfile.mkdtemp()\n\n    def tearDown(self):\n        shutil.rmtree(self.temp_folder)\n\n    def test_dynamic_array(self):\n        x = cdm_data.DynamicArray()\n        for value in range(2000):\n            x.append(value)\n        assert len(x) == 2000\n        assert (x.collect() == np.asarray(range(2000))).all()", ""]}
{"filename": "tests/test_cdm_processor_utils.py", "chunked_list": ["from typing import List\n\nimport unittest\nimport pyarrow as pa\nimport pyarrow.compute as pc\nimport datetime as dt\n\nimport cdm_processing.cdm_processor_utils as cdm_utils\n\n\ndef d(dates_as_strings: List[str]):\n    \"\"\"\n    Helper function: convert a list of dates as strings to a list of dates as datetime objects.\n    Args:\n        dates_as_strings: A list of dates as strings in the format YYYY-MM-DD.\n\n    Returns:\n        A list of dates as datetime objects.\n    \"\"\"\n    return pc.strptime(\n        dates_as_strings,\n        format=\"%Y-%m-%d\",\n        unit=\"s\"\n    )", "\n\ndef d(dates_as_strings: List[str]):\n    \"\"\"\n    Helper function: convert a list of dates as strings to a list of dates as datetime objects.\n    Args:\n        dates_as_strings: A list of dates as strings in the format YYYY-MM-DD.\n\n    Returns:\n        A list of dates as datetime objects.\n    \"\"\"\n    return pc.strptime(\n        dates_as_strings,\n        format=\"%Y-%m-%d\",\n        unit=\"s\"\n    )", "\n\nclass TestCdmProcessorUtils(unittest.TestCase):\n\n    def setUp(self) -> None:\n        person = pa.Table.from_pydict(\n            {\n                \"person_id\": [1],\n                \"year_of_birth\": [1970],\n                \"month_of_birth\": [5],\n                \"day_of_birth\": [7],\n                \"gender_concept_id\": [8507],\n            },\n            schema=pa.schema(\n                [\n                    (\"person_id\", pa.int64()),\n                    (\"year_of_birth\", pa.int32()),\n                    (\"month_of_birth\", pa.int32()),\n                    (\"day_of_birth\", pa.int32()),\n                    (\"gender_concept_id\", pa.int32()),\n                ]\n            )\n        )\n        observation_period = pa.Table.from_pydict(\n            {\n                \"person_id\": [1, 1, 1],\n                \"observation_period_id\": [1, 2, 3],\n                \"observation_period_start_date\": d([\"2000-01-01\", \"2001-01-01\", \"2002-01-01\"]),\n                \"observation_period_end_date\": d([\"2000-07-01\", \"2001-07-01\", \"2002-07-01\"]),\n            },\n            schema=pa.schema(\n                [\n                    (\"person_id\", pa.int64()),\n                    (\"observation_period_id\", pa.int64()),\n                    (\"observation_period_start_date\", pa.date32()),\n                    (\"observation_period_end_date\", pa.date32()),\n                ]\n            )\n        )\n        visit_occurrence = pa.Table.from_pydict(\n            {\n                \"person_id\": pa.array([1, 1, 1]),\n                \"visit_occurrence_id\": [1, 2, 3],\n                \"visit_concept_id\": [9201, 9202, 9201],\n                \"visit_start_date\": d([\"2000-01-01\", \"2000-02-01\", \"2002-07-01\"]),\n                \"visit_end_date\": d([\"2000-01-01\", \"2000-02-05\", \"2002-07-01\"]),\n            },\n            schema=pa.schema(\n                [\n                    (\"person_id\", pa.int64()),\n                    (\"visit_occurrence_id\", pa.int64()),\n                    (\"visit_concept_id\", pa.int32()),\n                    (\"visit_start_date\", pa.date32()),\n                    (\"visit_end_date\", pa.date32()),\n                ]\n            )\n        )\n        condition_occurrence = pa.Table.from_pydict(\n            {\n                \"person_id\": [1, 1, 1],\n                \"condition_concept_id\": [123, 456, 0],\n                \"condition_start_date\": d([\"2000-01-01\", \"2000-02-01\", \"2000-03-01\"]),\n                \"condition_end_date\": d([\"2000-01-01\", \"2000-02-01\", \"2000-03-01\"]),\n                \"visit_occurrence_id\": [1, None, None],\n            },\n            schema=pa.schema(\n                [\n                    (\"person_id\", pa.int64()),\n                    (\"condition_concept_id\", pa.int32()),\n                    (\"condition_start_date\", pa.date32()),\n                    (\"condition_end_date\", pa.date32()),\n                    (\"visit_occurrence_id\", pa.int64()),\n                ]\n            )\n        )\n        death = pa.Table.from_pydict(\n            {\n                \"person_id\": [1],\n                \"death_date\": d([\"2020-07-01\"]),\n            },\n            schema=pa.schema(\n                [\n                    (\"person_id\", pa.int64()),\n                    (\"death_date\", pa.date32()),\n                ]\n            )\n        )\n        self.cdm_tables = {\"person\": person,\n                           \"observation_period\": observation_period,\n                           \"visit_occurrence\": visit_occurrence,\n                           \"condition_occurrence\": condition_occurrence,\n                           \"death\": death}\n\n    def test_union_domain_tables(self):\n        event_table = cdm_utils.union_domain_tables(self.cdm_tables)\n\n        # First record should be death:\n        assert event_table[\"concept_id\"].to_pylist()[0] == 4306655\n\n    def test_remove_concepts(self):\n        event_table = cdm_utils.union_domain_tables(self.cdm_tables)\n        new_cdm_tables, removed_count = cdm_utils.remove_concepts(event_table=event_table, concept_ids=[0])\n        assert removed_count == 1\n        assert len(event_table) == 4\n\n    def test_add_date_of_birth(self):\n        person = pa.Table.from_pydict(\n            {\n                \"person_id\": [1, 2, 3],\n                \"year_of_birth\": [1970, 1980, 1990],\n                \"month_of_birth\": [5, 4, None],\n                \"day_of_birth\": [7, None, None],\n                \"gender_concept_id\": [8507, 8507, 8507],\n            }\n        )\n        dob = cdm_utils.add_date_of_birth(person)\n        assert dob[\"date_of_birth\"].to_pylist()[0] == dt.datetime(1970, 5, 7)\n        assert dob[\"date_of_birth\"].to_pylist()[1] == dt.datetime(1980, 4, 1)\n        assert dob[\"date_of_birth\"].to_pylist()[2] == dt.datetime(1990, 1, 1)\n\n    def test_group_by_visit(self):\n        event_table = cdm_utils.union_domain_tables(self.cdm_tables)\n        visits = self.cdm_tables[\"visit_occurrence\"]\n        event_table, visits, stats = cdm_utils.link_events_to_visits(event_table=event_table,\n                                                                     visit_occurrence=visits,\n                                                                     mising_visit_concept_id=0)\n        assert pc.max(visits[\"internal_visit_id\"]).as_py() == 4\n        # First visit in CDM data, linked by ID:\n        visit_group = event_table.filter(pc.equal(event_table[\"internal_visit_id\"], 0))\n        assert len(visit_group) == 1\n        assert visit_group[\"concept_id\"].to_pylist()[0] == 123\n        # Second visit in CDM data, linked by date\n        visit_group = event_table.filter(pc.equal(event_table[\"internal_visit_id\"], 1))\n        assert len(visit_group) == 1\n        assert visit_group[\"concept_id\"].to_pylist()[0] == 456\n        # Third visit in CDM data, has no events:\n        visit_group = event_table.filter(pc.equal(event_table[\"internal_visit_id\"], 2))\n        assert len(visit_group) == 0\n        # New visit, derived from condition occurrence\n        visit_group = event_table.filter(pc.equal(event_table[\"internal_visit_id\"], 3))\n        assert len(visit_group) == 1\n        assert visit_group[\"concept_id\"].to_pylist()[0] == 0\n        visit = visits.filter(pc.equal(visits[\"internal_visit_id\"], 3))\n        assert visit[\"visit_concept_id\"].to_pylist()[0] == 0\n        # New visit, derived from death\n        visit_group = event_table.filter(pc.equal(event_table[\"internal_visit_id\"], 4))\n        assert len(visit_group) == 1\n        assert visit_group[\"concept_id\"].to_pylist()[0] == 4306655\n\n    def test_remove_duplicate_events(self):\n        event_table = pa.Table.from_pydict(\n            {\n                \"concept_id\": [1000, 2000, 2000, 2000],\n                \"start_date\": d([\"2000-01-01\", \"2001-01-01\", \"2001-01-01\", \"2001-01-02\"]),\n            }\n        )\n        event_table, removed_count = cdm_utils.remove_duplicates(event_table)\n        assert removed_count == 1\n        assert len(event_table) == 3\n        assert event_table[\"concept_id\"].to_pylist() == [1000, 2000, 2000]", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/test_data_generating.py", "chunked_list": ["import shutil\nimport tempfile\nimport os\n\nimport pandas as pd\nimport numpy as np\nimport unittest\nimport tensorflow as tf\n\nfrom data_generating import tokenizer, learning_objective, data_generator, parquet_data_iterator", "\nfrom data_generating import tokenizer, learning_objective, data_generator, parquet_data_iterator\n\n\nclass TestDataGenerating(unittest.TestCase):\n\n    def setUp(self) -> None:\n        self.parquet_folder = tempfile.mkdtemp()\n\n        row = pd.DataFrame(\n            {\n                \"cohort_member_id\": [1],\n                \"person_id\": [1],\n                \"concept_ids\": [np.array([\"VS\", \"123\", \"456\", \"VE\", \"W1\", \"VS\", \"456\", \"VE\"], dtype=str)],\n                \"visit_segments\": [np.array([2, 2, 2, 2, 0, 1, 1, 1], dtype=np.int32)],\n                \"orders\": [np.array([0, 1, 2, 3, 4, 5, 6, 7], dtype=np.int32)],\n                \"dates\": [np.array([1800, 1800, 1800, 1800, 0, 1801, 1801, 1801], dtype=np.int32)],\n                \"ages\": [np.array([75, 75, 75, 75, 0, 76, 76, 76], dtype=np.int32)],\n                \"visit_concept_orders\": [np.array([1, 1, 1, 1, 2, 2, 2, 2], dtype=np.int32)],\n                \"num_of_concepts\": [8],\n                \"num_of_visits\": [2],\n                \"visit_concept_ids\": [np.array([\"9202\", \"9202\", \"9202\", \"9202\", \"0\", \"9202\", \"9202\", \"9202\"], dtype=str)],\n            }\n        )\n        row.to_parquet(os.path.join(self.parquet_folder, \"test.parquet\"))\n\n    def tearDown(self):\n        shutil.rmtree(self.parquet_folder)\n\n    def test_parquest_data_iterator(self):\n        data = parquet_data_iterator.ParquetDataIterator(parquet_folder_name=self.parquet_folder)\n        row_count = 0\n        for row in data:\n            assert row[\"cohort_member_id\"] == 1\n            assert row[\"person_id\"] == 1\n            assert row[\"concept_ids\"].shape == (8,)\n            assert row[\"visit_segments\"].shape == (8,)\n            assert row[\"orders\"].shape == (8,)\n            assert row[\"dates\"].shape == (8,)\n            assert row[\"ages\"].shape == (8,)\n            assert row[\"visit_concept_orders\"].shape == (8,)\n            assert row[\"num_of_concepts\"] == 8\n            assert row[\"num_of_visits\"] == 2\n            assert row[\"visit_concept_ids\"].shape == (8,)\n            row_count += 1\n            break\n        assert row_count == 1\n\n\n    def test_concept_tokenizer(self):\n        data = parquet_data_iterator.ParquetDataIterator(parquet_folder_name=self.parquet_folder)\n        concept_tokenizer = tokenizer.ConceptTokenizer()\n        concept_tokenizer.fit_on_concept_sequences(parquet_data_iterator=data,\n                                                   column_name=\"concept_ids\")\n        assert concept_tokenizer.encode([tokenizer.OUT_OF_VOCABULARY_TOKEN]) == \\\n               [concept_tokenizer.get_out_of_vocabulary_token_id()]\n        assert concept_tokenizer.encode([tokenizer.MASK_TOKEN]) == [concept_tokenizer.get_mask_token_id()]\n        assert concept_tokenizer.encode([tokenizer.UNUSED_TOKEN]) == [concept_tokenizer.get_unused_token_id()]\n        test_concept_ids = np.array([\"VS\", \"123\", \"456\", \"VE\", \"W1\", \"VS\", \"456\", \"VE\"], dtype=str)\n        encoding = concept_tokenizer.encode(test_concept_ids)\n        decoding = concept_tokenizer.decode(encoding)\n        assert decoding == test_concept_ids.tolist()\n\n        json_filename = os.path.join(self.parquet_folder, \"_test.json\")\n        concept_tokenizer.save_to_json(json_filename)\n        concept_tokenizer_2 = tokenizer.load_from_json(json_filename)\n        os.remove(json_filename)\n        encoding_2 = concept_tokenizer_2.encode(test_concept_ids)\n        assert encoding == encoding_2\n\n\n    def test_data_generator(self):\n        learning_objectives = [learning_objective.MaskedLanguageModelLearningObjective(work_folder=self.parquet_folder),\n                               learning_objective.VisitPredictionLearningObjective(work_folder=self.parquet_folder)]\n        bert_data_generator = data_generator.DataGenerator(training_data_path=self.parquet_folder,\n                                                           batch_size=4,\n                                                           max_sequence_length=10,\n                                                           min_sequence_length=5,\n                                                           is_training=False,\n                                                           learning_objectives=learning_objectives)\n        assert len(bert_data_generator) == 1\n        batch_count = 0\n        for batch_input, batch_output in bert_data_generator.generator():\n            # TODO: add some specific tests on output\n            batch_count += 1\n            break\n        assert batch_count == 1\n\n\n    def test_dataset_from_generator(self):\n        learning_objectives = [learning_objective.MaskedLanguageModelLearningObjective(work_folder=self.parquet_folder),\n                               learning_objective.VisitPredictionLearningObjective(work_folder=self.parquet_folder)]\n        bert_data_generator = data_generator.DataGenerator(training_data_path=self.parquet_folder,\n                                                           batch_size=4,\n                                                           max_sequence_length=10,\n                                                           min_sequence_length=5,\n                                                           is_training=True,\n                                                           learning_objectives=learning_objectives)\n        # from_generator() verifies if the output of the generator matches the schema:\n        dataset = tf.data.Dataset.from_generator(generator=bert_data_generator.generator,\n                                                 output_types=bert_data_generator.get_tf_dataset_schema())\n        batch_count = 0\n        for batch in dataset:\n            # TODO: add some specific tests on output\n            batch_count += 1\n            break\n        assert batch_count == 1", ""]}
{"filename": "data_generating/parquet_data_iterator.py", "chunked_list": ["from typing import Iterator\n\nimport pandas as pd\nimport pyarrow.parquet as pq\n\n\nclass ParquetDataIterator:\n    \"\"\"Iterate over rows in parquet files\"\"\"\n\n    def __init__(self, parquet_folder_name: str):\n        \"\"\"\n        Initialization\n\n        Args:\n            parquet_folder_name: Path to the folder containing the parquet files.\n        \"\"\"\n        self._parquet_path = parquet_folder_name\n        self._dataset = pq.ParquetDataset(parquet_folder_name)\n        self._nrows = sum(fragment.count_rows() for fragment in self._dataset.fragments)\n        self._iterator = self.__iter__()  # Used by __next__\n\n    def __iter__(self) -> Iterator[pd.DataFrame]:\n        for fragment in self._dataset.fragments:\n            for batch in fragment.to_batches():\n                for index, row in batch.to_pandas().iterrows():\n                    yield row\n\n    def __len__(self) -> int:\n        \"\"\"The number of batches per epoch\"\"\"\n        return self._nrows\n\n    def __next__(self) -> pd.DataFrame:\n        return next(self._iterator)", ""]}
{"filename": "data_generating/abstract_data_generator.py", "chunked_list": ["from abc import ABC, abstractmethod\n\nfrom data_generating.parquet_data_iterator import ParquetDataIterator\n\n\nclass AbstractDataGenerator(ABC):\n    \"\"\"\n    The interface of the data generator that will be visible to the learning objectives.\n    \"\"\"\n    @abstractmethod\n    def get_parquet_data_iterator(self) -> ParquetDataIterator:\n        pass\n\n    @abstractmethod\n    def get_is_training(self) -> bool:\n        pass\n\n    @abstractmethod\n    def get_max_sequence_length(self) -> int:\n        pass", ""]}
{"filename": "data_generating/data_generator.py", "chunked_list": ["import random\nfrom collections import ChainMap, defaultdict\nfrom typing import Iterator, Dict\n\nimport numpy as np\nimport pandas as pd\n\nfrom data_generating.abstract_data_generator import AbstractDataGenerator\nfrom data_generating.learning_objective import LearningObjective\nfrom data_generating.parquet_data_iterator import ParquetDataIterator", "from data_generating.learning_objective import LearningObjective\nfrom data_generating.parquet_data_iterator import ParquetDataIterator\n\n\nSEQUENCE_LENGTH_COLUMN_NAME = \"num_of_concepts\"\n\n\nclass DataGenerator(AbstractDataGenerator):\n    \"\"\"\n    Generate data for tensorflow from parquet files. Iterates over the sequence data created using the CDM\n    processing. To be used with tf.data.Dataset.from_generator\n    \"\"\"\n\n    def __init__(self,\n                 training_data_path: str,\n                 batch_size: int,\n                 max_sequence_length: int,\n                 min_sequence_length: int,\n                 is_training: bool,\n                 learning_objectives: list[LearningObjective] = None):\n        \"\"\"\n        Initialization\n\n        Args:\n            training_data_path: Path to the folder containing the parquet files.\n            batch_size: Number of examples in a batch.\n            max_sequence_length: The maximum length of a sequence.\n            min_sequence_length: The minimum length of a sequence. Persons with sequences shorter than this will be\n                ignored.\n            is_training: If true, the generated data is intended for training, and for example subsequences will be\n                sampled and tokens will be masked.\n            learning_objectives: One or more learning objectives for which to generate data.\n        \"\"\"\n        self._parquet_path = training_data_path\n        self._batch_size = batch_size\n        self._max_sequence_length = max_sequence_length\n        self._min_sequence_length = min_sequence_length\n        self._is_training = is_training\n        self._parquet_data_iterator = ParquetDataIterator(training_data_path)\n        self._nrows = len(self._parquet_data_iterator)\n        self._learning_objectives = learning_objectives\n        for learning_objective in self._learning_objectives:\n            learning_objective.initialize(self)\n\n    def __len__(self) -> int:\n        \"\"\"The number of batches per epoch\"\"\"\n        return int(np.ceil(self._nrows / self._batch_size))\n\n    def get_parquet_data_iterator(self) -> ParquetDataIterator:\n        return self._parquet_data_iterator\n\n    def get_is_training(self) -> bool:\n        return self._is_training\n\n    def get_max_sequence_length(self) -> int:\n        return self._max_sequence_length\n\n    def generator(self) -> Iterator[tuple[Dict, Dict]]:\n        \"\"\"Generate data for tensorflow\"\"\"\n        while True:\n            try:\n                yield self._get_batch()\n            except StopIteration:\n                break\n\n    def _get_batch(self) -> tuple[Dict, Dict]:\n        \"\"\"Get a batch of data for tensorflow\"\"\"\n        row_batch = self._get_row_batch()\n        input_dicts = defaultdict(list)\n        output_dicts = defaultdict(list)\n        for row in row_batch:\n            begin_index, end_index = self._create_begin_end_indices(row)\n            for learning_objective in self._learning_objectives:\n                inputs, outputs = learning_objective.process_row(row, begin_index, end_index)\n                for key, value in inputs.items():\n                    input_dicts[key].append(value)\n                for key, value in outputs.items():\n                    output_dicts[key].append(value)\n        return dict(input_dicts), dict(output_dicts)\n\n    def _get_row_batch(self) -> list[pd.DataFrame]:\n        \"\"\"Get a batch of rows\"\"\"\n        row_batch = []\n        while len(row_batch) < self._batch_size:\n            try:\n                row = next(self._parquet_data_iterator)\n            except StopIteration:\n                break\n            if row[SEQUENCE_LENGTH_COLUMN_NAME] >= self._min_sequence_length:\n                row_batch.append(row)\n        if len(row_batch) == 0:\n            raise StopIteration\n        return row_batch\n\n    def _create_begin_end_indices(self, row: pd.DataFrame) -> tuple[int, int]:\n        \"\"\"Create begin and end indices for a row, either by sampling a sequence or using the whole sequence\"\"\"\n        seq_length = row[SEQUENCE_LENGTH_COLUMN_NAME]\n        if self._is_training:\n            cursor = random.randint(0, seq_length - 1)\n            half_window_size = int(self._max_sequence_length / 2)\n            start_index = max(0, cursor - half_window_size)\n            end_index = min(cursor + half_window_size, seq_length)\n            if start_index < end_index:\n                return start_index, end_index\n            else:\n                return 0, seq_length\n        else:\n            return 0, seq_length\n\n    def get_tf_dataset_schema(self):\n        \"\"\"\n        Combine the input and output tensorflow data schema from multiple learning objectives\n        :return: A tuple of input and output tensorflow data schema.\n        \"\"\"\n        input_dict_schemas = []\n        output_dict_schemas = []\n        for learning_objective in self._learning_objectives:\n            input_dict_schema, output_dict_schema = learning_objective.get_tf_dataset_schema()\n            input_dict_schemas.append(input_dict_schema)\n            output_dict_schemas.append(output_dict_schema)\n        return dict(ChainMap(*input_dict_schemas)), dict(ChainMap(*output_dict_schemas))", ""]}
{"filename": "data_generating/tokenizer.py", "chunked_list": ["import json\n\nfrom data_generating.parquet_data_iterator import ParquetDataIterator\nfrom typing import List, Union\n\nimport numpy as np\n\nUNUSED_TOKEN = \"[UNUSED]\"\nMASK_TOKEN = \"[MASK]\"\nOUT_OF_VOCABULARY_TOKEN = \"[OOV]\"", "MASK_TOKEN = \"[MASK]\"\nOUT_OF_VOCABULARY_TOKEN = \"[OOV]\"\n\n\nclass ConceptTokenizer:\n    \"\"\"\n    Maps concept ID strings and special tokens to integer indexes and vice versa.\n    \"\"\"\n\n    def __init__(self):\n        self._word_index = {}\n        self._index_word = {}\n        self._oov_token_index = 1\n        self._unused_token_index = 2\n        self._mask_token_index = 3\n\n    def fit_on_concept_sequences(self, parquet_data_iterator: ParquetDataIterator, column_name: str):\n        \"\"\"\n        Fit the tokenizer on the concept IDs in the given column of the given parquet data iterator.\n        Args:\n            parquet_data_iterator: A parquet data iterator.\n            column_name: The name of the column containing the concept IDs.\n        \"\"\"\n        words = set()\n        for row in parquet_data_iterator:\n            for concept_id in row[column_name]:\n                words.add(concept_id)\n        vocabulary = [OUT_OF_VOCABULARY_TOKEN, UNUSED_TOKEN, MASK_TOKEN]\n        vocabulary.extend(words)\n        self._word_index = dict(zip(vocabulary, list(range(1, len(vocabulary) + 1))))\n        self._index_word = {index: word for word, index in self._word_index.items()}\n        self._oov_token_index = self._word_index[OUT_OF_VOCABULARY_TOKEN]\n        self._unused_token_index = self._word_index[UNUSED_TOKEN]\n        self._mask_token_index = self._word_index[MASK_TOKEN]\n\n    def encode(self, concept_ids: Union[List[str], np.ndarray[str]]) -> List[int]:\n        result = []\n        for word in concept_ids:\n            idx = self._word_index.get(word)\n            if idx is None:\n                result.append(self._oov_token_index)\n            else:\n                result.append(idx)\n        return result\n\n    def decode(self, concept_token_ids: List[int]) -> List[str]:\n        return [self._index_word.get(i) for i in concept_token_ids]\n\n    def get_vocab_size(self):\n        return len(self._word_index)\n\n    def get_unused_token_id(self):\n        return self._unused_token_index\n\n    def get_mask_token_id(self):\n        return self._mask_token_index\n\n    def get_out_of_vocabulary_token_id(self):\n        return self._oov_token_index\n\n    def get_first_token_id(self):\n        return 4\n\n    def get_last_token_id(self):\n        return self.get_vocab_size() - 1\n\n    def save_to_json(self, file_name: str):\n        with open(file_name, \"w\") as f:\n            json.dump(self._word_index, f)", "\n\ndef load_from_json(file_name: str):\n    self = ConceptTokenizer()\n    with open(file_name, \"r\") as f:\n        self._word_index = json.load(f)\n    self._index_word = {index: word for word, index in self._word_index.items()}\n    self._oov_token_index = self._word_index[OUT_OF_VOCABULARY_TOKEN]\n    self._unused_token_index = self._word_index[UNUSED_TOKEN]\n    self._mask_token_index = self._word_index[MASK_TOKEN]\n    return self", ""]}
{"filename": "data_generating/learning_objective.py", "chunked_list": ["import os\nimport random\nfrom abc import ABC, abstractmethod\nfrom typing import Dict\n\nimport numpy as np\nimport pandas as pd\nimport tensorflow as tf\n\nfrom data_generating import tokenizer", "\nfrom data_generating import tokenizer\nfrom data_generating.abstract_data_generator import AbstractDataGenerator\n\n\nclass LayerInputNames:\n    \"\"\"\n    Names of the inputs to the model. These inputs are generated by the data generator using the learning objectives.\n    \"\"\"\n    LABEL = \"label\"\n    MASKED_VISIT_CONCEPTS = \"masked_visit_concepts\"\n    MASK_VISIT = \"mask_visit\"\n    VISIT_PREDICTIONS = \"visit_predictions\"\n    MASKED_CONCEPT_IDS = \"masked_concept_ids\"\n    CONCEPT_IDS = \"concept_ids\"\n    MASK = \"mask\"\n    TIME_STAMPS = \"time_stamps\"\n    VISIT_SEGMENTS = \"visit_segments\"\n    AGES = \"ages\"\n    VISIT_CONCEPT_ORDERS = \"visit_concept_orders\"\n    CONCEPT_PREDICTIONS = \"concept_predictions\"", "\n\ndef _pad_sequence(sequence: np.ndarray[any], padding_value: any, max_sequence_length: int) -> np.ndarray[any]:\n    \"\"\"\n    Pad a sequence to a given length.\n\n    Args\n        sequence: The sequence to pad.\n        max_sequence_length: The length to pad to.\n        adding_value: The value to pad with.\n    Returns\n        The padded sequence.\n    \"\"\"\n    n_to_pad = max_sequence_length - len(sequence)\n    if n_to_pad > 0:\n        sequence = np.append(sequence, [padding_value] * n_to_pad)\n    return sequence", "\n\nclass LearningObjective(ABC):\n    \"\"\"\n    A learning objective is a task that can be learned from the data. For example, predicting the next visit. This\n    class is used to generate the data for the learning objective.\n    \"\"\"\n\n    @abstractmethod\n    def initialize(self, data_generator: AbstractDataGenerator):\n        \"\"\"\n        An initializer called by the DataGenerator. Other, objective-specific initialization, can be done in __init__.\n\n        Args\n            data_generator: The calling data generator.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def process_row(self, row: pd.DataFrame, start_index: int, end_index: int) -> tuple[Dict, Dict]:\n        \"\"\"\n        Process a row to generate input and output data for the learning objective\n\n        Args\n            row: The row to process, as generated by the CDM processing.\n            start_index: Any sequence in the row should start at this index.\n            end_index: Any sequence in the row should end at this index.\n\n        Returns\n            Two dictonaries to be used by Tensorflow. The first is the input, the second is the output.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_tf_dataset_schema(self) -> tuple[Dict, Dict]:\n        \"\"\"\n        Get the schema for the input and output to the tensorflow Dataset\n\n        Returns\n            A tuple of two dictionaries. The first is the input schema, the second is the output schema.\n        \"\"\"\n        pass", "\n\nclass BertFineTuningLearningObjective(LearningObjective):\n    def initialize(self, data_generator: AbstractDataGenerator):\n        pass\n\n    def get_tf_dataset_schema(self) -> tuple[Dict, Dict]:\n        output_dict_schema = {LayerInputNames.LABEL: tf.int32}\n        return {}, output_dict_schema\n\n    def process_row(self, row: pd.DataFrame, start_index: int, end_index: int) -> tuple[Dict, Dict]:\n        output_dict = {LayerInputNames.LABEL: row.label}\n        return {}, output_dict", "\n\nclass VisitPredictionLearningObjective(LearningObjective):\n\n    def __init__(self, work_folder: str, reuse_tokenizer: bool = True):\n        \"\"\"\n        Initialization\n        Args:\n            work_folder: The folder where the tokenizer will be saved.\n            reuse_tokenizer: If true, the tokenizer will be loaded from the work_folder if it exists.\n        \"\"\"\n        self._work_folder = work_folder\n        self._visit_tokenizer = None\n        self._reuse_tokenizer = reuse_tokenizer\n        self._max_sequence_length = None\n\n    def initialize(self, data_generator: AbstractDataGenerator):\n        json_file = os.path.join(self._work_folder, \"_visit_tokenizer.json\")\n        if self._reuse_tokenizer and os.path.exists(json_file):\n            self._visit_tokenizer = tokenizer.load_from_json(json_file)\n        else:\n            self._visit_tokenizer = tokenizer.ConceptTokenizer()\n            self._visit_tokenizer.fit_on_concept_sequences(data_generator.get_parquet_data_iterator(),\n                                                           \"visit_concept_ids\")\n            self._visit_tokenizer.save_to_json(json_file)\n        self._max_sequence_length = data_generator.get_max_sequence_length()\n\n    def get_tf_dataset_schema(self):\n        input_dict_schema = {\n            LayerInputNames.MASKED_VISIT_CONCEPTS: tf.int32,\n            LayerInputNames.MASK_VISIT: tf.int32\n        }\n        output_dict_schema = {LayerInputNames.VISIT_PREDICTIONS: tf.int32}\n        return input_dict_schema, output_dict_schema\n\n    def process_row(self, row: pd.DataFrame, start_index: int, end_index: int) -> tuple[Dict, Dict]:\n        visit_concept_ids = row.visit_concept_ids[start_index:end_index]\n        visit_token_ids = self._visit_tokenizer.encode(visit_concept_ids)\n        masked_visit_token_ids, output_mask = self._mask_visit_concepts(visit_token_ids)\n        masked_visit_token_ids = _pad_sequence(sequence=masked_visit_token_ids,\n                                               padding_value=self._visit_tokenizer.get_unused_token_id(),\n                                               max_sequence_length=self._max_sequence_length)\n        visit_token_ids = _pad_sequence(sequence=masked_visit_token_ids,\n                                        padding_value=self._visit_tokenizer.get_unused_token_id(),\n                                        max_sequence_length=self._max_sequence_length)\n        visit_mask = (visit_token_ids == self._visit_tokenizer.get_unused_token_id()).astype(int)\n        combined_label = np.stack([visit_token_ids, output_mask], axis=-1)\n        input_dict = {\n            LayerInputNames.MASKED_VISIT_CONCEPTS: masked_visit_token_ids,\n            LayerInputNames.MASK_VISIT: visit_mask\n        }\n        output_dict = {LayerInputNames.VISIT_PREDICTIONS: combined_label}\n        return input_dict, output_dict\n\n    def _mask_visit_concepts(self, visit_concepts):\n        masked_visit_concepts = np.asarray(visit_concepts).copy()\n        output_mask = np.zeros((self._max_sequence_length,), dtype=int)\n        for word_pos in range(0, len(visit_concepts)):\n            if random.random() < 0.5:\n                output_mask[word_pos] = 1\n                masked_visit_concepts[word_pos] = self._visit_tokenizer.get_mask_token_id()\n        return masked_visit_concepts, output_mask", "\n\nclass MaskedLanguageModelLearningObjective(LearningObjective):\n\n    def __init__(self, work_folder: str, reuse_tokenizer: bool = True):\n        \"\"\"\n        Initialization\n        Args:\n            work_folder: The folder where the tokenizer will be saved.\n            reuse_tokenizer: If true, the tokenizer will be loaded from the work_folder if it exists.\n        \"\"\"\n        self._work_folder = work_folder\n        self._reuse_tokenizer = reuse_tokenizer\n        self._concept_tokenizer = None\n        self._max_sequence_length = None\n        self._is_training = None\n\n    def initialize(self, data_generator: AbstractDataGenerator):\n        json_file = os.path.join(self._work_folder, \"_concept_tokenizer.json\")\n        if self._reuse_tokenizer and os.path.exists(json_file):\n            self._concept_tokenizer = tokenizer.load_from_json(json_file)\n        else:\n            self._concept_tokenizer = tokenizer.ConceptTokenizer()\n            self._concept_tokenizer.fit_on_concept_sequences(data_generator.get_parquet_data_iterator(), \"concept_ids\")\n            self._concept_tokenizer.save_to_json(json_file)\n        self._max_sequence_length = data_generator.get_max_sequence_length()\n        self._is_training = data_generator.get_is_training()\n\n    def get_tf_dataset_schema(self):\n        input_dict_schema = {\n            LayerInputNames.MASKED_CONCEPT_IDS: tf.int32,\n            LayerInputNames.CONCEPT_IDS: tf.int32,\n            LayerInputNames.MASK: tf.int32,\n            LayerInputNames.TIME_STAMPS: tf.int32,\n            LayerInputNames.VISIT_SEGMENTS: tf.int32,\n            LayerInputNames.AGES: tf.int32,\n            LayerInputNames.VISIT_CONCEPT_ORDERS: tf.int32\n        }\n        output_dict_schema = {LayerInputNames.CONCEPT_PREDICTIONS: tf.int32}\n        return input_dict_schema, output_dict_schema\n\n    def process_row(self, row: pd.DataFrame, start_index: int, end_index: int) -> tuple[Dict, Dict]:\n        concept_ids = row.concept_ids[start_index:end_index]\n        visit_segments = row.visit_segments[start_index:end_index]\n        dates = row.dates[start_index:end_index]\n        ages = row.ages[start_index:end_index]\n        visit_concept_orders = row.visit_concept_orders[start_index:end_index]\n\n        token_ids = self._concept_tokenizer.encode(concept_ids)\n        # Normalize the visit_orders using the smallest visit_concept_orders\n        visit_concept_orders = visit_concept_orders - min(visit_concept_orders)\n        masked_token_ids, output_mask = self._mask_concepts(token_ids)\n\n        token_ids = _pad_sequence(sequence=token_ids,\n                                  padding_value=self._concept_tokenizer.get_unused_token_id(),\n                                  max_sequence_length=self._max_sequence_length)\n        masked_token_ids = _pad_sequence(sequence=masked_token_ids,\n                                         padding_value=self._concept_tokenizer.get_unused_token_id(),\n                                         max_sequence_length=self._max_sequence_length)\n        visit_segments = _pad_sequence(sequence=visit_segments,\n                                       padding_value=self._max_sequence_length,\n                                       max_sequence_length=self._max_sequence_length)\n        dates = _pad_sequence(sequence=dates,\n                              padding_value=self._max_sequence_length,\n                              max_sequence_length=self._max_sequence_length)\n        ages = _pad_sequence(sequence=ages,\n                             padding_value=self._max_sequence_length,\n                             max_sequence_length=self._max_sequence_length)\n        visit_concept_orders = _pad_sequence(sequence=visit_concept_orders,\n                                             padding_value=self._max_sequence_length - 1,\n                                             max_sequence_length=self._max_sequence_length)\n\n        output_mask = (token_ids == self._concept_tokenizer.get_unused_token_id()).astype(int)\n        combined_label = np.stack([token_ids, output_mask], axis=-1)\n        input_dict = {LayerInputNames.MASKED_CONCEPT_IDS: masked_token_ids,\n                      LayerInputNames.CONCEPT_IDS: token_ids,\n                      LayerInputNames.MASK: output_mask,\n                      LayerInputNames.TIME_STAMPS: dates,\n                      LayerInputNames.AGES: ages,\n                      LayerInputNames.VISIT_SEGMENTS: visit_segments,\n                      LayerInputNames.VISIT_CONCEPT_ORDERS: visit_concept_orders}\n\n        output_dict = {LayerInputNames.CONCEPT_PREDICTIONS: combined_label}\n        return input_dict, output_dict\n\n    def _mask_concepts(self, concepts):\n        masked_concepts = concepts.copy()\n        output_mask = np.zeros((self._max_sequence_length,), dtype=int)\n        if self._is_training:\n            for word_pos in range(0, len(concepts)):\n                if concepts[word_pos] == self._concept_tokenizer.get_unused_token_id():\n                    break\n\n                if random.random() < 0.15:\n                    dice = random.random()\n                    if dice < 0.8:\n                        masked_concepts[word_pos] = self._concept_tokenizer.get_mask_token_id()\n                    elif dice < 0.9:\n                        masked_concepts[word_pos] = random.randint(\n                            self._concept_tokenizer.get_first_token_id(),\n                            self._concept_tokenizer.get_last_token_id())\n                    # else: 10% of the time we just leave the token as is\n                    output_mask[word_pos] = 1\n\n        return masked_concepts, output_mask", ""]}
{"filename": "data_generating/__init__.py", "chunked_list": [""]}
