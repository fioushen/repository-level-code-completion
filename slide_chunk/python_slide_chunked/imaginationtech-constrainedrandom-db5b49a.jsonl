{"filename": "tests/__main__.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\n'''\nTest all supported features.\n\nTest for determinism within one thread, record performance.\n'''\n\nimport unittest", "\nimport unittest\nimport sys\n\nfrom argparse import ArgumentParser\n\nfrom . import testutils\n# Import all tests for unittest to run\nfrom .bits import *\nfrom .determinism import *", "from .bits import *\nfrom .determinism import *\nfrom .features.basic import *\nfrom .features.errors import *\nfrom .features.rand_list import *\nfrom .features.temp import *\n\n\ndef parse_args():\n    parser = ArgumentParser(description='Run unit tests for constrainedrandom library')\n    parser.add_argument(\n        '--length-mul',\n        type=int,\n        default=1,\n        help='Multiplier for test length, when desiring greater certainty on performance.')\n    args, extra = parser.parse_known_args()\n    return args, extra", "def parse_args():\n    parser = ArgumentParser(description='Run unit tests for constrainedrandom library')\n    parser.add_argument(\n        '--length-mul',\n        type=int,\n        default=1,\n        help='Multiplier for test length, when desiring greater certainty on performance.')\n    args, extra = parser.parse_known_args()\n    return args, extra\n", "\n\nif __name__ == \"__main__\":\n    args, extra = parse_args()\n    testutils.RandObjTestBase.TEST_LENGTH_MULTIPLIER = args.length_mul\n    # Reconstruct argv\n    argv = [sys.argv[0]] + extra\n    unittest.main(argv=argv)\n", ""]}
{"filename": "tests/bits.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\n'''\nTest bitwise operations.\n'''\n\nimport unittest\n\nfrom constrainedrandom.bits import get_bitslice, set_bitslice", "\nfrom constrainedrandom.bits import get_bitslice, set_bitslice\n\n\nclass BitsliceTests(unittest.TestCase):\n\n    def test_get_bitslice(self):\n        print(\"Testing get_bitslice...\")\n        self.assertEqual(get_bitslice(0xdeadbeef, 11, 8), 0xe)\n        self.assertEqual(get_bitslice(0xdeadbeef, 3, 0), 0xf)\n        self.assertEqual(get_bitslice(0xdeadbeef, 4, 0), 0xf)\n        self.assertEqual(get_bitslice(0xdeadbeef, 6, 1), 0x37)\n        self.assertEqual(get_bitslice(0xdeadbeef, 19, 12), 0xdb)\n        self.assertEqual(get_bitslice(0xdeadbeef, 31, 0), 0xdeadbeef)\n        self.assertEqual(get_bitslice(0xdeadbeef, 32, 0), 0xdeadbeef)\n        self.assertEqual(get_bitslice(0xdeadbeef, 0, 0), 0x1)\n        self.assertEqual(get_bitslice(0xdeadbeef, 4, 4), 0x0)\n        self.assertEqual(get_bitslice(0xdeadbeef, 34, 32), 0x0)\n        print(\"... done testing get_bitslice.\")\n\n    def test_set_bitslice(self):\n        print(\"Testing set_bitslice...\")\n        self.assertEqual(set_bitslice(0xf00, 1, 0, 2), 0xf02)\n        self.assertEqual(set_bitslice(0xf00, 3, 2, 2), 0xf08)\n        self.assertEqual(set_bitslice(0xf00, 2, 1, 2), 0xf04)\n        self.assertEqual(set_bitslice(0xf00, 11, 8, 0), 0x0)\n        self.assertEqual(set_bitslice(0xf00, 11, 8, 3), 0x300)\n        self.assertEqual(set_bitslice(0xf00, 12, 11, 3), 0x1f00)\n        self.assertEqual(set_bitslice(0, 12, 11, 3), 0x1800)\n        self.assertEqual(set_bitslice(0, 15, 0, 0xdeadbeef), 0xbeef)\n        self.assertEqual(set_bitslice(0, 31, 16, 0xdeadbeef), 0xbeef0000)\n        self.assertEqual(set_bitslice(0xcafef00d, 15, 0, 0xdeadbeef), 0xcafebeef)\n        self.assertEqual(set_bitslice(0xcafef00d, 31, 16, 0xdeadbeef), 0xbeeff00d)\n        print(\"... done testing set_bitslice.\")\n\n    def test_errors(self):\n        print(\"Testing bitslice errors...\")\n        # lo > hi\n        self.assertRaises(AssertionError, get_bitslice, 0xdeadbeef, 3, 5)\n        self.assertRaises(AssertionError, set_bitslice, 0xdeadbeef, 3, 5, 3)\n        print(\"... done testing bitslice errors.\")", ""]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/testutils.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\n''' Reusable definitions for unit testing '''\n\nimport random\nimport timeit\nimport unittest\nfrom copy import deepcopy\nfrom typing import Any, Dict, List", "from copy import deepcopy\nfrom typing import Any, Dict, List\n\nfrom constrainedrandom import RandObj, RandomizationError\n\n\ndef assertListOfDictsEqual(instance, list0, list1, msg) -> None:\n    '''\n    This is missing from unittest. It doesn't like it when two large lists of dictionaries\n    are different and compared using `assertListEqual` or `assertEqual`.\n    '''\n    for idx, (i, j) in enumerate(zip(list0, list1)):\n        instance.assertDictEqual(i, j, f\"iteration {idx} failed: \" + msg)", "\n\nclass RandObjTestBase(unittest.TestCase):\n    '''\n    Provides useful utilities for testing features of constrainedrandom.\n    Extend this class to create testcases.\n    '''\n\n    ITERATIONS = 1000\n    TEST_LENGTH_MULTIPLIER = 1\n    EXPECT_FAILURE = False\n\n    def setUp(self) -> None:\n        self.iterations = self.ITERATIONS * self.TEST_LENGTH_MULTIPLIER\n\n    def get_full_test_name(self) -> str:\n        '''\n        Returns the full path to the test being run.\n        '''\n        return f'{self.__class__.__module__}.{self.__class__.__name__}.{self._testMethodName}'\n\n    def get_randobj(self, *args) -> RandObj:\n        '''\n        Returns an instance of a `RandObj` for this problem, based\n        on a given seed.\n        '''\n        pass\n\n    def check(self, results) -> None:\n        '''\n        Checks the results of randomization are correct,\n        according to the defined problem.\n        '''\n        pass\n\n    def get_tmp_constraints(self) -> List[Any]:\n        '''\n        Returns temporary constraints for the problem, if any.\n        '''\n        return None\n\n    def get_tmp_values(self) -> Dict[str, Any]:\n        '''\n        Returns temporary values for the problem, if any.\n        '''\n        return None\n\n    def tmp_check(self, results) -> None:\n        '''\n        Checks the results of randomization are correct,\n        according to the defined problem plus any\n        temporary constraints/values.\n        '''\n        pass\n\n    def randomize_and_time(self, randobj, iterations, tmp_constraints=None, tmp_values=None) -> List[Dict[str, Any]]:\n        '''\n        Call randobj.randomize() iterations times, time it, print performance stats,\n        return the results.\n        '''\n        results = []\n        time_taken = 0\n        for _ in range(iterations):\n            start_time = timeit.default_timer()\n            if tmp_constraints is not None or tmp_values is not None:\n                randobj.randomize(with_constraints=tmp_constraints, with_values=tmp_values)\n            else:\n                randobj.randomize()\n            end_time = timeit.default_timer()\n            time_taken += end_time - start_time\n            # Extract the results\n            results.append(randobj.get_results())\n        hz = iterations/time_taken\n        print(f'{self.get_full_test_name()} took {time_taken:.4g}s for {iterations} iterations ({hz:.1f}Hz)')\n        return results\n\n    def randomize_and_check_result(\n        self,\n        randobj,\n        expected_results,\n        do_tmp_checks,\n        tmp_constraints,\n        tmp_values,\n        expected_tmp_results,\n        expected_post_tmp_results,\n        expected_add_results,\n        add_tmp_constraints,\n    ) -> None:\n        '''\n        Code to randomize a randobj and check its results against expected\n        results.\n        '''\n        if self.EXPECT_FAILURE:\n            self.assertRaises(RandomizationError, randobj.randomize)\n        else:\n            results = self.randomize_and_time(randobj, self.iterations)\n            assertListOfDictsEqual(self, expected_results, results, \"Non-determinism detected, results were not equal\")\n            if do_tmp_checks:\n                # Check applying temporary constraints is also deterministic\n                tmp_results = self.randomize_and_time(randobj, self.iterations, tmp_constraints, tmp_values)\n                assertListOfDictsEqual(\n                    self,\n                    expected_tmp_results,\n                    tmp_results,\n                    \"Non-determinism detected, results were not equal with temp constraints\"\n                )\n                # Check temporary constraints don't break base randomization determinism\n                post_tmp_results = self.randomize_and_time(randobj, self.iterations)\n                assertListOfDictsEqual(\n                    self,\n                    expected_post_tmp_results,\n                    post_tmp_results,\n                    \"Non-determinism detected, results were not equal after temp constraints\"\n                )\n                # Add temporary constraints permanently, see what happens\n                if add_tmp_constraints and tmp_constraints is not None:\n                    for constr, vars in tmp_constraints:\n                        randobj.add_constraint(constr, vars)\n                    add_results = self.randomize_and_time(randobj, self.iterations, tmp_values=tmp_values)\n                    assertListOfDictsEqual(\n                        self,\n                        expected_add_results,\n                        add_results,\n                        \"Non-determinism detected, results were not equal after constraints added\"\n                    )\n\n    def test_randobj(self) -> None:\n        '''\n        Reusable test function to randomize a RandObj for a number of iterations and perform checks.\n\n        Tests functionality based on `self.check`.\n        Reports performance stats.\n        Tests determinism.\n        Tests use of temporary constraints and values.\n        '''\n        tmp_constraints = self.get_tmp_constraints()\n        tmp_values = self.get_tmp_values()\n        do_tmp_checks = tmp_constraints is not None or tmp_values is not None\n        results = None\n        tmp_results = None\n        post_tmp_results = None\n        add_results = None\n\n        # Test with seed 0\n        r = random.Random(0)\n        randobj = self.get_randobj(r)\n        # Take a copy of the randobj for use later\n        randobj_copy = deepcopy(randobj)\n        if self.EXPECT_FAILURE:\n            self.assertRaises(RandomizationError, randobj.randomize)\n        else:\n            results = self.randomize_and_time(randobj, self.iterations)\n            self.check(results)\n            if do_tmp_checks:\n                # Check when applying temporary constraints\n                tmp_results = self.randomize_and_time(randobj, self.iterations, tmp_constraints, tmp_values)\n                self.tmp_check(tmp_results)\n                # Check temporary constraints don't break base randomization\n                post_tmp_results = self.randomize_and_time(randobj, self.iterations)\n                self.check(post_tmp_results)\n                # Add temporary constraints permanently, see what happens\n                if tmp_constraints is not None:\n                    for constr, vars in tmp_constraints:\n                        randobj.add_constraint(constr, vars)\n                    add_results = self.randomize_and_time(randobj, self.iterations, tmp_values=tmp_values)\n                    self.tmp_check(add_results)\n\n        # Test again with seed 0, ensuring results are the same.\n        r0 = random.Random(0)\n        randobj0 = self.get_randobj(r0)\n        self.randomize_and_check_result(\n            randobj0,\n            results,\n            do_tmp_checks,\n            tmp_constraints,\n            tmp_values,\n            tmp_results,\n            post_tmp_results,\n            add_results,\n            add_tmp_constraints=True,\n        )\n\n        # Also test the copy we took earlier.\n        self.randomize_and_check_result(\n            randobj_copy,\n            results,\n            do_tmp_checks,\n            tmp_constraints,\n            tmp_values,\n            tmp_results,\n            post_tmp_results,\n            add_results,\n            add_tmp_constraints=True,\n        )\n\n        # Test with seed 1, ensuring results are different\n        r1 = random.Random(1)\n        randobj1 = self.get_randobj(r1)\n        if self.EXPECT_FAILURE:\n            self.assertRaises(RandomizationError, randobj1.randomize)\n        else:\n            results1 = self.randomize_and_time(randobj1, self.iterations)\n            self.check(results1)\n            self.assertNotEqual(results, results1, \"Results were the same for two different seeds, check testcase.\")\n            if do_tmp_checks:\n                # Check results are also different when applying temporary constraints\n                tmp_results1 = self.randomize_and_time(randobj1, self.iterations, tmp_constraints, tmp_values)\n                self.tmp_check(tmp_results1)\n                self.assertNotEqual(tmp_results, tmp_results1,\n                                    \"Results were the same for two different seeds, check testcase.\")\n\n        # Test using global seeding, ensuring results are the same\n        # Don't add temp constraints this time, so that we can test this object again.\n        random.seed(0)\n        randobj0_global = self.get_randobj()\n        self.randomize_and_check_result(\n            randobj0_global,\n            results,\n            do_tmp_checks,\n            tmp_constraints,\n            tmp_values,\n            tmp_results,\n            post_tmp_results,\n            add_results,\n            add_tmp_constraints=False,\n        )\n\n        # Re-test the the globally-seeded object\n        # Must re-seed the global random module to ensure repeatability.\n        random.seed(0)\n        self.randomize_and_check_result(\n            randobj0_global,\n            results,\n            do_tmp_checks,\n            tmp_constraints,\n            tmp_values,\n            tmp_results,\n            post_tmp_results,\n            add_results,\n            add_tmp_constraints=True,\n        )\n\n        # TODO: Fix interaction between global random module and deepcopy.\n        # Details:\n        # There is an issue around copying an object that relies on the\n        # global random object - the state of any copied object is tied to\n        # its original.\n        # Having spent a lot of time debugging this issue, it is still very\n        # difficult to understand.\n        # Each individual copied RandObj instance points to a new random.Random\n        # instance, which shares state with the global module. It appears then\n        # in some instances that the object uses the global value in the random\n        # module, and in others it uses the copied one, meaning the state\n        # diverges.\n        # Right now, all I can conclude is it would take a lot of work to\n        # fully debug it, and it can be worked around by passing objects a\n        # seeded random.Random if the user desires reproducible objects.\n\n        # TODO: Make testing of copy more thorough when above issue fixed.\n        # Take a copy, to show that we can. Its behaviour can't be guaranteed\n        # to be deterministic w.r.t. randobj0_global due to issues around\n        # deepcopy interacting with the global random module.\n        # So, just test it can randomize.\n        randobj0_global_copy = deepcopy(randobj0_global)\n        if self.EXPECT_FAILURE:\n            self.assertRaises(RandomizationError, randobj0_global_copy.randomize)\n        else:\n            # Don't check results. Checks may fail due to the interaction\n            # between deepcopy and global random. E.g. if we check that temp\n            # constraints are not followed when not supplied, they may\n            # be due to the interaction between random and deepcopy.\n            # This just ensures it doesn't crash.\n            self.randomize_and_time(randobj0_global_copy, self.iterations)\n            self.randomize_and_time(randobj0_global_copy, self.iterations, tmp_constraints, tmp_values)", ""]}
{"filename": "tests/determinism.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\n'''\nTest determinism between processes.\n'''\n\nimport os\nimport subprocess\nimport timeit", "import subprocess\nimport timeit\nimport unittest\n\n\nclass DeterminismTest(unittest.TestCase):\n    '''\n    Test determinism between processes when PYTHONHASHSEED changes\n    between runs.\n\n    PYTHONHASHSEED controls the `hash` function in Python, and so\n    affects iteration order of dictionaries and sets.\n    '''\n\n    def test_determinism(self):\n        # Create a program that does some determinstic randomization.\n        # Indendation here is poor but arguably more readable than doing\n        # a string per line.\n        program = '''\nimport random\nfrom constrainedrandom import RandObj\n\nrandom.seed(0)\nr = RandObj()\n\nr.add_rand_var('a', domain=range(100))\nr.add_rand_var('b', domain=range(100))\nr.add_rand_var('c', domain=range(100))\n\ndef sum_lt50(a, b, c):\n    return a + b + c < 50\nr.add_constraint(sum_lt50, ('a', 'b', 'c'))\n\nresults = []\nfor _ in range(100):\n    r.randomize()\n    results.append(r.get_results())\n\nprint(results)\nexit(0)\n'''\n\n        cmd = ['python3', '-c', program]\n        # Capture the current env\n        env = dict(os.environ)\n        results = []\n        print(\"Testing thread-level determinism...\")\n        start_time = timeit.default_timer()\n        for hashseed in range(10):\n            # Vary the PYTHONHASHSEED to introduce non-determinism in set/dict ordering\n            env['PYTHONHASHSEED'] = str(hashseed)\n            process_result = subprocess.run(cmd, env=env, capture_output=True, check=True)\n            # Result is a string\n            result = process_result.stdout\n            if len(results) > 0:\n                # Check these results are the same as the rest\n                self.assertEqual(results[-1], result, \"Results were not deterministic when PYTHONHASHSEED changes.\")\n            results.append(result)\n        end_time = timeit.default_timer()\n        total_time = end_time - start_time\n        print(f\"... done testing thread-level determinism. Took {total_time:.4g}s.\")", ""]}
{"filename": "tests/features/errors.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\n'''\nTest error cases.\n'''\n\nfrom random import Random\n\nfrom constrainedrandom import RandObj, RandomizationError", "\nfrom constrainedrandom import RandObj, RandomizationError\n\nfrom .basic import MultiSum\nfrom .. import testutils\n\n\nclass ImpossibleThorough(MultiSum):\n    '''\n    Test the thorough solver for a problem that will always fail.\n\n    The thorough solver almost always converges, so it's very\n    hard to construct a problem 'too hard' for it.\n    Instead, make it impossible and only enable the thorough\n    solver.\n    '''\n\n    EXPECT_FAILURE = True\n\n    def get_randobj(self, *args):\n        randobj = super().get_randobj(*args)\n        # Only use thorough solver.\n        randobj.set_solver_mode(naive=False, sparse=False)\n        # Make problem impossible so that numbers can't sum to 41.\n        def mod_2(z):\n            return z % 2 == 0\n        randobj.add_constraint(mod_2, ('x',))\n        randobj.add_constraint(mod_2, ('y',))\n        randobj.add_constraint(mod_2, ('z',))\n        # Setting max domain size to 1 makes this run a bit quicker.\n        randobj._max_domain_size = 1\n        return randobj", "\n\nclass ImpossibleOneVar(testutils.RandObjTestBase):\n    '''\n    Test an impossible constraint problem with one variable.\n    '''\n\n    def get_randobj(self, *args):\n        randobj = RandObj(*args)\n        def eq_zero(x):\n            return x == 0\n        randobj.add_rand_var('a', domain=[1,], constraints=[eq_zero,])\n        return randobj\n\n    def test_randobj(self):\n        # Override the whole test function, because unsolvable\n        # simple single variables fail on creation, rather\n        # than when randomize is called.\n        self.assertRaises(RandomizationError, self.get_randobj, 0)\n        self.assertRaises(RandomizationError, self.get_randobj, 1)", "\n\nclass ImpossibleComplexVar(testutils.RandObjTestBase):\n    '''\n    Test an impossible constraint problem with one variable, where\n    the variable state space is too large to fail on creation.\n    '''\n\n    EXPECT_FAILURE = True\n\n    def get_randobj(self, *args):\n        randobj = RandObj(*args)\n        def eq_minus_one(x):\n            return x == -1\n        randobj.add_rand_var('a', bits=64, constraints=[eq_minus_one,])\n        return randobj", "\n\nclass ImpossibleMultiVar(testutils.RandObjTestBase):\n    '''\n    Test an impossible constraint problem with multiple variables.\n    '''\n\n    EXPECT_FAILURE = True\n\n    def get_randobj(self, *args):\n        randobj = RandObj(*args)\n        def lt_5(x):\n            return x < 5\n        randobj.add_rand_var('a', domain=range(10), constraints=[lt_5,])\n        randobj.add_rand_var('b', domain=range(10), constraints=[lt_5,])\n        def sum_gt_10(x, y):\n            return x + y > 10\n        randobj.add_constraint(sum_gt_10, ('a', 'b'))\n        return randobj", ""]}
{"filename": "tests/features/__init__.py", "chunked_list": [""]}
{"filename": "tests/features/rand_list.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\n'''\nTest random lists.\n'''\n\nfrom random import Random\n\nfrom constrainedrandom import RandObj", "\nfrom constrainedrandom import RandObj\nfrom constrainedrandom.utils import unique\nfrom .. import testutils\n\n\ndef plus_or_minus_one(listvar):\n    val = listvar[0]\n    for nxt_val in listvar[1:]:\n        if nxt_val == val + 1 or nxt_val == val - 1:\n            val = nxt_val\n            continue\n        return False\n    return True", "\n\ndef sum_0(listvar):\n    return sum(listvar) == 0\n\n\nclass RandList(testutils.RandObjTestBase):\n    '''\n    Test a randomized list.\n    '''\n\n    ITERATIONS = 1000\n    LENGTH = 10\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        def not_7(x):\n            return x != 7\n        r.add_rand_var('listvar', domain=range(10), constraints=[not_7], length=self.LENGTH)\n        return r\n\n    def check(self, results):\n        nonzero_seen = False\n        for result in results:\n            self.assertIsInstance(result['listvar'], list, \"Var with length > 0 wasn't a list\")\n            self.assertEqual(len(result['listvar']), self.LENGTH, \"Length incorrect\")\n            for x in result['listvar']:\n                self.assertIn(x, range(10), \"Value was wrongly randomized\")\n                self.assertNotEqual(x, 7, \"Scalar constraint not respected\")\n                if x != 0:\n                    nonzero_seen = True\n        self.assertTrue(nonzero_seen, \"All values were zero\")", "\n\nclass RandListConstrained(testutils.RandObjTestBase):\n    '''\n    Test a randomized list with a basic list constraint.\n    Keep it simple enough that we use the CSP list solver.\n    '''\n\n    ITERATIONS = 1000\n    LENGTH = 2\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        def not_7(x):\n            return x != 7\n        r.add_rand_var('listvar', domain=range(10), constraints=[not_7], length=self.LENGTH)\n        def sum_lt_val(listvar):\n            return sum(listvar) < (6 * self.LENGTH)\n        r.add_constraint(sum_lt_val, ('listvar',))\n        return r\n\n    def check(self, results):\n        nonzero_seen = False\n        for result in results:\n            self.assertIsInstance(result['listvar'], list, \"Var with length > 0 wasn't a list\")\n            self.assertEqual(len(result['listvar']), self.LENGTH, \"Length incorrect\")\n            self.assertLess(sum(result['listvar']), (8 * self.LENGTH), \"List constraint not followed\")\n            for x in result['listvar']:\n                self.assertIn(x, range(10), \"Value was wrongly randomized\")\n                self.assertNotEqual(x, 7, \"Scalar constraint not respected\")\n                if x != 0:\n                    nonzero_seen = True\n        self.assertTrue(nonzero_seen, \"All values were zero\")", "\n\nclass RandListConstrainedHard(RandListConstrained):\n    '''\n    Test a randomized list with a basic list constraint.\n    Make it sufficiently complex that it requires the random solver,\n    do this by increasing the length.\n    '''\n\n    ITERATIONS = 1000\n    LENGTH = 10", "\n\nclass RandListConstrainedVeryHard(testutils.RandObjTestBase):\n    '''\n    Test a randomized list with a difficult constraint on the values in the list.\n    '''\n\n    ITERATIONS = 10\n    LENGTH = 10\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        r.add_rand_var('listvar', domain=range(10), length=self.LENGTH, list_constraints=(plus_or_minus_one,))\n        return r\n\n    def check(self, results):\n        for result in results:\n            self.assertIsInstance(result['listvar'], list, \"Var with length > 0 wasn't a list\")\n            self.assertEqual(len(result['listvar']), self.LENGTH, \"Length incorrect\")\n            prev = None\n            for x in result['listvar']:\n                self.assertIn(x, range(10), \"Value was wrongly randomized\")\n                if prev is not None:\n                    self.assertTrue(x == prev + 1 or x == prev - 1, \"list constraint not followed\")\n                prev = x", "\n\nclass RandListMultivar(testutils.RandObjTestBase):\n    '''\n    Test a randomized list with constraints on the values in the list,\n    also with constraints over multiple variables.\n    '''\n\n    ITERATIONS = 10\n    LENGTH = 10\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        r.add_rand_var('listvar', domain=range(10), length=self.LENGTH, list_constraints=(plus_or_minus_one,))\n        # Give x slightly larger range so it is sometimes impossible\n        r.add_rand_var('x', domain=range(11), order=1)\n        def in_list(x, listvar):\n            return x in listvar\n        r.add_constraint(in_list, ('x', 'listvar'))\n        return r\n\n    def check(self, results):\n        for result in results:\n            self.assertIsInstance(result['listvar'], list, \"Var with length > 0 wasn't a list\")\n            self.assertEqual(len(result['listvar']), self.LENGTH, \"Length incorrect\")\n            prev = None\n            for l in result['listvar']:\n                self.assertIn(l, range(10), \"Value was wrongly randomized\")\n                if prev is not None:\n                    self.assertTrue(l == prev + 1 or l == prev - 1, \"list constraint not followed\")\n                prev = l\n            self.assertIn(result['x'], result['listvar'])", "\n\nclass RandListUnique(testutils.RandObjTestBase):\n    '''\n    Test that the unique constraint works on a random list.\n    '''\n\n    ITERATIONS = 100\n    LENGTH = 10\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        r.add_rand_var(\n            'listvar',\n            domain=range(10),\n            length=self.LENGTH,\n            list_constraints=(unique,),\n            disable_naive_list_solver=True,\n        )\n        return r\n\n    def check(self, results):\n        for result in results:\n            self.assertIsInstance(result['listvar'], list, \"Var with length > 0 wasn't a list\")\n            self.assertEqual(len(result['listvar']), self.LENGTH, \"Length incorrect\")\n            for x_idx, x in enumerate(result['listvar']):\n                self.assertIn(x, range(10), \"Value was wrongly randomized\")\n                for y_idx, y in enumerate(result['listvar']):\n                    if x_idx != y_idx:\n                        self.assertNotEqual(x, y, \"List elements were not unique\")", "\n\nclass RandListTempConstraints(testutils.RandObjTestBase):\n    '''\n    Test a randomized list with temporary constraints.\n    '''\n\n    ITERATIONS = 100\n    LENGTH = 10\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        def not_4(x):\n            return x != 4\n        def not_too_many_zeros(listvar):\n            zeros = [x for x in listvar if x == 0]\n            return len(zeros) < 5\n        r.add_rand_var('listvar', domain=range(10), constraints=[not_4],\n            length=self.LENGTH, list_constraints=[not_too_many_zeros])\n        return r\n\n    def check(self, results):\n        for result in results:\n            self.assertIsInstance(result['listvar'], list, \"Var with length > 0 wasn't a list\")\n            self.assertEqual(len(result['listvar']), self.LENGTH, \"Length incorrect\")\n            zeros = 0\n            for x in result['listvar']:\n                self.assertIn(x, range(10), \"Value was wrongly randomized\")\n                self.assertNotEqual(x, 4, \"Scalar constraint not respected\")\n                if x == 0:\n                    zeros += 1\n            self.assertLess(zeros, 5, \"List constraint not respected\")\n\n    def get_tmp_constraints(self):\n        def temp_constr(listvar):\n            for x in listvar:\n                if x == 5:\n                    return False\n            return True\n        return [(temp_constr, ('listvar',))]\n\n    def tmp_check(self, results):\n        self.check(results)\n        for result in results:\n            for x in result['listvar']:\n                self.assertNotEqual(x, 5, \"Temp constraint not respected\")", "\n\nclass RandListSumZero(testutils.RandObjTestBase):\n\n    ITERATIONS = 100\n\n    def get_randobj(self, *args):\n        randobj = RandObj(*args)\n        randobj.add_rand_var('listvar', length=10, domain=range(-10, 11))\n        randobj.add_constraint(sum_0, ('listvar',))\n        return randobj\n\n    def check(self, results):\n        nonzero_seen = False\n        for result in results:\n            sum = 0\n            listvar = result['listvar']\n            self.assertIsInstance(listvar, list, \"Returned non-list\")\n            self.assertEqual(len(listvar), 10, \"Length incorrect\")\n            for val in listvar:\n                if val != 0:\n                    nonzero_seen = True\n                sum += val\n            self.assertEqual(sum, 0, \"Sum must be zero but wasn't.\")\n        self.assertTrue(nonzero_seen, \"Should not always solve this problem with a list full of zeroes.\")", "\n\nclass RandListSparse(testutils.RandObjTestBase):\n    '''\n    Test a randomized list with the sparse solver.\n    Make it hard enough to fail with a depth-first search.\n    '''\n\n    ITERATIONS = 1\n\n    def get_randobj(self, *args):\n        randobj = RandObj(*args)\n        randobj.set_solver_mode(naive=False, sparse=True, thorough=False)\n        randobj.add_rand_var('listvar1', length=10, domain=range(-10, 11))\n        randobj.add_constraint(sum_0, ('listvar1',))\n        randobj.add_rand_var('listvar2', length=3, domain=range(-10, 11), list_constraints=[unique])\n        def not_in_list(listvar1, listvar2):\n            for x in listvar2:\n                if x in listvar1:\n                    return False\n            return True\n        randobj.add_constraint(not_in_list, ('listvar1', 'listvar2'))\n        randobj.add_rand_var('listvar3', length=2, domain=range(-10,11))\n        def awful_constraint(listvar1, listvar2, listvar3):\n            total = 1\n            for val in listvar1:\n                if val != 0:\n                    total = total * val\n            for val in listvar2:\n                if val != 0:\n                    total = total * val\n            for val in listvar3:\n                if val != 0:\n                    total = total * val\n            return total % 3 == 1\n        randobj.add_constraint(awful_constraint, ('listvar1', 'listvar2', 'listvar3'))\n\n        return randobj\n\n    def check(self, results):\n        nonzero_seen = False\n        for result in results:\n            sum = 0\n            product = 1\n            listvar1 = result['listvar1']\n            listvar2 = result['listvar2']\n            listvar3 = result['listvar3']\n            self.assertIsInstance(listvar1, list, \"Returned non-list\")\n            self.assertEqual(len(listvar1), 10, \"Length incorrect\")\n            self.assertIsInstance(listvar2, list, \"Returned non-list\")\n            self.assertEqual(len(listvar2), 3, \"Length incorrect\")\n            self.assertIsInstance(listvar3, list, \"Returned non-list\")\n            self.assertEqual(len(listvar3), 2, \"Length incorrect\")\n            for val in listvar1:\n                if val != 0:\n                    nonzero_seen = True\n                    product = product * val\n                sum += val\n                self.assertNotIn(val, listvar2, \"Lists must be disjoint\")\n            for val in listvar2:\n                if val != 0:\n                    product = product * val\n            for val in listvar3:\n                if val != 0:\n                    product = product * val\n            self.assertEqual(sum, 0, \"Sum must be zero but wasn't.\")\n            self.assertEqual(product % 3, 1, \"Product mod 3 wasn't 1.\")\n        self.assertTrue(nonzero_seen, \"Should not always solve this problem with a list full of zeroes.\")", ""]}
{"filename": "tests/features/basic.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\n'''\nTest basic features.\n'''\n\nfrom enum import Enum, IntEnum\nfrom random import Random\n", "from random import Random\n\nfrom constrainedrandom import RandObj\nfrom examples.ldinstr import ldInstr\nfrom .. import testutils\n\n\nclass BasicFeatures(testutils.RandObjTestBase):\n    '''\n    Test all basic single random variable features.\n    '''\n\n    ITERATIONS = 10000\n\n    class MyEnum(Enum):\n        A = 'a'\n        B = 'b'\n\n    class MyIntEnum(IntEnum):\n        ONE = 1\n        TWO = 2\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        r.add_rand_var(\"foo\", domain=range(100))\n        r.add_rand_var(\"bar\", domain=(1,2,3,))\n        r.add_rand_var(\"baz\", bits=4)\n        r.add_rand_var(\"bob\", domain={0: 9, 1: 1})\n        def not_3(foo):\n            return foo != 3\n        r.add_rand_var(\"dan\", domain=range(5), constraints=(not_3,))\n        def custom_fn(arg):\n            return arg + 1\n        r.add_rand_var(\"joe\", fn=custom_fn, args=(1,))\n        r.add_rand_var(\"enum\", domain=self.MyEnum)\n        r.add_rand_var(\"int_enum\", domain=self.MyIntEnum)\n        return r\n\n    def check(self, results):\n        for result in results:\n            self.assertLessEqual(0, result['foo'])\n            self.assertLess(result['foo'], 100)\n            self.assertIn(result['bar'], (1,2,3,))\n            self.assertLessEqual(0, result['baz'])\n            self.assertLess(result['baz'], (1 << 4))\n            self.assertIn(result['bob'], (0,1))\n            self.assertIn(result['dan'], (0,1,2,4))\n            self.assertEqual(result['joe'], 2)\n            self.assertIn(result['enum'], (self.MyEnum.A, self.MyEnum.B))\n            self.assertIn(result['int_enum'], (1, 2))", "\n\nclass BasicSparse(BasicFeatures):\n    '''\n    Test basic features, only with sparse constraint solver.\n    '''\n\n    def get_randobj(self, *args):\n        randobj = super().get_randobj(*args)\n        randobj.set_solver_mode(naive=False, sparse=True, thorough=False)\n        return randobj", "\n\nclass BasicThorough(BasicFeatures):\n    '''\n    Test basic features, only with thorough constraint solver.\n    '''\n\n    ITERATIONS = 1000\n\n    def get_randobj(self, *args):\n        randobj = super().get_randobj(*args)\n        randobj.set_solver_mode(naive=False, sparse=False, thorough=True)\n        return randobj", "\n\nclass MultiBasic(testutils.RandObjTestBase):\n    '''\n    Test a basic multi-variable constraint (easy to randomly fulfill the constraint).\n    '''\n\n    ITERATIONS = 100\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        r.add_rand_var(\"a\", domain=range(10))\n        r.add_rand_var(\"b\", domain=range(10))\n        r.add_rand_var(\"c\", domain=range(5,10))\n        def abc(a, b, c):\n            return a < b < c\n        r.add_constraint(abc, (\"a\",\"b\",\"c\"))\n        return r\n\n    def check(self, results):\n        for result in results:\n            self.assertLess(result['a'], result['b'], f'Check failed for {result=}')\n            self.assertLess(result['b'], result['c'], f'Check failed for {result=}')", "\n\nclass MultiPlusOne(testutils.RandObjTestBase):\n    '''\n    Test a slightly trickier multi-variable constraint (much less likely to just randomly get it right).\n    '''\n\n    ITERATIONS = 100\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        # Very unlikely (1/100) to solve the problem naively, just skip to applying constraints.\n        r.set_solver_mode(naive=False)\n        r.add_rand_var(\"x\", domain=range(100), order=0)\n        r.add_rand_var(\"y\", domain=range(100), order=1)\n        def plus_one(x, y):\n            return y == x + 1\n        r.add_constraint(plus_one, (\"x\", \"y\"))\n        return r\n\n    def check(self, results):\n        for result in results:\n            self.assertEqual(result['y'], result['x'] + 1, f'Check failed for {result=}')", "\n\nclass MultiSum(testutils.RandObjTestBase):\n    '''\n    Test a much trickier multi-variable constraint.\n    '''\n\n    ITERATIONS = 100\n\n    def get_randobj(self, *args):\n        '''\n        Very difficult problem to solve naively, to force the solver\n        into using MultiVarProblem. Used by several tests.\n        '''\n        r = RandObj(*args)\n        # Very unlikely (1/200^3) to solve the problem naively, just skip to applying constraints.\n        r.set_solver_mode(naive=False)\n        def nonzero(x):\n            return x != 0\n        r.add_rand_var(\"x\", domain=range(-100, 100), order=0, constraints=(nonzero,))\n        r.add_rand_var(\"y\", domain=range(-100, 100), order=1, constraints=(nonzero,))\n        r.add_rand_var(\"z\", domain=range(-100, 100), order=1, constraints=(nonzero,))\n        def sum_41(x, y, z):\n            return x + y + z == 41\n        r.add_constraint(sum_41, (\"x\", \"y\", \"z\"))\n        return r\n\n    def check(self, results):\n        for result in results:\n            self.assertEqual(result['x'] + result['y'] + result['z'], 41, f'Check failed for {result=}')\n            self.assertNotEqual(result['x'], 0, f'Check failed for {result=}')", "\n\nclass MultiOrder(testutils.RandObjTestBase):\n    '''\n    Test a problem that benefits greatly from being solved in a certain order.\n    '''\n\n    ITERATIONS = 100\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        r.add_rand_var(\"a\", domain=range(100), order=0)\n        r.add_rand_var(\"b\", domain=range(100), order=1)\n        def mul_lt1000(a, b):\n            return a * b < 1000\n        r.add_constraint(mul_lt1000, ('a', 'b'))\n        r.add_rand_var(\"c\", domain=range(100), order=2)\n        def sum_lt100(a, b, c):\n            return a + b + c < 100\n        r.add_constraint(sum_lt100, ('a', 'b', 'c'))\n        return r\n\n    def check(self, results):\n        for result in results:\n            self.assertLess(result['a'] * result['b'], 1000, f'Check failed for {result=}')\n            self.assertLess(result['a'] + result['b'] + result['c'], 100, f'Check failed for {result=}')", "\n\nclass Dist(testutils.RandObjTestBase):\n    '''\n    Test a distribution.\n    '''\n\n    ITERATIONS = 10000\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        r.add_rand_var(\"dist\", domain={0: 25, 1 : 25, range(2,5): 50})\n        return r\n\n    def check(self, results):\n        count_zeroes = 0\n        count_ones = 0\n        count_two_plus = 0\n        for result in results:\n            val = result['dist']\n            if val == 0:\n                count_zeroes += 1\n            elif val == 1:\n                count_ones += 1\n            elif 2 <= val < 5:\n                count_two_plus += 1\n            else:\n                self.fail(\"too high!\")\n        # Check it's roughly the right distribution.\n        # Work out what the distribution should be,\n        modified_iterations = self.ITERATIONS * self.TEST_LENGTH_MULTIPLIER\n        quarter = modified_iterations // 4\n        half = modified_iterations // 2\n        # Allow 10% leeway,\n        q_delta = quarter // 10\n        h_delta = half // 10\n        quarter_range = range(quarter - q_delta, quarter + q_delta + 1)\n        half_range = range(half - h_delta, half + h_delta + 1)\n        self.assertIn(count_zeroes, quarter_range)\n        self.assertIn(count_ones, quarter_range)\n        self.assertIn(count_two_plus, half_range)", "\n\nclass Instr(testutils.RandObjTestBase):\n    '''\n    Test something that looks like an instruction opcode, one of the desired\n    use cases for this library.\n    '''\n\n    ITERATIONS = 1000\n\n    def get_randobj(self, *args):\n        ld_instr = ldInstr(*args)\n        return ld_instr\n\n    def check(self, results):\n        for result in results:\n            if result['wb']:\n                self.assertNotEqual(result['src0'], result['dst0'])\n            address = result['src0_value'] + result['imm0']\n            self.assertLess(address, 0xffffffff)\n            self.assertEqual(address & 3, 0)", "\n\nclass ThoroughMultiSum(MultiSum):\n    '''\n    Test the thorough solver for a hard problem.\n    '''\n\n    ITERATIONS = 5\n\n    def get_randobj(self, *args):\n        randobj = super().get_randobj(*args)\n        # Set max_iterations to 1 to ensure thorough solver is used.\n        randobj._max_iterations = 1\n        # Set a smaller max domain size to speed thigns up a bit.\n        randobj._max_domain_size = 50\n        return randobj", ""]}
{"filename": "tests/features/temp.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\n'''\nTest temporary constraints and values.\n'''\n\nfrom random import Random\n\nfrom constrainedrandom import RandObj", "\nfrom constrainedrandom import RandObj\nfrom . import basic\nfrom .. import testutils\n\n\nclass TempConstraint(testutils.RandObjTestBase):\n    '''\n    Test using a simple temporary constraint.\n    '''\n\n    ITERATIONS = 1000\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        r.add_rand_var('a', domain=range(10))\n        return r\n\n    def check(self, results):\n        seen_gt_4 = False\n        for result in results:\n            self.assertIn(result['a'], range(10))\n            if result['a'] >= 5:\n                seen_gt_4 = True\n        self.assertTrue(seen_gt_4, \"Temporary constraint followed when not given\")\n\n    def get_tmp_constraints(self):\n        def tmp_constraint(a):\n            return a < 5\n        return [(tmp_constraint, ('a',))]\n\n    def tmp_check(self, results):\n        for result in results:\n            self.assertIn(result['a'], range(5))", "\n\nclass TempMultiConstraint(testutils.RandObjTestBase):\n    '''\n    Test using a temporary multi-variable constraint.\n    '''\n\n    ITERATIONS = 1000\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        r.add_rand_var('a', domain=range(10))\n        r.add_rand_var('b', domain=range(100))\n        return r\n\n    def check(self, results):\n        seen_tmp_constraint_false = False\n        for result in results:\n            self.assertIn(result['a'], range(10))\n            self.assertIn(result['b'], range(100))\n            if result['a'] * result['b'] >= 200 and result['a'] >= 5:\n                seen_tmp_constraint_false = True\n        self.assertTrue(seen_tmp_constraint_false, \"Temporary constraint followed when not given\")\n\n    def get_tmp_constraints(self):\n        def a_mul_b_lt_200(a, b):\n            return a * b < 200\n        return [(a_mul_b_lt_200, ('a', 'b'))]\n\n    def tmp_check(self, results):\n        for result in results:\n            # Do normal checks\n            self.assertIn(result['a'], range(10))\n            self.assertIn(result['b'], range(100))\n            # Also check the temp constraint is followed\n            self.assertLess(result['a'] * result['b'], 200)", "\n\nclass MixedTempConstraints(testutils.RandObjTestBase):\n    '''\n    Test using a temporary multi-variable constraint, with a single-variable constraint.\n    '''\n\n    ITERATIONS = 1000\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        r.add_rand_var('a', domain=range(10))\n        r.add_rand_var('b', domain=range(100))\n        return r\n\n    def check(self, results):\n        seen_tmp_constraint_false = False\n        for result in results:\n            self.assertIn(result['a'], range(10))\n            self.assertIn(result['b'], range(100))\n            if result['a'] * result['b'] >= 200 and result['a'] >= 5:\n                seen_tmp_constraint_false = True\n        self.assertTrue(seen_tmp_constraint_false, \"Temporary constraint followed when not given\")\n\n    def tmp_check(self, results):\n        for result in results:\n            # Do normal checks\n            self.assertIn(result['a'], range(5))\n            self.assertIn(result['b'], range(100))\n            # Also check the temp constraint is followed\n            self.assertLess(result['a'] * result['b'], 200)\n\n    def get_tmp_constraints(self):\n        def a_lt_5(a):\n            return a < 5\n        def a_mul_b_lt_200(a, b):\n            return a * b < 200\n        return [(a_lt_5, ('a',)), (a_mul_b_lt_200, ('a', 'b'))]", "\n\nclass TrickyTempConstraints(basic.MultiSum):\n    '''\n    Force use of MultiVarProblem with a difficult problem, and\n    also use temporary constraints.\n    '''\n\n    ITERATIONS = 30\n\n    def check(self, results):\n        # Normal checks\n        super().check(results)\n        # Check that we see x and y sum to greater than 50 when\n        # the temporary constraint isn't in place.\n        # Temp constraint not respected - check for at least one instance\n        # where all conditions are not respected.\n        temp_constraint_respected = True\n        for result in results:\n            if result['x'] + result['y'] >= 50 and \\\n                result['x'] % 2 != 0 and \\\n                (result['y'] + result['z']) % 3 != 0:\n                temp_constraint_respected = False\n        self.assertFalse(\n            temp_constraint_respected,\n            \"Temp constraint should not be followed when not applied\"\n        )\n\n    def get_tmp_constraints(self):\n        # Use a few extra temporary constraints to make the problem even harder\n        tmp_constraints = []\n\n        def tmp_abs_sum_xy_lt50(x, y):\n            return abs(x) + abs(y) < 50\n        tmp_constraints.append((tmp_abs_sum_xy_lt50, ('x', 'y')))\n\n        def tmp_x_mod2(x):\n            return x % 2 == 0\n        tmp_constraints.append((tmp_x_mod2, ('x',)))\n\n        def tmp_yz_mod3(y, z):\n            return (y + z) % 3 == 0\n        tmp_constraints.append((tmp_yz_mod3, ('y', 'z')))\n\n        return tmp_constraints\n\n    # Check that the temp constraint is respected\n    def tmp_check(self, results):\n        # Normal checks\n        super().check(results)\n        # Temp constraint respected\n        for result in results:\n            self.assertLess(result['x'] + result['y'], 50, \"Temp constraint not respected\")\n            self.assertTrue(result['x'] % 2 == 0, \"Temp constraint not respected\")\n            self.assertTrue((result['y'] + result['z']) % 3 == 0, \"Temp constraint not respected\")", "\n\nclass WithValues(testutils.RandObjTestBase):\n    '''\n    Basic test for with_values.\n    '''\n\n    ITERATIONS = 1000\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        r.add_rand_var('a', domain=range(10))\n        r.add_rand_var('b', domain=range(100))\n        return r\n\n    def check(self, results):\n        # Ensure we see the temporary value violated at least once\n        non_52_seen = False\n        for result in results:\n            self.assertIn(result['a'], range(10))\n            self.assertIn(result['b'], range(100))\n            if result['b'] != 52:\n                non_52_seen = True\n        self.assertTrue(non_52_seen, \"Temporary value used when it shouldn't be\")\n\n    def get_tmp_values(self):\n        return {'b': 52}\n\n    def tmp_check(self, results):\n        for result in results:\n            self.assertIn(result['a'], range(10))\n            self.assertEqual(result['b'], 52)", "\n\nclass WithValuesWithConstraints(testutils.RandObjTestBase):\n    '''\n    Test how with_values and with_constraints interact.\n    '''\n\n    ITERATIONS = 1000\n\n    def get_randobj(self, *args):\n        r = RandObj(*args)\n        r.add_rand_var('a', domain=range(10))\n        r.add_rand_var('b', domain=range(100))\n        return r\n\n    def check(self, results):\n        seen_tmp_constraint_false = False\n        seen_tmp_value_false = False\n        for result in results:\n            self.assertIn(result['a'], range(10))\n            self.assertIn(result['b'], range(100))\n            if result['a'] * result['b'] >= 200 and result['a'] >= 5:\n                seen_tmp_constraint_false = True\n            if result['a'] != 3:\n                seen_tmp_value_false = True\n        self.assertTrue(seen_tmp_constraint_false, \"Temporary constraint followed when not given\")\n        self.assertTrue(seen_tmp_value_false, \"Temporary value followed when not given\")\n\n    def get_tmp_constraints(self):\n        def a_lt_5(a):\n            return a < 5\n        def a_mul_b_lt_200(a, b):\n            return a * b < 200\n        return [(a_lt_5, ('a',)), (a_mul_b_lt_200, ('a', 'b'))]\n\n    def get_tmp_values(self):\n        return {'a': 3}\n\n    def tmp_check(self, results):\n        for result in results:\n            # Do normal checks\n            self.assertIn(result['a'], range(5))\n            self.assertIn(result['b'], range(100))\n            # Also check the temp constraint is followed\n            self.assertLess(result['a'] * result['b'], 200)\n            # Check the temp value has been followed\n            self.assertEqual(result['a'], 3)", "\n\nclass TrickyTempValues(basic.MultiSum):\n    '''\n    Force use of MultiVarProblem with a difficult problem, and\n    also use temporary constraints and temporary values.\n    '''\n\n    ITERATIONS = 50\n\n    # Check that we see x and y sum to greater than 50 when\n    # the temporary constraint isn't in place\n    def check(self, results):\n        # Normal checks\n        super().check(results)\n        # Temp constraint not respected - check for at least one instance\n        # where all conditions are not respected\n        temp_constraint_respected = True\n        temp_value_respected = True\n        for result in results:\n            if result['x'] + result['y'] >= 50 and \\\n                (result['x'] % 2 == 1 or \\\n                    (result['y'] + result['z']) % 2 == 0):\n                temp_constraint_respected = False\n            if result['x'] != 6:\n                temp_value_respected = False\n        self.assertFalse(\n            temp_constraint_respected,\n            \"Temp constraint should not be followed when not applied\"\n        )\n        self.assertFalse(\n            temp_value_respected,\n            \"Temp value should not be followed when not applied\"\n        )\n\n    def get_tmp_constraints(self):\n        # Use a few extra temporary constraints to make the problem even harder\n        tmp_constraints = []\n\n        def tmp_abs_sum_xy_lt50(x, y):\n            return abs(x) + abs(y) < 50\n        tmp_constraints.append((tmp_abs_sum_xy_lt50, ('x', 'y')))\n\n        def tmp_x_mod2(x):\n            return x % 2 == 0\n        tmp_constraints.append((tmp_x_mod2, ('x',)))\n\n        def tmp_yz_mod3(y, z):\n            return (y + z) % 2 == 1\n        tmp_constraints.append((tmp_yz_mod3, ('y', 'z')))\n\n        return tmp_constraints\n\n    def get_tmp_values(self):\n        return {'x': 6}\n\n    # Check that the temp constraint is respected\n    def tmp_check(self, results):\n        # Normal checks\n        super().check(results)\n        # Temp constraint respected\n        for result in results:\n            self.assertLess(result['x'] + result['y'], 50, \"Temp constraint not respected\")\n            self.assertTrue(result['x'] % 2 == 0, \"Temp constraint not respected\")\n            self.assertTrue((result['y'] + result['z']) % 2 == 1, \"Temp constraint not respected\")\n            self.assertEqual(result['x'], 6, \"Temp value not respected\")", ""]}
{"filename": "benchmarks/__main__.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\n'''\nBenchmark against pyvsc library for equivalent testcases.\n'''\n\nimport unittest\nimport timeit\nimport sys", "import timeit\nimport sys\n\nfrom argparse import ArgumentParser\nfrom random import Random\n\nfrom benchmarks.pyvsc.basic import vsc_basic, cr_basic\nfrom benchmarks.pyvsc.in_keyword import vsc_in, cr_in, cr_in_order\nfrom benchmarks.pyvsc.ldinstr import vsc_ldinstr\nfrom benchmarks.pyvsc.randlist import vscRandListSumZero, \\", "from benchmarks.pyvsc.ldinstr import vsc_ldinstr\nfrom benchmarks.pyvsc.randlist import vscRandListSumZero, \\\n    crRandListSumZero, vscRandListUnique, crRandListUnique, \\\n    crRandListSumZeroFaster, crRandListUniqueFaster\nfrom examples.ldinstr import ldInstr\n\n\nTEST_LENGTH_MULTIPLIER = 1\n\n\nclass BenchmarkTests(unittest.TestCase):\n\n    def run_one(self, name, randobj, iterations):\n        '''\n        Benchmark one object that implements the .randomize() function\n        for N iterations.\n        '''\n        start_time = timeit.default_timer()\n        for _ in range(iterations):\n            randobj.randomize()\n        end_time = timeit.default_timer()\n        total_time = end_time - start_time\n        hz = iterations / total_time\n        print(f'{self._testMethodName}: {name} took {total_time:.4g}s for {iterations} iterations ({hz:.1f}Hz)')\n        return total_time, hz\n\n    def run_benchmark(self, randobjs, iterations, check):\n        '''\n        Reusable function to run a fair benchmark between\n        two or more randomizable objects.\n\n        randobjs:   dictionary where key is name, value is an object that implements .randomize()\n        iterations: how many times to call .randomize()\n        check:      function taking a dictionary of results to check.\n        '''\n        iterations *= TEST_LENGTH_MULTIPLIER\n        results = {}\n        winner = None\n        best_hz = 0\n        for name, randobj in randobjs.items():\n            total_time, hz = self.run_one(name, randobj, iterations)\n            if hz > best_hz:\n                winner = name\n                best_hz = hz\n            # Store both total time and Hz in case the test wants to specify\n            # checks on how long should be taken in wall clock time.\n            results[name] = total_time, hz\n        print(f'{self._testMethodName}: The winner is {winner} with {best_hz:.1f}Hz!')\n        # Print summary of hz delta\n        for name, (_total_time, hz) in results.items():\n            if name == winner:\n                continue\n            speedup = best_hz / hz\n            print(f'{self._testMethodName}: {winner} was {speedup:.2f}x faster than {name}')\n        check(results)\n\n    def test_basic(self):\n        '''\n        Test basic randomizable object.\n        '''\n        randobjs = {'vsc': vsc_basic(), 'cr': cr_basic(Random(0))}\n        def check(results):\n            self.assertGreater(results['cr'][1], results['vsc'][1])\n            # This testcase is typically 40-50x faster, which may vary depending\n            # on machine. Ensure it doesn't fall below 30x.\n            speedup = results['cr'][1] / results['vsc'][1]\n            self.assertGreater(speedup, 30, \"Performance has degraded!\")\n        self.run_benchmark(randobjs, 100, check)\n\n    def test_in(self):\n        '''\n        Test object using 'in' keyword.\n        '''\n        randobjs = {\n            'vsc': vsc_in(),\n            'cr': cr_in(Random(0)),\n            'cr_order': cr_in_order(Random(0)),\n        }\n        def check(results):\n            self.assertGreater(results['cr'][1], results['vsc'][1])\n            # This testcase is typically 13-15x faster, which may vary depending\n            # on machine. Ensure it doesn't fall below 10x.\n            speedup = results['cr'][1] / results['vsc'][1]\n            self.assertGreater(speedup, 10, \"Performance has degraded!\")\n        self.run_benchmark(randobjs, 100, check)\n\n    def test_ldinstr(self):\n        '''\n        Test LD instruction example.\n        '''\n        randobjs = {\n            'vsc': vsc_ldinstr(),\n            'cr': ldInstr(Random(0)),\n        }\n        def check(results):\n            self.assertGreater(results['cr'][1], results['vsc'][1])\n            # This testcase is typically 13-15x faster, which may vary depending\n            # on machine. Ensure it doesn't fall below 10x.\n            speedup = results['cr'][1] / results['vsc'][1]\n            self.assertGreater(speedup, 10, \"Performance has degraded!\")\n        self.run_benchmark(randobjs, 100, check)\n\n    def test_randlist_sumzero(self):\n        '''\n        Test random list example where the list must sum to zero.\n        '''\n        randobjs = {\n            'vsc': vscRandListSumZero(),\n            'cr': crRandListSumZero(Random(0)),\n            'cr_faster': crRandListSumZeroFaster(Random(0)),\n        }\n        def check(results):\n            self.assertGreater(results['cr'][1], results['vsc'][1])\n            self.assertGreater(results['cr_faster'][1], results['vsc'][1])\n            # This testcase is typically 20x faster, which may vary depending\n            # on machine. Ensure it doesn't fall below 15x.\n            speedup = results['cr'][1] / results['vsc'][1]\n            self.assertGreater(speedup, 15, \"Performance has degraded!\")\n            speedup = results['cr_faster'][1] / results['vsc'][1]\n            self.assertGreater(speedup, 15, \"Performance has degraded!\")\n        self.run_benchmark(randobjs, 100, check)\n\n    def test_randlist_unique(self):\n        '''\n        Test random list example where the list must be unique.\n        '''\n        randobjs = {\n            'vsc': vscRandListUnique(),\n            'cr': crRandListUnique(Random(0)),\n            'cr_faster': crRandListUniqueFaster(Random(0)),\n        }\n        def check(results):\n            self.assertGreater(results['cr_faster'][1], results['vsc'][1])\n            self.assertGreater(results['cr'][1], results['vsc'][1])\n            # With the naive solver, this testcase is typically 3-4x faster,\n            # which may vary depending on machine. Ensure it doesn't fall\n            # below 2x.\n            speedup = results['cr'][1] / results['vsc'][1]\n            self.assertGreater(speedup, 2, \"Performance has degraded!\")\n            # This testcase is typically 10-13x faster, which may vary depending\n            # on machine. Ensure it doesn't fall below 10x.\n            speedup = results['cr_faster'][1] / results['vsc'][1]\n            self.assertGreater(speedup, 10, \"Performance has degraded!\")\n        self.run_benchmark(randobjs, 100, check)", "\n\nclass BenchmarkTests(unittest.TestCase):\n\n    def run_one(self, name, randobj, iterations):\n        '''\n        Benchmark one object that implements the .randomize() function\n        for N iterations.\n        '''\n        start_time = timeit.default_timer()\n        for _ in range(iterations):\n            randobj.randomize()\n        end_time = timeit.default_timer()\n        total_time = end_time - start_time\n        hz = iterations / total_time\n        print(f'{self._testMethodName}: {name} took {total_time:.4g}s for {iterations} iterations ({hz:.1f}Hz)')\n        return total_time, hz\n\n    def run_benchmark(self, randobjs, iterations, check):\n        '''\n        Reusable function to run a fair benchmark between\n        two or more randomizable objects.\n\n        randobjs:   dictionary where key is name, value is an object that implements .randomize()\n        iterations: how many times to call .randomize()\n        check:      function taking a dictionary of results to check.\n        '''\n        iterations *= TEST_LENGTH_MULTIPLIER\n        results = {}\n        winner = None\n        best_hz = 0\n        for name, randobj in randobjs.items():\n            total_time, hz = self.run_one(name, randobj, iterations)\n            if hz > best_hz:\n                winner = name\n                best_hz = hz\n            # Store both total time and Hz in case the test wants to specify\n            # checks on how long should be taken in wall clock time.\n            results[name] = total_time, hz\n        print(f'{self._testMethodName}: The winner is {winner} with {best_hz:.1f}Hz!')\n        # Print summary of hz delta\n        for name, (_total_time, hz) in results.items():\n            if name == winner:\n                continue\n            speedup = best_hz / hz\n            print(f'{self._testMethodName}: {winner} was {speedup:.2f}x faster than {name}')\n        check(results)\n\n    def test_basic(self):\n        '''\n        Test basic randomizable object.\n        '''\n        randobjs = {'vsc': vsc_basic(), 'cr': cr_basic(Random(0))}\n        def check(results):\n            self.assertGreater(results['cr'][1], results['vsc'][1])\n            # This testcase is typically 40-50x faster, which may vary depending\n            # on machine. Ensure it doesn't fall below 30x.\n            speedup = results['cr'][1] / results['vsc'][1]\n            self.assertGreater(speedup, 30, \"Performance has degraded!\")\n        self.run_benchmark(randobjs, 100, check)\n\n    def test_in(self):\n        '''\n        Test object using 'in' keyword.\n        '''\n        randobjs = {\n            'vsc': vsc_in(),\n            'cr': cr_in(Random(0)),\n            'cr_order': cr_in_order(Random(0)),\n        }\n        def check(results):\n            self.assertGreater(results['cr'][1], results['vsc'][1])\n            # This testcase is typically 13-15x faster, which may vary depending\n            # on machine. Ensure it doesn't fall below 10x.\n            speedup = results['cr'][1] / results['vsc'][1]\n            self.assertGreater(speedup, 10, \"Performance has degraded!\")\n        self.run_benchmark(randobjs, 100, check)\n\n    def test_ldinstr(self):\n        '''\n        Test LD instruction example.\n        '''\n        randobjs = {\n            'vsc': vsc_ldinstr(),\n            'cr': ldInstr(Random(0)),\n        }\n        def check(results):\n            self.assertGreater(results['cr'][1], results['vsc'][1])\n            # This testcase is typically 13-15x faster, which may vary depending\n            # on machine. Ensure it doesn't fall below 10x.\n            speedup = results['cr'][1] / results['vsc'][1]\n            self.assertGreater(speedup, 10, \"Performance has degraded!\")\n        self.run_benchmark(randobjs, 100, check)\n\n    def test_randlist_sumzero(self):\n        '''\n        Test random list example where the list must sum to zero.\n        '''\n        randobjs = {\n            'vsc': vscRandListSumZero(),\n            'cr': crRandListSumZero(Random(0)),\n            'cr_faster': crRandListSumZeroFaster(Random(0)),\n        }\n        def check(results):\n            self.assertGreater(results['cr'][1], results['vsc'][1])\n            self.assertGreater(results['cr_faster'][1], results['vsc'][1])\n            # This testcase is typically 20x faster, which may vary depending\n            # on machine. Ensure it doesn't fall below 15x.\n            speedup = results['cr'][1] / results['vsc'][1]\n            self.assertGreater(speedup, 15, \"Performance has degraded!\")\n            speedup = results['cr_faster'][1] / results['vsc'][1]\n            self.assertGreater(speedup, 15, \"Performance has degraded!\")\n        self.run_benchmark(randobjs, 100, check)\n\n    def test_randlist_unique(self):\n        '''\n        Test random list example where the list must be unique.\n        '''\n        randobjs = {\n            'vsc': vscRandListUnique(),\n            'cr': crRandListUnique(Random(0)),\n            'cr_faster': crRandListUniqueFaster(Random(0)),\n        }\n        def check(results):\n            self.assertGreater(results['cr_faster'][1], results['vsc'][1])\n            self.assertGreater(results['cr'][1], results['vsc'][1])\n            # With the naive solver, this testcase is typically 3-4x faster,\n            # which may vary depending on machine. Ensure it doesn't fall\n            # below 2x.\n            speedup = results['cr'][1] / results['vsc'][1]\n            self.assertGreater(speedup, 2, \"Performance has degraded!\")\n            # This testcase is typically 10-13x faster, which may vary depending\n            # on machine. Ensure it doesn't fall below 10x.\n            speedup = results['cr_faster'][1] / results['vsc'][1]\n            self.assertGreater(speedup, 10, \"Performance has degraded!\")\n        self.run_benchmark(randobjs, 100, check)", "\n\ndef parse_args():\n    parser = ArgumentParser(description='Run unit tests for constrainedrandom library')\n    parser.add_argument('--length-mul', type=int, default=1, help='Multiplier for test length, when desiring greater certainty on performance.')\n    args, extra = parser.parse_known_args()\n    return args, extra\n\n\nif __name__ == \"__main__\":\n    args, extra = parse_args()\n    TEST_LENGTH_MULTIPLIER = args.length_mul\n    # Reconstruct argv\n    argv = [sys.argv[0]] + extra\n    unittest.main(argv=argv)", "\nif __name__ == \"__main__\":\n    args, extra = parse_args()\n    TEST_LENGTH_MULTIPLIER = args.length_mul\n    # Reconstruct argv\n    argv = [sys.argv[0]] + extra\n    unittest.main(argv=argv)\n"]}
{"filename": "benchmarks/__init__.py", "chunked_list": [""]}
{"filename": "benchmarks/pyvsc/in_keyword.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\n'''\nRandom object using 'in' keyword from pyvsc documentation.\n'''\n\nfrom constrainedrandom import RandObj\nimport vsc\n", "import vsc\n\n\n@vsc.randobj\nclass vsc_in(object):\n\n    def __init__(self):\n        self.a = vsc.rand_bit_t(8)\n        self.b = vsc.rand_bit_t(8)\n        self.c = vsc.rand_bit_t(8)\n        self.d = vsc.rand_bit_t(8)\n\n    @vsc.constraint\n    def ab_c(self):\n\n       self.a in vsc.rangelist(1, 2, vsc.rng(4,8))\n       self.c != 0\n       self.d != 0\n\n       self.c < self.d\n       self.b in vsc.rangelist(vsc.rng(self.c,self.d))", "\n\nclass cr_in(RandObj):\n    '''\n    Basic implementation, does thes same thing as vsc_in. No ordering hints.\n    '''\n\n    def __init__(self, random):\n        super().__init__(random)\n\n        self.add_rand_var('a', domain=[1,2] + list(range(4,8)))\n        self.add_rand_var('b', bits=8, constraints=(lambda b : b != 0,))\n        self.add_rand_var('c', bits=8)\n        self.add_rand_var('d', bits=8, constraints=(lambda d : d != 0,))\n\n        def c_lt_d(c, d):\n            return c < d\n        self.add_constraint(c_lt_d, ('c', 'd'))\n\n        def b_in_range(b, c, d):\n            return b in range(c, d)\n        self.add_constraint(b_in_range, ('b', 'c', 'd'))", "\n\nclass cr_in_order(RandObj):\n    '''\n    cr_in, but with ordering hints.\n    '''\n\n    def __init__(self, random):\n        super().__init__(random)\n\n        self.add_rand_var('a', domain=[1,2] + list(range(4,8)), order=0)\n        self.add_rand_var('b', bits=8, constraints=(lambda b : b != 0,), order=2)\n        self.add_rand_var('c', bits=8, order=0)\n        self.add_rand_var('d', bits=8, constraints=(lambda d : d != 0,), order=1)\n\n        def c_lt_d(c, d):\n            return c < d\n        self.add_constraint(c_lt_d, ('c', 'd'))\n\n        def b_in_range(b, c, d):\n            return b in range(c, d)\n        self.add_constraint(b_in_range, ('b', 'c', 'd'))", ""]}
{"filename": "benchmarks/pyvsc/ldinstr.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\n'''\nImplement realistic load instruction case from constrainedrandom examples.ldinstr\n'''\n\nimport vsc\n\n@vsc.randobj\nclass vsc_ldinstr(object):\n\n    def __init__(self):\n        self.imm0 = vsc.rand_bit_t(11)\n        self.src0 = vsc.rand_bit_t(5)\n        self.dst0 = vsc.rand_bit_t(5)\n        self.wb = vsc.rand_bit_t(1)\n        self.enc = 0xfa800000\n        # Make this the same as in examples.ldinstr\n        self.src0_value_getter = lambda : 0xfffffbcd\n\n    @vsc.constraint\n    def wb_src0_dst0(self):\n        with vsc.if_then(self.wb == 1):\n            self.src0 != self.dst0\n\n    @vsc.constraint\n    def sum_src0_imm0(self):\n        self.imm0 + self.src0_value_getter() <= 0xffffffff\n        (self.imm0 + self.src0_value_getter()) & 3 == 0", "\n@vsc.randobj\nclass vsc_ldinstr(object):\n\n    def __init__(self):\n        self.imm0 = vsc.rand_bit_t(11)\n        self.src0 = vsc.rand_bit_t(5)\n        self.dst0 = vsc.rand_bit_t(5)\n        self.wb = vsc.rand_bit_t(1)\n        self.enc = 0xfa800000\n        # Make this the same as in examples.ldinstr\n        self.src0_value_getter = lambda : 0xfffffbcd\n\n    @vsc.constraint\n    def wb_src0_dst0(self):\n        with vsc.if_then(self.wb == 1):\n            self.src0 != self.dst0\n\n    @vsc.constraint\n    def sum_src0_imm0(self):\n        self.imm0 + self.src0_value_getter() <= 0xffffffff\n        (self.imm0 + self.src0_value_getter()) & 3 == 0", ""]}
{"filename": "benchmarks/pyvsc/randlist.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\n'''\nRandom list examples where constrainedrandom has previously struggled.\n'''\n\nfrom constrainedrandom import RandObj\nfrom constrainedrandom.utils import unique\nimport vsc", "from constrainedrandom.utils import unique\nimport vsc\n\n\n@vsc.randobj\nclass vscRandListSumZero(object):\n\n    def __init__(self):\n        self.listvar = vsc.rand_list_t(vsc.int8_t(), 10)\n\n    @vsc.constraint\n    def listvar_c(self):\n        with vsc.foreach(self.listvar) as l:\n            l >= -10\n            l < 11\n\n    @vsc.constraint\n    def listvar_sum_c(self):\n        sum(self.listvar) == 0", "\n\nclass crRandListSumZero(RandObj):\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        self.add_rand_var('listvar', domain=range(-10, 11), length=10)\n        def sum_0(listvar):\n            return sum(listvar) == 0\n        self.add_constraint(sum_0, ('listvar',))", "\n\nclass crRandListSumZeroFaster(RandObj):\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        self.add_rand_var('listvar', domain=range(-10, 11), length=10, disable_naive_list_solver=True)\n        def sum_0(listvar):\n            return sum(listvar) == 0\n        self.add_constraint(sum_0, ('listvar',))", "\n\n@vsc.randobj\nclass vscRandListUnique(object):\n\n    def __init__(self):\n        self.listvar = vsc.rand_list_t(vsc.uint8_t(), 10)\n\n    @vsc.constraint\n    def listvar_c(self):\n        with vsc.foreach(self.listvar) as l:\n            l >= 0\n            l < 10\n\n    @vsc.constraint\n    def listvar_unique_c(self):\n        vsc.unique(self.listvar)", "\n\nclass crRandListUnique(RandObj):\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        self.add_rand_var('listvar', domain=range(10), length=10, list_constraints=[unique])\n\n\nclass crRandListUniqueFaster(RandObj):\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        self.add_rand_var('listvar',\n            domain=range(10),\n            length=10,\n            list_constraints=[unique],\n            disable_naive_list_solver=True,\n        )", "\nclass crRandListUniqueFaster(RandObj):\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        self.add_rand_var('listvar',\n            domain=range(10),\n            length=10,\n            list_constraints=[unique],\n            disable_naive_list_solver=True,\n        )", ""]}
{"filename": "benchmarks/pyvsc/__init__.py", "chunked_list": [""]}
{"filename": "benchmarks/pyvsc/basic.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\n'''\nBasic random object from pyvsc documentation.\n'''\n\nfrom constrainedrandom import RandObj\nimport vsc\n", "import vsc\n\n\n@vsc.randobj\nclass vsc_basic(object):\n\n    def __init__(self):\n        self.a = vsc.rand_bit_t(8)\n        self.b = vsc.rand_bit_t(8)\n        self.c = vsc.rand_bit_t(8)\n        self.d = vsc.rand_bit_t(8)\n\n    @vsc.constraint\n    def ab_c(self):\n        self.a < self.b", "\n\nclass cr_basic(RandObj):\n\n    def __init__(self, random):\n        super().__init__(random)\n        self.add_rand_var('a', bits=8)\n        self.add_rand_var('b', bits=8, order=1)\n        self.add_rand_var('c', bits=8)\n        self.add_rand_var('d', bits=8)\n\n        self.add_constraint(lambda a, b : a < b, ('a', 'b'))", ""]}
{"filename": "examples/ldinstr.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\nimport random\n\nfrom constrainedrandom import RandObj\n\nclass ldInstr(RandObj):\n    '''\n    A made-up load instruction has the following fields (starting at LSB):\n    - imm0 (11 bits): immediate offset for memory address\n    - src0 ( 5 bits): source register for memory address\n    - dst0 ( 5 bits): destination register for load data\n    - wb   ( 1 bit ): enable for writeback of the address to the src0 register.\n    - enc  (10 bits): fixed encoding to signify this kind of load instruction.\n\n    And the following rules:\n    - If writeback (wb) is set, src0 is written back with memory offset. In\n    this case, do not allow dst0 to be the same register as src0.\n    - The sum of the current contents of src0 and imm0 should be word-aligned.\n    - The sum of the current contents of src0 and imm0 should not overflow 32\n    bits.\n    '''\n    ENC = 0xfa800000\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        self.add_rand_var('src0', bits=5, order=0)\n        def read_model_for_src0_value():\n            # Pretend getter for src0 current value\n            return 0xfffffbcd\n        self.add_rand_var('src0_value', fn=read_model_for_src0_value, order=0)\n        self.add_rand_var('wb', bits=1, order=0)\n        self.add_rand_var('dst0', bits=5, order=1)\n        self.add_rand_var('imm0', bits=11, order=2)\n        def wb_dst_src(wb, dst0, src0):\n            if wb:\n                return dst0 != src0\n            return True\n        self.add_constraint(wb_dst_src, ('wb', 'dst0', 'src0'))\n        def sum_src0_imm0(src0_value, imm0):\n            address = src0_value + imm0\n            return (address & 3 == 0) and (address < 0xffffffff)\n        self.add_constraint(sum_src0_imm0, ('src0_value', 'imm0'))\n\n    def post_randomize(self):\n        self.opcode = self.get_opcode()\n\n    def get_opcode(self):\n        opcode = self.ENC\n        opcode = opcode | self.imm0\n        opcode = opcode | (self.src0 << 11)\n        opcode = opcode | (self.dst0 << 5)\n        opcode = opcode | (self.wb << 5)\n        return opcode", "\n\nif __name__ == \"__main__\":\n    # Use a seed of 0 so our results are repeatable\n    random.seed(0)\n    ld_instr = ldInstr()\n    # Produce 5 random valid opcodes for this load instruction\n    for _ in range(5):\n        ld_instr.randomize()\n        print(hex(ld_instr.opcode))", ""]}
{"filename": "examples/__init__.py", "chunked_list": [""]}
{"filename": "docs/conf.py", "chunked_list": ["import sys\nimport os\nsys.path.insert(0, os.path.abspath('../'))\n\n# Configuration file for the Sphinx documentation builder.\n#\n# For the full list of built-in configuration values, see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Project information -----------------------------------------------------", "\n# -- Project information -----------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information\n\nproject = 'constrainedrandom'\ncopyright = '2023, Imagination Technologies Ltd.'\nauthor = 'Will Keen'\n\n# -- General configuration ---------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration", "# -- General configuration ---------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n\nextensions = ['sphinx.ext.autodoc', 'sphinx.ext.autosectionlabel']\n\ntemplates_path = ['_templates']\nexclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n\n# -- Options for HTML output -------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output", "# -- Options for HTML output -------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n\nhtml_theme = 'sphinx_rtd_theme'\nhtml_static_path = []\n"]}
{"filename": "constrainedrandom/bits.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\n'''\nReusable utility functions to perform commonly required bitwise operations.\n'''\n\ndef get_bitslice(val: int, hi: int, lo: int):\n    '''\n    Function to get a bit slice from a value.\n    Equivalent behaviour to SystemVerilog, i.e.\n    ``get_bitslice(val, hi, lo)`` in Python\n    is the same as:\n    ``val[hi:lo]`` in SV.\n\n    :param val: The value to slice.\n    :param hi: The highest bit index of the desired slice.\n    :param hi: The lowest bit index of the desired slice.\n    :return: The requested bit slice.\n    :raises AssertionError: If lo > hi.\n    '''\n    assert lo <= hi, \"low index must be less than or equal to high index\"\n    size = hi - lo + 1\n    mask = (1 << size) - 1\n    return (val >> lo) & mask", "\n\ndef set_bitslice(val: int, hi: int, lo: int, new_val: int):\n    '''\n    Function to take a value and set a slice of bits to\n    a particular value. The function returns that new\n    value. The input value is unaffected.\n    Equivalent behaviour to SystemVerilog, i.e.\n    ``val = set_bitslice(val, hi, lo, new_val)`` in Python\n    is the same as:\n    ``val[hi:lo] = new_val`` in SV.\n\n    :param val: The value to modify.\n    :param hi: The highest bit index of the desired slice.\n    :param hi: The lowest bit index of the desired slice.\n    :param new_val: The new value to be assigned to the slice.\n    :return: The modified value.\n    :raises AssertionError: If lo > hi.\n    '''\n    assert lo <= hi, \"low index must be less than or equal to high index\"\n    size = hi - lo + 1\n    mask = (1 << size) - 1\n    new_val = new_val & mask\n    not_mask = ((1 << val.bit_length()) - 1) & ~(mask << lo)\n    return (val & not_mask) | (new_val << lo)", ""]}
{"filename": "constrainedrandom/randobj.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\nimport constraint\nimport random\nfrom collections import defaultdict\nfrom typing import Any, Callable, Dict, Iterable, List, Optional\n\nfrom . import utils\nfrom .internal.multivar import MultiVarProblem", "from . import utils\nfrom .internal.multivar import MultiVarProblem\nfrom .internal.randvar import RandVar\n\n\nclass RandObj:\n    '''\n    Randomizable object. User-facing class.\n    Contains any number of random variables and constraints.\n    Randomizes to produce a valid solution for those variables and constraints.\n\n    :param _random: An instance of ``random.Random``, which controls the\n        seeding and random generation for this class. If passed none, use the global\n        Python random package.\n    :param max_iterations: The maximum number of failed attempts to solve the randomization\n        problem before giving up.\n    :param max_domain_size: The maximum size of domain that a constraint satisfaction problem\n        may take. This is used to avoid poor performance. When a problem exceeds this domain\n        size, we don't use the ``constraint`` package, but just use ``random`` instead.\n\n    :example:\n\n    .. code-block:: python\n\n        import random\n        from constrainedrandom import RandObj\n\n        # Create a random object based on a random generator with seed 0\n        rand_generator = random.Random(0)\n        rand_obj = RandObj(rand_generator)\n\n        # Add some random variables\n        rand_obj.add_rand_var('one_to_nine', domain=range(1, 10))\n        rand_obj.add_rand_var('eight_bits', bits=8, constraints=(lambda x : x != 0))\n\n        # Add a multi-variable constraint\n        rand_obj.add_constraint(lambda x, y : x != y, ('one_to_nine', 'eight_bits'))\n\n        # Produce one valid solution\n        rand_obj.randomize()\n\n        # Random variables are now accessible as member variables\n        print(rand_obj.one_to_nine)\n        print(rand_obj.eight_bits)\n    '''\n\n    def __init__(\n        self,\n        _random: Optional[random.Random]=None,\n        max_iterations: int=utils.MAX_ITERATIONS,\n        max_domain_size: int=utils.CONSTRAINT_MAX_DOMAIN_SIZE,\n    ) -> None:\n        # Prefix 'internal use' variables with '_', as randomized results are populated to the class\n        self._random = _random\n        self._random_vars = {}\n        self._constraints : List[utils.ConstraintAndVars] = []\n        self._constrained_vars = set()\n        self._max_iterations = max_iterations\n        self._max_domain_size = max_domain_size\n        self._naive_solve = True\n        self._sparse_solve = True\n        self._thorough_solve = True\n        self._problem_changed = False\n\n    def _get_random(self) -> random.Random:\n        '''\n        Internal function to get the appropriate randomization object.\n\n        We can't store the package ``random`` in a member variable as this\n        prevents pickling.\n\n        :return: The appropriate random generator.\n        '''\n        if self._random is None:\n            return random\n        return self._random\n\n    def set_solver_mode(self,\n        naive: Optional[bool]=None,\n        sparse: Optional[bool]=None,\n        thorough: Optional[bool]=None,\n    ) -> None:\n        '''\n        Disable/enable different solving steps.\n\n        Solvers are used in the following order:\n        1. Naive solve - randomizing and checking constraints.\n        For some problems, it is more expedient to skip this\n        step and go straight to a MultiVarProblem.\n        2. Sparse solve - graph-based exporation of state space.\n        Start with depth-first search, move to wider subsets\n        of each level of state space until valid solution\n        found.\n        3. Thorough solve - use constraint solver to get\n        all solutions and pick a random one.\n\n        If a solver step is enabled it will run, if disabled\n        it won't run.\n\n        :param naive: ``True`` if naive solver should be used,\n            ``False`` otherwise. Setting not changed if argument\n            not provided.\n        :param sparse: ``True`` if sparse solver should be used,\n            ``False`` otherwise. Setting not changed if argument\n            not provided.\n        :param thorough: ``True`` if thorough solver should be used,\n            ``False`` otherwise. Setting not changed if argument\n            not provided.\n        :return: ``None``\n        '''\n        if naive is not None:\n            self._naive_solve = naive\n        if sparse is not None:\n            self._sparse_solve = sparse\n        if thorough is not None:\n            self._thorough_solve = thorough\n\n    def add_rand_var(\n        self,\n        name: str,\n        *,\n        domain: Optional[utils.Domain]=None,\n        bits: Optional[int]=None,\n        fn: Optional[Callable]=None,\n        args: Optional[tuple]=None,\n        constraints: Optional[Iterable[utils.Constraint]]=None,\n        list_constraints: Optional[Iterable[utils.Constraint]]=None,\n        length: int=0,\n        order: int=0,\n        initial: Any=None,\n        disable_naive_list_solver: bool=False,\n    ) -> None:\n        '''\n        Add a random variable to the object.\n        Exactly one of ``domain``, ``bits``, or ``fn`` (optionally with ``args``) must be provided\n        to determine how to randomize.\n\n        :param name: The name of this random variable.\n        :param domain: The possible values for this random variable, expressed either\n            as a ``range``, or as an iterable (e.g. ``list``, ``tuple``) of possible values.\n            Mutually exclusive with ``bits`` and ``fn``.\n        :param bits: Specifies the possible values of this variable in terms of a width\n            in bits. E.g. ``bits=32`` signifies this variable can be ``0 <= x < 1 << 32``.\n            Mutually exclusive with ``domain`` and ``fn``.\n        :param fn: Specifies a function to call that will provide the value of this random\n            variable.\n            Mutually exclusive with ``domain`` and ``bits``.\n        :param args: Arguments to pass to the function specified in ``fn``.\n            If ``fn`` is not used, ``args`` must not be used.\n        :param constraints: List or tuple of constraints that apply to this random variable.\n            Each of these apply only to the individual values in the list, if a length is\n            specified.\n        :param constraints: List or tuple of constraints that apply to this random variable.\n            Each of these apply across the values in the list, if a length is specified.\n        :param length: Specify a length > 0 to turn this variable into a list of random\n            values. A value of 0 means a scalar value. A value >= 1 means a list of that length.\n        :param order: The solution order for this variable with respect to other variables.\n        :param initial: Initial value to assign to the variable prior to randomizing.\n        :param disable_naive_list_solver: Attempt to use a faster algorithm for solving\n            list problems. May be faster, but may negatively impact quality of results.\n        :return: ``None``\n        :raises AssertionError: If inputs are not valid.\n\n        :example:\n\n        .. code-block:: python\n\n            # Create a random object based on a random generator with seed 0\n            rand_generator = random.Random(0)\n            rand_obj = RandObj(rand_generator)\n\n            # Add a variable which can be 1, 3, 5, 7 or 11\n            rand_obj.add_rand_var('prime', domain=(1, 3, 5, 7, 11))\n\n            # Add a variable which can be any number between 3 and 13, except 7\n            rand_obj.add_rand_var('not_7', domain=range(3, 14), constraints=(lambda x: x != 7,))\n\n            # Add a variable which is 12 bits wide and can't be zero\n            rand_obj.add_rand_var('twelve_bits', bits=12, constraints=(lambda x: x != 0,))\n\n            # Add a variable whose value is generated by calling a function\n            def my_fn():\n                return rand_generator.randrange(10)\n            rand_obj.add_rand_var('fn_based', fn=my_fn)\n\n            # Add a variable whose value is generated by calling a function that takes arguments\n            def my_fn(factor):\n                return factor * rand_generator.randrange(10)\n            rand_obj.add_rand_var('fn_based_with_args', fn=my_fn, args=(2,))\n        '''\n        # Check this is a valid name\n        assert name not in self.__dict__, f\"random variable name {name} is not valid, already exists in object\"\n        assert name not in self._random_vars, f\"random variable name {name} is not valid, already exists in random variables\"\n        self._random_vars[name] = RandVar(\n            name=name,\n            _random=self._random,\n            order=order,\n            domain=domain,\n            bits=bits,\n            fn=fn,\n            args=args,\n            constraints=constraints,\n            list_constraints=list_constraints,\n            length=length,\n            max_iterations=self._max_iterations,\n            max_domain_size=self._max_domain_size,\n            disable_naive_list_solver=disable_naive_list_solver,\n        )\n        self._problem_changed = True\n        self.__dict__[name] = initial\n\n    def add_constraint(self, constr: utils.Constraint, variables: Iterable[str]):\n        '''\n        Add an aribtrary constraint that applies to one or more variable(s).\n\n        :param constr: A function (or callable) that accepts the random variables listed in\n            ``variables`` as argument(s) and returns either ``True`` or ``False``.\n            If the function returns ``True`` when passed the variables, the constraint is satisfied.\n        :param variables: A tuple/list of variables affected by this constraint.\n            The order matters, this order will be preserved when passing variables into the constraint.\n        :return: ``None``\n        :raises AssertionError: If any member of ``variables`` is not a valid random variable.\n        :raises TypeError: If type of ``variables`` is not str, list or tuple.\n\n        :example:\n\n        .. code-block:: python\n\n            # Assume we have a RandObj called 'randobj', with random variables a, b and c\n            # Add a constraint that a, b and c must be different values\n            def not_equal(x, y, z):\n                return (x != y) and (y != z) and (x != z)\n            randobj.add_constraint(not_equal, ('a', 'b', 'c'))\n\n            # Add a constraint that a is less than b\n            randobj.add_constraint(lambda x, y: x < y, ('a', 'b'))\n\n            # Add a constraint that c must be more than double a but less than double b\n            randobj.constr(lambda a, b, c: (a * 2) < c < (b * 2), ('a', 'b', 'c'))\n        '''\n        if isinstance(variables, str):\n            # Single-variable constraint\n            self._random_vars[variables].add_constraint(constr)\n        elif isinstance(variables, list) or isinstance(variables, tuple):\n            if len(variables) == 1:\n                # Single-variable constraint\n                self._random_vars[variables[0]].add_constraint(constr)\n            else:\n                # Multi-variable constraint\n                for var in variables:\n                    assert var in self._random_vars, \\\n                        f\"Variable {var} was not in the set of random variables!\"\n                    self._constrained_vars.add(var)\n                self._constraints.append((constr, variables))\n        else:\n            raise TypeError(f\"{variables=} must be of type str, tuple or list\")\n        self._problem_changed = True\n\n    def pre_randomize(self) -> None:\n        '''\n        Called by :func:`randomize` before randomizing variables. Can be overridden to do something.\n\n        :return: ``None``\n        '''\n        pass\n\n    def randomize(\n        self,\n        *,\n        with_values: Optional[Dict[str, Any]]=None,\n        with_constraints: Optional[Iterable[utils.ConstraintAndVars]]=None,\n        debug: bool=False,\n    ) -> None:\n        '''\n        Randomizes all random variables, applying all constraints provided.\n        After calling this for the first time, random variables are\n        accessible as member variables.\n\n        :return: None\n        :param with_constraints: Temporary constraints for this randomization only.\n            List of tuples, consisting of a constraint function and an iterable\n            containing the variables it applies to.\n        :param debug: ``True`` to run in debug mode. Slower, but collects\n            all debug info along the way and not just the final failure.\n        :raises RandomizationError: If no solution is found\n            that satisfies the defined constraints.\n        '''\n        self.pre_randomize()\n\n        result = {}\n\n        # Copy always-on constraints, ready to add any temporary ones\n        constraints = list(self._constraints)\n        constrained_vars = set(self._constrained_vars)\n\n        # Process temporary constraints\n        tmp_single_var_constraints = defaultdict(list)\n        # Set to True if the problem is different from the base problem\n        problem_changed = False\n        if with_constraints is not None:\n            for constr, vars in with_constraints:\n                assert isinstance(vars, Iterable), \\\n                    \"with_constraints should specify a list of tuples of (constraint, Iterable[variables])\"\n                assert len(vars) > 0, \"Cannot add a constraint that applies to no variables\"\n                if len(vars) == 1:\n                    # Single-variable constraint\n                    tmp_single_var_constraints[vars[0]].append(constr)\n                    problem_changed = True\n                else:\n                    # Multi-variable constraint\n                    constraints.append((constr, vars))\n                    for var in vars:\n                        constrained_vars.add(var)\n                    problem_changed = True\n            # If a variable becomes constrained due to temporary multi-variable\n            # constraints, we must respect single var temporary constraints too.\n            for var, constrs in sorted(tmp_single_var_constraints.items()):\n                if var in constrained_vars:\n                    for constr in constrs:\n                        constraints.append((constr, (var,)))\n\n        # Don't allow non-determinism when iterating over a set\n        constrained_vars = sorted(constrained_vars)\n        # Don't allow non-determinism when iterating over a dict\n        random_vars = sorted(self._random_vars.items())\n\n        # Process concrete values - use these preferentially\n        with_values = with_values if with_values is not None else {}\n\n        for name, random_var in random_vars:\n            if name in with_values:\n                result[name] = with_values[name]\n            else:\n                tmp_constraints = tmp_single_var_constraints.get(name, [])\n                result[name] = random_var.randomize(tmp_constraints, debug)\n\n        # If there are constraints, first try just to solve naively by randomizing the values.\n        # This will be faster than constructing a MultiVarProblem if the constraints turn out\n        # to be trivial. Only try this a few times so as not to waste time.\n        constraints_satisfied = len(constraints) == 0\n        if self._naive_solve:\n            attempts = 0\n            max = self._max_iterations\n            while not constraints_satisfied:\n                if attempts == max:\n                    break\n                problem = constraint.Problem()\n                for var in constrained_vars:\n                    problem.addVariable(var, (result[var],))\n                for _constraint, variables in constraints:\n                    problem.addConstraint(_constraint, variables)\n                solutions = problem.getSolutions()\n                if len(solutions) > 0:\n                    # At least one solution was found, all is well\n                    constraints_satisfied = True\n                    solution = self._get_random().choice(solutions)\n                    result.update(solution)\n                else:\n                    # No solution found, re-randomize and try again\n                    for var in constrained_vars:\n                        # Don't re-randomize if we've specified a concrete value\n                        if var in with_values:\n                            continue\n                        else:\n                            tmp_constraints = tmp_single_var_constraints.get(var, [])\n                            result[var] = self._random_vars[var].randomize(tmp_constraints, debug)\n                    attempts += 1\n\n        # If constraints are still not satisfied by this point, construct a multi-variable\n        # problem and solve them properly\n        if not constraints_satisfied:\n            if not (self._sparse_solve or self._thorough_solve):\n                raise utils.RandomizationError(\n                    'Naive solve failed, and sparse solve and thorough solve disabled.' \\\n                    ' There is no way to solve the problem.'\n                )\n            if problem_changed or self._problem_changed or self._multi_var_problem is None:\n                multi_var_problem = MultiVarProblem(\n                    self,\n                    [var for var_name, var in random_vars if var_name in constrained_vars],\n                    constraints,\n                    max_iterations=self._max_iterations,\n                    max_domain_size=self._max_domain_size,\n                )\n                # Only 'cache' the problem if it's the base problem with no extra constraints\n                if not problem_changed:\n                    self._multi_var_problem = multi_var_problem\n                    self._problem_changed = False\n            else:\n                multi_var_problem = self._multi_var_problem\n            result.update(\n                multi_var_problem.solve(\n                    sparse=self._sparse_solve,\n                    thorough=self._thorough_solve,\n                    with_values=with_values,\n                    debug=debug,\n                )\n            )\n\n        # Update this object such that the results of randomization are available as member variables\n        self.__dict__.update(result)\n\n        self.post_randomize()\n\n    def post_randomize(self) -> None:\n        '''\n        Called by :func:`randomize` after randomizing variables. Can be overridden to do something.\n\n        :return: ``None``\n        '''\n        pass\n\n    def get_results(self) -> Dict[str, Any]:\n        '''\n        Returns a dictionary of the results from the most recent randomization.\n        This is mainly provided for testing purposes.\n\n        Note that individual variables can be accessed as member variables of\n        a RandObj instance, e.g.\n\n        .. code-block:: python\n\n            randobj = RandObj()\n            randobj.add_rand_var('a', domain=range(10))\n            randobj.randomize()\n            print(randobj.a)\n\n        :return: dictionary of the results from the most recent randomization.\n        '''\n        # Return a new dict object rather than a reference to this object's __dict__\n        return {k: self.__dict__[k] for k in self._random_vars.keys()}", ""]}
{"filename": "constrainedrandom/__init__.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\nfrom .random import dist, weighted_choice\nfrom .randobj import RandObj\nfrom .utils import RandomizationError\n\n__all__ = ['dist', 'weighted_choice', 'RandObj', 'RandomizationError']\n", ""]}
{"filename": "constrainedrandom/utils.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\n'''\nMiscellaneous utilities for the constrainedrandom package.\n'''\n\n\nfrom typing import Any, Callable, Dict, Iterable, List, Tuple, Union\n", "from typing import Any, Callable, Dict, Iterable, List, Tuple, Union\n\n\n# Distribution type\nDist = Dict[Any, int]\n\n# Domain type\nDomain = Union[Iterable[Any], range, Dist]\n\n# Constraint type", "\n# Constraint type\nConstraint = Callable[..., bool]\n\n# Constraint and the variables it applies to\nConstraintAndVars = Tuple[Constraint, Iterable[str]]\n\n# The default maximum iterations before giving up on any randomization problem.\n# A larger number means convergence is more likely, but runtime may be higher.\nMAX_ITERATIONS = 100", "# A larger number means convergence is more likely, but runtime may be higher.\nMAX_ITERATIONS = 100\n\n# The default largest domain size to use with the constraint library.\n# A large number may improve convergence, but hurt performance.\n# A lower number may improve performance, but make convergence less likely.\nCONSTRAINT_MAX_DOMAIN_SIZE = 1 << 10\n\nclass RandomizationError(Exception):\n    '''\n    Denotes that a randomization attempt has failed.\n    '''", "class RandomizationError(Exception):\n    '''\n    Denotes that a randomization attempt has failed.\n    '''\n\ndef unique(list_variable: Iterable[Any]) -> bool:\n    '''\n    Optimal function for testing uniqueness of values in a list.\n    Useful constraint on a list.\n    O(N) time complexity where N is list length, but also\n    O(N) worst-case space complexity.\n    Usually what you want rather than O(N**2) time compexity\n    and O(1) space.\n\n    :param list_variable: A list (or any iterable).\n    :return: True if every element in the list is unique,\n        False otherwise.\n    '''\n    seen = set()\n    for i in list_variable:\n        if i in seen:\n            return False\n        seen.add(i)\n    return True", ""]}
{"filename": "constrainedrandom/random.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\nimport random\n\nfrom typing import Any, Optional\n\nfrom . import utils\n\n\ndef weighted_choice(choices_dict: utils.Dist, _random: Optional[random.Random]=None) -> Any:\n    '''\n    Wrapper around ``random.choices``, allowing the user to specify weights in a dictionary.\n\n    :param choices_dict: A dict containing the possible values as keys and relative\n        weights as values.\n    :param _random: Instance of random generator object to use. If not supplied, use\n        global Python ``random`` module.\n    :return: One of the keys of ``choices_dict`` chosen at random, based on weighting.\n    :example:\n\n    .. code-block:: python\n\n        # 0 will be chosen 25% of the time, 1 25% of the time and 'foo' 50% of the time\n        value = weighted_choice({0: 25, 1: 25, 'foo': 50})\n    '''\n    if _random is None:\n        _random = random\n    return _random.choices(tuple(choices_dict.keys()), weights=tuple(choices_dict.values()))", "\n\ndef weighted_choice(choices_dict: utils.Dist, _random: Optional[random.Random]=None) -> Any:\n    '''\n    Wrapper around ``random.choices``, allowing the user to specify weights in a dictionary.\n\n    :param choices_dict: A dict containing the possible values as keys and relative\n        weights as values.\n    :param _random: Instance of random generator object to use. If not supplied, use\n        global Python ``random`` module.\n    :return: One of the keys of ``choices_dict`` chosen at random, based on weighting.\n    :example:\n\n    .. code-block:: python\n\n        # 0 will be chosen 25% of the time, 1 25% of the time and 'foo' 50% of the time\n        value = weighted_choice({0: 25, 1: 25, 'foo': 50})\n    '''\n    if _random is None:\n        _random = random\n    return _random.choices(tuple(choices_dict.keys()), weights=tuple(choices_dict.values()))", "\n\ndef dist(dist_dict: utils.Dist, _random: Optional[random.Random]=None) -> Any:\n    '''\n    Random distribution. As :func:`weighted_choice`, but allows ``range`` to be used as\n    a key to the dictionary, which if chosen is then evaluated as a random range.\n\n    :param dist_dict: A dict containing the possible values as keys and relative\n        weights as values. If a range is supplied as a key, it will be evaluated\n        as a random range.\n    :param _random: Instance of random generator object to use. If not supplied, use\n        global Python ``random`` module.\n    :return: One of the keys of ``dist_dict`` chosen at random, based on weighting.\n        If the key is a range, evaluate the range as a random range before returning.\n    :example:\n\n    .. code-block:: python\n\n        # 0 will be chosen 25% of the time, a value in the range 1 to 9 25% of the time\n        # and 'foo' 50% of the time\n        value = dist({0: 25, range(1, 10): 25, 'foo': 50})\n    '''\n    if _random is None:\n        _random = random\n    answer = weighted_choice(choices_dict=dist_dict, _random=_random)[0]\n    if isinstance(answer, range):\n        return _random.randrange(answer.start, answer.stop)\n    return answer", ""]}
{"filename": "constrainedrandom/debug.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\nfrom typing import Any, Dict, Iterable, List\n\nfrom .utils import Constraint, ConstraintAndVars\n\n\ndef debug_constraints(\n        constraints: Iterable[ConstraintAndVars],\n        values: Dict[str, Any]\n    ) -> List[Constraint]:\n    '''\n    Call this to debug constraints. Gives feedback on which constraints\n    are not satisfied by the current set of values.\n\n    :param constraints: the list of constraints and the variables\n        they apply to.\n    :param values: dictionary of values.\n    :return: List of failing constraints.\n    '''\n    unsatisfied = []\n    for constr, var_names in constraints:\n        args = []\n        for var_name in var_names:\n            args.append(values[var_name])\n        satisfied = constr(*args)\n        if not satisfied:\n            unsatisfied.append((constr, var_names))\n    return unsatisfied", "def debug_constraints(\n        constraints: Iterable[ConstraintAndVars],\n        values: Dict[str, Any]\n    ) -> List[Constraint]:\n    '''\n    Call this to debug constraints. Gives feedback on which constraints\n    are not satisfied by the current set of values.\n\n    :param constraints: the list of constraints and the variables\n        they apply to.\n    :param values: dictionary of values.\n    :return: List of failing constraints.\n    '''\n    unsatisfied = []\n    for constr, var_names in constraints:\n        args = []\n        for var_name in var_names:\n            args.append(values[var_name])\n        satisfied = constr(*args)\n        if not satisfied:\n            unsatisfied.append((constr, var_names))\n    return unsatisfied", "\n\nclass RandomizationFail:\n    '''\n    Represents one failure to randomize a problem.\n\n    :param variables: List of variables that were randomized.\n    :param constraints: List of tuples, giving constraints that\n        were applied and the variables they apply to.\n    '''\n\n    def __init__(self, variables: Iterable[str], constraints: Iterable[ConstraintAndVars]) -> None:\n        self.variables = variables\n        self.constraints = constraints\n        self.values = []\n        self.failing_constraints = []\n\n    def add_values(self, attempt: int, values: Dict[str, Any]) -> None:\n        '''\n        Adds values to the failed randomization. These values did\n        not satisfy one or more constraints.\n\n        :param attempt: Number of attempts up until this failure.\n        :param values: Dictionary where keys are names of variables,\n            values are the failed values.\n        '''\n        self.values.append((attempt, values))\n        # Try to work out the constraints that are failing.\n        # This may not be possible, depending on the problem we are being passed.\n        try:\n            failing_constraints = debug_constraints(self.constraints, values)\n            self.failing_constraints.append(failing_constraints)\n        except Exception:\n            self.failing_constraints.append('could not compute failing constraints')\n\n    def __str__(self):\n        s = f\"variables: {self.variables}\"\n        s += f\"\\nconstraints: {self.constraints}\"\n        if len(self.values) > 0:\n            s += f\"\\nvalues and failing constraints:\"\n        for (attempt, value_dict), failing_constraints in zip(self.values, self.failing_constraints):\n            s += f\"\\n  attempt: {attempt}  values: {value_dict}\"\n            s += f\" failing constraints: {failing_constraints}\"\n        return s\n\n    def __repr__(self) -> str:\n        return self.__str__()", "\n\nclass RandomizationDebugInfo:\n    '''\n    Contains information about a failing randomization problem.\n\n    Returned as part of a ``RandomizationError``.\n    '''\n\n    def __init__(self) -> None:\n        self.failures = []\n\n    def __str__(self) -> str:\n        s = \"Randomization failure:\"\n        for fail in self.failures:\n            s += \"\\n\" + (str(fail))\n        return s\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\n    def add_failure(self, failure: RandomizationFail):\n        '''\n        Adds a failure object, representing a single\n        randomization failure along the way.\n\n        :param failure: One ``RandomizationFail`` instance\n            to add to the debug info.\n        '''\n        self.failures.append(failure)", ""]}
{"filename": "constrainedrandom/internal/randvar.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\nimport constraint\nfrom functools import partial\nfrom itertools import product\nfrom typing import Any, Callable, Iterable, List, Optional\nimport random\n\nfrom .. import utils", "\nfrom .. import utils\nfrom ..debug import RandomizationDebugInfo, RandomizationFail\nfrom ..random import dist\n\n\ndef get_and_call(getter: Callable, member_fn: str, *args: List[Any]):\n    '''\n    This is a very strange workaround for a very strange issue.\n    ``copy.deepcopy`` can handle a ``partial`` for all other members\n    of ``random.Random``, but not ``getrandbits``. I.e. it correctly\n    copies the other functions and their instance of ``random.Random``,\n    but not ``getrandbits``. The reason for this is unknown.\n\n    This function therefore exists to work around that issue\n    by getting ``getrandbits`` and calling it. I tried many\n    other approaches, but this was the only one that worked.\n\n    :param getter: Getter to call, returning an object that\n        has a member function with name ``member_fn``.\n    :param member_fn: Member function of the the object returned\n        by ``getter``.\n    :param args: Arguments to supply to ``member_fn``.\n    '''\n    callable_obj = getter()\n    fn = getattr(callable_obj, member_fn)\n    return fn(*args)", "\n\nclass RandVar:\n    '''\n    Randomizable variable. For internal use with :class:`RandObj`.\n\n    :param name: The name of this random variable.\n    :param _random: Provides the random generator object this instance will use to\n        create random values. Either provide an existing instance of a :class:`Random`,\n        or leave as ``None`` to use the global Python `random` package.\n    :param order: The solution order for this variable with respect to other variables.\n    :param domain: The possible values for this random variable, expressed either\n        as a ``range``, or as an iterable (e.g. ``list``, ``tuple``) of possible values.\n        Mutually exclusive with ``bits`` and ``fn``.\n    :param bits: Specifies the possible values of this variable in terms of a width\n        in bits. E.g. ``bits=32`` signifies this variable can be ``0 <= x < 1 << 32``.\n        Mutually exclusive with ``domain`` and ``fn``.\n    :param fn: Specifies a function to call that will provide the value of this random\n        variable.\n        Mutually exclusive with ``domain`` and ``bits``.\n    :param args: Arguments to pass to the function specified in ``fn``.\n        If ``fn`` is not used, ``args`` must not be used.\n    :param constraints: List or tuple of constraints that apply to this random variable.\n        Each of these apply only to the individual values in the list, if a length is\n        specified.\n    :param constraints: List or tuple of constraints that apply to this random variable.\n        Each of these apply across the values in the list, if a length is specified.\n    :param length: Specify a length > 0 to turn this variable into a list of random\n        values. A value of 0 means a scalar value. A value >= 1 means a list of that length.\n    :param max_iterations: The maximum number of failed attempts to solve the randomization\n        problem before giving up.\n    :param max_domain_size: The maximum size of domain that a constraint satisfaction problem\n        may take. This is used to avoid poor performance. When a problem exceeds this domain\n        size, we don't use the ``constraint`` package, but just use ``random`` instead.\n    :param disable_naive_list_solver: Attempt to use a faster algorithm for solving\n        list problems. May be faster, but may negatively impact quality of results.\n    '''\n\n    def __init__(self,\n        name: str,\n        *,\n        _random: Optional[random.Random]=None,\n        order: int=0,\n        domain: Optional[utils.Domain]=None,\n        bits: Optional[int]=None,\n        fn: Optional[Callable]=None,\n        args: Optional[tuple]=None,\n        constraints: Optional[Iterable[utils.Constraint]]=None,\n        list_constraints: Optional[Iterable[utils.Constraint]]=None,\n        length: int,\n        max_iterations: int,\n        max_domain_size: int,\n        disable_naive_list_solver: bool,\n    ) -> None:\n        self._random = _random\n        self.name = name\n        self.order = order\n        self.length = length\n        self.max_iterations = max_iterations\n        self.max_domain_size = max_domain_size\n        assert  ((domain is not None) != (fn is not None)) != (bits is not None), \"Must specify exactly one of fn, domain or bits\"\n        if fn is None:\n            assert args is None, \"args has no effect without fn\"\n        self.domain = domain\n        self.bits = bits\n        self.fn = fn\n        self.args = args\n        self.constraints = constraints if constraints is not None else []\n        assert isinstance(self.constraints, list) or isinstance(self.constraints, tuple), \\\n            \"constraints was bad type, should be list or tuple\"\n        if not isinstance(self.constraints, list):\n            self.constraints = list(self.constraints)\n        self.list_constraints = list_constraints if list_constraints is not None else []\n        assert isinstance(self.list_constraints, list) or isinstance(self.list_constraints, tuple), \\\n            \"list_constraints was bad type, should be list or tuple\"\n        if not isinstance(self.list_constraints, list):\n            self.list_constraints = list(self.list_constraints)\n        # Default strategy is to randomize and check the constraints.\n        # List constraints are always checked.\n        self.check_constraints = len(self.constraints) > 0\n        self.randomizer = self.create_randomizer()\n        self.disable_naive_list_solver = disable_naive_list_solver\n\n    def create_randomizer(self) -> Callable:\n        '''\n        Creates a randomizer function that returns an appropriate\n        random value for a single instance of the variable, i.e. a single\n        element of a list or a simple scalar variable.\n        We do this to create a more optimal randomizer than the user might\n        have specified that is functionally equivalent.\n\n        We always return a ``partial`` because these work with\n        ``copy.deepcopy``, whereas locally-defined functions and\n        lambdas can only ever have one instance.\n\n        :return: a function as described.\n        :raises TypeError: if the domain is of a bad type.\n        '''\n        # self.fn, self.bits and self.domain should already be guaranteed\n        # to be mutually exclusive - only one should be non-None.\n        if self.fn is not None:\n            if self.args is not None:\n                return partial(self.fn, *self.args)\n            else:\n                return self.fn\n        elif self.bits is not None:\n            self.domain = range(0, 1 << self.bits)\n            # This is still faster than doing self._get_random().randrange(self.bits << 1),\n            # it seems that getrandbits is 10x faster than randrange.\n            return partial(get_and_call, self._get_random, 'getrandbits', self.bits)\n        else:\n            # Handle possible types of domain.\n            is_range = isinstance(self.domain, range)\n            is_list_or_tuple = isinstance(self.domain, list) or isinstance(self.domain, tuple)\n            is_dict = isinstance(self.domain, dict)\n            # Range, list and tuple are handled nicely by the constraint package.\n            # Other Iterables may not be, e.g. enum.Enum isn't, despite being an Iterable.\n            is_iterable = isinstance(self.domain, Iterable)\n            if is_iterable and not (is_range or is_list_or_tuple or is_dict):\n                # Convert non-dict iterables to a tuple as we don't expect them to need to be mutable,\n                # and tuple ought to be slightly more performant than list.\n                try:\n                    self.domain = tuple(self.domain)\n                except TypeError:\n                    raise TypeError(f'RandVar was passed a domain of bad type - {self.domain}. '\n                                    'This was an Iterable but could not be converted to tuple.')\n                is_list_or_tuple = True\n            if self.check_constraints and (is_range or is_list_or_tuple) and len(self.domain) < self.max_domain_size:\n                # If we are provided a sufficiently small domain and we have constraints, simply construct a\n                # constraint solution problem instead.\n                problem = constraint.Problem()\n                problem.addVariable(self.name, self.domain)\n                for con in self.constraints:\n                    problem.addConstraint(con, (self.name,))\n                # Produces a list of dictionaries - index it up front for very marginal\n                # performance gains\n                solutions = problem.getSolutions()\n                if len(solutions) == 0:\n                    debug_fail = RandomizationFail([self.name],\n                        [(c, (self.name,)) for c in self.constraints])\n                    debug_info = RandomizationDebugInfo()\n                    debug_info.add_failure(debug_fail)\n                    raise utils.RandomizationError(\"Variable was unsolvable. Check constraints.\", debug_info)\n                solution_list = [s[self.name] for s in solutions]\n                self.check_constraints = False\n                return partial(self._get_random().choice, solution_list)\n            elif is_range:\n                return partial(self._get_random().randrange, self.domain.start, self.domain.stop)\n            elif is_list_or_tuple:\n                return partial(self._get_random().choice, self.domain)\n            elif is_dict:\n                rand = self._get_random()\n                if rand is random:\n                    # Don't store a module in a partial as this can't be copied.\n                    # dist defaults to using the global random module.\n                    return partial(dist, self.domain)\n                return partial(dist, self.domain, rand)\n            else:\n                raise TypeError(f'RandVar was passed a domain of a bad type - {self.domain}. '\n                                'Domain should be a range, list, tuple, dictionary or other Iterable.')\n\n    def add_constraint(self, constr: utils.Constraint) -> None:\n        '''\n        Add a single constraint to this variable.\n\n        :param constr: Constraint to add.\n        '''\n        if self.length > 0:\n            # Treat all additional constraints as list constraints,\n            # although this is a little less performant.\n            self.list_constraints.append(constr)\n        else:\n            # For adding scalar constraints, reevalute whether we can\n            # still use a CSP - recreate the randomizer.\n            self.constraints.append(constr)\n            self.check_constraints = True\n            self.randomizer = self.create_randomizer()\n\n    def _get_random(self) -> random.Random:\n        '''\n        Internal function to get the appropriate randomization object.\n\n        We can't store the package ``random`` in a member variable as this\n        prevents pickling.\n\n        :return: The appropriate random generator.\n        '''\n        if self._random is None:\n            return random\n        return self._random\n\n    def get_domain_size(self) -> int:\n        '''\n        Return total domain size, accounting for length of this random variable.\n\n        :return: domain size, integer.\n        '''\n        if self.domain is None:\n            # If there's no domain, it means we can't estimate the complexity\n            # of this variable. Return 1.\n            return 1\n        else:\n            # length == 0 implies a scalar variable, 1 is a list of length 1\n            if self.length == 0 or self.length == 1:\n                return len(self.domain)\n            else:\n                # In this case it is effectively cartesian product, i.e.\n                # n ** k, where n is the size of the domain and k is the length\n                # of the list.\n                return len(self.domain) ** self.length\n\n    def can_use_with_constraint(self) -> bool:\n        '''\n        Check whether this random variable can be used in a\n        ``constraint.Problem`` or not.\n        Note this isn't depenedent on the domain size, just\n        purely whether it will work.\n\n        :return: bool, True if it can be used with ``constraint.Problem``.\n        '''\n        # constraint can handle the variable as long as it has a domain\n        # and the domain isn't a dictionary.\n        return self.domain is not None and not isinstance(self.domain, dict)\n\n    def get_constraint_domain(self) -> utils.Domain:\n        '''\n        Get a ``constraint`` package friendly version of the domain\n        of this random variable.\n\n        :return: the variable's domain in a format that will work\n            with the ``constraint`` package.\n        '''\n        if self.length == 0:\n            # Straightforward, scalar\n            return self.domain\n        elif self.length == 1:\n            # List of length one\n            return [[x] for x in self.domain]\n        else:\n            # List of greater length, cartesian product.\n            # Beware that this may be an extremely large domain.\n            # Ensure each element is of type list, which is what\n            # we want to return.\n            return [list(x) for x in product(self.domain, repeat=self.length)]\n\n    def randomize_once(self, constraints: Iterable[utils.Constraint], check_constraints: bool, debug: bool) -> Any:\n        '''\n        Get one random value that satisfies the constraints.\n\n        :param constraints: The constraints that apply to this randomization.\n        :param check_constraints: Whether constraints need to be checked.\n        :param debug: ``True`` to run in debug mode. Slower, but collects\n            all debug info along the way and not just the final failure.\n        :return: A random value for the variable, respecting the constraints.\n        :raises RandomizationError: When the problem cannot be solved in fewer than\n            the allowed number of iterations.\n        '''\n        value = self.randomizer()\n        if not check_constraints:\n            return value\n        value_valid = False\n        iterations = 0\n        if debug:\n            # Collect failures as we go along\n            debug_fail = RandomizationFail([self.name],\n                [(c, (self.name,)) for c in constraints])\n        while not value_valid:\n            if iterations == self.max_iterations:\n                if not debug:\n                    # Just capture the most recent value\n                    debug_fail = RandomizationFail([self.name],\n                        [(c, (self.name,)) for c in constraints])\n                debug_fail.add_values(iterations, {self.name: value})\n                debug_info = RandomizationDebugInfo()\n                debug_info.add_failure(debug_fail)\n                raise utils.RandomizationError(\"Too many iterations, can't solve problem\", debug_fail)\n            problem = constraint.Problem()\n            problem.addVariable(self.name, (value,))\n            for con in constraints:\n                problem.addConstraint(con, (self.name,))\n            value_valid = problem.getSolution() is not None\n            if not value_valid:\n                if debug:\n                    # Capture all failing values as we go\n                    debug_fail.add_values(iterations, {self.name: value})\n                value = self.randomizer()\n            iterations += 1\n        return value\n\n    def randomize_list_csp(\n        self,\n        constraints: Iterable[utils.Constraint],\n        list_constraints: Iterable[utils.Constraint],\n    ):\n        '''\n        Use a CSP to get a full set of soltuons for the random list,\n        fulfilling the constraints. Selects and returns one randomization.\n        Should only be used when the domain is suitably small.\n\n        :param constraints: The constraints that apply to this randomization.\n            These are scalar constraints, i.e. on each individual element of\n            the list.\n        :param list_constraints: The constraints that apply to the entire list.\n        :return: A random list of values for the variable, respecting\n            the constraints.\n        '''\n        problem = constraint.Problem()\n        possible_values = self.get_constraint_domain()\n        # Prune possibilities according to scalar constraints.\n        possible_values = [x for x in possible_values \\\n            if all(constr(val) for val in x for constr in constraints)]\n        problem.addVariable(self.name, possible_values)\n        for con in list_constraints:\n            problem.addConstraint(con, (self.name,))\n        solutions = problem.getSolutions()\n        if len(solutions) == 0:\n            debug_fail = RandomizationFail([self.name],\n                [(con, (self.name,)) for con in list_constraints])\n            debug_info = RandomizationDebugInfo()\n            debug_info.add_failure(debug_fail)\n            raise utils.RandomizationError(\"Problem was unsolvable.\", debug_info)\n        values = self._get_random().choice(solutions)[self.name]\n        return values\n\n    def randomize_list_naive(\n        self,\n        constraints: Iterable[utils.Constraint],\n        check_constraints: bool,\n        list_constraints: Iterable[utils.Constraint],\n        debug : bool,\n        debug_fail: Optional[RandomizationFail],\n    ):\n        '''\n        Naive algorithm to randomize a random list of values, and check\n        it against the constraints. Faster than CSP as long as it's a simple\n        problem. Prone to failure.\n\n        :param constraints: The constraints that apply to this randomization.\n            These are scalar constraints, i.e. on each individual element of\n            the list.\n        :param check_constraints: Whether constraints need to be checked.\n        :param list_constraints: The constraints that apply to the entire list.\n        :param debug: ``True`` to run in debug mode. Slower, but collects\n            all debug info along the way and not just the final failure.\n        :param debug_fail: :class:`RandomizationFail` containing debug info,\n            if in debug mode, else ``None``.\n        :return: A random list of values for the variable, respecting\n            the constraints.\n        '''\n        values = [self.randomize_once(constraints, check_constraints, debug) \\\n            for _ in range(self.length)]\n        values_valid = len(list_constraints) == 0\n        iterations = 0\n        max_iterations = self.max_iterations\n        while not values_valid:\n            if iterations >= max_iterations:\n                # This method has failed.\n                return None\n            problem = constraint.Problem()\n            problem.addVariable(self.name, (values,))\n            for con in list_constraints:\n                problem.addConstraint(con, (self.name,))\n            values_valid = problem.getSolution() is not None\n            if not values_valid:\n                if debug:\n                    # Capture all failing values as we go\n                    debug_fail.add_values(iterations, {self.name: values})\n                iterations += 1\n                values = [self.randomize_once(constraints, check_constraints, debug) \\\n                    for _ in range(self.length)]\n        return values\n\n    def randomize_list_subset(\n        self,\n        constraints: Iterable[utils.Constraint],\n        check_constraints: bool,\n        list_constraints: Iterable[utils.Constraint],\n        debug : bool,\n        debug_fail: Optional[RandomizationFail],\n    ):\n        '''\n        Algorithm that attempts to ensure forward progress when randomizing\n        a random list. Over-constrains the problem slightly. Aims to converage\n        quickly while still giving good quality of results.\n\n        :param constraints: The constraints that apply to this randomization.\n            These are scalar constraints, i.e. on each individual element of\n            the list.\n        :param check_constraints: Whether constraints need to be checked.\n        :param list_constraints: The constraints that apply to the entire list.\n        :param debug: ``True`` to run in debug mode. Slower, but collects\n            all debug info along the way and not just the final failure.\n        :param debug_fail: :class:`RandomizationFail` containing debug info,\n            if in debug mode, else ``None``.\n        :return: A random list of values for the variable, respecting\n            the constraints.\n        :raises RandomizationError: When the problem cannot be solved in fewer than\n            the allowed number of iterations.\n        '''\n        values = [self.randomize_once(constraints, check_constraints, debug) \\\n            for _ in range(self.length)]\n        values_valid = len(list_constraints) == 0\n        iterations = 0\n        # Allow more attempts at a list, as it may be computationally hard.\n        # Assume it's linearly harder.\n        max_iterations = self.max_iterations * self.length\n        checked = []\n        while not values_valid:\n            iterations += 1\n            if iterations >= max_iterations:\n                if not debug:\n                    # Create the debug info 'late', only capturing the final\n                    # set of values.\n                    debug_fail = RandomizationFail([self.name],\n                        [(c, (self.name,)) for c in list_constraints])\n                debug_fail.add_values(iterations, {self.name: values})\n                debug_info = RandomizationDebugInfo()\n                debug_info.add_failure(debug_fail)\n                raise utils.RandomizationError(\"Too many iterations, can't solve problem\", debug_info)\n            # Keep a subset of the answer, to try to ensure forward progress.\n            min_group_size = len(checked) + 1\n            for idx in range(min_group_size, self.length):\n                tmp_values = values[:idx]\n                problem = constraint.Problem()\n                problem.addVariable(self.name, (tmp_values,))\n                for con in list_constraints:\n                    problem.addConstraint(con, (self.name,))\n                # This may fail if the user is relying on the\n                # list being fully-sized in their constraint.\n                try:\n                    tmp_values_valid = problem.getSolution() is not None\n                except Exception:\n                    tmp_values_valid = False\n                if tmp_values_valid:\n                    # Use these values and continue this loop,\n                    # adding to the checked values if more\n                    # values satisfy the constraints.\n                    # Check the entire list to ensure maximum\n                    # degrees of freedom.\n                    checked = tmp_values\n            values = checked + [self.randomize_once(constraints, check_constraints, debug) \\\n                for _ in range(self.length - len(checked))]\n            problem = constraint.Problem()\n            problem.addVariable(self.name, (values,))\n            for con in list_constraints:\n                problem.addConstraint(con, (self.name,))\n            values_valid = problem.getSolution() is not None\n            if debug and not values_valid:\n                # Capture failure info as we go along\n                debug_fail.add_values(iterations, {self.name: values})\n        return values\n\n    def randomize(\n        self,\n        temp_constraints: Optional[Iterable[utils.Constraint]]=None,\n        debug: bool=False\n    ) -> Any:\n        '''\n        Returns a random value based on the definition of this random variable.\n        Does not modify the state of the :class:`RandVar` instance.\n\n        :param temp_constraints: Temporary constraints to apply only for\n            this randomization.\n        :return: A randomly generated value, conforming to the definition of\n            this random variable, its constraints, etc.\n        :raises RandomizationError: When the problem cannot be solved in fewer than\n            the allowed number of iterations.\n        '''\n        check_constraints = self.check_constraints\n        # Handle temporary constraints. Start with copy of existing constraints,\n        # adding any temporary ones in.\n        constraints = list(self.constraints)\n        using_temp_constraints = temp_constraints is not None and len(temp_constraints) > 0\n        if self.length == 0:\n            # Interpret temporary constraints as scalar constraints\n            if using_temp_constraints:\n                check_constraints = True\n                constraints += temp_constraints\n            return self.randomize_once(constraints, check_constraints, debug)\n        else:\n            list_constraints = list(self.list_constraints)\n            # Interpret temporary constraints as list constraints\n            if using_temp_constraints:\n                list_constraints += temp_constraints\n            # Create list of values and check after that list constraints\n            # are followed.\n            # We can't check as we go along as this artificially limits\n            # the values that can be selected. E.g. if you have a constraint\n            # that says the values sum to zero, you would only ever\n            # end up with an all-zero list if you enforced the constraint\n            # at each iteration.\n            # Try to construct a constraint solution problem, if possible.\n            check_list_constraints = len(list_constraints) > 0\n            use_csp = check_list_constraints and self.can_use_with_constraint() \\\n                    and self.get_domain_size() <= self.max_domain_size\n            if use_csp:\n                return self.randomize_list_csp(constraints, list_constraints)\n            else:\n                # Otherwise, just randomize and check.\n                if debug:\n                    # Collect failures as we go along\n                    debug_fail = RandomizationFail([self.name],\n                        [(c, (self.name,)) for c in list_constraints])\n                else:\n                    debug_fail = None\n                # Start by purely randomizing and checking, unless\n                # naive mode disabled.\n                if not self.disable_naive_list_solver:\n                    values = self.randomize_list_naive(constraints, \\\n                        check_constraints, list_constraints, debug, debug_fail)\n                    if values is not None:\n                        return values\n                # If the above fails, use a slightly smarter algorithm,\n                # which is more likely to make forward progress, but\n                # might also restrict value selection.\n                # No fallback if this fails.\n                return self.randomize_list_subset(constraints, \\\n                    check_constraints, list_constraints, debug, debug_fail)", ""]}
{"filename": "constrainedrandom/internal/vargroup.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\nimport constraint\nfrom functools import cached_property\nfrom typing import Any, Dict, List, Tuple, TYPE_CHECKING, Union\n\nfrom .. import utils\nfrom ..debug import RandomizationDebugInfo, RandomizationFail\n\nif TYPE_CHECKING:\n    from ..internal.randvar import RandVar", "from ..debug import RandomizationDebugInfo, RandomizationFail\n\nif TYPE_CHECKING:\n    from ..internal.randvar import RandVar\n\n\nclass VarGroup:\n    '''\n    Represents a group of random variables to be solved together.\n\n    Determines which variables in the group can be solved via a\n    constraint problem and which ones must be randomized and checked.\n    (Used internally by :class:`MultiVarProblem`).\n\n    :param group: List of random variables in this group.\n    :param solved vars: List of variable names that are already solved.\n    :param problem: Constraint problem to add variables and constraints to.\n        Note that the instance will be modified by this function.\n    :param constraints: Constraints that still apply at this stage of\n        solving the problem.\n    :param max_domain_size: The maximum size of domain that a constraint satisfaction problem\n        may take. This is used to avoid poor performance. When a problem exceeds this domain\n        size, we don't use the ``constraint`` package, but just use ``random`` instead.\n    :param debug: ``True`` to run in debug mode. Slower, but collects\n        all debug info along the way and not just the final failure.\n    :return: A tuple of 1) a list the names of the variables in the group,\n        2) a list of variables that must be randomized rather than solved\n        via a constraint problem,\n        3) a list of constraints and variables that won't be applied for this group.\n    '''\n\n    def __init__(\n        self,\n        group: List['RandVar'],\n        solved_vars: List[str],\n        problem: constraint.Problem,\n        constraints: List[utils.ConstraintAndVars],\n        max_domain_size: int,\n        debug: bool,\n    ) -> None:\n        self.group_vars: List[str] = []\n        self.rand_vars: List['RandVar'] = []\n        self.raw_constraints: List[utils.ConstraintAndVars] = []\n        self.problem = problem\n        self.max_domain_size = max_domain_size\n        self.debug = debug\n\n        # Construct a constraint problem where possible. A variable must have a domain\n        # in order to be part of the problem. If it doesn't have one, it must just be\n        # randomized. Also take care not to exceed tha maximum domain size for an\n        # individual variable.\n        for var in group:\n            self.group_vars.append(var.name)\n            if var.can_use_with_constraint() and var.get_domain_size() < self.max_domain_size:\n                self.problem.addVariable(var.name, var.get_constraint_domain())\n                # If variable has its own constraints, these must be added to the problem,\n                # regardless of whether var.check_constraints is true, as the var's value will\n                # depend on the value of the other constrained variables in the problem.\n                for con in var.constraints:\n                    self.problem.addConstraint(con, (var.name,))\n                    self.raw_constraints.append((con, (var.name,)))\n            else:\n                self.rand_vars.append(var)\n\n        # Add all pertinent constraints\n        self.skipped_constraints = []\n        for (con, vars) in constraints:\n            skip = False\n            for var in vars:\n                if var not in self.group_vars and var not in solved_vars:\n                    # Skip this constraint\n                    skip = True\n                    break\n            if skip:\n                self.skipped_constraints.append((con, vars))\n                continue\n            self.problem.addConstraint(con, vars)\n            self.raw_constraints.append((con, vars))\n\n    @cached_property\n    def debug_fail(self):\n        '''\n        Cached property, instance of ``RandomizationFail`` that\n        corresponds to this problem.\n        '''\n        failing_constraints = list(self.raw_constraints)\n        for var in self.rand_vars:\n            failing_constraints += [(constr, (var.name,)) for constr in var.constraints]\n        return RandomizationFail(list(self.group_vars), failing_constraints)\n\n    def can_retry(self):\n        '''\n        Call this to determine whether or not retrying ``solve``\n        can have a different outcome.\n\n        :return: ``True`` if calling ``solve`` again might yield\n            a different result (assuming it has already been called.)\n            ``False`` otherwise.\n        '''\n        return len(self.rand_vars) > 0\n\n    def solve(\n        self,\n        max_iterations: int,\n        solutions_per_group: int,\n        debug_info: RandomizationDebugInfo,\n    ) -> Union[List[Dict[str, Any]], None]:\n        '''\n        Attempts to solve one group of variables. Preferentially uses a constraint\n        satisfaction problem, but may need to randomize variables that can't be\n        added to a constraint satisfaction problem.\n        (Used internally by :class:`MultiVarProblem`).\n\n        :param max_iterations: Maximum number of attempts to solve the problem\n            before giving up.\n        :solutions_per_group: How many random values to produce before attempting\n            to solve the constraint satisfaction problem. A lower value will run\n            quicker but has less chance to succeed.\n        :param debug_info: :class:`RandomizationDebugInfo`` instance to collect\n            any debug info.\n        :return: A list of all possible solutions for the group, or ``None`` if\n            it can't be solved within ``max_iterations`` attempts.\n        '''\n        # Problem is ready to solve, apart from random variables\n        solutions = []\n        attempts = 0\n        if len(self.rand_vars) > 0:\n            # If we have additional random variables, randomize and check\n            while True:\n                for var in self.rand_vars:\n                    # Add random variables in with a concrete value\n                    if solutions_per_group == 1:\n                        self.problem.addVariable(var.name, (var.randomize(),))\n                    else:\n                        iterations = self.max_domain_size if solutions_per_group is None else solutions_per_group\n                        var_domain = []\n                        for _ in range(iterations):\n                            val = var.randomize()\n                            # List is ~2x slower than set for 'in',\n                            # but variables might be non-hashable.\n                            if val not in var_domain:\n                                var_domain.append(val)\n                        self.problem.addVariable(var.name, var_domain)\n                solutions = self.problem.getSolutions()\n                if len(solutions) > 0:\n                    break\n                else:\n                    attempts += 1\n                    # Always output debug info on the last attempt.\n                    failed = attempts >= max_iterations\n                    debug = self.debug or (solutions_per_group is None and failed)\n                    for var in self.rand_vars:\n                        # Remove from problem, they will be re-added with different concrete values\n                        del self.problem._variables[var.name]\n                    if debug:\n                        self.debug_fail.add_values(attempts, dict(self.problem._variables))\n                    if failed:\n                        # We have failed, give up\n                        debug_info.add_failure(self.debug_fail)\n                        return None\n\n        else:\n            # Otherwise, just get the solutions, no randomization required.\n            solutions = self.problem.getSolutions()\n            if len(solutions) == 0:\n                # Failed\n                debug_info.add_failure(self.debug_fail)\n                return None\n\n        return solutions", ""]}
{"filename": "constrainedrandom/internal/__init__.py", "chunked_list": [""]}
{"filename": "constrainedrandom/internal/multivar.py", "chunked_list": ["# SPDX-License-Identifier: MIT\n# Copyright (c) 2023 Imagination Technologies Ltd. All Rights Reserved\n\nimport constraint\nfrom collections import defaultdict\nfrom typing import Any, Dict, Iterable, List, Optional, TYPE_CHECKING, Tuple, Union\n\nfrom .vargroup import VarGroup\n\nfrom .. import utils", "\nfrom .. import utils\nfrom ..debug import RandomizationDebugInfo, RandomizationFail\n\nif TYPE_CHECKING:\n    from ..randobj import RandObj\n    from ..internal.randvar import RandVar\n\n\nclass MultiVarProblem:\n    '''\n    Multi-variable problem. Used internally by RandObj.\n    Represents one problem concerning multiple random variables,\n    where those variables all share dependencies on one another.\n\n    :param parent: The :class:`RandObj` instance that owns this instance.\n    :param vars: The dictionary of names and :class:`RandVar` instances this problem consists of.\n    :param constraints: An iterable of tuples of (constraint, (variables,...)) denoting\n        the constraints and the variables they apply to.\n    :param max_iterations: The maximum number of failed attempts to solve the randomization\n        problem before giving up.\n    :param max_domain_size: The maximum size of domain that a constraint satisfaction problem\n        may take. This is used to avoid poor performance. When a problem exceeds this domain\n        size, we don't use the ``constraint`` package, but just use ``random`` instead.\n        For :class:`MultiVarProblem`, we also use this to determine the maximum size of a\n        solution group.\n    '''\n\n    def __init__(\n        self,\n        parent: 'RandObj',\n        vars: List['RandVar'],\n        constraints: Iterable[utils.ConstraintAndVars],\n        max_iterations: int,\n        max_domain_size: int,\n    ) -> None:\n        self.parent = parent\n        self.vars = vars\n        self.constraints = constraints\n        self.max_iterations = max_iterations\n        self.max_domain_size = max_domain_size\n        self.order = None\n        self.debug = False\n        self.debug_info = None\n\n    def determine_order(self, with_values: Dict[str, Any]) -> List[List['RandVar']]:\n        '''\n        Chooses an order in which to resolve the values of the variables.\n        Used internally.\n\n        :param with_values: Dictionary of variables with set values for this\n            randomization.\n        :return: A list of lists denoting the order in which to solve the problem.\n            Each inner list is a group of variables that can be solved at the same\n            time. Each inner list will be considered separately.\n        '''\n        # Use 'cached' version if no concrete values are specified\n        problem_changed = len(with_values) != 0\n        if not problem_changed and self.order is not None:\n            return self.order\n\n        # Aim to build a list of lists, each inner list denoting a group of variables\n        # to solve at the same time.\n        # The best case is to simply solve them all at once, if possible, however it is\n        # likely that the domain will be too large.\n        # If values are provided, simply don't add those variables to the ordering problem.\n        if problem_changed:\n            vars = []\n            for var in self.vars:\n                if var.name not in with_values:\n                    vars.append(var)\n        else:\n            vars = list(self.vars)\n\n        # Use order hints first, remaining variables can be placed anywhere the domain\n        # isn't too large.\n        sorted_vars = sorted(vars, key=lambda x: x.order)\n\n        # Currently this is just a flat list. Group into as large groups as possible.\n        result = [[sorted_vars[0]]]\n        index = 0\n        domain_size = sorted_vars[0].get_domain_size()\n        for var in sorted_vars[1:]:\n            domain_size = domain_size * var.get_domain_size()\n            if var.order == result[index][0].order and domain_size < self.max_domain_size:\n                # Put it in the same group as the previous one, carry on\n                result[index].append(var)\n            else:\n                # Make a new group\n                index += 1\n                domain_size = var.get_domain_size()\n                result.append([var])\n\n        if not problem_changed:\n            self.order = result\n\n        return result\n\n    def solve_groups(\n        self,\n        groups: List[List['RandVar']],\n        with_values: Dict[str, Any],\n        max_iterations: int,\n        solutions_per_group: Optional[int]=None,\n    ) -> Union[Dict[str, Any], None]:\n        '''\n        Constraint solving algorithm. (Used internally by :class:`MultiVarProblem`)\n\n        :param groups: The list of lists denoting the order in which to resolve the random variables.\n            See :func:`determine_order`.\n        :param with_values: Dictionary of variables with set values for this\n            randomization.\n        :param max_iterations: The maximum number of failed attempts to solve the randomization\n            problem before giving up.\n        :param solutions_per_group: If ``solutions_per_group`` is not ``None``,\n            solve each constraint group problem 'sparsely',\n            i.e. maintain only a subset of potential solutions between groups.\n            Fast but prone to failure.\n\n            ``solutions_per_group = 1`` is effectively a depth-first search through the state space\n            and comes with greater benefits of considering each multi-variable constraint at\n            most once.\n\n            If ``solutions_per_group`` is ``None``, Solve constraint problem 'thoroughly',\n            i.e. keep all possible results between iterations.\n            Slow, but will usually converge.\n        :returns: A valid solution to the problem, in the form of a dictionary with the\n            names of the random variables as keys and the valid solution as the values.\n            Returns ``None`` if no solution is found within the allotted ``max_iterations``.\n        '''\n        constraints = self.constraints\n        sparse_solver = solutions_per_group is not None\n        solutions = []\n        solved_vars = []\n\n        # Respect assigned temporary values\n        if len(with_values) > 0:\n            for var_name in with_values.keys():\n                solved_vars.append(var_name)\n            solutions.append(with_values)\n\n        # If solving sparsely, we'll create a new problem for each group.\n        # If not solving sparsely, just create one big problem that we add to\n        # as we go along.\n        if not sparse_solver:\n            problem = constraint.Problem()\n            for var_name, value in with_values.items():\n                problem.addVariable(var_name, (value,))\n\n        for group in groups:\n            if sparse_solver:\n                # Construct one problem per group, add solved variables from previous groups.\n                problem = constraint.Problem()\n            # Construct the appropriate group variable problem\n            group_problem = VarGroup(\n                group,\n                solved_vars,\n                problem,\n                constraints,\n                self.max_domain_size,\n                self.debug,\n            )\n\n            group_solutions = None\n            attempts = 0\n            while group_solutions is None or len(group_solutions) == 0:\n                if attempts >= max_iterations:\n                    # We have failed, give up\n                    return None\n                if attempts > 0 and not group_problem.can_retry():\n                    # Not worth retrying - the same result will be obtained.\n                    return None\n                if sparse_solver:\n                    if len(solutions) > 0:\n                        # Respect a proportion of the solution space, determined\n                        # by the sparsity/solutions_per_group.\n                        if solutions_per_group >= len(solutions):\n                            solution_subset = solutions\n                        else:\n                            solution_subset = self.parent._get_random().choices(\n                                solutions,\n                                k=solutions_per_group\n                            )\n                        if solutions_per_group == 1:\n                            for var_name, value in solution_subset[0].items():\n                                if var_name in problem._variables:\n                                    del problem._variables[var_name]\n                                problem.addVariable(var_name, (value,))\n                        else:\n                            solution_space = defaultdict(list)\n                            for soln in solution_subset:\n                                for var_name, value in soln.items():\n                                    # List is ~2x slower than set for 'in',\n                                    # but variables might be non-hashable.\n                                    if value not in solution_space[var_name]:\n                                        solution_space[var_name].append(value)\n                            for var_name, values in solution_space.items():\n                                if var_name in problem._variables:\n                                    del problem._variables[var_name]\n                                problem.addVariable(var_name, values)\n\n                # Attempt to solve the group\n                group_solutions = group_problem.solve(\n                    max_iterations,\n                    solutions_per_group,\n                    self.debug_info,\n                )\n                attempts += 1\n\n            # This group is solved, move on to the next group.\n            if solutions_per_group == 1:\n                # This means we have exactly one solution for the variables considered so far,\n                # meaning we don't need to re-apply solved constraints for future groups.\n                constraints = group_problem.skipped_constraints\n            solved_vars += group_problem.group_vars\n            solutions = group_solutions\n\n        return self.parent._get_random().choice(solutions)\n\n    def solve(\n        self,\n        sparse: bool,\n        thorough: bool,\n        with_values: Optional[Dict[str, Any]]=None,\n        debug: bool=False,\n    ) -> Union[Dict[str, Any], None]:\n        '''\n        Attempt to solve the variables with respect to the constraints.\n\n        :param with_values: Dictionary of variables with set values for this\n            randomization.\n        :return: One valid solution for the randomization problem, represented as\n            a dictionary with keys referring to the named variables.\n        :param debug: ``True`` to run in debug mode. Slower, but collects\n            all debug info along the way and not just the final failure.\n        :raises RandomizationError: When the problem cannot be solved in fewer than\n            the allowed number of iterations.\n        '''\n        with_values = {} if with_values is None else with_values\n        groups = self.determine_order(with_values)\n        solution = None\n        # Create debug info in case of failure\n        self.debug_info = RandomizationDebugInfo()\n        self.debug = debug\n\n        # Try to solve sparsely first\n        if sparse:\n            sparsities = [1, 10, 100, 1000]\n            # The worst-case value of the number of iterations for one sparsity level is:\n            # iterations_per_sparsity * iterations_per_attempt\n            # because of the call to solve_groups hitting iterations_per_attempt.\n            # Failing individual solution attempts speeds up some problems greatly,\n            # this can be thought of as pruning explorations of the state tree.\n            # So, reduce iterations_per_attempt by an order of magnitude.\n            iterations_per_sparsity = self.max_iterations\n            # Ensure it's non-zero\n            iterations_per_attempt = (self.max_iterations // 10) + 1\n            for sparsity in sparsities:\n                for _ in range(iterations_per_sparsity):\n                    solution = self.solve_groups(\n                        groups=groups,\n                        with_values=with_values,\n                        max_iterations=iterations_per_attempt,\n                        solutions_per_group=sparsity,\n                    )\n                    if solution is not None and len(solution) > 0:\n                        return solution\n\n        if thorough:\n            # Try 'thorough' method - no backup plan if this fails\n            solution = self.solve_groups(\n                groups=groups,\n                with_values=with_values,\n                max_iterations=self.max_iterations,\n                solutions_per_group=None,\n            )\n        if solution is None:\n            raise utils.RandomizationError(\"Could not solve problem.\", self.debug_info)\n        return solution", "\nclass MultiVarProblem:\n    '''\n    Multi-variable problem. Used internally by RandObj.\n    Represents one problem concerning multiple random variables,\n    where those variables all share dependencies on one another.\n\n    :param parent: The :class:`RandObj` instance that owns this instance.\n    :param vars: The dictionary of names and :class:`RandVar` instances this problem consists of.\n    :param constraints: An iterable of tuples of (constraint, (variables,...)) denoting\n        the constraints and the variables they apply to.\n    :param max_iterations: The maximum number of failed attempts to solve the randomization\n        problem before giving up.\n    :param max_domain_size: The maximum size of domain that a constraint satisfaction problem\n        may take. This is used to avoid poor performance. When a problem exceeds this domain\n        size, we don't use the ``constraint`` package, but just use ``random`` instead.\n        For :class:`MultiVarProblem`, we also use this to determine the maximum size of a\n        solution group.\n    '''\n\n    def __init__(\n        self,\n        parent: 'RandObj',\n        vars: List['RandVar'],\n        constraints: Iterable[utils.ConstraintAndVars],\n        max_iterations: int,\n        max_domain_size: int,\n    ) -> None:\n        self.parent = parent\n        self.vars = vars\n        self.constraints = constraints\n        self.max_iterations = max_iterations\n        self.max_domain_size = max_domain_size\n        self.order = None\n        self.debug = False\n        self.debug_info = None\n\n    def determine_order(self, with_values: Dict[str, Any]) -> List[List['RandVar']]:\n        '''\n        Chooses an order in which to resolve the values of the variables.\n        Used internally.\n\n        :param with_values: Dictionary of variables with set values for this\n            randomization.\n        :return: A list of lists denoting the order in which to solve the problem.\n            Each inner list is a group of variables that can be solved at the same\n            time. Each inner list will be considered separately.\n        '''\n        # Use 'cached' version if no concrete values are specified\n        problem_changed = len(with_values) != 0\n        if not problem_changed and self.order is not None:\n            return self.order\n\n        # Aim to build a list of lists, each inner list denoting a group of variables\n        # to solve at the same time.\n        # The best case is to simply solve them all at once, if possible, however it is\n        # likely that the domain will be too large.\n        # If values are provided, simply don't add those variables to the ordering problem.\n        if problem_changed:\n            vars = []\n            for var in self.vars:\n                if var.name not in with_values:\n                    vars.append(var)\n        else:\n            vars = list(self.vars)\n\n        # Use order hints first, remaining variables can be placed anywhere the domain\n        # isn't too large.\n        sorted_vars = sorted(vars, key=lambda x: x.order)\n\n        # Currently this is just a flat list. Group into as large groups as possible.\n        result = [[sorted_vars[0]]]\n        index = 0\n        domain_size = sorted_vars[0].get_domain_size()\n        for var in sorted_vars[1:]:\n            domain_size = domain_size * var.get_domain_size()\n            if var.order == result[index][0].order and domain_size < self.max_domain_size:\n                # Put it in the same group as the previous one, carry on\n                result[index].append(var)\n            else:\n                # Make a new group\n                index += 1\n                domain_size = var.get_domain_size()\n                result.append([var])\n\n        if not problem_changed:\n            self.order = result\n\n        return result\n\n    def solve_groups(\n        self,\n        groups: List[List['RandVar']],\n        with_values: Dict[str, Any],\n        max_iterations: int,\n        solutions_per_group: Optional[int]=None,\n    ) -> Union[Dict[str, Any], None]:\n        '''\n        Constraint solving algorithm. (Used internally by :class:`MultiVarProblem`)\n\n        :param groups: The list of lists denoting the order in which to resolve the random variables.\n            See :func:`determine_order`.\n        :param with_values: Dictionary of variables with set values for this\n            randomization.\n        :param max_iterations: The maximum number of failed attempts to solve the randomization\n            problem before giving up.\n        :param solutions_per_group: If ``solutions_per_group`` is not ``None``,\n            solve each constraint group problem 'sparsely',\n            i.e. maintain only a subset of potential solutions between groups.\n            Fast but prone to failure.\n\n            ``solutions_per_group = 1`` is effectively a depth-first search through the state space\n            and comes with greater benefits of considering each multi-variable constraint at\n            most once.\n\n            If ``solutions_per_group`` is ``None``, Solve constraint problem 'thoroughly',\n            i.e. keep all possible results between iterations.\n            Slow, but will usually converge.\n        :returns: A valid solution to the problem, in the form of a dictionary with the\n            names of the random variables as keys and the valid solution as the values.\n            Returns ``None`` if no solution is found within the allotted ``max_iterations``.\n        '''\n        constraints = self.constraints\n        sparse_solver = solutions_per_group is not None\n        solutions = []\n        solved_vars = []\n\n        # Respect assigned temporary values\n        if len(with_values) > 0:\n            for var_name in with_values.keys():\n                solved_vars.append(var_name)\n            solutions.append(with_values)\n\n        # If solving sparsely, we'll create a new problem for each group.\n        # If not solving sparsely, just create one big problem that we add to\n        # as we go along.\n        if not sparse_solver:\n            problem = constraint.Problem()\n            for var_name, value in with_values.items():\n                problem.addVariable(var_name, (value,))\n\n        for group in groups:\n            if sparse_solver:\n                # Construct one problem per group, add solved variables from previous groups.\n                problem = constraint.Problem()\n            # Construct the appropriate group variable problem\n            group_problem = VarGroup(\n                group,\n                solved_vars,\n                problem,\n                constraints,\n                self.max_domain_size,\n                self.debug,\n            )\n\n            group_solutions = None\n            attempts = 0\n            while group_solutions is None or len(group_solutions) == 0:\n                if attempts >= max_iterations:\n                    # We have failed, give up\n                    return None\n                if attempts > 0 and not group_problem.can_retry():\n                    # Not worth retrying - the same result will be obtained.\n                    return None\n                if sparse_solver:\n                    if len(solutions) > 0:\n                        # Respect a proportion of the solution space, determined\n                        # by the sparsity/solutions_per_group.\n                        if solutions_per_group >= len(solutions):\n                            solution_subset = solutions\n                        else:\n                            solution_subset = self.parent._get_random().choices(\n                                solutions,\n                                k=solutions_per_group\n                            )\n                        if solutions_per_group == 1:\n                            for var_name, value in solution_subset[0].items():\n                                if var_name in problem._variables:\n                                    del problem._variables[var_name]\n                                problem.addVariable(var_name, (value,))\n                        else:\n                            solution_space = defaultdict(list)\n                            for soln in solution_subset:\n                                for var_name, value in soln.items():\n                                    # List is ~2x slower than set for 'in',\n                                    # but variables might be non-hashable.\n                                    if value not in solution_space[var_name]:\n                                        solution_space[var_name].append(value)\n                            for var_name, values in solution_space.items():\n                                if var_name in problem._variables:\n                                    del problem._variables[var_name]\n                                problem.addVariable(var_name, values)\n\n                # Attempt to solve the group\n                group_solutions = group_problem.solve(\n                    max_iterations,\n                    solutions_per_group,\n                    self.debug_info,\n                )\n                attempts += 1\n\n            # This group is solved, move on to the next group.\n            if solutions_per_group == 1:\n                # This means we have exactly one solution for the variables considered so far,\n                # meaning we don't need to re-apply solved constraints for future groups.\n                constraints = group_problem.skipped_constraints\n            solved_vars += group_problem.group_vars\n            solutions = group_solutions\n\n        return self.parent._get_random().choice(solutions)\n\n    def solve(\n        self,\n        sparse: bool,\n        thorough: bool,\n        with_values: Optional[Dict[str, Any]]=None,\n        debug: bool=False,\n    ) -> Union[Dict[str, Any], None]:\n        '''\n        Attempt to solve the variables with respect to the constraints.\n\n        :param with_values: Dictionary of variables with set values for this\n            randomization.\n        :return: One valid solution for the randomization problem, represented as\n            a dictionary with keys referring to the named variables.\n        :param debug: ``True`` to run in debug mode. Slower, but collects\n            all debug info along the way and not just the final failure.\n        :raises RandomizationError: When the problem cannot be solved in fewer than\n            the allowed number of iterations.\n        '''\n        with_values = {} if with_values is None else with_values\n        groups = self.determine_order(with_values)\n        solution = None\n        # Create debug info in case of failure\n        self.debug_info = RandomizationDebugInfo()\n        self.debug = debug\n\n        # Try to solve sparsely first\n        if sparse:\n            sparsities = [1, 10, 100, 1000]\n            # The worst-case value of the number of iterations for one sparsity level is:\n            # iterations_per_sparsity * iterations_per_attempt\n            # because of the call to solve_groups hitting iterations_per_attempt.\n            # Failing individual solution attempts speeds up some problems greatly,\n            # this can be thought of as pruning explorations of the state tree.\n            # So, reduce iterations_per_attempt by an order of magnitude.\n            iterations_per_sparsity = self.max_iterations\n            # Ensure it's non-zero\n            iterations_per_attempt = (self.max_iterations // 10) + 1\n            for sparsity in sparsities:\n                for _ in range(iterations_per_sparsity):\n                    solution = self.solve_groups(\n                        groups=groups,\n                        with_values=with_values,\n                        max_iterations=iterations_per_attempt,\n                        solutions_per_group=sparsity,\n                    )\n                    if solution is not None and len(solution) > 0:\n                        return solution\n\n        if thorough:\n            # Try 'thorough' method - no backup plan if this fails\n            solution = self.solve_groups(\n                groups=groups,\n                with_values=with_values,\n                max_iterations=self.max_iterations,\n                solutions_per_group=None,\n            )\n        if solution is None:\n            raise utils.RandomizationError(\"Could not solve problem.\", self.debug_info)\n        return solution", ""]}
