{"filename": "setup.py", "chunked_list": ["import os\nimport sys\nfrom setuptools import setup\nfrom setuptools.command.test import test as TestCommand\n\n\nclass PyTest(TestCommand):\n    user_options = [(\"pytest-args=\", \"a\", \"Arguments to pass into py.test\")]\n\n    def initialize_options(self):\n        TestCommand.initialize_options(self)\n        try:\n            from multiprocessing import cpu_count\n\n            self.pytest_args = [\"-n\", str(cpu_count()), \"--boxed\"]\n        except (ImportError, NotImplementedError):\n            self.pytest_args = [\"-n\", \"1\", \"--boxed\"]\n\n    def finalize_options(self):\n        TestCommand.finalize_options(self)\n        self.test_args = []\n        self.test_suite = True\n\n    def run_tests(self):\n        import pytest\n\n        errno = pytest.main(self.pytest_args)\n        sys.exit(errno)", "\n\nwith open(\"requirements.txt\", \"r\", encoding=\"utf8\") as f:\n    requires = f.readlines()\n\nwith open(\"requirements-dev.txt\", \"r\", encoding=\"utf8\") as f:\n    test_requirements = f.readlines()\n\nabout = {}\nhere = os.path.abspath(os.path.dirname(__file__))", "about = {}\nhere = os.path.abspath(os.path.dirname(__file__))\nversion_file = os.path.join(here, \"ja3requests\", \"__version__.py\")\nwith open(version_file, \"r\", encoding=\"utf8\") as f:\n    exec(f.read(), about)\n\nwith open(\"README.md\", \"r\", encoding=\"utf8\") as f:\n    readme = f.read()\n\n", "\n\nsetup(\n    name=about[\"__title__\"],\n    version=about[\"__version__\"],\n    description=about[\"__description__\"],\n    long_description=readme,\n    long_description_content_type=\"text/markdown\",\n    keywords=[\"pip\", \"ja3requests\", \"ja3\", \"requests\"],\n    license=about[\"__license__\"],", "    keywords=[\"pip\", \"ja3requests\", \"ja3\", \"requests\"],\n    license=about[\"__license__\"],\n    author=about[\"__author__\"],\n    author_email=about[\"__author_email__\"],\n    url=about[\"__url__\"],\n    packages=[\"ja3requests\", \"ja3requests/base\", \"ja3requests/protocol\"],\n    package_dir={\"ja3requests\": \"ja3requests\"},\n    zip_safe=False,\n    include_package_data=True,\n    platforms=\"any\",", "    include_package_data=True,\n    platforms=\"any\",\n    install_requires=requires,\n    tests_require=test_requirements,\n    cmdclass={\"test\": PyTest},\n)\n"]}
{"filename": "main.py", "chunked_list": ["from ja3requests.sessions import Session\n\n\nheaders = {\n    \"connection\": \"keep-alive\",\n    \"Accept-Encoding\": \"deflate, br, gzip\"\n}\nwith Session() as session:\n    # response = session.get(\"http://127.0.0.1:8080\", headers=headers)\n    # response = session.get(\"http://www.baidu.com\", headers=headers)\n    response = session.get(\"http://www.aliyun.com\")\n    print(response.headers)\n    print(response)\n    # print(response.status_code)\n    # print(response.content)\n    print(response.text)", "    # print(response.json())\n\n    # with open(\"baidu.html\", \"w+\") as f:\n    #     f.write(response.text)\n\n\n# import requests\n#\n# requests.get(\"http://127.0.0.1:8080\", headers=headers)\n", "# requests.get(\"http://127.0.0.1:8080\", headers=headers)\n\n# import socket\n#\n# # create a socket object\n# client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n#\n# # connect to the server\n# host = 'www.baidu.com'\n# port = 80", "# host = 'www.baidu.com'\n# port = 80\n# client_socket.connect((host, port))\n#\n# request = \"GET / HTTP/1.1\\r\\nHost: {}\\r\\nConnection: close\\r\\n\\r\\n\".format(host)\n# client_socket.send(request.encode())\n#\n# response = b''\n# while True:\n#     data = client_socket.recv(1024)", "# while True:\n#     data = client_socket.recv(1024)\n#     if not data:\n#         break\n#     response += data\n#\n# # decode the response headers\n# response_headers = response.decode().split('\\r\\n')\n#\n# content_length = None", "#\n# content_length = None\n# transfer_encoding = None\n#\n# for header in response_headers:\n#     if 'Content-Length' in header:\n#         content_length = int(header.split(': ')[1])\n#     elif 'Transfer-Encoding' in header:\n#         transfer_encoding = header.split(': ')[1]\n#", "#         transfer_encoding = header.split(': ')[1]\n#\n# print(content_length, transfer_encoding)\n# if transfer_encoding == 'chunked':\n#     response_body = b''\n#     while True:\n#         chunk_size = int(response[:response.find(b'\\r\\n')], 16)\n#         if chunk_size == 0:\n#             break\n#         response = response[response.find(b'\\r\\n')+2:]", "#             break\n#         response = response[response.find(b'\\r\\n')+2:]\n#         response_body += response[:chunk_size]\n#         response = response[chunk_size+2:]\n# else:\n#     # read the response body using content length\n#     response_body = client_socket.recv(content_length)\n#\n# print(response[len(response)-content_length:])\n# client_socket.close()", "# print(response[len(response)-content_length:])\n# client_socket.close()\n"]}
{"filename": "test/test_ready_request.py", "chunked_list": ["import unittest\nfrom ja3requests.request import ReadyRequest\n\n\nclass TestReadyRequest(unittest.TestCase):\n\n    request = ReadyRequest(\n        \"GET\",\n        \"http://www.baidu.com\"\n    )\n\n    def test_ready(self):\n\n        self.request.ready()\n        print(self.request.scheme, self.request.url)\n\n    def test_request(self):\n        req = self.request.request()\n        req.send()", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "test/test_session.py", "chunked_list": ["import unittest\nfrom ja3requests.sessions import Session\n\n\nclass TestSession(unittest.TestCase):\n\n    session = Session()\n\n    def test_get(self):\n\n        headers = {\n            \"connection\": \"close\"\n        }\n        self.session.get(\"http://www.baidu.com\")\n\n    def test_post_data(self):\n\n        data = {\n            \"username\": \"admin\",\n            \"password\": \"admin\"\n        }\n        response = self.session.post(\"http://127.0.0.1:8080/login\", data=data)\n        print(response)\n        print(response.status_code)\n        print(response.headers)\n        print(response.content)", "\n\nif __name__ == '__main__':\n    unittest.main()\n\n\n"]}
{"filename": "test/test_utils.py", "chunked_list": ["import unittest\nfrom ja3requests.utils import default_headers\n\n\nclass TestUtils(unittest.TestCase):\n\n    def test_default_headers(self):\n\n        result = default_headers()\n        print(result)", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "ja3requests/response.py", "chunked_list": ["\"\"\"\nja3requests.response\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module contains response.\n\"\"\"\n\n\nimport json\nimport gzip", "import json\nimport gzip\nimport zlib\nimport brotli\nfrom .base import BaseResponse\nfrom .const import MAX_LINE, MAX_HEADERS\nfrom .exceptions import InvalidStatusLine, InvalidResponseHeaders, IssueError\n\n\nclass HTTPResponse(BaseResponse):\n    \"\"\"\n    An HTTP response from socket connection.\n    \"\"\"\n\n    def __init__(self, sock, method=None):\n        super().__init__()\n        self.fp = sock.makefile(\"rb\")\n        self._method = method\n        self._chunked = False\n        self._content_encoding = None\n        self._content_length = 0\n\n    def __repr__(self):\n        return (\n            f\"<HTTPResponse [{self.status_code.decode()}] {self.status_text.decode()}>\"\n        )\n\n    def _close_conn(self):\n        fp = self.fp\n        self.fp = None\n        fp.close()\n\n    def _read_status_line(self):\n        line = self.fp.readline(MAX_LINE + 1)\n        if len(line) > MAX_LINE:\n            raise InvalidStatusLine(\n                f\"The status line is too long, exceeding the {MAX_LINE} Max limit\"\n            )\n\n        if not line:\n            raise InvalidStatusLine(\n                f\"The remote servers return an invalid response status line: {line!r}\"\n            )\n\n        try:\n            protocol_version, status_code, status_text = line.split(None, 2)\n            self.protocol_version = protocol_version\n            self.status_code = status_code\n            self.status_text = status_text.strip()\n        except ValueError as err:\n            raise InvalidStatusLine(f\"Can't parse status line: {line!r}\") from err\n\n        if not self.protocol_version.startswith(b\"HTTP/\"):\n            self._close_conn()\n            raise InvalidStatusLine(f\"The status line version not support: {line!r}\")\n\n        return protocol_version, status_code, status_text\n\n    def _read_headers(self):\n        headers = []\n        while True:\n            line = self.fp.readline(MAX_LINE + 1)\n            if len(line) > MAX_LINE:\n                raise InvalidResponseHeaders(\n                    f\"The response headers is too long, exceeding the {MAX_LINE} Max limit\"\n                )\n\n            headers.append(line)\n            if len(headers) > MAX_HEADERS:\n                raise InvalidResponseHeaders(\n                    f\"The response headers is too long, exceeding the {MAX_LINE} Max limit\"\n                )\n\n            if line in (b\"\\r\\n\", b\"\\n\", b\"\"):\n                headers.pop()\n                break\n\n        return headers\n\n    def _parse_headers(self, headers_list=None):\n        headers = {}\n        headers_list = headers_list if headers_list is not None else self.headers\n        if headers_list is None:\n            raise ValueError(\"Required headers to parse.\")\n\n        self.headers = b\"\"\n        for header in headers_list[1:]:\n            self.headers += header\n            name, value = header.strip().split(b\": \")\n            headers.setdefault(name.lower(), value)\n\n        return headers\n\n    def read_body(self):\n        \"\"\"\n        Read body from remote connection.\n        :return:\n        \"\"\"\n        body = b\"\"\n\n        if self.fp is None:\n            return body\n\n        if self._method == \"HEAD\":\n            self._close_conn()\n            return body\n\n        if self._chunked:\n            body = self._read_chunked()\n\n        if self._content_length > 0:\n            body = self.fp.read(self._content_length)\n\n        if self._content_encoding is not None or self._content_encoding != b\"\":\n            if self._content_encoding == b\"gzip\":\n                body = gzip.decompress(body)\n            elif self._content_encoding == b\"deflate\":\n                try:\n                    body = zlib.decompress(body, -zlib.MAX_WBITS)\n                except zlib.error:\n                    body = zlib.decompress(body)\n            elif self._content_encoding == b\"br\":\n                body = brotli.decompress(body)\n\n        return body\n\n    def _read_chunked(self):\n        chunked_data = b\"\"\n        while True:\n            chunked_size = self.fp.readline(MAX_LINE + 1).strip()\n            if chunked_size == b\"\":\n                continue\n            if chunked_size == b\"0\":\n                break\n            size = int(chunked_size, 16)\n            chunked_data += self.fp.read(size)\n\n        return chunked_data\n\n    def begin(self):\n        \"\"\"\n        Receive data from remote connection and begin parse message.\n        :return:\n        \"\"\"\n        if self.headers is not None:\n            return\n\n        self._read_status_line()\n        self.headers = self._read_headers()\n        headers = self._parse_headers()\n\n        self._content_encoding = headers.get(b\"content-encoding\", b\"\")\n\n        transfer_encoding = headers.get(b\"transfer-encoding\", b\"\")\n        if transfer_encoding == b\"chunked\":\n            self._chunked = True\n        elif transfer_encoding != b\"\":\n            raise IssueError(\n                \"This situation may not be considered yet, please issue it\"\n            )\n\n        self._content_length = int(headers.get(b\"content-length\", 0))", "\nclass HTTPResponse(BaseResponse):\n    \"\"\"\n    An HTTP response from socket connection.\n    \"\"\"\n\n    def __init__(self, sock, method=None):\n        super().__init__()\n        self.fp = sock.makefile(\"rb\")\n        self._method = method\n        self._chunked = False\n        self._content_encoding = None\n        self._content_length = 0\n\n    def __repr__(self):\n        return (\n            f\"<HTTPResponse [{self.status_code.decode()}] {self.status_text.decode()}>\"\n        )\n\n    def _close_conn(self):\n        fp = self.fp\n        self.fp = None\n        fp.close()\n\n    def _read_status_line(self):\n        line = self.fp.readline(MAX_LINE + 1)\n        if len(line) > MAX_LINE:\n            raise InvalidStatusLine(\n                f\"The status line is too long, exceeding the {MAX_LINE} Max limit\"\n            )\n\n        if not line:\n            raise InvalidStatusLine(\n                f\"The remote servers return an invalid response status line: {line!r}\"\n            )\n\n        try:\n            protocol_version, status_code, status_text = line.split(None, 2)\n            self.protocol_version = protocol_version\n            self.status_code = status_code\n            self.status_text = status_text.strip()\n        except ValueError as err:\n            raise InvalidStatusLine(f\"Can't parse status line: {line!r}\") from err\n\n        if not self.protocol_version.startswith(b\"HTTP/\"):\n            self._close_conn()\n            raise InvalidStatusLine(f\"The status line version not support: {line!r}\")\n\n        return protocol_version, status_code, status_text\n\n    def _read_headers(self):\n        headers = []\n        while True:\n            line = self.fp.readline(MAX_LINE + 1)\n            if len(line) > MAX_LINE:\n                raise InvalidResponseHeaders(\n                    f\"The response headers is too long, exceeding the {MAX_LINE} Max limit\"\n                )\n\n            headers.append(line)\n            if len(headers) > MAX_HEADERS:\n                raise InvalidResponseHeaders(\n                    f\"The response headers is too long, exceeding the {MAX_LINE} Max limit\"\n                )\n\n            if line in (b\"\\r\\n\", b\"\\n\", b\"\"):\n                headers.pop()\n                break\n\n        return headers\n\n    def _parse_headers(self, headers_list=None):\n        headers = {}\n        headers_list = headers_list if headers_list is not None else self.headers\n        if headers_list is None:\n            raise ValueError(\"Required headers to parse.\")\n\n        self.headers = b\"\"\n        for header in headers_list[1:]:\n            self.headers += header\n            name, value = header.strip().split(b\": \")\n            headers.setdefault(name.lower(), value)\n\n        return headers\n\n    def read_body(self):\n        \"\"\"\n        Read body from remote connection.\n        :return:\n        \"\"\"\n        body = b\"\"\n\n        if self.fp is None:\n            return body\n\n        if self._method == \"HEAD\":\n            self._close_conn()\n            return body\n\n        if self._chunked:\n            body = self._read_chunked()\n\n        if self._content_length > 0:\n            body = self.fp.read(self._content_length)\n\n        if self._content_encoding is not None or self._content_encoding != b\"\":\n            if self._content_encoding == b\"gzip\":\n                body = gzip.decompress(body)\n            elif self._content_encoding == b\"deflate\":\n                try:\n                    body = zlib.decompress(body, -zlib.MAX_WBITS)\n                except zlib.error:\n                    body = zlib.decompress(body)\n            elif self._content_encoding == b\"br\":\n                body = brotli.decompress(body)\n\n        return body\n\n    def _read_chunked(self):\n        chunked_data = b\"\"\n        while True:\n            chunked_size = self.fp.readline(MAX_LINE + 1).strip()\n            if chunked_size == b\"\":\n                continue\n            if chunked_size == b\"0\":\n                break\n            size = int(chunked_size, 16)\n            chunked_data += self.fp.read(size)\n\n        return chunked_data\n\n    def begin(self):\n        \"\"\"\n        Receive data from remote connection and begin parse message.\n        :return:\n        \"\"\"\n        if self.headers is not None:\n            return\n\n        self._read_status_line()\n        self.headers = self._read_headers()\n        headers = self._parse_headers()\n\n        self._content_encoding = headers.get(b\"content-encoding\", b\"\")\n\n        transfer_encoding = headers.get(b\"transfer-encoding\", b\"\")\n        if transfer_encoding == b\"chunked\":\n            self._chunked = True\n        elif transfer_encoding != b\"\":\n            raise IssueError(\n                \"This situation may not be considered yet, please issue it\"\n            )\n\n        self._content_length = int(headers.get(b\"content-length\", 0))", "\n\nclass Response(BaseResponse):\n    \"\"\"Response\n    <Response [200]>\n    \"\"\"\n\n    def __init__(self, response=None):\n        super().__init__()\n        self.response = response\n\n    def __repr__(self):\n        return f\"<Response [{self.status_code}]>\"\n\n    @property\n    def headers(self):\n        \"\"\"\n        Response Headers.\n        :return:\n        \"\"\"\n        headers = []\n        if self.response is None:\n            return headers\n\n        headers_raw = self.response.headers.decode()\n        header_list = headers_raw.split(\"\\r\\n\")\n        for header_item in header_list:\n            if header_item == \"\":\n                continue\n            name, value = header_item.split(\": \", 1)\n            headers.append({name.strip(): value.strip()})\n\n        return headers\n\n    @property\n    def body(self):\n        \"\"\"\n        Response Body.\n        :return:\n        \"\"\"\n        body = b\"\"\n        if self.response is None:\n            return body\n\n        return self.response.read_body()\n\n    @property\n    def status_code(self):\n        \"\"\"\n        Response Status Code\n        :return:\n        \"\"\"\n        status_code = -1\n        if self.response is None:\n            return status_code\n\n        return int(self.response.status_code)\n\n    @property\n    def content(self):\n        \"\"\"\n        Response Content\n        :return:\n        \"\"\"\n        return self.body\n\n    @property\n    def text(self):\n        \"\"\"\n        Response Text\n        :return:\n        \"\"\"\n        return self.content.decode(\"utf8\")\n\n    def json(self):\n        \"\"\"\n        Response JSON\n        :return:\n        \"\"\"\n        return json.loads(self.body)", ""]}
{"filename": "ja3requests/sessions.py", "chunked_list": ["\"\"\"\nja3Requests.sessions\n~~~~~~~~~~~~~~~~~~~~\n\nThis module provides a Session object to manage and persist settings across\nja3Requests.\n\"\"\"\nimport sys\nimport time\nfrom http.cookiejar import CookieJar", "import time\nfrom http.cookiejar import CookieJar\nfrom typing import AnyStr, Any, Dict, ByteString, Union, List, Tuple\nfrom .base import BaseSession\nfrom .response import Response\nfrom .utils import default_headers\nfrom .const import DEFAULT_REDIRECT_LIMIT\nfrom .request import ReadyRequest, Request\n\n# Preferred clock, based on which one is more accurate on a given system.\nif sys.platform == \"win32\":\n    preferred_clock = time.perf_counter\nelse:\n    preferred_clock = time.time", "\n# Preferred clock, based on which one is more accurate on a given system.\nif sys.platform == \"win32\":\n    preferred_clock = time.perf_counter\nelse:\n    preferred_clock = time.time\n\n\nclass Session(BaseSession):\n    \"\"\"A Ja3Request session.\n\n    Provides cookie persistence, connection-pooling, and configuration.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        self.headers = default_headers()\n        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\n    def ready(self, method, url, params, data, headers, cookies, auth, json):\n        \"\"\"\n        Ready to send request.\n        :return:\n        \"\"\"\n\n        req = ReadyRequest(\n            method=method,\n            url=url,\n            params=params,\n            data=data,\n            headers=headers,\n            cookies=cookies,\n            auth=auth,\n            json=json,\n        )\n        req.ready()\n\n        return req\n\n    def request(\n        self,\n        method: AnyStr,\n        url: AnyStr,\n        params: Union[Dict[AnyStr, Any], ByteString] = None,\n        data: Union[Dict[AnyStr, Any], List, Tuple, ByteString] = None,\n        headers: Dict[AnyStr, AnyStr] = None,\n        cookies: Union[Dict[AnyStr, AnyStr], CookieJar] = None,\n        # files = None,\n        auth: Tuple = None,\n        timeout: float = None,\n        allow_redirects: bool = True,\n        proxies: Dict[AnyStr, AnyStr] = None,\n        json: Dict[AnyStr, AnyStr] = None,\n    ):\n        \"\"\"\n        Instantiating a request class<Request> and ready request<ReadyRequest> to send.\n        :param method:\n        :param url:\n        :param params:\n        :param data:\n        :param headers:\n        :param cookies:\n        :param auth:\n        :param timeout:\n        :param allow_redirects:\n        :param proxies:\n        :param json:\n        :return:\n        \"\"\"\n        ready_request = self.ready(\n            method=method,\n            url=url,\n            params=params,\n            data=data,\n            headers=headers,\n            cookies=cookies,\n            auth=auth,\n            json=json,\n        )\n\n        req = ready_request.request()\n        response = self.send(req)\n\n        return response\n\n    def get(self, url, **kwargs):\n        \"\"\"\n        Send a GET request.\n        :param url:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n        return self.request(\"GET\", url, **kwargs)\n\n    def options(self, url, **kwargs):\n        \"\"\"\n        Send a OPTIONS request.\n        :param url:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n        return self.request(\"OPTIONS\", url, **kwargs)\n\n    def head(self, url, **kwargs):\n        \"\"\"\n        Send a HEAD request.\n        :param url:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n        kwargs.setdefault(\"allow_redirects\", False)\n        return self.request(\"HEAD\", url, **kwargs)\n\n    def post(self, url, data=None, json=None, **kwargs):\n        \"\"\"\n        Send a POST request.\n        :param url:\n        :param data:\n        :param json:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n        return self.request(\"POST\", url, data=data, json=json, **kwargs)\n\n    def put(self, url, data=None, **kwargs):\n        \"\"\"\n        Send a PUT request.\n        :param url:\n        :param data:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n        return self.request(\"PUT\", url, data=data, **kwargs)\n\n    def patch(self, url, data=None, **kwargs):\n        \"\"\"\n        Send a PATCH request.\n        :param url:\n        :param data:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n        return self.request(\"PATCH\", url, data=data, **kwargs)\n\n    def delete(self, url, data=None, **kwargs):\n        \"\"\"\n        Send a DELETE request.\n        :param url:\n        :param data:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n        return self.request(\"DELETE\", url, **kwargs)\n\n    def send(self, request: Request):\n        \"\"\"\n        Send request.\n        :return:\n        \"\"\"\n\n        rep = request.send()\n        response = Response(rep)\n\n        return response", "class Session(BaseSession):\n    \"\"\"A Ja3Request session.\n\n    Provides cookie persistence, connection-pooling, and configuration.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        self.headers = default_headers()\n        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\n    def ready(self, method, url, params, data, headers, cookies, auth, json):\n        \"\"\"\n        Ready to send request.\n        :return:\n        \"\"\"\n\n        req = ReadyRequest(\n            method=method,\n            url=url,\n            params=params,\n            data=data,\n            headers=headers,\n            cookies=cookies,\n            auth=auth,\n            json=json,\n        )\n        req.ready()\n\n        return req\n\n    def request(\n        self,\n        method: AnyStr,\n        url: AnyStr,\n        params: Union[Dict[AnyStr, Any], ByteString] = None,\n        data: Union[Dict[AnyStr, Any], List, Tuple, ByteString] = None,\n        headers: Dict[AnyStr, AnyStr] = None,\n        cookies: Union[Dict[AnyStr, AnyStr], CookieJar] = None,\n        # files = None,\n        auth: Tuple = None,\n        timeout: float = None,\n        allow_redirects: bool = True,\n        proxies: Dict[AnyStr, AnyStr] = None,\n        json: Dict[AnyStr, AnyStr] = None,\n    ):\n        \"\"\"\n        Instantiating a request class<Request> and ready request<ReadyRequest> to send.\n        :param method:\n        :param url:\n        :param params:\n        :param data:\n        :param headers:\n        :param cookies:\n        :param auth:\n        :param timeout:\n        :param allow_redirects:\n        :param proxies:\n        :param json:\n        :return:\n        \"\"\"\n        ready_request = self.ready(\n            method=method,\n            url=url,\n            params=params,\n            data=data,\n            headers=headers,\n            cookies=cookies,\n            auth=auth,\n            json=json,\n        )\n\n        req = ready_request.request()\n        response = self.send(req)\n\n        return response\n\n    def get(self, url, **kwargs):\n        \"\"\"\n        Send a GET request.\n        :param url:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n        return self.request(\"GET\", url, **kwargs)\n\n    def options(self, url, **kwargs):\n        \"\"\"\n        Send a OPTIONS request.\n        :param url:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n        return self.request(\"OPTIONS\", url, **kwargs)\n\n    def head(self, url, **kwargs):\n        \"\"\"\n        Send a HEAD request.\n        :param url:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n        kwargs.setdefault(\"allow_redirects\", False)\n        return self.request(\"HEAD\", url, **kwargs)\n\n    def post(self, url, data=None, json=None, **kwargs):\n        \"\"\"\n        Send a POST request.\n        :param url:\n        :param data:\n        :param json:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n        return self.request(\"POST\", url, data=data, json=json, **kwargs)\n\n    def put(self, url, data=None, **kwargs):\n        \"\"\"\n        Send a PUT request.\n        :param url:\n        :param data:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n        return self.request(\"PUT\", url, data=data, **kwargs)\n\n    def patch(self, url, data=None, **kwargs):\n        \"\"\"\n        Send a PATCH request.\n        :param url:\n        :param data:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n        return self.request(\"PATCH\", url, data=data, **kwargs)\n\n    def delete(self, url, data=None, **kwargs):\n        \"\"\"\n        Send a DELETE request.\n        :param url:\n        :param data:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n        return self.request(\"DELETE\", url, **kwargs)\n\n    def send(self, request: Request):\n        \"\"\"\n        Send request.\n        :return:\n        \"\"\"\n\n        rep = request.send()\n        response = Response(rep)\n\n        return response", ""]}
{"filename": "ja3requests/context.py", "chunked_list": ["\"\"\"\nja3requests.context\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nHTTP Context and HTTPS Context\n\"\"\"\n\n\nfrom .base import BaseContext\n", "from .base import BaseContext\n\n\nDEFAULT_HTTP_CONTEXT_PROTOCOL = 11\nDEFAULT_HTTP_VERSION = \"HTTP/1.1\"\n\n\nclass HTTPContext(BaseContext):\n    \"\"\"\n    HTTPContext\n    \"\"\"\n\n    def __init__(self, connection):\n        super().__init__()\n        self.protocol = DEFAULT_HTTP_CONTEXT_PROTOCOL\n        self.version = DEFAULT_HTTP_VERSION\n        self.connection = connection\n\n    @property\n    def message(self):\n        \"\"\"\n        HTTP Context message to send\n        :return:\n        \"\"\"\n        self.start_line = \" \".join([self.method, self.connection.path, self.version])\n        self._message = \"\\r\\n\".join([self.start_line, self.put_headers()])\n        self._message += \"\\r\\n\\r\\n\"\n\n        if self.body:\n            self._message += self.body\n\n        print(self._message)\n\n        return self._message.encode()\n\n    def set_payload(self, **kwargs):\n        \"\"\"\n        Set context payload\n        :param kwargs:\n        :return:\n        \"\"\"\n        for k, v in kwargs.items():\n            if hasattr(self, k):\n                setattr(self, k, v)\n\n    def put_headers(self):\n        \"\"\"\n        Set context headers\n        :return:\n        \"\"\"\n        headers = \"\"\n        if self.headers is not None:\n            if not self.headers.get(\"host\", None):\n                self.headers[\"host\"] = self.connection.host\n\n            headers = \"\\r\\n\".join([f\"{k}: {v}\" for k, v in self.headers.items()])\n\n        return headers", ""]}
{"filename": "ja3requests/__init__.py", "chunked_list": ["from .sessions import Session\n\n\ndef session():\n    \"\"\"\n    Return a Session object.\n    :return:\n    \"\"\"\n    return Session()\n", ""]}
{"filename": "ja3requests/utils.py", "chunked_list": ["\"\"\"\nja3requests.utils\n~~~~~~~~~~~~~~~~~\n\nThis module provides utility functions.\n\"\"\"\n\nimport platform\nfrom base64 import b64encode\nfrom typing import Union, AnyStr, List", "from base64 import b64encode\nfrom typing import Union, AnyStr, List\nfrom .__version__ import __version__\n\n\nACCEPT_ENCODING = \"gzip,deflate\"\n\n\ndef b(s: AnyStr):  # pylint: disable=C\n    \"\"\"\n    String encode latin1\n    :param s:\n    :return:\n    \"\"\"\n    return s.encode(\"latin1\")", "def b(s: AnyStr):  # pylint: disable=C\n    \"\"\"\n    String encode latin1\n    :param s:\n    :return:\n    \"\"\"\n    return s.encode(\"latin1\")\n\n\ndef default_user_agent(agent: AnyStr = \"Ja3Requests\"):\n    \"\"\"\n    Return a string representing the default user agent.\n    :param agent:\n    :return: str\n    \"\"\"\n\n    return f\"Python/{platform.python_version()} ({platform.system()}; {platform.platform()}) {agent}/{__version__}\"", "\ndef default_user_agent(agent: AnyStr = \"Ja3Requests\"):\n    \"\"\"\n    Return a string representing the default user agent.\n    :param agent:\n    :return: str\n    \"\"\"\n\n    return f\"Python/{platform.python_version()} ({platform.system()}; {platform.platform()}) {agent}/{__version__}\"\n", "\n\ndef make_headers(\n    keep_alive: bool = None,\n    accept_encoding: Union[AnyStr, List[AnyStr]] = None,\n    user_agent: AnyStr = None,\n    basic_auth: AnyStr = None,\n    proxy_basic_auth: AnyStr = None,\n    disable_cache: bool = None,\n):\n    \"\"\"\n    Shortcuts for generating request headers.\n    :param keep_alive:\n    :param accept_encoding:\n    :param user_agent:\n    :param basic_auth: username:password\n    :param proxy_basic_auth: username:password\n    :param disable_cache:\n    :return: dict\n    \"\"\"\n    headers = {\"Accept\": \"*/*\"}\n    if accept_encoding:\n        if isinstance(accept_encoding, str):\n            pass\n        elif isinstance(accept_encoding, list):\n            accept_encoding = \",\".join(accept_encoding)\n        else:\n            accept_encoding = ACCEPT_ENCODING\n        headers[\"Accept-Encoding\"] = accept_encoding\n\n    if keep_alive:\n        headers[\"Connection\"] = \"keep-alive\"\n\n    if basic_auth:\n        headers[\"Authorization\"] = \"Basic \" + b64encode(b(basic_auth)).decode(\"utf-8\")\n\n    if proxy_basic_auth:\n        headers[\"Proxy-Authorization\"] = \"Basic \" + b64encode(\n            b(proxy_basic_auth)\n        ).decode(\"utf-8\")\n\n    if disable_cache:\n        headers[\"Cache-Control\"] = \"no-cache\"\n\n    headers[\"User-Agent\"] = user_agent if user_agent else default_user_agent()\n\n    return headers", "\n\ndef default_headers():\n    \"\"\"\n    Return default headers.\n    :return:\n    \"\"\"\n\n    return make_headers(keep_alive=True)\n", ""]}
{"filename": "ja3requests/connections.py", "chunked_list": ["\"\"\"\nja3requests.connections\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module contains HTTP connection and HTTPS connection.\n\"\"\"\n\n\nfrom .response import HTTPResponse\nfrom .exceptions import InvalidHost", "from .response import HTTPResponse\nfrom .exceptions import InvalidHost\nfrom .base import BaseHttpConnection\nfrom .protocol.sockets import create_connection\nfrom .const import DEFAULT_HTTP_SCHEME\nfrom .const import DEFAULT_HTTP_PORT\nfrom .protocol.exceptions import SocketTimeout, ConnectTimeoutError\n\n\nclass HTTPConnection(BaseHttpConnection):\n    \"\"\"\n    HTTP connection.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.scheme = DEFAULT_HTTP_SCHEME\n        self.port = DEFAULT_HTTP_PORT\n        self.is_close = False\n\n    def __del__(self):\n        self.close()\n\n    def _new_conn(self):\n        \"\"\"\n        Establish a socket connection\n        :return: socket connection\n        \"\"\"\n\n        try:\n            conn = create_connection(\n                (self.destination_address, self.port),\n                self.timeout,\n                self.source_address,\n            )\n        except SocketTimeout as err:\n            raise ConnectTimeoutError(\n                f\"Connection to {self.destination_address} timeout out. timeout={self.timeout}\"\n            ) from err\n\n        return conn\n\n    def _ready_connect(self, **kwargs):\n        \"\"\"\n        Ready http connection.\n        :param kwargs:\n        :return:\n        \"\"\"\n        self.scheme = kwargs[\"scheme\"] if kwargs.get(\"scheme\", None) else self.scheme\n        self.port = kwargs[\"port\"] if kwargs.get(\"port\", None) else self.port\n        self.source_address = (\n            kwargs[\"source_address\"]\n            if kwargs.get(\"source_address\", None)\n            else self.source_address\n        )\n        self.timeout = (\n            kwargs[\"timeout\"] if kwargs.get(\"timeout\", None) else self.timeout\n        )\n        self.proxy = kwargs[\"proxy\"] if kwargs.get(\"proxy\", None) else self.proxy\n        self.proxy_username = (\n            kwargs[\"proxy_username\"]\n            if kwargs.get(\"proxy_username\", None)\n            else self.proxy_username\n        )\n        self.proxy_password = (\n            kwargs[\"proxy_password\"]\n            if kwargs.get(\"proxy_password\", None)\n            else self.proxy_password\n        )\n\n        if kwargs.get(\"host\", None):\n            host = kwargs[\"host\"].replace(\"http://\", \"\").split(\"/\")\n            if len(host) > 0:\n                self.host = host[0]\n                self.path = \"/\" + \"/\".join(host[1:])\n                if \":\" in self.host:\n                    self.destination_address = self.host.split(\":\")[0]\n                    if self.port is None:\n                        self.port = self.host.split(\":\")[1]\n                else:\n                    self.destination_address = self.host\n            else:\n                raise InvalidHost(\n                    f\"Invalid Host: {kwargs['host']!r}, can not parse destination address or path.\"\n                )\n\n    def connect(\n        self,\n        scheme=None,\n        port=None,\n        source_address=None,\n        host=None,\n        timeout=None,\n        proxy=None,\n        proxy_username=None,\n        proxy_password=None,\n    ):\n        \"\"\"\n        Create an http connection.\n        :param scheme:\n        :param port:\n        :param source_address:\n        :param host:\n        :param timeout:\n        :param proxy:\n        :param proxy_username:\n        :param proxy_password:\n        :return:\n        \"\"\"\n        self._ready_connect(\n            scheme=scheme,\n            port=port,\n            source_address=source_address,\n            host=host,\n            timeout=timeout,\n            proxy=proxy,\n            proxy_username=proxy_username,\n            proxy_password=proxy_password,\n        )\n        conn = self._new_conn()\n        self.connection = conn\n\n    def send(self, context):\n        \"\"\"\n        Send socket.\n        :return:\n        \"\"\"\n        self.connection.sendall(context.message)\n\n        response = HTTPResponse(sock=self.connection, method=context.method)\n        response.begin()\n\n        return response\n\n    def close(self):\n        \"\"\"\n        Close connection.\n        :return:\n        \"\"\"\n        if self.connection:\n            self.connection.close()", "\nclass HTTPConnection(BaseHttpConnection):\n    \"\"\"\n    HTTP connection.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.scheme = DEFAULT_HTTP_SCHEME\n        self.port = DEFAULT_HTTP_PORT\n        self.is_close = False\n\n    def __del__(self):\n        self.close()\n\n    def _new_conn(self):\n        \"\"\"\n        Establish a socket connection\n        :return: socket connection\n        \"\"\"\n\n        try:\n            conn = create_connection(\n                (self.destination_address, self.port),\n                self.timeout,\n                self.source_address,\n            )\n        except SocketTimeout as err:\n            raise ConnectTimeoutError(\n                f\"Connection to {self.destination_address} timeout out. timeout={self.timeout}\"\n            ) from err\n\n        return conn\n\n    def _ready_connect(self, **kwargs):\n        \"\"\"\n        Ready http connection.\n        :param kwargs:\n        :return:\n        \"\"\"\n        self.scheme = kwargs[\"scheme\"] if kwargs.get(\"scheme\", None) else self.scheme\n        self.port = kwargs[\"port\"] if kwargs.get(\"port\", None) else self.port\n        self.source_address = (\n            kwargs[\"source_address\"]\n            if kwargs.get(\"source_address\", None)\n            else self.source_address\n        )\n        self.timeout = (\n            kwargs[\"timeout\"] if kwargs.get(\"timeout\", None) else self.timeout\n        )\n        self.proxy = kwargs[\"proxy\"] if kwargs.get(\"proxy\", None) else self.proxy\n        self.proxy_username = (\n            kwargs[\"proxy_username\"]\n            if kwargs.get(\"proxy_username\", None)\n            else self.proxy_username\n        )\n        self.proxy_password = (\n            kwargs[\"proxy_password\"]\n            if kwargs.get(\"proxy_password\", None)\n            else self.proxy_password\n        )\n\n        if kwargs.get(\"host\", None):\n            host = kwargs[\"host\"].replace(\"http://\", \"\").split(\"/\")\n            if len(host) > 0:\n                self.host = host[0]\n                self.path = \"/\" + \"/\".join(host[1:])\n                if \":\" in self.host:\n                    self.destination_address = self.host.split(\":\")[0]\n                    if self.port is None:\n                        self.port = self.host.split(\":\")[1]\n                else:\n                    self.destination_address = self.host\n            else:\n                raise InvalidHost(\n                    f\"Invalid Host: {kwargs['host']!r}, can not parse destination address or path.\"\n                )\n\n    def connect(\n        self,\n        scheme=None,\n        port=None,\n        source_address=None,\n        host=None,\n        timeout=None,\n        proxy=None,\n        proxy_username=None,\n        proxy_password=None,\n    ):\n        \"\"\"\n        Create an http connection.\n        :param scheme:\n        :param port:\n        :param source_address:\n        :param host:\n        :param timeout:\n        :param proxy:\n        :param proxy_username:\n        :param proxy_password:\n        :return:\n        \"\"\"\n        self._ready_connect(\n            scheme=scheme,\n            port=port,\n            source_address=source_address,\n            host=host,\n            timeout=timeout,\n            proxy=proxy,\n            proxy_username=proxy_username,\n            proxy_password=proxy_password,\n        )\n        conn = self._new_conn()\n        self.connection = conn\n\n    def send(self, context):\n        \"\"\"\n        Send socket.\n        :return:\n        \"\"\"\n        self.connection.sendall(context.message)\n\n        response = HTTPResponse(sock=self.connection, method=context.method)\n        response.begin()\n\n        return response\n\n    def close(self):\n        \"\"\"\n        Close connection.\n        :return:\n        \"\"\"\n        if self.connection:\n            self.connection.close()", ""]}
{"filename": "ja3requests/const.py", "chunked_list": ["\"\"\"\nja3requests.const\n~~~~~~~~~~~~~~~~~\n\nA constant module.\n\"\"\"\n\nimport sys\n\n\nclass _Const:\n    class ConstError(TypeError):\n        \"\"\"\n        Const Error\n        \"\"\"\n\n    class ConstCaseError(ConstError):\n        \"\"\"\n        Const Case Error\n        \"\"\"\n\n    def __setattr__(self, key, value):\n        if self.__dict__.get(key) is not None:\n            raise self.ConstError(f\"The constant {key} already exists\")\n\n        if not key.isupper():\n            raise self.ConstCaseError(f\"{key}-constants need to be capitalized.\")\n\n        self.__dict__[key] = value", "\n\nclass _Const:\n    class ConstError(TypeError):\n        \"\"\"\n        Const Error\n        \"\"\"\n\n    class ConstCaseError(ConstError):\n        \"\"\"\n        Const Case Error\n        \"\"\"\n\n    def __setattr__(self, key, value):\n        if self.__dict__.get(key) is not None:\n            raise self.ConstError(f\"The constant {key} already exists\")\n\n        if not key.isupper():\n            raise self.ConstCaseError(f\"{key}-constants need to be capitalized.\")\n\n        self.__dict__[key] = value", "\n\nconst = _Const()\n\nconst.MAX_LINE = 65536\nconst.MAX_HEADERS = 100\nconst.DEFAULT_CHUNKED_SIZE = 2048\nconst.DEFAULT_HTTP_SCHEME = \"http\"\nconst.DEFAULT_HTTPS_SCHEME = \"https\"\nconst.DEFAULT_HTTP_PORT = 80", "const.DEFAULT_HTTPS_SCHEME = \"https\"\nconst.DEFAULT_HTTP_PORT = 80\nconst.DEFAULT_HTTPS_PORT = 443\nconst.DEFAULT_REDIRECT_LIMIT = 8  # max redirect\n\nsys.modules[__name__] = const\n"]}
{"filename": "ja3requests/__version__.py", "chunked_list": ["\"\"\"\nja3requests.__version__\n~~~~~~~~~~~~~~~~~~~~~~~\n\nVersion information.\n\"\"\"\n\n__title__ = \"ja3requests\"\n__description__ = \"An http request library that can customize ja3 or h2 fingerprints.\"\n__url__ = \"https://github.com/lxjmaster/ja3requests\"", "__description__ = \"An http request library that can customize ja3 or h2 fingerprints.\"\n__url__ = \"https://github.com/lxjmaster/ja3requests\"\n__version__ = \"1.0.2\"\n__author__ = \"Mast Luo\"\n__author_email__ = \"379501669@qq.com\"\n__license__ = \"Apache-2.0 license\"\n__copyright__ = \"Copyright Mast Luo\"\n"]}
{"filename": "ja3requests/exceptions.py", "chunked_list": ["\"\"\"\nja3requests.exceptions\n~~~~~~~~~~~~~~~~~~~~~~\n\nThis module contains the set of Requests' exceptions.\n\"\"\"\n\n\nclass RequestException(IOError):\n    \"\"\"\n    There was an ambiguous exception that occurred while handling your request.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Initialize RequestException with `request` and `response` objects.\n        \"\"\"\n        response = kwargs.pop(\"response\", None)\n        self.response = response\n        self.request = kwargs.pop(\"request\", None)\n        if response is not None and not self.request and hasattr(response, \"request\"):\n            self.request = self.response.request\n        super().__init__(*args, **kwargs)", "class RequestException(IOError):\n    \"\"\"\n    There was an ambiguous exception that occurred while handling your request.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Initialize RequestException with `request` and `response` objects.\n        \"\"\"\n        response = kwargs.pop(\"response\", None)\n        self.response = response\n        self.request = kwargs.pop(\"request\", None)\n        if response is not None and not self.request and hasattr(response, \"request\"):\n            self.request = self.response.request\n        super().__init__(*args, **kwargs)", "\n\nclass NotAllowedRequestMethod(RequestException, ValueError):\n    \"\"\"\n    If the request method not allowed and raise it.\n    \"\"\"\n\n\nclass MissingScheme(RequestException, ValueError):\n    \"\"\"\n    The URL scheme (e.g. http or https) is missing and raise it.\n    \"\"\"", "class MissingScheme(RequestException, ValueError):\n    \"\"\"\n    The URL scheme (e.g. http or https) is missing and raise it.\n    \"\"\"\n\n\nclass NotAllowedScheme(RequestException, ValueError):\n    \"\"\"\n    If the scheme not allowed and raise it.\n    \"\"\"", "\n\nclass InvalidParams(RequestException, ValueError):\n    \"\"\"\n    If request params invalid and raise it.\n    \"\"\"\n\n\nclass InvalidHost(RequestException, ValueError):\n    \"\"\"\n    Raised it while host can not parse.\n    \"\"\"", "class InvalidHost(RequestException, ValueError):\n    \"\"\"\n    Raised it while host can not parse.\n    \"\"\"\n\n\nclass InvalidStatusLine(RequestException, ValueError):\n    \"\"\"\n    Raised it when can't receive streamline.\n    \"\"\"", "\n\nclass InvalidResponseHeaders(RequestException, ValueError):\n    \"\"\"\n    Raised it when cant receive response headers.\n    \"\"\"\n\n\nclass IssueError(ValueError):\n    \"\"\"\n    This situation may not be considered yet, please issue it\n    \"\"\"", "class IssueError(ValueError):\n    \"\"\"\n    This situation may not be considered yet, please issue it\n    \"\"\"\n"]}
{"filename": "ja3requests/request.py", "chunked_list": ["\"\"\"\nja3requests.request\n~~~~~~~~~~~~~~~~~~~\n\nThis module create a request struct and ready request object.\n\"\"\"\n\n\nimport warnings\nfrom http.cookiejar import CookieJar", "import warnings\nfrom http.cookiejar import CookieJar\nfrom urllib.parse import urlparse, urlencode\nfrom typing import Any, AnyStr, Dict, List, Union, ByteString, Tuple\nfrom .base import BaseRequest\nfrom .utils import default_headers\nfrom .context import HTTPContext\nfrom .connections import HTTPConnection\nfrom .exceptions import (\n    NotAllowedRequestMethod,", "from .exceptions import (\n    NotAllowedRequestMethod,\n    MissingScheme,\n    NotAllowedScheme,\n    InvalidParams,\n)\n\n\nclass ReadyRequest(BaseRequest):\n    \"\"\"\n    Ready a request, e.g.(check url, check params)\n    \"\"\"\n\n    def __init__(\n        self,\n        method: AnyStr,\n        url: AnyStr,\n        params: Union[\n            Dict[Any, Any],\n            List[Tuple[Any, Any]],\n            Tuple[Tuple[Any, Any]],\n            ByteString,\n            AnyStr,\n        ] = None,\n        data: Union[Dict[AnyStr, Any], List, Tuple, ByteString] = None,\n        headers: Dict[AnyStr, AnyStr] = None,\n        cookies: Union[Dict[AnyStr, AnyStr], CookieJar] = None,\n        auth: Tuple = None,\n        json: Dict[AnyStr, AnyStr] = None,\n    ):\n        super().__init__()\n        self.method = method\n        self.url = url\n        self.params = params\n        self.data = data\n        self.headers = headers\n        self.cookies = cookies\n        self.auth = auth\n        self.json = json\n\n    def __repr__(self):\n        return f\"<ReadyRequest [{self.method}]>\"\n\n    def ready_method(self):\n        \"\"\"\n        Ready request method and check request method whether allow used.\n        :return:\n        \"\"\"\n\n        if self.method == \"\" or self.method not in [\n            \"GET\",\n            \"OPTIONS\",\n            \"HEAD\",\n            \"POST\",\n            \"PUT\",\n            \"PATCH\",\n            \"DELETE\",\n        ]:\n            raise NotAllowedRequestMethod(self.method)\n\n        self.method = self.method.upper()\n\n    def ready_url(self):\n        \"\"\"\n        Ready http url and check url whether valid.\n        :return:\n        \"\"\"\n\n        if self.url == \"\":\n            raise ValueError(\"The request url is required.\")\n\n        # Remove whitespaces for url\n        self.url.strip()\n\n        parse = urlparse(self.url)\n\n        # Check HTTP scheme\n        if parse.scheme == \"\":\n            raise MissingScheme(\n                f\"Invalid URL {self.url!r}: No scheme supplied. \"\n                f\"Perhaps you meant http://{self.url} or https://{self.url}\"\n            )\n\n        # Just allow http or https\n        if parse.scheme not in [\"http\", \"https\"]:\n            raise NotAllowedScheme(f\"Schema: {parse.scheme} not allowed.\")\n\n        self.scheme = parse.scheme\n        if self.scheme == \"https\":\n            self.port = 443\n\n        if parse.netloc != \"\" and \":\" in parse.netloc:\n            port = parse.netloc.split(\":\")[-1]\n            self.port = int(port)\n        else:\n            self.port = 80\n\n    def ready_params(self):\n        \"\"\"\n        Ready params.\n        :return:\n        \"\"\"\n        if self.params:\n            parse = urlparse(self.url)\n\n            if isinstance(self.params, str):\n                params = self.params\n            elif isinstance(self.params, bytes):\n                params = self.params.decode()\n            elif isinstance(self.params, (dict, list, tuple)):\n                params = urlencode(self.params)\n            else:\n                raise InvalidParams(f\"Invalid params: {self.params!r}\")\n\n            if params.startswith(\"?\"):\n                params = params.replace(\"?\", \"\")\n\n            if parse.query != \"\":\n                self.url = \"&\" + params\n            else:\n                self.url = \"?\" + params\n\n    def ready_data(self):\n        \"\"\"\n        Ready form data.\n        :return:\n        \"\"\"\n        if self.data:\n            if self.headers is not None:\n                content_type = self.headers.get(\"Content-Type\", \"\")\n                if content_type == \"\":\n                    self.headers[\"Content-Type\"] = content_type = \"application/x-www-form-urlencoded\"\n            else:\n                self.headers = default_headers()\n                self.headers[\"Content-Type\"] = content_type = \"application/x-www-form-urlencoded\"\n\n            if content_type == \"application/x-www-form-urlencoded\":\n                self.data = urlencode(self.data)\n                self.headers[\"Content-Length\"] = len(self.data)\n\n        print(self.data)\n\n    def ready_headers(self):\n        \"\"\"\n        Ready http headers.\n        :return:\n        \"\"\"\n\n        # Default headers\n        if self.headers is None:\n            self.headers = default_headers()\n\n        # Check duplicate default item\n        new_headers = {}\n        header_list = []\n        for k, v in self.headers.items():\n            header = k.title()\n            if header in header_list:\n                warnings.warn(\n                    f\"Duplicate header: {k}, you should check the request headers.\",\n                    RuntimeWarning,\n                )\n\n            header_list.append(header)\n            new_headers[header] = v\n\n        self.headers = new_headers\n        del new_headers\n        del header_list\n\n    def ready_cookies(self):\n        \"\"\"\n        Todo: Ready http cookies.\n        :return:\n        \"\"\"\n\n    def ready_auth(self):\n        \"\"\"\n        Todo: Ready http authenticator\n        :return:\n        \"\"\"\n\n    def ready_json(self):\n        \"\"\"\n        Todo: Ready post json.\n        :return:\n        \"\"\"\n\n    def ready(self):\n        \"\"\"\n        Make a ready request to send.\n        :return:\n        \"\"\"\n        self.ready_method()\n        self.ready_url()\n        self.ready_params()\n        self.ready_headers()\n        self.ready_data()\n        self.ready_cookies()\n        self.ready_auth()\n        self.ready_json()\n\n    def request(self):\n        \"\"\"\n        Create a Request object.\n        :return:\n        \"\"\"\n        req = Request()\n        req.clone(self)\n\n        return req", "class ReadyRequest(BaseRequest):\n    \"\"\"\n    Ready a request, e.g.(check url, check params)\n    \"\"\"\n\n    def __init__(\n        self,\n        method: AnyStr,\n        url: AnyStr,\n        params: Union[\n            Dict[Any, Any],\n            List[Tuple[Any, Any]],\n            Tuple[Tuple[Any, Any]],\n            ByteString,\n            AnyStr,\n        ] = None,\n        data: Union[Dict[AnyStr, Any], List, Tuple, ByteString] = None,\n        headers: Dict[AnyStr, AnyStr] = None,\n        cookies: Union[Dict[AnyStr, AnyStr], CookieJar] = None,\n        auth: Tuple = None,\n        json: Dict[AnyStr, AnyStr] = None,\n    ):\n        super().__init__()\n        self.method = method\n        self.url = url\n        self.params = params\n        self.data = data\n        self.headers = headers\n        self.cookies = cookies\n        self.auth = auth\n        self.json = json\n\n    def __repr__(self):\n        return f\"<ReadyRequest [{self.method}]>\"\n\n    def ready_method(self):\n        \"\"\"\n        Ready request method and check request method whether allow used.\n        :return:\n        \"\"\"\n\n        if self.method == \"\" or self.method not in [\n            \"GET\",\n            \"OPTIONS\",\n            \"HEAD\",\n            \"POST\",\n            \"PUT\",\n            \"PATCH\",\n            \"DELETE\",\n        ]:\n            raise NotAllowedRequestMethod(self.method)\n\n        self.method = self.method.upper()\n\n    def ready_url(self):\n        \"\"\"\n        Ready http url and check url whether valid.\n        :return:\n        \"\"\"\n\n        if self.url == \"\":\n            raise ValueError(\"The request url is required.\")\n\n        # Remove whitespaces for url\n        self.url.strip()\n\n        parse = urlparse(self.url)\n\n        # Check HTTP scheme\n        if parse.scheme == \"\":\n            raise MissingScheme(\n                f\"Invalid URL {self.url!r}: No scheme supplied. \"\n                f\"Perhaps you meant http://{self.url} or https://{self.url}\"\n            )\n\n        # Just allow http or https\n        if parse.scheme not in [\"http\", \"https\"]:\n            raise NotAllowedScheme(f\"Schema: {parse.scheme} not allowed.\")\n\n        self.scheme = parse.scheme\n        if self.scheme == \"https\":\n            self.port = 443\n\n        if parse.netloc != \"\" and \":\" in parse.netloc:\n            port = parse.netloc.split(\":\")[-1]\n            self.port = int(port)\n        else:\n            self.port = 80\n\n    def ready_params(self):\n        \"\"\"\n        Ready params.\n        :return:\n        \"\"\"\n        if self.params:\n            parse = urlparse(self.url)\n\n            if isinstance(self.params, str):\n                params = self.params\n            elif isinstance(self.params, bytes):\n                params = self.params.decode()\n            elif isinstance(self.params, (dict, list, tuple)):\n                params = urlencode(self.params)\n            else:\n                raise InvalidParams(f\"Invalid params: {self.params!r}\")\n\n            if params.startswith(\"?\"):\n                params = params.replace(\"?\", \"\")\n\n            if parse.query != \"\":\n                self.url = \"&\" + params\n            else:\n                self.url = \"?\" + params\n\n    def ready_data(self):\n        \"\"\"\n        Ready form data.\n        :return:\n        \"\"\"\n        if self.data:\n            if self.headers is not None:\n                content_type = self.headers.get(\"Content-Type\", \"\")\n                if content_type == \"\":\n                    self.headers[\"Content-Type\"] = content_type = \"application/x-www-form-urlencoded\"\n            else:\n                self.headers = default_headers()\n                self.headers[\"Content-Type\"] = content_type = \"application/x-www-form-urlencoded\"\n\n            if content_type == \"application/x-www-form-urlencoded\":\n                self.data = urlencode(self.data)\n                self.headers[\"Content-Length\"] = len(self.data)\n\n        print(self.data)\n\n    def ready_headers(self):\n        \"\"\"\n        Ready http headers.\n        :return:\n        \"\"\"\n\n        # Default headers\n        if self.headers is None:\n            self.headers = default_headers()\n\n        # Check duplicate default item\n        new_headers = {}\n        header_list = []\n        for k, v in self.headers.items():\n            header = k.title()\n            if header in header_list:\n                warnings.warn(\n                    f\"Duplicate header: {k}, you should check the request headers.\",\n                    RuntimeWarning,\n                )\n\n            header_list.append(header)\n            new_headers[header] = v\n\n        self.headers = new_headers\n        del new_headers\n        del header_list\n\n    def ready_cookies(self):\n        \"\"\"\n        Todo: Ready http cookies.\n        :return:\n        \"\"\"\n\n    def ready_auth(self):\n        \"\"\"\n        Todo: Ready http authenticator\n        :return:\n        \"\"\"\n\n    def ready_json(self):\n        \"\"\"\n        Todo: Ready post json.\n        :return:\n        \"\"\"\n\n    def ready(self):\n        \"\"\"\n        Make a ready request to send.\n        :return:\n        \"\"\"\n        self.ready_method()\n        self.ready_url()\n        self.ready_params()\n        self.ready_headers()\n        self.ready_data()\n        self.ready_cookies()\n        self.ready_auth()\n        self.ready_json()\n\n    def request(self):\n        \"\"\"\n        Create a Request object.\n        :return:\n        \"\"\"\n        req = Request()\n        req.clone(self)\n\n        return req", "\n\nclass Request(BaseRequest):\n    \"\"\"\n    Request object to send.\n    \"\"\"\n\n    def __repr__(self):\n        return f\"<Request [{self.method}]>\"\n\n    def clone(self, ready_request: ReadyRequest):\n        \"\"\"\n        Clone arguments from ReadyRequest\n        :param ready_request:\n        :return:\n        \"\"\"\n        for k, v in ready_request.__dict__.items():\n            setattr(self, k, v)\n\n    def send(self):\n        \"\"\"\n        Connection sending.\n        :return:\n        \"\"\"\n\n        conn = self.create_connect()\n        proxy, proxy_username, proxy_password = self.parse_proxies()\n        conn.connect(\n            self.scheme,\n            self.port,\n            self.source,\n            self.url,\n            self.timeout,\n            proxy,\n            proxy_username,\n            proxy_password,\n        )\n        context = HTTPContext(conn)\n        context.set_payload(\n            method=self.method,\n            headers=self.headers,\n            body=self.data,\n        )\n        response = conn.send(context)\n\n        return response\n\n    def create_connect(self):\n        \"\"\"\n        Create http connection or https connection by request scheme.\n        :return:\n        \"\"\"\n\n        if self.is_http():\n            conn = HTTPConnection()\n        elif self.is_https():\n            # TODO: HTTPS\n            # conn = HTTPSConnection()\n            raise NotImplementedError(\"HTTPS not implemented yet.\")\n        else:\n            raise MissingScheme(\n                f\"Scheme: {self.scheme}, parse scheme failed, can't create connection.\"\n            )\n\n        return conn\n\n    def parse_proxies(self):\n        \"\"\"\n        TODO\n        Parse proxy, proxy's username and password. if proxies is set.\n        :return:\n        \"\"\"\n        return None, None, None", ""]}
{"filename": "ja3requests/protocol/__init__.py", "chunked_list": [""]}
{"filename": "ja3requests/protocol/sockets.py", "chunked_list": ["# pylint: skip-file\n\"\"\"\nja3requests.protocol.sockets\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module contains socket dependencies.\n\"\"\"\n\nimport socket\nfrom .exceptions import LocationParseError", "import socket\nfrom .exceptions import LocationParseError\n\n\ndef create_connection(\n    address,\n    timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n    source_address=None,\n    socket_options=None,\n):\n    \"\"\"\n    Create a socket connection.\n    :param address:\n    :param timeout:\n    :param source_address:\n    :param socket_options:\n    :return:\n    \"\"\"\n    if socket_options is None:\n        socket_options = [(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]\n\n    err = None\n    host, port = address\n\n    family = allowed_gai_family()\n\n    try:\n        host.encode(\"idna\")\n    except UnicodeError:\n        raise LocationParseError(f\"{host!r}, label empty or too long\")\n\n    for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n        _family, _type, _proto, _canonname, _addr = res\n        sock = None\n        try:\n            sock = socket.socket(_family, _type, _proto)\n\n            # If provided, set socket level options before connecting.\n            _set_socket_options(sock, socket_options)\n\n            if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                sock.settimeout(timeout)\n            if source_address:\n                sock.bind(source_address)\n            sock.connect(_addr)\n            return sock\n\n        except socket.error as e:\n            err = e\n            if sock is not None:\n                sock.close()\n\n    if err is not None:\n        raise err\n\n    raise socket.error(\"getaddrinfo returns an empty list\")", "\n\ndef _set_socket_options(sock, options):\n    if options is None:\n        return\n\n    for opt in options:\n        sock.setsockopt(*opt)\n\n\ndef allowed_gai_family():\n    family = socket.AF_INET\n    if HAS_IPV6:\n        family = socket.AF_UNSPEC\n    return family", "\n\ndef allowed_gai_family():\n    family = socket.AF_INET\n    if HAS_IPV6:\n        family = socket.AF_UNSPEC\n    return family\n\n\ndef _has_ipv6(host):\n    \"\"\"Returns True if the system can bind an IPv6 address.\"\"\"\n    sock = None\n    has_ipv6 = False\n\n    if socket.has_ipv6:\n        try:\n            sock = socket.socket(socket.AF_INET6)\n            sock.bind((host, 0))\n            has_ipv6 = True\n        except Exception:\n            pass\n\n    if sock:\n        sock.close()\n    return has_ipv6", "\ndef _has_ipv6(host):\n    \"\"\"Returns True if the system can bind an IPv6 address.\"\"\"\n    sock = None\n    has_ipv6 = False\n\n    if socket.has_ipv6:\n        try:\n            sock = socket.socket(socket.AF_INET6)\n            sock.bind((host, 0))\n            has_ipv6 = True\n        except Exception:\n            pass\n\n    if sock:\n        sock.close()\n    return has_ipv6", "\n\nHAS_IPV6 = _has_ipv6(\"::1\")\n"]}
{"filename": "ja3requests/protocol/exceptions.py", "chunked_list": ["\"\"\"\nja3requests.protocol.exceptions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module contains socket exceptions.\n\"\"\"\n\n\nclass SocketException(Exception):\n    \"\"\"\n    Base exception used by this module.\n    \"\"\"", "class SocketException(Exception):\n    \"\"\"\n    Base exception used by this module.\n    \"\"\"\n\n\nclass SocketTimeout(OSError):\n    \"\"\"Timeout expired.\"\"\"\n\n\nclass LocationParseError(SocketException, ValueError):\n    \"\"\"\n    Socket host encode error.\n    \"\"\"", "\n\nclass LocationParseError(SocketException, ValueError):\n    \"\"\"\n    Socket host encode error.\n    \"\"\"\n\n\nclass SocketTimeoutError(SocketException):\n    \"\"\"\n    Raised when a socket timeout error occurs.\n    \"\"\"", "class SocketTimeoutError(SocketException):\n    \"\"\"\n    Raised when a socket timeout error occurs.\n    \"\"\"\n\n\nclass ConnectTimeoutError(SocketTimeoutError):\n    \"\"\"\n    Raised when a socket timeout occurs while connecting to a server\n    \"\"\"", "\n\nclass ReadTimeout(SocketTimeoutError):\n    \"\"\"\n    Raised when socket receive timeout.\n    \"\"\"\n"]}
{"filename": "ja3requests/base/_connection.py", "chunked_list": ["\"\"\"\nja3Requests.base._connection\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBasic HTTP Connection\n\"\"\"\n\n\nclass BaseHttpConnection:\n    \"\"\"\n    Basic HTTP Connection\n    \"\"\"\n\n    def __init__(self):\n        self._scheme = None\n        self._host = None\n        self._port = None\n        self._source_address = None\n        self._destination_address = None\n        self._path = None\n        self._timeout = None\n        self._proxy = None\n        self._proxy_username = None\n        self._proxy_password = None\n        self._connection = None\n        self._is_close = None\n\n    @property\n    def scheme(self):\n        \"\"\"\n        Scheme\n        :return:\n        \"\"\"\n        return self._scheme\n\n    @scheme.setter\n    def scheme(self, attr):\n        \"\"\"\n        Set Scheme\n        :param attr:\n        :return:\n        \"\"\"\n        self._scheme = attr\n\n    @property\n    def host(self):\n        \"\"\"\n        Host\n        :return:\n        \"\"\"\n        return self._host\n\n    @host.setter\n    def host(self, attr):\n        \"\"\"\n        Set Host\n        :param attr:\n        :return:\n        \"\"\"\n        self._host = attr\n\n    @property\n    def port(self):\n        \"\"\"\n        Port\n        :return:\n        \"\"\"\n        return self._port\n\n    @port.setter\n    def port(self, attr):\n        \"\"\"\n        Set Port\n        :param attr:\n        :return:\n        \"\"\"\n        self._port = attr\n\n    @property\n    def source_address(self):\n        \"\"\"\n        Source Address\n        :return:\n        \"\"\"\n        return self._source_address\n\n    @source_address.setter\n    def source_address(self, attr):\n        \"\"\"\n        Set Source Address\n        :param attr:\n        :return:\n        \"\"\"\n        self._source_address = attr\n\n    @property\n    def destination_address(self):\n        \"\"\"\n        Destination Address\n        :return:\n        \"\"\"\n        return self._destination_address\n\n    @destination_address.setter\n    def destination_address(self, attr):\n        \"\"\"\n        Set Destination Address\n        :param attr:\n        :return:\n        \"\"\"\n        self._destination_address = attr\n\n    @property\n    def path(self):\n        \"\"\"\n        Path\n        :return:\n        \"\"\"\n        return self._path\n\n    @path.setter\n    def path(self, attr):\n        \"\"\"\n        Set Path\n        :param attr:\n        :return:\n        \"\"\"\n        self._path = attr\n\n    @property\n    def timeout(self):\n        \"\"\"\n        Timeout\n        :return:\n        \"\"\"\n        return self._timeout\n\n    @timeout.setter\n    def timeout(self, attr):\n        \"\"\"\n        Set Timeout\n        :param attr:\n        :return:\n        \"\"\"\n        self._timeout = attr\n\n    @property\n    def proxy(self):\n        \"\"\"\n        Proxy\n        :return:\n        \"\"\"\n        return self._proxy\n\n    @proxy.setter\n    def proxy(self, attr):\n        \"\"\"\n        Set Proxy\n        :param attr:\n        :return:\n        \"\"\"\n        self._proxy = attr\n\n    @property\n    def proxy_username(self):\n        \"\"\"\n        Proxy username\n        :return:\n        \"\"\"\n        return self._proxy_username\n\n    @proxy_username.setter\n    def proxy_username(self, attr):\n        \"\"\"\n        Set Proxy Username\n        :param attr:\n        :return:\n        \"\"\"\n        self._proxy_username = attr\n\n    @property\n    def proxy_password(self):\n        \"\"\"\n        Proxy Password\n        :return:\n        \"\"\"\n        return self._proxy_password\n\n    @proxy_password.setter\n    def proxy_password(self, attr):\n        \"\"\"\n        Set Proxy Password\n        :param attr:\n        :return:\n        \"\"\"\n        self._proxy_password = attr\n\n    @property\n    def connection(self):\n        \"\"\"\n        Connection\n        :return:\n        \"\"\"\n        return self._connection\n\n    @connection.setter\n    def connection(self, attr):\n        \"\"\"\n        Set Connection\n        :param attr:\n        :return:\n        \"\"\"\n        self._connection = attr\n\n    @property\n    def is_close(self):\n        \"\"\"\n        Connection is closed\n        :return:\n        \"\"\"\n        return self._is_close\n\n    @is_close.setter\n    def is_close(self, attr):\n        \"\"\"\n        Set connection close\n        :param attr:\n        :return:\n        \"\"\"\n        self._is_close = attr", "class BaseHttpConnection:\n    \"\"\"\n    Basic HTTP Connection\n    \"\"\"\n\n    def __init__(self):\n        self._scheme = None\n        self._host = None\n        self._port = None\n        self._source_address = None\n        self._destination_address = None\n        self._path = None\n        self._timeout = None\n        self._proxy = None\n        self._proxy_username = None\n        self._proxy_password = None\n        self._connection = None\n        self._is_close = None\n\n    @property\n    def scheme(self):\n        \"\"\"\n        Scheme\n        :return:\n        \"\"\"\n        return self._scheme\n\n    @scheme.setter\n    def scheme(self, attr):\n        \"\"\"\n        Set Scheme\n        :param attr:\n        :return:\n        \"\"\"\n        self._scheme = attr\n\n    @property\n    def host(self):\n        \"\"\"\n        Host\n        :return:\n        \"\"\"\n        return self._host\n\n    @host.setter\n    def host(self, attr):\n        \"\"\"\n        Set Host\n        :param attr:\n        :return:\n        \"\"\"\n        self._host = attr\n\n    @property\n    def port(self):\n        \"\"\"\n        Port\n        :return:\n        \"\"\"\n        return self._port\n\n    @port.setter\n    def port(self, attr):\n        \"\"\"\n        Set Port\n        :param attr:\n        :return:\n        \"\"\"\n        self._port = attr\n\n    @property\n    def source_address(self):\n        \"\"\"\n        Source Address\n        :return:\n        \"\"\"\n        return self._source_address\n\n    @source_address.setter\n    def source_address(self, attr):\n        \"\"\"\n        Set Source Address\n        :param attr:\n        :return:\n        \"\"\"\n        self._source_address = attr\n\n    @property\n    def destination_address(self):\n        \"\"\"\n        Destination Address\n        :return:\n        \"\"\"\n        return self._destination_address\n\n    @destination_address.setter\n    def destination_address(self, attr):\n        \"\"\"\n        Set Destination Address\n        :param attr:\n        :return:\n        \"\"\"\n        self._destination_address = attr\n\n    @property\n    def path(self):\n        \"\"\"\n        Path\n        :return:\n        \"\"\"\n        return self._path\n\n    @path.setter\n    def path(self, attr):\n        \"\"\"\n        Set Path\n        :param attr:\n        :return:\n        \"\"\"\n        self._path = attr\n\n    @property\n    def timeout(self):\n        \"\"\"\n        Timeout\n        :return:\n        \"\"\"\n        return self._timeout\n\n    @timeout.setter\n    def timeout(self, attr):\n        \"\"\"\n        Set Timeout\n        :param attr:\n        :return:\n        \"\"\"\n        self._timeout = attr\n\n    @property\n    def proxy(self):\n        \"\"\"\n        Proxy\n        :return:\n        \"\"\"\n        return self._proxy\n\n    @proxy.setter\n    def proxy(self, attr):\n        \"\"\"\n        Set Proxy\n        :param attr:\n        :return:\n        \"\"\"\n        self._proxy = attr\n\n    @property\n    def proxy_username(self):\n        \"\"\"\n        Proxy username\n        :return:\n        \"\"\"\n        return self._proxy_username\n\n    @proxy_username.setter\n    def proxy_username(self, attr):\n        \"\"\"\n        Set Proxy Username\n        :param attr:\n        :return:\n        \"\"\"\n        self._proxy_username = attr\n\n    @property\n    def proxy_password(self):\n        \"\"\"\n        Proxy Password\n        :return:\n        \"\"\"\n        return self._proxy_password\n\n    @proxy_password.setter\n    def proxy_password(self, attr):\n        \"\"\"\n        Set Proxy Password\n        :param attr:\n        :return:\n        \"\"\"\n        self._proxy_password = attr\n\n    @property\n    def connection(self):\n        \"\"\"\n        Connection\n        :return:\n        \"\"\"\n        return self._connection\n\n    @connection.setter\n    def connection(self, attr):\n        \"\"\"\n        Set Connection\n        :param attr:\n        :return:\n        \"\"\"\n        self._connection = attr\n\n    @property\n    def is_close(self):\n        \"\"\"\n        Connection is closed\n        :return:\n        \"\"\"\n        return self._is_close\n\n    @is_close.setter\n    def is_close(self, attr):\n        \"\"\"\n        Set connection close\n        :param attr:\n        :return:\n        \"\"\"\n        self._is_close = attr", ""]}
{"filename": "ja3requests/base/_response.py", "chunked_list": ["\"\"\"\nja3Requests.base._response\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBasic Response\n\"\"\"\n\n\nclass BaseResponse:\n    \"\"\"\n    The basic response.\n    \"\"\"\n\n    def __init__(self):\n        self._raw = None\n        self._protocol_version = None\n        self._status_code = None\n        self._status_text = None\n        self._headers = None\n        self._body = None\n\n    @property\n    def raw(self):\n        \"\"\"Raw Response\n        Receive from remote connection.\n        >>> b\"HTTP/1.1 200 OK...\"\n        :return:\n        \"\"\"\n        return self._raw\n\n    @raw.setter\n    def raw(self, attr):\n        \"\"\"\n        Set raw response.\n        :param attr:\n        :return:\n        \"\"\"\n        self._raw = attr\n\n    @property\n    def protocol_version(self):\n        \"\"\"\n        Protocol Version\n        >>> b\"HTTP/1.1\"\n        :return:\n        \"\"\"\n        return self._protocol_version\n\n    @protocol_version.setter\n    def protocol_version(self, attr):\n        \"\"\"\n        Set protocol version\n        :param attr:\n        :return:\n        \"\"\"\n        self._protocol_version = attr\n\n    @property\n    def status_code(self):\n        \"\"\"STATUS CODE\n        The response status code, e.g(200, 203, 400, 404...)\n        >>> b\"200\"\n        :return:\n        \"\"\"\n        return self._status_code\n\n    @status_code.setter\n    def status_code(self, attr):\n        \"\"\"\n        Set response status code.\n        :param attr:\n        :return:\n        \"\"\"\n        self._status_code = attr\n\n    @property\n    def status_text(self):\n        \"\"\"\n        Response status text. eg. HTTP/1.1 200 OK\n        >>> b\"OK\"\n        :return:\n        \"\"\"\n        return self._status_text\n\n    @status_text.setter\n    def status_text(self, attr):\n        \"\"\"\n        Set response status text.\n        :param attr:\n        :return:\n        \"\"\"\n        self._status_text = attr\n\n    @property\n    def headers(self):\n        \"\"\"Headers\n        Response headers\n        :return:\n        \"\"\"\n        return self._headers\n\n    @headers.setter\n    def headers(self, attr):\n        \"\"\"\n        Set response headers.\n        :param attr:\n        :return:\n        \"\"\"\n        self._headers = attr\n\n    @property\n    def body(self):\n        \"\"\"\n        Response Body\n        :return:\n        \"\"\"\n        return self._body\n\n    @body.setter\n    def body(self, attr):\n        \"\"\"\n        Set response body.\n        :param attr:\n        :return:\n        \"\"\"\n        self._body = attr", "class BaseResponse:\n    \"\"\"\n    The basic response.\n    \"\"\"\n\n    def __init__(self):\n        self._raw = None\n        self._protocol_version = None\n        self._status_code = None\n        self._status_text = None\n        self._headers = None\n        self._body = None\n\n    @property\n    def raw(self):\n        \"\"\"Raw Response\n        Receive from remote connection.\n        >>> b\"HTTP/1.1 200 OK...\"\n        :return:\n        \"\"\"\n        return self._raw\n\n    @raw.setter\n    def raw(self, attr):\n        \"\"\"\n        Set raw response.\n        :param attr:\n        :return:\n        \"\"\"\n        self._raw = attr\n\n    @property\n    def protocol_version(self):\n        \"\"\"\n        Protocol Version\n        >>> b\"HTTP/1.1\"\n        :return:\n        \"\"\"\n        return self._protocol_version\n\n    @protocol_version.setter\n    def protocol_version(self, attr):\n        \"\"\"\n        Set protocol version\n        :param attr:\n        :return:\n        \"\"\"\n        self._protocol_version = attr\n\n    @property\n    def status_code(self):\n        \"\"\"STATUS CODE\n        The response status code, e.g(200, 203, 400, 404...)\n        >>> b\"200\"\n        :return:\n        \"\"\"\n        return self._status_code\n\n    @status_code.setter\n    def status_code(self, attr):\n        \"\"\"\n        Set response status code.\n        :param attr:\n        :return:\n        \"\"\"\n        self._status_code = attr\n\n    @property\n    def status_text(self):\n        \"\"\"\n        Response status text. eg. HTTP/1.1 200 OK\n        >>> b\"OK\"\n        :return:\n        \"\"\"\n        return self._status_text\n\n    @status_text.setter\n    def status_text(self, attr):\n        \"\"\"\n        Set response status text.\n        :param attr:\n        :return:\n        \"\"\"\n        self._status_text = attr\n\n    @property\n    def headers(self):\n        \"\"\"Headers\n        Response headers\n        :return:\n        \"\"\"\n        return self._headers\n\n    @headers.setter\n    def headers(self, attr):\n        \"\"\"\n        Set response headers.\n        :param attr:\n        :return:\n        \"\"\"\n        self._headers = attr\n\n    @property\n    def body(self):\n        \"\"\"\n        Response Body\n        :return:\n        \"\"\"\n        return self._body\n\n    @body.setter\n    def body(self, attr):\n        \"\"\"\n        Set response body.\n        :param attr:\n        :return:\n        \"\"\"\n        self._body = attr", ""]}
{"filename": "ja3requests/base/__init__.py", "chunked_list": ["\"\"\"\nja3requests.base\n~~~~~~~~~~~~~~~~\n\nBasic module.\n\"\"\"\n\nfrom ._context import BaseContext\nfrom ._request import BaseRequest\nfrom ._sessions import BaseSession", "from ._request import BaseRequest\nfrom ._sessions import BaseSession\nfrom ._response import BaseResponse\nfrom ._connection import BaseHttpConnection\n"]}
{"filename": "ja3requests/base/_sessions.py", "chunked_list": ["\"\"\"\nja3Requests.base._sessions\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBasic Session\n\"\"\"\n\n\nclass BaseSession:\n    \"\"\"\n    The basic request session.\n    \"\"\"\n\n    def __init__(self):\n        self._headers = None\n        self._cookies = None\n        self._auth = None\n        self._proxies = None\n        self._params = None\n        self._max_redirects = None\n        self._allow_redirect = None\n        self._ja3_text = None\n        self._h2_settings = None\n        self._h2_window_update = None\n        self._h2_headers = None\n\n    @property\n    def headers(self):\n        \"\"\"Headers\n        Http headers.\n        >>> {'Accept': '*/*', 'Accept-Encoding': 'gzip,deflate'}\n        :return:\n        \"\"\"\n        return self._headers\n\n    @headers.setter\n    def headers(self, attr):\n        \"\"\"\n        Set Headers\n        :param attr:\n        :return:\n        \"\"\"\n        self._headers = attr\n\n    @property\n    def cookies(self):\n        \"\"\"Cookies\n        Http cookies.\n        >>> CookieJar({})\n        :return:\n        \"\"\"\n        return self._cookies\n\n    @cookies.setter\n    def cookies(self, attr):\n        \"\"\"\n        Set Cookies\n        :param attr:\n        :return:\n        \"\"\"\n        self.cookies = attr\n\n    @property\n    def auth(self):\n        \"\"\"Auth\n        >>> {'user': 'xxx', 'password': 'xxx'}\n        :return:\n        \"\"\"\n        return self._auth\n\n    @auth.setter\n    def auth(self, attr):\n        \"\"\"\n        Set Auth\n        :param attr:\n        :return:\n        \"\"\"\n        self._auth = attr\n\n    @property\n    def proxies(self):\n        \"\"\"Proxies\n        Http proxy server.\n        >>> {'http': 'user:password@host:port', 'https': 'user:password@host:port'}\n        :return:\n        \"\"\"\n        return self._cookies\n\n    @proxies.setter\n    def proxies(self, attr):\n        \"\"\"\n        Set Proxies\n        :param attr:\n        :return:\n        \"\"\"\n        self._proxies = attr\n\n    @property\n    def params(self):\n        \"\"\"Params.\n        Request Params. ?page=1&per_page=10\n        >>> {'page': 1, 'per_page': 10}\n        :return:\n        \"\"\"\n        return self._params\n\n    @params.setter\n    def params(self, attr):\n        \"\"\"\n        Set Params\n        :param attr:\n        :return:\n        \"\"\"\n        self._params = attr\n\n    @property\n    def max_redirects(self):\n        \"\"\"Max Redirects.\n        The max for redirect times.\n        >>> 5\n        :return:\n        \"\"\"\n        return self._max_redirects\n\n    @max_redirects.setter\n    def max_redirects(self, attr):\n        \"\"\"\n        Set Max Redirects\n        :param attr:\n        :return:\n        \"\"\"\n        self._max_redirects = attr\n\n    @property\n    def allow_redirect(self):\n        \"\"\"Allow Redirect.\n        Whether allow redirect.\n        >>> True or False.\n        :return:\n        \"\"\"\n        return self._allow_redirect\n\n    @allow_redirect.setter\n    def allow_redirect(self, attr):\n        \"\"\"\n        Set Allow Redirect\n        :param attr:\n        :return:\n        \"\"\"\n        self._allow_redirect = attr\n\n    @property\n    def ja3_text(self):\n        \"\"\"Ja3 Text.\n        The TLS fingerprint ja3 text.\n        >>> \"771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,17513-27-0-13-35-43-65281-23-51-5-45-11-16-10-18-21,29-23-24,0\"\n        :return:\n        \"\"\"\n        return self._ja3_text\n\n    @ja3_text.setter\n    def ja3_text(self, attr):\n        \"\"\"\n        Set Ja3 Text\n        :param attr:\n        :return:\n        \"\"\"\n        self._ja3_text = attr\n\n    @property\n    def h2_settings(self):\n        \"\"\"H2 Settings.\n        The htp2 fingerprint SETTINGS.\n        >>> {\"1\": \"65535\", \"2\": \"0\", \"3\": \"1000\", \"4\": \"6291456\", \"6\": \"262144\"}\n        :return:\n        \"\"\"\n        return self._h2_settings\n\n    @h2_settings.setter\n    def h2_settings(self, attr):\n        \"\"\"\n        Set H2 Settings\n        :param attr:\n        :return:\n        \"\"\"\n        self._h2_settings = attr\n\n    @property\n    def h2_window_update(self):\n        \"\"\"H2 Window Update.\n        The http2 fingerprint WINDOW_UPDATE.\n        >>> \"15663105\"\n        :return:\n        \"\"\"\n        return self._h2_window_update\n\n    @h2_window_update.setter\n    def h2_window_update(self, attr):\n        \"\"\"\n        Set Window Update\n        :param attr:\n        :return:\n        \"\"\"\n        self._h2_window_update = attr\n\n    @property\n    def h2_headers(self):\n        \"\"\"H2 Headers.\n        The http2 fingerprint HEADERS.\n        :method\n        :authority\n        :scheme\n        :path\n        >>> \"m,a,s,p\"\n        :return:\n        \"\"\"\n        return self._h2_headers\n\n    @h2_headers.setter\n    def h2_headers(self, attr):\n        \"\"\"\n        Set H2 Headers\n        :param attr:\n        :return:\n        \"\"\"\n        self._h2_headers = attr\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        self.close(*args, **kwargs)\n\n    def close(self, *args, **kwargs):\n        \"\"\"\n        Close session.\n        :param args:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n    def request(self, *args, **kwargs):\n        \"\"\"\n        Request\n        :return:\n        \"\"\"\n\n    def get(self, *args, **kwargs):\n        \"\"\"\n        GET Method.\n        :return:\n        \"\"\"\n\n    def options(self, *args, **kwargs):\n        \"\"\"\n        OPTIONS Method.\n        :return:\n        \"\"\"\n\n    def head(self, *args, **kwargs):\n        \"\"\"\n        HEAD Method.\n        :return:\n        \"\"\"\n\n    def post(self, *args, **kwargs):\n        \"\"\"\n        POST Method.\n        :return:\n        \"\"\"\n\n    def put(self, *args, **kwargs):\n        \"\"\"\n        PUT Method.\n        :return:\n        \"\"\"\n\n    def patch(self, *args, **kwargs):\n        \"\"\"\n        PATCH Method.\n        :return:\n        \"\"\"\n\n    def delete(self, *args, **kwargs):\n        \"\"\"\n        DELETE Method.\n        :return:\n        \"\"\"\n\n    def send(self, *args, **kwargs):\n        \"\"\"\n        Send\n        :return:\n        \"\"\"", "class BaseSession:\n    \"\"\"\n    The basic request session.\n    \"\"\"\n\n    def __init__(self):\n        self._headers = None\n        self._cookies = None\n        self._auth = None\n        self._proxies = None\n        self._params = None\n        self._max_redirects = None\n        self._allow_redirect = None\n        self._ja3_text = None\n        self._h2_settings = None\n        self._h2_window_update = None\n        self._h2_headers = None\n\n    @property\n    def headers(self):\n        \"\"\"Headers\n        Http headers.\n        >>> {'Accept': '*/*', 'Accept-Encoding': 'gzip,deflate'}\n        :return:\n        \"\"\"\n        return self._headers\n\n    @headers.setter\n    def headers(self, attr):\n        \"\"\"\n        Set Headers\n        :param attr:\n        :return:\n        \"\"\"\n        self._headers = attr\n\n    @property\n    def cookies(self):\n        \"\"\"Cookies\n        Http cookies.\n        >>> CookieJar({})\n        :return:\n        \"\"\"\n        return self._cookies\n\n    @cookies.setter\n    def cookies(self, attr):\n        \"\"\"\n        Set Cookies\n        :param attr:\n        :return:\n        \"\"\"\n        self.cookies = attr\n\n    @property\n    def auth(self):\n        \"\"\"Auth\n        >>> {'user': 'xxx', 'password': 'xxx'}\n        :return:\n        \"\"\"\n        return self._auth\n\n    @auth.setter\n    def auth(self, attr):\n        \"\"\"\n        Set Auth\n        :param attr:\n        :return:\n        \"\"\"\n        self._auth = attr\n\n    @property\n    def proxies(self):\n        \"\"\"Proxies\n        Http proxy server.\n        >>> {'http': 'user:password@host:port', 'https': 'user:password@host:port'}\n        :return:\n        \"\"\"\n        return self._cookies\n\n    @proxies.setter\n    def proxies(self, attr):\n        \"\"\"\n        Set Proxies\n        :param attr:\n        :return:\n        \"\"\"\n        self._proxies = attr\n\n    @property\n    def params(self):\n        \"\"\"Params.\n        Request Params. ?page=1&per_page=10\n        >>> {'page': 1, 'per_page': 10}\n        :return:\n        \"\"\"\n        return self._params\n\n    @params.setter\n    def params(self, attr):\n        \"\"\"\n        Set Params\n        :param attr:\n        :return:\n        \"\"\"\n        self._params = attr\n\n    @property\n    def max_redirects(self):\n        \"\"\"Max Redirects.\n        The max for redirect times.\n        >>> 5\n        :return:\n        \"\"\"\n        return self._max_redirects\n\n    @max_redirects.setter\n    def max_redirects(self, attr):\n        \"\"\"\n        Set Max Redirects\n        :param attr:\n        :return:\n        \"\"\"\n        self._max_redirects = attr\n\n    @property\n    def allow_redirect(self):\n        \"\"\"Allow Redirect.\n        Whether allow redirect.\n        >>> True or False.\n        :return:\n        \"\"\"\n        return self._allow_redirect\n\n    @allow_redirect.setter\n    def allow_redirect(self, attr):\n        \"\"\"\n        Set Allow Redirect\n        :param attr:\n        :return:\n        \"\"\"\n        self._allow_redirect = attr\n\n    @property\n    def ja3_text(self):\n        \"\"\"Ja3 Text.\n        The TLS fingerprint ja3 text.\n        >>> \"771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,17513-27-0-13-35-43-65281-23-51-5-45-11-16-10-18-21,29-23-24,0\"\n        :return:\n        \"\"\"\n        return self._ja3_text\n\n    @ja3_text.setter\n    def ja3_text(self, attr):\n        \"\"\"\n        Set Ja3 Text\n        :param attr:\n        :return:\n        \"\"\"\n        self._ja3_text = attr\n\n    @property\n    def h2_settings(self):\n        \"\"\"H2 Settings.\n        The htp2 fingerprint SETTINGS.\n        >>> {\"1\": \"65535\", \"2\": \"0\", \"3\": \"1000\", \"4\": \"6291456\", \"6\": \"262144\"}\n        :return:\n        \"\"\"\n        return self._h2_settings\n\n    @h2_settings.setter\n    def h2_settings(self, attr):\n        \"\"\"\n        Set H2 Settings\n        :param attr:\n        :return:\n        \"\"\"\n        self._h2_settings = attr\n\n    @property\n    def h2_window_update(self):\n        \"\"\"H2 Window Update.\n        The http2 fingerprint WINDOW_UPDATE.\n        >>> \"15663105\"\n        :return:\n        \"\"\"\n        return self._h2_window_update\n\n    @h2_window_update.setter\n    def h2_window_update(self, attr):\n        \"\"\"\n        Set Window Update\n        :param attr:\n        :return:\n        \"\"\"\n        self._h2_window_update = attr\n\n    @property\n    def h2_headers(self):\n        \"\"\"H2 Headers.\n        The http2 fingerprint HEADERS.\n        :method\n        :authority\n        :scheme\n        :path\n        >>> \"m,a,s,p\"\n        :return:\n        \"\"\"\n        return self._h2_headers\n\n    @h2_headers.setter\n    def h2_headers(self, attr):\n        \"\"\"\n        Set H2 Headers\n        :param attr:\n        :return:\n        \"\"\"\n        self._h2_headers = attr\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        self.close(*args, **kwargs)\n\n    def close(self, *args, **kwargs):\n        \"\"\"\n        Close session.\n        :param args:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n    def request(self, *args, **kwargs):\n        \"\"\"\n        Request\n        :return:\n        \"\"\"\n\n    def get(self, *args, **kwargs):\n        \"\"\"\n        GET Method.\n        :return:\n        \"\"\"\n\n    def options(self, *args, **kwargs):\n        \"\"\"\n        OPTIONS Method.\n        :return:\n        \"\"\"\n\n    def head(self, *args, **kwargs):\n        \"\"\"\n        HEAD Method.\n        :return:\n        \"\"\"\n\n    def post(self, *args, **kwargs):\n        \"\"\"\n        POST Method.\n        :return:\n        \"\"\"\n\n    def put(self, *args, **kwargs):\n        \"\"\"\n        PUT Method.\n        :return:\n        \"\"\"\n\n    def patch(self, *args, **kwargs):\n        \"\"\"\n        PATCH Method.\n        :return:\n        \"\"\"\n\n    def delete(self, *args, **kwargs):\n        \"\"\"\n        DELETE Method.\n        :return:\n        \"\"\"\n\n    def send(self, *args, **kwargs):\n        \"\"\"\n        Send\n        :return:\n        \"\"\"", ""]}
{"filename": "ja3requests/base/_context.py", "chunked_list": ["\"\"\"\"\nja3Requests.base._context\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBasic Context\n\"\"\"\n\n\nclass BaseContext:\n    \"\"\"\n    Basic connection context.\n    \"\"\"\n\n    def __init__(self):\n        self._protocol = None\n        self._version = None\n        self._start_line = None\n        self._method = None\n        self._headers = None\n        self._body = None\n        self._message = None\n\n    @property\n    def protocol(self):\n        \"\"\"\n        Protocol\n        :return:\n        \"\"\"\n        return self._protocol\n\n    @protocol.setter\n    def protocol(self, attr):\n        \"\"\"\n        Set protocol\n        :param attr:\n        :return:\n        \"\"\"\n        self._protocol = attr\n\n    @property\n    def version(self):\n        \"\"\"\n        Version\n        :return:\n        \"\"\"\n        return self._version\n\n    @version.setter\n    def version(self, attr):\n        \"\"\"\n        Set version\n        :param attr:\n        :return:\n        \"\"\"\n        self._version = attr\n\n    @property\n    def start_line(self):\n        \"\"\"\n        Start line\n        :return:\n        \"\"\"\n        return self._start_line\n\n    @start_line.setter\n    def start_line(self, attr):\n        \"\"\"\n        Set start line\n        :param attr:\n        :return:\n        \"\"\"\n        self._start_line = attr\n\n    @property\n    def method(self):\n        \"\"\"\n        Method\n        :return:\n        \"\"\"\n        return self._method\n\n    @method.setter\n    def method(self, attr):\n        \"\"\"\n        Set method\n        :param attr:\n        :return:\n        \"\"\"\n        self._method = attr\n\n    @property\n    def headers(self):\n        \"\"\"\n        Headers\n        :return:\n        \"\"\"\n        return self._headers\n\n    @headers.setter\n    def headers(self, attr):\n        \"\"\"\n        Set headers\n        :param attr:\n        :return:\n        \"\"\"\n        self._headers = attr\n\n    @property\n    def body(self):\n        \"\"\"\n        Body\n        :return:\n        \"\"\"\n        return self._body\n\n    @body.setter\n    def body(self, attr):\n        \"\"\"\n        Set body\n        :param attr:\n        :return:\n        \"\"\"\n        self._body = attr\n\n    @property\n    def message(self):\n        \"\"\"\n        Message\n        :return:\n        \"\"\"\n        return self._message\n\n    @message.setter\n    def message(self, attr):\n        \"\"\"\n        Set message\n        :param attr:\n        :return:\n        \"\"\"\n        self._message = attr", "class BaseContext:\n    \"\"\"\n    Basic connection context.\n    \"\"\"\n\n    def __init__(self):\n        self._protocol = None\n        self._version = None\n        self._start_line = None\n        self._method = None\n        self._headers = None\n        self._body = None\n        self._message = None\n\n    @property\n    def protocol(self):\n        \"\"\"\n        Protocol\n        :return:\n        \"\"\"\n        return self._protocol\n\n    @protocol.setter\n    def protocol(self, attr):\n        \"\"\"\n        Set protocol\n        :param attr:\n        :return:\n        \"\"\"\n        self._protocol = attr\n\n    @property\n    def version(self):\n        \"\"\"\n        Version\n        :return:\n        \"\"\"\n        return self._version\n\n    @version.setter\n    def version(self, attr):\n        \"\"\"\n        Set version\n        :param attr:\n        :return:\n        \"\"\"\n        self._version = attr\n\n    @property\n    def start_line(self):\n        \"\"\"\n        Start line\n        :return:\n        \"\"\"\n        return self._start_line\n\n    @start_line.setter\n    def start_line(self, attr):\n        \"\"\"\n        Set start line\n        :param attr:\n        :return:\n        \"\"\"\n        self._start_line = attr\n\n    @property\n    def method(self):\n        \"\"\"\n        Method\n        :return:\n        \"\"\"\n        return self._method\n\n    @method.setter\n    def method(self, attr):\n        \"\"\"\n        Set method\n        :param attr:\n        :return:\n        \"\"\"\n        self._method = attr\n\n    @property\n    def headers(self):\n        \"\"\"\n        Headers\n        :return:\n        \"\"\"\n        return self._headers\n\n    @headers.setter\n    def headers(self, attr):\n        \"\"\"\n        Set headers\n        :param attr:\n        :return:\n        \"\"\"\n        self._headers = attr\n\n    @property\n    def body(self):\n        \"\"\"\n        Body\n        :return:\n        \"\"\"\n        return self._body\n\n    @body.setter\n    def body(self, attr):\n        \"\"\"\n        Set body\n        :param attr:\n        :return:\n        \"\"\"\n        self._body = attr\n\n    @property\n    def message(self):\n        \"\"\"\n        Message\n        :return:\n        \"\"\"\n        return self._message\n\n    @message.setter\n    def message(self, attr):\n        \"\"\"\n        Set message\n        :param attr:\n        :return:\n        \"\"\"\n        self._message = attr", ""]}
{"filename": "ja3requests/base/_request.py", "chunked_list": ["\"\"\"\nja3Requests.base._request\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBasic Request\n\"\"\"\n\n\nclass BaseRequest:\n    \"\"\"\n    The basic request.\n    \"\"\"\n\n    def __init__(self):\n        self._method = None\n        self._source = None\n        self._url = None\n        self._scheme = None\n        self._port = None\n        self._headers = None\n        self._params = None\n        self._data = None\n        self._cookies = None\n        self._files = None\n        self._auth = None\n        self._json = None\n        self._timeout = None\n        self._proxies = None\n\n    @property\n    def method(self):\n        \"\"\"\n        Request method\n        >>> \"GET\"\n        :return:\n        \"\"\"\n        return self._method\n\n    @method.setter\n    def method(self, attr):\n        \"\"\"\n        Set request method.\n        :param attr:\n        :return:\n        \"\"\"\n        self._method = attr\n\n    @property\n    def source(self):\n        \"\"\"\n        Source Address.\n        :return:\n        \"\"\"\n        return self._source\n\n    @source.setter\n    def source(self, attr):\n        \"\"\"\n        Set source address.\n        :param attr:\n        :return:\n        \"\"\"\n        self._source = attr\n\n    @property\n    def url(self):\n        \"\"\"\n        Request url.\n        :return:\n        \"\"\"\n        return self._url\n\n    @url.setter\n    def url(self, attr):\n        \"\"\"\n        Set request url.\n        :param attr:\n        :return:\n        \"\"\"\n        self._url = attr\n\n    @property\n    def scheme(self):\n        \"\"\"\n        Request Scheme. eg. HTTP, HTTPS\n        :return:\n        \"\"\"\n        return self._scheme\n\n    @scheme.setter\n    def scheme(self, attr):\n        \"\"\"\n        Set scheme.\n        :param attr:\n        :return:\n        \"\"\"\n        self._scheme = attr\n\n    @property\n    def port(self):\n        \"\"\"\n        Remote address port.\n        :return:\n        \"\"\"\n        return self._port\n\n    @port.setter\n    def port(self, attr):\n        \"\"\"\n        Set port.\n        :param attr:\n        :return:\n        \"\"\"\n        self._port = attr\n\n    @property\n    def headers(self):\n        \"\"\"Headers\n        Request headers.\n        >>> {\"Host\": \"www.example.com\", \"Accept\": \"*/*\"}\n        :return:\n        \"\"\"\n        return self._headers\n\n    @headers.setter\n    def headers(self, attr):\n        \"\"\"\n        Set request headers.\n        :param attr:\n        :return:\n        \"\"\"\n        self._headers = attr\n\n    @property\n    def params(self):\n        \"\"\"\n        Request params. eg. ?page=1&page_size=10&desc=1\n        >>> [(\"page\", 1), (\"page_size\", 10),]\n        :return:\n        \"\"\"\n        return self._params\n\n    @params.setter\n    def params(self, attr):\n        \"\"\"\n        Set params.\n        :param attr:\n        :return:\n        \"\"\"\n        self._params = attr\n\n    @property\n    def data(self):\n        \"\"\"\n        Post request data.\n        >>> {\"username\": \"admin\", \"password\": \"admin\"}\n        :return:\n        \"\"\"\n        return self._data\n\n    @data.setter\n    def data(self, attr):\n        \"\"\"\n        Set post request data.\n        :param attr:\n        :return:\n        \"\"\"\n        self._data = attr\n\n    @property\n    def cookies(self):\n        \"\"\"\n        Request cookies.\n        >>> {\"UUID\": \"xxxxxxx\"}\n        :return:\n        \"\"\"\n        return self._cookies\n\n    @cookies.setter\n    def cookies(self, attr):\n        \"\"\"\n        Set request cookies.\n        :param attr:\n        :return:\n        \"\"\"\n        self._cookies = attr\n\n    @property\n    def files(self):\n        \"\"\"\n        Request files.\n        :return:\n        \"\"\"\n        return self._files\n\n    @files.setter\n    def files(self, attr):\n        \"\"\"\n        Set files.\n        :param attr:\n        :return:\n        \"\"\"\n        self._files = attr\n\n    @property\n    def auth(self):\n        \"\"\"\n        Request Authorization.\n        >>> {\"username\": \"admin\", \"password\": \"admin\"}\n        :return:\n        \"\"\"\n        return self._auth\n\n    @auth.setter\n    def auth(self, attr):\n        \"\"\"\n        Set authorization.\n        :param attr:\n        :return:\n        \"\"\"\n        self._auth = attr\n\n    @property\n    def json(self):\n        \"\"\"\n        Post json.\n        :return:\n        \"\"\"\n        return self._json\n\n    @json.setter\n    def json(self, attr):\n        \"\"\"\n        Set json for post request.\n        :param attr:\n        :return:\n        \"\"\"\n        self._json = attr\n\n    @property\n    def timeout(self):\n        \"\"\"\n        Request timeout.\n        :return:\n        \"\"\"\n        return self._timeout\n\n    @timeout.setter\n    def timeout(self, attr):\n        \"\"\"\n        Set request timeout.\n        :param attr:\n        :return:\n        \"\"\"\n        self._timeout = attr\n\n    @property\n    def proxies(self):\n        \"\"\"\n        Request proxies.\n        >>> {\"http\": \"username:password@host:port\", \"https\": \"username:password@host:port\"}\n        :return:\n        \"\"\"\n        return self._proxies\n\n    @proxies.setter\n    def proxies(self, attr):\n        \"\"\"\n        Set proxies.\n        :param attr:\n        :return:\n        \"\"\"\n        self._proxies = attr\n\n    def is_http(self):\n        \"\"\"\n        Is http request.\n        :return:\n        \"\"\"\n        return self._scheme == \"http\"\n\n    def is_https(self):\n        \"\"\"\n        Is https request.\n        :return:\n        \"\"\"\n        return self._scheme == \"https\"", "class BaseRequest:\n    \"\"\"\n    The basic request.\n    \"\"\"\n\n    def __init__(self):\n        self._method = None\n        self._source = None\n        self._url = None\n        self._scheme = None\n        self._port = None\n        self._headers = None\n        self._params = None\n        self._data = None\n        self._cookies = None\n        self._files = None\n        self._auth = None\n        self._json = None\n        self._timeout = None\n        self._proxies = None\n\n    @property\n    def method(self):\n        \"\"\"\n        Request method\n        >>> \"GET\"\n        :return:\n        \"\"\"\n        return self._method\n\n    @method.setter\n    def method(self, attr):\n        \"\"\"\n        Set request method.\n        :param attr:\n        :return:\n        \"\"\"\n        self._method = attr\n\n    @property\n    def source(self):\n        \"\"\"\n        Source Address.\n        :return:\n        \"\"\"\n        return self._source\n\n    @source.setter\n    def source(self, attr):\n        \"\"\"\n        Set source address.\n        :param attr:\n        :return:\n        \"\"\"\n        self._source = attr\n\n    @property\n    def url(self):\n        \"\"\"\n        Request url.\n        :return:\n        \"\"\"\n        return self._url\n\n    @url.setter\n    def url(self, attr):\n        \"\"\"\n        Set request url.\n        :param attr:\n        :return:\n        \"\"\"\n        self._url = attr\n\n    @property\n    def scheme(self):\n        \"\"\"\n        Request Scheme. eg. HTTP, HTTPS\n        :return:\n        \"\"\"\n        return self._scheme\n\n    @scheme.setter\n    def scheme(self, attr):\n        \"\"\"\n        Set scheme.\n        :param attr:\n        :return:\n        \"\"\"\n        self._scheme = attr\n\n    @property\n    def port(self):\n        \"\"\"\n        Remote address port.\n        :return:\n        \"\"\"\n        return self._port\n\n    @port.setter\n    def port(self, attr):\n        \"\"\"\n        Set port.\n        :param attr:\n        :return:\n        \"\"\"\n        self._port = attr\n\n    @property\n    def headers(self):\n        \"\"\"Headers\n        Request headers.\n        >>> {\"Host\": \"www.example.com\", \"Accept\": \"*/*\"}\n        :return:\n        \"\"\"\n        return self._headers\n\n    @headers.setter\n    def headers(self, attr):\n        \"\"\"\n        Set request headers.\n        :param attr:\n        :return:\n        \"\"\"\n        self._headers = attr\n\n    @property\n    def params(self):\n        \"\"\"\n        Request params. eg. ?page=1&page_size=10&desc=1\n        >>> [(\"page\", 1), (\"page_size\", 10),]\n        :return:\n        \"\"\"\n        return self._params\n\n    @params.setter\n    def params(self, attr):\n        \"\"\"\n        Set params.\n        :param attr:\n        :return:\n        \"\"\"\n        self._params = attr\n\n    @property\n    def data(self):\n        \"\"\"\n        Post request data.\n        >>> {\"username\": \"admin\", \"password\": \"admin\"}\n        :return:\n        \"\"\"\n        return self._data\n\n    @data.setter\n    def data(self, attr):\n        \"\"\"\n        Set post request data.\n        :param attr:\n        :return:\n        \"\"\"\n        self._data = attr\n\n    @property\n    def cookies(self):\n        \"\"\"\n        Request cookies.\n        >>> {\"UUID\": \"xxxxxxx\"}\n        :return:\n        \"\"\"\n        return self._cookies\n\n    @cookies.setter\n    def cookies(self, attr):\n        \"\"\"\n        Set request cookies.\n        :param attr:\n        :return:\n        \"\"\"\n        self._cookies = attr\n\n    @property\n    def files(self):\n        \"\"\"\n        Request files.\n        :return:\n        \"\"\"\n        return self._files\n\n    @files.setter\n    def files(self, attr):\n        \"\"\"\n        Set files.\n        :param attr:\n        :return:\n        \"\"\"\n        self._files = attr\n\n    @property\n    def auth(self):\n        \"\"\"\n        Request Authorization.\n        >>> {\"username\": \"admin\", \"password\": \"admin\"}\n        :return:\n        \"\"\"\n        return self._auth\n\n    @auth.setter\n    def auth(self, attr):\n        \"\"\"\n        Set authorization.\n        :param attr:\n        :return:\n        \"\"\"\n        self._auth = attr\n\n    @property\n    def json(self):\n        \"\"\"\n        Post json.\n        :return:\n        \"\"\"\n        return self._json\n\n    @json.setter\n    def json(self, attr):\n        \"\"\"\n        Set json for post request.\n        :param attr:\n        :return:\n        \"\"\"\n        self._json = attr\n\n    @property\n    def timeout(self):\n        \"\"\"\n        Request timeout.\n        :return:\n        \"\"\"\n        return self._timeout\n\n    @timeout.setter\n    def timeout(self, attr):\n        \"\"\"\n        Set request timeout.\n        :param attr:\n        :return:\n        \"\"\"\n        self._timeout = attr\n\n    @property\n    def proxies(self):\n        \"\"\"\n        Request proxies.\n        >>> {\"http\": \"username:password@host:port\", \"https\": \"username:password@host:port\"}\n        :return:\n        \"\"\"\n        return self._proxies\n\n    @proxies.setter\n    def proxies(self, attr):\n        \"\"\"\n        Set proxies.\n        :param attr:\n        :return:\n        \"\"\"\n        self._proxies = attr\n\n    def is_http(self):\n        \"\"\"\n        Is http request.\n        :return:\n        \"\"\"\n        return self._scheme == \"http\"\n\n    def is_https(self):\n        \"\"\"\n        Is https request.\n        :return:\n        \"\"\"\n        return self._scheme == \"https\"", ""]}
