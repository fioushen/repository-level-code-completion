{"filename": "godot-project/Scripts/DataManagement/InstallerEntryData.cs", "chunked_list": ["using System;\nusing Godot;\nusing Newtonsoft.Json;\n\nnamespace GodotLauncher\n{\n\tpublic class InstallerEntryData\n\t{\n\t\tpublic string version;\n\t\tpublic bool mono;\n\t\tpublic bool preRelease;", "\t\tpublic string version;\n\t\tpublic bool mono;\n\t\tpublic bool preRelease;\n\t\tpublic PlatformData linux;\n\t\tpublic PlatformData mac;\n\t\tpublic PlatformData win;\n\n\t\t[JsonIgnore] public string VersionKey => version + BuildType;\n\t\t[JsonIgnore] public string BuildType => mono ? \"mono\" : \"classic\";\n\n\t\t[JsonIgnore] public PlatformData PlatformData\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tswitch (DataPaths.GetPlatformName())\n\t\t\t\t{\n\t\t\t\t\tcase \"macOS\":\n\t\t\t\t\t\treturn mac;\n\t\t\t\t\tcase \"Linux\":\n\t\t\t\t\t\treturn linux;\n\t\t\t\t\tcase \"Windows\":\n\t\t\t\t\t\treturn win;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Exception(\"OS not defined! \" + OS.GetName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n", "\t\t[JsonIgnore] public string BuildType => mono ? \"mono\" : \"classic\";\n\n\t\t[JsonIgnore] public PlatformData PlatformData\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tswitch (DataPaths.GetPlatformName())\n\t\t\t\t{\n\t\t\t\t\tcase \"macOS\":\n\t\t\t\t\t\treturn mac;\n\t\t\t\t\tcase \"Linux\":\n\t\t\t\t\t\treturn linux;\n\t\t\t\t\tcase \"Windows\":\n\t\t\t\t\t\treturn win;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Exception(\"OS not defined! \" + OS.GetName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n", "\t\t[JsonIgnore] public string Url => PlatformData.url;\n\t\t[JsonIgnore] public string ExecutableName => PlatformData.executableName;\n\t}\n\n\n\tpublic struct PlatformData\n\t{\n\t\tpublic string url;\n\t\tpublic string executableName;\n\t}\n}", "\t\tpublic string executableName;\n\t}\n}"]}
{"filename": "godot-project/Scripts/DataManagement/Config.cs", "chunked_list": ["namespace GodotLauncher\n{\n\tpublic class Config\n\t{\n\t\tpublic bool installedOnlyToggled;\n\t\tpublic bool classicToggled = true;\n\t\tpublic bool monoToggled = true;\n\t\tpublic bool preReleaseToggled;\n\n\t\tpublic bool minimizeOnLaunch = false;\n\t}\n}", "\t\tpublic bool minimizeOnLaunch = false;\n\t}\n}"]}
{"filename": "godot-project/Scripts/DataManagement/Downloader.cs", "chunked_list": ["using System.Net;\nusing System.Text;\nusing Godot;\n\n\nnamespace GodotLauncher\n{\n\tpublic partial class Downloader : Node\n\t{\n\t\tprivate string url;\n\t\tprivate HttpRequest downloader;", "\t\tprivate string url;\n\t\tprivate HttpRequest downloader;\n\t\tprivate HttpClient client;\n\t\tprivate byte[] data;\n\t\tprivate bool done;\n\t\tprivate string error;\n\n\t\tpublic Downloader(string url, Node downloaderParent)\n\t\t{\n\t\t\tthis.url = url;\n\n\t\t\tdownloaderParent.AddChild(this);\n\t\t\tdownloader = new HttpRequest();\n\t\t\tdownloader.UseThreads = true;\n\t\t\tAddChild(downloader);\n\t\t\tdownloader.RequestCompleted += OnRequestCompleted;\n\t\t}\n\n\n\t\tvoid OnRequestCompleted(long result, long responseCode, string[] headers, byte[] body)\n\t\t{", "\t\t\tif (responseCode != (int)HttpClient.ResponseCode.Ok)\n\t\t\t{\n\t\t\t\terror = responseCode.ToString();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdata = body;\n\t\t\tdone = true;\n\t\t}\n\n\n\t\tpublic void Start()\n\t\t{\n\t\t\tvar err = downloader.Request(url);", "\t\tpublic void Start()\n\t\t{\n\t\t\tvar err = downloader.Request(url);\n\t\t\tif (err != Error.Ok)\n\t\t\t{\n\t\t\t\tGD.Print(err.ToString());\n\t\t\t}\n\t\t}\n\n\n\t\tpublic string ReadText()\n\t\t{\n\t\t\treturn Encoding.UTF8.GetString(data);\n\t\t}\n\n\n\t\tpublic byte[] ReadData()\n\t\t{\n\t\t\treturn data;\n\t\t}\n", "\t\tpublic string ReadText()\n\t\t{\n\t\t\treturn Encoding.UTF8.GetString(data);\n\t\t}\n\n\n\t\tpublic byte[] ReadData()\n\t\t{\n\t\t\treturn data;\n\t\t}\n", "\t\tpublic bool IsDone => done;\n\t\tpublic float SizeInMb => downloader.GetDownloadedBytes() / (1024f * 1024f);\n\t\tpublic bool HasError => !string.IsNullOrEmpty(error);\n\t\tpublic string ErrorMessage => error;\n\t}\n}"]}
{"filename": "godot-project/Scripts/DataManagement/DataBuilder.cs", "chunked_list": ["using System.Collections.Generic;\nusing GodotLauncher;\nusing Newtonsoft.Json;\n\n\npublic static class DataBuilder\n{\n\tpublic static Dictionary<string, InstallerEntryData> BuildInstallerData()\n\t{\n\t\tvar json = FileHelper.ReadAllText(\"res://Data/installers.json\");\n\t\tvar entries = LoadInstallerData(json);\n\t\treturn entries;\n\t}\n", "\tpublic static Dictionary<string, InstallerEntryData> LoadInstallerData(string json)\n\t{\n\t\tif (json == null) return new Dictionary<string, InstallerEntryData>();\n\n\t\tvar entries = JsonConvert.DeserializeObject<InstallerEntryData[]>(json);\n\t\tvar entriesDict = new Dictionary<string, InstallerEntryData>();\n\t\tif (entries == null) return entriesDict;\n\n\t\tforeach (var entry in entries)\n\t\t{\n\t\t\tentriesDict[entry.VersionKey] = entry;\n\t\t}\n\n\t\treturn entriesDict;\n\t}\n\n", "\t\tforeach (var entry in entries)\n\t\t{\n\t\t\tentriesDict[entry.VersionKey] = entry;\n\t\t}\n\n\t\treturn entriesDict;\n\t}\n\n\n\tpublic static string GetProjectListJson(List<ProjectEntryData> projects)\n\t{\n\t\treturn JsonConvert.SerializeObject(projects);\n\t}\n\n", "\tpublic static string GetProjectListJson(List<ProjectEntryData> projects)\n\t{\n\t\treturn JsonConvert.SerializeObject(projects);\n\t}\n\n\n\tpublic static List<ProjectEntryData> LoadProjectListFromJson(string json)\n\t{\n\t\treturn JsonConvert.DeserializeObject<List<ProjectEntryData>>(json);\n\t}\n\n", "\tpublic static string GetConfigJson(Config config)\n\t{\n\t\treturn JsonConvert.SerializeObject(config);\n\t}\n\n\n\tpublic static Config LoadConfigFromJson(string json)\n\t{\n\t\treturn JsonConvert.DeserializeObject<Config>(json);\n\t}\n}\n"]}
{"filename": "godot-project/Scripts/DataManagement/ProjectEntryData.cs", "chunked_list": ["namespace GodotLauncher\n{\n\tpublic class ProjectEntryData\n\t{\n\t\tpublic string path;\n\t\tpublic string versionKey;\n\t\tpublic long timestamp;\n\t}\n}"]}
{"filename": "godot-project/Scripts/DataManagement/FileHelper.cs", "chunked_list": ["using System.Collections.Generic;\nusing System.Text;\nusing Godot;\nusing Path = System.IO.Path;\n\npublic static class FileHelper\n{\n\tpublic static string BasePath => \"user://\";\n\tpublic static string CachePath => PathCombine(BasePath, \"Cache\");\n\tpublic const string InternalDataPath = \"res://Data/\";\n\n\n\tstatic FileHelper()\n\t{\n\t\tCreateDirectoryForUser(\"Data\");\n\t\tCreateDirectoryForUser(\"Cache\");\n\t}\n\n", "\tpublic static string CachePath => PathCombine(BasePath, \"Cache\");\n\tpublic const string InternalDataPath = \"res://Data/\";\n\n\n\tstatic FileHelper()\n\t{\n\t\tCreateDirectoryForUser(\"Data\");\n\t\tCreateDirectoryForUser(\"Cache\");\n\t}\n\n", "\tpublic static string PathCombine(params string[] path)\n\t{\n\t\tvar pathList = new List<string>();\n\n\t\tforeach (var element in path)\n\t\t{\n\t\t\tif (!string.IsNullOrEmpty(element))\n\t\t\t\tpathList.Add(element);\n\t\t}\n\n\t\tpath = pathList.ToArray();\n", "\t\tif (path.Length <= 0 || string.IsNullOrEmpty(path[0]))\n\t\t\treturn null;\n\n\t\tStringBuilder result = new StringBuilder(path[0]);\n\t\tbool addNext = path[0][path[0].Length-1] != '/';\n\n\t\tfor (int i = 1; i < path.Length; i++)\n\t\t{\n\t\t\tif (!string.IsNullOrEmpty(path[i]) && path[i][0] != '/')\n\t\t\t{\n\t\t\t\tif (addNext) result.Append(\"/\");\n\t\t\t\tresult.Append(path[i]);\n\n\t\t\t\taddNext = path[i][path[i].Length-1] != '/';\n\t\t\t}\n\t\t}\n\n\t\treturn result.ToString();\n\t}\n\n", "\t\t\tif (!string.IsNullOrEmpty(path[i]) && path[i][0] != '/')\n\t\t\t{\n\t\t\t\tif (addNext) result.Append(\"/\");\n\t\t\t\tresult.Append(path[i]);\n\n\t\t\t\taddNext = path[i][path[i].Length-1] != '/';\n\t\t\t}\n\t\t}\n\n\t\treturn result.ToString();\n\t}\n\n", "\tpublic static string ReadAllText(string path)\n\t{\n\t\tvar file = FileAccess.Open(path, FileAccess.ModeFlags.Read);\n\t\tvar len = file.GetLength();\n\t\tvar data = file.GetBuffer((int)len);\n\t\tvar json = Encoding.UTF8.GetString(data);\n\t\tfile.Close();\n\n\t\treturn json;\n\t}\n\n", "\tpublic static void WriteAllText(string path, string json)\n\t{\n\t\tvar file = FileAccess.Open(path, FileAccess.ModeFlags.Write);\n\t\tfile.StoreString(json);\n\t\tfile.Close();\n\t}\n\n\n\tpublic static bool FileExists(string path)\n\t{\n\t\treturn FileAccess.FileExists(path);\n\t}\n\n", "\tpublic static bool FileExists(string path)\n\t{\n\t\treturn FileAccess.FileExists(path);\n\t}\n\n\n\tpublic static string ReadUserText(string path)\n\t{\n\t\treturn ReadAllText(PathCombine(BasePath, path));\n\t}\n\n", "\tpublic static void WriteUserText(string path, string json)\n\t{\n\t\tWriteAllText(PathCombine(BasePath, path), json);\n\t}\n\n\n\tpublic static bool UserFileExists(string path)\n\t{\n\t\treturn FileExists(PathCombine(BasePath, path));\n\t}\n\n", "\tpublic static void Delete(string path)\n\t{\n\t\tGD.Print(\"*********** Delete file!\");\n\t}\n\n\n\tprivate static void CreateDirectoryForUser(string directory)\n\t{\n\t\tvar path = Path.Combine(BasePath, directory);\n\n\t\tif (!DirAccess.DirExistsAbsolute(path))\n\t\t{\n\t\t\tDirAccess.MakeDirRecursiveAbsolute(path);\n\t\t}\n\t}\n}", "\t\tif (!DirAccess.DirExistsAbsolute(path))\n\t\t{\n\t\t\tDirAccess.MakeDirRecursiveAbsolute(path);\n\t\t}\n\t}\n}"]}
{"filename": "godot-project/Scripts/DataManagement/LauncherManager.cs", "chunked_list": ["//#define PRINT_DEBUG\n\nusing System;\nusing Godot;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Path = System.IO.Path;\nusing File = System.IO.File;\n", "using File = System.IO.File;\n\n\nnamespace GodotLauncher\n{\n\tpublic partial class LauncherManager : Control\n\t{\n\t\t[Export] private bool useLocalData;\n\n\t\tprivate CheckBox installedOnlyToggle;\n\t\tprivate CheckBox classicToggle;", "\t\tprivate CheckBox installedOnlyToggle;\n\t\tprivate CheckBox classicToggle;\n\t\tprivate CheckBox monoToggle;\n\t\tprivate CheckBox preReleaseToggle;\n\n\t\tprivate FileDialog fileDialog;\n\t\tprivate MenuButton newProjectVersion;\n\t\tprivate string newProjectVersionKey;\n\n\t\tprivate Node projectsEntriesNode;\n\t\tprivate Node installersEntriesNode;", "\t\tprivate Node projectsEntriesNode;\n\t\tprivate Node installersEntriesNode;\n\t\tprivate Control infoNode;\n\t\tprivate double infoNodeTimer;\n\t\tprivate bool showExtracting;\n\n\t\tprivate const string ConfigFileName = \"config.json\";\n\t\tprivate const string ProjectsFileName = \"projects.json\";\n\n\t\tprivate Downloader installersDownloader;\n\t\tprivate const string InstallersJson = \"https://raw.githubusercontent.com/NathanWarden/ready-to-launch/master/godot-project/Data/installers.json\";", "\t\tprivate Downloader installersDownloader;\n\t\tprivate const string InstallersJson = \"https://raw.githubusercontent.com/NathanWarden/ready-to-launch/master/godot-project/Data/installers.json\";\n\t\tprivate const string LastInstallerList = \"last-installers.json\";\n\n\t\tprivate List<ProjectEntryData> projectEntries = new ();\n\t\tprivate Dictionary<string, InstallerEntryData> installerEntries = new ();\n\t\tprivate Dictionary<string, InstallerEntryData> previousInstallers = new ();\n\t\tprivate Dictionary<string, Downloader> downloaders = new ();\n\n\t\tprivate Config config;\n\n", "\t\tprivate Config config;\n\n\n\t\tpublic override void _Ready()\n\t\t{\n\t\t\tGetWindow().Title = \"Ready To Launch (Alpha)\";\n\t\t\tGetWindow().FilesDropped += _onFilesDropped;\n\n\t\t\tDataPaths.CreateInstallationDirectory();\n\n\t\t\tvar configJson = DataPaths.ReadFile(ConfigFileName, \"{}\");\n\t\t\tconfig = DataBuilder.LoadConfigFromJson(configJson);\n\n\t\t\tvar projectsJson = DataPaths.ReadFile(ProjectsFileName, \"[]\");\n\t\t\tprojectEntries = DataBuilder.LoadProjectListFromJson(projectsJson);\n\n\t\t\tfileDialog = GetNode<FileDialog>(\"FileDialog\");\n\t\t\tnewProjectVersion = GetNode<MenuButton>(\"ProjectsPanel/AddProjectsContainer/NewProjectVersionMenu\");\n\t\t\tprojectsEntriesNode = GetNode(\"ProjectsPanel/ProjectsList/ProjectEntries\");\n\t\t\tinstallersEntriesNode = GetNode(\"InstallersPanel/InstallersList/InstallerEntries\");\n\t\t\tinfoNode = GetNode<Control>(\"Info\");\n\n\t\t\tSetupToggles();\n", "\t\t\tif (OS.IsDebugBuild() && useLocalData)\n\t\t\t{\n\t\t\t\tinstallerEntries = DataBuilder.BuildInstallerData();\n\t\t\t\tBuildLists(false);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar json = DataPaths.ReadFile(LastInstallerList);\n\t\t\t\tinstallerEntries = DataBuilder.LoadInstallerData(json);\n\t\t\t\tBuildLists(false);\n\n\t\t\t\tinstallersDownloader = new Downloader(InstallersJson, this);\n\t\t\t\tinstallersDownloader.Start();\n\t\t\t}\n\t\t}\n", "\t\tpublic override void _Process(double delta)\n\t\t{\n\t\t\tif (CheckForQuit()) return;\n\n\t\t\tif (infoNodeTimer > 0)\n\t\t\t{\n\t\t\t\tinfoNodeTimer -= delta;\n\t\t\t\tif (infoNodeTimer <= 0)\n\t\t\t\t\tinfoNode.Visible = false;\n\t\t\t}\n", "\t\t\tif (installersDownloader != null && installersDownloader.IsDone)\n\t\t\t{\n\t\t\t\t// If the downloader failed, use the last downloaded json data\n\t\t\t\tvar previousJson = DataPaths.ReadFile(LastInstallerList);\n\t\t\t\tif (string.IsNullOrEmpty(previousJson))\n\t\t\t\t{\n\t\t\t\t\t// If that doesn't exist, use the builtin one\n\t\t\t\t\tpreviousJson = FileHelper.ReadAllText(\"res://Data/installers.json\");\n\t\t\t\t}\n\n\t\t\t\tvar json = installersDownloader.HasError ? previousJson : installersDownloader.ReadText();\n\t\t\t\tDataPaths.WriteFile(LastInstallerList, json);\n\n\t\t\t\tinstallerEntries = DataBuilder.LoadInstallerData(json);\n\t\t\t\tpreviousInstallers = DataBuilder.LoadInstallerData(previousJson);\n\n\t\t\t\tBuildLists(true);\n\n\t\t\t\tinstallersDownloader = null;\n\t\t\t}\n", "\t\t\tforeach (var dlPair in downloaders)\n\t\t\t{\n\t\t\t\tvar key = dlPair.Key;\n\t\t\t\tvar downloader = dlPair.Value;\n\t\t\t\tvar entry = installerEntries[key];\n\n\t\t\t\tif (downloader == null) continue;\n\t\t\t\tif (!downloader.IsDone)\n\t\t\t\t{\n\t\t\t\t\tinfoNode.Call(\"show_message\", \"Downloading Godot \" + entry.version + $\" ({entry.BuildType}) ...\\n\"\n\t\t\t\t\t\t\t\t\t\t\t\t+ downloader.SizeInMb.ToString(\"F2\") + \" MB\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n", "\t\t\t\tif (!showExtracting)\n\t\t\t\t{\n\t\t\t\t\tinfoNode.Call(\"show_message\", \"Extracting...\\n\\nThis may take a few minutes.\");\n\t\t\t\t\tshowExtracting = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar data = downloader.ReadData();\n\t\t\t\tif (data != null)\n\t\t\t\t{\n\t\t\t\t\tstring fileName = $\"{key}.zip\";\n\t\t\t\t\tDataPaths.WriteFile(fileName, data);\n\t\t\t\t\tDataPaths.ExtractArchive(fileName, entry);\n", "\t\t\t\tif (data != null)\n\t\t\t\t{\n\t\t\t\t\tstring fileName = $\"{key}.zip\";\n\t\t\t\t\tDataPaths.WriteFile(fileName, data);\n\t\t\t\t\tDataPaths.ExtractArchive(fileName, entry);\n\n\t\t\t\t\tif (!GetNode<Control>(\"InstallersPanel\").Visible)\n\t\t\t\t\t{\n\t\t\t\t\t\tBuildInstallersList(false);\n\t\t\t\t\t}\n\n\t\t\t\t\tbool installerExists = DataPaths.ExecutableExists(entry);\n\t\t\t\t\tinstallersEntriesNode.Call(\"_update_installer_button\", entry.version, entry.BuildType, installerExists);\n\n\t\t\t\t\tdownloaders.Remove(key);\n\t\t\t\t\tinfoNode.Visible = false;\n\t\t\t\t\tshowExtracting = false;\n\n\t\t\t\t\tBuildProjectsList();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n", "\t\t\t\tif (downloader.HasError)\n\t\t\t\t{\n\t\t\t\t\tGD.Print(downloader.ErrorMessage);\n\t\t\t\t\tinfoNode.Call(\"show_message\", downloader.ErrorMessage);\n\t\t\t\t\tdownloaders.Remove(key);\n\t\t\t\t\tinfoNodeTimer = 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tGD.Print(\"Data was null!\");\n\t\t\t}\n\t\t}\n", "\t\tprivate bool CheckForQuit()\n\t\t{\n\t\t\tif (Input.IsActionPressed(\"Control\") && Input.IsActionJustPressed(\"Quit\"))\n\t\t\t{\n\t\t\t\tGetTree().Quit();\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n", "\t\tprivate void SetupToggles()\n\t\t{\n\t\t\tvar rootNode = GetNode(\"InstallersPanel/HBoxContainer\");\n\t\t\tinstalledOnlyToggle = rootNode.GetNode<CheckBox>(\"InstalledOnlyToggle\");\n\t\t\tclassicToggle = rootNode.GetNode<CheckBox>(\"ClassicToggle\");\n\t\t\tmonoToggle = rootNode.GetNode<CheckBox>(\"MonoToggle\");\n\t\t\tpreReleaseToggle = rootNode.GetNode<CheckBox>(\"PreReleaseToggle\");\n\n\t\t\tinstalledOnlyToggle.ButtonPressed = config.installedOnlyToggled;\n\t\t\tclassicToggle.ButtonPressed = config.classicToggled;\n\t\t\tmonoToggle.ButtonPressed = config.monoToggled;\n\t\t\tpreReleaseToggle.ButtonPressed = config.preReleaseToggled;\n\t\t}\n\n\n\t\tvoid BuildProjectsList()\n\t\t{\n\t\t\tvar installers = GetInstalledVersions();\n\t\t\tvar installerKeysList = new List<string>();\n\t\t\tvar installerNamesList = new List<string>();\n", "\t\t\tforeach (var installer in installers)\n\t\t\t{\n\t\t\t\tinstallerKeysList.Add(installer.VersionKey);\n\t\t\t\tinstallerNamesList.Add(installer.version + \" \" + installer.BuildType);\n\t\t\t}\n\n\t\t\tvar installerKeys = installerKeysList.ToArray();\n\t\t\tvar installerNames = installerNamesList.ToArray();\n\n\t\t\tprojectsEntriesNode.Call(\"_clear_project_buttons\");\n\n\t\t\tprojectEntries.Sort((x, y) =>\n\t\t\t{", "\t\t\t\tif (x.timestamp == y.timestamp) return 0;\n\t\t\t\treturn x.timestamp < y.timestamp ? 1 : -1;\n\t\t\t});\n\n\t\t\tnewProjectVersion.Call(\"_setup\", \"\", installerKeys, installerNames);\n\n\t\t\tforeach (var entry in projectEntries)\n\t\t\t{\n\t\t\t\tstring version = \"\";\n\t\t\t\tstring buildType = \"\";\n", "\t\t\t\tif (installerEntries.TryGetValue(entry.versionKey, out var installer))\n\t\t\t\t{\n\t\t\t\t\tversion = installer.version;\n\t\t\t\t\tbuildType = installer.BuildType;\n\t\t\t\t}\n\n\t\t\t\tprojectsEntriesNode.Call(\"_add_project_button\", entry.path, version, buildType, false, installerKeys, installerNames);\n\t\t\t}\n\t\t}\n\n\n\t\tList<InstallerEntryData> GetInstalledVersions()\n\t\t{\n\t\t\tvar results = new List<InstallerEntryData>();", "\t\t\tforeach (var entry in installerEntries.Values)\n\t\t\t{\n\t\t\t\tbool installerExists = DataPaths.ExecutableExists(entry);\n\t\t\t\tif (installerExists) results.Add(entry);\n\t\t\t}\n\n\t\t\treturn results;\n\t\t}\n\n\n\t\tvoid BuildLists(bool showNewInstallers)\n\t\t{\n\t\t\tBuildInstallersList(showNewInstallers);\n\t\t\tBuildProjectsList();\n\t\t}\n\n\t\tvoid BuildInstallersList(bool showNewInstallers)\n\t\t{\n\t\t\tinstallersEntriesNode.Call(\"_clear_installer_buttons\");\n", "\t\t\tif (showNewInstallers)\n\t\t\t{\n\t\t\t\tforeach (var entry in installerEntries)\n\t\t\t\t{\n\t\t\t\t\tif (!previousInstallers.ContainsKey(entry.Key))\n\t\t\t\t\t{\n\t\t\t\t\t\tprojectsEntriesNode.Call(\"_new_installer_available\", entry.Value.version,\n\t\t\t\t\t\t\tentry.Value.BuildType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n", "\t\t\tforeach (var entry in GetFilteredEntries())\n\t\t\t{\n\t\t\t\tbool installerExists = DataPaths.ExecutableExists(entry);\n\t\t\t\tvar path = DataPaths.GetExecutablePath(entry);\n\t\t\t\tinstallersEntriesNode.Call(\"_add_installer_button\", entry.version, entry.BuildType, path, installerExists);\n\t\t\t}\n\t\t}\n\n\n\t\tIEnumerable<InstallerEntryData> GetFilteredEntries()\n\t\t{", "\t\t\tforeach (var entry in installerEntries.Values)\n\t\t\t{\n\t\t\t\tif (config.installedOnlyToggled && !DataPaths.ExecutableExists(entry)) continue;\n\t\t\t\tif (!config.preReleaseToggled && entry.preRelease) continue;\n\t\t\t\tif (!config.monoToggled && entry.mono) continue;\n\t\t\t\tif (!config.classicToggled && !entry.mono) continue;\n\t\t\t\tyield return entry;\n\t\t\t}\n\t\t}\n\n\n\t\tvoid _onNewProjectPressed()\n\t\t{\n\t\t\tfileDialog.Visible = true;\n\t\t}\n\n\n\t\tvoid _onNewProjectVersionChanged(string versionKey)\n\t\t{\n\t\t\tnewProjectVersionKey = versionKey;\n\t\t}\n\n\n\t\tvoid _onFileDialogDirSelected(string directoryPath)\n\t\t{", "\t\t\tif (string.IsNullOrEmpty(newProjectVersionKey))\n\t\t\t{\n\t\t\t\tvar installers = GetInstalledVersions();\n\t\t\t\tif (installers.Count == 0)\n\t\t\t\t{\n\t\t\t\t\tGD.Print(\"No version selected!!!\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tnewProjectVersionKey = installers[0].VersionKey;\n\t\t\t}\n\n\t\t\tDataPaths.EnsureProjectExists(directoryPath);\n\t\t\tvar project = new ProjectEntryData\n\t\t\t{\n\t\t\t\tpath = directoryPath,\n\t\t\t\tversionKey = newProjectVersionKey,\n\t\t\t\ttimestamp = DateTime.UtcNow.Ticks\n\t\t\t};\n\t\t\tprojectEntries.Add(project);\n\t\t\tLaunchProject(directoryPath, false);\n\t\t}\n\n\n\t\tvoid _onFilesDropped(string[] files)\n\t\t{", "\t\t\tfor (int i = 0; i < files.Length; i++)\n\t\t\t{\n\t\t\t\tstring path = DataPaths.SanitizeProjectPath(files[i]);\n\n\t\t\t\t// Check for duplicates\n\t\t\t\tif (projectEntries.Any(t => t.path.Equals(path)))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tvar versionKey = File.ReadAllText(GodotVersionPath(path));\n\t\t\t\tprojectEntries.Add(new ProjectEntryData\n\t\t\t\t{\n\t\t\t\t\tpath = path,\n\t\t\t\t\tversionKey = versionKey,\n\t\t\t\t\ttimestamp = 0\n\t\t\t\t});\n\n\t\t\t\tInstallVersion(versionKey);\n\t\t\t}\n\n\t\t\tSaveProjectsList();\n\t\t\tBuildProjectsList();\n\t\t}\n\n\n\t\tvoid SaveConfig()\n\t\t{\n\t\t\tvar json = DataBuilder.GetConfigJson(config);\n\t\t\tDataPaths.WriteFile(ConfigFileName, json);\n\t\t}\n\n\n\t\tvoid SaveProjectsList()\n\t\t{\n\t\t\tvar json = DataBuilder.GetProjectListJson(projectEntries);\n\t\t\tDataPaths.WriteFile(ProjectsFileName, json);\n\t\t}\n\n\n\t\tstring GodotVersionPath(string basePath) => Path.Combine(basePath, \"godotversion.txt\");\n\n\n\t\tvoid _onProjectEntryPressed(string path)\n\t\t{\n\t\t\tLaunchProject(path, false);\n\t\t}\n\n\n\t\tvoid _onRunProject(string path)\n\t\t{\n\t\t\tLaunchProject(path, true);\n\t\t}\n\n\n\t\tvoid LaunchProject(string path, bool run)\n\t\t{", "\t\t\tfor (int i = 0; i < projectEntries.Count; i++)\n\t\t\t{\n\t\t\t\tif (projectEntries[i].path.Equals(path) && installerEntries.TryGetValue(projectEntries[i].versionKey, out var entry))\n\t\t\t\t{\n\t\t\t\t\tvar project = projectEntries[i];\n\n\t\t\t\t\t#if PRINT_DEBUG\n\t\t\t\t\tGD.Print(\"Launch \" + path);\n\t\t\t\t\t#endif\n\n\t\t\t\t\tif (!run)\n\t\t\t\t\t{\n\t\t\t\t\t\tFile.WriteAllText(GodotVersionPath(path), project.versionKey);\n\t\t\t\t\t}\n\n\t\t\t\t\tproject.timestamp = DateTime.UtcNow.Ticks;\n\t\t\t\t\tSaveProjectsList();\n\t\t\t\t\tBuildProjectsList();\n", "\t\t\t\t\tif (!run)\n\t\t\t\t\t{\n\t\t\t\t\t\tFile.WriteAllText(GodotVersionPath(path), project.versionKey);\n\t\t\t\t\t}\n\n\t\t\t\t\tproject.timestamp = DateTime.UtcNow.Ticks;\n\t\t\t\t\tSaveProjectsList();\n\t\t\t\t\tBuildProjectsList();\n\n\t\t\t\t\tif (entry.version.StartsWith(\"1.\") || entry.version.StartsWith(\"2.\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tLaunchInstaller(entry);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar additionalFlags = run ? \"\" : \"-e\";\n\t\t\t\t\tDataPaths.LaunchGodot(entry, additionalFlags + \" --path \\\"\" + path + \"\\\"\");\n\t\t\t\t\t//OS.WindowMinimized = config.minimizeOnLaunch;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tvoid _onProjectVersionChanged(string path, string versionKey)\n\t\t{", "\t\t\t\t\tif (entry.version.StartsWith(\"1.\") || entry.version.StartsWith(\"2.\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tLaunchInstaller(entry);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar additionalFlags = run ? \"\" : \"-e\";\n\t\t\t\t\tDataPaths.LaunchGodot(entry, additionalFlags + \" --path \\\"\" + path + \"\\\"\");\n\t\t\t\t\t//OS.WindowMinimized = config.minimizeOnLaunch;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tvoid _onProjectVersionChanged(string path, string versionKey)\n\t\t{", "\t\t\tforeach (var entry in projectEntries)\n\t\t\t{\n\t\t\t\tif (entry.path.Equals(path))\n\t\t\t\t{\n\t\t\t\t\tentry.versionKey = versionKey;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSaveProjectsList();\n\t\t}\n\n\n\t\tvoid _onShowInFolder(string path)\n\t\t{\n\t\t\tvar fileInfo = new FileInfo(path);", "\t\t\tif (fileInfo.Exists)\n\t\t\t{\n\t\t\t\tpath = fileInfo.DirectoryName;\n\t\t\t}\n\t\t\tDataPaths.ShowInFolder(path);\n\t\t}\n\n\n\t\tvoid _onProjectDeletePressed(string path)\n\t\t{\n\t\t\tfor (int i = 0; i < projectEntries.Count; i++)\n\t\t\t{", "\t\t\tfor (int i = 0; i < projectEntries.Count; i++)\n\t\t\t{\n\t\t\t\tif (!projectEntries[i].path.Equals(path)) continue;\n\t\t\t\tprojectEntries.RemoveAt(i);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSaveProjectsList();\n\t\t\tBuildProjectsList();\n\t\t}\n\n\t\tvoid _onInstallerEntryPressed(string version, string buildType)\n\t\t{\n\t\t\tInstallVersion(version + buildType);\n\t\t}\n\n\t\tvoid InstallVersion(string key)\n\t\t{\n\t\t\tvar installerEntry = installerEntries[key];\n", "\t\t\tif (LaunchInstaller(installerEntry) || downloaders.ContainsKey(key)) return;\n\t\t\tvar entry = installerEntries[key];\n\t\t\tdownloaders[key] = new Downloader(entry.Url, this);\n\t\t\tdownloaders[key].Start();\n\t\t\tinfoNode.Call(\"show_message\", \"Downloading Godot \" + installerEntry.version + $\" ({installerEntry.BuildType}) ...\");\n\t\t}\n\n\n\t\tbool LaunchInstaller(InstallerEntryData installerEntry)\n\t\t{\n\t\t\tbool installerExists = DataPaths.ExecutableExists(installerEntry);", "\t\t\tif (installerExists)\n\t\t\t{\n\t\t\t\tDataPaths.LaunchGodot(installerEntry);\n\t\t\t\t//OS.WindowMinimized = config.minimizeOnLaunch;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\n\t\tvoid _onInstallerDeletePressed(string version, string buildType)\n\t\t{\n\t\t\tDataPaths.DeleteVersion(version, buildType);\n\t\t\tBuildLists(false);\n\t\t}\n\n\n\t\tvoid _onInstalledOnlyToggled(bool state)\n\t\t{\n\t\t\tconfig.installedOnlyToggled = state;\n\t\t\tBuildInstallersList(false);\n\t\t\tSaveConfig();\n\t\t}\n\n\n\t\tvoid _onClassicToggled(bool state)\n\t\t{\n\t\t\tconfig.classicToggled = state;\n\t\t\tBuildInstallersList(false);\n\t\t\tSaveConfig();\n\t\t}\n\n\n\t\tvoid _onMonoToggled(bool state)\n\t\t{\n\t\t\tconfig.monoToggled = state;\n\t\t\tBuildInstallersList(false);\n\t\t\tSaveConfig();\n\t\t}\n\n\n\t\tvoid _onPreReleaseToggled(bool state)\n\t\t{\n\t\t\tconfig.preReleaseToggled = state;\n\t\t\tBuildInstallersList(false);\n\t\t\tSaveConfig();\n\t\t}\n\n\n\t\tvoid _onDebugOsSelected(string os)\n\t\t{\n\t\t\tDataPaths.platformOverride = os;\n\t\t\tBuildInstallersList(false);\n\t\t}\n\n\t\tvoid _onDownloadAllPressed()\n\t\t{", "\t\t\tforeach (var entry in installerEntries.Values)\n\t\t\t{\n\t\t\t\tif (DataPaths.ExecutableExists(entry) || string.IsNullOrEmpty(entry.Url)) continue;\n\t\t\t\tvar key = entry.VersionKey;\n\t\t\t\tdownloaders[key] = new Downloader(entry.Url, this);\n\t\t\t\tdownloaders[key].Start();\n\t\t\t}\n\t\t}\n\t}\n}\n"]}
{"filename": "godot-project/Scripts/DataManagement/DataPaths.cs", "chunked_list": ["//#define PRINT_DEBUG\n\nusing System;\nusing System.IO;\nusing Godot;\nusing Mono.Unix;\nusing Directory = System.IO.Directory;\nusing Environment = System.Environment;\nusing File = System.IO.File;\nusing Path = System.IO.Path;", "using File = System.IO.File;\nusing Path = System.IO.Path;\n\nnamespace GodotLauncher\n{\n\tpublic class DataPaths\n\t{\n\t\tstatic string AppDataPath => Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);\n\t\tstatic string BasePath => Path.Combine(AppDataPath, \"ReadyToLaunch\");\n\t\tpublic static string platformOverride;\n\n", "\t\tpublic static string platformOverride;\n\n\n\t\tpublic static string SanitizeProjectPath(string path)\n\t\t{\n\t\t\tif (File.Exists(path))\n\t\t\t{\n\t\t\t\tpath = new FileInfo(path).DirectoryName;\n\t\t\t}\n\n\t\t\treturn path;\n\t\t}\n\n", "\t\tpublic static void EnsureProjectExists(string path)\n\t\t{\n\t\t\tvar filePath = Path.Combine(path, \"project.godot\");\n\t\t\tif (!File.Exists(filePath)) File.WriteAllText(filePath, \"\");\n\t\t}\n\n\n\t\tpublic static string GetExecutablePath(InstallerEntryData installerEntryData)\n\t\t{\n\t\t\tstring platformName = GetPlatformName();\n\t\t\tstring path = Path.Combine(BasePath, platformName, installerEntryData.BuildType, installerEntryData.version);\n\n\t\t\tpath = Path.Combine(path, installerEntryData.ExecutableName);\n\n\t\t\treturn path;\n\t\t}\n\n", "\t\tpublic static string GetPlatformName()\n\t\t{\n\t\t\tif (!string.IsNullOrEmpty(platformOverride)) return platformOverride;\n\t\t\treturn OS.GetName();\n\t\t}\n\n\n\t\tpublic static void WriteFile(string fileName, byte[] data)\n\t\t{\n\t\t\tvar path = Path.Combine(BasePath, fileName);\n\t\t\t#if PRINT_DEBUG\n\t\t\tGD.Print(\"Writing: \" + path);\n\t\t\t#endif\n\t\t\tFile.WriteAllBytes(path, data);\n\t\t}\n\n", "\t\tpublic static void WriteFile(string fileName, string data)\n\t\t{\n\t\t\tvar path = Path.Combine(BasePath, fileName);\n\t\t\t#if PRINT_DEBUG\n\t\t\tGD.Print(\"Writing: \" + path);\n\t\t\t#endif\n\t\t\tFile.WriteAllText(path, data);\n\t\t}\n\n\n\t\tpublic static string ReadFile(string fileName, string defaultData = null)\n\t\t{\n\t\t\tvar path = Path.Combine(BasePath, fileName);", "\t\tpublic static string ReadFile(string fileName, string defaultData = null)\n\t\t{\n\t\t\tvar path = Path.Combine(BasePath, fileName);\n\t\t\tif (File.Exists(path))\n\t\t\t{\n\t\t\t\t#if PRINT_DEBUG\n\t\t\t\tGD.Print(\"Reading: \" + path);\n\t\t\t\t#endif\n\t\t\t\treturn File.ReadAllText(path);\n\t\t\t}\n\n\t\t\t#if PRINT_DEBUG\n\t\t\tGD.Print(\"File not found: \" + path);\n\t\t\t#endif\n\t\t\treturn defaultData;\n\t\t}\n\n", "\t\tpublic static bool ExecutableExists(InstallerEntryData installerEntryData)\n\t\t{\n\t\t\tstring path = GetExecutablePath(installerEntryData);\n\t\t\tbool exists = File.Exists(path);\n\t\t\t#if PRINT_DEBUG\n\t\t\tGD.Print(\"Checking if path exists: \" + path + \" exists=\" + exists);\n\t\t\t#endif\n\t\t\treturn exists;\n\t\t}\n\n", "\t\tpublic static void ExtractArchive(string fileName, InstallerEntryData installerEntryData)\n\t\t{\n\t\t\tstring source = Path.Combine(BasePath, fileName);\n\t\t\tstring dest = Path.Combine(BasePath, GetPlatformName(), installerEntryData.BuildType, installerEntryData.version);\n\t\t\tif (!Directory.Exists(dest)) System.IO.Compression.ZipFile.ExtractToDirectory(source, dest);\n\t\t\tFile.Delete(source);\n\t\t}\n\n\n\t\tpublic static void DeleteVersion(string version, string buildType)\n\t\t{\n\t\t\tDirectory.Delete(Path.Combine(BasePath, GetPlatformName(), buildType, version), true);\n\t\t}\n\n", "\t\tpublic static void DeleteVersion(string version, string buildType)\n\t\t{\n\t\t\tDirectory.Delete(Path.Combine(BasePath, GetPlatformName(), buildType, version), true);\n\t\t}\n\n\n\t\tpublic static void LaunchGodot(InstallerEntryData installerEntryData, string arguments = \"\")\n\t\t{\n\t\t\tstring path = GetExecutablePath(installerEntryData);\n\t\t\t#if PRINT_DEBUG\n\t\t\tGD.Print(\"Launching: \" + path);\n\t\t\t#endif", "\t\t\tif (!OS.GetName().Equals(\"Windows\"))\n\t\t\t{\n\t\t\t\tvar unixFile = new UnixFileInfo(path);\n\t\t\t\tunixFile.FileAccessPermissions |= FileAccessPermissions.UserExecute\n\t\t\t\t\t\t\t\t\t\t\t\t  | FileAccessPermissions.GroupExecute\n\t\t\t\t\t\t\t\t\t\t\t\t  | FileAccessPermissions.OtherExecute;\n\t\t\t}\n\n\t\t\tusing var process = new System.Diagnostics.Process();\n\t\t\tprocess.StartInfo.FileName = path;\n\t\t\tprocess.StartInfo.WorkingDirectory = BasePath;\n\t\t\tprocess.StartInfo.Arguments = arguments;\n\t\t\tprocess.Start();\n\t\t}\n\n", "\t\tpublic static void CreateInstallationDirectory()\n\t\t{\n\t\t\tMoveOldInstallationDirectory(\"ReadyForLaunch\");\n\t\t\tMoveOldInstallationDirectory(\"GodotLauncher\");\n\t\t\tDirectory.CreateDirectory(BasePath);\n\t\t}\n\n\n\t\tstatic void MoveOldInstallationDirectory(string oldName)\n\t\t{\n\t\t\tvar oldPath = Path.Combine(AppDataPath, oldName);", "\t\t\tif (!Directory.Exists(oldPath) || Directory.Exists(BasePath))\n\t\t\t\treturn;\n\t\t\tDirectory.Move(oldPath, BasePath);\n\t\t}\n\n\n\t\tpublic static void ShowInFolder(string filePath)\n\t\t{\n\t\t\tfilePath = \"\\\"\" + filePath + \"\\\"\";\n\t\t\tswitch (OS.GetName())\n\t\t\t{\n\t\t\t\tcase \"Linux\":\n\t\t\t\t\tSystem.Diagnostics.Process.Start(\"xdg-open\", filePath);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"Windows\":\n\t\t\t\t\tstring argument = \"/select, \" + filePath;\n\t\t\t\t\tSystem.Diagnostics.Process.Start(\"explorer.exe\", argument);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"macOS\":\n\t\t\t\t\tSystem.Diagnostics.Process.Start(\"open\", filePath);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Exception(\"OS not defined! \" + OS.GetName());\n\t\t\t}\n\t\t}\n\t}\n}\n"]}
{"filename": "godot-project/addons/PostBuild/PostBuild.cs", "chunked_list": ["#if TOOLS\nusing System.IO;\nusing Godot;\nusing Path = System.IO.Path;\n\n\n[Tool]\npublic partial class PostBuild : EditorExportPlugin\n{\n\tprivate string[] features;\n\tprivate bool isDebug;", "\tprivate bool isDebug;\n\tprivate string path;\n\n\n\tpublic override void _ExportBegin(string[] features, bool isDebug, string path, uint flags)\n\t{\n\t\tthis.features = features;\n\t\tthis.isDebug = isDebug;\n\t\tthis.path = path;\n\t}\n\n", "\tpublic override void _ExportEnd()\n\t{\n\t\tforeach (var feat in features)\n\t\t{\n\t\t\tif (feat.Equals(\"OSX\"))\n\t\t\t{\n\t\t\t\t//PostMacBuild();\n\t\t\t}\n\t\t}\n\t}\n\n", "\tprivate void PostMacBuild()\n\t{\n\t\tvar fileInfo = new FileInfo(path);\n\t\tvar buildDirectory = fileInfo.Directory;\n\t\tSystem.IO.Compression.ZipFile.ExtractToDirectory(fileInfo.FullName, buildDirectory.FullName);\n\t}\n}\n#endif\n"]}
{"filename": "godot-project/addons/PostBuild/BuildData.cs", "chunked_list": ["using System;\nusing Newtonsoft.Json;\n\n[Serializable]\npublic class BuildData\n{\n\tpublic const string BuildDataPath = \"res://Data/BuildData.json\";\n\n\tpublic int buildNumber;\n\tpublic string version;\n\tpublic string storeFlag;\n\n", "\tpublic int buildNumber;\n\tpublic string version;\n\tpublic string storeFlag;\n\n\n\tpublic static BuildData Load()\n\t{\n\t\tvar json = FileHelper.ReadAllText(BuildDataPath);\n\t\tif (string.IsNullOrEmpty(json)) return new BuildData();\n\t\treturn JsonConvert.DeserializeObject<BuildData>(json);\n\t}\n\n", "\t\tif (string.IsNullOrEmpty(json)) return new BuildData();\n\t\treturn JsonConvert.DeserializeObject<BuildData>(json);\n\t}\n\n\n\tpublic void Save()\n\t{\n\t\tFileHelper.WriteAllText(BuildDataPath, JsonConvert.SerializeObject(this, Formatting.Indented));\n\t}\n}\n"]}
{"filename": "godot-project/addons/PostBuild/PreBuildProcess.cs", "chunked_list": ["using Godot;\n\npublic partial class PreBuildProcess : SceneTree\n{\n\tconst string ConfigPath = \"res://export_presets.cfg\";\n\tconst string AndroidConfigSection = \"preset.4.options\";\n\n\n\tpublic override void _Initialize()\n\t{\n\t\tvar args = OS.GetCmdlineArgs();\n", "\tpublic override void _Initialize()\n\t{\n\t\tvar args = OS.GetCmdlineArgs();\n\n\t\tfor (int i = 0; i < args.Length; i++)\n\t\t{\n\t\t\tif (args[i].Equals(\"--increment\"))\n\t\t\t{\n\t\t\t\tUpdateBuildNumber();\n\t\t\t}\n", "\t\t\tif (args[i].Equals(\"--store-flag\"))\n\t\t\t{\n\t\t\t\tvar store = args[i + 1];\n\t\t\t\tvar buildData = BuildData.Load();\n\t\t\t\tbuildData.storeFlag = store;\n\t\t\t\tbuildData.Save();\n\t\t\t}\n\t\t}\n\n\t\tQuit();\n\t}\n\n", "\tprivate void UpdateBuildNumber()\n\t{\n\t\tvar buildData = BuildData.Load();\n\t\tbuildData.buildNumber++;\n\t\tbuildData.Save();\n\n\t\tvar cfg = new ConfigFile();\n\t\tcfg.Load(ConfigPath);\n\t\tcfg.SetValue(AndroidConfigSection, \"version/code\", buildData.buildNumber);\n\t\tcfg.Save(ConfigPath);\n\t\tGD.Print(\"Build with code: \" + buildData.buildNumber);\n\t}\n}\n"]}
{"filename": "godot-project/addons/PostBuild/PostBuildSetup.cs", "chunked_list": ["#if TOOLS\nusing Godot;\n\n[Tool]\npublic partial class PostBuildSetup : EditorPlugin\n{\n\tprivate PostBuild buildPlugin;\n\n\n\tpublic override void _EnterTree()\n\t{\n\t\tbuildPlugin = new PostBuild();\n\t\tAddExportPlugin(buildPlugin);\n\t}\n\n", "\tpublic override void _EnterTree()\n\t{\n\t\tbuildPlugin = new PostBuild();\n\t\tAddExportPlugin(buildPlugin);\n\t}\n\n\n\tpublic override void _ExitTree()\n\t{\n\t\tRemoveExportPlugin(buildPlugin);\n\t}\n}\n#endif\n"]}
