{"filename": "Startup.cs", "chunked_list": ["using GraphNotifications.Services;\nusing Microsoft.Azure.Functions.Extensions.DependencyInjection;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Configuration;\nusing GraphNotifications.Models;\nusing Microsoft.Extensions.Logging;\n\n[assembly: FunctionsStartup(typeof(GraphNotifications.Startup))]\n\nnamespace GraphNotifications", "\nnamespace GraphNotifications\n{\n    public class Startup : FunctionsStartup\n    {\n        public override void Configure(IFunctionsHostBuilder builder)\n        {\n            // set min threads to reduce chance for Redis timeoutes\n            // https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-troubleshoot-client#traffic-burst\n            ThreadPool.SetMinThreads(200, 200);\n            \n            builder.Services.AddOptions<AppSettings>()\n                .Configure<IConfiguration>((settings, configuration) =>\n                {\n                    configuration.GetSection(\"AppSettings\").Bind(settings);\n                });\n\n            builder.Services.AddApplicationInsightsTelemetry();\n\n            builder.Services.AddSingleton<ITokenValidationService, TokenValidationService>();\n            builder.Services.AddSingleton<IGraphClientService, GraphClientService>();\n            builder.Services.AddSingleton<IGraphNotificationService, GraphNotificationService>();\n\n            builder.Services.AddSingleton<ICertificateService, CertificateService>();\n\n            builder.Services.AddSingleton<IRedisFactory, RedisFactory>();\n            builder.Services.AddSingleton<ICacheService>(x =>\n                new CacheService(\n                    x.GetRequiredService<IRedisFactory>(),\n                    x.GetRequiredService<ILogger<CacheService>>()));\n        }\n    }\n}"]}
{"filename": "Functions/TestClient.cs", "chunked_list": ["using System;\nusing System.IO;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Azure.WebJobs;\nusing Microsoft.Azure.WebJobs.Extensions.Http;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing Newtonsoft.Json;\nusing System.Net;", "using Newtonsoft.Json;\nusing System.Net;\nusing System.Net.Http.Headers;\nusing ExecutionContext = Microsoft.Azure.WebJobs.ExecutionContext;\n\nnamespace GraphNotifications.Functions\n{\n    public static class Client\n    {\n        [FunctionName(\"TestClient\")]\n        public static HttpResponseMessage Run(\n            [HttpTrigger(AuthorizationLevel.Anonymous, \"get\", Route = \"/\")] HttpRequest req,\n            ILogger log, ExecutionContext context)\n        {\n            log.LogInformation(\"C# HTTP trigger function processed a request.\");\n\n            string fullFilePath = context.FunctionAppDirectory + \"/TestClient/index.html\";\n\n            log.LogInformation(fullFilePath);\n            var response = new HttpResponseMessage(HttpStatusCode.OK);\n            var stream = new FileStream(fullFilePath, FileMode.Open);\n            response.Content = new StreamContent(stream);\n            response.Content.Headers.ContentType = new MediaTypeHeaderValue(\"text/html\");\n            return response;\n        }\n    }\n}\n", "        public static HttpResponseMessage Run(\n            [HttpTrigger(AuthorizationLevel.Anonymous, \"get\", Route = \"/\")] HttpRequest req,\n            ILogger log, ExecutionContext context)\n        {\n            log.LogInformation(\"C# HTTP trigger function processed a request.\");\n\n            string fullFilePath = context.FunctionAppDirectory + \"/TestClient/index.html\";\n\n            log.LogInformation(fullFilePath);\n            var response = new HttpResponseMessage(HttpStatusCode.OK);\n            var stream = new FileStream(fullFilePath, FileMode.Open);\n            response.Content = new StreamContent(stream);\n            response.Content.Headers.ContentType = new MediaTypeHeaderValue(\"text/html\");\n            return response;\n        }\n    }\n}\n"]}
{"filename": "Functions/GraphNotificationsHub.cs", "chunked_list": ["using Microsoft.Extensions.Logging;\nusing GraphNotifications.Services;\nusing Microsoft.Azure.WebJobs.Extensions.SignalRService;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Azure.WebJobs;\nusing Microsoft.Azure.WebJobs.Extensions.Http;\nusing GraphNotifications.Models;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.Graph;\nusing System.Net;", "using Microsoft.Graph;\nusing System.Net;\nusing Microsoft.Extensions.Options;\nusing Azure.Messaging.EventHubs;\nusing System.Text;\nusing Newtonsoft.Json;\n\nnamespace GraphNotifications.Functions\n{\n    public class GraphNotificationsHub : ServerlessHub\n    {", "{\n    public class GraphNotificationsHub : ServerlessHub\n    {\n        private readonly ITokenValidationService _tokenValidationService;\n        private readonly IGraphNotificationService _graphNotificationService;\n        private readonly ICertificateService _certificateService;\n        private readonly ICacheService _cacheService;\n        private readonly ILogger _logger;\n        private readonly AppSettings _settings;\n        private const string MicrosoftGraphChangeTrackingSpId = \"0bf30f3b-4a52-48df-9a82-234910c4a086\";\n\n        public GraphNotificationsHub(\n            ITokenValidationService tokenValidationService,\n            IGraphNotificationService graphNotificationService,\n            ICacheService cacheService,\n            ICertificateService certificateService,\n            ILogger<GraphNotificationsHub> logger,\n            IOptions<AppSettings> options)\n        {\n            _tokenValidationService = tokenValidationService;\n            _graphNotificationService = graphNotificationService;\n            _certificateService = certificateService ?? throw new ArgumentException(nameof(certificateService));\n            _cacheService = cacheService ?? throw new ArgumentException(nameof(cacheService));\n            _logger = logger;\n            _settings = options.Value;\n        }\n\n        [FunctionName(\"negotiate\")]", "        private readonly AppSettings _settings;\n        private const string MicrosoftGraphChangeTrackingSpId = \"0bf30f3b-4a52-48df-9a82-234910c4a086\";\n\n        public GraphNotificationsHub(\n            ITokenValidationService tokenValidationService,\n            IGraphNotificationService graphNotificationService,\n            ICacheService cacheService,\n            ICertificateService certificateService,\n            ILogger<GraphNotificationsHub> logger,\n            IOptions<AppSettings> options)\n        {\n            _tokenValidationService = tokenValidationService;\n            _graphNotificationService = graphNotificationService;\n            _certificateService = certificateService ?? throw new ArgumentException(nameof(certificateService));\n            _cacheService = cacheService ?? throw new ArgumentException(nameof(cacheService));\n            _logger = logger;\n            _settings = options.Value;\n        }\n\n        [FunctionName(\"negotiate\")]", "        public async Task<SignalRConnectionInfo?> Negotiate([HttpTrigger(AuthorizationLevel.Anonymous, \"post\", Route = \"api/negotiate\")] HttpRequest req)\n        {\n            try\n            {\n                // Validate the bearer token\n                var validationTokenResult = await _tokenValidationService.ValidateAuthorizationHeaderAsync(req);\n                if (validationTokenResult == null || string.IsNullOrEmpty(validationTokenResult.UserId))\n                {\n                    // If token wasn't returned it isn't valid\n                    return null;\n                }\n\n                return Negotiate(validationTokenResult.UserId, validationTokenResult.Claims);\n            }", "            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Encountered an error in negotiate\");\n                return null;\n            }\n        }\n\n        [FunctionName(\"CreateSubscription\")]\n        public async Task CreateSubscription([SignalRTrigger]InvocationContext invocationContext, SubscriptionDefinition subscriptionDefinition, string accessToken)\n        {\n            try\n            {\n                // Validate the token\n                var tokenValidationResult = await _tokenValidationService.ValidateTokenAsync(accessToken);", "        public async Task CreateSubscription([SignalRTrigger]InvocationContext invocationContext, SubscriptionDefinition subscriptionDefinition, string accessToken)\n        {\n            try\n            {\n                // Validate the token\n                var tokenValidationResult = await _tokenValidationService.ValidateTokenAsync(accessToken);\n                if (tokenValidationResult == null)\n                {\n                    // This request is Unauthorized\n                    await Clients.Client(invocationContext.ConnectionId).SendAsync(\"Unauthorized\", \"The request is unauthorized to create the subscription\");\n                    return;\n                }\n", "                if (subscriptionDefinition == null)\n                {\n                    _logger.LogError(\"No subscription definition supplied.\");\n                    await Clients.Client(invocationContext.ConnectionId).SendAsync(\"SubscriptionCreationFailed\", subscriptionDefinition);\n                    return;\n                }\n\n                _logger.LogInformation($\"Creating subscription from {invocationContext.ConnectionId} for resource {subscriptionDefinition.Resource}.\");\n\n                // When notification events are received we get the Graph Subscription Id as the identifier\n                // Adding a cache entry with the logicalCacheKey as the Graph Subscription Id, we can\n                // fetch the subscription from the cache\n                \n                // The logicalCacheKey is key we can build when we create a subscription and when we receive a notification\n                var logicalCacheKey = $\"{subscriptionDefinition.Resource}_{tokenValidationResult.UserId}\";\n                _logger.LogInformation($\"logicalCacheKey: {logicalCacheKey}\");\n                var subscriptionId = await _cacheService.GetAsync<string>(logicalCacheKey);\n                _logger.LogInformation($\"subscriptionId: {subscriptionId ?? \"null\"}\");\n\n                SubscriptionRecord? subscription = null;", "                if (!string.IsNullOrEmpty(subscriptionId))\n                {\n                    // Check if subscription on the resource for this user already exist\n                    // If subscription on the resource for this user already exist, add the signalR connection to the SignalR group\n                    subscription = await _cacheService.GetAsync<SubscriptionRecord>(subscriptionId);\n                }\n                \n                if (subscription == null)\n                {\n                    _logger.LogInformation($\"Supscription not found in the cache\");\n                    // if subscription on the resource for this user does not exist create it\n                    subscription = await this.CreateGraphSubscription(tokenValidationResult, subscriptionDefinition);\n                    _logger.LogInformation($\"SubscriptionId: {subscription.SubscriptionId}\");\n                }\n                else\n                {\n                    var subscriptionTimeBeforeExpiring = subscription.ExpirationTime.Subtract(DateTimeOffset.UtcNow);\n                    _logger.LogInformation($\"Supscription found in the cache\");\n                    _logger.LogInformation($\"Supscription ExpirationTime: {subscription.ExpirationTime}\");\n                    _logger.LogInformation($\"subscriptionTimeBeforeExpiring: {subscriptionTimeBeforeExpiring.ToString(@\"hh\\:mm\\:ss\")}\");\n                    _logger.LogInformation($\"Supscription ExpirationTime: {subscriptionTimeBeforeExpiring.TotalSeconds}\");\n                    // If the subscription will expire in less than 5 minutes, renew the subscription ahead of time", "                    if (subscriptionTimeBeforeExpiring.TotalSeconds < (5 * 60))\n                    {\n                        _logger.LogInformation($\"Less than 5 minutes before renewal\");\n                        try\n                        {\n                            // Renew the current subscription\n                            subscription = await this.RenewGraphSubscription(tokenValidationResult.Token, subscription, subscriptionDefinition.ExpirationTime);\n                            _logger.LogInformation($\"SubscriptionId: {subscription.SubscriptionId}\");\n                        }\n                        catch (Exception ex)\n                        {\n                            // There was a subscription in the cache, but we were unable to renew it\n                            _logger.LogError(ex, $\"Encountered an error renewing subscription: {JsonConvert.SerializeObject(subscription)}\");\n\n                            // Let's check if there is an existing subscription\n                            var graphSubscription = await this.GetGraphSubscription(tokenValidationResult.Token, subscription);", "                        catch (Exception ex)\n                        {\n                            // There was a subscription in the cache, but we were unable to renew it\n                            _logger.LogError(ex, $\"Encountered an error renewing subscription: {JsonConvert.SerializeObject(subscription)}\");\n\n                            // Let's check if there is an existing subscription\n                            var graphSubscription = await this.GetGraphSubscription(tokenValidationResult.Token, subscription);\n                            if (graphSubscription == null)\n                            {\n                                _logger.LogInformation($\"Subscription does not exist. Removing cache entries for subscriptionId: {subscription.SubscriptionId}\");\n                                // Remove the logicalCacheKey refering to the graph Subscription Id from cache\n                                await _cacheService.DeleteAsync(logicalCacheKey);\n\n                                // Remove the old Graph Subscription Id\n                                await _cacheService.DeleteAsync(subscription.SubscriptionId);\n\n                                // We should try to create a new subscription for the following reasons:\n                                // A subscription was found in the cache, but the renew subscription failed\n                                // After the renewal failed, we still couldn't find that subscription in Graph \n                                // Create a new subscription\n                                subscription = await this.CreateGraphSubscription(tokenValidationResult, subscriptionDefinition);\n                            } else {\n                                // If the renew failed, but we found a subscription\n                                // return it\n                                subscription = graphSubscription;\n                            }\n                        }\n                    }\n                }\n\n                var expirationTimeSpan = subscription.ExpirationTime.Subtract(DateTimeOffset.UtcNow);\n                _logger.LogInformation($\"expirationTimeSpan: {expirationTimeSpan.ToString(@\"hh\\:mm\\:ss\")}\");\n\n                // Add connection to the Signal Group for this subscription.\n                _logger.LogInformation($\"Adding connection to SignalR Group\");\n                await Groups.AddToGroupAsync(invocationContext.ConnectionId, subscription.SubscriptionId);\n\n                // Add or update the logicalCacheKey with the subscriptionId\n                _logger.LogInformation($\"Add or update the logicalCacheKey: {logicalCacheKey} with the subscriptionId: {subscription.SubscriptionId}.\");\n                await _cacheService.AddAsync<string>(logicalCacheKey, subscription.SubscriptionId, expirationTimeSpan);\n\n                // Add or update the cache with updated subscription\n                _logger.LogInformation($\"Adding subscription to cache\");\n                await _cacheService.AddAsync<SubscriptionRecord>(subscription.SubscriptionId, subscription, expirationTimeSpan);\n\n                await Clients.Client(invocationContext.ConnectionId).SendAsync(\"SubscriptionCreated\", subscription);\n                _logger.LogInformation($\"Subscription was created successfully with connectionId {invocationContext.ConnectionId}\");\n                return;\n            }", "            catch(Exception ex)\n            {\n                 _logger.LogError(ex, \"Encountered an error when creating a subscription\");\n                 await Clients.Client(invocationContext.ConnectionId).SendAsync(\"SubscriptionCreationFailed\", subscriptionDefinition);\n            }\n        }\n\n        [FunctionName(\"EventHubProcessor\")]\n        public async Task Run([EventHubTrigger(\"%AppSettings:EventHubName%\", Connection = \"AppSettings:EventHubListenConnectionString\")] EventData[] events)\n        {\n            foreach (EventData eventData in events)\n            {\n                try\n                {\n                    string messageBody = Encoding.UTF8.GetString(eventData.EventBody.ToArray());\n                    \n                    // Replace these two lines with your processing logic.\n                    _logger.LogWarning($\"C# Event Hub trigger function processed a message: {messageBody}\");\n\n                    // Deserializing to ChangeNotificationCollection throws an error when the validation requests\n                    // are sent. Using a JObject to get around this issue.\n                    var notificationsObj = Newtonsoft.Json.Linq.JObject.Parse(messageBody);\n                    var notifications = notificationsObj[\"value\"];", "        public async Task Run([EventHubTrigger(\"%AppSettings:EventHubName%\", Connection = \"AppSettings:EventHubListenConnectionString\")] EventData[] events)\n        {\n            foreach (EventData eventData in events)\n            {\n                try\n                {\n                    string messageBody = Encoding.UTF8.GetString(eventData.EventBody.ToArray());\n                    \n                    // Replace these two lines with your processing logic.\n                    _logger.LogWarning($\"C# Event Hub trigger function processed a message: {messageBody}\");\n\n                    // Deserializing to ChangeNotificationCollection throws an error when the validation requests\n                    // are sent. Using a JObject to get around this issue.\n                    var notificationsObj = Newtonsoft.Json.Linq.JObject.Parse(messageBody);\n                    var notifications = notificationsObj[\"value\"];", "                    if (notifications == null)\n                    {\n                        _logger.LogWarning($\"No notifications found\");;\n                        return;\n                    }\n\n                    foreach (var notification in notifications)\n                    {\n\n                        var subscriptionId = notification[\"subscriptionId\"]?.ToString();\n                        if (string.IsNullOrEmpty(subscriptionId))\n                        {\n                            _logger.LogWarning($\"Notification subscriptionId is null\");\n                            continue;\n                        }\n\n                        // if this is a validation request, the subscription Id will be NA", "                        if (string.IsNullOrEmpty(subscriptionId))\n                        {\n                            _logger.LogWarning($\"Notification subscriptionId is null\");\n                            continue;\n                        }\n\n                        // if this is a validation request, the subscription Id will be NA\n                        if (subscriptionId.ToLower() == \"na\")\n                            continue;\n\n                        var decryptedContent = String.Empty;", "                        if(notification[\"encryptedContent\"] != null)\n                        {\n                            var encryptedContentJson = notification[\"encryptedContent\"]?.ToString();\n                            var encryptedContent = Newtonsoft.Json.JsonConvert.DeserializeObject<ChangeNotificationEncryptedContent>(encryptedContentJson) ;\n                            decryptedContent = await encryptedContent.DecryptAsync((id, thumbprint) => {\n                                return _certificateService.GetDecryptionCertificate();\n                            });\n                        }\n\n                        // A user can have multiple connections to the same resource / subscription. All need to be notified.\n                        await Clients.Group(subscriptionId).SendAsync(\"NewMessage\", notification, decryptedContent);\n                    }\n                }", "                catch (Exception e)\n                {\n                    _logger.LogError(e, \"Encountered an error processing the event\");\n                }\n            }\n        }\n\n        [FunctionName(nameof(GetChatMessageFromNotification))]\n        public async Task<HttpResponseMessage> GetChatMessageFromNotification(\n            [HttpTrigger(AuthorizationLevel.Anonymous, \"post\", Route = \"api/GetChatMessageFromNotification\")] HttpRequest req)\n        {\n            var response = new HttpResponseMessage();\n            try\n            {\n                _logger.LogInformation(\"GetChatMessageFromNotification function triggered.\");\n                \n                var access_token = GetAccessToken(req) ?? \"\";\n                // Validate the  token\n                var validationTokenResult = await _tokenValidationService\n                    .ValidateTokenAsync(access_token);", "        public async Task<HttpResponseMessage> GetChatMessageFromNotification(\n            [HttpTrigger(AuthorizationLevel.Anonymous, \"post\", Route = \"api/GetChatMessageFromNotification\")] HttpRequest req)\n        {\n            var response = new HttpResponseMessage();\n            try\n            {\n                _logger.LogInformation(\"GetChatMessageFromNotification function triggered.\");\n                \n                var access_token = GetAccessToken(req) ?? \"\";\n                // Validate the  token\n                var validationTokenResult = await _tokenValidationService\n                    .ValidateTokenAsync(access_token);", "                if (validationTokenResult == null)\n                {\n                    response.StatusCode = HttpStatusCode.Unauthorized;\n                    return response;\n                }\n                \n                string requestBody = string.Empty;\n                using (var streamReader = new StreamReader(req.Body))\n                {\n                    requestBody = await streamReader.ReadToEndAsync();\n                }\n\n                var encryptedContent = JsonConvert.DeserializeObject<ChangeNotificationEncryptedContent>(requestBody);             \n", "                if(encryptedContent == null)\n                {\n                    response.StatusCode = HttpStatusCode.InternalServerError;\n                    response.Content = new StringContent(\"Notification does not have right format.\");\n                    return response;\n                }\n\n                _logger.LogInformation($\"Decrypting content of type {encryptedContent.ODataType}\");\n\n                // Decrypt the encrypted payload using private key\n                var decryptedContent = await encryptedContent.DecryptAsync((id, thumbprint) => {\n                    return _certificateService.GetDecryptionCertificate();\n                });\n\n                response.StatusCode = HttpStatusCode.OK;\n                response.Headers.Add(\"ContentType\", \"application/json\");\n                response.Content = new StringContent(decryptedContent);\n            }", "            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"error decrypting\");\n                response.StatusCode = HttpStatusCode.InternalServerError;\n            }\n            \n            return response;\n        }\n\n        private string? GetAccessToken(HttpRequest req)\n        {", "            if (req!.Headers.TryGetValue(\"Authorization\", out var authHeader)) {\n                string[] parts = authHeader.First().Split(null) ?? new string[0];\n                if (parts.Length == 2 && parts[0].Equals(\"Bearer\"))\n                    return parts[1];\n            }\n            return null;\n        }\n\n        private async Task<Subscription?> GetGraphSubscription2(string accessToken, string subscriptionId)\n        {\n            _logger.LogInformation($\"Fetching subscription\");\n\n            try\n            {\n                return await _graphNotificationService.GetSubscriptionAsync(accessToken, subscriptionId);\n            }", "        private async Task<Subscription?> GetGraphSubscription2(string accessToken, string subscriptionId)\n        {\n            _logger.LogInformation($\"Fetching subscription\");\n\n            try\n            {\n                return await _graphNotificationService.GetSubscriptionAsync(accessToken, subscriptionId);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, $\"Failed to get graph subscriptionId: {subscriptionId}\");\n            }\n\n            return null;\n        }\n", "            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, $\"Failed to get graph subscriptionId: {subscriptionId}\");\n            }\n\n            return null;\n        }\n\n        private async Task<SubscriptionRecord?> GetGraphSubscription(string accessToken, SubscriptionRecord subscription)\n        {\n            _logger.LogInformation($\"Fetching subscription\");\n\n            try\n            {\n                var graphSubscription = await _graphNotificationService.GetSubscriptionAsync(accessToken, subscription.SubscriptionId);", "        private async Task<SubscriptionRecord?> GetGraphSubscription(string accessToken, SubscriptionRecord subscription)\n        {\n            _logger.LogInformation($\"Fetching subscription\");\n\n            try\n            {\n                var graphSubscription = await _graphNotificationService.GetSubscriptionAsync(accessToken, subscription.SubscriptionId);\n                if (!graphSubscription.ExpirationDateTime.HasValue)\n                {\n                    _logger.LogError(\"Graph Subscription does not have an expiration date\");\n                    throw new Exception(\"Graph Subscription does not have an expiration date\");\n                }\n                \n                return new SubscriptionRecord\n                {\n                    SubscriptionId = graphSubscription.Id,\n                    Resource = subscription.Resource,\n                    ExpirationTime = graphSubscription.ExpirationDateTime.Value,\n                    ResourceData = subscription.ResourceData,\n                    ChangeTypes = subscription.ChangeTypes \n                };\n            }", "            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, $\"Failed to get graph subscriptionId: {subscription.SubscriptionId}\");\n            }\n\n            return null;\n        }\n\n        private async Task<SubscriptionRecord> RenewGraphSubscription(string accessToken, SubscriptionRecord subscription, DateTimeOffset expirationTime)\n        {\n            _logger.LogInformation($\"Renewing subscription\");\n\n            // Renew the current graph subscription, passing the new expiration time sent from the client\n            var graphSubscription = await _graphNotificationService.RenewSubscriptionAsync(accessToken, subscription.SubscriptionId, expirationTime);\n", "        private async Task<SubscriptionRecord> RenewGraphSubscription(string accessToken, SubscriptionRecord subscription, DateTimeOffset expirationTime)\n        {\n            _logger.LogInformation($\"Renewing subscription\");\n\n            // Renew the current graph subscription, passing the new expiration time sent from the client\n            var graphSubscription = await _graphNotificationService.RenewSubscriptionAsync(accessToken, subscription.SubscriptionId, expirationTime);\n\n            if (!graphSubscription.ExpirationDateTime.HasValue)\n            {\n                _logger.LogError(\"Graph Subscription does not have an expiration date\");\n                throw new Exception(\"Graph Subscription does not have an expiration date\");\n            }\n\n            // Update subscription with renewed graph subscription data\n            subscription.SubscriptionId = graphSubscription.Id;\n            // If the graph subscription returns a null expiration time\n            subscription.ExpirationTime = graphSubscription.ExpirationDateTime.Value;\n\n            return subscription;\n        }\n", "        private async Task<SubscriptionRecord> CreateGraphSubscription(TokenValidationResult tokenValidationResult, SubscriptionDefinition subscriptionDefinition)\n        {\n            _logger.LogInformation(\"Creating Subscription\");\n            // if subscription on the resource for this user does not exist create it\n            var graphSubscription = await _graphNotificationService.AddSubscriptionAsync(tokenValidationResult.Token, subscriptionDefinition);\n\n            if (!graphSubscription.ExpirationDateTime.HasValue)\n            {\n                _logger.LogError(\"Graph Subscription does not have an expiration date\");\n                throw new Exception(\"Graph Subscription does not have an expiration date\");\n            }\n\n            _logger.LogInformation(\"Subscription Created\");\n            // Create a new subscription\n            return new SubscriptionRecord\n            {\n                SubscriptionId = graphSubscription.Id,\n                Resource = subscriptionDefinition.Resource,\n                ExpirationTime = graphSubscription.ExpirationDateTime.Value,\n                ResourceData = subscriptionDefinition.ResourceData,\n                ChangeTypes = subscriptionDefinition.ChangeTypes \n            };\n        }\n    }\n}\n"]}
{"filename": "Services/GraphNotificationService.cs", "chunked_list": ["using GraphNotifications.Models;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Microsoft.Graph;\n\nnamespace GraphNotifications.Services\n{\n    public class GraphNotificationService : IGraphNotificationService\n    {\n        private readonly ILogger _logger;\n        private readonly string _notificationUrl;", "        private readonly ILogger _logger;\n        private readonly string _notificationUrl;\n        private readonly IGraphClientService _graphClientService;\n        private readonly ICertificateService _certificateService;\n\n        public GraphNotificationService(IGraphClientService graphClientService, \n            ICertificateService certificateService, IOptions<AppSettings> settings, ILogger<GraphNotificationService> logger)\n        {\n            _graphClientService = graphClientService;\n            _certificateService = certificateService ?? throw new ArgumentException(nameof(certificateService));\n            _logger = logger;\n            _notificationUrl = settings.Value.NotificationUrl ?? throw new ArgumentException(nameof(settings.Value.NotificationUrl));\n        }\n", "        public async Task<Subscription> AddSubscriptionAsync(string userAccessToken, SubscriptionDefinition subscriptionDefinition)\n        {\n            // Create the subscription request\n            var subscription = new Subscription\n            {\n                ChangeType = string.Join(',', subscriptionDefinition.ChangeTypes), //\"created\",\n                NotificationUrl = _notificationUrl,\n                Resource = subscriptionDefinition.Resource, // \"me/mailfolders/inbox/messages\",\n                ClientState = Guid.NewGuid().ToString(),\n                IncludeResourceData = subscriptionDefinition.ResourceData,\n                ExpirationDateTime = subscriptionDefinition.ExpirationTime\n            };\n", "            if (subscriptionDefinition.ResourceData)\n            {\n                // Get the encryption certificate (public key)\n                var encryptionCertificate = await _certificateService.GetEncryptionCertificate();\n                subscription.EncryptionCertificateId = encryptionCertificate.Subject;\n                // To get resource data, we must provide a public key that\n                // Microsoft Graph will use to encrypt their key\n                // See https://docs.microsoft.com/graph/webhooks-with-resource-data#creating-a-subscription\n                subscription.AddPublicEncryptionCertificate(encryptionCertificate);\n            }\n\n            _logger.LogInformation(\"Getting GraphService with accesstoken for Graph onbehalf of user\");\n            var graphUserClient = _graphClientService.GetUserGraphClient(userAccessToken);\n\n            _logger.LogInformation(\"Create graph subscription\");\n            return await graphUserClient.Subscriptions.Request().AddAsync(subscription);\n        }\n", "        public async Task<Subscription> RenewSubscriptionAsync(string userAccessToken, string subscriptionId, DateTimeOffset expirationTime)\n        {\n            var subscription = new Subscription\n            {\n                ExpirationDateTime = expirationTime\n            };\n            \n            _logger.LogInformation(\"Getting GraphService with accesstoken for Graph onbehalf of user\");\n            var graphUserClient = _graphClientService.GetUserGraphClient(userAccessToken);\n            _logger.LogInformation($\"Renew graph subscription: {subscriptionId}\");\n            return await graphUserClient.Subscriptions[subscriptionId].Request().UpdateAsync(subscription);\n        }\n", "        public async Task<Subscription> GetSubscriptionAsync(string userAccessToken, string subscriptionId)\n        {\n            _logger.LogInformation(\"Getting GraphService with accesstoken for Graph onbehalf of user\");\n            var graphUserClient = _graphClientService.GetUserGraphClient(userAccessToken);\n            _logger.LogInformation($\"Get graph subscription: {subscriptionId}\");\n            return await graphUserClient.Subscriptions[subscriptionId].Request().GetAsync();\n        }\n    }\n}\n"]}
{"filename": "Services/CertificateService.cs", "chunked_list": ["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nusing System.Security.Cryptography.X509Certificates;\nusing Azure.Core;\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Certificates;\nusing Azure.Security.KeyVault.Secrets;\nusing GraphNotifications.Models;\nusing Microsoft.Extensions.Logging;", "using GraphNotifications.Models;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\n\nnamespace GraphNotifications.Services\n{\n\n    /// <summary>\n    /// Implements methods to retrieve certificates from Azure Key Vault\n    /// </summary>\n    public class CertificateService : ICertificateService\n    {", "    /// Implements methods to retrieve certificates from Azure Key Vault\n    /// </summary>\n    public class CertificateService : ICertificateService\n    {\n        private readonly AppSettings _settings;\n        private readonly ILogger _logger;\n        private readonly Uri _keyVaultUrl;\n        private byte[] _publicKeyBytes = null;\n        private byte[] _privateKeyBytes = null;\n\n        public CertificateService(IOptions<AppSettings> options, ILogger<CertificateService> logger)\n        {\n            _settings = options.Value;\n            _logger = logger;\n            _keyVaultUrl = !string.IsNullOrEmpty(_settings.KeyVaultUrl) ? \n                new Uri(_settings.KeyVaultUrl) : throw new ArgumentNullException(nameof(_settings.KeyVaultUrl));\n        }\n\n        /// <summary>", "        /// Gets the configured public key from the Azure Key Vault\n        /// </summary>\n        /// <returns>The public key</returns>\n        public async Task<X509Certificate2> GetEncryptionCertificate()\n        {\n            if (_publicKeyBytes == null)\n            {\n                await LoadCertificates();\n            }\n\n            return new X509Certificate2(_publicKeyBytes);\n        }\n\n        /// <summary>", "        /// Gets the configure private key from the Azure Key Vault\n        /// </summary>\n        /// <returns>The private key</returns>\n        public async Task<X509Certificate2> GetDecryptionCertificate()\n        {\n            if (_privateKeyBytes == null)\n            {\n                await LoadCertificates();\n            }\n\n            return new X509Certificate2(_privateKeyBytes);\n        }\n", "        private TokenCredential GetCredential()\n        {\n            // If you granted your Application access to the key vault\n            // you can use clientId and Client Secret\n            if (_settings.UseClientSecretAuth)\n            {\n                var tenantId = _settings.TenantId;\n                var clientId = _settings.ClientId;\n                var clientSecret = _settings.ClientSecret;\n\n                // Authenticate as the app to connect to Azure Key Vault\n                return new ClientSecretCredential(tenantId, clientId, clientSecret);\n            }\n\n            // If using user assigned managed identity\n            // pass the client id of the identity\n            var userAssignedClientId = _settings.UserAssignedClientId;", "            if (!string.IsNullOrEmpty(userAssignedClientId))\n            {\n                return new DefaultAzureCredential(new DefaultAzureCredentialOptions { ManagedIdentityClientId = userAssignedClientId });\n            }\n\n            // If using system assigned managed identity\n            // or local development\n            // Authenticate as the app to connect to Azure Key Vault\n            var defaultAzureCredentialOptions = new DefaultAzureCredentialOptions();\n            defaultAzureCredentialOptions.ExcludeAzureCliCredential = false;\n            defaultAzureCredentialOptions.ExcludeEnvironmentCredential = true;\n            defaultAzureCredentialOptions.ExcludeInteractiveBrowserCredential = true;\n            defaultAzureCredentialOptions.ExcludeManagedIdentityCredential = false;\n            defaultAzureCredentialOptions.ExcludeSharedTokenCacheCredential = true;\n            defaultAzureCredentialOptions.ExcludeVisualStudioCodeCredential = false;\n            defaultAzureCredentialOptions.ExcludeVisualStudioCredential = false;\n\n            return new DefaultAzureCredential(defaultAzureCredentialOptions);\n        }\n\n        /// <summary>", "        /// Gets the public and private keys from Azure Key Vault and caches the raw values\n        /// </summary>\n        private async Task LoadCertificates()\n        {\n            // Load configuration values\n            var certificateName = _settings.CertificateName;\n\n            var credential = GetCredential();\n\n            // CertificateClient can get the public key\n            var certClient = new CertificateClient(_keyVaultUrl, credential);\n            // Secret client can get the private key\n            var secretClient = new SecretClient(_keyVaultUrl, credential);\n\n            // Get the public key\n            var publicCertificate = await certClient.GetCertificateAsync(certificateName);\n", "            // Each certificate that has a private key in Azure Key Vault has a corresponding\n            // secret ID. Use this to get the private key\n            var privateCertificate = await secretClient.GetSecretAsync(ParseSecretName(publicCertificate.Value.SecretId));\n\n            _publicKeyBytes = publicCertificate.Value.Cer;\n            _privateKeyBytes = Convert.FromBase64String(privateCertificate.Value.Value);\n        }\n\n        /// <summary>\n        /// Extract the secret name from the secret ID\n        /// </summary>\n        /// <param name=\"secretId\">The URI to the secret</param>\n        /// <returns>The secret name</returns>\n        /// <exception cref=\"InvalidOperationException\"></exception>", "        private static string ParseSecretName(Uri secretId)\n        {\n            // Secret IDs are URIs. The name is in the\n            // third segment\n            if (secretId.Segments.Length < 3)\n            {\n                throw new InvalidOperationException($@\"The secret \"\"{secretId}\"\" does not contain a valid name.\");\n            }\n\n            return secretId.Segments[2].TrimEnd('/');\n        }\n    }\n}\n"]}
{"filename": "Services/GraphClientService.cs", "chunked_list": ["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nusing Azure.Identity;\nusing GraphNotifications.Models;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Microsoft.Graph;\n\nnamespace GraphNotifications.Services", "\nnamespace GraphNotifications.Services\n{\n    public class GraphClientService : IGraphClientService\n    {\n        private readonly AppSettings _settings;\n        private readonly ILogger _logger;\n\n        public GraphClientService(IOptions<AppSettings> options, ILogger<GraphClientService> logger)\n        {\n            _settings = options.Value;\n            _logger = logger;\n        }\n", "        public GraphServiceClient GetUserGraphClient(string userAssertion)\n        {\n            var tenantId = _settings.TenantId;\n            var clientId = _settings.ClientId;\n            var clientSecret = _settings.ClientSecret;\n\n            if (string.IsNullOrEmpty(tenantId) ||\n                string.IsNullOrEmpty(clientId) ||\n                string.IsNullOrEmpty(clientSecret))\n            {\n                _logger.LogError(\"Required settings missing: 'tenantId', 'apiClientId', and 'apiClientSecret'.\");\n                throw new ArgumentNullException(\"Required settings missing: 'tenantId', 'apiClientId', and 'apiClientSecret'.\");\n            }\n\n            var onBehalfOfCredential = new OnBehalfOfCredential(\n                tenantId, clientId, clientSecret, userAssertion);\n\n            return new GraphServiceClient(onBehalfOfCredential);\n        }\n    }\n}\n"]}
{"filename": "Services/CacheService.cs", "chunked_list": ["\n\nusing GraphNotifications.Models;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Newtonsoft.Json;\nusing StackExchange.Redis;\nusing System;\nusing System.Text;\nusing System.Threading;", "using System.Text;\nusing System.Threading;\n\nnamespace GraphNotifications.Services\n{\n    /// <summary>\n    /// Implements connection to Redis\n    /// </summary> \n    public class CacheService : ICacheService\n    {\n        private readonly ILogger<CacheService> _logger;", "    public class CacheService : ICacheService\n    {\n        private readonly ILogger<CacheService> _logger;\n        private readonly IRedisFactory _redisFactory;\n        private static readonly Encoding encoding = Encoding.UTF8;\n        \n        public CacheService(IRedisFactory redisFactory, ILogger<CacheService> logger)\n        {\n            _redisFactory = redisFactory;\n            _logger = logger;\n        }\n", "        public async Task<bool> AddAsync<T>(string key, T value, TimeSpan? expiry = default(TimeSpan?))\n        {\n            try\n            {\n                var redis = _redisFactory.GetCache();\n                if (redis == null) throw new ArgumentNullException(\"Redis Cache is null\");\n\n                _logger.LogInformation($\"Adding value to redis {key}\");\n                // TODO move this out to it's own UTIL Class\n                var jsonString = JsonConvert.SerializeObject(value);\n                return await redis.StringSetAsync(key, encoding.GetBytes(jsonString), expiry);\n            }", "            catch (RedisConnectionException ex)\n            {\n                _redisFactory.ForceReconnect();\n                _logger.LogError(ex, \"Redis Connection Error\");\n                throw;\n            }\n            catch(Exception ex)\n            {\n                _logger.LogError(ex, $\"Redis Add Error for - {key}\");\n                throw;\n            }\n        }\n", "        public async Task<T> GetAsync<T>(string key)\n        {\n            try\n            {\n                var redis = _redisFactory.GetCache();\n                if (redis == null) throw new ArgumentNullException(\"Redis Cache is null\");\n\n                var value = await redis.StringGetAsync(key);\n                if (!value.HasValue)\n                {\n                    return default(T);\n                }\n                return JsonConvert.DeserializeObject<T>(value);\n            }", "                if (!value.HasValue)\n                {\n                    return default(T);\n                }\n                return JsonConvert.DeserializeObject<T>(value);\n            }\n            catch (RedisConnectionException ex)\n            {\n                _redisFactory.ForceReconnect();\n                _logger.LogError(ex, \"Redis Connection Error\");\n                throw;\n            }", "            catch (Exception ex)\n            {\n                _logger.LogError(ex, $\"Redis Get Error for - {key}\");\n                throw;\n            }\n        }\n\n        public async Task<bool> DeleteAsync(string key)\n        {\n            try\n            {\n                var redis = _redisFactory.GetCache();", "                if (redis == null) throw new ArgumentNullException(\"Redis Cache is null\");\n\n                return await redis.KeyDeleteAsync(key);\n            }\n            catch (RedisConnectionException ex)\n            {\n                _redisFactory.ForceReconnect();\n                _logger.LogError(ex, \"Redis Connection Error\");\n                throw;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, $\"Redis Get Error for - {key}\");\n                throw;\n            }\n        }\n    }\n}", "            catch (Exception ex)\n            {\n                _logger.LogError(ex, $\"Redis Get Error for - {key}\");\n                throw;\n            }\n        }\n    }\n}"]}
{"filename": "Services/TokenValidationResult.cs", "chunked_list": ["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nusing System.Security.Claims;\n\nnamespace GraphNotifications.Services\n{\n    public class TokenValidationResult\n    {\n        // User ID\n        public string Upn { get; private set; }", "        public string Upn { get; private set; }\n        public string UserId { get; private set; }\n        public string TenantId { get; private set; }\n        public string AppId {get; private set;}\n\n        // The extracted token - used to build user assertion\n        // for OBO flow\n        public string Token { get; private set; }\n\n        public IList<Claim> Claims { get; private set; }\n\n        public TokenValidationResult(string token, IList<Claim> claims)\n        {\n            Token = token;\n            Claims = claims;\n", "            if(claims.Where(x => x.Type == \"upn\").Count() > 0)\n                Upn = claims.First(x => x.Type == \"upn\").Value;\n            if(claims.Where(x => x.Type == \"oid\").Count() > 0)\n                UserId = claims.First(x => x.Type == \"oid\").Value;\n            if(claims.Where(x => x.Type == \"tid\").Count() > 0)\n                TenantId = claims.First(x => x.Type == \"tid\").Value;\n            if(claims.Where(x => x.Type == \"appid\").Count() > 0)\n                AppId = claims.First(x => x.Type == \"appid\").Value;\n        }\n    }\n}\n"]}
{"filename": "Services/IRedisFactory.cs", "chunked_list": ["using StackExchange.Redis;\n\nnamespace GraphNotifications.Services\n{\n    public interface IRedisFactory : IDisposable\n    {\n        IDatabase GetCache();\n\n        void ForceReconnect();\n    }\n}"]}
{"filename": "Services/ICertificateService.cs", "chunked_list": ["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nusing System.Security.Cryptography.X509Certificates;\n\nnamespace GraphNotifications.Services\n{\n    public interface ICertificateService\n    {\n        Task<X509Certificate2> GetDecryptionCertificate();\n        Task<X509Certificate2> GetEncryptionCertificate();\n    }\n}"]}
{"filename": "Services/TokenValidationService.cs", "chunked_list": ["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nusing System.Globalization;\nusing System.IdentityModel.Tokens.Jwt;\nusing System.Net.Http.Headers;\nusing System.Security.Claims;\nusing GraphNotifications.Models;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;", "using Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Microsoft.IdentityModel.Protocols;\nusing Microsoft.IdentityModel.Protocols.OpenIdConnect;\nusing Microsoft.IdentityModel.Tokens;\n\nnamespace GraphNotifications.Services\n{\n    public class TokenValidationService : ITokenValidationService\n    {\n        private TokenValidationParameters? _validationParameters;", "{\n    public class TokenValidationService : ITokenValidationService\n    {\n        private TokenValidationParameters? _validationParameters;\n        private readonly AppSettings _settings;\n        private readonly ILogger _logger;\n        private static readonly Lazy<JwtSecurityTokenHandler> JwtSecurityTokenHandler = new Lazy<JwtSecurityTokenHandler>(() => new JwtSecurityTokenHandler());\n\n        public TokenValidationService(IOptions<AppSettings> settings, ILogger<TokenValidationService> logger)\n        {\n            _settings = settings.Value;\n            _logger = logger;\n        }\n", "        public async Task<TokenValidationResult?> ValidateTokenAsync(string token)\n        {\n            var validationParameters = await GetTokenValidationParametersAsync();\n            if (validationParameters == null)\n            {\n                return null;\n            }\n\n            var tokenHandler = new JwtSecurityTokenHandler();\n            try\n            {\n                // Validate the token\n                var result = tokenHandler.ValidateToken(token,\n                    _validationParameters, out SecurityToken jwtToken);\n\n                // If ValidateToken did not throw an exception, token is valid.\n                return new TokenValidationResult(token, GetClaims(token));                        \n            }", "            catch (Exception exception)\n            {\n                _logger.LogError(exception, \"Error validating bearer token\");\n            }\n\n            return null;\n        }\n\n        public async Task<TokenValidationResult?> ValidateAuthorizationHeaderAsync(\n            HttpRequest request)\n        {\n            // The incoming request should have an Authorization header", "        public async Task<TokenValidationResult?> ValidateAuthorizationHeaderAsync(\n            HttpRequest request)\n        {\n            // The incoming request should have an Authorization header\n            if (request.Headers.TryGetValue(\"authorization\", out var authValues))\n            {\n                var authHeader = AuthenticationHeaderValue.Parse(authValues.ToArray().First());\n\n                // Make sure that the value is \"Bearer token-value\"\n                if (authHeader != null &&\n                    string.Compare(authHeader.Scheme, \"bearer\", true, CultureInfo.InvariantCulture) == 0 &&\n                    !string.IsNullOrEmpty(authHeader.Parameter))\n                {\n                    var validationParameters = await GetTokenValidationParametersAsync();", "                if (authHeader != null &&\n                    string.Compare(authHeader.Scheme, \"bearer\", true, CultureInfo.InvariantCulture) == 0 &&\n                    !string.IsNullOrEmpty(authHeader.Parameter))\n                {\n                    var validationParameters = await GetTokenValidationParametersAsync();\n                    if (validationParameters == null)\n                    {\n                        return null;\n                    }\n\n                    var tokenHandler = new JwtSecurityTokenHandler();\n                    try\n                    {\n                        // Validate the token\n                        var result = tokenHandler.ValidateToken(authHeader.Parameter,\n                            _validationParameters, out SecurityToken jwtToken);\n\n                        // If ValidateToken did not throw an exception, token is valid.\n                        return new TokenValidationResult(authHeader.Parameter, GetClaims(authHeader.Parameter));                        \n                    }", "                    catch (Exception exception)\n                    {\n                        _logger.LogError(exception, \"Error validating bearer token\");\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        private async Task<TokenValidationParameters?> GetTokenValidationParametersAsync()\n        {", "        private async Task<TokenValidationParameters?> GetTokenValidationParametersAsync()\n        {\n            if (_validationParameters == null)\n            {\n                // Get tenant ID and client ID\n                var tenantId = _settings.TenantId;\n                var clientId = _settings.ClientId;\n                if (string.IsNullOrEmpty(tenantId) ||\n                    string.IsNullOrEmpty(clientId))\n                {\n                    _logger.LogError(\"Required settings missing: 'tenantId' and/or 'apiClientId'.\");\n                    return null;\n                }\n\n                // Load the tenant-specific OpenID config from Azure\n                var configManager = new ConfigurationManager<OpenIdConnectConfiguration>(\n                $\"https://login.microsoftonline.com/{tenantId}/.well-known/openid-configuration\",\n                new OpenIdConnectConfigurationRetriever());\n\n                var config = await configManager.GetConfigurationAsync();\n\n                _validationParameters = new TokenValidationParameters\n                {\n                    // Use signing keys retrieved from Azure\n                    IssuerSigningKeys = config.SigningKeys,\n                    ValidateAudience = true,\n                    // Audience MUST be the app ID for the Web API or api://<app Id>. This is required for powerapp as connector will always request token for api://<app id?\n                    ValidAudiences = new string[] { clientId, $\"api://{clientId}\" },\n                    ValidateIssuer = tenantId != \"common\",\n                    // Use the issuer retrieved from Azure\n                    ValidIssuer = config.Issuer,\n                    ValidateLifetime = true\n                };\n            }\n\n            return _validationParameters;\n        }\n\n        private IList<Claim> GetClaims(string jwt)\n        {", "            if (jwt.StartsWith(\"Bearer \", StringComparison.OrdinalIgnoreCase))\n            {\n                jwt = jwt.Substring(\"Bearer \".Length).Trim();\n            }\n            return JwtSecurityTokenHandler.Value.ReadJwtToken(jwt).Claims.ToList();\n        }\n    }\n}\n"]}
{"filename": "Services/RedisFactory.cs", "chunked_list": ["\n\nusing GraphNotifications.Models;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing StackExchange.Redis;\nusing System;\nusing System.Threading;\n\nnamespace GraphNotifications.Services", "\nnamespace GraphNotifications.Services\n{\n    /// <summary>\n    /// Implements connection to Redis\n    /// </summary> \n    public class RedisFactory : IRedisFactory\n    {\n        private static Lazy<IConnectionMultiplexer> _multiplexer;\n        private static Lazy<IDatabase> _cache;\n        private bool _disposed = false;\n", "        private static Lazy<IConnectionMultiplexer> _multiplexer;\n        private static Lazy<IDatabase> _cache;\n        private bool _disposed = false;\n\n        private readonly AppSettings _settings;\n        private readonly ILogger<RedisFactory> _logger;\n\n        // Force Reconnect variables\n        static long lastReconnectTicks = DateTimeOffset.MinValue.UtcTicks;\n        static DateTimeOffset firstError = DateTimeOffset.MinValue;\n        static DateTimeOffset previousError = DateTimeOffset.MinValue;\n\n        static object reconnectLock = new object();\n\n        // In general, let StackExchange.Redis handle most reconnects, \n        // so limit the frequency of how often this will actually reconnect.", "        public static TimeSpan ReconnectMinFrequency = TimeSpan.FromSeconds(60);\n\n        // if errors continue for longer than the below threshold, then the \n        // multiplexer seems to not be reconnecting, so re-create the multiplexer\n        public static TimeSpan ReconnectErrorThreshold = TimeSpan.FromSeconds(30);\n\n        public RedisFactory(IOptions<AppSettings> settings, ILogger<RedisFactory> logger)\n        {\n            _settings = settings.Value;\n            _logger = logger;\n            _multiplexer = CreateMultiplexer();\n            _cache = GetDatabase();\n        }\n", "        public IDatabase GetCache()\n        {\n            if (_disposed) throw new ObjectDisposedException(nameof(RedisFactory));\n\n            return _cache.Value;\n        }\n\n        private Lazy<IConnectionMultiplexer> CreateMultiplexer()\n        {\n            _logger.LogInformation(\"Connecting to Redis\");\n            return new Lazy<IConnectionMultiplexer>(() => ConnectionMultiplexer.Connect(_settings.RedisConnectionString));\n        }\n\n        private Lazy<IDatabase> GetDatabase()\n        {\n            return new Lazy<IDatabase>(_multiplexer.Value.GetDatabase());\n        }\n", "        private void CloseMultiplexer(Lazy<IConnectionMultiplexer> oldMultiplexer)\n        {\n            if (oldMultiplexer != null)\n            {\n                try\n                {\n                    oldMultiplexer.Value.Close();\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError($\"Error closing old multiplexer. Message = {ex.Message}\");\n                }\n            }\n        }\n\n        /// <summary>\n        /// Force a new ConnectionMultiplexer to be created.\n        /// NOTES: \n        ///     1. Users of the ConnectionMultiplexer MUST handle ObjectDisposedExceptions, which can now happen as a result of calling ForceReconnect()\n        ///     2. Don't call ForceReconnect for Timeouts, just for RedisConnectionExceptions or SocketExceptions\n        ///     3. Call this method every time you see a connection exception, the code will wait to reconnect:\n        ///         a. for at least the \"ReconnectErrorThreshold\" time of repeated errors before actually reconnecting\n        ///         b. not reconnect more frequently than configured in \"ReconnectMinFrequency\"\n        /// </summary>", "                catch (Exception ex)\n                {\n                    _logger.LogError($\"Error closing old multiplexer. Message = {ex.Message}\");\n                }\n            }\n        }\n\n        /// <summary>\n        /// Force a new ConnectionMultiplexer to be created.\n        /// NOTES: \n        ///     1. Users of the ConnectionMultiplexer MUST handle ObjectDisposedExceptions, which can now happen as a result of calling ForceReconnect()\n        ///     2. Don't call ForceReconnect for Timeouts, just for RedisConnectionExceptions or SocketExceptions\n        ///     3. Call this method every time you see a connection exception, the code will wait to reconnect:\n        ///         a. for at least the \"ReconnectErrorThreshold\" time of repeated errors before actually reconnecting\n        ///         b. not reconnect more frequently than configured in \"ReconnectMinFrequency\"\n        /// </summary>", "        public void ForceReconnect()\n        {\n            _logger.LogInformation(\"Force Reconnect called\");\n            var utcNow = DateTimeOffset.UtcNow;\n            var previousTicks = Interlocked.Read(ref lastReconnectTicks);\n            var previousReconnect = new DateTimeOffset(previousTicks, TimeSpan.Zero);\n            var elapsedSinceLastReconnect = utcNow - previousReconnect;\n\n            // If mulitple threads call ForceReconnect at the same time, we only want to honor one of them.\n            if (elapsedSinceLastReconnect > ReconnectMinFrequency)\n            {\n                lock (reconnectLock)\n                {\n                    utcNow = DateTimeOffset.UtcNow;\n                    elapsedSinceLastReconnect = utcNow - previousReconnect;\n", "            if (elapsedSinceLastReconnect > ReconnectMinFrequency)\n            {\n                lock (reconnectLock)\n                {\n                    utcNow = DateTimeOffset.UtcNow;\n                    elapsedSinceLastReconnect = utcNow - previousReconnect;\n\n                    if (firstError == DateTimeOffset.MinValue)\n                    {\n                        // We haven't seen an error since last reconnect, so set initial values.\n                        firstError = utcNow;\n                        previousError = utcNow;\n                        return;\n                    }\n", "                    if (elapsedSinceLastReconnect < ReconnectMinFrequency)\n                        return; // Some other thread made it through the check and the lock, so nothing to do.\n\n                    var elapsedSinceFirstError = utcNow - firstError;\n                    var elapsedSinceMostRecentError = utcNow - previousError;\n\n                    var shouldReconnect =\n                        elapsedSinceFirstError >= ReconnectErrorThreshold   // make sure we gave the multiplexer enough time to reconnect on its own if it can\n                        && elapsedSinceMostRecentError <= ReconnectErrorThreshold; //make sure we aren't working on stale data (e.g. if there was a gap in errors, don't reconnect yet).\n\n                    // Update the previousError timestamp to be now (e.g. this reconnect request)\n                    previousError = utcNow;\n                    _logger.LogInformation($\"Should reconnect = ({shouldReconnect})\");", "                    if (shouldReconnect)\n                    {\n                        _logger.LogInformation($\"Reconnecting to Redis\");\n                        firstError = DateTimeOffset.MinValue;\n                        previousError = DateTimeOffset.MinValue;\n\n                        var oldMultiplexer = _multiplexer;\n                        CloseMultiplexer(oldMultiplexer);\n                        _multiplexer = CreateMultiplexer();\n                        _cache = GetDatabase();\n                        Interlocked.Exchange(ref lastReconnectTicks, utcNow.UtcTicks);\n                        _logger.LogInformation($\"Reconnected to Redis\");\n                    }\n                }\n            }\n        }\n", "        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!_disposed)\n            {\n                if (disposing && _multiplexer.IsValueCreated)\n                {\n                    _multiplexer.Value?.Dispose();\n                }\n\n                _disposed = true;\n            }\n        }\n    }\n}", "            if (!_disposed)\n            {\n                if (disposing && _multiplexer.IsValueCreated)\n                {\n                    _multiplexer.Value?.Dispose();\n                }\n\n                _disposed = true;\n            }\n        }\n    }\n}"]}
{"filename": "Services/ICacheService.cs", "chunked_list": ["namespace GraphNotifications.Services\n{\n    /// <summary>\n    /// \n    /// </summary> \n    public interface ICacheService\n    {\n        Task<bool> AddAsync<T>(string key, T value, TimeSpan? expiry = default(TimeSpan?));\n\n        Task<T> GetAsync<T>(string key);\n\n        Task<bool> DeleteAsync(string key);\n    }\n}"]}
{"filename": "Services/IGraphNotificationService.cs", "chunked_list": ["using Microsoft.Graph;\nusing GraphNotifications.Models;\n\nnamespace GraphNotifications.Services\n{\n    public interface IGraphNotificationService\n    {\n        Task<Subscription> GetSubscriptionAsync(string userAccessToken, string subscriptionId);\n        Task<Subscription> AddSubscriptionAsync(string userAccessToken, SubscriptionDefinition subscriptionDefinition);\n        Task<Subscription> RenewSubscriptionAsync(string userAccessToken, string subscriptionId, DateTimeOffset expirationTime);\n    }\n}\n"]}
{"filename": "Services/IGraphClientService.cs", "chunked_list": ["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nusing Microsoft.Graph;\n\nnamespace GraphNotifications.Services\n{\n    public interface IGraphClientService\n    {\n        GraphServiceClient GetUserGraphClient(string userAssertion);\n    }\n}\n"]}
{"filename": "Services/ITokenValidationService.cs", "chunked_list": ["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nusing Microsoft.AspNetCore.Http;\n\nnamespace GraphNotifications.Services\n{\n    public interface ITokenValidationService\n    {\n        Task<TokenValidationResult?> ValidateAuthorizationHeaderAsync(\n            HttpRequest request);\n\n        Task<TokenValidationResult?> ValidateTokenAsync(\n            string token);\n    }\n}\n"]}
{"filename": "Models/SubscriptionDefinition.cs", "chunked_list": ["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nnamespace GraphNotifications.Models\n{\n    public class SubscriptionDefinition\n    {\n        public string Resource {get; set;}\n        public DateTimeOffset ExpirationTime {get;set;}\n        public string[] ChangeTypes {get; set;}\n        public bool ResourceData {get; set;}\n    }\n}", "        public DateTimeOffset ExpirationTime {get;set;}\n        public string[] ChangeTypes {get; set;}\n        public bool ResourceData {get; set;}\n    }\n}"]}
{"filename": "Models/AppSettings.cs", "chunked_list": ["\ufeffnamespace GraphNotifications.Models\n{\n    public class AppSettings\n    {\n        public string TenantId { get; set; }\n        \n        public string NotificationUrl { get; set; }\n\n        public string ClientId { get; set; }\n\n        public string ClientSecret { get; set; }\n", "        public string ClientId { get; set; }\n\n        public string ClientSecret { get; set; }\n\n        public string KeyVaultUrl { get; set; }\n\n        public string CertificateName { get; set; }\n\n        public string UserAssignedClientId { get; set; }\n\n        public string RedisConnectionString { get; set; }\n        \n        // Flag to set if ClientSecret of Managed Identity is used", "        public string UserAssignedClientId { get; set; }\n\n        public string RedisConnectionString { get; set; }\n        \n        // Flag to set if ClientSecret of Managed Identity is used\n        public bool UseClientSecretAuth { get; set; }\n    }\n}\n"]}
{"filename": "Models/SubscriptionRecord.cs", "chunked_list": ["namespace GraphNotifications.Models\n{\n    /// <summary>\n    /// Subscription record saved in subscription store\n    /// </summary>\n    public class SubscriptionRecord : SubscriptionDefinition\n    {\n        /// <summary>\n        /// The ID of the graph subscription\n        /// </summary>\n        public string SubscriptionId { get; set; }\n    }\n}\n", "        public string SubscriptionId { get; set; }\n    }\n}\n"]}
