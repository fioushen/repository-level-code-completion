{"filename": "src/SKernel.Services/Extensions.cs", "chunked_list": ["\ufeffusing Microsoft.SemanticKernel.Orchestration;\nusing Microsoft.SemanticKernel;\nusing SKernel.Factory.Config;\nusing SKernel.Factory;\nusing Microsoft.AspNetCore.Http;\n\nnamespace SKernel.Service\n{\n    public static class Extensions\n    {\n        public static ApiKey ToApiKeyConfig(this HttpRequest request)\n        {\n            var apiConfig = new ApiKey();\n", "    public static class Extensions\n    {\n        public static ApiKey ToApiKeyConfig(this HttpRequest request)\n        {\n            var apiConfig = new ApiKey();\n\n            if (request.Headers.TryGetValue(Headers.TextCompletionKey, out var textKey))\n                apiConfig.Text = textKey.First()!;\n\n            apiConfig.Embedding = request.Headers.TryGetValue(Headers.EmbeddingKey, out var embeddingKey)\n                ? embeddingKey.First()!\n                : apiConfig.Text;\n            apiConfig.Chat = request.Headers.TryGetValue(Headers.ChatCompletionKey, out var chatKey)\n                ? chatKey.First()!\n                : apiConfig.Text;\n\n            return apiConfig;\n        }\n", "        public static bool TryGetKernel(this HttpRequest request, SemanticKernelFactory factory,\n            out IKernel? kernel, IList<string>? selected = null)\n        {\n            var api = request.ToApiKeyConfig();\n            kernel = api is { Text: { }, Embedding: { } } ? factory.Create(api, selected) : null;\n            return kernel != null;\n        }\n\n        public static IResult ToResult(this SKContext result, IList<string>? skills) => (result.ErrorOccurred)\n            ? Results.BadRequest(result.LastErrorDescription)\n            : Results.Ok(new Message { Variables = result.Variables, Skills = skills ?? new List<string>() });\n    }\n}\n", "        public static IResult ToResult(this SKContext result, IList<string>? skills) => (result.ErrorOccurred)\n            ? Results.BadRequest(result.LastErrorDescription)\n            : Results.Ok(new Message { Variables = result.Variables, Skills = skills ?? new List<string>() });\n    }\n}\n"]}
{"filename": "src/SKernel.Services/Services/SkillsService.cs", "chunked_list": ["\ufeffusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Server.IIS.Core;\nusing Microsoft.SemanticKernel;\nusing Microsoft.SemanticKernel.Orchestration;\nusing SKernel.Contract.Services;\nusing SKernel.Factory;\n\nnamespace SKernel.Service.Services\n{\n    public class SkillsService : ServiceBase, ISkillsService\n    {", "namespace SKernel.Service.Services\n{\n    public class SkillsService : ServiceBase, ISkillsService\n    {\n        private SemanticKernelFactory semanticKernelFactory;\n        private IHttpContextAccessor contextAccessor;\n\n        public SkillsService(SemanticKernelFactory factory, IHttpContextAccessor contextAccessor)\n        {\n            this.semanticKernelFactory = factory;\n            this.contextAccessor = contextAccessor;\n            RouteOptions.DisableAutoMapRoute = true;//\u5f53\u524d\u670d\u52a1\u7981\u7528\u81ea\u52a8\u6ce8\u518c\u8def\u7531\n            App.MapGet(\"/api/skills/{skill}/{function}\", GetSkillFunctionAsync);\n            App.MapGet(\"/api/skills\", GetSkillsAsync);\n        }\n\n", "        public async Task<IResult> GetSkillFunctionAsync(string skill, string function)\n        {\n            var httpRequest = this.contextAccessor?.HttpContext?.Request;\n\n            return httpRequest.TryGetKernel(semanticKernelFactory, out var kernel)\n                 ? kernel!.Skills.HasFunction(skill, function)\n                 ? Results.Ok(kernel.Skills.GetFunction(skill, function).Describe())\n             : Results.NotFound()\n             : Results.BadRequest(\"API config is not valid\");\n        }\n", "        public async Task<IResult> GetSkillsAsync()\n        {\n            var httpRequest = this.contextAccessor?.HttpContext?.Request;\n\n            return  httpRequest.TryGetKernel(semanticKernelFactory, out var kernel)\n                ? Results.Ok(\n                    new Dictionary<string, List<Dictionary<string, object>>>\n            {\n                [\"skills\"] = (from function in kernel!.ToSkills()\n                              select new Dictionary<string, object>\n                              {\n                                  [\"skill\"] = function.SkillName,\n                                  [\"function\"] = function.Name,\n                                  [\"_links\"] = new Dictionary<string, object>\n                                  {\n                                      [\"self\"] = new Dictionary<string, object>\n                                      {\n                                          [\"href\"] = ($\"/api/skills/{function.SkillName}/{function.Name}\".ToLower())\n                                      }\n                                  }\n                              })\n                    .ToList()\n            })\n                : Results.BadRequest(\"API config is not valid\");\n\n\n        }\n    }\n}\n"]}
{"filename": "src/SKernel.Services/Services/AsksService.cs", "chunked_list": ["\ufeffusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing SKernel.Contract.Services;\nusing SKernel.Factory;\nusing static System.Runtime.InteropServices.JavaScript.JSType;\n\nnamespace SKernel.Service.Services\n{\n    public class AsksService : ServiceBase, IAsksService\n    {", "{\n    public class AsksService : ServiceBase, IAsksService\n    {\n        private SemanticKernelFactory semanticKernelFactory;\n        private IHttpContextAccessor contextAccessor;\n        private IPlanExecutor planExecutor;\n\n        public AsksService(SemanticKernelFactory factory, IHttpContextAccessor contextAccessor, IPlanExecutor planExecutor)\n        {\n            this.semanticKernelFactory = factory;\n            this.contextAccessor = contextAccessor;\n            this.planExecutor = planExecutor;\n            RouteOptions.DisableAutoMapRoute = true;//\u5f53\u524d\u670d\u52a1\u7981\u7528\u81ea\u52a8\u6ce8\u518c\u8def\u7531\n            App.MapPost(\"/api/asks\", PostAsync);\n        }\n", "        public async Task<IResult> PostAsync([FromQuery(Name = \"iterations\")] int? iterations, Message message)\n        {\n            var httpRequest = this.contextAccessor?.HttpContext?.Request;\n\n            return httpRequest.TryGetKernel(semanticKernelFactory, out var kernel)\n                ? (message.Pipeline == null || message.Pipeline.Count == 0\n                ? await planExecutor.Execute(kernel!, message, iterations ?? 10)\n                : await kernel!.InvokePipedFunctions(message)).ToResult(message.Skills)\n            : Results.BadRequest(\"API config is not valid\");\n        }\n    }\n}\n"]}
{"filename": "src/SKernel.WebApi/Program.cs", "chunked_list": ["using Masa.BuildingBlocks.Service.MinimalAPIs;\nusing Microsoft.AspNetCore.Diagnostics;\nusing Microsoft.OpenApi.Models;\nusing Microsoft.SemanticKernel;\nusing SKernel;\nusing SKernel.Factory.Config;\nusing System.Reflection;\n\nnamespace SKernel.WebApi\n{\n    public class Program\n    {", "namespace SKernel.WebApi\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var builder = WebApplication.CreateBuilder(args);\n\n            var skills = builder.Configuration.GetSection(\"SKConfig:Skills\").Get<string[]>() ?? new[] { \"./skills\" };\n\n            foreach (var folder in skills)\n            {", "            foreach (var folder in skills)\n            {\n                if (!Directory.Exists(folder))\n                    Directory.CreateDirectory(folder);\n            }\n            // Add services to the container.\n            builder.Services.AddAuthorization();\n            builder.Services.AddConsoleLogger(builder.Configuration);\n            builder.Services.AddSemanticKernelFactory(builder.Configuration);\n            builder.WebHost.UseUrls($\"http://*:{builder.Configuration[\"Port\"] ?? \"5000\"}\");\n\n            // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle\n            builder.Services.AddEndpointsApiExplorer();\n            builder.Services.AddSwaggerGen(c =>\n            {\n                c.SwaggerDoc(\"v1\", new OpenApiInfo\n                {\n                    Title = \"SK API\",\n                    Version = \"v1\",\n                    Contact = new OpenApiContact { Name = \"SK\", }\n                });\n", "                foreach (var item in Directory.GetFiles(Directory.GetCurrentDirectory(), \"*.xml\"))\n                {\n                    c.IncludeXmlComments(item, true);\n                }\n                c.DocInclusionPredicate((docName, action) => true);\n            });\n\n            builder.Services.AddMasaMinimalAPIs(opt =>\n            {\n                opt.PluralizeServiceName = false;  \n                var loadMinimalApiAssembies = opt.Assemblies.ToList();\n                loadMinimalApiAssembies.Add(Assembly.Load(\"SKernel.Service\")); //\u04b5\n                opt.Assemblies = loadMinimalApiAssembies;\n            });\n            builder.Services.AddSemanticKernelFactory(builder.Configuration);\n            builder.Services.AddAutoInject();\n            builder.Services.AddSingleton<IHttpContextAccessor, HttpContextAccessor>();\n\n            var app = builder.Build();\n\n            // Configure the HTTP request pipeline.", "            if (app.Environment.IsDevelopment())\n            {\n                app.UseSwagger();\n                app.UseSwaggerUI();\n            }\n\n            app.UseAuthorization();\n            app.UseMasaExceptionHandler();\n            app.MapMasaMinimalAPIs();\n            app.UseExceptionHandler(handler =>\n            handler.Run(async context =>\n            {\n                var exception = context.Features.Get<IExceptionHandlerFeature>()!.Error;\n                switch (exception)\n                {\n                    case KernelException\n                    {\n                        ErrorCode: KernelException.ErrorCodes.FunctionNotAvailable\n                    }\n                    kernelException:\n                        await Results.BadRequest(kernelException.Message).ExecuteAsync(context);\n                        break;\n                    default:\n                        await Results.Problem(exception.Message).ExecuteAsync(context);\n                        break;\n                }\n                }));\n            app.Run();\n        }\n    }\n}"]}
{"filename": "src/SKernel.Contracts/Services/ISkillsService.cs", "chunked_list": ["\ufeffnamespace SKernel.Contract.Services\n{\n    public  interface ISkillsService\n    {\n        Task<IResult> GetSkillsAsync();\n\n        Task<IResult> GetSkillFunctionAsync(string skill, string function);\n    }\n}\n"]}
{"filename": "src/SKernel.Contracts/Services/IAsksService.cs", "chunked_list": ["\ufeffnamespace SKernel.Contract.Services\n{\n    public interface IAsksService\n    {\n        /// <summary>\n        /// \n        /// </summary>\n        /// <param name=\"id\"></param>\n        /// <returns></returns>\n        Task<IResult> PostAsync(int? iterations, Message message);\n    }\n}\n"]}
{"filename": "src/SKernel/Message.cs", "chunked_list": ["\ufeffusing Microsoft.SemanticKernel.Orchestration;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace SKernel\n{\n    public class Message\n    {\n        public IEnumerable<KeyValuePair<string, string>> Variables { get; init; } = new ContextVariables();\n        public IList<FunctionRef>? Pipeline { get; init; } = new List<FunctionRef>();\n        public IList<string>? Skills { get; init; } = new List<string>();\n", "        public class FunctionRef\n        {\n            public string Skill { get; init; } = \"PlannerSkill\";\n            public string Name { get; init; } = \"CreatePlan\";\n        }\n\n        public static Message Ask(string question, ContextVariables context)\n        {\n            return new Message\n            {\n                Variables = context.Clone().Update(question),\n                Pipeline = new List<FunctionRef> { new() { Skill = \"PlannerSkill\", Name = \"ExecutePlan\" } }\n            };\n        }\n", "        public static Message Ask(ContextVariables context, params FunctionRef[] pipeline)\n        {\n            return new Message()\n            {\n                Variables = new ContextVariables().Update(context),\n                Pipeline = pipeline.ToList()\n            };\n        }\n    }\n}\n"]}
{"filename": "src/SKernel/Headers.cs", "chunked_list": ["\ufeffnamespace SKernel\n{\n    public static class Headers\n    {\n        public const string TextCompletionKey = \"x-sk-text-completion-key\";\n        public const string ChatCompletionKey = \"x-sk-chat-completion-key\";\n        public const string EmbeddingKey = \"x-sk-embedding-key\";\n    }\n}\n"]}
{"filename": "src/SKernel/KernelExtensions.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.SemanticKernel;\nusing Microsoft.SemanticKernel.Connectors.Memory.Qdrant;\nusing Microsoft.SemanticKernel.CoreSkills;\nusing Microsoft.SemanticKernel.KernelExtensions;\nusing Microsoft.SemanticKernel.Memory;\nusing Microsoft.SemanticKernel.Orchestration;", "using Microsoft.SemanticKernel.Memory;\nusing Microsoft.SemanticKernel.Orchestration;\nusing Microsoft.SemanticKernel.SkillDefinition;\nusing SKernel.Factory;\nusing SKernel.Factory.Config;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;", "using System.Linq;\nusing System.Reflection;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace SKernel\n{\n    public static partial class Extensions\n    {\n        internal static ISKFunction CreatePlan(this IKernel kernel) =>\n            kernel.Skills.GetFunction(\"plannerskill\", \"createplan\");\n\n        internal static ISKFunction ExecutePlan(this IKernel kernel) =>\n            kernel.Skills.GetFunction(\"plannerskill\", \"executeplan\");\n\n        internal static ContextVariables ToContext(this IEnumerable<KeyValuePair<string, string>> variables)\n        {\n            var context = new ContextVariables();", "    public static partial class Extensions\n    {\n        internal static ISKFunction CreatePlan(this IKernel kernel) =>\n            kernel.Skills.GetFunction(\"plannerskill\", \"createplan\");\n\n        internal static ISKFunction ExecutePlan(this IKernel kernel) =>\n            kernel.Skills.GetFunction(\"plannerskill\", \"executeplan\");\n\n        internal static ContextVariables ToContext(this IEnumerable<KeyValuePair<string, string>> variables)\n        {\n            var context = new ContextVariables();", "            foreach (var variable in variables) context[variable.Key] = variable.Value;\n            return context;\n        }\n\n        internal static IKernel RegisterSemanticSkills(this IKernel kernel, string skill, IList<string> skills, ILogger logger)\n        {\n            foreach (var prompt in Directory.EnumerateFiles(skill, \"*.txt\", SearchOption.AllDirectories)\n                         .Select(_ => new FileInfo(_)))\n            {\n                logger.LogDebug($\"{prompt} === \");\n                logger.LogDebug($\"{skill} === \");\n                logger.LogDebug($\"{prompt.Directory?.Parent} === \");\n                var skillName = FunctionName(new DirectoryInfo(skill), prompt.Directory);\n                logger.LogDebug($\"{skillName} === \");", "                if (skills.Count != 0 && !skills.Contains(skillName.ToLower())) continue;\n                logger.LogDebug($\"Importing semantic skill ${skill}/${skillName}\");\n                kernel.ImportSemanticSkillFromDirectory(skill, skillName);\n            }\n            return kernel;\n        }\n\n        private static string FunctionName(DirectoryInfo skill, DirectoryInfo? folder)\n        {\n            while (!skill.FullName.Equals(folder?.Parent?.FullName)) folder = folder?.Parent;\n            return folder.Name;\n        }\n\n        internal static KernelBuilder WithOpenAI(this KernelBuilder builder, SKConfig config, ApiKey api) =>\n     builder.Configure(_ =>\n     {", "            while (!skill.FullName.Equals(folder?.Parent?.FullName)) folder = folder?.Parent;\n            return folder.Name;\n        }\n\n        internal static KernelBuilder WithOpenAI(this KernelBuilder builder, SKConfig config, ApiKey api) =>\n     builder.Configure(_ =>\n     {\n         if (api.Text != null)\n             _.AddOpenAITextCompletionService(\"text\", config.Models.Text, api.Text);\n         if (api.Embedding != null)\n             _.AddOpenAIEmbeddingGenerationService(\"embedding\", config.Models.Embedding, api.Embedding);", "         if (api.Embedding != null)\n             _.AddOpenAIEmbeddingGenerationService(\"embedding\", config.Models.Embedding, api.Embedding);\n         if (api.Chat != null)\n             _.AddOpenAIChatCompletionService(\"chat\", config.Models.Chat, api.Chat);\n     });\n\n        internal static IKernel Register(this IKernel kernel, ISkillsImporter importer, IList<string> skills)\n        {\n            importer.ImportSkills(kernel, skills);\n            return kernel;\n        }\n", "        public static IKernel RegistryCoreSkills(this IKernel kernel, IList<string> skills)\n        {\n            if (ShouldLoad(skills, nameof(FileIOSkill))) \n                kernel.ImportSkill(new FileIOSkill(), nameof(FileIOSkill));\n            if (ShouldLoad(skills, nameof(HttpSkill)))\n                kernel.ImportSkill(new HttpSkill(), nameof(HttpSkill));\n            if (ShouldLoad(skills, nameof(TextSkill)))\n                kernel.ImportSkill(new TextSkill(), nameof(TextSkill));\n            if (ShouldLoad(skills, nameof(TextMemorySkill)))\n                kernel.ImportSkill(new TextMemorySkill(), nameof(TextMemorySkill));\n            if (ShouldLoad(skills, nameof(ConversationSummarySkill)))\n                kernel.ImportSkill(new ConversationSummarySkill(kernel), nameof(ConversationSummarySkill));", "            if (ShouldLoad(skills, nameof(TextMemorySkill)))\n                kernel.ImportSkill(new TextMemorySkill(), nameof(TextMemorySkill));\n            if (ShouldLoad(skills, nameof(ConversationSummarySkill)))\n                kernel.ImportSkill(new ConversationSummarySkill(kernel), nameof(ConversationSummarySkill));\n            if (ShouldLoad(skills, nameof(TimeSkill)))\n                kernel.ImportSkill(new TimeSkill(), nameof(TimeSkill));\n\n            kernel.ImportSkill(new PlannerSkill(kernel), nameof(PlannerSkill));\n            return kernel;\n        }\n", "        private static bool ShouldLoad(IList<string> skills, string skill) =>\n            skills.Count == 0 || skills.Contains(skill.ToLower());\n\n        public static IHostBuilder ConfigureAdventKernelDefaults(this IHostBuilder builder, IConfiguration configuration) =>\n       builder.ConfigureServices(services =>\n       {\n           services.AddSemanticKernelFactory(configuration);\n           services.AddConsoleLogger(configuration);\n       });\n\n        public static IServiceCollection AddSemanticKernelFactory(this IServiceCollection services, IConfiguration configuration)\n        {\n            var config = new SKConfig();\n            configuration.Bind(config);\n\n            var options = config.Skills.ToSkillOptions();", "        public static IServiceCollection AddSemanticKernelFactory(this IServiceCollection services, IConfiguration configuration)\n        {\n            var config = new SKConfig();\n            configuration.Bind(config);\n\n            var options = config.Skills.ToSkillOptions();\n            foreach (var skillType in options.NativeSkillTypes)\n                services.AddSingleton(skillType);\n\n            services.AddSingleton(options);\n            services.AddSingleton(config);\n            services.AddSingleton<NativeSkillsImporter>();\n            services.AddSingleton<SemanticSkillsImporter>();\n            services.AddSingleton<SemanticKernelFactory>();\n            services.AddSingleton(typeof(IPlanExecutor), typeof(DefaultPlanExecutor));\n\n            services.AddSingleton<IMemoryStore>(\n                config.Memory.Type == \"Volatile\"\n                    ? new VolatileMemoryStore()\n                    : new QdrantMemoryStore(config.Memory.Host, config.Memory.Port, config.Memory.VectorSize));\n            return services;\n        }\n", "        public static IServiceCollection AddConsoleLogger(this IServiceCollection services, IConfiguration configuration)\n        {\n            var factory = LoggerFactory.Create(builder =>\n            {\n                builder.AddConfiguration(configuration.GetSection(\"Logging\"));\n                builder.AddConsole();\n            });\n            services.AddSingleton(factory);\n            services.AddSingleton<ILogger>(factory.CreateLogger<object>());\n            return services;\n        }\n", "        public static IList<FunctionView> ToSkills(this IKernel kernel)\n        {\n            var view = kernel.Skills.GetFunctionsView();\n            return view.NativeFunctions.Values.SelectMany(Enumerable.ToList)\n                .Union(view.SemanticFunctions.Values.SelectMany(Enumerable.ToList)).ToList();\n        }\n\n        public static async Task<SKContext> InvokePipedFunctions(this IKernel kernel, Message message) =>\n            await kernel.RunAsync(message.Variables.ToContext(),\n                (message.Pipeline?.Select(_ => kernel.Skills.GetFunction(_.Skill, _.Name)) ?? Array.Empty<ISKFunction>())\n                .ToArray());\n", "        public static SkillOptions ToSkillOptions(this string[] directories) =>\n       new()\n       {\n           SemanticSkillsFolders = directories,\n           NativeSkillTypes = directories.SelectMany(_ => Directory\n               .EnumerateFiles(_, \"*.dll\", SearchOption.AllDirectories)\n               .SelectMany(file => Assembly.LoadFrom(file).GetTypes().Where(_ =>\n                   _.GetMethods().Any(m => m.GetCustomAttribute<SKFunctionAttribute>() != null)))).ToList()\n       };\n\n\n        /// <summary>\n        /// \u52a0\u5bc6\n        /// </summary>\n        /// <param name=\"data\"></param>\n        /// <param name=\"key\"></param>\n        /// <returns></returns>", "        public static string AesEncryption(this string data, string key)\n        {\n            byte[] keyArr = Encoding.UTF8.GetBytes(key);\n            byte[] dataArr = Encoding.UTF8.GetBytes(data);\n\n            using var aes = Aes.Create();\n            aes.Key = keyArr;\n            aes.Mode = CipherMode.ECB;\n            aes.Padding = PaddingMode.PKCS7;\n\n            using var cryptoTransform = aes.CreateEncryptor();\n            byte[] result = cryptoTransform.TransformFinalBlock(dataArr, 0, dataArr.Length);\n\n            return Convert.ToBase64String(result);\n        }\n\n        /// <summary>\n        /// \u89e3\u5bc6\n        /// </summary>\n        /// <param name=\"data\"></param>\n        /// <param name=\"key\"></param>\n        /// <returns></returns>", "        public static string AesDecryption(this string data, string key)\n        {\n            byte[] keyArr = Encoding.UTF8.GetBytes(key);\n            byte[] dataArr = Convert.FromBase64String(data);\n\n            using var aes = Aes.Create();\n            aes.Key = keyArr;\n            aes.Mode = CipherMode.ECB;\n            aes.Padding = PaddingMode.PKCS7;\n\n            using var cryptoTransform = aes.CreateDecryptor();\n            byte[] result = cryptoTransform.TransformFinalBlock(dataArr, 0, dataArr.Length);\n\n            return Convert.ToBase64String(result);\n        }\n    }\n}\n"]}
{"filename": "src/SKernel/Factory/SemanticKernelFactory.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.Logging;\nusing Microsoft.SemanticKernel;\nusing Microsoft.SemanticKernel.Memory;\nusing SKernel.Factory.Config;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace SKernel.Factory\n{\n    public class SemanticKernelFactory\n    {", "{\n    public class SemanticKernelFactory\n    {\n        private readonly NativeSkillsImporter _native;\n        private readonly SemanticSkillsImporter _semantic;\n        private readonly SKConfig _config;\n        private readonly IMemoryStore _memoryStore;\n        private readonly ILogger _logger;\n\n        public SemanticKernelFactory(NativeSkillsImporter native, SemanticSkillsImporter semantic, SKConfig config,\n            IMemoryStore memoryStore, ILoggerFactory logger)\n        {\n            _native = native;\n            _semantic = semantic;\n            _config = config;\n            _memoryStore = memoryStore;\n            _logger = logger.CreateLogger<SemanticKernelFactory>();\n        }\n", "        public IKernel Create(ApiKey key, IList<string>? skills = null)\n        {\n            var selected = (skills ?? new List<string>())\n                .Select(_ => _.ToLower()).ToList();\n\n            var kernel = new KernelBuilder()\n                .WithOpenAI(_config, key)\n                .WithLogger(_logger)\n                .Build()\n                .RegistryCoreSkills(selected)\n                .Register(_native, selected)\n                .Register(_semantic, selected);\n            kernel.UseMemory(\"embedding\", _memoryStore);\n            return kernel;\n        }\n    }\n}\n"]}
{"filename": "src/SKernel/Factory/DefaultPlanExecutor.cs", "chunked_list": ["\ufeffusing Microsoft.SemanticKernel;\nusing Microsoft.SemanticKernel.Orchestration;\nusing System.Threading.Tasks;\n\nnamespace SKernel.Factory\n{\n    public class DefaultPlanExecutor : IPlanExecutor\n    {\n        public async Task<SKContext> Execute(IKernel kernel, Message message, int iterations)\n        {\n            SKContext plan = await kernel.RunAsync(message.Variables.ToContext(), kernel.CreatePlan());\n            var iteration = 0;\n            var executePlan = kernel.ExecutePlan();\n\n            var result = await kernel.RunAsync(plan.Variables, executePlan);\n", "        public async Task<SKContext> Execute(IKernel kernel, Message message, int iterations)\n        {\n            SKContext plan = await kernel.RunAsync(message.Variables.ToContext(), kernel.CreatePlan());\n            var iteration = 0;\n            var executePlan = kernel.ExecutePlan();\n\n            var result = await kernel.RunAsync(plan.Variables, executePlan);\n\n            while (!result.Variables.ToPlan().IsComplete && result.Variables.ToPlan().IsSuccessful &&\n                   iteration < iterations - 1)\n            {\n                result = await kernel.RunAsync(result.Variables, executePlan);\n                iteration++;\n            }\n\n            return result;\n        }\n    }\n}\n", "            while (!result.Variables.ToPlan().IsComplete && result.Variables.ToPlan().IsSuccessful &&\n                   iteration < iterations - 1)\n            {\n                result = await kernel.RunAsync(result.Variables, executePlan);\n                iteration++;\n            }\n\n            return result;\n        }\n    }\n}\n"]}
{"filename": "src/SKernel/Factory/SemanticSkillsImporter.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.Logging;\nusing Microsoft.SemanticKernel;\nusing SKernel.Factory.Config;\nusing System.Collections.Generic;\n\nnamespace SKernel.Factory\n{\n    public class SemanticSkillsImporter : ISkillsImporter\n    {\n        private readonly string[] _folders;\n        private readonly ILogger<SemanticSkillsImporter> _logger;\n\n        public SemanticSkillsImporter(SkillOptions skillOptions, ILoggerFactory logger)\n        {\n            _folders = skillOptions.SemanticSkillsFolders;\n            _logger = logger.CreateLogger<SemanticSkillsImporter>();\n        }\n", "        private readonly string[] _folders;\n        private readonly ILogger<SemanticSkillsImporter> _logger;\n\n        public SemanticSkillsImporter(SkillOptions skillOptions, ILoggerFactory logger)\n        {\n            _folders = skillOptions.SemanticSkillsFolders;\n            _logger = logger.CreateLogger<SemanticSkillsImporter>();\n        }\n\n        public void ImportSkills(IKernel kernel, IList<string> skills)\n        {", "        public void ImportSkills(IKernel kernel, IList<string> skills)\n        {\n            foreach (var folder in _folders)\n                kernel.RegisterSemanticSkills(folder, skills, _logger);\n        }\n    }\n\n}"]}
{"filename": "src/SKernel/Factory/ISkillsImporter.cs", "chunked_list": ["\ufeffusing Microsoft.SemanticKernel;\nusing System.Collections.Generic;\n\nnamespace SKernel.Factory\n{\n    public interface ISkillsImporter\n    {\n        void ImportSkills(IKernel kernel, IList<string> skills);\n    }\n}\n"]}
{"filename": "src/SKernel/Factory/IPlanExecutor.cs", "chunked_list": ["\ufeffusing Microsoft.SemanticKernel.Orchestration;\nusing Microsoft.SemanticKernel;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace SKernel.Factory\n{\n    public interface IPlanExecutor\n    {\n        Task<SKContext> Execute(IKernel kernel, Message message, int iterations);\n    }\n}\n", "namespace SKernel.Factory\n{\n    public interface IPlanExecutor\n    {\n        Task<SKContext> Execute(IKernel kernel, Message message, int iterations);\n    }\n}\n"]}
{"filename": "src/SKernel/Factory/NativeSkillsImporter.cs", "chunked_list": ["\ufeffusing Microsoft.SemanticKernel;\nusing SKernel.Factory.Config;\nusing System;\nusing System.Collections.Generic;\n\nnamespace SKernel.Factory\n{\n    public class NativeSkillsImporter : ISkillsImporter\n    {\n        private readonly IList<Type> _skills;\n        private readonly IServiceProvider _provider;\n\n        public NativeSkillsImporter(SkillOptions skillOptions, IServiceProvider provider)\n        {\n            _skills = skillOptions.NativeSkillTypes;\n            _provider = provider;\n        }\n", "        private readonly IList<Type> _skills;\n        private readonly IServiceProvider _provider;\n\n        public NativeSkillsImporter(SkillOptions skillOptions, IServiceProvider provider)\n        {\n            _skills = skillOptions.NativeSkillTypes;\n            _provider = provider;\n        }\n\n        public void ImportSkills(IKernel kernel, IList<string> skills)\n        {", "        public void ImportSkills(IKernel kernel, IList<string> skills)\n        {\n            foreach (var skill in _skills)\n            {\n                var instance = _provider.GetService(skill);\n                if (instance != null && (skills.Count == 0 || skills.Contains(skill.Name.ToLower())))\n                    kernel.ImportSkill(instance, skill.Name);\n            }\n        }\n    }\n}\n"]}
{"filename": "src/SKernel/Factory/Config/ApiKey.cs", "chunked_list": ["\ufeffnamespace SKernel.Factory.Config\n{\n    public class ApiKey\n    {\n        public string? Text { get; set; }\n        public string? Chat { get; set; }\n        public string? Embedding { get; set; }\n    }\n}\n"]}
{"filename": "src/SKernel/Factory/Config/SkillOptions.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\n\nnamespace SKernel.Factory.Config\n{\n    public class SkillOptions\n    {\n        public string[] SemanticSkillsFolders { get; init; } = { \"./skills\" };\n\n        public IList<Type> NativeSkillTypes { get; init; } = new List<Type>();\n    }\n}\n"]}
{"filename": "src/SKernel/Factory/Config/SKConfig.cs", "chunked_list": ["\ufeffnamespace SKernel.Factory.Config\n{\n    public class SKConfig\n    {\n        public string[] Skills { get; set; } = { \"./skills\" };\n\n        public LanguageModel Models { get; set; } = new();\n\n        public SemanticMemory Memory { get; set; } = new();\n\n        public class LanguageModel\n        {", "        public SemanticMemory Memory { get; set; } = new();\n\n        public class LanguageModel\n        {\n            public string Text { get; set; } = \"text-davinci-003\";\n            public string Chat { get; set; } = \"gpt-3.5-turbo\";\n            public string Embedding { get; set; } = \"text-embedding-ada-002\";\n        }\n\n        public class SemanticMemory\n        {", "        public class SemanticMemory\n        {\n            public string Type { get; set; } = \"Volatile\";\n            public string Host { get; set; } = \"localhost\";\n            public int Port { get; set; } = 6333;\n            public int VectorSize { get; set; } = 1536;\n        }\n    }\n}\n"]}
